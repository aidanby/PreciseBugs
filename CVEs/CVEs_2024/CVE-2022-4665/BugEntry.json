{"buggy_code": ["# CHANGELOG\n\n## Ampache 5.5.6-release\n\nThis release imports the API code cleanup from Ampache Develop which has fixed a lot of data issues.\n\nThere will probably not be another big change to Ampache 5 as work has moved to Ampache6 but there will be more bugfix releases if needed.\n\n### Changed\n\n* Scrutinizer moved to php8.1\n\n### Fixed\n\n* Spotify art collector (**AGAIN**)\n* get_now_playing `has_access` check\n* Malformed HTML for regular users in preferences sidebar\n* Missing translation on preferences sidebar\n* Default catalog_filter group could be missing on a new install\n* Gather genre tags when not an array\n\n## API 5.5.6\n\nFix various runtime errors and incorrect parameters for responses.\n\n### Changed\n\n* API browses all point to the Api class\n* Use `FILTER_VALIDATE_IP` on ping calls\n\n### Fixed\n\n* Api5\n  * `songs` set_filter call without browse parameter may have lost info\n  * `get_indexes` set album_artist filter correctly\n  * `artists` set album_artist filter correctly\n  * `share_create` undefined filter check\n* Api4\n  * `songs` set_filter call without browse parameter may have lost info\n  * `get_indexes` set album_artist filter correctly\n  * `timeline` incorrect JSON attribute `data` instead of `date`\n  * `catalogs` JSON had incorrect data for `last_add` and missing `enabled`\n  * `albums` return an empty response with a bad artist id\n  * `download` url parameter order matching \"client, action, cache\"\n  * `catalogs` undefined filter check\n  * `podcast` undefined filter check\n  * `podcast_edit` undefined filter check\n  * `podcasts` undefined filter check\n  * `share_create` undefined filter check\n  * `share_edit` undefined filter check\n* Api3\n  * `album_songs` return an empty response with a bad album id\n  * `artist_albums` return an empty response with a bad artist id\n  * Calls to `songs` with user ID instead of user object\n\n## Ampache 5.5.5-release\n\nThis release fixes up all the issues I created with the bad release files as well as an art search issue I missed until after the release.\n\n### Fixed\n\n* Set etag for image cache\n* Spotify art collector\n* Double scrub string in catalog search rules\n\n## API 5.5.5\n\n**NO CHANGE**\n\n## Ampache 5.5.4-release\n\n### Added\n\n* Database 550005\n  * Add `song_artist` and `album_artist` maps to catalog_map\n\n### Changed\n\n* Update catalog map tables based on the catalog action\n* Force `b` and `n` for back, next in webplayer (was overwritten with `[` and `]`)\n\n### Fixed\n\n* Missing tables on a fresh install\n* Not filtering song_artist on album_artist browses\n* Don't use catalog_filter and rating_filter without a valid user\n* Uploaded/Manual Album Artist maps on tag update\n* Delete artist's from the catalog_map that don't have a song or album for that catalog\n* Set correct transcode `bitrate` and `mime` for songs on play_url calls\n* Save Track Order when viewing all the items\n* Use cache_target for cached song cleanup (was hardcoded to mp3)\n* RSS Feed generation with bad characters\n* Don't spam the artist description for each song\n* Show better Trending Dashboard section\n* Subsonic\n  * Art for artist index arrays was missing\n* Search\n  * SQL for Artist `catalog` searches\n  * Make sure saved rules match the correct names on load\n* CLI\n  * Don't try to update a database when the connection fails\n\n## API 5.5.4\n\n### Fixed\n\n* User count in Api::ping and Api::handshake was doubled\n* Api3::stats method had incorrect recent parameters\n* Ensure the output `bitrate` and `mime` are set for song objects\n\n## Ampache 5.5.3-release\n\n### Changed\n\n* Update copyright year in footer.inc.php\n* Localplay status and instance_fields function cleanup\n* Update some docker files to match current images\n* Allow adding streams to playlists (including rightbar)\n* Shuffle the top 100 albums for Popular Dashboard section\n* webplayer\n  * Another code rework, remove the old 'original' list\n  * Shuffle is an action instead of a state of the playlist\n\n### Fixed\n\n* Hidden Genres shouldn't have a catalog\n* Streaming with certain parameters could not identify a session/user\n* Should be counting podcast objects in stats\n* Null artist->id on wanted pages\n* Search\n  * Album 'other_user' favorite searches\n* Subsonic\n  * Error if you didn't have data when using get_user_data\n  * Response data might fall back to mp3 and not match the output format\n  * Incorrect `playqueue_date` call for user playqueue\n* webplayer\n  * Reordering the list could lose track of items\n  * Remove single item from list could create a weird list\n  * Remove the final track when it's finished playing (if you've set that option)\n\n## API 5.5.3\n\n**NO CHANGE**\n\n## Ampache 5.5.2-release\n\n### Added\n\n* Check for upload_catalog before showing upload pages\n* Search\n  * Class rework and many additional aliases, check the docs for [advanced_search](https://ampache.org/api/api-advanced-search)\n  * Add `song_artist` as a search type (uses artist rules)\n  * Add `album_artist` as a search type (uses artist rules)\n  * Add `song_genre`, `mbid_artist`, `mbid_song` to album search\n  * Add `song_genre`, `mbid_album`, `mbid_song` to artist search\n  * Add `possible_duplicate_album` to song search\n* webplayer\n  * Code cleanup and attempt to make it a bit less confusing\n\n### Changed\n\n* Do not overwrite a custom Artist/Album when updating from tags\n* Ignore case when comparing Genre\n* Show an error on share create failures\n* Pull some function back into the search class\n* When searching without rules treat it like a browse and return results unfiltered\n\n### Fixed\n\n* Tmp_Playlist::get_items may not order by the playlist id\n* Fix album time update when time is NULL\n* Transcoding format could be ignored (`encode_player_webplayer_target`)\n* Set the file extension based on expected transcode / download format\n* Don't look at the transcode cache when downloading a raw file\n* If you are transcoding redirect to the transcoded file\n* Download stats for song, video, podcast_episode\n* Set the file extension for urls on generation\n* Don't overwrite artist art when searching for album art\n* Retrieve song art from tags the same way they are found ('invalid' art)\n* Searching from the search bar did not pickup up the rules for the search page\n* Upload artist, album and license selection\n* Don't show hidden Genres on object rows\n* Video needs get_f_link function\n* Playlists need to be in catalog_map table\n* Insert Podcasts more often in catalog_map\n* Subsonic basic auth may get filtered\n* Don't filter auth in the PlayAction if sent\n* Search\n  * Correctly identify alias rule types\n  * Bad SQL on 0 rating query for album/artist search\n* webplayer\n  * Desired transcode format not being respected\n  * Video types missing from supported types\n  * Playlist sorting issues\n\n## API 5.5.2\n\n### Added\n\n* advanced_search\n  * Add `song_artist` as a search type (uses artist rules)\n  * Add `album_artist` as a search type (uses artist rules)\n  * Add `song_genre`, `mbid_artist`, `mbid_song` to album search\n  * Add `song_genre`, `mbid_album`, `mbid_song` to artist search\n  * Add `possible_duplicate_album` to song search\n\n### Fixed\n\n* advanced_search\n  * unable to retrieve song_artist or album_artist results\n\n## Ampache 5.5.1\n\nI made a mistake in the release string so we need a new point release already!\n\n### Added\n\n* Translation Updates August 2022\n* Grouping for label search items\n\n### Fixed\n\n* Release version string is incorrect and will tell you you have updates if you use the release files\n* Missing comma between label links on song pages\n\n## API 5.5.1\n\n**NO CHANGE**\n\n## Ampache 5.5.0\n\nPrivate catalogs have been given a lot of love. This feature allows you to assign a catalog to multiple users instead of just one.\n\nCheck out the [wiki](https://github.com/ampache/ampache/wiki/catalog-filters) for more information about this feature.\n\n**NOTE** Any user that has a private catalog will have their own filter group created which includes all public catalogs\n\nPHP8.1 has now been fixed up completely and is now fully supported.\n\n### Added\n\n* Update Copyright notice to 2022\n* Added a new option 'Random Play' (shuffle) to playlists and smartlists\n* Add 'Recently Skipped' to user pages\n* Add Podcast Episodes to the browse pages and sidebar\n* Translate podcast episode state and some other missing ones\n* Allow using a smartplaylist in Democratic play\n* Allow podcast_episode table sort by `time` and `state`\n* Allow podcast table sort by `website` and `episodes`\n* Database 550004\n  * Add system preference `demo_use_search`, Use smartlists for base playlist in Democratic play\n  * Add tables `catalog_filter_group` and `catalog_filter_group_map` for catalog filtering by groups\n  * Add column `catalog_filter_group` to `user` table to assign a filter group\n  * Migrate catalog `filter_user` settings to the `catalog_filter_group` table\n  * Assign all public catalogs to the DEFAULT group\n  * Drop table `user_catalog`\n  * Remove `filter_user` from the `catalog` table\n* Search\n  * Added more missing groups to search type lists\n  * Added missing `song` (was `song_title`) to album searches\n  * Add `podcast` as a search type\n    * Add rule `title`\n    * Add rule `podcast_episode` (Search by podcast episode name)\n    * Add rule `time` (Episode length in minutes)\n    * Add rule `state` (Completed, Pending Skipped)\n    * Add rule `file`\n    * Add rule `added`\n    * Add rule `pubdate` (Episode Publication Date)\n  * Add `podcast_episode` as a search type\n    * Add rule `title`\n    * Add rule `podcast` (Search by podcast name)\n    * Add rule `time` (Length in minutes)\n    * Add rule `state` (Completed, Pending Skipped)\n    * Add rule `file`\n    * Add rule `added`\n    * Add rule `pubdate` (Publication Date)\n  * Add `genre` as a search type\n    * Add rule `title`\n* CLI\n  * Add verify for podcast catalogs (fix time and size from tags)\n\n### Changed\n\n* Private catalogs have been migrated into [Catalog filters](https://github.com/ampache/ampache/wiki/catalog-filters)\n* Interface cookies for the sidebar state have new names matching their page and group\n* Made getID function required for library_item's\n* Update codeql-analysis.yml to v2\n* When streaming a Democratic or Random item, redirect to the result\n* Hide 'is_true' boxes on search rows (you can't change it so why show it?)\n* Hide action buttons from random and demo webplayer lists\n\n### Fixed\n\n* The cookies for the interface sidebar had multiple issues holding and restoring status\n* Removed **A LOT** of FILTER_SANITIZE_STRING from code for PHP8.1\n* Errors on empty values when loading the UI rows\n* Lots of docstring and code issues\n* Fixed up deleting plays (and now skips) on the user pages\n* Sorting playlist, user and smartlist names in search rows\n* SQL in get_tags when catalog_filter is disabled\n* A lot of browse filters were missing for certain object types\n* Don't try to load the playlist dialog from the webplayer when you can't add things\n* When using random/Democratic play send the additional parameters to the actual media\n* Respect play urls with transcode_to instead of format\n* Updated example `docs/examples/inotifywait.sh`\n* Podcast_episode browse may sent a camel case argument\n* Null max_upload_size could still be counted as a limit\n* Search\n  * SQL might have connected AND and OR incorrectly\n  * Metadata search might have badly parsed input\n  * Added aliases for some of the confusing search types\n* Subsonic\n  * Checking parameters might return the error AND the empty response\n\n## API 5.5.0\n\nThis will likely be the last 5.x API release. API6 will be a continuation of API5 and not be a significant change like the 4->5 transition.\n\n### Added\n\n* Api::stream add new types `playlist` and `search` (Streams a random object from these lists)\n* Api::download add new types `playlist` and `search`\n* advanced_search\n  * Add `podcast` as a search type\n    * Add rule `title`\n    * Add rule `podcast_episode` (Search by podcast episode name)\n    * Add rule `time` (Episode length in minutes)\n    * Add rule `state` (Completed, Pending Skipped)\n    * Add rule `file`\n    * Add rule `added`\n    * Add rule `pubdate` (Episode Publication Date)\n  * Add `podcast_episode` as a search type\n    * Add rule `title`\n    * Add rule `podcast` (Search by podcast name)\n    * Add rule `time` (Length in minutes)\n    * Add rule `state` (Completed, Pending Skipped)\n    * Add rule `file`\n    * Add rule `added`\n    * Add rule `pubdate` (Publication Date)\n  * Add `genre` as a search type\n    * Add rule `title`\n\n### Fixed\n\n* API4::get_indexes podcast_episode was encoding into the API5 object\n* API4::share_create was unable to share when using lowercase types\n* advanced_search\n  * Added missing `song` (was `song_title`) to album searches\n\n## Ampache 5.4.1-release\n\n### Added\n\n* Put next (n) and back (b) shortcuts in the web_player\n* Allow _ and % wildcards for hiding playlists (api_hidden_playlists)\n* Missing translations on CLI strings\n* Config version 62\n  * Added webplayer_debug (was previously undocumented/hidden)\n* Search\n  * Add `track` to song search\n  * Add `summary` to artist search\n* CLI\n  * New argument for cleanup:sortSongs `-w|--windows` Replace windows-incompatible strings with _\n  * Add a table check function to admin:updateDatabase. This will repair missing tables/details\n\n### Changed\n\n* Only enforce `subsonic_always_download` for song objects\n* Always insert podcast source urls. But mark them as skipped if out of date\n* When adding a podcast feed, sync everything\n* Don't trim search input (e.g. allow single spaces for search)\n\n### Fixed\n\n* web_player being unable to play different formats in some cases\n* Playlist download button missing ID\n* Truncate long podcast episode author lengths\n* Incorrect link on the albums page\n* Section on the information sidebar looking for the wrong cookie\n* Bad verify mod time check\n* SongSorter would get caught with % in your strings\n* Rating Match plugin may overwrite album rating\n* Artist getRandom using the wrong sql column name\n* Pocast episode time regex\n\n## API 5.4.1\n\n### Added\n\n* Include `lyrics` in Song objects\n* advanced_search\n  * Add `file` to album and artist search\n  * Add `track` to song search\n  * Add `summary` to artist search\n\n## Ampache 5.4.0-release\n\n### Added\n\n* Translation Updates May 2022\n* Search\n  * Add `file` to album and artist search\n* CLI\n  * New argument for run:updateCatalog `-f|--find` Find missing files and print a list of filenames\n  * New argument for cleanup:sortSongs `-f|--files` Rename files and keep them in the current folder\n  * New argument for cleanup:sortSongs `-l|--limit` Limit how many moves to allow before stopping\n  * New argument for cleanup:sortSongs `[catalogName]` Name of Catalog (optional)\n* Database 540002\n  * Index `title` with `enabled` on `song` table to speed up searching\n  * Index `album` table columns; `catalog`, `album_artist`, `original_year`, `release_type`, `release_status`, `mbid`, `mbid_group`\n  * Index `object_type` with `date` in `object_count` table\n\n### Changed\n\n* Moved to php-cs-fixer 3\n* Update from tags now shows an 'Error' status if there was an issues reading the file\n\n### Fixed\n\n* SQL for random artist with mapping\n* SQL for servers < 5.0.0 might try to insert into a missing table\n* Respect grouping for song_count searches\n* Autoplay in xbmc localplay and conform to localplay api\n* Ungrouped albums were forced into groups\n* Artists array should overwrite artist_mbid arrays that are smaller\n* Some empty globals relating to user\n* More work on the forked Jplayer playlist code when using `play last`\n* DAAP play urls\n* Single disk download links on group pages\n* CLI\n  * cleanup:sortSongs was broken (It actually works again)\n  * cleanup:sortSongs removes incomplete copied files after failure\n\n## API 5.4.0\n\n### Added\n\n* advanced_search\n  * Add `file` to album and artist search\n\n## Ampache 5.3.3-release\n\n### Added\n\n* Remove duplicates and order largest to smallest for art search\n* Allow update_from_tags for a single Song from it's page\n* Search\n  * Add `song_title` to album search\n  * Add `album_title` and `song_title` to artist search\n  * Add `orphaned_album` to song search\n\n### Changed\n\n* Default art_search_limit raised to 15\n* web_player shuffle improvements\n  * Current selected track will become the first track and everything else shuffled below it\n  * Playlist isn't automatically played so if a song was playing, it will continue to play\n\n### Fixed\n\n* Speed up stream_playlist generation by chunking into blocks\n* Make sure there is an object_id to fill in update_530006\n* Remove song mapping on delete\n* Make sure podcast descriptions don't overfill the column\n* Clean dead total wasn't returned on completion\n* Searching for albums with '# Played' with grouping enabled with album_map\n* Adding a new xbmc localplay\n* Catalog type filter in get_top_sql\n* Subsonic\n  * Fixed the query searches (Again) based on the wildcards different clients may send\n  * Song discNumber was sending the MAX disk instead of the actual disk\n  * getPlayQueue doesn't change back to miliseconds from seconds\n\n## API 5.3.3\n\n### Added\n\n* advanced_search\n  * Add `song_title` to album search\n  * Add `album_title` and `song_title` to artist search\n  * Add `orphaned_album` to song search\n\n### Fixed\n\n* Api4::record_play had the `user` as mandatory again\n* After catalog actions; verify songs with an orphaned album which you won't be able to find in the ui\n\n## Ampache 5.3.2-release\n\nSome QoL fixes here with some initial SubSonic, Search and that database column again!\n\n### Added\n\n* Look for orphaned maps to delete.\n* Get server timezone for get_datetime (date_default_timezone_get())\n* Allow deleting played activity from the ui and count using a function (Require: 100)\n\n### Changed\n\n* Updated the translation gathering process a little\n* Organized the play/skip counting into it's own function\n* Update artist from tags needs to update albums first\n* Subsonic\n  * Only search for song title instead of everything\n  * Add starred to directory elements\n\n### Fixed\n\n* Format on an empty album would complain in the log\n* Update from tags might not remove the old song artist\n* Migrating to a new album would leave old album maps\n* Artist search query with mapping was very slow\n* Database column check not included in 5.3.1 correctly\n* Subsonic\n  * Get recently played\n  * Fixed up search queries using \"\" (wrapping in quotes means exact search)\n\n## API 5.3.2\n\n**NO CHANGE**\n\n## Ampache 5.3.1-release\n\nThere were a few reports of some databases missing an important column. This release makes sure it's there.\n\n### Added\n\n* Docker compose files to help create a local dev environment (read docker/README.md for more info)\n* Added php8.1 to composer (**still considered unstable**)\n\n### Changed\n\n* Began rework of Subsonic modules\n\n### Fixed\n\n* Database missing rsstoken column in the user table\n* gather-messages.sh was finding lots more strings than it needed\n* Query sql with ambiguous ID\n* New song import might not map all the artists\n* Catalog query missing a comma\n\n## API 5.3.1\n\n**NO CHANGE**\n\n## Ampache 5.3.0-release\n\nThis cycle we have added support for multiple Album and Song artists.\n\nThis allows multiple artists to be part of a single song/album object and is created from file tags.\n\nCheck out the [wiki](https://github.com/ampache/ampache/wiki/multi-artist) for more information about this feature.\n\nThe old and long ignored module [jPlayer](https://github.com/jplayer/jPlayer) has been forked into the base Ampache code.\n\nThere have been a few fixes and changes to the module to make the webplayer a lot better to use.\n\n### Added\n\n* Additional xhtml templates added\n* Parse lots more WMA (ASF) file tags\n* Add play next and play last to radio station rows\n* Additional option for artist pages 'Show Artist Songs'\n* Add some missing tag options for mpc files\n* Allow manually syncing Artist name, year formed and place formed from musicbrainz (if it has an mbid)\n* Notify and allow updating Plugins when updates are available\n* You can now unhide a tag from the 'Hidden' page for Genres\n  * This will delete previous merges but it will not retag your songs (update from tags to fix that)\n* Config version 61\n  * Add disable_xframe_sameorigin (allow disabling \"X-Frame-Options: SAMEORIGIN\")\n  * Disable catalog_verify_by_time by default\n* Database 530016\n  * Create `artist_map` table and fill it with data\n  * Create `album_map` table and fill it with data\n  * Use `song_count` & `artist_count` using `album_map`\n  * Drop id column from `catalog_map` table and alter object_type charset and collation\n  * Alter `album_map` table charset and engine to MyISAM if engine set\n  * Alter `artist_map` table charset and engine to MyISAM if engine set\n  * Make sure `object_count` table has all the correct primary artist/album rows\n  * Convert basic text columns into utf8 to reduce index sizes\n  * Remove `user_activity` columns that are useless\n  * Delete duplicate rows on `object_count`\n  * Compact mbid columns back to 36 characters\n  * Compact some `user` columns\n  * enum `object_count`.`count_type`\n  * Index data on object_count\n  * Use a unique index on `object_count`\n  * Compact `cache_object_count`, `cache_object_count_run` columns\n  * Add `show_album_artist` and `show_artist` preferences to show/hide Sidebar Browse menu links\n* Search\n  * Add `songrating` to album search (My Rating (Song))\n  * Add `songrating` (My Rating (Song)) and `albumrating` (My Rating (Album)) to artist search\n  * Allow empty/null searches for all mbid searches\n  * Allow empty/null searches for label searches\n  * Add `song_count` to album and artist search\n  * Add `album_count` to artist search\n  * Add `myplayedartist` (Played by Me (Artist)) to album search\n  * Add `song_artist` to album search\n  * Add alias `album_artist` to album search for `artist` searches\n  * Add `recent_added` to album search\n\n### Changed\n\n* Clean up artists with a duplicate MBID (Use the lowest artist id)\n* Delete cached recommendations instead of trying to update (Really slow)\n* Artist::check uses MBID on lookups as well as name\n* update_from_tags: Only update counts, tags and garbage collect after changes found\n* Use albums instead of songs for catalog verify actions\n* Expand search sidebar menu and collapse information without cookies\n* Moved all the extended functions into the forked jplayer module\n* Instead of skipping duplicate songs on import, disable them\n* jPlayer (Webplayer):\n  * Shuffle now follows the currently playing track (If playing)\n  * Shuffle also does not track the old playlist so you can't undo a shuffle\n* Subsonic\n  * Check for art instead of always sending an art attribute\n\n### Removed\n\n* Search\n  * removed mbid group sql from `possible_duplicate` and `possible_duplicate_album`\n\n### Fixed\n\n* VaInfo time for size/playtime_seconds\n* Tag arrays for Mbid and Artists lookup\n* Deleted item tables would not record some deletions\n* Updating the artist name would always migrate data when not required\n* Artist::check would always create an artist object with readonly set\n* Genres would not update the parent (Song->Album->Artist) whan using update from tags\n* Random sql that uses search rules\n* Use configured Ampache temp directory in Seafile catalog\n* Prepare media before update from tags (Seafile needs to download the file first)\n* Seafile catalog checks for a local file before downloading it again\n* Delete custom_metadata when removed from the object\n* Artist Garbage Collection was way too slow\n* Album and Artist count value sql\n* Don't remove Genre tags when they have been merged (hidden) into a different tag\n* Don't delete merged (hidden) Genres from the tag table\n* Album song_artist_count not calculated correctly\n* Grouping with mbid_group was missing making some albums not possible to view\n* Display and hide of artist columns in some pages based on count\n* Clean and verify would count totals based on all items instead of item type\n* Missing strings from xhtml templates\n* Album grouping for getAlbumSuite with null values\n* Set ratings for all album disks (if grouping enabled) for ratings and flags\n* Issues when you don't have an album artist tag\n* Correctly set null values on library_item edits\n* Search for song art might have sent a Song object\n* Fix missing preference on musicbrainz plugin\n* Disable/enable catalog\n* jPlayer (Webplayer):\n  * Fixed moving items in the playlist\n  * Fixed adding after the current playing track\n  * Fixed logic behind the index and order between the HTML and the JS lists\n* Search\n  * played search for album and artist was including your user in the results\n  * other_user artist search sql\n* Subsonic\n  * Artist was missing starred status\n\n## API 5.3.0\n\n### Added\n\n* advanced_search:\n  * Add `songrating` to album search (My Rating (Song))\n  * Add `songrating` (My Rating (Song)) and `albumrating` (My Rating (Album)) to artist search\n  * Allow empty/null searches for all mbid searches\n  * Allow empty/null searches for label searches\n  * Add `song_count` to album and artist search\n  * Add `album_count` to artist search\n  * Add `myplayedartist` (Played by Me (Artist)) to album search\n  * Add `song_artist` to album search\n  * Add alias `album_artist` to album search for `artist` searches\n  * Add `recent_added` to album search\n\n## Ampache 5.2.1-release\n\n### Added\n\n* Translation Updates Jan 2022\n* Count tables on create and delete actions\n* Set allow-plugins in composer.json\n* Improve description of rss feed to make each play more unique\n* Wait 30 minutes between catalog updates before running update_counts\n* On database connection failure, go to test.php\n* Search\n  * Added no_tag as a possible search item (song, album, artist)\n  * Document the alias names of search rules (docs/API-advanced-search.md)\n  * Add playlist and playlist_name search to artist types\n\n### Changed\n\n* AmpachePersonalFavorites: double the playlist title height\n* Move get_f_link from playlist/search into playlist_object\n* Make some functions that do the same thing use the same variable names\n* Don't optimize tables when doing full_service catalog updates\n* Use parameters in search queries instead of printing them into the query\n* Logout action requires a session id now to log out\n* Update mapping more often after catalog actions\n* Album check function added mbid_group to lookup\n* Support database upgrades from version 350008 (Ampache 3.5.4)\n* Remove additional 'Details' string from song/video and radio pages\n* Tag value is being extra filtered in the edit screen\n* Hide the login link when using simple_user_mode and no auth is set **note** this does not stop you logging in with /login.php\n* When not using auth, keep recording stats for system user plays\n* Hide username column from Recently Played when not authed as a user\n\n### Fixed\n\n* Lowercase package names in composer\n* CLI add user\n* Demo Systemd timer files WantedBy\n* Some missing garbage collection for some tables\n* Phantom html table row in show_catalogs page\n* Grouping albums with special characters\n* Searching albums with special characters\n* Lots more PHP8 runtime errors\n* SQL for artists in catalog_map\n* Typo in url for update_all_file_tags\n* SQL error in database update 500013 (Not fatal)\n* Don't garbage_collect tags after merging\n* Create art URLs correctly when using rewrite rules and no auth\n* Respect sidebar_light preference when no cookie is present\n* Don't try to create users that already exist\n* Add/Edit catalogs in the UI missing filter_user\n* Search\n  * possible_duplicate was grouping too much together\n* Subsonic\n  * Jukeboxcontrol didn't send an index to the client\n\n## API 5.2.1\n\n### Added\n\n* API5\n  * The docs for errors have been extended for the type when returned\n\n### Changed\n\n* API5\n  * Return the xml total_count of playlists based on hide_search preference\n\n### Fixed\n\n* API5\n  * Some errors were returning the value and not the parameter on error\n* API4\n  * update_from_tags: type case error\n  * rate: Object type to class mapping\n  * flag: Object type to class mapping\n  * update_art: Object type to class mapping and type case check\n  * update_from_tags: Object type to class mapping\n  * genre and tag function compatibility\n* API3\n  * stats: incorrect getRandom call\n  * rate: Object type to class mapping\n  * playlist: bad escaping on the playlist id\n\n## Ampache 5.2.0-release\n\nAmpache 5.2.0 (and all future versions) now support multiple API versions. This means that you can send your handshake with a specific version (e.g. 390001, 440001 or 5.2.0) you will be sent API3, API4 and API5 responses in return.\n\nTo change from API3 to API5 you can send a ping with a new version parameter to update your session (or send goodbye to log off and start again.)\n\nAPI3 is not recommended for use outside of running old applications and it is recommended that you turn off API versions you don't use.\n\n### Added\n\n* Get image from more tag types\n* Translation Updates Nov 2021\n* Added the ability to play random songs from a playlist with a play url\n* Update AmpacheRatingMatch.php to allow writing ratings to file tags\n  * Enable 'Save ratings to file tags when changed' on the plugin page\n  * write_tags must be enabled in the config file\n* Config version 59\n  * Removed overwrite_tags (It doesn't do anything)\n  * playlist_art now true by default\n* Database 520005\n  * Make sure preference names are always unique\n  * Add ui options ('api_enable_3', 'api_enable_4', 'api_enable_5') to enable/disable specific API versions\n  * Add ui option ('api_force_version') to force a specific API response (even if that version is disabled)\n  * Add ui option ('show_playlist_username') Show playlist owner username in titles\n  * Add ui option ('api_hidden_playlists') Hide playlists in Subsonic and API clients that start with this string\n  * Add ui option ('api_hide_dupe_searches') Hide searchs in Subsonic and API clients with the same name as playlists (and both owned by you)\n\n### Changed\n\n* Don't try to return objects that aren't there sometimes\n* Update catalog counts before returning API data\n* Fix preferences for system and users after each update\n* Light theme hover color for sidebar\n* Changed some cookie's from Strict to Lax to fix some bugs\n* Check ldap group by username instead of DN\n* Allow gathering random art from playlist contents instead of generating on page load\n\n### Removed\n\n* Remove AssestCache class and functions (unreliable)\n* When recording stats don't ignore based on a hardcoded gap\n\n### Fixed\n\n* test_image function would fail without php-gd (which is optional)\n* Searching for images in files could not return the files you found\n* Get rid of that annoying space on api key text in the WebUI\n* Catalog map for artist tables\n* ratingmatch_stars value 5 wasn't setting itself\n* filter_has_var is returning false in FCGI enabled PHP\n* Allow catalog manager to manage a catalog in the WebUI\n* When using custom metadata don't overwrite managed values\n* Missing (and duplicate) preferences for users and system\n* Size 0 when reading file tags\n* Disk and totaldisks for wma files\n* Genre for quicktime/m4a files\n* Last.fm login impossible with strict cookies\n* Some double scrubs of text in image links\n* Updating playlist user would only update the name and not the ID\n* garbage collection for playlist images\n* Stats when skipping songs with 0 plays\n* More PHP8 runtime errors\n* Fixed single song random playback using a play url\n* Make sure we error if php_intl module isn't found\n\n## API 5.2.0\n\nCheck out the docs for multi API support at [ampache.org](https://ampache.org/api/)\n\n**note** JSON didn't exist for API3 so all json requests from API3 calls will revert to API5\n\n### Added\n\n* Support for API3, API4 and API5 responses including PHP8 support (keeps original tag calls)\n* API5\n  * playlists: add parameter `show_dupes` if true ignore 'api_hide_dupe_searches' setting\n  * get_art: add parameter `fallback` if true return default art ('blankalbum.png') instead of an error\n* API4\n  * playlists: add parameter `show_dupes` if true ignore 'api_hide_dupe_searches' setting\n* API3\n  * Added genre calls as an alias to tag functions to match API4 and API5\n\n### Fixed\n\n* Session and user id identification and errors from that\n* API5\n  * playlists: sql for searches wasn't filtering\n  * Art URL for searches was malformed\n* API4\n  * Art URL for searches was malformed\n* API3\n  * democratic: This method was broken in API3 and never worked correctly\n\n## Ampache 5.1.1-release\n\n### Added\n\n* Clean cache files that aren't in the database\n* Translate random and democratic in the webplayer\n* Add transcode_flv to config\n* Add playlist, playlist_name to album searches\n* Send the user to an error page when the config wasn't written\n* Config version 58\n  * Removed subsonic_stream_scrobble\n* Database 510005\n  * Add `subsonic_always_download` to preferences\n\n### Changed\n\n* Rebuild aurora.js modules from source\n* Perform waveform and cache on disk the same way\n* Move song waveforms on load if in the wrong folder\n* Make genre searches faster with a join instead of select in\n* Send a flat file path for zips when using browse/playlist\n\n### Removed\n\n* Podcast links on the dashboard removed (There is no link for them to go to)\n* Remove subsonic_stream_scrobble from config and make it per user (subsonic_always_download)\n\n### Fixed\n\n* Use addslashes for translations in html5 player\n* Send the generic client name for localplay again\n* Use the set permission level for localplay access\n* Webplayer playlists would become out of order after moving/adding\n* Cache process could cache the wrong song\n* Missing user id in search\n* Grouping sql in search when not grouping albums\n* Setting Localplay instance would not update the preference\n* Advanced search (Random) wasn't working in php8\n* Fixed returning the correct objects for advanced search (Random)\n* Some objects would add transcode_to to their play url\n* Set system prefs for mb and tadb plugins\n* Updating a channel in php8\n* Get tmp_playlist by session (could get confused and never retrieve items)\n* Setting cookies and session details on remember_me sessions\n* Set the catalog parameters for seafile catalogs\n* Database updates for php8\n* Remember me session cookie error when recreating a new session\n* ampache.sql script had AUTO_INCREMENT data it didn't need\n* Subsonic\n  * Get the artists for a single catalog correctly\n  * Browse highest used the sql differently to the UI\n\n## API 5.1.1\n\n### Fixed\n\n* Access to podcast_episode_delete\n* stats calls with an offest and limit\n* advanced_search calls with an offset and limit\n\n## Ampache 5.1.0-release\n\n### Added\n\n* Split search items in WebUI into optgroup categories\n* Add en_AU as a locale\n* Require confirmation on enable/disable user links\n* Add f_size  to video parameters\n* Record plays for live_streams and playlists in object_count\n* Add podcast to the object_count table and add missing rows\n* Store playlist art in the database\n  * Show the art on the main playlist page\n  * Allow reset and change of playlist art\n  * Pick a random art item on reset and store\n  * Add a simple continue button for these dialogs\n  * Fix up display of image showaction\n  * Subsonic art looks for the playlist art the same as UI\n* Check for `?` in a query before trying to use parameters\n* Add the current php version to the debug page\n* Cache bust some frequently updated assets\n* Clear asset cache during AutoUpdate\n* Gather Artist recommendations on play/Stat insert\n* Add Top Tracks and Similar Songs to Artist pages\n* Extend run:updateCatalog --update to update artist name matching mbid\n* Add duplicate_mbid_group to album searches\n* Restored missing artist search to the header searchbar\n* Press enter on the list header to allow changing page number\n* Translation Update October 2021\n* Config version 57\n* NEW config options\n  * allow_upload_scripts: Allow or disallow upload scripts on the server\n* Database 510004\n  * Add `podcast` to object_count table\n  * Add `podcast` to cache_object_count table\n  * Add `live_stream` to the rating table\n  * Add `waveforms` for podcast episodes\n* PHP8 Support\n  * Use array_key_exists to skip runtime errors\n  * Fix undefined variables in templates\n  * Errors with wanted/missing lookups and templates\n  * Ajax handler updates and fixes\n  * Set default and fallback values more often to avoid errors\n  * Query errors would kill the whole page\n  * Stop trying to read unreadable files\n  * Explode key pairs when there is something to explode\n  * Don't try to update preferences that don't exist\n  * Errors when not logged in trying to load a session\n* NEW files\n  * Test scripts: codecoverage.sh, stan.sh, tests.sh\n\n### Changed\n\n* Always update time when updating songs and videos from tags\n* Merge config 'ratings' and 'userflags' checks into ratings. (drop userflags)\n* Split search items into groups to help make it a bit clearer\n* Rearranged the list of search items\n* Simplify PlayAction code a bit and use filter_input\n* Speed up update_counts for missing object_counts\n* Enable Podcasts on new installs\n* Delete composer.lock\n* bin/cli run:updateCatalog with no options now does clean, Add, Verify and gather for all catalogs\n* Make category headers a bit nicer\n* Check for valid browse types before loading nothing\n* Browsing Genre defaults to artist\n* Skip albums that match the exact title in wanted search\n* Translate all database description strings on updates\n* Hi-res blankalbum/placeholder image (1400x1400)\n* Allow larger artist summary with a scroll. linebreak place, year formed\n* During garbage collection clean up empty strings with NULL\n* Subsonic\n  * Disable stat recording on stream calls (disable subsonic_stream_scrobble in config to enable)\n\n### Removed\n\n* object_cnt: use total_count and total_skip instead of calculated properties\n* f_title: use f_name\n* Scrub CSS with Autorprefixer\n\n### Fixed\n\n* SQL query error for Random Album in certain config setups\n* Album suite needed even without grouping\n* Stop scrubbing the podcast title so hard (so many `&amp;`'s)\n* Use total_count and total_skip columns for searches (Fixes searching with 0)\n* Can't change view limit on Android\n* Localplay instance could be 1\n* Missing add_type variable on ACL pages\n* Light theme follow button color\n* Missing CSS on list headers\n* Templates with missing variables\n* Fix Stream_Playlist::_add_urls to stop mismatched query values\n* Fix stream.php downloads not sending their url parameters to PlayAction\n* Garbage collect object_count for the possible items\n* Do not drop catalog in table podcast_episode when it doesn't exist yet\n* AAC codec from itunes doesn't provide a bitrate_mode (assume vbr)\n* bin/cli ExportPlaylistCommand had out of order args\n* bin/cli Allow database updates when out of date\n* Fix computeCache for playlists\n* Logic of SQL query to get random albums\n* Simplify the join code for some queries\n* Don't force random for smartlists when you turn it off\n* Empty release_date when updating videos\n* Chrome errors where Content-Disposition has a comma (,)\n* Remove subtitle in stream_playlist if empty\n* Fix options and bitrate selection for stream.php requests\n* Scrobbles from Song::can_scrobble\n* Default preference list\n* MusicBrainz Artist Id could have been replaced with the Album Id\n* Artists being duplicated when feat. another artist\n* Don't let a non-critical update fail DB update\n* Search for 'played' albums and artists\n* Commands loading plugins from cli might not have a user\n* Dashboard links to podcast episodes and art\n* Lots of issues in the webplayer which only supported song links\n* Clean up deleted user date from all tables\n* Waveforms for podcast episodes\n* Subsonic\n  * Trim quotes (\") for Subsonic searches (some clients add them)\n  * Support exact (lucene) searching when using quotes (\")\n  * Browse by folder is fixed\n  * Faster browse queries for all types\n  * Fix catalog browsing and loading library\n\n### API 5.1.0\n\n### Added\n\n* NEW API functions\n  * Api::live_stream (get a radio stream by id)\n  * Api::live_streams\n* Api::stream Added type 'podcast_episode' ('podcast' to be removed in Ampache 6)\n* Add 'time' and 'size' to all podcast_episode responses\n\n### Changed\n\n* live_stream objects added 'catalog' and 'site_url'\n* stats: additional type values: 'video', 'playlist', 'podcast', 'podcast_episode'\n\n### Fixed\n\n* get_indexes: JSON didn't think live_streams was valid (it is)\n* record_play: user is optional\n* Bad xml tags in deleted functions\n* scrobble: Add song_mbid, artist_mbid, album_mbid (docs have no '_' so support both)\n\n## Ampache 5.0.0-release\n\nAmpache 5 is here and it's big!\n\n* Check out [Ampache 5 for Admins](https://github.com/ampache/ampache/wiki/Ampache-Next-Changes)\n* As well as [Ampache 5 for Users](https://github.com/ampache/ampache/wiki/Ampache-5-for-users)\n* The bin folder has had a major [rework](https://github.com/ampache/ampache/wiki/cli-faq)\n* You can pre cache files using [Transcode Caching](https://github.com/ampache/ampache/wiki/Transcode-Caching)\n\n**IMPORTANT** instead of using date() we are now using IntlDateFormatter and your locale to identify formats.\nThis means that 'custom_datetime' based on the date() format is incorrect and will look weird.\nLook here for the code to change your 'custom_datetime' string [(<http://userguide.icu-project.org/formatparse/datetime>)]\n\nThis means Ampache now **requires** php-intl module/dll to be enabled.\n\n**IMPORTANT** For new installs default database charset/collation and table engine have changed\n\n* Engine MyISAM => InnoDB\n* Charset utf8 => utf8mb4\n* Collation utf8_unicode_ci => utf8mb4_unicode_ci\n\nIf you want to keep utf8 make sure you set it before running updates.\n\n* To keep the current collation/charset update your config file\n  * Set `database_charset = \"utf8\"`\n  * Set `database_collation = \"utf8_unicode_ci\"`\n\n### Added\n\n* Private catalogs! You can now set a public or per user catalog for your music folders\n* Cache transcoded files before a user requests them with [Transcode Caching](https://github.com/ampache/ampache/wiki/Transcode-Caching)\n* Added a CONTRIBUTING.md file\n* php-intl is now required for translation of date formats into your locale\n* Added %R (Release Status) to catalog pattern matching\n* Add ability to hide the Song Artist column for Albums with one Artist\n* Add ability to browse albums by Original Year\n* Add ability to hide the licence column on song pages\n* A helper index.php has been added to the old project root with directions to help\n* Show the country and Active status (Generated tags are assumed active) on label rows\n* Podcast_Episode show episode art for podcast mashup allow sort by date\n* Save a search or Smartlist as a regular playlist\n* New option to refresh a Playlist from Searches with the same name\n* Option to change the playlist owner when editing OR importing\n* Set \"X-Frame-Options: SAMEORIGIN\" on login page\n* Added the ability to export database art when local_metadata_dir is enabled\n* Save more types of thumb to the local_metadata_dir when enabled\n* Inform with a \"Not Found: podcast\" when you haven't created a podcast catalog\n* Added CatalogUpdate import command to the WebUI (Import = Add + playlist imports)\n* Search changes\n  * Add 'possible_duplicate', 'recently_played' to song, artist and album search\n  * Add 'catalog' to artist and album search\n  * Add 'favorite_album', 'favorite_artist' to song search\n  * Add 'release_status' to album search\n  * Add 1, 5 and 10 to the Maximum Results limit\n* Database 500015\n  * Add `song_count`, `album_count`, `album_group_count` to artist table\n  * Add `release_status`, `addition_time`, `catalog`, `song_count`, `artist_count` to album table\n  * Add `mbid`, `country`, `active` to label table\n  * Add `total_count` and `total_skip` to album, artist, song, video and podcast_episode tables\n  * Add `catalog` to podcast_episode table\n  * Add `filter_user` to catalog table\n  * Add `total_count`, `episodes` to podcast table\n  * Add `username` to playlist table\n  * Create catalog_map table (map catalog location for media objects)\n  * Create user_playlist table (Global play queue)\n  * Create user_data table (One shot info for user actions)\n  * Create deleted_song, deleted_video and deleted_podcast_episode tables for tracking deleted files\n* NEW database options\n  * use_original_year: Browse by Original Year for albums (falls back to Year)\n  * hide_single_artist: Hide the Song Artist column for Albums with one Artist\n  * show_license: Hiding the license column in song rows\n  * hide_genres: Hide the Genre column in all browse table rows\n* Config version 56\n* NEW config options\n  * composer_binary_path: Override the composer binary path to distinguish between multiple composer versions\n  * write_tags: Write tag changes to file (including art if available)\n  * art_zip_add: Include Album Art for zip downlaods\n  * catalog_filter: Allow filtering catalogs to specific users\n  * catalog_verify_by_time: Only verify the files that have been modified since the last verify\n  * cache_path: The folder where the pre-transcoded files will be stored\n  * cache_target: Target audio format for the cache\n  * cache_remote: Remote catalogs will cache every file so this is handled separately\n  * catalog_ignore_pattern: Allow you to ignore audio, video and playlist files with a regex\n* NEW cli commands\n  * `run:moveCatalogPath`: Change a Catalog path\n  * `run:cacheProcess`: Run the [cache process](https://github.com/ampache/ampache/wiki/Transcode-Caching)\n  * `export:databaseArt`: Export all database art to local_metadata_dir\n\n### Changed\n\n* get_datetime(): use IntlDateFormatter to format based on locale. [(<https://www.php.net/manual/en/intldateformatter.format.php>)]\n* Renamed 'Tag' strings to 'Genre'\n* Changed sidebar back to browse for artist/album\n* Moved sidebar mashup pages into their own 'Dashboards' section\n* Move artist counts (song, album) to a DB column\n* Global counts are calculated after catalog changes instead of dynamically\n* Display userflag with star ratings\n* Always put year in Spotify art search if available\n* Imported playslists don't add the extension to the title\n* Visually crop images from the centre instead of resizing into a square\n* Display release year if it doesn't macth original_year. e.g. 'Back in Black (2010)'\n* Don't round the average rating to an integer\n* Replace mt_rand with random_bytes for random token generation\n* Move user bandwidth calculations out of the user format function into the user_data table\n* All localplay links use the type (e.g. mpd/upnp) as the agent to fix muti-client access\n* updateCatalog now implies add when using -i / --import by itself\n* Playlist Import checks for playlists by your user only in the UI (System for the cli)\n* Plugins: Use only https for building gravatar urls\n* Scrobble actions now check for the exact time as well (different agents or scripts would insert)\n* If you call a play url without an action we assume stream\n* Use ISO 8601 date for podcast episode pubdate display\n* Database tables default to InnoDB engine with utf8mb4 charset & collation\n* Subsonic\n  * Wait a few seconds before allowing scrobbles to avoid collisions\n  * Shift the last music play if gap is bigger than 5 repeated plays (over night, etc)\n\n### Removed\n\n* Take out the random items (except random search) from the main sidebar (use the playlist on the rightbar instead)\n* 'Find Duplicates' and related pages have been removed. Use 'Possible Duplicate' searches instead\n* 'Genre' and 'Missing Artists' removed from the top search bar\n* Take out the info icon from the song row; just click the song link\n* Take song artist out of the album edit popup\n* File tag reading for Band/Album Artist\n* Corrected album_artist collection and added missing tags to vorbis, aac and id3v2\n* Removed links from album list headers when split by release type\n* REMOVED config options\n  * write_id3: Use write_tags\n  * write_id3_art: Use write_tags\n\n### Fixed\n\n* Delete duplicates from song table\n* Mashup page for podcast_episodes\n* Searching by Genre needed a query overhaul\n* Album groupings are the same everywhere when album_group is enabled\n* Unknown (Orphaned) groups all unknown files into one artist and album\n* Album groups for ratings and userflags\n* SQL queries regarding rating order and grouping of mutliple users\n* Ensure valid media is found before inserting into a playlist\n* Searching by Genre needed a lot of updates to speed up and correct\n* Bump phpmailer/phpmailer from 6.4.1 to 6.5.0 (#2957)\n* Groupings for albums and add original_year to grouping\n* Editing album titles with prefixes\n* CSS fixes for light theme\n* Shares didn't insert into object_count correctly\n* Repair missing rows in object_count after catalog updates\n* Browse / Mashup by podcast_episode\n* Sorting for a lot of browse pages that used arguments\n* Refreshing the details after editing an object didn't include browse aruments\n* Get the correct total artist_count for albums when grouped\n* Some buttons and links in the light theme needed extra CSS\n* Updated the inotifywait.sh example to stop it trying to add the same file multiple times\n* Translations could break JS with apostrophes\n* Playlist imports with an empty web_path would never work\n* Playlist imports were importing nothing\n* List preferences didn't allow null values after being set (Personal Favorites plugin)\n* When using album_art_store_disk the art lookup was hardcoded for jpg\n* Generating thumbnails wouldn't work with album_art_store_disk enabled\n* Updating config values for spotify_art_filter and art_search_limit would not keep your value\n* Delete podcasts and radio streams when deleting a catalog\n* Collect recommendation garbage correctly\n* Empty release date when updating a video would fail\n* Scrub out some link titles that can be abused by uploads\n* Subsonic\n  * Support a global user playqueue with getplayqueue, saveplayqueue\n  * Incorrect header being set on art requests\n  * averageRating wasn't correctly cast for json\n  * bookmark JSON was not correctly converted\n\n### API 5.0.0\n\nAll API code that used 'Tag' now references 'Genre' instead\n\nThis version of the API is the first semantic version. \"5.0.0\"\n\n### Added\n\n* Add global playcount to podcast_episode and video responses\n* searches (the number of saved smartlists) added to the handshake/ping response\n* NEW API functions\n  * Api::song_delete (Delete files when you are allowed to)\n  * Api::user_preferences (Get your user preferences)\n  * Api::user_preference (Get your preference by name)\n  * Api::system_update (Check Ampache for updates and run the update if there is one.)\n  * Api::system_preferences (Preferences for the system user)\n  * Api::system_preference (Get a system preference by name)\n  * Api::preference_create (Add a new preference to Ampache)\n  * Api::preference_edit (Edit a preference value by name; optionally apply to all users)\n  * Api::preference_delete (Delete a preference by name)\n  * Api::labels (list your record labels)\n  * Api::label (get a label by id)\n  * Api::label_artists (get all artists attached to that label)\n  * Api::get_bookmark (See if you've previously played the file)\n  * Api::bookmarks (List all bookmarks created by your account)\n  * Api::bookmark_create (Create a bookmark to allow revisting later)\n  * Api::bookmark_edit (Edit a bookmark)\n  * Api::bookmark_delete (Delete a bookmark by object id, type, user and client name)\n  * Api::localplay_songs (Get the list of songs in your localplay instance)\n  * API::deleted_songs\n  * API::deleted_podcast_episodes\n  * API::deleted_videos\n\n### Changed\n\n* The API version matches release version '5.0.0'\n* A backcompatible version (500000) is sent when using old api versions\n* handshake and ping counts now return the actual object counts for playlists\n  * 'playlists' => $counts['playlist'],\n  * 'searches' => $counts['search'],\n  * 'playlists_searches' => $counts['playlist'] + $counts['search']\n* Renamed functions:\n  * tags => genres\n  * tag => genre\n  * tag_artists => genre_artists\n  * tag_albums => genre_albums\n  * tag_songs => genre_songs\n* Don't allow duplicate podcast feeds\n* Make filter optional in shares, genre_artists, genre_albums, genre_songs (Used as a general catch all method like genres)\n* Error Codes and response structure has changed\n  * 4700 Access Control not Enabled\n  * 4701 Received Invalid Handshake\n  * 4703 Access Denied\n  * 4704 Not Found\n  * 4705 Missing Method\n  * 4706 Depreciated Method\n  * 4710 Bad Request\n  * 4742 Failed Access Check\n* stats: Removed back compat from older versions. Only 'type' is mandatory\n* Return empty objects when the request was correct but the results were empty\n* Don't transcode podcast_episodes\n* localplay\n  * Added 'track' parameter used by 'skip' commands to go to the playlist track (playlist starts at 1)\n* system_update: update the database if required as well\n* playlist_edit: added 'owner' as an optional parameter (Change playlist owner to the user id)\n* catalog_file: Allow comma-separate task values. (good for API inotify scripts)\n* podcast_episode object \"pubdate\" has been changed to ISO 8601 date (2004-02-12T15:19:21+00:00)\n* podcast object \"build_date\" and \"sync_date\" have also been changed to ISO 8601 date\n\n### Fixed\n\n* catalog_file: Couldn't add files\n\n## Ampache 4.4.3-release\n\n### Added\n\n* Catalog::update_counts to manage catalog changes\n* Gather more art files from your tags\n* Allow RatingMatch plugin to rate Album->Artist (Originally Song->Album->Artist)\n\n### Changed\n\n* Calculate MP3 stream length on transcode to avoid cutting it off early\n\n### Removed\n\n* Don't apply an album artist when it isn't distinct\n* MySQL faq isn't needed during install now that PHP 7.4 is a requirement\n\n### Fixed\n\n* CVE-2021-32644\n* Identifying a distinct album_artist query wasn't great\n* Don't return duplicate art while searching file tags\n* SQL query in random::advanced_sql was ambiguous\n* Filtering random and search page type element\n* NowPlaying stats would be overwritten when they didn't need to be\n* Subsonic\n  * getNowPlaying was unable to return playing media or the correct time\n  * createShare would not set the object_id correctly and ignored expires value\n\n### API 4.4.3\n\n**NO CHANGE**\n\n## Ampache 4.4.2-release\n\n### Added\n\n* Larger artist images when you don't have a text summary available\n* Expanded artist, album and podcast thumbnails to reduce blank space\n* Update album tags first when you update artist tags\n\n### Changed\n\n* Simplify flagging/rating multi-disk albums\n* Subsonic\n  * just send getmusicfolders music folders\n  * When calling createPlaylist, assume that the list needs to be empty first\n\n### Fixed\n\n* Require a valid database hostname instead of assuming localhost\n* A valid transcode_cmd is required to transcode media\n* Subsonic\n  * Clients might send you a file path of Artist art instead of the id\n  * Strings don't need json conversion checks\n  * Send the cover art id for playlists\n  * Check for artist and podcast prefixes on art id's\n  * Bugs when converting between SubSonic id and Ampache id\n  * Assign roles based on preferences (fixes jukebox, podcast and share roles)\n  * CreateUser could overwrite admin access level\n  * UpdateUser didn't write the access level\n  * don't return null Genre counts\n  * fix getting artist indexes for large libraries\n* Don't get null playlist objects from the DB\n* Using 'Save Track Order' would not apply the offset\n* Vorbis/Ogg comments use 'organization' for publisher and 'track_number' for track\n* Automated Label creation when updating from tags\n* Grouped album downloads and rightbar actions\n* Preference::get_by_user was caching into a single value\n* A user who owned a playlist was unable to reorder (but could still save the order)\n* When creating shares, don't allow secret to be longer than database limit (20)\n* Album full name wasn't being used in some places\n* Tag::get_tag_objects was not grouping albums\n* Return integers for tag counts\n* rmccue/requests CVE: CVE-2021-29476\n* PHPMailer/PHPMailer CVE: CVE-2020-36326\n\n### API 4.4.2\n\n### Fixed\n\n* API::indexes Artist albums were being added incorrectly for XML\n* Send back the full album name in responses\n\n## Ampache 4.4.1-release\n\n### Added\n\n* If you have an MBID in your artist, use that for last.fm queries\n\n### Changed\n\n* Updated composer dependencies\n* Default podcast_keep and podcast_new_download preferences are set to 0 (unlimited)\n\n### Removed\n\n* Delete 'concerts_limit_past' and 'concerts_limit_future' database settings.\n\n### Fixed\n\n* Grid View shouldn't change the artist image\n* Catalog Update -u (gather last.fm info) wasn't getting an ID list correctly\n* Album::get_random_songs not returning id's\n* Bookmark::get_bookmarks typo for get_bookmark_ids\n* Sorting album browses by artist name could fail with mysql\n* Subsonic getPlaylists should always send a user\n* Album browsing SQL didn't include Artist name in grouping\n* CVE-2021-21399: Unauthenticated SubSonic backend access in Ampache\n\n### API 4.4.1\n\n### Fixed\n\n* API::stats would not offset recent calls\n\n## Ampache 4.4.0-release\n\nKeep an eye on the incoming changes to develop at [Ampache-Next-Changes](https://github.com/ampache/ampache/wiki/Ampache-Next-Changes)\n\n### Added\n\n* Write metadata to mp3, flac and ogg files. Requires metaflac and vorbiscomment installed on Linux.\n* Write images to mp3 and flac files. Also requires metaflac on linux.\n* File tags can be updated from catalog management page.\n* Configurable settings for \"Gather Art\".\n* Configurable art search limit.\n* User selectable artist and year filter for Spotify album searches\n* User selectable limit for art searches.\n* Generate rsstokens for each user allowing unique feed URLs\n* Allow setting custom database collation and charset without overwriting your changes\n  * rsstoken: Identify users by token when generating RSS feeds\n* Run garbage collection after catalog_update.inc 'clean' or 'verify'\n* Add duration to the table headers when browsing playlists and smartlists\n* Add time and duration to albums, artists instead of calculating from songs each time\n* Allow setting a custom background on the login page\n* Musicbrainz search icon on Artist, Album and Song pages\n* Update missing album artists on catalog add\n* Add R128 Gain adjustments\n* Persist replaygain setting as a cookie\n* Support for image per song\n* Format XML output using DOMDocument\n* SubSonic - shift the current track start time when you pause/resume\n* Config version 49\n* NEW config options\n  * hide_ampache_messages: We sometimes need to talk and will show a warning to admin users. Allow hiding this\n* NEW search options (also available in Api::advanced_search)\n  * last_skip (artist, album, song)\n  * last_play_or_skip (artist, album, song)\n  * played_or_skipped_times (song)\n\n### Changed\n\n* Stop logging auth/passphrase strings\n* Add Y scrolling to the current playlist box (rightbar)\n\n### Fixed\n\n* Escape filepaths when removing from database\n* Regex in config for additional_genre_delimiters\n* Grid View option was backwards\n* Replaygain issues in the webplayer\n* Per disk actions for grouped albums (e.g. play just that disk)\n* Catalog removal needs to run garbage collection\n* Recognize opus when reading tags\n* Regex in config for additional_genre_delimiters\n* SQL query for smartlists not joining the OR correctly\n* Searching with bad rules will return no results instead of everything\n* Check the 'unique_playlist' option in more places\n* When you haven't set an active localplay nothing was picked\n* Set time for artists that are only albums\n* Don't hide rss generation when you haven't got a key\n* Podcast episode durations that use seconds were converting into crazy lengths\n* Playlist and Smartlist check sql simplified\n* SubSonic - Json clients need their playlist entry to always array (single item lists)\n\n### API 4.4.0\n\n### Added\n\n* NEW API functions\n  * Api::users (ID and Username of the site users)\n* Api::localplay added new options to 'command' ('pause', 'add', 'volume_up', 'volume_down', 'volume_mute', 'delete_all', 'skip')\n* Api::localplay added parameters:\n  * 'oid' (integer) object_id to add //optional\n  * 'type' (string) Default: 'Song' ('Song', 'Video', 'Podcast_Episode', 'Channel', 'Broadcast', 'Democratic', 'Live_Stream') //optional\n  * 'clear' (integer) 0|1 clear the current playlist on add //optional\n* Api::playlist_edit added new parameter 'sort': (0,1) sort the playlist by 'Artist, Album, Song' //optional\n* Api::get_indexes\n  * New type options: 'album_artist', 'podcast', 'podcast_episode', 'share', 'video'\n  * Added parameter 'include': (0,1) (add the extra songs details if a playlist or podcast_episodes if a podcast)\n* Api::rate - Added types 'playlist', 'podcast', 'podcast_episode', 'video', 'tvshow', 'tvshow_season'\n* Api::flag - Added types 'podcast', 'podcast_episode', 'video', 'tvshow', 'tvshow_season'\n* Add time to artist and album objects. (total time of all songs in seconds)\n* Add songcount, albumcount to artist objects. (time in seconds)\n* Add songcount to album objects. (time in seconds)\n* Add type (release_type) to album objects\n* Add disk to song objects\n* Add time to video objects. (time in seconds)\n* Add title, mime, catalog to podcast_episodes\n* Api::advanced_search Add 'playlist', 'user' and 'video' to search types\n* Api::handshake added extra total counts to the response\n  * users, tags, podcasts, podcast_episodes, shares, licenses, live_streams, labels\n* Api::ping match the handshake response (excluding the auth token)\n\n### Changed\n\n* get_indexes: 'playlist' now requires include=1 for xml calls if you want the tracks\n* Make filter optional in shares\n* Api::podcast_episodes\n  * \"url\" is now a play url (instead of a link to the episode)\n  * \"public_url\" is now the old episode link\n\n### Fixed\n\n* Api::podcast_edit wasn't able to edit a podcast...\n* Api::democratic was using action from localplay in the return responses\n* get_indexes for XML didn't include podcast indexes\n* Set OUTDATED_DATABASE_OK on image.php, play/index.php and share.php to stop blocking requests\n* Don't limit sub items when using a limit (e.g return all podcast episodes when selecting a podcast)\n\n### Deprecated\n\n* Dropped in API 5.0.0\n  * Api::get_indexes; stop including playlist track and id in xml by default\n  * Album objects: \"tracks\" will only include track details. Use \"songcount\"\n  * Artist objects: \"albums\", \"songs\" will only include track details Use \"albumcount\" and \"songcount\"\n\n## Ampache 4.3.0-release\n\nThis version of Ampache seeks to bring in some of the great changes going on in develop while we work on v5.\nThere also a few API changes to enable a bit better control for older clients.\n\n### Added\n\n* Check limits on democratic playlists (> 0 && < 3000000000)\n* Show an error for out of range democratic cooldowns\n* SubSonic - Force a default format (xml) instead of none\n* Added back the agent string in recently played (for admins)\n* Replace 'Admin' icon with padlock in sidebar when access check fails. (Hide this new icon with 'simple_user_mode')\n* Disable API/Subsonic password resets in 'simple_user_mode'\n* New option -m 'move_catalog' added to catalog_update.inc\n* More default preferences to the refill/check functions\n* More functions to search (album artist, mbid)\n* Config version 46\n* NEW config options\n  * hide_search: If true do not include searches/smartlists in playlist results for Api::get_indexes, Api::playlists\n* NEW plugin:\n  * 'Personal Favorites'. Show a shortcut to a favorite smartlist or playlist on the homepage\n  * 'RatingMatch'. Raise the minimum star rating (and song loves) of artists and albums when you rate/love the song\n\n### Changed\n\n* Scrobble plugins fire after stat recording\n* Split art search by 5 instead of 4\n* Increase autoupdate check time and don't force it on each logon\n* Updated CSS and separated mashup covers from other types\n* Don't use mail_enabled for registration checks\n* WebUI - Browse by album_artist instead of single artists\n* Better sorting for playlists using sort_tracks\n* Don't allow duplicate podcast feeds\n* Updated the gather art process\n* Searches will order by file/name instead of id (unless random)\n* Updated amapche.sql\n* Updated composer requirements\n* Default false config option text changed to true (no more typing, just uncomment!)\n* Compressed PNG and JPG images\n\n### Removed\n\n* Disabled the jPlayer fullscreen shortcut (ctrl + f)\n* Remove system preferences from the user that aren't classified as a system preference\n* Stop setting open_basedir from fs.ajax\n* Concert/Event pages (dead Last.fm API)\n* Don't run reset_db_charset on DB updates\n* Disabled browse_filter for new user accounts\n\n### Fixed\n\n* Speed up the playlist dialog boxes (Add to playlist)\n* Fix SQL query for Stats::get_newest_sql\n* Session cookie creation\n* Multiple auth attempts in the same second would not return a session\n* Mail auth was not checked correctly\n* Gather art correctly for update_file.inc\n* set bitrate correctly if using a maxbitrate in play/index\n* MP3's would not get a waveform without editing the config\n* Recently played respects your privacy settings\n* Graph class sql grouping\n* **MAJOR** UPnP fixes\n* Upload catalog rename logic\n\n### API 4.3.0\n\n### Changed\n\n* Api::record_play\n  * Make 'user' parameter optional\n  * Allow 'user' to the be user_id **or** the username string\n  * Add 'date' parameter (optional)\n  * Require 100 (Admin) permission to record plays for other users\n* Api::get_indexes\n  * Add 'hide_search' parameter (optional)\n* Api::playlists\n  * Add 'hide_search' parameter (optional)\n* Setting a limit of 'none' would slice away all the results\n\n## Ampache 4.2.6-release\n\n### Changed\n\n* Ignore ALL tagged releases (e.g. 4.2.6-preview 4.2.6-beta)\n* Don't check the times in save_mediaplay plugins\n* Plugins should only have 1 category\n* Update Composer requirements\n\n### Removed\n\n* Some system preferences were added as user preferences\n\n### Fixed\n\n* Search original_year query\n* Replaygain was missing from the webplayer\n* Check albumartist in get_album_suite queries\n* Recently played queries check for privacy options\n* Headphones plugin fix for missing mbid's\n* Duplicate downloads recorded in play/index\n* Subsonic video HLS stream and json values\n* Block more password resets when using simple_user_mode\n* Upload catalog rename logic\n\n### API 4.2.6\n\n**NO CHANGE**\n\n## Ampache 4.2.5-release\n\n### Added\n\n* Use _add_urls when building a stream playlist\n\n### Changed\n\n* Removed the forced random from search\n* Put the browse header at the top above plugins\n* Make the webplayer class a bit faster at deciding what to transcode\n\n### Fixed\n\n* Ampache Debug, cron.lib.php missing from init\n* Slow playlist creation when inserting a large amount of items\n* Stream_URL properties were inconsistently applied\n* Fix streaming when play_type is Democratic\n* Save your limit and random settings when creating a smartlist\n\n### API 4.2.5\n\n**NO CHANGE**\n\n## Ampache 4.2.4-release\n\n### Added\n\n* \"Random\" tickbox added to search pages\n\n### Changed\n\n* Searching 'original_year' will now fall back to 'year' if no release year is present\n\n### Fixed\n\n* User was being created but you were told it isn't\n* The search pages remember your limit correctly\n* PHP exception when < 7.1\n* Correct \"Recently Added\", \"Recently Updated\" searches\n* Check that song can be inserted before inserting the remaining rows\n* Logic in stat recording when skips occur\n* Don't query for null tag ids\n\n### API 4.2.4\n\n**NO CHANGE**\n\n## Ampache 4.2.3-release\n\n### Added\n\n* Subsonic Generate errors for objects missing art\n\n### Changed\n\n* Don't mark short songs as skipped\n* Subsonic Stop converting strings to ints in JSON responses\n\n### Fixed\n\n* User registrations\n* Workaround null values for new columns in search table\n* Check release_type length before inserting into the database\n* Ensure Album Artist is set correctly on songs\n* Subsonic Fix callbacks for similarSongs2 and artistInfo2\n* Subsonic getCoverArt fixes\n\n### API 4.2.3\n\n**NO CHANGE**\n\n## Ampache 4.2.2-release\n\n**DATABASE CHANGES** You can now force a default collation and charset on your database.\nIf you choose to use utf8mb4; Ampache will convert your table engine to InnoDB to handle the extra bytes.\n\n### Added\n\n* Numeric 'Played/Skipped ratio' added to search. (Set using (stream/skip)*100.)\n  * ```> 0 & < 100```: Skipped more than played\n  * ```100```: Equal plays and skips\n  * ```> 100```: Played more than skipped\n* Add 'Original Year', 'Release Type' to Album searches\n* Allow setting custom database collation and charset without overwriting your changes\n* Video search added to random.php\n* 'samesite=strict' on JS cookies\n* Translation updates (August 2020)\n* Put 'Labels' into search, browse headers and sidebar when enabled\n* NEW config options (config_version 45)\n  * database_charset: Set a default charset for your database\n  * database_collation: Set a default collation for your database\n  * simple_user_mode: Don't allow users to edit their account values (used for demo sites that allow login)\n* NEW files\n  * bin/update_file.inc: Update your catalog when individual files are changed using inotifywait.sh\n  * bin/update_db.inc: Update your database collation, charset and table engine from the cli\n  * docs/examples/inotifywait.sh: script to use inotifywait and update_file.inc to update as file changes happen\n  * docs/examples/inotifywait.service: systemd example service for inotifywait.sh\n\n### Changed\n\n* stats.php: Show total 'Item Count' on Statistics page instead of trying to shoehorn songs/videos/etc into different columns\n* ampache.sql updated after about 4 years... no more updates on install!\n* Searching by \"Rating (average)\" now ignores private/public and always returns the average.\n* Hide searches for '# Skipped' and 'Played/Skipped ratio' when 'Show # skipped' is Off\n* Search items rearranged to try to match each other\n* Sort 'Playlist' and 'Smart Playlist' browse pages by name\n* Display the blankuser avatar in now playing if missing\n* Swap 'Random' and 'Playlists' in the sidebar (CSS order numbers)\n* Don't hide artist art when you disable lastfm_api_key in the config\n* Hide 'Metadata' search when 'enable_custom_metadata' is disabled\n\n### Deprecated\n\n* Drop version number from the release string in develop. ('4.3.0-develop' => 'develop')\n  * This should stop a bit of confusion when removing / adding requirements\n* The '-release' suffix in version number will be dropped for Ampache 5.0.0\n\n### Removed\n\n* Remove stat recording from channels\n* Don't reset the database charset and collation after each db update\n\n### Fixed\n\n* Fixed a few issues on the Statistics page\n  * Report 'Catalog Size' correctly for podcasts\n  * Report 'Item Count' correctly for podcasts and video catalogs\n* Searching albums for artist name\n* Mashup 'Newest' would incorrectly apply an offset missing the newest items\n* Search by 'Smart Playlist' rules fixed when added with other rules\n* Use LEFT JOIN instead of HAVING for search rules to allow more complicated lists\n* Logic searching 'My Rating' includes unrated (0 Stars) in a better way\n* Captcha was not generated for registration\n* Enforce lowercase codec for live streams\n* Parsing integer search rules was overwriting index values\n* Handle empty XML on similar artist requests to last.fm\n\n### Security\n\nFix CVE-2020-15153 - Unauthenticated SQL injection in Ampache\n\n### API 4.2.2\n\nMinor bugfixes\n\n### Added\n\n* Api::advanced_search added parameter 'random' (0|1) to shuffle your searches\n\n### Changed\n\n* Remove spaces from advanced_search rule names. (Backwards compatible with old names)\n  * 'has image' => 'has_image'\n  * 'image height' => 'image_height'\n  * 'image width' => 'image_width'\n  * 'filename' => 'file' (Video search)\n\n### Deprecated\n\n* Search rules 'has image', 'image height', 'image width', 'filename'. (Removed in Ampache 5.0.0)\n\n### Fixed\n\n* Api::stream, Api::download Api::playlist_generate 'format' parameter was overwritten with 'xml' or 'json'\n* Produce valid XML for playlist_generate using the 'id' format in XML\n\n## 4.2.1-release\n\n**NOTICE** Ampache 5.0.0 will require **php-intl** module/dll to be enabled.\n\n### Added\n\n* Numeric ('1 Star'-'5 Stars') searches now include '0 Stars' to show unrated objects\n* Ajax refresh localplay \"Now Playing\" same as the index \"Now Playing\" section\n* Add 'has not rated' to \"Another User\" searches\n* Add higher bitrates (640, 1280) to search to allow for lossless files\n* Put strings ('1 Star', '2 Stars', etc) back into numeric searches for ratings\n* When using a string title for numeric searches use the order of the items starting with 0\n* NEW files\n  * Include API docs from the wiki. (API.md, API-JSON-methods.md, API-XML-methods.md, API-advanced-search.md)\n* 'Filters' added to each sidebar tab if enabled (previously only 'Home' and 'Admin')\n\n### Changed\n\n* Use binary (.mo) translation files to speed up translation processing\n* Don't show 'Generate new API key' if you don't have access\n* QR Code in account page is now just the API Key (redundant link removed too)\n* Require minimum version of Ampache 3.8.2 to upgrade database\n* Added an icon to webplayer to go to album. Clicking on song title now directs to song\n\n### Fixed\n\n* Waveform config option 'get_tmp_dir' was ignored if set\n* Rightbar: 'Add to New Playlist' not adding on new playlists\n* Translate preference subcategories and status\n* 'podcast_new_download' logic fix\n* Filters box would show up in the Admin tab if you disabled 'browse_filter'\n* Update album when 'release_type' changes\n* Parse 'Release Type' from tags in a less terrible way\n\n### API 4.2.1\n\nNo functional changes from 4.2.0\n\n### Fixed\n\n* Filter in \"playlist\" and \"playlist_songs\" fixed\n\n## 4.2.0-release\n\nThe API changelog for this version has been separated into a new sub-heading below to make it easier to follow.\n\n### Added\n\n* Added Spotify art searches for both album and artist images.\n* Updated component installer and php-cs-fixer package.\n* Translation updates (April 2020, May 2020, July 2020)\n* Added declare(strict_types=0); to lib/* and lib/class/* (requires more work before it can be enabled)\n* Add 250 for search form limits in the web UI. (Jump from 100 to 500 is pretty big)\n* Add Recently updated/added to search rules\n* Add regex searching to text fields. ([<https://mariadb.com/kb/en/regexp/>])\n  * Refer to the wiki for information about search rules. (<http://ampache.org/api/api-advanced-search>)\n* When labels are enabled, automatically generate and associate artists with their publisher/label tag values.\n* Enforced stat recording for videos. (podcasts and episodes to be added later)\n* Add tags (Genres) to \"Anywhere\" text searches.\n* 10 second redirect on \"Access Denied\" to the default web_path\n* Allow \"Update from tags\" for multi-disk album and artist pages\n* show and hide the rightbar (playlist) using the minimize button in the header\n* Tag->f_name (New property on tag that was being set hackily)\n* Add \"Album\" to Find Duplicates in admin/duplicates.php.\n* \"Local Image\" added to Artist & Album search. Find out whether you have art stored in Ampache\n* PHP_CodeSniffer checks and settings added to Scrutinizer. (phpcs --standard=.phpcs.xml lib/class)\n* NEW database options\n  * cron_cache: Speed up the interface by allowing background caching of data\n  * show_skipped_times: Add \"# skipped\" to the UI. (disabled by default)\n  * custom_datetime: Allow you to format your date strings your way.\n  * unique_playlist: Force unique playlists by ignoring existing songs\n* NEW config options\n  * skip_timer: Add Skip Timer Threshold to the config\n  * artist_art_folder: Specify a local folder to search for artist images using name/title\n  * rating_file_tag_user: Set ratings to this user ID when importing ratings from file tags\n  * spotify_client_id: Allows Spotify art search\n  * spotify_client_secret: Allows Spotify art search\n* NEW files\n  * server/json.server.php & lib\\class\\json_data.class.php: JSON API!\n  * bin/compute_cache.inc: Cache object_count data to speed up access\n  * bin/cron.inc: Perform garbage_collection functions outside of main functions (includes compute_cache.inc)\n* NEW examples\n  * docs/examples/ampache_cron.service\n  * docs/examples/ampache_cron.timer\n\n### Changed\n\n* Change license string from AGPLv3 to AGPL-3.0-or-later\n* Update Composer requirements\n* Allow searching play times without requiring UI option\n* Stop showing the average rating in the web interface as stars. (show an average when available as text separately)\n* When you don't have a config file redirect to installer\n* Change to numeric searches: Renamed 'is' => 'equals' and 'is not' => 'does not equal'\n* Allow negative track numbers; reducing the maximum track number to 32767.\n* Localplay volume control moved to the playlist (rightbar)\n* Podcast_Episode::check_play_history Podcast_Episode::set_played (match song.class versions for stat recording)\n* Video::check_play_history Video::set_played (match song.class versions for stat recording)\n* php_cs rules for line endings\n* Simplify play history checks and code a bit more\n* Tag (Genre) searches compare each item (e.g Pop) rather than the whole string (Pop,Rock,etc)\n* Replace \"Browse Library\" buttons with a search header allowing faster browsing of other types\n* Share secrets are generated by generate_password instead of a separate function\n* inet_ntop may not convert some binary IP addresses (like ::1) these now show up as \"Invalid\" in the ip history.\n* Searches using numeric rules must use an integer. ('1 Star' => 1, '2 Stars' => 2, etc)\n* bin/delete_disabled.inc require -x to execute. (previously you needed to edit the file)\n\n### Deprecated\n\n* Horde_Browser::getIPAddress(). Use Core::get_user_ip() instead.\n\n### Removed\n\n* bin/migrate_config.inc (This was used to migrate the config file from php4 to php5)\n* EchoNest api/song previews\n* User::update_user_stats (used in play index only and useless)\n* Share::generate_secret; use generate_password instead\n* Song::get_cache_count (unused)\n* Ampache Debug check for 'safe_mode'\n\n### Fixed\n\n* Fixed a lot of incorrectly typed function calls and code documentation\n* Gravatar Plugin: Make sure https is used when force_ssl is configured\n* Truncate strings to match database limits when strings go over\n* Add User php warnings\n* Channel authentication\n* IP checks when sending null proxy values\n* Gather art page layout\n* Read vorbis rating correctly\n* Search rules in UI failing to load with custom_metadata\n* Warn correctly when inserting art fails\n* Insert missing user preferences on login\n* When you had beautiful_urls enabled tracks would not parse in localplay making them all Unknown\n* Podcast durations aren't always correct format, prep the time before trying to insert it\n* Subsonic playlist add/remove removing incorrect songs\n* Search/Smartlists need to have results to be used in lists\n* Auth issues with stats for recording and localplay\n* Stream_urls were generated with a typo when downloading\n* Respect album grouping using of the moment plugin\n* Filter album title with grouping enabled. (seriously deadmau5, stop with the <> everywhere)\n* Share playback without a UID would fail to start\n* Set a default popular_threshold if unauthenticated or unset\n* play/index would record democratic streams as a download\n* Make sure the default preferences table has all the preferences in them\n* Beets catalog bug; date_diff expecting a datetime but given a string\n* Searches using user data like ratings has been split in the SQL correctly\n* Flagged playlists never had their flag deleted\n* offset and limit were incorrectly used for top/recent searches\n\n### Security\n\n* Fix: CVE-2020-13625 in phpmailer\n\n### API 4.2.0\n\n**API versions will follow release version and no longer use builds in the integer versions (e.g. 420000)**\nAPI 5.0.0-release will be the first Ampache release to match the release string.\n\n#### Added\n\n* JSON API now available!\n  * Call xml as normal:\n    * [<http://music.com.au/server/xml.server.php?action=handshake&auth=APIKEY&version=420000>]\n  * Call the JSON server:\n    * [<http://music.com.au/server/json.server.php?action=handshake&auth=APIKEY&version=420000>]\n  * Example XML and JSON responses available [here](https://github.com/ampache/python3-ampache/tree/master/docs)\n* NEW API functions\n  * get_similar: send artist or song id to get related objects from last.fm\n  * shares: get a list of shares you can access\n  * share: get a share by id\n  * share_create: create a share\n  * share_edit: edit an existing share\n  * share_delete: delete an existing share\n  * podcasts: get a list of podcasts you can access\n  * podcast: get a podcast by id\n  * podcast_episodes: get a list of podcast_episodes you can access\n  * podcast_episode: get a podcast_episode by id\n  * podcast_episode_delete: delete an existing podcast_episode\n  * podcast_create: create a podcast\n  * podcast_edit: edit an existing podcast\n  * podcast_delete: delete an existing podcast\n  * update_podcast: sync and download new episodes\n  * licenses: get a list of licenses you can access\n  * license: get a license by id\n  * catalogs: get all the catalogs\n  * catalog: get a catalog by id\n  * catalog_file: clean, add, verify using the file path (good for scripting)\n\n#### Changed\n\n* Bump API version to 420000 (4.2.0)\n* All calls that return songs now include ```<playlisttrack>``` which can be used to identify track order.\n* ```<playcount>``` added to objects with a playcount.\n* ```<license>``` added to song objects.\n* Don't gather art when adding songs\n* Added actions to catalog_action. 'verify_catalog' 'gather_art'\n* API function \"playlist_edit\": added ability to edit playlist items\n  * items  = (string) comma-separated song_id's (replace existing items with a new object_id) //optional\n  * tracks = (string) comma-separated playlisttrack numbers matched to items in order //optional\n* Random albums will get songs for all disks if album_group enabled\n\n### Deprecated\n\n* API Build number is depreciated (the last 3 digits of the api version)\n  * API 5.0.0 will be released with a string version (\"5.0.0-release\")\n  * All future 4.x.x API versions will follow the main Ampache version. (420000, 421000, 422000)\n* total_count in the XML API is depreciated and will be removed in API 5.0.0.\n  * XML can count objects the same was as a JSON array [https://www.php.net/manual/en/simplexmlelement.count.php]\n* Genre in songs is depreciated and will be removed in API 5.0.0.\n  * Use tag instead of genre, tag provides a genre ID as well as the name.\n\n#### Fixed\n\n* Extra text in catalog API calls\n* Don't fail the API calls when the database needs updating\n\n## 4.1.1\n\n### Added\n\n* Extend Shouts to 2000 characters; Labels to 250\n* Add a status icon to the channel list pointing to the channel/ID/status.xsl\n\n### Changed\n\n* Hide localplay in the sidebar when you disable all the plugins\n\n### Removed\n\n* Remove non-free lib/composer.* files.\n  * You can enable c-pchart with (composer require szymach/c-pchart \"2.*\")\n* Remove shoutcast table and preferences. (Dead code)\n\n### Fixed\n\n* Musicbrainz Art search\n* tmp_playlist bug removing items\n* Dropbox catalog errors when using a small library\n* some bugs getting invalid time/date when reading tags\n\n### API 4.0.0 build 004\n\nBump API version to 400004 (4.0.0 build 004)\n\n#### Added\n\n* Add Api::check_access to warn when you can't access a function\n\n#### Fixed\n\n* Fix parameters using 0\n* Get the correct total_count in xml when you set a limit\n* Fix many XML formatting issues\n\n## 4.1.0\n\n### Added\n\n* December translation update from Transifex\n* Add playlist into main search page. (Songs, Albums, Artists, Playlists, Videos)\n* Add docs/examples/channel_run.service for running background processes as a service\n* New search option \"Another User\" allows searching other user ratings and favorites\n* Updates to support php7.4 (Ampache supports 7.1-7.4)\n* Checks in Subsonic/WebUI for recording repeated plays\n* composer & php-cs-fixer updates\n* Add github package guide for docker to RELEASE-PROCESS.md\n\n### Changed\n\n* Update channel status pages (/channel/$CHANNELID/status.xsl)\n* Update ListenBrainz plugin for empty additional info. (API says remove this section from json)\n\n### Removed\n\n* Roll back mysql8 workarounds. (Orace MySQL supported on php7.4+ only)\n* Revert changes in 4.0.0 and allow manual choices for artist/album on upload again.\n\n### Fixed\n\n* Fix comparison bugs found during static type testing\n* Fix enable/disable song ajax\n* Typo in login page HTTP_REFERER\n* Fix bin\\*.inc text issues with newline\n* Fix bug in UI when enabling/disabling songs\n* Fix smartlists when searching sub-lists (Ampache was trying to create one giant query that didn't scale well)\n* Fix \"Add New...\" in album edit\n* Subsonic return json errors when requesting json format (previously errors were always xml)\n\n### API 4.0.0 build 003\n\nBump API version to 400003 (4.0.0 build 003)\n\n#### Added\n\n* user_numeric searches also available in the API. ([<http://ampache.org/api/api-xml-methods>])\n\n#### Changed\n\n* Api::playlist - filter mandatory\n* Api::playlist_edit - filter mandatory. name and type now optional\n* Api::user - Extend return values to include more user fields\n* Playlist::create - Return duplicate playlist ID instead of creating a new one\n* Do not limit smartlists based on item count (return everything you can access)\n* Api/Database - Add last_count for search table to speed up access in API\n\n#### Removed\n\n* Artist::check - Remove MBID from Various Artist objects\n\n#### Fixed\n\n* Fix Song::update_song for label\n* Fix Api issues relating to playlist access\n\n## 4.0.4\n\nFinalize release procedure to make these updates a bit smoother\n\n### Added\n\n* Reduce the time for repeated track playback (Song length - 5 sec)\n\n### Changed\n\n* Filter playlists in API, Web and Subsonic correctly for regular users vs admins\n* Hide some lines from the mashup to make it a bit nicer\n\n### Removed\n\n* Remove the old logo from the main install page\n\n### Fixed\n\n* Fix album count for Artists when the album is missing data\n* Fix searches / searchbox for MYSQL8\n* Fix some invalid returns in lib/*\n* Send the correct function in ajax.server when deleting from playlist\n\n### Security\n\n* None\n\n## 4.0.3\n\n### Changed\n\n* Filter playlists by access in subsonic\n* Fail check_php_verison() when using less than php7.1\n\n### Fixed\n\n* Fixes for Api::get_indexes, Api::playlists, Api::playlist, Api::playlist_songs\n* Fix Access::check to allow all public lists\n* Fix global user connecting through the API with an API key.\n\n## 4.0.2\n\n### Changed\n\n* Bump API version to 400002 (4.0.0 build 002)\n* Extend Api::playlist_generate (add new mode 'unplayed')\n* Translate typo in show_test.inc\n* Trim massive year, time and track when importing new songs\n\n### Fixed\n\n* Fix API playlist commands and access checks relating to playlists\n* Access::check should be passing user id from the API\n* SQL query fixes for Album, Playlist methods\n* Remove spaces from play url extensions (Should help nginx users)\n* Set play_type correctly in preferences pages\n\n## 4.0.1\n\n### Added\n\n* Added 'file' to Song::find\n\n### Fixed\n\n* Bug fix that would cause albums to be recreated in Album::check\n\n## 4.0.0\n\nNotes about this release that can't be summed up in a log line\n\n### Added\n\n* JavaScript and Ajax updates\n* Code documentation and bug hunting\n* Added SVG support to the theme engine.\n* Default to disk 1 instead of 0 (db updates to handle existing albums)\n* Add Barcode, Original Year and Catalog Number to Album table\n* New Plugin - Matomo.plugin. [<https://matomo.org/>]\n* New Plugin - ListenBrainz.plugin [<https://listenbrainz.org/>]\n* Add bin/clean_art_table.inc to clean art that doesn't fit your min or max dimensions.\n* Default fallback user avatar when none found\n* Added a $_SESSION['mobile'] variable to allow changing pages for mobile devices.\n* Viewport settings for mobile devices\n* Use a random cover for playlist art\n* Add now_playing.php to allow badges for currently track and fall back to last played if none. (thanks @Rycieos)\n* Add Now Playing icon to each user page if enabled.\n* Add year information and links to the data rows and interface\n* Add debugging in song.class.php when the file may be corrupt\n* Allow the main sidebar to be reordered using CSS (.sb2_music, .sb2_video, .sb2_*)\n* Subsonic Update api to 1.13.0 [<http://www.subsonic.org/pages/api.jsp>]\n* Subsonic Allow token auth using API Key instead of password.\n* Subsonic New Method: updateUser\n* Subsonic New Method: getTopSongs\n* Config Version 40\n  * Add: mail_enable - Enable or disable email server features otherwise, you can reset your password and never receive an email with the new one\n  * Add: rating_browse_filter, rating_browse_minimum_stars - filter based on a star rating.\n  * Add: send_full_stream - allow pushing the full track instead of segmenting\n  * Add: github_force_branch - Allow any official Ampache git branch set in config\n  * Add: subsonic_stream_scrobble - set to false to force all caching to count as a download.\n    This is to be used with the subsonic client set to scrobble. (Ampache will now scrobble to itself over subsonic.)\n  * Add: waveform_height, waveform_width - customize waveform size\n  * Add: of_the_moment - set custom amount of albums/videos in \"of the moment areas\"\n  * Add: use_now_playing_embedded, now_playing_refresh_limit, now_playing_css_file - Show a user forum tag \"Now playing / last played\"\n\n### Changed\n\n* Don't allow lost password reset for Admin users\n* Don't allow emails until mail_enable is true\n* Don't allow last.fm queries to overwrite existing art\n* Stop trying to insert art when present during catalog update\n* Move some $_GET, POST, $_REQUEST calls to Core\n* HTML5 doctype across the board. (DOCTYPE html)\n* Lots of HTML and UI fixes courtesy of @kuzi-moto\n* If you are using charts/graphs there has been a change regarding c-pchart\n  * [chart-faq](https://github.com/ampache/ampache/wiki/chart-faq)\n* Numerous catalog updates to allow data migration when updating file tags meaning faster tag updates/catalog verify! (Updating an album would update each file multiple times)\n  * UserActivity::migrate, Userflag::migrate, Rating::migrate, Catalog::migrate,\n  * Shoutbox::migrate, Recommendation::migrate, Tag::migrate, Share::migrate\n* Rework user uploads to rely on file tags ONLY instead of allowing manual choices.\n* Extend bin/sort_files.inc & catalog patterns to handle new fields\n* Updated bin/sort_files.inc for a smoother experience that actually works\n* Add -u to bin/catalog_update.inc This function will update the artist table with bio, image, etc as well as update similar artists.\n* Update the CSS theme colors and structure.\n* Light theme updated.\n* Format the input fields. (you get a datetime picker on mobile!)\n* Login/lostpassword moves the logo to the bottom on mobile like cockpit does! (makes typing easier on a touch screen)\n* Load webplayer hidden to stop popup preferences hiding the window\n* Hide video in search/stats if not enabled\n* Lots of code tweaks to make things more uniform and readable.\n* Default to mashup for artists and albums\n* Remove '[Disk x]' when grouped from all UI areas by enforcing the group setting.\n* Subsonic Enable getChatMessages, addMessage allowing server chat\n\n### Removed\n\n* Drop PHP 5.6 support for 7.1+\n* Remove all Plex code\n* Remove message of the day\n* No video, no channels in new installs\n* Remove plex and googleplus plugins\n\n### Fixed\n\n* Fix import_playlist code. Do not recreate existing playlists and don't imports existing songs.\n* Allow cli tools to use system settings for plugins.\n* Fix MySQL8 installation using mysql_native_password with caveats ([<https://github.com/ampache/ampache/wiki/mysql-faq>])\n* Catalog Manager can now access catalog areas correctly\n* Filter zip names in batch so they are named correctly by the download\n* Fixed setting button requiring two single clicks to open. (Thanks for this 2016 pull @AshotN)\n* Make test.php, init.php & install.php show an error page instead of blank screen. (gettext)\n* Fix slideshow creating black screen when using web player\n* Fixed QRCode views\n* Subsonic Don't ignore group settings with id3 browsing\n* Subsonic Fix cover art for playlists and albums\n* Subsonic Api fixes for podcast playback, Ultrasonic/Dsub workarounds\n\n### Security\n\n* Resolve NS-18-046 Multiple Reflected Cross-site Scripting Vulnerabilities in Ampache 3.9.0\n* Resolve CVE-2019-12385 for the SQL Injection\n* Resolve CVE-2019-12386 for the persistent XSS\n\n### API 4.0.0 build 001\n\n* Bump API version to 400002 (4.0.0 build 001)\n\n#### Added\n\n* Documented the Ampache API [<http://ampache.org/api/api-xml-methods>]\n* Include smartlists in the API playlist calls.\n* Authentication: allow sha256 encrypted apikey for auth\n  * You must send an encrypted api key in the following fashion. (Hash key joined with username)\n  * $passphrase = hash('sha256', $username . hash('sha256', $apikey));\n* Added artist_tag to song searches\n* flag: allows flagging object by id & type\n* record_play: allows recording play of object without streaming\n* catalog_action: allow running add_to_catalog|clean_catalog\n* playlist_edit: allow editing name and type of playlist\n* goodbye: Destroy session\n* get_indexes: return simple index lists to allow a quicker library fill.\n* check_parameter: error when mandatory inputs are missing\n* stream: Raw stream of song_id\n* download: Download, not recorded as a play\n* get_art: Raw art file like subsonic getCoverArt\n* user_create: 'user' access level only!\n* user_update: update user details and passwords for non-admins\n* user_delete: you can't delete yourself or and admin account!\n* update_from_tags: updates a single album, artist, song from the tag data instead of the entire library!\n* update_art: updates a single album, artist, song running the gather_art process\n* update_artist_info: Update artist information and fetch similar artists from last.fm\n* playlist_generate: Get a list of song xml, indexes or id's based on some simple search criteria. care of @4phun\n\n#### Changed\n\n* Authentication: Require a handshake and generate unique sessions at all times\n* advanced_search\n  * 'is not' has been added shifting values down the list.\n    (0=contains, 1=does not contain, 2=starts with, 3=ends with, 4=is, 5=is not, 6=sounds like, 7=does not sound like)\n  * rule_1['name'] is depreciated. Instead of multiple searches for the same thing rule_1'name'\n    has been replaced with 'title' (I have put a temp workaround into the search rules to alleviate this change)\n* stats\n  * allow songs|artists|albums (instead of just albums)\n* playlists\n  * allow return of smartlists as well as regular playlists (set a 5000 limit on unlimited smartlists)\n* playlist_add_song\n  * Added check boolean to skip duplicate songs\n* playlist_remove_song\n  * Allow uid of song instead of the track id from the playlist\n\n## 3.9.1\n\n* Fixed Beets catalog creation and updating.\n* Autoupdate now ignores pre-release (preview) versions.\n* Fixed various command ine utilities in bin folder.\n* Fixed XML api syntax for logging in with user name.\n* Fixed newline display in xml data returned in playlist, etc.\n\n## 3.9.0\n\n* Video details now correctly displayed for personal video.\n* XML API now fully accepts user's API key. Session will be extended if it exists; Otherwise it's replaced.\n* Artist name added to Lastfm track.getsimilar query.\n* Catalog_update.inc now includes switches for catalog name and catalog type.\n* Added Beets catalog to Composer autoload.\n* Performance improved with playlist display and search.\n* General translation Updates.\n* Documented php module requirement for FreeBSD.\n\n## 3.8.9\n\n* Improved display of artist summary on web page.\n* Fixed uploading of avatar.\n* DSub now writes the correct extension when the ampache config switch `encode_player_api_target` is enabled.\n* Artist info now properly displayed.\n\n## 3.8.8\n\n* Subsonic API now removes illegal characters before returning text.\n* Removed hardcoded access level to allow guests to stream audio.\n* Guest accounts can now access songs and public playlists.\n* Fixed bug in subsonic API which caused DSub not to create folders or\n  add file extensions when caching.\n\n## 3.8.7\n\n* Better able to clean up image extentions when gathering art from remote sites.\n* Check for B.O.M. (\\xff\\xfe) only in mp3 composer tag and remove.\n* Added .ogv encoding target for more efficient streaming of mkv files.\n* Top menu appearance more reader friendly for translations.\n* Additional fixes to update_remote_catalog function.\n* Enabled similar songs when clicking on radio icon in DSub.\n* Repaired problem with removing \"empty\" albums.\n* Can now access XML-API when default ACL(s) are removed.\n* 'Find Duplicates' tool now works.\n* Cleaning now checks for mounted path before removing empty albums/missing files.\n* Starring album and artist now work via Subsonic client.\n* Modified \"Gather Art\" debug message to remove confusion from \"Image less than 5 chars...\".\n\n## 3.8.6\n\n* Updated Subsonic Remote Catalog Module to version 2.\n* Subsonic Catalog now grabs artwork directly from the subsonic server.\n* Various fixes to Subsonic Catalog and Subsonic API.\n* Release package now downloads from release update alert.\n* Develop package downloads from develop update alert.\n* Fixed album Search.\n\n## 3.8.5\n\n* Added search capability for user's own ratings option for Song, Artist, Album search.\n* Clean process now removes empty albums.\n* Further translation updates and fixes.\n* Updated Subsonic API to increase compliance with Subsonic json API specs.\n* Added starred date to album list and song and formatted per Subsonic spec.\n* Now compatible with latest Ultrasonic client (json transfer).\n* Fixed ability to edit/save smartplaylist name without setting 'random'.\n* Search/smart playlist now includes favorite artists and albums.\n* Modified SQL statement to not offend default SQL_MODE of ONLY_FULL_GROUP_BY on server versions after 5.7.6.\n* Set redirect to false for streaming types.\n\n## 3.8.4\n\n* Subsonic catalog now displays album art and artist bio.\n* Artist info now displays in Ampache's installed language.\n* Updated translations.\n* Composer tag changes now saved to database.\n* Seafile catalog module added.\n* Dropbox catalog updated to V2 API.\n* ip6 addresses now added to user history.\n* Updated api.class.php\n* fix for web_path auto configuration for subdirectory installation\n* Composer tag changes now written to database\n* Fixed catch null reference\n* Changes to make translation easier\n* Smart Playlist can now be edited/saved without 'random' set.\n\n## 3.8.3\n\n* Fixed upload problem\n* Fixed charting problem\n* Updated composer dependencies\n* Fixed ipv6 issue\n* Improved Opus transcoding\n* Fixed localization chart\n* Improved Subsonic API\n* Improved ID3v2.3 and v2.4 to better handle multivalued lists\n* Added sort by disc numbers\n* Song comments are now editable\n* Fixed composer column in iTunes\n* Many typos fixed\n* Fixed field types in modules and Localplay\n* Fixed timeline function\n* Activated jplayer \"preload\" option\n* Fixed missing submit button on options page\n* Increased info on DSub failing via Subsonic API\n* Fixed Group actions in private message page causing JavaScript error\n* Fixed some info lievel issues in Codacy\n* Apply trim on dropbox parameters\n* Added Prompt for user to change secret_key during install\n* Enabled use of cache in PHPCs\n* All files now use UTF8 without BOM\n* Now require Exact catalog name match on catalog update\n* Port 443 removed from play url\n* Now test all images found to select the one with the good dimensions\n* Rewrote LDAP class\n* Song count in handshake now matches the number returned from songs\n* Blocking of webplayer when transcoding fixed\n* Cover art is added to live stream\n* Added browse filter and light sidebar options\n* Updated gettext, zipstream, react and sabre dependencies\n* Fixed Subsonic scrobble submission check\n\n## 3.8.2\n\n* Fixed potential security vulnerability on smartplaylist search rule and catalog management actions (thanks Roman Ammann)\n* Fixed song comparison issue on arrays (genre ...) when updating from tag\n* Fixed song insertion issue if track year is out of range\n* Fixed unexpected artist summary autoupdate\n* Improved generated playlist filename (thanks yam655)\n* Fixed user avatar upload (thanks vader083)\n* Fixed waveform temporary file deletion issue if GD library is unavailable\n* Fixed max number of items returned from Subsonic getStarred.view (thanks zerodogg)\n* Fixed video update from tags (thanks stebe)\n* Reverted PHP 5.5.9 dependency to PHP 5.4\n* Added video playlist support (thanks SurvivalHive)\n* Added preference subcategory\n* Added prompt for new playlist name\n* Fixed page refresh when canceling album art change (thanks EvilLivesHere)\n* Added /play htaccess rewrite rule to avoid default max limit redirection\n* Fixed Subsonic artist/album/song name JSON parsing if the name is numeric only\n* Added ignored articles and cover art to Subsonic getArtists.view function\n* Fixed MySQL requests to support ONLY_FULL_GROUP_BY mode\n* Fixed Ajax art refresh after changing it (thanks gnujeremie)\n* Fixed playlist creation from smartplaylist (thanks stebe)\n* Added SQL unique constraint on tag map\n* Fixed Subsonic genres with JSON format\n* Added Bookmarks feature on Subsonic API\n* Fixed thumb art regeneration if entry found in database without data (thanks s4astliv)\n* Added Podcast feature\n* Added large view / grid view option on artist and albums collection\n* Moved from php-gettext to oscarotero/Gettext\n* Added `Access-Control-Allow-Origin: *` header on Subsonic images & streams\n* Fixed Subsonic item identifier parsing\n* Added logic for external plugin directories (ampache-*)\n* Added Discogs metadata plugin\n\n## 3.8.1\n\n* Fixed PHP7 Error class conflict (thanks trampi)\n* Fixed user password with special characters at install time (thanks jagerman)\n* Moved Ampache project license from GPLv2 to AGPLv3\n* Added Ampache specific information on Subsonic API getAlbum using a new `ampache` parameter (thanks nicklan)\n* Added 'album tag' option in song search (thanks DanielMaly)\n* Added Message of the Day plugin to display MOTD\n* Moved AmpacheApi class to a separate ampacheapi-php git repository\n* Added timeline / friends timeline feature\n* Fixed disabled song display to regular users (thanks shangril)\n* Fixed random albums art size (thanks Bidules079)\n* Moved tag cloud to artist browsing by default\n* Fixed utf8 BOM empty string on song comparison\n* Improved Recently Played and user stats queries performance (thanks thinca)\n* Renamed SAMPLE_RATE to TRANSCODE_BITRATE on transcoding\n* Fixed tag deletion sql error (thanks stebe)\n* Moved to PNG default blank image instead of JPG (thanks Psy-Virus)\n* Fixed temporary playlist initial position when scrolling down (thanks RobertoCarlo)\n* Added Radio stations to UPnP backend\n* Fixed Subsonic API art to use album art if song doesn't have a custom art (thanks hypfvieh)\n* Fixed Subsonic API search when object count parameter is 0 (thanks hypfvieh)\n* Fixed UPnP UUID to be based on host information\n* Moved to Composer for dependencies management\n* Fixed catalog action when not using Ajax page loading (thanks Razrael)\n* Fixed unrated song default value (thanks Combustible)\n* Added custom metadata support from files (thanks Razrael)\n* Improved Subsonic API getArtists performance (thanks nicklan)\n* Fixed theme color setting behavior\n* Moved audioscrobbler API to v2\n* Added m3u8 playlist import\n* Fixed utf8 id3v2 comments support\n* Added write_playlists script to export playlists to file\n* Fixed Tvdb and Tmdb plugins (thanks wagnered)\n* Improved Video filename parsing (thanks wagnered)\n* Fixed non scalar settings value printing on debug page\n* Improved Subsonic API getAlbumList error handling\n* Fixed user login with browser used during the installation\n* Fixed iTunes 12 browsing when using DAAP (thanks Chattaway83)\n* Moved http_port user preference to ampache.cfg.php\n* Upgraded last.fm and libre.fm scrobbling to latest API version (thanks nioc)\n* Added missing space between track and album in Localplay playlist (thanks arnaudbey)\n* Added check fo mbstring.func_overload support before using id3 write functionality (thanks anonymous2ch)\n* Fixed file size calculation when using id3v2 tag (thanks hypfvieh)\n* Added rating from id3 tag (thanks nioc)\n* Added track number on streaming playlist (thanks Fondor1)\n* Fixed catalog export (thanks shellshocker)\n* Fixed file change detection\n* Improved XML API with more information and new functions\n  * (advanced_search, toggle_follow, last_shouts, rate, timeline, friends_timeline)\n* Fixed 'Next' button when browsing start offset is aligned to offset limit (thanks wagnered)\n* Fixed stream kill OS detection (thanks nan4k7)\n* Fixed calculate_art_size script to support storage on disk (thanks nan4k7)\n* Fixed sql script semicolon typo (thanks jack)\n* Added support for .opus files (thanks mrpi)\n* Fixed podcast owner xml information\n* Fixed ldap filter parameter check (thanks ChrGeiss)\n* Fixed 'Add to existing playlist' link for regular users (thanks Niols)\n\n## 3.8.0\n\n* Added Portuguese (Brasil) language (thanks Ione Souza Junior)\n* Updated PHPMailer version to 5.2.10\n* Fixed user stats clear\n* Added user, followers and last shouts XML API functions\n* Fixed transcoded process end on some systems (thanks nan4k7)\n* Added ogg channel streaming support (thanks Deathcow)\n* Fixed sql connection close before stream (thanks fufroma)\n* Added support for several ldap filters (thanks T-Rock)\n* Fixed 'Add to existing playlist' button on web player (thanks RyanCopley)\n* Added 'add to existing playlist' link on album page (thanks RyanCopley)\n* Added option to hide user fullname from other users\n* Added playlist track information in Apache XML API (thanks RyanCopley)\n* Fixed playlist remove song in Apache XML API (thanks RyanCopley)\n* Fixed Subsonic API ifModifiedSince information\n* Added Podcast links to albums / artists\n* Added Piwik and Google Analytics plugins\n* Added Apache 2.4 access control declaration in htaccess files\n* Fixed performance issues on user preferences\n* Added artist search by year and place\n* Fixed search by comment (thanks malkavi)\n* Added Paypal and Flattr plugins\n* Added .maintenance page\n* Fixed captcha\n* Added private messages between users\n* Fixed Subsonic API rating information on albums and songs\n* Added latest artists and shouts RSS feeds\n* Fixed tag cloud ordering\n* Added Label entities associated to artists / users\n* Added WebDAV backend\n* Fixed Subsonic API requests with musicFolderId parameter (thanks dhsc19)\n* Added footer text edition setting\n* Added uploaded artist list on user page\n* Added custom Ampache login logo and favicon support\n* Added edition support on shared objects (thanks dhsc19)\n* Fixed share feature on videos (thanks RobertoCarlo)\n* Removed album year display from album name if unset\n* Fixed Subsonic API Album/Artist song's link (thanks dhsc19 and daneren2005)\n* Added mysql database socket authentication support on web setup (thanks AsavarTzeth)\n* Fixed artist art url for mobile use (thanks dhsc19)\n* Added Shoutbox home plugin\n* Added catalog favorites home plugin\n* Fixed search by rating (thanks iamnumbersix)\n* Added UPnP Localplay (thanks SeregaPru)\n* Changed preferences to return the global value if preference is missing for the searched user\n* Fixed special chars in songs names and tags (thanks SeregaPru)\n* Fixed Subsonic API playlist edition/delation (thanks dhsc19)\n* Fixed integer default value in Apache XML API\n* Fixed image thumb on webplayer and search preview (thanks RobertoCarlo and eephyne)\n* Fixed proxy setting on all external http requests (thanks brendankearney)\n* Added QRCode view of user API key\n* Fixed http status code on Subsonic API streams when using curl (thanks nicklan)\n* Added Server-Sent Events on catalog actions\n* Added option to enable/disable channel and live stream features\n* Removed official PHP 5.3 support\n* Added option to show/hide footer statistics (thanks brownl)\n* Added delete from disk option on user uploaded files\n* Added installation type and players helper at installation process\n* Added tv_episode tag on quicktime files (thanks wagnered)\n* Added new option to disable deferred extended metadata, e.g. artist details\n* Added Subsonic API getAvatar function\n* Fixed unsynced lyrics tags\n* Fixed ldap_filter setting deactivation on ampache.cfg.php update (thanks Rouzax)\n* Added Subsonic API similar artists & songs functions\n* Added Subsonic API getLyrics function\n* Fixed disk number and album artist metadata on quicktime files (thanks JoeDat)\n* Fixed Ampache API playlist_add_song function\n* Added ability to store images on disk\n* Added new setting to define album art min and max width/height\n* Fixed Subsonic API getAlbum returned artist id on songs\n* Fixed Subsonic API cover art when PHP-GD unavailable\n* Fixed Localplay playlist refresh on volume changes (thanks essagl)\n* Fixed web player equalizer option if visualizer is not enabled (thanks brownl)\n* Fixed asx file mime type (thanks thinca)\n* Added song genre parsing options (thanks Razrael and lotan)\n* Added sort on languages list (thanks brownl)\n* Added placeholder text to search box (thanks brownl)\n* Added web player Play Next feature (thanks tan-ce)\n* Fixed Plex backend administration page uri (thanks a9k)\n* Fixed expired shared objects clean (thanks eephyne)\n* Added missing artist search results (thanks bliptec)\n* Fixed song genre id parsing (thanks lotan)\n* Added Scrobble method to Subsonic API\n* Added an option to add tags to child without overwriting\n* Added image dimension info to image tables (thanks tsquare66)\n* Replaced ArchiveLib by StreamZip-PHP to avoid temporary zip file\n* Added Year field in song details and edition\n* Added Subsonic API create/delete user, jukebox control and search auto suggestion\n* Added few optional install tests\n* Improved Share features with modal dialog choices\n* Added new action on playlists to remove duplicates\n* Fixed playlist addition to another playlist (thanks kszulc)\n* Fixed Various Artist link on album page (thanks Jucgshu)\n* Added session_destroy call when a session should be destroyed\n* Added HTML5 ReplayGain track feature\n* Added display and mandatory user registration fields settings\n* Added .htaccess IfModule mod_access.c directives\n* Fixed SmartPlayer results per user (thanks nakinigit)\n* Fixed XSS vulnerability CVE-2014-8620 (thanks g0blin)\n* Fixed playlist import setting on catalog update to be disabled by default (thanks DaPike)\n* Added ability to browse my tags other library items than songs\n* Added Stream Control plugins\n* Added transcode settings per player type\n* Added ability to write directly the new configuration file when it version changed\n* Added `quick play url` to have permanent authenticated stream link without session\n* Fixed unresponsive website on batch download (thanks Rouzax)\n* Added batch download item granularity\n* Fixed 'guest' user site rendering\n* Added Aurora.js support in webplayer\n* Added Google Maps geolocation analyze plugin\n* Added statistical graphs\n* Added user geolocation\n* Added 'Missing Artist' search\n* Fixed Ampache installation with FastCGI\n* Added a new RSS Feed plugin\n* Added a new 'display home' plugin type\n* Added Favorite and Rating features to playlists\n* Added user feedback near mouse cursor on democratic votes\n* Changed header page position to be fixed\n* Added external links on song page details\n* Fixed Subsonic API getAlbumList2 byGenre and byYear order (thanks rrjk)\n* Added html5 desktop notification\n* Added album group order setting\n* Fixed unwanted album merge when one of the album doesn't have mbid\n* Changed video player to go outside the footer\n* Added ip address in authentication failure for fail2ban scripts (thanks popindavibe)\n* Added parameter to hide directplay button if number of items is above a limit\n* Added Tag split (thanks jcwmoore)\n* Fixed album/artist arts and stats migration on rename (thanks jcwmoore)\n* Fixed get lyrics from files (thanks apastuszak)\n* Fixed verify local catalog (thanks JoeDat)\n* Removed Twitter code\n* Added optional cookie disclaimer for the EU Cookie Law\n* Replaced catalog action links to action dropdown list (thanks Psy-Virus)\n* Fixed `remember me` feature (thanks ainola)\n* Added email when registered user must be enabled by administrators\n* Fixed local catalog clean on Windows (thanks Rouzax)\n* Added Subsonic API maxBitRate parameter support (thanks philipl)\n* Fixed Subsonic API special characters encode (thanks nan4k7)\n* Added Beets local and remote catalog support (thanks Razrael)\n* Fixed XML error code returned with invalid Ampache API handshake (thanks funkygaddafi)\n* Replaced iframe to Ajax dynamic page loading\n* Changed `Albums of the Moment` to not necessarily have a cover\n* Added Plex backend items edition support\n* Added hls stream support\n* Added X-Content-Duration header support on streams\n* Removed Toogle Art from artist page\n* Fixed track numbers when removing a song from playlist (thanks stonie08)\n* Added Plex backend playlist support\n* Added gather art from video files (thanks wagnered)\n* Added Plex backend movie / tvshow support\n* Added release group on albums\n* Added Smart Playlist songs list\n* Added zlib test\n* Removed old Ampache themes\n* Fixed Subsonic API lastModified element (thanks bikkuri10)\n* Disabled `beautiful url` on XML-API for retro-compatibility\n* Fixed image resource allocation (thanks greengeek1)\n* Added setting to write id3 metadata to files (thanks tsquare66)\n* Added check for large files manipulation\n* Added video subtitle support\n* Fixed Google arts to use real arts and not the small size preview\n* Added Tmdb metadata plugin\n* Added Omdb metadata plugin\n* Added Music Clips, Movies and TV Shows support\n* Added media type information on catalog\n* Fixed get SmartPlaylist in XML-API (thanks opencrf)\n* Added beautiful url on arts\n* Improved browse list header (thanks Psy-Virus)\n* Fixed user online/offline information on Reborn theme (thanks thorsforge)\n* Added UPnP backend (thanks SeregaPru)\n* Added DAAP backend\n* Added sort options on playlists (thanks Shdwdrgn)\n* Fixed XML-API tag information (thanks jcwmoore)\n* Fixed multiple broadcast play (thanks uk3gaus)\n* Added SmartPlaylists to Subsonic API\n* Added limit option on SmartPlaylists\n* Added random option on SmartPlaylists\n* Added 'item count' on browse\n* Added direct typed links on items tags\n* Fixed Subsonic API compatibility with few players requesting information on library -1\n* Added license information on songs\n* Added upload feature on web interface\n* Added albumartist information on songs (thanks tsquare66)\n* Fixed errors on sql table exists check\n* Fixed play/pause on broadcasts (thanks uk3gaus)\n* Added donation button\n* Added democratic page automatic refresh\n* Fixed distinct random albums\n* Added collapsing menu (thanks Kaivo)\n* Added 'save to playlist' feature on web player (thanks Kaivo)\n* Added tag merge feature\n* Fixed democratic vote with automatic logins (thanks M4DM4NZ)\n* Added git pull update from web interface for development versions\n* Fixed http-rang requests on streaming (thanks thejk)\n* Improved installation process\n* Improved French translation (thanks arnaudbey)\n* Improved German translation (thanks Psy-Virus and meandor)\n\n## 3.7.0\n\n* Added Scrutinizer analyze\n* Fixed playlist play with disabled songs (reported by stebe)\n* Improved user auto-registration to optionally avoid email validation\n* Fixed date.timezone php warnings breaking Ampache API (reported by redcap1)\n* Fixed playlist browse with items > 1000 (reported by Tetram67)\n* Fixed Amazon API Image support (thanks jbrain)\n* Fixed id3v2 multiples genres (reported by Rouzax)\n* Improved democratic playlist view to select the first one by default\n* Improved German translation (thanks Psy-Virus)\n* Fixed playlist view of all users for administrator accounts (reported by stonie08)\n* Added option to regroup album disks to one album view\n* Changed Ampache logo\n* Fixed email validation on user registration (reported by redcap1)\n* Added local charset setting\n* Improved installation steps and design (thanks changi67)\n* Improved Recently Played to not filter songs to one display only\n* Fixed Subsonic transcoding support\n* Fixed Subsonic offline storage file path (reported by Tetram76)\n* Added optional top dock menu\n* Added html5 web audio api visualizer and equalizer\n* Added `Play List` to Localplay mode\n* Fixed encoding issue in batch download\n* Added pagination to democratic playlists\n* Added an option to group albums discs to an unique album\n* Added alphabeticalByName and alphabeticalByArtist browse view in Subsonic API\n* Fixed album art on xspf generated playlist\n* Added stats, playlist and new authentication method to Ampache XML API\n* Added responsive tables to automatically hide optional information on small screen\n* Added song action buttons (user favorite, rating, ...) to the web player\n* Added sortable capability to the web player playlist\n* Added Growl notification/scrobbler plugin\n* Added artist slideshow photos plugin from Flickr\n* Added setting to change Ampache log file name\n* Added playlists to Quick and Advanced search\n* Added pls, asx and xspf playlist file format import\n* Fixed playlist import with song file absolute path (reported by ricksorensen)\n* Fixed playlist import with same song file names (reported by captainark)\n* Added shoutcast notification at specific time when playing a song with a waveform\n* Added Tag edit/delete capability\n* Added several search engine links\n* Added myPlex support on Plex API\n* Added cache on LastFM data\n* Added custom buttons play actions\n* Added artist pictures slideshow for current playing artist\n* Added Broadcast feature\n* Added Channel feature with Icecast compatibility\n* Replaced Muses Radio Player by jPlayer to keep one web player for all\n* Added missing artists in similar artists for Wanted feature\n* Added concerts information from LastFM\n* Added tabs on artist information\n* Added 'add to playlist' direct button on browse items\n* Added avatar on users and Gravatar/Libravatar plugins\n* Fixed playlist visibility (reported by stonie08)\n* Added OpenID authentication\n* Fixed m3u import to playlist on catalog creation (reported by jaydoes)\n* Improved missing/wanted albums with the capability to browse missing artists\n* Added share feature\n* Updated French translation\n* Added options per browse view (alphabetic, infinite scroll, number of items per page...)\n* Fixed several Subsonic players (SubHub, Jamstash...)\n* Added option to get beautiful stream url with url rewriting\n* Added check to use a new thread for scrobbling if available\n* Added confirmation option when closing the currently playing web player\n* Added auto-pause web player option between several browse tabs\n* Fixed similar artists list with disabled catalogs (reported by stebe)\n* Improved Shoutbox (css fix, real time notifications...)\n* Fixed iframe basket play action reload\n* Fixed wanted album auto-remove\n* Fixed MusicBrainz get album art from releases\n* Added Waveform feature on songs\n* Added AutoUpdate Ampache version check\n* Added auto-completion in global Ampache search\n* Added option to 'lock' header/sidebars UI\n* Fixed catalog export when 'All' selected\n* Fixed XBMC Local Play (reported by nakinigit)\n* Fixed artist search\n* Fixed Random Advanced (reported by stebe)\n* Changed song preview directplay icons\n* Added Headphones Automatic Music Downloader support as a 'Wanted Process' plugin\n* Updated PHPMailer to version 5.2.7\n* Updated getID3 to version 1.9.7\n* Added 'Song Preview' feature on missing albums tracks, with EchoNest api\n* Added 'Missing Albums' / 'Wanted List' feature\n* Upgraded to MusicBrainz api v2\n* Replaced Snoopy project with Requests project\n* Added user-agent on Recently Played\n* Added option to show/hide Recently Played, time and user-agent per user\n* Updated French language\n* Added option for iframe or popup web player mode\n* Improved Song/Video web player with jPlayer, Radio player with Muse Radio Player\n* Added 'add media' to the currently played playlist on web player\n* Added dedicated 'Recently Played' page\n* Added enable/disable feature on catalogs\n* Fixed Config class conflict with PEAR\n* Improved recommended artists/songs loading using ajax\n* Added a new modern 'Reborn' theme\n* Improved Subsonic api backend support (json, ...)\n* Added Plex api backend support\n* Added artist art/summary when using LastFM api\n* Added 'all' link when browsing\n* Added option to enable/disable web player technology (flash / html5)\n* Fixed artist/song edition\n* Improved tag edition\n* Added song re-order on album / playlists\n* Replaced Prototype with jQuery\n* Added 'Favorite' feature on songs/albums/artists\n* Added 'Direct Play' feature to play songs without using a playlist\n* Added Lyrics plugins (ChartLyrics and LyricWiki)\n* Fixed ShoutBox enable/disable (reported by cipriant)\n* Added SoundCloud, Dropbox, Subsonic and Google Music catalog plugins\n* Improved Catalogs using plug-ins\n* Added browse paging to all information pages\n* Fixed LDAP authentication with password containing '&' (reported by bruth2)\n* Added directories to zip archives\n* Improved project code style and added Travis builds\n* Added albums default sort preference\n* Added number of times an artist/album/song was played\n* Fixed installation process without database creation\n* Removed administrative flags\n\n## 3.6-FUTURE\n\n* Fixed issue with long session IDs that affected OS X Mavericks and possibly\n  other newer PHP installations (reported by yebo29)\n* Fixed some sort issues (patch by Afterster)\n* Fixed Fresh theme display on large screens (patch by Afterster)\n* Fixed bug that allowed guests to add radio stations\n* Added support for aacp transcoding\n* Improved storage efficiency for large browse results\n* Fixed unnecessary growth of the tmp_browse table from API usage (reported\n  by Ondalf)\n* Removed external module 'validateEmail'\n* Updated PHPMailer to 5.2.6\n\n## 3.6-alpha6 *2013-05-30*\n\n* Fixed date searches using 'before' to use the correct comparison\n  (patch by thinca)\n* Fixed long-standing issue affecting Synology users (patch by NigridsVa)\n* Added support for MySQL sockets (based on patches by randomessence)\n* Fixed some issues with the logic around memory_limit (reported by CableNinja)\n* Fixed issue that sometimes removed ratings after catalog operations (reported\n  by stebe)\n* Fixed catalog song stats (reported by stebe)\n* Fixed ACL text field length to allow entry of IPv6 addresses (reported\n  by Baggypants)\n* Fixed regression preventing the use of an existing database during\n  installation (reported by cjsmo)\n* Fixed operating on all catalogs via the web interface\n  (reported by orbisvicis)\n* Added support for nonstandard database ports\n* Updated getID3 to 1.9.5\n* Improved the performance of stream playlist creation (reported by AkbarSerad)\n* Fixed \"Pure Random\" / Random URLs (reported by mafe)\n\n## 3.6-alpha5 *2013-04-15*\n\n* Fixed persistent XSS vulnerability in user self-editing (reported by\n  Jean-Lou Hau)\n* Fixed persistent XSS vulnerabilities in AJAX object editing (reported by\n  Jean-Lou Hau)\n* Fixed character set detection for ID3v1 tags\n* Added matroska to the list of known tag types\n* Made the getID3 metadata source work better with tag types that Ampache\n  doesn't recognise\n* Switched from the deprecated mysql extension to PDO\n* stderr from the transcode command is now logged for debugging\n* Made database updates more robust and verified that a fresh ## 3.## 3.## 3.5 import\n  will run through the updates without errors\n* Added support for external authenticators like pwauth (based on a patch by\n  sjlu)\n* Renamed the local auth method to pam, which is less confusing\n* Removed the Flash player\n* Added an HTML5 player (patch by Holger Brunn)\n* Changed the way themes handle RTL languages\n* Fixed a display problem with the Penguin theme by adding a new CSS class\n  (patch by Fred Thomsen)\n* Made transcoding and its configuration more flexible\n* Made transcoded streams more standards compliant by not sending a random\n  value as the Content-Length or claiming that ranged requests are\n  supported\n* Changed rating semantics to distinguish between user ratings and the\n  global average and add the ability to search for unrated items\n  (< 1 star)\n* Updated Prototype to git HEAD (4ce0b0f)\n* Fixed bug that disclosed passwords for plugins to users that didn't\n  have access to update the password (patch by Fred Thomsen)\n* Fixed streaming on Android devices and anything else that expects to\n  be able to pass a playlist URL to an application and have it work\n* Removed the SHOUTcast Localplay controller\n\n## 3.6-Alpha4 *2012-11-27*\n\n* Removed lyric support, which was broken and ugly\n* Removed tight coupling to the PHP mysql extension\n* Fixed an issue with adding catalogs on Windows caused by inconsistent\n  behaviour of is_readable() (reported by Lockzi)\n\n## 3.6-Alpha3 *2012-10-15*\n\n* Updated getID3 to 1.9.4b1\n* Removed support for extremely old passwords\n* Playlists imported from M3U now retain their ordering\n  (patch by Florent Fourcot)\n* Removed HTML entity encoding of plaintext email (reported by USMC Guy)\n* Fixed a search issue which prevented the use of multiple tag rules\n  (reported by Istarion)\n* Fixed ASF tag parsing regression (reported by cygn)\n\n## 3.6-Alpha2 *2012-08-15*\n\n* Fixed CLI database load to work regardless of whether it's run from\n  the top-level directory (reported by porthose)\n* Fixed XML cleanup to work with newer versions of libpcre\n  (patch by Natureshadow)\n* Fixed ID3v2 disk number parsing\n* Updated getID3 to 1.9.3\n* Added php-gettext for fallback emulation when a locale (or gettext) isn't\n  supported\n* Fixed pluralisation issue in Recently Played\n* Added support for extracting MBIDs from M4A files\n* Fixed parsing of some tag types (most notably M4A)\n* Corrected PLS output to work with more players (reported by bhassel)\n* Fixed an issue with compound artists in media with MusicBrainz tags\n  (reported by greengeek)\n* Fixed an issue with filename pattern matching when patterns contained\n  characters that are part of regex syntax (such as -)\n* Fixed display of logic operator in rules (reported by Twister)\n* Fixed newsearch issue preventing use of more than 9 rules\n  (reported by Twister)\n* Fixed JSON escaping issue that broke search in some cases\n  (reported by XeeNiX)\n* Overhauled CLI tools for installation and database management\n* Fixed admin form issue (reported by the3rdbit)\n* Improved efficiency of fetching song lists via the API\n  (reported by lotan_rm)\n* Added admin_enable_required option to user registration\n* Fixed session issue preventing some users from streaming\n  (reported by miir01)\n* Quote Content-Disposition header for art, fixes Chrome issue\n  (patch by S\u00e9bastien LIENARD)\n* Fixed art URL returned via the API (patch by lotan_rm)\n* Fixed video searches (reported by mchugh19)\n* Fixed Database Upgrade issue that caused catalog user/pass for\n  remote catalogs to not be added correctly\n* Added the ability to locally cache passwords validated by external\n  means (e.g. to allow LDAP authenticated users to use the API)\n* Fixed session handling to actually use our custom handler\n  (reported by ss23)\n* Fixed Last.FM art method (reported by claudio)\n* Updated Captcha PHP to 2.3\n* Updated PHPMailer to 5.2.0\n* Fixed bug in MPD module which affected toggling random or repeat\n  (patch from jherold)\n* Properly escape config values when writing ampache.cfg.php\n* Fixed session persistence with auth disabled (reported by Nathanael\n  Anderson)\n* Fixed item count retention for Advanced Random (reported by USAF_Pride)\n* Made catalog verify respect memory_cache\n* Some catalog operations are now done in chunks, which works better on\n  large catalogs\n* API now returns year and bitrate for songs\n* Fixed search_songs API method to use Search::run properly\n* Fixed require_session when auth_type is 'local'\n* Catalog filtering fix\n* Toggle artwork with a button instead of a checkbox (patch from mywindow)\n* API handshake code cleanup, including a bugfix from postfuturist\n* Improved install process when JavaScript is disabled\n* Fixed duplicate searching even more\n* Committed minor bugfixes for Penguin theme\n* Added Fresh theme\n* Fixed spurious API handshake failure output\n\n## 3.6-Alpha1 *2011-04-27*\n\n* Fixed forced transcoding\n* Fixed display during catalog updates (reported by Demonic)\n* Fixed duplicate searching (patch from Demonic)\n* Cleaned up transcoding assumptions\n* Fixed tag browsing\n* Added new search/advanced random/dynamic playlist interface\n* byterange handling for ranges starting with 0 (patch from uberbrady)\n* Fixed issue with updating ACLs under Windows (reported by Citlali)\n* Add function that check ampache and php version from each website.\n* Updated each ampache header comment based on phpdocumentor.\n* Fixed only admin can browse phpinfo() for security reasons on /info.php\n* Added a few translation words.\n* Updated version ## 3.6 on docs/*\n* Implemented ldap_require group (patch from eliasp)\n* Fix \\ in web path under Apache + Windows Bug #135\n* Partial MusicBrainz metadata gathering via plugin\n* Metadata code cleanup, support for plugins as metadata sources\n* New plugin architecture\n* Fixed display charset issue with catalog add/update\n* Fixed handling of temporary playlists with >100 items\n* Changed Browse from a singleton to multiple instances\n* Fixed setting access levels for plugin passwords\n* Fixed handling of unusual characters in passwords\n* Fixed support for requesting different thumbnail sizes\n* Added ability to rate Albums of the Moment\n* Added ability to edit/delete playlists while they are displayed\n* Fix track numbers not being 0 padded when downloading or renaming.\n* Rating search now allows specification of operator (>=, <=, or =)\n  and uses the same ratings as normal display.\n* Add -t to catalog_update.inc for generating thumbnails\n* Generate Thumbnails during catalog art operations\n* Fixed transcode seeking of Flacs by switching to MM:SS format for\n  flacs being transcoded\n* Change album_art_order to art_order to reflect general nature of\n  config option\n* Fix PHP warning with IP History if no data is found.\n* Add -g flag to catalog update to allow for art gathering via cmdline\n* Change Update frequency of catalog display to 1 second rather then\n  %10 reduces cpu load due to javascript excution (Thx Dmole)\n* Add bmp to the list of allowed / supported album art types\n* Strip extranious whitespace from cmdline catalog update (Thx ascheel)\n* Fix catalog size math for catalogs up to 4TB (Thx Joost.t.Hart@planet.nl)\n* Fix httpQ not correctly skipping to new song\n* Fix refreshing of Localplay playlist when an item is skipped to\n* Fix missing Content-Disposition filename= on non-transcoded songs\n* Fix refresh of Localplay playlist when you delete a track from it\n* Added ability to add Ampache as a search descriptor (Thx Vlet)\n* Correct issue with single song downloads\n* Removed old useless files\n* Added local auth method that uses PHP's PAM module\n* Correct potential security issues due to misuse of REQUEST for write\n  operations rather then POST (Thx Raphael Geissert <geissert@debian.org>)\n* Finished switching to Dba::read() Dba::write() for database calls\n  (Thx dipsol)\n* Improved File pattern matching (Thx october.rust)\n* Updated Amazon Album art search to current Amazon API specs (Thx Vlet)\n* Fix typo that caused song count to not be set on tag xml response\n* Fix tag methods so that alpha_match and exact_match work\n* Fix limit and offset not working on search_songs API method\n* Fix import m3u on catalog build so it does something\n* Fix inconsistent view during catalog operations\n* Sort malformed files into \"Unknown (Broken)\" rather then leaving\n  them in \"Unknown (Orphaned)\"\n* Fix API democratic voting methods (Thx kindachris)\n* Add server version to API ping response\n* Fix Localplay API methods (Thx thomasa)\n* Improve bin/catalog_update.inc to allow only verify, clean or add\n  (Thx ascheel)\n* Fix issue with batch download and UNC paths (Thx greengeek)\n* Added config option to turn caching on/off, Default is off\n* Fix issue where file tag pattern was ignore if files have no tag structure\n* Add TDRC to list of parsed id3v2 tags\n* Added the rating to a single song view\n* Fix caching issue when updating ratings where they would not\n  display correctly until a page reload\n* Altered the behavior of adding to playlists so that it maintains\n  playlist order rather then using track order\n* Strip excessive \\n's from catalog_update (Thx ascheel)\n* Fix incorrect default ogg transcode target in base config file\n* Fix stream user preferences using cached system preferences\n  rather then their own\n* Fixed prevent_multiple_logins preventing all logins (Thx Hugh)\n* Added additional information to installation process\n* Fix PHP 5.3 errors (Thx momo-i)\n* Fix random methods not working for Localplay\n* Fixed extra space on prefixed albums (Thx ibizaman)\n* Add missing operator on tag and rating searches so they will\n  work with other methods (Thx kiehnet@netscape.net)\n* Add MusicBrainz MBID support to uniqly identify albums and\n  also get more album art (Thx flowerysong)\n* Fix the url to song function\n* Add full path to the files needed by the installation just to\n  make it a little clearer\n* Fixed potential endless loop with malformed genre tags in mp3s\n  (Thx Bernhard Weyrauch)\n* Fixed web path always returning false on /test.php\n* Updated Man Page to fix litian problems for Debian packaging\n* Fixed bug where video was registering as songs for now playing\n  and stats\n* Add phpmailer and change ampache.cfg.php.dist\n* Fixed manpage (Thx Porthose)\n\n## 3.5 *2009-05-05*\n\n* Added complete Czech translation (Thx martin hason)\n* Add the AlmightyOatmeal-Sanity check to prevent a clean from\n  removing all songs if your mount failed, but is still\n  readable by ampache\n* Make the Lang Install page prettier\n* Added Check for hash,inet_pton,windows PHP Version to init so\n  that upgrades without pre-reqs are handled correctly\n* Allow mms,mmsh,mmsu,mmst,rstp in Radio Stream URLs\n* Fixed a problem where after adding a track to a saved playlist\n  there was no UI response upon deleting the track without\n  a page refresh\n* Fix an issue where the full version of the album art was never\n  used even when requested\n* Fix maxlength on acl fields being to small for all IPv6 addresses\n* Add error message when file exists but is unreadable do not\n  remove unreadable songs from catalog\n* Fixed missing title tag on song browse for the title\n  (Thx flowerysong)\n* Fix htmlchar'd rss feed url\n* Fix Port not correctly being added to URL in most cases\n  even when defined in config\n\n  v.## 3.5-Beta2 04/07/2009\n* Fix ASX playlists so more data shows up in WMP (Thx Jon611)\n* Fix dynamic playlist items so they work in stream methods again\n* Fixed Recently Played so that it correctly shows unique songs\n  with the correct data\n* Fix some issues with filenames with Multi-byte characters\n  (Thx Momo-i)\n* Add WMV/MPG specific parsing functions (Thx Momo-i)\n* Add text to /test.php for hash() and SHA256() support under PHP\n  section\n* Fix SHA256 Support so that it references something that exists\n* Fix incorrect debug_event() on login due to typo\n* Remove manage democratic playlist as it has no meaning in the\n  current version\n* Run Dba::reset_db_charset() after upgrade in case people are playing\n  hot potato with their charsets.\n* Move Server Preferences to Admin menu (Thx geekdawg)\n* Fixed missing web_path reference on radio creation link\n* Fixed remote catalog_clean not working\n* Fixed xmlrpc get image. getEncoding wasn't static\n\n## 3.5-Beta1 *2009-03-15*\n\n* Add democratic methods to api, can now vote, devote, get url\n  and the current democratic playlist through the api\n* Revert to old Random Play method\n* Added proxy use for xmlrpcclient\n* Added Configuration 'Wizard' for democratic play\n* Fixed interface feedback issues with democratic play actions\n* Add extension to image urls for the API will add to others as\n  needed due to additional query requirement. Needed to fix\n  some DLNA devices\n* Fixed typo that caused the height of album art not to display\n* Modified database and added GC for tmp_browse table\n* Added get lyrics and album art using http proxy server #313 + username,\n  password patch\n* Added lyricswiki link Ticket #70\n* Updated README language\n* Updated getid3 library 2.0.0b4 to 2.0.0b5\n* Make the Democratic playlist be associated with the user\n  who sends it to a 'player'\n* Fixed missing page headers on democratic playlist\n* Show who voted for the sogns on democratic playlist\n* Increase default stream length to account for the fact that movies\n  are a good bit longer then songs\n* Correct Issues with multi-byte characters in Lyrics (Thx Momo-i)\n* Added caching to Video\n* Added Video calls to the API\n* Remove redundent code from Browse class by making it extend\n  new Query class\n* Update Prototype to 1.6.0.3\n* Add Time range to advanced search\n* Add sorting to Video Browse\n* Changed to new Query backend for Browsing and Dynamic Playlists\n\n## 3.5-Alpha2 *2009-03-08*\n\n* Fixed caching of objects with no return value\n* Fixed updating of songs that should not be updated during catalog\n  verify\n* Added default_user_level config option that allows you to define\n  the user level when use_auth is false. Also allows manual\n  login of admin users when use_auth is false.\n* Fix Version checking and Version Error Message on install (Thx Paleo)\n* Moved Statistics to main menu, split out newest/popular/stats\n* Fixed bug where saved Thumbnails were almost never used\n* Fixed Localplay httpQ and MPD controls to recognize Live Stream\n  urls.\n* Added Localplay controls to API\n* Added Added/Updated filters to API include the ability to specify\n  a date range using ISO 8601 format with [START]/[END]\n* Changed API Date format to ISO 8601\n* Fixed Incorrect Caching of Album records that caused the\n  Name + Year + Disk to not be respected\n* Added Lyrics Patch (Thx alister55 & momo-i)\n* Fixed password not updating when editing an httpQ Localplay\n  instance\n* Added Video support\n* Fixed normalize tracks not re-displaying playlist correctly\n* Fixed now playing now showing currently playing song\n* Fixed now playing clear all not correctly refreshing screen\n* Fixed adding object to playlist so that it correctly shows the\n  songs rather then an empty playlist\n* Added User Agent to IP History information gathering\n* Added Access Control List Wizards to make API interface\n  setup easier\n* Added IPv6 support for Access Control, Sessions, IP History\n* Fixed sorting issue on artist when using search method\n* Updated flash player to 5.9.5\n* Fixed bug where you admins couldn't edit preferences of\n  users due to missing 'key' on form\n* Added Mime type to Song XML\n\n## 3.5-Alpha1 *2008-12-31*\n\n* Fixed sort_files script so that it properly handles variable\n  album art file names in the directories\n* Fixed issue where small thumbnails were used for larger images\n  if gd based resizing was enabled in the config\n* Fixed catalog_update.inc so it doesn't produce errors\n* Made democratic play respect force http play\n* Make installation error messages more helpful\n* Added Swedish (sv_SE) translation (Thanks yeager)\n* Allow Add / Verify of sub directories of existing catalogs\n* Prevent an fread of 0 bytes if you seek to the end of a file\n* Added require_localnet_session config that allows you to exclude\n  IP(s) from session checks, see config.dist\n* Added Nusoap (<http://sourceforge.net/projects/nusoap/>) library\n  for use with future lyrics feature\n* Fixed problem with flash player where random urls were not being\n  added correctly\n* Fixed problem with user creation using old method (Thx Purdyk)\n* Switched to SHA256() for API and passwords\n* Added check for BADTIME error code from Last.FM and correctly\n  return the error rather then a generic one\n* Fix http auth session issues, where every request blew away the\n  old session information\n* Many other minor improvements (Thx Dipsol)\n* Fixed warnings in caching code (Thx Dipsol)\n* Massive text cleanup (Thx Dipsol)\n* Fixed tag searching and improved some other search methods to\n  prevent SQL warnings on no results\n* Improved Test page checks to more accuratly verify putENV support\n* Make network downsampling a little more sane, don't require\n  access level\n* Added caching to Playlist dropdown\n* Fixed double caching on some objects\n* Added base.css and 4 tag 'font' sizes depending on weight/count\n* Fixed inline song edit\n* Updated registration multi-byte mail.\n* Fixed vainfo.class.php didn't catch exception for first analyze.\n* Fixed iconv() returns an empty strings (Thx abs0)\n* Updated getid3 for multi-byte characters, but some wrong id3tags\n  have occurred exception error.\n* Fixed use_auth = false not correctly re-creating the session if\n  you had just switched from use_auth = true\n* Add links to RSS feeds and set default to TRUE in config.dist\n* Fixed Dynamic Random/Related URLs with players that always send\n  a byte offset (MPD)\n* Added Checkbox to use existing Database\n* Updated language code and Fixed catalan language code\n* Added Emulate gettext() from upgradephp-15\n  (<http://freshmeat.net/p/upgradephp>)\n* Fixed Test.php parse error.\n* Updated multibyte character strings mail.\n* Fixed To send mail don't remove the last comma from recipient.\n* Updated More translatable templates.\n* Removed merge-messages.sh and Add LANGLIST (each languages\n  translation statistics).\n* Fixed If database name don't named ampache, can't renamed tags\n  to tag.\n* Fixed count issue on browse Artists (Thx Sylvander)\n* Fixed prevent_multiple_logins, preventing all logins (Thx hugh)\n* Fixed Export catalog headers so it corretly prompts you to download\n  the file\n* Add ability to sort by artist name, album name on song browse\n* Implemented caching on artist and album browse, added total\n  artist time to the many artist view\n* Fixed test config page so it bounces you back to the test page\n  if the config starts parsing correctly\n* Fixed browsing so that you can browse two different types in two\n  windows at the same time\n* Improved gather script for translations (Thx momo-i)\n* Added paging to the Localplay playlist\n* Updated German Translation (Thx Laurent)\n* Fixed issue where Remote songs would never be removed from\n  the democratic playlist\n* Fixed issue where user preferences weren't set correctly\n  on stream (Thx lorijho)\n* Added caching of user preferences to avoid a SQL query on load\n  (Thx Protagonist)\n* Fixed home menu not always displaying the entire contents\n* Fixed logic error with duplicate login setting which caused it\n  to only work if mysql auth was used\n* Changed passwords to SHA1 will prompt to reset password\n* Corrected some translation strings and added jp_JP (Thx momo-i)\n* Ignore filenames that start with . (hidden) solves an issue\n  with mac filesystems\n* Fix tracking of stats for downloaded songs\n* Fix divide by 0 error during transcode in some configurations\n* Remove root mysql pw requirement from installer\n* Added Image Dimensions on Find Album Art page\n* Added Confirmation Screen to Catalog Deletion\n* Reorganized Menu System and Added Modules section\n* Fix an error if you try to add a shoutbox for an invalid object\n  (Thx atrophic)\n* Fixed issue with art dump on jpeg files (Thx atrophic)\n* Fixed issue with force http play and port not correctly specifying\n  non-standard http port (Thx Deathcrow)\n* Remember Starts With value even if you switch tabs\n* Fixed rating caching so it actually completely works now\n* Removed redundent UPDATE on session table due to /util.php\n* Added Batch Download to single Artist view\n* Added back in the direct links on songs, requires download set\n  to enabled as it's essentially the same thing except with\n  now playing information tied to it\n* Bumped API Version to 350001 and require that a version is sent\n  with handshake to indicate the application will work\n* Removed the MyStrands plugin as did not provide good data, and does\n  not appear to have been used\n* Added Catalog Prefix config option used to determine which prefixes\n  should not be used for sorting\n* Merged Browse Menu with Home\n* Added checkbox to single artist view allowing you to enable/disable\n  album art thumbnails on albums of said artist\n* Added timeout override on update_single_item because the function\n  is a lie\n* Fix translations so it's not all german\n* Genre Tag is now used as a 'Tag', Browse Genre removed\n* Ignore getid3() iconv stuff doesn't seem to work\n* Improved fix_filenames.inc, tries a translation first then strips\n  invalid characters\n* Fixed album art not clearing thumbnail correctly on gather\n* Fixed Localplay instance not displaying correctly after change\n  until a page refresh\n* Fixed endless loop on index if you haven't played a song in\n  over two years\n* Fixed gather art and parse m3u not working on catalog create\n  also added URL read support to m3u import\n* Upped Minimum requirements to Mysql 5.x\n* Add codeunde1load's Web 2.0 style tag patch\n* Fixed typo in e-mail From: name (Thx Xgizzmo)\n* Fixed typo in browse auto_init() which could cause ampache to not\n  remember your start point in some situations. (Thx Xgizzmo)\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Repository\\Model\\Art;\nuse Ampache\\Repository\\Model\\Artist;\nuse Ampache\\Module\\Util\\Ui;\n\n/** @var Artist $artist */\n/** @var array $biography */\n\n?>\n\n<div class=\"item_info\">\n    <?php if ($artist instanceof Artist) {\n    $thumb = (empty(trim($biography['summary'] ?? ''))) ? 32 : 2;\n    Art::display('artist', $artist->id, scrub_out($artist->get_fullname() ?? $artist->name), $thumb);\n} ?>\n    <div class=\"item_properties\">\n        <?php $dcol = array();\n        if (array_key_exists('placeformed', $biography) && !empty($biography['placeformed'])) {\n            $dcol[] = $biography['placeformed'];\n        }\n        if (array_key_exists('yearformed', $biography) && (int)$biography['yearformed'] > 0) {\n            $dcol[] = $biography['yearformed'];\n        }\n        if (count($dcol) > 0) {\n            echo implode(', ', $dcol);\n        } ?>\n    </div>\n</div>\n<div id=\"item_summary\">\n    <?php if (array_key_exists('summary', $biography) && !empty(trim($biography['summary']))) { ?>\n        <?php echo nl2br($biography['summary']); ?>\n        <?php\n    }?>\n</div>\n<script>\n    $(document).ready(function(){\n        $(\"a[rel^='prettyPhoto']\").prettyPhoto({social_tools:false});\n    });\n</script>", "-- GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n-- Copyright 2001 - 2022 Ampache.org\n--\n-- This program is free software: you can redistribute it and/or modify\n-- it under the terms of the GNU Affero General Public License as published by\n-- the Free Software Foundation, either version 3 of the License, or\n-- (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-- GNU Affero General Public License for more details.\n--\n-- You should have received a copy of the GNU Affero General Public License\n-- along with this program.  If not, see <https://www.gnu.org/licenses/>.\n-- phpMyAdmin SQL Dump\n-- version 5.1.3\n-- https://www.phpmyadmin.net/\n--\n-- Host: 192.168.1.20\n-- Generation Time: Nov 19, 2022 at 05:49 PM\n-- Server version: 10.5.15-MariaDB-0+deb11u1\n-- PHP Version: 8.1.11\n\nSET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\";\nSET AUTOCOMMIT = 0;\nSTART TRANSACTION;\nSET time_zone = \"+00:00\";\n\n\n/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;\n/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;\n/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;\n/*!40101 SET NAMES utf8mb4 */;\n\n--\n-- Database: `ampache554`\n--\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `access_list`\n--\n\nDROP TABLE IF EXISTS `access_list`;\nCREATE TABLE IF NOT EXISTS `access_list` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `start` varbinary(255) NOT NULL,\n  `end` varbinary(255) NOT NULL,\n  `level` smallint(3) UNSIGNED NOT NULL DEFAULT 5,\n  `type` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `user` int(11) NOT NULL,\n  `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 1,\n  PRIMARY KEY (`id`),\n  KEY `start` (`start`),\n  KEY `end` (`end`),\n  KEY `level` (`level`),\n  KEY `enabled` (`enabled`)\n) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `access_list`\n--\n\nINSERT INTO `access_list` (`id`, `name`, `start`, `end`, `level`, `type`, `user`, `enabled`) VALUES\n(1, 'DEFAULTv4', 0x00000000, 0xffffffff, 75, 'interface', -1, 1),\n(2, 'DEFAULTv4', 0x00000000, 0xffffffff, 75, 'stream', -1, 1),\n(3, 'DEFAULTv4', 0x00000000, 0xffffffff, 75, 'rpc', -1, 1),\n(4, 'DEFAULTv6', 0x00000000000000000000000000000000, 0xffffffffffffffff, 75, 'interface', -1, 1),\n(5, 'DEFAULTv6', 0x00000000000000000000000000000000, 0xffffffffffffffff, 75, 'stream', -1, 1),\n(6, 'DEFAULTv6', 0x00000000000000000000000000000000, 0xffffffffffffffff, 75, 'rpc', -1, 1);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `album`\n--\n\nDROP TABLE IF EXISTS `album`;\nCREATE TABLE IF NOT EXISTS `album` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `prefix` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `year` int(4) UNSIGNED NOT NULL DEFAULT 1984,\n  `disk` smallint(5) UNSIGNED DEFAULT NULL,\n  `mbid_group` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `release_type` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `album_artist` int(11) UNSIGNED DEFAULT NULL,\n  `original_year` int(4) DEFAULT NULL,\n  `barcode` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog_number` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `time` bigint(20) UNSIGNED DEFAULT NULL,\n  `release_status` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `addition_time` int(11) UNSIGNED DEFAULT 0,\n  `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `song_count` smallint(5) UNSIGNED DEFAULT 0,\n  `artist_count` smallint(5) UNSIGNED DEFAULT 0,\n  `song_artist_count` smallint(5) UNSIGNED DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `name` (`name`),\n  KEY `year` (`year`),\n  KEY `disk` (`disk`),\n  KEY `catalog_IDX` (`catalog`) USING BTREE,\n  KEY `album_artist_IDX` (`album_artist`) USING BTREE,\n  KEY `original_year_IDX` (`original_year`) USING BTREE,\n  KEY `release_type_IDX` (`release_type`) USING BTREE,\n  KEY `release_status_IDX` (`release_status`) USING BTREE,\n  KEY `mbid_IDX` (`mbid`) USING BTREE,\n  KEY `mbid_group_IDX` (`mbid_group`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `album_map`\n--\n\nDROP TABLE IF EXISTS `album_map`;\nCREATE TABLE IF NOT EXISTS `album_map` (\n  `album_id` int(11) UNSIGNED NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(16) COLLATE utf8_unicode_ci DEFAULT NULL,\n  UNIQUE KEY `unique_album_map` (`object_id`,`object_type`,`album_id`),\n  KEY `object_id_index` (`object_id`),\n  KEY `album_id_type_index` (`album_id`,`object_type`),\n  KEY `object_id_type_index` (`object_id`,`object_type`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `artist`\n--\n\nDROP TABLE IF EXISTS `artist`;\nCREATE TABLE IF NOT EXISTS `artist` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `prefix` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `summary` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `placeformed` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `yearformed` int(4) DEFAULT NULL,\n  `last_update` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `user` int(11) DEFAULT NULL,\n  `manual_update` smallint(1) DEFAULT 0,\n  `time` int(11) UNSIGNED DEFAULT NULL,\n  `song_count` smallint(5) UNSIGNED DEFAULT 0,\n  `album_count` smallint(5) UNSIGNED DEFAULT 0,\n  `album_group_count` smallint(5) UNSIGNED DEFAULT 0,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `artist_map`\n--\n\nDROP TABLE IF EXISTS `artist_map`;\nCREATE TABLE IF NOT EXISTS `artist_map` (\n  `artist_id` int(11) UNSIGNED NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(16) COLLATE utf8_unicode_ci DEFAULT NULL,\n  UNIQUE KEY `unique_artist_map` (`object_id`,`object_type`,`artist_id`),\n  KEY `object_id_index` (`object_id`),\n  KEY `artist_id_index` (`artist_id`),\n  KEY `artist_id_type_index` (`artist_id`,`object_type`),\n  KEY `object_id_type_index` (`object_id`,`object_type`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `bookmark`\n--\n\nDROP TABLE IF EXISTS `bookmark`;\nCREATE TABLE IF NOT EXISTS `bookmark` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `position` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `comment` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `object_type` varchar(64) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `creation_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `update_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `broadcast`\n--\n\nDROP TABLE IF EXISTS `broadcast`;\nCREATE TABLE IF NOT EXISTS `broadcast` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) UNSIGNED NOT NULL,\n  `name` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `is_private` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `song` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `started` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `listeners` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `key` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `cache_object_count`\n--\n\nDROP TABLE IF EXISTS `cache_object_count`;\nCREATE TABLE IF NOT EXISTS `cache_object_count` (\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  `count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `threshold` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  PRIMARY KEY (`object_id`,`object_type`,`threshold`,`count_type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `cache_object_count_run`\n--\n\nDROP TABLE IF EXISTS `cache_object_count_run`;\nCREATE TABLE IF NOT EXISTS `cache_object_count_run` (\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  `count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `threshold` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  PRIMARY KEY (`object_id`,`object_type`,`threshold`,`count_type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog`\n--\n\nDROP TABLE IF EXISTS `catalog`;\nCREATE TABLE IF NOT EXISTS `catalog` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `catalog_type` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `last_update` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `last_clean` int(11) UNSIGNED DEFAULT NULL,\n  `last_add` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 1,\n  `rename_pattern` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `sort_pattern` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `gather_types` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `enabled` (`enabled`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog_filter_group`\n--\n\nDROP TABLE IF EXISTS `catalog_filter_group`;\nCREATE TABLE IF NOT EXISTS `catalog_filter_group` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog_filter_group_map`\n--\n\nDROP TABLE IF EXISTS `catalog_filter_group_map`;\nCREATE TABLE IF NOT EXISTS `catalog_filter_group_map` (\n  `group_id` int(11) UNSIGNED NOT NULL,\n  `catalog_id` int(11) UNSIGNED NOT NULL,\n  `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  UNIQUE KEY `group_id` (`group_id`,`catalog_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog_local`\n--\n\nDROP TABLE IF EXISTS `catalog_local`;\nCREATE TABLE IF NOT EXISTS `catalog_local` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `path` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog_map`\n--\n\nDROP TABLE IF EXISTS `catalog_map`;\nCREATE TABLE IF NOT EXISTS `catalog_map` (\n  `catalog_id` int(11) UNSIGNED NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  UNIQUE KEY `unique_catalog_map` (`object_id`,`object_type`,`catalog_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog_remote`\n--\n\nDROP TABLE IF EXISTS `catalog_remote`;\nCREATE TABLE IF NOT EXISTS `catalog_remote` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `uri` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `password` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `channel`\n--\n\nDROP TABLE IF EXISTS `channel`;\nCREATE TABLE IF NOT EXISTS `channel` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `url` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `interface` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `port` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `fixed_endpoint` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `is_private` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `random` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `loop` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `admin_password` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `start_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `max_listeners` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `peak_listeners` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `listeners` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `connections` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `stream_type` varchar(8) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `bitrate` int(11) UNSIGNED NOT NULL DEFAULT 128,\n  `pid` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `clip`\n--\n\nDROP TABLE IF EXISTS `clip`;\nCREATE TABLE IF NOT EXISTS `clip` (\n  `id` int(11) UNSIGNED NOT NULL,\n  `artist` int(11) DEFAULT NULL,\n  `song` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `daap_session`\n--\n\nDROP TABLE IF EXISTS `daap_session`;\nCREATE TABLE IF NOT EXISTS `daap_session` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `creationdate` int(11) UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `deleted_podcast_episode`\n--\n\nDROP TABLE IF EXISTS `deleted_podcast_episode`;\nCREATE TABLE IF NOT EXISTS `deleted_podcast_episode` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `addition_time` int(11) UNSIGNED NOT NULL,\n  `delete_time` int(11) UNSIGNED NOT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) UNSIGNED NOT NULL,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `podcast` int(11) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `deleted_song`\n--\n\nDROP TABLE IF EXISTS `deleted_song`;\nCREATE TABLE IF NOT EXISTS `deleted_song` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `addition_time` int(11) UNSIGNED DEFAULT 0,\n  `delete_time` int(11) UNSIGNED DEFAULT 0,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `update_time` int(11) UNSIGNED DEFAULT 0,\n  `album` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `artist` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `deleted_video`\n--\n\nDROP TABLE IF EXISTS `deleted_video`;\nCREATE TABLE IF NOT EXISTS `deleted_video` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `addition_time` int(11) UNSIGNED NOT NULL,\n  `delete_time` int(11) UNSIGNED NOT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) UNSIGNED NOT NULL,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `democratic`\n--\n\nDROP TABLE IF EXISTS `democratic`;\nCREATE TABLE IF NOT EXISTS `democratic` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `cooldown` int(11) UNSIGNED DEFAULT NULL,\n  `level` tinyint(4) UNSIGNED NOT NULL DEFAULT 25,\n  `user` int(11) NOT NULL,\n  `primary` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `base_playlist` int(11) UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `level` (`level`),\n  KEY `primary_2` (`primary`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `image`\n--\n\nDROP TABLE IF EXISTS `image`;\nCREATE TABLE IF NOT EXISTS `image` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `image` mediumblob DEFAULT NULL,\n  `width` int(4) UNSIGNED DEFAULT 0,\n  `height` int(4) UNSIGNED DEFAULT 0,\n  `mime` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `size` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `object_type` varchar(64) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `kind` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `object_type` (`object_type`),\n  KEY `object_id` (`object_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `ip_history`\n--\n\nDROP TABLE IF EXISTS `ip_history`;\nCREATE TABLE IF NOT EXISTS `ip_history` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `ip` varbinary(255) DEFAULT NULL,\n  `date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `agent` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`user`),\n  KEY `date` (`date`),\n  KEY `ip` (`ip`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `label`\n--\n\nDROP TABLE IF EXISTS `label`;\nCREATE TABLE IF NOT EXISTS `label` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `category` varchar(40) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `summary` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `address` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `email` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `website` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `user` int(11) UNSIGNED DEFAULT NULL,\n  `creation_date` int(11) UNSIGNED DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `country` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `active` tinyint(1) UNSIGNED NOT NULL DEFAULT 1,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `label_asso`\n--\n\nDROP TABLE IF EXISTS `label_asso`;\nCREATE TABLE IF NOT EXISTS `label_asso` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `label` int(11) UNSIGNED NOT NULL,\n  `artist` int(11) UNSIGNED NOT NULL,\n  `creation_date` int(11) UNSIGNED DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `license`\n--\n\nDROP TABLE IF EXISTS `license`;\nCREATE TABLE IF NOT EXISTS `license` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `external_link` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `license`\n--\n\nINSERT INTO `license` (`id`, `name`, `description`, `external_link`) VALUES\n(1, '0 - default', NULL, ''),\n(2, 'CC BY', NULL, 'https://creativecommons.org/licenses/by/3.0/'),\n(3, 'CC BY NC', NULL, 'https://creativecommons.org/licenses/by-nc/3.0/'),\n(4, 'CC BY NC ND', NULL, 'https://creativecommons.org/licenses/by-nc-nd/3.0/'),\n(5, 'CC BY NC SA', NULL, 'https://creativecommons.org/licenses/by-nc-sa/3.0/'),\n(6, 'CC BY ND', NULL, 'https://creativecommons.org/licenses/by-nd/3.0/'),\n(7, 'CC BY SA', NULL, 'https://creativecommons.org/licenses/by-sa/3.0/'),\n(8, 'Licence Art Libre', NULL, 'http://artlibre.org/licence/lal/'),\n(9, 'Yellow OpenMusic', NULL, 'http://openmusic.linuxtag.org/yellow.html'),\n(10, 'Green OpenMusic', NULL, 'http://openmusic.linuxtag.org/green.html'),\n(11, 'Gnu GPL Art', NULL, 'http://gnuart.org/english/gnugpl.html'),\n(12, 'WTFPL', NULL, 'https://en.wikipedia.org/wiki/WTFPL'),\n(13, 'FMPL', NULL, 'http://www.fmpl.org/fmpl.html'),\n(14, 'C Reaction', NULL, 'http://morne.free.fr/Necktar7/creaction.htm');\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `live_stream`\n--\n\nDROP TABLE IF EXISTS `live_stream`;\nCREATE TABLE IF NOT EXISTS `live_stream` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `site_url` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `url` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `genre` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `codec` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `catalog` (`catalog`),\n  KEY `genre` (`genre`),\n  KEY `name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `localplay_httpq`\n--\n\nDROP TABLE IF EXISTS `localplay_httpq`;\nCREATE TABLE IF NOT EXISTS `localplay_httpq` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `owner` int(11) NOT NULL,\n  `host` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `port` int(11) UNSIGNED NOT NULL,\n  `password` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `access` smallint(4) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `localplay_mpd`\n--\n\nDROP TABLE IF EXISTS `localplay_mpd`;\nCREATE TABLE IF NOT EXISTS `localplay_mpd` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `owner` int(11) NOT NULL,\n  `host` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `port` int(11) UNSIGNED NOT NULL DEFAULT 6600,\n  `password` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `access` smallint(4) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `metadata`\n--\n\nDROP TABLE IF EXISTS `metadata`;\nCREATE TABLE IF NOT EXISTS `metadata` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `field` int(11) UNSIGNED NOT NULL,\n  `data` text COLLATE utf8mb4_unicode_ci NOT NULL,\n  `type` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `field` (`field`),\n  KEY `object_id` (`object_id`),\n  KEY `type` (`type`),\n  KEY `objecttype` (`object_id`,`type`),\n  KEY `objectfield` (`object_id`,`field`,`type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `metadata_field`\n--\n\nDROP TABLE IF EXISTS `metadata_field`;\nCREATE TABLE IF NOT EXISTS `metadata_field` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `public` tinyint(1) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `movie`\n--\n\nDROP TABLE IF EXISTS `movie`;\nCREATE TABLE IF NOT EXISTS `movie` (\n  `id` int(11) UNSIGNED NOT NULL,\n  `original_name` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `summary` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `year` int(11) UNSIGNED DEFAULT NULL,\n  `prefix` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `now_playing`\n--\n\nDROP TABLE IF EXISTS `now_playing`;\nCREATE TABLE IF NOT EXISTS `now_playing` (\n  `id` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `user` int(11) NOT NULL,\n  `expire` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `insertion` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `expire` (`expire`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `object_count`\n--\n\nDROP TABLE IF EXISTS `object_count`;\nCREATE TABLE IF NOT EXISTS `object_count` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `user` int(11) NOT NULL,\n  `agent` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `geo_latitude` decimal(10,6) DEFAULT NULL,\n  `geo_longitude` decimal(10,6) DEFAULT NULL,\n  `geo_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `object_count_UNIQUE_IDX` (`object_type`,`object_id`,`date`,`user`,`agent`,`count_type`) USING BTREE,\n  KEY `object_type` (`object_type`),\n  KEY `object_id` (`object_id`),\n  KEY `userid` (`user`),\n  KEY `date` (`date`),\n  KEY `object_count_full_index` (`object_type`,`object_id`,`date`,`user`,`agent`,`count_type`) USING BTREE,\n  KEY `object_count_type_IDX` (`object_type`,`object_id`) USING BTREE,\n  KEY `object_count_date_IDX` (`date`,`count_type`) USING BTREE,\n  KEY `object_count_user_IDX` (`object_type`,`object_id`,`user`,`count_type`) USING BTREE,\n  KEY `object_type_date_IDX` (`object_type`,`date`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `personal_video`\n--\n\nDROP TABLE IF EXISTS `personal_video`;\nCREATE TABLE IF NOT EXISTS `personal_video` (\n  `id` int(11) UNSIGNED NOT NULL,\n  `location` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `summary` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `player_control`\n--\n\nDROP TABLE IF EXISTS `player_control`;\nCREATE TABLE IF NOT EXISTS `player_control` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) UNSIGNED NOT NULL,\n  `cmd` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `value` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `send_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `playlist`\n--\n\nDROP TABLE IF EXISTS `playlist`;\nCREATE TABLE IF NOT EXISTS `playlist` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `user` int(11) DEFAULT NULL,\n  `type` enum('private','public') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `date` int(11) UNSIGNED NOT NULL,\n  `last_update` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `last_duration` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `name` (`name`),\n  KEY `type` (`type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `playlist_data`\n--\n\nDROP TABLE IF EXISTS `playlist_data`;\nCREATE TABLE IF NOT EXISTS `playlist_data` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `playlist` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `object_id` int(11) UNSIGNED DEFAULT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `track` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `playlist` (`playlist`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `podcast`\n--\n\nDROP TABLE IF EXISTS `podcast`;\nCREATE TABLE IF NOT EXISTS `podcast` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `feed` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) NOT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `website` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `language` varchar(5) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `copyright` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `generator` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `lastbuilddate` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `lastsync` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `episodes` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `podcast_episode`\n--\n\nDROP TABLE IF EXISTS `podcast_episode`;\nCREATE TABLE IF NOT EXISTS `podcast_episode` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `guid` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `podcast` int(11) NOT NULL,\n  `state` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `source` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `size` bigint(20) UNSIGNED NOT NULL DEFAULT 0,\n  `time` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `website` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `author` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `category` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `played` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `pubdate` int(11) UNSIGNED NOT NULL,\n  `addition_time` int(11) UNSIGNED NOT NULL,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `waveform` mediumblob DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `preference`\n--\n\nDROP TABLE IF EXISTS `preference`;\nCREATE TABLE IF NOT EXISTS `preference` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `value` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `level` int(11) UNSIGNED NOT NULL DEFAULT 100,\n  `type` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catagory` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `subcatagory` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `preference_UN` (`name`),\n  KEY `catagory` (`catagory`),\n  KEY `name` (`name`)\n) ENGINE=InnoDB AUTO_INCREMENT=176 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `preference`\n--\n\nINSERT INTO `preference` (`id`, `name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES\n(1, 'download', '1', 'Allow Downloads', 100, 'boolean', 'options', 'feature'),\n(4, 'popular_threshold', '10', 'Popular Threshold', 25, 'integer', 'interface', 'query'),\n(19, 'transcode_bitrate', '128', 'Transcode Bitrate', 25, 'string', 'streaming', 'transcoding'),\n(22, 'site_title', 'Ampache :: For the Love of Music', 'Website Title', 100, 'string', 'interface', 'custom'),\n(23, 'lock_songs', '0', 'Lock Songs', 100, 'boolean', 'system', NULL),\n(24, 'force_http_play', '0', 'Force HTTP playback regardless of port', 100, 'boolean', 'system', NULL),\n(29, 'play_type', 'web_player', 'Playback Type', 25, 'special', 'streaming', NULL),\n(31, 'lang', 'en_US', 'Language', 100, 'special', 'interface', NULL),\n(32, 'playlist_type', 'm3u', 'Playlist Type', 100, 'special', 'playlist', NULL),\n(33, 'theme_name', 'reborn', 'Theme', 0, 'special', 'interface', 'theme'),\n(40, 'localplay_level', '0', 'Localplay Access', 100, 'special', 'options', 'localplay'),\n(41, 'localplay_controller', '0', 'Localplay Type', 100, 'special', 'options', 'localplay'),\n(44, 'allow_stream_playback', '1', 'Allow Streaming', 100, 'boolean', 'options', 'feature'),\n(45, 'allow_democratic_playback', '0', 'Allow Democratic Play', 100, 'boolean', 'options', 'feature'),\n(46, 'allow_localplay_playback', '0', 'Allow Localplay Play', 100, 'boolean', 'options', 'localplay'),\n(47, 'stats_threshold', '7', 'Statistics Day Threshold', 75, 'integer', 'interface', 'query'),\n(51, 'offset_limit', '50', 'Offset Limit', 5, 'integer', 'interface', 'query'),\n(52, 'rate_limit', '8192', 'Rate Limit', 100, 'integer', 'streaming', 'transcoding'),\n(53, 'playlist_method', 'default', 'Playlist Method', 5, 'string', 'playlist', NULL),\n(55, 'transcode', 'default', 'Allow Transcoding', 25, 'string', 'streaming', 'transcoding'),\n(69, 'show_lyrics', '0', 'Show lyrics', 0, 'boolean', 'interface', 'player'),\n(70, 'mpd_active', '0', 'MPD Active Instance', 25, 'integer', 'internal', 'mpd'),\n(71, 'httpq_active', '0', 'httpQ Active Instance', 25, 'integer', 'internal', 'httpq'),\n(77, 'lastfm_grant_link', '', 'Last.FM Grant URL', 25, 'string', 'internal', 'lastfm'),\n(78, 'lastfm_challenge', '', 'Last.FM Submit Challenge', 25, 'string', 'plugins', 'lastfm'),\n(82, 'now_playing_per_user', '1', 'Now Playing filtered per user', 50, 'boolean', 'interface', 'home'),\n(83, 'album_sort', '0', 'Album - Default sort', 25, 'string', 'interface', 'library'),\n(84, 'show_played_times', '0', 'Show # played', 25, 'string', 'interface', 'browse'),\n(85, 'song_page_title', '1', 'Show current song in Web Player page title', 25, 'boolean', 'interface', 'player'),\n(86, 'subsonic_backend', '1', 'Use Subsonic backend', 100, 'boolean', 'system', 'backend'),\n(88, 'webplayer_flash', '1', 'Authorize Flash Web Player', 25, 'boolean', 'streaming', 'player'),\n(89, 'webplayer_html5', '1', 'Authorize HTML5 Web Player', 25, 'boolean', 'streaming', 'player'),\n(90, 'allow_personal_info_now', '1', 'Share Now Playing information', 25, 'boolean', 'interface', 'privacy'),\n(91, 'allow_personal_info_recent', '1', 'Share Recently Played information', 25, 'boolean', 'interface', 'privacy'),\n(92, 'allow_personal_info_time', '1', 'Share Recently Played information - Allow access to streaming date/time', 25, 'boolean', 'interface', 'privacy'),\n(93, 'allow_personal_info_agent', '1', 'Share Recently Played information - Allow access to streaming agent', 25, 'boolean', 'interface', 'privacy'),\n(94, 'ui_fixed', '0', 'Fix header position on compatible themes', 25, 'boolean', 'interface', 'theme'),\n(95, 'autoupdate', '1', 'Check for Ampache updates automatically', 25, 'boolean', 'system', 'update'),\n(96, 'autoupdate_lastcheck', '', 'AutoUpdate last check time', 25, 'string', 'internal', 'update'),\n(97, 'autoupdate_lastversion', '', 'AutoUpdate last version from last check', 25, 'string', 'internal', 'update'),\n(98, 'autoupdate_lastversion_new', '', 'AutoUpdate last version from last check is newer', 25, 'boolean', 'internal', 'update'),\n(99, 'webplayer_confirmclose', '0', 'Confirmation when closing current playing window', 25, 'boolean', 'interface', 'player'),\n(100, 'webplayer_pausetabs', '1', 'Auto-pause between tabs', 25, 'boolean', 'interface', 'player'),\n(101, 'stream_beautiful_url', '0', 'Enable URL Rewriting', 100, 'boolean', 'streaming', NULL),\n(102, 'share', '0', 'Allow Share', 100, 'boolean', 'options', 'feature'),\n(103, 'share_expire', '7', 'Share links default expiration days (0=never)', 100, 'integer', 'system', 'share'),\n(104, 'slideshow_time', '0', 'Artist slideshow inactivity time', 25, 'integer', 'interface', 'player'),\n(105, 'broadcast_by_default', '0', 'Broadcast web player by default', 25, 'boolean', 'streaming', 'player'),\n(108, 'album_group', '1', 'Album - Group multiple disks', 25, 'boolean', 'interface', 'library'),\n(109, 'topmenu', '0', 'Top menu', 25, 'boolean', 'interface', 'theme'),\n(110, 'demo_clear_sessions', '0', 'Democratic - Clear votes for expired user sessions', 25, 'boolean', 'playlist', NULL),\n(111, 'show_donate', '1', 'Show donate button in footer', 25, 'boolean', 'interface', NULL),\n(112, 'upload_catalog', '-1', 'Destination catalog', 75, 'integer', 'system', 'upload'),\n(113, 'allow_upload', '0', 'Allow user uploads', 75, 'boolean', 'system', 'upload'),\n(114, 'upload_subdir', '1', 'Create a subdirectory per user', 75, 'boolean', 'system', 'upload'),\n(115, 'upload_user_artist', '0', 'Consider the user sender as the track\\'s artist', 75, 'boolean', 'system', 'upload'),\n(116, 'upload_script', '', 'Post-upload script (current directory = upload target directory)', 75, 'string', 'system', 'upload'),\n(117, 'upload_allow_edit', '1', 'Allow users to edit uploaded songs', 75, 'boolean', 'system', 'upload'),\n(118, 'daap_backend', '0', 'Use DAAP backend', 100, 'boolean', 'system', 'backend'),\n(119, 'daap_pass', '', 'DAAP backend password', 100, 'string', 'system', 'backend'),\n(120, 'upnp_backend', '0', 'Use UPnP backend', 100, 'boolean', 'system', 'backend'),\n(121, 'allow_video', '0', 'Allow Video Features', 75, 'integer', 'options', 'feature'),\n(122, 'album_release_type', '1', 'Album - Group per release type', 25, 'boolean', 'interface', 'library'),\n(123, 'ajax_load', '1', 'Ajax page load', 25, 'boolean', 'interface', NULL),\n(124, 'direct_play_limit', '0', 'Limit direct play to maximum media count', 25, 'integer', 'interface', 'player'),\n(125, 'home_moment_albums', '1', 'Show Albums of the Moment', 25, 'integer', 'interface', 'home'),\n(126, 'home_moment_videos', '0', 'Show Videos of the Moment', 25, 'integer', 'interface', 'home'),\n(127, 'home_recently_played', '1', 'Show Recently Played', 25, 'integer', 'interface', 'home'),\n(128, 'home_now_playing', '1', 'Show Now Playing', 25, 'integer', 'interface', 'home'),\n(129, 'custom_logo', '', 'Custom URL - Logo', 25, 'string', 'interface', 'custom'),\n(130, 'album_release_type_sort', 'album,ep,live,single', 'Album - Group per release type sort', 25, 'string', 'interface', 'library'),\n(131, 'browser_notify', '1', 'Web Player browser notifications', 25, 'integer', 'interface', 'notification'),\n(132, 'browser_notify_timeout', '10', 'Web Player browser notifications timeout (seconds)', 25, 'integer', 'interface', 'notification'),\n(133, 'geolocation', '0', 'Allow Geolocation', 25, 'integer', 'options', 'feature'),\n(134, 'webplayer_aurora', '1', 'Authorize JavaScript decoder (Aurora.js) in Web Player', 25, 'boolean', 'streaming', 'player'),\n(135, 'upload_allow_remove', '1', 'Allow users to remove uploaded songs', 75, 'boolean', 'system', 'upload'),\n(136, 'custom_login_logo', '', 'Custom URL - Login page logo', 75, 'string', 'interface', 'custom'),\n(137, 'custom_favicon', '', 'Custom URL - Favicon', 75, 'string', 'interface', 'custom'),\n(138, 'custom_text_footer', '', 'Custom text footer', 75, 'string', 'interface', 'custom'),\n(139, 'webdav_backend', '0', 'Use WebDAV backend', 100, 'boolean', 'system', 'backend'),\n(140, 'notify_email', '0', 'Allow E-mail notifications', 25, 'boolean', 'options', NULL),\n(141, 'theme_color', 'dark', 'Theme color', 0, 'special', 'interface', 'theme'),\n(142, 'disabled_custom_metadata_fields', '', 'Custom metadata - Disable these fields', 100, 'string', 'system', 'metadata'),\n(143, 'disabled_custom_metadata_fields_input', '', 'Custom metadata - Define field list', 100, 'string', 'system', 'metadata'),\n(144, 'podcast_keep', '0', '# latest episodes to keep', 100, 'integer', 'system', 'podcast'),\n(145, 'podcast_new_download', '0', '# episodes to download when new episodes are available', 100, 'integer', 'system', 'podcast'),\n(146, 'libitem_contextmenu', '1', 'Library item context menu', 0, 'boolean', 'interface', 'library'),\n(147, 'upload_catalog_pattern', '0', 'Rename uploaded file according to catalog pattern', 100, 'boolean', 'system', 'upload'),\n(148, 'catalog_check_duplicate', '0', 'Check library item at import time and disable duplicates', 100, 'boolean', 'system', 'catalog'),\n(149, 'browse_filter', '0', 'Show filter box on browse', 25, 'boolean', 'interface', 'browse'),\n(150, 'sidebar_light', '0', 'Light sidebar by default', 25, 'boolean', 'interface', 'theme'),\n(151, 'custom_blankalbum', '', 'Custom blank album default image', 75, 'string', 'interface', 'custom'),\n(152, 'custom_blankmovie', '', 'Custom blank video default image', 75, 'string', 'interface', 'custom'),\n(153, 'libitem_browse_alpha', '', 'Alphabet browsing by default for following library items (album,artist,...)', 75, 'string', 'interface', 'browse'),\n(154, 'show_skipped_times', '0', 'Show # skipped', 25, 'boolean', 'interface', 'browse'),\n(155, 'custom_datetime', '', 'Custom datetime', 25, 'string', 'interface', 'custom'),\n(156, 'cron_cache', '0', 'Cache computed SQL data (eg. media hits stats) using a cron', 25, 'boolean', 'system', 'catalog'),\n(157, 'unique_playlist', '0', 'Only add unique items to playlists', 25, 'boolean', 'playlist', NULL),\n(158, 'of_the_moment', '6', 'Set the amount of items Album/Video of the Moment will display', 25, 'integer', 'interface', 'home'),\n(159, 'custom_login_background', '', 'Custom URL - Login page background', 75, 'string', 'interface', 'custom'),\n(160, 'show_license', '1', 'Show License', 25, 'boolean', 'interface', 'browse'),\n(161, 'use_original_year', '0', 'Browse by Original Year for albums (falls back to Year)', 25, 'boolean', 'interface', 'browse'),\n(162, 'hide_single_artist', '0', 'Hide the Song Artist column for Albums with one Artist', 25, 'boolean', 'interface', 'browse'),\n(163, 'hide_genres', '0', 'Hide the Genre column in browse table rows', 25, 'boolean', 'interface', 'browse'),\n(164, 'subsonic_always_download', '0', 'Force Subsonic streams to download. (Enable scrobble in your client to record stats)', 25, 'boolean', 'options', 'subsonic'),\n(165, 'api_enable_3', '1', 'Allow Ampache API3 responses', 25, 'boolean', 'options', NULL),\n(166, 'api_enable_4', '1', 'Allow Ampache API4 responses', 25, 'boolean', 'options', NULL),\n(167, 'api_enable_5', '1', 'Allow Ampache API5 responses', 25, 'boolean', 'options', NULL),\n(168, 'api_force_version', '0', 'Force a specific API response no matter what version you send', 25, 'special', 'options', NULL),\n(169, 'show_playlist_username', '1', 'Show playlist owner username in titles', 25, 'boolean', 'interface', 'browse'),\n(170, 'api_hidden_playlists', '', 'Hide playlists in Subsonic and API clients that start with this string', 25, 'string', 'options', NULL),\n(171, 'api_hide_dupe_searches', '0', 'Hide smartlists that match playlist names in Subsonic and API clients', 25, 'boolean', 'options', NULL),\n(172, 'show_album_artist', '1', 'Show \\'Album Artists\\' link in the main sidebar', 25, 'boolean', 'interface', 'theme'),\n(173, 'show_artist', '0', 'Show \\'Artists\\' link in the main sidebar', 25, 'boolean', 'interface', 'theme'),\n(175, 'demo_use_search', '0', 'Democratic - Use smartlists for base playlist', 25, 'boolean', 'system', NULL);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `rating`\n--\n\nDROP TABLE IF EXISTS `rating`;\nCREATE TABLE IF NOT EXISTS `rating` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `object_type` enum('artist','album','song','stream','live_stream','video','playlist','tvshow','tvshow_season','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `rating` tinyint(4) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_rating` (`user`,`object_type`,`object_id`),\n  KEY `object_id` (`object_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `recommendation`\n--\n\nDROP TABLE IF EXISTS `recommendation`;\nCREATE TABLE IF NOT EXISTS `recommendation` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `last_update` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `recommendation_item`\n--\n\nDROP TABLE IF EXISTS `recommendation_item`;\nCREATE TABLE IF NOT EXISTS `recommendation_item` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `recommendation` int(11) UNSIGNED NOT NULL,\n  `recommendation_id` int(11) UNSIGNED DEFAULT NULL,\n  `name` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `rel` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `search`\n--\n\nDROP TABLE IF EXISTS `search`;\nCREATE TABLE IF NOT EXISTS `search` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `type` enum('private','public') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `rules` mediumtext COLLATE utf8mb4_unicode_ci NOT NULL,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `logic_operator` varchar(3) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `random` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `limit` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `last_count` int(11) DEFAULT NULL,\n  `last_duration` int(11) DEFAULT NULL,\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `search`\n--\n\nINSERT INTO `search` (`id`, `user`, `type`, `rules`, `name`, `logic_operator`, `random`, `limit`, `last_count`, `last_duration`, `username`) VALUES\n(5, -1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Artist 5*', 'AND', 0, 0, NULL, NULL, 'System'),\n(6, -1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Artist 4*', 'AND', 0, 0, NULL, NULL, 'System'),\n(7, -1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Artist 3*', 'AND', 0, 0, NULL, NULL, 'System'),\n(8, -1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Artist 2*', 'AND', 0, 0, NULL, NULL, 'System'),\n(9, -1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Artist 1*', 'AND', 0, 0, NULL, NULL, 'System'),\n(10, -1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Album 5*', 'AND', 0, 0, NULL, NULL, 'System'),\n(11, -1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Album 4*', 'AND', 0, 0, NULL, NULL, 'System'),\n(12, -1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Album 3*', 'AND', 0, 0, NULL, NULL, 'System'),\n(13, -1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Album 2*', 'AND', 0, 0, NULL, NULL, 'System'),\n(14, -1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Album 1*', 'AND', 0, 0, NULL, NULL, 'System'),\n(15, -1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Song 5*', 'AND', 0, 0, NULL, NULL, 'System'),\n(16, -1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Song 4*', 'AND', 0, 0, NULL, NULL, 'System'),\n(17, -1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Song 3*', 'AND', 0, 0, NULL, NULL, 'System'),\n(18, -1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Song 2*', 'AND', 0, 0, NULL, NULL, 'System'),\n(19, -1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Song 1*', 'AND', 0, 0, NULL, NULL, 'System');\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `session`\n--\n\nDROP TABLE IF EXISTS `session`;\nCREATE TABLE IF NOT EXISTS `session` (\n  `id` varchar(256) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `expire` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `value` longtext COLLATE utf8mb4_unicode_ci NOT NULL,\n  `ip` varbinary(255) DEFAULT NULL,\n  `type` varchar(16) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `agent` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `geo_latitude` decimal(10,6) DEFAULT NULL,\n  `geo_longitude` decimal(10,6) DEFAULT NULL,\n  `geo_name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `expire` (`expire`),\n  KEY `type` (`type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `session_remember`\n--\n\nDROP TABLE IF EXISTS `session_remember`;\nCREATE TABLE IF NOT EXISTS `session_remember` (\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  `token` varchar(32) COLLATE utf8mb4_unicode_ci NOT NULL,\n  `expire` int(11) DEFAULT NULL,\n  PRIMARY KEY (`username`,`token`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `session_stream`\n--\n\nDROP TABLE IF EXISTS `session_stream`;\nCREATE TABLE IF NOT EXISTS `session_stream` (\n  `id` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL,\n  `user` int(11) UNSIGNED NOT NULL,\n  `agent` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `expire` int(11) UNSIGNED NOT NULL,\n  `ip` varbinary(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `share`\n--\n\nDROP TABLE IF EXISTS `share`;\nCREATE TABLE IF NOT EXISTS `share` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `allow_stream` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `allow_download` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `expire_days` int(4) UNSIGNED NOT NULL DEFAULT 0,\n  `max_counter` int(4) UNSIGNED NOT NULL DEFAULT 0,\n  `secret` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `counter` int(4) UNSIGNED NOT NULL DEFAULT 0,\n  `creation_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `lastvisit_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `public_url` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `song`\n--\n\nDROP TABLE IF EXISTS `song`;\nCREATE TABLE IF NOT EXISTS `song` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `album` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `year` mediumint(4) UNSIGNED NOT NULL DEFAULT 0,\n  `artist` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `bitrate` mediumint(8) UNSIGNED NOT NULL DEFAULT 0,\n  `rate` mediumint(8) UNSIGNED NOT NULL DEFAULT 0,\n  `mode` enum('abr','vbr','cbr') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `size` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `time` smallint(5) UNSIGNED NOT NULL DEFAULT 0,\n  `track` smallint(6) DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `played` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 1,\n  `update_time` int(11) UNSIGNED DEFAULT 0,\n  `addition_time` int(11) UNSIGNED DEFAULT 0,\n  `user_upload` int(11) DEFAULT NULL,\n  `license` int(11) DEFAULT NULL,\n  `composer` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `channels` mediumint(9) DEFAULT NULL,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `album` (`album`),\n  KEY `artist` (`artist`),\n  KEY `file` (`file`(333)),\n  KEY `update_time` (`update_time`),\n  KEY `addition_time` (`addition_time`),\n  KEY `catalog` (`catalog`),\n  KEY `played` (`played`),\n  KEY `enabled` (`enabled`),\n  KEY `title_enabled_IDX` (`title`,`enabled`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `song_data`\n--\n\nDROP TABLE IF EXISTS `song_data`;\nCREATE TABLE IF NOT EXISTS `song_data` (\n  `song_id` int(11) UNSIGNED NOT NULL,\n  `comment` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `lyrics` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `label` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `language` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `waveform` mediumblob DEFAULT NULL,\n  `replaygain_track_gain` decimal(10,6) DEFAULT NULL,\n  `replaygain_track_peak` decimal(10,6) DEFAULT NULL,\n  `replaygain_album_gain` decimal(10,6) DEFAULT NULL,\n  `replaygain_album_peak` decimal(10,6) DEFAULT NULL,\n  `r128_track_gain` smallint(5) DEFAULT NULL,\n  `r128_album_gain` smallint(5) DEFAULT NULL,\n  UNIQUE KEY `song_id` (`song_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `song_preview`\n--\n\nDROP TABLE IF EXISTS `song_preview`;\nCREATE TABLE IF NOT EXISTS `song_preview` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `session` varchar(256) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `artist` int(11) DEFAULT NULL,\n  `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `album_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `disk` int(11) DEFAULT NULL,\n  `track` int(11) DEFAULT NULL,\n  `file` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `stream_playlist`\n--\n\nDROP TABLE IF EXISTS `stream_playlist`;\nCREATE TABLE IF NOT EXISTS `stream_playlist` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `sid` varchar(256) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `url` text COLLATE utf8mb4_unicode_ci NOT NULL,\n  `info_url` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `image_url` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `author` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `album` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `type` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `time` smallint(5) DEFAULT NULL,\n  `codec` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `track_num` smallint(5) DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `sid` (`sid`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tag`\n--\n\nDROP TABLE IF EXISTS `tag`;\nCREATE TABLE IF NOT EXISTS `tag` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `is_hidden` tinyint(1) NOT NULL DEFAULT 0,\n  UNIQUE KEY `name` (`name`),\n  KEY `map_id` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tag_map`\n--\n\nDROP TABLE IF EXISTS `tag_map`;\nCREATE TABLE IF NOT EXISTS `tag_map` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `tag_id` int(11) UNSIGNED NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `user` int(11) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_tag_map` (`object_id`,`object_type`,`user`,`tag_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tag_merge`\n--\n\nDROP TABLE IF EXISTS `tag_merge`;\nCREATE TABLE IF NOT EXISTS `tag_merge` (\n  `tag_id` int(11) NOT NULL,\n  `merged_to` int(11) NOT NULL,\n  PRIMARY KEY (`tag_id`,`merged_to`),\n  KEY `merged_to` (`merged_to`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tmp_browse`\n--\n\nDROP TABLE IF EXISTS `tmp_browse`;\nCREATE TABLE IF NOT EXISTS `tmp_browse` (\n  `id` int(13) NOT NULL AUTO_INCREMENT,\n  `sid` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL,\n  `data` longtext COLLATE utf8mb4_unicode_ci NOT NULL,\n  `object_data` longtext COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`sid`,`id`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tmp_playlist`\n--\n\nDROP TABLE IF EXISTS `tmp_playlist`;\nCREATE TABLE IF NOT EXISTS `tmp_playlist` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `session` varchar(256) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `type` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `session` (`session`),\n  KEY `type` (`type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tmp_playlist_data`\n--\n\nDROP TABLE IF EXISTS `tmp_playlist_data`;\nCREATE TABLE IF NOT EXISTS `tmp_playlist_data` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `tmp_playlist` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `track` int(11) UNSIGNED DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `tmp_playlist` (`tmp_playlist`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tvshow`\n--\n\nDROP TABLE IF EXISTS `tvshow`;\nCREATE TABLE IF NOT EXISTS `tvshow` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `summary` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `year` int(11) UNSIGNED DEFAULT NULL,\n  `prefix` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tvshow_episode`\n--\n\nDROP TABLE IF EXISTS `tvshow_episode`;\nCREATE TABLE IF NOT EXISTS `tvshow_episode` (\n  `id` int(11) UNSIGNED NOT NULL,\n  `original_name` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `season` int(11) UNSIGNED NOT NULL,\n  `episode_number` int(11) UNSIGNED NOT NULL,\n  `summary` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tvshow_season`\n--\n\nDROP TABLE IF EXISTS `tvshow_season`;\nCREATE TABLE IF NOT EXISTS `tvshow_season` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `season_number` int(11) UNSIGNED NOT NULL,\n  `tvshow` int(11) UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `update_info`\n--\n\nDROP TABLE IF EXISTS `update_info`;\nCREATE TABLE IF NOT EXISTS `update_info` (\n  `key` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `value` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  UNIQUE KEY `key` (`key`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `update_info`\n--\n\nINSERT INTO `update_info` (`key`, `value`) VALUES\n('db_version', '550005'),\n('Plugin_Last.FM', '000005');\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user`\n--\n\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE IF NOT EXISTS `user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `fullname` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `email` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `website` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `apikey` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `access` tinyint(4) UNSIGNED NOT NULL,\n  `disabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `last_seen` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `create_date` int(11) UNSIGNED DEFAULT NULL,\n  `validation` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `state` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `city` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `fullname_public` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `rsstoken` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `catalog_filter_group` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `username` (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_activity`\n--\n\nDROP TABLE IF EXISTS `user_activity`;\nCREATE TABLE IF NOT EXISTS `user_activity` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) UNSIGNED NOT NULL,\n  `action` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `activity_date` int(11) UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_data`\n--\n\nDROP TABLE IF EXISTS `user_data`;\nCREATE TABLE IF NOT EXISTS `user_data` (\n  `user` int(11) DEFAULT NULL,\n  `key` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `value` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  UNIQUE KEY `unique_data` (`user`,`key`),\n  KEY `user` (`user`),\n  KEY `key` (`key`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_flag`\n--\n\nDROP TABLE IF EXISTS `user_flag`;\nCREATE TABLE IF NOT EXISTS `user_flag` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_userflag` (`user`,`object_type`,`object_id`),\n  KEY `object_id` (`object_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_follower`\n--\n\nDROP TABLE IF EXISTS `user_follower`;\nCREATE TABLE IF NOT EXISTS `user_follower` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) UNSIGNED NOT NULL,\n  `follow_user` int(11) UNSIGNED NOT NULL,\n  `follow_date` int(11) UNSIGNED DEFAULT NULL,\n  `creation_date` int(11) UNSIGNED DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_playlist`\n--\n\nDROP TABLE IF EXISTS `user_playlist`;\nCREATE TABLE IF NOT EXISTS `user_playlist` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) DEFAULT NULL,\n  `object_type` enum('song','live_stream','video','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `track` smallint(6) DEFAULT NULL,\n  `current_track` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `current_time` smallint(5) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `user` (`user`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_preference`\n--\n\nDROP TABLE IF EXISTS `user_preference`;\nCREATE TABLE IF NOT EXISTS `user_preference` (\n  `user` int(11) NOT NULL,\n  `preference` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `value` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  KEY `user` (`user`),\n  KEY `preference` (`preference`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `user_preference`\n--\n\nINSERT INTO `user_preference` (`user`, `preference`, `value`) VALUES\n(-1, 1, '1'),\n(-1, 4, '10'),\n(-1, 19, '32'),\n(-1, 22, 'Ampache :: For the Love of Music'),\n(-1, 23, '0'),\n(-1, 24, '0'),\n(-1, 41, 'mpd'),\n(-1, 29, 'web_player'),\n(-1, 31, 'en_US'),\n(-1, 32, 'm3u'),\n(-1, 33, 'reborn'),\n(-1, 51, '50'),\n(-1, 40, '100'),\n(-1, 44, '1'),\n(-1, 45, '1'),\n(-1, 46, '1'),\n(-1, 47, '7'),\n(-1, 52, '8192'),\n(-1, 53, 'default'),\n(-1, 55, 'default'),\n(-1, 69, '0'),\n(-1, 70, '0'),\n(-1, 71, '0'),\n(-1, 77, ''),\n(-1, 78, ''),\n(-1, 114, '1'),\n(-1, 113, '0'),\n(-1, 112, '-1'),\n(-1, 111, '1'),\n(-1, 110, '0'),\n(-1, 109, '0'),\n(-1, 108, '1'),\n(-1, 105, '0'),\n(-1, 104, '0'),\n(-1, 103, '7'),\n(-1, 102, '0'),\n(-1, 101, '0'),\n(-1, 100, '1'),\n(-1, 99, '0'),\n(-1, 95, '1'),\n(-1, 94, '0'),\n(-1, 93, '1'),\n(-1, 92, '1'),\n(-1, 91, '1'),\n(-1, 90, '1'),\n(-1, 89, '1'),\n(-1, 88, '1'),\n(-1, 86, '1'),\n(-1, 85, '1'),\n(-1, 84, '0'),\n(-1, 83, '0'),\n(-1, 82, '1'),\n(-1, 154, '0'),\n(-1, 116, ''),\n(-1, 117, '1'),\n(-1, 118, '0'),\n(-1, 119, ''),\n(-1, 120, '0'),\n(-1, 121, '0'),\n(-1, 122, '1'),\n(-1, 123, '1'),\n(-1, 124, '0'),\n(-1, 125, '1'),\n(-1, 126, '1'),\n(-1, 127, '1'),\n(-1, 128, '1'),\n(-1, 129, ''),\n(-1, 130, 'album,ep,live,single'),\n(-1, 131, '1'),\n(-1, 132, '10'),\n(-1, 133, '0'),\n(-1, 134, '1'),\n(-1, 135, '1'),\n(-1, 136, ''),\n(-1, 137, ''),\n(-1, 138, ''),\n(-1, 139, '0'),\n(-1, 140, '0'),\n(-1, 141, 'dark'),\n(-1, 142, ''),\n(-1, 143, ''),\n(-1, 96, ''),\n(-1, 97, ''),\n(-1, 98, ''),\n(-1, 144, '10'),\n(-1, 145, '1'),\n(-1, 146, '1'),\n(-1, 147, '0'),\n(-1, 148, '0'),\n(-1, 149, '0'),\n(-1, 150, '0'),\n(-1, 151, ''),\n(-1, 152, ''),\n(-1, 153, ''),\n(-1, 155, ''),\n(-1, 156, '0'),\n(-1, 157, ''),\n(-1, 115, '0'),\n(-1, 158, '6'),\n(-1, 159, ''),\n(-1, 160, '1'),\n(-1, 161, '0'),\n(-1, 162, '0'),\n(-1, 163, '0'),\n(-1, 164, '0'),\n(-1, 165, '1'),\n(-1, 166, '1'),\n(-1, 167, '1'),\n(-1, 168, '1'),\n(-1, 169, '0'),\n(-1, 170, '1'),\n(-1, 171, ''),\n(-1, 172, '0'),\n(-1, 173, '1'),\n(-1, 174, '0'),\n(-1, 175, '0');\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_pvmsg`\n--\n\nDROP TABLE IF EXISTS `user_pvmsg`;\nCREATE TABLE IF NOT EXISTS `user_pvmsg` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `subject` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `message` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `from_user` int(11) UNSIGNED NOT NULL,\n  `to_user` int(11) UNSIGNED NOT NULL,\n  `is_read` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `creation_date` int(11) UNSIGNED DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_shout`\n--\n\nDROP TABLE IF EXISTS `user_shout`;\nCREATE TABLE IF NOT EXISTS `user_shout` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `text` text COLLATE utf8mb4_unicode_ci NOT NULL,\n  `date` int(11) UNSIGNED NOT NULL,\n  `sticky` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `data` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `sticky` (`sticky`),\n  KEY `date` (`date`),\n  KEY `user` (`user`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_vote`\n--\n\nDROP TABLE IF EXISTS `user_vote`;\nCREATE TABLE IF NOT EXISTS `user_vote` (\n  `user` int(11) UNSIGNED NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `date` int(11) UNSIGNED NOT NULL,\n  `sid` varchar(256) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  KEY `user` (`user`),\n  KEY `object_id` (`object_id`),\n  KEY `date` (`date`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `video`\n--\n\nDROP TABLE IF EXISTS `video`;\nCREATE TABLE IF NOT EXISTS `video` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) UNSIGNED NOT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `video_codec` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `audio_codec` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `resolution_x` mediumint(8) UNSIGNED NOT NULL,\n  `resolution_y` mediumint(8) UNSIGNED NOT NULL,\n  `time` int(11) UNSIGNED NOT NULL,\n  `size` bigint(20) UNSIGNED NOT NULL,\n  `mime` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `addition_time` int(11) UNSIGNED NOT NULL,\n  `update_time` int(11) UNSIGNED DEFAULT NULL,\n  `enabled` tinyint(1) NOT NULL DEFAULT 1,\n  `played` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `release_date` int(11) DEFAULT NULL,\n  `channels` mediumint(9) DEFAULT NULL,\n  `bitrate` mediumint(8) DEFAULT NULL,\n  `video_bitrate` int(11) UNSIGNED DEFAULT NULL,\n  `display_x` mediumint(8) DEFAULT NULL,\n  `display_y` mediumint(8) DEFAULT NULL,\n  `frame_rate` float DEFAULT NULL,\n  `mode` enum('abr','vbr','cbr') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `file` (`file`(333)),\n  KEY `enabled` (`enabled`),\n  KEY `title` (`title`),\n  KEY `addition_time` (`addition_time`),\n  KEY `update_time` (`update_time`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `wanted`\n--\n\nDROP TABLE IF EXISTS `wanted`;\nCREATE TABLE IF NOT EXISTS `wanted` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `artist` int(11) DEFAULT NULL,\n  `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `year` int(4) DEFAULT NULL,\n  `date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `accepted` tinyint(1) NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_wanted` (`user`,`artist`,`mbid`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Indexes for dumped tables\n--\n\n--\n-- Indexes for table `album`\n--\nALTER TABLE `album` ADD FULLTEXT KEY `name_2` (`name`);\n\n--\n-- Indexes for table `artist`\n--\nALTER TABLE `artist` ADD FULLTEXT KEY `name_2` (`name`);\n\n--\n-- Indexes for table `song`\n--\nALTER TABLE `song` ADD FULLTEXT KEY `title` (`title`);\nCOMMIT;\n\n/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;\n/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;\n/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;\n", "<?php\n\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\Art\\Collector;\n\nuse Ampache\\Config\\ConfigContainerInterface;\nuse Ampache\\Repository\\Model\\Album;\nuse Ampache\\Repository\\Model\\Art;\nuse Ampache\\Repository\\Model\\Artist;\nuse Ampache\\Repository\\Model\\Song;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Module\\System\\AmpError;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\LegacyLogger;\nuse Ampache\\Repository\\SongRepositoryInterface;\nuse Psr\\Log\\LoggerInterface;\n\nfinal class FolderCollectorModule implements CollectorModuleInterface\n{\n    private ConfigContainerInterface $configContainer;\n\n    private LoggerInterface $logger;\n\n    private SongRepositoryInterface $songRepository;\n\n    public function __construct(\n        ConfigContainerInterface $configContainer,\n        LoggerInterface $logger,\n        SongRepositoryInterface $songRepository\n    ) {\n        $this->configContainer = $configContainer;\n        $this->logger          = $logger;\n        $this->songRepository  = $songRepository;\n    }\n\n    /**\n     * This returns the art from the folder of the files\n     * If a limit is passed or the preferred filename is found the current\n     * results set is returned\n     *\n     * @param Art $art\n     * @param integer $limit\n     * @param array $data\n     *\n     * @return array\n     */\n    public function collect(\n        Art $art,\n        int $limit = 5,\n        array $data = []\n    ): array {\n        if (!$limit) {\n            $limit = 5;\n        }\n\n        $results   = [];\n        $preferred = [];\n        // For storing which directories we've already done\n        $processed = [];\n\n        /* See if we are looking for a specific filename */\n        $preferred_filename = ($this->configContainer->get('album_art_preferred_filename')) ?: 'folder.jpg';\n        $artist_filename    = $this->configContainer->get('artist_art_preferred_filename');\n        $artist_art_folder  = $this->configContainer->get('artist_art_folder');\n\n        // Array of valid extensions\n        $image_extensions = [\n            'bmp',\n            'gif',\n            'jp2',\n            'jpeg',\n            'jpg',\n            'png'\n        ];\n\n        $dirs = array();\n        if ($art->type == 'album') {\n            $media = new Album($art->uid);\n            $songs = $this->songRepository->getByAlbum((int) $media->id);\n            foreach ($songs as $song_id) {\n                $song   = new Song($song_id);\n                $dirs[] = Core::conv_lc_file(dirname($song->file));\n            }\n        } elseif ($art->type == 'video') {\n            $media  = new Video($art->uid);\n            $dirs[] = Core::conv_lc_file(dirname($media->file));\n        } elseif ($art->type == 'artist') {\n            $media              = new Artist($art->uid);\n            $preferred_filename = str_replace(array('<', '>', '\\\\', '/'), '_', $media->get_fullname());\n            if ($artist_art_folder) {\n                $dirs[] = Core::conv_lc_file($artist_art_folder);\n            }\n            // get the folders from songs as well\n            $songs = $this->songRepository->getByArtist((int) $media->id);\n            foreach ($songs as $song_id) {\n                $song = new Song($song_id);\n                // look in the directory name of the files (e.g. /mnt/Music/%artistName%/%album%)\n                $dirs[] = Core::conv_lc_file(dirname($song->file));\n                // look one level up (e.g. /mnt/Music/%artistName%)\n                $dirs[] = Core::conv_lc_file(dirname($song->file, 2));\n            }\n        }\n\n        foreach ($dirs as $dir) {\n            if (isset($processed[$dir])) {\n                continue;\n            }\n\n            $this->logger->notice(\n                \"gather_folder: Opening $dir and checking for \" . $art->type . \" Art\",\n                [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n            );\n\n            /* Open up the directory */\n            $handle = opendir($dir);\n\n            if (!$handle) {\n                AmpError::add('general', T_('Unable to open') . ' ' . $dir);\n\n                $this->logger->warning(\n                    \"gather_folder: Opening $dir and checking for \" . $art->type . \" Art\",\n                    [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n                );\n                continue;\n            }\n\n            $processed[$dir] = true;\n\n            // Recurse through this dir and create the files array\n            while (false !== ($file = readdir($handle))) {\n                $extension = pathinfo($file);\n                $extension = $extension['extension'] ?? '';\n\n                // Make sure it looks like an image file\n                if (!in_array($extension, $image_extensions)) {\n                    continue;\n                }\n\n                $full_filename = $dir . '/' . $file;\n\n                // Make sure it's got something in it\n                if (!Core::get_filesize($full_filename)) {\n                    $this->logger->debug(\n                        \"gather_folder: Opening $dir and checking for \" . $art->type . \" Art\",\n                        [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n                    );\n                    continue;\n                }\n\n                // Regularize for mime type\n                if ($extension == 'jpg') {\n                    $extension = 'jpeg';\n                }\n\n                // Take an md5sum so we don't show duplicate files.\n                $index = md5($full_filename);\n\n                if (\n                    (\n                        $file == $preferred_filename ||\n                        pathinfo($file, PATHINFO_FILENAME) == $preferred_filename) ||\n                        (\n                            $file == $artist_filename ||\n                            pathinfo($file, PATHINFO_FILENAME) == $artist_filename\n                        )\n                ) {\n                    // We found the preferred filename and so we're done.\n                    $this->logger->debug(\n                        \"gather_folder: Found preferred image file: $file\",\n                        [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n                    );\n                    $preferred[$index] = [\n                        'file' => $full_filename,\n                        'mime' => 'image/' . $extension,\n                        'title' => 'Folder'\n                    ];\n                    break;\n                }\n                if ($art->type !== 'artist') {\n                    $this->logger->debug(\n                        \"gather_folder: Found image file: $file\",\n                        [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n                    );\n                    $results[$index] = [\n                        'file' => $full_filename,\n                        'mime' => 'image/' . $extension,\n                        'title' => 'Folder'\n                    ];\n                }\n            } // end while reading dir\n            closedir($handle);\n        } // end foreach dirs\n\n        if (!empty($preferred)) {\n            // We found our favorite filename somewhere, so we need\n            // to dump the other, less sexy ones.\n            $results = $preferred;\n        }\n\n        if ($limit && count($results) > $limit) {\n            $results = array_slice($results, 0, $limit);\n        }\n\n        return array_values($results);\n    }\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nnamespace Ampache\\Module\\Playback\\Localplay\\Mpd;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Democratic;\nuse Ampache\\Module\\Playback\\Localplay\\localplay_controller;\nuse Ampache\\Repository\\Model\\Live_Stream;\nuse Ampache\\Repository\\Model\\Preference;\nuse Ampache\\Repository\\Model\\Song;\nuse Ampache\\Module\\Playback\\Stream_Url;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\Util\\ObjectTypeToClassNameMapper;\nuse PDOStatement;\n\n/**\n * AmpacheMpd Class\n *\n * the Ampache Mpd Controller, this is the glue between\n * the MPD class and the Ampache Localplay class\n */\nclass AmpacheMpd extends localplay_controller\n{\n    /* Variables */\n    private $version     = '000003';\n    private $description = 'Controls an instance of MPD';\n\n    private $_add_count = 0;\n\n    /* Constructed variables */\n    private $_mpd;\n\n    /**\n     * get_description\n     * Returns the description\n     */\n    public function get_description()\n    {\n        return $this->description;\n    } // get_description\n\n    /**\n     * get_version\n     * This returns the version information\n     */\n    public function get_version()\n    {\n        return $this->version;\n    } // get_version\n\n    /**\n     * is_installed\n     * This returns true or false if MPD controller is installed\n     */\n    public function is_installed()\n    {\n        $sql        = \"SHOW TABLES LIKE 'localplay_mpd'\";\n        $db_results = Dba::read($sql);\n\n        return (Dba::num_rows($db_results) > 0);\n    } // is_installed\n\n    /**\n     * install\n     * This function installs the MPD Localplay controller\n     */\n    public function install()\n    {\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        /* We need to create the MPD table */\n        $sql = \"CREATE TABLE `localplay_mpd` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `name` VARCHAR(128) COLLATE $collation NOT NULL, `owner` INT(11) NOT NULL, `host` VARCHAR(255) COLLATE $collation NOT NULL, `port` INT(11) UNSIGNED NOT NULL DEFAULT '6600', `password` VARCHAR(255) COLLATE $collation NOT NULL, `access` SMALLINT(4) UNSIGNED NOT NULL DEFAULT '0') ENGINE = $engine DEFAULT CHARSET=$charset COLLATE=$collation\";\n        Dba::query($sql);\n\n        // Add an internal preference for the users current active instance\n        Preference::insert('mpd_active', T_('MPD Active Instance'), 0, 25, 'integer', 'internal', 'mpd');\n\n        return true;\n    } // install\n\n    /**\n     * uninstall\n     * This removes the Localplay controller\n     */\n    public function uninstall()\n    {\n        $sql = \"DROP TABLE `localplay_mpd`\";\n        Dba::write($sql);\n\n        Preference::delete('mpd_active');\n\n        return true;\n    } // uninstall\n\n    /**\n     * add_instance\n     * This takes key'd data and inserts a new MPD instance\n     * @param array $data\n     * @return PDOStatement|boolean\n     */\n    public function add_instance($data)\n    {\n        $sql     = \"INSERT INTO `localplay_mpd` (`name`, `host`, `port`, `password`, `owner`)  VALUES (?, ?, ?, ?, ?)\";\n        $user_id = !empty(Core::get_global('user'))\n            ? Core::get_global('user')->id\n            : -1;\n\n        return Dba::write($sql, array($data['name'] ?? null, $data['host'] ?? null, $data['port'] ?? null, $data['password'] ?? null, $user_id));\n    } // add_instance\n\n    /**\n     * delete_instance\n     * This takes a UID and deletes the instance in question\n     * @param $uid\n     * @return boolean\n     */\n    public function delete_instance($uid)\n    {\n        $uid = Dba::escape($uid);\n        $sql = \"DELETE FROM `localplay_mpd` WHERE `id`='$uid'\";\n        Dba::write($sql);\n\n        return true;\n    } // delete_instance\n\n    /**\n     * get_instances\n     * This returns a key'd array of the instance information with\n     * [UID]=>[NAME]\n     */\n    public function get_instances()\n    {\n        $sql = \"SELECT * FROM `localplay_mpd` ORDER BY `name`\";\n\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['id']] = $row['name'];\n        }\n\n        return $results;\n    } // get_instances\n\n    /**\n     * get_instance\n     * This returns the specified instance and all it's pretty variables\n     * If no instance is passed current is used\n     * @param string $instance\n     * @return array\n     */\n    public function get_instance($instance = '')\n    {\n        $instance   = (is_numeric($instance)) ? (int) $instance : (int) AmpConfig::get('mpd_active', 0);\n        $sql        = ($instance > 0) ? \"SELECT * FROM `localplay_mpd` WHERE `id`= ?\" : \"SELECT * FROM `localplay_mpd`\";\n        $db_results = ($instance > 0) ? Dba::query($sql, array($instance)) : Dba::query($sql);\n\n        return Dba::fetch_assoc($db_results);\n    } // get_instance\n\n    /**\n     * update_instance\n     * This takes an ID and an array of data and updates the instance specified\n     * @param $uid\n     * @param array $data\n     * @return boolean\n     */\n    public function update_instance($uid, $data)\n    {\n        $uid  = Dba::escape($uid);\n        $host = $data['host'] ? Dba::escape($data['host']) : '127.0.0.1';\n        $port = $data['port'] ? Dba::escape($data['port']) : '6600';\n        $name = Dba::escape($data['name']);\n        $pass = Dba::escape($data['password']);\n        $sql  = \"UPDATE `localplay_mpd` SET `host`='$host', `port`='$port', `name`='$name', `password`='$pass' WHERE `id`='$uid'\";\n        Dba::write($sql);\n\n        return true;\n    } // update_instance\n\n    /**\n     * instance_fields\n     * This returns a key'd array of [NAME]=>array([DESCRIPTION]=>VALUE,[TYPE]=>VALUE) for the\n     * fields so that we can on-the-fly generate a form\n     */\n    public function instance_fields(): array\n    {\n        $fields             = array();\n        $fields['name']     = array('description' => T_('Instance Name'), 'type' => 'text');\n        $fields['host']     = array('description' => T_('Hostname'), 'type' => 'text');\n        $fields['port']     = array('description' => T_('Port'), 'type' => 'number');\n        $fields['password'] = array('description' => T_('Password'), 'type' => 'password');\n\n        return $fields;\n    } // instance_fields\n\n    /**\n     * set_active_instance\n     * This sets the specified instance as the 'active' one\n     * @param string $uid\n     * @return boolean\n     */\n    public function set_active_instance($uid)\n    {\n        $user = Core::get_global('user');\n        if ($user == '') {\n            return false;\n        }\n        Preference::update('mpd_active', $user->id, $uid);\n        AmpConfig::set('mpd_active', $uid, true);\n        debug_event('mdp.controller', 'set_active_instance: ' . $uid . ' ' . $user->id, 5);\n\n        return true;\n    } // set_active_instance\n\n    /**\n     * get_active_instance\n     * This returns the UID of the current active instance\n     * false if none are active\n     */\n    public function get_active_instance()\n    {\n    } // get_active_instance\n\n    /**\n     * add_url\n     * This is the new hotness\n     * @param Stream_Url $url\n     * @return boolean\n     */\n    public function add_url(Stream_Url $url)\n    {\n        // If we haven't added anything then maybe we should clear the\n        // playlist.\n        if ($this->_add_count < 1) {\n            $this->_mpd->RefreshInfo();\n            if ($this->_mpd->status['state'] == mpd::STATE_STOPPED) {\n                $this->clear_playlist();\n            }\n        }\n\n        if (!$this->_mpd->PlAdd($url->url)) {\n            debug_event('mdp.controller', 'add_url failed to add: ' . json_encode($url), 1);\n\n            return false;\n        }\n\n        $this->_add_count++;\n\n        return true;\n    }\n\n    /**\n     * delete_track\n     * This must take a single ID (as returned by the get function)\n     * and delete it from the current playlist\n     * @param integer $object_id\n     * @return boolean|string\n     */\n    public function delete_track($object_id)\n    {\n        return $this->_mpd->PLRemove($object_id);\n    } // delete_track\n\n    /**\n     * clear_playlist\n     * This deletes the entire MPD playlist\n     */\n    public function clear_playlist()\n    {\n        return $this->_mpd->PLClear();\n    } // clear_playlist\n\n    /**\n     * play\n     * This just tells MPD to start playing, it does not\n     * take any arguments\n     */\n    public function play()\n    {\n        return $this->_mpd->Play();\n    } // play\n\n    /**\n     * stop\n     * This just tells MPD to stop playing, it does not take\n     * any arguments\n     */\n    public function stop()\n    {\n        return $this->_mpd->Stop();\n    } // stop\n\n    /**\n     * skip\n     * This tells MPD to skip to the specified song\n     * @param $song\n     * @return boolean\n     */\n    public function skip($song)\n    {\n        if (!$this->_mpd->SkipTo($song)) {\n            return false;\n        }\n        sleep(2);\n        $this->stop();\n        sleep(2);\n        $this->play();\n\n        return true;\n    } // skip\n\n    /**\n     * This tells MPD to increase the volume by 5\n     */\n    public function volume_up()\n    {\n        return $this->_mpd->AdjustVolume('5');\n    } // volume_up\n\n    /**\n     * This tells MPD to decrease the volume by 5\n     */\n    public function volume_down()\n    {\n        return $this->_mpd->AdjustVolume('-5');\n    } // volume_down\n\n    /**\n     * next\n     * This just tells MPD to skip to the next song\n     */\n    public function next()\n    {\n        return $this->_mpd->Next();\n    } // next\n\n    /**\n     * prev\n     * This just tells MPD to skip to the prev song\n     */\n    public function prev()\n    {\n        return $this->_mpd->Previous();\n    } // prev\n\n    /**\n     * pause\n     * This tells MPD to pause the current song\n     */\n    public function pause()\n    {\n        return $this->_mpd->Pause();\n    } // pause\n\n\n    /**\n     * volume\n     * This tells MPD to set the volume to the parameter\n     * @param $volume\n     * @return boolean|string\n     */\n    public function volume($volume)\n    {\n        return $this->_mpd->SetVolume($volume);\n    } // volume\n\n    /**\n     * repeat\n     * This tells MPD to set the repeating the playlist (i.e. loop) to either\n     * on or off.\n     * @param $state\n     * @return boolean|string\n     */\n    public function repeat($state)\n    {\n        return $this->_mpd->SetRepeat($state);\n    } // repeat\n\n    /**\n     * random\n     * This tells MPD to turn on or off the playing of songs from the\n     * playlist in random order.\n     * @param $onoff\n     * @return boolean|string\n     */\n    public function random($onoff)\n    {\n        return $this->_mpd->SetRandom($onoff);\n    } // random\n\n    /**\n     * move\n     * This tells MPD to move a song\n     * @param $source\n     * @param $destination\n     * @return boolean|string\n     */\n    public function move($source, $destination)\n    {\n        return $this->_mpd->PLMoveTrack($source, $destination);\n    } // move\n\n    /**\n     * get_songs\n     * This functions returns an array containing information about\n     * the songs that MPD currently has in its playlist. This must be\n     * done in a standardized fashion\n     * @return array\n     */\n    public function get()\n    {\n        if (!$this->_mpd || ($this->_mpd && !$this->_mpd->status)) {\n            return array();\n        }\n        // If we don't have the playlist yet, pull it\n        if (!isset($this->_mpd->playlist)) {\n            $this->_mpd->RefreshInfo();\n        }\n\n        /* Get the Current Playlist */\n        $playlist = $this->_mpd->playlist;\n        $results  = array();\n        // if there isn't anything to return don't do it\n        if (empty($playlist)) {\n            return $results;\n        }\n\n        foreach ($playlist as $entry) {\n            $data = array();\n\n            /* Required Elements */\n            $data['id']  = $entry['Pos'];\n            $data['raw'] = $entry['file'];\n\n            $url_data = $this->parse_url($entry['file']);\n            $url_key  = $url_data['primary_key'] ?? '';\n\n            switch ($url_key) {\n                case 'oid':\n                    $data['oid'] = $url_data['oid'];\n                    $song        = new Song($data['oid']);\n                    $song->format();\n                    $data['name'] = $song->get_fullname() . ' - ' . $song->f_album . ' - ' . $song->f_artist;\n                    $data['link'] = $song->get_f_link();\n                    break;\n                case 'demo_id':\n                    $democratic   = new Democratic($url_data['demo_id']);\n                    $data['name'] = T_('Democratic') . ' - ' . $democratic->name;\n                    $data['link'] = '';\n                    break;\n                case 'random':\n                    $data['name'] = T_('Random') . ' - ' . scrub_out(ucfirst($url_data['type']));\n                    $data['link'] = '';\n                    break;\n                default:\n                    // If we don't know it, look up by filename\n                    $filename = Dba::escape($entry['file']);\n                    $sql      = \"SELECT `id`, 'song' AS `type` FROM `song` WHERE `file` LIKE '%$filename' UNION ALL SELECT `id`, 'live_stream' AS `type` FROM `live_stream` WHERE `url`='$filename' \";\n\n                    $db_results = Dba::read($sql);\n                    if ($row = Dba::fetch_assoc($db_results)) {\n                        $class_name = ObjectTypeToClassNameMapper::map($row['type']);\n                        $media      = new $class_name($row['id']);\n                        $media->format();\n                        switch ($row['type']) {\n                            case 'song':\n                                $data['name'] = $media->get_fullname() . ' - ' . $media->f_album . ' - ' . $media->f_artist;\n                                $data['link'] = $media->f_link;\n                                break;\n                            case 'live_stream':\n                                /** @var Live_Stream $media */\n                                $site_url     = $media->site_url ? '(' . $media->site_url . ')' : '';\n                                $data['name'] = \"$media->name $site_url\";\n                                $data['link'] = $media->site_url;\n                                break;\n                        } // end switch on type\n                    } else {\n                        $title_string = (isset($entry['Title']) && isset($entry['Album']) && isset($entry['Artist']))\n                            ? $entry['Title'] . ' - ' . $entry['Album'] . ' - ' . $entry['Artist']\n                            : T_('Unknown');\n                        $data['name'] = $title_string;\n                        $data['link'] = '';\n                    }\n                    break;\n            } // end switch on primary key type\n\n            /* Optional Elements */\n            $data['track'] = $entry['Pos'] + 1;\n\n            $results[] = $data;\n        } // foreach playlist items\n\n        return $results;\n    } // get\n\n    /**\n     * get_status\n     * This returns bool/int values for features, loop, repeat and any other\n     * features that this Localplay method supports.\n     * @return array\n     */\n    public function status(): array\n    {\n        $array = array();\n        if (!$this->_mpd || ($this->_mpd && !$this->_mpd->status)) {\n            return $array;\n        }\n        $track = $this->_mpd->status['song'] ?? 0;\n\n        /* Construct the Array */\n        $array['state']        = $this->_mpd->status['state'];\n        $array['volume']       = $this->_mpd->status['volume'];\n        $array['repeat']       = $this->_mpd->status['repeat'];\n        $array['random']       = $this->_mpd->status['random'];\n        $array['track']        = $track + 1;\n        $array['track_title']  = '';\n        $array['track_artist'] = '';\n        $array['track_album']  = '';\n\n        $playlist_item = array();\n        $url_data      = array();\n        if (is_array($this->_mpd->playlist) && array_key_exists($track, $this->_mpd->playlist)) {\n            $playlist_item = $this->_mpd->playlist[$track];\n            $url_data      = $this->parse_url($playlist_item['file']);\n        }\n\n        debug_event('mdp.controller', 'Status result. Current song (' . $track . ') info: ' . json_encode($playlist_item), 5);\n\n        if (count($url_data) > 0 && array_key_exists('oid', $url_data) && !empty($url_data['oid'])) {\n            $song                  = new Song($url_data['oid']);\n            $array['track_title']  = $song->title;\n            $array['track_artist'] = $song->get_artist_fullname();\n            $array['track_album']  = $song->get_album_fullname();\n        } elseif (!empty($playlist_item)) {\n            if (!empty($playlist_item['Title'])) {\n                $array['track_title'] = $playlist_item['Title'];\n            } else {\n                if (!empty($playlist_item['Name'])) {\n                    $array['track_title'] = $playlist_item['Name'];\n                } else {\n                    $array['track_title'] = $playlist_item['file'] ?? '';\n                }\n            }\n            if (!empty($playlist_item['Artist'])) {\n                $array['track_artist'] = $playlist_item['Artist'];\n            }\n            if (!empty($playlist_item['Album'])) {\n                $array['track_album'] = $playlist_item['Album'];\n            }\n        }\n\n        return $array;\n    } // get_status\n\n    /**\n     * connect\n     * This functions creates the connection to MPD and returns\n     * a boolean value for the status, to save time this handle\n     * is stored in this class\n     */\n    public function connect()\n    {\n        // Look at the current instance and pull the options for said instance\n        $options = self::get_instance();\n        if (!array_key_exists('host', $options) && !array_key_exists('port', $options)) {\n            return false;\n        }\n        $this->_mpd = new mpd($options['host'], $options['port'], $options['password'] ?? '', 'debug_event');\n\n        if ($this->_mpd->connected) {\n            return true;\n        }\n\n        return false;\n    } // connect\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\Playback\\Localplay\\Upnp;\n\nuse Ampache\\Module\\System\\Session;\n\nclass UPnPDevice\n{\n    private $_settings = array(\n        \"descriptionURL\" => \"\",\n        \"host\" => \"\",\n        \"controlURLs\" => array(),\n        \"eventURLs\" => array()\n    );\n\n\n    /**\n     * UPnPDevice constructor.\n     * @param $descriptionUrl\n     */\n    public function __construct($descriptionUrl)\n    {\n        if (!$this->restoreDescriptionUrl($descriptionUrl)) {\n            $this->parseDescriptionUrl($descriptionUrl);\n        }\n    }\n\n    /**\n     * Reads description URL from session\n     * @param $descriptionUrl\n     * @return boolean\n     */\n    private function restoreDescriptionUrl($descriptionUrl)\n    {\n        debug_event('upnpdevice', 'readDescriptionUrl: ' . $descriptionUrl, 5);\n        $this->_settings = json_decode(Session::read('upnp_dev_' . $descriptionUrl), true);\n\n        if ($this->_settings && $this->_settings['descriptionURL'] == $descriptionUrl) {\n            debug_event('upnpdevice', 'service Urls restored from session.', 5);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @param $descriptionUrl\n     */\n    private function parseDescriptionUrl($descriptionUrl)\n    {\n        debug_event('upnpdevice', 'parseDescriptionUrl: ' . $descriptionUrl, 5);\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $descriptionUrl);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        $response = curl_exec($curl);\n        curl_close($curl);\n        //!!debug_event('upnpdevice', 'parseDescriptionUrl response: ' . $response, 5);\n\n        $responseXML = simplexml_load_string($response);\n        $services    = $responseXML->device->serviceList->service ?? array();\n        foreach ($services as $service) {\n            $serviceType                                      = $service->serviceType;\n            $serviceTypeNames                                 = explode(\":\", $serviceType);\n            $serviceTypeName                                  = $serviceTypeNames[3];\n            $this->_settings['controlURLs'][$serviceTypeName] = (string)$service->controlURL;\n            $this->_settings['eventURLs'][$serviceTypeName]   = (string)$service->eventSubURL;\n        }\n\n        $urldata                 = parse_url($descriptionUrl);\n        $this->_settings['host'] = $urldata['scheme'] . '://' . $urldata['host'] . ':' . $urldata['port'];\n\n        $this->_settings['descriptionURL'] = $descriptionUrl;\n\n        Session::create(array(\n            'type' => 'stream',\n            'sid' => 'upnp_dev_' . $descriptionUrl,\n            'value' => json_encode($this->_settings)\n        ));\n    }\n\n    /**\n     * Sending HTTP-Request and returns parsed response\n     *\n     * @param string $method Method name\n     * @param array $arguments Key-Value array\n     * @param string $type\n     * @return string\n     */\n    public function sendRequestToDevice($method, $arguments, $type = 'RenderingControl')\n    {\n        if (!array_key_exists('host', $this->_settings) || !array_key_exists('controlURLs', $this->_settings)) {\n            return '';\n        }\n        $body = '<?xml version=\"1.0\" encoding=\"utf-8\"?>';\n        $body .= '<s:Envelope s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\" xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\"><s:Body>';\n        $body .= '  <u:' . $method . ' xmlns:u=\"urn:schemas-upnp-org:service:' . $type . ':1\">';\n        foreach ($arguments as $arg => $value) {\n            $body .= ' <' . $arg . '>' . $value . '</' . $arg . '>';\n        }\n        $body .= '  </u:' . $method . '>';\n        $body .= '</s:Body></s:Envelope>';\n\n        $controlUrl = $this->_settings['host'] . ((substr($this->_settings['controlURLs'][$type], 0, 1) != \"/\") ? '/' : \"\") . $this->_settings['controlURLs'][$type];\n\n        //!! TODO - need to use scheme in header ??\n        $header = array(\n            'SOAPACTION: \"urn:schemas-upnp-org:service:' . $type . ':1#' . $method . '\"',\n            'CONTENT-TYPE: text/xml; charset=\"utf-8\"',\n            'HOST: ' . $this->_settings['host'],\n            'Connection: close',\n            'Content-Length: ' . mb_strlen($body),\n        );\n        //debug_event('upnpdevice', 'sendRequestToDevice Met: ' . $method . ' | ' . $controlUrl, 5);\n        //debug_event('upnpdevice', 'sendRequestToDevice Body: ' . $body, 5);\n        //debug_event('upnpdevice', 'sendRequestToDevice Hdr: ' . print_r($header, true), 5);\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $controlUrl);\n        curl_setopt($curl, CURLOPT_POST, 1);\n        curl_setopt($curl, CURLOPT_POSTFIELDS, $body);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl, CURLOPT_HEADER, true);\n        curl_setopt($curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n\n        $response = curl_exec($curl);\n        curl_close($curl);\n        //debug_event('upnpdevice', 'sendRequestToDevice response: ' . $response, 5);\n\n        $headers = array();\n        $tmp     = explode(\"\\r\\n\\r\\n\", $response);\n\n        foreach ($tmp as $key => $value) {\n            if (substr($value, 0, 8) == 'HTTP/1.1') {\n                $headers[] = $value;\n                unset($tmp[$key]);\n            }\n        }\n\n        return join(\"\\r\\n\", $tmp);\n    }\n\n    /**\n     * helper function for calls that require only an instance id\n     * @param $command\n     * @param string $type\n     * @param integer $instance_id\n     * @return string\n     */\n    public function instanceOnly($command, $type = 'AVTransport', $instance_id = 0)\n    {\n        $args = array('InstanceID' => $instance_id);\n        //$response = \\Format::forge($response, 'xml:ns')->to_array();\n        //return $response['s:Body']['u:' . $command . 'Response'];\n\n        return $this->sendRequestToDevice($command, $args, $type);\n    }\n\n    //!! UPNP subscription work not for all renderers, and works strange\n    //!! so now is not used\n    /**\n     * Subscribe\n     * Subscribe to UPnP event\n     */\n    /*\n    public function Subscribe($type = 'AVTransport')\n    {\n        $web_path = Ampache\\Config\\AmpConfig::get('web_path');\n        $eventSubsUrl = $web_path . '/upnp/play-event.php?device=' . urlencode($this->_descrUrl);\n        $eventUrl = $this->_host . $this->_eventURLs[$type];\n\n        $header = array(\n            'HOST: ' . $this->_host,\n            'CALLBACK: <' . $eventSubsUrl . '>',\n            'NT: upnp:event',\n            'TIMEOUT: Second-180',\n        );\n        debug_event('upnpdevice', 'Subscribe with: ' . print_r($header, true), 5);\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $eventUrl);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\n        curl_setopt($curl, CURLOPT_HEADER, TRUE);\n        curl_setopt($curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, TRUE);\n        curl_setopt($curl, CURLOPT_CUSTOMREQUEST, 'SUBSCRIBE');\n\n        $response = curl_exec($curl);\n        curl_close( $curl );\n        debug_event('upnpdevice', 'Subscribe response: ' . $response, 5);\n\n        $lines = explode(\"\\r\\n\", trim($response));\n        foreach($lines as $line) {\n            $tmp = explode(':', $line);\n            $key = strtoupper(trim(array_shift($tmp)));\n            $value = trim(join(':', $tmp));\n\n            if ($key == 'SID')\n            {\n                debug_event('upnpdevice', 'Subscribtion SID: ' . $value, 5);\n                return $value;\n            }\n        }\n\n        return null;\n    }\n    */\n\n    //!! UPNP subscription work not for all renderers, and works strange\n    //!! so now is not used\n    /**\n     * UnSubscribe\n     * Unsubscribe from UPnP event\n     */\n    /*\n    public function UnSubscribe($sid, $type = 'AVTransport')\n    {\n        if (empty($sid))\n            return;\n\n        $eventUrl = $this->_host . $this->_eventURLs[$type];\n\n        $header = array(\n            'HOST: ' . $this->_host,\n            'SID: ' . $sid,\n        );\n\n        debug_event('upnpdevice', 'Unsubscribe from SID: ' . $sid . ' with: ' . \"\\n\" . print_r($header, true), 5);\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $eventUrl);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl, CURLOPT_HEADER, true);\n        curl_setopt($curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($curl, CURLOPT_CUSTOMREQUEST, 'UNSUBSCRIBE');\n\n        $response = curl_exec($curl);\n        curl_close( $curl );\n    }\n    */\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\Playback\\Localplay\\Vlc;\n\n/**\n * This player controls an instance of VLC webinterface\n * which in turn controls VLC. All functions\n * return null on failure.\n */\nclass VlcPlayer\n{\n    public $host;\n    public $port;\n    public $password;\n\n    /**\n     * VlcPlayer\n     * This is the constructor, it defaults to localhost\n     * with port 8080\n     * i would change this to another value then standard 8080, it gets used by more things\n     * @param string $host\n     * @param string $password\n     * @param integer $port\n     */\n    public function __construct($host = 'localhost', $password = '', $port = 8080)\n    {\n        $this->host     = $host;\n        $this->port     = $port;\n        $this->password = $password;\n    } // VlcPlayer\n\n    /**\n     * add\n     * append a song to the playlist\n     * $name    Name to be shown in the playlist\n     * $url        URL of the song\n     * @param string $name\n     * @param $url\n     * @return boolean\n     */\n    public function add($name, $url)\n    {\n        $aurl = urlencode($url);\n        $aurl .= \"&\";\n        $aurl .= urlencode($name);\n\n        $args    = array('command' => 'in_enqueue', '&input' => $aurl);\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // add\n\n    /**\n     * version\n     * No version returned in the standard xml file, just need to check for xml returned\n     */\n    public function version()\n    {\n        $args    = array();\n        $results = $this->sendCommand('status.xml', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // version\n\n    /**\n     * clear\n     * clear the playlist\n     * Every command returns status.xml no other way\n     */\n    public function clear()\n    {\n        $args    = array('command' => 'pl_empty');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // clear\n\n    /**\n     * next\n     * go to next song\n     */\n    public function next()\n    {\n        $args    = array('command' => 'pl_next');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // next\n\n    /**\n     * prev\n     * go to previous song\n     */\n    public function prev()\n    {\n        $args    = array('command' => 'pl_previous');\n        $results = $this->sendCommand(\"status.xml?\", $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // prev\n\n    /**\n     * skip\n     * This skips to POS in the playlist\n     * @param $pos\n     * @return boolean|null\n     */\n    public function skip($pos)\n    {\n        $args    = array('command' => 'pl_play', '&id' => $pos);\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        // Works but if user clicks next afterwards player goes to first song our last song played before\n\n        return true;\n    } // skip\n\n    /**\n     * play\n     * play the current song\n     */\n    public function play()\n    {\n        $args    = array('command' => 'pl_play');\n        $results = $this->sendCommand(\"status.xml?\", $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // play\n\n    /**\n     * pause\n     * toggle pause mode on current song\n     */\n    public function pause()\n    {\n        $args    = array('command' => 'pl_pause');\n        $results = $this->sendCommand(\"status.xml?\", $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // pause\n\n    /**\n     * stop\n     * stops the current song amazing!\n     */\n    public function stop()\n    {\n        $args    = array('command' => 'pl_stop');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // stop\n\n    /**\n     * repeat\n     * This toggles the repeat state of VLC\n     * @param $value\n     * @return boolean|null\n     */\n    public function repeat($value)\n    {\n        $args    = array('command' => 'pl_repeat');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // repeat\n\n    /**\n     * random\n     * this toggles the random state of VLC\n     * @param $value\n     * @return boolean\n     */\n    public function random($value)\n    {\n        $args    = array('command' => 'pl_random');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // random\n\n    /**\n     * delete_pos\n     * This deletes a specific track\n     * @param $track\n     * @return boolean\n     */\n    public function delete_pos($track)\n    {\n        $args    = array('command' => 'pl_delete', '&id' => $track);\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // delete_pos\n\n    /**\n     * state\n     * This returns the current state of the VLC player\n     */\n    public function state()\n    {\n        $args = array();\n\n        $state       = 'unknown';\n        $results     = $this->sendCommand('status.xml', $args);\n        $currentstat = $results['root']['state']['value'];\n\n        if ($currentstat == 'playing') {\n            $state = 'play';\n        }\n        if ($currentstat == 'stop') {\n            $state = 'stop';\n        }\n        if ($currentstat == 'paused') {\n            $state = 'pause';\n        }\n\n        return $state;\n    } // state\n\n    /**\n     * extract the full state from the xml file and send to status in vlccontroller for further parsing.\n     *\n     */\n    public function fullstate()\n    {\n        $args = array();\n\n        $results = $this->sendCommand('status.xml', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return $results;\n    } // fullstate\n\n\n    /**\n     * volume_up\n     * This increases the volume of VLC, set to +20 can be changed to your preference\n     */\n    public function volume_up()\n    {\n        $args    = array('command' => 'volume', '&val' => '%2B20');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // volume_up\n\n    /**\n     * volume_down\n     * This decreases the volume of VLC, can be set to your preference\n     */\n    public function volume_down()\n    {\n        $args    = array('command' => 'volume', '&val' => '-20');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // volume_down\n\n    /**\n     * set_volume\n     * This sets the volume as best it can, i think it's from 0 to 400, need more testing'\n     * @param $value\n     * @return boolean\n     */\n    public function set_volume($value)\n    {\n        // Convert it to base 400\n        $value   = $value * 4;\n        $args    = array('command' => 'volume', '&val' => $value);\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // set_volume\n\n    /**\n     * clear_playlist\n     * this flushes the playlist cache (I hope this means clear)\n     */\n    public function clear_playlist()\n    {\n        $args    = array('command' => 'pl_empty');\n        $results = $this->sendcommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // clear_playlist\n\n    /**\n     * get_tracks\n     * This returns a delimited string of all of the filenames\n     * current in your playlist, only urls at the moment,normal files put in the playlist with VLC wil not show'\n     */\n    public function get_tracks()\n    {\n        // Gets complete playlist + medialib in VLC's case, needs to be looked at\n        $args = array();\n\n        $results = $this->sendCommand('playlist.xml', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return $results;\n    } // get_tracks\n\n    /**\n     * sendCommand\n     * This is the core of this library it takes care of sending the HTTP\n     * request to the VLC server and getting the response\n     * @param $cmd\n     * @param $args\n     * @return array|null\n     */\n    private function sendCommand($cmd, $args)\n    {\n        $fsock = fsockopen($this->host, (int)$this->port, $errno, $errstr);\n\n        if (!$fsock) {\n            debug_event(self::class, \"VLCPlayer: $errstr ($errno)\", 1);\n\n            return null;\n        }\n\n        // Define the base message\n        $msg = \"GET /requests/$cmd\";\n\n        // Foreach our arguments\n        foreach ($args as $key => $val) {\n            $msg .= \"$key=$val\";\n        }\n\n        $msg .= \" HTTP/1.0\\r\\n\";\n\n        // Basic authentication\n        if (!empty($this->password)) {\n            $b64pwd = base64_encode(':' . $this->password);\n            $msg .= \"Authorization: Basic \" . $b64pwd . \"\\r\\n\";\n        }\n\n        $msg .= \"\\r\\n\";\n\n        fputs($fsock, $msg);\n        $data   = '';\n        $header = '';\n        // here the header is split from the xml to avoid problems\n        do {\n            // loop until the end of the header\n\n            $header .= fgets($fsock);\n        } while (strpos($header, \"\\r\\n\\r\\n\") === false);\n\n        // now put the body in variable $data\n        while (!feof($fsock)) {\n            $data .= fgets($fsock);\n        }\n\n        fclose($fsock);\n\n        // send to xml parser and make an array\n        return $this->xmltoarray($data);\n    } // sendCommand\n\n    /**\n     * xmltoarray\n     * this function parses the xml page into an array thx to bin-co\n     * warning VLC returns it's complete media lib if asked for playlist\n     * @param $contents\n     * @param integer $get_attributes\n     * @param string $priority\n     * @return array|void\n     */\n    private function xmltoarray($contents, $get_attributes = 1, $priority = 'attribute')\n    {\n        if (!$contents) {\n            return array();\n        }\n\n        if (!function_exists('xml_parser_create')) {\n            //print \"'xml_parser_create()' function not found!\";\n            return array();\n        }\n\n        // Get the XML parser of PHP - PHP must have this module for the parser to work\n        $parser = xml_parser_create('');\n        xml_parser_set_option($parser, XML_OPTION_TARGET_ENCODING,\n            \"UTF-8\"); # http://minutillo.com/steve/weblog/2004/6/17/php-xml-and-character-encodings-a-tale-of-sadness-rage-and-data-loss\n        xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);\n        xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);\n        xml_parse_into_struct($parser, trim($contents), $xml_values);\n        xml_parser_free($parser);\n\n        if (!$xml_values) {\n            return;\n        } // Hmm...\n\n        // Initializations\n        $bigxml_array = array();\n\n        $current = &$bigxml_array; // Reference\n\n        // Go through the tags.\n        // Multiple tags with same name will be turned into an array\n        $repeated_tag_index = array();\n        foreach ($xml_values as $data) {\n            // Remove existing values, or there will be trouble\n            unset($attributes, $value);\n\n            // This command will extract these variables into the foreach scope\n            // tag(string), type(string), level(int), attributes(array).\n            extract($data); // We could use the array by itself, but this cooler.\n\n            $result          = array();\n            $attributes_data = array();\n\n            if (isset($value)) {\n                if ($priority == 'tag') {\n                    $result = $value;\n                } else {\n                    $result['value'] = $value;\n                } // Put the value in a assoc array if we are in the 'Attribute' mode\n            }\n\n            // Set the attributes too.\n            if (isset($attributes) && $get_attributes) {\n                foreach ($attributes as $attr => $val) {\n                    if ($priority == 'tag') {\n                        $attributes_data[$attr] = $val;\n                    } else {\n                        $result['attr'][$attr] = $val;\n                    } // Set all the attributes in a array called 'attr'\n                }\n            }\n\n            // See tag status and do the needed.\n            if ($type == \"open\") {\n                // The starting of the tag '<tag>'\n                $parent[$level - 1] = &$current;\n                // Insert New tag\n                if (!is_array($current) || (!in_array($tag, array_keys($current)))) {\n                    $current[$tag] = $result;\n                    if ($attributes_data) {\n                        $current[$tag . '_attr'] = $attributes_data;\n                    }\n                    $repeated_tag_index[$tag . '_' . $level] = 1;\n\n                    $current = &$current[$tag];\n                } else {\n                    // There was another element with the same tag name\n                    if (isset($current[$tag][0])) {\n                        // If there is a 0th element it is already an array\n                        $current[$tag][$repeated_tag_index[$tag . '_' . $level]] = $result;\n                        $repeated_tag_index[$tag . '_' . $level]++;\n                    } else {\n                        // This section will make the value an array if multiple tags with the same name appear together\n                        $current[$tag] = array(\n                            $current[$tag],\n                            $result\n                        ); // This will combine the existing item and the new item together to make an array\n                        $repeated_tag_index[$tag . '_' . $level] = 2;\n\n                        if (isset($current[$tag . '_attr'])) {\n                            // The attribute of the last(0th) tag must be moved as well\n                            $current[$tag]['0_attr'] = $current[$tag . '_attr'];\n                            unset($current[$tag . '_attr']);\n                        }\n                    }\n                    $last_item_index = $repeated_tag_index[$tag . '_' . $level] - 1;\n                    $current         = &$current[$tag][$last_item_index];\n                }\n            } elseif ($type == \"complete\") {\n                // Tags that ends in 1 line '<tag />'\n                // See if the key is already taken.\n                if (!isset($current[$tag])) {\n                    //New Key\n                    $current[$tag]                           = $result;\n                    $repeated_tag_index[$tag . '_' . $level] = 1;\n                    if ($priority == 'tag' && $attributes_data) {\n                        $current[$tag . '_attr'] = $attributes_data;\n                    }\n                } else {\n                    // If taken, put all things inside a list(array)\n                    if (isset($current[$tag][0]) && is_array($current[$tag])) {\n                        // If it is already an array push the new element into that array.\n                        $current[$tag][$repeated_tag_index[$tag . '_' . $level]] = $result;\n\n                        if ($priority == 'tag' && $get_attributes && $attributes_data) {\n                            $current[$tag][$repeated_tag_index[$tag . '_' . $level] . '_attr'] = $attributes_data;\n                        }\n                        $repeated_tag_index[$tag . '_' . $level]++;\n                    } else {\n                        // If it is not an array...\n                        $current[$tag] = array(\n                            $current[$tag],\n                            $result\n                        ); // ...Make it an array using using the existing value and the new value\n                        $repeated_tag_index[$tag . '_' . $level] = 1;\n                        if ($priority == 'tag' && $get_attributes) {\n                            if (isset($current[$tag . '_attr'])) {\n                                // The attribute of the last(0th) tag must be moved as well\n                                $current[$tag]['0_attr'] = $current[$tag . '_attr'];\n                                unset($current[$tag . '_attr']);\n                            }\n\n                            if ($attributes_data) {\n                                $current[$tag][$repeated_tag_index[$tag . '_' . $level] . '_attr'] = $attributes_data;\n                            }\n                        }\n                        $repeated_tag_index[$tag . '_' . $level]++; // 0 and 1 index is already taken\n                    }\n                }\n            } elseif ($type == 'close') {\n                // End of tag '</tag>'\n                $current = &$parent[$level - 1];\n            }\n        }\n\n        return ($bigxml_array);\n    }   // xml parser\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\Playback;\n\nuse Ampache\\Repository\\Model\\Media;\nuse Ampache\\Module\\Playback\\Localplay\\LocalPlay;\nuse Ampache\\Module\\Util\\ObjectTypeToClassNameMapper;\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Art;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Repository\\Model\\Democratic;\nuse PDOStatement;\nuse Ampache\\Module\\System\\Session;\nuse Ampache\\Module\\Util\\Ui;\nuse Ampache\\Module\\Api\\Xml_Data;\n\n/**\n * Stream_Playlist Class\n *\n * This class is used to generate the Playlists and pass them on\n * For Localplay this actually just sends the commands to the Localplay\n * module in question.\n */\nclass Stream_Playlist\n{\n    public $id;\n    public $urls = array();\n    public $user;\n    public $title;\n\n    /**\n     * Stream_Playlist constructor\n     * If an ID is passed, it should be a stream session ID.\n     * @param integer|string $session_id\n     */\n    public function __construct($session_id = null)\n    {\n        if ($session_id != -1) {\n            if ($session_id !== null) {\n                Stream::set_session($session_id);\n            }\n\n            $this->id = Stream::get_session();\n\n            if (!Session::exists('stream', $this->id)) {\n                debug_event(self::class, 'Session::exists failed', 2);\n\n                return false;\n            }\n\n            $this->user = (int)(Core::get_global('user')->id);\n\n            $sql        = 'SELECT * FROM `stream_playlist` WHERE `sid` = ? ORDER BY `id`';\n            $db_results = Dba::read($sql, array($this->id));\n\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $this->urls[] = new Stream_Url($row);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param Stream_URL $url\n     * @return PDOStatement|boolean\n     */\n    private function _add_url($url)\n    {\n        debug_event(\"stream_playlist.class\", \"Adding url {\" . json_encode($url) . \"}...\", 5);\n\n        $this->urls[] = $url;\n        $fields       = array();\n        $fields[]     = '`sid`';\n        $values       = array();\n        $values[]     = $this->id;\n        $holders      = array();\n        $holders[]    = '?';\n\n        foreach ($url->properties as $field) {\n            if ($url->$field) {\n                $fields[]  = '`' . $field . '`';\n                $values[]  = $url->$field;\n                $holders[] = '?';\n            }\n        }\n        $sql = 'INSERT INTO `stream_playlist` (' . implode(',', $fields) . ') VALUES (' . implode(',', $holders) . ')';\n\n        return Dba::write($sql, $values);\n    }\n\n    /**\n     * @param array $urls\n     * @return PDOStatement|boolean\n     */\n    private function _add_urls($urls)\n    {\n        debug_event(\"stream_playlist.class\", \"Adding urls to {\" . $this->id . \"}...\", 5);\n        $sql         = '';\n        $fields      = array();\n        $values      = array();\n        $holders_arr = array();\n\n        foreach ($urls as $url) {\n            $this->urls[] = $url;\n            $fields       = array();\n            $fields[]     = '`sid`';\n            $values[]     = $this->id;\n            $holders      = array();\n            $holders[]    = '?';\n\n            foreach ($url->properties as $field) {\n                if ($url->$field !== null) {\n                    $fields[]  = '`' . $field . '`';\n                    $values[]  = $url->$field;\n                    $holders[] = '?';\n                }\n            }\n            $holders_arr[] = $holders;\n        }\n\n        $holders_chunks = array_chunk($holders_arr, 500);\n        foreach ($holders_chunks as $holders_arr_temp) {\n            $sql .= 'INSERT INTO `stream_playlist` (' . implode(',', $fields) . ') VALUES ';\n\n            foreach ($holders_arr_temp as $placeholder) {\n                $sql .= '(' . implode(',', $placeholder) . '),';\n            }\n            // remove last comma\n            $sql = substr($sql, 0, -1);\n            $sql .= ';';\n        }\n\n        return Dba::write($sql, $values);\n    }\n\n    /**\n     * @return PDOStatement|boolean\n     */\n    public static function garbage_collection()\n    {\n        $sql = 'DELETE FROM `stream_playlist` USING `stream_playlist` LEFT JOIN `session` ON `session`.`id`=`stream_playlist`.`sid` WHERE `session`.`id` IS NULL';\n\n        return Dba::write($sql);\n    }\n\n    /**\n     * media_to_urlarray\n     * Formats the URL and media information and adds it to the object\n     * @param $media\n     * @param string $additional_params\n     * @return array\n     */\n    public static function media_to_urlarray($media, $additional_params = '')\n    {\n        $urls = array();\n        foreach ($media as $medium) {\n            $surl = self::media_to_url($medium, $additional_params);\n            if ($surl != null) {\n                $urls[] = $surl;\n            }\n        }\n\n        return $urls;\n    }\n\n    /**\n     * media_to_url\n     * @param $media\n     * @param string $additional_params\n     * @param string $urltype\n     * @return Stream_Url\n     */\n    public static function media_to_url($media, $additional_params = '', $urltype = 'web')\n    {\n        $type       = $media['object_type'];\n        $object_id  = $media['object_id'];\n        $class_name = ObjectTypeToClassNameMapper::map($type);\n        $object     = new $class_name($object_id);\n        $object->format();\n\n        if (array_key_exists('client', $media)) {\n            $additional_params .= \"&client=\" . $media['client'];\n        }\n        if (array_key_exists('action', $media)) {\n            $additional_params .= \"&action=\" . $media['action'];\n        }\n        if (array_key_exists('cache', $media)) {\n            $additional_params .= \"&cache=\" . $media['cache'];\n        }\n        if (array_key_exists('player', $media)) {\n            $additional_params .= \"&player=\" . $media['player'];\n        }\n        if (array_key_exists('format', $media)) {\n            $additional_params .= \"&format=\" . $media['format'];\n        }\n        if (array_key_exists('transcode_to', $media)) {\n            $additional_params .= \"&transcode_to=\" . $media['transcode_to'];\n        }\n        if (array_key_exists('custom_play_action', $media)) {\n            $additional_params .= \"&custom_play_action=\" . $media['custom_play_action'];\n        }\n\n        if (array_key_exists('iframe', $_SESSION) && array_key_exists('subtitle', $_SESSION['iframe'])) {\n            $additional_params .= \"&subtitle=\" . $_SESSION['iframe']['subtitle'];\n        }\n\n        return self::media_object_to_url($object, $additional_params, $urltype);\n    }\n\n    /**\n     * media_object_to_url\n     * @param media $object\n     * @param string $additional_params\n     * @param string $urltype\n     * @return Stream_Url\n     */\n    public static function media_object_to_url($object, $additional_params = '', $urltype = 'web')\n    {\n        $surl = null;\n        $url  = array();\n\n        $class_name  = get_class($object);\n        $type        = ObjectTypeToClassNameMapper::reverseMap($class_name);\n        $url['type'] = $type;\n\n        // Don't add disabled media objects to the stream playlist\n        // Playing a disabled media return a 404 error that could make failed the player (mpd ...)\n        if (!isset($object->enabled) || make_bool($object->enabled)) {\n            if ($urltype == 'file') {\n                $url['url'] = $object->file;\n                // Relative path\n                if (!empty($additional_params) && strpos($url['url'], $additional_params) === 0) {\n                    $url['url'] = substr($url['url'], strlen((string)$additional_params));\n                    if (strlen((string)$url['url']) < 1) {\n                        return null;\n                    }\n                    if ($url['url'][0] == DIRECTORY_SEPARATOR) {\n                        $url['url'] = substr($url['url'], 1);\n                    }\n                }\n            } else {\n                $url['url'] = $object->play_url($additional_params);\n            }\n\n            $api_session = (AmpConfig::get('require_session')) ? Stream::get_session() : null;\n\n            // Set a default which can be overridden\n            $url['author'] = 'Ampache';\n            $url['time']   = (isset($object->time)) ? $object->time : 0;\n            switch ($type) {\n                case 'song':\n                    $url['title']     = $object->title;\n                    $url['author']    = $object->f_artist_full;\n                    $url['info_url']  = $object->f_link;\n                    $show_song_art    = AmpConfig::get('show_song_art', false);\n                    $has_art          = Art::has_db($object->id, 'song');\n                    $art_object       = ($show_song_art && $has_art) ? $object->id : $object->album;\n                    $art_type         = ($show_song_art && $has_art) ? 'song' : 'album';\n                    $url['image_url'] = Art::url($art_object, $art_type, $api_session, (AmpConfig::get('ajax_load') ? 3 : 4));\n                    $url['album']     = $object->f_album_full;\n                    $url['codec']     = $object->type;\n                    $url['track_num'] = (string)$object->track;\n                    break;\n                case 'video':\n                    $url['title']      = 'Video - ' . $object->title;\n                    $url['author']     = $object->f_artist_full;\n                    $url['resolution'] = $object->f_resolution;\n                    $url['codec']      = $object->type;\n                    break;\n                case 'live_stream':\n                    $url['title'] = 'Radio - ' . $object->name;\n                    if (!empty($object->site_url)) {\n                        $url['title'] .= ' (' . $object->site_url . ')';\n                    }\n                    $url['info_url']  = $object->f_link;\n                    $url['image_url'] = Art::url($object->id, 'live_stream', $api_session, (AmpConfig::get('ajax_load') ? 3 : 4));\n                    $url['codec']     = $object->codec;\n                    break;\n                case 'song_preview':\n                    $url['title']  = $object->title;\n                    $url['author'] = $object->f_artist_full;\n                    $url['codec']  = $object->type;\n                    break;\n                case 'channel':\n                    $url['title'] = $object->name;\n                    $url['codec'] = $object->stream_type;\n                    break;\n                case 'podcast_episode':\n                    $url['title']     = $object->f_name;\n                    $url['author']    = $object->f_podcast;\n                    $url['info_url']  = $object->f_link;\n                    $url['image_url'] = Art::url($object->podcast, 'podcast', $api_session, (AmpConfig::get('ajax_load') ? 3 : 4));\n                    $url['codec']     = $object->type;\n                    break;\n                default:\n                    $url['title'] = Stream_Url::get_title($url['url']);\n                    $url['time']  = -1;\n                    break;\n            }\n\n            $surl = new Stream_Url($url);\n        }\n\n        return $surl;\n    }\n\n    /**\n     * check_autoplay_append\n     * @return boolean\n     */\n    public static function check_autoplay_append()\n    {\n        // For now, only iframed web player support media append in the currently played playlist\n        return ((AmpConfig::get('ajax_load') && AmpConfig::get('play_type') == 'web_player') || AmpConfig::get('play_type') == 'localplay');\n    }\n\n    /**\n     * check_autoplay_next\n     * @return boolean\n     */\n    public static function check_autoplay_next()\n    {\n        // Currently only supported for web player\n        return (AmpConfig::get('ajax_load') && AmpConfig::get('play_type') == 'web_player');\n    }\n\n    /**\n     * @param $type\n     * @param boolean $redirect\n     * @return boolean\n     */\n    public function generate_playlist($type, $redirect = false)\n    {\n        if (!count($this->urls)) {\n            debug_event(self::class, 'Error: Empty URL array for ' . $this->id, 2);\n\n            return false;\n        }\n\n        debug_event(self::class, 'Generating a {' . $type . '} object...', 4);\n\n        $ext = $type;\n        switch ($type) {\n            case 'download':\n            case 'democratic':\n            case 'localplay':\n            case 'web_player':\n                // These are valid, but witchy\n                $ctype    = \"\";\n                $redirect = false;\n                unset($ext);\n                break;\n            case 'asx':\n                $ctype = 'video/x-ms-asf';\n                break;\n            case 'pls':\n                $ctype = 'audio/x-scpls';\n                break;\n            case 'ram':\n                $ctype = 'audio/x-pn-realaudio ram';\n                break;\n            case 'simple_m3u':\n                $ext   = 'm3u';\n                $ctype = 'audio/x-mpegurl';\n                break;\n            case 'xspf':\n                $ctype = 'application/xspf+xml';\n                break;\n            case 'hls':\n                $ext   = 'm3u8';\n                $ctype = 'application/vnd.apple.mpegurl';\n                break;\n            case 'm3u':\n            default:\n                // Assume M3U if the pooch is screwed\n                $ext   = $type = 'm3u';\n                $ctype = 'audio/x-mpegurl';\n                break;\n        }\n\n        if ($redirect) {\n            // Our ID is the SID, so we always want to include it\n            AmpConfig::set('require_session', true, true);\n            header('Location: ' . Stream::get_base_url() . 'uid=' . scrub_out($this->user) . '&type=playlist&playlist_type=' . scrub_out($type));\n\n            return false;\n        }\n\n        if (isset($ext)) {\n            header('Cache-control: public');\n            header('Content-Disposition: filename=ampache_playlist.' . $ext);\n            header('Content-Type: ' . $ctype . ';');\n        }\n\n        $this->{'create_' . $type}();\n\n        return true;\n    }\n\n    /**\n     * add\n     * Adds an array of media\n     * @param array $media\n     * @param string $additional_params\n     */\n    public function add($media = array(), $additional_params = '')\n    {\n        $urls = self::media_to_urlarray($media, $additional_params);\n        $this->_add_urls($urls);\n    }\n\n    /**\n     * add_urls\n     * Add an array of urls. This is used for things that aren't coming\n     * from media objects like democratic playlists\n     * @param array $urls\n     * @return boolean\n     */\n    public function add_urls($urls = array())\n    {\n        if (!is_array($urls)) {\n            return false;\n        }\n\n        foreach ($urls as $url) {\n            $this->_add_url(new Stream_Url(array(\n                'url' => $url,\n                'title' => Stream_Url::get_title($url),\n                'author' => T_('Ampache'),\n                'time' => '-1'\n            )));\n        }\n\n        return true;\n    }\n\n    /**\n     * create_simplem3u\n     * this creates a simple m3u without any of the extended information\n     */\n    public function create_simple_m3u()\n    {\n        foreach ($this->urls as $url) {\n            echo $url->url . \"\\n\";\n        }\n    } // simple_m3u\n\n    /**\n     * get_m3u_string\n     * creates an m3u file, this includes the EXTINFO and as such can be\n     * large with very long playlists\n     * @return string\n     */\n    public function get_m3u_string()\n    {\n        $ret = \"#EXTM3U\\n\";\n\n        $count = 0;\n        foreach ($this->urls as $url) {\n            $ret .= '#EXTINF:' . $url->time . ', ' . $url->author . ' - ' . $url->title . \"\\n\";\n            $ret .= $url->url . \"\\n\";\n            $count++;\n        }\n\n        return $ret;\n    } // get_m3u_string\n\n    public function create_m3u()\n    {\n        echo $this->get_m3u_string();\n    }\n\n    /**\n     * get_pls_string\n     * @return string\n     */\n    public function get_pls_string()\n    {\n        $ret = \"[playlist]\\n\";\n        $ret .= 'NumberOfEntries=' . count($this->urls) . \"\\n\";\n        $count = 0;\n        foreach ($this->urls as $url) {\n            $count++;\n            $ret .= 'File' . $count . '=' . $url->url . \"\\n\";\n            $ret .= 'Title' . $count . '=' . $url->author . ' - ' . $url->title . \"\\n\";\n            $ret .= 'Length' . $count . '=' . $url->time . \"\\n\";\n        }\n\n        $ret .= \"Version=2\\n\";\n\n        return $ret;\n    } // get_pls_string\n\n    public function create_pls()\n    {\n        echo $this->get_pls_string();\n    }\n\n    /**\n     * get_asx_string\n     * This should really only be used if all of the content is ASF files.\n     * @return string\n     */\n    public function get_asx_string()\n    {\n        $ret = '<ASX VERSION=\"3.0\" BANNERBAR=\"auto\">' . \"\\n\";\n        $ret .= \"<TITLE>\" . ($this->title ?: T_(\"Ampache ASX Playlist\")) . \"</TITLE>\\n\";\n        $ret .= '<PARAM NAME=\"Encoding\" VALUE=\"utf-8\"' . \"></PARAM>\\n\";\n\n        foreach ($this->urls as $url) {\n            $ret .= \"<ENTRY>\\n\";\n            $ret .= '<TITLE>' . scrub_out($url->title) . \"</TITLE>\\n\";\n            $ret .= '<AUTHOR>' . scrub_out($url->author) . \"</AUTHOR>\\n\";\n            // FIXME: duration looks hacky and wrong\n            $ret .= \"\\t\\t\" . '<DURATION VALUE=\"00:00:' . $url->time . '\" />' . \"\\n\";\n            $ret .= \"\\t\\t\" . '<PARAM NAME=\"Album\" Value=\"' . scrub_out($url->album) . '\" />' . \"\\n\";\n            $ret .= \"\\t\\t\" . '<PARAM NAME=\"Composer\" Value=\"' . scrub_out($url->author) . '\" />' . \"\\n\";\n            $ret .= \"\\t\\t\" . '<PARAM NAME=\"Prebuffer\" Value=\"false\" />' . \"\\n\";\n            $ret .= '<REF HREF=\"' . $url->url . '\" />' . \"\\n\";\n            $ret .= \"</ENTRY>\\n\";\n        }\n\n        $ret .= \"</ASX>\\n\";\n\n        return $ret;\n    } // get_asx_string\n\n    public function create_asx()\n    {\n        echo $this->get_asx_string();\n    }\n\n    /**\n     * get_xspf_string\n     * @return string\n     */\n    public function get_xspf_string()\n    {\n        $result = \"\";\n        foreach ($this->urls as $url) {\n            $xml = array();\n\n            $xml['track'] = array(\n                'title' => $url->title,\n                'creator' => $url->author,\n                'duration' => $url->time * 1000,\n                'location' => $url->url,\n                'identifier' => $url->url\n            );\n            if ($url->type == 'video') {\n                $xml['track']['meta'] = array(\n                    'attribute' => 'rel=\"provider\"',\n                    'value' => 'video'\n                );\n            }\n            if ($url->info_url) {\n                $xml['track']['info'] = $url->info_url;\n            }\n            if ($url->image_url) {\n                $xml['track']['image'] = $url->image_url;\n            }\n            if ($url->album) {\n                $xml['track']['album'] = $url->album;\n            }\n            if ($url->track_num) {\n                $xml['track']['trackNum'] = $url->track_num;\n            }\n\n            $result .= Xml_Data::keyed_array($xml, true);\n        } // end foreach\n\n        Xml_Data::set_type('xspf');\n        $ret = Xml_Data::header($this->title);\n        $ret .= $result;\n        $ret .= Xml_Data::footer();\n\n        return $ret;\n    } // get_xspf_string\n\n    public function create_xspf()\n    {\n        echo $this->get_xspf_string();\n    }\n\n    /**\n     * get_hls_string\n     * @return string\n     */\n    public function get_hls_string()\n    {\n        $ssize = 10;\n        $ret   = \"#EXTM3U\\n\";\n        $ret .= \"#EXT-X-TARGETDURATION:\" . $ssize . \"\\n\";\n        $ret .= \"#EXT-X-VERSION:1\\n\";\n        $ret .= \"#EXT-X-ALLOW-CACHE:NO\\n\";\n        $ret .= \"#EXT-X-MEDIA-SEQUENCE:0\\n\";\n        $ret .= \"#EXT-X-PLAYLIST-TYPE:VOD\\n\"; // Static list of segments\n\n        foreach ($this->urls as $url) {\n            $soffset = 0;\n            $segment = 0;\n            while ($soffset < $url->time) {\n                $type              = $url->type;\n                $size              = (($soffset + $ssize) <= $url->time) ? $ssize : ($url->time - $soffset);\n                $additional_params = '&transcode_to=ts&segment=' . $segment;\n                $ret .= \"#EXTINF:\" . $size . \",\\n\";\n                $url_data = Stream_Url::parse($url->url);\n                $id       = $url_data['id'];\n\n                unset($url_data['id']);\n                unset($url_data['ssid']);\n                unset($url_data['type']);\n                unset($url_data['base_url']);\n                unset($url_data['uid']);\n                unset($url_data['name']);\n\n                foreach ($url_data as $key => $value) {\n                    $additional_params .= '&' . $key . '=' . $value;\n                }\n\n                $className = ObjectTypeToClassNameMapper::map($type);\n\n                $item = new $className($id);\n                $hu   = $item->play_url($additional_params);\n                $ret .= $hu . \"\\n\";\n                $soffset += $size;\n                $segment++;\n            }\n        }\n\n        $ret .= \"#EXT-X-ENDLIST\\n\\n\";\n\n        return $ret;\n    }\n\n    public function create_hls()\n    {\n        echo $this->get_hls_string();\n    }\n\n    /**\n     * create_web_player\n     *\n     * Creates an web player.\n     */\n    public function create_web_player()\n    {\n        if (AmpConfig::get(\"ajax_load\")) {\n            require Ui::find_template('create_web_player_embedded.inc.php');\n        } else {\n            require Ui::find_template('create_web_player.inc.php');\n        }\n    }  // create_web_player\n\n    /**\n     * show_web_player\n     *\n     * Show the created web player for ajax page loading.\n     * Browsers block autoplay when you haven't interacted with the page so load it early.\n     */\n    public function show_web_player()\n    {\n        if (AmpConfig::get(\"ajax_load\")) {\n            require Ui::find_template('show_web_player_embedded.inc.php');\n        }\n    }  // show_web_player\n\n    /**\n     * create_localplay\n     * This calls the Localplay API to add the URLs and then start playback\n     */\n    public function create_localplay()\n    {\n        $localplay = new LocalPlay(AmpConfig::get('localplay_controller'));\n        $localplay->connect();\n        $append = $_REQUEST['append'] ?? false;\n        if (!$append) {\n            $localplay->delete_all();\n        }\n        foreach ($this->urls as $url) {\n            $localplay->add_url($url);\n        }\n        if (!$append) {\n            // We don't have metadata on Stream_URL to know its kind\n            // so we check the content to know if it is democratic\n            if (count($this->urls) == 1) {\n                $furl = $this->urls[0];\n                if (strpos($furl->url, \"&demo_id=1\") !== false && $furl->time == -1) {\n                    // If democratic, repeat the song to get the next voted one.\n                    debug_event(self::class, 'Playing democratic on Localplay, enabling repeat...', 5);\n                    $localplay->repeat(true);\n                }\n            }\n            $localplay->play();\n        }\n    } // create_localplay\n\n    /**\n     * create_democratic\n     *\n     * This 'votes' on the songs; it inserts them into a tmp_playlist with user\n     * set to -1.\n     */\n    public function create_democratic()\n    {\n        $democratic = Democratic::get_current_playlist();\n        $democratic->set_parent();\n        $items = array();\n\n        foreach ($this->urls as $url) {\n            $url_data = Stream_Url::parse($url->url);\n            $items[]  = array($url_data['type'], $url_data['id']);\n        }\n        if (!empty($items)) {\n            $democratic->add_vote($items);\n            display_notification(T_('Vote added'));\n        }\n    }\n\n    /**\n     * create_download\n     * This prompts for a download of the song\n     */\n    private function create_download()\n    {\n        // There should only be one here...\n        if (count($this->urls) != 1) {\n            debug_event(self::class, 'Download called, but $urls contains ' . json_encode($this->urls), 2);\n        }\n\n        // Header redirect baby!\n        $url = current($this->urls);\n        $url = Stream_Url::add_options($url->url, '&action=download&cache=1');\n        header('Location: ' . $url);\n\n        return false;\n    } // create_download\n\n\n    /**\n     * create_ram\n     *this functions creates a RAM file for use by Real Player\n     */\n    public function create_ram()\n    {\n        foreach ($this->urls as $url) {\n            echo $url->url . \"\\n\";\n        }\n    } // create_ram\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\System;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Catalog;\nuse Ampache\\Repository\\Model\\Preference;\nuse Ampache\\Repository\\Model\\User;\n\n/**\n * Update Class\n *\n * This class mainly handles schema updates for the database.\n * Versions are a monotonically increasing integer: First column(s) are the\n * major version, followed by a single column for the minor version and four\n * columns for the build number. 3.6 build 1 is 360000; 10.9 build 17 is\n * 1090017.\n */\nclass Update\n{\n    public $key;\n    public $value;\n    public static $versions; // array containing version information\n\n    /**\n     * get_version\n     *\n     * This checks to see what version you are currently running.\n     * Because we may not have the update_info table we have to check\n     * for its existence first.\n     * @return string\n     */\n    public static function get_version()\n    {\n        $version = \"\";\n        /* Make sure that update_info exits */\n        $sql        = \"SHOW TABLES LIKE 'update_info'\";\n        $db_results = Dba::read($sql);\n        if (!Dba::dbh()) {\n            header(\"Location: test.php\");\n        }\n\n        // If no table\n        if (!Dba::num_rows($db_results)) {\n            // They can't upgrade, they are too old\n            header(\"Location: test.php\");\n        } else {\n            // If we've found the update_info table, let's get the version from it\n            $sql        = \"SELECT `key`, `value` FROM `update_info` WHERE `key`='db_version'\";\n            $db_results = Dba::read($sql);\n            $results    = Dba::fetch_assoc($db_results);\n            $version    = $results['value'];\n        }\n\n        return $version;\n    } // get_version\n\n    /**\n     * check_tables\n     *\n     * is something missing? why is it missing!?\n     * @param bool $execute\n     * @return array\n     */\n    public static function check_tables(bool $execute = false)\n    {\n        $db_version = (int)self::get_version();\n        $missing    = array();\n        $collation  = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset    = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine     = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        $tables     = array(\n            'image' => \"CREATE TABLE IF NOT EXISTS `image` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `image` mediumblob DEFAULT NULL, `width` int(4) UNSIGNED DEFAULT 0, `height` int(4) UNSIGNED DEFAULT 0, `mime` varchar(64) COLLATE $collation DEFAULT NULL, `size` varchar(64) COLLATE $collation DEFAULT NULL, `object_type` varchar(64) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL, `kind` varchar(32) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`), KEY `object_type` (`object_type`), KEY `object_id` (`object_id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'tmp_browse' => \"CREATE TABLE IF NOT EXISTS `tmp_browse` ( `id` int(13) NOT NULL AUTO_INCREMENT, `sid` varchar(128) COLLATE $collation NOT NULL, `data` longtext COLLATE $collation NOT NULL, `object_data` longtext COLLATE $collation DEFAULT NULL, PRIMARY KEY (`sid`,`id`)) ENGINE=MyISAM DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'share' => \"CREATE TABLE IF NOT EXISTS `share` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) UNSIGNED NOT NULL, `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL, `allow_stream` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `allow_download` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `expire_days` int(4) UNSIGNED NOT NULL DEFAULT 0, `max_counter` int(4) UNSIGNED NOT NULL DEFAULT 0, `secret` varchar(20) COLLATE $collation DEFAULT NULL, `counter` int(4) UNSIGNED NOT NULL DEFAULT 0, `creation_date` int(11) UNSIGNED NOT NULL DEFAULT 0, `lastvisit_date` int(11) UNSIGNED NOT NULL DEFAULT 0, `public_url` varchar(255) COLLATE $collation DEFAULT NULL, `description` varchar(255) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'broadcast' => \"CREATE TABLE IF NOT EXISTS `broadcast` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) UNSIGNED NOT NULL, `name` varchar(64) COLLATE $collation DEFAULT NULL, `description` varchar(256) COLLATE $collation DEFAULT NULL, `is_private` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `song` int(11) UNSIGNED NOT NULL DEFAULT 0, `started` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `listeners` int(11) UNSIGNED NOT NULL DEFAULT 0, `key` varchar(32) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'player_control' => \"CREATE TABLE IF NOT EXISTS `player_control` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) UNSIGNED NOT NULL, `cmd` varchar(32) COLLATE $collation DEFAULT NULL, `value` varchar(256) COLLATE $collation DEFAULT NULL, `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL, `send_date` int(11) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'recommendation' => \"CREATE TABLE IF NOT EXISTS `recommendation` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL, `last_update` int(11) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'recommendation_item' => \"CREATE TABLE IF NOT EXISTS `recommendation_item` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `recommendation` int(11) UNSIGNED NOT NULL, `recommendation_id` int(11) UNSIGNED DEFAULT NULL, `name` varchar(256) COLLATE $collation DEFAULT NULL, `rel` varchar(256) COLLATE $collation DEFAULT NULL, `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'license' => \"CREATE TABLE IF NOT EXISTS `license` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(80) COLLATE $collation DEFAULT NULL, `description` varchar(256) COLLATE $collation DEFAULT NULL, `external_link` varchar(256) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine AUTO_INCREMENT=15 DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'daap_session' => \"CREATE TABLE IF NOT EXISTS `daap_session` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `creationdate` int(11) UNSIGNED NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'tvshow' => \"CREATE TABLE IF NOT EXISTS `tvshow` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(80) COLLATE $collation DEFAULT NULL, `summary` varchar(256) COLLATE $collation DEFAULT NULL, `year` int(11) UNSIGNED DEFAULT NULL, `prefix` varchar(32) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'tvshow_season' => \"CREATE TABLE IF NOT EXISTS `tvshow_season` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `season_number` int(11) UNSIGNED NOT NULL, `tvshow` int(11) UNSIGNED NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'tvshow_episode' => \"CREATE TABLE IF NOT EXISTS `tvshow_episode` ( `id` int(11) UNSIGNED NOT NULL, `original_name` varchar(80) COLLATE $collation DEFAULT NULL, `season` int(11) UNSIGNED NOT NULL, `episode_number` int(11) UNSIGNED NOT NULL, `summary` varchar(256) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'movie' => \"CREATE TABLE IF NOT EXISTS `movie` ( `id` int(11) UNSIGNED NOT NULL, `original_name` varchar(80) COLLATE $collation DEFAULT NULL, `summary` varchar(256) COLLATE $collation DEFAULT NULL, `year` int(11) UNSIGNED DEFAULT NULL, `prefix` varchar(32) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'personal_video' => \"CREATE TABLE IF NOT EXISTS `personal_video` ( `id` int(11) UNSIGNED NOT NULL, `location` varchar(256) COLLATE $collation DEFAULT NULL, `summary` varchar(256) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'clip' => \"CREATE TABLE IF NOT EXISTS `clip` ( `id` int(11) UNSIGNED NOT NULL, `artist` int(11) DEFAULT NULL, `song` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'tag_merge' => \"CREATE TABLE IF NOT EXISTS `tag_merge` ( `tag_id` int(11) NOT NULL, `merged_to` int(11) NOT NULL, PRIMARY KEY (`tag_id`,`merged_to`), KEY `merged_to` (`merged_to`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'label' => \"CREATE TABLE IF NOT EXISTS `label` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(80) COLLATE $collation DEFAULT NULL, `category` varchar(40) COLLATE $collation DEFAULT NULL, `summary` text COLLATE $collation DEFAULT NULL, `address` varchar(256) COLLATE $collation DEFAULT NULL, `email` varchar(128) COLLATE $collation DEFAULT NULL, `website` varchar(256) COLLATE $collation DEFAULT NULL, `user` int(11) UNSIGNED DEFAULT NULL, `creation_date` int(11) UNSIGNED DEFAULT NULL, `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `country` varchar(64) COLLATE $collation DEFAULT NULL, `active` tinyint(1) UNSIGNED NOT NULL DEFAULT 1, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'label_asso' => \"CREATE TABLE IF NOT EXISTS `label_asso` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `label` int(11) UNSIGNED NOT NULL, `artist` int(11) UNSIGNED NOT NULL, `creation_date` int(11) UNSIGNED DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'user_pvmsg' => \"CREATE TABLE IF NOT EXISTS `user_pvmsg` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `subject` varchar(80) COLLATE $collation DEFAULT NULL, `message` text COLLATE $collation DEFAULT NULL, `from_user` int(11) UNSIGNED NOT NULL, `to_user` int(11) UNSIGNED NOT NULL, `is_read` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `creation_date` int(11) UNSIGNED DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'user_follower' => \"CREATE TABLE IF NOT EXISTS `user_follower` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) UNSIGNED NOT NULL, `follow_user` int(11) UNSIGNED NOT NULL, `follow_date` int(11) UNSIGNED DEFAULT NULL, `creation_date` int(11) UNSIGNED DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'metadata_field' => \"CREATE TABLE IF NOT EXISTS `metadata_field` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(255) COLLATE $collation DEFAULT NULL, `public` tinyint(1) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'metadata' => \"CREATE TABLE IF NOT EXISTS `metadata` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `object_id` int(11) UNSIGNED NOT NULL, `field` int(11) UNSIGNED NOT NULL, `data` text COLLATE $collation NOT NULL, `type` varchar(50) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`), KEY `field` (`field`), KEY `object_id` (`object_id`), KEY `type` (`type`), KEY `objecttype` (`object_id`,`type`), KEY `objectfield` (`object_id`,`field`,`type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'podcast' => \"CREATE TABLE IF NOT EXISTS `podcast` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `feed` varchar(4096) COLLATE $collation DEFAULT NULL, `catalog` int(11) NOT NULL, `title` varchar(255) COLLATE $collation DEFAULT NULL, `website` varchar(255) COLLATE $collation DEFAULT NULL, `description` varchar(4096) COLLATE $collation DEFAULT NULL, `language` varchar(5) COLLATE $collation DEFAULT NULL, `copyright` varchar(255) COLLATE $collation DEFAULT NULL, `generator` varchar(64) COLLATE $collation DEFAULT NULL, `lastbuilddate` int(11) UNSIGNED NOT NULL DEFAULT 0, `lastsync` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0, `episodes` int(11) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'podcast_episode' => \"CREATE TABLE IF NOT EXISTS `podcast_episode` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `title` varchar(255) COLLATE $collation DEFAULT NULL, `guid` varchar(255) COLLATE $collation DEFAULT NULL, `podcast` int(11) NOT NULL, `state` varchar(32) COLLATE $collation DEFAULT NULL, `file` varchar(4096) COLLATE $collation DEFAULT NULL, `source` varchar(4096) COLLATE $collation DEFAULT NULL, `size` bigint(20) UNSIGNED NOT NULL DEFAULT 0, `time` int(11) UNSIGNED NOT NULL DEFAULT 0, `website` varchar(255) COLLATE $collation DEFAULT NULL, `description` varchar(4096) COLLATE $collation DEFAULT NULL, `author` varchar(64) COLLATE $collation DEFAULT NULL, `category` varchar(64) COLLATE $collation DEFAULT NULL, `played` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `pubdate` int(11) UNSIGNED NOT NULL, `addition_time` int(11) UNSIGNED NOT NULL, `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0, `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0, `waveform` mediumblob DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'cache_object_count' => \"CREATE TABLE IF NOT EXISTS `cache_object_count` ( `object_id` int(11) UNSIGNED NOT NULL, `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL, `count` int(11) UNSIGNED NOT NULL DEFAULT 0, `threshold` int(11) UNSIGNED NOT NULL DEFAULT 0, `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL, PRIMARY KEY (`object_id`,`object_type`,`threshold`,`count_type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'cache_object_count_run' => \"CREATE TABLE IF NOT EXISTS `cache_object_count_run` ( `object_id` int(11) UNSIGNED NOT NULL, `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL, `count` int(11) UNSIGNED NOT NULL DEFAULT 0, `threshold` int(11) UNSIGNED NOT NULL DEFAULT 0, `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL, PRIMARY KEY (`object_id`,`object_type`,`threshold`,`count_type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'catalog_map' => \"CREATE TABLE IF NOT EXISTS `catalog_map` ( `catalog_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, UNIQUE KEY `unique_catalog_map` (`object_id`,`object_type`,`catalog_id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'user_playlist' => \"CREATE TABLE IF NOT EXISTS `user_playlist` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) DEFAULT NULL, `object_type` enum('song','live_stream','video','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL DEFAULT 0, `track` smallint(6) DEFAULT NULL, `current_track` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `current_time` smallint(5) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`), KEY `user` (`user`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'user_data' => \"CREATE TABLE IF NOT EXISTS `user_data` ( `user` int(11) DEFAULT NULL, `key` varchar(128) COLLATE $collation DEFAULT NULL, `value` varchar(255) COLLATE $collation DEFAULT NULL, UNIQUE KEY `unique_data` (`user`,`key`), KEY `user` (`user`), KEY `key` (`key`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'deleted_song' => \"CREATE TABLE IF NOT EXISTS `deleted_song` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED DEFAULT 0, `delete_time` int(11) UNSIGNED DEFAULT 0, `title` varchar(255) COLLATE $collation DEFAULT NULL, `file` varchar(4096) COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0, `update_time` int(11) UNSIGNED DEFAULT 0, `album` int(11) UNSIGNED NOT NULL DEFAULT 0, `artist` int(11) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'deleted_video' => \"CREATE TABLE IF NOT EXISTS `deleted_video` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED NOT NULL, `delete_time` int(11) UNSIGNED NOT NULL, `title` varchar(255) COLLATE $collation DEFAULT NULL, `file` varchar(4096) COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL, `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'deleted_podcast_episode' => \"CREATE TABLE IF NOT EXISTS `deleted_podcast_episode` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED NOT NULL, `delete_time` int(11) UNSIGNED NOT NULL, `title` varchar(255) COLLATE $collation DEFAULT NULL, `file` varchar(4096) COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL, `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0, `podcast` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'artist_map' => \"CREATE TABLE IF NOT EXISTS `artist_map` ( `artist_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) COLLATE utf8_unicode_ci DEFAULT NULL, UNIQUE KEY `unique_artist_map` (`object_id`,`object_type`,`artist_id`), KEY `object_id_index` (`object_id`), KEY `artist_id_index` (`artist_id`), KEY `artist_id_type_index` (`artist_id`,`object_type`), KEY `object_id_type_index` (`object_id`,`object_type`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\",\n            'album_map' => \"CREATE TABLE IF NOT EXISTS `album_map` ( `album_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) COLLATE utf8_unicode_ci DEFAULT NULL, UNIQUE KEY `unique_album_map` (`object_id`,`object_type`,`album_id`), KEY `object_id_index` (`object_id`), KEY `album_id_type_index` (`album_id`,`object_type`), KEY `object_id_type_index` (`object_id`,`object_type`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\",\n            'catalog_filter_group' => \"CREATE TABLE IF NOT EXISTS `catalog_filter_group` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;INSERT IGNORE INTO `catalog_filter_group` (`name`) VALUES ('DEFAULT'); UPDATE `catalog_filter_group` SET `id` = 0 WHERE `name` = 'DEFAULT'; ALTER TABLE `catalog_filter_group` AUTO_INCREMENT = 1;\",\n            'catalog_filter_group_map' => \"CREATE TABLE IF NOT EXISTS `catalog_filter_group_map` (`group_id` int(11) UNSIGNED NOT NULL, `catalog_id` int(11) UNSIGNED NOT NULL, `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, UNIQUE KEY (group_id,catalog_id)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\"\n        );\n        $versions   = array(\n            'image' => 360003,\n            'tmp_browse' => 360005,\n            'share' => 360037,\n            'broadcast' => 360042,\n            'player_control' => 360042,\n            'recommendation' => 360044,\n            'recommendation_item' => 360044,\n            'license' => 370004,\n            'daap_session' => 370007,\n            'tvshow' => 370009,\n            'tvshow_season' => 370009,\n            'tvshow_episode' => 370009,\n            'movie' => 370009,\n            'personal_video' => 370009,\n            'clip' => 370009,\n            'tag_merge' => 370018,\n            'label' => 370033,\n            'label_asso' => 370033,\n            'user_pvmsg' => 370034,\n            'user_follower' => 370034,\n            'metadata_field' => 370041,\n            'metadata' => 370041,\n            'podcast' => 380001,\n            'podcast_episode' => 380001,\n            'cache_object_count' => 400008,\n            'cache_object_count_run' => 400008,\n            'catalog_map' => 500004,\n            'user_playlist' => 500006,\n            'user_data' => 500006,\n            'deleted_song' => 500013,\n            'deleted_video' => 500013,\n            'deleted_podcast_episode' => 500013,\n            'artist_map' => 530000,\n            'album_map' => 530001,\n            'catalog_filter_group' => 550001,\n            'catalog_filter_group_map' => 550001\n        );\n        foreach ($tables as $table_name => $table_sql) {\n            $sql        = \"DESCRIBE `$table_name`;\";\n            $db_results = Dba::read($sql);\n            // you might not be at the version required for this table so make sure it actually is missing.\n            if (!$db_results && $db_version >= $versions[$table_name]) {\n                $missing[] = $table_name;\n                if (!$execute) {\n                    debug_event(__CLASS__, 'MISSING TABLE: ' . $table_name, 1);\n                    continue;\n                }\n                if (Dba::write($table_sql)) {\n                    debug_event(__CLASS__, 'CREATED MISSING TABLE: ' . $table_name, 1);\n                }\n            }\n        }\n\n        return $missing;\n    }\n\n    /**\n     * format_version\n     *\n     * Make the version number pretty.\n     * @param string $data\n     * @return string\n     */\n    public static function format_version($data)\n    {\n        return substr($data, 0, strlen((string)$data) - 5) . '.' . substr($data, strlen((string)$data) - 5, 1) . ' Build:' . substr($data, strlen((string)$data) - 4, strlen((string)$data));\n    }\n\n    /**\n     * need_update\n     *\n     * Checks to see if we need to update ampache at all.\n     */\n    public static function need_update(): bool\n    {\n        $current_version = self::get_version();\n\n        if (!is_array(self::$versions)) {\n            self::$versions = self::populate_version();\n        }\n\n        // Iterate through the versions and see if we need to apply any updates\n        foreach (self::$versions as $update) {\n            if ($update['version'] > $current_version) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * populate_version\n     * just sets an array the current differences\n     * that require an update\n     * @return array\n     */\n    public static function populate_version()\n    {\n        /* Define the array */\n        $version = array();\n\n        $update_string = \"* Add MBID (MusicBrainz ID) fields<br />* Remove useless preferences<br />\";\n        $version[]     = array('version' => '360001', 'description' => $update_string);\n\n        $update_string = \"* Add Bandwidth and Feature preferences to simplify how interface is presented<br />* Change Tables to FULLTEXT() for improved searching<br />* Increase Filename lengths to 4096<br />* Remove useless KEY reference from ACL and Catalog tables<br />* Add new Remote User / Remote Password fields to Catalog<br />\";\n        $version[]     = array('version' => '360002', 'description' => $update_string);\n\n        $update_string = \"* Add image table to store images.<br />* Drop album_data and artist_data.<br />\";\n        $version[]     = array('version' => '360003', 'description' => $update_string);\n\n        $update_string = \"* Add uniqueness constraint to ratings.<br />\";\n        $version[]     = array('version' => '360004', 'description' => $update_string);\n\n        $update_string = \"* Modify tmp_browse to allow caching of multiple browses per session.<br />\";\n        $version[]     = array('version' => '360005', 'description' => $update_string);\n\n        $update_string = \"* Add table for dynamic playlists.<br />\";\n        $version[]     = array('version' => '360006', 'description' => $update_string);\n\n        $update_string = \"* Verify remote_username and remote_password were added correctly to catalog table.<br />\";\n        $version[]     = array('version' => '360008', 'description' => $update_string);\n\n        $update_string = \"* Allow long sessionids in tmp_playlist table.<br />\";\n        $version[]     = array('version' => '360009', 'description' => $update_string);\n\n        $update_string = \"* Allow compound MBIDs in the artist table.<br />\";\n        $version[]     = array('version' => '360010', 'description' => $update_string);\n\n        $update_string = \"* Add table to store stream session playlist.<br />\";\n        $version[]     = array('version' => '360011', 'description' => $update_string);\n\n        $update_string = \"* Drop enum for the type field in session.<br />\";\n        $version[]     = array('version' => '360012', 'description' => $update_string);\n\n        $update_string = \"* Update stream_playlist table to address performance issues.<br />\";\n        $version[]     = array('version' => '360013', 'description' => $update_string);\n\n        $update_string = \"* Increase the length of sessionids again.<br />\";\n        $version[]     = array('version' => '360014', 'description' => $update_string);\n\n        $update_string = \"* Add iframes parameter to preferences.<br />\";\n        $version[]     = array('version' => '360015', 'description' => $update_string);\n\n        $update_string = \"* Optionally filter Now Playing to return only the last song per user.<br />\";\n        $version[]     = array('version' => '360016', 'description' => $update_string);\n\n        $update_string = \"* Add user flags on objects.<br />\";\n        $version[]     = array('version' => '360017', 'description' => $update_string);\n\n        $update_string = \"* Add album default sort value to preferences.<br />\";\n        $version[]     = array('version' => '360018', 'description' => $update_string);\n\n        $update_string = \"* Add option to show number of times a song was played.<br />\";\n        $version[]     = array('version' => '360019', 'description' => $update_string);\n\n        $update_string = \"* Catalog types are plugins now.<br />\";\n        $version[]     = array('version' => '360020', 'description' => $update_string);\n\n        $update_string = \"* Add insertion date on Now Playing and option to show the current song in page title for Web player.<br />\";\n        $version[]     = array('version' => '360021', 'description' => $update_string);\n\n        $update_string = \"* Remove unused live_stream fields and add codec field.<br />\";\n        $version[]     = array('version' => '360022', 'description' => $update_string);\n\n        $update_string = \"* Enable/Disable SubSonic and Plex backend.<br />\";\n        $version[]     = array('version' => '360023', 'description' => $update_string);\n\n        $update_string = \"* Drop flagged table.<br />\";\n        $version[]     = array('version' => '360024', 'description' => $update_string);\n\n        $update_string = \"* Add options to enable HTML5 / Flash on web players.<br />\";\n        $version[]     = array('version' => '360025', 'description' => $update_string);\n\n        $update_string = \"* Added agent to `object_count` table.<br />\";\n        $version[]     = array('version' => '360026', 'description' => $update_string);\n\n        $update_string = \"* Add option to allow/disallow to show personnal information to other users (now playing and recently played).<br />\";\n        $version[]     = array('version' => '360027', 'description' => $update_string);\n\n        $update_string = \"* Personnal information: allow/disallow to show in now playing.<br />* Personnal information: allow/disallow to show in recently played.<br />* Personnal information: allow/disallow to show time and/or agent in recently played.<br />\";\n        $version[]     = array('version' => '360028', 'description' => $update_string);\n\n        $update_string = \"* Add new table to store wanted releases.<br />\";\n        $version[]     = array('version' => '360029', 'description' => $update_string);\n\n        $update_string = \"* New table to store song previews.<br />\";\n        $version[]     = array('version' => '360030', 'description' => $update_string);\n\n        $update_string = \"* Add option to fix header position on compatible themes.<br />\";\n        $version[]     = array('version' => '360031', 'description' => $update_string);\n\n        $update_string = \"* Add check update automatically option.<br />\";\n        $version[]     = array('version' => '360032', 'description' => $update_string);\n\n        $update_string = \"* Add song waveform as song data.<br />\";\n        $version[]     = array('version' => '360033', 'description' => $update_string);\n\n        $update_string = \"* Add settings for confirmation when closing window and auto-pause between tabs.<br />\";\n        $version[]     = array('version' => '360034', 'description' => $update_string);\n\n        $update_string = \"* Add beautiful stream url setting.<br />\";\n        $version[]     = array('version' => '360035', 'description' => $update_string);\n\n        $update_string = \"* Remove unused parameters.<br />\";\n        $version[]     = array('version' => '360036', 'description' => $update_string);\n\n        $update_string = \"* Add sharing features.<br />\";\n        $version[]     = array('version' => '360037', 'description' => $update_string);\n\n        $update_string = \"* Add missing albums browse on missing artists.<br />\";\n        $version[]     = array('version' => '360038', 'description' => $update_string);\n\n        $update_string = \"* Add website field on users.<br />\";\n        $version[]     = array('version' => '360039', 'description' => $update_string);\n\n        $update_string = \"* Add channels.<br />\";\n        $version[]     = array('version' => '360041', 'description' => $update_string);\n\n        $update_string = \"* Add broadcasts and player control.<br />\";\n        $version[]     = array('version' => '360042', 'description' => $update_string);\n\n        $update_string = \"* Add slideshow on currently played artist preference.<br />\";\n        $version[]     = array('version' => '360043', 'description' => $update_string);\n\n        $update_string = \"* Add artist description/recommendation external service data cache.<br />\";\n        $version[]     = array('version' => '360044', 'description' => $update_string);\n\n        $update_string = \"* Set user field on playlists as optional.<br />\";\n        $version[]     = array('version' => '360045', 'description' => $update_string);\n\n        $update_string = \"* Add broadcast web player by default preference.<br />\";\n        $version[]     = array('version' => '360046', 'description' => $update_string);\n\n        $update_string = \"* Add apikey field on users.<br />\";\n        $version[]     = array('version' => '360047', 'description' => $update_string);\n\n        $update_string = \"* Add concerts options.<br />\";\n        $version[]     = array('version' => '360048', 'description' => $update_string);\n\n        $update_string = \"* Add album group multiple disks setting.<br />\";\n        $version[]     = array('version' => '360049', 'description' => $update_string);\n\n        $update_string = \"* Add top menu setting.<br />\";\n        $version[]     = array('version' => '360050', 'description' => $update_string);\n\n        $update_string = \"* Copy default .htaccess configurations.<br />\";\n        $version[]     = array('version' => '360051', 'description' => $update_string);\n\n        $update_string = \"* Drop unused dynamic_playlist tables and add session id to votes.<br />\";\n        $version[]     = array('version' => '370001', 'description' => $update_string);\n\n        $update_string = \"* Add tag persistent merge reference.<br />\";\n        $version[]     = array('version' => '370002', 'description' => $update_string);\n\n        $update_string = \"* Add show/hide donate button preference.<br />\";\n        $version[]     = array('version' => '370003', 'description' => $update_string);\n\n        $update_string = \"* Add license information and user's artist association.<br />\";\n        $version[]     = array('version' => '370004', 'description' => $update_string);\n\n        $update_string = \"* Add new column album_artist into table song.<br />\";\n        $version[]     = array('version' => '370005', 'description' => $update_string);\n\n        $update_string = \"* Add random and limit options to smart playlists.<br />\";\n        $version[]     = array('version' => '370006', 'description' => $update_string);\n\n        $update_string = \"* Add DAAP backend preference.<br />\";\n        $version[]     = array('version' => '370007', 'description' => $update_string);\n\n        $update_string = \"* Add UPnP backend preference.<br />\";\n        $version[]     = array('version' => '370008', 'description' => $update_string);\n\n        $update_string = \"* Enhance video support with TVShows and Movies.<br />\";\n        $version[]     = array('version' => '370009', 'description' => $update_string);\n\n        $update_string = \"* Add MusicBrainz Album Release Group identifier.<br />\";\n        $version[]     = array('version' => '370010', 'description' => $update_string);\n\n        $update_string = \"* Add Prefix to TVShows and Movies.<br />\";\n        $version[]     = array('version' => '370011', 'description' => $update_string);\n\n        $update_string = \"* Add metadata information to albums / songs / videos.<br />\";\n        $version[]     = array('version' => '370012', 'description' => $update_string);\n\n        $update_string = \"* Replace iframe with ajax page load.<br />\";\n        $version[]     = array('version' => '370013', 'description' => $update_string);\n\n        $update_string = \"* Modified release_date in video table to signed int.<br />\";\n        $version[]     = array('version' => '370014', 'description' => $update_string);\n\n        $update_string = \"* Add session_remember table to store remember tokens.<br />\";\n        $version[]     = array('version' => '370015', 'description' => $update_string);\n\n        $update_string = \"* Add limit of media count for direct play preference.<br />\";\n        $version[]     = array('version' => '370016', 'description' => $update_string);\n\n        $update_string = \"* Add home display settings.<br />\";\n        $version[]     = array('version' => '370017', 'description' => $update_string);\n\n        $update_string = \"* Enhance tag persistent merge reference.<br />\";\n        $version[]     = array('version' => '370018', 'description' => $update_string);\n\n        $update_string = \"* Add album group order setting.<br />\";\n        $version[]     = array('version' => '370019', 'description' => $update_string);\n\n        $update_string = \"* Add webplayer browser notification settings.<br />\";\n        $version[]     = array('version' => '370020', 'description' => $update_string);\n\n        $update_string = \"* Add rating to playlists, tvshows and tvshows seasons.<br />\";\n        $version[]     = array('version' => '370021', 'description' => $update_string);\n\n        $update_string = \"* Add users geolocation.<br />\";\n        $version[]     = array('version' => '370022', 'description' => $update_string);\n\n        $update_string = \"* Add Aurora.js webplayer option.<br />\";\n        $version[]     = array('version' => '370023', 'description' => $update_string);\n\n        $update_string = \"* Add count_type column to object_count table.<br />\";\n        $version[]     = array('version' => '370024', 'description' => $update_string);\n\n        $update_string = \"* Add state and city fields to user table.<br />\";\n        $version[]     = array('version' => '370025', 'description' => $update_string);\n\n        $update_string = \"* Add replay gain fields to song_data table.<br />\";\n        $version[]     = array('version' => '370026', 'description' => $update_string);\n\n        $update_string = \"* Move column album_artist from table song to table album.<br />\";\n        $version[]     = array('version' => '370027', 'description' => $update_string);\n\n        $update_string = \"* Add width and height in table image.<br />\";\n        $version[]     = array('version' => '370028', 'description' => $update_string);\n\n        $update_string = \"* Set image column from image table as nullable.<br />\";\n        $version[]     = array('version' => '370029', 'description' => $update_string);\n\n        $update_string = \"* Add an option to allow users to remove uploaded songs.<br />\";\n        $version[]     = array('version' => '370030', 'description' => $update_string);\n\n        $update_string = \"* Add an option to customize login art, favicon and text footer.<br />\";\n        $version[]     = array('version' => '370031', 'description' => $update_string);\n\n        $update_string = \"* Add WebDAV backend preference.<br />\";\n        $version[]     = array('version' => '370032', 'description' => $update_string);\n\n        $update_string = \"* Add Label tables.<br />\";\n        $version[]     = array('version' => '370033', 'description' => $update_string);\n\n        $update_string = \"* Add User messages and user follow tables.<br />\";\n        $version[]     = array('version' => '370034', 'description' => $update_string);\n\n        $update_string = \"* Add option on user fullname to show/hide it publicly.<br />\";\n        $version[]     = array('version' => '370035', 'description' => $update_string);\n\n        $update_string = \"* Add track number field to stream_playlist table.<br />\";\n        $version[]     = array('version' => '370036', 'description' => $update_string);\n\n        $update_string = \"* Delete http_port preference (use ampache.cfg.php configuration instead).<br />\";\n        $version[]     = array('version' => '370037', 'description' => $update_string);\n\n        $update_string = \"* Add theme color option.<br />\";\n        $version[]     = array('version' => '370038', 'description' => $update_string);\n\n        $update_string = \"* Renamed false named sample_rate option name in preference table.<br />\";\n        $version[]     = array('version' => '370039', 'description' => $update_string);\n\n        $update_string = \"* Add user_activity table.<br />\";\n        $version[]     = array('version' => '370040', 'description' => $update_string);\n\n        $update_string = \"* Add basic metadata tables.<br />\";\n        $version[]     = array('version' => '370041', 'description' => $update_string);\n\n        $update_string = \"* Add podcasts.<br />\";\n        $version[]     = array('version' => '380001', 'description' => $update_string);\n\n        $update_string = \"* Add bookmarks.<br />\";\n        $version[]     = array('version' => '380002', 'description' => $update_string);\n\n        $update_string = \"* Add unique constraint on tag_map table.<br />\";\n        $version[]     = array('version' => '380003', 'description' => $update_string);\n\n        $update_string = \"* Add preference subcategory.<br />\";\n        $version[]     = array('version' => '380004', 'description' => $update_string);\n\n        $update_string = \"* Add manual update flag on artist.<br />\";\n        $version[]     = array('version' => '380005', 'description' => $update_string);\n\n        $update_string = \"* Add library item context menu option.<br />\";\n        $version[]     = array('version' => '380006', 'description' => $update_string);\n\n        $update_string = \"* Add upload rename pattern and ignore duplicate options.<br />\";\n        $version[]     = array('version' => '380007', 'description' => $update_string);\n\n        $update_string = \"* Add browse filter and light sidebar options.<br />\";\n        $version[]     = array('version' => '380008', 'description' => $update_string);\n\n        $update_string = \"* Add update date to playlist.<br />\";\n        $version[]     = array('version' => '380009', 'description' => $update_string);\n\n        $update_string = \"* Add custom blank album/video default image and alphabet browsing options.<br />\";\n        $version[]     = array('version' => '380010', 'description' => $update_string);\n\n        $update_string = \"* Fix username max size to be the same one across all tables.<br />\";\n        $version[]     = array('version' => '380011', 'description' => $update_string);\n\n        $update_string = \"* Fix change in <a href='https://github.com/ampache/ampache/commit/0c26c336269624d75985e46d324e2bc8108576ee'>this commit</a>, that left the userbase with an inconsistent database, if users updated or installed Ampache before 28 Apr 2015<br />\";\n        $version[]     = array('version' => '380012', 'description' => $update_string);\n\n        $update_string = \"* Enable better podcast defaults<br />* Increase copyright column size to fix issue #1861<br />* Add name_track, name_artist, name_album to user_activity<br />* Add mbid_track, mbid_artist, mbid_album to user_activity<br />* Insert some decent SmartLists for a better default experience<br />* Delete plex preferences from the server<br />\";\n        $version[]     = array('version' => '400000', 'description' => $update_string);\n\n        $update_string = \"* Update preferences for older users to match current subcategory items<br /> (~3.6 introduced subcategories but didn't include updates for existing users.<br /> This is a cosmetic update and does not affect any operation)<br />\";\n        $version[]     = array('version' => '400001', 'description' => $update_string);\n\n        $update_string = \"**IMPORTANT UPDATE NOTES**<br /><br /> This is part of a major update to how Ampache handles Albums, Artists and data migration during tag updates.<br /><br />* Update album disk support to allow 1 instead of 0 by default.<br />* Add barcode catalog_number and original_year to albums.<br />* Drop catalog_number from song_data and use album instead.<br />\";\n        $version[]     = array('version' => '400002', 'description' => $update_string);\n\n        $update_string = \"* Make sure preference names are updated to current strings<br />\";\n        $version[]     = array('version' => '400003', 'description' => $update_string);\n\n        $update_string = \"* Delete upload_user_artist database settings<br />\";\n        $version[]     = array('version' => '400004', 'description' => $update_string);\n\n        $update_string = \"* Add a last_count to search table to speed up access requests<br />\";\n        $version[]     = array('version' => '400005', 'description' => $update_string);\n\n        $update_string = \"* Drop shoutcast_active preferences. (Feature has not existed for years)<br />* Drop localplay_shoutcast table if present.<br />\";\n        $version[]     = array('version' => '400006', 'description' => $update_string);\n\n        $update_string = \"* Add ui option for skip_count display.<br />* Add ui option for displaying dates in a custom format.<br />\";\n        $version[]     = array('version' => '400007', 'description' => $update_string);\n\n        $update_string = \"* Add system option for cron based cache and create related tables.<br />\";\n        $version[]     = array('version' => '400008', 'description' => $update_string);\n\n        $update_string = \"* Add ui option for forcing unique items to playlists.<br />\";\n        $version[]     = array('version' => '400009', 'description' => $update_string);\n\n        $update_string = \"* Add a last_duration to search table to speed up access requests<br />\";\n        $version[]     = array('version' => '400010', 'description' => $update_string);\n\n        $update_string = \"**IMPORTANT UPDATE NOTES**<br /><br /> To allow negatives the maximum value of `song`.`track` has been reduced. This shouldn't affect anyone due to the large size allowed.<br /><br />* Allow negative track numbers for albums. (-32,767 -> 32,767)<br />* Truncate database tracks to 0 when greater than 32,767<br />\";\n        $version[]     = array('version' => '400011', 'description' => $update_string);\n\n        $update_string = \"* Add a rss token to allow the use of RSS unauthenticated feeds<br/ >\";\n        $version[]     = array('version' => '400012', 'description' => $update_string);\n\n        $update_string = \"* Extend Democratic cooldown beyond 255.<br/ >\";\n        $version[]     = array('version' => '400013', 'description' => $update_string);\n\n        $update_string = \"* Add last_duration to playlist<br/ > * Add time to artist and album<br/ >\";\n        $version[]     = array('version' => '400014', 'description' => $update_string);\n\n        $update_string = \"* Extend artist time. smallint was too small<br/ > \";\n        $version[]     = array('version' => '400015', 'description' => $update_string);\n\n        $update_string = \"* Extend album and make artist even bigger. This should cover everyone.<br/ > \";\n        $version[]     = array('version' => '400016', 'description' => $update_string);\n\n        $update_string = \"\"; // REMOVED update\n        $version[]     = array('version' => '400017', 'description' => $update_string);\n\n        $update_string = \"* Extend video bitrate to unsigned. There's no reason for a negative bitrate.<br/ > \";\n        $version[]     = array('version' => '400018', 'description' => $update_string);\n\n        $update_string = \"* Put 'of_the_moment' into a per user preference.<br/ > \";\n        $version[]     = array('version' => '400019', 'description' => $update_string);\n\n        $update_string = \"* Customizable login page background.<br/ > \";\n        $version[]     = array('version' => '400020', 'description' => $update_string);\n\n        $update_string = \"* Add r128 gain columns to song_data.<br/ > \";\n        $version[]     = array('version' => '400021', 'description' => $update_string);\n\n        $update_string = \"* Extend allowed time for podcast_episodes.<br/ > \";\n        $version[]     = array('version' => '400022', 'description' => $update_string);\n\n        $update_string = \"* Delete 'concerts_limit_past' and 'concerts_limit_future' database settings.<br/ > \";\n        $version[]     = array('version' => '400023', 'description' => $update_string);\n\n        $update_string = \"**IMPORTANT UPDATE NOTES**<br />These columns will fill dynamically in the web UI but you should do a catalog 'add' as soon as possible to fill them.<br />It will take a while for large libraries but will help API and SubSonic clients.<br /><br />* Add 'song_count', 'album_count' and 'album_group_count' to artist. <br />\";\n        $version[]     = array('version' => '400024', 'description' => $update_string);\n\n        $update_string = \"* Delete duplicate files in the song table<br />\";\n        $version[]     = array('version' => '500000', 'description' => $update_string);\n\n        $update_string = \"* Add `release_status`, `addition_time`, `catalog` to album table<br />* Add `mbid`, `country` and `active` to label table<br />* Fill the album `catalog` value using the song table<br />* Fill the artist `album_count`, `album_group_count` and `song_count` values\";\n        $version[]     = array('version' => '500001', 'description' => $update_string);\n\n        $update_string = \"* Create `total_count` and `total_skip` to album, artist, song, video and podcast_episode tables<br />* Fill counts into the columns\";\n        $version[]     = array('version' => '500002', 'description' => $update_string);\n\n        $update_string = \"* Add `catalog` to podcast_episode table\";\n        $version[]     = array('version' => '500003', 'description' => $update_string);\n\n        $update_string = \"**IMPORTANT UPDATE NOTES**<br />For large catalogs this will be slow!<br />* Create catalog_map table and fill it with data\";\n        $version[]     = array('version' => '500004', 'description' => $update_string);\n\n        $update_string = \"* Add song_count, artist_count to album\";\n        $version[]     = array('version' => '500005', 'description' => $update_string);\n\n        $update_string = \"* Add user_playlist and user_data table\";\n        $version[]     = array('version' => '500006', 'description' => $update_string);\n\n        $update_string = \"* Add a 'Browse' category to interface preferences<br />* Add option ('show_license') for hiding license column in song rows\";\n        $version[]     = array('version' => '500007', 'description' => $update_string);\n\n        $update_string = \"* Add filter_user to catalog table<br />* Set a unique key on user_data\";\n        $version[]     = array('version' => '500008', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('use_original_year') Browse by Original Year for albums (falls back to Year)\";\n        $version[]     = array('version' => '500009', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('hide_single_artist') Hide the Song Artist column for Albums with one Artist\";\n        $version[]     = array('version' => '500010', 'description' => $update_string);\n\n        $update_string = \"* Add `total_count` to podcast table and fill counts into the column\";\n        $version[]     = array('version' => '500011', 'description' => $update_string);\n\n        $update_string = \"* Move user bandwidth calculations out of the user format function into the user_data table\";\n        $version[]     = array('version' => '500012', 'description' => $update_string);\n\n        $update_string = \"* Add tables for tracking deleted files. (deleted_song, deleted_video, deleted_podcast_episode)<br />* Add username to the playlist table to stop pulling user all the time\";\n        $version[]     = array('version' => '500013', 'description' => $update_string);\n\n        $update_string = \"* Add `episodes` to podcast table to track episode count\";\n        $version[]     = array('version' => '500014', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('hide_genres') Hide the Genre column in browse table rows\";\n        $version[]     = array('version' => '500015', 'description' => $update_string);\n\n        $update_string = \"* Add podcast to the object_count table\";\n        $version[]     = array('version' => '510000', 'description' => $update_string);\n\n        $update_string = \"* Add podcast to the cache_object_count tables\";\n        $version[]     = array('version' => '510001', 'description' => $update_string);\n\n        $update_string = \"\"; // REMOVED update\n        $version[]     = array('version' => '510002', 'description' => $update_string);\n\n        $update_string = \"* Add live_stream to the rating table\";\n        $version[]     = array('version' => '510003', 'description' => $update_string);\n\n        $update_string = \"* Add waveform column to podcast_episode table\";\n        $version[]     = array('version' => '510004', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('subsonic_always_download') Force Subsonic streams to download. (Enable scrobble in your client to record stats)\";\n        $version[]     = array('version' => '510005', 'description' => $update_string);\n\n        $update_string = \"* Add ui options ('api_enable_3', 'api_enable_4', 'api_enable_5') to enable/disable specific API versions<br />* Add ui option ('api_force_version') to to force a specific API response (even if that version is disabled)\";\n        $version[]     = array('version' => '520000', 'description' => $update_string);\n\n        $update_string = \"* Make sure preference names are always unique\";\n        $version[]     = array('version' => '520001', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('show_playlist_username') Show playlist owner username in titles\";\n        $version[]     = array('version' => '520002', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('api_hidden_playlists') Hide playlists in Subsonic and API clients that start with this string\";\n        $version[]     = array('version' => '520003', 'description' => $update_string);\n\n        $update_string = \"* Set 'plugins' category to lastfm_challenge preference\";\n        $version[]     = array('version' => '520004', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('api_hide_dupe_searches') Hide smartlists that match playlist names in Subsonic and API clients\";\n        $version[]     = array('version' => '520005', 'description' => $update_string);\n\n        $update_string = \"**IMPORTANT UPDATE NOTES**<br />For large catalogs this will be slow!<br />* Create artist_map table and fill it with data\";\n        $version[]     = array('version' => '530000', 'description' => $update_string);\n\n        $update_string = \"* Create album_map table and fill it with data\";\n        $version[]     = array('version' => '530001', 'description' => $update_string);\n\n        $update_string = \"* Use song_count & artist_count with album_map\";\n        $version[]     = array('version' => '530002', 'description' => $update_string);\n\n        $update_string = \"* Drop id column from catalog_map table<br />* Alter `catalog_map` object_type charset and collation\";\n        $version[]     = array('version' => '530003', 'description' => $update_string);\n\n        $update_string = \"* Alter `album_map` table charset and engine to MyISAM if engine set\";\n        $version[]     = array('version' => '530004', 'description' => $update_string);\n\n        $update_string = \"* Alter `artist_map` table charset and engine to MyISAM if engine set\";\n        $version[]     = array('version' => '530005', 'description' => $update_string);\n\n        $update_string = \"* Make sure `object_count` table has all the correct primary artist/album rows\";\n        $version[]     = array('version' => '530006', 'description' => $update_string);\n\n        $update_string = \"* Convert basic text columns into utf8 to reduce index sizes\";\n        $version[]     = array('version' => '530007', 'description' => $update_string);\n\n        $update_string = \"* Remove `user_activity` columns that are useless\";\n        $version[]     = array('version' => '530008', 'description' => $update_string);\n\n        $update_string = \"* Compact `object_count` columns\";\n        $version[]     = array('version' => '530009', 'description' => $update_string);\n\n        $update_string = \"* Compact mbid columns back to 36 characters\";\n        $version[]     = array('version' => '530010', 'description' => $update_string);\n\n        $update_string = \"* Compact some `user` columns<br />* enum `object_count`.`count_type`\";\n        $version[]     = array('version' => '530011', 'description' => $update_string);\n\n        $update_string = \"* Index data on object_count\";\n        $version[]     = array('version' => '530012', 'description' => $update_string);\n\n        $update_string = \"* Compact `cache_object_count`, `cache_object_count_run` columns\";\n        $version[]     = array('version' => '530013', 'description' => $update_string);\n\n        $update_string = \"* Delete `object_count` duplicates<br />* Use a smaller unique index on `object_count`\";\n        $version[]     = array('version' => '530014', 'description' => $update_string);\n\n        $update_string = \"* Add `show_album_artist` and `show_artist` preferences to show/hide Sidebar Browse menu links<br />* Fallback to Album Artist if both disabled\";\n        $version[]     = array('version' => '530015', 'description' => $update_string);\n\n        $update_string = \"* Add missing rating item back in the type enum\";\n        $version[]     = array('version' => '530016', 'description' => $update_string);\n\n        $update_string = \"* Index `title` with `enabled` on `song` table to speed up searching\";\n        $version[]     = array('version' => '540000', 'description' => $update_string);\n\n        $update_string = \"* Index `album` table columns.<br />* `catalog`, `album_artist`, `original_year`, `release_type`, `release_status`, `mbid`, `mbid_group`\";\n        $version[]     = array('version' => '540001', 'description' => $update_string);\n\n        $update_string = \"* Index `object_type` with `date` in `object_count` table\";\n        $version[]     = array('version' => '540002', 'description' => $update_string);\n\n        $update_string = \"* Add tables `catalog_filter_group` and `catalog_filter_group_map` for catalog filtering by groups<br />* Add column `catalog_filter_group` to `user` table to assign a filter group\";\n        $version[]     = array('version' => '550001', 'description' => $update_string);\n\n        $update_string = \"* Migrate catalog `filter_user` settings to the `catalog_filter_group` table<br>* Assign all public catalogs to the DEFAULT group<br>* Drop table `user_catalog`<br>* Remove `filter_user` from the `catalog` table<br><br><br>**IMPORTANT UPDATE NOTES** Any user that has a private catalog will have their own filter group created which includes all public catalogs\";\n        $version[]     = array('version' => '550002', 'description' => $update_string);\n\n        $update_string = \"* Add system preference `demo_use_search`, Use smartlists for base playlist in Democratic play\";\n        $version[]     = array('version' => '550003', 'description' => $update_string);\n\n        $update_string = \"* Make `demo_use_search`a system preference correctly\";\n        $version[]     = array('version' => '550004', 'description' => $update_string);\n\n        $update_string = \"* Add `song_artist` and `album_artist` maps to catalog_map\";\n        $version[]     = array('version' => '550005', 'description' => $update_string);\n\n        return $version;\n    }\n\n    /**\n     * display_update\n     * This displays a list of the needed\n     * updates to the database. This will actually\n     * echo out the list...\n     */\n    public static function display_update(): array\n    {\n        $result          = [];\n        $current_version = self::get_version();\n        if (!is_array(self::$versions)) {\n            self::$versions = self::populate_version();\n        }\n\n        foreach (self::$versions as $update) {\n            if ($update['version'] > $current_version) {\n                $result[] = [\n                    'version' => T_('Version') . ': ' . self::format_version($update['version']),\n                    'description' => $update['description']\n                ];\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * run_update\n     * This function actually updates the db.\n     * it goes through versions and finds the ones\n     * that need to be run. Checking to make sure\n     * the function exists first.\n     */\n    public static function run_update(): bool\n    {\n        debug_event(self::class, 'run_update: starting', 4);\n        /* Nuke All Active session before we start the mojo */\n        $sql = \"TRUNCATE session\";\n        Dba::write($sql);\n\n        // Prevent the script from timing out, which could be bad\n        set_time_limit(0);\n\n        $current_version = self::get_version();\n\n        // Run a check to make sure that they don't try to upgrade from a version that won't work.\n        if ($current_version < '350008') {\n            echo '<p class=\"database-update\">Database version too old, please upgrade to <a href=\"https://github.com/ampache/ampache/releases/download/3.8.2/ampache-3.8.2_all.zip\">Ampache-3.8.2</a> first</p>';\n\n            return false;\n        }\n\n        $methods = get_class_methods(Update::class);\n\n        if (!is_array((self::$versions))) {\n            self::$versions = self::populate_version();\n        }\n\n        debug_event(self::class, 'run_update: checking versions', 4);\n        foreach (self::$versions as $version) {\n            // If it's newer than our current version let's see if a function\n            // exists and run the bugger.\n            if ($version['version'] > $current_version) {\n                $update_function = \"update_\" . $version['version'];\n                if (in_array($update_function, $methods)) {\n                    $success = call_user_func(array('Ampache\\Module\\System\\Update', $update_function));\n\n                    // If the update fails drop out\n                    if ($success) {\n                        debug_event(self::class, 'run_update: successfully updated to ' . $version['version'], 3);\n                        self::set_version('db_version', $version['version']);\n                    } else {\n                        echo AmpError::display('update');\n\n                        return false;\n                    }\n                }\n            }\n        } // end foreach version\n\n        // Let's also clean up the preferences unconditionally\n        debug_event(self::class, 'run_update: starting rebuild_all_preferences', 5);\n        User::rebuild_all_preferences();\n        // translate preferences on DB update\n        Preference::translate_db();\n\n        debug_event(self::class, 'run_update: Upgrade complete', 4);\n\n        return true;\n    } // run_update\n\n    /**\n     * set_version\n     *\n     * This updates the 'update_info' which is used by the updater and plugins\n     * @param string $key\n     * @param $value\n     */\n    private static function set_version($key, $value)\n    {\n        $sql = \"UPDATE `update_info` SET `value` = ? WHERE `key` = ?\";\n        Dba::write($sql, array($value, $key));\n    }\n\n    /**\n     * update_360001\n     *\n     * This adds the MB UUIDs to the different tables as well as some additional\n     * cleanup.\n     */\n    public static function update_360001(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `album` ADD `mbid` CHAR (36) AFTER `prefix`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `artist` ADD `mbid` CHAR (36) AFTER `prefix`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song` ADD `mbid` CHAR (36) AFTER `track`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Remove any RIO related information from the database as the plugin has been removed\n        $sql = \"DELETE FROM `update_info` WHERE `key` LIKE 'Plugin_Ri%'\";\n        Dba::write($sql);\n        $sql = \"DELETE FROM `preference` WHERE `name` LIKE 'rio_%'\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_360002\n     *\n     * This update makes changes to the cataloging to accomodate the new method\n     * for syncing between Ampache instances.\n     */\n    public static function update_360002(): bool\n    {\n        $retval = true;\n        // Drop the key from catalog and ACL\n        $sql = \"ALTER TABLE `catalog` DROP `key`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `access_list` DROP `key`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Add in Username / Password for catalog - to be used for remote catalogs\n        $sql = \"ALTER TABLE `catalog` ADD `remote_username` VARCHAR (255) AFTER `catalog_type`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `catalog` ADD `remote_password` VARCHAR (255) AFTER `remote_username`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Adjust the Filename field in song, make it gi-normous. If someone has\n        // anything close to this file length, they seriously need to reconsider\n        // what they are doing.\n        $sql = \"ALTER TABLE `song` CHANGE `file` `file` VARCHAR (4096)\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `video` CHANGE `file` `file` VARCHAR (4096)\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `live_stream` CHANGE `url` `url` VARCHAR (4096)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Index the Artist, Album, and Song tables for fulltext searches.\n        $sql = \"ALTER TABLE `artist` ADD FULLTEXT(`name`)\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `album` ADD FULLTEXT(`name`)\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song` ADD FULLTEXT(`title`)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Now add in the min_object_count preference and the random_method\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('bandwidth', '50', 'Bandwidth', '5', 'integer', 'interface')\";\n        Dba::write($sql);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('features', '50', 'Features', '5', 'integer', 'interface')\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_360003\n     *\n     * This update moves the image data to its own table.\n     */\n    public static function update_360003(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        $sql       = \"CREATE TABLE `image` (`id` int(11) unsigned NOT NULL auto_increment, `image` mediumblob NOT NULL, `mime` varchar(64) NOT NULL, `size` varchar(64) NOT NULL, `object_type` varchar(64) NOT NULL, `object_id` int(11) unsigned NOT NULL, PRIMARY KEY  (`id`), KEY `object_type` (`object_type`), KEY `object_id` (`object_id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation\";\n        $retval &= (Dba::write($sql) !== false);\n\n        foreach (array('album', 'artist') as $type) {\n            $sql        = \"SELECT `\" . $type . \"_id` AS `object_id`, `art`, `art_mime` FROM `\" . $type . \"_data` WHERE `art` IS NOT NULL\";\n            $db_results = Dba::read($sql);\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $sql = \"INSERT INTO `image` (`image`, `mime`, `size`, `object_type`, `object_id`) VALUES('\" . Dba::escape($row['art']) . \"', '\" . $row['art_mime'] . \"', 'original', '\" . $type . \"', '\" . $row['object_id'] . \"')\";\n                Dba::write($sql);\n            }\n            $sql = \"DROP TABLE `\" . $type . \"_data`\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * update_360004\n     *\n     * This update creates an index on the rating table.\n     */\n    public static function update_360004()\n    {\n        return (Dba::write(\"CREATE UNIQUE INDEX `unique_rating` ON `rating` (`user`, `object_type`, `object_id`);\") !== false);\n    }\n\n    /**\n     * update_360005\n     *\n     * This changes the tmp_browse table around.\n     */\n    public static function update_360005(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"DROP TABLE IF EXISTS `tmp_browse`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `tmp_browse` (`id` int(13) NOT NULL auto_increment, `sid` varchar(128) CHARACTER SET $charset NOT NULL default '', `data` longtext NOT NULL, `object_data` longtext, PRIMARY KEY  (`sid`, `id`)) ENGINE=$engine DEFAULT CHARSET=utf8\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360006\n     *\n     * This adds the table for newsearch/dynamic playlists\n     */\n    public static function update_360006(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `search` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) NOT NULL, `type` enum('private', 'public') CHARACTER SET $charset DEFAULT NULL, `rules` mediumtext NOT NULL, `name` varchar(255) CHARACTER SET $charset DEFAULT NULL, `logic_operator` varchar(3) CHARACTER SET $charset DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine AUTO_INCREMENT=4 DEFAULT CHARSET=$charset;\") !== false);\n    }\n\n    /**\n     * update_360008\n     *\n     * Fix bug that caused the remote_username/password fields to not be created.\n     * FIXME: Huh?\n     */\n    public static function update_360008(): bool\n    {\n        $retval          = true;\n        $remote_username = false;\n        $remote_password = false;\n\n        $sql        = \"DESCRIBE `catalog`\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            if ($row['Field'] == 'remote_username') {\n                $remote_username = true;\n            }\n            if ($row['Field'] == 'remote_password') {\n                $remote_password = true;\n            }\n        } // end while\n\n        if (!$remote_username) {\n            // Add in Username / Password for catalog - to be used for remote catalogs\n            $sql = \"ALTER TABLE `catalog` ADD `remote_username` VARCHAR (255) AFTER `catalog_type`\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        if (!$remote_password) {\n            $sql = \"ALTER TABLE `catalog` ADD `remote_password` VARCHAR (255) AFTER `remote_username`\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * update_360009\n     *\n     * The main session table was already updated to use varchar(64) for the ID,\n     * tmp_playlist needs the same change\n     */\n    public static function update_360009(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `tmp_playlist` CHANGE `session` `session` VARCHAR(64);\") !== false);\n    }\n\n    /**\n     * update_360010\n     *\n     * MBz NGS means collaborations have more than one MBID (the ones\n     * belonging to the underlying artists).  We need a bigger column.\n     */\n    public static function update_360010(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `artist` CHANGE `mbid` `mbid` VARCHAR(36);\") !== false);\n    }\n\n    /**\n     * update_360011\n     *\n     * We need a place to store actual playlist data for downloadable\n     * playlist files.\n     */\n    public static function update_360011(): bool\n    {\n        return (Dba::write(\"CREATE TABLE `stream_playlist` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `sid` varchar(64) NOT NULL, `url` text NOT NULL, `info_url` text DEFAULT NULL, `image_url` text DEFAULT NULL, `title` varchar(255) DEFAULT NULL, `author` varchar(255) DEFAULT NULL, `album` varchar(255) DEFAULT NULL, `type` varchar(255) DEFAULT NULL, `time` smallint(5) DEFAULT NULL, PRIMARY KEY (`id`), KEY `sid` (`sid`));\") !== false);\n    }\n\n    /**\n     * update_360012\n     *\n     * Drop the enum on session.type\n     */\n    public static function update_360012(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `session` CHANGE `type` `type` VARCHAR(16) DEFAULT NULL;\") !== false);\n    }\n\n    /**\n     * update_360013\n     *\n     * MyISAM works better out of the box for the stream_playlist table\n     */\n    public static function update_360013(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"ALTER TABLE `stream_playlist` ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_360014\n     *\n     * PHP session IDs are an ever-growing beast.\n     */\n    public static function update_360014(): bool\n    {\n        $retval = true;\n\n        $retval &= (Dba::write(\"ALTER TABLE `stream_playlist` CHANGE `sid` `sid` VARCHAR(256);\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `tmp_playlist` CHANGE `session` `session` VARCHAR(256);\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `session` CHANGE `id` `id` VARCHAR(256) NOT NULL;\") !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360015\n     *\n     * This inserts the Iframes preference...\n     */\n    public static function update_360015(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('iframes', '1', 'Iframes', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /*\n     * update_360016\n     *\n     * Add Now Playing filtered per user preference option\n     */\n    public static function update_360016(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('now_playing_per_user', '1', 'Now playing filtered per user', 50, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360017\n     *\n     * New table to store user flags.\n     */\n    public static function update_360017(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `user_flag` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) NOT NULL, `object_id` int(11) unsigned NOT NULL, `object_type` varchar(32) CHARACTER SET $charset DEFAULT NULL, `date` int(11) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`), UNIQUE KEY `unique_userflag` (`user`, `object_type`, `object_id`), KEY `object_id` (`object_id`)) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_360018\n     *\n     * Add Album default sort preference...\n     */\n    public static function update_360018(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('album_sort', '0', 'Album Default Sort', 25, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360019\n     *\n     * Add Show number of times a song was played preference\n     */\n    public static function update_360019(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('show_played_times', '0', 'Show # played', 25, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360020\n     *\n     * Catalog types are plugins now\n     */\n    public static function update_360020(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `catalog_local` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `path` VARCHAR(255) COLLATE $collation NOT NULL, `catalog_id` INT(11) NOT NULL) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation\";\n        Dba::write($sql);\n        $sql = \"CREATE TABLE `catalog_remote` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `uri` VARCHAR(255) COLLATE $collation NOT NULL, `username` VARCHAR(255) COLLATE $collation NOT NULL, `password` VARCHAR(255) COLLATE $collation NOT NULL, `catalog_id` INT(11) NOT NULL) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation\";\n        Dba::write($sql);\n\n        $sql        = \"SELECT `id`, `catalog_type`, `path`, `remote_username`, `remote_password` FROM `catalog`\";\n        $db_results = Dba::read($sql);\n        while ($results = Dba::fetch_assoc($db_results)) {\n            if ($results['catalog_type'] == 'local') {\n                $sql = \"INSERT INTO `catalog_local` (`path`, `catalog_id`) VALUES (?, ?)\";\n                $retval &= (Dba::write($sql, array($results['path'], $results['id'])) !== false);\n            } elseif ($results['catalog_type'] == 'remote') {\n                $sql = \"INSERT INTO `catalog_remote` (`uri`, `username`, `password`, `catalog_id`) VALUES (?, ?, ?, ?)\";\n                $retval &= (Dba::write($sql, array($results['path'], $results['remote_username'], $results['remote_password'], $results['id'])) !== false);\n            }\n        }\n\n        $sql = \"ALTER TABLE `catalog` DROP `path`, DROP `remote_username`, DROP `remote_password`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `catalog` MODIFY COLUMN `catalog_type` varchar(128)\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `artist` SET `mbid` = NULL WHERE `mbid` = ''\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `album` SET `mbid` = NULL WHERE `mbid` = ''\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `song` SET `mbid` = NULL WHERE `mbid` = ''\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360021\n     *\n     * Add insertion date on Now Playing and option to show the current song in page title for Web player\n     */\n    public static function update_360021(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `now_playing` ADD `insertion` INT (11) AFTER `expire`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('song_page_title', '1', 'Show current song in Web player page title', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360022\n     *\n     * Remove unused live_stream fields and add codec field\n     */\n    public static function update_360022(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `live_stream` ADD `codec` VARCHAR(32) NULL AFTER `catalog`, DROP `frequency`, DROP `call_sign`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `stream_playlist` ADD `codec` VARCHAR(32) NULL AFTER `time`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360023\n     *\n     * Enable/Disable SubSonic and Plex backend\n     */\n    public static function update_360023(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('subsonic_backend', '1', 'Use SubSonic backend', 100, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('plex_backend', '0', 'Use Plex backend', 100, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360024\n     *\n     * Drop unused flagged table\n     */\n    public static function update_360024(): bool\n    {\n        return (Dba::write(\"DROP TABLE IF EXISTS `flagged`;\") !== false);\n    }\n\n    /**\n     * update_360025\n     *\n     * Add options to enable HTML5 / Flash on web players\n     */\n    public static function update_360025(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webplayer_flash', '1', 'Authorize Flash Web Player(s)', 25, 'boolean', 'streaming')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webplayer_html5', '1', 'Authorize HTML5 Web Player(s)', 25, 'boolean', 'streaming')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360026\n     *\n     * Add agent field in `object_count` table\n     */\n    public static function update_360026(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `object_count` ADD `agent` VARCHAR(255) NULL AFTER `user`;\") !== false);\n    }\n\n    /**\n     * update_360027\n     *\n     * Personal information: allow/disallow to show my personal information into now playing and recently played lists.\n     */\n    public static function update_360027(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_personal_info', '1', 'Allow to show my personal info to other users (now playing, recently played)', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360028\n     *\n     * Personal information: allow/disallow to show in now playing.\n     * Personal information: allow/disallow to show in recently played.\n     * Personal information: allow/disallow to show time and/or agent in recently played.\n     */\n    public static function update_360028(): bool\n    {\n        $retval = true;\n\n        // Update previous update preference\n        $sql = \"UPDATE `preference` SET `name`='allow_personal_info_now', `description`='Personal information visibility - Now playing' WHERE `name`='allow_personal_info'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Insert new recently played preference\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_personal_info_recent', '1', 'Personal information visibility - Recently played / actions', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        // Insert streaming time preference\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_personal_info_time', '1', 'Personal information visibility - Recently played - Allow to show streaming date/time', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        // Insert streaming agent preference\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_personal_info_agent', '1', 'Personal information visibility - Recently played - Allow to show streaming agent', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360029\n     *\n     * New table to store wanted releases\n     */\n    public static function update_360029(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `wanted` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) NOT NULL, `artist` int(11) NOT NULL, `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL, `name` varchar(255) CHARACTER SET $charset NOT NULL, `year` int(4) NULL, `date` int(11) unsigned NOT NULL DEFAULT '0', `accepted` tinyint(1) NOT NULL DEFAULT '0', PRIMARY KEY (`id`), UNIQUE KEY `unique_wanted` (`user`, `artist`, `mbid`)) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_360030\n     *\n     * New table to store song previews\n     */\n    public static function update_360030(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `song_preview` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `session` varchar(256) CHARACTER SET $charset NOT NULL, `artist` int(11) NOT NULL, `title` varchar(255) CHARACTER SET $charset NOT NULL, `album_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL, `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL, `disk` int(11) NULL, `track` int(11) NULL, `file` varchar(255) CHARACTER SET $charset NULL, PRIMARY KEY (`id`)) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_360031\n     *\n     * Add option to fix header/sidebars position on compatible themes\n     */\n    public static function update_360031(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('ui_fixed', '0', 'Fix header position on compatible themes', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360032\n     *\n     * Add check update automatically option\n     */\n    public static function update_360032(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('autoupdate', '1', 'Check for Ampache updates automatically', 25, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        Preference::insert('autoupdate_lastcheck', 'AutoUpdate last check time', '', '25', 'string', 'internal');\n        Preference::insert('autoupdate_lastversion', 'AutoUpdate last version from last check', '', '25', 'string', 'internal');\n        Preference::insert('autoupdate_lastversion_new', 'AutoUpdate last version from last check is newer', '', '25', 'boolean', 'internal');\n\n        return $retval;\n    }\n\n    /**\n     * update_360033\n     *\n     * Add song waveform as song data\n     */\n    public static function update_360033(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `song_data` ADD `waveform` MEDIUMBLOB NULL AFTER `language`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user_shout` ADD `data` VARCHAR(256) NULL AFTER `object_type`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360034\n     *\n     * Add settings for confirmation when closing window and auto-pause between tabs\n     */\n    public static function update_360034(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webplayer_confirmclose', '0', 'Confirmation when closing current playing window', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webplayer_pausetabs', '1', 'Auto-pause betweens tabs', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360035\n     *\n     * Add beautiful stream url setting\n     * Reverted https://github.com/ampache/ampache/commit/0c26c336269624d75985e46d324e2bc8108576ee\n     * with adding update_380012.\n     * Because it was changed after many systems have already performed this update.\n     * Fix for this is update_380012 that actually readds the preference string.\n     * So all users have a consistent database.\n     */\n    public static function update_360035(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('stream_beautiful_url', '0', 'Use beautiful stream url', 100, 'boolean', 'streaming')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360036\n     *\n     * Remove some unused parameters\n     */\n    public static function update_360036(): bool\n    {\n        $retval = true;\n\n        $sql = \"DELETE FROM `preference` WHERE `name` LIKE 'ellipse_threshold_%'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"DELETE FROM `preference` WHERE `name` = 'min_object_count'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"DELETE FROM `preference` WHERE `name` = 'bandwidth'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"DELETE FROM `preference` WHERE `name` = 'features'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"DELETE FROM `preference` WHERE `name` = 'tags_userlist'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360037\n     *\n     * Add sharing features\n     */\n    public static function update_360037(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `share` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) unsigned NOT NULL, `object_type` varchar(32) NOT NULL, `object_id` int(11) unsigned NOT NULL, `allow_stream` tinyint(1) unsigned NOT NULL DEFAULT '0', `allow_download` tinyint(1) unsigned NOT NULL DEFAULT '0', `expire_days` int(4) unsigned NOT NULL DEFAULT '0', `max_counter` int(4) unsigned NOT NULL DEFAULT '0', `secret` varchar(20) CHARACTER SET $charset NULL, `counter` int(4) unsigned NOT NULL DEFAULT '0', `creation_date` int(11) unsigned NOT NULL DEFAULT '0', `lastvisit_date` int(11) unsigned NOT NULL DEFAULT '0', `public_url` varchar(255) CHARACTER SET $charset NULL, `description` varchar(255) CHARACTER SET $charset NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('share', '0', 'Allow Share', 100, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('share_expire', '7', 'Share links default expiration days (0=never)', 100, 'integer', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '7')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360038\n     *\n     * Add missing albums browse on missing artists\n     */\n    public static function update_360038(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `wanted` ADD `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL AFTER `artist`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `wanted` MODIFY `artist` int(11) NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song_preview` ADD `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL AFTER `artist`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song_preview` MODIFY `artist` int(11) NULL\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360039\n     *\n     * Add website field on users\n     */\n    public static function update_360039(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        return (Dba::write(\"ALTER TABLE `user` ADD `website` varchar(255) CHARACTER SET $charset NULL AFTER `email`;\") !== false);\n    }\n\n    /**\n     * update_360040 skipped.\n     */\n\n    /**\n     * update_360041\n     *\n     * Add channels\n     */\n    public static function update_360041(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `channel` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(64) CHARACTER SET $charset NULL, `description` varchar(256) CHARACTER SET $charset NULL, `url` varchar(256) CHARACTER SET $charset NULL, `interface` varchar(64) CHARACTER SET $charset NULL, `port` int(11) unsigned NOT NULL DEFAULT '0', `fixed_endpoint` tinyint(1) unsigned NOT NULL DEFAULT '0', `object_type` varchar(32) NOT NULL, `object_id` int(11) unsigned NOT NULL, `is_private` tinyint(1) unsigned NOT NULL DEFAULT '0', `random` tinyint(1) unsigned NOT NULL DEFAULT '0', `loop` tinyint(1) unsigned NOT NULL DEFAULT '0', `admin_password` varchar(20) CHARACTER SET $charset NULL, `start_date` int(11) unsigned NOT NULL DEFAULT '0', `max_listeners` int(11) unsigned NOT NULL DEFAULT '0', `peak_listeners` int(11) unsigned NOT NULL DEFAULT '0', `listeners` int(11) unsigned NOT NULL DEFAULT '0', `connections` int(11) unsigned NOT NULL DEFAULT '0', `stream_type` varchar(8) CHARACTER SET $charset NOT NULL DEFAULT 'mp3', `bitrate` int(11) unsigned NOT NULL DEFAULT '128', `pid` int(11) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_360042\n     *\n     * Add broadcasts and player control\n     */\n    public static function update_360042(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `broadcast` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) unsigned NOT NULL, `name` varchar(64) CHARACTER SET $charset NULL, `description` varchar(256) CHARACTER SET $charset NULL, `is_private` tinyint(1) unsigned NOT NULL DEFAULT '0', `song` int(11) unsigned NOT NULL DEFAULT '0', `started` tinyint(1) unsigned NOT NULL DEFAULT '0', `listeners` int(11) unsigned NOT NULL DEFAULT '0', `key` varchar(32) CHARACTER SET $charset NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `player_control` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) unsigned NOT NULL, `cmd` varchar(32) CHARACTER SET $charset NOT NULL, `value` varchar(256) CHARACTER SET $charset NULL, `object_type` varchar(32) NOT NULL, `object_id` int(11) unsigned NOT NULL, `send_date` int(11) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360043\n     *\n     * Add slideshow on currently played artist preference\n     */\n    public static function update_360043(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('slideshow_time', '0', 'Artist slideshow inactivity time', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360044\n     *\n     * Add artist description/recommendation external service data cache\n     */\n    public static function update_360044(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"ALTER TABLE `artist` ADD `summary` TEXT CHARACTER SET $charset NULL, ADD `placeformed` varchar(64) NULL, ADD `yearformed` int(4) NULL, ADD `last_update` int(11) unsigned NOT NULL DEFAULT '0'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `recommendation` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `object_type` varchar(32) NOT NULL, `object_id` int(11) unsigned NOT NULL, `last_update` int(11) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `recommendation_item` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `recommendation` int(11) unsigned NOT NULL, `recommendation_id` int(11) unsigned NULL, `name` varchar(256) NULL, `rel` varchar(256) NULL, `mbid` varchar(36) NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360045\n     *\n     * Set user field on playlists as optional\n     */\n    public static function update_360045(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `playlist` MODIFY `user` int(11) NULL;\") !== false);\n    }\n\n    /**\n     * update_360046\n     *\n     * Add broadcast web player by default preference\n     */\n    public static function update_360046(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('broadcast_by_default', '0', 'Broadcast web player by default', 25, 'boolean', 'streaming')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360047\n     *\n     * Add apikey field on users\n     */\n    public static function update_360047(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        return (Dba::write(\"ALTER TABLE `user` ADD `apikey` varchar(255) CHARACTER SET $charset NULL AFTER `website`;\") !== false);\n    }\n\n    /**\n     * update_360048\n     *\n     * Add concerts options\n     */\n    public static function update_360048(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('concerts_limit_future', '0', 'Limit number of future events', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('concerts_limit_past', '0', 'Limit number of past events', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360049\n     *\n     * Add album group multiple disks setting\n     */\n    public static function update_360049(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('album_group', '0', 'Album - Group multiple disks', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360050\n     *\n     * Add top menu setting\n     */\n    public static function update_360050(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('topmenu', '0', 'Top menu', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360051\n     *\n     * REMOVED\n     */\n    public static function update_360051(): bool\n    {\n        return true;\n    }\n\n    /**\n     * update_370001\n     *\n     * Drop unused dynamic_playlist tables and add session id to votes\n     */\n    public static function update_370001(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        $sql = \"DROP TABLE dynamic_playlist\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"DROP TABLE dynamic_playlist_data\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user_vote` ADD `sid` varchar(256) CHARACTER SET $charset NULL AFTER `date`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('demo_clear_sessions', '0', 'Clear democratic votes of expired user sessions', 25, 'boolean', 'playlist')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370002\n     *\n     * Add tag persistent merge reference\n     */\n    public static function update_370002(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `tag` ADD `merged_to` int(11) NULL AFTER `name`;\") !== false);\n    }\n\n    /**\n     * update_370003\n     *\n     * Add show/hide donate button preference\n     */\n    public static function update_370003(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('show_donate', '1', 'Show donate button in footer', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370004\n     *\n     * Add license information and user's artist association\n     */\n    public static function update_370004(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_catalog', '-1', 'Uploads catalog destination', 75, 'integer', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '-1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_upload', '0', 'Allow users to upload media', 75, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_subdir', '1', 'Upload: create a subdirectory per user (recommended)', 75, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_user_artist', '0', 'Upload: consider the user sender as the track\\'s artist', 75, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_script', '', 'Upload: run the following script after upload (current directory = upload target directory)', 75, 'string', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_allow_edit', '1', 'Upload: allow users to edit uploaded songs', 75, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"ALTER TABLE `artist` ADD `user` int(11) NULL AFTER `last_update`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `license` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(80) NOT NULL, `description` varchar(256) NULL, `external_link` varchar(256) NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('0 - default', '')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY', 'https://creativecommons.org/licenses/by/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY NC', 'https://creativecommons.org/licenses/by-nc/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY NC ND', 'https://creativecommons.org/licenses/by-nc-nd/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY NC SA', 'https://creativecommons.org/licenses/by-nc-sa/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY ND', 'https://creativecommons.org/licenses/by-nd/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY SA', 'https://creativecommons.org/licenses/by-sa/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('Licence Art Libre', 'http://artlibre.org/licence/lal/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('Yellow OpenMusic', 'http://openmusic.linuxtag.org/yellow.html')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('Green OpenMusic', 'http://openmusic.linuxtag.org/green.html')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('Gnu GPL Art', 'http://gnuart.org/english/gnugpl.html')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('WTFPL', 'https://en.wikipedia.org/wiki/WTFPL')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('FMPL', 'http://www.fmpl.org/fmpl.html')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('C Reaction', 'http://morne.free.fr/Necktar7/creaction.htm')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song` ADD `user_upload` int(11) NULL AFTER `addition_time`, ADD `license` int(11) NULL AFTER `user_upload`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370005\n     *\n     * Add new column album_artist into table album\n     *\n     */\n    public static function update_370005(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `song` ADD `album_artist` int(11) unsigned DEFAULT NULL AFTER `artist`;\") !== false);\n    }\n\n    /**\n     * update_370006\n     *\n     * Add random and limit options to smart playlists\n     *\n     */\n    public static function update_370006(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `search` ADD `random` tinyint(1) unsigned NOT NULL DEFAULT '0' AFTER `logic_operator`, ADD `limit` int(11) unsigned NOT NULL DEFAULT '0' AFTER `random`;\") !== false);\n    }\n\n    /**\n     * update_370007\n     *\n     * Add DAAP backend preference\n     */\n    public static function update_370007(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('daap_backend', '0', 'Use DAAP backend', 100, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('daap_pass', '', 'DAAP backend password', 100, 'string', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"CREATE TABLE `daap_session` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `creationdate` int(11) unsigned NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370008\n     *\n     * Add UPnP backend preference\n     *\n     */\n    public static function update_370008(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upnp_backend', '0', 'Use UPnP backend', 100, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370009\n     *\n     * Enhance video support with TVShows and Movies\n     */\n    public static function update_370009(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"ALTER TABLE `video` ADD `release_date` date NULL AFTER `enabled`, ADD `played` tinyint(1) unsigned DEFAULT '0' NOT NULL AFTER `enabled`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `tvshow` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(80) NOT NULL, `summary` varchar(256) NULL, `year` int(11) unsigned NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `tvshow_season` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `season_number` int(11) unsigned NOT NULL, `tvshow` int(11) unsigned NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `tvshow_episode` (`id` int(11) unsigned NOT NULL, `original_name` varchar(80) NULL, `season` int(11) unsigned NOT NULL, `episode_number` int(11) unsigned NOT NULL, `summary` varchar(256) NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `movie` (`id` int(11) unsigned NOT NULL, `original_name` varchar(80) NULL, `summary` varchar(256) NULL, `year` int(11) unsigned NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `personal_video` (`id` int(11) unsigned NOT NULL, `location` varchar(256) NULL, `summary` varchar(256) NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `clip` (`id` int(11) unsigned NOT NULL, `artist` int(11) NULL, `song` int(11) NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_video', '1', 'Allow video features', 75, 'integer', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"ALTER TABLE `image` ADD `kind` VARCHAR(32) NULL DEFAULT 'default' AFTER `object_id`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370010\n     *\n     * Add MusicBrainz Album Release Group identifier\n     */\n    public static function update_370010(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        return (Dba::write(\"ALTER TABLE `album` ADD `mbid_group` varchar(36) CHARACTER SET $charset NULL;\") !== false);\n    }\n\n    /**\n     * update_370011\n     *\n     * Add Prefix to TVShows and Movies\n     */\n    public static function update_370011(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        $sql = \"ALTER TABLE `tvshow` ADD `prefix` varchar(32) CHARACTER SET $charset NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `movie` ADD `prefix` varchar(32) CHARACTER SET $charset NULL\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370012\n     *\n     * Add metadata information to albums / songs / videos\n     */\n    public static function update_370012(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        $sql = \"ALTER TABLE `album` ADD `release_type` varchar(32) CHARACTER SET $charset NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song` ADD `composer` varchar(256) CHARACTER SET $charset NULL, ADD `channels` MEDIUMINT NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `video` ADD `channels` MEDIUMINT NULL, ADD `bitrate` MEDIUMINT(8) NULL, ADD `video_bitrate` MEDIUMINT(8) NULL, ADD `display_x` MEDIUMINT(8) NULL, ADD `display_y` MEDIUMINT(8) NULL, ADD `frame_rate` FLOAT NULL, ADD `mode` ENUM('abr', 'vbr', 'cbr') NULL DEFAULT 'cbr'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('album_release_type', '1', 'Album - Group per release type', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370013\n     *\n     * Replace iframe with ajax page load\n     */\n    public static function update_370013(): bool\n    {\n        $retval = true;\n\n        $sql = \"DELETE FROM `preference` WHERE `name` = 'iframes'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('ajax_load', '1', 'Ajax page load', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370014\n     *\n     * Modified release_date of table video to signed int(11)\n     */\n    public static function update_370014(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `video` CHANGE COLUMN `release_date` `release_date` INT NULL DEFAULT NULL;\") !== false);\n    }\n\n    /**\n     * update 370015\n     *\n     * Add session_remember table to store remember tokens\n     */\n    public static function update_370015(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `session_remember` (`username` varchar(16) NOT NULL, `token` varchar(32) NOT NULL, `expire` int(11) NULL, PRIMARY KEY (`username`, `token`)) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update 370016\n     *\n     * Add limit of media count for direct play preference\n     */\n    public static function update_370016(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('direct_play_limit', '0', 'Limit direct play to maximum media count', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370017\n     *\n     * Add home display settings\n     */\n    public static function update_370017(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('home_moment_albums', '1', 'Show Albums of the moment at home page', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('home_moment_videos', '1', 'Show Videos of the moment at home page', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('home_recently_played', '1', 'Show Recently Played at home page', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('home_now_playing', '1', 'Show Now Playing at home page', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('custom_logo', '', 'Custom logo url', 25, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /*\n     * update 370018\n     *\n     * Enhance tag persistent merge reference.\n     */\n    public static function update_370018(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE IF NOT EXISTS `tag_merge` (`tag_id` int(11) NOT NULL, `merged_to` int(11) NOT NULL, FOREIGN KEY (`tag_id`) REFERENCES `tag` (`tag_id`), FOREIGN KEY (`merged_to`) REFERENCES `tag` (`tag_id`), PRIMARY KEY (`tag_id`, `merged_to`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `tag_merge` (`tag_id`, `merged_to`) SELECT `tag`.`id`, `tag`.`merged_to` FROM `tag` WHERE `merged_to` IS NOT NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `tag` DROP COLUMN `merged_to`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `tag` ADD COLUMN `is_hidden` TINYINT(1) NOT NULL DEFAULT 0\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370019\n     *\n     * Add album group order setting\n     */\n    public static function update_370019(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('album_release_type_sort', 'album,ep,live,single', 'Album - Group per release type Sort', 25, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, 'album,ep,live,single')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370020\n     *\n     * Add webplayer browser notification settings\n     */\n    public static function update_370020(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('browser_notify', '1', 'WebPlayer browser notifications', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('browser_notify_timeout', '10', 'WebPlayer browser notifications timeout (seconds)', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '10')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370021\n     *\n     * Add rating to playlists, tvshows and tvshows seasons\n     */\n    public static function update_370021(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `rating` CHANGE `object_type` `object_type` ENUM ('artist', 'album', 'song', 'stream', 'video', 'playlist', 'tvshow', 'tvshow_season') NULL;\") !== false);\n    }\n\n    /**\n     * update 370022\n     *\n     * Add users geolocation\n     */\n    public static function update_370022(): bool\n    {\n        $retval = true;\n\n        $sql    = \"ALTER TABLE `session` ADD COLUMN `geo_latitude` DECIMAL(10,6) NULL, ADD COLUMN `geo_longitude` DECIMAL(10,6) NULL, ADD COLUMN `geo_name` VARCHAR(255) NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `object_count` ADD COLUMN `geo_latitude` DECIMAL(10,6) NULL, ADD COLUMN `geo_longitude` DECIMAL(10,6) NULL, ADD COLUMN `geo_name` VARCHAR(255) NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('geolocation', '0', 'Allow geolocation', 25, 'integer', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370023\n     *\n     * Add Aurora.js webplayer option\n     */\n    public static function update_370023(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webplayer_aurora', '1', 'Authorize JavaScript decoder (Aurora.js) in Web Player(s)', 25, 'boolean', 'streaming')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370024\n     *\n     * Add count_type column to object_count table\n     */\n    public static function update_370024(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `object_count` ADD COLUMN `count_type` VARCHAR(16) NOT NULL DEFAULT 'stream';\") !== false);\n    }\n\n    /**\n     * update 370025\n     *\n     * Add state and city fields to user table\n     */\n    public static function update_370025(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `user` ADD COLUMN `state` VARCHAR(64) NULL, ADD COLUMN `city` VARCHAR(64) NULL;\") !== false);\n    }\n\n    /**\n     * update 370026\n     *\n     * Add replay gain fields to song_data table\n     */\n    public static function update_370026(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `song_data` ADD COLUMN `replaygain_track_gain` DECIMAL(10,6) NULL, ADD COLUMN `replaygain_track_peak` DECIMAL(10,6) NULL, ADD COLUMN `replaygain_album_gain` DECIMAL(10,6) NULL, ADD COLUMN `replaygain_album_peak` DECIMAL(10,6) NULL;\") !== false);\n    }\n\n    /**\n     * update_370027\n     *\n     * Move column album_artist from table song to table album\n     *\n     */\n    public static function update_370027(): bool\n    {\n        $retval = true;\n\n        $sql    = \"ALTER TABLE `album` ADD `album_artist` int(11) unsigned DEFAULT NULL AFTER `release_type`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"UPDATE `album` INNER JOIN `song` ON `album`.`id` = `song`.`album` SET `album`.`album_artist` = `song`.`album_artist`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `song` DROP COLUMN `album_artist`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n\n\n    /**\n     * update_370028\n     *\n     * Add width and height in table image\n     *\n     */\n    public static function update_370028(): bool\n    {\n        $retval = true;\n\n        $sql        = \"SELECT `width` FROM `image`\";\n        $db_results = Dba::read($sql);\n        if (!$db_results) {\n            $sql    = \"ALTER TABLE `image` ADD `width` int(4) unsigned DEFAULT 0 AFTER `image`\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        $sql        = \"SELECT `height` FROM `image`\";\n        $db_results = Dba::read($sql);\n        if (!$db_results) {\n            $sql    = \"ALTER TABLE `image` ADD `height` int(4) unsigned DEFAULT 0 AFTER `width`\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * update_370029\n     *\n     * Set image column from image table as nullable.\n     *\n     */\n    public static function update_370029(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `image` CHANGE COLUMN `image` `image` MEDIUMBLOB NULL DEFAULT NULL;\") !== false);\n    }\n\n    /**\n     * update_370030\n     *\n     * Add an option to allow users to remove uploaded songs.\n     */\n    public static function update_370030(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_allow_remove', '1', 'Upload: allow users to remove uploaded songs', 75, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370031\n     *\n     * Add an option to customize login art, favicon and text footer.\n     */\n    public static function update_370031(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('custom_login_logo', '', 'Custom login page logo url', 75, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('custom_favicon', '', 'Custom favicon url', 75, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('custom_text_footer', '', 'Custom text footer', 75, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370032\n     *\n     * Add WebDAV backend preference.\n     */\n    public static function update_370032(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webdav_backend', '0', 'Use WebDAV backend', 100, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370033\n     *\n     * Add Label tables.\n     */\n    public static function update_370033(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `label` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(80) NOT NULL, `category` varchar(40) NULL, `summary` TEXT CHARACTER SET $charset NULL, `address` varchar(256) NULL, `email` varchar(128) NULL, `website` varchar(256) NULL, `user` int(11) unsigned NULL, `creation_date` int(11) unsigned NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `label_asso` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `label` int(11) unsigned NOT NULL, `artist` int(11) unsigned NOT NULL, `creation_date` int(11) unsigned NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370034\n     *\n     * Add User messages and user follow tables.\n     */\n    public static function update_370034(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `user_pvmsg` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `subject` varchar(80) NOT NULL, `message` TEXT CHARACTER SET $charset NULL, `from_user` int(11) unsigned NOT NULL, `to_user` int(11) unsigned NOT NULL, `is_read` tinyint(1) unsigned NOT NULL DEFAULT '0', `creation_date` int(11) unsigned NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `user_follower` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) unsigned NOT NULL, `follow_user` int(11) unsigned NOT NULL, `follow_date` int(11) unsigned  NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('notify_email', '0', 'Receive notifications by email (shouts, private messages, ...)', 25, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370035\n     *\n     * Add option on user fullname to show/hide it publicly\n     */\n    public static function update_370035(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `user` ADD COLUMN `fullname_public` TINYINT(1) UNSIGNED NOT NULL DEFAULT '0';\") !== false);\n    }\n\n    /**\n     * update_370036\n     *\n     * Add field for track number when generating streaming playlists\n     */\n    public static function update_370036(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `stream_playlist` ADD COLUMN `track_num` SMALLINT(5) DEFAULT '0';\") !== false);\n    }\n\n    /**\n     * update_370037\n     *\n     * Delete http_port preference (use ampache.cfg.php configuration instead)\n     */\n    public static function update_370037(): bool\n    {\n        return (Dba::write(\"DELETE FROM `preference` WHERE `name` = 'http_port';\") !== false);\n    }\n\n    /**\n     * update_370038\n     *\n     * Add theme color option\n     */\n    public static function update_370038(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('theme_color', 'dark', 'Theme color',0, 'special', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, 'dark')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370039\n     *\n     * Renamed false named sample_rate option name in preference table\n     */\n    public static function update_370039(): bool\n    {\n        return (Dba::write(\"UPDATE `preference` SET `name` = 'transcode_bitrate' WHERE `preference`.`name` = 'sample_rate';\") !== false);\n    }\n\n    /**\n     * update_370040\n     *\n     * Add user_activity table\n     */\n    public static function update_370040(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `user_activity` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `user` INT(11) NOT NULL, `action` varchar(20) NOT NULL, `object_id` INT(11) UNSIGNED NOT NULL, `object_type` VARCHAR(32) NOT NULL, `activity_date` INT(11) UNSIGNED NOT NULL) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_370041\n     *\n     * Add Metadata tables and preferences\n     */\n    public static function update_370041(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `metadata_field` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `name` varchar(255) NOT NULL, `public` tinyint(1) NOT NULL, UNIQUE KEY `name` (`name`) ) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `metadata` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `object_id` INT(11) UNSIGNED NOT NULL, `field` INT(11) UNSIGNED NOT NULL, `data` text COLLATE $collation NOT NULL, `type` varchar(50) CHARACTER SET $charset DEFAULT NULL, KEY `field` (`field`), KEY `object_id` (`object_id`), KEY `type` (`type`), KEY `objecttype` (`object_id`, `type`), KEY `objectfield` (`object_id`, `field`, `type`) ) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('disabled_custom_metadata_fields', '', 'Disable custom metadata fields (ctrl / shift click to select multiple)', 100, 'string', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('disabled_custom_metadata_fields_input', '', 'Disable custom metadata fields. Insert them in a comma separated list. They will add to the fields selected above.', 100, 'string', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380001\n     *\n     * Add podcasts\n     */\n    public static function update_380001(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `podcast` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `feed` varchar(4096) NOT NULL, `catalog` int(11) NOT NULL, `title` varchar(255) CHARACTER SET $charset NOT NULL, `website` varchar(255) NULL, `description` varchar(4096) CHARACTER SET $charset NULL, `language` varchar(5) NULL, `copyright` varchar(64) NULL, `generator` varchar(64) NULL, `lastbuilddate` int(11) UNSIGNED DEFAULT '0' NOT NULL, `lastsync` int(11) UNSIGNED DEFAULT '0' NOT NULL) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `podcast_episode` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `title` varchar(255) CHARACTER SET $charset NOT NULL, `guid` varchar(255) NOT NULL, `podcast` int(11) NOT NULL, `state` varchar(32) NOT NULL, `file` varchar(4096) CHARACTER SET $charset NULL, `source` varchar(4096) NULL, `size` bigint(20) UNSIGNED DEFAULT '0' NOT NULL, `time` smallint(5) UNSIGNED DEFAULT '0' NOT NULL, `website` varchar(255) NULL, `description` varchar(4096) CHARACTER SET $charset NULL, `author` varchar(64) NULL, `category` varchar(64) NULL, `played` tinyint(1) UNSIGNED DEFAULT '0' NOT NULL, `pubdate` int(11) UNSIGNED NOT NULL, `addition_time` int(11) UNSIGNED NOT NULL) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('podcast_keep', '10', 'Podcast: # latest episodes to keep', 100, 'integer', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '10')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('podcast_new_download', '1', 'Podcast: # episodes to download when new episodes are available', 100, 'integer', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"ALTER TABLE `rating` CHANGE `object_type` `object_type` ENUM ('artist', 'album', 'song', 'stream', 'video', 'playlist', 'tvshow', 'tvshow_season', 'podcast', 'podcast_episode') NULL\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380002\n     *\n     * Add bookmarks\n     */\n    public static function update_380002(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `bookmark` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `user` int(11) UNSIGNED NOT NULL, `position` int(11) UNSIGNED DEFAULT '0' NOT NULL, `comment` varchar(255) CHARACTER SET $charset NOT NULL, `object_type` varchar(64) NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `creation_date` int(11) UNSIGNED DEFAULT '0' NOT NULL, `update_date` int(11) UNSIGNED DEFAULT '0' NOT NULL) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_380003\n     *\n     * Add unique constraint on tag_map table\n     */\n    public static function update_380003(): bool\n    {\n        return (Dba::write(\"ALTER IGNORE TABLE `tag_map` ADD UNIQUE INDEX `UNIQUE_TAG_MAP` (`object_id`, `object_type`, `user`, `tag_id`);\") !== false);\n    }\n\n    /**\n     * update_380004\n     *\n     * Add preference subcategory\n     */\n    public static function update_380004(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        return (Dba::write(\"ALTER TABLE `preference` ADD `subcatagory` varchar(128) CHARACTER SET $charset DEFAULT NULL AFTER `catagory`;\") !== false);\n    }\n\n    /**\n     * update_380005\n     *\n     * Add manual update flag on artist\n     */\n    public static function update_380005(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `artist` ADD COLUMN `manual_update` SMALLINT(1) DEFAULT '0';\") !== false);\n    }\n\n    /**\n     * update_380006\n     *\n     * Add library item context menu option\n     */\n    public static function update_380006(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('libitem_contextmenu', '1', 'Library item context menu',0, 'boolean', 'interface', 'library')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380007\n     *\n     * Add upload rename pattern and ignore duplicate options\n     */\n    public static function update_380007(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('upload_catalog_pattern', '0', 'Rename uploaded file according to catalog pattern', 100, 'boolean', 'system', 'upload')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('catalog_check_duplicate', '0', 'Check library item at import time and disable duplicates', 100, 'boolean', 'system', 'catalog')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380008\n     *\n     * Add browse filter and light sidebar options\n     */\n    public static function update_380008(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('browse_filter', '0', 'Show filter box on browse', 25, 'boolean', 'interface', 'library')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('sidebar_light', '0', 'Light sidebar by default', 25, 'boolean', 'interface', 'theme')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380009\n     *\n     * Add update date to playlist\n     */\n    public static function update_380009(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `playlist` ADD COLUMN `last_update` int(11) unsigned NOT NULL DEFAULT '0';\") !== false);\n    }\n\n    /**\n     * update_380010\n     *\n     * Add custom blank album/video default image and alphabet browsing options\n     */\n    public static function update_380010(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('custom_blankalbum', '', 'Custom blank album default image', 75, 'string', 'interface', 'custom')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('custom_blankmovie', '', 'Custom blank video default image', 75, 'string', 'interface', 'custom')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('libitem_browse_alpha', '', 'Alphabet browsing by default for following library items (album,artist,...)', 75, 'string', 'interface', 'library')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380011\n     *\n     * Fix username max size to be the same one across all tables.\n     */\n    public static function update_380011(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE session MODIFY username VARCHAR(255)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE session_remember MODIFY username VARCHAR(255)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE user MODIFY username VARCHAR(255)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE user MODIFY fullname VARCHAR(255)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380012\n     *\n     * Fix change in https://github.com/ampache/ampache/commit/0c26c336269624d75985e46d324e2bc8108576ee\n     * That left the user base with an inconsistent database.\n     * For more information, please look at update_360035.\n     */\n    public static function update_380012(): bool\n    {\n        $retval = true;\n\n        $sql = \"UPDATE `preference` SET `description`='Enable url rewriting' WHERE `preference`.`name`='stream_beautiful_url'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400000\n     *\n     * Increase copyright column size to fix issue #1861\n     * Add name_track, name_artist, name_album to user_activity\n     * Add mbid_track, mbid_artist, mbid_album to user_activity\n     * Insert some decent SmartLists for a better default experience\n     * Delete the following plex preferences from the server\n     *   plex_backend\n     *   myplex_username\n     *   myplex_authtoken\n     *   myplex_published\n     *   plex_uniqid\n     *   plex_servername\n     *   plex_public_address\n     *   plex_public_port\n     *   plex_local_auth\n     *   plex_match_email\n     * Add preference for master/develop branch selection\n     */\n    public static function update_400000(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `podcast` MODIFY `copyright` VARCHAR(255)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `user_activity` ADD COLUMN `name_track` VARCHAR(255) NULL DEFAULT NULL, ADD COLUMN `name_artist` VARCHAR(255) NULL DEFAULT NULL, ADD COLUMN `name_album` VARCHAR(255) NULL DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `user_activity` ADD COLUMN `mbid_track` VARCHAR(255) NULL DEFAULT NULL, ADD COLUMN `mbid_artist` VARCHAR(255) NULL DEFAULT NULL, ADD COLUMN `mbid_album` VARCHAR(255) NULL DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"INSERT IGNORE INTO `search` (`user`, `type`, `rules`, `name`, `logic_operator`, `random`, `limit`) VALUES (-1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Artist 5*', 'AND', 0, 0), (-1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Artist 4*', 'AND', 0, 0), (-1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Artist 3*', 'AND', 0, 0), (-1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Artist 2*', 'AND', 0, 0), (-1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Artist 1*', 'AND', 0, 0), (-1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Album 5*', 'AND', 0, 0), (-1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Album 4*', 'AND', 0, 0), (-1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Album 3*', 'AND', 0, 0), (-1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Album 2*', 'AND', 0, 0), (-1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Album 1*', 'AND', 0, 0), (-1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Song 5*', 'AND', 0, 0), (-1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Song 4*', 'AND', 0, 0), (-1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Song 3*', 'AND', 0, 0), (-1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Song 2*', 'AND', 0, 0), (-1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Song 1*', 'AND', 0, 0);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_backend');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'myplex_username');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'myplex_authtoken');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'myplex_published');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_uniqid');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_servername');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_public_address');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_public_port');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_local_auth');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_match_email');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `preference` WHERE `preference`.`name` IN ('plex_backend', 'myplex_username', 'myplex_authtoken', 'myplex_published', 'plex_uniqid', 'plex_servername', 'plex_public_address', 'plex_public_port ', 'plex_local_auth', 'plex_match_email');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400001\n     *\n     * Make sure people on older databases have the same preference categories\n     */\n    public static function update_400001(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `preference` SET `preference`.`subcatagory` = 'library' WHERE `preference`.`name` in ('album_sort', 'show_played_times', 'album_group', 'album_release_type', 'album_release_type_sort', 'libitem_contextmenu', 'browse_filter', 'libitem_browse_alpha') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'backend' WHERE `preference`.`name` in ('subsonic_backend', 'daap_backend', 'daap_pass', 'upnp_backend', 'webdav_backend') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'catalog' WHERE `preference`.`name` = 'catalog_check_duplicate' AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'custom' WHERE `preference`.`name` in ('site_title', 'custom_logo', 'custom_login_logo', 'custom_favicon', 'custom_text_footer', 'custom_blankalbum', 'custom_blankmovie') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'feature' WHERE `preference`.`name` in ('download', 'allow_stream_playback', 'allow_democratic_playback', 'share', 'allow_video', 'geolocation') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'home' WHERE `preference`.`name` in ('now_playing_per_user', 'home_moment_albums', 'home_moment_videos', 'home_recently_played', 'home_now_playing') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'httpq' WHERE `preference`.`name` = 'httpq_active' AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'lastfm' WHERE `preference`.`name` in ('lastfm_grant_link', 'lastfm_challenge') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'localplay' WHERE `preference`.`name` in ('localplay_controller', 'localplay_level', 'allow_localplay_playback') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'metadata' WHERE `preference`.`name` in ('disabled_custom_metadata_fields', 'disabled_custom_metadata_fields_input') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'mpd' WHERE `preference`.`name` = 'mpd_active' AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'notification' WHERE `preference`.`name` in ('browser_notify', 'browser_notify_timeout') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'player' WHERE `preference`.`name` in ('show_lyrics', 'song_page_title', 'webplayer_flash', 'webplayer_html5', 'webplayer_confirmclose', 'webplayer_pausetabs', 'slideshow_time', 'broadcast_by_default', 'direct_play_limit', 'webplayer_aurora') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'podcast' WHERE `preference`.`name` in ('podcast_keep', 'podcast_new_download') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'privacy' WHERE `preference`.`name` in ('allow_personal_info_now', 'allow_personal_info_recent', 'allow_personal_info_time', 'allow_personal_info_agent') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'query' WHERE `preference`.`name` in ('popular_threshold', 'offset_limit', 'stats_threshold', 'concerts_limit_future', 'concerts_limit_past') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'share' WHERE `preference`.`name` = 'share_expire' AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'shoutcast' WHERE `preference`.`name` = 'shoutcast_active' AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'theme' WHERE `preference`.`name` in ('theme_name', 'ui_fixed', 'topmenu', 'theme_color', 'sidebar_light') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'transcoding' WHERE `preference`.`name` in ('transcode_bitrate', 'rate_limit', 'transcode') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'update' WHERE `preference`.`name` in ('autoupdate', 'autoupdate_lastcheck', 'autoupdate_lastversion', 'autoupdate_lastversion_new') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'upload' WHERE `preference`.`name` in ('upload_catalog', 'allow_upload', 'upload_subdir', 'upload_user_artist', 'upload_script', 'upload_allow_edit', 'upload_allow_remove', 'upload_catalog_pattern') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400002\n     *\n     * Update disk to allow 1 instead of making it 0 by default\n     * Add barcode catalog_number and original_year\n     * Drop catalog_number from song_data\n     */\n    public static function update_400002(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `album` SET `album`.`disk` = 1 WHERE `album`.`disk` = 0;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `album` ADD `original_year` INT(4) NULL, ADD `barcode` VARCHAR(64) NULL, ADD `catalog_number` VARCHAR(64) NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `song_data` DROP `catalog_number`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400003\n     *\n     * Make sure preference names are updated to current strings\n     */\n    public static function update_400003(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `preference` SET `preference`.`description` = 'Force HTTP playback regardless of port' WHERE `preference`.`name` = 'force_http_play' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Playback Type' WHERE `preference`.`name` = 'play_type' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'httpQ Active Instance' WHERE `preference`.`name` = 'httpq_active' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Now Playing filtered per user' WHERE `preference`.`name` = 'now_playing_per_user' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Use Subsonic backend' WHERE `preference`.`name` = 'subsonic_backend' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Share Now Playing information' WHERE `preference`.`name` = 'allow_personal_info_now' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Share Recently Played information' WHERE `preference`.`name` = 'allow_personal_info_recent' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Share Recently Played information - Allow access to streaming date/time' WHERE `preference`.`name` = 'allow_personal_info_time' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Share Recently Played information - Allow access to streaming agent' WHERE `preference`.`name` = 'allow_personal_info_agent' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Enable URL Rewriting' WHERE `preference`.`name` = 'stream_beautiful_url' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Destination catalog' WHERE `preference`.`name` = 'upload_catalog' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow user uploads' WHERE `preference`.`name` = 'allow_upload' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Create a subdirectory per user' WHERE `preference`.`name` = 'upload_subdir' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Consider the user sender as the track''s artist' WHERE `preference`.`name` = 'upload_user_artist' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Post-upload script (current directory = upload target directory)' WHERE `preference`.`name` = 'upload_script' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow users to edit uploaded songs' WHERE `preference`.`name` = 'upload_allow_edit' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow users to remove uploaded songs' WHERE `preference`.`name` = 'upload_allow_remove' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Show Albums of the Moment' WHERE `preference`.`name` = 'home_moment_albums' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Show Videos of the Moment' WHERE `preference`.`name` = 'home_moment_videos' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Custom URL - Logo' WHERE `preference`.`name` = 'custom_logo' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Custom URL - Login page logo' WHERE `preference`.`name` = 'custom_login_logo' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Custom URL - Favicon' WHERE `preference`.`name` = 'custom_favicon' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Album - Default sort' WHERE `preference`.`name` = 'album_sort' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow Geolocation' WHERE `preference`.`name` = 'Geolocation' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow Video Features' WHERE `preference`.`name` = 'allow_video' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Democratic - Clear votes for expired user sessions' WHERE `preference`.`name` = 'demo_clear_sessions' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow Transcoding' WHERE `preference`.`name` = 'transcoding' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Authorize Flash Web Player' WHERE `preference`.`name` = 'webplayer_flash' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Authorize HTML5 Web Player' WHERE `preference`.`name` = 'webplayer_html5' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Web Player browser notifications' WHERE `preference`.`name` = 'browser_notify' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Web Player browser notifications timeout (seconds)' WHERE `preference`.`name` = 'browser_notify_timeout' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Authorize JavaScript decoder (Aurora.js) in Web Player' WHERE `preference`.`name` = 'webplayer_aurora' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Show Now Playing' WHERE `preference`.`name` = 'home_now_playing' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Show Recently Played' WHERE `preference`.`name` = 'home_recently_played' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = '# latest episodes to keep' WHERE `preference`.`name` = 'podcast_keep' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = '# episodes to download when new episodes are available' WHERE `preference`.`name` = 'podcast_new_download' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow Transcoding' WHERE `preference`.`name` = 'transcode' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow E-mail notifications' WHERE `preference`.`name` = 'notify_email' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Custom metadata - Disable these fields' WHERE `preference`.`name` = 'disabled_custom_metadata_fields' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Custom metadata - Define field list' WHERE `preference`.`name` = 'disabled_custom_metadata_fields_input' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Auto-pause between tabs' WHERE `preference`.`name` = 'webplayer_pausetabs' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400004\n     *\n     * delete upload_user_artist database settings\n     */\n    public static function update_400004(): bool\n    {\n        $retval = true;\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'upload_user_artist');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `preference` WHERE `preference`.`name` = 'upload_user_artist';\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400005\n     *\n     * Add a last_count to searches to speed up access requests\n     */\n    public static function update_400005(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `search` ADD `last_count` INT(11) NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400006\n     *\n     * drop shoutcast_active preferences and localplay_shoutcast table\n     */\n    public static function update_400006(): bool\n    {\n        $retval = true;\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'shoutcast_active');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `preference` WHERE `preference`.`name` = 'shoutcast_active';\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DROP TABLE IF EXISTS `localplay_shoutcast`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400007\n     *\n     * Add ui option for skip_count display\n     * Add ui option for displaying dates in a custom format\n     */\n    public static function update_400007(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('show_skipped_times', '0', 'Show # skipped', 25, 'boolean', 'interface', 'library')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('custom_datetime', '', 'Custom datetime', 25, 'string', 'interface', 'custom')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400008\n     *\n     * Add system option for cron based cache and create related tables\n     */\n    public static function update_400008(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('cron_cache', '0', 'Cache computed SQL data (eg. media hits stats) using a cron', 25, 'boolean', 'system', 'catalog')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $tables    = ['cache_object_count', 'cache_object_count_run'];\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        foreach ($tables as $table) {\n            $sql = \"CREATE TABLE IF NOT EXISTS `\" . $table . \"` (`object_id` int(11) unsigned NOT NULL, `object_type` enum('album', 'artist', 'song', 'playlist', 'genre', 'catalog', 'live_stream', 'video', 'podcast_episode') CHARACTER SET $charset NOT NULL, `count` int(11) unsigned NOT NULL DEFAULT '0', `threshold` int(11) unsigned NOT NULL DEFAULT '0', `count_type` varchar(16) NOT NULL, PRIMARY KEY (`object_id`, `object_type`, `threshold`, `count_type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n\n        $sql = \"UPDATE `preference` SET `level`=75 WHERE `preference`.`name`='stats_threshold'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400009\n     *\n     * Add ui option for forcing unique items to playlists\n     */\n    public static function update_400009(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('unique_playlist', '0', 'Only add unique items to playlists', 25, 'boolean', 'playlist', null)\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400010\n     *\n     * Add a last_duration to searches to speed up access requests\n     */\n    public static function update_400010(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `search` ADD `last_duration` INT(11) NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400011\n     *\n     * Allow negative track numbers for albums\n     * Truncate database tracks to 0 when greater than 32767\n     */\n    public static function update_400011(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `song` SET `track` = 0 WHERE `track` > 32767;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `song` MODIFY COLUMN `track` SMALLINT DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400012\n     *\n     * Add a rss token to use an RSS unauthenticated feed.\n     */\n    public static function update_400012(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `user` ADD `rsstoken` VARCHAR(255) NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400013\n     *\n     * Extend Democratic cooldown beyond 255.\n     */\n    public static function update_400013(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `democratic` MODIFY COLUMN `cooldown` int(11) unsigned DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400014\n     *\n     * Add last_duration to playlist\n     * Add time to artist and album\n     */\n    public static function update_400014(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `playlist` ADD COLUMN `last_duration` int(11) unsigned NOT NULL DEFAULT '0'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `album` ADD COLUMN `time` smallint(5) unsigned NOT NULL DEFAULT '0'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `artist` ADD COLUMN `time` smallint(5) unsigned NOT NULL DEFAULT '0'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    } //\n\n    /**\n     * update_400015\n     *\n     * Extend artist time. smallint was too small\n     */\n    public static function update_400015(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `artist` MODIFY COLUMN `time` int(11) unsigned DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400016\n     *\n     * Extend album and make artist even bigger. This should cover everyone.\n     */\n    public static function update_400016(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `album` MODIFY COLUMN `time` bigint(20) unsigned DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `artist` MODIFY COLUMN `time` int(11) unsigned DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400017\n     *\n     * Removed.\n     */\n    public static function update_400017(): bool\n    {\n        return true;\n    }\n\n    /**\n     * update_400018\n     *\n     * Extend video bitrate to unsigned. There's no reason for a negative bitrate.\n     */\n    public static function update_400018(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `video` SET `video_bitrate` = 0 WHERE `video_bitrate` < 0;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `video` MODIFY COLUMN `video_bitrate` int(11) unsigned DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400019\n     *\n     * Put of_the_moment into a per user preference\n     */\n    public static function update_400019(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('of_the_moment', '6', 'Set the amount of items Album/Video of the Moment will display', 25, 'integer', 'interface', 'home')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '6')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400020\n     *\n     * Customizable login background image\n     */\n    public static function update_400020(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('custom_login_background', '', 'Custom URL - Login page background', 75, 'string', 'interface', 'custom')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400021\n     *\n     * Add r128 gain columns to song_data\n     */\n    public static function update_400021(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `song_data` ADD `r128_track_gain` smallint(5) DEFAULT NULL, ADD `r128_album_gain` smallint(5) DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400022\n     *\n     * Extend allowed time for podcast_episodes\n     */\n    public static function update_400022(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `podcast_episode` MODIFY COLUMN `time` int(11) unsigned DEFAULT 0 NOT NULL; \";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400023\n     *\n     * delete concerts_limit_past and concerts_limit_future database settings\n     */\n    public static function update_400023(): bool\n    {\n        $retval = true;\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` IN ('concerts_limit_past', 'concerts_limit_future'));\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `preference` WHERE `preference`.`name` IN ('concerts_limit_past', 'concerts_limit_future');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400024\n     *\n     * Add song_count, album_count and album_group_count to artist\n     */\n    public static function update_400024(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `artist` ADD `song_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `artist` ADD `album_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `artist` ADD `album_group_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500000\n     *\n     * Delete duplicate files in the song table\n     */\n    public static function update_500000(): bool\n    {\n        $retval = true;\n        $sql    = \"DELETE `dupe` FROM `song` AS `dupe`, `song` AS `orig` WHERE `dupe`.`id` > `orig`.`id` AND `dupe`.`file` <=> `orig`.`file`;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500001\n     *\n     * Add `release_status`, `addition_time`, `catalog` to album table\n     * Add `mbid`, `country`, `active` to label table\n     * Fill the album `catalog` and `time` values using the song table\n     * Fill the artist `album_count`, `album_group_count` and `song_count` values\n     */\n    public static function update_500001(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `album` ADD `release_status` varchar(32) DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `album` ADD `addition_time` int(11) UNSIGNED DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `album` ADD `catalog` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `label` ADD `mbid` varchar(36) DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `label` ADD `country` varchar(64) DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `label` ADD `active` tinyint(1) UNSIGNED NOT NULL DEFAULT '1';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `album`, (SELECT min(`song`.`catalog`) AS `catalog`, `song`.`album` FROM `song` GROUP BY `song`.`album`) AS `song` SET `album`.`catalog` = `song`.`catalog` WHERE `album`.`catalog` != `song`.`catalog` AND `album`.`id` = `song`.`album`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `album`, (SELECT SUM(`song`.`time`) AS `time`, `song`.`album` FROM `song` GROUP BY `song`.`album`) AS `song` SET `album`.`time` = `song`.`time` WHERE `album`.`time` != `song`.`time` AND `album`.`id` = `song`.`album`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `album`, (SELECT MIN(`song`.`addition_time`) AS `addition_time`, `song`.`album` FROM `song` GROUP BY `song`.`album`) AS `song` SET `album`.`addition_time` = `song`.`addition_time` WHERE `album`.`addition_time` != `song`.`addition_time` AND `song`.`album` = `album`.`id`;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_500002\n     *\n     * Create `total_count` and `total_skip` to album, artist, song, video and podcast_episode tables\n     * Fill counts into the columns\n     */\n    public static function update_500002(): bool\n    {\n        $retval = true;\n        // tables which usually calculate a count\n        $tables = ['album', 'artist', 'song', 'video', 'podcast_episode'];\n        foreach ($tables as $type) {\n            $sql = \"ALTER TABLE `$type` ADD `total_count` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n            $retval &= (Dba::write($sql) !== false);\n            $sql = \"UPDATE `$type`, (SELECT COUNT(`object_count`.`object_id`) AS `total_count`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = '$type' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS `object_count` SET `$type`.`total_count` = `object_count`.`total_count` WHERE `$type`.`total_count` != `object_count`.`total_count` AND `$type`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n        }\n        // tables that also have a skip count\n        $tables = ['song', 'video', 'podcast_episode'];\n        foreach ($tables as $type) {\n            $sql = \"ALTER TABLE `$type` ADD `total_skip` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n            $retval &= (Dba::write($sql) !== false);\n            $sql = \"UPDATE `$type`, (SELECT COUNT(`object_count`.`object_id`) AS `total_skip`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = '$type' AND `object_count`.`count_type` = 'skip' GROUP BY `object_count`.`object_id`) AS `object_count` SET `$type`.`total_skip` = `object_count`.`total_skip` WHERE `$type`.`total_skip` != `object_count`.`total_skip` AND `$type`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * update_500003\n     *\n     * add `catalog` to podcast_episode table\n     */\n    public static function update_500003(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `podcast_episode` ADD `catalog` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `podcast_episode`, (SELECT min(`podcast`.`catalog`) AS `catalog`, `podcast`.`id` FROM `podcast` GROUP BY `podcast`.`id`) AS `podcast` SET `podcast_episode`.`catalog` = `podcast`.`catalog` WHERE `podcast_episode`.`catalog` != `podcast`.`catalog` AND `podcast_episode`.`podcast` = `podcast`.`id` AND `podcast`.`catalog` > 0;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_500004\n     *\n     * Create catalog_map table and fill it with data\n     */\n    public static function update_500004(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        // create the table\n        $sql = \"CREATE TABLE IF NOT EXISTS `catalog_map` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `catalog_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `unique_catalog_map` (`object_id`, `object_type`, `catalog_id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n        // fill the data\n        $tables = ['album', 'song', 'video', 'podcast_episode'];\n        foreach ($tables as $type) {\n            $sql = \"REPLACE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `$type`.`catalog`, '$type', `$type`.`id` FROM `$type` WHERE `$type`.`catalog` > 0;\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        // artist is a special one as it can be across multiple tables\n        $sql = \"REPLACE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `song`.`catalog`, 'artist', `artist`.`id` FROM `artist` LEFT JOIN `song` ON `song`.`artist` = `artist`.`id` WHERE `song`.`catalog` > 0;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"REPLACE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `album`.`catalog`, 'artist', `artist`.`id` FROM `artist` LEFT JOIN `album` ON `album`.`album_artist` = `artist`.`id` WHERE `album`.`catalog` > 0;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500005\n     *\n     * Add song_count, artist_count to album\n     */\n    public static function update_500005(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `album` ADD `song_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `album` ADD `artist_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"REPLACE INTO `update_info` SET `key`= 'album_group', `value`= (SELECT COUNT(DISTINCT(`album`.`id`)) AS `count` FROM `album` WHERE `id` in (SELECT MIN(`id`) FROM `album` GROUP BY `album`.`prefix`, `album`.`name`, `album`.`album_artist`, `album`.`release_type`, `album`.`release_status`, `album`.`mbid`, `album`.`year`, `album`.`original_year`, `album`.`mbid_group`));\";\n        Dba::write($sql);\n        $sql = \"UPDATE `album`, (SELECT COUNT(`song`.`id`) AS `song_count`, `album` FROM `song` LEFT JOIN `catalog` ON `catalog`.`id` = `song`.`catalog` WHERE `catalog`.`enabled` = '1' GROUP BY `album`) AS `song` SET `album`.`song_count` = `song`.`song_count` WHERE `album`.`song_count` != `song`.`song_count` AND `album`.`id` = `song`.`album`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `album`, (SELECT COUNT(DISTINCT(`song`.`artist`)) AS `artist_count`, `album` FROM `song` LEFT JOIN `catalog` ON `catalog`.`id` = `song`.`catalog` WHERE `catalog`.`enabled` = '1' GROUP BY `album`) AS `song` SET `album`.`artist_count` = `song`.`artist_count` WHERE `album`.`artist_count` != `song`.`artist_count` AND `album`.`id` = `song`.`album`;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_500006\n     *\n     * Add user_playlist table\n     */\n    public static function update_500006(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        $sql       = \"CREATE TABLE IF NOT EXISTS `user_playlist` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) DEFAULT NULL, `object_type` enum('song', 'live_stream', 'video', 'podcast_episode') CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL DEFAULT '0', `track` smallint(6) DEFAULT NULL, `current_track` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `current_time` smallint(5) UNSIGNED NOT NULL DEFAULT '0', PRIMARY KEY (`id`),KEY `user` (`user`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE IF NOT EXISTS `user_data` (`user` int(11) DEFAULT NULL, `key` varchar(128) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `value` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, KEY `user` (`user`), KEY `key` (`key`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500007\n     *\n     * Add a 'Browse' category to interface preferences\n     * Add ui option ('show_license') for hiding license column in song rows\n     */\n    public static function update_500007(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `preference` SET `preference`.`subcatagory` = 'browse' WHERE `preference`.`name` IN ('show_played_times', 'browse_filter', 'libitem_browse_alpha', 'show_skipped_times')\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('show_license', '1', 'Show License', 25, 'boolean', 'interface', 'browse')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500008\n     *\n     * Add filter_user to catalog table, set unique on user_data\n     */\n    public static function update_500008(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `catalog` ADD `filter_user` int(11) unsigned DEFAULT 0 NOT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $tables = ['podcast', 'live_stream'];\n        foreach ($tables as $type) {\n            $sql = \"REPLACE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `$type`.`catalog`, '$type', `$type`.`id` FROM `$type` WHERE `$type`.`catalog` > 0;\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        $sql = \"ALTER TABLE `user_data` ADD UNIQUE `unique_data` (`user`, `key`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500009\n     *\n     * Add ui option ('use_original_year') Browse by Original Year for albums (falls back to Year)\n     */\n    public static function update_500009(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('use_original_year', '0', 'Browse by Original Year for albums (falls back to Year)', 25, 'boolean', 'interface', 'browse')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500010\n     *\n     * Add ui option ('hide_single_artist') Hide the Song Artist column for Albums with one Artist\n     */\n    public static function update_500010(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('hide_single_artist', '0', 'Hide the Song Artist column for Albums with one Artist', 25, 'boolean', 'interface', 'browse')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500011\n     *\n     * Add `total_count` to podcast table and fill counts into the column\n     */\n    public static function update_500011(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `podcast` ADD `total_count` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `podcast`, (SELECT SUM(`podcast_episode`.`total_count`) AS `total_count`, `podcast` FROM `podcast_episode` GROUP BY `podcast_episode`.`podcast`) AS `object_count` SET `podcast`.`total_count` = `object_count`.`total_count` WHERE `podcast`.`total_count` != `object_count`.`total_count` AND `podcast`.`id` = `object_count`.`podcast`;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_500012\n     *\n     * Move user bandwidth calculations out of the user format function into the user_data table\n     */\n    public static function update_500012(): bool\n    {\n        $retval          = true;\n        $sql             = \"SELECT `id` FROM `user`\";\n        $db_users        = Dba::read($sql);\n        $user_list       = array();\n        while ($results  = Dba::fetch_assoc($db_users)) {\n            $user_list[] = (int)$results['id'];\n        }\n        // Calculate their total Bandwidth Usage\n        foreach ($user_list as $user_id) {\n            $params = array($user_id);\n            $total  = 0;\n            $sql_s  = \"SELECT SUM(`song`.`size`) AS `size` FROM `object_count` LEFT JOIN `song` ON `song`.`id`=`object_count`.`object_id` AND `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `object_count`.`user` = ?;\";\n            $db_s   = Dba::read($sql_s, $params);\n            while ($results  = Dba::fetch_assoc($db_s)) {\n                $total = $total + (int)$results['size'];\n            }\n            $sql_v = \"SELECT SUM(`video`.`size`) AS `size` FROM `object_count` LEFT JOIN `video` ON `video`.`id`=`object_count`.`object_id` AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_type` = 'video' AND `object_count`.`user` = ?;\";\n            $db_v  = Dba::read($sql_v, $params);\n            while ($results  = Dba::fetch_assoc($db_v)) {\n                $total = $total + (int)$results['size'];\n            }\n            $sql_p = \"SELECT SUM(`podcast_episode`.`size`) AS `size` FROM `object_count`LEFT JOIN `podcast_episode` ON `podcast_episode`.`id`=`object_count`.`object_id` AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_type` = 'podcast_episode' AND `object_count`.`user` = ?;\";\n            $db_p  = Dba::read($sql_p, $params);\n            while ($results  = Dba::fetch_assoc($db_p)) {\n                $total = $total + (int)$results['size'];\n            }\n            $retval &= (Dba::write(\"REPLACE INTO `user_data` SET `user`= ?, `key`= ?, `value`= ?;\", array($user_id, 'play_size', $total)) !== false);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * update_500013\n     *\n     * Add tables for tracking deleted files. (deleted_song, deleted_video, deleted_podcast_episode)\n     * Add username to the playlist table to stop pulling user all the time\n     */\n    public static function update_500013(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        // deleted_song (id, addition_time, delete_time, title, file, catalog, total_count, total_skip, album, artist)\n        $sql = \"CREATE TABLE IF NOT EXISTS `deleted_song` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED DEFAULT '0', `delete_time` int(11) UNSIGNED DEFAULT '0', `title` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `file` varchar(4096) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL DEFAULT '0', `total_count` int(11) UNSIGNED NOT NULL DEFAULT '0', `total_skip` int(11) UNSIGNED NOT NULL DEFAULT '0', `update_time` int(11) UNSIGNED DEFAULT '0', `album` int(11) UNSIGNED NOT NULL DEFAULT '0', `artist` int(11) UNSIGNED NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // deleted_video (id, addition_time, delete_time, title, file, catalog, total_count, total_skip)\n        $sql = \"CREATE TABLE IF NOT EXISTS `deleted_video` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED NOT NULL, `delete_time` int(11) UNSIGNED NOT NULL, `title` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `file` varchar(4096) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL, `total_count` int(11) UNSIGNED NOT NULL DEFAULT '0', `total_skip` int(11) UNSIGNED NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // deleted_podcast_episode (id, addition_time, delete_time, title, file, catalog, total_count, total_skip, podcast)\n        $sql = \"CREATE TABLE IF NOT EXISTS `deleted_podcast_episode` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED NOT NULL, `delete_time` int(11) UNSIGNED NOT NULL, `title` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `file` varchar(4096) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL, `total_count` int(11) UNSIGNED NOT NULL DEFAULT '0', `total_skip` int(11) UNSIGNED NOT NULL DEFAULT '0', `podcast` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // add username to playlist and searches to stop calling the objects all the time\n        $sql = \"ALTER TABLE `playlist` ADD `username` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `search` ADD `username` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // fill the data\n        $sql = \"UPDATE `playlist`, (SELECT `id`, `username` FROM `user`) AS `user` SET `playlist`.`username` = `user`.`username` WHERE `playlist`.`user` = `user`.`id`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `search`, (SELECT `id`, `username` FROM `user`) AS `user` SET `search`.`username` = `user`.`username` WHERE `search`.`user` = `user`.`id`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `playlist` SET `playlist`.`username` = ? WHERE `playlist`.`user` = -1;\";\n        Dba::write($sql, array(T_('System')));\n        $sql = \"UPDATE `search` SET `search`.`username` = ? WHERE `search`.`user` = -1;\";\n        Dba::write($sql, array(T_('System')));\n\n        return $retval;\n    }\n\n    /**\n     * update_500014\n     *\n     * Add `episodes` to podcast table to track episode count\n     */\n    public static function update_500014(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `podcast` ADD `episodes` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `podcast`, (SELECT COUNT(`podcast_episode`.`id`) AS `episodes`, `podcast` FROM `podcast_episode` GROUP BY `podcast_episode`.`podcast`) AS `episode_count` SET `podcast`.`episodes` = `episode_count`.`episodes` WHERE `podcast`.`episodes` != `episode_count`.`episodes` AND `podcast`.`id` = `episode_count`.`podcast`;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_500015\n     *\n     * Add ui option ('hide_genres') Hide the Genre column in browse table rows\n     */\n    public static function update_500015(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('hide_genres', '0', 'Hide the Genre column in browse table rows', 25, 'boolean', 'interface', 'browse')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_510000\n     *\n     * Add podcast to the object_count table\n     */\n    public static function update_510000(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `object_count` MODIFY COLUMN `object_type` enum('album', 'artist', 'song', 'playlist', 'genre', 'catalog', 'live_stream', 'video', 'podcast', 'podcast_episode');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_510001\n     *\n     * Add podcast to the cache_object_count tables\n     */\n    public static function update_510001(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `cache_object_count_run` MODIFY COLUMN `object_type` enum('album', 'artist', 'song', 'playlist', 'genre', 'catalog', 'live_stream', 'video', 'podcast', 'podcast_episode');\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `cache_object_count` MODIFY COLUMN `object_type` enum('album', 'artist', 'song', 'playlist', 'genre', 'catalog', 'live_stream', 'video', 'podcast', 'podcast_episode');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_510002\n     *\n     * Removed.\n     */\n    public static function update_510002(): bool\n    {\n        return true;\n    }\n\n    /**\n     * update_510003\n     *\n     * Add live_stream to the rating table\n     */\n    public static function update_510003(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `rating` MODIFY COLUMN `object_type` enum('artist', 'album', 'song', 'stream', 'live_stream', 'video', 'playlist', 'tvshow', 'tvshow_season', 'podcast', 'podcast_episode');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_510004\n     *\n     * Add waveform column to podcast_episode table\n     */\n    public static function update_510004(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `podcast_episode` ADD COLUMN `waveform` mediumblob DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_510005\n     *\n     * Add ui option ('subsonic_always_download') Force Subsonic streams to download. (Enable scrobble in your client to record stats)\n     */\n    public static function update_510005(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('subsonic_always_download', '0', 'Force Subsonic streams to download. (Enable scrobble in your client to record stats)', 25, 'boolean', 'options', 'subsonic')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520000\n     *\n     * Add ui options ('api_enable_3', 'api_enable_4', 'api_enable_5') to enable/disable specific API versions\n     * Add ui option ('api_force_version') to force a specific API response (even if that version is disabled)\n     */\n    public static function update_520000(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_enable_3', '1', 'Enable API3 responses', 25, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_enable_4', '1', 'Enable API4 responses', 25, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_enable_5', '1', 'Enable API5 responses', 25, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_force_version', '0', 'Force a specific API response (even if that version is disabled)', 25, 'special', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520001\n     *\n     * Make sure preference names are always unique\n     */\n    public static function update_520001(): bool\n    {\n        $sql             = \"SELECT `id` FROM `preference` WHERE `name` IN (SELECT `name` FROM `preference` GROUP BY `name` HAVING count(`name`) >1) AND `id` NOT IN (SELECT MIN(`id`) FROM `preference` GROUP by `name`);\";\n        $dupe_prefs      = Dba::read($sql);\n        $pref_list       = array();\n        while ($results  = Dba::fetch_assoc($dupe_prefs)) {\n            $pref_list[] = (int)$results['id'];\n        }\n        // delete duplicates (if they exist)\n        foreach ($pref_list as $pref_id) {\n            $sql    = \"DELETE FROM `preference` WHERE `id` = ?;\";\n            Dba::write($sql, array($pref_id));\n        }\n        $sql    = \"DELETE FROM `user_preference` WHERE `preference` NOT IN (SELECT `id` FROM `preference`);\";\n        Dba::write($sql);\n        $sql    = \"ALTER TABLE `preference` ADD CONSTRAINT preference_UN UNIQUE KEY (`name`);\";\n        $retval = (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520002\n     *\n     * Add ui option ('show_playlist_username') Show playlist owner username in titles\n     */\n    public static function update_520002(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('show_playlist_username', '1', 'Show playlist owner username in titles', 25, 'boolean', 'interface', 'browse')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520003\n     *\n     * Add ui option ('api_hidden_playlists') Hide playlists in Subsonic and API clients that start with this string\n     */\n    public static function update_520003(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_hidden_playlists', '', 'Hide playlists in Subsonic and API clients that start with this string', 25, 'string', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520004\n     *\n     * Set 'plugins' category to lastfm_challenge preference\n     */\n    public static function update_520004(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `preference` SET `preference`.`catagory` = 'plugins' WHERE `preference`.`name` = 'lastfm_challenge'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520005\n     *\n     * Add ui option ('api_hide_dupe_searches') Hide smartlists that match playlist names in Subsonic and API clients\n     */\n    public static function update_520005(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_hide_dupe_searches', '0', 'Hide smartlists that match playlist names in Subsonic and API clients', 25, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530000\n     *\n     * Create artist_map table and fill it with data\n     */\n    public static function update_530000(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = 'MyISAM';\n        // create the table\n        $sql = \"CREATE TABLE IF NOT EXISTS `artist_map` (`artist_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, UNIQUE KEY `unique_artist_map` (`object_id`, `object_type`, `artist_id`), INDEX `object_id_index` (`object_id`), INDEX `artist_id_index` (`artist_id`), INDEX `artist_id_type_index` (`artist_id`, `object_type`), INDEX `object_id_type_index` (`object_id`, `object_type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n        // fill the data\n        $sql = \"INSERT IGNORE INTO `artist_map` (`artist_id`, `object_type`, `object_id`) SELECT DISTINCT `song`.`artist` AS `artist_id`, 'song', `song`.`id` FROM `song` WHERE `song`.`artist` > 0 UNION SELECT DISTINCT `album`.`album_artist` AS `artist_id`, 'album', `album`.`id` FROM `album` WHERE `album`.`album_artist` > 0;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530001\n     *\n     * Create album_map table and fill it with data\n     */\n    public static function update_530001(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = 'MyISAM';\n        // create the table\n        $sql = \"CREATE TABLE IF NOT EXISTS `album_map` (`album_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, UNIQUE KEY `unique_album_map` (`object_id`, `object_type`, `album_id`), INDEX `object_id_index` (`object_id`), INDEX `album_id_type_index` (`album_id`, `object_type`), INDEX `object_id_type_index` (`object_id`, `object_type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n        // fill the data\n        $sql = \"INSERT IGNORE INTO `album_map` (`album_id`, `object_type`, `object_id`)  SELECT DISTINCT `artist_map`.`object_id` AS `album_id`, 'album' AS `object_type`, `artist_map`.`artist_id` AS `object_id` FROM `artist_map` WHERE `artist_map`.`object_type` = 'album' AND `artist_map`.`object_id` IS NOT NULL UNION SELECT DISTINCT `song`.`album` AS `album_id`, 'song' AS `object_type`, `song`.`artist` AS `object_id` FROM `song` WHERE `song`.`album` IS NOT NULL UNION SELECT DISTINCT `song`.`album` AS `album_id`, 'song' AS `object_type`, `artist_map`.`artist_id` AS `object_id` FROM `artist_map` LEFT JOIN `song` ON `artist_map`.`object_type` = 'song' AND `artist_map`.`object_id` = `song`.`id` WHERE `song`.`album` IS NOT NULL AND `artist_map`.`object_type` = 'song';\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530002\n     *\n     * Use song_count & artist_count with album_map\n     */\n    public static function update_530002(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `album` ADD `song_artist_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `album`, (SELECT COUNT(`song`.`id`) AS `song_count`, `album` FROM `song` LEFT JOIN `catalog` ON `catalog`.`id` = `song`.`catalog` WHERE `catalog`.`enabled` = '1' GROUP BY `album`) AS `song` SET `album`.`song_count` = `song`.`song_count` WHERE `album`.`song_count` != `song`.`song_count` AND `album`.`id` = `song`.`album`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `album`, (SELECT COUNT(DISTINCT(`album_map`.`object_id`)) AS `artist_count`, `album_id` FROM `album_map` LEFT JOIN `album` ON `album`.`id` = `album_map`.`album_id` LEFT JOIN `catalog` ON `catalog`.`id` = `album`.`catalog` WHERE `album_map`.`object_type` = 'song' AND `catalog`.`enabled` = '1' GROUP BY `album_id`) AS `album_map` SET `album`.`song_artist_count` = `album_map`.`artist_count` WHERE `album`.`id` = `album_map`.`album_id`;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_530003\n     *\n     * Drop id column from catalog_map\n     * Alter `catalog_map` object_type charset and collation\n     */\n    public static function update_530003(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `catalog_map` DROP COLUMN `id`;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `catalog_map` MODIFY COLUMN object_type varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530004\n     *\n     * Alter `album_map` charset and engine to MyISAM if engine set\n     */\n    public static function update_530004(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `album_map` ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `album_map` MODIFY COLUMN `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530005\n     *\n     * Alter `artist_map` charset and engine to MyISAM if engine set\n     */\n    public static function update_530005(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `artist_map` ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `artist_map` MODIFY COLUMN `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530006\n     *\n     * Make sure the object_count table has all the correct primary artist/album rows\n     */\n    public static function update_530006(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `object_count` (object_type, object_id, `date`, `user`, agent, geo_latitude, geo_longitude, geo_name, count_type) SELECT 'album', `song`.`album`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `song` ON `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` = `song`.`id` LEFT JOIN `object_count` AS `album_count` ON `album_count`.`object_type` = 'album' AND `object_count`.`date` = `album_count`.`date` AND `object_count`.`user` = `album_count`.`user` AND `object_count`.`agent` = `album_count`.`agent` AND `object_count`.`count_type` = `album_count`.`count_type` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `album_count`.`id` IS NULL AND `song`.`album` IS NOT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `object_count` (object_type, object_id, `date`, `user`, agent, geo_latitude, geo_longitude, geo_name, count_type) SELECT 'artist', `song`.`artist`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `song` ON `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` = `song`.`id` LEFT JOIN `object_count` AS `artist_count` ON `artist_count`.`object_type` = 'artist' AND `object_count`.`date` = `artist_count`.`date` AND `object_count`.`user` = `artist_count`.`user` AND `object_count`.`agent` = `artist_count`.`agent` AND `object_count`.`count_type` = `artist_count`.`count_type` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `artist_count`.`id` IS NULL AND `song`.`artist` IS NOT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530007\n     *\n     * Convert basic text columns into utf8/utf8_unicode_ci\n     */\n    public static function update_530007(): bool\n    {\n        $retval = true;\n        Dba::write(\"UPDATE `album` SET `mbid` = NULL WHERE CHAR_LENGTH(`mbid`) > 36;\");\n        Dba::write(\"UPDATE `album` SET `mbid_group` = NULL WHERE CHAR_LENGTH(`mbid`) > 36;\");\n\n        $retval &= (Dba::write(\"ALTER TABLE `album` MODIFY COLUMN `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `album` MODIFY COLUMN `mbid_group` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `object_count` MODIFY COLUMN `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `rating` MODIFY COLUMN `object_type` enum('artist','album','song','stream','video','playlist','tvshow','tvshow_season','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_flag` MODIFY COLUMN `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_shout` MODIFY COLUMN `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `video` MODIFY COLUMN `mode` enum('abr','vbr','cbr') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530008\n     *\n     * Remove `user_activity` columns that are useless\n     */\n    public static function update_530008(): bool\n    {\n        $retval = true;\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `name_track`;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `name_artist`;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `name_album`;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `mbid_track`;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `mbid_artist`;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `mbid_album`;\") !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530009\n     *\n     * Compact `object_count` columns\n     */\n    public static function update_530009(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `object_count` MODIFY COLUMN `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `object_count` MODIFY COLUMN `agent` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `object_count` MODIFY COLUMN `geo_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530010\n     *\n     * Compact mbid columns back to 36 characters\n     */\n    public static function update_530010(): bool\n    {\n        $retval = true;\n        Dba::write(\"UPDATE `artist` SET `mbid` = NULL WHERE CHAR_LENGTH(`mbid`) > 36;\");\n        Dba::write(\"UPDATE `recommendation_item` SET `mbid` = NULL WHERE CHAR_LENGTH(`mbid`) > 36;\");\n        $sql    = \"ALTER TABLE `artist` MODIFY COLUMN `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `recommendation_item` MODIFY COLUMN `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song_preview` MODIFY COLUMN `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `wanted` MODIFY COLUMN `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530011\n     *\n     * Compact `user` columns and enum `object_count`.`count_type`\n     */\n    public static function update_530011(): bool\n    {\n        $retval     = true;\n        $collation  = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset    = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $rsstoken   = false;\n        $sql        = \"DESCRIBE `user`\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            if ($row['Field'] == 'rsstoken') {\n                $rsstoken = true;\n            }\n        }\n        if (!$rsstoken) {\n            $sql = \"ALTER TABLE `user` ADD `rsstoken` VARCHAR(255) NULL;\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        $sql = \"ALTER TABLE `user` MODIFY COLUMN `rsstoken` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user` MODIFY COLUMN `validation` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user` MODIFY COLUMN `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user` MODIFY COLUMN `apikey` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user` MODIFY COLUMN `username` varchar(128) CHARACTER SET $charset COLLATE $collation DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530012\n     *\n     * Index data on object_count\n     */\n    public static function update_530012(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `object_count` DROP KEY `object_count_full_index`;\";\n        Dba::write($sql);\n        $sql = \"ALTER TABLE `object_count` DROP KEY `object_count_type_IDX`;\";\n        Dba::write($sql);\n        $sql = \"ALTER TABLE `object_count` DROP KEY `object_count_date_IDX`;\";\n        Dba::write($sql);\n        $sql = \"ALTER TABLE `object_count` DROP KEY `object_count_user_IDX`;\";\n        Dba::write($sql);\n        $sql = \"ALTER TABLE `object_count` DROP KEY `object_count_unique`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `object_count_full_index` USING BTREE ON `object_count` (`object_type`, `object_id`, `date`, `user`, `agent`, `count_type`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE INDEX `object_count_type_IDX` USING BTREE ON `object_count` (`object_type`, `object_id`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE INDEX `object_count_date_IDX` USING BTREE ON `object_count` (`date`, `count_type`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE INDEX `object_count_user_IDX` USING BTREE ON `object_count` (`object_type`, `object_id`, `user`, `count_type`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530013\n     *\n     * Compact `cache_object_count`, `cache_object_count_run` columns\n     */\n    public static function update_530013(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `cache_object_count` MODIFY COLUMN `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `cache_object_count_run` MODIFY COLUMN `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530014\n     *\n     * Use a smaller unique index on `object_count`\n     */\n    public static function update_530014(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `object_count` DROP KEY `object_count_UNIQUE_IDX`;\";\n        Dba::write($sql);\n        // delete duplicates and make sure they're gone\n        $sql = \"DELETE FROM `object_count` WHERE `id` IN (SELECT `id` FROM (SELECT `id` FROM `object_count` WHERE `object_id` IN (SELECT `object_id` FROM `object_count` GROUP BY `object_type`, `object_id`, `date`, `user`, `agent`, `count_type` HAVING COUNT(`object_id`) > 1) AND `id` NOT IN (SELECT MIN(`id`) FROM `object_count` GROUP BY `object_type`, `object_id`, `date`, `user`, `agent`, `count_type`)) AS `count`);\";\n        Dba::write($sql);\n        $sql = \"CREATE UNIQUE INDEX `object_count_UNIQUE_IDX` USING BTREE ON `object_count` (`object_type`, `object_id`, `date`, `user`, `agent`, `count_type`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530015\n     *\n     * Add `show_album_artist` and `show_artist` preferences to show/hide Sidebar Browse menu links. (Fallback to Album Artist if both disabled)\n     */\n    public static function update_530015(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('show_album_artist', '1', 'Show \\'Album Artists\\' link in the main sidebar', 25, 'boolean', 'interface', 'theme')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('show_artist', '0', 'Show \\'Artists\\' link in the main sidebar', 25, 'boolean', 'interface', 'theme')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530016\n     *\n     * Missing type compared to previous version\n     */\n    public static function update_530016(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `rating` MODIFY COLUMN `object_type` enum('artist','album','song','stream','live_stream','video','playlist','tvshow','tvshow_season','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n    }\n\n    /**\n     * update_540000\n     *\n     * Index `title` with `enabled` on `song` table to speed up searching\n     */\n    public static function update_540000(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `song` DROP KEY `title_enabled_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `title_enabled_IDX` USING BTREE ON `song` (`title`, `enabled`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_540001\n     *\n     * Index album tables. `catalog`, `album_artist`, `original_year`, `release_type`, `release_status`, `mbid`, `mbid_group`\n     */\n    public static function update_540001(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `album` DROP KEY `catalog_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `catalog_IDX` USING BTREE ON `album` (`catalog`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `album_artist_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `album_artist_IDX` USING BTREE ON `album` (`album_artist`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `original_year_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `original_year_IDX` USING BTREE ON `album` (`original_year`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `release_type_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `release_type_IDX` USING BTREE ON `album` (`release_type`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `release_status_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `release_status_IDX` USING BTREE ON `album` (`release_status`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `mbid_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `mbid_IDX` USING BTREE ON `album` (`mbid`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `mbid_group_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `mbid_group_IDX` USING BTREE ON `album` (`mbid_group`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_540002\n     *\n     * Index `object_type` with `date` in `object_count` table\n     */\n    public static function update_540002(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `object_count` DROP KEY `object_type_date_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `object_type_date_IDX` USING BTREE ON `object_count` (`object_type`, `date`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /** update_550001\n     *\n     * Add tables `catalog_filter_group` and `catalog_filter_group_map` for catalog filtering by groups\n     * Add column `catalog_filter_group` to `user` table to assign a filter group\n     * Create a DEFAULT group\n     */\n    public static function update_550001(): bool\n    {\n        $retval     = true;\n        $collation  = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset    = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine     = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        // Add the new catalog_filter_group table\n        $sql = \"CREATE TABLE IF NOT EXISTS `catalog_filter_group` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Add the default group (autoincrement starts at 1 so force it to be 0)\n        $sql = \"INSERT IGNORE INTO `catalog_filter_group` (`name`) VALUES ('DEFAULT');\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `catalog_filter_group` SET `id` = 0 WHERE `name` = 'DEFAULT';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `catalog_filter_group` AUTO_INCREMENT = 1;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Add the new catalog_filter_group_map table\n        $sql = \"CREATE TABLE IF NOT EXISTS `catalog_filter_group_map` (`group_id` int(11) UNSIGNED NOT NULL, `catalog_id` int(11) UNSIGNED NOT NULL, `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, UNIQUE KEY (group_id,catalog_id)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Add the default access group to the user table\n        $sql = \"ALTER TABLE `user` ADD `catalog_filter_group` INT(11) UNSIGNED NOT NULL DEFAULT 0;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /** update_550002\n     *\n     * Migrate catalog `filter_user` settings to catalog_filter groups\n     * Assign all public catalogs to the DEFAULT group\n     * Drop table `user_catalog`\n     * Remove `filter_user` from the `catalog` table\n     */\n    public static function update_550002(): bool\n    {\n        $retval = true;\n\n        // Copy existing filters into individual groups for each user. (if a user only has access to public catalogs they are given the default list)\n        $sql        = \"SELECT `id`, `username` FROM `user`;\";\n        $db_results = Dba::read($sql);\n        $user_list  = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $user_list[$row['id']] = $row['username'];\n        }\n        // If the user had a private catalog, create an individual group for them using the current filter and public catalogs.\n        foreach ($user_list as $key => $value) {\n            $group_id   = 0;\n            $sql        = 'SELECT `filter_user` FROM `catalog` WHERE `filter_user` = ?;';\n            $db_results = Dba::read($sql, array($key));\n            if (Dba::num_rows($db_results)) {\n                $sql = \"INSERT IGNORE INTO `catalog_filter_group` (`name`) VALUES ('\" . Dba::escape($value) . \"');\";\n                Dba::write($sql);\n                $group_id = (int)Dba::insert_id();\n            }\n            if ($group_id > 0) {\n                $sql        = \"SELECT `id`, `filter_user` FROM `catalog`;\";\n                $db_results = Dba::read($sql);\n                while ($row = Dba::fetch_assoc($db_results)) {\n                    $catalog = $row['id'];\n                    $enabled = ($row['filter_user'] == 0 || $row['filter_user'] == $key)\n                        ? 1\n                        : 0;\n                    $sql = \"INSERT IGNORE INTO `catalog_filter_group_map` (`group_id`, `catalog_id`, `enabled`) VALUES ($group_id, $catalog, $enabled);\";\n                    $retval &= (Dba::write($sql) !== false);\n                }\n                $sql = \"UPDATE `user` SET `catalog_filter_group` = ? WHERE `id` = ?\";\n                Dba::write($sql, array($group_id, $key));\n            }\n        }\n\n        // Add all public catalogs in the DEFAULT profile.\n        $sql        = \"SELECT `id` FROM `catalog` WHERE `filter_user` = 0;\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $catalog = (int)$row['id'];\n            $sql     = \"INSERT IGNORE INTO `catalog_filter_group_map` (`group_id`, `catalog_id`, `enabled`) VALUES (0, $catalog, 1);\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        $sql = \"DROP TABLE IF EXISTS `user_catalog`;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        if ($retval) {\n            // Drop filter_user but only if the migration has worked\n            $sql = \"ALTER TABLE `catalog` DROP COLUMN `filter_user`;\";\n            Dba::write($sql);\n        }\n\n        return $retval;\n    }\n\n    /** update_550003\n     *\n     * Add system preference `demo_use_search`, Use smartlists for base playlist in Democratic play\n     */\n    public static function update_550003(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('demo_use_search', '0', 'Democratic - Use smartlists for base playlist', 25, 'boolean', 'playlist')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /** update_550004\n     *\n     * Make `demo_use_search`a system preference correctly\n     */\n    public static function update_550004(): bool\n    {\n        $retval = true;\n\n        // Update previous update preference\n        $sql = \"UPDATE `preference` SET `catagory`='system' WHERE `name`='demo_use_search'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /** update_550005\n     *\n     * Add `song_artist` and `album_artist` maps to catalog_map\n     */\n    public static function update_550005(): bool\n    {\n        $retval = true;\n\n        // delete bad maps if they exist\n        $tables = ['album', 'song', 'video', 'podcast', 'podcast_episode', 'live_stream'];\n        foreach ($tables as $type) {\n            $sql = \"DELETE FROM `catalog_map` USING `catalog_map` LEFT JOIN (SELECT DISTINCT `$type`.`catalog` AS `catalog_id`, '$type' AS `map_type`, `$type`.`id` AS `object_id` FROM `$type` GROUP BY `$type`.`catalog`, `map_type`, `$type`.`id`) AS `valid_maps` ON `valid_maps`.`catalog_id` = `catalog_map`.`catalog_id` AND `valid_maps`.`object_id` = `catalog_map`.`object_id` AND `valid_maps`.`map_type` = `catalog_map`.`object_type` WHERE `catalog_map`.`object_type` = '$type' AND `valid_maps`.`object_id` IS NULL;\";\n            Dba::write($sql);\n        }\n        // delete catalog_map artists\n        $sql = \"DELETE FROM `catalog_map` USING `catalog_map` LEFT JOIN (SELECT DISTINCT `song`.`catalog` AS `catalog_id`, 'artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `song` INNER JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `album`.`catalog` AS `catalog_id`, 'artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `album` INNER JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `song`.`catalog` AS `catalog_id`, 'song_artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `song` INNER JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `album`.`catalog` AS `catalog_id`, 'album_artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `album` INNER JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`object_type` IS NOT NULL GROUP BY `album`.`catalog`, `artist_map`.`object_type`, `artist_map`.`artist_id`) AS `valid_maps` ON `valid_maps`.`catalog_id` = `catalog_map`.`catalog_id` AND `valid_maps`.`object_id` = `catalog_map`.`object_id` AND `valid_maps`.`map_type` = `catalog_map`.`object_type` WHERE `catalog_map`.`object_type` IN ('artist', 'song_artist', 'album_artist') AND `valid_maps`.`object_id` IS NULL;\";\n        Dba::write($sql);\n        // insert catalog_map artists\n        $sql = \"INSERT IGNORE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT DISTINCT `song`.`catalog` AS `catalog_id`, 'artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `album`.`catalog` AS `catalog_id`, 'artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `song`.`catalog` AS `catalog_id`, 'song_artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `album`.`catalog` AS `catalog_id`, 'album_artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`object_type` IS NOT NULL GROUP BY `catalog`, `artist_map`.`object_type`, `artist_map`.`artist_id`;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n} // end update.class\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Repository\\Model;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\Art\\Collector\\MetaTagCollectorModule;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\System\\Session;\nuse Ampache\\Module\\Util\\ObjectTypeToClassNameMapper;\nuse Ampache\\Module\\Util\\Ui;\nuse Ampache\\Module\\Api\\Ajax;\nuse Ampache\\Module\\Util\\UtilityFactoryInterface;\nuse Ampache\\Module\\Util\\InterfaceImplementationChecker;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Repository\\SongRepositoryInterface;\nuse Exception;\nuse getID3;\nuse PDOStatement;\nuse Requests;\nuse RuntimeException;\n\n/**\n * This class handles the images / artwork in ampache\n * This was initially in the album class, but was pulled out\n * to be more general and potentially apply to albums, artists, movies etc\n */\nclass Art extends database_object\n{\n    protected const DB_TABLENAME = 'art';\n\n    /**\n     * @var integer $id\n     */\n    public $id;\n    /**\n     * @var string $type\n     */\n    public $type;\n    /**\n     * @var integer $uid\n     */\n    public $uid; // UID of the object not ID because it's not the ART.ID\n    /**\n     * @var string $raw\n     */\n    public $raw; // Raw art data\n    /**\n     * @var string $raw_mime\n     */\n    public $raw_mime;\n    /**\n     * @var string $kind\n     */\n    public $kind;\n\n    /**\n     * @var string $thumb\n     */\n    public $thumb;\n    /**\n     * @var string $thumb_mime\n     */\n    public $thumb_mime;\n\n    /**\n     * Constructor\n     * Art constructor, takes the UID of the object and the\n     * object type.\n     * @param integer $uid\n     * @param string $type\n     * @param string $kind\n     */\n    public function __construct($uid, $type = 'album', $kind = 'default')\n    {\n        if (Art::is_valid_type($type)) {\n            $this->type = $type;\n            $this->uid  = (int)($uid);\n            $this->kind = $kind;\n        }\n    } // constructor\n\n    public function getId(): int\n    {\n        return (int)$this->id;\n    }\n\n    /**\n     * @param string $type\n     * @return boolean\n     */\n    public static function is_valid_type($type)\n    {\n        if (!$type) {\n            return false;\n        }\n\n        return (InterfaceImplementationChecker::is_library_item($type) || $type == 'user');\n    }\n\n    /**\n     * build_cache\n     * This attempts to reduce # of queries by asking for everything in the\n     * browse all at once and storing it in the cache, this can help if the\n     * db connection is the slow point\n     * @param integer[] $object_ids\n     * @param string $type\n     * @return boolean\n     */\n    public static function build_cache($object_ids, $type = null)\n    {\n        if (empty($object_ids)) {\n            return false;\n        }\n        $idlist = '(' . implode(',', $object_ids) . ')';\n        $sql    = \"SELECT `object_type`, `object_id`, `mime`, `size` FROM `image` WHERE `object_id` IN $idlist\";\n        if ($type !== null) {\n            $sql .= \" AND `object_type` = '$type'\";\n        }\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            parent::add_to_cache('art', $row['object_type'] . $row['object_id'] . $row['size'], $row);\n        }\n\n        return true;\n    } // build_cache\n\n    /**\n     * extension\n     * This returns the file extension for the currently loaded art\n     * @param string $mime\n     * @return string\n     */\n    public static function extension($mime)\n    {\n        if (empty($mime)) {\n            return '';\n        }\n        $data      = explode('/', $mime);\n        $extension = $data['1'] ?? '';\n\n        if ($extension == 'jpeg') {\n            $extension = 'jpg';\n        }\n\n        return (string)$extension;\n    } // extension\n\n    /**\n     * test_image\n     * Runs some sanity checks on the putative image\n     * @param string $source\n     * @return boolean\n     * @throws RuntimeException\n     */\n    public static function test_image($source)\n    {\n        if (strlen((string) $source) < 10) {\n            debug_event(self::class, 'Invalid image passed', 1);\n\n            return false;\n        }\n        $max_upload_size = (int)AmpConfig::get('max_upload_size', 0);\n\n        // Check image size doesn't exceed the limit\n        if ($max_upload_size > 0 && strlen((string) $source) > $max_upload_size) {\n            debug_event(self::class, 'Image size (' . strlen((string) $source) . ') exceed the limit (' . $max_upload_size . ').', 1);\n\n            return false;\n        }\n\n        // Check to make sure PHP:GD exists. Don't test things you can't change\n        if (!function_exists('imagecreatefromstring')) {\n            return true;\n        }\n\n        $test  = false;\n        $image = false;\n        if (is_string($source)) {\n            $test  = true;\n            $image = imagecreatefromstring($source);\n            if ($image == false || imagesx($image) < 5 || imagesy($image) < 5) {\n                debug_event(self::class, 'Image failed PHP-GD test', 1);\n                $test = false;\n            }\n        }\n        if ($test && $image != false) {\n            if (imagedestroy($image) === false) {\n                throw new RuntimeException('The image handle from source: ' . $source . ' could not be destroyed');\n            }\n        }\n\n        return $test;\n    } // test_image\n\n    /**\n     * get\n     * This returns the art for our current object, this can\n     * look in the database and will return the thumb if it\n     * exists, if it doesn't depending on settings it will try\n     * to create it.\n     * @param boolean $raw\n     * @param boolean $fallback\n     * @return string\n     */\n    public function get($raw = false, $fallback = false)\n    {\n        // Get the data either way (allow forcing to fallback image)\n        if (!$this->has_db_info($fallback)) {\n            return '';\n        }\n\n        if ($raw || !$this->thumb) {\n            return $this->raw;\n        } else {\n            return $this->thumb;\n        }\n    } // get\n\n    /**\n     * has_db_info\n     * This pulls the information out from the database, depending\n     * on if we want to resize and if there is not a thumbnail go\n     * ahead and try to resize\n     * @return boolean\n     */\n    public function has_db_info($fallback = false)\n    {\n        $sql         = \"SELECT `id`, `image`, `mime`, `size` FROM `image` WHERE `object_type` = ? AND `object_id` = ? AND `kind` = ?\";\n        $db_results  = Dba::read($sql, array($this->type, $this->uid, $this->kind));\n        $default_art = false;\n\n        while ($results = Dba::fetch_assoc($db_results)) {\n            if ($results['size'] == 'original') {\n                if (AmpConfig::get('album_art_store_disk')) {\n                    $this->raw = self::read_from_dir($results['size'], $this->type, $this->uid, $this->kind, $results['mime']);\n                } else {\n                    $this->raw = $results['image'];\n                }\n                $this->raw_mime = $results['mime'];\n            } elseif (AmpConfig::get('resize_images')) {\n                if (AmpConfig::get('album_art_store_disk')) {\n                    $this->thumb = self::read_from_dir($results['size'], $this->type, $this->uid, $this->kind, $results['mime']);\n                } elseif ($results['size'] == '275x275') {\n                    $this->thumb = $results['image'];\n                }\n                $this->raw_mime = $results['mime'];\n            }\n            $this->id = (int)$results['id'];\n        }\n        // return a default image if fallback is requested\n        if (!$this->raw && $fallback) {\n            $this->raw      = self::read_from_images();\n            $this->raw_mime = 'image/png';\n            $default_art    = true;\n        }\n        // If we get nothing return false\n        if (!$this->raw) {\n            return false;\n        }\n\n        // If there is no thumb and we want thumbs\n        if (!$this->thumb && AmpConfig::get('resize_images')) {\n            $size = array('width' => 275, 'height' => 275);\n            $data = $this->generate_thumb($this->raw, $size, $this->raw_mime);\n            // If it works save it!\n            if (!empty($data)) {\n                if (!$default_art) {\n                    $this->save_thumb($data['thumb'], $data['thumb_mime'], $size);\n                }\n                $this->thumb      = $data['thumb'];\n                $this->thumb_mime = $data['thumb_mime'];\n            } else {\n                debug_event(self::class, 'Art id {' . $this->id . '} Unable to generate thumbnail for ' . $this->type . ': ' . $this->uid, 1);\n            }\n        } // if no thumb, but art and we want to resize\n\n        return true;\n    } // has_db_info\n\n    /**\n     * This check if an object has an associated image in db.\n     * @param integer $object_id\n     * @param string $object_type\n     * @param string $kind\n     * @return boolean\n     */\n    public static function has_db($object_id, $object_type, $kind = 'default')\n    {\n        $sql        = \"SELECT COUNT(`id`) AS `nb_img` FROM `image` WHERE `object_type` = ? AND `object_id` = ? AND `kind` = ?\";\n        $db_results = Dba::read($sql, array($object_type, $object_id, $kind));\n        $nb_img     = 0;\n        if ($results = Dba::fetch_assoc($db_results)) {\n            $nb_img = $results['nb_img'];\n        }\n\n        return ($nb_img > 0);\n    }\n\n    /**\n     * This insert art from url.\n     * @param string $url\n     */\n    public function insert_url($url)\n    {\n        debug_event(self::class, 'Insert art from url ' . $url, 4);\n        $image = self::get_from_source(array('url' => $url), $this->type);\n        $rurl  = pathinfo($url);\n        $mime  = \"image/\" . $rurl['extension'];\n        $this->insert($image, $mime);\n    }\n\n    /**\n     * insert\n     * This takes the string representation of an image and inserts it into\n     * the database. You must also pass the mime type.\n     * @param string $source\n     * @param string $mime\n     * @return boolean\n     */\n    public function insert($source, $mime = '')\n    {\n        // Disabled in demo mode cause people suck and upload porn\n        if (AmpConfig::get('demo_mode')) {\n            return false;\n        }\n\n        // Check to make sure we like this image\n        if (!self::test_image($source)) {\n            debug_event(self::class, 'Not inserting image for ' . $this->type . ' ' . $this->uid . ', invalid data passed', 1);\n\n            return false;\n        }\n\n        $dimensions = Core::image_dimensions($source);\n        $width      = (int)($dimensions['width']);\n        $height     = (int)($dimensions['height']);\n        $sizetext   = 'original';\n\n        if (!self::check_dimensions($dimensions)) {\n            return false;\n        }\n\n        // Default to image/jpeg if they don't pass anything\n        $mime = $mime ?? 'image/jpeg';\n        // Blow it away!\n        $this->reset();\n        $current_picturetypeid = ($this->type == 'album') ? 3 : 8;\n\n        if (AmpConfig::get('write_tags', false)) {\n            $class_name = ObjectTypeToClassNameMapper::map($this->type);\n            $object     = new $class_name($this->uid);\n            $songs      = array();\n            debug_event(__CLASS__, 'Inserting ' . $this->type . ' image' . $object->name . ' for song files.', 5);\n            if ($this->type === 'album') {\n                /** Use special treatment for albums */\n                $songs = $this->getSongRepository()->getByAlbum($object->id);\n            } elseif ($this->type === 'artist') {\n                /** Use special treatment for artists */\n                $songs = $this->getSongRepository()->getByArtist($object->id);\n            }\n            global $dic;\n            $utilityFactory = $dic->get(UtilityFactoryInterface::class);\n\n            foreach ($songs as $song_id) {\n                $song   = new Song($song_id);\n                $song->format();\n                $description = ($this->type == 'artist') ? $song->f_artist_full : $object->full_name;\n                $vainfo      = $utilityFactory->createVaInfo(\n                    $song->file\n                );\n\n                $ndata      = array();\n                $data       = $vainfo->read_id3();\n                $fileformat = $data['fileformat'];\n                if ($fileformat == 'flac' || $fileformat == 'ogg') {\n                    $apics = $data['flac']['PICTURE'];\n                } else {\n                    $apics = $data['id3v2']['APIC'];\n                }\n                /* is the file flac or mp3? */\n                $apic_typeid   = ($fileformat == 'flac' || $fileformat == 'ogg') ? 'typeid' : 'picturetypeid';\n                $apic_mimetype = ($fileformat == 'flac' || $fileformat == 'ogg') ? 'image_mime' : 'mime';\n                $new_pic       = array('data' => $source, 'mime' => $mime,\n                    'picturetypeid' => $current_picturetypeid, 'description' => $description);\n\n                if (is_null($apics)) {\n                    $ndata['attached_picture'][]    = $new_pic;\n                } else {\n                    switch (count($apics)) {\n                        case 1:\n                            $idx = $this->check_for_duplicate($apics, $ndata, $new_pic, $apic_typeid);\n                            if (is_null($idx)) {\n                                $ndata['attached_picture'][] = $new_pic;\n                                $ndata['attached_picture'][] = array('data' => $apics[0]['data'], 'description' => $apics[0]['description'],\n                                    'mime' => $apics[0]['mime'], 'picturetypeid' => $apics[0]['picturetypeid']);\n                            }\n                            break;\n                        case 2:\n                            $idx = $this->check_for_duplicate($apics, $ndata, $new_pic, $apic_typeid);\n                            /* If $idx is null, it means both images are of opposite types\n                             * of the new image. Either image could be replaced to have\n                             * one cover and one artist image.\n                             */\n                            if (is_null($idx)) {\n                                $ndata['attached_picture'][0] = $new_pic;\n                            } else {\n                                $apicsId                              = ($idx == 0) ? 1 : 0;\n                                $ndata['attached_picture'][$apicsId]  = array('data' => $apics[$apicsId]['data'], 'mime' => $apics[$apicsId][$apic_mimetype],\n                                'picturetypeid' => $apics[$apicsId][$apic_typeid], 'description' => $apics[$apicsId]['description']);\n                            }\n\n                            break;\n                    }\n                }\n                unset($apics);\n                $tags    = ($fileformat == 'flac' || $fileformat == 'ogg') ? 'vorbiscomment' : 'id3v2';\n                $ndata   = array_merge($ndata, $vainfo->prepare_metadata_for_writing($data['tags'][$tags]));\n                $vainfo->write_id3($ndata);\n            } // foreach song\n        } // write_id3\n\n        if (AmpConfig::get('album_art_store_disk')) {\n            self::write_to_dir($source, $sizetext, $this->type, $this->uid, $this->kind, $mime);\n            $source = null;\n        }\n        // Insert it!\n        $sql = \"INSERT INTO `image` (`image`, `mime`, `size`, `width`, `height`, `object_type`, `object_id`, `kind`) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\";\n        Dba::write($sql, array($source, $mime, $sizetext, $width, $height, $this->type, $this->uid, $this->kind));\n\n        return true;\n    } // insert\n\n    /**\n     * check_for_duplicate\n     * @param array $apics\n     * @param array $ndata\n     * @param array $new_pic\n     * @param string $apic_typeid\n     * @return int|null\n     */\n    private function check_for_duplicate($apics, &$ndata, $new_pic, $apic_typeid)\n    {\n        $idx = null;\n        $cnt = count($apics);\n        for ($i=0; $i < $cnt; $i++) {\n            if ($new_pic['picturetypeid'] == $apics[$i][$apic_typeid]) {\n                $ndata['attached_picture'][$i]['description']       = $new_pic['description'];\n                $ndata['attached_picture'][$i]['data']              = $new_pic['data'];\n                $ndata['attached_picture'][$i]['mime']              = $new_pic['mime'];\n                $ndata['attached_picture'][$i]['picturetypeid']     = $new_pic['picturetypeid'];\n                $idx                                                = $i;\n                break;\n            }\n        }\n\n        return $idx;\n    }\n\n    /**\n     * Prepares images to be written to file tag.\n     * @param array $pics\n     * @return array\n     */\n    public static function prepare_pics($pics)\n    {\n        $ndata = array();\n        $i     = 0;\n        foreach ($pics as $pic) {\n            $ndata['attached_picture'][$i]['description']   = $pic['description'];\n            $ndata['attached_picture'][$i]['data']          = $pic['data'];\n            $ndata['attached_picture'][$i]['picturetypeid'] = $pic['picturetypeid'];\n            $ndata['attached_picture'][$i]['mime']          = $pic['mime'];\n\n            $i++;\n        }\n\n        return $ndata;\n    }\n\n    /**\n     * check_dimensions\n     * @param array $dimensions\n     * @return boolean\n     */\n    public static function check_dimensions($dimensions)\n    {\n        $width  = (int)($dimensions['width']);\n        $height = (int)($dimensions['height']);\n\n        if ($width > 0 && $height > 0) {\n            $minw = (AmpConfig::get('album_art_min_width')) ? AmpConfig::get('album_art_min_width') : 0;\n            $maxw = (AmpConfig::get('album_art_max_width')) ? AmpConfig::get('album_art_max_width') : 0;\n            $minh = (AmpConfig::get('album_art_min_height')) ? AmpConfig::get('album_art_min_height') : 0;\n            $maxh = (AmpConfig::get('album_art_max_height')) ? AmpConfig::get('album_art_max_height') : 0;\n\n            // minimum width is set and current width is too low\n            if ($minw > 0 && $width < $minw) {\n                debug_event(self::class, \"Image width not in range (min=$minw, max=$maxw, current=$width).\", 1);\n\n                return false;\n            }\n            // max width is set and current width is too high\n            if ($maxw > 0 && $width > $maxw) {\n                debug_event(self::class, \"Image width not in range (min=$minw, max=$maxw, current=$width).\", 1);\n\n                return false;\n            }\n            if ($minh > 0 && $height < $minh) {\n                debug_event(self::class, \"Image height not in range (min=$minh, max=$maxh, current=$height).\", 1);\n\n                return false;\n            }\n            if ($maxh > 0 && $height > $maxh) {\n                debug_event(self::class, \"Image height not in range (min=$minh, max=$maxh, current=$height).\", 1);\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * clear_image\n     * Clear the image column (if you have the image on disk)\n     */\n    public static function clear_image($image_id)\n    {\n        $sql = \"UPDATE `image` SET `image` = NULL WHERE `id` = ?\";\n        Dba::write($sql, array($image_id));\n    } // clear_image\n\n    /**\n     * get_dir_on_disk\n     * @param string $type\n     * @param string $uid\n     * @param string $kind\n     * @param boolean $autocreate\n     * @return false|string\n     */\n    public static function get_dir_on_disk($type, $uid, $kind = '', $autocreate = false)\n    {\n        $path = AmpConfig::get('local_metadata_dir');\n        if (!$path) {\n            debug_event(self::class, 'local_metadata_dir setting is required to store art on disk.', 1);\n\n            return false;\n        }\n\n        // Correctly detect the slash we need to use here\n        if (strpos($path, '/') !== false) {\n            $slash_type = '/';\n        } else {\n            $slash_type = '\\\\';\n        }\n\n        $path .= $slash_type . $type;\n        if ($autocreate && !Core::is_readable($path)) {\n            mkdir($path);\n        }\n\n        $path .= $slash_type . $uid;\n        if ($autocreate && !Core::is_readable($path)) {\n            mkdir($path);\n        }\n\n        if (!empty($kind)) {\n            $path .= $slash_type . $kind;\n            if ($autocreate && !Core::is_readable($path)) {\n                mkdir($path);\n            }\n        }\n        $path .= $slash_type;\n\n        return $path;\n    }\n\n    /**\n     * write_to_dir\n     * @param string $source\n     * @param string $sizetext\n     * @param string $type\n     * @param integer $uid\n     * @param $kind\n     * @param $mime\n     * @return boolean\n     */\n    private static function write_to_dir($source, $sizetext, $type, $uid, $kind, $mime)\n    {\n        $path = self::get_dir_on_disk($type, $uid, $kind, true);\n        if ($path === false) {\n            return false;\n        }\n        $path .= \"art-\" . $sizetext . \".\" . self::extension($mime);\n        if (Core::is_readable($path)) {\n            unlink($path);\n        }\n        $filepath = fopen($path, \"wb\");\n        fwrite($filepath, $source);\n        fclose($filepath);\n\n        return true;\n    }\n\n    /**\n     * read_from_images\n     * @param string $name\n     */\n    private static function read_from_images($name = 'blankalbum.png')\n    {\n        $path = __DIR__ . '/../../../public/images/blankalbum.png';\n        if (!Core::is_readable($path)) {\n            debug_event(self::class, 'read_from_images ' . $path . ' cannot be read.', 1);\n\n            return null;\n        }\n\n        $image    = '';\n        $filepath = fopen($path, \"rb\");\n        do {\n            $image .= fread($filepath, 2048);\n        } while (!feof($filepath));\n        fclose($filepath);\n\n        return $image;\n    }\n\n    /**\n     * read_from_dir\n     * @param $sizetext\n     * @param string $type\n     * @param integer $uid\n     * @param string $kind\n     * @param $mime\n     * @return string|null\n     */\n    private static function read_from_dir($sizetext, $type, $uid, $kind, $mime)\n    {\n        $path = self::get_dir_on_disk($type, $uid, $kind);\n        if ($path === false) {\n            return null;\n        }\n        $path .= \"art-\" . $sizetext . '.' . self::extension($mime);\n        if (!Core::is_readable($path)) {\n            debug_event(self::class, 'Local image art ' . $path . ' cannot be read.', 1);\n\n            return null;\n        }\n\n        $image    = '';\n        $filepath = fopen($path, \"rb\");\n        do {\n            $image .= fread($filepath, 2048);\n        } while (!feof($filepath));\n        fclose($filepath);\n\n        return $image;\n    }\n\n    /**\n     * delete_from_dir\n     * @param string $type\n     * @param string $uid\n     * @param string $kind\n     */\n    private static function delete_from_dir($type, $uid, $kind = '')\n    {\n        if ($type && $uid) {\n            $path = self::get_dir_on_disk($type, $uid, $kind);\n            if ($path !== false) {\n                self::delete_rec_dir(rtrim($path, '/'));\n            }\n        }\n    }\n\n    /**\n     * delete_rec_dir\n     * @param string $path\n     */\n    private static function delete_rec_dir($path)\n    {\n        debug_event(self::class, 'Deleting ' . (string) $path . ' directory...', 5);\n\n        if (Core::is_readable($path)) {\n            foreach (scandir($path) as $file) {\n                if ('.' === $file || '..' === $file) {\n                    continue;\n                } elseif (is_dir($path . '/' . $file)) {\n                    self::delete_rec_dir(rtrim($path, '/') . '/' . $file);\n                } else {\n                    unlink($path . '/' . $file);\n                }\n            }\n            rmdir($path);\n        }\n    }\n\n    /**\n     * reset\n     * This resets the art in the database\n     */\n    public function reset()\n    {\n        if (AmpConfig::get('album_art_store_disk')) {\n            self::delete_from_dir($this->type, $this->uid, $this->kind);\n        }\n        $sql = \"DELETE FROM `image` WHERE `object_id` = ? AND `object_type` = ? AND `kind` = ?\";\n        Dba::write($sql, array($this->uid, $this->type, $this->kind));\n    } // reset\n\n    /**\n     * save_thumb\n     * This saves the thumbnail that we're passed\n     * @param string $source\n     * @param string $mime\n     * @param array $size\n     * @return boolean\n     */\n    public function save_thumb($source, $mime, $size)\n    {\n        // Quick sanity check\n        if (!self::test_image($source)) {\n            debug_event(self::class, 'Not inserting thumbnail, invalid data passed', 1);\n\n            return false;\n        }\n\n        $width    = $size['width'];\n        $height   = $size['height'];\n        $sizetext = $width . 'x' . $height;\n\n        $sql = \"DELETE FROM `image` WHERE `object_id` = ? AND `object_type` = ? AND `size` = ? AND `kind` = ?\";\n        Dba::write($sql, array($this->uid, $this->type, $sizetext, $this->kind));\n\n        if (AmpConfig::get('album_art_store_disk')) {\n            self::write_to_dir($source, $sizetext, $this->type, $this->uid, $this->kind, $mime);\n            $source = null;\n        }\n        $sql = \"INSERT INTO `image` (`image`, `mime`, `size`, `width`, `height`, `object_type`, `object_id`, `kind`) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\";\n        Dba::write($sql, array($source, $mime, $sizetext, $width, $height, $this->type, $this->uid, $this->kind));\n\n        return true;\n    } // save_thumb\n\n    /**\n     * get_thumb\n     * Returns the specified resized image.  If the requested size doesn't\n     * already exist, create and cache it.\n     * @param array $size\n     * @return array\n     */\n    public function get_thumb($size)\n    {\n        $sizetext   = $size['width'] . 'x' . $size['height'];\n        $sql        = \"SELECT `image`, `mime` FROM `image` WHERE `size` = ? AND `object_type` = ? AND `object_id` = ? AND `kind` = ?\";\n        $db_results = Dba::read($sql, array($sizetext, $this->type, $this->uid, $this->kind));\n\n        $results = Dba::fetch_assoc($db_results);\n        if (count($results)) {\n            if (AmpConfig::get('album_art_store_disk')) {\n                $image = self::read_from_dir($sizetext, $this->type, $this->uid, $this->kind, $results['mime']);\n            } else {\n                $image = $results['image'];\n            }\n\n            if ($image != null) {\n                return array(\n                    'thumb' => (AmpConfig::get('album_art_store_disk'))\n                        ? self::read_from_dir($sizetext, $this->type, $this->uid, $this->kind, $results['mime'])\n                        : $results['image'],\n                    'thumb_mime' => $results['mime']\n                );\n            } else {\n                debug_event(self::class, 'Thumb entry found in database but associated data cannot be found.', 3);\n            }\n        }\n\n        // If we didn't get a result try again\n        $results = array();\n        if (!$this->raw && $this->thumb) {\n            $results = $this->generate_thumb($this->thumb, $size, $this->raw_mime);\n        }\n        if ($this->raw) {\n            $results = $this->generate_thumb($this->raw, $size, $this->raw_mime);\n        }\n        if (!empty($results)) {\n            $this->save_thumb($results['thumb'], $results['thumb_mime'], $size);\n        }\n\n        return $results;\n    } // get_thumb\n\n    /**\n     * generate_thumb\n     * Automatically resizes the image for thumbnail viewing.\n     * Only works on gif/jpg/png/bmp. Fails if PHP-GD isn't available\n     * or lacks support for the requested image type.\n     * @param string $image\n     * @param array $size\n     * @param string $mime\n     * @return array\n     */\n    public function generate_thumb($image, $size, $mime)\n    {\n        $data = explode('/', (string) $mime);\n        $type = ((string)($data[1] ?? '') !== '') ? strtolower((string) $data[1]) : 'jpg';\n\n        if (!self::test_image($image)) {\n            debug_event(self::class, 'Not trying to generate thumbnail, invalid data passed', 1);\n\n            return array();\n        }\n\n        if (!function_exists('gd_info')) {\n            debug_event(self::class, 'PHP-GD Not found - unable to resize art', 1);\n\n            return array();\n        }\n\n        // Check and make sure we can resize what you've asked us to\n        if (($type == 'jpg' || $type == 'jpeg' || $type == 'jpg?v=2') && !(imagetypes() & IMG_JPG)) {\n            debug_event(self::class, 'PHP-GD Does not support JPGs - unable to resize', 1);\n\n            return array();\n        }\n        if ($type == 'png' && !imagetypes() & IMG_PNG) {\n            debug_event(self::class, 'PHP-GD Does not support PNGs - unable to resize', 1);\n\n            return array();\n        }\n        if ($type == 'gif' && !imagetypes() & IMG_GIF) {\n            debug_event(self::class, 'PHP-GD Does not support GIFs - unable to resize', 1);\n\n            return array();\n        }\n        if ($type == 'bmp' && !imagetypes() & IMG_WBMP) {\n            debug_event(self::class, 'PHP-GD Does not support BMPs - unable to resize', 1);\n\n            return array();\n        }\n\n        $source = imagecreatefromstring($image);\n\n        if (!$source) {\n            debug_event(self::class, 'Failed to create Image from string - Source Image is damaged / malformed', 2);\n\n            return array();\n        }\n\n        $source_size = array('height' => imagesy($source), 'width' => imagesx($source));\n\n        // Create a new blank image of the correct size\n        $thumbnail = imagecreatetruecolor((int) $size['width'], (int) $size['height']);\n\n        if ($source_size['width'] > $source_size['height']) {\n            // landscape\n            $new_height = $size['height'];\n            $new_width  = floor($source_size['width'] * ($new_height / $source_size['height']));\n            $crop_x     = ceil(($source_size['width'] - $source_size['height']) / 2);\n            $crop_y     = 0;\n        } elseif ($source_size['height'] > $source_size['width']) {\n            // portrait\n            $new_width  = $size['width'];\n            $new_height = floor($source_size['height'] * ($new_width / $source_size['width']));\n            $crop_x     = 0;\n            $crop_y     = ceil(($source_size['height'] - $source_size['width']) / 3); // assuming most portrait images would have faces closer to the top\n        } else {\n            // square\n            $new_width  = $size['width'];\n            $new_height = $size['height'];\n            $crop_x     = 0;\n            $crop_y     = 0;\n        }\n\n        if (!imagecopyresampled($thumbnail, $source, 0, 0, $crop_x, $crop_y, $new_width, $new_height, $source_size['width'], $source_size['height'])) {\n            debug_event(self::class, 'Unable to create resized image', 1);\n            imagedestroy($source);\n            imagedestroy($thumbnail);\n\n            return array();\n        }\n        imagedestroy($source);\n\n        // Start output buffer\n        ob_start();\n\n        // Generate the image to our OB\n        switch ($type) {\n            case 'jpg':\n            case 'jpeg':\n            case 'jpg?v=2':\n            case '(null)':\n                imagejpeg($thumbnail, null, 75);\n                $mime_type = image_type_to_mime_type(IMAGETYPE_JPEG);\n                break;\n            case 'gif':\n                imagegif($thumbnail);\n                $mime_type = image_type_to_mime_type(IMAGETYPE_GIF);\n                break;\n            // Turn bmps into pngs\n            case 'bmp':\n            case 'png':\n                imagepng($thumbnail);\n                $mime_type = image_type_to_mime_type(IMAGETYPE_PNG);\n                break;\n            default:\n                $mime_type = null;\n        } // resized\n\n        if ($mime_type === null) {\n            debug_event(self::class, 'Error: No mime type found using: ' . $mime, 2);\n\n            return array();\n        }\n\n        $data = ob_get_contents();\n        ob_end_clean();\n\n        imagedestroy($thumbnail);\n\n        if (!strlen((string) $data)) {\n            debug_event(self::class, 'Unknown Error resizing art', 1);\n\n            return array();\n        }\n\n        return array('thumb' => $data, 'thumb_mime' => $mime_type);\n    } // generate_thumb\n\n    /**\n     * get_from_source\n     * This gets an image for the album art from a source as\n     * defined in the passed array. Because we don't know where\n     * it's coming from we are a passed an array that can look like\n     * ['url']      = URL *** OPTIONAL ***\n     * ['file']     = FILENAME *** OPTIONAL ***\n     * ['raw']      = Actual Image data, already captured\n     * @param array $data\n     * @param string $type\n     * @return string\n     */\n    public static function get_from_source($data, $type)\n    {\n        if (!isset($type)) {\n            $type = (AmpConfig::get('show_song_art')) ? 'song' : 'album';\n        }\n        if (empty($data) || !is_array($data)) {\n            return '';\n        }\n\n        // Already have the data, this often comes from id3tags\n        if (isset($data['raw'])) {\n            return $data['raw'];\n        }\n\n        // If it came from the database\n        if (isset($data['db'])) {\n            $sql        = \"SELECT * FROM `image` WHERE `object_type` = ? AND `object_id` = ? AND `size`='original'\";\n            $db_results = Dba::read($sql, array($type, $data['db']));\n            $row        = Dba::fetch_assoc($db_results);\n\n            return $row['art'];\n        } // came from the db\n\n        // Check to see if it's a URL\n        if (array_key_exists('url', $data) && filter_var($data['url'], FILTER_VALIDATE_URL)) {\n            debug_event(self::class, 'CHECKING URL ' . $data['url'], 2);\n            $options = array();\n            try {\n                $options['timeout'] = 10;\n                Requests::register_autoloader();\n                $request = Requests::get($data['url'], array(), Core::requests_options($options));\n                $raw     = $request->body;\n            } catch (Exception $error) {\n                debug_event(self::class, 'Error getting art: ' . $error->getMessage(), 2);\n                $raw = '';\n            }\n\n            return $raw;\n        }\n\n        // Check to see if it's a FILE\n        if (isset($data['file'])) {\n            $handle     = fopen($data['file'], 'rb');\n            $image_data = (string)fread($handle, Core::get_filesize($data['file']));\n            fclose($handle);\n\n            return $image_data;\n        }\n\n        // Check to see if it is embedded in id3 of a song\n        if (isset($data['song'])) {\n            // If we find a good one, stop looking\n            $getID3 = new getID3();\n            $id3    = $getID3->analyze($data['song']);\n\n            if (isset($id3['asf']['extended_content_description_object']['content_descriptors']['13'])) {\n                return $id3['asf']['extended_content_description_object']['content_descriptors']['13'];\n            }\n\n            if (isset($id3['id3v2']['APIC'])) {\n                // Foreach in case they have more than one\n                foreach ($id3['id3v2']['APIC'] as $image) {\n                    if (isset($image['picturetypeid']) && array_key_exists('data', $image)) {\n                        if ($data['title'] == MetaTagCollectorModule::getPictureType((int)$image['picturetypeid'])) {\n                            return $image['data'];\n                        }\n                    }\n                }\n            }\n\n            if (isset($id3['id3v2']['PIC'])) {\n                // Foreach in case they have more than one\n                foreach ($id3['id3v2']['PIC'] as $image) {\n                    if (isset($image['picturetypeid']) && array_key_exists('data', $image)) {\n                        if ($data['title'] == MetaTagCollectorModule::getPictureType((int)$image['picturetypeid'])) {\n                            return $image['data'];\n                        }\n                    }\n                }\n            }\n\n            if (isset($id3['flac']['PICTURE'])) {\n                // Foreach in case they have more than one\n                foreach ($id3['flac']['PICTURE'] as $image) {\n                    if (isset($image['typeid']) && array_key_exists('data', $image)) {\n                        $title = 'ID3 ' . MetaTagCollectorModule::getPictureType((int)$image['typeid']);\n                        if ($data['title'] == $title) {\n                            return $image['data'];\n                        }\n                    }\n                }\n            }\n\n            if (isset($id3['comments']['picture'])) {\n                // Foreach in case they have more than one\n                foreach ($id3['comments']['picture'] as $image) {\n                    if (isset($image['picturetype']) && array_key_exists('data', $image)) {\n                        if ($data['title'] == 'ID3 ' . $image['picturetype']) {\n                            return $image['data'];\n                        }\n                    }\n                    if (isset($image['description']) && array_key_exists('data', $image)) {\n                        if ($data['title'] == 'ID3 ' . $image['description']) {\n                            return $image['data'];\n                        }\n                    }\n                }\n            }\n        } // if data song\n\n        return '';\n    } // get_from_source\n\n    /**\n     * url\n     * This returns the constructed URL for the art in question\n     * @param integer $uid\n     * @param string $type\n     * @param string $sid\n     * @param integer|null $thumb\n     * @return string\n     */\n    public static function url($uid, $type, $sid = null, $thumb = null)\n    {\n        if (!self::is_valid_type($type)) {\n            return null;\n        }\n\n        if (AmpConfig::get('use_auth') && AmpConfig::get('require_session')) {\n            $sid = $sid ? scrub_out($sid) : scrub_out(session_id());\n            if ($sid == null) {\n                $sid = Session::create(array(\n                    'type' => 'api'\n                ));\n            }\n        } else {\n            $sid = 'none';\n        }\n\n        $key = $type . $uid;\n\n        if (parent::is_cached('art', $key . '275x275') && AmpConfig::get('resize_images')) {\n            $row  = parent::get_from_cache('art', $key . '275x275');\n            $mime = $row['mime'];\n        }\n        if (parent::is_cached('art', $key . 'original')) {\n            $row        = parent::get_from_cache('art', $key . 'original');\n            $thumb_mime = $row['mime'];\n        }\n        if (!isset($mime) && !isset($thumb_mime)) {\n            $sql        = \"SELECT `object_type`, `object_id`, `mime`, `size` FROM `image` WHERE `object_type` = ? AND `object_id` = ?\";\n            $db_results = Dba::read($sql, array($type, $uid));\n\n            while ($row = Dba::fetch_assoc($db_results)) {\n                parent::add_to_cache('art', $key . $row['size'], $row);\n                if ($row['size'] == 'original') {\n                    $mime = $row['mime'];\n                } else {\n                    if ($row['size'] == '275x275' && AmpConfig::get('resize_images')) {\n                        $thumb_mime = $row['mime'];\n                    }\n                }\n            }\n        }\n\n        $mime      = $thumb_mime ?? ($mime ?? null);\n        $extension = self::extension($mime);\n\n        if (AmpConfig::get('stream_beautiful_url')) {\n            if (empty($extension)) {\n                $extension = 'jpg';\n            }\n            $url = AmpConfig::get('web_path') . '/play/art/' . $sid . '/' . scrub_out($type) . '/' . scrub_out($uid) . '/thumb';\n            if ($thumb !== null) {\n                $url .= $thumb;\n            }\n            $url .= '.' . $extension;\n        } else {\n            $url = AmpConfig::get('web_path') . '/image.php?object_id=' . scrub_out($uid) . '&object_type=' . scrub_out($type) . '&auth=' . $sid;\n            if ($thumb !== null) {\n                $url .= '&thumb=' . $thumb;\n            }\n            if (!empty($extension)) {\n                $name = 'art.' . $extension;\n                $url .= '&name=' . $name;\n            }\n        }\n\n        return $url;\n    } // url\n\n    /**\n     * garbage_collection\n     * This cleans up art that no longer has a corresponding object\n     * @param string $object_type\n     * @param integer $object_id\n     */\n    public static function garbage_collection($object_type = null, $object_id = null)\n    {\n        $types = array(\n            'album',\n            'artist',\n            'tvshow',\n            'tvshow_season',\n            'video',\n            'user',\n            'live_stream',\n            'playlist',\n            'song'\n        );\n\n        if ($object_type !== null) {\n            if (in_array($object_type, $types)) {\n                if (AmpConfig::get('album_art_store_disk')) {\n                    self::delete_from_dir($object_type, $object_id);\n                }\n                $sql = \"DELETE FROM `image` WHERE `object_type` = ? AND `object_id` = ?\";\n                Dba::write($sql, array($object_type, $object_id));\n            } else {\n                debug_event(self::class, 'Garbage collect on type `' . $object_type . '` is not supported.', 1);\n            }\n        } else {\n            $album_art_store_disk = AmpConfig::get('album_art_store_disk');\n            // iterate over our types and delete the images\n            foreach ($types as $type) {\n                if ($album_art_store_disk) {\n                    $sql        = \"SELECT `image`.`object_id`, `image`.`object_type` FROM `image` LEFT JOIN `\" . $type . \"` ON `\" . $type . \"`.`id`=\" . \"`image`.`object_id` WHERE `object_type`='\" . $type . \"' AND `\" . $type . \"`.`id` IS NULL\";\n                    $db_results = Dba::read($sql);\n                    while ($row = Dba::fetch_row($db_results)) {\n                        self::delete_from_dir($row[1], $row[0]);\n                    }\n                }\n                $sql = \"DELETE FROM `image` USING `image` LEFT JOIN `\" . $type . \"` ON `\" . $type . \"`.`id`=\" . \"`image`.`object_id` WHERE `object_type`='\" . $type . \"' AND `\" . $type . \"`.`id` IS NULL\";\n                Dba::write($sql);\n            } // foreach\n        }\n    }\n\n    /**\n     * Migrate an object associate images to a new object\n     * @param string $object_type\n     * @param integer $old_object_id\n     * @param integer $new_object_id\n     * @return PDOStatement|boolean\n     */\n    public static function migrate($object_type, $old_object_id, $new_object_id)\n    {\n        $sql = \"UPDATE `image` SET `object_id` = ? WHERE `object_type` = ? AND `object_id` = ?\";\n\n        return Dba::write($sql, array($new_object_id, $object_type, $old_object_id));\n    }\n\n    /**\n     * Duplicate an object associate images to a new object\n     * @param string $object_type\n     * @param integer $old_object_id\n     * @param integer $new_object_id\n     * @param string $new_object_type\n     * @return PDOStatement|boolean\n     */\n    public static function duplicate($object_type, $old_object_id, $new_object_id, $new_object_type = null)\n    {\n        $write_type = (self::is_valid_type($new_object_type))\n            ? $new_object_type\n            : $object_type;\n        if (Art::has_db($new_object_id, $write_type) || $old_object_id == $new_object_id) {\n            return false;\n        }\n\n        debug_event(self::class, 'duplicate... type:' . $object_type . ' old_id:' . $old_object_id . ' new_type:' . $write_type . ' new_id:' . $new_object_id, 5);\n        if (AmpConfig::get('album_art_store_disk')) {\n            $sql        = \"SELECT `size`, `kind`, `mime` FROM `image` WHERE `object_type` = ? AND `object_id` = ?\";\n            $db_results = Dba::read($sql, array($object_type, $old_object_id));\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $image = self::read_from_dir($row['size'], $object_type, $old_object_id, $row['kind'], $row['mime']);\n                if ($image !== null) {\n                    self::write_to_dir($image, $row['size'], $write_type, $new_object_id, $row['kind'], $row['mime']);\n                }\n            }\n        }\n\n        $sql = \"INSERT INTO `image` (`image`, `mime`, `size`, `object_type`, `object_id`, `kind`) SELECT `image`, `mime`, `size`, ? AS `object_type`, ? AS `object_id`, `kind` FROM `image` WHERE `object_type` = ? AND `object_id` = ?\";\n\n        return Dba::write($sql, array($write_type, $new_object_id, $object_type, $old_object_id));\n    }\n\n    /**\n     * Gather metadata from plugin.\n     * @param $plugin\n     * @param string $type\n     * @param array $options\n     * @return array\n     */\n    public static function gather_metadata_plugin($plugin, $type, $options)\n    {\n        $gtypes     = array();\n        $media_info = array();\n        switch ($type) {\n            case 'tvshow':\n            case 'tvshow_season':\n            case 'tvshow_episode':\n                $gtypes[]                                   = 'tvshow';\n                $media_info['tvshow']                       = $options['tvshow'];\n                $media_info['tvshow_season']                = $options['tvshow_season'];\n                $media_info['tvshow_episode']               = $options['tvshow_episode'];\n                break;\n            case 'song':\n                $media_info['mb_trackid'] = $options['mb_trackid'];\n                $media_info['title']      = $options['title'];\n                $media_info['artist']     = $options['artist'];\n                $media_info['album']      = $options['album'];\n                $gtypes[]                 = 'song';\n                break;\n            case 'album':\n                $media_info['mb_albumid']       = $options['mb_albumid'];\n                $media_info['mb_albumid_group'] = $options['mb_albumid_group'];\n                $media_info['artist']           = $options['artist'];\n                $media_info['title']            = $options['album'];\n                $gtypes[]                       = 'music';\n                $gtypes[]                       = 'album';\n                break;\n            case 'artist':\n                $media_info['mb_artistid'] = $options['mb_artistid'];\n                $media_info['title']       = $options['artist'];\n                $gtypes[]                  = 'music';\n                $gtypes[]                  = 'artist';\n                break;\n            case 'movie':\n                $gtypes[]            = 'movie';\n                $media_info['title'] = $options['keyword'];\n                break;\n        }\n\n        $meta   = $plugin->get_metadata($gtypes, $media_info);\n        $images = array();\n\n        if (array_key_exists('art', $meta)) {\n            $url      = $meta['art'];\n            $ures     = pathinfo($url);\n            $images[] = array('url' => $url, 'mime' => 'image/' . ($ures['extension'] ?? 'jpg'), 'title' => $plugin->name);\n        }\n        if (array_key_exists('tvshow_season_art', $meta)) {\n            $url      = $meta['tvshow_season_art'];\n            $ures     = pathinfo($url);\n            $images[] = array('url' => $url, 'mime' => 'image/' . ($ures['extension'] ?? 'jpg'), 'title' => $plugin->name);\n        }\n        if (array_key_exists('tvshow_art', $meta)) {\n            $url      = $meta['tvshow_art'];\n            $ures     = pathinfo($url);\n            $images[] = array('url' => $url, 'mime' => 'image/' . ($ures['extension'] ?? 'jpg'), 'title' => $plugin->name);\n        }\n\n        return $images;\n    }\n\n    /**\n     * Get thumb size from thumb type.\n     * @param integer $thumb\n     * @return array\n     */\n    public static function get_thumb_size($thumb)\n    {\n        $size = array();\n\n        switch ($thumb) {\n            case 1:\n                // This is used by the now_playing / browse stuff\n                $size['height'] = 100;\n                $size['width']  = 100;\n                break;\n            case 2:\n                // live stream, artist pages\n                $size['height'] = 128;\n                $size['width']  = 128;\n                break;\n            case 22:\n                $size['height'] = 256;\n                $size['width']  = 256;\n                break;\n            case 32:\n                // Single Album & Podcast pages\n                $size['height'] = 384;\n                $size['width']  = 384;\n                break;\n            case 3:\n                // This is used by the embedded web player\n                $size['height'] = 80;\n                $size['width']  = 80;\n                break;\n            case 5:\n                // Web Player size\n                $size['height'] = 32;\n                $size['width']  = 32;\n                break;\n            case 6:\n                // Video browsing size\n                $size['height'] = 150;\n                $size['width']  = 100;\n                break;\n            case 34:\n                // small 34x34\n                $size['height'] = 34;\n                $size['width']  = 34;\n                break;\n            case 64:\n                // medium 64x64\n                $size['height'] = 64;\n                $size['width']  = 64;\n                break;\n            case 174:\n                // large 174x174\n                $size['height'] = 174;\n                $size['width']  = 174;\n                break;\n            case 300:\n                // extralarge, mega 300x300\n            case 7:\n                // Video page size\n                $size['height'] = 300;\n                $size['width']  = 200;\n                break;\n            case 8:\n                // Video preview size\n                $size['height'] = 200;\n                $size['width']  = 470;\n                break;\n            case 9:\n                // Video preview size\n                $size['height'] = 84;\n                $size['width']  = 150; // cel_cover max-width is 150px\n                break;\n            case 10:\n                // Search preview size\n                $size['height'] = 24;\n                $size['width']  = 24;\n                break;\n            case 4:\n                // Popup Web Player size\n            case 11:\n                // Large view browse size\n            case 12:\n                // Search preview size\n                $size['height'] = 150;\n                $size['width']  = 150;\n                break;\n            default:\n                $size['height'] = 200;\n                $size['width']  = 200;\n                break;\n        }\n\n        // For @2x output\n        $size['height'] *= 2;\n        $size['width'] *= 2;\n\n        return $size;\n    }\n\n    /**\n     * Display an item art.\n     * @param string $object_type\n     * @param integer $object_id\n     * @param string $name\n     * @param integer $thumb\n     * @param string $link\n     * @param boolean $show_default\n     * @param string $kind\n     * @return boolean\n     */\n    public static function display(\n        $object_type,\n        $object_id,\n        $name,\n        $thumb,\n        $link = null,\n        $show_default = true,\n        $kind = 'default'\n    ) {\n        if (!self::is_valid_type($object_type)) {\n            return false;\n        }\n\n        if (!$show_default) {\n            // Don't show any image if not available\n            if (!self::has_db($object_id, $object_type, $kind)) {\n                return false;\n            }\n        }\n        $size        = self::get_thumb_size($thumb);\n        $prettyPhoto = ($link === null);\n        if ($link === null) {\n            $link = AmpConfig::get('web_path') . \"/image.php?object_id=\" . $object_id . \"&object_type=\" . $object_type . \"&thumb=\" . $thumb;\n            if (AmpConfig::get('use_auth') && AmpConfig::get('require_session')) {\n                $link .= \"&auth=\" . session_id();\n            }\n            if ($kind != 'default') {\n                $link .= '&kind=' . $kind;\n            }\n        }\n        echo \"<div class=\\\"item_art\\\">\";\n        echo \"<a href=\\\"\" . $link . \"\\\" title=\\\"\" . $name . \"\\\"\";\n        if ($prettyPhoto) {\n            echo \" rel=\\\"prettyPhoto\\\"\";\n        }\n        echo \">\";\n        $imgurl = AmpConfig::get('web_path') . \"/image.php?object_id=\" . $object_id . \"&object_type=\" . $object_type . \"&thumb=\" . $thumb;\n        if ($kind != 'default') {\n            $imgurl .= '&kind=' . $kind;\n        }\n        // This to keep browser cache feature but force a refresh in case image just changed\n        if (Art::has_db($object_id, $object_type)) {\n            $art = new Art($object_id, $object_type);\n            if ($art->has_db_info()) {\n                $imgurl .= '&fooid=' . $art->id;\n            }\n        }\n\n        // For @2x output\n        $size['height'] /= 2;\n        $size['width'] /= 2;\n\n        echo \"<img src=\\\"\" . $imgurl . \"\\\" alt=\\\"\" . $name . \"\\\" height=\\\"\" . $size['height'] . \"\\\" width=\\\"\" . $size['width'] . \"\\\" />\";\n\n        // don't put the play icon on really large images.\n        if ($size['height'] >= 150 && $size['height'] <= 300) {\n            echo \"<div class=\\\"item_art_play\\\">\";\n            echo Ajax::text('?page=stream&action=directplay&object_type=' . $object_type . '&object_id=' . $object_id . '\\' + getPagePlaySettings() + \\'',\n                '<span class=\"item_art_play_icon\" title=\"' . T_('Play') . '\" />',\n                'directplay_art_' . $object_type . '_' . $object_id);\n            echo \"</div>\";\n        }\n\n        if ($prettyPhoto) {\n            $class_name  = ObjectTypeToClassNameMapper::map($object_type);\n            $libitem     = new $class_name($object_id);\n            echo \"<div class=\\\"item_art_actions\\\">\";\n            if (Core::get_global('user')->has_access(50) || (Core::get_global('user')->has_access(25) && Core::get_global('user')->id == $libitem->get_user_owner())) {\n                echo \"<a href=\\\"javascript:NavigateTo('\" . AmpConfig::get('web_path') . \"/arts.php?action=show_art_dlg&object_type=\" . $object_type . \"&object_id=\" . $object_id . \"&burl=' + getCurrentPage());\\\">\";\n                echo Ui::get_icon('edit', T_('Edit/Find Art'));\n                echo \"</a>\";\n                echo \"<a href=\\\"javascript:NavigateTo('\" . AmpConfig::get('web_path') . \"/arts.php?action=clear_art&object_type=\" . $object_type . \"&object_id=\" . $object_id . \"&burl=' + getCurrentPage());\\\" onclick=\\\"return confirm('\" . T_('Do you really want to reset art?') . \"');\\\">\";\n                echo Ui::get_icon('delete', T_('Reset Art'));\n                echo \"</a>\";\n            }\n            echo \"</div>\";\n        }\n\n        echo \"</a>\\n\";\n        echo \"</div>\";\n\n        return true;\n    }\n\n    /**\n     * Display an item art, bypassing the return value.\n     * @deprecated Temporary as legacy Art::display outputs boolean when used with return\n     * @param string $object_type\n     * @param integer $object_id\n     * @param string $name\n     * @param integer $thumb\n     * @param string $link\n     * @param boolean $show_default\n     * @param string $kind\n     * @return string\n     */\n    public static function display_without_return(\n        $object_type,\n        $object_id,\n        $name,\n        $thumb,\n        $link = null,\n        $show_default = true,\n        $kind = 'default'\n    ) {\n        self::display(\n            $object_type,\n            $object_id,\n            $name,\n            $thumb,\n            $link,\n            $show_default,\n            $kind\n        );\n\n        return '';\n    }\n\n    /**\n     * Get the object details for the art table\n     * @return array\n     */\n    public static function get_art_array()\n    {\n        $results    = array();\n        $sql        = \"SELECT `id`, `object_id`, `object_type`, `size`, `mime` FROM `image` WHERE `image` IS NOT NULL;\";\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row;\n        }\n\n        return $results;\n    }\n\n    /**\n     * Get the object details for the art table\n     * @param  array $data\n     * @return string\n     */\n    public static function get_raw_image($data)\n    {\n        $sql        = \"SELECT `image` FROM `image` WHERE `object_id` = ? AND `object_type` = ? AND `size` = ? AND `mime` = ?;\";\n        $db_results = Dba::read($sql, $data);\n        $row        = Dba::fetch_assoc($db_results);\n        if (empty($row)) {\n            return '';\n        }\n\n        return (string)$row['image'];\n    }\n\n    /**\n     * @deprecated\n     */\n    private function getSongRepository(): SongRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(SongRepositoryInterface::class);\n    }\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Repository\\Model;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Config\\ConfigContainerInterface;\nuse Ampache\\Config\\ConfigurationKeyEnum;\nuse Ampache\\Module\\Art\\Collector\\ArtCollectorInterface;\nuse Ampache\\Module\\Authorization\\Access;\nuse Ampache\\Module\\Catalog\\Catalog_beets;\nuse Ampache\\Module\\Catalog\\Catalog_beetsremote;\nuse Ampache\\Module\\Catalog\\Catalog_dropbox;\nuse Ampache\\Module\\Catalog\\Catalog_local;\nuse Ampache\\Module\\Catalog\\Catalog_remote;\nuse Ampache\\Module\\Catalog\\Catalog_Seafile;\nuse Ampache\\Module\\Catalog\\Catalog_soundcloud;\nuse Ampache\\Module\\Catalog\\Catalog_subsonic;\nuse Ampache\\Module\\Catalog\\GarbageCollector\\CatalogGarbageCollectorInterface;\nuse Ampache\\Module\\Playback\\Stream_Url;\nuse Ampache\\Module\\Song\\Tag\\SongTagWriterInterface;\nuse Ampache\\Module\\Statistics\\Stats;\nuse Ampache\\Module\\System\\AmpError;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\Util\\ObjectTypeToClassNameMapper;\nuse Ampache\\Module\\Util\\Recommendation;\nuse Ampache\\Module\\Util\\Ui;\nuse Ampache\\Module\\Util\\UtilityFactoryInterface;\nuse Ampache\\Module\\Util\\VaInfo;\nuse Ampache\\Repository\\AlbumRepositoryInterface;\nuse Ampache\\Repository\\LabelRepositoryInterface;\nuse Ampache\\Repository\\LicenseRepositoryInterface;\nuse Ampache\\Repository\\Model\\Metadata\\Repository\\Metadata;\nuse Ampache\\Repository\\SongRepositoryInterface;\nuse Ampache\\Repository\\UserRepositoryInterface;\nuse Exception;\nuse PDOStatement;\nuse RecursiveDirectoryIterator;\nuse RecursiveIteratorIterator;\nuse ReflectionException;\nuse RegexIterator;\n\n/**\n * This class handles all actual work in regards to the catalog,\n * it contains functions for creating/listing/updated the catalogs.\n */\nabstract class Catalog extends database_object\n{\n    protected const DB_TABLENAME = 'catalog';\n\n    private const CATALOG_TYPES = [\n        'beets' => Catalog_beets::class,\n        'beetsremote' => Catalog_beetsremote::class,\n        'dropbox' => Catalog_dropbox::class,\n        'local' => Catalog_local::class,\n        'remote' => Catalog_remote::class,\n        'seafile' => Catalog_Seafile::class,\n        'soundcloud' => Catalog_soundcloud::class,\n        'subsonic' => Catalog_subsonic::class,\n    ];\n\n    /**\n     * @var integer $id\n     */\n    public $id;\n    /**\n     * @var string $name\n     */\n    public $name;\n    /**\n     * @var integer $last_update\n     */\n    public $last_update;\n    /**\n     * @var integer $last_add\n     */\n    public $last_add;\n    /**\n     * @var integer $last_clean\n     */\n    public $last_clean;\n    /**\n     * @var string $key\n     */\n    public $key;\n    /**\n     * @var string $rename_pattern\n     */\n    public $rename_pattern;\n    /**\n     * @var string $sort_pattern\n     */\n    public $sort_pattern;\n    /**\n     * @var string $catalog_type\n     */\n    public $catalog_type;\n    /**\n     * @var string $gather_types\n     */\n    public $gather_types;\n\n    /**\n     * @var string $f_name\n     */\n    public $f_name;\n    /**\n     * @var string $link\n     */\n    public $link;\n    /**\n     * @var string $f_link\n     */\n    public $f_link;\n    /**\n     * @var string $f_update\n     */\n    public $f_update;\n    /**\n     * @var string $f_add\n     */\n    public $f_add;\n    /**\n     * @var string $f_clean\n     */\n    public $f_clean;\n    /**\n     * alias for catalog paths, urls, etc etc\n     * @var string $f_full_info\n     */\n    public $f_full_info;\n    /**\n     * alias for catalog paths, urls, etc etc\n     * @var string $f_info\n     */\n    public $f_info;\n    /**\n     * @var integer $enabled\n     */\n    public $enabled;\n\n    /**\n     * This is a private var that's used during catalog builds\n     * @var array $_playlists\n     */\n    protected $_playlists = array();\n\n    /**\n     * Cache all files in catalog for quick lookup during add\n     * @var array $_filecache\n     */\n    protected $_filecache = array();\n\n    // Used in functions\n    /**\n     * @var array $albums\n     */\n    protected static $albums = array();\n    /**\n     * @var array $artists\n     */\n    protected static $artists = array();\n    /**\n     * @var array $tags\n     */\n    protected static $tags = array();\n\n    /**\n     * @return string\n     */\n    abstract public function get_type();\n\n    /**\n     * @return string\n     */\n    abstract public function get_description();\n\n    /**\n     * @return string\n     */\n    abstract public function get_version();\n\n    /**\n     * @return string\n     */\n    abstract public function get_create_help();\n\n    /**\n     * @return bool\n     */\n    abstract public function is_installed();\n\n    /**\n     * @return bool\n     */\n    abstract public function install();\n\n    /**\n     * @param array $options\n     * @return mixed\n     */\n    abstract public function add_to_catalog($options = null);\n\n    /**\n     * @return mixed\n     */\n    abstract public function verify_catalog_proc();\n\n    /**\n     * @return int\n     */\n    abstract public function clean_catalog_proc();\n\n    /**\n     * @return array\n     */\n    abstract public function check_catalog_proc();\n\n    /**\n     * @param string $new_path\n     * @return boolean\n     */\n    abstract public function move_catalog_proc($new_path);\n\n    /**\n     * @return bool\n     */\n    abstract public function cache_catalog_proc();\n\n    /**\n     * @return array\n     */\n    abstract public function catalog_fields();\n\n    /**\n     * @param string $file_path\n     * @return string\n     */\n    abstract public function get_rel_path($file_path);\n\n    /**\n     * @param Song|Podcast_Episode|Song_Preview|Video $media\n     * @return Media|null\n     */\n    abstract public function prepare_media($media);\n\n    public function getId(): int\n    {\n        return (int)$this->id;\n    }\n\n    /**\n     * Check if the catalog is ready to perform actions (configuration completed, ...)\n     * @return boolean\n     */\n    public function isReady()\n    {\n        return true;\n    }\n\n    /**\n     * Show a message to make the catalog ready.\n     */\n    public function show_ready_process()\n    {\n        // Do nothing.\n    }\n\n    /**\n     * Perform the last step process to make the catalog ready.\n     */\n    public function perform_ready()\n    {\n        // Do nothing.\n    }\n\n    /**\n     * uninstall\n     * This removes the remote catalog\n     * @return boolean\n     */\n    public function uninstall()\n    {\n        $sql = \"DELETE FROM `catalog` WHERE `catalog_type` = ?\";\n        Dba::query($sql, array($this->get_type()));\n\n        $sql = \"DROP TABLE `catalog_\" . $this->get_type() . \"`\";\n        Dba::query($sql);\n\n        return true;\n    } // uninstall\n\n    /**\n     * Create a catalog from its id.\n     * @param integer $catalog_id\n     * @return Catalog|null\n     */\n    public static function create_from_id($catalog_id)\n    {\n        $sql        = 'SELECT `catalog_type` FROM `catalog` WHERE `id` = ?';\n        $db_results = Dba::read($sql, array($catalog_id));\n        $row        = Dba::fetch_assoc($db_results);\n        if (empty($row)) {\n            return null;\n        }\n\n        return self::create_catalog_type($row['catalog_type'], $catalog_id);\n    }\n\n    /**\n     * create_catalog_type\n     * This function attempts to create a catalog type\n     * @param string $type\n     * @param integer $catalog_id\n     * @return Catalog|null\n     */\n    public static function create_catalog_type($type, $catalog_id = 0)\n    {\n        if (!$type) {\n            return null;\n        }\n\n        $controller = self::CATALOG_TYPES[$type] ?? null;\n\n        if ($controller === null) {\n            /* Throw Error Here */\n            debug_event(__CLASS__, 'Unable to load ' . $type . ' catalog type', 2);\n\n            return null;\n        } // include\n        if ($catalog_id > 0) {\n            $catalog = new $controller($catalog_id);\n        } else {\n            $catalog = new $controller();\n        }\n        if (!($catalog instanceof Catalog)) {\n            debug_event(__CLASS__, $type . ' not an instance of Catalog abstract, unable to load', 1);\n\n            return null;\n        }\n        // identify if it's actually enabled\n        $sql        = 'SELECT `enabled` FROM `catalog` WHERE `id` = ?';\n        $db_results = Dba::read($sql, array($catalog->id));\n\n        while ($results = Dba::fetch_assoc($db_results)) {\n            $catalog->enabled = $results['enabled'];\n        }\n\n        return $catalog;\n    }\n\n    /**\n     * Show dropdown catalog types.\n     * @param string $divback\n     */\n    public static function show_catalog_types($divback = 'catalog_type_fields')\n    {\n        echo '<script>' . \"var type_fields = new Array();type_fields['none'] = '';\";\n        $seltypes = '<option value=\"none\">[' . T_(\"Select\") . ']</option>';\n        $types    = self::get_catalog_types();\n        foreach ($types as $type) {\n            $catalog = self::create_catalog_type($type);\n            if ($catalog->is_installed()) {\n                $seltypes .= '<option value=\"' . $type . '\">' . $type . '</option>';\n                echo \"type_fields['\" . $type . \"'] = \\\"\";\n                $fields = $catalog->catalog_fields();\n                $help   = $catalog->get_create_help();\n                if (!empty($help)) {\n                    echo \"<tr><td></td><td>\" . $help . \"</td></tr>\";\n                }\n                foreach ($fields as $key => $field) {\n                    echo \"<tr><td style='width: 25%;'>\" . $field['description'] . \":</td><td>\";\n                    $value = (array_key_exists('value', $field)) ? $field['value'] : '';\n\n                    switch ($field['type']) {\n                        case 'checkbox':\n                            echo \"<input type='checkbox' name='\" . $key . \"' value='1' \" . ((!empty($value)) ? 'checked' : '') . \"/>\";\n                            break;\n                        default:\n                            echo \"<input type='\" . $field['type'] . \"' name='\" . $key . \"' value='\" . $value . \"' />\";\n                            break;\n                    }\n                    echo \"</td></tr>\";\n                }\n                echo \"\\\";\";\n            }\n        }\n\n        echo \"function catalogTypeChanged() {var sel = document.getElementById('catalog_type');var seltype = sel.options[sel.selectedIndex].value;var ftbl = document.getElementById('\" . $divback . \"');ftbl.innerHTML = '<table class=\\\"tabledata\\\">' + type_fields[seltype] + '</table>';} </script><select name=\\\"type\\\" id=\\\"catalog_type\\\" onChange=\\\"catalogTypeChanged();\\\">\" . $seltypes . \"</select>\";\n    }\n\n    /**\n     * get_catalog_types\n     * This returns the catalog types that are available\n     * @return string[]\n     */\n    public static function get_catalog_types()\n    {\n        return array_keys(self::CATALOG_TYPES);\n    }\n\n    /**\n     * get_catalog_filters\n     * This returns the filters, sorting by name or by id as indicated by $sort\n     * $sort = field to sort on (id or name)\n     * @return string[]\n     */\n    public static function get_catalog_filters($sort = 'name')\n    {\n        $results = array();\n        // Now fetch the rest;\n        $sql        = \"SELECT `id`,`name` FROM `catalog_filter_group` ORDER BY `$sort` \";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row;\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_catalog_filter_names\n     * This returns the names of the catalog filters that are available with the default filter listed first.\n     * @return string[]\n     */\n    public static function get_catalog_filter_names()\n    {\n        $results = array();\n\n        // Get the default filter and name\n        // Default filter is always the first one.\n        $sql        = \"SELECT `name` FROM `catalog_filter_group` WHERE `id` = 0\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_assoc($db_results);\n        $results[]  = $row['name'];\n\n        // Now fetch the rest;\n        $sql        = \"SELECT `name` FROM `catalog_filter_group` WHERE `id` > 0 ORDER BY `name`\";\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row['name'];\n        }\n\n        return $results;\n    }\n\n    public static function get_catalog_filter_name($id = 0)\n    {\n        $sql        = \"SELECT `name` FROM `catalog_filter_group` WHERE `id` = ?\";\n        $db_results = Dba::read($sql, array($id));\n        $row        = Dba::fetch_assoc($db_results);\n\n        return $row['name'];\n    }\n\n    public static function get_catalog_filter_by_name($filter_name)\n    {\n        $sql        = \"SELECT `id` FROM `catalog_filter_group` WHERE `name` = ?\";\n        $db_results = Dba::read($sql, array($filter_name));\n        $row        = Dba::fetch_assoc($db_results);\n\n        return (int)$row['id'];\n    }\n\n    /**\n     * get_catalog_filter_name\n     * This returns the catalog filter name with the given ID.\n     * @return string\n     */\n    public static function get_catalog_name($filter_id = 0)\n    {\n        $sql        = \"SELECT `name` FROM `catalog` WHERE `id` = ?\";\n        $db_results = Dba::read($sql, array($filter_id));\n        $row        = Dba::fetch_assoc($db_results);\n\n        return $row['name'];\n    }\n\n    /**\n     * filter_user_count\n     * Returns the number of users assigned to a particular filter.\n     * @return int\n     */\n    public static function filter_user_count($filter_id)\n    {\n        $sql        = \"SELECT COUNT(1) AS `count` FROM `user` WHERE `catalog_filter_group` = ?\";\n        $db_results = Dba::read($sql, array($filter_id));\n        $row        = Dba::fetch_assoc($db_results);\n\n        return $row['count'];\n    }\n\n    /**\n     * filter_catalog_count\n     * This returns the number of catalogs assigned to a filter.\n     * @return string\n     */\n    public static function filter_catalog_count($filter_id)\n    {\n        $sql        = \"SELECT COUNT(1) AS `count` FROM `catalog_filter_group_map` WHERE `group_id` = ? AND `enabled` = 1\";\n        $db_results = Dba::read($sql, array($filter_id));\n        $row        = Dba::fetch_assoc($db_results);\n\n        return $row['count'];\n    }\n\n    /**\n     * filter_count\n     * This returns the number of filters.\n     * @return int\n     */\n    public static function filter_count()\n    {\n        $sql        = \"SELECT COUNT(1) AS `count` FROM `catalog_filter_group`\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_assoc($db_results);\n\n        return (int)$row['count'] ?? 0;\n    }\n\n    /**\n     * filter_name_exists\n     * can specifiy an ID to ignore in this check, useful for filter names.\n     * @return bool\n     */\n    public static function filter_name_exists($filter_name, $exclude_id = 0)\n    {\n        $params = array($filter_name);\n        $sql    = \"SELECT `id` FROM `catalog_filter_group` WHERE `name` = ?\";\n        if ($exclude_id >= 0) {\n            $sql .= \" AND `id` != ?\";\n            $params[] = $exclude_id;\n        }\n\n        $db_results = Dba::read($sql, $params);\n        if (Dba::num_rows($db_results) > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * check_filter_catalog_enabled\n     * Returns the `enabled` status of the filter/catalog combination\n     * @return bool\n     */\n    public static function check_filter_catalog_enabled($filter_id, $catalog_id)\n    {\n        $sql        = \"SELECT `enabled` FROM `catalog_filter_group_map` WHERE `group_id` = ? AND `catalog_id` = ? AND `enabled` = 1;\";\n        $db_results = Dba::read($sql, array($filter_id, $catalog_id));\n        if (Dba::num_rows($db_results)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * add_catalog_filter_group_map\n     * Adds appropriate rows when a catalog is added.\n     * @return PDOStatement|boolean\n     */\n    public static function add_catalog_filter_group_map($catalog_id)\n    {\n        $results    = array();\n        $sql        = \"SELECT `id` FROM `catalog_filter_group` ORDER BY `id`\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        $sql = \"INSERT IGNORE INTO `catalog_filter_group_map` (`group_id`, `catalog_id`, `enabled`) VALUES \";\n        foreach ($results as $filter_id) {\n            $sql .= \"\" . (int)$filter_id . \", \" . (int)$catalog_id . \", 0),\";\n        }\n        // Remove last comma to avoid SQL error\n        $sql = substr($sql, 0, -1);\n\n        return Dba::write($sql);\n    }\n\n    /**\n     * add_catalog_filter_group\n     * @return PDOStatement|boolean\n     */\n    public static function add_catalog_filter_group($filter_name, $catalogs)\n    {\n        // Create the filter\n        $params = array($filter_name);\n        $sql    = \"INSERT INTO `catalog_filter_group` (`name`) VALUES ('$filter_name')\";\n        Dba::write($sql, $params);\n        $filter_id = Dba::insert_id();\n\n        // Fill in catalog_filter_group_map table for the new filter\n        $results    = array();\n        $sql        = \"SELECT `id` FROM `catalog` ORDER BY `id`\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        $sql = \"INSERT INTO `catalog_filter_group_map` (`group_id`, `catalog_id`, `enabled`) VALUES \";\n        foreach ($results as $catalog_id) {\n            $cn      = self::get_catalog_name($catalog_id);\n            $enabled = $catalogs[$cn];\n            $sql .= \"($filter_id, $catalog_id, $enabled),\";\n        }\n        // Remove last comma to avoid SQL error\n        $sql = substr($sql, 0, -1);\n\n        return Dba::write($sql);\n    }\n\n    /**\n     * edit_catalog_filter\n     * @return bool\n     */\n    public static function edit_catalog_filter($filter_id, $filter_name, $catalogs)\n    {\n        // Modify the filter name\n        $results = array();\n        $sql     = \"UPDATE `catalog_filter_group` SET `name` = ? WHERE `id` = ?;\";\n        Dba::write($sql, array($filter_name, $filter_id));\n\n        // Fill in catalog_filter_group_map table for the filter\n        $sql        = \"SELECT `id` FROM `catalog` ORDER BY `id`\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        foreach ($results as $catalog_id) {\n            $sql        = \"SELECT `catalog_id` FROM `catalog_filter_group_map` WHERE `group_id` = ? AND `catalog_id` = ?\";\n            $db_results = Dba::read($sql, array($filter_id, $catalog_id));\n            $enabled    = $catalogs[$catalog_id];\n            if (Dba::num_rows($db_results)) {\n                // update the values\n                $sql     = \"UPDATE `catalog_filter_group_map` SET `enabled` = ? WHERE `group_id` = ? AND `catalog_id` = ?\";\n                if (!Dba::write($sql, array($enabled, $filter_id, $catalog_id))) {\n                    return false;\n                }\n            } else {\n                // missing group map? add it in\n                $sql = \"INSERT INTO `catalog_filter_group_map` SET `enabled` = ?, `group_id` = ?, `catalog_id` = ?\";\n                if (!Dba::write($sql, array($enabled, $filter_id, $catalog_id))) {\n                    return false;\n                }\n            }\n        }\n        self::garbage_collect_filters();\n\n        return true;\n    }\n\n    /**\n     * delete_catalog_filter\n     * @return PDOStatement|boolean\n     */\n    public static function delete_catalog_filter($filter_id)\n    {\n        if ($filter_id > 0) {\n            $params = array($filter_id);\n            $sql    = \"DELETE FROM `catalog_filter_group` WHERE `id` = ?\";\n            if (Dba::write($sql, $params)) {\n                $sql = \"DELETE FROM `catalog_filter_group_map` WHERE `group_id` = ?\";\n\n                return Dba::write($sql, $params);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * reset_user_filter\n     * reset a users's catalog filter to DEFAULT after deleting a filter group\n     */\n    public static function reset_user_filter($filter_id)\n    {\n        $sql = \"UPDATE `user` SET `catalog_filter_group` = 0 WHERE `catalog_filter_group` = ?\";\n        Dba::write($sql, array($filter_id));\n    }\n\n    /**\n     * Check if a file is an audio.\n     * @param string $file\n     * @return boolean\n     */\n    public static function is_audio_file($file)\n    {\n        $ignore_pattern = AmpConfig::get('catalog_ignore_pattern');\n        $ignore_check   = !($ignore_pattern) || preg_match(\"/(\" . $ignore_pattern . \")/i\", $file) === 0;\n        $file_pattern   = AmpConfig::get('catalog_file_pattern');\n        $pattern        = \"/\\.(\" . $file_pattern . \")$/i\";\n\n        return ($ignore_check && preg_match($pattern, $file));\n    }\n\n    /**\n     * Check if a file is a video.\n     * @param string $file\n     * @return boolean\n     */\n    public static function is_video_file($file)\n    {\n        $ignore_pattern = AmpConfig::get('catalog_ignore_pattern');\n        $ignore_check   = !($ignore_pattern) || preg_match(\"/(\" . $ignore_pattern . \")/i\", $file) === 0;\n        $video_pattern  = \"/\\.(\" . AmpConfig::get('catalog_video_pattern') . \")$/i\";\n\n        return ($ignore_check && preg_match($video_pattern, $file));\n    }\n\n    /**\n     * Check if a file is a playlist.\n     * @param string $file\n     * @return bool\n     */\n    public static function is_playlist_file($file)\n    {\n        $ignore_pattern   = AmpConfig::get('catalog_ignore_pattern');\n        $ignore_check     = !($ignore_pattern) || preg_match(\"/(\" . $ignore_pattern . \")/i\", $file) === 0;\n        $playlist_pattern = \"/\\.(\" . AmpConfig::get('catalog_playlist_pattern') . \")$/i\";\n\n        return ($ignore_check && preg_match($playlist_pattern, $file));\n    }\n\n    /**\n     * Get catalog info from table.\n     * @param integer $object_id\n     * @param string $table_name\n     * @return array\n     */\n    public function get_info($object_id, $table_name = 'catalog')\n    {\n        $info = parent::get_info($object_id, $table_name);\n\n        $table      = 'catalog_' . $this->get_type();\n        $sql        = \"SELECT `id` FROM `$table` WHERE `catalog_id` = ?\";\n        $db_results = Dba::read($sql, array($object_id));\n\n        if ($results = Dba::fetch_assoc($db_results)) {\n            $info_type = parent::get_info($results['id'], $table);\n            foreach ($info_type as $key => $value) {\n                if (!array_key_exists($key, $info) || !$info[$key]) {\n                    $info[$key] = $value;\n                }\n            }\n        }\n\n        return $info;\n    }\n\n    /**\n     * Get enable sql filter;\n     * @param string $type\n     * @param string $catalog_id\n     * @return string\n     */\n    public static function get_enable_filter($type, $catalog_id)\n    {\n        $sql = \"\";\n        if ($type == \"song\" || $type == \"album\" || $type == \"artist\") {\n            if ($type == \"song\") {\n                $type = \"id\";\n            }\n            $sql = \"(SELECT COUNT(`song_dis`.`id`) FROM `song` AS `song_dis` LEFT JOIN `catalog` AS `catalog_dis` ON `catalog_dis`.`id` = `song_dis`.`catalog` WHERE `song_dis`.`\" . $type . \"` = \" . $catalog_id . \" AND `catalog_dis`.`enabled` = '1' GROUP BY `song_dis`.`\" . $type . \"`) > 0\";\n        } elseif ($type == \"video\") {\n            $sql = \"(SELECT COUNT(`video_dis`.`id`) FROM `video` AS `video_dis` LEFT JOIN `catalog` AS `catalog_dis` ON `catalog_dis`.`id` = `video_dis`.`catalog` WHERE `video_dis`.`id` = \" . $catalog_id . \" AND `catalog_dis`.`enabled` = '1' GROUP BY `video_dis`.`id`) > 0\";\n        }\n\n        return $sql;\n    }\n\n    /**\n     * Get filter_user sql filter;\n     * @param string $type\n     * @param integer $user_id\n     * @return string\n     */\n    public static function get_user_filter($type, $user_id)\n    {\n        switch ($type) {\n            case \"album\":\n            case \"song\":\n            case \"video\":\n            case \"podcast\":\n            case \"podcast_episode\":\n            case \"live_stream\":\n            case \"artist\":\n                $sql = \" `$type`.`id` IN (SELECT `object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            case \"song_artist\":\n            case \"song_album\":\n                $type = str_replace('song_', '', (string) $type);\n                $sql  = \" `song`.`$type` IN (SELECT `object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            case \"album_artist\":\n                $sql  = \" `song`.`$type` IN (SELECT `object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            case \"label\":\n                $sql = \" `label`.`id` IN (SELECT `label` FROM `label_asso` LEFT JOIN `artist` ON `label_asso`.`artist` = `artist`.`id` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'artist'  AND `catalog_map`.`object_id` = `artist`.`id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = 'artist' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1) GROUP BY `label_asso`.`label`) \";\n                break;\n            case \"playlist\":\n                $sql = \" `playlist`.`id` IN (SELECT `playlist` FROM `playlist_data` LEFT JOIN `song` ON `playlist_data`.`object_id` = `song`.`id` AND `playlist_data`.`object_type` = 'song' LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'song'  AND `catalog_map`.`object_id` = `song`.`id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = 'song' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `playlist_data`.`playlist`) \";\n                break;\n            case \"share\":\n                $sql = \" `share`.`object_id` IN (SELECT `share`.`object_id` FROM `share` LEFT JOIN `catalog_map` ON `share`.`object_type` = `catalog_map`.`object_type` AND `share`.`object_id` = `catalog_map`.`object_id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)   GROUP BY `share`.`object_id`, `share`.`object_type`) \";\n                break;\n            case \"tag\":\n                $sql = \" `tag`.`id` IN (SELECT `tag_id` FROM `tag_map` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = `tag_map`.`object_type` AND `catalog_map`.`object_id` = `tag_map`.`object_id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `tag_map`.`tag_id`) \";\n                break;\n            case 'tvshow':\n                $sql = \" `tvshow`.`id` IN (SELECT `tvshow` FROM `tvshow_season` LEFT JOIN `tvshow_episode` ON `tvshow_episode`.`season` = `tvshow_season`.`id` LEFT JOIN `video` ON `tvshow_episode`.`id` = `video`.`id` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'video' AND `catalog_map`.`object_id` = `video`.`id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `tvshow_season`.`tvshow`) \";\n                break;\n            case 'tvshow_season':\n                $sql = \" `tvshow_season`.`tvshow` IN (SELECT `season` FROM `tvshow_episode` LEFT JOIN `video` ON `tvshow_episode`.`id` = `video`.`id` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'video' AND `catalog_map`.`object_id` = `video`.`id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1) GROUP BY `tvshow_episode`.`season`) \";\n                break;\n            case 'tvshow_episode':\n            case 'movie':\n            case 'personal_video':\n            case 'clip':\n                $sql = \" `$type`.`id` IN (SELECT `video`.`id` FROM `video` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'video' AND `catalog_map`.`object_id` = `video`.`id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `video`.`id`) \";\n                break;\n            // enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode')\n            case \"object_count_artist\":\n            case \"object_count_album\":\n            case \"object_count_song\":\n            case \"object_count_playlist\":\n            case \"object_count_genre\":\n            case \"object_count_catalog\":\n            case \"object_count_live_stream\":\n            case \"object_count_video\":\n            case \"object_count_podcast\":\n            case \"object_count_podcast_episode\":\n                $type = str_replace('object_count_', '', (string) $type);\n                $sql  = \" `object_count`.`object_id` IN (SELECT `catalog_map`.`object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            // enum('artist','album','song','stream','live_stream','video','playlist','tvshow','tvshow_season','podcast','podcast_episode')\n            case \"rating_artist\":\n            case \"rating_album\":\n            case \"rating_song\":\n            case \"rating_stream\":\n            case \"rating_live_stream\":\n            case \"rating_video\":\n            case \"rating_tvshow\":\n            case \"rating_tvshow_season\":\n            case \"rating_podcast\":\n            case \"rating_podcast_episode\":\n                $type = str_replace('rating_', '', (string) $type);\n                $sql  = \" `rating`.`object_id` IN (SELECT `catalog_map`.`object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            case \"user_flag_artist\":\n            case \"user_flag_album\":\n            case \"user_flag_song\":\n            case \"user_flag_video\":\n            case \"user_flag_podcast_episode\":\n                $type = str_replace('user_flag_', '', (string) $type);\n                $sql  = \" `user_flag`.`object_id` IN (SELECT `catalog_map`.`object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            case \"rating_playlist\":\n                $sql  = \" `rating`.`object_id` IN (SELECT DISTINCT(`playlist`.`id`) FROM `playlist` LEFT JOIN `playlist_data` ON `playlist_data`.`playlist` = `playlist`.`id` LEFT JOIN `catalog_map` ON `playlist_data`.`object_id` = `catalog_map`.`object_id` AND `playlist_data`.`object_type` = 'song' LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `playlist`.`id`) \";\n                break;\n            case \"user_flag_playlist\":\n                $sql  = \" `user_flag`.`object_id` IN (SELECT DISTINCT(`playlist`.`id`) FROM `playlist` LEFT JOIN `playlist_data` ON `playlist_data`.`playlist` = `playlist`.`id` LEFT JOIN `catalog_map` ON `playlist_data`.`object_id` = `catalog_map`.`object_id` AND `playlist_data`.`object_type` = 'song' LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `playlist`.`id`) \";\n                break;\n            case \"catalog\":\n                $sql = \" `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  \";\n                break;\n            default:\n                $sql = \"\";\n        }\n\n        return $sql;\n    }\n\n    /**\n     * _create_filecache\n     *\n     * This populates an array which is used to speed up the add process.\n     * @return boolean\n     */\n    protected function _create_filecache()\n    {\n        if (count($this->_filecache) == 0) {\n            // Get _EVERYTHING_\n            $sql        = 'SELECT `id`, `file` FROM `song` WHERE `catalog` = ?';\n            $db_results = Dba::read($sql, array($this->id));\n\n            // Populate the filecache\n            while ($results = Dba::fetch_assoc($db_results)) {\n                $this->_filecache[strtolower((string)$results['file'])] = $results['id'];\n            }\n\n            $sql        = 'SELECT `id`, `file` FROM `video` WHERE `catalog` = ?';\n            $db_results = Dba::read($sql, array($this->id));\n\n            while ($results = Dba::fetch_assoc($db_results)) {\n                $this->_filecache[strtolower((string)$results['file'])] = 'v_' . $results['id'];\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * get_update_info\n     *\n     * return the counts from update info to speed up responses\n     * @param string $key\n     * @return int\n     */\n    public static function get_update_info(string $key)\n    {\n        if ($key == 'joined') {\n            $sql        = \"SELECT 'playlist' AS `key`, SUM(value) AS `value` FROM `update_info` WHERE `key` IN ('playlist', 'search')\";\n            $db_results = Dba::read($sql);\n        } else {\n            $sql        = \"SELECT `key`, `value` FROM `update_info` WHERE `key` = ?\";\n            $db_results = Dba::read($sql, array($key));\n        }\n        $results = Dba::fetch_assoc($db_results);\n\n        return (int)($results['value'] ?? 0);\n    } // get_update_info\n\n    /**\n     * set_update_info\n     *\n     * write the total_counts to update_info\n     * @param string $key\n     * @param int $value\n     */\n    public static function set_update_info(string $key, int $value)\n    {\n        Dba::write(\"REPLACE INTO `update_info` SET `key` = ?, `value` = ?;\", array($key, $value));\n    } // set_update_info\n\n    /**\n     * update_enabled\n     * sets the enabled flag\n     * @param bool $new_enabled\n     * @param integer $catalog_id\n     */\n    public static function update_enabled($new_enabled, $catalog_id)\n    {\n        self::_update_item('enabled', (int)$new_enabled, $catalog_id, '75');\n    } // update_enabled\n\n    /**\n     * _update_item\n     * This is a private function that should only be called from within the catalog class.\n     * It takes a field, value, catalog id and level. first and foremost it checks the level\n     * against Core::get_global('user') to make sure they are allowed to update this record\n     * it then updates it and sets $this->{$field} to the new value\n     * @param string $field\n     * @param boolean $value\n     * @param integer $catalog_id\n     * @param integer $level\n     * @return PDOStatement|boolean\n     */\n    private static function _update_item($field, $value, $catalog_id, $level)\n    {\n        /* Check them Rights! */\n        if (!Access::check('interface', $level)) {\n            return false;\n        }\n\n        /* Can't update to blank */\n        if (!strlen(trim((string)$value))) {\n            return false;\n        }\n        $sql = \"UPDATE `catalog` SET `$field` = ? WHERE `id` = ?\";\n\n        return Dba::write($sql, array($value, $catalog_id));\n    } // _update_item\n\n    /**\n     * format\n     *\n     * This makes the object human-readable.\n     */\n    public function format()\n    {\n        $this->f_name        = scrub_out($this->name);\n        $this->link          = AmpConfig::get('web_path') . '/admin/catalog.php?action=show_customize_catalog&catalog_id=' . $this->id;\n        $this->f_link        = '<a href=\"' . $this->link . '\" title=\"' . $this->f_name . '\">' . $this->f_name . '</a>';\n        $this->f_update      = $this->last_update ? get_datetime((int)$this->last_update) : T_('Never');\n        $this->f_add         = $this->last_add ? get_datetime((int)$this->last_add) : T_('Never');\n        $this->f_clean       = $this->last_clean ? get_datetime((int)$this->last_clean) : T_('Never');\n    }\n\n    /**\n     * get_catalogs\n     *\n     * Pull all the current catalogs and return an array of ids\n     * of what you find\n     * @param string $filter_type\n     * @param int $user_id\n     * @return integer[]\n     */\n    public static function get_catalogs($filter_type = '', $user_id = null)\n    {\n        $params = array();\n        $sql    = \"SELECT `id` FROM `catalog` \";\n        $join   = 'WHERE';\n        if (!empty($filter_type)) {\n            $sql .= \"$join `gather_types` = ? \";\n            $params[] = $filter_type;\n            $join     = 'AND';\n        }\n        if (AmpConfig::get('catalog_filter') && $user_id > 0) {\n            $sql .= $join . self::get_user_filter('catalog', $user_id);\n        }\n        $sql .= \"ORDER BY `name`\";\n        $db_results = Dba::read($sql, $params);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * Run the cache_catalog_proc() on music catalogs.\n     */\n    public static function cache_catalogs()\n    {\n        $target = AmpConfig::get('cache_target');\n        $path   = (string)AmpConfig::get('cache_path', '');\n        // need a destination and target filetype\n        if (is_dir($path) && $target) {\n            $catalogs = self::get_catalogs('music');\n            foreach ($catalogs as $catalogid) {\n                debug_event(__CLASS__, 'cache_catalogs: ' . $catalogid, 5);\n                $catalog = self::create_from_id($catalogid);\n                $catalog->cache_catalog_proc();\n            }\n            $catalog_dirs  = new RecursiveDirectoryIterator($path);\n            $dir_files     = new RecursiveIteratorIterator($catalog_dirs);\n            $cache_files   = new RegexIterator($dir_files, \"/\\.$target$/i\");\n            debug_event(__CLASS__, 'cache_catalogs: cleaning old files', 5);\n            foreach ($cache_files as $file) {\n                $path    = pathinfo($file);\n                $song_id = $path['filename'];\n                if (!Song::has_id($song_id)) {\n                    unlink($file);\n                    debug_event(__CLASS__, 'cache_catalogs: removed {' . $file . '}', 4);\n                }\n            }\n        }\n    }\n\n    /**\n     * Get last catalogs update.\n     * @param integer[]|null $catalogs\n     * @return integer\n     */\n    public static function getLastUpdate($catalogs = null)\n    {\n        $last_update = 0;\n        if ($catalogs == null || !is_array($catalogs)) {\n            $catalogs = self::get_catalogs();\n        }\n        foreach ($catalogs as $catalogid) {\n            $catalog = self::create_from_id($catalogid);\n            if ($catalog->last_add > $last_update) {\n                $last_update = $catalog->last_add;\n            }\n            if ($catalog->last_update > $last_update) {\n                $last_update = $catalog->last_update;\n            }\n            if ($catalog->last_clean > $last_update) {\n                $last_update = $catalog->last_clean;\n            }\n        }\n\n        return $last_update;\n    }\n\n    /**\n     * get_stats\n     *\n     * This returns an hash with the #'s for the different\n     * objects that are associated with this catalog. This is used\n     * to build the stats box, it also calculates time.\n     * @param integer|null $catalog_id\n     * @return array\n     */\n    public static function get_stats($catalog_id = null)\n    {\n        $counts         = ($catalog_id) ? self::count_catalog($catalog_id) : self::get_server_counts(0);\n        $counts         = array_merge(User::count(), $counts);\n        $counts['tags'] = self::count_tags();\n\n        $counts['formatted_size'] = Ui::format_bytes($counts['size']);\n\n        $hours = floor($counts['time'] / 3600);\n        $days  = floor($hours / 24);\n        $hours = $hours % 24;\n\n        $time_text = \"$days \";\n        $time_text .= nT_('day', 'days', $days);\n        $time_text .= \", $hours \";\n        $time_text .= nT_('hour', 'hours', $hours);\n\n        $counts['time_text'] = $time_text;\n\n        return $counts;\n    }\n\n    /**\n     * create\n     *\n     * This creates a new catalog entry and associate it to current instance\n     * @param array $data\n     * @return integer\n     */\n    public static function create($data)\n    {\n        $name           = $data['name'];\n        $type           = $data['type'];\n        $rename_pattern = $data['rename_pattern'];\n        $sort_pattern   = $data['sort_pattern'];\n        $gather_types   = $data['gather_media'];\n\n        // Should it be an array? Not now.\n        if (!in_array($gather_types,\n            array('music', 'clip', 'tvshow', 'movie', 'personal_video', 'podcast'))) {\n            return 0;\n        }\n\n        $insert_id = 0;\n\n        $classname = self::CATALOG_TYPES[$type] ?? null;\n\n        if ($classname === null) {\n            return $insert_id;\n        }\n\n        $sql = 'INSERT INTO `catalog` (`name`, `catalog_type`, ' . '`rename_pattern`, `sort_pattern`, `gather_types`) VALUES (?, ?, ?, ?, ?)';\n        Dba::write($sql, array(\n            $name,\n            $type,\n            $rename_pattern,\n            $sort_pattern,\n            $gather_types\n        ));\n\n        $insert_id = Dba::insert_id();\n\n        if (!$insert_id) {\n            AmpError::add('general', T_('Failed to create the catalog, check the debug logs'));\n            debug_event(__CLASS__, 'Insert failed: ' . json_encode($data), 2);\n\n            return 0;\n        }\n\n        /** @var Catalog $classname */\n        if (!$classname::create_type($insert_id, $data)) {\n            $sql = 'DELETE FROM `catalog` WHERE `id` = ?';\n            Dba::write($sql, array($insert_id));\n            $insert_id = 0;\n        }\n\n        return (int)$insert_id;\n    }\n\n    /**\n     * count_tags\n     *\n     * This returns the current number of unique tags in the database.\n     * @return integer\n     */\n    public static function count_tags()\n    {\n        // FIXME: Ignores catalog_id\n        $sql        = \"SELECT COUNT(`id`) FROM `tag`\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_row($db_results);\n        if (empty($row)) {\n            return 0;\n        }\n\n        return $row[0];\n    }\n\n    /**\n     * has_access\n     *\n     * When filtering catalogs you shouldn't be able to play the files\n     * @param int $catalog_id\n     * @param int $user_id\n     * @return bool\n     */\n    public static function has_access($catalog_id, $user_id)\n    {\n        if (!AmpConfig::get('catalog_filter')) {\n            return true;\n        }\n        $params = array($catalog_id, $user_id);\n        $sql    = \"SELECT `catalog_id` FROM `catalog_filter_group_map` WHERE `catalog_id` = ? AND `group_id` IN (SELECT `catalog_filter_group` FROM `user` WHERE `id` = ?);\";\n\n        $db_results = Dba::read($sql, $params);\n        if (Dba::num_rows($db_results)) {\n            return true;\n        }\n\n        return false;\n    } // has_access\n\n    /**\n     * get_server_counts\n     *\n     * This returns the current number of songs, videos, albums, artists, items, etc across all catalogs on the server\n     * @param int $user_id\n     * @return array\n     */\n    public static function get_server_counts($user_id)\n    {\n        $results = array();\n        if ($user_id > 0) {\n            $sql        = \"SELECT `key`, `value` FROM `user_data` WHERE `user` = ?;\";\n            $db_results = Dba::read($sql, array($user_id));\n        } else {\n            $sql        = \"SELECT `key`, `value` FROM `update_info`;\";\n            $db_results = Dba::read($sql);\n        }\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['key']] = (int)$row['value'];\n        }\n\n        return $results;\n    } // get_server_counts\n\n    /**\n     * count_table\n     *\n     * Update a specific table count when adding/removing from the server\n     * @param string $table\n     * @return array\n     */\n    public static function count_table($table)\n    {\n        $sql        = \"SELECT COUNT(`id`) FROM `$table`\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_row($db_results);\n        if (empty($row)) {\n            return array();\n        }\n        self::set_update_info($table, (int)$row[0]);\n\n        return $row;\n    } // count_table\n\n    /**\n     * count_catalog\n     *\n     * This returns the current number of songs, videos, podcast_episodes in this catalog.\n     * @param integer $catalog_id\n     * @return array\n     */\n    public static function count_catalog($catalog_id)\n    {\n        $where_sql = $catalog_id ? 'WHERE `catalog` = ?' : '';\n        $params    = $catalog_id ? array($catalog_id) : array();\n        $results   = array();\n        $catalog   = self::create_from_id($catalog_id);\n\n        if ($catalog->id) {\n            $table = self::get_table_from_type($catalog->gather_types);\n            if ($table == 'podcast_episode' && $catalog_id) {\n                $where_sql = \"WHERE `podcast` IN (SELECT `id` FROM `podcast` WHERE `catalog` = ?)\";\n            }\n            $sql              = \"SELECT COUNT(`id`), IFNULL(SUM(`time`), 0), IFNULL(SUM(`size`), 0) FROM `\" . $table . \"` \" . $where_sql;\n            $db_results       = Dba::read($sql, $params);\n            $row              = Dba::fetch_row($db_results);\n            $results['items'] = ($row[0] ?? 0);\n            $results['time']  = ($row[1] ?? 0);\n            $results['size']  = ($row[2] ?? 0);\n        }\n\n        return $results;\n    } // count_catalog\n\n    /**\n     * get_uploads_sql\n     *\n     * @param string $type\n     * @param integer|null $user_id\n     * @return string\n     */\n    public static function get_uploads_sql($type, $user_id = null)\n    {\n        if ($user_id === null) {\n            $user    = Core::get_global('user');\n            $user_id = $user->id ?? 0;\n        }\n\n        switch ($type) {\n            case 'song':\n                $sql = \"SELECT `song`.`id` AS `id` FROM `song` WHERE `song`.`user_upload` = '\" . $user_id . \"'\";\n                break;\n            case 'album':\n                $sql = \"SELECT `album`.`id` AS `id` FROM `album` JOIN `song` ON `song`.`album` = `album`.`id` WHERE `song`.`user_upload` = '\" . $user_id . \"' GROUP BY `album`.`id`\";\n                break;\n            case 'artist':\n            default:\n                $sql = \"SELECT `artist`.`id` AS `id` FROM `artist` JOIN `song` ON `song`.`artist` = `artist`.`id` WHERE `song`.`user_upload` = '\" . $user_id . \"' GROUP BY `artist`.`id`\";\n                break;\n        }\n\n        return $sql;\n    } // get_uploads_sql\n\n    /**\n     * get_album_ids\n     *\n     * This returns an array of ids of albums that have songs in this\n     * catalog's\n     * @param string $filter\n     * @return integer[]\n     */\n    public function get_album_ids($filter = '')\n    {\n        $results = array();\n\n        $sql = 'SELECT `album`.`id` FROM `album` WHERE `album`.`catalog` = ?';\n        if ($filter === 'art') {\n            $sql = \"SELECT `album`.`id` FROM `album` LEFT JOIN `image` ON `album`.`id` = `image`.`object_id` AND `object_type` = 'album' WHERE `album`.`catalog` = ? AND `image`.`object_id` IS NULL\";\n        }\n        $db_results = Dba::read($sql, array($this->id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return array_reverse($results);\n    }\n\n    /**\n     * get_video_ids\n     *\n     * This returns an array of ids of videos in this catalog\n     * @param string $type\n     * @return integer[]\n     */\n    public function get_video_ids($type = '')\n    {\n        $results = array();\n\n        $sql = 'SELECT DISTINCT(`video`.`id`) AS `id` FROM `video` ';\n        if (!empty($type)) {\n            $sql .= 'JOIN `' . $type . '` ON `' . $type . '`.`id` = `video`.`id`';\n        }\n        $sql .= 'WHERE `video`.`catalog` = ?';\n        $db_results = Dba::read($sql, array($this->id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     *\n     * @param integer[]|null $catalogs\n     * @param string $type\n     * @return Video[]\n     */\n    public static function get_videos($catalogs = null, $type = '')\n    {\n        if (!$catalogs) {\n            $catalogs = self::get_catalogs();\n        }\n\n        $results = array();\n        foreach ($catalogs as $catalog_id) {\n            $catalog   = self::create_from_id($catalog_id);\n            $video_ids = $catalog->get_video_ids($type);\n            foreach ($video_ids as $video_id) {\n                $results[] = Video::create_from_id($video_id);\n            }\n        }\n\n        return $results;\n    }\n\n    /**\n     *\n     * @param integer|null $catalog_id\n     * @param string $type\n     * @return integer\n     */\n    public static function get_videos_count($catalog_id = null, $type = '')\n    {\n        $sql = \"SELECT COUNT(`video`.`id`) AS `video_cnt` FROM `video` \";\n        if (!empty($type)) {\n            $sql .= \"JOIN `\" . $type . \"` ON `\" . $type . \"`.`id` = `video`.`id` \";\n        }\n        if ($catalog_id) {\n            $sql .= \"WHERE `video`.`catalog` = `\" . (string)($catalog_id) . \"`\";\n        }\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_row($db_results);\n        if (empty($row)) {\n            return 0;\n        }\n\n        return $row[0];\n    }\n\n    /**\n     * get_tvshow_ids\n     *\n     * This returns an array of ids of tvshows in this catalog\n     * @return integer[]\n     */\n    public function get_tvshow_ids()\n    {\n        $results = array();\n\n        $sql = 'SELECT DISTINCT(`tvshow`.`id`) AS `id` FROM `tvshow` ';\n        $sql .= 'JOIN `tvshow_season` ON `tvshow_season`.`tvshow` = `tvshow`.`id` ';\n        $sql .= 'JOIN `tvshow_episode` ON `tvshow_episode`.`season` = `tvshow_season`.`id` ';\n        $sql .= 'JOIN `video` ON `video`.`id` = `tvshow_episode`.`id` ';\n        $sql .= 'WHERE `video`.`catalog` = ?';\n\n        $db_results = Dba::read($sql, array($this->id));\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_tvshows\n     * @param integer[]|null $catalogs\n     * @return TvShow[]\n     */\n    public static function get_tvshows($catalogs = null)\n    {\n        if (!$catalogs) {\n            $catalogs = self::get_catalogs();\n        }\n\n        $results = array();\n        foreach ($catalogs as $catalog_id) {\n            $catalog    = self::create_from_id($catalog_id);\n            $tvshow_ids = $catalog->get_tvshow_ids();\n            foreach ($tvshow_ids as $tvshow_id) {\n                $results[] = new TvShow($tvshow_id);\n            }\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_artist_arrays\n     *\n     * Get each array of [id, f_name, name, album_count, catalog_id, has_art] for artists in an array of catalog id's\n     * @param array $catalogs\n     * @return array\n     */\n    public static function get_artist_arrays($catalogs)\n    {\n        $sql  = (count($catalogs) == 1)\n            ? \"SELECT DISTINCT `artist`.`id`, LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) AS `f_name`, `artist`.`name`, `artist`.`album_count`, `catalog_map`.`catalog_id` AS `catalog_id`, `image`.`object_id` AS `has_art` FROM `artist` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'artist' AND `catalog_map`.`object_id` = `artist`.`id` AND `catalog_map`.`catalog_id` = \" . (int)$catalogs[0] . \" LEFT JOIN `image` ON `image`.`object_type` = 'artist' AND `image`.`object_id` = `artist`.`id` AND `image`.`size` = 'original' WHERE `catalog_map`.`catalog_id` IS NOT NULL ORDER BY `f_name`;\"\n            : \"SELECT DISTINCT `artist`.`id`, LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) AS `f_name`, `artist`.`name`, `artist`.`album_count`, MIN(`catalog_map`.`catalog_id`) AS `catalog_id`, `image`.`object_id` AS `has_art` FROM `artist` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'artist' AND `catalog_map`.`object_id` = `artist`.`id` AND `catalog_map`.`catalog_id` IN (\" . Dba::escape(implode(',', $catalogs)) . \") LEFT JOIN `image` ON `image`.`object_type` = 'artist' AND `image`.`object_id` = `artist`.`id` AND `image`.`size` = 'original' WHERE `catalog_map`.`catalog_id` IS NOT NULL GROUP BY `artist`.`id`, `f_name`, `artist`.`name`, `artist`.`album_count`, `image`.`object_id` ORDER BY `f_name`;\";\n\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results, false)) {\n            $results[] = $row;\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_artist_ids\n     *\n     * This returns an array of ids of artist that have songs in this catalog\n     * @param string $filter\n     * @return integer[]\n     */\n    public function get_artist_ids($filter = '')\n    {\n        $results = array();\n\n        $sql = 'SELECT DISTINCT(`song`.`artist`) AS `artist` FROM `song` WHERE `song`.`catalog` = ?';\n        if ($filter === 'art') {\n            $sql = \"SELECT DISTINCT(`song`.`artist`) AS `artist` FROM `song` LEFT JOIN `image` ON `song`.`artist` = `image`.`object_id` AND `object_type` = 'artist' WHERE `song`.`catalog` = ? AND `image`.`object_id` IS NULL\";\n        }\n        if ($filter === 'info') {\n            // used for recommendations / similar artists\n            $sql = \"SELECT DISTINCT(`artist`.`id`) AS `artist` FROM `artist` WHERE `artist`.`id` NOT IN (SELECT `object_id` FROM `recommendation` WHERE `object_type` = 'artist') ORDER BY RAND() LIMIT 500;\";\n        }\n        if ($filter === 'time') {\n            // used checking musicbrainz and other plugins\n            $sql = \"SELECT DISTINCT(`artist`.`id`) AS `artist` FROM `artist` WHERE (`artist`.`last_update` < (UNIX_TIMESTAMP() - 2629800) AND `artist`.`mbid` LIKE '%-%-%-%-%') ORDER BY RAND();\";\n        }\n        if ($filter === 'count') {\n            // Update for things added in the last run or empty ones\n            $sql = \"SELECT DISTINCT(`artist`.`id`) AS `artist` FROM `artist` WHERE `artist`.`id` IN (SELECT DISTINCT `song`.`artist` FROM `song` WHERE `song`.`catalog` = ? AND `addition_time` > \" . $this->last_add . \") OR (`album_count` = 0 AND `song_count` = 0) \";\n        }\n        $db_results = Dba::read($sql, array($this->id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int) $row['artist'];\n        }\n\n        return array_reverse($results);\n    }\n\n    /**\n     * get_artists\n     *\n     * This returns an array of artists that have songs in the catalogs parameter\n     * @param array|null $catalogs\n     * @param integer $size\n     * @param integer $offset\n     * @return Artist[]\n     */\n    public static function get_artists($catalogs = null, $size = 0, $offset = 0)\n    {\n        $sql_where = \"\";\n        if (is_array($catalogs) && count($catalogs)) {\n            $catlist   = '(' . implode(',', $catalogs) . ')';\n            $sql_where = \"WHERE `song`.`catalog` IN $catlist\";\n        }\n\n        $sql_limit = \"\";\n        if ($offset > 0 && $size > 0) {\n            $sql_limit = \"LIMIT \" . $offset . \", \" . $size;\n        } elseif ($size > 0) {\n            $sql_limit = \"LIMIT \" . $size;\n        } elseif ($offset > 0) {\n            // MySQL doesn't have notation for last row, so we have to use the largest possible BIGINT value\n            // https://dev.mysql.com/doc/refman/5.0/en/select.html  // TODO mysql8 test\n            $sql_limit = \"LIMIT \" . $offset . \", 18446744073709551615\";\n        }\n        $album_type = (AmpConfig::get('album_group')) ? '`artist`.`album_group_count`' : '`artist`.`album_count`';\n\n        $sql = \"SELECT `artist`.`id`, `artist`.`name`, `artist`.`prefix`, `artist`.`summary`, $album_type AS `albums` FROM `song` LEFT JOIN `artist` ON `artist`.`id` = `song`.`artist` $sql_where GROUP BY `artist`.`id`, `artist`.`name`, `artist`.`prefix`, `artist`.`summary`, `song`.`artist`, $album_type ORDER BY `artist`.`name` \" . $sql_limit;\n\n        $results    = array();\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = Artist::construct_from_array($row);\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_catalog_map\n     *\n     * This returns an id of artist that have songs in this catalog\n     * @param string $object_type\n     * @param string $object_id\n     * @return integer\n     */\n    public static function get_catalog_map($object_type, $object_id)\n    {\n        $sql = \"SELECT MIN(`catalog_map`.`catalog_id`) AS `catalog_id` FROM `catalog_map` WHERE `object_type` = ? AND `object_id` = ?\";\n\n        $db_results = Dba::read($sql, array($object_type, $object_id));\n        if ($row = Dba::fetch_assoc($db_results)) {\n            return (int) $row['catalog_id'];\n        }\n\n        return 0;\n    }\n\n    /**\n     * get_id_from_file\n     *\n     * Get media id from the file path.\n     *\n     * @param string $file_path\n     * @param string $media_type\n     * @return integer\n     */\n    public static function get_id_from_file($file_path, $media_type)\n    {\n        $sql        = \"SELECT `id` FROM `$media_type` WHERE `file` = ?;\";\n        $db_results = Dba::read($sql, array($file_path));\n\n        if ($results = Dba::fetch_assoc($db_results)) {\n            return (int)$results['id'];\n        }\n\n        return 0;\n    }\n\n    /**\n     * get_label_ids\n     *\n     * This returns an array of ids of labels\n     * @param string $filter\n     * @return integer[]\n     */\n    public function get_label_ids($filter)\n    {\n        $results = array();\n\n        $sql        = 'SELECT `id` FROM `label` WHERE `category` = ? OR `mbid` IS NULL';\n        $db_results = Dba::read($sql, array($filter));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * @param string $name\n     * @param integer $catalog_id\n     * @return array\n     */\n    public static function search_childrens($name, $catalog_id = 0)\n    {\n        $search                    = array();\n        $search['type']            = \"artist\";\n        $search['rule_0_input']    = $name;\n        $search['rule_0_operator'] = 4;\n        $search['rule_0']          = \"name\";\n        if ($catalog_id > 0) {\n            $search['rule_1_input']    = $catalog_id;\n            $search['rule_1_operator'] = 0;\n            $search['rule_1']          = \"catalog\";\n        }\n        $artists = Search::run($search);\n\n        $childrens = array();\n        foreach ($artists as $artist_id) {\n            $childrens[] = array(\n                'object_type' => 'artist',\n                'object_id' => $artist_id\n            );\n        }\n\n        return $childrens;\n    }\n\n    /**\n     * get_albums\n     *\n     * Returns an array of ids of albums that have songs in the catalogs parameter\n     * @param integer $size\n     * @param integer $offset\n     * @param integer[]|null $catalogs\n     * @return integer[]\n     */\n    public static function get_albums($size = 0, $offset = 0, $catalogs = null)\n    {\n        $sql = \"SELECT `album`.`id` FROM `album` \";\n        if (is_array($catalogs) && count($catalogs)) {\n            $catlist = '(' . implode(',', $catalogs) . ')';\n            $sql     = \"SELECT `album`.`id` FROM `song` LEFT JOIN `album` ON `album`.`id` = `song`.`album` WHERE `song`.`catalog` IN $catlist \";\n        }\n\n        $sql_limit = \"\";\n        if ($offset > 0 && $size > 0) {\n            $sql_limit = \"LIMIT $offset, $size\";\n        } elseif ($size > 0) {\n            $sql_limit = \"LIMIT $size\";\n        } elseif ($offset > 0) {\n            // MySQL doesn't have notation for last row, so we have to use the largest possible BIGINT value\n            // https://dev.mysql.com/doc/refman/5.0/en/select.html\n            $sql_limit = \"LIMIT $offset, 18446744073709551615\";\n        }\n\n        $sql .= \"GROUP BY `album`.`id` ORDER BY `album`.`name` $sql_limit\";\n\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_albums_by_artist\n     *\n     * Returns an array of ids of albums that have songs in the catalogs parameter, grouped by artist\n     * @param integer $size\n     * @param integer $offset\n     * @param integer[]|null $catalogs\n     * @return integer[]\n     * @oaram int $offset\n     */\n    public static function get_albums_by_artist($size = 0, $offset = 0, $catalogs = null)\n    {\n        $sql       = \"SELECT `album`.`id` FROM `album` \";\n        $sql_where = \"\";\n        $sql_group = \"GROUP BY `album`.`id`, `artist`.`name`, `artist`.`id`, `album`.`name`, `album`.`mbid`\";\n        if (is_array($catalogs) && count($catalogs)) {\n            $catlist   = '(' . implode(',', $catalogs) . ')';\n            $sql       = \"SELECT `song`.`album` as 'id' FROM `song` LEFT JOIN `album` ON `album`.`id` = `song`.`album` \";\n            $sql_where = \"WHERE `song`.`catalog` IN $catlist\";\n            $sql_group = \"GROUP BY `song`.`album`, `artist`.`name`, `artist`.`id`, `album`.`name`, `album`.`mbid`\";\n        }\n\n        $sql_limit = \"\";\n        if ($offset > 0 && $size > 0) {\n            $sql_limit = \"LIMIT $offset, $size\";\n        } elseif ($size > 0) {\n            $sql_limit = \"LIMIT $size\";\n        } elseif ($offset > 0) {\n            // MySQL doesn't have notation for last row, so we have to use the largest possible BIGINT value\n            // https://dev.mysql.com/doc/refman/5.0/en/select.html  // TODO mysql8 test\n            $sql_limit = \"LIMIT $offset, 18446744073709551615\";\n        }\n\n        $sql .= \"LEFT JOIN `artist` ON `artist`.`id` = `album`.`album_artist` $sql_where $sql_group ORDER BY `artist`.`name`, `artist`.`id`, `album`.`name` $sql_limit\";\n\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_podcast_ids\n     *\n     * This returns an array of ids of podcasts in this catalog\n     * @return integer[]\n     */\n    public function get_podcast_ids()\n    {\n        $results = array();\n\n        $sql = 'SELECT `podcast`.`id` FROM `podcast` ';\n        $sql .= 'WHERE `podcast`.`catalog` = ?';\n        $db_results = Dba::read($sql, array($this->id));\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     *\n     * @param integer[]|null $catalogs\n     * @return Podcast[]\n     */\n    public static function get_podcasts($catalogs = null)\n    {\n        if (!$catalogs) {\n            $catalogs = self::get_catalogs('podcast');\n        }\n\n        $results = array();\n        foreach ($catalogs as $catalog_id) {\n            $catalog     = self::create_from_id($catalog_id);\n            $podcast_ids = $catalog->get_podcast_ids();\n            foreach ($podcast_ids as $podcast_id) {\n                $results[] = new Podcast($podcast_id);\n            }\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_newest_podcasts_ids\n     *\n     * This returns an array of ids of latest podcast episodes in this catalog\n     * @param integer $count\n     * @return integer[]\n     */\n    public function get_newest_podcasts_ids($count)\n    {\n        $results = array();\n\n        $sql = 'SELECT `podcast_episode`.`id` FROM `podcast_episode` INNER JOIN `podcast` ON `podcast`.`id` = `podcast_episode`.`podcast` WHERE `podcast`.`catalog` = ? ORDER BY `podcast_episode`.`pubdate` DESC';\n        if ($count > 0) {\n            $sql .= ' LIMIT ' . (string)$count;\n        }\n        $db_results = Dba::read($sql, array($this->id));\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     *\n     * @param integer $count\n     * @return Podcast_Episode[]\n     */\n    public static function get_newest_podcasts($count)\n    {\n        $catalogs = self::get_catalogs('podcast');\n        $results  = array();\n\n        foreach ($catalogs as $catalog_id) {\n            $catalog     = self::create_from_id($catalog_id);\n            $episode_ids = $catalog->get_newest_podcasts_ids($count);\n            foreach ($episode_ids as $episode_id) {\n                $results[] = new Podcast_Episode($episode_id);\n            }\n        }\n\n        return $results;\n    }\n\n    /**\n     * gather_art_item\n     * @param string $type\n     * @param integer $object_id\n     * @param boolean $db_art_first\n     * @param boolean $api\n     * @return boolean\n     */\n    public static function gather_art_item($type, $object_id, $db_art_first = false, $api = false)\n    {\n        // Should be more generic !\n        if ($type == 'video') {\n            $libitem = Video::create_from_id($object_id);\n        } else {\n            $class_name = ObjectTypeToClassNameMapper::map($type);\n            $libitem    = new $class_name($object_id);\n        }\n        $inserted = false;\n        $options  = array();\n        $libitem->format();\n        if ($libitem->id) {\n            // Only search on items with default art kind AS `default`.\n            if ($libitem->get_default_art_kind() == 'default') {\n                $keywords = $libitem->get_keywords();\n                $keyword  = '';\n                foreach ($keywords as $key => $word) {\n                    $options[$key] = $word['value'];\n                    if (array_key_exists('important', $word) && !empty($word['value'])) {\n                        $keyword .= ' ' . $word['value'];\n                    }\n                }\n                $options['keyword'] = $keyword;\n            }\n\n            $parent = $libitem->get_parent();\n            if (!empty($parent) && $type !== 'album') {\n                self::gather_art_item($parent['object_type'], $parent['object_id'], $db_art_first, $api);\n            }\n        }\n\n        $art = new Art($object_id, $type);\n        // don't search for art when you already have it\n        if ($art->has_db_info() && $db_art_first) {\n            debug_event(__CLASS__, \"gather_art_item $type: {{$object_id}} blocked\", 5);\n            $results = array();\n        } else {\n            debug_event(__CLASS__, \"gather_art_item $type: {{$object_id}} searching\", 4);\n\n            global $dic;\n            $results = $dic->get(ArtCollectorInterface::class)->collect(\n                $art,\n                $options\n            );\n        }\n\n        foreach ($results as $result) {\n            // Pull the string representation from the source\n            $image = Art::get_from_source($result, $type);\n            if (strlen((string)$image) > '5') {\n                $inserted = $art->insert($image, $result['mime']);\n                // If they've enabled resizing of images generate a thumbnail\n                if (AmpConfig::get('resize_images')) {\n                    $size  = array('width' => 275, 'height' => 275);\n                    $thumb = $art->generate_thumb($image, $size, $result['mime']);\n                    if (!empty($thumb)) {\n                        $art->save_thumb($thumb['thumb'], $thumb['thumb_mime'], $size);\n                    }\n                }\n                if ($inserted) {\n                    break;\n                }\n            } elseif ($result === true) {\n                debug_event(__CLASS__, 'Database already has image.', 3);\n            } else {\n                debug_event(__CLASS__, 'Image less than 5 chars, not inserting', 3);\n            }\n        }\n\n        if ($type == 'video' && AmpConfig::get('generate_video_preview')) {\n            Video::generate_preview($object_id);\n        }\n\n        if (Ui::check_ticker() && !$api) {\n            Ui::update_text('read_art_' . $object_id, $libitem->get_fullname());\n        }\n        if ($inserted) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * gather_art\n     *\n     * This runs through all of the albums and finds art for them\n     * This runs through all of the needs art albums and tries\n     * to find the art for them from the mp3s\n     * @param integer[]|null $songs\n     * @param integer[]|null $videos\n     * @return boolean\n     */\n    public function gather_art($songs = null, $videos = null)\n    {\n        // Make sure they've actually got methods\n        $art_order       = AmpConfig::get('art_order');\n        $gather_song_art = AmpConfig::get('gather_song_art', false);\n        $db_art_first    = ($art_order[0] == 'db');\n        if (!count($art_order)) {\n            debug_event(__CLASS__, 'art_order not set, self::gather_art aborting', 3);\n\n            return false;\n        }\n\n        // Prevent the script from timing out\n        set_time_limit(0);\n\n        $search_count = 0;\n        $searches     = array();\n        if ($songs == null) {\n            $searches['album']  = $this->get_album_ids('art');\n            $searches['artist'] = $this->get_artist_ids('art');\n            if ($gather_song_art) {\n                $searches['song'] = $this->get_song_ids();\n            }\n        } else {\n            $searches['album']  = array();\n            $searches['artist'] = array();\n            if ($gather_song_art) {\n                $searches['song'] = array();\n            }\n            foreach ($songs as $song_id) {\n                $song = new Song($song_id);\n                if ($song->id) {\n                    if (!in_array($song->album, $searches['album'])) {\n                        $searches['album'][] = $song->album;\n                    }\n                    if (!in_array($song->artist, $searches['artist'])) {\n                        $searches['artist'][] = $song->artist;\n                    }\n                    if ($gather_song_art) {\n                        $searches['song'][] = $song->id;\n                    }\n                }\n            }\n        }\n        if ($videos == null) {\n            $searches['video'] = $this->get_video_ids();\n        } else {\n            $searches['video'] = $videos;\n        }\n\n        debug_event(__CLASS__, 'gather_art found ' . (string) count($searches) . ' items missing art', 4);\n        // Run through items and get the art!\n        foreach ($searches as $key => $values) {\n            foreach ($values as $object_id) {\n                self::gather_art_item($key, $object_id, $db_art_first);\n\n                // Stupid little cutesie thing\n                $search_count++;\n                if (Ui::check_ticker()) {\n                    Ui::update_text('count_art_' . $this->id, $search_count);\n                }\n            }\n        }\n        // One last time for good measure\n        Ui::update_text('count_art_' . $this->id, $search_count);\n\n        return true;\n    }\n\n    /**\n     * gather_artist_info\n     *\n     * This runs through all of the artists and refreshes last.fm information\n     * including similar artists that exist in your catalog.\n     * @param array $artist_list\n     */\n    public function gather_artist_info($artist_list = array())\n    {\n        // Prevent the script from timing out\n        set_time_limit(0);\n\n        $search_count = 0;\n        debug_event(__CLASS__, 'gather_artist_info found ' . (string) count($artist_list) . ' items to check', 4);\n        // Run through items and refresh info\n        foreach ($artist_list as $object_id) {\n            Recommendation::get_artist_info($object_id);\n            Recommendation::get_artists_like($object_id);\n            Artist::set_last_update($object_id);\n            // get similar songs too\n            $artistSongs = static::getSongRepository()->getAllByArtist($object_id);\n            foreach ($artistSongs as $song_id) {\n                Recommendation::get_songs_like($song_id);\n            }\n\n            // Stupid little cutesie thing\n            $search_count++;\n            if (Ui::check_ticker()) {\n                Ui::update_text('count_artist_' . $object_id, $search_count);\n            }\n        }\n\n        // One last time for good measure\n        Ui::update_text('count_artist_complete', $search_count);\n    }\n\n    /**\n     * update_from_external\n     *\n     * This runs through all of the labels and refreshes information from musicbrainz\n     * @param array $object_list\n     * @param string $object_type\n     */\n    public function update_from_external($object_list, $object_type)\n    {\n        // Prevent the script from timing out\n        set_time_limit(0);\n\n        debug_event(__CLASS__, 'update_from_external found ' . (string) count($object_list) . ' ' . $object_type . '\\'s to check', 4);\n\n        // only allow your primary external metadata source to update values\n        $overwrites   = true;\n        $meta_order   = array_map('strtolower', static::getConfigContainer()->get(ConfigurationKeyEnum::METADATA_ORDER));\n        $plugin_list  = Plugin::get_plugins('get_external_metadata');\n        $user         = (!empty(Core::get_global('user')))\n            ? Core::get_global('user')\n            : new User(-1);\n        foreach ($meta_order as $plugin_name) {\n            if (in_array($plugin_name, $plugin_list)) {\n                // only load metadata plugins you enable\n                $plugin = new Plugin($plugin_name);\n                if ($plugin->load($user) && $overwrites) {\n                    debug_event(__CLASS__, \"get_external_metadata with: \" . $plugin_name, 3);\n                    // Run through items and refresh info\n                    switch ($object_type) {\n                        case 'label':\n                            foreach ($object_list as $label_id) {\n                                $label = new Label($label_id);\n                                $plugin->_plugin->get_external_metadata($label, 'label');\n                            }\n                            break;\n                        case 'artist':\n                            foreach ($object_list as $artist_id) {\n                                $artist = new Artist($artist_id);\n                                $plugin->_plugin->get_external_metadata($artist, 'artist');\n                            }\n                            $overwrites = false;\n                            break;\n                        default:\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * get_songs\n     *\n     * Returns an array of song objects.\n     * @return Song[]\n     */\n    public function get_songs()\n    {\n        $songs   = array();\n        $results = array();\n\n        $sql        = \"SELECT `id` FROM `song` WHERE `catalog` = ? AND `enabled` = '1' ORDER BY `album`\";\n        $db_results = Dba::read($sql, array($this->id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $songs[] = (int)$row['id'];\n        }\n\n        if (AmpConfig::get('memory_cache')) {\n            Song::build_cache($songs);\n        }\n\n        foreach ($songs as $song_id) {\n            $results[] = new Song($song_id);\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_song_ids\n     *\n     * Returns an array of song ids.\n     * @return integer[]\n     */\n    public function get_song_ids()\n    {\n        $songs = array();\n\n        $sql        = \"SELECT `id` FROM `song` WHERE `catalog` = ? AND `enabled` = '1'\";\n        $db_results = Dba::read($sql, array($this->id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $songs[] = (int)$row['id'];\n        }\n\n        return $songs;\n    }\n\n    /**\n     * update_last_update\n     * updates the last_update of the catalog\n     */\n    protected function update_last_update()\n    {\n        $date = time();\n        $sql  = \"UPDATE `catalog` SET `last_update` = ? WHERE `id` = ?\";\n        Dba::write($sql, array($date, $this->id));\n    } // update_last_update\n\n    /**\n     * update_last_add\n     * updates the last_add of the catalog\n     */\n    public function update_last_add()\n    {\n        $date = time();\n        $sql  = \"UPDATE `catalog` SET `last_add` = ? WHERE `id` = ?\";\n        Dba::write($sql, array($date, $this->id));\n    } // update_last_add\n\n    /**\n     * update_last_clean\n     * This updates the last clean information\n     */\n    public function update_last_clean()\n    {\n        $date = time();\n        $sql  = \"UPDATE `catalog` SET `last_clean` = ? WHERE `id` = ?\";\n        Dba::write($sql, array($date, $this->id));\n    } // update_last_clean\n\n    /**\n     * update_settings\n     * This function updates the basic setting of the catalog\n     * @param array $data\n     * @return boolean\n     */\n    public static function update_settings($data)\n    {\n        $sql    = \"UPDATE `catalog` SET `name` = ?, `rename_pattern` = ?, `sort_pattern` = ? WHERE `id` = ?\";\n        $params = array($data['name'], $data['rename_pattern'], $data['sort_pattern'], $data['catalog_id']);\n        Dba::write($sql, $params);\n\n        return true;\n    } // update_settings\n\n    /**\n     * update_single_item\n     * updates a single album,artist,song from the tag data and return the id. (if the artist/album changes it's updated)\n     * this can be done by 75+\n     * @param string $type\n     * @param integer $object_id\n     * @param boolean $api\n     * @return array\n     */\n    public static function update_single_item($type, $object_id, $api = false)\n    {\n        // Because single items are large numbers of things too\n        set_time_limit(0);\n\n        $songs   = array();\n        $result  = $object_id;\n        $libitem = 0;\n\n        switch ($type) {\n            case 'album':\n                $libitem = new Album($object_id);\n                $songs   = static::getSongRepository()->getByAlbum($object_id);\n                break;\n            case 'artist':\n                $libitem = new Artist($object_id);\n                $songs   = static::getSongRepository()->getAllByArtist($object_id);\n                break;\n            case 'song':\n                $songs[] = $object_id;\n                break;\n            case 'podcast_episode':\n                $episode = new Podcast_Episode($object_id);\n                self::update_media_from_tags($episode);\n\n                return array(\n                    'object_id' => $object_id,\n                    'change' => true\n                );\n        } // end switch type\n\n        if (!$api) {\n            echo '<table class=\"tabledata striped-rows\">' . \"\\n\";\n            echo '<thead><tr class=\"th-top\">' . \"\\n\";\n            echo \"<th>\" . T_(\"Song\") . \"</th><th>\" . T_(\"Status\") . \"</th>\\n\";\n            echo \"<tbody>\\n\";\n        }\n        $album  = false;\n        $artist = false;\n        $tags   = false;\n        $maps   = false;\n        foreach ($songs as $song_id) {\n            $song   = new Song($song_id);\n            $info   = self::update_media_from_tags($song);\n            $file   = scrub_out($song->file);\n            $diff   = array_key_exists('element', $info) && is_array($info['element']) && !empty($info['element']);\n            $album  = ($album == true) || ($diff && array_key_exists('album', $info['element']));\n            $artist = ($artist == true) || ($diff && array_key_exists('artist', $info['element']));\n            $tags   = ($tags == true) || ($diff && array_key_exists('tags', $info['element']));\n            $maps   = ($maps == true) || ($diff && array_key_exists('maps', $info));\n            // don't echo useless info when using api\n            if (array_key_exists('change', $info) && $info['change'] && (!$api)) {\n                if ($diff && array_key_exists($type, $info['element'])) {\n                    $element = explode(' --> ', (string)$info['element'][$type]);\n                    $result  = (int)$element[1];\n                }\n                echo \"<tr><td>\" . $file . \"</td><td>\" . T_('Updated') . \"</td></tr>\\n\";\n            } elseif (array_key_exists('error', $info) && $info['error'] && (!$api)) {\n                echo '<tr><td>' . $file . \"</td><td>\" . T_('Error') . \"</td></tr>\\n\";\n            } elseif (!$api) {\n                echo '<tr><td>' . $file . \"</td><td>\" . T_('No Update Needed') . \"</td></tr>\\n\";\n            }\n            flush();\n        } // foreach songs\n        if (!$api) {\n            echo \"</tbody></table>\\n\";\n        }\n        // Update the tags for parent items (Songs -> Albums -> Artist)\n        if ($libitem instanceof Album) {\n            $tags    = self::getSongTags('album', $libitem->id);\n            Tag::update_tag_list(implode(',', $tags), 'album', $libitem->id, true);\n            if ($artist || $album || $tags || $maps) {\n                $artists = array();\n                // update the album artists\n                foreach (Album::get_artist_map('album', $libitem->id) as $albumArtist_id) {\n                    $artists[] = $albumArtist_id;\n                    $tags      = self::getSongTags('artist', $albumArtist_id);\n                    Tag::update_tag_list(implode(',', $tags), 'artist', $albumArtist_id, true);\n                }\n                // update the song artists too\n                foreach (Album::get_artist_map('song', $libitem->id) as $songArtist_id) {\n                    if (!in_array($songArtist_id, $artists)) {\n                        $tags = self::getSongTags('artist', $songArtist_id);\n                        Tag::update_tag_list(implode(',', $tags), 'artist', $songArtist_id, true);\n                    }\n                }\n            }\n        }\n        // artist\n        if ($libitem instanceof Artist) {\n            // make sure albums are updated before the artist (include if you're just a song artist too)\n            foreach (static::getAlbumRepository()->getByArtist($object_id) as $album_id) {\n                $album_tags = self::getSongTags('album', $album_id);\n                Tag::update_tag_list(implode(',', $album_tags), 'album', $album_id, true);\n            }\n            // refresh the artist tags after everything else\n            $tags = self::getSongTags('artist', $libitem->id);\n            Tag::update_tag_list(implode(',', $tags), 'artist', $libitem->id, true);\n        }\n        // check counts\n        if ($album || $maps || $type == 'album') {\n            Album::update_album_counts();\n        }\n        if ($artist || $maps || $type == 'artist') {\n            Artist::update_artist_counts();\n        }\n        // collect the garbage too\n        if ($album || $artist || $maps) {\n            Artist::garbage_collection();\n            static::getAlbumRepository()->collectGarbage();\n        }\n\n        return array(\n            'object_id' => $result,\n            'change' => ($album || $artist || $maps || $tags)\n        );\n    } // update_single_item\n\n    /**\n     * update_media_from_tags\n     * This is a 'wrapper' function calls the update function for the media\n     * type in question\n     * @param Song|Video|Podcast_Episode $media\n     * @param array $gather_types\n     * @param string $sort_pattern\n     * @param string $rename_pattern\n     * @return array\n     */\n    public static function update_media_from_tags(\n        $media,\n        $gather_types = array('music'),\n        $sort_pattern = '',\n        $rename_pattern = ''\n    ) {\n        $array   = array();\n        $catalog = self::create_from_id($media->catalog);\n        if ($catalog === null) {\n            debug_event(__CLASS__, 'update_media_from_tags: Error loading catalog ' . $media->catalog, 2);\n            $array['error']  = true;\n\n            return $array;\n        }\n\n        //retrieve the file if needed\n        $media = $catalog->prepare_media($media);\n\n        if (Core::get_filesize(Core::conv_lc_file($media->file)) == 0) {\n            debug_event(__CLASS__, 'update_media_from_tags: Error loading file ' . $media->file, 2);\n            $array['error']  = true;\n\n            return $array;\n        }\n\n        $type      = ObjectTypeToClassNameMapper::reverseMap(get_class($media));\n        $functions = [\n            'song' => static function ($results, $media) {\n                return self::update_song_from_tags($results, $media);\n            },\n            'video' => static function ($results, $media) {\n                return self::update_video_from_tags($results, $media);\n            },\n            'podcast_episode' => static function ($results, $media) {\n                return self::update_podcast_episode_from_tags($results, $media);\n            },\n        ];\n\n        $callable = $functions[$type];\n\n        // try and get the tags from your file\n        debug_event(__CLASS__, 'Reading tags from ' . $media->file, 4);\n        $extension = strtolower(pathinfo($media->file, PATHINFO_EXTENSION));\n        $results   = $catalog->get_media_tags($media, $gather_types, $sort_pattern, $rename_pattern);\n        // for files without tags try to update from their file name instead\n        if ($media->id && in_array($extension, array('wav', 'shn'))) {\n            // match against your catalog 'Filename Pattern' and 'Folder Pattern'\n            $patres  = vainfo::parse_pattern($media->file, $catalog->sort_pattern, $catalog->rename_pattern);\n            $results = array_merge($results, $patres);\n        }\n        $update = $callable($results, $media);\n\n        // remote catalogs should unlink the temp files if needed //TODO add other types of remote catalog\n        if ($catalog instanceof Catalog_Seafile) {\n            $catalog->clean_tmp_file($media->file);\n        }\n\n        return $update;\n    } // update_media_from_tags\n\n    /**\n     * update_song_from_tags\n     * Updates the song info based on tags; this is called from a bunch of\n     * different places and passes in a full fledged song object, so it's a\n     * static function.\n     * FIXME: This is an ugly mess, this really needs to be consolidated and cleaned up.\n     * @param array $results\n     * @param Song $song\n     * @return array\n     * @throws ReflectionException\n     */\n    public static function update_song_from_tags($results, Song $song)\n    {\n        //debug_event(__CLASS__, \"update_song_from_tags results: \" . print_r($results, true), 4);\n        // info for the song table. This is all the primary file data that is song related\n        $new_song       = new Song();\n        $new_song->file = $results['file'];\n        $new_song->year = (strlen((string)$results['year']) > 4)\n            ? (int)substr($results['year'], -4, 4)\n            : (int)($results['year']);\n        $new_song->title   = self::check_length(self::check_title($results['title'], $new_song->file));\n        $new_song->bitrate = $results['bitrate'];\n        $new_song->rate    = $results['rate'];\n        $new_song->mode    = ($results['mode'] == 'cbr') ? 'cbr' : 'vbr';\n        $new_song->size    = $results['size'];\n        $new_song->time    = (strlen((string)$results['time']) > 5)\n            ? (int)substr($results['time'], -5, 5)\n            : (int)($results['time']);\n        if ($new_song->time < 0) {\n            // fall back to last time if you fail to scan correctly\n            $new_song->time = $song->time;\n        }\n        $new_song->track    = self::check_track((string)$results['track']);\n        $new_song->mbid     = $results['mb_trackid'];\n        $new_song->composer = self::check_length($results['composer']);\n        $new_song->mime     = $results['mime'];\n\n        // info for the song_data table. used in Song::update_song\n        $new_song->comment     = $results['comment'];\n        $new_song->lyrics      = str_replace(\n            [\"\\r\\n\", \"\\r\", \"\\n\"],\n            '<br />',\n            strip_tags($results['lyrics'])\n        );\n        if (isset($results['license'])) {\n            $licenseRepository = static::getLicenseRepository();\n            $licenseName       = (string) $results['license'];\n            $licenseId         = $licenseRepository->find($licenseName);\n\n            $new_song->license = $licenseId === 0 ? $licenseRepository->create($licenseName, '', '') : $licenseId;\n        } else {\n            $new_song->license = null;\n        }\n        $new_song->label = isset($results['publisher']) ? self::check_length($results['publisher'], 128) : null;\n        if ($song->label && AmpConfig::get('label')) {\n            // create the label if missing\n            foreach (array_map('trim', explode(';', $new_song->label)) as $label_name) {\n                Label::helper($label_name);\n            }\n        }\n        $new_song->language              = self::check_length($results['language'], 128);\n        $new_song->replaygain_track_gain = (!is_null($results['replaygain_track_gain'])) ? (float) $results['replaygain_track_gain'] : null;\n        $new_song->replaygain_track_peak = (!is_null($results['replaygain_track_peak'])) ? (float) $results['replaygain_track_peak'] : null;\n        $new_song->replaygain_album_gain = (!is_null($results['replaygain_album_gain'])) ? (float) $results['replaygain_album_gain'] : null;\n        $new_song->replaygain_album_peak = (!is_null($results['replaygain_album_peak'])) ? (float) $results['replaygain_album_peak'] : null;\n        $new_song->r128_track_gain       = (!is_null($results['r128_track_gain'])) ? (int) $results['r128_track_gain'] : null;\n        $new_song->r128_album_gain       = (!is_null($results['r128_album_gain'])) ? (int) $results['r128_album_gain'] : null;\n\n        // genre is used in the tag and tag_map tables\n        $tag_array = array();\n        if (!empty($results['genre'])) {\n            if (!is_array($results['genre'])) {\n                $results['genre'] = array($results['genre']);\n            }\n            // check if this thing has been renamed into something else\n            foreach ($results['genre'] as $tagName) {\n                $merged = Tag::construct_from_name($tagName);\n                if ($merged && $merged->is_hidden) {\n                    foreach ($merged->get_merged_tags() as $merged_tag) {\n                        $tag_array[] = $merged_tag['name'];\n                    }\n                } else {\n                    $tag_array[] = $tagName;\n                }\n            }\n        }\n        $new_song->tags = $tag_array;\n        $tags           = Tag::get_object_tags('song', $song->id);\n        if ($tags) {\n            foreach ($tags as $tag) {\n                $song->tags[] = $tag['name'];\n            }\n        }\n        // info for the artist table.\n        $artist           = self::check_length($results['artist']);\n        $artist_mbid      = $results['mb_artistid'];\n        $albumartist_mbid = $results['mb_albumartistid'];\n        // info for the album table.\n        $album      = self::check_length($results['album']);\n        $album_mbid = $results['mb_albumid'];\n        $disk       = $results['disk'];\n        // year is also included in album\n        $album_mbid_group = $results['mb_albumid_group'];\n        $release_type     = self::check_length($results['release_type'], 32);\n        $release_status   = $results['release_status'];\n        $albumartist      = self::check_length($results['albumartist']) ?? $song->get_album_artist_fullname();\n        $albumartist      = $albumartist ?? null;\n        $original_year    = $results['original_year'];\n        $barcode          = self::check_length($results['barcode'], 64);\n        $catalog_number   = self::check_length($results['catalog_number'], 64);\n        // info for the artist_map table.\n        $artists_array          = $results['artists'] ?? array();\n        $artist_mbid_array      = $results['mb_artistid_array'] ?? array();\n        $albumartist_mbid_array = $results['mb_albumartistid_array'] ?? array();\n        // if you have an artist array this will be named better than what your tags will give you\n        if (!empty($artists_array)) {\n            if (!empty($artist) && !empty($albumartist) && $artist == $albumartist) {\n                $albumartist = $artists_array[0];\n            }\n            $artist = $artists_array[0];\n        }\n        $is_upload_artist = false;\n        if ($song->artist) {\n            $is_upload_artist = Artist::is_upload($song->artist);\n            if ($is_upload_artist) {\n                debug_event(__CLASS__, \"$song->artist : is an uploaded song artist\", 4);\n                $artist_mbid_array = array();\n            }\n        }\n        $is_upload_albumartist = false;\n        if ($song->album) {\n            $is_upload_albumartist = Artist::is_upload($song->albumartist);\n            if ($is_upload_albumartist) {\n                debug_event(__CLASS__, \"$song->albumartist : is an uploaded album artist\", 4);\n                $albumartist_mbid_array = array();\n            }\n        }\n        // check whether this artist exists (and the album_artist)\n        $new_song->artist = ($is_upload_artist)\n            ? $song->artist\n            : Artist::check($artist, $artist_mbid);\n        if ($albumartist || !empty($song->albumartist)) {\n            $new_song->albumartist = ($is_upload_albumartist)\n                ? $song->albumartist\n                : Artist::check($albumartist, $albumartist_mbid);\n            if (!$new_song->albumartist) {\n                $new_song->albumartist = $song->albumartist;\n            }\n        }\n        if (!$new_song->artist) {\n            $new_song->artist = $song->artist;\n        }\n\n        // check whether this album exists\n        $new_song->album = ($is_upload_albumartist)\n            ? $song->album\n            : Album::check($song->catalog, $album, $new_song->year, $disk, $album_mbid, $album_mbid_group, $new_song->albumartist, $release_type, $release_status, $original_year, $barcode, $catalog_number);\n        if (!$new_song->album) {\n            $new_song->album = $song->album;\n        }\n\n        // get the artists / album_artists for this song\n        $songArtist_array  = array($new_song->artist);\n        $albumArtist_array = array($new_song->albumartist);\n        // artist_map stores song and album against the artist_id\n        $artist_map_song  = Artist::get_artist_map('song', $song->id);\n        $artist_map_album = Artist::get_artist_map('album', $new_song->album);\n        // album_map stores song_artist and album_artist against the album_id\n        $album_map_songArtist  = Album::get_artist_map('song', $new_song->album);\n        $album_map_albumArtist = Album::get_artist_map('album', $new_song->album);\n        // don't update counts unless something changes\n        $map_change = false;\n\n        // add song artists with a valid mbid to the list\n        if (!empty($artist_mbid_array)) {\n            foreach ($artist_mbid_array as $song_artist_mbid) {\n                $songArtist_id = Artist::check_mbid($song_artist_mbid);\n                if ($songArtist_id > 0 && !in_array($songArtist_id, $songArtist_array)) {\n                    $songArtist_array[] = $songArtist_id;\n                }\n            }\n        }\n        // add song artists found by name to the list (Ignore artist names when we have the same amount of MBID's)\n        if (!empty($artists_array) && count($artists_array) > count($artist_mbid_array)) {\n            foreach ($artists_array as $artist_name) {\n                $songArtist_id = Artist::check($artist_name);\n                if ($songArtist_id > 0 && !in_array($songArtist_id, $songArtist_array)) {\n                    $songArtist_array[] = $songArtist_id;\n                }\n            }\n        }\n        // map every song artist we've found\n        foreach ($songArtist_array as $songArtist_id) {\n            if (!in_array($songArtist_id, $artist_map_song)) {\n                $artist_map_song[] = (int)$songArtist_id;\n                Artist::add_artist_map($songArtist_id, 'song', $song->id);\n                if ($song->played) {\n                    Stats::duplicate_map('song', $song->id, 'artist', $songArtist_id);\n                }\n                $map_change = true;\n            }\n            if (!in_array($songArtist_id, $album_map_songArtist)) {\n                $album_map_songArtist[] = $songArtist_id;\n                Album::add_album_map($new_song->album, 'song', $songArtist_id);\n                if ($song->played) {\n                    Stats::duplicate_map('song', $song->id, 'artist', $songArtist_id);\n                }\n                $map_change = true;\n            }\n        }\n        // add album artists to the list\n        if (!empty($albumartist_mbid_array)) {\n            foreach ($albumartist_mbid_array as $album_artist_mbid) {\n                $albumArtist_id = Artist::check_mbid($album_artist_mbid);\n                if ($albumArtist_id > 0 && !in_array($albumArtist_id, $albumArtist_array)) {\n                    $albumArtist_array[] = $albumArtist_id;\n                }\n            }\n        }\n        // map every album artist we've found\n        foreach ($albumArtist_array as $albumArtist_id) {\n            if (!in_array($albumArtist_id, $artist_map_album)) {\n                $artist_map_album[] = $albumArtist_id;\n                Artist::add_artist_map($albumArtist_id, 'album', $new_song->album);\n                $map_change = true;\n            }\n            if (!in_array($albumArtist_id, $album_map_albumArtist)) {\n                $album_map_albumArtist[] = $albumArtist_id;\n                Album::add_album_map($new_song->album, 'album', $albumArtist_id);\n                $map_change = true;\n            }\n        }\n        // clean up the mapped things that are missing after the update\n        foreach ($artist_map_song as $existing_map) {\n            if (!in_array($existing_map, $songArtist_array)) {\n                Artist::remove_artist_map($existing_map, 'song', $song->id);\n                Album::check_album_map($song->album, 'song', $existing_map);\n                if ($song->played) {\n                    Stats::delete_map('song', $song->id, 'artist', $existing_map);\n                }\n                $map_change = true;\n            }\n        }\n        foreach ($artist_map_song as $existing_map) {\n            $not_found = !in_array($existing_map, $songArtist_array);\n            // remove album song map if song artist is changed OR album changes\n            if ($not_found || ($song->album != $new_song->album)) {\n                Album::check_album_map($song->album, 'song', $existing_map);\n                $map_change = true;\n            }\n            // only delete play count on song artist change\n            if ($not_found && $song->played) {\n                Stats::delete_map('song', $song->id, 'artist', $existing_map);\n                $map_change = true;\n            }\n        }\n        foreach ($artist_map_album as $existing_map) {\n            if (!in_array($existing_map, $albumArtist_array)) {\n                Artist::remove_artist_map($existing_map, 'album', $song->album);\n                Album::check_album_map($song->album, 'album', $existing_map);\n                $map_change = true;\n            }\n        }\n        foreach ($album_map_songArtist as $existing_map) {\n            // check song maps in the album_map table (because this is per song we need to check the whole album)\n            if (Album::check_album_map($song->album, 'song', $existing_map)) {\n                $map_change = true;\n            }\n        }\n        foreach ($album_map_albumArtist as $existing_map) {\n            if (!in_array($existing_map, $albumArtist_array)) {\n                Album::remove_album_map($song->album, 'album', $existing_map);\n                $map_change = true;\n            }\n        }\n\n        if ($artist_mbid) {\n            $new_song->artist_mbid = $artist_mbid;\n        }\n        if ($album_mbid) {\n            $new_song->album_mbid = $album_mbid;\n        }\n        if ($albumartist_mbid) {\n            $new_song->albumartist_mbid = $albumartist_mbid;\n        }\n\n        /* Since we're doing a full compare make sure we fill the extended information */\n        $song->fill_ext_info();\n\n        if (AmpConfig::get('enable_custom_metadata')) {\n            $ctags = self::get_clean_metadata($song, $results);\n            //debug_event(__CLASS__, \"get_clean_metadata \" . print_r($ctags, true), 4);\n            if (method_exists($song, 'updateOrInsertMetadata')) {\n                $ctags = array_diff_key($ctags, array_flip($song->getDisabledMetadataFields()));\n                foreach ($ctags as $tag => $value) {\n                    $field = $song->getField($tag);\n                    $song->updateOrInsertMetadata($field, $value);\n                }\n            }\n            if (method_exists($song, 'deleteMetadata')) {\n                foreach ($song->getMetadata() as $metadata) {\n                    $metaName = $metadata->getField()->getName();\n                    if (!array_key_exists($metaName, $ctags)) {\n                        debug_event(__CLASS__, \"delete metadata field \" . $metaName, 4);\n                        $song->deleteMetadata($metadata);\n                    }\n                }\n            }\n        }\n\n        // Duplicate arts if required\n        if (($song->artist && $new_song->artist) && $song->artist != $new_song->artist) {\n            if (!Art::has_db($new_song->artist, 'artist')) {\n                Art::duplicate('artist', $song->artist, $new_song->artist);\n            }\n        }\n        if (($song->albumartist && $new_song->albumartist) && $song->albumartist != $new_song->albumartist) {\n            if (!Art::has_db($new_song->albumartist, 'artist')) {\n                Art::duplicate('artist', $song->albumartist, $new_song->albumartist);\n            }\n        }\n        if (($song->album && $new_song->album) && $song->album != $new_song->album) {\n            if (!Art::has_db($new_song->album, 'album')) {\n                Art::duplicate('album', $song->album, $new_song->album);\n            }\n        }\n        if ($song->label && AmpConfig::get('label')) {\n            $labelRepository = static::getLabelRepository();\n\n            foreach (array_map('trim', explode(';', $song->label)) as $label_name) {\n                $label_id = Label::helper($label_name) ?? $labelRepository->lookup($label_name);\n                if ($label_id > 0) {\n                    $label   = new Label($label_id);\n                    $artists = $label->get_artists();\n                    if (!in_array($song->artist, $artists)) {\n                        debug_event(__CLASS__, \"$song->artist: adding association to $label->name\", 4);\n                        $labelRepository->addArtistAssoc($label->id, $song->artist);\n                    }\n                }\n            }\n        }\n\n        $info = Song::compare_song_information($song, $new_song);\n        if ($info['change']) {\n            debug_event(__CLASS__, \"$song->file : differences found, updating database\", 4);\n\n            // Update the song and song_data table\n            Song::update_song($song->id, $new_song);\n\n            // If you've migrated the album/artist you need to migrate their data here\n            self::migrate('artist', $song->artist, $new_song->artist, $song->id);\n            self::migrate('album', $song->album, $new_song->album, $song->id);\n\n            if ($song->tags != $new_song->tags) {\n                // we do still care if there are no tags on your object\n                $tag_comma = (!empty($new_song->tags))\n                    ? implode(',', $new_song->tags)\n                    : '';\n                Tag::update_tag_list($tag_comma, 'song', $song->id, true);\n            }\n            if ($song->license != $new_song->license) {\n                Song::update_license($new_song->license, $song->id);\n            }\n        }\n\n        // If song rating tag exists and is well formed (array user=>rating), update it\n        if ($song->id && is_array($results) && array_key_exists('rating', $results) && is_array($results['rating'])) {\n            // For each user's ratings, call the function\n            foreach ($results['rating'] as $user => $rating) {\n                debug_event(__CLASS__, \"Updating rating for Song \" . $song->id . \" to $rating for user $user\", 5);\n                $o_rating = new Rating($song->id, 'song');\n                $o_rating->set_rating($rating, $user);\n            }\n        }\n        // lets always update the time when you update\n        $update_time = time();\n        Song::update_utime($song->id, $update_time);\n        if ($map_change) {\n            $info['change'] = true;\n            $info['maps']   = true;\n            self::updateArtistTags($song->id);\n            self::updateAlbumArtistTags($song->album);\n        }\n\n        return $info;\n    } // update_song_from_tags\n\n    /**\n     * @param $results\n     * @param Video $video\n     * @return array\n     */\n    public static function update_video_from_tags($results, Video $video)\n    {\n        /* Setup the vars */\n        $new_video                = new Video();\n        $new_video->file          = $results['file'];\n        $new_video->title         = $results['title'];\n        $new_video->size          = $results['size'];\n        $new_video->video_codec   = $results['video_codec'];\n        $new_video->audio_codec   = $results['audio_codec'];\n        $new_video->resolution_x  = $results['resolution_x'];\n        $new_video->resolution_y  = $results['resolution_y'];\n        $new_video->time          = $results['time'];\n        $new_video->release_date  = $results['release_date'] ?? null;\n        $new_video->bitrate       = $results['bitrate'];\n        $new_video->mode          = $results['mode'];\n        $new_video->channels      = $results['channels'];\n        $new_video->display_x     = $results['display_x'];\n        $new_video->display_y     = $results['display_y'];\n        $new_video->frame_rate    = $results['frame_rate'];\n        $new_video->video_bitrate = (int) self::check_int($results['video_bitrate'], 4294967294, 0);\n        $tags                     = Tag::get_object_tags('video', $video->id);\n        if ($tags) {\n            foreach ($tags as $tag) {\n                $video->tags[]     = $tag['name'];\n            }\n        }\n        $new_video->tags        = $results['genre'];\n\n        $info = Video::compare_video_information($video, $new_video);\n        if ($info['change']) {\n            debug_event(__CLASS__, $video->file . \" : differences found, updating database\", 5);\n\n            Video::update_video($video->id, $new_video);\n\n            if ($video->tags != $new_video->tags) {\n                Tag::update_tag_list(implode(',', $new_video->tags), 'video', $video->id, true);\n            }\n            Video::update_video_counts($video->id);\n        }\n        // lets always update the time when you update\n        $update_time = time();\n        Video::update_utime($video->id, $update_time);\n\n        return $info;\n    }\n\n    /**\n     * @param $results\n     * @param Podcast_Episode $podcast_episode\n     * @return array\n     */\n    public static function update_podcast_episode_from_tags($results, Podcast_Episode $podcast_episode)\n    {\n        $sql = \"UPDATE `podcast_episode` SET `file` = ?, `size` = ?, `time` = ?, `state` = 'completed' WHERE `id` = ?\";\n        Dba::write($sql, array($podcast_episode->file, $results['size'], $results['time'], $podcast_episode->id));\n\n        $podcast_episode->size = $results['size'];\n        $podcast_episode->time = $results['time'];\n\n        $array            = array();\n        $array['change']  = true;\n        $array['element'] = false;\n\n        return $array;\n    }\n\n    /**\n     * Get rid of all tags found in the libraryItem\n     * @param library_item $libraryItem\n     * @param array $metadata\n     * @return array\n     */\n    private static function get_clean_metadata(library_item $libraryItem, $metadata)\n    {\n        // these fields seem to be ignored but should be removed\n        $databaseFields = array(\n            'artists' => null,\n            'mb_albumartistid_array' => null,\n            'mb_artistid_array' => null,\n            'original_year' => null,\n            'release_status' => null,\n            'release_type' => null,\n            'originalyear' => null,\n            'dynamic range (r128)' => null,\n            'volume level (r128)' => null,\n            'volume level (replaygain)' => null,\n            'peak level (r128)' => null,\n            'peak level (sample)' => null\n        );\n        $tags = array_diff_key($metadata, get_object_vars($libraryItem), array_flip($libraryItem::$aliases ?? array()), $databaseFields);\n\n        return array_filter($tags);\n    }\n\n    /**\n     * update the artist or album counts on catalog changes\n     */\n    public static function update_counts()\n    {\n        $update_time = self::get_update_info('update_counts');\n        $now_time    = time();\n        // give the server a 30 min break for this help with load\n        if ($update_time !== 0 && $update_time > ($now_time - 1800)) {\n            return;\n        }\n        self::set_update_info('update_counts', $now_time);\n        debug_event(__CLASS__, 'update_counts after catalog changes', 5);\n        // missing map tables are pretty important\n        $sql = \"INSERT IGNORE INTO `artist_map` (`artist_id`, `object_type`, `object_id`) SELECT DISTINCT `song`.`artist` AS `artist_id`, 'song', `song`.`id` FROM `song` WHERE `song`.`artist` > 0 UNION SELECT DISTINCT `album`.`album_artist` AS `artist_id`, 'album', `album`.`id` FROM `album` WHERE `album`.`album_artist` > 0;\";\n        Dba::write($sql);\n        $sql = \"INSERT IGNORE INTO `album_map` (`album_id`, `object_type`, `object_id`)  SELECT DISTINCT `artist_map`.`object_id` AS `album_id`, 'album' AS `object_type`, `artist_map`.`artist_id` AS `object_id` FROM `artist_map` WHERE `artist_map`.`object_type` = 'album' AND `artist_map`.`object_id` IS NOT NULL UNION SELECT DISTINCT `song`.`album` AS `album_id`, 'song' AS `object_type`, `song`.`artist` AS `object_id` FROM `song` WHERE `song`.`album` IS NOT NULL UNION SELECT DISTINCT `song`.`album` AS `album_id`, 'song' AS `object_type`, `artist_map`.`artist_id` AS `object_id` FROM `artist_map` LEFT JOIN `song` ON `artist_map`.`object_type` = 'song' AND `artist_map`.`object_id` = `song`.`id` WHERE `song`.`album` IS NOT NULL AND `artist_map`.`object_type` = 'song';\";\n        Dba::write($sql);\n        // do the longer updates over a larger stretch of time\n        if ($update_time !== 0 && $update_time < ($now_time - 86400)) {\n            // delete old maps in album_map table\n            $sql        = \"SELECT `album_map`.`album_id`, `album_map`.`object_id`, `album_map`.`object_type` FROM (SELECT * FROM `album_map` WHERE `object_type` = 'song') AS `album_map` LEFT JOIN (SELECT DISTINCT `artist_id`, `album` FROM (SELECT `artist_id`, `object_id` AS `song_id` FROM `artist_map` WHERE `object_type` = 'song') AS `artist_songs`, `song` WHERE `song_id` = `id`) AS `artist_map` ON `album_map`.`object_id` = `artist_map`.`artist_id` AND `album_map`.`album_id` = `artist_map`.`album` WHERE `artist_map`.`album` IS NULL;\";\n            $db_results = Dba::read($sql);\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $sql = \"DELETE FROM `album_map` WHERE `album_id` = ? AND `object_id` = ? AND `object_type` = ?;\";\n                Dba::write($sql, array($row['album_id'], $row['object_id'], $row['object_type']));\n            }\n            // this isn't really needed often and is slow\n            Dba::write(\"DELETE FROM `recommendation_item` WHERE `recommendation` NOT IN (SELECT `id` FROM `recommendation`);\");\n            // Fill in null Agents with a value\n            $sql = \"UPDATE `object_count` SET `agent` = 'Unknown' WHERE `agent` IS NULL;\";\n            Dba::write($sql);\n            // object_count.album\n            $sql = \"UPDATE IGNORE `object_count`, (SELECT `song_count`.`date`, `song`.`id` AS `songid`, `song`.`album`, `album_count`.`object_id` AS `albumid`, `album_count`.`user`, `album_count`.`agent`, `album_count`.`count_type` FROM `song` LEFT JOIN `object_count` AS `song_count` ON `song_count`.`object_type` = 'song' AND `song_count`.`count_type` = 'stream' AND `song_count`.`object_id` = `song`.`id` LEFT JOIN `object_count` AS `album_count` ON `album_count`.`object_type` = 'album' AND `album_count`.`count_type` = 'stream' AND `album_count`.`date` = `song_count`.`date` WHERE `song_count`.`date` IS NOT NULL AND `song`.`album` != `album_count`.`object_id` AND `album_count`.`count_type` = 'stream') AS `album_check` SET `object_count`.`object_id` = `album_check`.`album` WHERE `object_count`.`object_id` != `album_check`.`album` AND `object_count`.`object_type` = 'album' AND `object_count`.`date` = `album_check`.`date` AND `object_count`.`user` = `album_check`.`user` AND `object_count`.`agent` = `album_check`.`agent` AND `object_count`.`count_type` = `album_check`.`count_type`;\";\n            Dba::write($sql);\n            // object_count.artist\n            $sql = \"UPDATE IGNORE `object_count`, (SELECT `song_count`.`date`, MIN(`song`.`id`) AS `songid`, MIN(`song`.`artist`) AS `artist`, `artist_count`.`object_id` AS `artistid`, `artist_count`.`user`, `artist_count`.`agent`, `artist_count`.`count_type` FROM `song` LEFT JOIN `object_count` AS `song_count` ON `song_count`.`object_type` = 'song' AND `song_count`.`count_type` = 'stream' AND `song_count`.`object_id` = `song`.`id` LEFT JOIN `object_count` AS `artist_count` ON `artist_count`.`object_type` = 'artist' AND `artist_count`.`count_type` = 'stream' AND `artist_count`.`date` = `song_count`.`date` WHERE `song_count`.`date` IS NOT NULL AND `song`.`artist` != `artist_count`.`object_id` AND `artist_count`.`count_type` = 'stream' GROUP BY `artist_count`.`object_id`, `date`, `user`, `agent`, `count_type`) AS `artist_check` SET `object_count`.`object_id` = `artist_check`.`artist` WHERE `object_count`.`object_id` != `artist_check`.`artist` AND `object_count`.`object_type` = 'artist' AND `object_count`.`date` = `artist_check`.`date` AND `object_count`.`user` = `artist_check`.`user` AND `object_count`.`agent` = `artist_check`.`agent` AND `object_count`.`count_type` = `artist_check`.`count_type`;\";\n            Dba::write($sql);\n        }\n        // fix object_count table missing artist row\n        debug_event(__CLASS__, 'update_counts object_count table missing artist row', 5);\n        $sql = \"INSERT IGNORE INTO `object_count` (`object_type`, `object_id`, `date`, `user`, `agent`, `geo_latitude`, `geo_longitude`, `geo_name`, `count_type`) SELECT 'artist', `artist_map`.`artist_id`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `artist_map` on `object_count`.`object_type` = `artist_map`.`object_type` AND `object_count`.`object_id` = `artist_map`.`object_id` LEFT JOIN `object_count` AS `artist_check` ON `object_count`.`date` = `artist_check`.`date` AND `artist_check`.`object_type` = 'artist' AND `artist_check`.`object_id` = `artist_map`.`artist_id` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` IN (SELECT `id` FROM `song` WHERE `id` IN (SELECT `object_id` FROM `artist_map` WHERE `object_type` = 'song')) AND `artist_check`.`object_id` IS NULL UNION SELECT 'artist', `artist_map`.`artist_id`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `artist_map` ON `object_count`.`object_type` = `artist_map`.`object_type` AND `object_count`.`object_id` = `artist_map`.`object_id` LEFT JOIN `object_count` AS `artist_check` ON `object_count`.`date` = `artist_check`.`date` AND `artist_check`.`object_type` = 'artist' AND `artist_check`.`object_id` = `artist_map`.`artist_id` WHERE `object_count`.`object_type` = 'album' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` IN (SELECT `id` FROM `song` WHERE `id` IN (SELECT `object_id` FROM `artist_map` WHERE `object_type` = 'album')) AND `artist_check`.`object_id` IS NULL GROUP BY `artist_map`.`artist_id`, `object_count`.`object_type`, `object_count`.`object_id`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type`;\";\n        Dba::write($sql);\n        // fix object_count table missing album row\n        debug_event(__CLASS__, 'update_counts object_count table missing album row', 5);\n        $sql = \"INSERT IGNORE INTO `object_count` (`object_type`, `object_id`, `date`, `user`, `agent`, `geo_latitude`, `geo_longitude`, `geo_name`, `count_type`) SELECT 'album', `song`.`album`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `song` ON `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` = `song`.`id` LEFT JOIN `object_count` AS `album_count` ON `album_count`.`object_type` = 'album' AND `object_count`.`date` = `album_count`.`date` AND `object_count`.`user` = `album_count`.`user` AND `object_count`.`agent` = `album_count`.`agent` AND `object_count`.`count_type` = `album_count`.`count_type` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `album_count`.`id` IS NULL;\";\n        Dba::write($sql);\n        // also clean up some bad data that might creep in\n        Dba::write(\"UPDATE `artist` SET `prefix` = NULL WHERE `prefix` = '';\");\n        Dba::write(\"UPDATE `artist` SET `mbid` = NULL WHERE `mbid` = '';\");\n        Dba::write(\"UPDATE `artist` SET `summary` = NULL WHERE `summary` = '';\");\n        Dba::write(\"UPDATE `artist` SET `placeformed` = NULL WHERE `placeformed` = '';\");\n        Dba::write(\"UPDATE `artist` SET `yearformed` = NULL WHERE `yearformed` = 0;\");\n        Dba::write(\"UPDATE `album` SET `album_artist` = NULL WHERE `album_artist` = 0;\");\n        Dba::write(\"UPDATE `album` SET `prefix` = NULL WHERE `prefix` = '';\");\n        Dba::write(\"UPDATE `album` SET `mbid` = NULL WHERE `mbid` = '';\");\n        Dba::write(\"UPDATE `album` SET `mbid_group` = NULL WHERE `mbid_group` = '';\");\n        Dba::write(\"UPDATE `album` SET `release_type` = NULL WHERE `release_type` = '';\");\n        Dba::write(\"UPDATE `album` SET `original_year` = NULL WHERE `original_year` = 0;\");\n        Dba::write(\"UPDATE `album` SET `barcode` = NULL WHERE `barcode` = '';\");\n        Dba::write(\"UPDATE `album` SET `catalog_number` = NULL WHERE `catalog_number` = '';\");\n        Dba::write(\"UPDATE `album` SET `release_status` = NULL WHERE `release_status` = '';\");\n        // song.played might have had issues\n        $sql = \"UPDATE `song` SET `song`.`played` = 0 WHERE `song`.`played` = 1 AND `song`.`id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'song' AND `count_type` = 'stream');\";\n        Dba::write($sql);\n        $sql = \"UPDATE `song` SET `song`.`played` = 1 WHERE `song`.`played` = 0 AND `song`.`id` IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'song' AND `count_type` = 'stream');\";\n        Dba::write($sql);\n        // fix up incorrect total_count values too\n        $sql = \"UPDATE `song` SET `total_count` = 0 WHERE `total_count` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream');\";\n        Dba::write($sql);\n        $sql = \"UPDATE `song` SET `total_skip` = 0 WHERE `total_skip` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream');\";\n        Dba::write($sql);\n        if (AmpConfig::get('podcast')) {\n            //debug_event(__CLASS__, 'update_counts podcast_episode table', 5);\n            // fix object_count table missing podcast row\n            $sql        = \"SELECT `podcast_episode`.`podcast`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `podcast_episode` ON `object_count`.`object_type` = 'podcast_episode' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` = `podcast_episode`.`id` LEFT JOIN `object_count` AS `podcast_count` ON `podcast_count`.`object_type` = 'podcast' AND `object_count`.`date` = `podcast_count`.`date` AND `object_count`.`user` = `podcast_count`.`user` AND `object_count`.`agent` = `podcast_count`.`agent` AND `object_count`.`count_type` = `podcast_count`.`count_type` WHERE `object_count`.`count_type` = 'stream' AND `object_count`.`object_type` = 'podcast_episode' AND `podcast_count`.`id` IS NULL LIMIT 100;\";\n            $db_results = Dba::read($sql);\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $sql = \"INSERT IGNORE INTO `object_count` (`object_type`, `object_id`, `count_type`, `date`, `user`, `agent`, `geo_latitude`, `geo_longitude`, `geo_name`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\";\n                Dba::write($sql, array('podcast', $row['podcast'], $row['count_type'], $row['date'], $row['user'], $row['agent'], $row['geo_latitude'], $row['geo_longitude'], $row['geo_name']));\n            }\n            $sql = \"UPDATE `podcast_episode` SET `total_count` = 0 WHERE `total_count` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'podcast_episode' AND `object_count`.`count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `podcast_episode` SET `total_skip` = 0 WHERE `total_skip` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'podcast_episode' AND `object_count`.`count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `podcast_episode` SET `podcast_episode`.`played` = 0 WHERE `podcast_episode`.`played` = 1 AND `podcast_episode`.`id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'podcast_episode' AND `count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `podcast_episode` SET `podcast_episode`.`played` = 1 WHERE `podcast_episode`.`played` = 0 AND `podcast_episode`.`id` IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'podcast_episode' AND `count_type` = 'stream');\";\n            Dba::write($sql);\n            // podcast_episode.total_count\n            $sql = \"UPDATE `podcast_episode`, (SELECT COUNT(`object_count`.`object_id`) AS `total_count`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'podcast_episode' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS `object_count` SET `podcast_episode`.`total_count` = `object_count`.`total_count` WHERE `podcast_episode`.`total_count` != `object_count`.`total_count` AND `podcast_episode`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n            // podcast.total_count\n            $sql = \"UPDATE `podcast`, (SELECT SUM(`podcast_episode`.`total_count`) AS `total_count`, `podcast` FROM `podcast_episode` GROUP BY `podcast_episode`.`podcast`) AS `object_count` SET `podcast`.`total_count` = `object_count`.`total_count` WHERE `podcast`.`total_count` != `object_count`.`total_count` AND `podcast`.`id` = `object_count`.`podcast`;\";\n            Dba::write($sql);\n            // song.total_count\n            $sql = \"UPDATE `song`, (SELECT COUNT(`object_count`.`object_id`) AS `total_count`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS `object_count` SET `song`.`total_count` = `object_count`.`total_count` WHERE `song`.`total_count` != `object_count`.`total_count` AND `song`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n            // song.total_skip\n            $sql = \"UPDATE `song`, (SELECT COUNT(`object_count`.`object_id`) AS `total_skip`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'skip' GROUP BY `object_count`.`object_id`) AS `object_count` SET `song`.`total_skip` = `object_count`.`total_skip` WHERE `song`.`total_skip` != `object_count`.`total_skip` AND `song`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n        }\n        if (AmpConfig::get('allow_video')) {\n            //debug_event(__CLASS__, 'update_counts video table', 5);\n            $sql = \"UPDATE `video` SET `total_count` = 0 WHERE `total_count` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'video' AND `object_count`.`count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `video` SET `total_skip` = 0 WHERE `total_skip` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'video' AND `object_count`.`count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `video` SET `video`.`played` = 0 WHERE `video`.`played` = 1 AND `video`.`id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'video' AND `count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `video` SET `video`.`played` = 1 WHERE `video`.`played` = 0 AND `video`.`id` IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'video' AND `count_type` = 'stream');\";\n            Dba::write($sql);\n            // video.total_count\n            $sql = \"UPDATE `video`, (SELECT COUNT(`object_count`.`object_id`) AS `total_count`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'video' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS `object_count` SET `video`.`total_count` = `object_count`.`total_count` WHERE `video`.`total_count` != `object_count`.`total_count` AND `video`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n        }\n        Artist::update_artist_counts();\n        Album::update_album_counts();\n\n        // update server total counts\n        debug_event(__CLASS__, 'update_counts server total counts', 5);\n        $catalog_disable = AmpConfig::get('catalog_disable');\n        // tables with media items to count, song-related tables and the rest\n        $media_tables = array('song', 'video', 'podcast_episode');\n        $items        = 0;\n        $time         = 0;\n        $size         = 0;\n        foreach ($media_tables as $table) {\n            $enabled_sql = ($catalog_disable && $table !== 'podcast_episode') ? \" WHERE `$table`.`enabled` = '1'\" : '';\n            $sql         = \"SELECT COUNT(`id`), IFNULL(SUM(`time`), 0), IFNULL(SUM(`size`), 0) FROM `$table`\" . $enabled_sql;\n            $db_results  = Dba::read($sql);\n            $row         = Dba::fetch_row($db_results);\n            // save the object and add to the current size\n            $items += (int)($row[0] ?? 0);\n            $time += (int)($row[1] ?? 0);\n            $size += (int)($row[2] ?? 0);\n            self::set_update_info($table, (int)($row[0] ?? 0));\n        }\n        self::set_update_info('items', $items);\n        self::set_update_info('time', $time);\n        self::set_update_info('size', $size);\n\n        $song_tables = array('artist', 'album');\n        foreach ($song_tables as $table) {\n            $sql        = \"SELECT COUNT(DISTINCT(`$table`)) FROM `song`\";\n            $db_results = Dba::read($sql);\n            $row        = Dba::fetch_row($db_results);\n            self::set_update_info($table, (int)($row[0] ?? 0));\n        }\n        // grouped album counts\n        $sql        = \"SELECT COUNT(DISTINCT(`album`.`id`)) AS `count` FROM `album` WHERE `id` in (SELECT MIN(`id`) FROM `album` GROUP BY `album`.`prefix`, `album`.`name`, `album`.`album_artist`, `album`.`release_type`, `album`.`release_status`, `album`.`mbid`, `album`.`year`, `album`.`original_year`, `album`.`mbid_group`);\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_row($db_results);\n        self::set_update_info('album_group', (int)($row[0] ?? 0));\n\n        $list_tables = array('search', 'playlist', 'live_stream', 'podcast', 'user', 'catalog', 'label', 'tag', 'share', 'license');\n        foreach ($list_tables as $table) {\n            $sql        = \"SELECT COUNT(`id`) FROM `$table`\";\n            $db_results = Dba::read($sql);\n            $row        = Dba::fetch_row($db_results);\n            self::set_update_info($table, (int)($row[0] ?? 0));\n        }\n        debug_event(__CLASS__, 'update_counts User::update_counts()', 5);\n        // user accounts may have different items to return based on catalog_filter so lets set those too\n        User::update_counts();\n        debug_event(__CLASS__, 'update_counts completed', 5);\n    }\n\n    /**\n     *\n     * @param library_item $libraryItem\n     * @param array $metadata\n     */\n    public static function add_metadata(library_item $libraryItem, $metadata)\n    {\n        $tags = self::get_clean_metadata($libraryItem, $metadata);\n\n        foreach ($tags as $tag => $value) {\n            $field = $libraryItem->getField($tag);\n            $libraryItem->addMetadata($field, $value);\n        }\n    }\n\n    /**\n     * get_media_tags\n     * @param Song|Video|Podcast_Episode $media\n     * @param array $gather_types\n     * @param string $sort_pattern\n     * @param string $rename_pattern\n     * @return array\n     */\n    public function get_media_tags($media, $gather_types, $sort_pattern, $rename_pattern)\n    {\n        // Check for patterns\n        if (!$sort_pattern || !$rename_pattern) {\n            $sort_pattern   = $this->sort_pattern;\n            $rename_pattern = $this->rename_pattern;\n        }\n\n        $vainfo = $this->getUtilityFactory()->createVaInfo(\n            $media->file,\n            $gather_types,\n            '',\n            '',\n            $sort_pattern,\n            $rename_pattern\n        );\n        try {\n            $vainfo->get_info();\n        } catch (Exception $error) {\n            debug_event(__CLASS__, 'Error ' . $error->getMessage(), 1);\n\n            return array();\n        }\n\n        $key = VaInfo::get_tag_type($vainfo->tags);\n\n        return VaInfo::clean_tag_info($vainfo->tags, $key, $media->file);\n    }\n\n    /**\n     * get_gather_types\n     * @param string $media_type\n     * @return array\n     */\n    public function get_gather_types($media_type = '')\n    {\n        $gtypes = $this->gather_types;\n        if (empty($gtypes)) {\n            $gtypes = \"music\";\n        }\n        $types = explode(',', $gtypes);\n\n        if ($media_type == \"video\") {\n            $types = array_diff($types, array('music'));\n        }\n\n        if ($media_type == \"music\") {\n            $types = array_diff($types, array('personal_video', 'movie', 'tvshow', 'clip'));\n        }\n\n        return $types;\n    }\n\n    /**\n     * get_gather_type\n     * @return string\n     */\n    public function get_gather_type()\n    {\n        $sql        = \"SELECT `gather_types` FROM `catalog` WHERE `id` = ?;\";\n        $db_results = Dba::read($sql, array($this->id));\n        if ($row = Dba::fetch_assoc($db_results)) {\n            return $row['gather_types'];\n        }\n\n        return '';\n    }\n\n    /**\n     * get_table_from_type\n     * @param string $gather_type\n     * @return string\n     */\n    public static function get_table_from_type($gather_type)\n    {\n        switch ($gather_type) {\n            case 'clip':\n            case 'tvshow':\n            case 'movie':\n            case 'personal_video':\n                $table = 'video';\n                break;\n            case 'podcast':\n                $table = 'podcast_episode';\n                break;\n            case 'music':\n            default:\n                $table = 'song';\n                break;\n        }\n\n        return $table;\n    }\n\n    /**\n     * clean_empty_albums\n     */\n    public static function clean_empty_albums()\n    {\n        $sql        = \"SELECT `id`, `album_artist` FROM `album` WHERE NOT EXISTS (SELECT `id` FROM `song` WHERE `song`.`album` = `album`.`id`);\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $sql       = \"DELETE FROM `album` WHERE `id` = ?\";\n            Dba::write($sql, array($row['id']));\n        }\n        // these files have missing albums so you can't verify them without updating from tags first\n        $sql        = \"SELECT `id` FROM `song` WHERE `album` in (SELECT `album_id` FROM `album_map` WHERE `album_id` NOT IN (SELECT `id` from `album`));\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            self::update_single_item('song', $row['id'], true);\n        }\n    }\n\n    /**\n     * clean_duplicate_artists\n     *\n     * Artists that have the same mbid shouldn't be duplicated but can be created and updated based on names\n     */\n    public static function clean_duplicate_artists()\n    {\n        debug_event(__CLASS__, \"Clean Artists with duplicate mbid's\", 5);\n        $sql        = \"SELECT `mbid`, min(`id`) AS `minid`, max(`id`) AS `maxid` FROM `artist` WHERE `mbid` IS NOT NULL GROUP BY `mbid` HAVING count(`mbid`) >1;\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            debug_event(__CLASS__, \"clean_duplicate_artists \" . $row['maxid'] . \"=>\" . $row['minid'], 5);\n            // migrate linked tables first\n            //Stats::migrate('artist', $row['maxid'], $row['minid']);\n            Useractivity::migrate('artist', $row['maxid'], $row['minid']);\n            Recommendation::migrate('artist', $row['maxid'], $row['minid']);\n            Share::migrate('artist', $row['maxid'], $row['minid']);\n            Shoutbox::migrate('artist', $row['maxid'], $row['minid']);\n            Tag::migrate('artist', $row['maxid'], $row['minid']);\n            Userflag::migrate('artist', $row['maxid'], $row['minid']);\n            Label::migrate('artist', $row['maxid'], $row['minid']);\n            Rating::migrate('artist', $row['maxid'], $row['minid']);\n            Wanted::migrate('artist', $row['maxid'], $row['minid']);\n            Clip::migrate('artist', $row['maxid'], $row['minid']);\n            self::migrate_map('artist', $row['maxid'], $row['minid']);\n\n            // replace all songs and albums with the original artist\n            Artist::migrate($row['maxid'], $row['minid']);\n        }\n        // remove the duplicates after moving everything\n        Artist::garbage_collection();\n        static::getAlbumRepository()->collectGarbage();\n    }\n\n    /**\n     * clean_catalog\n     *\n     * Cleans the catalog of files that no longer exist.\n     */\n    public function clean_catalog()\n    {\n        // We don't want to run out of time\n        set_time_limit(0);\n\n        debug_event(__CLASS__, 'Starting clean on ' . $this->name, 5);\n\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            require Ui::find_template('show_clean_catalog.inc.php');\n            ob_flush();\n            flush();\n        }\n\n        $dead_total = $this->clean_catalog_proc();\n        self::clean_empty_albums();\n        self::clean_duplicate_artists();\n\n        debug_event(__CLASS__, 'clean finished, ' . $dead_total . ' removed from ' . $this->name, 4);\n\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            Ui::show_box_top();\n        }\n        Ui::update_text(T_(\"Catalog Cleaned\"),\n            sprintf(nT_(\"%d file removed.\", \"%d files removed.\", $dead_total), $dead_total));\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            Ui::show_box_bottom();\n        }\n\n        $this->update_last_clean();\n    } // clean_catalog\n\n    /**\n     * verify_catalog\n     * This function verify the catalog\n     */\n    public function verify_catalog()\n    {\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            require Ui::find_template('show_verify_catalog.inc.php');\n            ob_flush();\n            flush();\n        }\n\n        $verified = $this->verify_catalog_proc();\n\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            Ui::show_box_top();\n        }\n        Ui::update_text(T_(\"Catalog Verified\"),\n            sprintf(nT_('%d file updated.', '%d files updated.', $verified['updated']), $verified['updated']));\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            Ui::show_box_bottom();\n        }\n\n        return true;\n    } // verify_catalog\n\n    /**\n     * trim_prefix\n     * Splits the prefix from the string\n     * @param string $string\n     * @return array\n     */\n    public static function trim_prefix($string)\n    {\n        $prefix_pattern = '/^(' . implode('\\\\s|', explode('|', AmpConfig::get('catalog_prefix_pattern'))) . '\\\\s)(.*)/i';\n        if (preg_match($prefix_pattern, $string, $matches)) {\n            $string = trim((string)$matches[2]);\n            $prefix = trim((string)$matches[1]);\n        } else {\n            $prefix = null;\n        }\n\n        return array('string' => $string, 'prefix' => $prefix);\n    } // trim_prefix\n\n    /**\n     * @param $year\n     * @return integer\n     */\n    public static function normalize_year($year)\n    {\n        if (empty($year)) {\n            return 0;\n        }\n\n        $year = (int)($year);\n        if ($year < 0 || $year > 9999) {\n            return 0;\n        }\n\n        return $year;\n    }\n\n    /**\n     * trim_slashed_list\n     * Split items by configurable delimiter\n     * Return first item as string = default\n     * Return all items as array if doTrim = false passed as optional parameter\n     * @param string $string\n     * @param bool $doTrim\n     * @return string|array\n     */\n    public static function trim_slashed_list($string, $doTrim = true)\n    {\n        $delimiters = static::getConfigContainer()->get(ConfigurationKeyEnum::ADDITIONAL_DELIMITERS);\n        $pattern    = '~[\\s]?(' . $delimiters . ')[\\s]?~';\n        $items      = preg_split($pattern, $string);\n        $items      = array_map('trim', $items);\n\n        if ((isset($items) && isset($items[0])) && $doTrim) {\n            return $items[0];\n        }\n\n        return $items;\n    } // trim_slashed_list\n\n    /**\n     * trim_featuring\n     * Splits artists featuring from the string\n     * @param string $string\n     * @return array\n     */\n    public static function trim_featuring($string)\n    {\n        return array_map('trim', preg_split(\"/ feat\\. /i\", $string));\n    } // trim_featuring\n\n    /**\n     * check_title\n     * this checks to make sure something is\n     * set on the title, if it isn't it looks at the\n     * filename and tries to set the title based on that\n     * @param string $title\n     * @param string $file\n     * @return string\n     */\n    public static function check_title($title, $file = '')\n    {\n        if (strlen(trim((string)$title)) < 1) {\n            $title = Dba::escape($file);\n        }\n\n        return $title;\n    } // check_title\n\n    /**\n     * check_length\n     * Check to make sure the string fits into the database\n     * max_length is the maximum number of characters that the (varchar) column can hold\n     * @param string $string\n     * @param integer $max_length\n     * @return string\n     */\n    public static function check_length($string, $max_length = 255)\n    {\n        $string = (string)$string;\n        if (false !== $encoding = mb_detect_encoding($string, null, true)) {\n            $string = trim(mb_substr($string, 0, $max_length, $encoding));\n        } else {\n            $string = trim(substr($string, 0, $max_length));\n        }\n\n        return $string;\n    }\n\n    /**\n     * check_track\n     * Check to make sure the track number fits into the database: max 32767, min -32767\n     *\n     * @param string $track\n     * @return integer\n     */\n    public static function check_track($track)\n    {\n        $retval = ((int)$track > 32767 || (int)$track < -32767) ? (int)substr($track, -4, 4) : (int)$track;\n        if ((int)$track !== $retval) {\n            debug_event(__CLASS__, \"check_track: '{$track}' out of range. Changed into '{$retval}'\", 4);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * check_int\n     * Check to make sure a number fits into the database\n     *\n     * @param integer $my_int\n     * @param integer $max\n     * @param integer $min\n     * @return integer\n     */\n    public static function check_int($my_int, $max, $min)\n    {\n        if ($my_int > $max) {\n            return $max;\n        }\n        if ($my_int < $min) {\n            return $min;\n        }\n\n        return $my_int;\n    }\n\n    /**\n     * get_unique_string\n     * Check to make sure the string doesn't have duplicate strings ({)e.g. \"Enough Records; Enough Records\")\n     *\n     * @param string $str_array\n     * @return string\n     */\n    public static function get_unique_string($str_array)\n    {\n        $array = array_unique(array_map('trim', explode(';', $str_array)));\n\n        return implode($array);\n    }\n\n    /**\n     * playlist_import\n     * Attempts to create a Public Playlist based on the playlist file\n     * @param string $playlist_file\n     * @param int $user_id\n     * @param string $playlist_type (public|private)\n     * @return array\n     */\n    public static function import_playlist($playlist_file, $user_id, $playlist_type)\n    {\n        $data = file_get_contents($playlist_file);\n        if (substr($playlist_file, -3, 3) == 'm3u' || substr($playlist_file, -4, 4) == 'm3u8') {\n            $files = self::parse_m3u($data);\n        } elseif (substr($playlist_file, -3, 3) == 'pls') {\n            $files = self::parse_pls($data);\n        } elseif (substr($playlist_file, -3, 3) == 'asx') {\n            $files = self::parse_asx($data);\n        } elseif (substr($playlist_file, -4, 4) == 'xspf') {\n            $files = self::parse_xspf($data);\n        }\n\n        $songs    = array();\n        $import   = array();\n        $pinfo    = pathinfo($playlist_file);\n        $track    = 1;\n        $web_path = AmpConfig::get('web_path');\n        if (isset($files)) {\n            foreach ($files as $file) {\n                $found = false;\n                $file  = trim((string)$file);\n                $orig  = $file;\n                // Check to see if it's a url from this ampache instance\n                if (!empty($web_path) && substr($file, 0, strlen($web_path)) == $web_path) {\n                    $url_data   = Stream_Url::parse($file);\n                    $sql        = 'SELECT COUNT(*) FROM `song` WHERE `id` = ?';\n                    $db_results = Dba::read($sql, array($url_data['id']));\n                    if (Dba::num_rows($db_results) && (int)$url_data['id'] > 0) {\n                        debug_event(__CLASS__, \"import_playlist identified: {\" . $url_data['id'] . \"}\", 5);\n                        $songs[$track] = $url_data['id'];\n                        $track++;\n                        $found = true;\n                    }\n                } else {\n                    // Remove file:// prefix if any\n                    if (strpos($file, \"file://\") !== false) {\n                        $file = urldecode(substr($file, 7));\n                        if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n                            // Removing starting / on Windows OS.\n                            if (substr($file, 0, 1) == '/') {\n                                $file = substr($file, 1);\n                            }\n                            // Restore real directory separator\n                            $file = str_replace(\"/\", DIRECTORY_SEPARATOR, $file);\n                        }\n                    }\n\n                    // First, try to find the file as absolute path\n                    $sql        = \"SELECT `id` FROM `song` WHERE `file` = ?\";\n                    $db_results = Dba::read($sql, array($file));\n                    $results    = Dba::fetch_assoc($db_results);\n\n                    if (array_key_exists('id', $results) && (int)($results['id']) > 0) {\n                        debug_event(__CLASS__, \"import_playlist identified: {\" . (int)$results['id'] . \"}\", 5);\n                        $songs[$track] = (int)$results['id'];\n                        $track++;\n                        $found = true;\n                    } else {\n                        // Not found in absolute path, create it from relative path\n                        $file = $pinfo['dirname'] . DIRECTORY_SEPARATOR . $file;\n                        // Normalize the file path. realpath requires the files to exists.\n                        $file = realpath($file);\n                        if ($file) {\n                            $sql        = \"SELECT `id` FROM `song` WHERE `file` = ?\";\n                            $db_results = Dba::read($sql, array($file));\n                            $results    = Dba::fetch_assoc($db_results);\n\n                            if ((int)$results['id'] > 0) {\n                                debug_event(__CLASS__, \"import_playlist identified: {\" . (int)$results['id'] . \"}\", 5);\n                                $songs[$track] = (int)$results['id'];\n                                $track++;\n                                $found = true;\n                            }\n                        }\n                    }\n                } // if it's a file\n                if (!$found) {\n                    debug_event(__CLASS__, \"import_playlist skipped: {{$orig}}\", 5);\n                }\n                // add the results to an array to display after\n                $import[] = array(\n                    'track' => $track - 1,\n                    'file' => $orig,\n                    'found' => (int)$found\n                );\n            }\n        }\n\n        debug_event(__CLASS__, \"import_playlist Parsed \" . $playlist_file . \", found \" . count($songs) . \" songs\", 5);\n\n        if (count($songs)) {\n            $name        = $pinfo['filename'];\n            $playlist_id = (int)Playlist::create($name, $playlist_type, $user_id);\n\n            if ($playlist_id < 1) {\n                return array(\n                    'success' => false,\n                    'error' => T_('Failed to create playlist'),\n                );\n            }\n\n            $playlist = new Playlist($playlist_id);\n            $playlist->delete_all();\n            $playlist->add_songs($songs);\n\n            return array(\n                'success' => true,\n                'id' => $playlist_id,\n                'count' => count($songs),\n                'results' => $import\n            );\n        }\n\n        return array(\n            'success' => false,\n            'error' => T_('No valid songs found in playlist file'),\n            'results' => $import\n        );\n    }\n\n    /**\n     * parse_m3u\n     * this takes m3u filename and then attempts to found song filenames listed in the m3u\n     * @param string $data\n     * @return array\n     */\n    public static function parse_m3u($data)\n    {\n        $files   = array();\n        $results = explode(\"\\n\", $data);\n\n        foreach ($results as $value) {\n            $value = trim((string)$value);\n            if (!empty($value) && substr($value, 0, 1) != '#') {\n                $files[] = $value;\n            }\n        }\n\n        return $files;\n    } // parse_m3u\n\n    /**\n     * parse_pls\n     * this takes pls filename and then attempts to found song filenames listed in the pls\n     * @param string $data\n     * @return array\n     */\n    public static function parse_pls($data)\n    {\n        $files   = array();\n        $results = explode(\"\\n\", $data);\n\n        foreach ($results as $value) {\n            $value = trim((string)$value);\n            if (preg_match(\"/file[0-9]+[\\s]*\\=(.*)/i\", $value, $matches)) {\n                $file = trim((string)$matches[1]);\n                if (!empty($file)) {\n                    $files[] = $file;\n                }\n            }\n        }\n\n        return $files;\n    } // parse_pls\n\n    /**\n     * parse_asx\n     * this takes asx filename and then attempts to found song filenames listed in the asx\n     * @param string $data\n     * @return array\n     */\n    public static function parse_asx($data)\n    {\n        $files = array();\n        $xml   = simplexml_load_string($data);\n\n        if ($xml) {\n            foreach ($xml->entry as $entry) {\n                $file = trim((string)$entry->ref['href']);\n                if (!empty($file)) {\n                    $files[] = $file;\n                }\n            }\n        }\n\n        return $files;\n    } // parse_asx\n\n    /**\n     * parse_xspf\n     * this takes xspf filename and then attempts to found song filenames listed in the xspf\n     * @param string $data\n     * @return array\n     */\n    public static function parse_xspf($data)\n    {\n        $files = array();\n        $xml   = simplexml_load_string($data);\n        if ($xml) {\n            foreach ($xml->trackList->track as $track) {\n                $file = trim((string)$track->location);\n                if (!empty($file)) {\n                    $files[] = $file;\n                }\n            }\n        }\n\n        return $files;\n    } // parse_xspf\n\n    /**\n     * delete\n     * Deletes the catalog and everything associated with it\n     * it takes the catalog id\n     * @param integer $catalog_id\n     * @return boolean\n     */\n    public static function delete($catalog_id)\n    {\n        // Large catalog deletion can take time\n        set_time_limit(0);\n        $params = array($catalog_id);\n\n        // First remove the songs in this catalog\n        $sql        = \"DELETE FROM `song` WHERE `catalog` = ?\";\n        $db_results = Dba::write($sql, $params);\n\n        // Only if the previous one works do we go on\n        if (!$db_results) {\n            return false;\n        }\n        self::clean_empty_albums();\n\n        $sql        = \"DELETE FROM `video` WHERE `catalog` = ?\";\n        $db_results = Dba::write($sql, $params);\n\n        if (!$db_results) {\n            return false;\n        }\n\n        $sql        = \"DELETE FROM `podcast` WHERE `catalog` = ?\";\n        $db_results = Dba::write($sql, $params);\n\n        if (!$db_results) {\n            return false;\n        }\n\n        $sql        = \"DELETE FROM `live_stream` WHERE `catalog` = ?\";\n        $db_results = Dba::write($sql, $params);\n\n        if (!$db_results) {\n            return false;\n        }\n\n        $catalog = self::create_from_id($catalog_id);\n\n        if (!$catalog) {\n            return false;\n        }\n\n        $sql        = 'DELETE FROM `catalog_' . $catalog->get_type() . '` WHERE catalog_id = ?';\n        $db_results = Dba::write($sql, $params);\n\n        if (!$db_results) {\n            return false;\n        }\n\n        // Next Remove the Catalog Entry it's self\n        $sql = \"DELETE FROM `catalog` WHERE `id` = ?\";\n        Dba::write($sql, $params);\n\n        // run garbage collection\n        static::getCatalogGarbageCollector()->collect();\n\n        return true;\n    } // delete\n\n    /**\n     * exports the catalog\n     * it exports all songs in the database to the given export type.\n     * @param string $type\n     * @param integer|null $catalog_id\n     */\n    public static function export($type, $catalog_id = null)\n    {\n        // Select all songs in catalog\n        $params = array();\n        if ($catalog_id) {\n            $sql      = \"SELECT `id` FROM `song` WHERE `catalog` = ? ORDER BY `album`, `track`\";\n            $params[] = $catalog_id;\n        } else {\n            $sql = 'SELECT `id` FROM `song` ORDER BY `album`, `track`';\n        }\n        $db_results = Dba::read($sql, $params);\n\n        switch ($type) {\n            case 'itunes':\n                echo static::xml_get_header('itunes');\n                while ($results = Dba::fetch_assoc($db_results)) {\n                    $song = new Song($results['id']);\n                    $song->format();\n\n                    $xml                         = array();\n                    $xml['key']                  = $results['id'];\n                    $xml['dict']['Track ID']     = (int)($results['id']);\n                    $xml['dict']['Name']         = $song->title;\n                    $xml['dict']['Artist']       = $song->f_artist_full;\n                    $xml['dict']['Album']        = $song->f_album_full;\n                    $xml['dict']['Total Time']   = (int) ($song->time) * 1000; // iTunes uses milliseconds\n                    $xml['dict']['Track Number'] = (int) ($song->track);\n                    $xml['dict']['Year']         = (int) ($song->year);\n                    $xml['dict']['Date Added']   = get_datetime((int) $song->addition_time, 'short', 'short', \"Y-m-d\\TH:i:s\\Z\");\n                    $xml['dict']['Bit Rate']     = (int) ($song->bitrate / 1000);\n                    $xml['dict']['Sample Rate']  = (int) ($song->rate);\n                    $xml['dict']['Play Count']   = (int) ($song->played);\n                    $xml['dict']['Track Type']   = \"URL\";\n                    $xml['dict']['Location']     = $song->play_url();\n                    echo (string) xoutput_from_array($xml, true, 'itunes');\n                    // flush output buffer\n                } // while result\n                echo static::xml_get_footer('itunes');\n                break;\n            case 'csv':\n                echo \"ID,Title,Artist,Album,Length,Track,Year,Date Added,Bitrate,Played,File\\n\";\n                while ($results = Dba::fetch_assoc($db_results)) {\n                    $song = new Song($results['id']);\n                    $song->format();\n                    echo '\"' . $song->id . '\",\"' . $song->title . '\",\"' . $song->f_artist_full . '\",\"' . $song->f_album_full . '\",\"' . $song->f_time . '\",\"' . $song->f_track . '\",\"' . $song->year . '\",\"' . get_datetime((int)$song->addition_time) . '\",\"' . $song->f_bitrate . '\",\"' . $song->played . '\",\"' . $song->file . '\"' . \"\\n\";\n                }\n                break;\n        } // end switch\n    } // export\n\n    /**\n     * Update the catalog mapping for various types\n     * @param string $table\n     */\n    public static function update_mapping($table)\n    {\n        // fill the data\n        debug_event(__CLASS__, 'Update mapping for table: ' . $table, 5);\n        if ($table == 'artist') {\n            $sql = \"INSERT IGNORE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT DISTINCT `song`.`catalog`, 'artist', `artist_map`.`artist_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `song`.`catalog` > 0 UNION SELECT DISTINCT `album`.`catalog`, 'artist', `artist_map`.`artist_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `album`.`catalog` > 0 AND `artist_map`.`object_type` = 'album' GROUP BY `catalog`, 'artist', `artist_map`.`artist_id`;\";\n            Dba::write($sql);\n        } elseif ($table == 'playlist') {\n            $sql = \"INSERT IGNORE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `song`.`catalog`, 'playlist', `playlist`.`id` FROM `playlist` LEFT JOIN `playlist_data` ON `playlist`.`id`=`playlist_data`.`playlist` LEFT JOIN `song` ON `song`.`id` = `playlist_data`.`object_id` AND `playlist_data`.`object_type` = 'song' WHERE `song`.`catalog` > 0 GROUP BY `song`.`catalog`, 'playlist', `playlist`.`id`;\";\n            Dba::write($sql);\n        } else {\n            // 'album', 'song', 'video', 'podcast', 'podcast_episode', 'live_stream'\n            $sql = \"INSERT IGNORE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `$table`.`catalog`, '$table', `$table`.`id` FROM `$table` WHERE `$table`.`catalog` > 0 GROUP BY `$table`.`catalog`, '$table', `$table`.`id`;\";\n            Dba::write($sql);\n        }\n    }\n\n    /**\n     * Update the catalog mapping for various types\n     */\n    public static function garbage_collect_mapping()\n    {\n        // delete non-existent maps\n        $tables = ['album', 'song', 'video', 'podcast', 'podcast_episode', 'live_stream'];\n        foreach ($tables as $type) {\n            $sql = \"DELETE FROM `catalog_map` USING `catalog_map` LEFT JOIN (SELECT DISTINCT `$type`.`catalog` AS `catalog_id`, '$type' AS `object_type`, `$type`.`id` AS `object_id` FROM `$type` WHERE `$type`.`catalog` > 0 GROUP BY `$type`.`catalog`, '$type', `$type`.`id`) AS `valid_maps` ON `valid_maps`.`catalog_id` = `catalog_map`.`catalog_id` AND `valid_maps`.`object_id` = `catalog_map`.`object_id` AND `valid_maps`.`object_type` = `catalog_map`.`object_type` WHERE `catalog_map`.`object_type` = '$type' AND `valid_maps`.`object_id` IS NULL;\";\n            Dba::write($sql);\n        }\n        // artists are different\n        $sql = \"DELETE FROM `catalog_map` USING `catalog_map` LEFT JOIN (SELECT DISTINCT `song`.`catalog` AS `catalog_id`, 'artist' AS `object_type`, `artist_map`.`artist_id` AS `object_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `song`.`catalog` > 0 UNION SELECT DISTINCT `album`.`catalog`, 'artist', `artist_map`.`artist_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `album`.`catalog` > 0 AND `artist_map`.`object_type` = 'album' GROUP BY `catalog`, 'artist', `artist_map`.`artist_id`) AS `valid_maps` ON `valid_maps`.`catalog_id` = `catalog_map`.`catalog_id` AND `valid_maps`.`object_id` = `catalog_map`.`object_id` AND `valid_maps`.`object_type` = `catalog_map`.`object_type` WHERE `catalog_map`.`object_type` = 'artist' AND `valid_maps`.`object_id` IS NULL;\";\n        Dba::write($sql);\n\n        $sql = \"DELETE FROM `catalog_map` WHERE `catalog_id` = 0\";\n        Dba::write($sql);\n    }\n    /**\n     * Delete catalog filters that might have gone missing\n     */\n    public static function garbage_collect_filters()\n    {\n        Dba::write(\"DELETE FROM `catalog_filter_group_map` WHERE `group_id` NOT IN (SELECT `id` FROM `catalog_filter_group`);\");\n        Dba::write(\"UPDATE `user` SET `catalog_filter_group` = 0 WHERE `catalog_filter_group` NOT IN (SELECT `id` FROM `catalog_filter_group`);\");\n        Dba::write(\"UPDATE IGNORE `catalog_filter_group` SET `id` = 0 WHERE `name` = 'DEFAULT' AND `id` > 0;\");\n    }\n\n    /**\n     * Update the catalog map for a single item\n     */\n    public static function update_map($catalog, $object_type, $object_id)\n    {\n        if ($catalog > 0) {\n            debug_event(__CLASS__, \"update_map $object_type: {{$object_id}}\", 5);\n            if ($object_type == 'artist') {\n                $sql = \"INSERT IGNORE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT DISTINCT `song`.`catalog`, 'artist' AS `object_type`, `artist_map`.`artist_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`artist_id` = ? AND `song`.`catalog` > 0 AND `artist_map`.`object_type` = 'song' UNION SELECT DISTINCT `album`.`catalog`, 'artist' AS `object_type`, `artist_map`.`artist_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`artist_id` = ? AND `album`.`catalog` > 0 AND `artist_map`.`object_type` = 'album'  UNION  SELECT DISTINCT `song`.`catalog`, 'song_artist' AS `object_type`, `artist_map`.`artist_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`artist_id` = ? AND `song`.`catalog` > 0 AND `artist_map`.`object_type` = 'song' UNION  SELECT DISTINCT `album`.`catalog`, 'album_artist' AS `object_type`, `artist_map`.`artist_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`artist_id` = ? AND `album`.`catalog` > 0 AND `artist_map`.`object_type` = 'album' GROUP BY `catalog`, `object_type`, `artist_map`.`artist_id`;\";\n                Dba::write($sql, array($object_id, $object_id, $object_id, $object_id));\n            } else {\n                $sql = \"REPLACE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) VALUES (?, ?, ?);\";\n                Dba::write($sql, array($catalog, $object_type, $object_id));\n            }\n        }\n    }\n\n    /**\n     * Migrate an object associated catalog to a new object\n     * @param string $object_type\n     * @param integer $old_object_id\n     * @param integer $new_object_id\n     * @return PDOStatement|boolean\n     */\n    public static function migrate_map($object_type, $old_object_id, $new_object_id)\n    {\n        $sql    = \"UPDATE IGNORE `catalog_map` SET `object_id` = ? WHERE `object_type` = ? AND `object_id` = ?\";\n        $params = array($new_object_id, $object_type, $old_object_id);\n\n        return Dba::write($sql, $params);\n    }\n\n    /**\n     * Updates album tags from given album id\n     * @param int $album_id\n     */\n    protected static function updateAlbumTags(int $album_id)\n    {\n        $tags = self::getSongTags('album', $album_id);\n        Tag::update_tag_list(implode(',', $tags), 'album', $album_id, true);\n    }\n\n    /**\n     * Updates artist tags from given song id\n     * @param int $song_id\n     */\n    protected static function updateArtistTags(int $song_id)\n    {\n        foreach (Song::get_parent_array($song_id) as $artist_id) {\n            $tags = self::getSongTags('artist', $artist_id);\n            Tag::update_tag_list(implode(',', $tags), 'artist', $artist_id, true);\n        }\n    }\n\n    /**\n     * Updates artist tags from given song id\n     * @param int $album_id\n     */\n    protected static function updateAlbumArtistTags(int $album_id)\n    {\n        foreach (Song::get_parent_array($album_id, 'album') as $artist_id) {\n            $tags = self::getSongTags('artist', $artist_id);\n            Tag::update_tag_list(implode(',', $tags), 'artist', $artist_id, true);\n        }\n    }\n\n    /**\n     * Get all tags from all Songs from [type] (artist, album, ...)\n     * @param string $type\n     * @param integer $object_id\n     * @return array\n     */\n    protected static function getSongTags($type, $object_id)\n    {\n        $tags       = array();\n        $sql        = ($type == 'artist')\n            ? \"SELECT `tag`.`name` FROM `tag` JOIN `tag_map` ON `tag`.`id` = `tag_map`.`tag_id` JOIN `song` ON `tag_map`.`object_id` = `song`.`id` WHERE `song`.`id` IN (SELECT `object_id` FROM `artist_map` WHERE `artist_id` = ? AND `object_type` = 'song') AND `tag_map`.`object_type` = 'song' GROUP BY `tag`.`id`, `tag`.`name`;\"\n            : \"SELECT `tag`.`name` FROM `tag` JOIN `tag_map` ON `tag`.`id` = `tag_map`.`tag_id` JOIN `song` ON `tag_map`.`object_id` = `song`.`id` WHERE `song`.`$type` = ? AND `tag_map`.`object_type` = 'song' GROUP BY `tag`.`id`, `tag`.`name`;\";\n        $db_results = Dba::read($sql, array($object_id));\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $tags[] = $row['name'];\n        }\n\n        return $tags;\n    }\n\n    /**\n     * @param Artist|Album|Song|Video|Podcast_Episode|TvShow|TVShow_Episode|Label|TVShow_Season $libitem\n     * @param integer|null $user_id\n     * @return boolean\n     */\n    public static function can_remove($libitem, $user_id = null)\n    {\n        if (!$user_id) {\n            $user    = Core::get_global('user');\n            $user_id = $user->id ?? false;\n        }\n\n        if (!$user_id) {\n            return false;\n        }\n\n        if (!AmpConfig::get('delete_from_disk')) {\n            return false;\n        }\n\n        return (\n            Access::check('interface', 75) ||\n            ($libitem->get_user_owner() == $user_id && AmpConfig::get('upload_allow_remove'))\n        );\n    }\n\n    /**\n     * Return full path of the cached music file.\n     * @param integer $object_id\n     * @param string $catalog_id\n     * @return false|string\n     */\n    public static function get_cache_path($object_id, $catalog_id)\n    {\n        $path   = (string)AmpConfig::get('cache_path', '');\n        $target = AmpConfig::get('cache_target');\n        // need a destination and target filetype\n        if ((!is_dir($path) || !$target)) {\n            return false;\n        }\n        // make a folder per catalog\n        if (!is_dir(rtrim(trim($path), '/') . '/' . $catalog_id)) {\n            mkdir(rtrim(trim($path), '/') . '/' . $catalog_id, 0775, true);\n        }\n        // Create subdirectory based on the 2 last digit of the SongID. We prevent having thousands of file in one directory.\n        $path .= '/' . $catalog_id . '/' . substr($object_id, -1, 1) . '/' . substr($object_id, -2, 1) . '/';\n        if (!file_exists($path)) {\n            mkdir($path, 0755, true);\n        }\n\n        return rtrim(trim($path), '/') . '/' . $object_id . '.' . $target;\n    }\n\n    /**\n     * process_action\n     * @param string $action\n     * @param $catalogs\n     * @param array $options\n     * @noinspection PhpMissingBreakStatementInspection\n     */\n    public static function process_action($action, $catalogs, $options = null)\n    {\n        if (empty($options)) {\n            $options = array(\n                'gather_art' => false,\n                'parse_playlist' => false\n            );\n        }\n        // make sure parse_playlist is set\n        if ($action == 'import_to_catalog') {\n            $options['parse_playlist'] = true;\n        }\n        $catalog = null;\n\n        switch ($action) {\n            case 'add_to_all_catalogs':\n                $catalogs = self::get_catalogs();\n                // Intentional break fall-through\n            case 'add_to_catalog':\n            case 'import_to_catalog':\n                if ($catalogs) {\n                    foreach ($catalogs as $catalog_id) {\n                        $catalog = self::create_from_id($catalog_id);\n                        if ($catalog !== null) {\n                            $catalog->add_to_catalog($options);\n                        }\n                    }\n\n                    if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n                        echo AmpError::display('catalog_add');\n                    }\n                }\n                Artist::update_artist_counts();\n                Album::update_album_counts();\n                break;\n            case 'update_all_catalogs':\n                $catalogs = self::get_catalogs();\n                // Intentional break fall-through\n            case 'update_catalog':\n                if ($catalogs) {\n                    foreach ($catalogs as $catalog_id) {\n                        $catalog = self::create_from_id($catalog_id);\n                        if ($catalog !== null) {\n                            $catalog->verify_catalog();\n                        }\n                    }\n                }\n                break;\n            case 'full_service':\n                if (!$catalogs) {\n                    $catalogs = self::get_catalogs();\n                }\n\n                /* This runs the clean/verify/add in that order */\n                foreach ($catalogs as $catalog_id) {\n                    $catalog = self::create_from_id($catalog_id);\n                    if ($catalog !== null) {\n                        $catalog->clean_catalog();\n                        $catalog->verify_catalog();\n                        $catalog->add_to_catalog();\n                    }\n                }\n                break;\n            case 'clean_all_catalogs':\n                $catalogs = self::get_catalogs();\n                // Intentional break fall-through\n            case 'clean_catalog':\n                if ($catalogs) {\n                    foreach ($catalogs as $catalog_id) {\n                        $catalog = self::create_from_id($catalog_id);\n                        if ($catalog !== null) {\n                            $catalog->clean_catalog();\n                        }\n                    } // end foreach catalogs\n                    Dba::optimize_tables();\n                    Artist::update_artist_counts();\n                    Album::update_album_counts();\n                }\n                break;\n            case 'update_from':\n                $catalog_id = 0;\n                // First see if we need to do an add\n                if ($options['add_path'] != '/' && strlen((string)$options['add_path'])) {\n                    if ($catalog_id = Catalog_local::get_from_path($options['add_path'])) {\n                        $catalog = self::create_from_id($catalog_id);\n                        if ($catalog !== null) {\n                            $catalog->add_to_catalog(array('subdirectory' => $options['add_path']));\n                        }\n                    }\n                } // end if add\n\n                // Now check for an update\n                if ($options['update_path'] != '/' && strlen((string)$options['update_path'])) {\n                    if ($catalog_id = Catalog_local::get_from_path($options['update_path'])) {\n                        $songs = Song::get_from_path($options['update_path']);\n                        foreach ($songs as $song_id) {\n                            self::update_single_item('song', $song_id);\n                        }\n                    }\n                } // end if update\n\n                if ($catalog_id < 1) {\n                    AmpError::add('general',\n                        T_(\"This subdirectory is not inside an existing Catalog. The update can not be processed.\"));\n                }\n                break;\n            case 'gather_media_art':\n                if (!$catalogs) {\n                    $catalogs = self::get_catalogs();\n                }\n\n                // Iterate throughout the catalogs and gather as needed\n                foreach ($catalogs as $catalog_id) {\n                    $catalog = self::create_from_id($catalog_id);\n                    if ($catalog !== null) {\n                        require Ui::find_template('show_gather_art.inc.php');\n                        flush();\n                        $catalog->gather_art();\n                    }\n                }\n                break;\n            case 'update_all_file_tags':\n                $catalogs = self::get_catalogs();\n                // Intentional break fall-through\n            case 'update_file_tags':\n                $write_tags     = AmpConfig::get('write_tags', false);\n                AmpConfig::set_by_array(['write_tags' => 'true'], true);\n\n                $songTagWriter = static::getSongTagWriter();\n                set_time_limit(0);\n                foreach ($catalogs as $catalog_id) {\n                    $catalog = self::create_from_id($catalog_id);\n                    if ($catalog !== null) {\n                        $song_ids = $catalog->get_song_ids();\n                        foreach ($song_ids as $song_id) {\n                            $song = new Song($song_id);\n                            $song->format();\n\n                            $songTagWriter->write($song);\n                        }\n                    }\n                }\n                AmpConfig::set_by_array(['write_tags' => $write_tags], true);\n        }\n\n        if ($catalog) {\n            // clean up after the action\n            debug_event(__CLASS__, 'Run Garbage collection', 5);\n            static::getCatalogGarbageCollector()->collect();\n            $catalog_media_type = $catalog->get_gather_type();\n            if ($catalog_media_type == 'music') {\n                self::clean_empty_albums();\n                Album::update_album_artist();\n                self::update_mapping('artist');\n                self::update_mapping('album');\n            } elseif ($catalog_media_type == 'podcast') {\n                self::update_mapping('podcast');\n                self::update_mapping('podcast_episode');\n            } elseif (in_array($catalog_media_type, array('clip', 'tvshow', 'movie', 'personal_video'))) {\n                self::update_mapping('video');\n            }\n            self::update_counts();\n        }\n    }\n\n    /**\n     * Migrate an object associate images to a new object\n     * @param string $object_type\n     * @param integer $old_object_id\n     * @param integer $new_object_id\n     * @param integer $song_id\n     * @return boolean\n     */\n    public static function migrate($object_type, $old_object_id, $new_object_id, $song_id)\n    {\n        if ($old_object_id != $new_object_id) {\n            debug_event(__CLASS__, \"migrate $song_id $object_type: {{$old_object_id}} to {{$new_object_id}}\", 4);\n\n            Stats::migrate($object_type, $old_object_id, $new_object_id, $song_id);\n            Useractivity::migrate($object_type, $old_object_id, $new_object_id);\n            Recommendation::migrate($object_type, $old_object_id);\n            Share::migrate($object_type, $old_object_id, $new_object_id);\n            Shoutbox::migrate($object_type, $old_object_id, $new_object_id);\n            Tag::migrate($object_type, $old_object_id, $new_object_id);\n            Userflag::migrate($object_type, $old_object_id, $new_object_id);\n            Rating::migrate($object_type, $old_object_id, $new_object_id);\n            Art::duplicate($object_type, $old_object_id, $new_object_id);\n            Playlist::migrate($object_type, $old_object_id, $new_object_id);\n            Label::migrate($object_type, $old_object_id, $new_object_id);\n            Wanted::migrate($object_type, $old_object_id, $new_object_id);\n            Metadata::migrate($object_type, $old_object_id, $new_object_id);\n            Bookmark::migrate($object_type, $old_object_id, $new_object_id);\n            self::migrate_map($object_type, $old_object_id, $new_object_id);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * xml_get_footer\n     * This takes the type and returns the correct xml footer\n     * @param string $type\n     * @return string\n     */\n    private static function xml_get_footer($type)\n    {\n        switch ($type) {\n            case 'itunes':\n                return \"      </dict>\\n\" .\n                    \"</dict>\\n\" .\n                    \"</plist>\\n\";\n            case 'xspf':\n                return \"      </trackList>\\n\" .\n                    \"</playlist>\\n\";\n            default:\n                return '';\n        }\n    } // xml_get_footer\n\n    /**\n     * xml_get_header\n     * This takes the type and returns the correct xml header\n     * @param string $type\n     * @return string\n     */\n    private static function xml_get_header($type)\n    {\n        switch ($type) {\n            case 'itunes':\n                return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" .\n                    \"<!DOCTYPE plist PUBLIC \\\"-//Apple Computer//DTD PLIST 1.0//EN\\\"\\n\" .\n                    \"\\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\">\\n\" .\n                    \"<plist version=\\\"1.0\\\">\\n\" .\n                    \"<dict>\\n\" .\n                    \"       <key>Major Version</key><integer>1</integer>\\n\" .\n                    \"       <key>Minor Version</key><integer>1</integer>\\n\" .\n                    \"       <key>Application Version</key><string>7.0.2</string>\\n\" .\n                    \"       <key>Features</key><integer>1</integer>\\n\" .\n                    \"       <key>Show Content Ratings</key><true/>\\n\" .\n                    \"       <key>Tracks</key>\\n\" .\n                    \"       <dict>\\n\";\n            case 'xspf':\n                return \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\\n\" .\n                    \"<!-- XML Generated by Ampache v.\" . AmpConfig::get('version') . \" -->\";\n            default:\n                return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n        }\n    } // xml_get_header\n\n    /**\n     * @deprecated\n     */\n    private static function getSongRepository(): SongRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(SongRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private static function getAlbumRepository(): AlbumRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(AlbumRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private static function getCatalogGarbageCollector(): CatalogGarbageCollectorInterface\n    {\n        global $dic;\n\n        return $dic->get(CatalogGarbageCollectorInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private static function getSongTagWriter(): SongTagWriterInterface\n    {\n        global $dic;\n\n        return $dic->get(SongTagWriterInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private static function getLabelRepository(): LabelRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(LabelRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private static function getLicenseRepository(): LicenseRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(LicenseRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated inject by constructor\n     */\n    private static function getConfigContainer(): ConfigContainerInterface\n    {\n        global $dic;\n\n        return $dic->get(ConfigContainerInterface::class);\n    }\n\n    /**\n     * @deprecated Inject by constructor\n     */\n    private function getUtilityFactory(): UtilityFactoryInterface\n    {\n        global $dic;\n\n        return $dic->get(UtilityFactoryInterface::class);\n    }\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Repository\\Model;\n\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\ShoutRepositoryInterface;\nuse Ampache\\Repository\\UserActivityRepositoryInterface;\nuse PDOStatement;\n\nclass TVShow_Season extends database_object implements library_item, GarbageCollectibleInterface\n{\n    protected const DB_TABLENAME = 'tvshow_season';\n\n    /* Variables from DB */\n    public $id;\n    public $season_number;\n    public $tvshow;\n\n    public $catalog_id;\n    public $episodes;\n    public $f_name;\n    public $f_tvshow;\n    public $f_tvshow_link;\n    public $link;\n    public $f_link;\n\n    // Constructed vars\n    private static $_mapcache = array();\n\n    /**\n     * TV Show\n     * Takes the ID of the tv show season and pulls the info from the db\n     * @param $show_id\n     */\n    public function __construct($show_id)\n    {\n        /* Get the information from the db */\n        $info = $this->get_info($show_id);\n\n        foreach ($info as $key => $value) {\n            $this->$key = $value;\n        } // foreach info\n\n        return true;\n    } // constructor\n\n    public function getId(): int\n    {\n        return (int)$this->id;\n    }\n\n    /**\n     * garbage_collection\n     *\n     * This cleans out unused tv shows seasons\n     */\n    public static function garbage_collection()\n    {\n        $sql = \"DELETE FROM `tvshow_season` USING `tvshow_season` LEFT JOIN `tvshow_episode` ON `tvshow_episode`.`season` = `tvshow_season`.`id` WHERE `tvshow_episode`.`id` IS NULL\";\n        Dba::write($sql);\n    }\n\n    /**\n     * get_songs\n     * gets all episodes for this tv show season\n     * @return array\n     */\n    public function get_episodes()\n    {\n        $sql = (AmpConfig::get('catalog_disable'))\n            ? \"SELECT `tvshow_episode`.`id` FROM `tvshow_episode` LEFT JOIN `video` ON `video`.`id` = `tvshow_episode`.`id` LEFT JOIN `catalog` ON `catalog`.`id` = `video`.`catalog` WHERE `tvshow_episode`.`season`='\" . Dba::escape($this->id) . \"' AND `catalog`.`enabled` = '1' \"\n            : \"SELECT `tvshow_episode`.`id` FROM `tvshow_episode` WHERE `tvshow_episode`.`season`='\" . Dba::escape($this->id) . \"' \";\n        $sql .= \"ORDER BY `tvshow_episode`.`episode_number`\";\n\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row['id'];\n        }\n\n        return $results;\n    } // get_episodes\n\n    /**\n     * _get_extra info\n     * This returns the extra information for the tv show season, this means totals etc\n     * @return array\n     */\n    private function _get_extra_info()\n    {\n        // Try to find it in the cache and save ourselves the trouble\n        if (parent::is_cached('tvshow_extra', $this->id)) {\n            $row = parent::get_from_cache('tvshow_extra', $this->id);\n        } else {\n            $sql = \"SELECT COUNT(`tvshow_episode`.`id`) AS `episode_count`, `video`.`catalog` AS `catalog_id` FROM `tvshow_episode` LEFT JOIN `video` ON `video`.`id` = `tvshow_episode`.`id` WHERE `tvshow_episode`.`season` = ?GROUP BY `catalog_id`\";\n\n            $db_results = Dba::read($sql, array($this->id));\n            $row        = Dba::fetch_assoc($db_results);\n            parent::add_to_cache('tvshow_extra', $this->id, $row);\n        }\n\n        /* Set Object Vars */\n        $this->episodes   = $row['episode_count'];\n        $this->catalog_id = $row['catalog_id'];\n\n        return $row;\n    } // _get_extra_info\n\n    /**\n     * format\n     * this function takes the object and formats some values\n     * @param boolean $details\n     * @return boolean\n     */\n    public function format($details = true)\n    {\n        $tvshow = new TvShow($this->tvshow);\n        $tvshow->format($details);\n        $this->f_tvshow      = $tvshow->get_link();\n        $this->f_tvshow_link = $tvshow->f_link;\n\n        $this->f_link = '<a href=\"' . $this->get_link() . '\" title=\"' . $tvshow->get_fullname() . ' - ' . scrub_out($this->get_fullname()) . '\">' . scrub_out($this->get_fullname()) . '</a>';\n\n        if ($details) {\n            $this->_get_extra_info();\n        }\n\n        return true;\n    }\n\n    /**\n     * Get item keywords for metadata searches.\n     * @return array\n     */\n    public function get_keywords()\n    {\n        $keywords           = array();\n        $keywords['tvshow'] = array(\n            'important' => true,\n            'label' => T_('TV Show'),\n            'value' => $this->f_tvshow\n        );\n        $keywords['tvshow_season'] = array(\n            'important' => false,\n            'label' => T_('Season'),\n            'value' => $this->season_number\n        );\n        $keywords['type'] = array(\n            'important' => false,\n            'label' => null,\n            'value' => 'tvshow'\n        );\n\n        return $keywords;\n    }\n\n    /**\n     * @return string\n     */\n    public function get_fullname()\n    {\n        // don't do anything if it's formatted\n        if (!isset($this->f_name)) {\n            $this->f_name = T_('Season') . ' ' . $this->season_number;\n        }\n\n        return $this->f_name;\n    }\n\n    /**\n     * Get item link.\n     * @return string\n     */\n    public function get_link()\n    {\n        // don't do anything if it's formatted\n        if (!isset($this->link)) {\n            $web_path   = AmpConfig::get('web_path');\n            $this->link = $web_path . '/tvshow_seasons.php?action=show&season=' . $this->id;\n        }\n\n        return $this->link;\n    }\n\n    /**\n     * @return array\n     */\n    public function get_parent()\n    {\n        return array('object_type' => 'tvshow', 'object_id' => $this->tvshow);\n    }\n\n    /**\n     * @return array\n     */\n    public function get_childrens()\n    {\n        return array('tvshow_episode' => $this->get_episodes());\n    }\n\n    /**\n     * @param string $name\n     * @return array\n     */\n    public function search_childrens($name)\n    {\n        debug_event(self::class, 'search_childrens ' . $name, 5);\n\n        return array();\n    }\n\n    /**\n     * get_medias\n     * @param string $filter_type\n     * @return array\n     */\n    public function get_medias($filter_type = null)\n    {\n        $medias = array();\n        if ($filter_type === null || $filter_type == 'video') {\n            $episodes = $this->get_episodes();\n            foreach ($episodes as $episode_id) {\n                $medias[] = array(\n                    'object_type' => 'video',\n                    'object_id' => $episode_id\n                );\n            }\n        }\n\n        return $medias;\n    }\n\n    /**\n     * get_catalogs\n     *\n     * Get all catalog ids related to this item.\n     * @return integer[]\n     */\n    public function get_catalogs()\n    {\n        return array($this->catalog_id);\n    }\n\n    /**\n     * @return mixed|null\n     */\n    public function get_user_owner()\n    {\n        return null;\n    }\n\n    /**\n     * @return string\n     */\n    public function get_default_art_kind()\n    {\n        return 'default';\n    }\n\n    /**\n     * @return mixed\n     */\n    public function get_description()\n    {\n        // No season description for now, always return tvshow description\n        $tvshow = new TvShow($this->tvshow);\n\n        return $tvshow->get_description();\n    }\n\n    /**\n     * display_art\n     * @param integer $thumb\n     * @param boolean $force\n     */\n    public function display_art($thumb = 2, $force = false)\n    {\n        $tvshow_id = null;\n        $type      = null;\n\n        if (Art::has_db($this->id, 'tvshow_season')) {\n            $tvshow_id = $this->id;\n            $type      = 'tvshow_season';\n        } else {\n            if (Art::has_db($this->tvshow, 'tvshow') || $force) {\n                $tvshow_id = $this->tvshow;\n                $type      = 'tvshow';\n            }\n        }\n\n        if ($tvshow_id !== null && $type !== null) {\n            Art::display($type, $tvshow_id, $this->get_fullname(), $thumb, $this->get_link());\n        }\n    }\n\n    /**\n     * check\n     *\n     * Checks for an existing tv show season; if none exists, insert one.\n     * @param $tvshow\n     * @param $season_number\n     * @param boolean $readonly\n     * @return string|null\n     */\n    public static function check($tvshow, $season_number, $readonly = false)\n    {\n        $name = $tvshow . '_' . $season_number;\n        // null because we don't have any unique id like mbid for now\n        if (isset(self::$_mapcache[$name]['null'])) {\n            return self::$_mapcache[$name]['null'];\n        }\n\n        $object_id  = 0;\n        $exists     = false;\n        $sql        = 'SELECT `id` FROM `tvshow_season` WHERE `tvshow` = ? AND `season_number` = ?';\n        $db_results = Dba::read($sql, array($tvshow, $season_number));\n        $id_array   = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $key            = 'null';\n            $id_array[$key] = $row['id'];\n        }\n\n        if (count($id_array)) {\n            $object_id = array_shift($id_array);\n            $exists    = true;\n        }\n\n        if ($exists && (int)$object_id > 0) {\n            self::$_mapcache[$name]['null'] = $object_id;\n\n            return $object_id;\n        }\n\n        if ($readonly) {\n            return null;\n        }\n\n        $sql = 'INSERT INTO `tvshow_season` (`tvshow`, `season_number`) ' . 'VALUES(?, ?)';\n\n        $db_results = Dba::write($sql, array($tvshow, $season_number));\n        if (!$db_results) {\n            return null;\n        }\n        $object_id = Dba::insert_id();\n\n        self::$_mapcache[$name]['null'] = $object_id;\n\n        return $object_id;\n    }\n\n    /**\n     * update\n     * This takes a key'd array of data and updates the current tv show\n     * @param array $data\n     * @return mixed\n     */\n    public function update(array $data)\n    {\n        $sql = 'UPDATE `tvshow_season` SET `season_number` = ?, `tvshow` = ? WHERE `id` = ?';\n        Dba::write($sql, array($data['season_number'], $data['tvshow'], $this->id));\n\n        return $this->id;\n    } // update\n\n    /**\n     * @return PDOStatement|boolean\n     */\n    public function remove()\n    {\n        $deleted = true;\n        $videos  = $this->get_episodes();\n        foreach ($videos as $video_id) {\n            $video   = Video::create_from_id($video_id);\n            $deleted = $video->remove();\n            if (!$deleted) {\n                debug_event(self::class, 'Error when deleting the video `' . $video_id . '`.', 1);\n                break;\n            }\n        }\n\n        if ($deleted) {\n            $sql     = \"DELETE FROM `tvshow_season` WHERE `id` = ?\";\n            $deleted = Dba::write($sql, array($this->id));\n            if ($deleted) {\n                Art::garbage_collection('tvshow_season', $this->id);\n                Userflag::garbage_collection('tvshow_season', $this->id);\n                Rating::garbage_collection('tvshow_season', $this->id);\n                $this->getShoutRepository()->collectGarbage('tvshow_season', $this->getId());\n                $this->getUseractivityRepository()->collectGarbage('tvshow_season', $this->getId());\n            }\n        }\n\n        return $deleted;\n    }\n\n    /**\n     * @param $tvshow_id\n     * @param $season_id\n     * @return PDOStatement|boolean\n     */\n    public static function update_tvshow($tvshow_id, $season_id)\n    {\n        $sql = \"UPDATE `tvshow_season` SET `tvshow` = ? WHERE `id` = ?\";\n\n        return Dba::write($sql, array($tvshow_id, $season_id));\n    }\n\n    /**\n     * @deprecated\n     */\n    private function getShoutRepository(): ShoutRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(ShoutRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private function getUseractivityRepository(): UserActivityRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(UserActivityRepositoryInterface::class);\n    }\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Repository\\Model;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\Util\\InterfaceImplementationChecker;\nuse PDOStatement;\n\n/**\n * Tag Class\n *\n * This class handles all of the genre related operations\n *\n */\nclass Tag extends database_object implements library_item, GarbageCollectibleInterface\n{\n    protected const DB_TABLENAME = 'tag';\n\n    public $id;\n    public $name;\n    public $f_name;\n    public $is_hidden;\n\n    /**\n     * constructor\n     * This takes a tag id and returns all of the relevant information\n     * @param $tag_id\n     */\n    public function __construct($tag_id)\n    {\n        if (!$tag_id) {\n            return false;\n        }\n\n        $info = $this->get_info($tag_id);\n        if (empty($info)) {\n            return false;\n        }\n\n        foreach ($info as $key => $value) {\n            $this->$key = $value;\n        } // end foreach\n\n        // the ui is sometimes looking for a formatted name...\n        $this->f_name = scrub_out($this->name);\n\n        return true;\n    } // constructor\n\n    public function getId(): int\n    {\n        return (int)$this->id;\n    }\n\n    /**\n     * construct_from_name\n     * This attempts to construct the tag from a name, rather then the ID\n     * @param string $name\n     * @return Tag\n     */\n    public static function construct_from_name($name)\n    {\n        $tag_id = self::tag_exists($name);\n\n        return new Tag($tag_id);\n    } // construct_from_name\n\n    /**\n     * build_cache\n     * This takes an array of object ids and caches all of their information\n     * in a single query, cuts down on the connections\n     * @param array $ids\n     * @return boolean\n     */\n    public static function build_cache($ids)\n    {\n        if (empty($ids)) {\n            return false;\n        }\n        $idlist     = '(' . implode(',', $ids) . ')';\n        $sql        = \"SELECT * FROM `tag` WHERE `id` IN $idlist\";\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            parent::add_to_cache('tag', $row['id'], $row);\n        }\n\n        return true;\n    } // build_cache\n\n    /**\n     * build_map_cache\n     * This builds a cache of the mappings for the specified object, no limit is given\n     * @param string $type\n     * @param $ids\n     * @return boolean\n     * @params array $ids\n     */\n    public static function build_map_cache($type, $ids)\n    {\n        if (!is_array($ids) || !count($ids)) {\n            return false;\n        }\n\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return false;\n        }\n\n        $idlist = '(' . implode(',', $ids) . ')';\n\n        $sql = \"SELECT `tag_map`.`id`, `tag_map`.`tag_id`, `tag`.`name`, `tag_map`.`object_id`, `tag_map`.`user` FROM `tag` LEFT JOIN `tag_map` ON `tag_map`.`tag_id`=`tag`.`id` WHERE `tag`.`is_hidden` = false AND `tag_map`.`object_type`='$type' AND `tag_map`.`object_id` IN $idlist\";\n\n        $db_results = Dba::read($sql);\n\n        $tags    = array();\n        $tag_map = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $tags[$row['object_id']][$row['tag_id']] = array(\n                'user' => $row['user'],\n                'id' => $row['tag_id'],\n                'name' => $row['name']\n            );\n            $tag_map[$row['object_id']] = array(\n                'id' => $row['id'],\n                'tag_id' => $row['tag_id'],\n                'user' => $row['user'],\n                'object_type' => $type,\n                'object_id' => $row['object_id']\n            );\n        }\n\n        // Run through our original ids as we also want to cache NULL\n        // results\n        foreach ($ids as $tagid) {\n            if (!isset($tags[$tagid])) {\n                $tags[$tagid]    = null;\n                $tag_map[$tagid] = null;\n            }\n            parent::add_to_cache('tag_top_' . $type, $tagid, array($tags[$tagid]));\n            parent::add_to_cache('tag_map_' . $type, $tagid, array($tag_map[$tagid]));\n        }\n\n        return true;\n    } // build_map_cache\n\n    /**\n     * add\n     * This is a wrapper function, it figures out what we need to add, be it a tag\n     * and map, or just the mapping\n     * @param string $type\n     * @param integer $object_id\n     * @param string $value\n     * @param boolean $user\n     * @return bool|int\n     */\n    public static function add($type, $object_id, $value, $user = true)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return false;\n        }\n\n        if (!is_numeric($object_id)) {\n            return false;\n        }\n\n        $cleaned_value = str_replace('Folk, World, & Country', 'Folk World & Country', $value);\n\n        if (!strlen((string)$cleaned_value)) {\n            return false;\n        }\n\n        if ($user === true) {\n            $uid = (int)(Core::get_global('user')->id);\n        } else {\n            $uid = (int)($user);\n        }\n\n        // Check and see if the tag exists, if not create it, we need the tag id from this\n        if (!$tag_id = self::tag_exists($cleaned_value)) {\n            debug_event(self::class, 'Adding new tag {' . $cleaned_value . '}', 5);\n            $tag_id = self::add_tag($cleaned_value);\n        }\n\n        if (!$tag_id) {\n            debug_event(self::class, 'Error unable to create tag value:' . $cleaned_value . ' unknown error', 1);\n\n            return false;\n        }\n\n        // We've got the tag id, let's see if it's already got a map, if not then create the map and return the value\n        if (!$map_id = self::tag_map_exists($type, $object_id, (int)$tag_id, $uid)) {\n            $map_id = self::add_tag_map($type, $object_id, (int)$tag_id, $user);\n        }\n\n        return (int)$map_id;\n    } // add\n\n    /**\n     * add_tag\n     * This function adds a new tag, for now we're going to limit the tagging a bit\n     * @param string $value\n     * @return int|null\n     */\n    public static function add_tag($value)\n    {\n        if (!strlen((string)$value)) {\n            return null;\n        }\n\n        $sql = \"REPLACE INTO `tag` SET `name` = ?\";\n        Dba::write($sql, array($value));\n        $insert_id = (int)Dba::insert_id();\n\n        parent::add_to_cache('tag_name', $value, array($insert_id));\n\n        return $insert_id;\n    } // add_tag\n\n    /**\n     * update\n     * Update the name of the tag\n     * @param array $data\n     * @return boolean\n     */\n    public function update(array $data)\n    {\n        if (!strlen((string)$data['name'])) {\n            return false;\n        }\n        $name      = $data['name'] ?? $this->name;\n        $is_hidden = (array_key_exists('is_hidden', $data))\n            ? (int)$data['is_hidden']\n            : 0;\n\n        if ($name != $this->name) {\n            debug_event(self::class, 'Updating tag {' . $this->id . '} with name {' . $data['name'] . '}...', 5);\n            $sql = 'UPDATE `tag` SET `name` = ? WHERE `id` = ?';\n            Dba::write($sql, array($name, $this->id));\n        }\n        if ($is_hidden != (int)$this->is_hidden) {\n            debug_event(self::class, 'Hidden tag {' . $this->id . '} with status {' . $is_hidden . '}...', 5);\n            $sql = 'UPDATE `tag` SET `is_hidden` = ? WHERE `id` = ?';\n            Dba::write($sql, array($is_hidden, $this->id));\n            // if you had previously hidden this tag then remove the merges too\n            if ($is_hidden == 0 && (int)$this->is_hidden == 1) {\n                debug_event(self::class, 'Unhiding tag {' . $this->id . '} removing all previous merges', 5);\n                $this->remove_merges();\n            }\n            $this->is_hidden = $is_hidden;\n        }\n\n        if (array_key_exists('edit_tags', $data) && $data['edit_tags']) {\n            $filterfolk  = str_replace('Folk, World, & Country', 'Folk World & Country', $data['edit_tags']);\n            $filterunder = str_replace('_', ', ', $filterfolk);\n            $filter      = str_replace(';', ', ', $filterunder);\n            $filter_list = preg_split('/(\\s*,*\\s*)*,+(\\s*,*\\s*)*/', $filter);\n            $tag_names   = (is_array($filter_list)) ? array_unique($filter_list) : array();\n\n            foreach ($tag_names as $tag) {\n                $merge_to = self::construct_from_name($tag);\n                if ($merge_to->id == 0) {\n                    self::add_tag($tag);\n                    $merge_to = self::construct_from_name($tag);\n                }\n                $this->merge($merge_to->id, array_key_exists('merge_persist', $data));\n            }\n            if (!array_key_exists('keep_existing', $data)) {\n                $sql = \"DELETE FROM `tag_map` WHERE `tag_map`.`tag_id` = ? \";\n                Dba::write($sql, array($this->id));\n                if (!array_key_exists('merge_persist', $data)) {\n                    $this->delete();\n                } else {\n                    $sql = \"UPDATE `tag` SET `is_hidden` = 1 WHERE `tag`.`id` = ? \";\n                    Dba::write($sql, array($this->id));\n                }\n            }\n        }\n\n        return $this->id;\n    } // add_tag\n\n    /**\n     * merge\n     * merges this tag to another one.\n     * @param integer $merge_to\n     * @param boolean $is_persistent\n     */\n    public function merge($merge_to, $is_persistent)\n    {\n        if ($this->id != $merge_to) {\n            debug_event(self::class, 'Merging tag ' . $this->id . ' into ' . $merge_to . ')...', 5);\n\n            $sql = \"REPLACE INTO `tag_map` (`tag_id`, `user`, `object_type`, `object_id`) SELECT \" . $merge_to . \",`user`, `object_type`, `object_id` FROM `tag_map` AS `tm` WHERE `tm`.`tag_id` = \" . $this->id . \" AND NOT EXISTS (SELECT 1 FROM `tag_map` WHERE `tag_map`.`tag_id` = \" . $merge_to . \" AND `tag_map`.`object_id` = `tm`.`object_id` AND `tag_map`.`object_type` = `tm`.`object_type` AND `tag_map`.`user` = `tm`.`user`)\";\n            Dba::write($sql);\n            if ($is_persistent) {\n                $sql = \"REPLACE INTO `tag_merge` (`tag_id`, `merged_to`) VALUES (?, ?)\";\n                Dba::write($sql, array($this->id, $merge_to));\n            }\n        }\n    }\n\n    /**\n     * get_merged_tags\n     * Get merged tags to this tag.\n     * @return array\n     */\n    public function get_merged_tags()\n    {\n        $sql = \"SELECT `tag`.`id`, `tag`.`name`FROM `tag_merge` INNER JOIN `tag` ON `tag`.`id` = `tag_merge`.`merged_to` WHERE `tag_merge`.`tag_id` = ? ORDER BY `tag`.`name` \";\n\n        $db_results = Dba::read($sql, array($this->id));\n\n        $results = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['id']] = array('id' => $row['id'], 'name' => $row['name']);\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_merged_count\n     * @return int\n     */\n    public static function get_merged_count()\n    {\n        $results    = 0;\n        $sql        = \"SELECT COUNT(DISTINCT `tag_id`) AS `tag_count` FROM `tag_merge`;\";\n        $db_results = Dba::read($sql);\n\n        if ($row = Dba::fetch_assoc($db_results)) {\n            $results = (int)$row['tag_count'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * has_merge\n     * Get merged tags to this tag.\n     * @param string $name\n     * @return bool\n     */\n    public function has_merge($name)\n    {\n        $sql        = \"SELECT `tag`.`name` FROM `tag_merge` INNER JOIN `tag` ON `tag`.`id` = `tag_merge`.`merged_to` WHERE `tag_merge`.`tag_id` = ? ORDER BY `tag`.`name` \";\n        $db_results = Dba::read($sql, array($this->id));\n        while ($row = Dba::fetch_assoc($db_results)) {\n            if ($name == $row['name']) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * remove_merges\n     * Remove merged tags from this tag.\n     */\n    public function remove_merges()\n    {\n        $sql = \"DELETE FROM `tag_merge` WHERE `tag_merge`.`tag_id` = ?;\";\n        Dba::write($sql, array($this->id));\n    }\n\n    /**\n     * add_tag_map\n     * This adds a specific tag to the map for specified object\n     * @param string $type\n     * @param integer|string $object_id\n     * @param integer|string $tag_id\n     * @param boolean $user\n     * @return boolean|int\n     */\n    public static function add_tag_map($type, $object_id, $tag_id, $user = true)\n    {\n        if ($user === true) {\n            $uid = (int)(Core::get_global('user')->id);\n        } else {\n            $uid = (int)($user);\n        }\n\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            debug_event(__CLASS__, $type . \" is not a library item.\", 3);\n\n            return false;\n        }\n        $tag_id  = (int)($tag_id);\n        $item_id = (int)($object_id);\n\n        if (!$tag_id || !$item_id) {\n            return false;\n        }\n\n        // If tag merged to another one, add reference to the merge destination\n        $parent = new Tag($tag_id);\n        $merges = $parent->get_merged_tags();\n        if (!$parent->is_hidden) {\n            $merges[] = array('id' => $parent->id, 'name' => $parent->name);\n        }\n        foreach ($merges as $tag) {\n            $sql = \"INSERT IGNORE INTO `tag_map` (`tag_id`, `user`, `object_type`, `object_id`) VALUES (?, ?, ?, ?)\";\n            Dba::write($sql, array($tag['id'], $uid, $type, $item_id));\n        }\n        $insert_id = (int)Dba::insert_id();\n\n        parent::add_to_cache('tag_map_' . $type, $insert_id, array('tag_id' => $tag_id, 'user' => $uid, 'object_type' => $type, 'object_id' => $item_id));\n\n        return $insert_id;\n    } // add_tag_map\n\n    /**\n     * garbage_collection\n     *\n     * This cleans out tag_maps that are obsolete and then removes tags that\n     * have no maps.\n     */\n    public static function garbage_collection()\n    {\n        $sql = \"DELETE FROM `tag_map` USING `tag_map` LEFT JOIN `song` ON `song`.`id`=`tag_map`.`object_id` WHERE `tag_map`.`object_type`='song' AND `song`.`id` IS NULL\";\n        Dba::write($sql);\n\n        $sql = \"DELETE FROM `tag_map` USING `tag_map` LEFT JOIN `album` ON `album`.`id`=`tag_map`.`object_id` WHERE `tag_map`.`object_type`='album' AND `album`.`id` IS NULL\";\n        Dba::write($sql);\n\n        $sql = \"DELETE FROM `tag_map` USING `tag_map` LEFT JOIN `artist` ON `artist`.`id`=`tag_map`.`object_id` WHERE `tag_map`.`object_type`='artist' AND `artist`.`id` IS NULL\";\n        Dba::write($sql);\n\n        // Now nuke the tags themselves\n        $sql = \"DELETE FROM `tag` USING `tag` LEFT JOIN `tag_map` ON `tag`.`id`=`tag_map`.`tag_id` WHERE `tag_map`.`id` IS NULL AND NOT EXISTS (SELECT 1 FROM `tag_merge` WHERE `tag_merge`.`tag_id` = `tag`.`id`)\";\n        Dba::write($sql);\n\n        // delete duplicates\n        $sql = \"DELETE `b` FROM `tag_map` AS `a`, `tag_map` AS `b` WHERE `a`.`id` < `b`.`id` AND `a`.`tag_id` <=> `b`.`tag_id` AND `a`.`object_id` <=> `b`.`object_id` AND `a`.`object_type` <=> `b`.`object_type`\";\n        Dba::write($sql);\n    }\n\n    /**\n     * delete\n     *\n     * Delete the tag and all maps\n     */\n    public function delete()\n    {\n        $sql = \"DELETE FROM `tag_map` WHERE `tag_map`.`tag_id` = ?\";\n        Dba::write($sql, array($this->id));\n\n        $sql = \"DELETE FROM `tag_merge` WHERE `tag_merge`.`tag_id` = ?\";\n        Dba::write($sql, array($this->id));\n\n        $sql = \"DELETE FROM `tag` WHERE `tag`.`id` = ? \";\n        Dba::write($sql, array($this->id));\n\n        // Call the garbage collector to clean everything\n        self::garbage_collection();\n\n        parent::clear_cache();\n    }\n\n    /**\n     * tag_exists\n     * This checks to see if a tag exists, this has nothing to do with objects or maps\n     * @param string $value\n     * @return integer\n     */\n    public static function tag_exists($value)\n    {\n        if (parent::is_cached('tag_name', $value)) {\n            return (int)(parent::get_from_cache('tag_name', $value))[0];\n        }\n\n        $sql        = \"SELECT `id` FROM `tag` WHERE `name` = ?\";\n        $db_results = Dba::read($sql, array($value));\n        $results    = Dba::fetch_assoc($db_results);\n\n        if (array_key_exists('id', $results)) {\n            parent::add_to_cache('tag_name', $value, array($results['id']));\n\n            return (int)$results['id'];\n        }\n\n        return 0;\n    } // tag_exists\n\n    /**\n     * tag_map_exists\n     * This looks to see if the current mapping of the current object of the current tag of the current\n     * user exists, lots of currents... taste good in scones.\n     * @param string $type\n     * @param integer $object_id\n     * @param integer $tag_id\n     * @param integer $user\n     * @return bool|int\n     */\n    public static function tag_map_exists($type, $object_id, $tag_id, $user)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            debug_event(__CLASS__, 'Requested type is not a library item.', 3);\n\n            return false;\n        }\n\n        $sql        = \"SELECT * FROM `tag_map` LEFT JOIN `tag` ON `tag`.`id` = `tag_map`.`tag_id` LEFT JOIN `tag_merge` ON `tag`.`id`=`tag_merge`.`tag_id` WHERE (`tag_map`.`tag_id` = ? OR `tag_map`.`tag_id` = `tag_merge`.`merged_to`) AND `tag_map`.`user` = ? AND `tag_map`.`object_id` = ? AND `tag_map`.`object_type` = ?\";\n        $db_results = Dba::read($sql, array($tag_id, $user, $object_id, $type));\n        $results    = Dba::fetch_assoc($db_results);\n\n        if (array_key_exists('id', $results)) {\n            return (int)$results['id'];\n        }\n\n        return false;\n    } // tag_map_exists\n\n    /**\n     * get_top_tags\n     * This gets the top tags for the specified object using limit\n     * @param string $type\n     * @param integer $object_id\n     * @param integer $limit\n     * @return array\n     */\n    public static function get_top_tags($type, $object_id, $limit = 10)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return array();\n        }\n\n        $object_id = (int)($object_id);\n\n        $limit = (int)($limit);\n        $sql   = \"SELECT `tag_map`.`id`, `tag_map`.`tag_id`, `tag`.`name`, `tag_map`.`user` FROM `tag` LEFT JOIN `tag_map` ON `tag_map`.`tag_id`=`tag`.`id` WHERE `tag`.`is_hidden` = false AND `tag_map`.`object_type` = ? AND `tag_map`.`object_id` = ?LIMIT $limit\";\n\n        $db_results = Dba::read($sql, array($type, $object_id));\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['id']] = array('user' => $row['user'], 'id' => $row['tag_id'], 'name' => $row['name']);\n        }\n\n        return $results;\n    } // get_top_tags\n\n    /**\n     * get_object_tags\n     * Display all tags that apply to matching target type of the specified id\n     * @param string $type\n     * @param integer $object_id\n     * @return array|boolean\n     */\n    public static function get_object_tags($type, $object_id = null)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return false;\n        }\n\n        $params = array($type);\n        $sql    = \"SELECT `tag_map`.`id`, `tag`.`name`, `tag_map`.`user` FROM `tag` LEFT JOIN `tag_map` ON `tag_map`.`tag_id`=`tag`.`id` WHERE `tag`.`is_hidden` = false AND `tag_map`.`object_type` = ?\";\n        if ($object_id !== null) {\n            $sql .= \" AND `tag_map`.`object_id` = ?\";\n            $params[] = $object_id;\n        }\n        $results    = array();\n        $db_results = Dba::read($sql, $params);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row;\n        }\n\n        return $results;\n    } // get_object_tags\n\n    /**\n     * get_tag_objects\n     * This gets the objects from a specified tag and returns an array of object ids, nothing more\n     * @param string $type\n     * @param $tag_id\n     * @param string $count\n     * @param string $offset\n     * @return integer[]\n     */\n    public static function get_tag_objects($type, $tag_id, $count = '', $offset = '')\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return array();\n        }\n        $tag_sql   = ((int) $tag_id == 0) ? \"\" : \"`tag_map`.`tag_id` = ? AND\";\n        $sql_param = ($tag_sql == \"\") ? array($type) : array($tag_id, $type);\n        $limit_sql = \"\";\n        if ($count) {\n            $limit_sql = \" LIMIT \";\n            if ($offset) {\n                $limit_sql .= (string)($offset) . ', ';\n            }\n            $limit_sql .= (string)($count);\n        }\n\n        $sql = ($type == 'album')\n            ? \"SELECT DISTINCT MIN(`tag_map`.`object_id`) AS `object_id` FROM `tag_map` LEFT JOIN `album` ON `tag_map`.`object_id` = `album`.`id` \"\n            : \"SELECT DISTINCT `tag_map`.`object_id` FROM `tag_map` \";\n        $sql .= \"WHERE $tag_sql `tag_map`.`object_type` = ?\";\n        if (AmpConfig::get('catalog_disable') && in_array($type, array('song', 'artist', 'album'))) {\n            $sql .= \"AND \" . Catalog::get_enable_filter($type, '`tag_map`.`object_id`');\n        }\n        if ($type == 'album') {\n            if (AmpConfig::get('album_group')) {\n                $sql .= \" GROUP BY `album`.`prefix`, `album`.`name`, `album`.`album_artist`, `album`.`release_type`, `album`.`release_status`, `album`.`mbid`, `album`.`year`, `album`.`original_year`, `album`.`mbid_group`\";\n            } else {\n                $sql .= \" GROUP BY `album`.`id`, `album`.`disk`\";\n            }\n        }\n        $sql .= $limit_sql;\n        $db_results = Dba::read($sql, $sql_param);\n\n        $results = array();\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['object_id'];\n        }\n\n        return $results;\n    } // get_tag_objects\n\n    /**\n     * get_tag_ids\n     * This gets the objects from a specified tag and returns an array of object ids, nothing more\n     * @param string $type\n     * @param string $count\n     * @param string $offset\n     * @return integer[]\n     */\n    public static function get_tag_ids($type, $count = '', $offset = '')\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return array();\n        }\n\n        $limit_sql = \"\";\n        if ($count) {\n            $limit_sql = \" LIMIT \";\n            if ($offset) {\n                $limit_sql .= (string)($offset) . ', ';\n            }\n            $limit_sql .= (string)($count);\n        }\n\n        $sql = \"SELECT DISTINCT `tag_map`.`tag_id` FROM `tag_map` WHERE `tag_map`.`object_type` = ? \";\n        if (AmpConfig::get('catalog_disable') && in_array($type, array('song', 'artist', 'album'))) {\n            $sql .= \"AND \" . Catalog::get_enable_filter($type, '`tag_map`.`object_id`');\n        }\n        $sql .= $limit_sql;\n        $db_results = Dba::read($sql, array($type));\n\n        $results = array();\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['tag_id'];\n        }\n\n        return $results;\n    } // get_tag_ids\n\n    /**\n     * get_tags\n     * This is a non-object non type dependent function that just returns tags\n     * we've got, it can take filters (this is used by the tag cloud)\n     * @param string $type\n     * @param integer $limit\n     * @param string $order\n     * @return array\n     */\n    public static function get_tags($type = '', $limit = 0, $order = 'count')\n    {\n        if (parent::is_cached('tags_list', 'no_name')) {\n            //debug_event(self::class, 'Tags list found into cache memory!', 5);\n            return parent::get_from_cache('tags_list', 'no_name');\n        }\n\n        $results  = array();\n        if ($type == 'tag_hidden') {\n            $sql = \"SELECT `tag`.`id` AS `tag_id`, `tag`.`name`, `tag`.`is_hidden` FROM `tag` WHERE `tag`.`is_hidden` = true \";\n        } else {\n            $type_sql = (!empty($type))\n                ? \"AND `tag_map`.`object_type` = '\" . (string)scrub_in($type) . \"'\"\n                : \"\";\n            $sql = (AmpConfig::get('catalog_filter') && !empty(Core::get_global('user')))\n                ? \"SELECT `tag_map`.`tag_id`, `tag`.`name`, `tag`.`is_hidden`, COUNT(`tag_map`.`object_id`) AS `count` FROM `tag_map` LEFT JOIN `tag` ON `tag`.`id`=`tag_map`.`tag_id` $type_sql AND `tag`.`is_hidden` = false WHERE\" . Catalog::get_user_filter('tag', Core::get_global('user')->id) . \" AND `name` IS NOT NULL \"\n                : \"SELECT `tag_map`.`tag_id`, `tag`.`name`, `tag`.`is_hidden`, COUNT(`tag_map`.`object_id`) AS `count` FROM `tag_map` LEFT JOIN `tag` ON `tag`.`id`=`tag_map`.`tag_id` $type_sql AND `tag`.`is_hidden` = false WHERE `name` IS NOT NULL \";\n\n            $sql .= \"GROUP BY `tag_map`.`tag_id`, `tag`.`name`, `tag`.`is_hidden` \";\n        }\n        $order = \"`\" . $order . \"`\";\n        if ($order == 'count') {\n            $order .= \" DESC\";\n        }\n        $sql .= \"ORDER BY \" . $order;\n\n        if ($limit > 0) {\n            $sql .= \" LIMIT $limit\";\n        }\n        //debug_event(self::class, 'get_tags ' . $sql, 5);\n\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['tag_id']] = array(\n                'id' => $row['tag_id'],\n                'name' => $row['name'],\n                'is_hidden' => $row['is_hidden'],\n                'count' => $row['count'] ?? 0\n            );\n        }\n\n        parent::add_to_cache('tags_list', 'no_name', $results);\n\n        return $results;\n    } // get_tags\n\n    /**\n     * get_display\n     * This returns a csv formatted version of the tags that we are given\n     * it also takes a type so that it knows how to return it, this is used\n     * by the formatting functions of the different objects\n     * @param array $tags\n     * @param boolean $link\n     * @param string $filter_type\n     * @return string\n     */\n    public static function get_display($tags, $link = false, $filter_type = '')\n    {\n        //debug_event(self::class, 'Get display tags called...', 5);\n        if (!is_array($tags)) {\n            return '';\n        }\n\n        $web_path = AmpConfig::get('web_path');\n        $results  = '';\n\n        // Iterate through the tags, format them according to type and element id\n        foreach ($tags as $value) {\n            if ($link) {\n                $results .= '<a href=\"' . $web_path . '/browse.php?action=tag&show_tag=' . $value['id'] . (!empty($filter_type) ? '&type=' . $filter_type : '') . '\" title=\"' . scrub_out($value['name']) . '\">';\n            }\n            $results .= $value['name'];\n            if ($link) {\n                $results .= '</a>';\n            }\n            $results .= ', ';\n        }\n\n        $results = rtrim((string)$results, ', ');\n\n        return $results;\n    } // get_display\n\n    /**\n     * update_tag_list\n     * Update the tags list based on a comma-separated list\n     *  (ex. tag1,tag2,tag3,..)\n     * @param string $tags_comma\n     * @param string $object_type\n     * @param integer $object_id\n     * @param boolean $overwrite\n     * @return boolean\n     */\n    public static function update_tag_list($tags_comma, $object_type, $object_id, $overwrite)\n    {\n        if (!strlen((string) $tags_comma) > 0) {\n            return self::remove_all_map($object_type, $object_id);\n        }\n        debug_event(self::class, \"update_tag_list $object_type: {{$object_id}}\", 5);\n        // tags from your file can be in a terrible format\n        $filterfolk  = str_replace('Folk, World, & Country', 'Folk World & Country', $tags_comma);\n        $filterunder = str_replace('_', ', ', $filterfolk);\n        $filter      = str_replace(';', ', ', $filterunder);\n        $filter_list = preg_split('/(\\s*,*\\s*)*,+(\\s*,*\\s*)*/', $filter);\n        $editedTags  = (is_array($filter_list)) ? array_unique($filter_list) : array();\n\n        $ctags = self::get_top_tags($object_type, $object_id, 50);\n        foreach ($ctags as $ctid => $ctv) {\n            //debug_event(self::class, 'ctag {' . $ctid . '} = ' . print_r($ctv, true), 5);\n            $found = false;\n            if ($ctv['id'] != '') {\n                $ctag  = new Tag($ctv['id']);\n                foreach ($editedTags as $tk => $tv) {\n                    //debug_event(self::class, 'from_tags {' . $tk . '} = ' . $tv, 5);\n                    if (strtolower($ctag->name) == strtolower($tv)) {\n                        $found = true;\n                        break;\n                    }\n                    // check if this thing has been renamed into something else\n                    $merged = self::construct_from_name($tv);\n                    if ($merged && $merged->is_hidden && $merged->has_merge($ctag->name)) {\n                        $found = true;\n                        break;\n                    }\n                }\n\n                if ($found) {\n                    unset($editedTags[$ctag->name]);\n                }\n                if (!$found && $overwrite && $ctv['user'] == 0) {\n                    debug_event(self::class, 'update_tag_list {' . $ctag->name . '} not found. Delete it.', 5);\n                    $ctag->remove_map($object_type, $object_id, false);\n                }\n            }\n        }\n        // Look if we need to add some new tags\n        foreach ($editedTags as $tk => $tv) {\n            if ($tv != '') {\n                self::add($object_type, $object_id, $tv, false);\n            }\n        }\n\n        return true;\n    } // update_tag_list\n\n    /**\n     * clean_to_existing\n     * Clean tag list to existing tag list only\n     * @param array|string $tags\n     * @return array|string\n     */\n    public static function clean_to_existing($tags)\n    {\n        if (is_array($tags)) {\n            $taglist = $tags;\n        } else {\n            $filterfolk  = str_replace('Folk, World, & Country', 'Folk World & Country', $tags);\n            $filterunder = str_replace('_', ', ', $filterfolk);\n            $filter      = str_replace(';', ', ', $filterunder);\n            $filter_list = preg_split('/(\\s*,*\\s*)*,+(\\s*,*\\s*)*/', $filter);\n            $taglist     = (is_array($filter_list)) ? array_unique($filter_list) : array();\n        }\n\n        $ret = array();\n        foreach ($taglist as $tag) {\n            $tag = trim((string)$tag);\n            if (!empty($tag)) {\n                if (self::tag_exists($tag)) {\n                    $ret[] = $tag;\n                }\n            }\n        }\n\n        return (is_array($tags) ? $ret : implode(\",\", $ret));\n    }\n\n    /**\n     * count\n     * This returns the count for the all objects associated with this tag\n     * If a type is specific only counts for said type are returned\n     * @param string $type\n     * @param integer $user_id\n     * @return array\n     */\n    public function count($type = '', $user_id = 0)\n    {\n        $params = array($this->id);\n\n        $filter_sql = \"\";\n        if ($user_id > 0) {\n            $filter_sql = \" AND `user` = ?\";\n            $params[]   = $user_id;\n        }\n        if ($type) {\n            $filter_sql = \" AND `object_type` = ?\";\n            $params[]   = $type;\n        }\n\n        $results = array();\n\n        $sql        = \"SELECT DISTINCT(`object_type`), COUNT(`object_id`) AS `count` FROM `tag_map` WHERE `tag_id` = ?\" . $filter_sql . \" GROUP BY `object_type`\";\n        $db_results = Dba::read($sql, $params);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['object_type']] = (int)$row['count'];\n        }\n\n        return $results;\n    } // count\n\n    /**\n     * remove_map\n     * This will only remove tag maps for the current user\n     * @param string $type\n     * @param integer $object_id\n     * @param boolean $user\n     * @return boolean\n     */\n    public function remove_map($type, $object_id, $user = true)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return false;\n        }\n\n        $uid = 0;\n        if ($user === true) {\n            $uid = (int)(Core::get_global('user')->id);\n        }\n\n        $sql = \"DELETE FROM `tag_map` WHERE `tag_id` = ? AND `object_type` = ? AND `object_id` = ? AND `user` = ?\";\n        Dba::write($sql, array($this->id, $type, $object_id, $uid));\n\n        return true;\n    } // remove_map\n\n    /**\n     * remove_all_map\n     * Clear all the tags from an object when there isn't anything there\n     * @param string $object_type\n     * @param integer $object_id\n     * @return boolean\n     */\n    public static function remove_all_map($object_type, $object_id)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($object_type)) {\n            return false;\n        }\n\n        $sql = \"DELETE FROM `tag_map` WHERE `object_type` = ? AND `object_id` = ?\";\n        Dba::write($sql, array($object_type, $object_id));\n\n        return true;\n    } // remove_all_map\n\n    /**\n     * @param boolean $details\n     */\n    public function format($details = true)\n    {\n        unset($details); //dead code but called from other format calls\n    }\n\n    /**\n     * Get item keywords for metadata searches.\n     * @return array\n     */\n    public function get_keywords()\n    {\n        $keywords        = [];\n        $keywords['tag'] = [\n            'important' => true,\n            'label' => T_('Genre'),\n            'value' => $this->name\n        ];\n\n        return $keywords;\n    }\n\n    /**\n     * get_fullname\n     * @return string\n     */\n    public function get_fullname()\n    {\n        return $this->name;\n    }\n\n    /**\n     * Get item link.\n     * @return string\n     */\n    public function get_link()\n    {\n        return '';\n    }\n\n    /**\n     * Get item f_link.\n     * @return string\n     */\n    public function get_f_link()\n    {\n        return '';\n    }\n\n    /**\n     * @return null\n     */\n    public function get_parent()\n    {\n        return null;\n    }\n\n    /**\n     * @return array\n     */\n    public function get_childrens()\n    {\n        return array();\n    }\n\n    /**\n     * search_childrens\n     * @param string $name\n     * @return array\n     */\n    public function search_childrens($name)\n    {\n        debug_event(self::class, 'search_childrens ' . $name, 5);\n\n        return array();\n    }\n\n    /**\n     * get_medias\n     * @param string $filter_type\n     * @return array\n     */\n    public function get_medias($filter_type = null)\n    {\n        $medias = array();\n        if ($filter_type) {\n            $ids = self::get_tag_objects($filter_type, $this->id);\n            foreach ($ids as $object_id) {\n                $medias[] = array(\n                    'object_type' => $filter_type,\n                    'object_id' => $object_id\n                );\n            }\n        }\n\n        return $medias;\n    }\n\n    /**\n     * get_catalogs\n     *\n     * Get all catalog ids related to this item.\n     * @return integer[]\n     */\n    public function get_catalogs()\n    {\n        return array();\n    }\n\n    /**\n     * @return mixed|null\n     */\n    public function get_user_owner()\n    {\n        return null;\n    }\n\n    /**\n     * get_default_art_kind\n     * @return string\n     */\n    public function get_default_art_kind()\n    {\n        return 'default';\n    }\n\n    /**\n     * get_description\n     * @return string\n     */\n    public function get_description()\n    {\n        return '';\n    }\n\n    /**\n     * display_art\n     * @param integer $thumb\n     * @param boolean $force\n     */\n    public function display_art($thumb = 2, $force = false)\n    {\n        if (Art::has_db($this->id, 'tag') || $force) {\n            Art::display('tag', $this->id, $this->get_fullname(), $thumb);\n        }\n    }\n\n    /**\n     * Migrate an object associate stats to a new object\n     * @param string $object_type\n     * @param integer $old_object_id\n     * @param integer $new_object_id\n     * @return PDOStatement|boolean\n     */\n    public static function migrate($object_type, $old_object_id, $new_object_id)\n    {\n        $sql = \"UPDATE IGNORE `tag_map` SET `object_id` = ? WHERE `object_type` = ? AND `object_id` = ?\";\n\n        return Dba::write($sql, array($new_object_id, $object_type, $old_object_id));\n    }\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Repository\\Model;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\Authorization\\AccessLevelEnum;\nuse Ampache\\Module\\Statistics\\Stats;\nuse Ampache\\Module\\System\\AmpError;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\Util\\Ui;\nuse Ampache\\Repository\\IpHistoryRepositoryInterface;\nuse Ampache\\Repository\\UserRepositoryInterface;\nuse Exception;\nuse PDOStatement;\n\n/**\n * This class handles all of the user related functions including the creation\n * and deletion of the user objects from the database by default you construct it\n * with a user_id from user.id\n */\nclass User extends database_object\n{\n    protected const DB_TABLENAME = 'user';\n\n    // Basic Components\n    /**\n     * @var integer $id\n     */\n    public $id;\n    /**\n     * @var string $username\n     */\n    public $username;\n    /**\n     * @var string $fullname\n     */\n    public $fullname;\n    /**\n     * @var boolean $fullname_public\n     */\n    public $fullname_public;\n    /**\n     * @var integer $access\n     */\n    public $access;\n    /**\n     * @var boolean $disabled\n     */\n    public $disabled;\n    /**\n     * @var string $email\n     */\n    public $email;\n    /**\n     * @var integer $last_seen\n     */\n    public $last_seen;\n    /**\n     * @var integer $create_date\n     */\n    public $create_date;\n    /**\n     * @var string $validation\n     */\n    public $validation;\n    /**\n     * @var string $website\n     */\n    public $website;\n    /**\n     * @var string $state\n     */\n    public $state;\n    /**\n     * @var string $city\n     */\n    public $city;\n    /**\n     * @var string $apikey\n     */\n    public $apikey;\n    /**\n     * @var string $rsstoken\n     */\n    public $rsstoken;\n\n    // Constructed variables\n    /**\n     * @var array $prefs\n     */\n    public $prefs = array();\n\n    /**\n     * @var Tmp_Playlist $playlist\n     */\n    public $playlist;\n\n    /**\n     * @var string $f_name\n     */\n    public $f_name;\n    /**\n     * @var string $f_last_seen\n     */\n    public $f_last_seen;\n    /**\n     * @var string $f_create_date\n     */\n    public $f_create_date;\n    /**\n     * @var string $link\n     */\n    public $link;\n    /**\n     * @var string $f_link\n     */\n    public $f_link;\n    /**\n     * @var string $f_usage\n     */\n    public $f_usage;\n    /**\n     * @var string $ip_history\n     */\n    public $ip_history;\n    /**\n     * @var string $f_avatar\n     */\n    public $f_avatar;\n    /**\n     * @var string $f_avatar_mini\n     */\n    public $f_avatar_mini;\n    /**\n     * @var string $f_avatar_medium\n     */\n    public $f_avatar_medium;\n\n    /**\n     * @var int $catalog_filter_group;\n     */\n    public $catalog_filter_group;\n\n    /**\n     * Constructor\n     * This function is the constructor object for the user\n     * class, it currently takes a username\n     * @param integer $user_id\n     */\n    public function __construct($user_id = 0)\n    {\n        if (!$user_id) {\n            return false;\n        }\n\n        $this->id = (int)($user_id);\n\n        $info = $this->has_info();\n\n        foreach ($info as $key => $value) {\n            // Let's not save the password in this object :S\n            if ($key == 'password') {\n                continue;\n            }\n            $this->$key = $value;\n        }\n\n        // Make sure the Full name is always filled\n        if (strlen((string)$this->fullname) < 1) {\n            $this->fullname = $this->username;\n        }\n\n        return true;\n    } // Constructor\n\n    public function getId(): int\n    {\n        return (int)$this->id;\n    }\n\n    /**\n     * count\n     *\n     * This returns the number of user accounts that exist.\n     */\n    public static function count()\n    {\n        $sql              = 'SELECT COUNT(`id`) FROM `user`';\n        $db_results       = Dba::read($sql);\n        $row              = Dba::fetch_row($db_results);\n        $results          = array();\n        $results['users'] = $row[0] ?? 0;\n\n        $time                 = time();\n        $last_seen            = $time - 1200;\n        $sql                  = \"SELECT COUNT(DISTINCT `session`.`username`) FROM `session` INNER JOIN `user` ON `session`.`username` = `user`.`username` WHERE `session`.`expire` > ? AND `user`.`last_seen` > ?\";\n        $db_results           = Dba::read($sql, array($time, $last_seen));\n        $row                  = Dba::fetch_row($db_results);\n        $results['connected'] = $row[0] ?? 0;\n\n        return $results;\n    }\n\n    /**\n     * has_info\n     * This function returns the information for this object\n     * @return array\n     */\n    private function has_info()\n    {\n        $user_id = (int)($this->id);\n\n        if (User::is_cached('user', $user_id)) {\n            return User::get_from_cache('user', $user_id);\n        }\n\n        $data = array();\n        // If the ID is -1 then\n        if ($user_id == '-1') {\n            $data['username'] = 'System';\n            $data['fullname'] = 'Ampache User';\n            $data['access']   = '25';\n\n            return $data;\n        }\n\n        $sql        = \"SELECT * FROM `user` WHERE `id`='$user_id'\";\n        $db_results = Dba::read($sql);\n\n        $data = Dba::fetch_assoc($db_results);\n\n        User::add_to_cache('user', $user_id, $data);\n\n        return $data;\n    } // has_info\n\n    /**\n     * load_playlist\n     * This is called once per page load it makes sure that this session\n     * has a tmp_playlist, creating it if it doesn't, then sets $this->playlist\n     * as a tmp_playlist object that can be fiddled with later on\n     */\n    public function load_playlist()\n    {\n        $session_id = session_id();\n\n        $this->playlist = Tmp_Playlist::get_from_session($session_id);\n    } // load_playlist\n\n    /**\n     * get_from_username\n     * This returns a built user from a username. This is a\n     * static function so it doesn't require an instance\n     * @param string $username\n     * @return User|null $user\n     */\n    public static function get_from_username($username)\n    {\n        return static::getUserRepository()->findByUsername($username);\n    } // get_from_username\n\n    /**\n     * get_from_apikey\n     * This returns a built user from a username. This is a\n     * static function so it doesn't require an instance\n     * @param string $apikey\n     * @return User|null\n     */\n    public static function get_from_apikey($apikey)\n    {\n        return static::getUserRepository()->findByApiKey($apikey);\n    } // get_from_apikey\n\n    /**\n     * get_from_email\n     * This returns a built user from an email address. This is a\n     * static function so it doesn't require an instance\n     * @param string $emailAddress\n     * @return User|null $user\n     */\n    public static function get_from_email($emailAddress)\n    {\n        return static::getUserRepository()->findByEmail($emailAddress);\n    } // get_from_email\n\n    /**\n     * id_from_username\n     * This returns a built user from a username. This is a\n     * static function so it doesn't require an instance\n     * @param string $username\n     * @return int\n     */\n    public static function id_from_username($username)\n    {\n        return static::getUserRepository()->idByUsername($username);\n    } // id_from_username\n\n    /**\n     * id_from_email\n     * This returns a built user from an email address. This is a\n     * static function so it doesn't require an instance\n     * @param string $emailAddress\n     * @return int\n     */\n    public static function id_from_email($emailAddress)\n    {\n        return static::getUserRepository()->idByEmail($emailAddress);\n    } // id_from_email\n\n    /**\n     * get_user_catalogs\n     * This returns the catalogs as an array of ids that this user is allowed to access\n     * @return integer[]\n     */\n    public static function get_user_catalogs($userid)\n    {\n        if (parent::is_cached('user_catalog', $userid)) {\n            return parent::get_from_cache('user_catalog', $userid);\n        }\n\n        $sql        = \"SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id`= ? AND `catalog_filter_group_map`.`enabled` = 1 ORDER BY `catalog_filter_group_map`.`catalog_id`\";\n        $db_results = Dba::read($sql, array($userid));\n\n        $catalogs = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $catalogs[] = (int)$row['catalog_id'];\n        }\n\n        parent::add_to_cache('user_catalog', $userid, $catalogs);\n\n        return $catalogs;\n    } // get_catalogs\n\n\n    /**\n     * get_catalogs\n     * This returns the catalogs as an array of ids that this user is allowed to access\n     * @return integer[]\n     */\n    public function get_catalogs()\n    {\n        return self::get_user_catalogs($this->id);\n    } // get_catalogs\n\n\n    /**\n     * get_preferences\n     * This is a little more complicate now that we've got many types of preferences\n     * This function pulls all of them an arranges them into a spiffy little array\n     * You can specify a type to limit it to a single type of preference\n     * []['title'] = uppercase type name\n     * []['prefs'] = array(array('name', 'display', 'value'));\n     * []['admin'] = t/f value if this is an admin only section\n     * @param integer $type\n     * @param boolean $system\n     * @return array\n     */\n    public function get_preferences($type = 0, $system = false)\n    {\n        $user_limit = \"\";\n        if (!$system) {\n            $user_id    = $this->id;\n            $user_limit = \"AND preference.catagory != 'system'\";\n        } else {\n            $user_id =  -1;\n            if ($type != '0') {\n                $user_limit = \"AND preference.catagory = '\" . Dba::escape($type) . \"'\";\n            }\n        }\n\n        $sql        = \"SELECT `preference`.`name`, `preference`.`description`, `preference`.`catagory`, `preference`.`subcatagory`, preference.level, user_preference.value FROM `preference` INNER JOIN `user_preference` ON `user_preference`.`preference` = `preference`.`id` WHERE `user_preference`.`user` = ? \" . $user_limit . \" ORDER BY `preference`.`catagory`, `preference`.`subcatagory`, `preference`.`description`\";\n        $db_results = Dba::read($sql, array($user_id));\n        $results    = array();\n        $type_array = array();\n        /* Ok this is crappy, need to clean this up or improve the code FIXME */\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $type  = $row['catagory'];\n            $admin = false;\n            if ($type == 'system') {\n                $admin = true;\n            }\n            $type_array[$type][$row['name']] = array(\n                'name' => $row['name'],\n                'level' => $row['level'],\n                'description' => $row['description'],\n                'value' => $row['value'],\n                'subcategory' => $row['subcatagory']\n            );\n            $results[$type] = array(\n                'title' => ucwords((string)$type),\n                'admin' => $admin,\n                'prefs' => $type_array[$type]\n            );\n        } // end while\n\n        return $results;\n    } // get_preferences\n\n    /**\n     * set_preferences\n     * sets the prefs for this specific user\n     */\n    public function set_preferences()\n    {\n        $user_id    = Dba::escape($this->id);\n        $sql        = \"SELECT `preference`.`name`, `user_preference`.`value` FROM `preference`, `user_preference` WHERE `user_preference`.`user` = ? AND `user_preference`.`preference` = `preference`.`id` AND `preference`.`type` != 'system';\";\n        $db_results = Dba::read($sql, array($user_id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $key               = $row['name'];\n            $this->prefs[$key] = $row['value'];\n        }\n    } // set_preferences\n\n    /**\n     * get_favorites\n     * returns an array of your $type favorites\n     * @param string $type\n     * @return array\n     */\n    public function get_favorites($type)\n    {\n        $count   = AmpConfig::get('popular_threshold', 10);\n        $results = Stats::get_user($count, $type, $this->id, 1);\n\n        $items = array();\n\n        foreach ($results as $row) {\n            // If its a song\n            if ($type == 'song') {\n                $data        = new Song($row['object_id']);\n                $data->count = $row['count'];\n                $data->format();\n                $items[] = $data;\n            } elseif ($type == 'album') {\n                // If its an album\n                $data = new Album($row['object_id']);\n                $data->format();\n                $items[] = $data;\n            } elseif ($type == 'artist') {\n                // If its an artist\n                $data = new Artist($row['object_id']);\n                $data->format();\n                $data->f_name = $data->f_link;\n                $items[]      = $data;\n            } elseif (($type == 'genre' || $type == 'tag')) {\n                // If it's a genre\n                $data    = new Tag($row['object_id']);\n                $items[] = $data;\n            }\n        } // end foreach\n\n        return $items;\n    } // get_favorites\n\n    /**\n     * is_logged_in\n     * checks to see if $this user is logged in returns their current IP if they are logged in\n     */\n    public function is_logged_in()\n    {\n        $sql        = \"SELECT `id`, `ip` FROM `session` WHERE `username`= ? AND `expire` > ?;\";\n        $db_results = Dba::read($sql, array($this->username, time()));\n\n        if ($row = Dba::fetch_assoc($db_results)) {\n            return $row['ip'] ?? null;\n        }\n\n        return false;\n    } // is_logged_in\n\n    /**\n     * has_access\n     * this function checks to see if this user has access\n     * to the passed action (pass a level requirement)\n     * @param integer $needed_level\n     * @return boolean\n     */\n    public function has_access($needed_level)\n    {\n        if (AmpConfig::get('demo_mode')) {\n            return true;\n        }\n\n        if ($this->access >= $needed_level) {\n            return true;\n        }\n\n        return false;\n    } // has_access\n\n    /**\n     * is_registered\n     * Check if the user is registered\n     * @return boolean\n     */\n    public static function is_registered()\n    {\n        if (empty(Core::get_global('user'))) {\n            return false;\n        }\n        if (!Core::get_global('user')->id) {\n            return false;\n        }\n\n        if (!AmpConfig::get('use_auth') && Core::get_global('user')->access < 5) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * set_user_data\n     * This updates some background data for user specific function\n     * @param int $user_id\n     * @param string $key\n     * @param string|integer $value\n     */\n    public static function set_user_data(int $user_id, string $key, $value)\n    {\n        Dba::write(\"REPLACE INTO `user_data` SET `user`= ?, `key`= ?, `value`= ?;\", array($user_id, $key, $value));\n    } // set_user_data\n\n    /**\n     * get_user_data\n     * This updates some background data for user specific function\n     * @param int $user_id\n     * @param string $key\n     * @return array\n     */\n    public static function get_user_data($user_id, $key = null)\n    {\n        $sql    = \"SELECT `key`, `value` FROM `user_data` WHERE `user` = ?\";\n        $params = array($user_id);\n        if ($key) {\n            $sql .= \" AND `key` = ?\";\n            $params[] = $key;\n        }\n\n        $db_results = Dba::read($sql, $params);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['key']] = $row['value'];\n        }\n\n        return $results;\n    } // get_user_data\n\n    /**\n     * update\n     * This function is an all encompassing update function that\n     * calls the mini ones does all the error checking and all that\n     * good stuff\n     * @param array $data\n     * @return boolean|int\n     */\n    public function update(array $data)\n    {\n        if (empty($data['username'])) {\n            AmpError::add('username', T_('Username is required'));\n        }\n\n        if ($data['password1'] != $data['password2'] && !empty($data['password1'])) {\n            AmpError::add('password', T_(\"Passwords do not match\"));\n        }\n\n        if (AmpError::occurred()) {\n            return false;\n        }\n\n        if (!isset($data['fullname_public'])) {\n            $data['fullname_public'] = false;\n        }\n\n        foreach ($data as $name => $value) {\n            if ($name == 'password1') {\n                $name = 'password';\n            } else {\n                $value = scrub_in($value);\n            }\n\n            switch ($name) {\n                case 'password':\n                case 'access':\n                case 'email':\n                case 'username':\n                case 'fullname':\n                case 'fullname_public':\n                case 'website':\n                case 'state':\n                case 'city':\n                case 'catalog_filter_group':\n                    if ($this->$name != $value) {\n                        $function = 'update_' . $name;\n                        $this->$function($value);\n                    }\n                    break;\n                case 'clear_stats':\n                    Stats::clear($this->id);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        return $this->id;\n    }\n\n    /**\n     * update_catalog_filter_group\n     * updates their catalog filter\n     * @param $new_filter\n     */\n    public function update_catalog_filter_group($new_filter)\n    {\n        $sql = \"UPDATE `user` SET `catalog_filter_group` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating catalog access group', 4);\n\n        Dba::write($sql, array($new_filter, $this->id));\n    } // update_catalog_filter_group\n\n    /**\n     * update_username\n     * updates their username\n     * @param $new_username\n     */\n    public function update_username($new_username)\n    {\n        $sql            = \"UPDATE `user` SET `username` = ? WHERE `id` = ?\";\n        $this->username = $new_username;\n\n        debug_event(self::class, 'Updating username', 4);\n\n        Dba::write($sql, array($new_username, $this->id));\n    } // update_username\n\n    /**\n     * update_validation\n     * This is used by the registration mumbojumbo\n     * Use this function to update the validation key\n     * NOTE: crap this doesn't have update_item the humanity of it all\n     * @param $new_validation\n     * @return PDOStatement|boolean\n     */\n    public function update_validation($new_validation)\n    {\n        $sql              = \"UPDATE `user` SET `validation` = ?, `disabled`='1' WHERE `id` = ?\";\n        $db_results       = Dba::write($sql, array($new_validation, $this->id));\n        $this->validation = $new_validation;\n\n        return $db_results;\n    } // update_validation\n\n    /**\n     * update_fullname\n     * updates their fullname\n     * @param $new_fullname\n     */\n    public function update_fullname($new_fullname)\n    {\n        $sql = \"UPDATE `user` SET `fullname` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating fullname', 4);\n\n        Dba::write($sql, array($new_fullname, $this->id));\n    } // update_fullname\n\n    /**\n     * update_fullname_public\n     * updates their fullname public\n     * @param $new_fullname_public\n     */\n    public function update_fullname_public($new_fullname_public)\n    {\n        $sql = \"UPDATE `user` SET `fullname_public` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating fullname public', 4);\n\n        Dba::write($sql, array($new_fullname_public ? '1' : '0', $this->id));\n    } // update_fullname_public\n\n    /**\n     * update_email\n     * updates their email address\n     * @param string $new_email\n     */\n    public function update_email($new_email)\n    {\n        $sql = \"UPDATE `user` SET `email` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating email', 4);\n\n        Dba::write($sql, array($new_email, $this->id));\n    } // update_email\n\n    /**\n     * update_website\n     * updates their website address\n     * @param $new_website\n     */\n    public function update_website($new_website)\n    {\n        $new_website = rtrim((string)$new_website, \"/\");\n        $sql         = \"UPDATE `user` SET `website` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating website', 4);\n\n        Dba::write($sql, array($new_website, $this->id));\n    } // update_website\n\n    /**\n     * update_state\n     * updates their state\n     * @param $new_state\n     */\n    public function update_state($new_state)\n    {\n        $sql = \"UPDATE `user` SET `state` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating state', 4);\n\n        Dba::write($sql, array($new_state, $this->id));\n    } // update_state\n\n    /**\n     * update_city\n     * updates their city\n     * @param $new_city\n     */\n    public function update_city($new_city)\n    {\n        $sql = \"UPDATE `user` SET `city` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating city', 4);\n\n        Dba::write($sql, array($new_city, $this->id));\n    } // update_city\n\n    /**\n     * update_counts for individual users\n     */\n    public static function update_counts()\n    {\n        $catalog_disable = AmpConfig::get('catalog_disable');\n        $catalog_filter  = AmpConfig::get('catalog_filter');\n        $sql             = \"SELECT `id` FROM `user`\";\n        $db_results      = Dba::read($sql);\n        $user_list       = array();\n        while ($results  = Dba::fetch_assoc($db_results)) {\n            $user_list[] = (int)$results['id'];\n        }\n        if (!$catalog_filter) {\n            // no filter means no need for filtering or counting per user\n            $count_array   = array('song', 'video', 'podcast_episode', 'artist', 'album', 'search', 'playlist', 'live_stream', 'podcast', 'user', 'catalog', 'label', 'tag', 'share', 'license', 'album_group', 'items', 'time', 'size');\n            $server_counts = Catalog::get_server_counts(0);\n            foreach ($user_list as $user_id) {\n                debug_event(self::class, 'Update counts for ' . $user_id, 5);\n                foreach ($server_counts as $table => $count) {\n                    if (in_array($table, $count_array)) {\n                        self::set_user_data($user_id, $table, $count);\n                    }\n                }\n            }\n\n            return;\n        }\n\n        $count_array = array('song', 'video', 'podcast_episode', 'artist', 'album', 'search', 'playlist', 'live_stream', 'podcast', 'user', 'catalog', 'label', 'tag', 'share', 'license');\n        foreach ($user_list as $user_id) {\n            debug_event(self::class, 'Update counts for ' . $user_id, 5);\n            // get counts per user (filtered catalogs aren't counted)\n            foreach ($count_array as $table) {\n                $sql        = (in_array($table, array('search', 'user', 'license')))\n                    ? \"SELECT COUNT(`id`) FROM `$table`\"\n                    : \"SELECT COUNT(`id`) FROM `$table` WHERE\" . Catalog::get_user_filter($table, $user_id);\n                $db_results = Dba::read($sql);\n                $row        = Dba::fetch_row($db_results);\n\n                self::set_user_data($user_id, $table, (int)($row[0] ?? 0));\n            }\n            // tables with media items to count, song-related tables and the rest\n            $media_tables = array('song', 'video', 'podcast_episode');\n            $items        = 0;\n            $time         = 0;\n            $size         = 0;\n            foreach ($media_tables as $table) {\n                $enabled_sql = ($catalog_disable && $table !== 'podcast_episode')\n                    ? \" WHERE `$table`.`enabled`='1' AND\"\n                    : ' WHERE';\n                $sql        = \"SELECT COUNT(`id`), IFNULL(SUM(`time`), 0), IFNULL(SUM(`size`), 0) FROM `$table`\" . $enabled_sql . Catalog::get_user_filter($table, $user_id);\n                $db_results = Dba::read($sql);\n                $row        = Dba::fetch_row($db_results);\n                // save the object and add to the current size\n                $items += (int)($row[0] ?? 0);\n                $time += (int)($row[1] ?? 0);\n                $size += (int)($row[2] ?? 0);\n                self::set_user_data($user_id, $table, (int)($row[0] ?? 0));\n            }\n            self::set_user_data($user_id, 'items', $items);\n            self::set_user_data($user_id, 'time', $time);\n            self::set_user_data($user_id, 'size', $size);\n            // grouped album counts\n            $sql        = \"SELECT COUNT(DISTINCT(`album`.`id`)) AS `count` FROM `album` WHERE `id` in (SELECT MIN(`id`) FROM `album` GROUP BY `album`.`prefix`, `album`.`name`, `album`.`album_artist`, `album`.`release_type`, `album`.`release_status`, `album`.`mbid`, `album`.`year`, `album`.`original_year`, `album`.`mbid_group`) AND\" . Catalog::get_user_filter('album', $user_id);\n            $db_results = Dba::read($sql);\n            $row        = Dba::fetch_row($db_results);\n            self::set_user_data($user_id, 'album_group', (int)($row[0] ?? 0));\n        }\n    } // update_counts\n\n    /**\n     * disable\n     * This disables the current user\n     */\n    public function disable()\n    {\n        // Make sure we aren't disabling the last admin\n        $sql        = \"SELECT `id` FROM `user` WHERE `disabled` = '0' AND `id` != '\" . $this->id . \"' AND `access`='100'\";\n        $db_results = Dba::read($sql);\n\n        if (!Dba::num_rows($db_results)) {\n            return false;\n        }\n\n        $sql = \"UPDATE `user` SET `disabled`='1' WHERE id='\" . $this->id . \"'\";\n        Dba::write($sql);\n\n        // Delete any sessions they may have\n        $sql = \"DELETE FROM `session` WHERE `username`='\" . Dba::escape($this->username) . \"'\";\n        Dba::write($sql);\n\n        return true;\n    } // disable\n\n    /**\n     * update_access\n     * updates their access level\n     * @param $new_access\n     * @return boolean\n     */\n    public function update_access($new_access)\n    {\n        /* Prevent Only User accounts */\n        if ($new_access < '100') {\n            $sql        = \"SELECT `id` FROM `user` WHERE `access`='100' AND `id` != '$this->id'\";\n            $db_results = Dba::read($sql);\n            if (!Dba::num_rows($db_results)) {\n                return false;\n            }\n        }\n\n        $new_access = Dba::escape($new_access);\n        $sql        = \"UPDATE `user` SET `access` = ? WHERE `id` = ?;\";\n\n        debug_event(self::class, 'Updating access level for ' . $this->id, 4);\n\n        Dba::write($sql, array($new_access, $this->id));\n\n        return true;\n    } // update_access\n\n    /**\n     * save_mediaplay\n     * @param User $user\n     * @param Song $media\n     */\n    public static function save_mediaplay($user, $media)\n    {\n        foreach (Plugin::get_plugins('save_mediaplay') as $plugin_name) {\n            try {\n                $plugin = new Plugin($plugin_name);\n                if ($plugin->load($user)) {\n                    debug_event(self::class, 'save_mediaplay... ' . $plugin->_plugin->name, 5);\n                    $plugin->_plugin->save_mediaplay($media);\n                }\n            } catch (Exception $error) {\n                debug_event(self::class, 'save_mediaplay plugin error: ' . $error->getMessage(), 1);\n            }\n        }\n    }\n\n    /**\n     * insert_ip_history\n     * This inserts a row into the IP History recording this user at this\n     * address at this time in this place, doing this thing.. you get the point\n     */\n    public function insert_ip_history()\n    {\n        $sip = (isset($_SERVER['HTTP_X_FORWARDED_FOR']))\n            ? filter_var($_SERVER['HTTP_X_FORWARDED_FOR'], FILTER_VALIDATE_IP)\n            : filter_var($_SERVER['REMOTE_ADDR'], FILTER_VALIDATE_IP);\n        debug_event(self::class, 'Login from IP address: ' . (string) $sip, 3);\n\n        // Remove port information if any\n        if (!empty($sip)) {\n            // Use parse_url to support easily ipv6\n            if (filter_var($sip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) === true) {\n                $sipar = parse_url(\"http://\" . $sip);\n            } else {\n                $sipar = parse_url(\"http://[\" . $sip . \"]\");\n            }\n            $sip = $sipar['host'];\n        }\n\n        $uip     = (!empty($sip)) ? Dba::escape(inet_pton(trim((string)$sip, \"[]\"))) : '';\n        $date    = time();\n        $user_id = (int)$this->id;\n        $agent   = Dba::escape(Core::get_server('HTTP_USER_AGENT'));\n\n        $sql = \"INSERT INTO `ip_history` (`ip`, `user`, `date`, `agent`) VALUES ('$uip', '$user_id', '$date', '$agent')\";\n        Dba::write($sql);\n\n        /* Clean up old records... sometimes  */\n        if (rand(1, 100) > 60) {\n            $date = time() - (86400 * AmpConfig::get('user_ip_cardinality'));\n            $sql  = \"DELETE FROM `ip_history` WHERE `date` < $date\";\n            Dba::write($sql);\n        }\n\n        return true;\n    } // insert_ip_history\n\n    /**\n     * create\n     * inserts a new user into Ampache\n     * @param string $username\n     * @param string $fullname\n     * @param string $email\n     * @param string $website\n     * @param string $password\n     * @param integer $access\n     * @param string $state\n     * @param string $city\n     * @param boolean $disabled\n     * @param boolean $encrypted\n     * @return integer\n     */\n    public static function create(\n        $username,\n        $fullname,\n        $email,\n        $website,\n        $password,\n        $access,\n        $catalog_filter_group = 0,\n        $state = '',\n        $city = '',\n        $disabled = false,\n        $encrypted = false\n    ) {\n        // don't try to overwrite users that already exist\n        if (static::getUserRepository()->idByUsername($username) > 0 || static::getUserRepository()->idByEmail($email) > 0) {\n            return 0;\n        }\n        $website = rtrim((string)$website, \"/\");\n        if (!$encrypted) {\n            $password = hash('sha256', $password);\n        }\n        $disabled = $disabled ? 1 : 0;\n\n        // Just in case a zero value slipped in from upper layers...\n        $catalog_filter_group = $catalog_filter_group ?? 0;\n\n        /* Now Insert this new user */\n        $sql    = \"INSERT INTO `user` (`username`, `disabled`, `fullname`, `email`, `password`, `access`, `catalog_filter_group`, `create_date`\";\n        $params = array($username, $disabled, $fullname, $email, $password, $access, $catalog_filter_group, time());\n\n        if (!empty($website)) {\n            $sql .= \", `website`\";\n            $params[] = $website;\n        }\n        if (!empty($state)) {\n            $sql .= \", `state`\";\n            $params[] = $state;\n        }\n        if (!empty($city)) {\n            $sql .= \", `city`\";\n            $params[] = $city;\n        }\n\n        $sql .= \") VALUES(?, ?, ?, ?, ?, ?, ?, ?\";\n\n        if (!empty($website)) {\n            $sql .= \", ?\";\n        }\n        if (!empty($state)) {\n            $sql .= \", ?\";\n        }\n        if (!empty($city)) {\n            $sql .= \", ?\";\n        }\n\n        $sql .= \")\";\n        $db_results = Dba::write($sql, $params);\n\n        if (!$db_results) {\n            return 0;\n        }\n        // Get the insert_id\n        $insert_id = (int)Dba::insert_id();\n\n        // Populates any missing preferences, in this case all of them\n        self::fix_preferences($insert_id);\n\n        Catalog::count_table('user');\n\n        return (int)$insert_id;\n    } // create\n\n    /**\n     * update_password\n     * updates a users password\n     * @param string $new_password\n     * @param string $hashed_password\n     */\n    public function update_password($new_password, $hashed_password = null)\n    {\n        debug_event(self::class, 'Updating password', 1);\n        if (!$hashed_password) {\n            $hashed_password = hash('sha256', $new_password);\n        }\n\n        $escaped_password = Dba::escape($hashed_password);\n        $sql              = \"UPDATE `user` SET `password` = ? WHERE `id` = ?\";\n        $db_results       = Dba::write($sql, array($escaped_password, $this->id));\n\n        // Clear this (temp fix)\n        if ($db_results) {\n            unset($_SESSION['userdata']['password']);\n        }\n    } // update_password\n\n    /**\n     * format\n     * This function sets up the extra variables we need when we are displaying a\n     * user for an admin, these should not be normally called when creating a\n     * user object\n     * @param boolean $details\n     */\n    public function format($details = true)\n    {\n        if (!$this->id) {\n            return;\n        }\n        /* If they have a last seen date */\n        if (!$this->last_seen) {\n            $this->f_last_seen = T_('Never');\n        } else {\n            $this->f_last_seen = get_datetime((int)$this->last_seen);\n        }\n\n        /* If they have a create date */\n        if (!$this->create_date) {\n            $this->f_create_date = T_('Unknown');\n        } else {\n            $this->f_create_date = get_datetime((int)$this->create_date);\n        }\n\n        // Base link\n        $this->f_link = '<a href=\"' . $this->get_link() . '\">' . scrub_out($this->get_fullname()) . '</a>';\n\n        if ($details) {\n            $user_data = self::get_user_data($this->id);\n            if (!isset($user_data['play_size'])) {\n                // Calculate their total Bandwidth Usage\n                $sql        = \"SELECT SUM(`song`.`size`) AS `play_size` FROM `object_count` LEFT JOIN `song` ON `song`.`id`=`object_count`.`object_id` WHERE `object_count`.`user` = ? AND `object_count`.`object_type` IN ('song', 'video', 'podcast_episode') GROUP BY `user`;\";\n                $db_results = Dba::read($sql, array($this->id));\n                $result     = Dba::fetch_assoc($db_results);\n                $play_size  = $result['play_size'] ?? 0;\n                // set the value for next time\n                self::set_user_data($this->id, 'play_size', (int)$play_size);\n                $user_data['play_size'] = $play_size;\n            }\n\n            $this->f_usage = Ui::format_bytes((int)$user_data['play_size']);\n\n            // Get Users Last ip\n            if (count($data = $this->getIpHistoryRepository()->getHistory($this->getId()))) {\n                $user_ip          = inet_ntop($data['0']['ip']);\n                $this->ip_history = (!empty($user_ip) && filter_var($user_ip, FILTER_VALIDATE_IP)) ? $user_ip : T_('Invalid');\n            } else {\n                $this->ip_history = T_('Not Enough Data');\n            }\n        }\n\n        $avatar = $this->get_avatar();\n        if (!empty($avatar['url'])) {\n            $this->f_avatar = '<img src=\"' . $avatar['url'] . '\" title=\"' . $avatar['title'] . '\"' . ' width=\"256px\" height=\"auto\" />';\n        }\n        if (!empty($avatar['url_mini'])) {\n            $this->f_avatar_mini = '<img src=\"' . $avatar['url_mini'] . '\" title=\"' . $avatar['title'] . '\" style=\"width: 32px; height: 32px;\" />';\n        }\n        if (!empty($avatar['url_medium'])) {\n            $this->f_avatar_medium = '<img src=\"' . $avatar['url_medium'] . '\" title=\"' . $avatar['title'] . '\" style=\"width: 64px; height: 64px;\" />';\n        }\n    } // format_user\n\n    /**\n     * access_name_to_level\n     * This takes the access name for the user and returns the level\n     * @param string $name\n     * @return integer\n     */\n    public static function access_name_to_level($name)\n    {\n        switch ($name) {\n            case 'admin':\n                return AccessLevelEnum::LEVEL_ADMIN;\n            case 'user':\n                return AccessLevelEnum::LEVEL_USER;\n            case 'manager':\n                return AccessLevelEnum::LEVEL_MANAGER;\n            // FIXME why is content manager not here?\n            //case 'manager':\n                //return AccessLevelEnum::LEVEL_CONTENT_MANAGER;\n            case 'guest':\n                return AccessLevelEnum::LEVEL_GUEST;\n            default:\n                return AccessLevelEnum::LEVEL_DEFAULT;\n        }\n    } // access_name_to_level\n\n    /**\n     * access_level_to_name\n     * This takes the access level for the user and returns the translated name for that level\n     * @param string $level\n     * @return string\n     */\n    public static function access_level_to_name($level)\n    {\n        switch ($level) {\n            case '100':\n                return T_('Admin');\n            case '75':\n                return T_('Catalog Manager');\n            case '50':\n                return T_('Content Manager');\n            case '25':\n                return T_('User');\n            case '5':\n                return T_('Guest');\n            default:\n                return T_('Unknown');\n        }\n    } // access_level_to_name\n\n    /**\n     * fix_preferences\n     * This is the new fix_preferences function, it does the following\n     * Remove Duplicates from user, add in missing\n     * If -1 is passed it also removes duplicates from the `preferences`\n     * table.\n     * @param integer $user_id\n     */\n    public static function fix_preferences($user_id)\n    {\n        // Check default group (autoincrement starts at 1 so force it to be 0)\n        $sql        = \"SELECT `id`, `name` FROM `catalog_filter_group` WHERE `name` = 'DEFAULT';\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_assoc($db_results);\n        if (!array_key_exists('id', $row) || ($row['id'] ?? '') != 0) {\n            debug_event(self::class, 'fix_preferences restore DEFAULT catalog_filter_group', 2);\n            // reinsert missing default group\n            $sql = \"INSERT IGNORE INTO `catalog_filter_group` (`name`) VALUES ('DEFAULT');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `catalog_filter_group` SET `id` = 0 WHERE `name` = 'DEFAULT';\";\n            Dba::write($sql);\n            $sql        = \"SELECT MAX(`id`) AS `filter_count` FROM `catalog_filter_group`;\";\n            $db_results = Dba::read($sql);\n            $row        = Dba::fetch_assoc($db_results);\n            $increment  = (int)($row['filter_count'] ?? 0) + 1;\n            $sql        = \"ALTER TABLE `catalog_filter_group` AUTO_INCREMENT = $increment;\";\n            Dba::write($sql);\n        }\n\n        /* Get All Preferences for the current user */\n        $sql          = \"SELECT * FROM `user_preference` WHERE `user` = ?\";\n        $db_results   = Dba::read($sql, array($user_id));\n        $results      = array();\n        $zero_results = array();\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $pref_id = $row['preference'];\n            // Check for duplicates\n            if (isset($results[$pref_id])) {\n                $sql = \"DELETE FROM `user_preference` WHERE `user` = ? AND `preference`= ? AND `value` = ?;\";\n                Dba::write($sql, array($user_id, $row['preference'], $row['value']));\n            } else {\n                // if its set\n                $results[$pref_id] = 1;\n            }\n        } // end while\n\n        // If your user is missing preferences we copy the value from system (Except for plugins and system prefs)\n        if ($user_id != '-1') {\n            $sql        = \"SELECT `user_preference`.`preference`, `user_preference`.`value` FROM `user_preference`, `preference` WHERE `user_preference`.`preference` = `preference`.`id` AND `user_preference`.`user`='-1' AND `preference`.`catagory` NOT IN ('plugins', 'system');\";\n            $db_results = Dba::read($sql);\n            /* While through our base stuff */\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $key                = $row['preference'];\n                $zero_results[$key] = $row['value'];\n            }\n        } // if not user -1\n\n        // get me _EVERYTHING_\n        $sql = \"SELECT * FROM `preference`\";\n\n        // If not system, exclude system... *gasp*\n        if ($user_id != '-1') {\n            $sql .= \" WHERE catagory !='system';\";\n        }\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $key = $row['id'];\n\n            // Check if this preference is set\n            if (!isset($results[$key])) {\n                if (isset($zero_results[$key])) {\n                    $row['value'] = $zero_results[$key];\n                }\n                $sql   = \"INSERT INTO user_preference (`user`, `preference`, `value`) VALUES (?, ?, ?)\";\n                Dba::write($sql, array($user_id, $key, $row['value']));\n            }\n        } // while preferences\n    } // fix_preferences\n\n    /**\n     * delete\n     * deletes this user and everything associated with it. This will affect\n     * ratings and total stats\n     * @return boolean\n     */\n    public function delete()\n    {\n        // Before we do anything make sure that they aren't the last admin\n        if ($this->has_access(100)) {\n            $sql        = \"SELECT `id` FROM `user` WHERE `access`='100' AND id != ?\";\n            $db_results = Dba::read($sql, array($this->id));\n            if (!Dba::num_rows($db_results)) {\n                return false;\n            }\n        } // if this is an admin check for others\n\n        // Delete the user itself\n        $sql = \"DELETE FROM `user` WHERE `id` = ?\";\n        Dba::write($sql, array($this->id));\n\n        // Delete custom access settings\n        $sql = \"DELETE FROM `access_list` WHERE `user` = ?\";\n        Dba::write($sql, array($this->id));\n\n        $sql = \"DELETE FROM `session` WHERE `username` = ?\";\n        Dba::write($sql, array($this->username));\n\n        Catalog::count_table('user');\n        static::getUserRepository()->collectGarbage();\n\n        return true;\n    } // delete\n\n    /**\n     * is_online\n     * delay how long since last_seen in seconds default of 20 min\n     * calculates difference between now and last_seen\n     * if less than delay, we consider them still online\n     * @param integer $delay\n     * @return boolean\n     */\n    public function is_online($delay = 1200)\n    {\n        return time() - $this->last_seen <= $delay;\n    } // is_online\n\n    /**\n     * get_recently_played\n     * This gets the recently played items for this user respecting\n     * the limit passed. ger recent by default or oldest if $newest is false.\n     * @param string $type\n     * @param integer $count\n     * @param integer $offset\n     * @param boolean $newest\n     * @return array\n     */\n    public function get_recently_played($type, $count, $offset = 0, $newest = true)\n    {\n        $ordersql = ($newest === true) ? 'DESC' : 'ASC';\n        $limit    = ($offset < 1) ? $count : $offset . \",\" . $count;\n\n        $sql        = \"SELECT `object_id`, MAX(`date`) AS `date` FROM `object_count` WHERE `object_type` = ? AND `user` = ? GROUP BY `object_id` ORDER BY `date` \" . $ordersql . \" LIMIT \" . $limit . \" \";\n        $db_results = Dba::read($sql, array($type, $this->id));\n\n        $results = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row['object_id'];\n        }\n\n        return $results;\n    } // get_recently_played\n\n    /**\n     * Get item fullname.\n     * @return string\n     */\n    public function get_fullname()\n    {\n        if (!isset($this->f_name)) {\n            $this->f_name = ($this->fullname_public)\n                ? $this->fullname\n                : $this->username;\n        }\n\n        return $this->f_name;\n    }\n\n    /**\n     * Get item link.\n     * @return string\n     */\n    public function get_link()\n    {\n        // don't do anything if it's formatted\n        if (!isset($this->link)) {\n            $web_path   = AmpConfig::get('web_path');\n            $this->link = $web_path . '/stats.php?action=show_user&user_id=' . $this->id;\n        }\n\n        return $this->link;\n    }\n\n    /**\n     * Get item name based on whether they allow public fullname access.\n     * @param int $user_id\n     * @return string\n     */\n    public static function get_username($user_id)\n    {\n        $users = static::getUserRepository()->getValidArray(true);\n\n        return (isset($users[$user_id]))\n            ? $users[$user_id]\n            : T_('System');\n    }\n\n    /**\n     * get_avatar\n     * Get the user avatar\n     * @param boolean $local\n     * @param array $session\n     * @return array\n     */\n    public function get_avatar($local = false, $session = array())\n    {\n        $avatar = array();\n        $auth   = '';\n        if (array_key_exists('t', $session) && $session['s']) {\n            $auth = '&t=' . $session['t'] . '&s=' . $session['s'];\n        } elseif (array_key_exists('auth', $session)) {\n            $auth = '&auth=' . $session['auth'];\n        }\n        $avatar['title'] = T_('User avatar');\n        $upavatar        = new Art($this->id, 'user');\n        if ($upavatar->has_db_info()) {\n            $avatar['url']        = ($local ? AmpConfig::get('local_web_path') : AmpConfig::get('web_path')) . '/image.php?object_type=user&object_id=' . $this->id . $auth;\n            $avatar['url_mini']   = $avatar['url'];\n            $avatar['url_medium'] = $avatar['url'];\n            $avatar['url'] .= '&thumb=4';\n            $avatar['url_mini'] .= '&thumb=5';\n            $avatar['url_medium'] .= '&thumb=3';\n        } else {\n            foreach (Plugin::get_plugins('get_avatar_url') as $plugin_name) {\n                $plugin = new Plugin($plugin_name);\n                if ($plugin->load(Core::get_global('user'))) {\n                    $avatar['url'] = $plugin->_plugin->get_avatar_url($this);\n                    if (!empty($avatar['url'])) {\n                        $avatar['url_mini']   = $plugin->_plugin->get_avatar_url($this, 32);\n                        $avatar['url_medium'] = $plugin->_plugin->get_avatar_url($this, 64);\n                        $avatar['title'] .= ' (' . $plugin->_plugin->name . ')';\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (!array_key_exists('url', $avatar)) {\n            $avatar['url']        = ($local ? AmpConfig::get('local_web_path') : AmpConfig::get('web_path')) . '/images/blankuser.png';\n            $avatar['url_mini']   = $avatar['url'];\n            $avatar['url_medium'] = $avatar['url'];\n        }\n\n        return $avatar;\n    } // get_avatar\n\n    /**\n     * @param string $data\n     * @param string $mime\n     * @return boolean\n     */\n    public function update_avatar($data, $mime = '')\n    {\n        debug_event(self::class, 'Updating avatar for ' . $this->id, 4);\n\n        $art = new Art($this->id, 'user');\n\n        return $art->insert($data, $mime);\n    }\n\n    /**\n     *\n     * @return boolean\n     */\n    public function upload_avatar()\n    {\n        $upload = array();\n        if (!empty($_FILES['avatar']['tmp_name']) && $_FILES['avatar']['size'] <= AmpConfig::get('max_upload_size')) {\n            $path_info      = pathinfo($_FILES['avatar']['name']);\n            $upload['file'] = $_FILES['avatar']['tmp_name'];\n            $upload['mime'] = 'image/' . $path_info['extension'];\n            $image_data     = Art::get_from_source($upload, 'user');\n\n            if ($image_data !== '') {\n                return $this->update_avatar($image_data, $upload['mime']);\n            }\n        }\n\n        return true; // only worry about failed uploads\n    }\n\n    public function delete_avatar()\n    {\n        $art = new Art($this->id, 'user');\n        $art->reset();\n    }\n\n    /**\n     * rebuild_all_preferences\n     * This rebuilds the user preferences for all installed users, called by the plugin functions\n     */\n    public static function rebuild_all_preferences()\n    {\n        // Garbage collection\n        $sql = \"DELETE `user_preference`.* FROM `user_preference` LEFT JOIN `user` ON `user_preference`.`user` = `user`.`id` WHERE `user_preference`.`user` != -1 AND `user`.`id` IS NULL;\";\n        Dba::write($sql);\n        // delete system prefs from users\n        $sql = \"DELETE `user_preference`.* FROM `user_preference` LEFT JOIN `preference` ON `user_preference`.`preference` = `preference`.`id` WHERE `user_preference`.`user` != -1 AND `preference`.`catagory` = 'system';\";\n        Dba::write($sql);\n\n        // How many preferences should we have?\n        $sql        = \"SELECT COUNT(`id`) AS `pref_count` FROM `preference` WHERE `catagory` != 'system';\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_assoc($db_results);\n        $pref_count = (int)$row['pref_count'];\n        // Get only users who have less preferences than excepted otherwise it would have significant performance issue with large user database\n        $sql        = \"SELECT `user` FROM `user_preference` GROUP BY `user` HAVING COUNT(*) < $pref_count\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            self::fix_preferences($row['user']);\n        }\n        // Fix the system user preferences\n        self::fix_preferences(-1);\n\n        return true;\n    } // rebuild_all_preferences\n\n    /**\n     * stream_control\n     * Check all stream control plugins\n     * @param array $media_ids\n     * @param User|null $user\n     * @return boolean\n     */\n    public static function stream_control($media_ids, User $user = null)\n    {\n        if ($user === null) {\n            $user = Core::get_global('user');\n        }\n\n        foreach (Plugin::get_plugins('stream_control') as $plugin_name) {\n            $plugin = new Plugin($plugin_name);\n            if ($plugin->load($user)) {\n                if (!$plugin->_plugin->stream_control($media_ids)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @deprecated inject dependency\n     */\n    private function getIpHistoryRepository(): IpHistoryRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(IpHistoryRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated inject dependency\n     */\n    private static function getUserRepository(): UserRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(UserRepositoryInterface::class);\n    }\n}\n"], "fixing_code": ["# CHANGELOG\n\n## Ampache 5.5.6-release\n\nThis release imports the API code cleanup from Ampache Develop which has fixed a lot of data issues.\n\nThere will probably not be another big change to Ampache 5 as work has moved to Ampache6 but there will be more bugfix releases if needed.\n\n### Changed\n\n* Scrutinizer moved to php8.1\n\n### Fixed\n\n* Spotify art collector (**AGAIN**)\n* get_now_playing `has_access` check\n* Malformed HTML for regular users in preferences sidebar\n* Missing translation on preferences sidebar\n* Default catalog_filter group could be missing on a new install\n* Gather genre tags when not an array\n* Display webp images\n* Check for a valid image extensions when uploading art\n\n## API 5.5.6\n\nFix various runtime errors and incorrect parameters for responses.\n\n### Changed\n\n* API browses all point to the Api class\n* Use `FILTER_VALIDATE_IP` on ping calls\n\n### Fixed\n\n* Api5\n  * `songs` set_filter call without browse parameter may have lost info\n  * `get_indexes` set album_artist filter correctly\n  * `artists` set album_artist filter correctly\n  * `share_create` undefined filter check\n* Api4\n  * `songs` set_filter call without browse parameter may have lost info\n  * `get_indexes` set album_artist filter correctly\n  * `timeline` incorrect JSON attribute `data` instead of `date`\n  * `catalogs` JSON had incorrect data for `last_add` and missing `enabled`\n  * `albums` return an empty response with a bad artist id\n  * `download` url parameter order matching \"client, action, cache\"\n  * `catalogs` undefined filter check\n  * `podcast` undefined filter check\n  * `podcast_edit` undefined filter check\n  * `podcasts` undefined filter check\n  * `share_create` undefined filter check\n  * `share_edit` undefined filter check\n* Api3\n  * `album_songs` return an empty response with a bad album id\n  * `artist_albums` return an empty response with a bad artist id\n  * Calls to `songs` with user ID instead of user object\n\n## Ampache 5.5.5-release\n\nThis release fixes up all the issues I created with the bad release files as well as an art search issue I missed until after the release.\n\n### Fixed\n\n* Set etag for image cache\n* Spotify art collector\n* Double scrub string in catalog search rules\n\n## API 5.5.5\n\n**NO CHANGE**\n\n## Ampache 5.5.4-release\n\n### Added\n\n* Database 550005\n  * Add `song_artist` and `album_artist` maps to catalog_map\n\n### Changed\n\n* Update catalog map tables based on the catalog action\n* Force `b` and `n` for back, next in webplayer (was overwritten with `[` and `]`)\n\n### Fixed\n\n* Missing tables on a fresh install\n* Not filtering song_artist on album_artist browses\n* Don't use catalog_filter and rating_filter without a valid user\n* Uploaded/Manual Album Artist maps on tag update\n* Delete artist's from the catalog_map that don't have a song or album for that catalog\n* Set correct transcode `bitrate` and `mime` for songs on play_url calls\n* Save Track Order when viewing all the items\n* Use cache_target for cached song cleanup (was hardcoded to mp3)\n* RSS Feed generation with bad characters\n* Don't spam the artist description for each song\n* Show better Trending Dashboard section\n* Subsonic\n  * Art for artist index arrays was missing\n* Search\n  * SQL for Artist `catalog` searches\n  * Make sure saved rules match the correct names on load\n* CLI\n  * Don't try to update a database when the connection fails\n\n## API 5.5.4\n\n### Fixed\n\n* User count in Api::ping and Api::handshake was doubled\n* Api3::stats method had incorrect recent parameters\n* Ensure the output `bitrate` and `mime` are set for song objects\n\n## Ampache 5.5.3-release\n\n### Changed\n\n* Update copyright year in footer.inc.php\n* Localplay status and instance_fields function cleanup\n* Update some docker files to match current images\n* Allow adding streams to playlists (including rightbar)\n* Shuffle the top 100 albums for Popular Dashboard section\n* webplayer\n  * Another code rework, remove the old 'original' list\n  * Shuffle is an action instead of a state of the playlist\n\n### Fixed\n\n* Hidden Genres shouldn't have a catalog\n* Streaming with certain parameters could not identify a session/user\n* Should be counting podcast objects in stats\n* Null artist->id on wanted pages\n* Search\n  * Album 'other_user' favorite searches\n* Subsonic\n  * Error if you didn't have data when using get_user_data\n  * Response data might fall back to mp3 and not match the output format\n  * Incorrect `playqueue_date` call for user playqueue\n* webplayer\n  * Reordering the list could lose track of items\n  * Remove single item from list could create a weird list\n  * Remove the final track when it's finished playing (if you've set that option)\n\n## API 5.5.3\n\n**NO CHANGE**\n\n## Ampache 5.5.2-release\n\n### Added\n\n* Check for upload_catalog before showing upload pages\n* Search\n  * Class rework and many additional aliases, check the docs for [advanced_search](https://ampache.org/api/api-advanced-search)\n  * Add `song_artist` as a search type (uses artist rules)\n  * Add `album_artist` as a search type (uses artist rules)\n  * Add `song_genre`, `mbid_artist`, `mbid_song` to album search\n  * Add `song_genre`, `mbid_album`, `mbid_song` to artist search\n  * Add `possible_duplicate_album` to song search\n* webplayer\n  * Code cleanup and attempt to make it a bit less confusing\n\n### Changed\n\n* Do not overwrite a custom Artist/Album when updating from tags\n* Ignore case when comparing Genre\n* Show an error on share create failures\n* Pull some function back into the search class\n* When searching without rules treat it like a browse and return results unfiltered\n\n### Fixed\n\n* Tmp_Playlist::get_items may not order by the playlist id\n* Fix album time update when time is NULL\n* Transcoding format could be ignored (`encode_player_webplayer_target`)\n* Set the file extension based on expected transcode / download format\n* Don't look at the transcode cache when downloading a raw file\n* If you are transcoding redirect to the transcoded file\n* Download stats for song, video, podcast_episode\n* Set the file extension for urls on generation\n* Don't overwrite artist art when searching for album art\n* Retrieve song art from tags the same way they are found ('invalid' art)\n* Searching from the search bar did not pickup up the rules for the search page\n* Upload artist, album and license selection\n* Don't show hidden Genres on object rows\n* Video needs get_f_link function\n* Playlists need to be in catalog_map table\n* Insert Podcasts more often in catalog_map\n* Subsonic basic auth may get filtered\n* Don't filter auth in the PlayAction if sent\n* Search\n  * Correctly identify alias rule types\n  * Bad SQL on 0 rating query for album/artist search\n* webplayer\n  * Desired transcode format not being respected\n  * Video types missing from supported types\n  * Playlist sorting issues\n\n## API 5.5.2\n\n### Added\n\n* advanced_search\n  * Add `song_artist` as a search type (uses artist rules)\n  * Add `album_artist` as a search type (uses artist rules)\n  * Add `song_genre`, `mbid_artist`, `mbid_song` to album search\n  * Add `song_genre`, `mbid_album`, `mbid_song` to artist search\n  * Add `possible_duplicate_album` to song search\n\n### Fixed\n\n* advanced_search\n  * unable to retrieve song_artist or album_artist results\n\n## Ampache 5.5.1\n\nI made a mistake in the release string so we need a new point release already!\n\n### Added\n\n* Translation Updates August 2022\n* Grouping for label search items\n\n### Fixed\n\n* Release version string is incorrect and will tell you you have updates if you use the release files\n* Missing comma between label links on song pages\n\n## API 5.5.1\n\n**NO CHANGE**\n\n## Ampache 5.5.0\n\nPrivate catalogs have been given a lot of love. This feature allows you to assign a catalog to multiple users instead of just one.\n\nCheck out the [wiki](https://github.com/ampache/ampache/wiki/catalog-filters) for more information about this feature.\n\n**NOTE** Any user that has a private catalog will have their own filter group created which includes all public catalogs\n\nPHP8.1 has now been fixed up completely and is now fully supported.\n\n### Added\n\n* Update Copyright notice to 2022\n* Added a new option 'Random Play' (shuffle) to playlists and smartlists\n* Add 'Recently Skipped' to user pages\n* Add Podcast Episodes to the browse pages and sidebar\n* Translate podcast episode state and some other missing ones\n* Allow using a smartplaylist in Democratic play\n* Allow podcast_episode table sort by `time` and `state`\n* Allow podcast table sort by `website` and `episodes`\n* Database 550004\n  * Add system preference `demo_use_search`, Use smartlists for base playlist in Democratic play\n  * Add tables `catalog_filter_group` and `catalog_filter_group_map` for catalog filtering by groups\n  * Add column `catalog_filter_group` to `user` table to assign a filter group\n  * Migrate catalog `filter_user` settings to the `catalog_filter_group` table\n  * Assign all public catalogs to the DEFAULT group\n  * Drop table `user_catalog`\n  * Remove `filter_user` from the `catalog` table\n* Search\n  * Added more missing groups to search type lists\n  * Added missing `song` (was `song_title`) to album searches\n  * Add `podcast` as a search type\n    * Add rule `title`\n    * Add rule `podcast_episode` (Search by podcast episode name)\n    * Add rule `time` (Episode length in minutes)\n    * Add rule `state` (Completed, Pending Skipped)\n    * Add rule `file`\n    * Add rule `added`\n    * Add rule `pubdate` (Episode Publication Date)\n  * Add `podcast_episode` as a search type\n    * Add rule `title`\n    * Add rule `podcast` (Search by podcast name)\n    * Add rule `time` (Length in minutes)\n    * Add rule `state` (Completed, Pending Skipped)\n    * Add rule `file`\n    * Add rule `added`\n    * Add rule `pubdate` (Publication Date)\n  * Add `genre` as a search type\n    * Add rule `title`\n* CLI\n  * Add verify for podcast catalogs (fix time and size from tags)\n\n### Changed\n\n* Private catalogs have been migrated into [Catalog filters](https://github.com/ampache/ampache/wiki/catalog-filters)\n* Interface cookies for the sidebar state have new names matching their page and group\n* Made getID function required for library_item's\n* Update codeql-analysis.yml to v2\n* When streaming a Democratic or Random item, redirect to the result\n* Hide 'is_true' boxes on search rows (you can't change it so why show it?)\n* Hide action buttons from random and demo webplayer lists\n\n### Fixed\n\n* The cookies for the interface sidebar had multiple issues holding and restoring status\n* Removed **A LOT** of FILTER_SANITIZE_STRING from code for PHP8.1\n* Errors on empty values when loading the UI rows\n* Lots of docstring and code issues\n* Fixed up deleting plays (and now skips) on the user pages\n* Sorting playlist, user and smartlist names in search rows\n* SQL in get_tags when catalog_filter is disabled\n* A lot of browse filters were missing for certain object types\n* Don't try to load the playlist dialog from the webplayer when you can't add things\n* When using random/Democratic play send the additional parameters to the actual media\n* Respect play urls with transcode_to instead of format\n* Updated example `docs/examples/inotifywait.sh`\n* Podcast_episode browse may sent a camel case argument\n* Null max_upload_size could still be counted as a limit\n* Search\n  * SQL might have connected AND and OR incorrectly\n  * Metadata search might have badly parsed input\n  * Added aliases for some of the confusing search types\n* Subsonic\n  * Checking parameters might return the error AND the empty response\n\n## API 5.5.0\n\nThis will likely be the last 5.x API release. API6 will be a continuation of API5 and not be a significant change like the 4->5 transition.\n\n### Added\n\n* Api::stream add new types `playlist` and `search` (Streams a random object from these lists)\n* Api::download add new types `playlist` and `search`\n* advanced_search\n  * Add `podcast` as a search type\n    * Add rule `title`\n    * Add rule `podcast_episode` (Search by podcast episode name)\n    * Add rule `time` (Episode length in minutes)\n    * Add rule `state` (Completed, Pending Skipped)\n    * Add rule `file`\n    * Add rule `added`\n    * Add rule `pubdate` (Episode Publication Date)\n  * Add `podcast_episode` as a search type\n    * Add rule `title`\n    * Add rule `podcast` (Search by podcast name)\n    * Add rule `time` (Length in minutes)\n    * Add rule `state` (Completed, Pending Skipped)\n    * Add rule `file`\n    * Add rule `added`\n    * Add rule `pubdate` (Publication Date)\n  * Add `genre` as a search type\n    * Add rule `title`\n\n### Fixed\n\n* API4::get_indexes podcast_episode was encoding into the API5 object\n* API4::share_create was unable to share when using lowercase types\n* advanced_search\n  * Added missing `song` (was `song_title`) to album searches\n\n## Ampache 5.4.1-release\n\n### Added\n\n* Put next (n) and back (b) shortcuts in the web_player\n* Allow _ and % wildcards for hiding playlists (api_hidden_playlists)\n* Missing translations on CLI strings\n* Config version 62\n  * Added webplayer_debug (was previously undocumented/hidden)\n* Search\n  * Add `track` to song search\n  * Add `summary` to artist search\n* CLI\n  * New argument for cleanup:sortSongs `-w|--windows` Replace windows-incompatible strings with _\n  * Add a table check function to admin:updateDatabase. This will repair missing tables/details\n\n### Changed\n\n* Only enforce `subsonic_always_download` for song objects\n* Always insert podcast source urls. But mark them as skipped if out of date\n* When adding a podcast feed, sync everything\n* Don't trim search input (e.g. allow single spaces for search)\n\n### Fixed\n\n* web_player being unable to play different formats in some cases\n* Playlist download button missing ID\n* Truncate long podcast episode author lengths\n* Incorrect link on the albums page\n* Section on the information sidebar looking for the wrong cookie\n* Bad verify mod time check\n* SongSorter would get caught with % in your strings\n* Rating Match plugin may overwrite album rating\n* Artist getRandom using the wrong sql column name\n* Pocast episode time regex\n\n## API 5.4.1\n\n### Added\n\n* Include `lyrics` in Song objects\n* advanced_search\n  * Add `file` to album and artist search\n  * Add `track` to song search\n  * Add `summary` to artist search\n\n## Ampache 5.4.0-release\n\n### Added\n\n* Translation Updates May 2022\n* Search\n  * Add `file` to album and artist search\n* CLI\n  * New argument for run:updateCatalog `-f|--find` Find missing files and print a list of filenames\n  * New argument for cleanup:sortSongs `-f|--files` Rename files and keep them in the current folder\n  * New argument for cleanup:sortSongs `-l|--limit` Limit how many moves to allow before stopping\n  * New argument for cleanup:sortSongs `[catalogName]` Name of Catalog (optional)\n* Database 540002\n  * Index `title` with `enabled` on `song` table to speed up searching\n  * Index `album` table columns; `catalog`, `album_artist`, `original_year`, `release_type`, `release_status`, `mbid`, `mbid_group`\n  * Index `object_type` with `date` in `object_count` table\n\n### Changed\n\n* Moved to php-cs-fixer 3\n* Update from tags now shows an 'Error' status if there was an issues reading the file\n\n### Fixed\n\n* SQL for random artist with mapping\n* SQL for servers < 5.0.0 might try to insert into a missing table\n* Respect grouping for song_count searches\n* Autoplay in xbmc localplay and conform to localplay api\n* Ungrouped albums were forced into groups\n* Artists array should overwrite artist_mbid arrays that are smaller\n* Some empty globals relating to user\n* More work on the forked Jplayer playlist code when using `play last`\n* DAAP play urls\n* Single disk download links on group pages\n* CLI\n  * cleanup:sortSongs was broken (It actually works again)\n  * cleanup:sortSongs removes incomplete copied files after failure\n\n## API 5.4.0\n\n### Added\n\n* advanced_search\n  * Add `file` to album and artist search\n\n## Ampache 5.3.3-release\n\n### Added\n\n* Remove duplicates and order largest to smallest for art search\n* Allow update_from_tags for a single Song from it's page\n* Search\n  * Add `song_title` to album search\n  * Add `album_title` and `song_title` to artist search\n  * Add `orphaned_album` to song search\n\n### Changed\n\n* Default art_search_limit raised to 15\n* web_player shuffle improvements\n  * Current selected track will become the first track and everything else shuffled below it\n  * Playlist isn't automatically played so if a song was playing, it will continue to play\n\n### Fixed\n\n* Speed up stream_playlist generation by chunking into blocks\n* Make sure there is an object_id to fill in update_530006\n* Remove song mapping on delete\n* Make sure podcast descriptions don't overfill the column\n* Clean dead total wasn't returned on completion\n* Searching for albums with '# Played' with grouping enabled with album_map\n* Adding a new xbmc localplay\n* Catalog type filter in get_top_sql\n* Subsonic\n  * Fixed the query searches (Again) based on the wildcards different clients may send\n  * Song discNumber was sending the MAX disk instead of the actual disk\n  * getPlayQueue doesn't change back to miliseconds from seconds\n\n## API 5.3.3\n\n### Added\n\n* advanced_search\n  * Add `song_title` to album search\n  * Add `album_title` and `song_title` to artist search\n  * Add `orphaned_album` to song search\n\n### Fixed\n\n* Api4::record_play had the `user` as mandatory again\n* After catalog actions; verify songs with an orphaned album which you won't be able to find in the ui\n\n## Ampache 5.3.2-release\n\nSome QoL fixes here with some initial SubSonic, Search and that database column again!\n\n### Added\n\n* Look for orphaned maps to delete.\n* Get server timezone for get_datetime (date_default_timezone_get())\n* Allow deleting played activity from the ui and count using a function (Require: 100)\n\n### Changed\n\n* Updated the translation gathering process a little\n* Organized the play/skip counting into it's own function\n* Update artist from tags needs to update albums first\n* Subsonic\n  * Only search for song title instead of everything\n  * Add starred to directory elements\n\n### Fixed\n\n* Format on an empty album would complain in the log\n* Update from tags might not remove the old song artist\n* Migrating to a new album would leave old album maps\n* Artist search query with mapping was very slow\n* Database column check not included in 5.3.1 correctly\n* Subsonic\n  * Get recently played\n  * Fixed up search queries using \"\" (wrapping in quotes means exact search)\n\n## API 5.3.2\n\n**NO CHANGE**\n\n## Ampache 5.3.1-release\n\nThere were a few reports of some databases missing an important column. This release makes sure it's there.\n\n### Added\n\n* Docker compose files to help create a local dev environment (read docker/README.md for more info)\n* Added php8.1 to composer (**still considered unstable**)\n\n### Changed\n\n* Began rework of Subsonic modules\n\n### Fixed\n\n* Database missing rsstoken column in the user table\n* gather-messages.sh was finding lots more strings than it needed\n* Query sql with ambiguous ID\n* New song import might not map all the artists\n* Catalog query missing a comma\n\n## API 5.3.1\n\n**NO CHANGE**\n\n## Ampache 5.3.0-release\n\nThis cycle we have added support for multiple Album and Song artists.\n\nThis allows multiple artists to be part of a single song/album object and is created from file tags.\n\nCheck out the [wiki](https://github.com/ampache/ampache/wiki/multi-artist) for more information about this feature.\n\nThe old and long ignored module [jPlayer](https://github.com/jplayer/jPlayer) has been forked into the base Ampache code.\n\nThere have been a few fixes and changes to the module to make the webplayer a lot better to use.\n\n### Added\n\n* Additional xhtml templates added\n* Parse lots more WMA (ASF) file tags\n* Add play next and play last to radio station rows\n* Additional option for artist pages 'Show Artist Songs'\n* Add some missing tag options for mpc files\n* Allow manually syncing Artist name, year formed and place formed from musicbrainz (if it has an mbid)\n* Notify and allow updating Plugins when updates are available\n* You can now unhide a tag from the 'Hidden' page for Genres\n  * This will delete previous merges but it will not retag your songs (update from tags to fix that)\n* Config version 61\n  * Add disable_xframe_sameorigin (allow disabling \"X-Frame-Options: SAMEORIGIN\")\n  * Disable catalog_verify_by_time by default\n* Database 530016\n  * Create `artist_map` table and fill it with data\n  * Create `album_map` table and fill it with data\n  * Use `song_count` & `artist_count` using `album_map`\n  * Drop id column from `catalog_map` table and alter object_type charset and collation\n  * Alter `album_map` table charset and engine to MyISAM if engine set\n  * Alter `artist_map` table charset and engine to MyISAM if engine set\n  * Make sure `object_count` table has all the correct primary artist/album rows\n  * Convert basic text columns into utf8 to reduce index sizes\n  * Remove `user_activity` columns that are useless\n  * Delete duplicate rows on `object_count`\n  * Compact mbid columns back to 36 characters\n  * Compact some `user` columns\n  * enum `object_count`.`count_type`\n  * Index data on object_count\n  * Use a unique index on `object_count`\n  * Compact `cache_object_count`, `cache_object_count_run` columns\n  * Add `show_album_artist` and `show_artist` preferences to show/hide Sidebar Browse menu links\n* Search\n  * Add `songrating` to album search (My Rating (Song))\n  * Add `songrating` (My Rating (Song)) and `albumrating` (My Rating (Album)) to artist search\n  * Allow empty/null searches for all mbid searches\n  * Allow empty/null searches for label searches\n  * Add `song_count` to album and artist search\n  * Add `album_count` to artist search\n  * Add `myplayedartist` (Played by Me (Artist)) to album search\n  * Add `song_artist` to album search\n  * Add alias `album_artist` to album search for `artist` searches\n  * Add `recent_added` to album search\n\n### Changed\n\n* Clean up artists with a duplicate MBID (Use the lowest artist id)\n* Delete cached recommendations instead of trying to update (Really slow)\n* Artist::check uses MBID on lookups as well as name\n* update_from_tags: Only update counts, tags and garbage collect after changes found\n* Use albums instead of songs for catalog verify actions\n* Expand search sidebar menu and collapse information without cookies\n* Moved all the extended functions into the forked jplayer module\n* Instead of skipping duplicate songs on import, disable them\n* jPlayer (Webplayer):\n  * Shuffle now follows the currently playing track (If playing)\n  * Shuffle also does not track the old playlist so you can't undo a shuffle\n* Subsonic\n  * Check for art instead of always sending an art attribute\n\n### Removed\n\n* Search\n  * removed mbid group sql from `possible_duplicate` and `possible_duplicate_album`\n\n### Fixed\n\n* VaInfo time for size/playtime_seconds\n* Tag arrays for Mbid and Artists lookup\n* Deleted item tables would not record some deletions\n* Updating the artist name would always migrate data when not required\n* Artist::check would always create an artist object with readonly set\n* Genres would not update the parent (Song->Album->Artist) whan using update from tags\n* Random sql that uses search rules\n* Use configured Ampache temp directory in Seafile catalog\n* Prepare media before update from tags (Seafile needs to download the file first)\n* Seafile catalog checks for a local file before downloading it again\n* Delete custom_metadata when removed from the object\n* Artist Garbage Collection was way too slow\n* Album and Artist count value sql\n* Don't remove Genre tags when they have been merged (hidden) into a different tag\n* Don't delete merged (hidden) Genres from the tag table\n* Album song_artist_count not calculated correctly\n* Grouping with mbid_group was missing making some albums not possible to view\n* Display and hide of artist columns in some pages based on count\n* Clean and verify would count totals based on all items instead of item type\n* Missing strings from xhtml templates\n* Album grouping for getAlbumSuite with null values\n* Set ratings for all album disks (if grouping enabled) for ratings and flags\n* Issues when you don't have an album artist tag\n* Correctly set null values on library_item edits\n* Search for song art might have sent a Song object\n* Fix missing preference on musicbrainz plugin\n* Disable/enable catalog\n* jPlayer (Webplayer):\n  * Fixed moving items in the playlist\n  * Fixed adding after the current playing track\n  * Fixed logic behind the index and order between the HTML and the JS lists\n* Search\n  * played search for album and artist was including your user in the results\n  * other_user artist search sql\n* Subsonic\n  * Artist was missing starred status\n\n## API 5.3.0\n\n### Added\n\n* advanced_search:\n  * Add `songrating` to album search (My Rating (Song))\n  * Add `songrating` (My Rating (Song)) and `albumrating` (My Rating (Album)) to artist search\n  * Allow empty/null searches for all mbid searches\n  * Allow empty/null searches for label searches\n  * Add `song_count` to album and artist search\n  * Add `album_count` to artist search\n  * Add `myplayedartist` (Played by Me (Artist)) to album search\n  * Add `song_artist` to album search\n  * Add alias `album_artist` to album search for `artist` searches\n  * Add `recent_added` to album search\n\n## Ampache 5.2.1-release\n\n### Added\n\n* Translation Updates Jan 2022\n* Count tables on create and delete actions\n* Set allow-plugins in composer.json\n* Improve description of rss feed to make each play more unique\n* Wait 30 minutes between catalog updates before running update_counts\n* On database connection failure, go to test.php\n* Search\n  * Added no_tag as a possible search item (song, album, artist)\n  * Document the alias names of search rules (docs/API-advanced-search.md)\n  * Add playlist and playlist_name search to artist types\n\n### Changed\n\n* AmpachePersonalFavorites: double the playlist title height\n* Move get_f_link from playlist/search into playlist_object\n* Make some functions that do the same thing use the same variable names\n* Don't optimize tables when doing full_service catalog updates\n* Use parameters in search queries instead of printing them into the query\n* Logout action requires a session id now to log out\n* Update mapping more often after catalog actions\n* Album check function added mbid_group to lookup\n* Support database upgrades from version 350008 (Ampache 3.5.4)\n* Remove additional 'Details' string from song/video and radio pages\n* Tag value is being extra filtered in the edit screen\n* Hide the login link when using simple_user_mode and no auth is set **note** this does not stop you logging in with /login.php\n* When not using auth, keep recording stats for system user plays\n* Hide username column from Recently Played when not authed as a user\n\n### Fixed\n\n* Lowercase package names in composer\n* CLI add user\n* Demo Systemd timer files WantedBy\n* Some missing garbage collection for some tables\n* Phantom html table row in show_catalogs page\n* Grouping albums with special characters\n* Searching albums with special characters\n* Lots more PHP8 runtime errors\n* SQL for artists in catalog_map\n* Typo in url for update_all_file_tags\n* SQL error in database update 500013 (Not fatal)\n* Don't garbage_collect tags after merging\n* Create art URLs correctly when using rewrite rules and no auth\n* Respect sidebar_light preference when no cookie is present\n* Don't try to create users that already exist\n* Add/Edit catalogs in the UI missing filter_user\n* Search\n  * possible_duplicate was grouping too much together\n* Subsonic\n  * Jukeboxcontrol didn't send an index to the client\n\n## API 5.2.1\n\n### Added\n\n* API5\n  * The docs for errors have been extended for the type when returned\n\n### Changed\n\n* API5\n  * Return the xml total_count of playlists based on hide_search preference\n\n### Fixed\n\n* API5\n  * Some errors were returning the value and not the parameter on error\n* API4\n  * update_from_tags: type case error\n  * rate: Object type to class mapping\n  * flag: Object type to class mapping\n  * update_art: Object type to class mapping and type case check\n  * update_from_tags: Object type to class mapping\n  * genre and tag function compatibility\n* API3\n  * stats: incorrect getRandom call\n  * rate: Object type to class mapping\n  * playlist: bad escaping on the playlist id\n\n## Ampache 5.2.0-release\n\nAmpache 5.2.0 (and all future versions) now support multiple API versions. This means that you can send your handshake with a specific version (e.g. 390001, 440001 or 5.2.0) you will be sent API3, API4 and API5 responses in return.\n\nTo change from API3 to API5 you can send a ping with a new version parameter to update your session (or send goodbye to log off and start again.)\n\nAPI3 is not recommended for use outside of running old applications and it is recommended that you turn off API versions you don't use.\n\n### Added\n\n* Get image from more tag types\n* Translation Updates Nov 2021\n* Added the ability to play random songs from a playlist with a play url\n* Update AmpacheRatingMatch.php to allow writing ratings to file tags\n  * Enable 'Save ratings to file tags when changed' on the plugin page\n  * write_tags must be enabled in the config file\n* Config version 59\n  * Removed overwrite_tags (It doesn't do anything)\n  * playlist_art now true by default\n* Database 520005\n  * Make sure preference names are always unique\n  * Add ui options ('api_enable_3', 'api_enable_4', 'api_enable_5') to enable/disable specific API versions\n  * Add ui option ('api_force_version') to force a specific API response (even if that version is disabled)\n  * Add ui option ('show_playlist_username') Show playlist owner username in titles\n  * Add ui option ('api_hidden_playlists') Hide playlists in Subsonic and API clients that start with this string\n  * Add ui option ('api_hide_dupe_searches') Hide searchs in Subsonic and API clients with the same name as playlists (and both owned by you)\n\n### Changed\n\n* Don't try to return objects that aren't there sometimes\n* Update catalog counts before returning API data\n* Fix preferences for system and users after each update\n* Light theme hover color for sidebar\n* Changed some cookie's from Strict to Lax to fix some bugs\n* Check ldap group by username instead of DN\n* Allow gathering random art from playlist contents instead of generating on page load\n\n### Removed\n\n* Remove AssestCache class and functions (unreliable)\n* When recording stats don't ignore based on a hardcoded gap\n\n### Fixed\n\n* test_image function would fail without php-gd (which is optional)\n* Searching for images in files could not return the files you found\n* Get rid of that annoying space on api key text in the WebUI\n* Catalog map for artist tables\n* ratingmatch_stars value 5 wasn't setting itself\n* filter_has_var is returning false in FCGI enabled PHP\n* Allow catalog manager to manage a catalog in the WebUI\n* When using custom metadata don't overwrite managed values\n* Missing (and duplicate) preferences for users and system\n* Size 0 when reading file tags\n* Disk and totaldisks for wma files\n* Genre for quicktime/m4a files\n* Last.fm login impossible with strict cookies\n* Some double scrubs of text in image links\n* Updating playlist user would only update the name and not the ID\n* garbage collection for playlist images\n* Stats when skipping songs with 0 plays\n* More PHP8 runtime errors\n* Fixed single song random playback using a play url\n* Make sure we error if php_intl module isn't found\n\n## API 5.2.0\n\nCheck out the docs for multi API support at [ampache.org](https://ampache.org/api/)\n\n**note** JSON didn't exist for API3 so all json requests from API3 calls will revert to API5\n\n### Added\n\n* Support for API3, API4 and API5 responses including PHP8 support (keeps original tag calls)\n* API5\n  * playlists: add parameter `show_dupes` if true ignore 'api_hide_dupe_searches' setting\n  * get_art: add parameter `fallback` if true return default art ('blankalbum.png') instead of an error\n* API4\n  * playlists: add parameter `show_dupes` if true ignore 'api_hide_dupe_searches' setting\n* API3\n  * Added genre calls as an alias to tag functions to match API4 and API5\n\n### Fixed\n\n* Session and user id identification and errors from that\n* API5\n  * playlists: sql for searches wasn't filtering\n  * Art URL for searches was malformed\n* API4\n  * Art URL for searches was malformed\n* API3\n  * democratic: This method was broken in API3 and never worked correctly\n\n## Ampache 5.1.1-release\n\n### Added\n\n* Clean cache files that aren't in the database\n* Translate random and democratic in the webplayer\n* Add transcode_flv to config\n* Add playlist, playlist_name to album searches\n* Send the user to an error page when the config wasn't written\n* Config version 58\n  * Removed subsonic_stream_scrobble\n* Database 510005\n  * Add `subsonic_always_download` to preferences\n\n### Changed\n\n* Rebuild aurora.js modules from source\n* Perform waveform and cache on disk the same way\n* Move song waveforms on load if in the wrong folder\n* Make genre searches faster with a join instead of select in\n* Send a flat file path for zips when using browse/playlist\n\n### Removed\n\n* Podcast links on the dashboard removed (There is no link for them to go to)\n* Remove subsonic_stream_scrobble from config and make it per user (subsonic_always_download)\n\n### Fixed\n\n* Use addslashes for translations in html5 player\n* Send the generic client name for localplay again\n* Use the set permission level for localplay access\n* Webplayer playlists would become out of order after moving/adding\n* Cache process could cache the wrong song\n* Missing user id in search\n* Grouping sql in search when not grouping albums\n* Setting Localplay instance would not update the preference\n* Advanced search (Random) wasn't working in php8\n* Fixed returning the correct objects for advanced search (Random)\n* Some objects would add transcode_to to their play url\n* Set system prefs for mb and tadb plugins\n* Updating a channel in php8\n* Get tmp_playlist by session (could get confused and never retrieve items)\n* Setting cookies and session details on remember_me sessions\n* Set the catalog parameters for seafile catalogs\n* Database updates for php8\n* Remember me session cookie error when recreating a new session\n* ampache.sql script had AUTO_INCREMENT data it didn't need\n* Subsonic\n  * Get the artists for a single catalog correctly\n  * Browse highest used the sql differently to the UI\n\n## API 5.1.1\n\n### Fixed\n\n* Access to podcast_episode_delete\n* stats calls with an offest and limit\n* advanced_search calls with an offset and limit\n\n## Ampache 5.1.0-release\n\n### Added\n\n* Split search items in WebUI into optgroup categories\n* Add en_AU as a locale\n* Require confirmation on enable/disable user links\n* Add f_size  to video parameters\n* Record plays for live_streams and playlists in object_count\n* Add podcast to the object_count table and add missing rows\n* Store playlist art in the database\n  * Show the art on the main playlist page\n  * Allow reset and change of playlist art\n  * Pick a random art item on reset and store\n  * Add a simple continue button for these dialogs\n  * Fix up display of image showaction\n  * Subsonic art looks for the playlist art the same as UI\n* Check for `?` in a query before trying to use parameters\n* Add the current php version to the debug page\n* Cache bust some frequently updated assets\n* Clear asset cache during AutoUpdate\n* Gather Artist recommendations on play/Stat insert\n* Add Top Tracks and Similar Songs to Artist pages\n* Extend run:updateCatalog --update to update artist name matching mbid\n* Add duplicate_mbid_group to album searches\n* Restored missing artist search to the header searchbar\n* Press enter on the list header to allow changing page number\n* Translation Update October 2021\n* Config version 57\n* NEW config options\n  * allow_upload_scripts: Allow or disallow upload scripts on the server\n* Database 510004\n  * Add `podcast` to object_count table\n  * Add `podcast` to cache_object_count table\n  * Add `live_stream` to the rating table\n  * Add `waveforms` for podcast episodes\n* PHP8 Support\n  * Use array_key_exists to skip runtime errors\n  * Fix undefined variables in templates\n  * Errors with wanted/missing lookups and templates\n  * Ajax handler updates and fixes\n  * Set default and fallback values more often to avoid errors\n  * Query errors would kill the whole page\n  * Stop trying to read unreadable files\n  * Explode key pairs when there is something to explode\n  * Don't try to update preferences that don't exist\n  * Errors when not logged in trying to load a session\n* NEW files\n  * Test scripts: codecoverage.sh, stan.sh, tests.sh\n\n### Changed\n\n* Always update time when updating songs and videos from tags\n* Merge config 'ratings' and 'userflags' checks into ratings. (drop userflags)\n* Split search items into groups to help make it a bit clearer\n* Rearranged the list of search items\n* Simplify PlayAction code a bit and use filter_input\n* Speed up update_counts for missing object_counts\n* Enable Podcasts on new installs\n* Delete composer.lock\n* bin/cli run:updateCatalog with no options now does clean, Add, Verify and gather for all catalogs\n* Make category headers a bit nicer\n* Check for valid browse types before loading nothing\n* Browsing Genre defaults to artist\n* Skip albums that match the exact title in wanted search\n* Translate all database description strings on updates\n* Hi-res blankalbum/placeholder image (1400x1400)\n* Allow larger artist summary with a scroll. linebreak place, year formed\n* During garbage collection clean up empty strings with NULL\n* Subsonic\n  * Disable stat recording on stream calls (disable subsonic_stream_scrobble in config to enable)\n\n### Removed\n\n* object_cnt: use total_count and total_skip instead of calculated properties\n* f_title: use f_name\n* Scrub CSS with Autorprefixer\n\n### Fixed\n\n* SQL query error for Random Album in certain config setups\n* Album suite needed even without grouping\n* Stop scrubbing the podcast title so hard (so many `&amp;`'s)\n* Use total_count and total_skip columns for searches (Fixes searching with 0)\n* Can't change view limit on Android\n* Localplay instance could be 1\n* Missing add_type variable on ACL pages\n* Light theme follow button color\n* Missing CSS on list headers\n* Templates with missing variables\n* Fix Stream_Playlist::_add_urls to stop mismatched query values\n* Fix stream.php downloads not sending their url parameters to PlayAction\n* Garbage collect object_count for the possible items\n* Do not drop catalog in table podcast_episode when it doesn't exist yet\n* AAC codec from itunes doesn't provide a bitrate_mode (assume vbr)\n* bin/cli ExportPlaylistCommand had out of order args\n* bin/cli Allow database updates when out of date\n* Fix computeCache for playlists\n* Logic of SQL query to get random albums\n* Simplify the join code for some queries\n* Don't force random for smartlists when you turn it off\n* Empty release_date when updating videos\n* Chrome errors where Content-Disposition has a comma (,)\n* Remove subtitle in stream_playlist if empty\n* Fix options and bitrate selection for stream.php requests\n* Scrobbles from Song::can_scrobble\n* Default preference list\n* MusicBrainz Artist Id could have been replaced with the Album Id\n* Artists being duplicated when feat. another artist\n* Don't let a non-critical update fail DB update\n* Search for 'played' albums and artists\n* Commands loading plugins from cli might not have a user\n* Dashboard links to podcast episodes and art\n* Lots of issues in the webplayer which only supported song links\n* Clean up deleted user date from all tables\n* Waveforms for podcast episodes\n* Subsonic\n  * Trim quotes (\") for Subsonic searches (some clients add them)\n  * Support exact (lucene) searching when using quotes (\")\n  * Browse by folder is fixed\n  * Faster browse queries for all types\n  * Fix catalog browsing and loading library\n\n### API 5.1.0\n\n### Added\n\n* NEW API functions\n  * Api::live_stream (get a radio stream by id)\n  * Api::live_streams\n* Api::stream Added type 'podcast_episode' ('podcast' to be removed in Ampache 6)\n* Add 'time' and 'size' to all podcast_episode responses\n\n### Changed\n\n* live_stream objects added 'catalog' and 'site_url'\n* stats: additional type values: 'video', 'playlist', 'podcast', 'podcast_episode'\n\n### Fixed\n\n* get_indexes: JSON didn't think live_streams was valid (it is)\n* record_play: user is optional\n* Bad xml tags in deleted functions\n* scrobble: Add song_mbid, artist_mbid, album_mbid (docs have no '_' so support both)\n\n## Ampache 5.0.0-release\n\nAmpache 5 is here and it's big!\n\n* Check out [Ampache 5 for Admins](https://github.com/ampache/ampache/wiki/Ampache-Next-Changes)\n* As well as [Ampache 5 for Users](https://github.com/ampache/ampache/wiki/Ampache-5-for-users)\n* The bin folder has had a major [rework](https://github.com/ampache/ampache/wiki/cli-faq)\n* You can pre cache files using [Transcode Caching](https://github.com/ampache/ampache/wiki/Transcode-Caching)\n\n**IMPORTANT** instead of using date() we are now using IntlDateFormatter and your locale to identify formats.\nThis means that 'custom_datetime' based on the date() format is incorrect and will look weird.\nLook here for the code to change your 'custom_datetime' string [(<http://userguide.icu-project.org/formatparse/datetime>)]\n\nThis means Ampache now **requires** php-intl module/dll to be enabled.\n\n**IMPORTANT** For new installs default database charset/collation and table engine have changed\n\n* Engine MyISAM => InnoDB\n* Charset utf8 => utf8mb4\n* Collation utf8_unicode_ci => utf8mb4_unicode_ci\n\nIf you want to keep utf8 make sure you set it before running updates.\n\n* To keep the current collation/charset update your config file\n  * Set `database_charset = \"utf8\"`\n  * Set `database_collation = \"utf8_unicode_ci\"`\n\n### Added\n\n* Private catalogs! You can now set a public or per user catalog for your music folders\n* Cache transcoded files before a user requests them with [Transcode Caching](https://github.com/ampache/ampache/wiki/Transcode-Caching)\n* Added a CONTRIBUTING.md file\n* php-intl is now required for translation of date formats into your locale\n* Added %R (Release Status) to catalog pattern matching\n* Add ability to hide the Song Artist column for Albums with one Artist\n* Add ability to browse albums by Original Year\n* Add ability to hide the licence column on song pages\n* A helper index.php has been added to the old project root with directions to help\n* Show the country and Active status (Generated tags are assumed active) on label rows\n* Podcast_Episode show episode art for podcast mashup allow sort by date\n* Save a search or Smartlist as a regular playlist\n* New option to refresh a Playlist from Searches with the same name\n* Option to change the playlist owner when editing OR importing\n* Set \"X-Frame-Options: SAMEORIGIN\" on login page\n* Added the ability to export database art when local_metadata_dir is enabled\n* Save more types of thumb to the local_metadata_dir when enabled\n* Inform with a \"Not Found: podcast\" when you haven't created a podcast catalog\n* Added CatalogUpdate import command to the WebUI (Import = Add + playlist imports)\n* Search changes\n  * Add 'possible_duplicate', 'recently_played' to song, artist and album search\n  * Add 'catalog' to artist and album search\n  * Add 'favorite_album', 'favorite_artist' to song search\n  * Add 'release_status' to album search\n  * Add 1, 5 and 10 to the Maximum Results limit\n* Database 500015\n  * Add `song_count`, `album_count`, `album_group_count` to artist table\n  * Add `release_status`, `addition_time`, `catalog`, `song_count`, `artist_count` to album table\n  * Add `mbid`, `country`, `active` to label table\n  * Add `total_count` and `total_skip` to album, artist, song, video and podcast_episode tables\n  * Add `catalog` to podcast_episode table\n  * Add `filter_user` to catalog table\n  * Add `total_count`, `episodes` to podcast table\n  * Add `username` to playlist table\n  * Create catalog_map table (map catalog location for media objects)\n  * Create user_playlist table (Global play queue)\n  * Create user_data table (One shot info for user actions)\n  * Create deleted_song, deleted_video and deleted_podcast_episode tables for tracking deleted files\n* NEW database options\n  * use_original_year: Browse by Original Year for albums (falls back to Year)\n  * hide_single_artist: Hide the Song Artist column for Albums with one Artist\n  * show_license: Hiding the license column in song rows\n  * hide_genres: Hide the Genre column in all browse table rows\n* Config version 56\n* NEW config options\n  * composer_binary_path: Override the composer binary path to distinguish between multiple composer versions\n  * write_tags: Write tag changes to file (including art if available)\n  * art_zip_add: Include Album Art for zip downlaods\n  * catalog_filter: Allow filtering catalogs to specific users\n  * catalog_verify_by_time: Only verify the files that have been modified since the last verify\n  * cache_path: The folder where the pre-transcoded files will be stored\n  * cache_target: Target audio format for the cache\n  * cache_remote: Remote catalogs will cache every file so this is handled separately\n  * catalog_ignore_pattern: Allow you to ignore audio, video and playlist files with a regex\n* NEW cli commands\n  * `run:moveCatalogPath`: Change a Catalog path\n  * `run:cacheProcess`: Run the [cache process](https://github.com/ampache/ampache/wiki/Transcode-Caching)\n  * `export:databaseArt`: Export all database art to local_metadata_dir\n\n### Changed\n\n* get_datetime(): use IntlDateFormatter to format based on locale. [(<https://www.php.net/manual/en/intldateformatter.format.php>)]\n* Renamed 'Tag' strings to 'Genre'\n* Changed sidebar back to browse for artist/album\n* Moved sidebar mashup pages into their own 'Dashboards' section\n* Move artist counts (song, album) to a DB column\n* Global counts are calculated after catalog changes instead of dynamically\n* Display userflag with star ratings\n* Always put year in Spotify art search if available\n* Imported playslists don't add the extension to the title\n* Visually crop images from the centre instead of resizing into a square\n* Display release year if it doesn't macth original_year. e.g. 'Back in Black (2010)'\n* Don't round the average rating to an integer\n* Replace mt_rand with random_bytes for random token generation\n* Move user bandwidth calculations out of the user format function into the user_data table\n* All localplay links use the type (e.g. mpd/upnp) as the agent to fix muti-client access\n* updateCatalog now implies add when using -i / --import by itself\n* Playlist Import checks for playlists by your user only in the UI (System for the cli)\n* Plugins: Use only https for building gravatar urls\n* Scrobble actions now check for the exact time as well (different agents or scripts would insert)\n* If you call a play url without an action we assume stream\n* Use ISO 8601 date for podcast episode pubdate display\n* Database tables default to InnoDB engine with utf8mb4 charset & collation\n* Subsonic\n  * Wait a few seconds before allowing scrobbles to avoid collisions\n  * Shift the last music play if gap is bigger than 5 repeated plays (over night, etc)\n\n### Removed\n\n* Take out the random items (except random search) from the main sidebar (use the playlist on the rightbar instead)\n* 'Find Duplicates' and related pages have been removed. Use 'Possible Duplicate' searches instead\n* 'Genre' and 'Missing Artists' removed from the top search bar\n* Take out the info icon from the song row; just click the song link\n* Take song artist out of the album edit popup\n* File tag reading for Band/Album Artist\n* Corrected album_artist collection and added missing tags to vorbis, aac and id3v2\n* Removed links from album list headers when split by release type\n* REMOVED config options\n  * write_id3: Use write_tags\n  * write_id3_art: Use write_tags\n\n### Fixed\n\n* Delete duplicates from song table\n* Mashup page for podcast_episodes\n* Searching by Genre needed a query overhaul\n* Album groupings are the same everywhere when album_group is enabled\n* Unknown (Orphaned) groups all unknown files into one artist and album\n* Album groups for ratings and userflags\n* SQL queries regarding rating order and grouping of mutliple users\n* Ensure valid media is found before inserting into a playlist\n* Searching by Genre needed a lot of updates to speed up and correct\n* Bump phpmailer/phpmailer from 6.4.1 to 6.5.0 (#2957)\n* Groupings for albums and add original_year to grouping\n* Editing album titles with prefixes\n* CSS fixes for light theme\n* Shares didn't insert into object_count correctly\n* Repair missing rows in object_count after catalog updates\n* Browse / Mashup by podcast_episode\n* Sorting for a lot of browse pages that used arguments\n* Refreshing the details after editing an object didn't include browse aruments\n* Get the correct total artist_count for albums when grouped\n* Some buttons and links in the light theme needed extra CSS\n* Updated the inotifywait.sh example to stop it trying to add the same file multiple times\n* Translations could break JS with apostrophes\n* Playlist imports with an empty web_path would never work\n* Playlist imports were importing nothing\n* List preferences didn't allow null values after being set (Personal Favorites plugin)\n* When using album_art_store_disk the art lookup was hardcoded for jpg\n* Generating thumbnails wouldn't work with album_art_store_disk enabled\n* Updating config values for spotify_art_filter and art_search_limit would not keep your value\n* Delete podcasts and radio streams when deleting a catalog\n* Collect recommendation garbage correctly\n* Empty release date when updating a video would fail\n* Scrub out some link titles that can be abused by uploads\n* Subsonic\n  * Support a global user playqueue with getplayqueue, saveplayqueue\n  * Incorrect header being set on art requests\n  * averageRating wasn't correctly cast for json\n  * bookmark JSON was not correctly converted\n\n### API 5.0.0\n\nAll API code that used 'Tag' now references 'Genre' instead\n\nThis version of the API is the first semantic version. \"5.0.0\"\n\n### Added\n\n* Add global playcount to podcast_episode and video responses\n* searches (the number of saved smartlists) added to the handshake/ping response\n* NEW API functions\n  * Api::song_delete (Delete files when you are allowed to)\n  * Api::user_preferences (Get your user preferences)\n  * Api::user_preference (Get your preference by name)\n  * Api::system_update (Check Ampache for updates and run the update if there is one.)\n  * Api::system_preferences (Preferences for the system user)\n  * Api::system_preference (Get a system preference by name)\n  * Api::preference_create (Add a new preference to Ampache)\n  * Api::preference_edit (Edit a preference value by name; optionally apply to all users)\n  * Api::preference_delete (Delete a preference by name)\n  * Api::labels (list your record labels)\n  * Api::label (get a label by id)\n  * Api::label_artists (get all artists attached to that label)\n  * Api::get_bookmark (See if you've previously played the file)\n  * Api::bookmarks (List all bookmarks created by your account)\n  * Api::bookmark_create (Create a bookmark to allow revisting later)\n  * Api::bookmark_edit (Edit a bookmark)\n  * Api::bookmark_delete (Delete a bookmark by object id, type, user and client name)\n  * Api::localplay_songs (Get the list of songs in your localplay instance)\n  * API::deleted_songs\n  * API::deleted_podcast_episodes\n  * API::deleted_videos\n\n### Changed\n\n* The API version matches release version '5.0.0'\n* A backcompatible version (500000) is sent when using old api versions\n* handshake and ping counts now return the actual object counts for playlists\n  * 'playlists' => $counts['playlist'],\n  * 'searches' => $counts['search'],\n  * 'playlists_searches' => $counts['playlist'] + $counts['search']\n* Renamed functions:\n  * tags => genres\n  * tag => genre\n  * tag_artists => genre_artists\n  * tag_albums => genre_albums\n  * tag_songs => genre_songs\n* Don't allow duplicate podcast feeds\n* Make filter optional in shares, genre_artists, genre_albums, genre_songs (Used as a general catch all method like genres)\n* Error Codes and response structure has changed\n  * 4700 Access Control not Enabled\n  * 4701 Received Invalid Handshake\n  * 4703 Access Denied\n  * 4704 Not Found\n  * 4705 Missing Method\n  * 4706 Depreciated Method\n  * 4710 Bad Request\n  * 4742 Failed Access Check\n* stats: Removed back compat from older versions. Only 'type' is mandatory\n* Return empty objects when the request was correct but the results were empty\n* Don't transcode podcast_episodes\n* localplay\n  * Added 'track' parameter used by 'skip' commands to go to the playlist track (playlist starts at 1)\n* system_update: update the database if required as well\n* playlist_edit: added 'owner' as an optional parameter (Change playlist owner to the user id)\n* catalog_file: Allow comma-separate task values. (good for API inotify scripts)\n* podcast_episode object \"pubdate\" has been changed to ISO 8601 date (2004-02-12T15:19:21+00:00)\n* podcast object \"build_date\" and \"sync_date\" have also been changed to ISO 8601 date\n\n### Fixed\n\n* catalog_file: Couldn't add files\n\n## Ampache 4.4.3-release\n\n### Added\n\n* Catalog::update_counts to manage catalog changes\n* Gather more art files from your tags\n* Allow RatingMatch plugin to rate Album->Artist (Originally Song->Album->Artist)\n\n### Changed\n\n* Calculate MP3 stream length on transcode to avoid cutting it off early\n\n### Removed\n\n* Don't apply an album artist when it isn't distinct\n* MySQL faq isn't needed during install now that PHP 7.4 is a requirement\n\n### Fixed\n\n* CVE-2021-32644\n* Identifying a distinct album_artist query wasn't great\n* Don't return duplicate art while searching file tags\n* SQL query in random::advanced_sql was ambiguous\n* Filtering random and search page type element\n* NowPlaying stats would be overwritten when they didn't need to be\n* Subsonic\n  * getNowPlaying was unable to return playing media or the correct time\n  * createShare would not set the object_id correctly and ignored expires value\n\n### API 4.4.3\n\n**NO CHANGE**\n\n## Ampache 4.4.2-release\n\n### Added\n\n* Larger artist images when you don't have a text summary available\n* Expanded artist, album and podcast thumbnails to reduce blank space\n* Update album tags first when you update artist tags\n\n### Changed\n\n* Simplify flagging/rating multi-disk albums\n* Subsonic\n  * just send getmusicfolders music folders\n  * When calling createPlaylist, assume that the list needs to be empty first\n\n### Fixed\n\n* Require a valid database hostname instead of assuming localhost\n* A valid transcode_cmd is required to transcode media\n* Subsonic\n  * Clients might send you a file path of Artist art instead of the id\n  * Strings don't need json conversion checks\n  * Send the cover art id for playlists\n  * Check for artist and podcast prefixes on art id's\n  * Bugs when converting between SubSonic id and Ampache id\n  * Assign roles based on preferences (fixes jukebox, podcast and share roles)\n  * CreateUser could overwrite admin access level\n  * UpdateUser didn't write the access level\n  * don't return null Genre counts\n  * fix getting artist indexes for large libraries\n* Don't get null playlist objects from the DB\n* Using 'Save Track Order' would not apply the offset\n* Vorbis/Ogg comments use 'organization' for publisher and 'track_number' for track\n* Automated Label creation when updating from tags\n* Grouped album downloads and rightbar actions\n* Preference::get_by_user was caching into a single value\n* A user who owned a playlist was unable to reorder (but could still save the order)\n* When creating shares, don't allow secret to be longer than database limit (20)\n* Album full name wasn't being used in some places\n* Tag::get_tag_objects was not grouping albums\n* Return integers for tag counts\n* rmccue/requests CVE: CVE-2021-29476\n* PHPMailer/PHPMailer CVE: CVE-2020-36326\n\n### API 4.4.2\n\n### Fixed\n\n* API::indexes Artist albums were being added incorrectly for XML\n* Send back the full album name in responses\n\n## Ampache 4.4.1-release\n\n### Added\n\n* If you have an MBID in your artist, use that for last.fm queries\n\n### Changed\n\n* Updated composer dependencies\n* Default podcast_keep and podcast_new_download preferences are set to 0 (unlimited)\n\n### Removed\n\n* Delete 'concerts_limit_past' and 'concerts_limit_future' database settings.\n\n### Fixed\n\n* Grid View shouldn't change the artist image\n* Catalog Update -u (gather last.fm info) wasn't getting an ID list correctly\n* Album::get_random_songs not returning id's\n* Bookmark::get_bookmarks typo for get_bookmark_ids\n* Sorting album browses by artist name could fail with mysql\n* Subsonic getPlaylists should always send a user\n* Album browsing SQL didn't include Artist name in grouping\n* CVE-2021-21399: Unauthenticated SubSonic backend access in Ampache\n\n### API 4.4.1\n\n### Fixed\n\n* API::stats would not offset recent calls\n\n## Ampache 4.4.0-release\n\nKeep an eye on the incoming changes to develop at [Ampache-Next-Changes](https://github.com/ampache/ampache/wiki/Ampache-Next-Changes)\n\n### Added\n\n* Write metadata to mp3, flac and ogg files. Requires metaflac and vorbiscomment installed on Linux.\n* Write images to mp3 and flac files. Also requires metaflac on linux.\n* File tags can be updated from catalog management page.\n* Configurable settings for \"Gather Art\".\n* Configurable art search limit.\n* User selectable artist and year filter for Spotify album searches\n* User selectable limit for art searches.\n* Generate rsstokens for each user allowing unique feed URLs\n* Allow setting custom database collation and charset without overwriting your changes\n  * rsstoken: Identify users by token when generating RSS feeds\n* Run garbage collection after catalog_update.inc 'clean' or 'verify'\n* Add duration to the table headers when browsing playlists and smartlists\n* Add time and duration to albums, artists instead of calculating from songs each time\n* Allow setting a custom background on the login page\n* Musicbrainz search icon on Artist, Album and Song pages\n* Update missing album artists on catalog add\n* Add R128 Gain adjustments\n* Persist replaygain setting as a cookie\n* Support for image per song\n* Format XML output using DOMDocument\n* SubSonic - shift the current track start time when you pause/resume\n* Config version 49\n* NEW config options\n  * hide_ampache_messages: We sometimes need to talk and will show a warning to admin users. Allow hiding this\n* NEW search options (also available in Api::advanced_search)\n  * last_skip (artist, album, song)\n  * last_play_or_skip (artist, album, song)\n  * played_or_skipped_times (song)\n\n### Changed\n\n* Stop logging auth/passphrase strings\n* Add Y scrolling to the current playlist box (rightbar)\n\n### Fixed\n\n* Escape filepaths when removing from database\n* Regex in config for additional_genre_delimiters\n* Grid View option was backwards\n* Replaygain issues in the webplayer\n* Per disk actions for grouped albums (e.g. play just that disk)\n* Catalog removal needs to run garbage collection\n* Recognize opus when reading tags\n* Regex in config for additional_genre_delimiters\n* SQL query for smartlists not joining the OR correctly\n* Searching with bad rules will return no results instead of everything\n* Check the 'unique_playlist' option in more places\n* When you haven't set an active localplay nothing was picked\n* Set time for artists that are only albums\n* Don't hide rss generation when you haven't got a key\n* Podcast episode durations that use seconds were converting into crazy lengths\n* Playlist and Smartlist check sql simplified\n* SubSonic - Json clients need their playlist entry to always array (single item lists)\n\n### API 4.4.0\n\n### Added\n\n* NEW API functions\n  * Api::users (ID and Username of the site users)\n* Api::localplay added new options to 'command' ('pause', 'add', 'volume_up', 'volume_down', 'volume_mute', 'delete_all', 'skip')\n* Api::localplay added parameters:\n  * 'oid' (integer) object_id to add //optional\n  * 'type' (string) Default: 'Song' ('Song', 'Video', 'Podcast_Episode', 'Channel', 'Broadcast', 'Democratic', 'Live_Stream') //optional\n  * 'clear' (integer) 0|1 clear the current playlist on add //optional\n* Api::playlist_edit added new parameter 'sort': (0,1) sort the playlist by 'Artist, Album, Song' //optional\n* Api::get_indexes\n  * New type options: 'album_artist', 'podcast', 'podcast_episode', 'share', 'video'\n  * Added parameter 'include': (0,1) (add the extra songs details if a playlist or podcast_episodes if a podcast)\n* Api::rate - Added types 'playlist', 'podcast', 'podcast_episode', 'video', 'tvshow', 'tvshow_season'\n* Api::flag - Added types 'podcast', 'podcast_episode', 'video', 'tvshow', 'tvshow_season'\n* Add time to artist and album objects. (total time of all songs in seconds)\n* Add songcount, albumcount to artist objects. (time in seconds)\n* Add songcount to album objects. (time in seconds)\n* Add type (release_type) to album objects\n* Add disk to song objects\n* Add time to video objects. (time in seconds)\n* Add title, mime, catalog to podcast_episodes\n* Api::advanced_search Add 'playlist', 'user' and 'video' to search types\n* Api::handshake added extra total counts to the response\n  * users, tags, podcasts, podcast_episodes, shares, licenses, live_streams, labels\n* Api::ping match the handshake response (excluding the auth token)\n\n### Changed\n\n* get_indexes: 'playlist' now requires include=1 for xml calls if you want the tracks\n* Make filter optional in shares\n* Api::podcast_episodes\n  * \"url\" is now a play url (instead of a link to the episode)\n  * \"public_url\" is now the old episode link\n\n### Fixed\n\n* Api::podcast_edit wasn't able to edit a podcast...\n* Api::democratic was using action from localplay in the return responses\n* get_indexes for XML didn't include podcast indexes\n* Set OUTDATED_DATABASE_OK on image.php, play/index.php and share.php to stop blocking requests\n* Don't limit sub items when using a limit (e.g return all podcast episodes when selecting a podcast)\n\n### Deprecated\n\n* Dropped in API 5.0.0\n  * Api::get_indexes; stop including playlist track and id in xml by default\n  * Album objects: \"tracks\" will only include track details. Use \"songcount\"\n  * Artist objects: \"albums\", \"songs\" will only include track details Use \"albumcount\" and \"songcount\"\n\n## Ampache 4.3.0-release\n\nThis version of Ampache seeks to bring in some of the great changes going on in develop while we work on v5.\nThere also a few API changes to enable a bit better control for older clients.\n\n### Added\n\n* Check limits on democratic playlists (> 0 && < 3000000000)\n* Show an error for out of range democratic cooldowns\n* SubSonic - Force a default format (xml) instead of none\n* Added back the agent string in recently played (for admins)\n* Replace 'Admin' icon with padlock in sidebar when access check fails. (Hide this new icon with 'simple_user_mode')\n* Disable API/Subsonic password resets in 'simple_user_mode'\n* New option -m 'move_catalog' added to catalog_update.inc\n* More default preferences to the refill/check functions\n* More functions to search (album artist, mbid)\n* Config version 46\n* NEW config options\n  * hide_search: If true do not include searches/smartlists in playlist results for Api::get_indexes, Api::playlists\n* NEW plugin:\n  * 'Personal Favorites'. Show a shortcut to a favorite smartlist or playlist on the homepage\n  * 'RatingMatch'. Raise the minimum star rating (and song loves) of artists and albums when you rate/love the song\n\n### Changed\n\n* Scrobble plugins fire after stat recording\n* Split art search by 5 instead of 4\n* Increase autoupdate check time and don't force it on each logon\n* Updated CSS and separated mashup covers from other types\n* Don't use mail_enabled for registration checks\n* WebUI - Browse by album_artist instead of single artists\n* Better sorting for playlists using sort_tracks\n* Don't allow duplicate podcast feeds\n* Updated the gather art process\n* Searches will order by file/name instead of id (unless random)\n* Updated amapche.sql\n* Updated composer requirements\n* Default false config option text changed to true (no more typing, just uncomment!)\n* Compressed PNG and JPG images\n\n### Removed\n\n* Disabled the jPlayer fullscreen shortcut (ctrl + f)\n* Remove system preferences from the user that aren't classified as a system preference\n* Stop setting open_basedir from fs.ajax\n* Concert/Event pages (dead Last.fm API)\n* Don't run reset_db_charset on DB updates\n* Disabled browse_filter for new user accounts\n\n### Fixed\n\n* Speed up the playlist dialog boxes (Add to playlist)\n* Fix SQL query for Stats::get_newest_sql\n* Session cookie creation\n* Multiple auth attempts in the same second would not return a session\n* Mail auth was not checked correctly\n* Gather art correctly for update_file.inc\n* set bitrate correctly if using a maxbitrate in play/index\n* MP3's would not get a waveform without editing the config\n* Recently played respects your privacy settings\n* Graph class sql grouping\n* **MAJOR** UPnP fixes\n* Upload catalog rename logic\n\n### API 4.3.0\n\n### Changed\n\n* Api::record_play\n  * Make 'user' parameter optional\n  * Allow 'user' to the be user_id **or** the username string\n  * Add 'date' parameter (optional)\n  * Require 100 (Admin) permission to record plays for other users\n* Api::get_indexes\n  * Add 'hide_search' parameter (optional)\n* Api::playlists\n  * Add 'hide_search' parameter (optional)\n* Setting a limit of 'none' would slice away all the results\n\n## Ampache 4.2.6-release\n\n### Changed\n\n* Ignore ALL tagged releases (e.g. 4.2.6-preview 4.2.6-beta)\n* Don't check the times in save_mediaplay plugins\n* Plugins should only have 1 category\n* Update Composer requirements\n\n### Removed\n\n* Some system preferences were added as user preferences\n\n### Fixed\n\n* Search original_year query\n* Replaygain was missing from the webplayer\n* Check albumartist in get_album_suite queries\n* Recently played queries check for privacy options\n* Headphones plugin fix for missing mbid's\n* Duplicate downloads recorded in play/index\n* Subsonic video HLS stream and json values\n* Block more password resets when using simple_user_mode\n* Upload catalog rename logic\n\n### API 4.2.6\n\n**NO CHANGE**\n\n## Ampache 4.2.5-release\n\n### Added\n\n* Use _add_urls when building a stream playlist\n\n### Changed\n\n* Removed the forced random from search\n* Put the browse header at the top above plugins\n* Make the webplayer class a bit faster at deciding what to transcode\n\n### Fixed\n\n* Ampache Debug, cron.lib.php missing from init\n* Slow playlist creation when inserting a large amount of items\n* Stream_URL properties were inconsistently applied\n* Fix streaming when play_type is Democratic\n* Save your limit and random settings when creating a smartlist\n\n### API 4.2.5\n\n**NO CHANGE**\n\n## Ampache 4.2.4-release\n\n### Added\n\n* \"Random\" tickbox added to search pages\n\n### Changed\n\n* Searching 'original_year' will now fall back to 'year' if no release year is present\n\n### Fixed\n\n* User was being created but you were told it isn't\n* The search pages remember your limit correctly\n* PHP exception when < 7.1\n* Correct \"Recently Added\", \"Recently Updated\" searches\n* Check that song can be inserted before inserting the remaining rows\n* Logic in stat recording when skips occur\n* Don't query for null tag ids\n\n### API 4.2.4\n\n**NO CHANGE**\n\n## Ampache 4.2.3-release\n\n### Added\n\n* Subsonic Generate errors for objects missing art\n\n### Changed\n\n* Don't mark short songs as skipped\n* Subsonic Stop converting strings to ints in JSON responses\n\n### Fixed\n\n* User registrations\n* Workaround null values for new columns in search table\n* Check release_type length before inserting into the database\n* Ensure Album Artist is set correctly on songs\n* Subsonic Fix callbacks for similarSongs2 and artistInfo2\n* Subsonic getCoverArt fixes\n\n### API 4.2.3\n\n**NO CHANGE**\n\n## Ampache 4.2.2-release\n\n**DATABASE CHANGES** You can now force a default collation and charset on your database.\nIf you choose to use utf8mb4; Ampache will convert your table engine to InnoDB to handle the extra bytes.\n\n### Added\n\n* Numeric 'Played/Skipped ratio' added to search. (Set using (stream/skip)*100.)\n  * ```> 0 & < 100```: Skipped more than played\n  * ```100```: Equal plays and skips\n  * ```> 100```: Played more than skipped\n* Add 'Original Year', 'Release Type' to Album searches\n* Allow setting custom database collation and charset without overwriting your changes\n* Video search added to random.php\n* 'samesite=strict' on JS cookies\n* Translation updates (August 2020)\n* Put 'Labels' into search, browse headers and sidebar when enabled\n* NEW config options (config_version 45)\n  * database_charset: Set a default charset for your database\n  * database_collation: Set a default collation for your database\n  * simple_user_mode: Don't allow users to edit their account values (used for demo sites that allow login)\n* NEW files\n  * bin/update_file.inc: Update your catalog when individual files are changed using inotifywait.sh\n  * bin/update_db.inc: Update your database collation, charset and table engine from the cli\n  * docs/examples/inotifywait.sh: script to use inotifywait and update_file.inc to update as file changes happen\n  * docs/examples/inotifywait.service: systemd example service for inotifywait.sh\n\n### Changed\n\n* stats.php: Show total 'Item Count' on Statistics page instead of trying to shoehorn songs/videos/etc into different columns\n* ampache.sql updated after about 4 years... no more updates on install!\n* Searching by \"Rating (average)\" now ignores private/public and always returns the average.\n* Hide searches for '# Skipped' and 'Played/Skipped ratio' when 'Show # skipped' is Off\n* Search items rearranged to try to match each other\n* Sort 'Playlist' and 'Smart Playlist' browse pages by name\n* Display the blankuser avatar in now playing if missing\n* Swap 'Random' and 'Playlists' in the sidebar (CSS order numbers)\n* Don't hide artist art when you disable lastfm_api_key in the config\n* Hide 'Metadata' search when 'enable_custom_metadata' is disabled\n\n### Deprecated\n\n* Drop version number from the release string in develop. ('4.3.0-develop' => 'develop')\n  * This should stop a bit of confusion when removing / adding requirements\n* The '-release' suffix in version number will be dropped for Ampache 5.0.0\n\n### Removed\n\n* Remove stat recording from channels\n* Don't reset the database charset and collation after each db update\n\n### Fixed\n\n* Fixed a few issues on the Statistics page\n  * Report 'Catalog Size' correctly for podcasts\n  * Report 'Item Count' correctly for podcasts and video catalogs\n* Searching albums for artist name\n* Mashup 'Newest' would incorrectly apply an offset missing the newest items\n* Search by 'Smart Playlist' rules fixed when added with other rules\n* Use LEFT JOIN instead of HAVING for search rules to allow more complicated lists\n* Logic searching 'My Rating' includes unrated (0 Stars) in a better way\n* Captcha was not generated for registration\n* Enforce lowercase codec for live streams\n* Parsing integer search rules was overwriting index values\n* Handle empty XML on similar artist requests to last.fm\n\n### Security\n\nFix CVE-2020-15153 - Unauthenticated SQL injection in Ampache\n\n### API 4.2.2\n\nMinor bugfixes\n\n### Added\n\n* Api::advanced_search added parameter 'random' (0|1) to shuffle your searches\n\n### Changed\n\n* Remove spaces from advanced_search rule names. (Backwards compatible with old names)\n  * 'has image' => 'has_image'\n  * 'image height' => 'image_height'\n  * 'image width' => 'image_width'\n  * 'filename' => 'file' (Video search)\n\n### Deprecated\n\n* Search rules 'has image', 'image height', 'image width', 'filename'. (Removed in Ampache 5.0.0)\n\n### Fixed\n\n* Api::stream, Api::download Api::playlist_generate 'format' parameter was overwritten with 'xml' or 'json'\n* Produce valid XML for playlist_generate using the 'id' format in XML\n\n## 4.2.1-release\n\n**NOTICE** Ampache 5.0.0 will require **php-intl** module/dll to be enabled.\n\n### Added\n\n* Numeric ('1 Star'-'5 Stars') searches now include '0 Stars' to show unrated objects\n* Ajax refresh localplay \"Now Playing\" same as the index \"Now Playing\" section\n* Add 'has not rated' to \"Another User\" searches\n* Add higher bitrates (640, 1280) to search to allow for lossless files\n* Put strings ('1 Star', '2 Stars', etc) back into numeric searches for ratings\n* When using a string title for numeric searches use the order of the items starting with 0\n* NEW files\n  * Include API docs from the wiki. (API.md, API-JSON-methods.md, API-XML-methods.md, API-advanced-search.md)\n* 'Filters' added to each sidebar tab if enabled (previously only 'Home' and 'Admin')\n\n### Changed\n\n* Use binary (.mo) translation files to speed up translation processing\n* Don't show 'Generate new API key' if you don't have access\n* QR Code in account page is now just the API Key (redundant link removed too)\n* Require minimum version of Ampache 3.8.2 to upgrade database\n* Added an icon to webplayer to go to album. Clicking on song title now directs to song\n\n### Fixed\n\n* Waveform config option 'get_tmp_dir' was ignored if set\n* Rightbar: 'Add to New Playlist' not adding on new playlists\n* Translate preference subcategories and status\n* 'podcast_new_download' logic fix\n* Filters box would show up in the Admin tab if you disabled 'browse_filter'\n* Update album when 'release_type' changes\n* Parse 'Release Type' from tags in a less terrible way\n\n### API 4.2.1\n\nNo functional changes from 4.2.0\n\n### Fixed\n\n* Filter in \"playlist\" and \"playlist_songs\" fixed\n\n## 4.2.0-release\n\nThe API changelog for this version has been separated into a new sub-heading below to make it easier to follow.\n\n### Added\n\n* Added Spotify art searches for both album and artist images.\n* Updated component installer and php-cs-fixer package.\n* Translation updates (April 2020, May 2020, July 2020)\n* Added declare(strict_types=0); to lib/* and lib/class/* (requires more work before it can be enabled)\n* Add 250 for search form limits in the web UI. (Jump from 100 to 500 is pretty big)\n* Add Recently updated/added to search rules\n* Add regex searching to text fields. ([<https://mariadb.com/kb/en/regexp/>])\n  * Refer to the wiki for information about search rules. (<http://ampache.org/api/api-advanced-search>)\n* When labels are enabled, automatically generate and associate artists with their publisher/label tag values.\n* Enforced stat recording for videos. (podcasts and episodes to be added later)\n* Add tags (Genres) to \"Anywhere\" text searches.\n* 10 second redirect on \"Access Denied\" to the default web_path\n* Allow \"Update from tags\" for multi-disk album and artist pages\n* show and hide the rightbar (playlist) using the minimize button in the header\n* Tag->f_name (New property on tag that was being set hackily)\n* Add \"Album\" to Find Duplicates in admin/duplicates.php.\n* \"Local Image\" added to Artist & Album search. Find out whether you have art stored in Ampache\n* PHP_CodeSniffer checks and settings added to Scrutinizer. (phpcs --standard=.phpcs.xml lib/class)\n* NEW database options\n  * cron_cache: Speed up the interface by allowing background caching of data\n  * show_skipped_times: Add \"# skipped\" to the UI. (disabled by default)\n  * custom_datetime: Allow you to format your date strings your way.\n  * unique_playlist: Force unique playlists by ignoring existing songs\n* NEW config options\n  * skip_timer: Add Skip Timer Threshold to the config\n  * artist_art_folder: Specify a local folder to search for artist images using name/title\n  * rating_file_tag_user: Set ratings to this user ID when importing ratings from file tags\n  * spotify_client_id: Allows Spotify art search\n  * spotify_client_secret: Allows Spotify art search\n* NEW files\n  * server/json.server.php & lib\\class\\json_data.class.php: JSON API!\n  * bin/compute_cache.inc: Cache object_count data to speed up access\n  * bin/cron.inc: Perform garbage_collection functions outside of main functions (includes compute_cache.inc)\n* NEW examples\n  * docs/examples/ampache_cron.service\n  * docs/examples/ampache_cron.timer\n\n### Changed\n\n* Change license string from AGPLv3 to AGPL-3.0-or-later\n* Update Composer requirements\n* Allow searching play times without requiring UI option\n* Stop showing the average rating in the web interface as stars. (show an average when available as text separately)\n* When you don't have a config file redirect to installer\n* Change to numeric searches: Renamed 'is' => 'equals' and 'is not' => 'does not equal'\n* Allow negative track numbers; reducing the maximum track number to 32767.\n* Localplay volume control moved to the playlist (rightbar)\n* Podcast_Episode::check_play_history Podcast_Episode::set_played (match song.class versions for stat recording)\n* Video::check_play_history Video::set_played (match song.class versions for stat recording)\n* php_cs rules for line endings\n* Simplify play history checks and code a bit more\n* Tag (Genre) searches compare each item (e.g Pop) rather than the whole string (Pop,Rock,etc)\n* Replace \"Browse Library\" buttons with a search header allowing faster browsing of other types\n* Share secrets are generated by generate_password instead of a separate function\n* inet_ntop may not convert some binary IP addresses (like ::1) these now show up as \"Invalid\" in the ip history.\n* Searches using numeric rules must use an integer. ('1 Star' => 1, '2 Stars' => 2, etc)\n* bin/delete_disabled.inc require -x to execute. (previously you needed to edit the file)\n\n### Deprecated\n\n* Horde_Browser::getIPAddress(). Use Core::get_user_ip() instead.\n\n### Removed\n\n* bin/migrate_config.inc (This was used to migrate the config file from php4 to php5)\n* EchoNest api/song previews\n* User::update_user_stats (used in play index only and useless)\n* Share::generate_secret; use generate_password instead\n* Song::get_cache_count (unused)\n* Ampache Debug check for 'safe_mode'\n\n### Fixed\n\n* Fixed a lot of incorrectly typed function calls and code documentation\n* Gravatar Plugin: Make sure https is used when force_ssl is configured\n* Truncate strings to match database limits when strings go over\n* Add User php warnings\n* Channel authentication\n* IP checks when sending null proxy values\n* Gather art page layout\n* Read vorbis rating correctly\n* Search rules in UI failing to load with custom_metadata\n* Warn correctly when inserting art fails\n* Insert missing user preferences on login\n* When you had beautiful_urls enabled tracks would not parse in localplay making them all Unknown\n* Podcast durations aren't always correct format, prep the time before trying to insert it\n* Subsonic playlist add/remove removing incorrect songs\n* Search/Smartlists need to have results to be used in lists\n* Auth issues with stats for recording and localplay\n* Stream_urls were generated with a typo when downloading\n* Respect album grouping using of the moment plugin\n* Filter album title with grouping enabled. (seriously deadmau5, stop with the <> everywhere)\n* Share playback without a UID would fail to start\n* Set a default popular_threshold if unauthenticated or unset\n* play/index would record democratic streams as a download\n* Make sure the default preferences table has all the preferences in them\n* Beets catalog bug; date_diff expecting a datetime but given a string\n* Searches using user data like ratings has been split in the SQL correctly\n* Flagged playlists never had their flag deleted\n* offset and limit were incorrectly used for top/recent searches\n\n### Security\n\n* Fix: CVE-2020-13625 in phpmailer\n\n### API 4.2.0\n\n**API versions will follow release version and no longer use builds in the integer versions (e.g. 420000)**\nAPI 5.0.0-release will be the first Ampache release to match the release string.\n\n#### Added\n\n* JSON API now available!\n  * Call xml as normal:\n    * [<http://music.com.au/server/xml.server.php?action=handshake&auth=APIKEY&version=420000>]\n  * Call the JSON server:\n    * [<http://music.com.au/server/json.server.php?action=handshake&auth=APIKEY&version=420000>]\n  * Example XML and JSON responses available [here](https://github.com/ampache/python3-ampache/tree/master/docs)\n* NEW API functions\n  * get_similar: send artist or song id to get related objects from last.fm\n  * shares: get a list of shares you can access\n  * share: get a share by id\n  * share_create: create a share\n  * share_edit: edit an existing share\n  * share_delete: delete an existing share\n  * podcasts: get a list of podcasts you can access\n  * podcast: get a podcast by id\n  * podcast_episodes: get a list of podcast_episodes you can access\n  * podcast_episode: get a podcast_episode by id\n  * podcast_episode_delete: delete an existing podcast_episode\n  * podcast_create: create a podcast\n  * podcast_edit: edit an existing podcast\n  * podcast_delete: delete an existing podcast\n  * update_podcast: sync and download new episodes\n  * licenses: get a list of licenses you can access\n  * license: get a license by id\n  * catalogs: get all the catalogs\n  * catalog: get a catalog by id\n  * catalog_file: clean, add, verify using the file path (good for scripting)\n\n#### Changed\n\n* Bump API version to 420000 (4.2.0)\n* All calls that return songs now include ```<playlisttrack>``` which can be used to identify track order.\n* ```<playcount>``` added to objects with a playcount.\n* ```<license>``` added to song objects.\n* Don't gather art when adding songs\n* Added actions to catalog_action. 'verify_catalog' 'gather_art'\n* API function \"playlist_edit\": added ability to edit playlist items\n  * items  = (string) comma-separated song_id's (replace existing items with a new object_id) //optional\n  * tracks = (string) comma-separated playlisttrack numbers matched to items in order //optional\n* Random albums will get songs for all disks if album_group enabled\n\n### Deprecated\n\n* API Build number is depreciated (the last 3 digits of the api version)\n  * API 5.0.0 will be released with a string version (\"5.0.0-release\")\n  * All future 4.x.x API versions will follow the main Ampache version. (420000, 421000, 422000)\n* total_count in the XML API is depreciated and will be removed in API 5.0.0.\n  * XML can count objects the same was as a JSON array [https://www.php.net/manual/en/simplexmlelement.count.php]\n* Genre in songs is depreciated and will be removed in API 5.0.0.\n  * Use tag instead of genre, tag provides a genre ID as well as the name.\n\n#### Fixed\n\n* Extra text in catalog API calls\n* Don't fail the API calls when the database needs updating\n\n## 4.1.1\n\n### Added\n\n* Extend Shouts to 2000 characters; Labels to 250\n* Add a status icon to the channel list pointing to the channel/ID/status.xsl\n\n### Changed\n\n* Hide localplay in the sidebar when you disable all the plugins\n\n### Removed\n\n* Remove non-free lib/composer.* files.\n  * You can enable c-pchart with (composer require szymach/c-pchart \"2.*\")\n* Remove shoutcast table and preferences. (Dead code)\n\n### Fixed\n\n* Musicbrainz Art search\n* tmp_playlist bug removing items\n* Dropbox catalog errors when using a small library\n* some bugs getting invalid time/date when reading tags\n\n### API 4.0.0 build 004\n\nBump API version to 400004 (4.0.0 build 004)\n\n#### Added\n\n* Add Api::check_access to warn when you can't access a function\n\n#### Fixed\n\n* Fix parameters using 0\n* Get the correct total_count in xml when you set a limit\n* Fix many XML formatting issues\n\n## 4.1.0\n\n### Added\n\n* December translation update from Transifex\n* Add playlist into main search page. (Songs, Albums, Artists, Playlists, Videos)\n* Add docs/examples/channel_run.service for running background processes as a service\n* New search option \"Another User\" allows searching other user ratings and favorites\n* Updates to support php7.4 (Ampache supports 7.1-7.4)\n* Checks in Subsonic/WebUI for recording repeated plays\n* composer & php-cs-fixer updates\n* Add github package guide for docker to RELEASE-PROCESS.md\n\n### Changed\n\n* Update channel status pages (/channel/$CHANNELID/status.xsl)\n* Update ListenBrainz plugin for empty additional info. (API says remove this section from json)\n\n### Removed\n\n* Roll back mysql8 workarounds. (Orace MySQL supported on php7.4+ only)\n* Revert changes in 4.0.0 and allow manual choices for artist/album on upload again.\n\n### Fixed\n\n* Fix comparison bugs found during static type testing\n* Fix enable/disable song ajax\n* Typo in login page HTTP_REFERER\n* Fix bin\\*.inc text issues with newline\n* Fix bug in UI when enabling/disabling songs\n* Fix smartlists when searching sub-lists (Ampache was trying to create one giant query that didn't scale well)\n* Fix \"Add New...\" in album edit\n* Subsonic return json errors when requesting json format (previously errors were always xml)\n\n### API 4.0.0 build 003\n\nBump API version to 400003 (4.0.0 build 003)\n\n#### Added\n\n* user_numeric searches also available in the API. ([<http://ampache.org/api/api-xml-methods>])\n\n#### Changed\n\n* Api::playlist - filter mandatory\n* Api::playlist_edit - filter mandatory. name and type now optional\n* Api::user - Extend return values to include more user fields\n* Playlist::create - Return duplicate playlist ID instead of creating a new one\n* Do not limit smartlists based on item count (return everything you can access)\n* Api/Database - Add last_count for search table to speed up access in API\n\n#### Removed\n\n* Artist::check - Remove MBID from Various Artist objects\n\n#### Fixed\n\n* Fix Song::update_song for label\n* Fix Api issues relating to playlist access\n\n## 4.0.4\n\nFinalize release procedure to make these updates a bit smoother\n\n### Added\n\n* Reduce the time for repeated track playback (Song length - 5 sec)\n\n### Changed\n\n* Filter playlists in API, Web and Subsonic correctly for regular users vs admins\n* Hide some lines from the mashup to make it a bit nicer\n\n### Removed\n\n* Remove the old logo from the main install page\n\n### Fixed\n\n* Fix album count for Artists when the album is missing data\n* Fix searches / searchbox for MYSQL8\n* Fix some invalid returns in lib/*\n* Send the correct function in ajax.server when deleting from playlist\n\n### Security\n\n* None\n\n## 4.0.3\n\n### Changed\n\n* Filter playlists by access in subsonic\n* Fail check_php_verison() when using less than php7.1\n\n### Fixed\n\n* Fixes for Api::get_indexes, Api::playlists, Api::playlist, Api::playlist_songs\n* Fix Access::check to allow all public lists\n* Fix global user connecting through the API with an API key.\n\n## 4.0.2\n\n### Changed\n\n* Bump API version to 400002 (4.0.0 build 002)\n* Extend Api::playlist_generate (add new mode 'unplayed')\n* Translate typo in show_test.inc\n* Trim massive year, time and track when importing new songs\n\n### Fixed\n\n* Fix API playlist commands and access checks relating to playlists\n* Access::check should be passing user id from the API\n* SQL query fixes for Album, Playlist methods\n* Remove spaces from play url extensions (Should help nginx users)\n* Set play_type correctly in preferences pages\n\n## 4.0.1\n\n### Added\n\n* Added 'file' to Song::find\n\n### Fixed\n\n* Bug fix that would cause albums to be recreated in Album::check\n\n## 4.0.0\n\nNotes about this release that can't be summed up in a log line\n\n### Added\n\n* JavaScript and Ajax updates\n* Code documentation and bug hunting\n* Added SVG support to the theme engine.\n* Default to disk 1 instead of 0 (db updates to handle existing albums)\n* Add Barcode, Original Year and Catalog Number to Album table\n* New Plugin - Matomo.plugin. [<https://matomo.org/>]\n* New Plugin - ListenBrainz.plugin [<https://listenbrainz.org/>]\n* Add bin/clean_art_table.inc to clean art that doesn't fit your min or max dimensions.\n* Default fallback user avatar when none found\n* Added a $_SESSION['mobile'] variable to allow changing pages for mobile devices.\n* Viewport settings for mobile devices\n* Use a random cover for playlist art\n* Add now_playing.php to allow badges for currently track and fall back to last played if none. (thanks @Rycieos)\n* Add Now Playing icon to each user page if enabled.\n* Add year information and links to the data rows and interface\n* Add debugging in song.class.php when the file may be corrupt\n* Allow the main sidebar to be reordered using CSS (.sb2_music, .sb2_video, .sb2_*)\n* Subsonic Update api to 1.13.0 [<http://www.subsonic.org/pages/api.jsp>]\n* Subsonic Allow token auth using API Key instead of password.\n* Subsonic New Method: updateUser\n* Subsonic New Method: getTopSongs\n* Config Version 40\n  * Add: mail_enable - Enable or disable email server features otherwise, you can reset your password and never receive an email with the new one\n  * Add: rating_browse_filter, rating_browse_minimum_stars - filter based on a star rating.\n  * Add: send_full_stream - allow pushing the full track instead of segmenting\n  * Add: github_force_branch - Allow any official Ampache git branch set in config\n  * Add: subsonic_stream_scrobble - set to false to force all caching to count as a download.\n    This is to be used with the subsonic client set to scrobble. (Ampache will now scrobble to itself over subsonic.)\n  * Add: waveform_height, waveform_width - customize waveform size\n  * Add: of_the_moment - set custom amount of albums/videos in \"of the moment areas\"\n  * Add: use_now_playing_embedded, now_playing_refresh_limit, now_playing_css_file - Show a user forum tag \"Now playing / last played\"\n\n### Changed\n\n* Don't allow lost password reset for Admin users\n* Don't allow emails until mail_enable is true\n* Don't allow last.fm queries to overwrite existing art\n* Stop trying to insert art when present during catalog update\n* Move some $_GET, POST, $_REQUEST calls to Core\n* HTML5 doctype across the board. (DOCTYPE html)\n* Lots of HTML and UI fixes courtesy of @kuzi-moto\n* If you are using charts/graphs there has been a change regarding c-pchart\n  * [chart-faq](https://github.com/ampache/ampache/wiki/chart-faq)\n* Numerous catalog updates to allow data migration when updating file tags meaning faster tag updates/catalog verify! (Updating an album would update each file multiple times)\n  * UserActivity::migrate, Userflag::migrate, Rating::migrate, Catalog::migrate,\n  * Shoutbox::migrate, Recommendation::migrate, Tag::migrate, Share::migrate\n* Rework user uploads to rely on file tags ONLY instead of allowing manual choices.\n* Extend bin/sort_files.inc & catalog patterns to handle new fields\n* Updated bin/sort_files.inc for a smoother experience that actually works\n* Add -u to bin/catalog_update.inc This function will update the artist table with bio, image, etc as well as update similar artists.\n* Update the CSS theme colors and structure.\n* Light theme updated.\n* Format the input fields. (you get a datetime picker on mobile!)\n* Login/lostpassword moves the logo to the bottom on mobile like cockpit does! (makes typing easier on a touch screen)\n* Load webplayer hidden to stop popup preferences hiding the window\n* Hide video in search/stats if not enabled\n* Lots of code tweaks to make things more uniform and readable.\n* Default to mashup for artists and albums\n* Remove '[Disk x]' when grouped from all UI areas by enforcing the group setting.\n* Subsonic Enable getChatMessages, addMessage allowing server chat\n\n### Removed\n\n* Drop PHP 5.6 support for 7.1+\n* Remove all Plex code\n* Remove message of the day\n* No video, no channels in new installs\n* Remove plex and googleplus plugins\n\n### Fixed\n\n* Fix import_playlist code. Do not recreate existing playlists and don't imports existing songs.\n* Allow cli tools to use system settings for plugins.\n* Fix MySQL8 installation using mysql_native_password with caveats ([<https://github.com/ampache/ampache/wiki/mysql-faq>])\n* Catalog Manager can now access catalog areas correctly\n* Filter zip names in batch so they are named correctly by the download\n* Fixed setting button requiring two single clicks to open. (Thanks for this 2016 pull @AshotN)\n* Make test.php, init.php & install.php show an error page instead of blank screen. (gettext)\n* Fix slideshow creating black screen when using web player\n* Fixed QRCode views\n* Subsonic Don't ignore group settings with id3 browsing\n* Subsonic Fix cover art for playlists and albums\n* Subsonic Api fixes for podcast playback, Ultrasonic/Dsub workarounds\n\n### Security\n\n* Resolve NS-18-046 Multiple Reflected Cross-site Scripting Vulnerabilities in Ampache 3.9.0\n* Resolve CVE-2019-12385 for the SQL Injection\n* Resolve CVE-2019-12386 for the persistent XSS\n\n### API 4.0.0 build 001\n\n* Bump API version to 400002 (4.0.0 build 001)\n\n#### Added\n\n* Documented the Ampache API [<http://ampache.org/api/api-xml-methods>]\n* Include smartlists in the API playlist calls.\n* Authentication: allow sha256 encrypted apikey for auth\n  * You must send an encrypted api key in the following fashion. (Hash key joined with username)\n  * $passphrase = hash('sha256', $username . hash('sha256', $apikey));\n* Added artist_tag to song searches\n* flag: allows flagging object by id & type\n* record_play: allows recording play of object without streaming\n* catalog_action: allow running add_to_catalog|clean_catalog\n* playlist_edit: allow editing name and type of playlist\n* goodbye: Destroy session\n* get_indexes: return simple index lists to allow a quicker library fill.\n* check_parameter: error when mandatory inputs are missing\n* stream: Raw stream of song_id\n* download: Download, not recorded as a play\n* get_art: Raw art file like subsonic getCoverArt\n* user_create: 'user' access level only!\n* user_update: update user details and passwords for non-admins\n* user_delete: you can't delete yourself or and admin account!\n* update_from_tags: updates a single album, artist, song from the tag data instead of the entire library!\n* update_art: updates a single album, artist, song running the gather_art process\n* update_artist_info: Update artist information and fetch similar artists from last.fm\n* playlist_generate: Get a list of song xml, indexes or id's based on some simple search criteria. care of @4phun\n\n#### Changed\n\n* Authentication: Require a handshake and generate unique sessions at all times\n* advanced_search\n  * 'is not' has been added shifting values down the list.\n    (0=contains, 1=does not contain, 2=starts with, 3=ends with, 4=is, 5=is not, 6=sounds like, 7=does not sound like)\n  * rule_1['name'] is depreciated. Instead of multiple searches for the same thing rule_1'name'\n    has been replaced with 'title' (I have put a temp workaround into the search rules to alleviate this change)\n* stats\n  * allow songs|artists|albums (instead of just albums)\n* playlists\n  * allow return of smartlists as well as regular playlists (set a 5000 limit on unlimited smartlists)\n* playlist_add_song\n  * Added check boolean to skip duplicate songs\n* playlist_remove_song\n  * Allow uid of song instead of the track id from the playlist\n\n## 3.9.1\n\n* Fixed Beets catalog creation and updating.\n* Autoupdate now ignores pre-release (preview) versions.\n* Fixed various command ine utilities in bin folder.\n* Fixed XML api syntax for logging in with user name.\n* Fixed newline display in xml data returned in playlist, etc.\n\n## 3.9.0\n\n* Video details now correctly displayed for personal video.\n* XML API now fully accepts user's API key. Session will be extended if it exists; Otherwise it's replaced.\n* Artist name added to Lastfm track.getsimilar query.\n* Catalog_update.inc now includes switches for catalog name and catalog type.\n* Added Beets catalog to Composer autoload.\n* Performance improved with playlist display and search.\n* General translation Updates.\n* Documented php module requirement for FreeBSD.\n\n## 3.8.9\n\n* Improved display of artist summary on web page.\n* Fixed uploading of avatar.\n* DSub now writes the correct extension when the ampache config switch `encode_player_api_target` is enabled.\n* Artist info now properly displayed.\n\n## 3.8.8\n\n* Subsonic API now removes illegal characters before returning text.\n* Removed hardcoded access level to allow guests to stream audio.\n* Guest accounts can now access songs and public playlists.\n* Fixed bug in subsonic API which caused DSub not to create folders or\n  add file extensions when caching.\n\n## 3.8.7\n\n* Better able to clean up image extentions when gathering art from remote sites.\n* Check for B.O.M. (\\xff\\xfe) only in mp3 composer tag and remove.\n* Added .ogv encoding target for more efficient streaming of mkv files.\n* Top menu appearance more reader friendly for translations.\n* Additional fixes to update_remote_catalog function.\n* Enabled similar songs when clicking on radio icon in DSub.\n* Repaired problem with removing \"empty\" albums.\n* Can now access XML-API when default ACL(s) are removed.\n* 'Find Duplicates' tool now works.\n* Cleaning now checks for mounted path before removing empty albums/missing files.\n* Starring album and artist now work via Subsonic client.\n* Modified \"Gather Art\" debug message to remove confusion from \"Image less than 5 chars...\".\n\n## 3.8.6\n\n* Updated Subsonic Remote Catalog Module to version 2.\n* Subsonic Catalog now grabs artwork directly from the subsonic server.\n* Various fixes to Subsonic Catalog and Subsonic API.\n* Release package now downloads from release update alert.\n* Develop package downloads from develop update alert.\n* Fixed album Search.\n\n## 3.8.5\n\n* Added search capability for user's own ratings option for Song, Artist, Album search.\n* Clean process now removes empty albums.\n* Further translation updates and fixes.\n* Updated Subsonic API to increase compliance with Subsonic json API specs.\n* Added starred date to album list and song and formatted per Subsonic spec.\n* Now compatible with latest Ultrasonic client (json transfer).\n* Fixed ability to edit/save smartplaylist name without setting 'random'.\n* Search/smart playlist now includes favorite artists and albums.\n* Modified SQL statement to not offend default SQL_MODE of ONLY_FULL_GROUP_BY on server versions after 5.7.6.\n* Set redirect to false for streaming types.\n\n## 3.8.4\n\n* Subsonic catalog now displays album art and artist bio.\n* Artist info now displays in Ampache's installed language.\n* Updated translations.\n* Composer tag changes now saved to database.\n* Seafile catalog module added.\n* Dropbox catalog updated to V2 API.\n* ip6 addresses now added to user history.\n* Updated api.class.php\n* fix for web_path auto configuration for subdirectory installation\n* Composer tag changes now written to database\n* Fixed catch null reference\n* Changes to make translation easier\n* Smart Playlist can now be edited/saved without 'random' set.\n\n## 3.8.3\n\n* Fixed upload problem\n* Fixed charting problem\n* Updated composer dependencies\n* Fixed ipv6 issue\n* Improved Opus transcoding\n* Fixed localization chart\n* Improved Subsonic API\n* Improved ID3v2.3 and v2.4 to better handle multivalued lists\n* Added sort by disc numbers\n* Song comments are now editable\n* Fixed composer column in iTunes\n* Many typos fixed\n* Fixed field types in modules and Localplay\n* Fixed timeline function\n* Activated jplayer \"preload\" option\n* Fixed missing submit button on options page\n* Increased info on DSub failing via Subsonic API\n* Fixed Group actions in private message page causing JavaScript error\n* Fixed some info lievel issues in Codacy\n* Apply trim on dropbox parameters\n* Added Prompt for user to change secret_key during install\n* Enabled use of cache in PHPCs\n* All files now use UTF8 without BOM\n* Now require Exact catalog name match on catalog update\n* Port 443 removed from play url\n* Now test all images found to select the one with the good dimensions\n* Rewrote LDAP class\n* Song count in handshake now matches the number returned from songs\n* Blocking of webplayer when transcoding fixed\n* Cover art is added to live stream\n* Added browse filter and light sidebar options\n* Updated gettext, zipstream, react and sabre dependencies\n* Fixed Subsonic scrobble submission check\n\n## 3.8.2\n\n* Fixed potential security vulnerability on smartplaylist search rule and catalog management actions (thanks Roman Ammann)\n* Fixed song comparison issue on arrays (genre ...) when updating from tag\n* Fixed song insertion issue if track year is out of range\n* Fixed unexpected artist summary autoupdate\n* Improved generated playlist filename (thanks yam655)\n* Fixed user avatar upload (thanks vader083)\n* Fixed waveform temporary file deletion issue if GD library is unavailable\n* Fixed max number of items returned from Subsonic getStarred.view (thanks zerodogg)\n* Fixed video update from tags (thanks stebe)\n* Reverted PHP 5.5.9 dependency to PHP 5.4\n* Added video playlist support (thanks SurvivalHive)\n* Added preference subcategory\n* Added prompt for new playlist name\n* Fixed page refresh when canceling album art change (thanks EvilLivesHere)\n* Added /play htaccess rewrite rule to avoid default max limit redirection\n* Fixed Subsonic artist/album/song name JSON parsing if the name is numeric only\n* Added ignored articles and cover art to Subsonic getArtists.view function\n* Fixed MySQL requests to support ONLY_FULL_GROUP_BY mode\n* Fixed Ajax art refresh after changing it (thanks gnujeremie)\n* Fixed playlist creation from smartplaylist (thanks stebe)\n* Added SQL unique constraint on tag map\n* Fixed Subsonic genres with JSON format\n* Added Bookmarks feature on Subsonic API\n* Fixed thumb art regeneration if entry found in database without data (thanks s4astliv)\n* Added Podcast feature\n* Added large view / grid view option on artist and albums collection\n* Moved from php-gettext to oscarotero/Gettext\n* Added `Access-Control-Allow-Origin: *` header on Subsonic images & streams\n* Fixed Subsonic item identifier parsing\n* Added logic for external plugin directories (ampache-*)\n* Added Discogs metadata plugin\n\n## 3.8.1\n\n* Fixed PHP7 Error class conflict (thanks trampi)\n* Fixed user password with special characters at install time (thanks jagerman)\n* Moved Ampache project license from GPLv2 to AGPLv3\n* Added Ampache specific information on Subsonic API getAlbum using a new `ampache` parameter (thanks nicklan)\n* Added 'album tag' option in song search (thanks DanielMaly)\n* Added Message of the Day plugin to display MOTD\n* Moved AmpacheApi class to a separate ampacheapi-php git repository\n* Added timeline / friends timeline feature\n* Fixed disabled song display to regular users (thanks shangril)\n* Fixed random albums art size (thanks Bidules079)\n* Moved tag cloud to artist browsing by default\n* Fixed utf8 BOM empty string on song comparison\n* Improved Recently Played and user stats queries performance (thanks thinca)\n* Renamed SAMPLE_RATE to TRANSCODE_BITRATE on transcoding\n* Fixed tag deletion sql error (thanks stebe)\n* Moved to PNG default blank image instead of JPG (thanks Psy-Virus)\n* Fixed temporary playlist initial position when scrolling down (thanks RobertoCarlo)\n* Added Radio stations to UPnP backend\n* Fixed Subsonic API art to use album art if song doesn't have a custom art (thanks hypfvieh)\n* Fixed Subsonic API search when object count parameter is 0 (thanks hypfvieh)\n* Fixed UPnP UUID to be based on host information\n* Moved to Composer for dependencies management\n* Fixed catalog action when not using Ajax page loading (thanks Razrael)\n* Fixed unrated song default value (thanks Combustible)\n* Added custom metadata support from files (thanks Razrael)\n* Improved Subsonic API getArtists performance (thanks nicklan)\n* Fixed theme color setting behavior\n* Moved audioscrobbler API to v2\n* Added m3u8 playlist import\n* Fixed utf8 id3v2 comments support\n* Added write_playlists script to export playlists to file\n* Fixed Tvdb and Tmdb plugins (thanks wagnered)\n* Improved Video filename parsing (thanks wagnered)\n* Fixed non scalar settings value printing on debug page\n* Improved Subsonic API getAlbumList error handling\n* Fixed user login with browser used during the installation\n* Fixed iTunes 12 browsing when using DAAP (thanks Chattaway83)\n* Moved http_port user preference to ampache.cfg.php\n* Upgraded last.fm and libre.fm scrobbling to latest API version (thanks nioc)\n* Added missing space between track and album in Localplay playlist (thanks arnaudbey)\n* Added check fo mbstring.func_overload support before using id3 write functionality (thanks anonymous2ch)\n* Fixed file size calculation when using id3v2 tag (thanks hypfvieh)\n* Added rating from id3 tag (thanks nioc)\n* Added track number on streaming playlist (thanks Fondor1)\n* Fixed catalog export (thanks shellshocker)\n* Fixed file change detection\n* Improved XML API with more information and new functions\n  * (advanced_search, toggle_follow, last_shouts, rate, timeline, friends_timeline)\n* Fixed 'Next' button when browsing start offset is aligned to offset limit (thanks wagnered)\n* Fixed stream kill OS detection (thanks nan4k7)\n* Fixed calculate_art_size script to support storage on disk (thanks nan4k7)\n* Fixed sql script semicolon typo (thanks jack)\n* Added support for .opus files (thanks mrpi)\n* Fixed podcast owner xml information\n* Fixed ldap filter parameter check (thanks ChrGeiss)\n* Fixed 'Add to existing playlist' link for regular users (thanks Niols)\n\n## 3.8.0\n\n* Added Portuguese (Brasil) language (thanks Ione Souza Junior)\n* Updated PHPMailer version to 5.2.10\n* Fixed user stats clear\n* Added user, followers and last shouts XML API functions\n* Fixed transcoded process end on some systems (thanks nan4k7)\n* Added ogg channel streaming support (thanks Deathcow)\n* Fixed sql connection close before stream (thanks fufroma)\n* Added support for several ldap filters (thanks T-Rock)\n* Fixed 'Add to existing playlist' button on web player (thanks RyanCopley)\n* Added 'add to existing playlist' link on album page (thanks RyanCopley)\n* Added option to hide user fullname from other users\n* Added playlist track information in Apache XML API (thanks RyanCopley)\n* Fixed playlist remove song in Apache XML API (thanks RyanCopley)\n* Fixed Subsonic API ifModifiedSince information\n* Added Podcast links to albums / artists\n* Added Piwik and Google Analytics plugins\n* Added Apache 2.4 access control declaration in htaccess files\n* Fixed performance issues on user preferences\n* Added artist search by year and place\n* Fixed search by comment (thanks malkavi)\n* Added Paypal and Flattr plugins\n* Added .maintenance page\n* Fixed captcha\n* Added private messages between users\n* Fixed Subsonic API rating information on albums and songs\n* Added latest artists and shouts RSS feeds\n* Fixed tag cloud ordering\n* Added Label entities associated to artists / users\n* Added WebDAV backend\n* Fixed Subsonic API requests with musicFolderId parameter (thanks dhsc19)\n* Added footer text edition setting\n* Added uploaded artist list on user page\n* Added custom Ampache login logo and favicon support\n* Added edition support on shared objects (thanks dhsc19)\n* Fixed share feature on videos (thanks RobertoCarlo)\n* Removed album year display from album name if unset\n* Fixed Subsonic API Album/Artist song's link (thanks dhsc19 and daneren2005)\n* Added mysql database socket authentication support on web setup (thanks AsavarTzeth)\n* Fixed artist art url for mobile use (thanks dhsc19)\n* Added Shoutbox home plugin\n* Added catalog favorites home plugin\n* Fixed search by rating (thanks iamnumbersix)\n* Added UPnP Localplay (thanks SeregaPru)\n* Changed preferences to return the global value if preference is missing for the searched user\n* Fixed special chars in songs names and tags (thanks SeregaPru)\n* Fixed Subsonic API playlist edition/delation (thanks dhsc19)\n* Fixed integer default value in Apache XML API\n* Fixed image thumb on webplayer and search preview (thanks RobertoCarlo and eephyne)\n* Fixed proxy setting on all external http requests (thanks brendankearney)\n* Added QRCode view of user API key\n* Fixed http status code on Subsonic API streams when using curl (thanks nicklan)\n* Added Server-Sent Events on catalog actions\n* Added option to enable/disable channel and live stream features\n* Removed official PHP 5.3 support\n* Added option to show/hide footer statistics (thanks brownl)\n* Added delete from disk option on user uploaded files\n* Added installation type and players helper at installation process\n* Added tv_episode tag on quicktime files (thanks wagnered)\n* Added new option to disable deferred extended metadata, e.g. artist details\n* Added Subsonic API getAvatar function\n* Fixed unsynced lyrics tags\n* Fixed ldap_filter setting deactivation on ampache.cfg.php update (thanks Rouzax)\n* Added Subsonic API similar artists & songs functions\n* Added Subsonic API getLyrics function\n* Fixed disk number and album artist metadata on quicktime files (thanks JoeDat)\n* Fixed Ampache API playlist_add_song function\n* Added ability to store images on disk\n* Added new setting to define album art min and max width/height\n* Fixed Subsonic API getAlbum returned artist id on songs\n* Fixed Subsonic API cover art when PHP-GD unavailable\n* Fixed Localplay playlist refresh on volume changes (thanks essagl)\n* Fixed web player equalizer option if visualizer is not enabled (thanks brownl)\n* Fixed asx file mime type (thanks thinca)\n* Added song genre parsing options (thanks Razrael and lotan)\n* Added sort on languages list (thanks brownl)\n* Added placeholder text to search box (thanks brownl)\n* Added web player Play Next feature (thanks tan-ce)\n* Fixed Plex backend administration page uri (thanks a9k)\n* Fixed expired shared objects clean (thanks eephyne)\n* Added missing artist search results (thanks bliptec)\n* Fixed song genre id parsing (thanks lotan)\n* Added Scrobble method to Subsonic API\n* Added an option to add tags to child without overwriting\n* Added image dimension info to image tables (thanks tsquare66)\n* Replaced ArchiveLib by StreamZip-PHP to avoid temporary zip file\n* Added Year field in song details and edition\n* Added Subsonic API create/delete user, jukebox control and search auto suggestion\n* Added few optional install tests\n* Improved Share features with modal dialog choices\n* Added new action on playlists to remove duplicates\n* Fixed playlist addition to another playlist (thanks kszulc)\n* Fixed Various Artist link on album page (thanks Jucgshu)\n* Added session_destroy call when a session should be destroyed\n* Added HTML5 ReplayGain track feature\n* Added display and mandatory user registration fields settings\n* Added .htaccess IfModule mod_access.c directives\n* Fixed SmartPlayer results per user (thanks nakinigit)\n* Fixed XSS vulnerability CVE-2014-8620 (thanks g0blin)\n* Fixed playlist import setting on catalog update to be disabled by default (thanks DaPike)\n* Added ability to browse my tags other library items than songs\n* Added Stream Control plugins\n* Added transcode settings per player type\n* Added ability to write directly the new configuration file when it version changed\n* Added `quick play url` to have permanent authenticated stream link without session\n* Fixed unresponsive website on batch download (thanks Rouzax)\n* Added batch download item granularity\n* Fixed 'guest' user site rendering\n* Added Aurora.js support in webplayer\n* Added Google Maps geolocation analyze plugin\n* Added statistical graphs\n* Added user geolocation\n* Added 'Missing Artist' search\n* Fixed Ampache installation with FastCGI\n* Added a new RSS Feed plugin\n* Added a new 'display home' plugin type\n* Added Favorite and Rating features to playlists\n* Added user feedback near mouse cursor on democratic votes\n* Changed header page position to be fixed\n* Added external links on song page details\n* Fixed Subsonic API getAlbumList2 byGenre and byYear order (thanks rrjk)\n* Added html5 desktop notification\n* Added album group order setting\n* Fixed unwanted album merge when one of the album doesn't have mbid\n* Changed video player to go outside the footer\n* Added ip address in authentication failure for fail2ban scripts (thanks popindavibe)\n* Added parameter to hide directplay button if number of items is above a limit\n* Added Tag split (thanks jcwmoore)\n* Fixed album/artist arts and stats migration on rename (thanks jcwmoore)\n* Fixed get lyrics from files (thanks apastuszak)\n* Fixed verify local catalog (thanks JoeDat)\n* Removed Twitter code\n* Added optional cookie disclaimer for the EU Cookie Law\n* Replaced catalog action links to action dropdown list (thanks Psy-Virus)\n* Fixed `remember me` feature (thanks ainola)\n* Added email when registered user must be enabled by administrators\n* Fixed local catalog clean on Windows (thanks Rouzax)\n* Added Subsonic API maxBitRate parameter support (thanks philipl)\n* Fixed Subsonic API special characters encode (thanks nan4k7)\n* Added Beets local and remote catalog support (thanks Razrael)\n* Fixed XML error code returned with invalid Ampache API handshake (thanks funkygaddafi)\n* Replaced iframe to Ajax dynamic page loading\n* Changed `Albums of the Moment` to not necessarily have a cover\n* Added Plex backend items edition support\n* Added hls stream support\n* Added X-Content-Duration header support on streams\n* Removed Toogle Art from artist page\n* Fixed track numbers when removing a song from playlist (thanks stonie08)\n* Added Plex backend playlist support\n* Added gather art from video files (thanks wagnered)\n* Added Plex backend movie / tvshow support\n* Added release group on albums\n* Added Smart Playlist songs list\n* Added zlib test\n* Removed old Ampache themes\n* Fixed Subsonic API lastModified element (thanks bikkuri10)\n* Disabled `beautiful url` on XML-API for retro-compatibility\n* Fixed image resource allocation (thanks greengeek1)\n* Added setting to write id3 metadata to files (thanks tsquare66)\n* Added check for large files manipulation\n* Added video subtitle support\n* Fixed Google arts to use real arts and not the small size preview\n* Added Tmdb metadata plugin\n* Added Omdb metadata plugin\n* Added Music Clips, Movies and TV Shows support\n* Added media type information on catalog\n* Fixed get SmartPlaylist in XML-API (thanks opencrf)\n* Added beautiful url on arts\n* Improved browse list header (thanks Psy-Virus)\n* Fixed user online/offline information on Reborn theme (thanks thorsforge)\n* Added UPnP backend (thanks SeregaPru)\n* Added DAAP backend\n* Added sort options on playlists (thanks Shdwdrgn)\n* Fixed XML-API tag information (thanks jcwmoore)\n* Fixed multiple broadcast play (thanks uk3gaus)\n* Added SmartPlaylists to Subsonic API\n* Added limit option on SmartPlaylists\n* Added random option on SmartPlaylists\n* Added 'item count' on browse\n* Added direct typed links on items tags\n* Fixed Subsonic API compatibility with few players requesting information on library -1\n* Added license information on songs\n* Added upload feature on web interface\n* Added albumartist information on songs (thanks tsquare66)\n* Fixed errors on sql table exists check\n* Fixed play/pause on broadcasts (thanks uk3gaus)\n* Added donation button\n* Added democratic page automatic refresh\n* Fixed distinct random albums\n* Added collapsing menu (thanks Kaivo)\n* Added 'save to playlist' feature on web player (thanks Kaivo)\n* Added tag merge feature\n* Fixed democratic vote with automatic logins (thanks M4DM4NZ)\n* Added git pull update from web interface for development versions\n* Fixed http-rang requests on streaming (thanks thejk)\n* Improved installation process\n* Improved French translation (thanks arnaudbey)\n* Improved German translation (thanks Psy-Virus and meandor)\n\n## 3.7.0\n\n* Added Scrutinizer analyze\n* Fixed playlist play with disabled songs (reported by stebe)\n* Improved user auto-registration to optionally avoid email validation\n* Fixed date.timezone php warnings breaking Ampache API (reported by redcap1)\n* Fixed playlist browse with items > 1000 (reported by Tetram67)\n* Fixed Amazon API Image support (thanks jbrain)\n* Fixed id3v2 multiples genres (reported by Rouzax)\n* Improved democratic playlist view to select the first one by default\n* Improved German translation (thanks Psy-Virus)\n* Fixed playlist view of all users for administrator accounts (reported by stonie08)\n* Added option to regroup album disks to one album view\n* Changed Ampache logo\n* Fixed email validation on user registration (reported by redcap1)\n* Added local charset setting\n* Improved installation steps and design (thanks changi67)\n* Improved Recently Played to not filter songs to one display only\n* Fixed Subsonic transcoding support\n* Fixed Subsonic offline storage file path (reported by Tetram76)\n* Added optional top dock menu\n* Added html5 web audio api visualizer and equalizer\n* Added `Play List` to Localplay mode\n* Fixed encoding issue in batch download\n* Added pagination to democratic playlists\n* Added an option to group albums discs to an unique album\n* Added alphabeticalByName and alphabeticalByArtist browse view in Subsonic API\n* Fixed album art on xspf generated playlist\n* Added stats, playlist and new authentication method to Ampache XML API\n* Added responsive tables to automatically hide optional information on small screen\n* Added song action buttons (user favorite, rating, ...) to the web player\n* Added sortable capability to the web player playlist\n* Added Growl notification/scrobbler plugin\n* Added artist slideshow photos plugin from Flickr\n* Added setting to change Ampache log file name\n* Added playlists to Quick and Advanced search\n* Added pls, asx and xspf playlist file format import\n* Fixed playlist import with song file absolute path (reported by ricksorensen)\n* Fixed playlist import with same song file names (reported by captainark)\n* Added shoutcast notification at specific time when playing a song with a waveform\n* Added Tag edit/delete capability\n* Added several search engine links\n* Added myPlex support on Plex API\n* Added cache on LastFM data\n* Added custom buttons play actions\n* Added artist pictures slideshow for current playing artist\n* Added Broadcast feature\n* Added Channel feature with Icecast compatibility\n* Replaced Muses Radio Player by jPlayer to keep one web player for all\n* Added missing artists in similar artists for Wanted feature\n* Added concerts information from LastFM\n* Added tabs on artist information\n* Added 'add to playlist' direct button on browse items\n* Added avatar on users and Gravatar/Libravatar plugins\n* Fixed playlist visibility (reported by stonie08)\n* Added OpenID authentication\n* Fixed m3u import to playlist on catalog creation (reported by jaydoes)\n* Improved missing/wanted albums with the capability to browse missing artists\n* Added share feature\n* Updated French translation\n* Added options per browse view (alphabetic, infinite scroll, number of items per page...)\n* Fixed several Subsonic players (SubHub, Jamstash...)\n* Added option to get beautiful stream url with url rewriting\n* Added check to use a new thread for scrobbling if available\n* Added confirmation option when closing the currently playing web player\n* Added auto-pause web player option between several browse tabs\n* Fixed similar artists list with disabled catalogs (reported by stebe)\n* Improved Shoutbox (css fix, real time notifications...)\n* Fixed iframe basket play action reload\n* Fixed wanted album auto-remove\n* Fixed MusicBrainz get album art from releases\n* Added Waveform feature on songs\n* Added AutoUpdate Ampache version check\n* Added auto-completion in global Ampache search\n* Added option to 'lock' header/sidebars UI\n* Fixed catalog export when 'All' selected\n* Fixed XBMC Local Play (reported by nakinigit)\n* Fixed artist search\n* Fixed Random Advanced (reported by stebe)\n* Changed song preview directplay icons\n* Added Headphones Automatic Music Downloader support as a 'Wanted Process' plugin\n* Updated PHPMailer to version 5.2.7\n* Updated getID3 to version 1.9.7\n* Added 'Song Preview' feature on missing albums tracks, with EchoNest api\n* Added 'Missing Albums' / 'Wanted List' feature\n* Upgraded to MusicBrainz api v2\n* Replaced Snoopy project with Requests project\n* Added user-agent on Recently Played\n* Added option to show/hide Recently Played, time and user-agent per user\n* Updated French language\n* Added option for iframe or popup web player mode\n* Improved Song/Video web player with jPlayer, Radio player with Muse Radio Player\n* Added 'add media' to the currently played playlist on web player\n* Added dedicated 'Recently Played' page\n* Added enable/disable feature on catalogs\n* Fixed Config class conflict with PEAR\n* Improved recommended artists/songs loading using ajax\n* Added a new modern 'Reborn' theme\n* Improved Subsonic api backend support (json, ...)\n* Added Plex api backend support\n* Added artist art/summary when using LastFM api\n* Added 'all' link when browsing\n* Added option to enable/disable web player technology (flash / html5)\n* Fixed artist/song edition\n* Improved tag edition\n* Added song re-order on album / playlists\n* Replaced Prototype with jQuery\n* Added 'Favorite' feature on songs/albums/artists\n* Added 'Direct Play' feature to play songs without using a playlist\n* Added Lyrics plugins (ChartLyrics and LyricWiki)\n* Fixed ShoutBox enable/disable (reported by cipriant)\n* Added SoundCloud, Dropbox, Subsonic and Google Music catalog plugins\n* Improved Catalogs using plug-ins\n* Added browse paging to all information pages\n* Fixed LDAP authentication with password containing '&' (reported by bruth2)\n* Added directories to zip archives\n* Improved project code style and added Travis builds\n* Added albums default sort preference\n* Added number of times an artist/album/song was played\n* Fixed installation process without database creation\n* Removed administrative flags\n\n## 3.6-FUTURE\n\n* Fixed issue with long session IDs that affected OS X Mavericks and possibly\n  other newer PHP installations (reported by yebo29)\n* Fixed some sort issues (patch by Afterster)\n* Fixed Fresh theme display on large screens (patch by Afterster)\n* Fixed bug that allowed guests to add radio stations\n* Added support for aacp transcoding\n* Improved storage efficiency for large browse results\n* Fixed unnecessary growth of the tmp_browse table from API usage (reported\n  by Ondalf)\n* Removed external module 'validateEmail'\n* Updated PHPMailer to 5.2.6\n\n## 3.6-alpha6 *2013-05-30*\n\n* Fixed date searches using 'before' to use the correct comparison\n  (patch by thinca)\n* Fixed long-standing issue affecting Synology users (patch by NigridsVa)\n* Added support for MySQL sockets (based on patches by randomessence)\n* Fixed some issues with the logic around memory_limit (reported by CableNinja)\n* Fixed issue that sometimes removed ratings after catalog operations (reported\n  by stebe)\n* Fixed catalog song stats (reported by stebe)\n* Fixed ACL text field length to allow entry of IPv6 addresses (reported\n  by Baggypants)\n* Fixed regression preventing the use of an existing database during\n  installation (reported by cjsmo)\n* Fixed operating on all catalogs via the web interface\n  (reported by orbisvicis)\n* Added support for nonstandard database ports\n* Updated getID3 to 1.9.5\n* Improved the performance of stream playlist creation (reported by AkbarSerad)\n* Fixed \"Pure Random\" / Random URLs (reported by mafe)\n\n## 3.6-alpha5 *2013-04-15*\n\n* Fixed persistent XSS vulnerability in user self-editing (reported by\n  Jean-Lou Hau)\n* Fixed persistent XSS vulnerabilities in AJAX object editing (reported by\n  Jean-Lou Hau)\n* Fixed character set detection for ID3v1 tags\n* Added matroska to the list of known tag types\n* Made the getID3 metadata source work better with tag types that Ampache\n  doesn't recognise\n* Switched from the deprecated mysql extension to PDO\n* stderr from the transcode command is now logged for debugging\n* Made database updates more robust and verified that a fresh ## 3.## 3.## 3.5 import\n  will run through the updates without errors\n* Added support for external authenticators like pwauth (based on a patch by\n  sjlu)\n* Renamed the local auth method to pam, which is less confusing\n* Removed the Flash player\n* Added an HTML5 player (patch by Holger Brunn)\n* Changed the way themes handle RTL languages\n* Fixed a display problem with the Penguin theme by adding a new CSS class\n  (patch by Fred Thomsen)\n* Made transcoding and its configuration more flexible\n* Made transcoded streams more standards compliant by not sending a random\n  value as the Content-Length or claiming that ranged requests are\n  supported\n* Changed rating semantics to distinguish between user ratings and the\n  global average and add the ability to search for unrated items\n  (< 1 star)\n* Updated Prototype to git HEAD (4ce0b0f)\n* Fixed bug that disclosed passwords for plugins to users that didn't\n  have access to update the password (patch by Fred Thomsen)\n* Fixed streaming on Android devices and anything else that expects to\n  be able to pass a playlist URL to an application and have it work\n* Removed the SHOUTcast Localplay controller\n\n## 3.6-Alpha4 *2012-11-27*\n\n* Removed lyric support, which was broken and ugly\n* Removed tight coupling to the PHP mysql extension\n* Fixed an issue with adding catalogs on Windows caused by inconsistent\n  behaviour of is_readable() (reported by Lockzi)\n\n## 3.6-Alpha3 *2012-10-15*\n\n* Updated getID3 to 1.9.4b1\n* Removed support for extremely old passwords\n* Playlists imported from M3U now retain their ordering\n  (patch by Florent Fourcot)\n* Removed HTML entity encoding of plaintext email (reported by USMC Guy)\n* Fixed a search issue which prevented the use of multiple tag rules\n  (reported by Istarion)\n* Fixed ASF tag parsing regression (reported by cygn)\n\n## 3.6-Alpha2 *2012-08-15*\n\n* Fixed CLI database load to work regardless of whether it's run from\n  the top-level directory (reported by porthose)\n* Fixed XML cleanup to work with newer versions of libpcre\n  (patch by Natureshadow)\n* Fixed ID3v2 disk number parsing\n* Updated getID3 to 1.9.3\n* Added php-gettext for fallback emulation when a locale (or gettext) isn't\n  supported\n* Fixed pluralisation issue in Recently Played\n* Added support for extracting MBIDs from M4A files\n* Fixed parsing of some tag types (most notably M4A)\n* Corrected PLS output to work with more players (reported by bhassel)\n* Fixed an issue with compound artists in media with MusicBrainz tags\n  (reported by greengeek)\n* Fixed an issue with filename pattern matching when patterns contained\n  characters that are part of regex syntax (such as -)\n* Fixed display of logic operator in rules (reported by Twister)\n* Fixed newsearch issue preventing use of more than 9 rules\n  (reported by Twister)\n* Fixed JSON escaping issue that broke search in some cases\n  (reported by XeeNiX)\n* Overhauled CLI tools for installation and database management\n* Fixed admin form issue (reported by the3rdbit)\n* Improved efficiency of fetching song lists via the API\n  (reported by lotan_rm)\n* Added admin_enable_required option to user registration\n* Fixed session issue preventing some users from streaming\n  (reported by miir01)\n* Quote Content-Disposition header for art, fixes Chrome issue\n  (patch by S\u00e9bastien LIENARD)\n* Fixed art URL returned via the API (patch by lotan_rm)\n* Fixed video searches (reported by mchugh19)\n* Fixed Database Upgrade issue that caused catalog user/pass for\n  remote catalogs to not be added correctly\n* Added the ability to locally cache passwords validated by external\n  means (e.g. to allow LDAP authenticated users to use the API)\n* Fixed session handling to actually use our custom handler\n  (reported by ss23)\n* Fixed Last.FM art method (reported by claudio)\n* Updated Captcha PHP to 2.3\n* Updated PHPMailer to 5.2.0\n* Fixed bug in MPD module which affected toggling random or repeat\n  (patch from jherold)\n* Properly escape config values when writing ampache.cfg.php\n* Fixed session persistence with auth disabled (reported by Nathanael\n  Anderson)\n* Fixed item count retention for Advanced Random (reported by USAF_Pride)\n* Made catalog verify respect memory_cache\n* Some catalog operations are now done in chunks, which works better on\n  large catalogs\n* API now returns year and bitrate for songs\n* Fixed search_songs API method to use Search::run properly\n* Fixed require_session when auth_type is 'local'\n* Catalog filtering fix\n* Toggle artwork with a button instead of a checkbox (patch from mywindow)\n* API handshake code cleanup, including a bugfix from postfuturist\n* Improved install process when JavaScript is disabled\n* Fixed duplicate searching even more\n* Committed minor bugfixes for Penguin theme\n* Added Fresh theme\n* Fixed spurious API handshake failure output\n\n## 3.6-Alpha1 *2011-04-27*\n\n* Fixed forced transcoding\n* Fixed display during catalog updates (reported by Demonic)\n* Fixed duplicate searching (patch from Demonic)\n* Cleaned up transcoding assumptions\n* Fixed tag browsing\n* Added new search/advanced random/dynamic playlist interface\n* byterange handling for ranges starting with 0 (patch from uberbrady)\n* Fixed issue with updating ACLs under Windows (reported by Citlali)\n* Add function that check ampache and php version from each website.\n* Updated each ampache header comment based on phpdocumentor.\n* Fixed only admin can browse phpinfo() for security reasons on /info.php\n* Added a few translation words.\n* Updated version ## 3.6 on docs/*\n* Implemented ldap_require group (patch from eliasp)\n* Fix \\ in web path under Apache + Windows Bug #135\n* Partial MusicBrainz metadata gathering via plugin\n* Metadata code cleanup, support for plugins as metadata sources\n* New plugin architecture\n* Fixed display charset issue with catalog add/update\n* Fixed handling of temporary playlists with >100 items\n* Changed Browse from a singleton to multiple instances\n* Fixed setting access levels for plugin passwords\n* Fixed handling of unusual characters in passwords\n* Fixed support for requesting different thumbnail sizes\n* Added ability to rate Albums of the Moment\n* Added ability to edit/delete playlists while they are displayed\n* Fix track numbers not being 0 padded when downloading or renaming.\n* Rating search now allows specification of operator (>=, <=, or =)\n  and uses the same ratings as normal display.\n* Add -t to catalog_update.inc for generating thumbnails\n* Generate Thumbnails during catalog art operations\n* Fixed transcode seeking of Flacs by switching to MM:SS format for\n  flacs being transcoded\n* Change album_art_order to art_order to reflect general nature of\n  config option\n* Fix PHP warning with IP History if no data is found.\n* Add -g flag to catalog update to allow for art gathering via cmdline\n* Change Update frequency of catalog display to 1 second rather then\n  %10 reduces cpu load due to javascript excution (Thx Dmole)\n* Add bmp to the list of allowed / supported album art types\n* Strip extranious whitespace from cmdline catalog update (Thx ascheel)\n* Fix catalog size math for catalogs up to 4TB (Thx Joost.t.Hart@planet.nl)\n* Fix httpQ not correctly skipping to new song\n* Fix refreshing of Localplay playlist when an item is skipped to\n* Fix missing Content-Disposition filename= on non-transcoded songs\n* Fix refresh of Localplay playlist when you delete a track from it\n* Added ability to add Ampache as a search descriptor (Thx Vlet)\n* Correct issue with single song downloads\n* Removed old useless files\n* Added local auth method that uses PHP's PAM module\n* Correct potential security issues due to misuse of REQUEST for write\n  operations rather then POST (Thx Raphael Geissert <geissert@debian.org>)\n* Finished switching to Dba::read() Dba::write() for database calls\n  (Thx dipsol)\n* Improved File pattern matching (Thx october.rust)\n* Updated Amazon Album art search to current Amazon API specs (Thx Vlet)\n* Fix typo that caused song count to not be set on tag xml response\n* Fix tag methods so that alpha_match and exact_match work\n* Fix limit and offset not working on search_songs API method\n* Fix import m3u on catalog build so it does something\n* Fix inconsistent view during catalog operations\n* Sort malformed files into \"Unknown (Broken)\" rather then leaving\n  them in \"Unknown (Orphaned)\"\n* Fix API democratic voting methods (Thx kindachris)\n* Add server version to API ping response\n* Fix Localplay API methods (Thx thomasa)\n* Improve bin/catalog_update.inc to allow only verify, clean or add\n  (Thx ascheel)\n* Fix issue with batch download and UNC paths (Thx greengeek)\n* Added config option to turn caching on/off, Default is off\n* Fix issue where file tag pattern was ignore if files have no tag structure\n* Add TDRC to list of parsed id3v2 tags\n* Added the rating to a single song view\n* Fix caching issue when updating ratings where they would not\n  display correctly until a page reload\n* Altered the behavior of adding to playlists so that it maintains\n  playlist order rather then using track order\n* Strip excessive \\n's from catalog_update (Thx ascheel)\n* Fix incorrect default ogg transcode target in base config file\n* Fix stream user preferences using cached system preferences\n  rather then their own\n* Fixed prevent_multiple_logins preventing all logins (Thx Hugh)\n* Added additional information to installation process\n* Fix PHP 5.3 errors (Thx momo-i)\n* Fix random methods not working for Localplay\n* Fixed extra space on prefixed albums (Thx ibizaman)\n* Add missing operator on tag and rating searches so they will\n  work with other methods (Thx kiehnet@netscape.net)\n* Add MusicBrainz MBID support to uniqly identify albums and\n  also get more album art (Thx flowerysong)\n* Fix the url to song function\n* Add full path to the files needed by the installation just to\n  make it a little clearer\n* Fixed potential endless loop with malformed genre tags in mp3s\n  (Thx Bernhard Weyrauch)\n* Fixed web path always returning false on /test.php\n* Updated Man Page to fix litian problems for Debian packaging\n* Fixed bug where video was registering as songs for now playing\n  and stats\n* Add phpmailer and change ampache.cfg.php.dist\n* Fixed manpage (Thx Porthose)\n\n## 3.5 *2009-05-05*\n\n* Added complete Czech translation (Thx martin hason)\n* Add the AlmightyOatmeal-Sanity check to prevent a clean from\n  removing all songs if your mount failed, but is still\n  readable by ampache\n* Make the Lang Install page prettier\n* Added Check for hash,inet_pton,windows PHP Version to init so\n  that upgrades without pre-reqs are handled correctly\n* Allow mms,mmsh,mmsu,mmst,rstp in Radio Stream URLs\n* Fixed a problem where after adding a track to a saved playlist\n  there was no UI response upon deleting the track without\n  a page refresh\n* Fix an issue where the full version of the album art was never\n  used even when requested\n* Fix maxlength on acl fields being to small for all IPv6 addresses\n* Add error message when file exists but is unreadable do not\n  remove unreadable songs from catalog\n* Fixed missing title tag on song browse for the title\n  (Thx flowerysong)\n* Fix htmlchar'd rss feed url\n* Fix Port not correctly being added to URL in most cases\n  even when defined in config\n\n  v.## 3.5-Beta2 04/07/2009\n* Fix ASX playlists so more data shows up in WMP (Thx Jon611)\n* Fix dynamic playlist items so they work in stream methods again\n* Fixed Recently Played so that it correctly shows unique songs\n  with the correct data\n* Fix some issues with filenames with Multi-byte characters\n  (Thx Momo-i)\n* Add WMV/MPG specific parsing functions (Thx Momo-i)\n* Add text to /test.php for hash() and SHA256() support under PHP\n  section\n* Fix SHA256 Support so that it references something that exists\n* Fix incorrect debug_event() on login due to typo\n* Remove manage democratic playlist as it has no meaning in the\n  current version\n* Run Dba::reset_db_charset() after upgrade in case people are playing\n  hot potato with their charsets.\n* Move Server Preferences to Admin menu (Thx geekdawg)\n* Fixed missing web_path reference on radio creation link\n* Fixed remote catalog_clean not working\n* Fixed xmlrpc get image. getEncoding wasn't static\n\n## 3.5-Beta1 *2009-03-15*\n\n* Add democratic methods to api, can now vote, devote, get url\n  and the current democratic playlist through the api\n* Revert to old Random Play method\n* Added proxy use for xmlrpcclient\n* Added Configuration 'Wizard' for democratic play\n* Fixed interface feedback issues with democratic play actions\n* Add extension to image urls for the API will add to others as\n  needed due to additional query requirement. Needed to fix\n  some DLNA devices\n* Fixed typo that caused the height of album art not to display\n* Modified database and added GC for tmp_browse table\n* Added get lyrics and album art using http proxy server #313 + username,\n  password patch\n* Added lyricswiki link Ticket #70\n* Updated README language\n* Updated getid3 library 2.0.0b4 to 2.0.0b5\n* Make the Democratic playlist be associated with the user\n  who sends it to a 'player'\n* Fixed missing page headers on democratic playlist\n* Show who voted for the sogns on democratic playlist\n* Increase default stream length to account for the fact that movies\n  are a good bit longer then songs\n* Correct Issues with multi-byte characters in Lyrics (Thx Momo-i)\n* Added caching to Video\n* Added Video calls to the API\n* Remove redundent code from Browse class by making it extend\n  new Query class\n* Update Prototype to 1.6.0.3\n* Add Time range to advanced search\n* Add sorting to Video Browse\n* Changed to new Query backend for Browsing and Dynamic Playlists\n\n## 3.5-Alpha2 *2009-03-08*\n\n* Fixed caching of objects with no return value\n* Fixed updating of songs that should not be updated during catalog\n  verify\n* Added default_user_level config option that allows you to define\n  the user level when use_auth is false. Also allows manual\n  login of admin users when use_auth is false.\n* Fix Version checking and Version Error Message on install (Thx Paleo)\n* Moved Statistics to main menu, split out newest/popular/stats\n* Fixed bug where saved Thumbnails were almost never used\n* Fixed Localplay httpQ and MPD controls to recognize Live Stream\n  urls.\n* Added Localplay controls to API\n* Added Added/Updated filters to API include the ability to specify\n  a date range using ISO 8601 format with [START]/[END]\n* Changed API Date format to ISO 8601\n* Fixed Incorrect Caching of Album records that caused the\n  Name + Year + Disk to not be respected\n* Added Lyrics Patch (Thx alister55 & momo-i)\n* Fixed password not updating when editing an httpQ Localplay\n  instance\n* Added Video support\n* Fixed normalize tracks not re-displaying playlist correctly\n* Fixed now playing now showing currently playing song\n* Fixed now playing clear all not correctly refreshing screen\n* Fixed adding object to playlist so that it correctly shows the\n  songs rather then an empty playlist\n* Added User Agent to IP History information gathering\n* Added Access Control List Wizards to make API interface\n  setup easier\n* Added IPv6 support for Access Control, Sessions, IP History\n* Fixed sorting issue on artist when using search method\n* Updated flash player to 5.9.5\n* Fixed bug where you admins couldn't edit preferences of\n  users due to missing 'key' on form\n* Added Mime type to Song XML\n\n## 3.5-Alpha1 *2008-12-31*\n\n* Fixed sort_files script so that it properly handles variable\n  album art file names in the directories\n* Fixed issue where small thumbnails were used for larger images\n  if gd based resizing was enabled in the config\n* Fixed catalog_update.inc so it doesn't produce errors\n* Made democratic play respect force http play\n* Make installation error messages more helpful\n* Added Swedish (sv_SE) translation (Thanks yeager)\n* Allow Add / Verify of sub directories of existing catalogs\n* Prevent an fread of 0 bytes if you seek to the end of a file\n* Added require_localnet_session config that allows you to exclude\n  IP(s) from session checks, see config.dist\n* Added Nusoap (<http://sourceforge.net/projects/nusoap/>) library\n  for use with future lyrics feature\n* Fixed problem with flash player where random urls were not being\n  added correctly\n* Fixed problem with user creation using old method (Thx Purdyk)\n* Switched to SHA256() for API and passwords\n* Added check for BADTIME error code from Last.FM and correctly\n  return the error rather then a generic one\n* Fix http auth session issues, where every request blew away the\n  old session information\n* Many other minor improvements (Thx Dipsol)\n* Fixed warnings in caching code (Thx Dipsol)\n* Massive text cleanup (Thx Dipsol)\n* Fixed tag searching and improved some other search methods to\n  prevent SQL warnings on no results\n* Improved Test page checks to more accuratly verify putENV support\n* Make network downsampling a little more sane, don't require\n  access level\n* Added caching to Playlist dropdown\n* Fixed double caching on some objects\n* Added base.css and 4 tag 'font' sizes depending on weight/count\n* Fixed inline song edit\n* Updated registration multi-byte mail.\n* Fixed vainfo.class.php didn't catch exception for first analyze.\n* Fixed iconv() returns an empty strings (Thx abs0)\n* Updated getid3 for multi-byte characters, but some wrong id3tags\n  have occurred exception error.\n* Fixed use_auth = false not correctly re-creating the session if\n  you had just switched from use_auth = true\n* Add links to RSS feeds and set default to TRUE in config.dist\n* Fixed Dynamic Random/Related URLs with players that always send\n  a byte offset (MPD)\n* Added Checkbox to use existing Database\n* Updated language code and Fixed catalan language code\n* Added Emulate gettext() from upgradephp-15\n  (<http://freshmeat.net/p/upgradephp>)\n* Fixed Test.php parse error.\n* Updated multibyte character strings mail.\n* Fixed To send mail don't remove the last comma from recipient.\n* Updated More translatable templates.\n* Removed merge-messages.sh and Add LANGLIST (each languages\n  translation statistics).\n* Fixed If database name don't named ampache, can't renamed tags\n  to tag.\n* Fixed count issue on browse Artists (Thx Sylvander)\n* Fixed prevent_multiple_logins, preventing all logins (Thx hugh)\n* Fixed Export catalog headers so it corretly prompts you to download\n  the file\n* Add ability to sort by artist name, album name on song browse\n* Implemented caching on artist and album browse, added total\n  artist time to the many artist view\n* Fixed test config page so it bounces you back to the test page\n  if the config starts parsing correctly\n* Fixed browsing so that you can browse two different types in two\n  windows at the same time\n* Improved gather script for translations (Thx momo-i)\n* Added paging to the Localplay playlist\n* Updated German Translation (Thx Laurent)\n* Fixed issue where Remote songs would never be removed from\n  the democratic playlist\n* Fixed issue where user preferences weren't set correctly\n  on stream (Thx lorijho)\n* Added caching of user preferences to avoid a SQL query on load\n  (Thx Protagonist)\n* Fixed home menu not always displaying the entire contents\n* Fixed logic error with duplicate login setting which caused it\n  to only work if mysql auth was used\n* Changed passwords to SHA1 will prompt to reset password\n* Corrected some translation strings and added jp_JP (Thx momo-i)\n* Ignore filenames that start with . (hidden) solves an issue\n  with mac filesystems\n* Fix tracking of stats for downloaded songs\n* Fix divide by 0 error during transcode in some configurations\n* Remove root mysql pw requirement from installer\n* Added Image Dimensions on Find Album Art page\n* Added Confirmation Screen to Catalog Deletion\n* Reorganized Menu System and Added Modules section\n* Fix an error if you try to add a shoutbox for an invalid object\n  (Thx atrophic)\n* Fixed issue with art dump on jpeg files (Thx atrophic)\n* Fixed issue with force http play and port not correctly specifying\n  non-standard http port (Thx Deathcrow)\n* Remember Starts With value even if you switch tabs\n* Fixed rating caching so it actually completely works now\n* Removed redundent UPDATE on session table due to /util.php\n* Added Batch Download to single Artist view\n* Added back in the direct links on songs, requires download set\n  to enabled as it's essentially the same thing except with\n  now playing information tied to it\n* Bumped API Version to 350001 and require that a version is sent\n  with handshake to indicate the application will work\n* Removed the MyStrands plugin as did not provide good data, and does\n  not appear to have been used\n* Added Catalog Prefix config option used to determine which prefixes\n  should not be used for sorting\n* Merged Browse Menu with Home\n* Added checkbox to single artist view allowing you to enable/disable\n  album art thumbnails on albums of said artist\n* Added timeout override on update_single_item because the function\n  is a lie\n* Fix translations so it's not all german\n* Genre Tag is now used as a 'Tag', Browse Genre removed\n* Ignore getid3() iconv stuff doesn't seem to work\n* Improved fix_filenames.inc, tries a translation first then strips\n  invalid characters\n* Fixed album art not clearing thumbnail correctly on gather\n* Fixed Localplay instance not displaying correctly after change\n  until a page refresh\n* Fixed endless loop on index if you haven't played a song in\n  over two years\n* Fixed gather art and parse m3u not working on catalog create\n  also added URL read support to m3u import\n* Upped Minimum requirements to Mysql 5.x\n* Add codeunde1load's Web 2.0 style tag patch\n* Fixed typo in e-mail From: name (Thx Xgizzmo)\n* Fixed typo in browse auto_init() which could cause ampache to not\n  remember your start point in some situations. (Thx Xgizzmo)\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Repository\\Model\\Art;\nuse Ampache\\Repository\\Model\\Artist;\nuse Ampache\\Module\\Util\\Ui;\n\n/** @var Artist $artist */\n/** @var array $biography */\n\n?>\n\n<div class=\"item_info\">\n    <?php if ($artist instanceof Artist) {\n    $thumb = (empty(trim($biography['summary'] ?? ''))) ? 32 : 2;\n    Art::display('artist', $artist->id, scrub_out($artist->get_fullname() ?? $artist->name), $thumb);\n} ?>\n    <div class=\"item_properties\">\n        <?php $dcol = array();\n        if (array_key_exists('placeformed', $biography) && !empty($biography['placeformed'])) {\n            $dcol[] = $biography['placeformed'];\n        }\n        if (array_key_exists('yearformed', $biography) && (int)$biography['yearformed'] > 0) {\n            $dcol[] = $biography['yearformed'];\n        }\n        if (count($dcol) > 0) {\n            echo implode(', ', $dcol);\n        } ?>\n    </div>\n</div>\n<div id=\"item_summary\">\n    <?php if (array_key_exists('summary', $biography) && !empty($biography['summary'])) { ?>\n        <?php echo nl2br(trim($biography['summary'])); ?>\n        <?php\n    }?>\n</div>\n<script>\n    $(document).ready(function(){\n        $(\"a[rel^='prettyPhoto']\").prettyPhoto({social_tools:false});\n    });\n</script>", "-- GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n-- Copyright 2001 - 2022 Ampache.org\n--\n-- This program is free software: you can redistribute it and/or modify\n-- it under the terms of the GNU Affero General Public License as published by\n-- the Free Software Foundation, either version 3 of the License, or\n-- (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-- GNU Affero General Public License for more details.\n--\n-- You should have received a copy of the GNU Affero General Public License\n-- along with this program.  If not, see <https://www.gnu.org/licenses/>.\n-- phpMyAdmin SQL Dump\n-- version 5.1.3\n-- https://www.phpmyadmin.net/\n--\n-- Host: 192.168.1.20\n-- Generation Time: Dec 08, 2022 at 08:40 AM\n-- Server version: 10.5.15-MariaDB-0+deb11u1\n-- PHP Version: 8.1.11\n\nSET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\";\nSET AUTOCOMMIT = 0;\nSTART TRANSACTION;\nSET time_zone = \"+00:00\";\n\n\n/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;\n/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;\n/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;\n/*!40101 SET NAMES utf8mb4 */;\n\n--\n-- Database: `ampache556`\n--\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `access_list`\n--\n\nDROP TABLE IF EXISTS `access_list`;\nCREATE TABLE IF NOT EXISTS `access_list` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `start` varbinary(255) NOT NULL,\n  `end` varbinary(255) NOT NULL,\n  `level` smallint(3) UNSIGNED NOT NULL DEFAULT 5,\n  `type` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `user` int(11) NOT NULL,\n  `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 1,\n  PRIMARY KEY (`id`),\n  KEY `start` (`start`),\n  KEY `end` (`end`),\n  KEY `level` (`level`),\n  KEY `enabled` (`enabled`)\n) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `access_list`\n--\n\nINSERT INTO `access_list` (`id`, `name`, `start`, `end`, `level`, `type`, `user`, `enabled`) VALUES\n(1, 'DEFAULTv4', 0x00000000, 0xffffffff, 75, 'interface', -1, 1),\n(2, 'DEFAULTv4', 0x00000000, 0xffffffff, 75, 'stream', -1, 1),\n(3, 'DEFAULTv4', 0x00000000, 0xffffffff, 75, 'rpc', -1, 1),\n(4, 'DEFAULTv6', 0x00000000000000000000000000000000, 0xffffffffffffffff, 75, 'interface', -1, 1),\n(5, 'DEFAULTv6', 0x00000000000000000000000000000000, 0xffffffffffffffff, 75, 'stream', -1, 1),\n(6, 'DEFAULTv6', 0x00000000000000000000000000000000, 0xffffffffffffffff, 75, 'rpc', -1, 1);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `album`\n--\n\nDROP TABLE IF EXISTS `album`;\nCREATE TABLE IF NOT EXISTS `album` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `prefix` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `year` int(4) UNSIGNED NOT NULL DEFAULT 1984,\n  `disk` smallint(5) UNSIGNED DEFAULT NULL,\n  `mbid_group` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `release_type` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `album_artist` int(11) UNSIGNED DEFAULT NULL,\n  `original_year` int(4) DEFAULT NULL,\n  `barcode` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog_number` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `time` bigint(20) UNSIGNED DEFAULT NULL,\n  `release_status` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `addition_time` int(11) UNSIGNED DEFAULT 0,\n  `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `song_count` smallint(5) UNSIGNED DEFAULT 0,\n  `artist_count` smallint(5) UNSIGNED DEFAULT 0,\n  `song_artist_count` smallint(5) UNSIGNED DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `name` (`name`),\n  KEY `year` (`year`),\n  KEY `disk` (`disk`),\n  KEY `catalog_IDX` (`catalog`) USING BTREE,\n  KEY `album_artist_IDX` (`album_artist`) USING BTREE,\n  KEY `original_year_IDX` (`original_year`) USING BTREE,\n  KEY `release_type_IDX` (`release_type`) USING BTREE,\n  KEY `release_status_IDX` (`release_status`) USING BTREE,\n  KEY `mbid_IDX` (`mbid`) USING BTREE,\n  KEY `mbid_group_IDX` (`mbid_group`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `album_map`\n--\n\nDROP TABLE IF EXISTS `album_map`;\nCREATE TABLE IF NOT EXISTS `album_map` (\n  `album_id` int(11) UNSIGNED NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(16) COLLATE utf8_unicode_ci DEFAULT NULL,\n  UNIQUE KEY `unique_album_map` (`object_id`,`object_type`,`album_id`),\n  KEY `object_id_index` (`object_id`),\n  KEY `album_id_type_index` (`album_id`,`object_type`),\n  KEY `object_id_type_index` (`object_id`,`object_type`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `artist`\n--\n\nDROP TABLE IF EXISTS `artist`;\nCREATE TABLE IF NOT EXISTS `artist` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `prefix` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `summary` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `placeformed` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `yearformed` int(4) DEFAULT NULL,\n  `last_update` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `user` int(11) DEFAULT NULL,\n  `manual_update` smallint(1) DEFAULT 0,\n  `time` int(11) UNSIGNED DEFAULT NULL,\n  `song_count` smallint(5) UNSIGNED DEFAULT 0,\n  `album_count` smallint(5) UNSIGNED DEFAULT 0,\n  `album_group_count` smallint(5) UNSIGNED DEFAULT 0,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `artist_map`\n--\n\nDROP TABLE IF EXISTS `artist_map`;\nCREATE TABLE IF NOT EXISTS `artist_map` (\n  `artist_id` int(11) UNSIGNED NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(16) COLLATE utf8_unicode_ci DEFAULT NULL,\n  UNIQUE KEY `unique_artist_map` (`object_id`,`object_type`,`artist_id`),\n  KEY `object_id_index` (`object_id`),\n  KEY `artist_id_index` (`artist_id`),\n  KEY `artist_id_type_index` (`artist_id`,`object_type`),\n  KEY `object_id_type_index` (`object_id`,`object_type`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `bookmark`\n--\n\nDROP TABLE IF EXISTS `bookmark`;\nCREATE TABLE IF NOT EXISTS `bookmark` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `position` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `comment` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `object_type` varchar(64) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `creation_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `update_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `broadcast`\n--\n\nDROP TABLE IF EXISTS `broadcast`;\nCREATE TABLE IF NOT EXISTS `broadcast` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) UNSIGNED NOT NULL,\n  `name` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `is_private` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `song` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `started` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `listeners` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `key` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `cache_object_count`\n--\n\nDROP TABLE IF EXISTS `cache_object_count`;\nCREATE TABLE IF NOT EXISTS `cache_object_count` (\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  `count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `threshold` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  PRIMARY KEY (`object_id`,`object_type`,`threshold`,`count_type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `cache_object_count_run`\n--\n\nDROP TABLE IF EXISTS `cache_object_count_run`;\nCREATE TABLE IF NOT EXISTS `cache_object_count_run` (\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  `count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `threshold` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  PRIMARY KEY (`object_id`,`object_type`,`threshold`,`count_type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog`\n--\n\nDROP TABLE IF EXISTS `catalog`;\nCREATE TABLE IF NOT EXISTS `catalog` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `catalog_type` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `last_update` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `last_clean` int(11) UNSIGNED DEFAULT NULL,\n  `last_add` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 1,\n  `rename_pattern` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `sort_pattern` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `gather_types` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `enabled` (`enabled`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog_filter_group`\n--\n\nDROP TABLE IF EXISTS `catalog_filter_group`;\nCREATE TABLE IF NOT EXISTS `catalog_filter_group` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog_filter_group_map`\n--\n\nDROP TABLE IF EXISTS `catalog_filter_group_map`;\nCREATE TABLE IF NOT EXISTS `catalog_filter_group_map` (\n  `group_id` int(11) UNSIGNED NOT NULL,\n  `catalog_id` int(11) UNSIGNED NOT NULL,\n  `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  UNIQUE KEY `group_id` (`group_id`,`catalog_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog_local`\n--\n\nDROP TABLE IF EXISTS `catalog_local`;\nCREATE TABLE IF NOT EXISTS `catalog_local` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `path` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog_map`\n--\n\nDROP TABLE IF EXISTS `catalog_map`;\nCREATE TABLE IF NOT EXISTS `catalog_map` (\n  `catalog_id` int(11) UNSIGNED NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  UNIQUE KEY `unique_catalog_map` (`object_id`,`object_type`,`catalog_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `catalog_remote`\n--\n\nDROP TABLE IF EXISTS `catalog_remote`;\nCREATE TABLE IF NOT EXISTS `catalog_remote` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `uri` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `password` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `channel`\n--\n\nDROP TABLE IF EXISTS `channel`;\nCREATE TABLE IF NOT EXISTS `channel` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `url` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `interface` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `port` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `fixed_endpoint` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `is_private` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `random` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `loop` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `admin_password` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `start_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `max_listeners` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `peak_listeners` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `listeners` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `connections` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `stream_type` varchar(8) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `bitrate` int(11) UNSIGNED NOT NULL DEFAULT 128,\n  `pid` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `clip`\n--\n\nDROP TABLE IF EXISTS `clip`;\nCREATE TABLE IF NOT EXISTS `clip` (\n  `id` int(11) UNSIGNED NOT NULL,\n  `artist` int(11) DEFAULT NULL,\n  `song` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `daap_session`\n--\n\nDROP TABLE IF EXISTS `daap_session`;\nCREATE TABLE IF NOT EXISTS `daap_session` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `creationdate` int(11) UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `deleted_podcast_episode`\n--\n\nDROP TABLE IF EXISTS `deleted_podcast_episode`;\nCREATE TABLE IF NOT EXISTS `deleted_podcast_episode` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `addition_time` int(11) UNSIGNED NOT NULL,\n  `delete_time` int(11) UNSIGNED NOT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) UNSIGNED NOT NULL,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `podcast` int(11) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `deleted_song`\n--\n\nDROP TABLE IF EXISTS `deleted_song`;\nCREATE TABLE IF NOT EXISTS `deleted_song` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `addition_time` int(11) UNSIGNED DEFAULT 0,\n  `delete_time` int(11) UNSIGNED DEFAULT 0,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `update_time` int(11) UNSIGNED DEFAULT 0,\n  `album` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `artist` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `deleted_video`\n--\n\nDROP TABLE IF EXISTS `deleted_video`;\nCREATE TABLE IF NOT EXISTS `deleted_video` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `addition_time` int(11) UNSIGNED NOT NULL,\n  `delete_time` int(11) UNSIGNED NOT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) UNSIGNED NOT NULL,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `democratic`\n--\n\nDROP TABLE IF EXISTS `democratic`;\nCREATE TABLE IF NOT EXISTS `democratic` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `cooldown` int(11) UNSIGNED DEFAULT NULL,\n  `level` tinyint(4) UNSIGNED NOT NULL DEFAULT 25,\n  `user` int(11) NOT NULL,\n  `primary` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `base_playlist` int(11) UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `level` (`level`),\n  KEY `primary_2` (`primary`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `image`\n--\n\nDROP TABLE IF EXISTS `image`;\nCREATE TABLE IF NOT EXISTS `image` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `image` mediumblob DEFAULT NULL,\n  `width` int(4) UNSIGNED DEFAULT 0,\n  `height` int(4) UNSIGNED DEFAULT 0,\n  `mime` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `size` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `object_type` varchar(64) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `kind` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `object_type` (`object_type`),\n  KEY `object_id` (`object_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `ip_history`\n--\n\nDROP TABLE IF EXISTS `ip_history`;\nCREATE TABLE IF NOT EXISTS `ip_history` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `ip` varbinary(255) DEFAULT NULL,\n  `date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `agent` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`user`),\n  KEY `date` (`date`),\n  KEY `ip` (`ip`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `label`\n--\n\nDROP TABLE IF EXISTS `label`;\nCREATE TABLE IF NOT EXISTS `label` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `category` varchar(40) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `summary` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `address` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `email` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `website` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `user` int(11) UNSIGNED DEFAULT NULL,\n  `creation_date` int(11) UNSIGNED DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `country` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `active` tinyint(1) UNSIGNED NOT NULL DEFAULT 1,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `label_asso`\n--\n\nDROP TABLE IF EXISTS `label_asso`;\nCREATE TABLE IF NOT EXISTS `label_asso` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `label` int(11) UNSIGNED NOT NULL,\n  `artist` int(11) UNSIGNED NOT NULL,\n  `creation_date` int(11) UNSIGNED DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `license`\n--\n\nDROP TABLE IF EXISTS `license`;\nCREATE TABLE IF NOT EXISTS `license` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `external_link` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `license`\n--\n\nINSERT INTO `license` (`id`, `name`, `description`, `external_link`) VALUES\n(1, '0 - default', NULL, ''),\n(2, 'CC BY', NULL, 'https://creativecommons.org/licenses/by/3.0/'),\n(3, 'CC BY NC', NULL, 'https://creativecommons.org/licenses/by-nc/3.0/'),\n(4, 'CC BY NC ND', NULL, 'https://creativecommons.org/licenses/by-nc-nd/3.0/'),\n(5, 'CC BY NC SA', NULL, 'https://creativecommons.org/licenses/by-nc-sa/3.0/'),\n(6, 'CC BY ND', NULL, 'https://creativecommons.org/licenses/by-nd/3.0/'),\n(7, 'CC BY SA', NULL, 'https://creativecommons.org/licenses/by-sa/3.0/'),\n(8, 'Licence Art Libre', NULL, 'http://artlibre.org/licence/lal/'),\n(9, 'Yellow OpenMusic', NULL, 'http://openmusic.linuxtag.org/yellow.html'),\n(10, 'Green OpenMusic', NULL, 'http://openmusic.linuxtag.org/green.html'),\n(11, 'Gnu GPL Art', NULL, 'http://gnuart.org/english/gnugpl.html'),\n(12, 'WTFPL', NULL, 'https://en.wikipedia.org/wiki/WTFPL'),\n(13, 'FMPL', NULL, 'http://www.fmpl.org/fmpl.html'),\n(14, 'C Reaction', NULL, 'http://morne.free.fr/Necktar7/creaction.htm');\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `live_stream`\n--\n\nDROP TABLE IF EXISTS `live_stream`;\nCREATE TABLE IF NOT EXISTS `live_stream` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `site_url` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `url` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `genre` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `codec` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `catalog` (`catalog`),\n  KEY `genre` (`genre`),\n  KEY `name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `localplay_httpq`\n--\n\nDROP TABLE IF EXISTS `localplay_httpq`;\nCREATE TABLE IF NOT EXISTS `localplay_httpq` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `owner` int(11) NOT NULL,\n  `host` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `port` int(11) UNSIGNED NOT NULL,\n  `password` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `access` smallint(4) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `localplay_mpd`\n--\n\nDROP TABLE IF EXISTS `localplay_mpd`;\nCREATE TABLE IF NOT EXISTS `localplay_mpd` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `owner` int(11) NOT NULL,\n  `host` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `port` int(11) UNSIGNED NOT NULL DEFAULT 6600,\n  `password` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `access` smallint(4) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `metadata`\n--\n\nDROP TABLE IF EXISTS `metadata`;\nCREATE TABLE IF NOT EXISTS `metadata` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `field` int(11) UNSIGNED NOT NULL,\n  `data` text COLLATE utf8mb4_unicode_ci NOT NULL,\n  `type` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `field` (`field`),\n  KEY `object_id` (`object_id`),\n  KEY `type` (`type`),\n  KEY `objecttype` (`object_id`,`type`),\n  KEY `objectfield` (`object_id`,`field`,`type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `metadata_field`\n--\n\nDROP TABLE IF EXISTS `metadata_field`;\nCREATE TABLE IF NOT EXISTS `metadata_field` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `public` tinyint(1) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `movie`\n--\n\nDROP TABLE IF EXISTS `movie`;\nCREATE TABLE IF NOT EXISTS `movie` (\n  `id` int(11) UNSIGNED NOT NULL,\n  `original_name` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `summary` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `year` int(11) UNSIGNED DEFAULT NULL,\n  `prefix` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `now_playing`\n--\n\nDROP TABLE IF EXISTS `now_playing`;\nCREATE TABLE IF NOT EXISTS `now_playing` (\n  `id` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `user` int(11) NOT NULL,\n  `expire` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `insertion` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `expire` (`expire`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `object_count`\n--\n\nDROP TABLE IF EXISTS `object_count`;\nCREATE TABLE IF NOT EXISTS `object_count` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `user` int(11) NOT NULL,\n  `agent` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `geo_latitude` decimal(10,6) DEFAULT NULL,\n  `geo_longitude` decimal(10,6) DEFAULT NULL,\n  `geo_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `object_count_UNIQUE_IDX` (`object_type`,`object_id`,`date`,`user`,`agent`,`count_type`) USING BTREE,\n  KEY `object_type` (`object_type`),\n  KEY `object_id` (`object_id`),\n  KEY `userid` (`user`),\n  KEY `date` (`date`),\n  KEY `object_count_full_index` (`object_type`,`object_id`,`date`,`user`,`agent`,`count_type`) USING BTREE,\n  KEY `object_count_type_IDX` (`object_type`,`object_id`) USING BTREE,\n  KEY `object_count_date_IDX` (`date`,`count_type`) USING BTREE,\n  KEY `object_count_user_IDX` (`object_type`,`object_id`,`user`,`count_type`) USING BTREE,\n  KEY `object_type_date_IDX` (`object_type`,`date`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `personal_video`\n--\n\nDROP TABLE IF EXISTS `personal_video`;\nCREATE TABLE IF NOT EXISTS `personal_video` (\n  `id` int(11) UNSIGNED NOT NULL,\n  `location` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `summary` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `player_control`\n--\n\nDROP TABLE IF EXISTS `player_control`;\nCREATE TABLE IF NOT EXISTS `player_control` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) UNSIGNED NOT NULL,\n  `cmd` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `value` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `send_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `playlist`\n--\n\nDROP TABLE IF EXISTS `playlist`;\nCREATE TABLE IF NOT EXISTS `playlist` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `user` int(11) DEFAULT NULL,\n  `type` enum('private','public') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `date` int(11) UNSIGNED NOT NULL,\n  `last_update` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `last_duration` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `name` (`name`),\n  KEY `type` (`type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `playlist_data`\n--\n\nDROP TABLE IF EXISTS `playlist_data`;\nCREATE TABLE IF NOT EXISTS `playlist_data` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `playlist` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `object_id` int(11) UNSIGNED DEFAULT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `track` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `playlist` (`playlist`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `podcast`\n--\n\nDROP TABLE IF EXISTS `podcast`;\nCREATE TABLE IF NOT EXISTS `podcast` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `feed` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) NOT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `website` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `language` varchar(5) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `copyright` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `generator` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `lastbuilddate` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `lastsync` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `episodes` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `podcast_episode`\n--\n\nDROP TABLE IF EXISTS `podcast_episode`;\nCREATE TABLE IF NOT EXISTS `podcast_episode` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `guid` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `podcast` int(11) NOT NULL,\n  `state` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `source` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `size` bigint(20) UNSIGNED NOT NULL DEFAULT 0,\n  `time` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `website` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `author` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `category` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `played` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `pubdate` int(11) UNSIGNED NOT NULL,\n  `addition_time` int(11) UNSIGNED NOT NULL,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `waveform` mediumblob DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `preference`\n--\n\nDROP TABLE IF EXISTS `preference`;\nCREATE TABLE IF NOT EXISTS `preference` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `value` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `level` int(11) UNSIGNED NOT NULL DEFAULT 100,\n  `type` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catagory` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `subcatagory` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `preference_UN` (`name`),\n  KEY `catagory` (`catagory`),\n  KEY `name` (`name`)\n) ENGINE=InnoDB AUTO_INCREMENT=176 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `preference`\n--\n\nINSERT INTO `preference` (`id`, `name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES\n(1, 'download', '1', 'Allow Downloads', 100, 'boolean', 'options', 'feature'),\n(4, 'popular_threshold', '10', 'Popular Threshold', 25, 'integer', 'interface', 'query'),\n(19, 'transcode_bitrate', '128', 'Transcode Bitrate', 25, 'string', 'streaming', 'transcoding'),\n(22, 'site_title', 'Ampache :: For the Love of Music', 'Website Title', 100, 'string', 'interface', 'custom'),\n(23, 'lock_songs', '0', 'Lock Songs', 100, 'boolean', 'system', NULL),\n(24, 'force_http_play', '0', 'Force HTTP playback regardless of port', 100, 'boolean', 'system', NULL),\n(29, 'play_type', 'web_player', 'Playback Type', 25, 'special', 'streaming', NULL),\n(31, 'lang', 'en_US', 'Language', 100, 'special', 'interface', NULL),\n(32, 'playlist_type', 'm3u', 'Playlist Type', 100, 'special', 'playlist', NULL),\n(33, 'theme_name', 'reborn', 'Theme', 0, 'special', 'interface', 'theme'),\n(40, 'localplay_level', '0', 'Localplay Access', 100, 'special', 'options', 'localplay'),\n(41, 'localplay_controller', '0', 'Localplay Type', 100, 'special', 'options', 'localplay'),\n(44, 'allow_stream_playback', '1', 'Allow Streaming', 100, 'boolean', 'options', 'feature'),\n(45, 'allow_democratic_playback', '0', 'Allow Democratic Play', 100, 'boolean', 'options', 'feature'),\n(46, 'allow_localplay_playback', '0', 'Allow Localplay Play', 100, 'boolean', 'options', 'localplay'),\n(47, 'stats_threshold', '7', 'Statistics Day Threshold', 75, 'integer', 'interface', 'query'),\n(51, 'offset_limit', '50', 'Offset Limit', 5, 'integer', 'interface', 'query'),\n(52, 'rate_limit', '8192', 'Rate Limit', 100, 'integer', 'streaming', 'transcoding'),\n(53, 'playlist_method', 'default', 'Playlist Method', 5, 'string', 'playlist', NULL),\n(55, 'transcode', 'default', 'Allow Transcoding', 25, 'string', 'streaming', 'transcoding'),\n(69, 'show_lyrics', '0', 'Show lyrics', 0, 'boolean', 'interface', 'player'),\n(70, 'mpd_active', '0', 'MPD Active Instance', 25, 'integer', 'internal', 'mpd'),\n(71, 'httpq_active', '0', 'httpQ Active Instance', 25, 'integer', 'internal', 'httpq'),\n(77, 'lastfm_grant_link', '', 'Last.FM Grant URL', 25, 'string', 'internal', 'lastfm'),\n(78, 'lastfm_challenge', '', 'Last.FM Submit Challenge', 25, 'string', 'plugins', 'lastfm'),\n(82, 'now_playing_per_user', '1', 'Now Playing filtered per user', 50, 'boolean', 'interface', 'home'),\n(83, 'album_sort', '0', 'Album - Default sort', 25, 'string', 'interface', 'library'),\n(84, 'show_played_times', '0', 'Show # played', 25, 'string', 'interface', 'browse'),\n(85, 'song_page_title', '1', 'Show current song in Web Player page title', 25, 'boolean', 'interface', 'player'),\n(86, 'subsonic_backend', '1', 'Use Subsonic backend', 100, 'boolean', 'system', 'backend'),\n(88, 'webplayer_flash', '1', 'Authorize Flash Web Player', 25, 'boolean', 'streaming', 'player'),\n(89, 'webplayer_html5', '1', 'Authorize HTML5 Web Player', 25, 'boolean', 'streaming', 'player'),\n(90, 'allow_personal_info_now', '1', 'Share Now Playing information', 25, 'boolean', 'interface', 'privacy'),\n(91, 'allow_personal_info_recent', '1', 'Share Recently Played information', 25, 'boolean', 'interface', 'privacy'),\n(92, 'allow_personal_info_time', '1', 'Share Recently Played information - Allow access to streaming date/time', 25, 'boolean', 'interface', 'privacy'),\n(93, 'allow_personal_info_agent', '1', 'Share Recently Played information - Allow access to streaming agent', 25, 'boolean', 'interface', 'privacy'),\n(94, 'ui_fixed', '0', 'Fix header position on compatible themes', 25, 'boolean', 'interface', 'theme'),\n(95, 'autoupdate', '1', 'Check for Ampache updates automatically', 25, 'boolean', 'system', 'update'),\n(96, 'autoupdate_lastcheck', '', 'AutoUpdate last check time', 25, 'string', 'internal', 'update'),\n(97, 'autoupdate_lastversion', '', 'AutoUpdate last version from last check', 25, 'string', 'internal', 'update'),\n(98, 'autoupdate_lastversion_new', '', 'AutoUpdate last version from last check is newer', 25, 'boolean', 'internal', 'update'),\n(99, 'webplayer_confirmclose', '0', 'Confirmation when closing current playing window', 25, 'boolean', 'interface', 'player'),\n(100, 'webplayer_pausetabs', '1', 'Auto-pause between tabs', 25, 'boolean', 'interface', 'player'),\n(101, 'stream_beautiful_url', '0', 'Enable URL Rewriting', 100, 'boolean', 'streaming', NULL),\n(102, 'share', '0', 'Allow Share', 100, 'boolean', 'options', 'feature'),\n(103, 'share_expire', '7', 'Share links default expiration days (0=never)', 100, 'integer', 'system', 'share'),\n(104, 'slideshow_time', '0', 'Artist slideshow inactivity time', 25, 'integer', 'interface', 'player'),\n(105, 'broadcast_by_default', '0', 'Broadcast web player by default', 25, 'boolean', 'streaming', 'player'),\n(108, 'album_group', '1', 'Album - Group multiple disks', 25, 'boolean', 'interface', 'library'),\n(109, 'topmenu', '0', 'Top menu', 25, 'boolean', 'interface', 'theme'),\n(110, 'demo_clear_sessions', '0', 'Democratic - Clear votes for expired user sessions', 25, 'boolean', 'playlist', NULL),\n(111, 'show_donate', '1', 'Show donate button in footer', 25, 'boolean', 'interface', NULL),\n(112, 'upload_catalog', '-1', 'Destination catalog', 75, 'integer', 'system', 'upload'),\n(113, 'allow_upload', '0', 'Allow user uploads', 75, 'boolean', 'system', 'upload'),\n(114, 'upload_subdir', '1', 'Create a subdirectory per user', 75, 'boolean', 'system', 'upload'),\n(115, 'upload_user_artist', '0', 'Consider the user sender as the track\\'s artist', 75, 'boolean', 'system', 'upload'),\n(116, 'upload_script', '', 'Post-upload script (current directory = upload target directory)', 75, 'string', 'system', 'upload'),\n(117, 'upload_allow_edit', '1', 'Allow users to edit uploaded songs', 75, 'boolean', 'system', 'upload'),\n(118, 'daap_backend', '0', 'Use DAAP backend', 100, 'boolean', 'system', 'backend'),\n(119, 'daap_pass', '', 'DAAP backend password', 100, 'string', 'system', 'backend'),\n(120, 'upnp_backend', '0', 'Use UPnP backend', 100, 'boolean', 'system', 'backend'),\n(121, 'allow_video', '0', 'Allow Video Features', 75, 'integer', 'options', 'feature'),\n(122, 'album_release_type', '1', 'Album - Group per release type', 25, 'boolean', 'interface', 'library'),\n(123, 'ajax_load', '1', 'Ajax page load', 25, 'boolean', 'interface', NULL),\n(124, 'direct_play_limit', '0', 'Limit direct play to maximum media count', 25, 'integer', 'interface', 'player'),\n(125, 'home_moment_albums', '1', 'Show Albums of the Moment', 25, 'integer', 'interface', 'home'),\n(126, 'home_moment_videos', '0', 'Show Videos of the Moment', 25, 'integer', 'interface', 'home'),\n(127, 'home_recently_played', '1', 'Show Recently Played', 25, 'integer', 'interface', 'home'),\n(128, 'home_now_playing', '1', 'Show Now Playing', 25, 'integer', 'interface', 'home'),\n(129, 'custom_logo', '', 'Custom URL - Logo', 25, 'string', 'interface', 'custom'),\n(130, 'album_release_type_sort', 'album,ep,live,single', 'Album - Group per release type sort', 25, 'string', 'interface', 'library'),\n(131, 'browser_notify', '1', 'Web Player browser notifications', 25, 'integer', 'interface', 'notification'),\n(132, 'browser_notify_timeout', '10', 'Web Player browser notifications timeout (seconds)', 25, 'integer', 'interface', 'notification'),\n(133, 'geolocation', '0', 'Allow Geolocation', 25, 'integer', 'options', 'feature'),\n(134, 'webplayer_aurora', '1', 'Authorize JavaScript decoder (Aurora.js) in Web Player', 25, 'boolean', 'streaming', 'player'),\n(135, 'upload_allow_remove', '1', 'Allow users to remove uploaded songs', 75, 'boolean', 'system', 'upload'),\n(136, 'custom_login_logo', '', 'Custom URL - Login page logo', 75, 'string', 'interface', 'custom'),\n(137, 'custom_favicon', '', 'Custom URL - Favicon', 75, 'string', 'interface', 'custom'),\n(138, 'custom_text_footer', '', 'Custom text footer', 75, 'string', 'interface', 'custom'),\n(139, 'webdav_backend', '0', 'Use WebDAV backend', 100, 'boolean', 'system', 'backend'),\n(140, 'notify_email', '0', 'Allow E-mail notifications', 25, 'boolean', 'options', NULL),\n(141, 'theme_color', 'dark', 'Theme color', 0, 'special', 'interface', 'theme'),\n(142, 'disabled_custom_metadata_fields', '', 'Custom metadata - Disable these fields', 100, 'string', 'system', 'metadata'),\n(143, 'disabled_custom_metadata_fields_input', '', 'Custom metadata - Define field list', 100, 'string', 'system', 'metadata'),\n(144, 'podcast_keep', '0', '# latest episodes to keep', 100, 'integer', 'system', 'podcast'),\n(145, 'podcast_new_download', '0', '# episodes to download when new episodes are available', 100, 'integer', 'system', 'podcast'),\n(146, 'libitem_contextmenu', '1', 'Library item context menu', 0, 'boolean', 'interface', 'library'),\n(147, 'upload_catalog_pattern', '0', 'Rename uploaded file according to catalog pattern', 100, 'boolean', 'system', 'upload'),\n(148, 'catalog_check_duplicate', '0', 'Check library item at import time and disable duplicates', 100, 'boolean', 'system', 'catalog'),\n(149, 'browse_filter', '0', 'Show filter box on browse', 25, 'boolean', 'interface', 'browse'),\n(150, 'sidebar_light', '0', 'Light sidebar by default', 25, 'boolean', 'interface', 'theme'),\n(151, 'custom_blankalbum', '', 'Custom blank album default image', 75, 'string', 'interface', 'custom'),\n(152, 'custom_blankmovie', '', 'Custom blank video default image', 75, 'string', 'interface', 'custom'),\n(153, 'libitem_browse_alpha', '', 'Alphabet browsing by default for following library items (album,artist,...)', 75, 'string', 'interface', 'browse'),\n(154, 'show_skipped_times', '0', 'Show # skipped', 25, 'boolean', 'interface', 'browse'),\n(155, 'custom_datetime', '', 'Custom datetime', 25, 'string', 'interface', 'custom'),\n(156, 'cron_cache', '0', 'Cache computed SQL data (eg. media hits stats) using a cron', 25, 'boolean', 'system', 'catalog'),\n(157, 'unique_playlist', '0', 'Only add unique items to playlists', 25, 'boolean', 'playlist', NULL),\n(158, 'of_the_moment', '6', 'Set the amount of items Album/Video of the Moment will display', 25, 'integer', 'interface', 'home'),\n(159, 'custom_login_background', '', 'Custom URL - Login page background', 75, 'string', 'interface', 'custom'),\n(160, 'show_license', '1', 'Show License', 25, 'boolean', 'interface', 'browse'),\n(161, 'use_original_year', '0', 'Browse by Original Year for albums (falls back to Year)', 25, 'boolean', 'interface', 'browse'),\n(162, 'hide_single_artist', '0', 'Hide the Song Artist column for Albums with one Artist', 25, 'boolean', 'interface', 'browse'),\n(163, 'hide_genres', '0', 'Hide the Genre column in browse table rows', 25, 'boolean', 'interface', 'browse'),\n(164, 'subsonic_always_download', '0', 'Force Subsonic streams to download. (Enable scrobble in your client to record stats)', 25, 'boolean', 'options', 'subsonic'),\n(165, 'api_enable_3', '1', 'Allow Ampache API3 responses', 25, 'boolean', 'options', NULL),\n(166, 'api_enable_4', '1', 'Allow Ampache API4 responses', 25, 'boolean', 'options', NULL),\n(167, 'api_enable_5', '1', 'Allow Ampache API5 responses', 25, 'boolean', 'options', NULL),\n(168, 'api_force_version', '0', 'Force a specific API response no matter what version you send', 25, 'special', 'options', NULL),\n(169, 'show_playlist_username', '1', 'Show playlist owner username in titles', 25, 'boolean', 'interface', 'browse'),\n(170, 'api_hidden_playlists', '', 'Hide playlists in Subsonic and API clients that start with this string', 25, 'string', 'options', NULL),\n(171, 'api_hide_dupe_searches', '0', 'Hide smartlists that match playlist names in Subsonic and API clients', 25, 'boolean', 'options', NULL),\n(172, 'show_album_artist', '1', 'Show \\'Album Artists\\' link in the main sidebar', 25, 'boolean', 'interface', 'theme'),\n(173, 'show_artist', '0', 'Show \\'Artists\\' link in the main sidebar', 25, 'boolean', 'interface', 'theme'),\n(175, 'demo_use_search', '0', 'Democratic - Use smartlists for base playlist', 25, 'boolean', 'system', NULL);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `rating`\n--\n\nDROP TABLE IF EXISTS `rating`;\nCREATE TABLE IF NOT EXISTS `rating` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `object_type` enum('artist','album','song','stream','live_stream','video','playlist','tvshow','tvshow_season','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `rating` tinyint(4) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_rating` (`user`,`object_type`,`object_id`),\n  KEY `object_id` (`object_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `recommendation`\n--\n\nDROP TABLE IF EXISTS `recommendation`;\nCREATE TABLE IF NOT EXISTS `recommendation` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `last_update` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `recommendation_item`\n--\n\nDROP TABLE IF EXISTS `recommendation_item`;\nCREATE TABLE IF NOT EXISTS `recommendation_item` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `recommendation` int(11) UNSIGNED NOT NULL,\n  `recommendation_id` int(11) UNSIGNED DEFAULT NULL,\n  `name` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `rel` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `search`\n--\n\nDROP TABLE IF EXISTS `search`;\nCREATE TABLE IF NOT EXISTS `search` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `type` enum('private','public') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `rules` mediumtext COLLATE utf8mb4_unicode_ci NOT NULL,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `logic_operator` varchar(3) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `random` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `limit` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `last_count` int(11) DEFAULT NULL,\n  `last_duration` int(11) DEFAULT NULL,\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `search`\n--\n\nINSERT INTO `search` (`id`, `user`, `type`, `rules`, `name`, `logic_operator`, `random`, `limit`, `last_count`, `last_duration`, `username`) VALUES\n(5, -1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Artist 5*', 'AND', 0, 0, NULL, NULL, 'System'),\n(6, -1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Artist 4*', 'AND', 0, 0, NULL, NULL, 'System'),\n(7, -1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Artist 3*', 'AND', 0, 0, NULL, NULL, 'System'),\n(8, -1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Artist 2*', 'AND', 0, 0, NULL, NULL, 'System'),\n(9, -1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Artist 1*', 'AND', 0, 0, NULL, NULL, 'System'),\n(10, -1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Album 5*', 'AND', 0, 0, NULL, NULL, 'System'),\n(11, -1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Album 4*', 'AND', 0, 0, NULL, NULL, 'System'),\n(12, -1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Album 3*', 'AND', 0, 0, NULL, NULL, 'System'),\n(13, -1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Album 2*', 'AND', 0, 0, NULL, NULL, 'System'),\n(14, -1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Album 1*', 'AND', 0, 0, NULL, NULL, 'System'),\n(15, -1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Song 5*', 'AND', 0, 0, NULL, NULL, 'System'),\n(16, -1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Song 4*', 'AND', 0, 0, NULL, NULL, 'System'),\n(17, -1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Song 3*', 'AND', 0, 0, NULL, NULL, 'System'),\n(18, -1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Song 2*', 'AND', 0, 0, NULL, NULL, 'System'),\n(19, -1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Song 1*', 'AND', 0, 0, NULL, NULL, 'System');\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `session`\n--\n\nDROP TABLE IF EXISTS `session`;\nCREATE TABLE IF NOT EXISTS `session` (\n  `id` varchar(256) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `expire` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `value` longtext COLLATE utf8mb4_unicode_ci NOT NULL,\n  `ip` varbinary(255) DEFAULT NULL,\n  `type` varchar(16) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `agent` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `geo_latitude` decimal(10,6) DEFAULT NULL,\n  `geo_longitude` decimal(10,6) DEFAULT NULL,\n  `geo_name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `expire` (`expire`),\n  KEY `type` (`type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `session_remember`\n--\n\nDROP TABLE IF EXISTS `session_remember`;\nCREATE TABLE IF NOT EXISTS `session_remember` (\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,\n  `token` varchar(32) COLLATE utf8mb4_unicode_ci NOT NULL,\n  `expire` int(11) DEFAULT NULL,\n  PRIMARY KEY (`username`,`token`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `session_stream`\n--\n\nDROP TABLE IF EXISTS `session_stream`;\nCREATE TABLE IF NOT EXISTS `session_stream` (\n  `id` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL,\n  `user` int(11) UNSIGNED NOT NULL,\n  `agent` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `expire` int(11) UNSIGNED NOT NULL,\n  `ip` varbinary(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `share`\n--\n\nDROP TABLE IF EXISTS `share`;\nCREATE TABLE IF NOT EXISTS `share` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `allow_stream` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `allow_download` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `expire_days` int(4) UNSIGNED NOT NULL DEFAULT 0,\n  `max_counter` int(4) UNSIGNED NOT NULL DEFAULT 0,\n  `secret` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `counter` int(4) UNSIGNED NOT NULL DEFAULT 0,\n  `creation_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `lastvisit_date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `public_url` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `description` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `song`\n--\n\nDROP TABLE IF EXISTS `song`;\nCREATE TABLE IF NOT EXISTS `song` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `album` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `year` mediumint(4) UNSIGNED NOT NULL DEFAULT 0,\n  `artist` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `bitrate` mediumint(8) UNSIGNED NOT NULL DEFAULT 0,\n  `rate` mediumint(8) UNSIGNED NOT NULL DEFAULT 0,\n  `mode` enum('abr','vbr','cbr') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `size` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `time` smallint(5) UNSIGNED NOT NULL DEFAULT 0,\n  `track` smallint(6) DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `played` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 1,\n  `update_time` int(11) UNSIGNED DEFAULT 0,\n  `addition_time` int(11) UNSIGNED DEFAULT 0,\n  `user_upload` int(11) DEFAULT NULL,\n  `license` int(11) DEFAULT NULL,\n  `composer` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `channels` mediumint(9) DEFAULT NULL,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `album` (`album`),\n  KEY `artist` (`artist`),\n  KEY `file` (`file`(333)),\n  KEY `update_time` (`update_time`),\n  KEY `addition_time` (`addition_time`),\n  KEY `catalog` (`catalog`),\n  KEY `played` (`played`),\n  KEY `enabled` (`enabled`),\n  KEY `title_enabled_IDX` (`title`,`enabled`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `song_data`\n--\n\nDROP TABLE IF EXISTS `song_data`;\nCREATE TABLE IF NOT EXISTS `song_data` (\n  `song_id` int(11) UNSIGNED NOT NULL,\n  `comment` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `lyrics` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `label` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `language` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `waveform` mediumblob DEFAULT NULL,\n  `replaygain_track_gain` decimal(10,6) DEFAULT NULL,\n  `replaygain_track_peak` decimal(10,6) DEFAULT NULL,\n  `replaygain_album_gain` decimal(10,6) DEFAULT NULL,\n  `replaygain_album_peak` decimal(10,6) DEFAULT NULL,\n  `r128_track_gain` smallint(5) DEFAULT NULL,\n  `r128_album_gain` smallint(5) DEFAULT NULL,\n  UNIQUE KEY `song_id` (`song_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `song_preview`\n--\n\nDROP TABLE IF EXISTS `song_preview`;\nCREATE TABLE IF NOT EXISTS `song_preview` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `session` varchar(256) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `artist` int(11) DEFAULT NULL,\n  `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `album_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `disk` int(11) DEFAULT NULL,\n  `track` int(11) DEFAULT NULL,\n  `file` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `stream_playlist`\n--\n\nDROP TABLE IF EXISTS `stream_playlist`;\nCREATE TABLE IF NOT EXISTS `stream_playlist` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `sid` varchar(256) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `url` text COLLATE utf8mb4_unicode_ci NOT NULL,\n  `info_url` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `image_url` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `author` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `album` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `type` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `time` smallint(5) DEFAULT NULL,\n  `codec` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `track_num` smallint(5) DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `sid` (`sid`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tag`\n--\n\nDROP TABLE IF EXISTS `tag`;\nCREATE TABLE IF NOT EXISTS `tag` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `is_hidden` tinyint(1) NOT NULL DEFAULT 0,\n  UNIQUE KEY `name` (`name`),\n  KEY `map_id` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tag_map`\n--\n\nDROP TABLE IF EXISTS `tag_map`;\nCREATE TABLE IF NOT EXISTS `tag_map` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `tag_id` int(11) UNSIGNED NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `user` int(11) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_tag_map` (`object_id`,`object_type`,`user`,`tag_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tag_merge`\n--\n\nDROP TABLE IF EXISTS `tag_merge`;\nCREATE TABLE IF NOT EXISTS `tag_merge` (\n  `tag_id` int(11) NOT NULL,\n  `merged_to` int(11) NOT NULL,\n  PRIMARY KEY (`tag_id`,`merged_to`),\n  KEY `merged_to` (`merged_to`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tmp_browse`\n--\n\nDROP TABLE IF EXISTS `tmp_browse`;\nCREATE TABLE IF NOT EXISTS `tmp_browse` (\n  `id` int(13) NOT NULL AUTO_INCREMENT,\n  `sid` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL,\n  `data` longtext COLLATE utf8mb4_unicode_ci NOT NULL,\n  `object_data` longtext COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`sid`,`id`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tmp_playlist`\n--\n\nDROP TABLE IF EXISTS `tmp_playlist`;\nCREATE TABLE IF NOT EXISTS `tmp_playlist` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `session` varchar(256) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `type` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `session` (`session`),\n  KEY `type` (`type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tmp_playlist_data`\n--\n\nDROP TABLE IF EXISTS `tmp_playlist_data`;\nCREATE TABLE IF NOT EXISTS `tmp_playlist_data` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `tmp_playlist` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `track` int(11) UNSIGNED DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `tmp_playlist` (`tmp_playlist`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tvshow`\n--\n\nDROP TABLE IF EXISTS `tvshow`;\nCREATE TABLE IF NOT EXISTS `tvshow` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `summary` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `year` int(11) UNSIGNED DEFAULT NULL,\n  `prefix` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tvshow_episode`\n--\n\nDROP TABLE IF EXISTS `tvshow_episode`;\nCREATE TABLE IF NOT EXISTS `tvshow_episode` (\n  `id` int(11) UNSIGNED NOT NULL,\n  `original_name` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `season` int(11) UNSIGNED NOT NULL,\n  `episode_number` int(11) UNSIGNED NOT NULL,\n  `summary` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `tvshow_season`\n--\n\nDROP TABLE IF EXISTS `tvshow_season`;\nCREATE TABLE IF NOT EXISTS `tvshow_season` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `season_number` int(11) UNSIGNED NOT NULL,\n  `tvshow` int(11) UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `update_info`\n--\n\nDROP TABLE IF EXISTS `update_info`;\nCREATE TABLE IF NOT EXISTS `update_info` (\n  `key` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `value` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  UNIQUE KEY `key` (`key`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `update_info`\n--\n\nINSERT INTO `update_info` (`key`, `value`) VALUES\n('db_version', '550005'),\n('Plugin_Last.FM', '000005');\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user`\n--\n\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE IF NOT EXISTS `user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `fullname` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `email` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `website` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `apikey` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `access` tinyint(4) UNSIGNED NOT NULL,\n  `disabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `last_seen` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `create_date` int(11) UNSIGNED DEFAULT NULL,\n  `validation` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `state` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `city` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `fullname_public` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `rsstoken` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `catalog_filter_group` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `username` (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_activity`\n--\n\nDROP TABLE IF EXISTS `user_activity`;\nCREATE TABLE IF NOT EXISTS `user_activity` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) UNSIGNED NOT NULL,\n  `action` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `activity_date` int(11) UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_data`\n--\n\nDROP TABLE IF EXISTS `user_data`;\nCREATE TABLE IF NOT EXISTS `user_data` (\n  `user` int(11) DEFAULT NULL,\n  `key` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `value` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  UNIQUE KEY `unique_data` (`user`,`key`),\n  KEY `user` (`user`),\n  KEY `key` (`key`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_flag`\n--\n\nDROP TABLE IF EXISTS `user_flag`;\nCREATE TABLE IF NOT EXISTS `user_flag` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_userflag` (`user`,`object_type`,`object_id`),\n  KEY `object_id` (`object_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_follower`\n--\n\nDROP TABLE IF EXISTS `user_follower`;\nCREATE TABLE IF NOT EXISTS `user_follower` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) UNSIGNED NOT NULL,\n  `follow_user` int(11) UNSIGNED NOT NULL,\n  `follow_date` int(11) UNSIGNED DEFAULT NULL,\n  `creation_date` int(11) UNSIGNED DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_playlist`\n--\n\nDROP TABLE IF EXISTS `user_playlist`;\nCREATE TABLE IF NOT EXISTS `user_playlist` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) DEFAULT NULL,\n  `object_type` enum('song','live_stream','video','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `track` smallint(6) DEFAULT NULL,\n  `current_track` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `current_time` smallint(5) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `user` (`user`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_preference`\n--\n\nDROP TABLE IF EXISTS `user_preference`;\nCREATE TABLE IF NOT EXISTS `user_preference` (\n  `user` int(11) NOT NULL,\n  `preference` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `value` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  KEY `user` (`user`),\n  KEY `preference` (`preference`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Dumping data for table `user_preference`\n--\n\nINSERT INTO `user_preference` (`user`, `preference`, `value`) VALUES\n(-1, 1, '1'),\n(-1, 4, '10'),\n(-1, 19, '32'),\n(-1, 22, 'Ampache :: For the Love of Music'),\n(-1, 23, '0'),\n(-1, 24, '0'),\n(-1, 41, 'mpd'),\n(-1, 29, 'web_player'),\n(-1, 31, 'en_US'),\n(-1, 32, 'm3u'),\n(-1, 33, 'reborn'),\n(-1, 51, '50'),\n(-1, 40, '100'),\n(-1, 44, '1'),\n(-1, 45, '1'),\n(-1, 46, '1'),\n(-1, 47, '7'),\n(-1, 52, '8192'),\n(-1, 53, 'default'),\n(-1, 55, 'default'),\n(-1, 69, '0'),\n(-1, 70, '0'),\n(-1, 71, '0'),\n(-1, 77, ''),\n(-1, 78, ''),\n(-1, 114, '1'),\n(-1, 113, '0'),\n(-1, 112, '-1'),\n(-1, 111, '1'),\n(-1, 110, '0'),\n(-1, 109, '0'),\n(-1, 108, '1'),\n(-1, 105, '0'),\n(-1, 104, '0'),\n(-1, 103, '7'),\n(-1, 102, '0'),\n(-1, 101, '0'),\n(-1, 100, '1'),\n(-1, 99, '0'),\n(-1, 95, '1'),\n(-1, 94, '0'),\n(-1, 93, '1'),\n(-1, 92, '1'),\n(-1, 91, '1'),\n(-1, 90, '1'),\n(-1, 89, '1'),\n(-1, 88, '1'),\n(-1, 86, '1'),\n(-1, 85, '1'),\n(-1, 84, '0'),\n(-1, 83, '0'),\n(-1, 82, '1'),\n(-1, 154, '0'),\n(-1, 116, ''),\n(-1, 117, '1'),\n(-1, 118, '0'),\n(-1, 119, ''),\n(-1, 120, '0'),\n(-1, 121, '0'),\n(-1, 122, '1'),\n(-1, 123, '1'),\n(-1, 124, '0'),\n(-1, 125, '1'),\n(-1, 126, '1'),\n(-1, 127, '1'),\n(-1, 128, '1'),\n(-1, 129, ''),\n(-1, 130, 'album,ep,live,single'),\n(-1, 131, '1'),\n(-1, 132, '10'),\n(-1, 133, '0'),\n(-1, 134, '1'),\n(-1, 135, '1'),\n(-1, 136, ''),\n(-1, 137, ''),\n(-1, 138, ''),\n(-1, 139, '0'),\n(-1, 140, '0'),\n(-1, 141, 'dark'),\n(-1, 142, ''),\n(-1, 143, ''),\n(-1, 96, ''),\n(-1, 97, ''),\n(-1, 98, ''),\n(-1, 144, '10'),\n(-1, 145, '1'),\n(-1, 146, '1'),\n(-1, 147, '0'),\n(-1, 148, '0'),\n(-1, 149, '0'),\n(-1, 150, '0'),\n(-1, 151, ''),\n(-1, 152, ''),\n(-1, 153, ''),\n(-1, 155, ''),\n(-1, 156, '0'),\n(-1, 157, ''),\n(-1, 115, '0'),\n(-1, 158, '6'),\n(-1, 159, ''),\n(-1, 160, '1'),\n(-1, 161, '0'),\n(-1, 162, '0'),\n(-1, 163, '0'),\n(-1, 164, '0'),\n(-1, 165, '1'),\n(-1, 166, '1'),\n(-1, 167, '1'),\n(-1, 168, '1'),\n(-1, 169, '0'),\n(-1, 170, '1'),\n(-1, 171, ''),\n(-1, 172, '0'),\n(-1, 173, '1'),\n(-1, 174, '0'),\n(-1, 175, '0');\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_pvmsg`\n--\n\nDROP TABLE IF EXISTS `user_pvmsg`;\nCREATE TABLE IF NOT EXISTS `user_pvmsg` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `subject` varchar(80) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `message` text COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `from_user` int(11) UNSIGNED NOT NULL,\n  `to_user` int(11) UNSIGNED NOT NULL,\n  `is_read` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `creation_date` int(11) UNSIGNED DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_shout`\n--\n\nDROP TABLE IF EXISTS `user_shout`;\nCREATE TABLE IF NOT EXISTS `user_shout` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `text` text COLLATE utf8mb4_unicode_ci NOT NULL,\n  `date` int(11) UNSIGNED NOT NULL,\n  `sticky` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `data` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `sticky` (`sticky`),\n  KEY `date` (`date`),\n  KEY `user` (`user`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `user_vote`\n--\n\nDROP TABLE IF EXISTS `user_vote`;\nCREATE TABLE IF NOT EXISTS `user_vote` (\n  `user` int(11) UNSIGNED NOT NULL,\n  `object_id` int(11) UNSIGNED NOT NULL,\n  `date` int(11) UNSIGNED NOT NULL,\n  `sid` varchar(256) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  KEY `user` (`user`),\n  KEY `object_id` (`object_id`),\n  KEY `date` (`date`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `video`\n--\n\nDROP TABLE IF EXISTS `video`;\nCREATE TABLE IF NOT EXISTS `video` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `file` varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `catalog` int(11) UNSIGNED NOT NULL,\n  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `video_codec` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `audio_codec` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `resolution_x` mediumint(8) UNSIGNED NOT NULL,\n  `resolution_y` mediumint(8) UNSIGNED NOT NULL,\n  `time` int(11) UNSIGNED NOT NULL,\n  `size` bigint(20) UNSIGNED NOT NULL,\n  `mime` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `addition_time` int(11) UNSIGNED NOT NULL,\n  `update_time` int(11) UNSIGNED DEFAULT NULL,\n  `enabled` tinyint(1) NOT NULL DEFAULT 1,\n  `played` tinyint(1) UNSIGNED NOT NULL DEFAULT 0,\n  `release_date` int(11) DEFAULT NULL,\n  `channels` mediumint(9) DEFAULT NULL,\n  `bitrate` mediumint(8) DEFAULT NULL,\n  `video_bitrate` int(11) UNSIGNED DEFAULT NULL,\n  `display_x` mediumint(8) DEFAULT NULL,\n  `display_y` mediumint(8) DEFAULT NULL,\n  `frame_rate` float DEFAULT NULL,\n  `mode` enum('abr','vbr','cbr') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `file` (`file`(333)),\n  KEY `enabled` (`enabled`),\n  KEY `title` (`title`),\n  KEY `addition_time` (`addition_time`),\n  KEY `update_time` (`update_time`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `wanted`\n--\n\nDROP TABLE IF EXISTS `wanted`;\nCREATE TABLE IF NOT EXISTS `wanted` (\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `user` int(11) NOT NULL,\n  `artist` int(11) DEFAULT NULL,\n  `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `year` int(4) DEFAULT NULL,\n  `date` int(11) UNSIGNED NOT NULL DEFAULT 0,\n  `accepted` tinyint(1) NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_wanted` (`user`,`artist`,`mbid`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n--\n-- Indexes for dumped tables\n--\n\n--\n-- Indexes for table `album`\n--\nALTER TABLE `album` ADD FULLTEXT KEY `name_2` (`name`);\n\n--\n-- Indexes for table `artist`\n--\nALTER TABLE `artist` ADD FULLTEXT KEY `name_2` (`name`);\n\n--\n-- Indexes for table `song`\n--\nALTER TABLE `song` ADD FULLTEXT KEY `title` (`title`);\nCOMMIT;\n\n/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;\n/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;\n/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;\n", "<?php\n\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\Art\\Collector;\n\nuse Ampache\\Config\\ConfigContainerInterface;\nuse Ampache\\Repository\\Model\\Album;\nuse Ampache\\Repository\\Model\\Art;\nuse Ampache\\Repository\\Model\\Artist;\nuse Ampache\\Repository\\Model\\Song;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Module\\System\\AmpError;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\LegacyLogger;\nuse Ampache\\Repository\\SongRepositoryInterface;\nuse Psr\\Log\\LoggerInterface;\n\nfinal class FolderCollectorModule implements CollectorModuleInterface\n{\n    private ConfigContainerInterface $configContainer;\n\n    private LoggerInterface $logger;\n\n    private SongRepositoryInterface $songRepository;\n\n    public function __construct(\n        ConfigContainerInterface $configContainer,\n        LoggerInterface $logger,\n        SongRepositoryInterface $songRepository\n    ) {\n        $this->configContainer = $configContainer;\n        $this->logger          = $logger;\n        $this->songRepository  = $songRepository;\n    }\n\n    /**\n     * This returns the art from the folder of the files\n     * If a limit is passed or the preferred filename is found the current\n     * results set is returned\n     *\n     * @param Art $art\n     * @param integer $limit\n     * @param array $data\n     *\n     * @return array\n     */\n    public function collect(\n        Art $art,\n        int $limit = 5,\n        array $data = []\n    ): array {\n        if (!$limit) {\n            $limit = 5;\n        }\n\n        $results   = [];\n        $preferred = [];\n        // For storing which directories we've already done\n        $processed = [];\n\n        /* See if we are looking for a specific filename */\n        $preferred_filename = ($this->configContainer->get('album_art_preferred_filename')) ?: 'folder.jpg';\n        $artist_filename    = $this->configContainer->get('artist_art_preferred_filename');\n        $artist_art_folder  = $this->configContainer->get('artist_art_folder');\n\n        $dirs = array();\n        if ($art->type == 'album') {\n            $media = new Album($art->uid);\n            $songs = $this->songRepository->getByAlbum((int) $media->id);\n            foreach ($songs as $song_id) {\n                $song   = new Song($song_id);\n                $dirs[] = Core::conv_lc_file(dirname($song->file));\n            }\n        } elseif ($art->type == 'video') {\n            $media  = new Video($art->uid);\n            $dirs[] = Core::conv_lc_file(dirname($media->file));\n        } elseif ($art->type == 'artist') {\n            $media              = new Artist($art->uid);\n            $preferred_filename = str_replace(array('<', '>', '\\\\', '/'), '_', $media->get_fullname());\n            if ($artist_art_folder) {\n                $dirs[] = Core::conv_lc_file($artist_art_folder);\n            }\n            // get the folders from songs as well\n            $songs = $this->songRepository->getByArtist((int) $media->id);\n            foreach ($songs as $song_id) {\n                $song = new Song($song_id);\n                // look in the directory name of the files (e.g. /mnt/Music/%artistName%/%album%)\n                $dirs[] = Core::conv_lc_file(dirname($song->file));\n                // look one level up (e.g. /mnt/Music/%artistName%)\n                $dirs[] = Core::conv_lc_file(dirname($song->file, 2));\n            }\n        }\n\n        foreach ($dirs as $dir) {\n            if (isset($processed[$dir])) {\n                continue;\n            }\n\n            $this->logger->notice(\n                \"gather_folder: Opening $dir and checking for \" . $art->type . \" Art\",\n                [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n            );\n\n            /* Open up the directory */\n            $handle = opendir($dir);\n\n            if (!$handle) {\n                AmpError::add('general', T_('Unable to open') . ' ' . $dir);\n\n                $this->logger->warning(\n                    \"gather_folder: Opening $dir and checking for \" . $art->type . \" Art\",\n                    [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n                );\n                continue;\n            }\n\n            $processed[$dir] = true;\n\n            // Recurse through this dir and create the files array\n            while (false !== ($file = readdir($handle))) {\n                $extension = pathinfo($file);\n                $extension = $extension['extension'] ?? '';\n\n                // Make sure it looks like an image file\n                if (!in_array($extension, Art::VALID_TYPES)) {\n                    continue;\n                }\n\n                $full_filename = $dir . '/' . $file;\n\n                // Make sure it's got something in it\n                if (!Core::get_filesize($full_filename)) {\n                    $this->logger->debug(\n                        \"gather_folder: Opening $dir and checking for \" . $art->type . \" Art\",\n                        [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n                    );\n                    continue;\n                }\n\n                // Regularize for mime type\n                if ($extension == 'jpg') {\n                    $extension = 'jpeg';\n                }\n\n                // Take an md5sum so we don't show duplicate files.\n                $index = md5($full_filename);\n\n                if (\n                    (\n                        $file == $preferred_filename ||\n                        pathinfo($file, PATHINFO_FILENAME) == $preferred_filename) ||\n                        (\n                            $file == $artist_filename ||\n                            pathinfo($file, PATHINFO_FILENAME) == $artist_filename\n                        )\n                ) {\n                    // We found the preferred filename and so we're done.\n                    $this->logger->debug(\n                        \"gather_folder: Found preferred image file: $file\",\n                        [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n                    );\n                    $preferred[$index] = [\n                        'file' => $full_filename,\n                        'mime' => 'image/' . $extension,\n                        'title' => 'Folder'\n                    ];\n                    break;\n                }\n                if ($art->type !== 'artist') {\n                    $this->logger->debug(\n                        \"gather_folder: Found image file: $file\",\n                        [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n                    );\n                    $results[$index] = [\n                        'file' => $full_filename,\n                        'mime' => 'image/' . $extension,\n                        'title' => 'Folder'\n                    ];\n                }\n            } // end while reading dir\n            closedir($handle);\n        } // end foreach dirs\n\n        if (!empty($preferred)) {\n            // We found our favorite filename somewhere, so we need\n            // to dump the other, less sexy ones.\n            $results = $preferred;\n        }\n\n        if ($limit && count($results) > $limit) {\n            $results = array_slice($results, 0, $limit);\n        }\n\n        return array_values($results);\n    }\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nnamespace Ampache\\Module\\Playback\\Localplay\\Mpd;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Democratic;\nuse Ampache\\Module\\Playback\\Localplay\\localplay_controller;\nuse Ampache\\Repository\\Model\\Live_Stream;\nuse Ampache\\Repository\\Model\\Preference;\nuse Ampache\\Repository\\Model\\Song;\nuse Ampache\\Module\\Playback\\Stream_Url;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\Util\\ObjectTypeToClassNameMapper;\nuse PDOStatement;\n\n/**\n * AmpacheMpd Class\n *\n * the Ampache Mpd Controller, this is the glue between\n * the MPD class and the Ampache Localplay class\n */\nclass AmpacheMpd extends localplay_controller\n{\n    /* Variables */\n    private $version     = '000003';\n    private $description = 'Controls an instance of MPD';\n\n    private $_add_count = 0;\n\n    /* Constructed variables */\n    private $_mpd;\n\n    /**\n     * get_description\n     * Returns the description\n     */\n    public function get_description()\n    {\n        return $this->description;\n    } // get_description\n\n    /**\n     * get_version\n     * This returns the version information\n     */\n    public function get_version()\n    {\n        return $this->version;\n    } // get_version\n\n    /**\n     * is_installed\n     * This returns true or false if MPD controller is installed\n     */\n    public function is_installed()\n    {\n        $sql        = \"SHOW TABLES LIKE 'localplay_mpd'\";\n        $db_results = Dba::read($sql);\n\n        return (Dba::num_rows($db_results) > 0);\n    } // is_installed\n\n    /**\n     * install\n     * This function installs the MPD Localplay controller\n     */\n    public function install()\n    {\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        /* We need to create the MPD table */\n        $sql = \"CREATE TABLE `localplay_mpd` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `name` VARCHAR(128) COLLATE $collation NOT NULL, `owner` INT(11) NOT NULL, `host` VARCHAR(255) COLLATE $collation NOT NULL, `port` INT(11) UNSIGNED NOT NULL DEFAULT '6600', `password` VARCHAR(255) COLLATE $collation NOT NULL, `access` SMALLINT(4) UNSIGNED NOT NULL DEFAULT '0') ENGINE = $engine DEFAULT CHARSET=$charset COLLATE=$collation\";\n        Dba::query($sql);\n\n        // Add an internal preference for the users current active instance\n        Preference::insert('mpd_active', T_('MPD Active Instance'), 0, 25, 'integer', 'internal', 'mpd');\n\n        return true;\n    } // install\n\n    /**\n     * uninstall\n     * This removes the Localplay controller\n     */\n    public function uninstall()\n    {\n        $sql = \"DROP TABLE `localplay_mpd`\";\n        Dba::write($sql);\n\n        Preference::delete('mpd_active');\n\n        return true;\n    } // uninstall\n\n    /**\n     * add_instance\n     * This takes key'd data and inserts a new MPD instance\n     * @param array $data\n     * @return PDOStatement|boolean\n     */\n    public function add_instance($data)\n    {\n        $sql     = \"INSERT INTO `localplay_mpd` (`name`, `host`, `port`, `password`, `owner`)  VALUES (?, ?, ?, ?, ?)\";\n        $user_id = !empty(Core::get_global('user'))\n            ? Core::get_global('user')->id\n            : -1;\n\n        return Dba::write($sql, array($data['name'] ?? null, $data['host'] ?? null, $data['port'] ?? null, $data['password'] ?? null, $user_id));\n    } // add_instance\n\n    /**\n     * delete_instance\n     * This takes a UID and deletes the instance in question\n     * @param $uid\n     * @return boolean\n     */\n    public function delete_instance($uid)\n    {\n        $uid = Dba::escape($uid);\n        $sql = \"DELETE FROM `localplay_mpd` WHERE `id`='$uid'\";\n        Dba::write($sql);\n\n        return true;\n    } // delete_instance\n\n    /**\n     * get_instances\n     * This returns a key'd array of the instance information with\n     * [UID]=>[NAME]\n     */\n    public function get_instances()\n    {\n        $sql = \"SELECT * FROM `localplay_mpd` ORDER BY `name`\";\n\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['id']] = $row['name'];\n        }\n\n        return $results;\n    } // get_instances\n\n    /**\n     * get_instance\n     * This returns the specified instance and all it's pretty variables\n     * If no instance is passed current is used\n     * @param string $instance\n     * @return array\n     */\n    public function get_instance($instance = '')\n    {\n        $instance   = (is_numeric($instance)) ? (int) $instance : (int) AmpConfig::get('mpd_active', 0);\n        $sql        = ($instance > 0) ? \"SELECT * FROM `localplay_mpd` WHERE `id`= ?\" : \"SELECT * FROM `localplay_mpd`\";\n        $db_results = ($instance > 0) ? Dba::query($sql, array($instance)) : Dba::query($sql);\n\n        return Dba::fetch_assoc($db_results);\n    } // get_instance\n\n    /**\n     * update_instance\n     * This takes an ID and an array of data and updates the instance specified\n     * @param $uid\n     * @param array $data\n     * @return boolean\n     */\n    public function update_instance($uid, $data)\n    {\n        $uid  = Dba::escape($uid);\n        $host = $data['host'] ? Dba::escape($data['host']) : '127.0.0.1';\n        $port = $data['port'] ? Dba::escape($data['port']) : '6600';\n        $name = Dba::escape($data['name']);\n        $pass = Dba::escape($data['password']);\n        $sql  = \"UPDATE `localplay_mpd` SET `host`='$host', `port`='$port', `name`='$name', `password`='$pass' WHERE `id`='$uid'\";\n        Dba::write($sql);\n\n        return true;\n    } // update_instance\n\n    /**\n     * instance_fields\n     * This returns a key'd array of [NAME]=>array([DESCRIPTION]=>VALUE,[TYPE]=>VALUE) for the\n     * fields so that we can on-the-fly generate a form\n     */\n    public function instance_fields(): array\n    {\n        $fields             = array();\n        $fields['name']     = array('description' => T_('Instance Name'), 'type' => 'text');\n        $fields['host']     = array('description' => T_('Hostname'), 'type' => 'text');\n        $fields['port']     = array('description' => T_('Port'), 'type' => 'number');\n        $fields['password'] = array('description' => T_('Password'), 'type' => 'password');\n\n        return $fields;\n    } // instance_fields\n\n    /**\n     * set_active_instance\n     * This sets the specified instance as the 'active' one\n     * @param string $uid\n     * @return boolean\n     */\n    public function set_active_instance($uid)\n    {\n        $user = Core::get_global('user');\n        if ($user == '') {\n            return false;\n        }\n        Preference::update('mpd_active', $user->id, $uid);\n        AmpConfig::set('mpd_active', $uid, true);\n        debug_event('mdp.controller', 'set_active_instance: ' . $uid . ' ' . $user->id, 5);\n\n        return true;\n    } // set_active_instance\n\n    /**\n     * get_active_instance\n     * This returns the UID of the current active instance\n     * false if none are active\n     */\n    public function get_active_instance()\n    {\n    } // get_active_instance\n\n    /**\n     * add_url\n     * This is the new hotness\n     * @param Stream_Url $url\n     * @return boolean\n     */\n    public function add_url(Stream_Url $url)\n    {\n        // If we haven't added anything then maybe we should clear the\n        // playlist.\n        if ($this->_add_count < 1) {\n            $this->_mpd->RefreshInfo();\n            if ($this->_mpd->status['state'] == mpd::STATE_STOPPED) {\n                $this->clear_playlist();\n            }\n        }\n\n        if (!$this->_mpd->PlAdd($url->url)) {\n            debug_event('mdp.controller', 'add_url failed to add: ' . json_encode($url), 1);\n\n            return false;\n        }\n\n        $this->_add_count++;\n\n        return true;\n    }\n\n    /**\n     * delete_track\n     * This must take a single ID (as returned by the get function)\n     * and delete it from the current playlist\n     * @param integer $object_id\n     * @return boolean|string\n     */\n    public function delete_track($object_id)\n    {\n        return $this->_mpd->PLRemove($object_id);\n    } // delete_track\n\n    /**\n     * clear_playlist\n     * This deletes the entire MPD playlist\n     */\n    public function clear_playlist()\n    {\n        return $this->_mpd->PLClear();\n    } // clear_playlist\n\n    /**\n     * play\n     * This just tells MPD to start playing, it does not\n     * take any arguments\n     */\n    public function play()\n    {\n        return $this->_mpd->Play();\n    } // play\n\n    /**\n     * stop\n     * This just tells MPD to stop playing, it does not take\n     * any arguments\n     */\n    public function stop()\n    {\n        return $this->_mpd->Stop();\n    } // stop\n\n    /**\n     * skip\n     * This tells MPD to skip to the specified song\n     * @param $song\n     * @return boolean\n     */\n    public function skip($song)\n    {\n        if (!$this->_mpd->SkipTo($song)) {\n            return false;\n        }\n        sleep(2);\n        $this->stop();\n        sleep(2);\n        $this->play();\n\n        return true;\n    } // skip\n\n    /**\n     * This tells MPD to increase the volume by 5\n     */\n    public function volume_up()\n    {\n        return $this->_mpd->AdjustVolume('5');\n    } // volume_up\n\n    /**\n     * This tells MPD to decrease the volume by 5\n     */\n    public function volume_down()\n    {\n        return $this->_mpd->AdjustVolume('-5');\n    } // volume_down\n\n    /**\n     * next\n     * This just tells MPD to skip to the next song\n     */\n    public function next()\n    {\n        return $this->_mpd->Next();\n    } // next\n\n    /**\n     * prev\n     * This just tells MPD to skip to the prev song\n     */\n    public function prev()\n    {\n        return $this->_mpd->Previous();\n    } // prev\n\n    /**\n     * pause\n     * This tells MPD to pause the current song\n     */\n    public function pause()\n    {\n        return $this->_mpd->Pause();\n    } // pause\n\n    /**\n     * volume\n     * This tells MPD to set the volume to the parameter\n     * @param $volume\n     * @return boolean|string\n     */\n    public function volume($volume)\n    {\n        return $this->_mpd->SetVolume($volume);\n    } // volume\n\n    /**\n     * repeat\n     * This tells MPD to set the repeating the playlist (i.e. loop) to either\n     * on or off.\n     * @param $state\n     * @return boolean|string\n     */\n    public function repeat($state)\n    {\n        return $this->_mpd->SetRepeat($state);\n    } // repeat\n\n    /**\n     * random\n     * This tells MPD to turn on or off the playing of songs from the\n     * playlist in random order.\n     * @param $onoff\n     * @return boolean|string\n     */\n    public function random($onoff)\n    {\n        return $this->_mpd->SetRandom($onoff);\n    } // random\n\n    /**\n     * move\n     * This tells MPD to move a song\n     * @param $source\n     * @param $destination\n     * @return boolean|string\n     */\n    public function move($source, $destination)\n    {\n        return $this->_mpd->PLMoveTrack($source, $destination);\n    } // move\n\n    /**\n     * get_songs\n     * This functions returns an array containing information about\n     * the songs that MPD currently has in its playlist. This must be\n     * done in a standardized fashion\n     * @return array\n     */\n    public function get()\n    {\n        if (!$this->_mpd || ($this->_mpd && !$this->_mpd->status)) {\n            return array();\n        }\n        // If we don't have the playlist yet, pull it\n        if (!isset($this->_mpd->playlist)) {\n            $this->_mpd->RefreshInfo();\n        }\n\n        /* Get the Current Playlist */\n        $playlist = $this->_mpd->playlist;\n        $results  = array();\n        // if there isn't anything to return don't do it\n        if (empty($playlist)) {\n            return $results;\n        }\n\n        foreach ($playlist as $entry) {\n            $data = array();\n\n            /* Required Elements */\n            $data['id']  = $entry['Pos'];\n            $data['raw'] = $entry['file'];\n\n            $url_data = $this->parse_url($entry['file']);\n            $url_key  = $url_data['primary_key'] ?? '';\n\n            switch ($url_key) {\n                case 'oid':\n                    $data['oid'] = $url_data['oid'];\n                    $song        = new Song($data['oid']);\n                    $song->format();\n                    $data['name'] = $song->get_fullname() . ' - ' . $song->f_album . ' - ' . $song->f_artist;\n                    $data['link'] = $song->get_f_link();\n                    break;\n                case 'demo_id':\n                    $democratic   = new Democratic($url_data['demo_id']);\n                    $data['name'] = T_('Democratic') . ' - ' . $democratic->name;\n                    $data['link'] = '';\n                    break;\n                case 'random':\n                    $data['name'] = T_('Random') . ' - ' . scrub_out(ucfirst($url_data['type']));\n                    $data['link'] = '';\n                    break;\n                default:\n                    // If we don't know it, look up by filename\n                    $filename = Dba::escape($entry['file']);\n                    $sql      = \"SELECT `id`, 'song' AS `type` FROM `song` WHERE `file` LIKE '%$filename' UNION ALL SELECT `id`, 'live_stream' AS `type` FROM `live_stream` WHERE `url`='$filename' \";\n\n                    $db_results = Dba::read($sql);\n                    if ($row = Dba::fetch_assoc($db_results)) {\n                        $class_name = ObjectTypeToClassNameMapper::map($row['type']);\n                        $media      = new $class_name($row['id']);\n                        $media->format();\n                        switch ($row['type']) {\n                            case 'song':\n                                $data['name'] = $media->get_fullname() . ' - ' . $media->f_album . ' - ' . $media->f_artist;\n                                $data['link'] = $media->f_link;\n                                break;\n                            case 'live_stream':\n                                /** @var Live_Stream $media */\n                                $site_url     = $media->site_url ? '(' . $media->site_url . ')' : '';\n                                $data['name'] = \"$media->name $site_url\";\n                                $data['link'] = $media->site_url;\n                                break;\n                        } // end switch on type\n                    } else {\n                        $title_string = (isset($entry['Title']) && isset($entry['Album']) && isset($entry['Artist']))\n                            ? $entry['Title'] . ' - ' . $entry['Album'] . ' - ' . $entry['Artist']\n                            : T_('Unknown');\n                        $data['name'] = $title_string;\n                        $data['link'] = '';\n                    }\n                    break;\n            } // end switch on primary key type\n\n            /* Optional Elements */\n            $data['track'] = $entry['Pos'] + 1;\n\n            $results[] = $data;\n        } // foreach playlist items\n\n        return $results;\n    } // get\n\n    /**\n     * get_status\n     * This returns bool/int values for features, loop, repeat and any other\n     * features that this Localplay method supports.\n     * @return array\n     */\n    public function status(): array\n    {\n        $array = array();\n        if (!$this->_mpd || ($this->_mpd && !$this->_mpd->status)) {\n            return $array;\n        }\n        $track = $this->_mpd->status['song'] ?? 0;\n\n        /* Construct the Array */\n        $array['state']        = $this->_mpd->status['state'];\n        $array['volume']       = $this->_mpd->status['volume'];\n        $array['repeat']       = $this->_mpd->status['repeat'];\n        $array['random']       = $this->_mpd->status['random'];\n        $array['track']        = $track + 1;\n        $array['track_title']  = '';\n        $array['track_artist'] = '';\n        $array['track_album']  = '';\n\n        $playlist_item = array();\n        $url_data      = array();\n        if (is_array($this->_mpd->playlist) && array_key_exists($track, $this->_mpd->playlist)) {\n            $playlist_item = $this->_mpd->playlist[$track];\n            $url_data      = $this->parse_url($playlist_item['file']);\n        }\n\n        debug_event('mdp.controller', 'Status result. Current song (' . $track . ') info: ' . json_encode($playlist_item), 5);\n\n        if (count($url_data) > 0 && array_key_exists('oid', $url_data) && !empty($url_data['oid'])) {\n            $song                  = new Song($url_data['oid']);\n            $array['track_title']  = $song->title;\n            $array['track_artist'] = $song->get_artist_fullname();\n            $array['track_album']  = $song->get_album_fullname();\n        } elseif (!empty($playlist_item)) {\n            if (!empty($playlist_item['Title'])) {\n                $array['track_title'] = $playlist_item['Title'];\n            } else {\n                if (!empty($playlist_item['Name'])) {\n                    $array['track_title'] = $playlist_item['Name'];\n                } else {\n                    $array['track_title'] = $playlist_item['file'] ?? '';\n                }\n            }\n            if (!empty($playlist_item['Artist'])) {\n                $array['track_artist'] = $playlist_item['Artist'];\n            }\n            if (!empty($playlist_item['Album'])) {\n                $array['track_album'] = $playlist_item['Album'];\n            }\n        }\n\n        return $array;\n    } // get_status\n\n    /**\n     * connect\n     * This functions creates the connection to MPD and returns\n     * a boolean value for the status, to save time this handle\n     * is stored in this class\n     */\n    public function connect()\n    {\n        // Look at the current instance and pull the options for said instance\n        $options = self::get_instance();\n        if (!array_key_exists('host', $options) && !array_key_exists('port', $options)) {\n            return false;\n        }\n        $this->_mpd = new mpd($options['host'], $options['port'], $options['password'] ?? '', 'debug_event');\n\n        if ($this->_mpd->connected) {\n            return true;\n        }\n\n        return false;\n    } // connect\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\Playback\\Localplay\\Upnp;\n\nuse Ampache\\Module\\System\\Session;\n\nclass UPnPDevice\n{\n    private $_settings = array(\n        \"descriptionURL\" => \"\",\n        \"host\" => \"\",\n        \"controlURLs\" => array(),\n        \"eventURLs\" => array()\n    );\n\n    /**\n     * UPnPDevice constructor.\n     * @param $descriptionUrl\n     */\n    public function __construct($descriptionUrl)\n    {\n        if (!$this->restoreDescriptionUrl($descriptionUrl)) {\n            $this->parseDescriptionUrl($descriptionUrl);\n        }\n    }\n\n    /**\n     * Reads description URL from session\n     * @param $descriptionUrl\n     * @return boolean\n     */\n    private function restoreDescriptionUrl($descriptionUrl)\n    {\n        debug_event('upnpdevice', 'readDescriptionUrl: ' . $descriptionUrl, 5);\n        $this->_settings = json_decode(Session::read('upnp_dev_' . $descriptionUrl), true);\n\n        if ($this->_settings && $this->_settings['descriptionURL'] == $descriptionUrl) {\n            debug_event('upnpdevice', 'service Urls restored from session.', 5);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @param $descriptionUrl\n     */\n    private function parseDescriptionUrl($descriptionUrl)\n    {\n        debug_event('upnpdevice', 'parseDescriptionUrl: ' . $descriptionUrl, 5);\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $descriptionUrl);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        $response = curl_exec($curl);\n        curl_close($curl);\n        //!!debug_event('upnpdevice', 'parseDescriptionUrl response: ' . $response, 5);\n\n        $responseXML = simplexml_load_string($response);\n        $services    = $responseXML->device->serviceList->service ?? array();\n        foreach ($services as $service) {\n            $serviceType                                      = $service->serviceType;\n            $serviceTypeNames                                 = explode(\":\", $serviceType);\n            $serviceTypeName                                  = $serviceTypeNames[3];\n            $this->_settings['controlURLs'][$serviceTypeName] = (string)$service->controlURL;\n            $this->_settings['eventURLs'][$serviceTypeName]   = (string)$service->eventSubURL;\n        }\n\n        $urldata                 = parse_url($descriptionUrl);\n        $this->_settings['host'] = $urldata['scheme'] . '://' . $urldata['host'] . ':' . $urldata['port'];\n\n        $this->_settings['descriptionURL'] = $descriptionUrl;\n\n        Session::create(array(\n            'type' => 'stream',\n            'sid' => 'upnp_dev_' . $descriptionUrl,\n            'value' => json_encode($this->_settings)\n        ));\n    }\n\n    /**\n     * Sending HTTP-Request and returns parsed response\n     *\n     * @param string $method Method name\n     * @param array $arguments Key-Value array\n     * @param string $type\n     * @return string\n     */\n    public function sendRequestToDevice($method, $arguments, $type = 'RenderingControl')\n    {\n        if (!array_key_exists('host', $this->_settings) || !array_key_exists('controlURLs', $this->_settings)) {\n            return '';\n        }\n        $body = '<?xml version=\"1.0\" encoding=\"utf-8\"?>';\n        $body .= '<s:Envelope s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\" xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\"><s:Body>';\n        $body .= '  <u:' . $method . ' xmlns:u=\"urn:schemas-upnp-org:service:' . $type . ':1\">';\n        foreach ($arguments as $arg => $value) {\n            $body .= ' <' . $arg . '>' . $value . '</' . $arg . '>';\n        }\n        $body .= '  </u:' . $method . '>';\n        $body .= '</s:Body></s:Envelope>';\n\n        $controlUrl = $this->_settings['host'] . ((substr($this->_settings['controlURLs'][$type], 0, 1) != \"/\") ? '/' : \"\") . $this->_settings['controlURLs'][$type];\n\n        //!! TODO - need to use scheme in header ??\n        $header = array(\n            'SOAPACTION: \"urn:schemas-upnp-org:service:' . $type . ':1#' . $method . '\"',\n            'CONTENT-TYPE: text/xml; charset=\"utf-8\"',\n            'HOST: ' . $this->_settings['host'],\n            'Connection: close',\n            'Content-Length: ' . mb_strlen($body),\n        );\n        //debug_event('upnpdevice', 'sendRequestToDevice Met: ' . $method . ' | ' . $controlUrl, 5);\n        //debug_event('upnpdevice', 'sendRequestToDevice Body: ' . $body, 5);\n        //debug_event('upnpdevice', 'sendRequestToDevice Hdr: ' . print_r($header, true), 5);\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $controlUrl);\n        curl_setopt($curl, CURLOPT_POST, 1);\n        curl_setopt($curl, CURLOPT_POSTFIELDS, $body);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl, CURLOPT_HEADER, true);\n        curl_setopt($curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n\n        $response = curl_exec($curl);\n        curl_close($curl);\n        //debug_event('upnpdevice', 'sendRequestToDevice response: ' . $response, 5);\n\n        $headers = array();\n        $tmp     = explode(\"\\r\\n\\r\\n\", $response);\n\n        foreach ($tmp as $key => $value) {\n            if (substr($value, 0, 8) == 'HTTP/1.1') {\n                $headers[] = $value;\n                unset($tmp[$key]);\n            }\n        }\n\n        return join(\"\\r\\n\", $tmp);\n    }\n\n    /**\n     * helper function for calls that require only an instance id\n     * @param $command\n     * @param string $type\n     * @param integer $instance_id\n     * @return string\n     */\n    public function instanceOnly($command, $type = 'AVTransport', $instance_id = 0)\n    {\n        $args = array('InstanceID' => $instance_id);\n        //$response = \\Format::forge($response, 'xml:ns')->to_array();\n        //return $response['s:Body']['u:' . $command . 'Response'];\n\n        return $this->sendRequestToDevice($command, $args, $type);\n    }\n\n    //!! UPNP subscription work not for all renderers, and works strange\n    //!! so now is not used\n    /**\n     * Subscribe\n     * Subscribe to UPnP event\n     */\n    /*\n    public function Subscribe($type = 'AVTransport')\n    {\n        $web_path = Ampache\\Config\\AmpConfig::get('web_path');\n        $eventSubsUrl = $web_path . '/upnp/play-event.php?device=' . urlencode($this->_descrUrl);\n        $eventUrl = $this->_host . $this->_eventURLs[$type];\n\n        $header = array(\n            'HOST: ' . $this->_host,\n            'CALLBACK: <' . $eventSubsUrl . '>',\n            'NT: upnp:event',\n            'TIMEOUT: Second-180',\n        );\n        debug_event('upnpdevice', 'Subscribe with: ' . print_r($header, true), 5);\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $eventUrl);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\n        curl_setopt($curl, CURLOPT_HEADER, TRUE);\n        curl_setopt($curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, TRUE);\n        curl_setopt($curl, CURLOPT_CUSTOMREQUEST, 'SUBSCRIBE');\n\n        $response = curl_exec($curl);\n        curl_close( $curl );\n        debug_event('upnpdevice', 'Subscribe response: ' . $response, 5);\n\n        $lines = explode(\"\\r\\n\", trim($response));\n        foreach($lines as $line) {\n            $tmp = explode(':', $line);\n            $key = strtoupper(trim(array_shift($tmp)));\n            $value = trim(join(':', $tmp));\n\n            if ($key == 'SID')\n            {\n                debug_event('upnpdevice', 'Subscribtion SID: ' . $value, 5);\n                return $value;\n            }\n        }\n\n        return null;\n    }\n    */\n\n    //!! UPNP subscription work not for all renderers, and works strange\n    //!! so now is not used\n    /**\n     * UnSubscribe\n     * Unsubscribe from UPnP event\n     */\n    /*\n    public function UnSubscribe($sid, $type = 'AVTransport')\n    {\n        if (empty($sid))\n            return;\n\n        $eventUrl = $this->_host . $this->_eventURLs[$type];\n\n        $header = array(\n            'HOST: ' . $this->_host,\n            'SID: ' . $sid,\n        );\n\n        debug_event('upnpdevice', 'Unsubscribe from SID: ' . $sid . ' with: ' . \"\\n\" . print_r($header, true), 5);\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $eventUrl);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl, CURLOPT_HEADER, true);\n        curl_setopt($curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($curl, CURLOPT_CUSTOMREQUEST, 'UNSUBSCRIBE');\n\n        $response = curl_exec($curl);\n        curl_close( $curl );\n    }\n    */\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\Playback\\Localplay\\Vlc;\n\n/**\n * This player controls an instance of VLC webinterface\n * which in turn controls VLC. All functions\n * return null on failure.\n */\nclass VlcPlayer\n{\n    public $host;\n    public $port;\n    public $password;\n\n    /**\n     * VlcPlayer\n     * This is the constructor, it defaults to localhost\n     * with port 8080\n     * i would change this to another value then standard 8080, it gets used by more things\n     * @param string $host\n     * @param string $password\n     * @param integer $port\n     */\n    public function __construct($host = 'localhost', $password = '', $port = 8080)\n    {\n        $this->host     = $host;\n        $this->port     = $port;\n        $this->password = $password;\n    } // VlcPlayer\n\n    /**\n     * add\n     * append a song to the playlist\n     * $name    Name to be shown in the playlist\n     * $url        URL of the song\n     * @param string $name\n     * @param $url\n     * @return boolean\n     */\n    public function add($name, $url)\n    {\n        $aurl = urlencode($url);\n        $aurl .= \"&\";\n        $aurl .= urlencode($name);\n\n        $args    = array('command' => 'in_enqueue', '&input' => $aurl);\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // add\n\n    /**\n     * version\n     * No version returned in the standard xml file, just need to check for xml returned\n     */\n    public function version()\n    {\n        $args    = array();\n        $results = $this->sendCommand('status.xml', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // version\n\n    /**\n     * clear\n     * clear the playlist\n     * Every command returns status.xml no other way\n     */\n    public function clear()\n    {\n        $args    = array('command' => 'pl_empty');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // clear\n\n    /**\n     * next\n     * go to next song\n     */\n    public function next()\n    {\n        $args    = array('command' => 'pl_next');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // next\n\n    /**\n     * prev\n     * go to previous song\n     */\n    public function prev()\n    {\n        $args    = array('command' => 'pl_previous');\n        $results = $this->sendCommand(\"status.xml?\", $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // prev\n\n    /**\n     * skip\n     * This skips to POS in the playlist\n     * @param $pos\n     * @return boolean|null\n     */\n    public function skip($pos)\n    {\n        $args    = array('command' => 'pl_play', '&id' => $pos);\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        // Works but if user clicks next afterwards player goes to first song our last song played before\n\n        return true;\n    } // skip\n\n    /**\n     * play\n     * play the current song\n     */\n    public function play()\n    {\n        $args    = array('command' => 'pl_play');\n        $results = $this->sendCommand(\"status.xml?\", $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // play\n\n    /**\n     * pause\n     * toggle pause mode on current song\n     */\n    public function pause()\n    {\n        $args    = array('command' => 'pl_pause');\n        $results = $this->sendCommand(\"status.xml?\", $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // pause\n\n    /**\n     * stop\n     * stops the current song amazing!\n     */\n    public function stop()\n    {\n        $args    = array('command' => 'pl_stop');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // stop\n\n    /**\n     * repeat\n     * This toggles the repeat state of VLC\n     * @param $value\n     * @return boolean|null\n     */\n    public function repeat($value)\n    {\n        $args    = array('command' => 'pl_repeat');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return null;\n        }\n\n        return true;\n    } // repeat\n\n    /**\n     * random\n     * this toggles the random state of VLC\n     * @param $value\n     * @return boolean\n     */\n    public function random($value)\n    {\n        $args    = array('command' => 'pl_random');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // random\n\n    /**\n     * delete_pos\n     * This deletes a specific track\n     * @param $track\n     * @return boolean\n     */\n    public function delete_pos($track)\n    {\n        $args    = array('command' => 'pl_delete', '&id' => $track);\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // delete_pos\n\n    /**\n     * state\n     * This returns the current state of the VLC player\n     */\n    public function state()\n    {\n        $args = array();\n\n        $state       = 'unknown';\n        $results     = $this->sendCommand('status.xml', $args);\n        $currentstat = $results['root']['state']['value'];\n\n        if ($currentstat == 'playing') {\n            $state = 'play';\n        }\n        if ($currentstat == 'stop') {\n            $state = 'stop';\n        }\n        if ($currentstat == 'paused') {\n            $state = 'pause';\n        }\n\n        return $state;\n    } // state\n\n    /**\n     * extract the full state from the xml file and send to status in vlccontroller for further parsing.\n     *\n     */\n    public function fullstate()\n    {\n        $args = array();\n\n        $results = $this->sendCommand('status.xml', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return $results;\n    } // fullstate\n\n    /**\n     * volume_up\n     * This increases the volume of VLC, set to +20 can be changed to your preference\n     */\n    public function volume_up()\n    {\n        $args    = array('command' => 'volume', '&val' => '%2B20');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // volume_up\n\n    /**\n     * volume_down\n     * This decreases the volume of VLC, can be set to your preference\n     */\n    public function volume_down()\n    {\n        $args    = array('command' => 'volume', '&val' => '-20');\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // volume_down\n\n    /**\n     * set_volume\n     * This sets the volume as best it can, i think it's from 0 to 400, need more testing'\n     * @param $value\n     * @return boolean\n     */\n    public function set_volume($value)\n    {\n        // Convert it to base 400\n        $value   = $value * 4;\n        $args    = array('command' => 'volume', '&val' => $value);\n        $results = $this->sendCommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // set_volume\n\n    /**\n     * clear_playlist\n     * this flushes the playlist cache (I hope this means clear)\n     */\n    public function clear_playlist()\n    {\n        $args    = array('command' => 'pl_empty');\n        $results = $this->sendcommand('status.xml?', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return true;\n    } // clear_playlist\n\n    /**\n     * get_tracks\n     * This returns a delimited string of all of the filenames\n     * current in your playlist, only urls at the moment,normal files put in the playlist with VLC wil not show'\n     */\n    public function get_tracks()\n    {\n        // Gets complete playlist + medialib in VLC's case, needs to be looked at\n        $args = array();\n\n        $results = $this->sendCommand('playlist.xml', $args);\n        if ($results === null) {\n            return false;\n        }\n\n        return $results;\n    } // get_tracks\n\n    /**\n     * sendCommand\n     * This is the core of this library it takes care of sending the HTTP\n     * request to the VLC server and getting the response\n     * @param $cmd\n     * @param $args\n     * @return array|null\n     */\n    private function sendCommand($cmd, $args)\n    {\n        $fsock = fsockopen($this->host, (int)$this->port, $errno, $errstr);\n\n        if (!$fsock) {\n            debug_event(self::class, \"VLCPlayer: $errstr ($errno)\", 1);\n\n            return null;\n        }\n\n        // Define the base message\n        $msg = \"GET /requests/$cmd\";\n\n        // Foreach our arguments\n        foreach ($args as $key => $val) {\n            $msg .= \"$key=$val\";\n        }\n\n        $msg .= \" HTTP/1.0\\r\\n\";\n\n        // Basic authentication\n        if (!empty($this->password)) {\n            $b64pwd = base64_encode(':' . $this->password);\n            $msg .= \"Authorization: Basic \" . $b64pwd . \"\\r\\n\";\n        }\n\n        $msg .= \"\\r\\n\";\n\n        fputs($fsock, $msg);\n        $data   = '';\n        $header = '';\n        // here the header is split from the xml to avoid problems\n        do {\n            // loop until the end of the header\n\n            $header .= fgets($fsock);\n        } while (strpos($header, \"\\r\\n\\r\\n\") === false);\n\n        // now put the body in variable $data\n        while (!feof($fsock)) {\n            $data .= fgets($fsock);\n        }\n\n        fclose($fsock);\n\n        // send to xml parser and make an array\n        return $this->xmltoarray($data);\n    } // sendCommand\n\n    /**\n     * xmltoarray\n     * this function parses the xml page into an array thx to bin-co\n     * warning VLC returns it's complete media lib if asked for playlist\n     * @param $contents\n     * @param integer $get_attributes\n     * @param string $priority\n     * @return array|void\n     */\n    private function xmltoarray($contents, $get_attributes = 1, $priority = 'attribute')\n    {\n        if (!$contents) {\n            return array();\n        }\n\n        if (!function_exists('xml_parser_create')) {\n            //print \"'xml_parser_create()' function not found!\";\n            return array();\n        }\n\n        // Get the XML parser of PHP - PHP must have this module for the parser to work\n        $parser = xml_parser_create('');\n        xml_parser_set_option($parser, XML_OPTION_TARGET_ENCODING,\n            \"UTF-8\"); # http://minutillo.com/steve/weblog/2004/6/17/php-xml-and-character-encodings-a-tale-of-sadness-rage-and-data-loss\n        xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);\n        xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);\n        xml_parse_into_struct($parser, trim($contents), $xml_values);\n        xml_parser_free($parser);\n\n        if (!$xml_values) {\n            return;\n        } // Hmm...\n\n        // Initializations\n        $bigxml_array = array();\n\n        $current = &$bigxml_array; // Reference\n\n        // Go through the tags.\n        // Multiple tags with same name will be turned into an array\n        $repeated_tag_index = array();\n        foreach ($xml_values as $data) {\n            // Remove existing values, or there will be trouble\n            unset($attributes, $value);\n\n            // This command will extract these variables into the foreach scope\n            // tag(string), type(string), level(int), attributes(array).\n            extract($data); // We could use the array by itself, but this cooler.\n\n            $result          = array();\n            $attributes_data = array();\n\n            if (isset($value)) {\n                if ($priority == 'tag') {\n                    $result = $value;\n                } else {\n                    $result['value'] = $value;\n                } // Put the value in a assoc array if we are in the 'Attribute' mode\n            }\n\n            // Set the attributes too.\n            if (isset($attributes) && $get_attributes) {\n                foreach ($attributes as $attr => $val) {\n                    if ($priority == 'tag') {\n                        $attributes_data[$attr] = $val;\n                    } else {\n                        $result['attr'][$attr] = $val;\n                    } // Set all the attributes in a array called 'attr'\n                }\n            }\n\n            // See tag status and do the needed.\n            if ($type == \"open\") {\n                // The starting of the tag '<tag>'\n                $parent[$level - 1] = &$current;\n                // Insert New tag\n                if (!is_array($current) || (!in_array($tag, array_keys($current)))) {\n                    $current[$tag] = $result;\n                    if ($attributes_data) {\n                        $current[$tag . '_attr'] = $attributes_data;\n                    }\n                    $repeated_tag_index[$tag . '_' . $level] = 1;\n\n                    $current = &$current[$tag];\n                } else {\n                    // There was another element with the same tag name\n                    if (isset($current[$tag][0])) {\n                        // If there is a 0th element it is already an array\n                        $current[$tag][$repeated_tag_index[$tag . '_' . $level]] = $result;\n                        $repeated_tag_index[$tag . '_' . $level]++;\n                    } else {\n                        // This section will make the value an array if multiple tags with the same name appear together\n                        $current[$tag] = array(\n                            $current[$tag],\n                            $result\n                        ); // This will combine the existing item and the new item together to make an array\n                        $repeated_tag_index[$tag . '_' . $level] = 2;\n\n                        if (isset($current[$tag . '_attr'])) {\n                            // The attribute of the last(0th) tag must be moved as well\n                            $current[$tag]['0_attr'] = $current[$tag . '_attr'];\n                            unset($current[$tag . '_attr']);\n                        }\n                    }\n                    $last_item_index = $repeated_tag_index[$tag . '_' . $level] - 1;\n                    $current         = &$current[$tag][$last_item_index];\n                }\n            } elseif ($type == \"complete\") {\n                // Tags that ends in 1 line '<tag />'\n                // See if the key is already taken.\n                if (!isset($current[$tag])) {\n                    //New Key\n                    $current[$tag]                           = $result;\n                    $repeated_tag_index[$tag . '_' . $level] = 1;\n                    if ($priority == 'tag' && $attributes_data) {\n                        $current[$tag . '_attr'] = $attributes_data;\n                    }\n                } else {\n                    // If taken, put all things inside a list(array)\n                    if (isset($current[$tag][0]) && is_array($current[$tag])) {\n                        // If it is already an array push the new element into that array.\n                        $current[$tag][$repeated_tag_index[$tag . '_' . $level]] = $result;\n\n                        if ($priority == 'tag' && $get_attributes && $attributes_data) {\n                            $current[$tag][$repeated_tag_index[$tag . '_' . $level] . '_attr'] = $attributes_data;\n                        }\n                        $repeated_tag_index[$tag . '_' . $level]++;\n                    } else {\n                        // If it is not an array...\n                        $current[$tag] = array(\n                            $current[$tag],\n                            $result\n                        ); // ...Make it an array using using the existing value and the new value\n                        $repeated_tag_index[$tag . '_' . $level] = 1;\n                        if ($priority == 'tag' && $get_attributes) {\n                            if (isset($current[$tag . '_attr'])) {\n                                // The attribute of the last(0th) tag must be moved as well\n                                $current[$tag]['0_attr'] = $current[$tag . '_attr'];\n                                unset($current[$tag . '_attr']);\n                            }\n\n                            if ($attributes_data) {\n                                $current[$tag][$repeated_tag_index[$tag . '_' . $level] . '_attr'] = $attributes_data;\n                            }\n                        }\n                        $repeated_tag_index[$tag . '_' . $level]++; // 0 and 1 index is already taken\n                    }\n                }\n            } elseif ($type == 'close') {\n                // End of tag '</tag>'\n                $current = &$parent[$level - 1];\n            }\n        }\n\n        return ($bigxml_array);\n    }   // xml parser\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\Playback;\n\nuse Ampache\\Repository\\Model\\Media;\nuse Ampache\\Module\\Playback\\Localplay\\LocalPlay;\nuse Ampache\\Module\\Util\\ObjectTypeToClassNameMapper;\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Art;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Repository\\Model\\Democratic;\nuse PDOStatement;\nuse Ampache\\Module\\System\\Session;\nuse Ampache\\Module\\Util\\Ui;\nuse Ampache\\Module\\Api\\Xml_Data;\n\n/**\n * Stream_Playlist Class\n *\n * This class is used to generate the Playlists and pass them on\n * For Localplay this actually just sends the commands to the Localplay\n * module in question.\n */\nclass Stream_Playlist\n{\n    public $id;\n    public $urls = array();\n    public $user;\n    public $title;\n\n    /**\n     * Stream_Playlist constructor\n     * If an ID is passed, it should be a stream session ID.\n     * @param integer|string $session_id\n     */\n    public function __construct($session_id = null)\n    {\n        if ($session_id != -1) {\n            if ($session_id !== null) {\n                Stream::set_session($session_id);\n            }\n\n            $this->id = Stream::get_session();\n\n            if (!Session::exists('stream', $this->id)) {\n                debug_event(self::class, 'Session::exists failed', 2);\n\n                return false;\n            }\n\n            $this->user = (int)(Core::get_global('user')->id);\n\n            $sql        = 'SELECT * FROM `stream_playlist` WHERE `sid` = ? ORDER BY `id`';\n            $db_results = Dba::read($sql, array($this->id));\n\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $this->urls[] = new Stream_Url($row);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param Stream_URL $url\n     * @return PDOStatement|boolean\n     */\n    private function _add_url($url)\n    {\n        debug_event(\"stream_playlist.class\", \"Adding url {\" . json_encode($url) . \"}...\", 5);\n\n        $this->urls[] = $url;\n        $fields       = array();\n        $fields[]     = '`sid`';\n        $values       = array();\n        $values[]     = $this->id;\n        $holders      = array();\n        $holders[]    = '?';\n\n        foreach ($url->properties as $field) {\n            if ($url->$field) {\n                $fields[]  = '`' . $field . '`';\n                $values[]  = $url->$field;\n                $holders[] = '?';\n            }\n        }\n        $sql = 'INSERT INTO `stream_playlist` (' . implode(',', $fields) . ') VALUES (' . implode(',', $holders) . ')';\n\n        return Dba::write($sql, $values);\n    }\n\n    /**\n     * @param array $urls\n     * @return PDOStatement|boolean\n     */\n    private function _add_urls($urls)\n    {\n        debug_event(\"stream_playlist.class\", \"Adding urls to {\" . $this->id . \"}...\", 5);\n        $sql         = '';\n        $fields      = array();\n        $values      = array();\n        $holders_arr = array();\n\n        foreach ($urls as $url) {\n            $this->urls[] = $url;\n            $fields       = array();\n            $fields[]     = '`sid`';\n            $values[]     = $this->id;\n            $holders      = array();\n            $holders[]    = '?';\n\n            foreach ($url->properties as $field) {\n                if ($url->$field !== null) {\n                    $fields[]  = '`' . $field . '`';\n                    $values[]  = $url->$field;\n                    $holders[] = '?';\n                }\n            }\n            $holders_arr[] = $holders;\n        }\n\n        $holders_chunks = array_chunk($holders_arr, 500);\n        foreach ($holders_chunks as $holders_arr_temp) {\n            $sql .= 'INSERT INTO `stream_playlist` (' . implode(',', $fields) . ') VALUES ';\n\n            foreach ($holders_arr_temp as $placeholder) {\n                $sql .= '(' . implode(',', $placeholder) . '),';\n            }\n            // remove last comma\n            $sql = substr($sql, 0, -1);\n            $sql .= ';';\n        }\n\n        return Dba::write($sql, $values);\n    }\n\n    /**\n     * @return PDOStatement|boolean\n     */\n    public static function garbage_collection()\n    {\n        $sql = 'DELETE FROM `stream_playlist` USING `stream_playlist` LEFT JOIN `session` ON `session`.`id`=`stream_playlist`.`sid` WHERE `session`.`id` IS NULL';\n\n        return Dba::write($sql);\n    }\n\n    /**\n     * media_to_urlarray\n     * Formats the URL and media information and adds it to the object\n     * @param $media\n     * @param string $additional_params\n     * @return array\n     */\n    public static function media_to_urlarray($media, $additional_params = '')\n    {\n        $urls = array();\n        foreach ($media as $medium) {\n            $surl = self::media_to_url($medium, $additional_params);\n            if ($surl != null) {\n                $urls[] = $surl;\n            }\n        }\n\n        return $urls;\n    }\n\n    /**\n     * media_to_url\n     * @param $media\n     * @param string $additional_params\n     * @param string $urltype\n     * @return Stream_Url\n     */\n    public static function media_to_url($media, $additional_params = '', $urltype = 'web')\n    {\n        $type       = $media['object_type'];\n        $object_id  = $media['object_id'];\n        $class_name = ObjectTypeToClassNameMapper::map($type);\n        $object     = new $class_name($object_id);\n        $object->format();\n\n        if (array_key_exists('client', $media)) {\n            $additional_params .= \"&client=\" . $media['client'];\n        }\n        if (array_key_exists('action', $media)) {\n            $additional_params .= \"&action=\" . $media['action'];\n        }\n        if (array_key_exists('cache', $media)) {\n            $additional_params .= \"&cache=\" . $media['cache'];\n        }\n        if (array_key_exists('player', $media)) {\n            $additional_params .= \"&player=\" . $media['player'];\n        }\n        if (array_key_exists('format', $media)) {\n            $additional_params .= \"&format=\" . $media['format'];\n        }\n        if (array_key_exists('transcode_to', $media)) {\n            $additional_params .= \"&transcode_to=\" . $media['transcode_to'];\n        }\n        if (array_key_exists('custom_play_action', $media)) {\n            $additional_params .= \"&custom_play_action=\" . $media['custom_play_action'];\n        }\n\n        if (array_key_exists('iframe', $_SESSION) && array_key_exists('subtitle', $_SESSION['iframe'])) {\n            $additional_params .= \"&subtitle=\" . $_SESSION['iframe']['subtitle'];\n        }\n\n        return self::media_object_to_url($object, $additional_params, $urltype);\n    }\n\n    /**\n     * media_object_to_url\n     * @param media $object\n     * @param string $additional_params\n     * @param string $urltype\n     * @return Stream_Url\n     */\n    public static function media_object_to_url($object, $additional_params = '', $urltype = 'web')\n    {\n        $surl = null;\n        $url  = array();\n\n        $class_name  = get_class($object);\n        $type        = ObjectTypeToClassNameMapper::reverseMap($class_name);\n        $url['type'] = $type;\n\n        // Don't add disabled media objects to the stream playlist\n        // Playing a disabled media return a 404 error that could make failed the player (mpd ...)\n        if (!isset($object->enabled) || make_bool($object->enabled)) {\n            if ($urltype == 'file') {\n                $url['url'] = $object->file;\n                // Relative path\n                if (!empty($additional_params) && strpos($url['url'], $additional_params) === 0) {\n                    $url['url'] = substr($url['url'], strlen((string)$additional_params));\n                    if (strlen((string)$url['url']) < 1) {\n                        return null;\n                    }\n                    if ($url['url'][0] == DIRECTORY_SEPARATOR) {\n                        $url['url'] = substr($url['url'], 1);\n                    }\n                }\n            } else {\n                $url['url'] = $object->play_url($additional_params);\n            }\n\n            $api_session = (AmpConfig::get('require_session')) ? Stream::get_session() : null;\n\n            // Set a default which can be overridden\n            $url['author'] = 'Ampache';\n            $url['time']   = (isset($object->time)) ? $object->time : 0;\n            switch ($type) {\n                case 'song':\n                    $url['title']     = $object->title;\n                    $url['author']    = $object->f_artist_full;\n                    $url['info_url']  = $object->f_link;\n                    $show_song_art    = AmpConfig::get('show_song_art', false);\n                    $has_art          = Art::has_db($object->id, 'song');\n                    $art_object       = ($show_song_art && $has_art) ? $object->id : $object->album;\n                    $art_type         = ($show_song_art && $has_art) ? 'song' : 'album';\n                    $url['image_url'] = Art::url($art_object, $art_type, $api_session, (AmpConfig::get('ajax_load') ? 3 : 4));\n                    $url['album']     = $object->f_album_full;\n                    $url['codec']     = $object->type;\n                    $url['track_num'] = (string)$object->track;\n                    break;\n                case 'video':\n                    $url['title']      = 'Video - ' . $object->title;\n                    $url['author']     = $object->f_artist_full;\n                    $url['resolution'] = $object->f_resolution;\n                    $url['codec']      = $object->type;\n                    break;\n                case 'live_stream':\n                    $url['title'] = 'Radio - ' . $object->name;\n                    if (!empty($object->site_url)) {\n                        $url['title'] .= ' (' . $object->site_url . ')';\n                    }\n                    $url['info_url']  = $object->f_link;\n                    $url['image_url'] = Art::url($object->id, 'live_stream', $api_session, (AmpConfig::get('ajax_load') ? 3 : 4));\n                    $url['codec']     = $object->codec;\n                    break;\n                case 'song_preview':\n                    $url['title']  = $object->title;\n                    $url['author'] = $object->f_artist_full;\n                    $url['codec']  = $object->type;\n                    break;\n                case 'channel':\n                    $url['title'] = $object->name;\n                    $url['codec'] = $object->stream_type;\n                    break;\n                case 'podcast_episode':\n                    $url['title']     = $object->f_name;\n                    $url['author']    = $object->f_podcast;\n                    $url['info_url']  = $object->f_link;\n                    $url['image_url'] = Art::url($object->podcast, 'podcast', $api_session, (AmpConfig::get('ajax_load') ? 3 : 4));\n                    $url['codec']     = $object->type;\n                    break;\n                default:\n                    $url['title'] = Stream_Url::get_title($url['url']);\n                    $url['time']  = -1;\n                    break;\n            }\n\n            $surl = new Stream_Url($url);\n        }\n\n        return $surl;\n    }\n\n    /**\n     * check_autoplay_append\n     * @return boolean\n     */\n    public static function check_autoplay_append()\n    {\n        // For now, only iframed web player support media append in the currently played playlist\n        return ((AmpConfig::get('ajax_load') && AmpConfig::get('play_type') == 'web_player') || AmpConfig::get('play_type') == 'localplay');\n    }\n\n    /**\n     * check_autoplay_next\n     * @return boolean\n     */\n    public static function check_autoplay_next()\n    {\n        // Currently only supported for web player\n        return (AmpConfig::get('ajax_load') && AmpConfig::get('play_type') == 'web_player');\n    }\n\n    /**\n     * @param $type\n     * @param boolean $redirect\n     * @return boolean\n     */\n    public function generate_playlist($type, $redirect = false)\n    {\n        if (!count($this->urls)) {\n            debug_event(self::class, 'Error: Empty URL array for ' . $this->id, 2);\n\n            return false;\n        }\n\n        debug_event(self::class, 'Generating a {' . $type . '} object...', 4);\n\n        $ext = $type;\n        switch ($type) {\n            case 'download':\n            case 'democratic':\n            case 'localplay':\n            case 'web_player':\n                // These are valid, but witchy\n                $ctype    = \"\";\n                $redirect = false;\n                unset($ext);\n                break;\n            case 'asx':\n                $ctype = 'video/x-ms-asf';\n                break;\n            case 'pls':\n                $ctype = 'audio/x-scpls';\n                break;\n            case 'ram':\n                $ctype = 'audio/x-pn-realaudio ram';\n                break;\n            case 'simple_m3u':\n                $ext   = 'm3u';\n                $ctype = 'audio/x-mpegurl';\n                break;\n            case 'xspf':\n                $ctype = 'application/xspf+xml';\n                break;\n            case 'hls':\n                $ext   = 'm3u8';\n                $ctype = 'application/vnd.apple.mpegurl';\n                break;\n            case 'm3u':\n            default:\n                // Assume M3U if the pooch is screwed\n                $ext   = $type = 'm3u';\n                $ctype = 'audio/x-mpegurl';\n                break;\n        }\n\n        if ($redirect) {\n            // Our ID is the SID, so we always want to include it\n            AmpConfig::set('require_session', true, true);\n            header('Location: ' . Stream::get_base_url() . 'uid=' . scrub_out($this->user) . '&type=playlist&playlist_type=' . scrub_out($type));\n\n            return false;\n        }\n\n        if (isset($ext)) {\n            header('Cache-control: public');\n            header('Content-Disposition: filename=ampache_playlist.' . $ext);\n            header('Content-Type: ' . $ctype . ';');\n        }\n\n        $this->{'create_' . $type}();\n\n        return true;\n    }\n\n    /**\n     * add\n     * Adds an array of media\n     * @param array $media\n     * @param string $additional_params\n     */\n    public function add($media = array(), $additional_params = '')\n    {\n        $urls = self::media_to_urlarray($media, $additional_params);\n        $this->_add_urls($urls);\n    }\n\n    /**\n     * add_urls\n     * Add an array of urls. This is used for things that aren't coming\n     * from media objects like democratic playlists\n     * @param array $urls\n     * @return boolean\n     */\n    public function add_urls($urls = array())\n    {\n        if (!is_array($urls)) {\n            return false;\n        }\n\n        foreach ($urls as $url) {\n            $this->_add_url(new Stream_Url(array(\n                'url' => $url,\n                'title' => Stream_Url::get_title($url),\n                'author' => T_('Ampache'),\n                'time' => '-1'\n            )));\n        }\n\n        return true;\n    }\n\n    /**\n     * create_simplem3u\n     * this creates a simple m3u without any of the extended information\n     */\n    public function create_simple_m3u()\n    {\n        foreach ($this->urls as $url) {\n            echo $url->url . \"\\n\";\n        }\n    } // simple_m3u\n\n    /**\n     * get_m3u_string\n     * creates an m3u file, this includes the EXTINFO and as such can be\n     * large with very long playlists\n     * @return string\n     */\n    public function get_m3u_string()\n    {\n        $ret = \"#EXTM3U\\n\";\n\n        $count = 0;\n        foreach ($this->urls as $url) {\n            $ret .= '#EXTINF:' . $url->time . ', ' . $url->author . ' - ' . $url->title . \"\\n\";\n            $ret .= $url->url . \"\\n\";\n            $count++;\n        }\n\n        return $ret;\n    } // get_m3u_string\n\n    public function create_m3u()\n    {\n        echo $this->get_m3u_string();\n    }\n\n    /**\n     * get_pls_string\n     * @return string\n     */\n    public function get_pls_string()\n    {\n        $ret = \"[playlist]\\n\";\n        $ret .= 'NumberOfEntries=' . count($this->urls) . \"\\n\";\n        $count = 0;\n        foreach ($this->urls as $url) {\n            $count++;\n            $ret .= 'File' . $count . '=' . $url->url . \"\\n\";\n            $ret .= 'Title' . $count . '=' . $url->author . ' - ' . $url->title . \"\\n\";\n            $ret .= 'Length' . $count . '=' . $url->time . \"\\n\";\n        }\n\n        $ret .= \"Version=2\\n\";\n\n        return $ret;\n    } // get_pls_string\n\n    public function create_pls()\n    {\n        echo $this->get_pls_string();\n    }\n\n    /**\n     * get_asx_string\n     * This should really only be used if all of the content is ASF files.\n     * @return string\n     */\n    public function get_asx_string()\n    {\n        $ret = '<ASX VERSION=\"3.0\" BANNERBAR=\"auto\">' . \"\\n\";\n        $ret .= \"<TITLE>\" . ($this->title ?: T_(\"Ampache ASX Playlist\")) . \"</TITLE>\\n\";\n        $ret .= '<PARAM NAME=\"Encoding\" VALUE=\"utf-8\"' . \"></PARAM>\\n\";\n\n        foreach ($this->urls as $url) {\n            $ret .= \"<ENTRY>\\n\";\n            $ret .= '<TITLE>' . scrub_out($url->title) . \"</TITLE>\\n\";\n            $ret .= '<AUTHOR>' . scrub_out($url->author) . \"</AUTHOR>\\n\";\n            // FIXME: duration looks hacky and wrong\n            $ret .= \"\\t\\t\" . '<DURATION VALUE=\"00:00:' . $url->time . '\" />' . \"\\n\";\n            $ret .= \"\\t\\t\" . '<PARAM NAME=\"Album\" Value=\"' . scrub_out($url->album) . '\" />' . \"\\n\";\n            $ret .= \"\\t\\t\" . '<PARAM NAME=\"Composer\" Value=\"' . scrub_out($url->author) . '\" />' . \"\\n\";\n            $ret .= \"\\t\\t\" . '<PARAM NAME=\"Prebuffer\" Value=\"false\" />' . \"\\n\";\n            $ret .= '<REF HREF=\"' . $url->url . '\" />' . \"\\n\";\n            $ret .= \"</ENTRY>\\n\";\n        }\n\n        $ret .= \"</ASX>\\n\";\n\n        return $ret;\n    } // get_asx_string\n\n    public function create_asx()\n    {\n        echo $this->get_asx_string();\n    }\n\n    /**\n     * get_xspf_string\n     * @return string\n     */\n    public function get_xspf_string()\n    {\n        $result = \"\";\n        foreach ($this->urls as $url) {\n            $xml = array();\n\n            $xml['track'] = array(\n                'title' => $url->title,\n                'creator' => $url->author,\n                'duration' => $url->time * 1000,\n                'location' => $url->url,\n                'identifier' => $url->url\n            );\n            if ($url->type == 'video') {\n                $xml['track']['meta'] = array(\n                    'attribute' => 'rel=\"provider\"',\n                    'value' => 'video'\n                );\n            }\n            if ($url->info_url) {\n                $xml['track']['info'] = $url->info_url;\n            }\n            if ($url->image_url) {\n                $xml['track']['image'] = $url->image_url;\n            }\n            if ($url->album) {\n                $xml['track']['album'] = $url->album;\n            }\n            if ($url->track_num) {\n                $xml['track']['trackNum'] = $url->track_num;\n            }\n\n            $result .= Xml_Data::keyed_array($xml, true);\n        } // end foreach\n\n        Xml_Data::set_type('xspf');\n        $ret = Xml_Data::header($this->title);\n        $ret .= $result;\n        $ret .= Xml_Data::footer();\n\n        return $ret;\n    } // get_xspf_string\n\n    public function create_xspf()\n    {\n        echo $this->get_xspf_string();\n    }\n\n    /**\n     * get_hls_string\n     * @return string\n     */\n    public function get_hls_string()\n    {\n        $ssize = 10;\n        $ret   = \"#EXTM3U\\n\";\n        $ret .= \"#EXT-X-TARGETDURATION:\" . $ssize . \"\\n\";\n        $ret .= \"#EXT-X-VERSION:1\\n\";\n        $ret .= \"#EXT-X-ALLOW-CACHE:NO\\n\";\n        $ret .= \"#EXT-X-MEDIA-SEQUENCE:0\\n\";\n        $ret .= \"#EXT-X-PLAYLIST-TYPE:VOD\\n\"; // Static list of segments\n\n        foreach ($this->urls as $url) {\n            $soffset = 0;\n            $segment = 0;\n            while ($soffset < $url->time) {\n                $type              = $url->type;\n                $size              = (($soffset + $ssize) <= $url->time) ? $ssize : ($url->time - $soffset);\n                $additional_params = '&transcode_to=ts&segment=' . $segment;\n                $ret .= \"#EXTINF:\" . $size . \",\\n\";\n                $url_data = Stream_Url::parse($url->url);\n                $id       = $url_data['id'];\n\n                unset($url_data['id']);\n                unset($url_data['ssid']);\n                unset($url_data['type']);\n                unset($url_data['base_url']);\n                unset($url_data['uid']);\n                unset($url_data['name']);\n\n                foreach ($url_data as $key => $value) {\n                    $additional_params .= '&' . $key . '=' . $value;\n                }\n\n                $className = ObjectTypeToClassNameMapper::map($type);\n\n                $item = new $className($id);\n                $hu   = $item->play_url($additional_params);\n                $ret .= $hu . \"\\n\";\n                $soffset += $size;\n                $segment++;\n            }\n        }\n\n        $ret .= \"#EXT-X-ENDLIST\\n\\n\";\n\n        return $ret;\n    }\n\n    public function create_hls()\n    {\n        echo $this->get_hls_string();\n    }\n\n    /**\n     * create_web_player\n     *\n     * Creates an web player.\n     */\n    public function create_web_player()\n    {\n        if (AmpConfig::get(\"ajax_load\")) {\n            require Ui::find_template('create_web_player_embedded.inc.php');\n        } else {\n            require Ui::find_template('create_web_player.inc.php');\n        }\n    }  // create_web_player\n\n    /**\n     * show_web_player\n     *\n     * Show the created web player for ajax page loading.\n     * Browsers block autoplay when you haven't interacted with the page so load it early.\n     */\n    public function show_web_player()\n    {\n        if (AmpConfig::get(\"ajax_load\")) {\n            require Ui::find_template('show_web_player_embedded.inc.php');\n        }\n    }  // show_web_player\n\n    /**\n     * create_localplay\n     * This calls the Localplay API to add the URLs and then start playback\n     */\n    public function create_localplay()\n    {\n        $localplay = new LocalPlay(AmpConfig::get('localplay_controller'));\n        $localplay->connect();\n        $append = $_REQUEST['append'] ?? false;\n        if (!$append) {\n            $localplay->delete_all();\n        }\n        foreach ($this->urls as $url) {\n            $localplay->add_url($url);\n        }\n        if (!$append) {\n            // We don't have metadata on Stream_URL to know its kind\n            // so we check the content to know if it is democratic\n            if (count($this->urls) == 1) {\n                $furl = $this->urls[0];\n                if (strpos($furl->url, \"&demo_id=1\") !== false && $furl->time == -1) {\n                    // If democratic, repeat the song to get the next voted one.\n                    debug_event(self::class, 'Playing democratic on Localplay, enabling repeat...', 5);\n                    $localplay->repeat(true);\n                }\n            }\n            $localplay->play();\n        }\n    } // create_localplay\n\n    /**\n     * create_democratic\n     *\n     * This 'votes' on the songs; it inserts them into a tmp_playlist with user\n     * set to -1.\n     */\n    public function create_democratic()\n    {\n        $democratic = Democratic::get_current_playlist();\n        $democratic->set_parent();\n        $items = array();\n\n        foreach ($this->urls as $url) {\n            $url_data = Stream_Url::parse($url->url);\n            $items[]  = array($url_data['type'], $url_data['id']);\n        }\n        if (!empty($items)) {\n            $democratic->add_vote($items);\n            display_notification(T_('Vote added'));\n        }\n    }\n\n    /**\n     * create_download\n     * This prompts for a download of the song\n     */\n    private function create_download()\n    {\n        // There should only be one here...\n        if (count($this->urls) != 1) {\n            debug_event(self::class, 'Download called, but $urls contains ' . json_encode($this->urls), 2);\n        }\n\n        // Header redirect baby!\n        $url = current($this->urls);\n        $url = Stream_Url::add_options($url->url, '&action=download&cache=1');\n        header('Location: ' . $url);\n\n        return false;\n    } // create_download\n\n    /**\n     * create_ram\n     *this functions creates a RAM file for use by Real Player\n     */\n    public function create_ram()\n    {\n        foreach ($this->urls as $url) {\n            echo $url->url . \"\\n\";\n        }\n    } // create_ram\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\System;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Catalog;\nuse Ampache\\Repository\\Model\\Preference;\nuse Ampache\\Repository\\Model\\User;\n\n/**\n * Update Class\n *\n * This class mainly handles schema updates for the database.\n * Versions are a monotonically increasing integer: First column(s) are the\n * major version, followed by a single column for the minor version and four\n * columns for the build number. 3.6 build 1 is 360000; 10.9 build 17 is\n * 1090017.\n */\nclass Update\n{\n    public $key;\n    public $value;\n    public static $versions; // array containing version information\n\n    /**\n     * get_version\n     *\n     * This checks to see what version you are currently running.\n     * Because we may not have the update_info table we have to check\n     * for its existence first.\n     * @return string\n     */\n    public static function get_version()\n    {\n        $version = \"\";\n        /* Make sure that update_info exits */\n        $sql        = \"SHOW TABLES LIKE 'update_info'\";\n        $db_results = Dba::read($sql);\n        if (!Dba::dbh()) {\n            header(\"Location: test.php\");\n        }\n\n        // If no table\n        if (!Dba::num_rows($db_results)) {\n            // They can't upgrade, they are too old\n            header(\"Location: test.php\");\n        } else {\n            // If we've found the update_info table, let's get the version from it\n            $sql        = \"SELECT `key`, `value` FROM `update_info` WHERE `key`='db_version'\";\n            $db_results = Dba::read($sql);\n            $results    = Dba::fetch_assoc($db_results);\n            $version    = $results['value'];\n        }\n\n        return $version;\n    } // get_version\n\n    /**\n     * check_tables\n     *\n     * is something missing? why is it missing!?\n     * @param bool $execute\n     * @return array\n     */\n    public static function check_tables(bool $execute = false)\n    {\n        $db_version = (int)self::get_version();\n        $missing    = array();\n        $collation  = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset    = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine     = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        $tables     = array(\n            'image' => \"CREATE TABLE IF NOT EXISTS `image` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `image` mediumblob DEFAULT NULL, `width` int(4) UNSIGNED DEFAULT 0, `height` int(4) UNSIGNED DEFAULT 0, `mime` varchar(64) COLLATE $collation DEFAULT NULL, `size` varchar(64) COLLATE $collation DEFAULT NULL, `object_type` varchar(64) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL, `kind` varchar(32) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`), KEY `object_type` (`object_type`), KEY `object_id` (`object_id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'tmp_browse' => \"CREATE TABLE IF NOT EXISTS `tmp_browse` ( `id` int(13) NOT NULL AUTO_INCREMENT, `sid` varchar(128) COLLATE $collation NOT NULL, `data` longtext COLLATE $collation NOT NULL, `object_data` longtext COLLATE $collation DEFAULT NULL, PRIMARY KEY (`sid`,`id`)) ENGINE=MyISAM DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'share' => \"CREATE TABLE IF NOT EXISTS `share` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) UNSIGNED NOT NULL, `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL, `allow_stream` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `allow_download` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `expire_days` int(4) UNSIGNED NOT NULL DEFAULT 0, `max_counter` int(4) UNSIGNED NOT NULL DEFAULT 0, `secret` varchar(20) COLLATE $collation DEFAULT NULL, `counter` int(4) UNSIGNED NOT NULL DEFAULT 0, `creation_date` int(11) UNSIGNED NOT NULL DEFAULT 0, `lastvisit_date` int(11) UNSIGNED NOT NULL DEFAULT 0, `public_url` varchar(255) COLLATE $collation DEFAULT NULL, `description` varchar(255) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'broadcast' => \"CREATE TABLE IF NOT EXISTS `broadcast` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) UNSIGNED NOT NULL, `name` varchar(64) COLLATE $collation DEFAULT NULL, `description` varchar(256) COLLATE $collation DEFAULT NULL, `is_private` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `song` int(11) UNSIGNED NOT NULL DEFAULT 0, `started` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `listeners` int(11) UNSIGNED NOT NULL DEFAULT 0, `key` varchar(32) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'player_control' => \"CREATE TABLE IF NOT EXISTS `player_control` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) UNSIGNED NOT NULL, `cmd` varchar(32) COLLATE $collation DEFAULT NULL, `value` varchar(256) COLLATE $collation DEFAULT NULL, `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL, `send_date` int(11) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'recommendation' => \"CREATE TABLE IF NOT EXISTS `recommendation` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL, `last_update` int(11) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'recommendation_item' => \"CREATE TABLE IF NOT EXISTS `recommendation_item` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `recommendation` int(11) UNSIGNED NOT NULL, `recommendation_id` int(11) UNSIGNED DEFAULT NULL, `name` varchar(256) COLLATE $collation DEFAULT NULL, `rel` varchar(256) COLLATE $collation DEFAULT NULL, `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'license' => \"CREATE TABLE IF NOT EXISTS `license` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(80) COLLATE $collation DEFAULT NULL, `description` varchar(256) COLLATE $collation DEFAULT NULL, `external_link` varchar(256) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine AUTO_INCREMENT=15 DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'daap_session' => \"CREATE TABLE IF NOT EXISTS `daap_session` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `creationdate` int(11) UNSIGNED NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'tvshow' => \"CREATE TABLE IF NOT EXISTS `tvshow` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(80) COLLATE $collation DEFAULT NULL, `summary` varchar(256) COLLATE $collation DEFAULT NULL, `year` int(11) UNSIGNED DEFAULT NULL, `prefix` varchar(32) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'tvshow_season' => \"CREATE TABLE IF NOT EXISTS `tvshow_season` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `season_number` int(11) UNSIGNED NOT NULL, `tvshow` int(11) UNSIGNED NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'tvshow_episode' => \"CREATE TABLE IF NOT EXISTS `tvshow_episode` ( `id` int(11) UNSIGNED NOT NULL, `original_name` varchar(80) COLLATE $collation DEFAULT NULL, `season` int(11) UNSIGNED NOT NULL, `episode_number` int(11) UNSIGNED NOT NULL, `summary` varchar(256) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'movie' => \"CREATE TABLE IF NOT EXISTS `movie` ( `id` int(11) UNSIGNED NOT NULL, `original_name` varchar(80) COLLATE $collation DEFAULT NULL, `summary` varchar(256) COLLATE $collation DEFAULT NULL, `year` int(11) UNSIGNED DEFAULT NULL, `prefix` varchar(32) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'personal_video' => \"CREATE TABLE IF NOT EXISTS `personal_video` ( `id` int(11) UNSIGNED NOT NULL, `location` varchar(256) COLLATE $collation DEFAULT NULL, `summary` varchar(256) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'clip' => \"CREATE TABLE IF NOT EXISTS `clip` ( `id` int(11) UNSIGNED NOT NULL, `artist` int(11) DEFAULT NULL, `song` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'tag_merge' => \"CREATE TABLE IF NOT EXISTS `tag_merge` ( `tag_id` int(11) NOT NULL, `merged_to` int(11) NOT NULL, PRIMARY KEY (`tag_id`,`merged_to`), KEY `merged_to` (`merged_to`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'label' => \"CREATE TABLE IF NOT EXISTS `label` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(80) COLLATE $collation DEFAULT NULL, `category` varchar(40) COLLATE $collation DEFAULT NULL, `summary` text COLLATE $collation DEFAULT NULL, `address` varchar(256) COLLATE $collation DEFAULT NULL, `email` varchar(128) COLLATE $collation DEFAULT NULL, `website` varchar(256) COLLATE $collation DEFAULT NULL, `user` int(11) UNSIGNED DEFAULT NULL, `creation_date` int(11) UNSIGNED DEFAULT NULL, `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `country` varchar(64) COLLATE $collation DEFAULT NULL, `active` tinyint(1) UNSIGNED NOT NULL DEFAULT 1, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'label_asso' => \"CREATE TABLE IF NOT EXISTS `label_asso` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `label` int(11) UNSIGNED NOT NULL, `artist` int(11) UNSIGNED NOT NULL, `creation_date` int(11) UNSIGNED DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'user_pvmsg' => \"CREATE TABLE IF NOT EXISTS `user_pvmsg` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `subject` varchar(80) COLLATE $collation DEFAULT NULL, `message` text COLLATE $collation DEFAULT NULL, `from_user` int(11) UNSIGNED NOT NULL, `to_user` int(11) UNSIGNED NOT NULL, `is_read` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `creation_date` int(11) UNSIGNED DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'user_follower' => \"CREATE TABLE IF NOT EXISTS `user_follower` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) UNSIGNED NOT NULL, `follow_user` int(11) UNSIGNED NOT NULL, `follow_date` int(11) UNSIGNED DEFAULT NULL, `creation_date` int(11) UNSIGNED DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'metadata_field' => \"CREATE TABLE IF NOT EXISTS `metadata_field` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(255) COLLATE $collation DEFAULT NULL, `public` tinyint(1) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'metadata' => \"CREATE TABLE IF NOT EXISTS `metadata` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `object_id` int(11) UNSIGNED NOT NULL, `field` int(11) UNSIGNED NOT NULL, `data` text COLLATE $collation NOT NULL, `type` varchar(50) COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`), KEY `field` (`field`), KEY `object_id` (`object_id`), KEY `type` (`type`), KEY `objecttype` (`object_id`,`type`), KEY `objectfield` (`object_id`,`field`,`type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'podcast' => \"CREATE TABLE IF NOT EXISTS `podcast` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `feed` varchar(4096) COLLATE $collation DEFAULT NULL, `catalog` int(11) NOT NULL, `title` varchar(255) COLLATE $collation DEFAULT NULL, `website` varchar(255) COLLATE $collation DEFAULT NULL, `description` varchar(4096) COLLATE $collation DEFAULT NULL, `language` varchar(5) COLLATE $collation DEFAULT NULL, `copyright` varchar(255) COLLATE $collation DEFAULT NULL, `generator` varchar(64) COLLATE $collation DEFAULT NULL, `lastbuilddate` int(11) UNSIGNED NOT NULL DEFAULT 0, `lastsync` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0, `episodes` int(11) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'podcast_episode' => \"CREATE TABLE IF NOT EXISTS `podcast_episode` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `title` varchar(255) COLLATE $collation DEFAULT NULL, `guid` varchar(255) COLLATE $collation DEFAULT NULL, `podcast` int(11) NOT NULL, `state` varchar(32) COLLATE $collation DEFAULT NULL, `file` varchar(4096) COLLATE $collation DEFAULT NULL, `source` varchar(4096) COLLATE $collation DEFAULT NULL, `size` bigint(20) UNSIGNED NOT NULL DEFAULT 0, `time` int(11) UNSIGNED NOT NULL DEFAULT 0, `website` varchar(255) COLLATE $collation DEFAULT NULL, `description` varchar(4096) COLLATE $collation DEFAULT NULL, `author` varchar(64) COLLATE $collation DEFAULT NULL, `category` varchar(64) COLLATE $collation DEFAULT NULL, `played` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `pubdate` int(11) UNSIGNED NOT NULL, `addition_time` int(11) UNSIGNED NOT NULL, `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0, `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0, `waveform` mediumblob DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'cache_object_count' => \"CREATE TABLE IF NOT EXISTS `cache_object_count` ( `object_id` int(11) UNSIGNED NOT NULL, `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL, `count` int(11) UNSIGNED NOT NULL DEFAULT 0, `threshold` int(11) UNSIGNED NOT NULL DEFAULT 0, `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL, PRIMARY KEY (`object_id`,`object_type`,`threshold`,`count_type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'cache_object_count_run' => \"CREATE TABLE IF NOT EXISTS `cache_object_count_run` ( `object_id` int(11) UNSIGNED NOT NULL, `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL, `count` int(11) UNSIGNED NOT NULL DEFAULT 0, `threshold` int(11) UNSIGNED NOT NULL DEFAULT 0, `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL, PRIMARY KEY (`object_id`,`object_type`,`threshold`,`count_type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'catalog_map' => \"CREATE TABLE IF NOT EXISTS `catalog_map` ( `catalog_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, UNIQUE KEY `unique_catalog_map` (`object_id`,`object_type`,`catalog_id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'user_playlist' => \"CREATE TABLE IF NOT EXISTS `user_playlist` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) DEFAULT NULL, `object_type` enum('song','live_stream','video','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL DEFAULT 0, `track` smallint(6) DEFAULT NULL, `current_track` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `current_time` smallint(5) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`), KEY `user` (`user`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'user_data' => \"CREATE TABLE IF NOT EXISTS `user_data` ( `user` int(11) DEFAULT NULL, `key` varchar(128) COLLATE $collation DEFAULT NULL, `value` varchar(255) COLLATE $collation DEFAULT NULL, UNIQUE KEY `unique_data` (`user`,`key`), KEY `user` (`user`), KEY `key` (`key`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'deleted_song' => \"CREATE TABLE IF NOT EXISTS `deleted_song` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED DEFAULT 0, `delete_time` int(11) UNSIGNED DEFAULT 0, `title` varchar(255) COLLATE $collation DEFAULT NULL, `file` varchar(4096) COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0, `update_time` int(11) UNSIGNED DEFAULT 0, `album` int(11) UNSIGNED NOT NULL DEFAULT 0, `artist` int(11) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'deleted_video' => \"CREATE TABLE IF NOT EXISTS `deleted_video` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED NOT NULL, `delete_time` int(11) UNSIGNED NOT NULL, `title` varchar(255) COLLATE $collation DEFAULT NULL, `file` varchar(4096) COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL, `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'deleted_podcast_episode' => \"CREATE TABLE IF NOT EXISTS `deleted_podcast_episode` ( `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED NOT NULL, `delete_time` int(11) UNSIGNED NOT NULL, `title` varchar(255) COLLATE $collation DEFAULT NULL, `file` varchar(4096) COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL, `total_count` int(11) UNSIGNED NOT NULL DEFAULT 0, `total_skip` int(11) UNSIGNED NOT NULL DEFAULT 0, `podcast` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\",\n            'artist_map' => \"CREATE TABLE IF NOT EXISTS `artist_map` ( `artist_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) COLLATE utf8_unicode_ci DEFAULT NULL, UNIQUE KEY `unique_artist_map` (`object_id`,`object_type`,`artist_id`), KEY `object_id_index` (`object_id`), KEY `artist_id_index` (`artist_id`), KEY `artist_id_type_index` (`artist_id`,`object_type`), KEY `object_id_type_index` (`object_id`,`object_type`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\",\n            'album_map' => \"CREATE TABLE IF NOT EXISTS `album_map` ( `album_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) COLLATE utf8_unicode_ci DEFAULT NULL, UNIQUE KEY `unique_album_map` (`object_id`,`object_type`,`album_id`), KEY `object_id_index` (`object_id`), KEY `album_id_type_index` (`album_id`,`object_type`), KEY `object_id_type_index` (`object_id`,`object_type`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\",\n            'catalog_filter_group' => \"CREATE TABLE IF NOT EXISTS `catalog_filter_group` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;INSERT IGNORE INTO `catalog_filter_group` (`name`) VALUES ('DEFAULT'); UPDATE `catalog_filter_group` SET `id` = 0 WHERE `name` = 'DEFAULT'; ALTER TABLE `catalog_filter_group` AUTO_INCREMENT = 1;\",\n            'catalog_filter_group_map' => \"CREATE TABLE IF NOT EXISTS `catalog_filter_group_map` (`group_id` int(11) UNSIGNED NOT NULL, `catalog_id` int(11) UNSIGNED NOT NULL, `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, UNIQUE KEY (group_id,catalog_id)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\"\n        );\n        $versions   = array(\n            'image' => 360003,\n            'tmp_browse' => 360005,\n            'share' => 360037,\n            'broadcast' => 360042,\n            'player_control' => 360042,\n            'recommendation' => 360044,\n            'recommendation_item' => 360044,\n            'license' => 370004,\n            'daap_session' => 370007,\n            'tvshow' => 370009,\n            'tvshow_season' => 370009,\n            'tvshow_episode' => 370009,\n            'movie' => 370009,\n            'personal_video' => 370009,\n            'clip' => 370009,\n            'tag_merge' => 370018,\n            'label' => 370033,\n            'label_asso' => 370033,\n            'user_pvmsg' => 370034,\n            'user_follower' => 370034,\n            'metadata_field' => 370041,\n            'metadata' => 370041,\n            'podcast' => 380001,\n            'podcast_episode' => 380001,\n            'cache_object_count' => 400008,\n            'cache_object_count_run' => 400008,\n            'catalog_map' => 500004,\n            'user_playlist' => 500006,\n            'user_data' => 500006,\n            'deleted_song' => 500013,\n            'deleted_video' => 500013,\n            'deleted_podcast_episode' => 500013,\n            'artist_map' => 530000,\n            'album_map' => 530001,\n            'catalog_filter_group' => 550001,\n            'catalog_filter_group_map' => 550001\n        );\n        foreach ($tables as $table_name => $table_sql) {\n            $sql        = \"DESCRIBE `$table_name`;\";\n            $db_results = Dba::read($sql);\n            // you might not be at the version required for this table so make sure it actually is missing.\n            if (!$db_results && $db_version >= $versions[$table_name]) {\n                $missing[] = $table_name;\n                if (!$execute) {\n                    debug_event(__CLASS__, 'MISSING TABLE: ' . $table_name, 1);\n                    continue;\n                }\n                if (Dba::write($table_sql)) {\n                    debug_event(__CLASS__, 'CREATED MISSING TABLE: ' . $table_name, 1);\n                }\n            }\n        }\n\n        return $missing;\n    }\n\n    /**\n     * format_version\n     *\n     * Make the version number pretty.\n     * @param string $data\n     * @return string\n     */\n    public static function format_version($data)\n    {\n        return substr($data, 0, strlen((string)$data) - 5) . '.' . substr($data, strlen((string)$data) - 5, 1) . ' Build:' . substr($data, strlen((string)$data) - 4, strlen((string)$data));\n    }\n\n    /**\n     * need_update\n     *\n     * Checks to see if we need to update ampache at all.\n     */\n    public static function need_update(): bool\n    {\n        $current_version = self::get_version();\n\n        if (!is_array(self::$versions)) {\n            self::$versions = self::populate_version();\n        }\n\n        // Iterate through the versions and see if we need to apply any updates\n        foreach (self::$versions as $update) {\n            if ($update['version'] > $current_version) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * populate_version\n     * just sets an array the current differences\n     * that require an update\n     * @return array\n     */\n    public static function populate_version()\n    {\n        /* Define the array */\n        $version = array();\n\n        $update_string = \"* Add MBID (MusicBrainz ID) fields<br />* Remove useless preferences<br />\";\n        $version[]     = array('version' => '360001', 'description' => $update_string);\n\n        $update_string = \"* Add Bandwidth and Feature preferences to simplify how interface is presented<br />* Change Tables to FULLTEXT() for improved searching<br />* Increase Filename lengths to 4096<br />* Remove useless KEY reference from ACL and Catalog tables<br />* Add new Remote User / Remote Password fields to Catalog<br />\";\n        $version[]     = array('version' => '360002', 'description' => $update_string);\n\n        $update_string = \"* Add image table to store images.<br />* Drop album_data and artist_data.<br />\";\n        $version[]     = array('version' => '360003', 'description' => $update_string);\n\n        $update_string = \"* Add uniqueness constraint to ratings.<br />\";\n        $version[]     = array('version' => '360004', 'description' => $update_string);\n\n        $update_string = \"* Modify tmp_browse to allow caching of multiple browses per session.<br />\";\n        $version[]     = array('version' => '360005', 'description' => $update_string);\n\n        $update_string = \"* Add table for dynamic playlists.<br />\";\n        $version[]     = array('version' => '360006', 'description' => $update_string);\n\n        $update_string = \"* Verify remote_username and remote_password were added correctly to catalog table.<br />\";\n        $version[]     = array('version' => '360008', 'description' => $update_string);\n\n        $update_string = \"* Allow long sessionids in tmp_playlist table.<br />\";\n        $version[]     = array('version' => '360009', 'description' => $update_string);\n\n        $update_string = \"* Allow compound MBIDs in the artist table.<br />\";\n        $version[]     = array('version' => '360010', 'description' => $update_string);\n\n        $update_string = \"* Add table to store stream session playlist.<br />\";\n        $version[]     = array('version' => '360011', 'description' => $update_string);\n\n        $update_string = \"* Drop enum for the type field in session.<br />\";\n        $version[]     = array('version' => '360012', 'description' => $update_string);\n\n        $update_string = \"* Update stream_playlist table to address performance issues.<br />\";\n        $version[]     = array('version' => '360013', 'description' => $update_string);\n\n        $update_string = \"* Increase the length of sessionids again.<br />\";\n        $version[]     = array('version' => '360014', 'description' => $update_string);\n\n        $update_string = \"* Add iframes parameter to preferences.<br />\";\n        $version[]     = array('version' => '360015', 'description' => $update_string);\n\n        $update_string = \"* Optionally filter Now Playing to return only the last song per user.<br />\";\n        $version[]     = array('version' => '360016', 'description' => $update_string);\n\n        $update_string = \"* Add user flags on objects.<br />\";\n        $version[]     = array('version' => '360017', 'description' => $update_string);\n\n        $update_string = \"* Add album default sort value to preferences.<br />\";\n        $version[]     = array('version' => '360018', 'description' => $update_string);\n\n        $update_string = \"* Add option to show number of times a song was played.<br />\";\n        $version[]     = array('version' => '360019', 'description' => $update_string);\n\n        $update_string = \"* Catalog types are plugins now.<br />\";\n        $version[]     = array('version' => '360020', 'description' => $update_string);\n\n        $update_string = \"* Add insertion date on Now Playing and option to show the current song in page title for Web player.<br />\";\n        $version[]     = array('version' => '360021', 'description' => $update_string);\n\n        $update_string = \"* Remove unused live_stream fields and add codec field.<br />\";\n        $version[]     = array('version' => '360022', 'description' => $update_string);\n\n        $update_string = \"* Enable/Disable SubSonic and Plex backend.<br />\";\n        $version[]     = array('version' => '360023', 'description' => $update_string);\n\n        $update_string = \"* Drop flagged table.<br />\";\n        $version[]     = array('version' => '360024', 'description' => $update_string);\n\n        $update_string = \"* Add options to enable HTML5 / Flash on web players.<br />\";\n        $version[]     = array('version' => '360025', 'description' => $update_string);\n\n        $update_string = \"* Added agent to `object_count` table.<br />\";\n        $version[]     = array('version' => '360026', 'description' => $update_string);\n\n        $update_string = \"* Add option to allow/disallow to show personnal information to other users (now playing and recently played).<br />\";\n        $version[]     = array('version' => '360027', 'description' => $update_string);\n\n        $update_string = \"* Personnal information: allow/disallow to show in now playing.<br />* Personnal information: allow/disallow to show in recently played.<br />* Personnal information: allow/disallow to show time and/or agent in recently played.<br />\";\n        $version[]     = array('version' => '360028', 'description' => $update_string);\n\n        $update_string = \"* Add new table to store wanted releases.<br />\";\n        $version[]     = array('version' => '360029', 'description' => $update_string);\n\n        $update_string = \"* New table to store song previews.<br />\";\n        $version[]     = array('version' => '360030', 'description' => $update_string);\n\n        $update_string = \"* Add option to fix header position on compatible themes.<br />\";\n        $version[]     = array('version' => '360031', 'description' => $update_string);\n\n        $update_string = \"* Add check update automatically option.<br />\";\n        $version[]     = array('version' => '360032', 'description' => $update_string);\n\n        $update_string = \"* Add song waveform as song data.<br />\";\n        $version[]     = array('version' => '360033', 'description' => $update_string);\n\n        $update_string = \"* Add settings for confirmation when closing window and auto-pause between tabs.<br />\";\n        $version[]     = array('version' => '360034', 'description' => $update_string);\n\n        $update_string = \"* Add beautiful stream url setting.<br />\";\n        $version[]     = array('version' => '360035', 'description' => $update_string);\n\n        $update_string = \"* Remove unused parameters.<br />\";\n        $version[]     = array('version' => '360036', 'description' => $update_string);\n\n        $update_string = \"* Add sharing features.<br />\";\n        $version[]     = array('version' => '360037', 'description' => $update_string);\n\n        $update_string = \"* Add missing albums browse on missing artists.<br />\";\n        $version[]     = array('version' => '360038', 'description' => $update_string);\n\n        $update_string = \"* Add website field on users.<br />\";\n        $version[]     = array('version' => '360039', 'description' => $update_string);\n\n        $update_string = \"* Add channels.<br />\";\n        $version[]     = array('version' => '360041', 'description' => $update_string);\n\n        $update_string = \"* Add broadcasts and player control.<br />\";\n        $version[]     = array('version' => '360042', 'description' => $update_string);\n\n        $update_string = \"* Add slideshow on currently played artist preference.<br />\";\n        $version[]     = array('version' => '360043', 'description' => $update_string);\n\n        $update_string = \"* Add artist description/recommendation external service data cache.<br />\";\n        $version[]     = array('version' => '360044', 'description' => $update_string);\n\n        $update_string = \"* Set user field on playlists as optional.<br />\";\n        $version[]     = array('version' => '360045', 'description' => $update_string);\n\n        $update_string = \"* Add broadcast web player by default preference.<br />\";\n        $version[]     = array('version' => '360046', 'description' => $update_string);\n\n        $update_string = \"* Add apikey field on users.<br />\";\n        $version[]     = array('version' => '360047', 'description' => $update_string);\n\n        $update_string = \"* Add concerts options.<br />\";\n        $version[]     = array('version' => '360048', 'description' => $update_string);\n\n        $update_string = \"* Add album group multiple disks setting.<br />\";\n        $version[]     = array('version' => '360049', 'description' => $update_string);\n\n        $update_string = \"* Add top menu setting.<br />\";\n        $version[]     = array('version' => '360050', 'description' => $update_string);\n\n        $update_string = \"* Copy default .htaccess configurations.<br />\";\n        $version[]     = array('version' => '360051', 'description' => $update_string);\n\n        $update_string = \"* Drop unused dynamic_playlist tables and add session id to votes.<br />\";\n        $version[]     = array('version' => '370001', 'description' => $update_string);\n\n        $update_string = \"* Add tag persistent merge reference.<br />\";\n        $version[]     = array('version' => '370002', 'description' => $update_string);\n\n        $update_string = \"* Add show/hide donate button preference.<br />\";\n        $version[]     = array('version' => '370003', 'description' => $update_string);\n\n        $update_string = \"* Add license information and user's artist association.<br />\";\n        $version[]     = array('version' => '370004', 'description' => $update_string);\n\n        $update_string = \"* Add new column album_artist into table song.<br />\";\n        $version[]     = array('version' => '370005', 'description' => $update_string);\n\n        $update_string = \"* Add random and limit options to smart playlists.<br />\";\n        $version[]     = array('version' => '370006', 'description' => $update_string);\n\n        $update_string = \"* Add DAAP backend preference.<br />\";\n        $version[]     = array('version' => '370007', 'description' => $update_string);\n\n        $update_string = \"* Add UPnP backend preference.<br />\";\n        $version[]     = array('version' => '370008', 'description' => $update_string);\n\n        $update_string = \"* Enhance video support with TVShows and Movies.<br />\";\n        $version[]     = array('version' => '370009', 'description' => $update_string);\n\n        $update_string = \"* Add MusicBrainz Album Release Group identifier.<br />\";\n        $version[]     = array('version' => '370010', 'description' => $update_string);\n\n        $update_string = \"* Add Prefix to TVShows and Movies.<br />\";\n        $version[]     = array('version' => '370011', 'description' => $update_string);\n\n        $update_string = \"* Add metadata information to albums / songs / videos.<br />\";\n        $version[]     = array('version' => '370012', 'description' => $update_string);\n\n        $update_string = \"* Replace iframe with ajax page load.<br />\";\n        $version[]     = array('version' => '370013', 'description' => $update_string);\n\n        $update_string = \"* Modified release_date in video table to signed int.<br />\";\n        $version[]     = array('version' => '370014', 'description' => $update_string);\n\n        $update_string = \"* Add session_remember table to store remember tokens.<br />\";\n        $version[]     = array('version' => '370015', 'description' => $update_string);\n\n        $update_string = \"* Add limit of media count for direct play preference.<br />\";\n        $version[]     = array('version' => '370016', 'description' => $update_string);\n\n        $update_string = \"* Add home display settings.<br />\";\n        $version[]     = array('version' => '370017', 'description' => $update_string);\n\n        $update_string = \"* Enhance tag persistent merge reference.<br />\";\n        $version[]     = array('version' => '370018', 'description' => $update_string);\n\n        $update_string = \"* Add album group order setting.<br />\";\n        $version[]     = array('version' => '370019', 'description' => $update_string);\n\n        $update_string = \"* Add webplayer browser notification settings.<br />\";\n        $version[]     = array('version' => '370020', 'description' => $update_string);\n\n        $update_string = \"* Add rating to playlists, tvshows and tvshows seasons.<br />\";\n        $version[]     = array('version' => '370021', 'description' => $update_string);\n\n        $update_string = \"* Add users geolocation.<br />\";\n        $version[]     = array('version' => '370022', 'description' => $update_string);\n\n        $update_string = \"* Add Aurora.js webplayer option.<br />\";\n        $version[]     = array('version' => '370023', 'description' => $update_string);\n\n        $update_string = \"* Add count_type column to object_count table.<br />\";\n        $version[]     = array('version' => '370024', 'description' => $update_string);\n\n        $update_string = \"* Add state and city fields to user table.<br />\";\n        $version[]     = array('version' => '370025', 'description' => $update_string);\n\n        $update_string = \"* Add replay gain fields to song_data table.<br />\";\n        $version[]     = array('version' => '370026', 'description' => $update_string);\n\n        $update_string = \"* Move column album_artist from table song to table album.<br />\";\n        $version[]     = array('version' => '370027', 'description' => $update_string);\n\n        $update_string = \"* Add width and height in table image.<br />\";\n        $version[]     = array('version' => '370028', 'description' => $update_string);\n\n        $update_string = \"* Set image column from image table as nullable.<br />\";\n        $version[]     = array('version' => '370029', 'description' => $update_string);\n\n        $update_string = \"* Add an option to allow users to remove uploaded songs.<br />\";\n        $version[]     = array('version' => '370030', 'description' => $update_string);\n\n        $update_string = \"* Add an option to customize login art, favicon and text footer.<br />\";\n        $version[]     = array('version' => '370031', 'description' => $update_string);\n\n        $update_string = \"* Add WebDAV backend preference.<br />\";\n        $version[]     = array('version' => '370032', 'description' => $update_string);\n\n        $update_string = \"* Add Label tables.<br />\";\n        $version[]     = array('version' => '370033', 'description' => $update_string);\n\n        $update_string = \"* Add User messages and user follow tables.<br />\";\n        $version[]     = array('version' => '370034', 'description' => $update_string);\n\n        $update_string = \"* Add option on user fullname to show/hide it publicly.<br />\";\n        $version[]     = array('version' => '370035', 'description' => $update_string);\n\n        $update_string = \"* Add track number field to stream_playlist table.<br />\";\n        $version[]     = array('version' => '370036', 'description' => $update_string);\n\n        $update_string = \"* Delete http_port preference (use ampache.cfg.php configuration instead).<br />\";\n        $version[]     = array('version' => '370037', 'description' => $update_string);\n\n        $update_string = \"* Add theme color option.<br />\";\n        $version[]     = array('version' => '370038', 'description' => $update_string);\n\n        $update_string = \"* Renamed false named sample_rate option name in preference table.<br />\";\n        $version[]     = array('version' => '370039', 'description' => $update_string);\n\n        $update_string = \"* Add user_activity table.<br />\";\n        $version[]     = array('version' => '370040', 'description' => $update_string);\n\n        $update_string = \"* Add basic metadata tables.<br />\";\n        $version[]     = array('version' => '370041', 'description' => $update_string);\n\n        $update_string = \"* Add podcasts.<br />\";\n        $version[]     = array('version' => '380001', 'description' => $update_string);\n\n        $update_string = \"* Add bookmarks.<br />\";\n        $version[]     = array('version' => '380002', 'description' => $update_string);\n\n        $update_string = \"* Add unique constraint on tag_map table.<br />\";\n        $version[]     = array('version' => '380003', 'description' => $update_string);\n\n        $update_string = \"* Add preference subcategory.<br />\";\n        $version[]     = array('version' => '380004', 'description' => $update_string);\n\n        $update_string = \"* Add manual update flag on artist.<br />\";\n        $version[]     = array('version' => '380005', 'description' => $update_string);\n\n        $update_string = \"* Add library item context menu option.<br />\";\n        $version[]     = array('version' => '380006', 'description' => $update_string);\n\n        $update_string = \"* Add upload rename pattern and ignore duplicate options.<br />\";\n        $version[]     = array('version' => '380007', 'description' => $update_string);\n\n        $update_string = \"* Add browse filter and light sidebar options.<br />\";\n        $version[]     = array('version' => '380008', 'description' => $update_string);\n\n        $update_string = \"* Add update date to playlist.<br />\";\n        $version[]     = array('version' => '380009', 'description' => $update_string);\n\n        $update_string = \"* Add custom blank album/video default image and alphabet browsing options.<br />\";\n        $version[]     = array('version' => '380010', 'description' => $update_string);\n\n        $update_string = \"* Fix username max size to be the same one across all tables.<br />\";\n        $version[]     = array('version' => '380011', 'description' => $update_string);\n\n        $update_string = \"* Fix change in <a href='https://github.com/ampache/ampache/commit/0c26c336269624d75985e46d324e2bc8108576ee'>this commit</a>, that left the userbase with an inconsistent database, if users updated or installed Ampache before 28 Apr 2015<br />\";\n        $version[]     = array('version' => '380012', 'description' => $update_string);\n\n        $update_string = \"* Enable better podcast defaults<br />* Increase copyright column size to fix issue #1861<br />* Add name_track, name_artist, name_album to user_activity<br />* Add mbid_track, mbid_artist, mbid_album to user_activity<br />* Insert some decent SmartLists for a better default experience<br />* Delete plex preferences from the server<br />\";\n        $version[]     = array('version' => '400000', 'description' => $update_string);\n\n        $update_string = \"* Update preferences for older users to match current subcategory items<br /> (~3.6 introduced subcategories but didn't include updates for existing users.<br /> This is a cosmetic update and does not affect any operation)<br />\";\n        $version[]     = array('version' => '400001', 'description' => $update_string);\n\n        $update_string = \"**IMPORTANT UPDATE NOTES**<br /><br /> This is part of a major update to how Ampache handles Albums, Artists and data migration during tag updates.<br /><br />* Update album disk support to allow 1 instead of 0 by default.<br />* Add barcode catalog_number and original_year to albums.<br />* Drop catalog_number from song_data and use album instead.<br />\";\n        $version[]     = array('version' => '400002', 'description' => $update_string);\n\n        $update_string = \"* Make sure preference names are updated to current strings<br />\";\n        $version[]     = array('version' => '400003', 'description' => $update_string);\n\n        $update_string = \"* Delete upload_user_artist database settings<br />\";\n        $version[]     = array('version' => '400004', 'description' => $update_string);\n\n        $update_string = \"* Add a last_count to search table to speed up access requests<br />\";\n        $version[]     = array('version' => '400005', 'description' => $update_string);\n\n        $update_string = \"* Drop shoutcast_active preferences. (Feature has not existed for years)<br />* Drop localplay_shoutcast table if present.<br />\";\n        $version[]     = array('version' => '400006', 'description' => $update_string);\n\n        $update_string = \"* Add ui option for skip_count display.<br />* Add ui option for displaying dates in a custom format.<br />\";\n        $version[]     = array('version' => '400007', 'description' => $update_string);\n\n        $update_string = \"* Add system option for cron based cache and create related tables.<br />\";\n        $version[]     = array('version' => '400008', 'description' => $update_string);\n\n        $update_string = \"* Add ui option for forcing unique items to playlists.<br />\";\n        $version[]     = array('version' => '400009', 'description' => $update_string);\n\n        $update_string = \"* Add a last_duration to search table to speed up access requests<br />\";\n        $version[]     = array('version' => '400010', 'description' => $update_string);\n\n        $update_string = \"**IMPORTANT UPDATE NOTES**<br /><br /> To allow negatives the maximum value of `song`.`track` has been reduced. This shouldn't affect anyone due to the large size allowed.<br /><br />* Allow negative track numbers for albums. (-32,767 -> 32,767)<br />* Truncate database tracks to 0 when greater than 32,767<br />\";\n        $version[]     = array('version' => '400011', 'description' => $update_string);\n\n        $update_string = \"* Add a rss token to allow the use of RSS unauthenticated feeds<br/ >\";\n        $version[]     = array('version' => '400012', 'description' => $update_string);\n\n        $update_string = \"* Extend Democratic cooldown beyond 255.<br/ >\";\n        $version[]     = array('version' => '400013', 'description' => $update_string);\n\n        $update_string = \"* Add last_duration to playlist<br/ > * Add time to artist and album<br/ >\";\n        $version[]     = array('version' => '400014', 'description' => $update_string);\n\n        $update_string = \"* Extend artist time. smallint was too small<br/ > \";\n        $version[]     = array('version' => '400015', 'description' => $update_string);\n\n        $update_string = \"* Extend album and make artist even bigger. This should cover everyone.<br/ > \";\n        $version[]     = array('version' => '400016', 'description' => $update_string);\n\n        $update_string = \"\"; // REMOVED update\n        $version[]     = array('version' => '400017', 'description' => $update_string);\n\n        $update_string = \"* Extend video bitrate to unsigned. There's no reason for a negative bitrate.<br/ > \";\n        $version[]     = array('version' => '400018', 'description' => $update_string);\n\n        $update_string = \"* Put 'of_the_moment' into a per user preference.<br/ > \";\n        $version[]     = array('version' => '400019', 'description' => $update_string);\n\n        $update_string = \"* Customizable login page background.<br/ > \";\n        $version[]     = array('version' => '400020', 'description' => $update_string);\n\n        $update_string = \"* Add r128 gain columns to song_data.<br/ > \";\n        $version[]     = array('version' => '400021', 'description' => $update_string);\n\n        $update_string = \"* Extend allowed time for podcast_episodes.<br/ > \";\n        $version[]     = array('version' => '400022', 'description' => $update_string);\n\n        $update_string = \"* Delete 'concerts_limit_past' and 'concerts_limit_future' database settings.<br/ > \";\n        $version[]     = array('version' => '400023', 'description' => $update_string);\n\n        $update_string = \"**IMPORTANT UPDATE NOTES**<br />These columns will fill dynamically in the web UI but you should do a catalog 'add' as soon as possible to fill them.<br />It will take a while for large libraries but will help API and SubSonic clients.<br /><br />* Add 'song_count', 'album_count' and 'album_group_count' to artist. <br />\";\n        $version[]     = array('version' => '400024', 'description' => $update_string);\n\n        $update_string = \"* Delete duplicate files in the song table<br />\";\n        $version[]     = array('version' => '500000', 'description' => $update_string);\n\n        $update_string = \"* Add `release_status`, `addition_time`, `catalog` to album table<br />* Add `mbid`, `country` and `active` to label table<br />* Fill the album `catalog` value using the song table<br />* Fill the artist `album_count`, `album_group_count` and `song_count` values\";\n        $version[]     = array('version' => '500001', 'description' => $update_string);\n\n        $update_string = \"* Create `total_count` and `total_skip` to album, artist, song, video and podcast_episode tables<br />* Fill counts into the columns\";\n        $version[]     = array('version' => '500002', 'description' => $update_string);\n\n        $update_string = \"* Add `catalog` to podcast_episode table\";\n        $version[]     = array('version' => '500003', 'description' => $update_string);\n\n        $update_string = \"**IMPORTANT UPDATE NOTES**<br />For large catalogs this will be slow!<br />* Create catalog_map table and fill it with data\";\n        $version[]     = array('version' => '500004', 'description' => $update_string);\n\n        $update_string = \"* Add song_count, artist_count to album\";\n        $version[]     = array('version' => '500005', 'description' => $update_string);\n\n        $update_string = \"* Add user_playlist and user_data table\";\n        $version[]     = array('version' => '500006', 'description' => $update_string);\n\n        $update_string = \"* Add a 'Browse' category to interface preferences<br />* Add option ('show_license') for hiding license column in song rows\";\n        $version[]     = array('version' => '500007', 'description' => $update_string);\n\n        $update_string = \"* Add filter_user to catalog table<br />* Set a unique key on user_data\";\n        $version[]     = array('version' => '500008', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('use_original_year') Browse by Original Year for albums (falls back to Year)\";\n        $version[]     = array('version' => '500009', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('hide_single_artist') Hide the Song Artist column for Albums with one Artist\";\n        $version[]     = array('version' => '500010', 'description' => $update_string);\n\n        $update_string = \"* Add `total_count` to podcast table and fill counts into the column\";\n        $version[]     = array('version' => '500011', 'description' => $update_string);\n\n        $update_string = \"* Move user bandwidth calculations out of the user format function into the user_data table\";\n        $version[]     = array('version' => '500012', 'description' => $update_string);\n\n        $update_string = \"* Add tables for tracking deleted files. (deleted_song, deleted_video, deleted_podcast_episode)<br />* Add username to the playlist table to stop pulling user all the time\";\n        $version[]     = array('version' => '500013', 'description' => $update_string);\n\n        $update_string = \"* Add `episodes` to podcast table to track episode count\";\n        $version[]     = array('version' => '500014', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('hide_genres') Hide the Genre column in browse table rows\";\n        $version[]     = array('version' => '500015', 'description' => $update_string);\n\n        $update_string = \"* Add podcast to the object_count table\";\n        $version[]     = array('version' => '510000', 'description' => $update_string);\n\n        $update_string = \"* Add podcast to the cache_object_count tables\";\n        $version[]     = array('version' => '510001', 'description' => $update_string);\n\n        $update_string = \"\"; // REMOVED update\n        $version[]     = array('version' => '510002', 'description' => $update_string);\n\n        $update_string = \"* Add live_stream to the rating table\";\n        $version[]     = array('version' => '510003', 'description' => $update_string);\n\n        $update_string = \"* Add waveform column to podcast_episode table\";\n        $version[]     = array('version' => '510004', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('subsonic_always_download') Force Subsonic streams to download. (Enable scrobble in your client to record stats)\";\n        $version[]     = array('version' => '510005', 'description' => $update_string);\n\n        $update_string = \"* Add ui options ('api_enable_3', 'api_enable_4', 'api_enable_5') to enable/disable specific API versions<br />* Add ui option ('api_force_version') to to force a specific API response (even if that version is disabled)\";\n        $version[]     = array('version' => '520000', 'description' => $update_string);\n\n        $update_string = \"* Make sure preference names are always unique\";\n        $version[]     = array('version' => '520001', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('show_playlist_username') Show playlist owner username in titles\";\n        $version[]     = array('version' => '520002', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('api_hidden_playlists') Hide playlists in Subsonic and API clients that start with this string\";\n        $version[]     = array('version' => '520003', 'description' => $update_string);\n\n        $update_string = \"* Set 'plugins' category to lastfm_challenge preference\";\n        $version[]     = array('version' => '520004', 'description' => $update_string);\n\n        $update_string = \"* Add ui option ('api_hide_dupe_searches') Hide smartlists that match playlist names in Subsonic and API clients\";\n        $version[]     = array('version' => '520005', 'description' => $update_string);\n\n        $update_string = \"**IMPORTANT UPDATE NOTES**<br />For large catalogs this will be slow!<br />* Create artist_map table and fill it with data\";\n        $version[]     = array('version' => '530000', 'description' => $update_string);\n\n        $update_string = \"* Create album_map table and fill it with data\";\n        $version[]     = array('version' => '530001', 'description' => $update_string);\n\n        $update_string = \"* Use song_count & artist_count with album_map\";\n        $version[]     = array('version' => '530002', 'description' => $update_string);\n\n        $update_string = \"* Drop id column from catalog_map table<br />* Alter `catalog_map` object_type charset and collation\";\n        $version[]     = array('version' => '530003', 'description' => $update_string);\n\n        $update_string = \"* Alter `album_map` table charset and engine to MyISAM if engine set\";\n        $version[]     = array('version' => '530004', 'description' => $update_string);\n\n        $update_string = \"* Alter `artist_map` table charset and engine to MyISAM if engine set\";\n        $version[]     = array('version' => '530005', 'description' => $update_string);\n\n        $update_string = \"* Make sure `object_count` table has all the correct primary artist/album rows\";\n        $version[]     = array('version' => '530006', 'description' => $update_string);\n\n        $update_string = \"* Convert basic text columns into utf8 to reduce index sizes\";\n        $version[]     = array('version' => '530007', 'description' => $update_string);\n\n        $update_string = \"* Remove `user_activity` columns that are useless\";\n        $version[]     = array('version' => '530008', 'description' => $update_string);\n\n        $update_string = \"* Compact `object_count` columns\";\n        $version[]     = array('version' => '530009', 'description' => $update_string);\n\n        $update_string = \"* Compact mbid columns back to 36 characters\";\n        $version[]     = array('version' => '530010', 'description' => $update_string);\n\n        $update_string = \"* Compact some `user` columns<br />* enum `object_count`.`count_type`\";\n        $version[]     = array('version' => '530011', 'description' => $update_string);\n\n        $update_string = \"* Index data on object_count\";\n        $version[]     = array('version' => '530012', 'description' => $update_string);\n\n        $update_string = \"* Compact `cache_object_count`, `cache_object_count_run` columns\";\n        $version[]     = array('version' => '530013', 'description' => $update_string);\n\n        $update_string = \"* Delete `object_count` duplicates<br />* Use a smaller unique index on `object_count`\";\n        $version[]     = array('version' => '530014', 'description' => $update_string);\n\n        $update_string = \"* Add `show_album_artist` and `show_artist` preferences to show/hide Sidebar Browse menu links<br />* Fallback to Album Artist if both disabled\";\n        $version[]     = array('version' => '530015', 'description' => $update_string);\n\n        $update_string = \"* Add missing rating item back in the type enum\";\n        $version[]     = array('version' => '530016', 'description' => $update_string);\n\n        $update_string = \"* Index `title` with `enabled` on `song` table to speed up searching\";\n        $version[]     = array('version' => '540000', 'description' => $update_string);\n\n        $update_string = \"* Index `album` table columns.<br />* `catalog`, `album_artist`, `original_year`, `release_type`, `release_status`, `mbid`, `mbid_group`\";\n        $version[]     = array('version' => '540001', 'description' => $update_string);\n\n        $update_string = \"* Index `object_type` with `date` in `object_count` table\";\n        $version[]     = array('version' => '540002', 'description' => $update_string);\n\n        $update_string = \"* Add tables `catalog_filter_group` and `catalog_filter_group_map` for catalog filtering by groups<br />* Add column `catalog_filter_group` to `user` table to assign a filter group\";\n        $version[]     = array('version' => '550001', 'description' => $update_string);\n\n        $update_string = \"* Migrate catalog `filter_user` settings to the `catalog_filter_group` table<br>* Assign all public catalogs to the DEFAULT group<br>* Drop table `user_catalog`<br>* Remove `filter_user` from the `catalog` table<br><br><br>**IMPORTANT UPDATE NOTES** Any user that has a private catalog will have their own filter group created which includes all public catalogs\";\n        $version[]     = array('version' => '550002', 'description' => $update_string);\n\n        $update_string = \"* Add system preference `demo_use_search`, Use smartlists for base playlist in Democratic play\";\n        $version[]     = array('version' => '550003', 'description' => $update_string);\n\n        $update_string = \"* Make `demo_use_search`a system preference correctly\";\n        $version[]     = array('version' => '550004', 'description' => $update_string);\n\n        $update_string = \"* Add `song_artist` and `album_artist` maps to catalog_map\";\n        $version[]     = array('version' => '550005', 'description' => $update_string);\n\n        return $version;\n    }\n\n    /**\n     * display_update\n     * This displays a list of the needed\n     * updates to the database. This will actually\n     * echo out the list...\n     */\n    public static function display_update(): array\n    {\n        $result          = [];\n        $current_version = self::get_version();\n        if (!is_array(self::$versions)) {\n            self::$versions = self::populate_version();\n        }\n\n        foreach (self::$versions as $update) {\n            if ($update['version'] > $current_version) {\n                $result[] = [\n                    'version' => T_('Version') . ': ' . self::format_version($update['version']),\n                    'description' => $update['description']\n                ];\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * run_update\n     * This function actually updates the db.\n     * it goes through versions and finds the ones\n     * that need to be run. Checking to make sure\n     * the function exists first.\n     */\n    public static function run_update(): bool\n    {\n        debug_event(self::class, 'run_update: starting', 4);\n        /* Nuke All Active session before we start the mojo */\n        $sql = \"TRUNCATE session\";\n        Dba::write($sql);\n\n        // Prevent the script from timing out, which could be bad\n        set_time_limit(0);\n\n        $current_version = self::get_version();\n\n        // Run a check to make sure that they don't try to upgrade from a version that won't work.\n        if ($current_version < '350008') {\n            echo '<p class=\"database-update\">Database version too old, please upgrade to <a href=\"https://github.com/ampache/ampache/releases/download/3.8.2/ampache-3.8.2_all.zip\">Ampache-3.8.2</a> first</p>';\n\n            return false;\n        }\n\n        $methods = get_class_methods(Update::class);\n\n        if (!is_array((self::$versions))) {\n            self::$versions = self::populate_version();\n        }\n\n        debug_event(self::class, 'run_update: checking versions', 4);\n        foreach (self::$versions as $version) {\n            // If it's newer than our current version let's see if a function\n            // exists and run the bugger.\n            if ($version['version'] > $current_version) {\n                $update_function = \"update_\" . $version['version'];\n                if (in_array($update_function, $methods)) {\n                    $success = call_user_func(array('Ampache\\Module\\System\\Update', $update_function));\n\n                    // If the update fails drop out\n                    if ($success) {\n                        debug_event(self::class, 'run_update: successfully updated to ' . $version['version'], 3);\n                        self::set_version('db_version', $version['version']);\n                    } else {\n                        echo AmpError::display('update');\n\n                        return false;\n                    }\n                }\n            }\n        } // end foreach version\n\n        // Let's also clean up the preferences unconditionally\n        debug_event(self::class, 'run_update: starting rebuild_all_preferences', 5);\n        User::rebuild_all_preferences();\n        // translate preferences on DB update\n        Preference::translate_db();\n\n        debug_event(self::class, 'run_update: Upgrade complete', 4);\n\n        return true;\n    } // run_update\n\n    /**\n     * set_version\n     *\n     * This updates the 'update_info' which is used by the updater and plugins\n     * @param string $key\n     * @param $value\n     */\n    private static function set_version($key, $value)\n    {\n        $sql = \"UPDATE `update_info` SET `value` = ? WHERE `key` = ?\";\n        Dba::write($sql, array($value, $key));\n    }\n\n    /**\n     * update_360001\n     *\n     * This adds the MB UUIDs to the different tables as well as some additional\n     * cleanup.\n     */\n    public static function update_360001(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `album` ADD `mbid` CHAR (36) AFTER `prefix`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `artist` ADD `mbid` CHAR (36) AFTER `prefix`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song` ADD `mbid` CHAR (36) AFTER `track`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Remove any RIO related information from the database as the plugin has been removed\n        $sql = \"DELETE FROM `update_info` WHERE `key` LIKE 'Plugin_Ri%'\";\n        Dba::write($sql);\n        $sql = \"DELETE FROM `preference` WHERE `name` LIKE 'rio_%'\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_360002\n     *\n     * This update makes changes to the cataloging to accomodate the new method\n     * for syncing between Ampache instances.\n     */\n    public static function update_360002(): bool\n    {\n        $retval = true;\n        // Drop the key from catalog and ACL\n        $sql = \"ALTER TABLE `catalog` DROP `key`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `access_list` DROP `key`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Add in Username / Password for catalog - to be used for remote catalogs\n        $sql = \"ALTER TABLE `catalog` ADD `remote_username` VARCHAR (255) AFTER `catalog_type`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `catalog` ADD `remote_password` VARCHAR (255) AFTER `remote_username`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Adjust the Filename field in song, make it gi-normous. If someone has\n        // anything close to this file length, they seriously need to reconsider\n        // what they are doing.\n        $sql = \"ALTER TABLE `song` CHANGE `file` `file` VARCHAR (4096)\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `video` CHANGE `file` `file` VARCHAR (4096)\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `live_stream` CHANGE `url` `url` VARCHAR (4096)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Index the Artist, Album, and Song tables for fulltext searches.\n        $sql = \"ALTER TABLE `artist` ADD FULLTEXT(`name`)\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `album` ADD FULLTEXT(`name`)\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song` ADD FULLTEXT(`title`)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Now add in the min_object_count preference and the random_method\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('bandwidth', '50', 'Bandwidth', '5', 'integer', 'interface')\";\n        Dba::write($sql);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('features', '50', 'Features', '5', 'integer', 'interface')\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_360003\n     *\n     * This update moves the image data to its own table.\n     */\n    public static function update_360003(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        $sql       = \"CREATE TABLE `image` (`id` int(11) unsigned NOT NULL auto_increment, `image` mediumblob NOT NULL, `mime` varchar(64) NOT NULL, `size` varchar(64) NOT NULL, `object_type` varchar(64) NOT NULL, `object_id` int(11) unsigned NOT NULL, PRIMARY KEY  (`id`), KEY `object_type` (`object_type`), KEY `object_id` (`object_id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation\";\n        $retval &= (Dba::write($sql) !== false);\n\n        foreach (array('album', 'artist') as $type) {\n            $sql        = \"SELECT `\" . $type . \"_id` AS `object_id`, `art`, `art_mime` FROM `\" . $type . \"_data` WHERE `art` IS NOT NULL\";\n            $db_results = Dba::read($sql);\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $sql = \"INSERT INTO `image` (`image`, `mime`, `size`, `object_type`, `object_id`) VALUES('\" . Dba::escape($row['art']) . \"', '\" . $row['art_mime'] . \"', 'original', '\" . $type . \"', '\" . $row['object_id'] . \"')\";\n                Dba::write($sql);\n            }\n            $sql = \"DROP TABLE `\" . $type . \"_data`\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * update_360004\n     *\n     * This update creates an index on the rating table.\n     */\n    public static function update_360004()\n    {\n        return (Dba::write(\"CREATE UNIQUE INDEX `unique_rating` ON `rating` (`user`, `object_type`, `object_id`);\") !== false);\n    }\n\n    /**\n     * update_360005\n     *\n     * This changes the tmp_browse table around.\n     */\n    public static function update_360005(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"DROP TABLE IF EXISTS `tmp_browse`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `tmp_browse` (`id` int(13) NOT NULL auto_increment, `sid` varchar(128) CHARACTER SET $charset NOT NULL default '', `data` longtext NOT NULL, `object_data` longtext, PRIMARY KEY  (`sid`, `id`)) ENGINE=$engine DEFAULT CHARSET=utf8\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360006\n     *\n     * This adds the table for newsearch/dynamic playlists\n     */\n    public static function update_360006(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `search` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) NOT NULL, `type` enum('private', 'public') CHARACTER SET $charset DEFAULT NULL, `rules` mediumtext NOT NULL, `name` varchar(255) CHARACTER SET $charset DEFAULT NULL, `logic_operator` varchar(3) CHARACTER SET $charset DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=$engine AUTO_INCREMENT=4 DEFAULT CHARSET=$charset;\") !== false);\n    }\n\n    /**\n     * update_360008\n     *\n     * Fix bug that caused the remote_username/password fields to not be created.\n     * FIXME: Huh?\n     */\n    public static function update_360008(): bool\n    {\n        $retval          = true;\n        $remote_username = false;\n        $remote_password = false;\n\n        $sql        = \"DESCRIBE `catalog`\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            if ($row['Field'] == 'remote_username') {\n                $remote_username = true;\n            }\n            if ($row['Field'] == 'remote_password') {\n                $remote_password = true;\n            }\n        } // end while\n\n        if (!$remote_username) {\n            // Add in Username / Password for catalog - to be used for remote catalogs\n            $sql = \"ALTER TABLE `catalog` ADD `remote_username` VARCHAR (255) AFTER `catalog_type`\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        if (!$remote_password) {\n            $sql = \"ALTER TABLE `catalog` ADD `remote_password` VARCHAR (255) AFTER `remote_username`\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * update_360009\n     *\n     * The main session table was already updated to use varchar(64) for the ID,\n     * tmp_playlist needs the same change\n     */\n    public static function update_360009(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `tmp_playlist` CHANGE `session` `session` VARCHAR(64);\") !== false);\n    }\n\n    /**\n     * update_360010\n     *\n     * MBz NGS means collaborations have more than one MBID (the ones\n     * belonging to the underlying artists).  We need a bigger column.\n     */\n    public static function update_360010(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `artist` CHANGE `mbid` `mbid` VARCHAR(36);\") !== false);\n    }\n\n    /**\n     * update_360011\n     *\n     * We need a place to store actual playlist data for downloadable\n     * playlist files.\n     */\n    public static function update_360011(): bool\n    {\n        return (Dba::write(\"CREATE TABLE `stream_playlist` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `sid` varchar(64) NOT NULL, `url` text NOT NULL, `info_url` text DEFAULT NULL, `image_url` text DEFAULT NULL, `title` varchar(255) DEFAULT NULL, `author` varchar(255) DEFAULT NULL, `album` varchar(255) DEFAULT NULL, `type` varchar(255) DEFAULT NULL, `time` smallint(5) DEFAULT NULL, PRIMARY KEY (`id`), KEY `sid` (`sid`));\") !== false);\n    }\n\n    /**\n     * update_360012\n     *\n     * Drop the enum on session.type\n     */\n    public static function update_360012(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `session` CHANGE `type` `type` VARCHAR(16) DEFAULT NULL;\") !== false);\n    }\n\n    /**\n     * update_360013\n     *\n     * MyISAM works better out of the box for the stream_playlist table\n     */\n    public static function update_360013(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"ALTER TABLE `stream_playlist` ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_360014\n     *\n     * PHP session IDs are an ever-growing beast.\n     */\n    public static function update_360014(): bool\n    {\n        $retval = true;\n\n        $retval &= (Dba::write(\"ALTER TABLE `stream_playlist` CHANGE `sid` `sid` VARCHAR(256);\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `tmp_playlist` CHANGE `session` `session` VARCHAR(256);\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `session` CHANGE `id` `id` VARCHAR(256) NOT NULL;\") !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360015\n     *\n     * This inserts the Iframes preference...\n     */\n    public static function update_360015(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('iframes', '1', 'Iframes', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /*\n     * update_360016\n     *\n     * Add Now Playing filtered per user preference option\n     */\n    public static function update_360016(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('now_playing_per_user', '1', 'Now playing filtered per user', 50, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360017\n     *\n     * New table to store user flags.\n     */\n    public static function update_360017(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `user_flag` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) NOT NULL, `object_id` int(11) unsigned NOT NULL, `object_type` varchar(32) CHARACTER SET $charset DEFAULT NULL, `date` int(11) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`), UNIQUE KEY `unique_userflag` (`user`, `object_type`, `object_id`), KEY `object_id` (`object_id`)) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_360018\n     *\n     * Add Album default sort preference...\n     */\n    public static function update_360018(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('album_sort', '0', 'Album Default Sort', 25, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360019\n     *\n     * Add Show number of times a song was played preference\n     */\n    public static function update_360019(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('show_played_times', '0', 'Show # played', 25, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360020\n     *\n     * Catalog types are plugins now\n     */\n    public static function update_360020(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `catalog_local` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `path` VARCHAR(255) COLLATE $collation NOT NULL, `catalog_id` INT(11) NOT NULL) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation\";\n        Dba::write($sql);\n        $sql = \"CREATE TABLE `catalog_remote` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `uri` VARCHAR(255) COLLATE $collation NOT NULL, `username` VARCHAR(255) COLLATE $collation NOT NULL, `password` VARCHAR(255) COLLATE $collation NOT NULL, `catalog_id` INT(11) NOT NULL) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation\";\n        Dba::write($sql);\n\n        $sql        = \"SELECT `id`, `catalog_type`, `path`, `remote_username`, `remote_password` FROM `catalog`\";\n        $db_results = Dba::read($sql);\n        while ($results = Dba::fetch_assoc($db_results)) {\n            if ($results['catalog_type'] == 'local') {\n                $sql = \"INSERT INTO `catalog_local` (`path`, `catalog_id`) VALUES (?, ?)\";\n                $retval &= (Dba::write($sql, array($results['path'], $results['id'])) !== false);\n            } elseif ($results['catalog_type'] == 'remote') {\n                $sql = \"INSERT INTO `catalog_remote` (`uri`, `username`, `password`, `catalog_id`) VALUES (?, ?, ?, ?)\";\n                $retval &= (Dba::write($sql, array($results['path'], $results['remote_username'], $results['remote_password'], $results['id'])) !== false);\n            }\n        }\n\n        $sql = \"ALTER TABLE `catalog` DROP `path`, DROP `remote_username`, DROP `remote_password`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `catalog` MODIFY COLUMN `catalog_type` varchar(128)\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `artist` SET `mbid` = NULL WHERE `mbid` = ''\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `album` SET `mbid` = NULL WHERE `mbid` = ''\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `song` SET `mbid` = NULL WHERE `mbid` = ''\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360021\n     *\n     * Add insertion date on Now Playing and option to show the current song in page title for Web player\n     */\n    public static function update_360021(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `now_playing` ADD `insertion` INT (11) AFTER `expire`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('song_page_title', '1', 'Show current song in Web player page title', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360022\n     *\n     * Remove unused live_stream fields and add codec field\n     */\n    public static function update_360022(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `live_stream` ADD `codec` VARCHAR(32) NULL AFTER `catalog`, DROP `frequency`, DROP `call_sign`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `stream_playlist` ADD `codec` VARCHAR(32) NULL AFTER `time`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360023\n     *\n     * Enable/Disable SubSonic and Plex backend\n     */\n    public static function update_360023(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('subsonic_backend', '1', 'Use SubSonic backend', 100, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('plex_backend', '0', 'Use Plex backend', 100, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360024\n     *\n     * Drop unused flagged table\n     */\n    public static function update_360024(): bool\n    {\n        return (Dba::write(\"DROP TABLE IF EXISTS `flagged`;\") !== false);\n    }\n\n    /**\n     * update_360025\n     *\n     * Add options to enable HTML5 / Flash on web players\n     */\n    public static function update_360025(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webplayer_flash', '1', 'Authorize Flash Web Player(s)', 25, 'boolean', 'streaming')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webplayer_html5', '1', 'Authorize HTML5 Web Player(s)', 25, 'boolean', 'streaming')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360026\n     *\n     * Add agent field in `object_count` table\n     */\n    public static function update_360026(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `object_count` ADD `agent` VARCHAR(255) NULL AFTER `user`;\") !== false);\n    }\n\n    /**\n     * update_360027\n     *\n     * Personal information: allow/disallow to show my personal information into now playing and recently played lists.\n     */\n    public static function update_360027(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_personal_info', '1', 'Allow to show my personal info to other users (now playing, recently played)', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360028\n     *\n     * Personal information: allow/disallow to show in now playing.\n     * Personal information: allow/disallow to show in recently played.\n     * Personal information: allow/disallow to show time and/or agent in recently played.\n     */\n    public static function update_360028(): bool\n    {\n        $retval = true;\n\n        // Update previous update preference\n        $sql = \"UPDATE `preference` SET `name`='allow_personal_info_now', `description`='Personal information visibility - Now playing' WHERE `name`='allow_personal_info'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Insert new recently played preference\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_personal_info_recent', '1', 'Personal information visibility - Recently played / actions', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        // Insert streaming time preference\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_personal_info_time', '1', 'Personal information visibility - Recently played - Allow to show streaming date/time', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        // Insert streaming agent preference\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_personal_info_agent', '1', 'Personal information visibility - Recently played - Allow to show streaming agent', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360029\n     *\n     * New table to store wanted releases\n     */\n    public static function update_360029(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `wanted` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) NOT NULL, `artist` int(11) NOT NULL, `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL, `name` varchar(255) CHARACTER SET $charset NOT NULL, `year` int(4) NULL, `date` int(11) unsigned NOT NULL DEFAULT '0', `accepted` tinyint(1) NOT NULL DEFAULT '0', PRIMARY KEY (`id`), UNIQUE KEY `unique_wanted` (`user`, `artist`, `mbid`)) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_360030\n     *\n     * New table to store song previews\n     */\n    public static function update_360030(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `song_preview` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `session` varchar(256) CHARACTER SET $charset NOT NULL, `artist` int(11) NOT NULL, `title` varchar(255) CHARACTER SET $charset NOT NULL, `album_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL, `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL, `disk` int(11) NULL, `track` int(11) NULL, `file` varchar(255) CHARACTER SET $charset NULL, PRIMARY KEY (`id`)) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_360031\n     *\n     * Add option to fix header/sidebars position on compatible themes\n     */\n    public static function update_360031(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('ui_fixed', '0', 'Fix header position on compatible themes', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360032\n     *\n     * Add check update automatically option\n     */\n    public static function update_360032(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('autoupdate', '1', 'Check for Ampache updates automatically', 25, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        Preference::insert('autoupdate_lastcheck', 'AutoUpdate last check time', '', '25', 'string', 'internal');\n        Preference::insert('autoupdate_lastversion', 'AutoUpdate last version from last check', '', '25', 'string', 'internal');\n        Preference::insert('autoupdate_lastversion_new', 'AutoUpdate last version from last check is newer', '', '25', 'boolean', 'internal');\n\n        return $retval;\n    }\n\n    /**\n     * update_360033\n     *\n     * Add song waveform as song data\n     */\n    public static function update_360033(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `song_data` ADD `waveform` MEDIUMBLOB NULL AFTER `language`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user_shout` ADD `data` VARCHAR(256) NULL AFTER `object_type`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360034\n     *\n     * Add settings for confirmation when closing window and auto-pause between tabs\n     */\n    public static function update_360034(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webplayer_confirmclose', '0', 'Confirmation when closing current playing window', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webplayer_pausetabs', '1', 'Auto-pause betweens tabs', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360035\n     *\n     * Add beautiful stream url setting\n     * Reverted https://github.com/ampache/ampache/commit/0c26c336269624d75985e46d324e2bc8108576ee\n     * with adding update_380012.\n     * Because it was changed after many systems have already performed this update.\n     * Fix for this is update_380012 that actually readds the preference string.\n     * So all users have a consistent database.\n     */\n    public static function update_360035(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('stream_beautiful_url', '0', 'Use beautiful stream url', 100, 'boolean', 'streaming')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360036\n     *\n     * Remove some unused parameters\n     */\n    public static function update_360036(): bool\n    {\n        $retval = true;\n\n        $sql = \"DELETE FROM `preference` WHERE `name` LIKE 'ellipse_threshold_%'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"DELETE FROM `preference` WHERE `name` = 'min_object_count'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"DELETE FROM `preference` WHERE `name` = 'bandwidth'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"DELETE FROM `preference` WHERE `name` = 'features'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"DELETE FROM `preference` WHERE `name` = 'tags_userlist'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360037\n     *\n     * Add sharing features\n     */\n    public static function update_360037(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `share` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) unsigned NOT NULL, `object_type` varchar(32) NOT NULL, `object_id` int(11) unsigned NOT NULL, `allow_stream` tinyint(1) unsigned NOT NULL DEFAULT '0', `allow_download` tinyint(1) unsigned NOT NULL DEFAULT '0', `expire_days` int(4) unsigned NOT NULL DEFAULT '0', `max_counter` int(4) unsigned NOT NULL DEFAULT '0', `secret` varchar(20) CHARACTER SET $charset NULL, `counter` int(4) unsigned NOT NULL DEFAULT '0', `creation_date` int(11) unsigned NOT NULL DEFAULT '0', `lastvisit_date` int(11) unsigned NOT NULL DEFAULT '0', `public_url` varchar(255) CHARACTER SET $charset NULL, `description` varchar(255) CHARACTER SET $charset NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('share', '0', 'Allow Share', 100, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('share_expire', '7', 'Share links default expiration days (0=never)', 100, 'integer', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '7')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360038\n     *\n     * Add missing albums browse on missing artists\n     */\n    public static function update_360038(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `wanted` ADD `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL AFTER `artist`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `wanted` MODIFY `artist` int(11) NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song_preview` ADD `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL AFTER `artist`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song_preview` MODIFY `artist` int(11) NULL\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360039\n     *\n     * Add website field on users\n     */\n    public static function update_360039(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        return (Dba::write(\"ALTER TABLE `user` ADD `website` varchar(255) CHARACTER SET $charset NULL AFTER `email`;\") !== false);\n    }\n\n    /**\n     * update_360040 skipped.\n     */\n\n    /**\n     * update_360041\n     *\n     * Add channels\n     */\n    public static function update_360041(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `channel` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(64) CHARACTER SET $charset NULL, `description` varchar(256) CHARACTER SET $charset NULL, `url` varchar(256) CHARACTER SET $charset NULL, `interface` varchar(64) CHARACTER SET $charset NULL, `port` int(11) unsigned NOT NULL DEFAULT '0', `fixed_endpoint` tinyint(1) unsigned NOT NULL DEFAULT '0', `object_type` varchar(32) NOT NULL, `object_id` int(11) unsigned NOT NULL, `is_private` tinyint(1) unsigned NOT NULL DEFAULT '0', `random` tinyint(1) unsigned NOT NULL DEFAULT '0', `loop` tinyint(1) unsigned NOT NULL DEFAULT '0', `admin_password` varchar(20) CHARACTER SET $charset NULL, `start_date` int(11) unsigned NOT NULL DEFAULT '0', `max_listeners` int(11) unsigned NOT NULL DEFAULT '0', `peak_listeners` int(11) unsigned NOT NULL DEFAULT '0', `listeners` int(11) unsigned NOT NULL DEFAULT '0', `connections` int(11) unsigned NOT NULL DEFAULT '0', `stream_type` varchar(8) CHARACTER SET $charset NOT NULL DEFAULT 'mp3', `bitrate` int(11) unsigned NOT NULL DEFAULT '128', `pid` int(11) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_360042\n     *\n     * Add broadcasts and player control\n     */\n    public static function update_360042(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `broadcast` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) unsigned NOT NULL, `name` varchar(64) CHARACTER SET $charset NULL, `description` varchar(256) CHARACTER SET $charset NULL, `is_private` tinyint(1) unsigned NOT NULL DEFAULT '0', `song` int(11) unsigned NOT NULL DEFAULT '0', `started` tinyint(1) unsigned NOT NULL DEFAULT '0', `listeners` int(11) unsigned NOT NULL DEFAULT '0', `key` varchar(32) CHARACTER SET $charset NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `player_control` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) unsigned NOT NULL, `cmd` varchar(32) CHARACTER SET $charset NOT NULL, `value` varchar(256) CHARACTER SET $charset NULL, `object_type` varchar(32) NOT NULL, `object_id` int(11) unsigned NOT NULL, `send_date` int(11) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360043\n     *\n     * Add slideshow on currently played artist preference\n     */\n    public static function update_360043(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('slideshow_time', '0', 'Artist slideshow inactivity time', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360044\n     *\n     * Add artist description/recommendation external service data cache\n     */\n    public static function update_360044(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"ALTER TABLE `artist` ADD `summary` TEXT CHARACTER SET $charset NULL, ADD `placeformed` varchar(64) NULL, ADD `yearformed` int(4) NULL, ADD `last_update` int(11) unsigned NOT NULL DEFAULT '0'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `recommendation` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `object_type` varchar(32) NOT NULL, `object_id` int(11) unsigned NOT NULL, `last_update` int(11) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `recommendation_item` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `recommendation` int(11) unsigned NOT NULL, `recommendation_id` int(11) unsigned NULL, `name` varchar(256) NULL, `rel` varchar(256) NULL, `mbid` varchar(36) NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360045\n     *\n     * Set user field on playlists as optional\n     */\n    public static function update_360045(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `playlist` MODIFY `user` int(11) NULL;\") !== false);\n    }\n\n    /**\n     * update_360046\n     *\n     * Add broadcast web player by default preference\n     */\n    public static function update_360046(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('broadcast_by_default', '0', 'Broadcast web player by default', 25, 'boolean', 'streaming')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360047\n     *\n     * Add apikey field on users\n     */\n    public static function update_360047(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        return (Dba::write(\"ALTER TABLE `user` ADD `apikey` varchar(255) CHARACTER SET $charset NULL AFTER `website`;\") !== false);\n    }\n\n    /**\n     * update_360048\n     *\n     * Add concerts options\n     */\n    public static function update_360048(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('concerts_limit_future', '0', 'Limit number of future events', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('concerts_limit_past', '0', 'Limit number of past events', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360049\n     *\n     * Add album group multiple disks setting\n     */\n    public static function update_360049(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('album_group', '0', 'Album - Group multiple disks', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360050\n     *\n     * Add top menu setting\n     */\n    public static function update_360050(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('topmenu', '0', 'Top menu', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_360051\n     *\n     * REMOVED\n     */\n    public static function update_360051(): bool\n    {\n        return true;\n    }\n\n    /**\n     * update_370001\n     *\n     * Drop unused dynamic_playlist tables and add session id to votes\n     */\n    public static function update_370001(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        $sql = \"DROP TABLE dynamic_playlist\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"DROP TABLE dynamic_playlist_data\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user_vote` ADD `sid` varchar(256) CHARACTER SET $charset NULL AFTER `date`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('demo_clear_sessions', '0', 'Clear democratic votes of expired user sessions', 25, 'boolean', 'playlist')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370002\n     *\n     * Add tag persistent merge reference\n     */\n    public static function update_370002(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `tag` ADD `merged_to` int(11) NULL AFTER `name`;\") !== false);\n    }\n\n    /**\n     * update_370003\n     *\n     * Add show/hide donate button preference\n     */\n    public static function update_370003(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('show_donate', '1', 'Show donate button in footer', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370004\n     *\n     * Add license information and user's artist association\n     */\n    public static function update_370004(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_catalog', '-1', 'Uploads catalog destination', 75, 'integer', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '-1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_upload', '0', 'Allow users to upload media', 75, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_subdir', '1', 'Upload: create a subdirectory per user (recommended)', 75, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_user_artist', '0', 'Upload: consider the user sender as the track\\'s artist', 75, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_script', '', 'Upload: run the following script after upload (current directory = upload target directory)', 75, 'string', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_allow_edit', '1', 'Upload: allow users to edit uploaded songs', 75, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"ALTER TABLE `artist` ADD `user` int(11) NULL AFTER `last_update`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `license` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(80) NOT NULL, `description` varchar(256) NULL, `external_link` varchar(256) NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('0 - default', '')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY', 'https://creativecommons.org/licenses/by/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY NC', 'https://creativecommons.org/licenses/by-nc/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY NC ND', 'https://creativecommons.org/licenses/by-nc-nd/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY NC SA', 'https://creativecommons.org/licenses/by-nc-sa/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY ND', 'https://creativecommons.org/licenses/by-nd/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('CC BY SA', 'https://creativecommons.org/licenses/by-sa/3.0/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('Licence Art Libre', 'http://artlibre.org/licence/lal/')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('Yellow OpenMusic', 'http://openmusic.linuxtag.org/yellow.html')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('Green OpenMusic', 'http://openmusic.linuxtag.org/green.html')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('Gnu GPL Art', 'http://gnuart.org/english/gnugpl.html')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('WTFPL', 'https://en.wikipedia.org/wiki/WTFPL')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('FMPL', 'http://www.fmpl.org/fmpl.html')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `license`(`name`, `external_link`) VALUES ('C Reaction', 'http://morne.free.fr/Necktar7/creaction.htm')\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song` ADD `user_upload` int(11) NULL AFTER `addition_time`, ADD `license` int(11) NULL AFTER `user_upload`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370005\n     *\n     * Add new column album_artist into table album\n     *\n     */\n    public static function update_370005(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `song` ADD `album_artist` int(11) unsigned DEFAULT NULL AFTER `artist`;\") !== false);\n    }\n\n    /**\n     * update_370006\n     *\n     * Add random and limit options to smart playlists\n     *\n     */\n    public static function update_370006(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `search` ADD `random` tinyint(1) unsigned NOT NULL DEFAULT '0' AFTER `logic_operator`, ADD `limit` int(11) unsigned NOT NULL DEFAULT '0' AFTER `random`;\") !== false);\n    }\n\n    /**\n     * update_370007\n     *\n     * Add DAAP backend preference\n     */\n    public static function update_370007(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('daap_backend', '0', 'Use DAAP backend', 100, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('daap_pass', '', 'DAAP backend password', 100, 'string', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"CREATE TABLE `daap_session` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `creationdate` int(11) unsigned NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370008\n     *\n     * Add UPnP backend preference\n     *\n     */\n    public static function update_370008(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upnp_backend', '0', 'Use UPnP backend', 100, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370009\n     *\n     * Enhance video support with TVShows and Movies\n     */\n    public static function update_370009(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"ALTER TABLE `video` ADD `release_date` date NULL AFTER `enabled`, ADD `played` tinyint(1) unsigned DEFAULT '0' NOT NULL AFTER `enabled`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `tvshow` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(80) NOT NULL, `summary` varchar(256) NULL, `year` int(11) unsigned NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `tvshow_season` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `season_number` int(11) unsigned NOT NULL, `tvshow` int(11) unsigned NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `tvshow_episode` (`id` int(11) unsigned NOT NULL, `original_name` varchar(80) NULL, `season` int(11) unsigned NOT NULL, `episode_number` int(11) unsigned NOT NULL, `summary` varchar(256) NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `movie` (`id` int(11) unsigned NOT NULL, `original_name` varchar(80) NULL, `summary` varchar(256) NULL, `year` int(11) unsigned NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `personal_video` (`id` int(11) unsigned NOT NULL, `location` varchar(256) NULL, `summary` varchar(256) NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `clip` (`id` int(11) unsigned NOT NULL, `artist` int(11) NULL, `song` int(11) NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('allow_video', '1', 'Allow video features', 75, 'integer', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"ALTER TABLE `image` ADD `kind` VARCHAR(32) NULL DEFAULT 'default' AFTER `object_id`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370010\n     *\n     * Add MusicBrainz Album Release Group identifier\n     */\n    public static function update_370010(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        return (Dba::write(\"ALTER TABLE `album` ADD `mbid_group` varchar(36) CHARACTER SET $charset NULL;\") !== false);\n    }\n\n    /**\n     * update_370011\n     *\n     * Add Prefix to TVShows and Movies\n     */\n    public static function update_370011(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        $sql = \"ALTER TABLE `tvshow` ADD `prefix` varchar(32) CHARACTER SET $charset NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `movie` ADD `prefix` varchar(32) CHARACTER SET $charset NULL\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370012\n     *\n     * Add metadata information to albums / songs / videos\n     */\n    public static function update_370012(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        $sql = \"ALTER TABLE `album` ADD `release_type` varchar(32) CHARACTER SET $charset NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song` ADD `composer` varchar(256) CHARACTER SET $charset NULL, ADD `channels` MEDIUMINT NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `video` ADD `channels` MEDIUMINT NULL, ADD `bitrate` MEDIUMINT(8) NULL, ADD `video_bitrate` MEDIUMINT(8) NULL, ADD `display_x` MEDIUMINT(8) NULL, ADD `display_y` MEDIUMINT(8) NULL, ADD `frame_rate` FLOAT NULL, ADD `mode` ENUM('abr', 'vbr', 'cbr') NULL DEFAULT 'cbr'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('album_release_type', '1', 'Album - Group per release type', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370013\n     *\n     * Replace iframe with ajax page load\n     */\n    public static function update_370013(): bool\n    {\n        $retval = true;\n\n        $sql = \"DELETE FROM `preference` WHERE `name` = 'iframes'\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('ajax_load', '1', 'Ajax page load', 25, 'boolean', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370014\n     *\n     * Modified release_date of table video to signed int(11)\n     */\n    public static function update_370014(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `video` CHANGE COLUMN `release_date` `release_date` INT NULL DEFAULT NULL;\") !== false);\n    }\n\n    /**\n     * update 370015\n     *\n     * Add session_remember table to store remember tokens\n     */\n    public static function update_370015(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `session_remember` (`username` varchar(16) NOT NULL, `token` varchar(32) NOT NULL, `expire` int(11) NULL, PRIMARY KEY (`username`, `token`)) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update 370016\n     *\n     * Add limit of media count for direct play preference\n     */\n    public static function update_370016(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('direct_play_limit', '0', 'Limit direct play to maximum media count', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370017\n     *\n     * Add home display settings\n     */\n    public static function update_370017(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('home_moment_albums', '1', 'Show Albums of the moment at home page', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('home_moment_videos', '1', 'Show Videos of the moment at home page', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('home_recently_played', '1', 'Show Recently Played at home page', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('home_now_playing', '1', 'Show Now Playing at home page', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('custom_logo', '', 'Custom logo url', 25, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /*\n     * update 370018\n     *\n     * Enhance tag persistent merge reference.\n     */\n    public static function update_370018(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE IF NOT EXISTS `tag_merge` (`tag_id` int(11) NOT NULL, `merged_to` int(11) NOT NULL, FOREIGN KEY (`tag_id`) REFERENCES `tag` (`tag_id`), FOREIGN KEY (`merged_to`) REFERENCES `tag` (`tag_id`), PRIMARY KEY (`tag_id`, `merged_to`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `tag_merge` (`tag_id`, `merged_to`) SELECT `tag`.`id`, `tag`.`merged_to` FROM `tag` WHERE `merged_to` IS NOT NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `tag` DROP COLUMN `merged_to`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `tag` ADD COLUMN `is_hidden` TINYINT(1) NOT NULL DEFAULT 0\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370019\n     *\n     * Add album group order setting\n     */\n    public static function update_370019(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('album_release_type_sort', 'album,ep,live,single', 'Album - Group per release type Sort', 25, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, 'album,ep,live,single')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370020\n     *\n     * Add webplayer browser notification settings\n     */\n    public static function update_370020(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('browser_notify', '1', 'WebPlayer browser notifications', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('browser_notify_timeout', '10', 'WebPlayer browser notifications timeout (seconds)', 25, 'integer', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '10')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370021\n     *\n     * Add rating to playlists, tvshows and tvshows seasons\n     */\n    public static function update_370021(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `rating` CHANGE `object_type` `object_type` ENUM ('artist', 'album', 'song', 'stream', 'video', 'playlist', 'tvshow', 'tvshow_season') NULL;\") !== false);\n    }\n\n    /**\n     * update 370022\n     *\n     * Add users geolocation\n     */\n    public static function update_370022(): bool\n    {\n        $retval = true;\n\n        $sql    = \"ALTER TABLE `session` ADD COLUMN `geo_latitude` DECIMAL(10,6) NULL, ADD COLUMN `geo_longitude` DECIMAL(10,6) NULL, ADD COLUMN `geo_name` VARCHAR(255) NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `object_count` ADD COLUMN `geo_latitude` DECIMAL(10,6) NULL, ADD COLUMN `geo_longitude` DECIMAL(10,6) NULL, ADD COLUMN `geo_name` VARCHAR(255) NULL\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('geolocation', '0', 'Allow geolocation', 25, 'integer', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370023\n     *\n     * Add Aurora.js webplayer option\n     */\n    public static function update_370023(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webplayer_aurora', '1', 'Authorize JavaScript decoder (Aurora.js) in Web Player(s)', 25, 'boolean', 'streaming')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update 370024\n     *\n     * Add count_type column to object_count table\n     */\n    public static function update_370024(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `object_count` ADD COLUMN `count_type` VARCHAR(16) NOT NULL DEFAULT 'stream';\") !== false);\n    }\n\n    /**\n     * update 370025\n     *\n     * Add state and city fields to user table\n     */\n    public static function update_370025(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `user` ADD COLUMN `state` VARCHAR(64) NULL, ADD COLUMN `city` VARCHAR(64) NULL;\") !== false);\n    }\n\n    /**\n     * update 370026\n     *\n     * Add replay gain fields to song_data table\n     */\n    public static function update_370026(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `song_data` ADD COLUMN `replaygain_track_gain` DECIMAL(10,6) NULL, ADD COLUMN `replaygain_track_peak` DECIMAL(10,6) NULL, ADD COLUMN `replaygain_album_gain` DECIMAL(10,6) NULL, ADD COLUMN `replaygain_album_peak` DECIMAL(10,6) NULL;\") !== false);\n    }\n\n    /**\n     * update_370027\n     *\n     * Move column album_artist from table song to table album\n     *\n     */\n    public static function update_370027(): bool\n    {\n        $retval = true;\n\n        $sql    = \"ALTER TABLE `album` ADD `album_artist` int(11) unsigned DEFAULT NULL AFTER `release_type`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"UPDATE `album` INNER JOIN `song` ON `album`.`id` = `song`.`album` SET `album`.`album_artist` = `song`.`album_artist`\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `song` DROP COLUMN `album_artist`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370028\n     *\n     * Add width and height in table image\n     *\n     */\n    public static function update_370028(): bool\n    {\n        $retval = true;\n\n        $sql        = \"SELECT `width` FROM `image`\";\n        $db_results = Dba::read($sql);\n        if (!$db_results) {\n            $sql    = \"ALTER TABLE `image` ADD `width` int(4) unsigned DEFAULT 0 AFTER `image`\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        $sql        = \"SELECT `height` FROM `image`\";\n        $db_results = Dba::read($sql);\n        if (!$db_results) {\n            $sql    = \"ALTER TABLE `image` ADD `height` int(4) unsigned DEFAULT 0 AFTER `width`\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * update_370029\n     *\n     * Set image column from image table as nullable.\n     *\n     */\n    public static function update_370029(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `image` CHANGE COLUMN `image` `image` MEDIUMBLOB NULL DEFAULT NULL;\") !== false);\n    }\n\n    /**\n     * update_370030\n     *\n     * Add an option to allow users to remove uploaded songs.\n     */\n    public static function update_370030(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('upload_allow_remove', '1', 'Upload: allow users to remove uploaded songs', 75, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370031\n     *\n     * Add an option to customize login art, favicon and text footer.\n     */\n    public static function update_370031(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('custom_login_logo', '', 'Custom login page logo url', 75, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('custom_favicon', '', 'Custom favicon url', 75, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('custom_text_footer', '', 'Custom text footer', 75, 'string', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370032\n     *\n     * Add WebDAV backend preference.\n     */\n    public static function update_370032(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('webdav_backend', '0', 'Use WebDAV backend', 100, 'boolean', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370033\n     *\n     * Add Label tables.\n     */\n    public static function update_370033(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `label` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(80) NOT NULL, `category` varchar(40) NULL, `summary` TEXT CHARACTER SET $charset NULL, `address` varchar(256) NULL, `email` varchar(128) NULL, `website` varchar(256) NULL, `user` int(11) unsigned NULL, `creation_date` int(11) unsigned NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `label_asso` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `label` int(11) unsigned NOT NULL, `artist` int(11) unsigned NOT NULL, `creation_date` int(11) unsigned NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370034\n     *\n     * Add User messages and user follow tables.\n     */\n    public static function update_370034(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `user_pvmsg` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `subject` varchar(80) NOT NULL, `message` TEXT CHARACTER SET $charset NULL, `from_user` int(11) unsigned NOT NULL, `to_user` int(11) unsigned NOT NULL, `is_read` tinyint(1) unsigned NOT NULL DEFAULT '0', `creation_date` int(11) unsigned NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `user_follower` (`id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user` int(11) unsigned NOT NULL, `follow_user` int(11) unsigned NOT NULL, `follow_date` int(11) unsigned  NULL, PRIMARY KEY (`id`)) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('notify_email', '0', 'Receive notifications by email (shouts, private messages, ...)', 25, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370035\n     *\n     * Add option on user fullname to show/hide it publicly\n     */\n    public static function update_370035(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `user` ADD COLUMN `fullname_public` TINYINT(1) UNSIGNED NOT NULL DEFAULT '0';\") !== false);\n    }\n\n    /**\n     * update_370036\n     *\n     * Add field for track number when generating streaming playlists\n     */\n    public static function update_370036(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `stream_playlist` ADD COLUMN `track_num` SMALLINT(5) DEFAULT '0';\") !== false);\n    }\n\n    /**\n     * update_370037\n     *\n     * Delete http_port preference (use ampache.cfg.php configuration instead)\n     */\n    public static function update_370037(): bool\n    {\n        return (Dba::write(\"DELETE FROM `preference` WHERE `name` = 'http_port';\") !== false);\n    }\n\n    /**\n     * update_370038\n     *\n     * Add theme color option\n     */\n    public static function update_370038(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('theme_color', 'dark', 'Theme color',0, 'special', 'interface')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, 'dark')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_370039\n     *\n     * Renamed false named sample_rate option name in preference table\n     */\n    public static function update_370039(): bool\n    {\n        return (Dba::write(\"UPDATE `preference` SET `name` = 'transcode_bitrate' WHERE `preference`.`name` = 'sample_rate';\") !== false);\n    }\n\n    /**\n     * update_370040\n     *\n     * Add user_activity table\n     */\n    public static function update_370040(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `user_activity` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `user` INT(11) NOT NULL, `action` varchar(20) NOT NULL, `object_id` INT(11) UNSIGNED NOT NULL, `object_type` VARCHAR(32) NOT NULL, `activity_date` INT(11) UNSIGNED NOT NULL) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_370041\n     *\n     * Add Metadata tables and preferences\n     */\n    public static function update_370041(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `metadata_field` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `name` varchar(255) NOT NULL, `public` tinyint(1) NOT NULL, UNIQUE KEY `name` (`name`) ) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `metadata` (`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `object_id` INT(11) UNSIGNED NOT NULL, `field` INT(11) UNSIGNED NOT NULL, `data` text COLLATE $collation NOT NULL, `type` varchar(50) CHARACTER SET $charset DEFAULT NULL, KEY `field` (`field`), KEY `object_id` (`object_id`), KEY `type` (`type`), KEY `objecttype` (`object_id`, `type`), KEY `objectfield` (`object_id`, `field`, `type`) ) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('disabled_custom_metadata_fields', '', 'Disable custom metadata fields (ctrl / shift click to select multiple)', 100, 'string', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('disabled_custom_metadata_fields_input', '', 'Disable custom metadata fields. Insert them in a comma separated list. They will add to the fields selected above.', 100, 'string', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380001\n     *\n     * Add podcasts\n     */\n    public static function update_380001(): bool\n    {\n        $retval  = true;\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        $sql = \"CREATE TABLE `podcast` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `feed` varchar(4096) NOT NULL, `catalog` int(11) NOT NULL, `title` varchar(255) CHARACTER SET $charset NOT NULL, `website` varchar(255) NULL, `description` varchar(4096) CHARACTER SET $charset NULL, `language` varchar(5) NULL, `copyright` varchar(64) NULL, `generator` varchar(64) NULL, `lastbuilddate` int(11) UNSIGNED DEFAULT '0' NOT NULL, `lastsync` int(11) UNSIGNED DEFAULT '0' NOT NULL) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE `podcast_episode` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `title` varchar(255) CHARACTER SET $charset NOT NULL, `guid` varchar(255) NOT NULL, `podcast` int(11) NOT NULL, `state` varchar(32) NOT NULL, `file` varchar(4096) CHARACTER SET $charset NULL, `source` varchar(4096) NULL, `size` bigint(20) UNSIGNED DEFAULT '0' NOT NULL, `time` smallint(5) UNSIGNED DEFAULT '0' NOT NULL, `website` varchar(255) NULL, `description` varchar(4096) CHARACTER SET $charset NULL, `author` varchar(64) NULL, `category` varchar(64) NULL, `played` tinyint(1) UNSIGNED DEFAULT '0' NOT NULL, `pubdate` int(11) UNSIGNED NOT NULL, `addition_time` int(11) UNSIGNED NOT NULL) ENGINE=$engine\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('podcast_keep', '10', 'Podcast: # latest episodes to keep', 100, 'integer', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '10')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('podcast_new_download', '1', 'Podcast: # episodes to download when new episodes are available', 100, 'integer', 'system')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql = \"ALTER TABLE `rating` CHANGE `object_type` `object_type` ENUM ('artist', 'album', 'song', 'stream', 'video', 'playlist', 'tvshow', 'tvshow_season', 'podcast', 'podcast_episode') NULL\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380002\n     *\n     * Add bookmarks\n     */\n    public static function update_380002(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine  = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        return (Dba::write(\"CREATE TABLE `bookmark` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, `user` int(11) UNSIGNED NOT NULL, `position` int(11) UNSIGNED DEFAULT '0' NOT NULL, `comment` varchar(255) CHARACTER SET $charset NOT NULL, `object_type` varchar(64) NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `creation_date` int(11) UNSIGNED DEFAULT '0' NOT NULL, `update_date` int(11) UNSIGNED DEFAULT '0' NOT NULL) ENGINE=$engine;\") !== false);\n    }\n\n    /**\n     * update_380003\n     *\n     * Add unique constraint on tag_map table\n     */\n    public static function update_380003(): bool\n    {\n        return (Dba::write(\"ALTER IGNORE TABLE `tag_map` ADD UNIQUE INDEX `UNIQUE_TAG_MAP` (`object_id`, `object_type`, `user`, `tag_id`);\") !== false);\n    }\n\n    /**\n     * update_380004\n     *\n     * Add preference subcategory\n     */\n    public static function update_380004(): bool\n    {\n        $charset = (AmpConfig::get('database_charset', 'utf8mb4'));\n\n        return (Dba::write(\"ALTER TABLE `preference` ADD `subcatagory` varchar(128) CHARACTER SET $charset DEFAULT NULL AFTER `catagory`;\") !== false);\n    }\n\n    /**\n     * update_380005\n     *\n     * Add manual update flag on artist\n     */\n    public static function update_380005(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `artist` ADD COLUMN `manual_update` SMALLINT(1) DEFAULT '0';\") !== false);\n    }\n\n    /**\n     * update_380006\n     *\n     * Add library item context menu option\n     */\n    public static function update_380006(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('libitem_contextmenu', '1', 'Library item context menu',0, 'boolean', 'interface', 'library')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380007\n     *\n     * Add upload rename pattern and ignore duplicate options\n     */\n    public static function update_380007(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('upload_catalog_pattern', '0', 'Rename uploaded file according to catalog pattern', 100, 'boolean', 'system', 'upload')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('catalog_check_duplicate', '0', 'Check library item at import time and disable duplicates', 100, 'boolean', 'system', 'catalog')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380008\n     *\n     * Add browse filter and light sidebar options\n     */\n    public static function update_380008(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('browse_filter', '0', 'Show filter box on browse', 25, 'boolean', 'interface', 'library')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('sidebar_light', '0', 'Light sidebar by default', 25, 'boolean', 'interface', 'theme')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380009\n     *\n     * Add update date to playlist\n     */\n    public static function update_380009(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `playlist` ADD COLUMN `last_update` int(11) unsigned NOT NULL DEFAULT '0';\") !== false);\n    }\n\n    /**\n     * update_380010\n     *\n     * Add custom blank album/video default image and alphabet browsing options\n     */\n    public static function update_380010(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('custom_blankalbum', '', 'Custom blank album default image', 75, 'string', 'interface', 'custom')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('custom_blankmovie', '', 'Custom blank video default image', 75, 'string', 'interface', 'custom')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('libitem_browse_alpha', '', 'Alphabet browsing by default for following library items (album,artist,...)', 75, 'string', 'interface', 'library')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380011\n     *\n     * Fix username max size to be the same one across all tables.\n     */\n    public static function update_380011(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE session MODIFY username VARCHAR(255)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE session_remember MODIFY username VARCHAR(255)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE user MODIFY username VARCHAR(255)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE user MODIFY fullname VARCHAR(255)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_380012\n     *\n     * Fix change in https://github.com/ampache/ampache/commit/0c26c336269624d75985e46d324e2bc8108576ee\n     * That left the user base with an inconsistent database.\n     * For more information, please look at update_360035.\n     */\n    public static function update_380012(): bool\n    {\n        $retval = true;\n\n        $sql = \"UPDATE `preference` SET `description`='Enable url rewriting' WHERE `preference`.`name`='stream_beautiful_url'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400000\n     *\n     * Increase copyright column size to fix issue #1861\n     * Add name_track, name_artist, name_album to user_activity\n     * Add mbid_track, mbid_artist, mbid_album to user_activity\n     * Insert some decent SmartLists for a better default experience\n     * Delete the following plex preferences from the server\n     *   plex_backend\n     *   myplex_username\n     *   myplex_authtoken\n     *   myplex_published\n     *   plex_uniqid\n     *   plex_servername\n     *   plex_public_address\n     *   plex_public_port\n     *   plex_local_auth\n     *   plex_match_email\n     * Add preference for master/develop branch selection\n     */\n    public static function update_400000(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `podcast` MODIFY `copyright` VARCHAR(255)\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `user_activity` ADD COLUMN `name_track` VARCHAR(255) NULL DEFAULT NULL, ADD COLUMN `name_artist` VARCHAR(255) NULL DEFAULT NULL, ADD COLUMN `name_album` VARCHAR(255) NULL DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `user_activity` ADD COLUMN `mbid_track` VARCHAR(255) NULL DEFAULT NULL, ADD COLUMN `mbid_artist` VARCHAR(255) NULL DEFAULT NULL, ADD COLUMN `mbid_album` VARCHAR(255) NULL DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"INSERT IGNORE INTO `search` (`user`, `type`, `rules`, `name`, `logic_operator`, `random`, `limit`) VALUES (-1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Artist 5*', 'AND', 0, 0), (-1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Artist 4*', 'AND', 0, 0), (-1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Artist 3*', 'AND', 0, 0), (-1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Artist 2*', 'AND', 0, 0), (-1, 'public', '[[\\\"artistrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Artist 1*', 'AND', 0, 0), (-1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Album 5*', 'AND', 0, 0), (-1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Album 4*', 'AND', 0, 0), (-1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Album 3*', 'AND', 0, 0), (-1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Album 2*', 'AND', 0, 0), (-1, 'public', '[[\\\"albumrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Album 1*', 'AND', 0, 0), (-1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"5\\\",null]]', 'Song 5*', 'AND', 0, 0), (-1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"4\\\",null]]', 'Song 4*', 'AND', 0, 0), (-1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"3\\\",null]]', 'Song 3*', 'AND', 0, 0), (-1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"2\\\",null]]', 'Song 2*', 'AND', 0, 0), (-1, 'public', '[[\\\"myrating\\\",\\\"equal\\\",\\\"1\\\",null]]', 'Song 1*', 'AND', 0, 0);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_backend');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'myplex_username');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'myplex_authtoken');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'myplex_published');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_uniqid');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_servername');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_public_address');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_public_port');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_local_auth');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'plex_match_email');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `preference` WHERE `preference`.`name` IN ('plex_backend', 'myplex_username', 'myplex_authtoken', 'myplex_published', 'plex_uniqid', 'plex_servername', 'plex_public_address', 'plex_public_port ', 'plex_local_auth', 'plex_match_email');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400001\n     *\n     * Make sure people on older databases have the same preference categories\n     */\n    public static function update_400001(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `preference` SET `preference`.`subcatagory` = 'library' WHERE `preference`.`name` in ('album_sort', 'show_played_times', 'album_group', 'album_release_type', 'album_release_type_sort', 'libitem_contextmenu', 'browse_filter', 'libitem_browse_alpha') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'backend' WHERE `preference`.`name` in ('subsonic_backend', 'daap_backend', 'daap_pass', 'upnp_backend', 'webdav_backend') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'catalog' WHERE `preference`.`name` = 'catalog_check_duplicate' AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'custom' WHERE `preference`.`name` in ('site_title', 'custom_logo', 'custom_login_logo', 'custom_favicon', 'custom_text_footer', 'custom_blankalbum', 'custom_blankmovie') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'feature' WHERE `preference`.`name` in ('download', 'allow_stream_playback', 'allow_democratic_playback', 'share', 'allow_video', 'geolocation') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'home' WHERE `preference`.`name` in ('now_playing_per_user', 'home_moment_albums', 'home_moment_videos', 'home_recently_played', 'home_now_playing') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'httpq' WHERE `preference`.`name` = 'httpq_active' AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'lastfm' WHERE `preference`.`name` in ('lastfm_grant_link', 'lastfm_challenge') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'localplay' WHERE `preference`.`name` in ('localplay_controller', 'localplay_level', 'allow_localplay_playback') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'metadata' WHERE `preference`.`name` in ('disabled_custom_metadata_fields', 'disabled_custom_metadata_fields_input') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'mpd' WHERE `preference`.`name` = 'mpd_active' AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'notification' WHERE `preference`.`name` in ('browser_notify', 'browser_notify_timeout') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'player' WHERE `preference`.`name` in ('show_lyrics', 'song_page_title', 'webplayer_flash', 'webplayer_html5', 'webplayer_confirmclose', 'webplayer_pausetabs', 'slideshow_time', 'broadcast_by_default', 'direct_play_limit', 'webplayer_aurora') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'podcast' WHERE `preference`.`name` in ('podcast_keep', 'podcast_new_download') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'privacy' WHERE `preference`.`name` in ('allow_personal_info_now', 'allow_personal_info_recent', 'allow_personal_info_time', 'allow_personal_info_agent') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'query' WHERE `preference`.`name` in ('popular_threshold', 'offset_limit', 'stats_threshold', 'concerts_limit_future', 'concerts_limit_past') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'share' WHERE `preference`.`name` = 'share_expire' AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'shoutcast' WHERE `preference`.`name` = 'shoutcast_active' AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'theme' WHERE `preference`.`name` in ('theme_name', 'ui_fixed', 'topmenu', 'theme_color', 'sidebar_light') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'transcoding' WHERE `preference`.`name` in ('transcode_bitrate', 'rate_limit', 'transcode') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'update' WHERE `preference`.`name` in ('autoupdate', 'autoupdate_lastcheck', 'autoupdate_lastversion', 'autoupdate_lastversion_new') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`subcatagory` = 'upload' WHERE `preference`.`name` in ('upload_catalog', 'allow_upload', 'upload_subdir', 'upload_user_artist', 'upload_script', 'upload_allow_edit', 'upload_allow_remove', 'upload_catalog_pattern') AND `preference`.`subcatagory` IS NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400002\n     *\n     * Update disk to allow 1 instead of making it 0 by default\n     * Add barcode catalog_number and original_year\n     * Drop catalog_number from song_data\n     */\n    public static function update_400002(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `album` SET `album`.`disk` = 1 WHERE `album`.`disk` = 0;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `album` ADD `original_year` INT(4) NULL, ADD `barcode` VARCHAR(64) NULL, ADD `catalog_number` VARCHAR(64) NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `song_data` DROP `catalog_number`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400003\n     *\n     * Make sure preference names are updated to current strings\n     */\n    public static function update_400003(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `preference` SET `preference`.`description` = 'Force HTTP playback regardless of port' WHERE `preference`.`name` = 'force_http_play' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Playback Type' WHERE `preference`.`name` = 'play_type' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'httpQ Active Instance' WHERE `preference`.`name` = 'httpq_active' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Now Playing filtered per user' WHERE `preference`.`name` = 'now_playing_per_user' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Use Subsonic backend' WHERE `preference`.`name` = 'subsonic_backend' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Share Now Playing information' WHERE `preference`.`name` = 'allow_personal_info_now' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Share Recently Played information' WHERE `preference`.`name` = 'allow_personal_info_recent' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Share Recently Played information - Allow access to streaming date/time' WHERE `preference`.`name` = 'allow_personal_info_time' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Share Recently Played information - Allow access to streaming agent' WHERE `preference`.`name` = 'allow_personal_info_agent' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Enable URL Rewriting' WHERE `preference`.`name` = 'stream_beautiful_url' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Destination catalog' WHERE `preference`.`name` = 'upload_catalog' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow user uploads' WHERE `preference`.`name` = 'allow_upload' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Create a subdirectory per user' WHERE `preference`.`name` = 'upload_subdir' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Consider the user sender as the track''s artist' WHERE `preference`.`name` = 'upload_user_artist' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Post-upload script (current directory = upload target directory)' WHERE `preference`.`name` = 'upload_script' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow users to edit uploaded songs' WHERE `preference`.`name` = 'upload_allow_edit' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow users to remove uploaded songs' WHERE `preference`.`name` = 'upload_allow_remove' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Show Albums of the Moment' WHERE `preference`.`name` = 'home_moment_albums' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Show Videos of the Moment' WHERE `preference`.`name` = 'home_moment_videos' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Custom URL - Logo' WHERE `preference`.`name` = 'custom_logo' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Custom URL - Login page logo' WHERE `preference`.`name` = 'custom_login_logo' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Custom URL - Favicon' WHERE `preference`.`name` = 'custom_favicon' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Album - Default sort' WHERE `preference`.`name` = 'album_sort' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow Geolocation' WHERE `preference`.`name` = 'Geolocation' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow Video Features' WHERE `preference`.`name` = 'allow_video' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Democratic - Clear votes for expired user sessions' WHERE `preference`.`name` = 'demo_clear_sessions' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow Transcoding' WHERE `preference`.`name` = 'transcoding' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Authorize Flash Web Player' WHERE `preference`.`name` = 'webplayer_flash' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Authorize HTML5 Web Player' WHERE `preference`.`name` = 'webplayer_html5' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Web Player browser notifications' WHERE `preference`.`name` = 'browser_notify' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Web Player browser notifications timeout (seconds)' WHERE `preference`.`name` = 'browser_notify_timeout' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Authorize JavaScript decoder (Aurora.js) in Web Player' WHERE `preference`.`name` = 'webplayer_aurora' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Show Now Playing' WHERE `preference`.`name` = 'home_now_playing' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Show Recently Played' WHERE `preference`.`name` = 'home_recently_played' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = '# latest episodes to keep' WHERE `preference`.`name` = 'podcast_keep' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = '# episodes to download when new episodes are available' WHERE `preference`.`name` = 'podcast_new_download' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow Transcoding' WHERE `preference`.`name` = 'transcode' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Allow E-mail notifications' WHERE `preference`.`name` = 'notify_email' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Custom metadata - Disable these fields' WHERE `preference`.`name` = 'disabled_custom_metadata_fields' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Custom metadata - Define field list' WHERE `preference`.`name` = 'disabled_custom_metadata_fields_input' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"UPDATE `preference` SET `preference`.`description` = 'Auto-pause between tabs' WHERE `preference`.`name` = 'webplayer_pausetabs' \";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400004\n     *\n     * delete upload_user_artist database settings\n     */\n    public static function update_400004(): bool\n    {\n        $retval = true;\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'upload_user_artist');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `preference` WHERE `preference`.`name` = 'upload_user_artist';\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400005\n     *\n     * Add a last_count to searches to speed up access requests\n     */\n    public static function update_400005(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `search` ADD `last_count` INT(11) NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400006\n     *\n     * drop shoutcast_active preferences and localplay_shoutcast table\n     */\n    public static function update_400006(): bool\n    {\n        $retval = true;\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` = 'shoutcast_active');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `preference` WHERE `preference`.`name` = 'shoutcast_active';\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DROP TABLE IF EXISTS `localplay_shoutcast`\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400007\n     *\n     * Add ui option for skip_count display\n     * Add ui option for displaying dates in a custom format\n     */\n    public static function update_400007(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('show_skipped_times', '0', 'Show # skipped', 25, 'boolean', 'interface', 'library')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('custom_datetime', '', 'Custom datetime', 25, 'string', 'interface', 'custom')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400008\n     *\n     * Add system option for cron based cache and create related tables\n     */\n    public static function update_400008(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('cron_cache', '0', 'Cache computed SQL data (eg. media hits stats) using a cron', 25, 'boolean', 'system', 'catalog')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $tables    = ['cache_object_count', 'cache_object_count_run'];\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        foreach ($tables as $table) {\n            $sql = \"CREATE TABLE IF NOT EXISTS `\" . $table . \"` (`object_id` int(11) unsigned NOT NULL, `object_type` enum('album', 'artist', 'song', 'playlist', 'genre', 'catalog', 'live_stream', 'video', 'podcast_episode') CHARACTER SET $charset NOT NULL, `count` int(11) unsigned NOT NULL DEFAULT '0', `threshold` int(11) unsigned NOT NULL DEFAULT '0', `count_type` varchar(16) NOT NULL, PRIMARY KEY (`object_id`, `object_type`, `threshold`, `count_type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n\n        $sql = \"UPDATE `preference` SET `level`=75 WHERE `preference`.`name`='stats_threshold'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400009\n     *\n     * Add ui option for forcing unique items to playlists\n     */\n    public static function update_400009(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('unique_playlist', '0', 'Only add unique items to playlists', 25, 'boolean', 'playlist', null)\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400010\n     *\n     * Add a last_duration to searches to speed up access requests\n     */\n    public static function update_400010(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `search` ADD `last_duration` INT(11) NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400011\n     *\n     * Allow negative track numbers for albums\n     * Truncate database tracks to 0 when greater than 32767\n     */\n    public static function update_400011(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `song` SET `track` = 0 WHERE `track` > 32767;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `song` MODIFY COLUMN `track` SMALLINT DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400012\n     *\n     * Add a rss token to use an RSS unauthenticated feed.\n     */\n    public static function update_400012(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `user` ADD `rsstoken` VARCHAR(255) NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400013\n     *\n     * Extend Democratic cooldown beyond 255.\n     */\n    public static function update_400013(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `democratic` MODIFY COLUMN `cooldown` int(11) unsigned DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400014\n     *\n     * Add last_duration to playlist\n     * Add time to artist and album\n     */\n    public static function update_400014(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `playlist` ADD COLUMN `last_duration` int(11) unsigned NOT NULL DEFAULT '0'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `album` ADD COLUMN `time` smallint(5) unsigned NOT NULL DEFAULT '0'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `artist` ADD COLUMN `time` smallint(5) unsigned NOT NULL DEFAULT '0'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    } //\n\n    /**\n     * update_400015\n     *\n     * Extend artist time. smallint was too small\n     */\n    public static function update_400015(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `artist` MODIFY COLUMN `time` int(11) unsigned DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400016\n     *\n     * Extend album and make artist even bigger. This should cover everyone.\n     */\n    public static function update_400016(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `album` MODIFY COLUMN `time` bigint(20) unsigned DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `artist` MODIFY COLUMN `time` int(11) unsigned DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400017\n     *\n     * Removed.\n     */\n    public static function update_400017(): bool\n    {\n        return true;\n    }\n\n    /**\n     * update_400018\n     *\n     * Extend video bitrate to unsigned. There's no reason for a negative bitrate.\n     */\n    public static function update_400018(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `video` SET `video_bitrate` = 0 WHERE `video_bitrate` < 0;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"ALTER TABLE `video` MODIFY COLUMN `video_bitrate` int(11) unsigned DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400019\n     *\n     * Put of_the_moment into a per user preference\n     */\n    public static function update_400019(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('of_the_moment', '6', 'Set the amount of items Album/Video of the Moment will display', 25, 'integer', 'interface', 'home')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '6')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400020\n     *\n     * Customizable login background image\n     */\n    public static function update_400020(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('custom_login_background', '', 'Custom URL - Login page background', 75, 'string', 'interface', 'custom')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400021\n     *\n     * Add r128 gain columns to song_data\n     */\n    public static function update_400021(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `song_data` ADD `r128_track_gain` smallint(5) DEFAULT NULL, ADD `r128_album_gain` smallint(5) DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400022\n     *\n     * Extend allowed time for podcast_episodes\n     */\n    public static function update_400022(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `podcast_episode` MODIFY COLUMN `time` int(11) unsigned DEFAULT 0 NOT NULL; \";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400023\n     *\n     * delete concerts_limit_past and concerts_limit_future database settings\n     */\n    public static function update_400023(): bool\n    {\n        $retval = true;\n\n        $sql = \"DELETE FROM `user_preference` WHERE `user_preference`.`preference` IN (SELECT `preference`.`id` FROM `preference` WHERE `preference`.`name` IN ('concerts_limit_past', 'concerts_limit_future'));\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"DELETE FROM `preference` WHERE `preference`.`name` IN ('concerts_limit_past', 'concerts_limit_future');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_400024\n     *\n     * Add song_count, album_count and album_group_count to artist\n     */\n    public static function update_400024(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `artist` ADD `song_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `artist` ADD `album_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `artist` ADD `album_group_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500000\n     *\n     * Delete duplicate files in the song table\n     */\n    public static function update_500000(): bool\n    {\n        $retval = true;\n        $sql    = \"DELETE `dupe` FROM `song` AS `dupe`, `song` AS `orig` WHERE `dupe`.`id` > `orig`.`id` AND `dupe`.`file` <=> `orig`.`file`;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500001\n     *\n     * Add `release_status`, `addition_time`, `catalog` to album table\n     * Add `mbid`, `country`, `active` to label table\n     * Fill the album `catalog` and `time` values using the song table\n     * Fill the artist `album_count`, `album_group_count` and `song_count` values\n     */\n    public static function update_500001(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `album` ADD `release_status` varchar(32) DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `album` ADD `addition_time` int(11) UNSIGNED DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `album` ADD `catalog` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `label` ADD `mbid` varchar(36) DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `label` ADD `country` varchar(64) DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `label` ADD `active` tinyint(1) UNSIGNED NOT NULL DEFAULT '1';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `album`, (SELECT min(`song`.`catalog`) AS `catalog`, `song`.`album` FROM `song` GROUP BY `song`.`album`) AS `song` SET `album`.`catalog` = `song`.`catalog` WHERE `album`.`catalog` != `song`.`catalog` AND `album`.`id` = `song`.`album`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `album`, (SELECT SUM(`song`.`time`) AS `time`, `song`.`album` FROM `song` GROUP BY `song`.`album`) AS `song` SET `album`.`time` = `song`.`time` WHERE `album`.`time` != `song`.`time` AND `album`.`id` = `song`.`album`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `album`, (SELECT MIN(`song`.`addition_time`) AS `addition_time`, `song`.`album` FROM `song` GROUP BY `song`.`album`) AS `song` SET `album`.`addition_time` = `song`.`addition_time` WHERE `album`.`addition_time` != `song`.`addition_time` AND `song`.`album` = `album`.`id`;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_500002\n     *\n     * Create `total_count` and `total_skip` to album, artist, song, video and podcast_episode tables\n     * Fill counts into the columns\n     */\n    public static function update_500002(): bool\n    {\n        $retval = true;\n        // tables which usually calculate a count\n        $tables = ['album', 'artist', 'song', 'video', 'podcast_episode'];\n        foreach ($tables as $type) {\n            $sql = \"ALTER TABLE `$type` ADD `total_count` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n            $retval &= (Dba::write($sql) !== false);\n            $sql = \"UPDATE `$type`, (SELECT COUNT(`object_count`.`object_id`) AS `total_count`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = '$type' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS `object_count` SET `$type`.`total_count` = `object_count`.`total_count` WHERE `$type`.`total_count` != `object_count`.`total_count` AND `$type`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n        }\n        // tables that also have a skip count\n        $tables = ['song', 'video', 'podcast_episode'];\n        foreach ($tables as $type) {\n            $sql = \"ALTER TABLE `$type` ADD `total_skip` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n            $retval &= (Dba::write($sql) !== false);\n            $sql = \"UPDATE `$type`, (SELECT COUNT(`object_count`.`object_id`) AS `total_skip`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = '$type' AND `object_count`.`count_type` = 'skip' GROUP BY `object_count`.`object_id`) AS `object_count` SET `$type`.`total_skip` = `object_count`.`total_skip` WHERE `$type`.`total_skip` != `object_count`.`total_skip` AND `$type`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * update_500003\n     *\n     * add `catalog` to podcast_episode table\n     */\n    public static function update_500003(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `podcast_episode` ADD `catalog` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `podcast_episode`, (SELECT min(`podcast`.`catalog`) AS `catalog`, `podcast`.`id` FROM `podcast` GROUP BY `podcast`.`id`) AS `podcast` SET `podcast_episode`.`catalog` = `podcast`.`catalog` WHERE `podcast_episode`.`catalog` != `podcast`.`catalog` AND `podcast_episode`.`podcast` = `podcast`.`id` AND `podcast`.`catalog` > 0;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_500004\n     *\n     * Create catalog_map table and fill it with data\n     */\n    public static function update_500004(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        // create the table\n        $sql = \"CREATE TABLE IF NOT EXISTS `catalog_map` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `catalog_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `unique_catalog_map` (`object_id`, `object_type`, `catalog_id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n        // fill the data\n        $tables = ['album', 'song', 'video', 'podcast_episode'];\n        foreach ($tables as $type) {\n            $sql = \"REPLACE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `$type`.`catalog`, '$type', `$type`.`id` FROM `$type` WHERE `$type`.`catalog` > 0;\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        // artist is a special one as it can be across multiple tables\n        $sql = \"REPLACE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `song`.`catalog`, 'artist', `artist`.`id` FROM `artist` LEFT JOIN `song` ON `song`.`artist` = `artist`.`id` WHERE `song`.`catalog` > 0;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"REPLACE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `album`.`catalog`, 'artist', `artist`.`id` FROM `artist` LEFT JOIN `album` ON `album`.`album_artist` = `artist`.`id` WHERE `album`.`catalog` > 0;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500005\n     *\n     * Add song_count, artist_count to album\n     */\n    public static function update_500005(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `album` ADD `song_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `album` ADD `artist_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"REPLACE INTO `update_info` SET `key`= 'album_group', `value`= (SELECT COUNT(DISTINCT(`album`.`id`)) AS `count` FROM `album` WHERE `id` in (SELECT MIN(`id`) FROM `album` GROUP BY `album`.`prefix`, `album`.`name`, `album`.`album_artist`, `album`.`release_type`, `album`.`release_status`, `album`.`mbid`, `album`.`year`, `album`.`original_year`, `album`.`mbid_group`));\";\n        Dba::write($sql);\n        $sql = \"UPDATE `album`, (SELECT COUNT(`song`.`id`) AS `song_count`, `album` FROM `song` LEFT JOIN `catalog` ON `catalog`.`id` = `song`.`catalog` WHERE `catalog`.`enabled` = '1' GROUP BY `album`) AS `song` SET `album`.`song_count` = `song`.`song_count` WHERE `album`.`song_count` != `song`.`song_count` AND `album`.`id` = `song`.`album`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `album`, (SELECT COUNT(DISTINCT(`song`.`artist`)) AS `artist_count`, `album` FROM `song` LEFT JOIN `catalog` ON `catalog`.`id` = `song`.`catalog` WHERE `catalog`.`enabled` = '1' GROUP BY `album`) AS `song` SET `album`.`artist_count` = `song`.`artist_count` WHERE `album`.`artist_count` != `song`.`artist_count` AND `album`.`id` = `song`.`album`;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_500006\n     *\n     * Add user_playlist table\n     */\n    public static function update_500006(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        $sql       = \"CREATE TABLE IF NOT EXISTS `user_playlist` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `user` int(11) DEFAULT NULL, `object_type` enum('song', 'live_stream', 'video', 'podcast_episode') CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `object_id` int(11) UNSIGNED NOT NULL DEFAULT '0', `track` smallint(6) DEFAULT NULL, `current_track` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, `current_time` smallint(5) UNSIGNED NOT NULL DEFAULT '0', PRIMARY KEY (`id`),KEY `user` (`user`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE TABLE IF NOT EXISTS `user_data` (`user` int(11) DEFAULT NULL, `key` varchar(128) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `value` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, KEY `user` (`user`), KEY `key` (`key`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500007\n     *\n     * Add a 'Browse' category to interface preferences\n     * Add ui option ('show_license') for hiding license column in song rows\n     */\n    public static function update_500007(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `preference` SET `preference`.`subcatagory` = 'browse' WHERE `preference`.`name` IN ('show_played_times', 'browse_filter', 'libitem_browse_alpha', 'show_skipped_times')\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('show_license', '1', 'Show License', 25, 'boolean', 'interface', 'browse')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500008\n     *\n     * Add filter_user to catalog table, set unique on user_data\n     */\n    public static function update_500008(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `catalog` ADD `filter_user` int(11) unsigned DEFAULT 0 NOT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        $tables = ['podcast', 'live_stream'];\n        foreach ($tables as $type) {\n            $sql = \"REPLACE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `$type`.`catalog`, '$type', `$type`.`id` FROM `$type` WHERE `$type`.`catalog` > 0;\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        $sql = \"ALTER TABLE `user_data` ADD UNIQUE `unique_data` (`user`, `key`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500009\n     *\n     * Add ui option ('use_original_year') Browse by Original Year for albums (falls back to Year)\n     */\n    public static function update_500009(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('use_original_year', '0', 'Browse by Original Year for albums (falls back to Year)', 25, 'boolean', 'interface', 'browse')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500010\n     *\n     * Add ui option ('hide_single_artist') Hide the Song Artist column for Albums with one Artist\n     */\n    public static function update_500010(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('hide_single_artist', '0', 'Hide the Song Artist column for Albums with one Artist', 25, 'boolean', 'interface', 'browse')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_500011\n     *\n     * Add `total_count` to podcast table and fill counts into the column\n     */\n    public static function update_500011(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `podcast` ADD `total_count` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `podcast`, (SELECT SUM(`podcast_episode`.`total_count`) AS `total_count`, `podcast` FROM `podcast_episode` GROUP BY `podcast_episode`.`podcast`) AS `object_count` SET `podcast`.`total_count` = `object_count`.`total_count` WHERE `podcast`.`total_count` != `object_count`.`total_count` AND `podcast`.`id` = `object_count`.`podcast`;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_500012\n     *\n     * Move user bandwidth calculations out of the user format function into the user_data table\n     */\n    public static function update_500012(): bool\n    {\n        $retval          = true;\n        $sql             = \"SELECT `id` FROM `user`\";\n        $db_users        = Dba::read($sql);\n        $user_list       = array();\n        while ($results  = Dba::fetch_assoc($db_users)) {\n            $user_list[] = (int)$results['id'];\n        }\n        // Calculate their total Bandwidth Usage\n        foreach ($user_list as $user_id) {\n            $params = array($user_id);\n            $total  = 0;\n            $sql_s  = \"SELECT SUM(`song`.`size`) AS `size` FROM `object_count` LEFT JOIN `song` ON `song`.`id`=`object_count`.`object_id` AND `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `object_count`.`user` = ?;\";\n            $db_s   = Dba::read($sql_s, $params);\n            while ($results  = Dba::fetch_assoc($db_s)) {\n                $total = $total + (int)$results['size'];\n            }\n            $sql_v = \"SELECT SUM(`video`.`size`) AS `size` FROM `object_count` LEFT JOIN `video` ON `video`.`id`=`object_count`.`object_id` AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_type` = 'video' AND `object_count`.`user` = ?;\";\n            $db_v  = Dba::read($sql_v, $params);\n            while ($results  = Dba::fetch_assoc($db_v)) {\n                $total = $total + (int)$results['size'];\n            }\n            $sql_p = \"SELECT SUM(`podcast_episode`.`size`) AS `size` FROM `object_count`LEFT JOIN `podcast_episode` ON `podcast_episode`.`id`=`object_count`.`object_id` AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_type` = 'podcast_episode' AND `object_count`.`user` = ?;\";\n            $db_p  = Dba::read($sql_p, $params);\n            while ($results  = Dba::fetch_assoc($db_p)) {\n                $total = $total + (int)$results['size'];\n            }\n            $retval &= (Dba::write(\"REPLACE INTO `user_data` SET `user`= ?, `key`= ?, `value`= ?;\", array($user_id, 'play_size', $total)) !== false);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * update_500013\n     *\n     * Add tables for tracking deleted files. (deleted_song, deleted_video, deleted_podcast_episode)\n     * Add username to the playlist table to stop pulling user all the time\n     */\n    public static function update_500013(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n        // deleted_song (id, addition_time, delete_time, title, file, catalog, total_count, total_skip, album, artist)\n        $sql = \"CREATE TABLE IF NOT EXISTS `deleted_song` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED DEFAULT '0', `delete_time` int(11) UNSIGNED DEFAULT '0', `title` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `file` varchar(4096) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL DEFAULT '0', `total_count` int(11) UNSIGNED NOT NULL DEFAULT '0', `total_skip` int(11) UNSIGNED NOT NULL DEFAULT '0', `update_time` int(11) UNSIGNED DEFAULT '0', `album` int(11) UNSIGNED NOT NULL DEFAULT '0', `artist` int(11) UNSIGNED NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // deleted_video (id, addition_time, delete_time, title, file, catalog, total_count, total_skip)\n        $sql = \"CREATE TABLE IF NOT EXISTS `deleted_video` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED NOT NULL, `delete_time` int(11) UNSIGNED NOT NULL, `title` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `file` varchar(4096) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL, `total_count` int(11) UNSIGNED NOT NULL DEFAULT '0', `total_skip` int(11) UNSIGNED NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // deleted_podcast_episode (id, addition_time, delete_time, title, file, catalog, total_count, total_skip, podcast)\n        $sql = \"CREATE TABLE IF NOT EXISTS `deleted_podcast_episode` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `addition_time` int(11) UNSIGNED NOT NULL, `delete_time` int(11) UNSIGNED NOT NULL, `title` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `file` varchar(4096) CHARACTER SET $charset COLLATE $collation DEFAULT NULL, `catalog` int(11) UNSIGNED NOT NULL, `total_count` int(11) UNSIGNED NOT NULL DEFAULT '0', `total_skip` int(11) UNSIGNED NOT NULL DEFAULT '0', `podcast` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // add username to playlist and searches to stop calling the objects all the time\n        $sql = \"ALTER TABLE `playlist` ADD `username` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `search` ADD `username` varchar(255) CHARACTER SET $charset COLLATE $collation DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // fill the data\n        $sql = \"UPDATE `playlist`, (SELECT `id`, `username` FROM `user`) AS `user` SET `playlist`.`username` = `user`.`username` WHERE `playlist`.`user` = `user`.`id`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `search`, (SELECT `id`, `username` FROM `user`) AS `user` SET `search`.`username` = `user`.`username` WHERE `search`.`user` = `user`.`id`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `playlist` SET `playlist`.`username` = ? WHERE `playlist`.`user` = -1;\";\n        Dba::write($sql, array(T_('System')));\n        $sql = \"UPDATE `search` SET `search`.`username` = ? WHERE `search`.`user` = -1;\";\n        Dba::write($sql, array(T_('System')));\n\n        return $retval;\n    }\n\n    /**\n     * update_500014\n     *\n     * Add `episodes` to podcast table to track episode count\n     */\n    public static function update_500014(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `podcast` ADD `episodes` int(11) UNSIGNED NOT NULL DEFAULT '0';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `podcast`, (SELECT COUNT(`podcast_episode`.`id`) AS `episodes`, `podcast` FROM `podcast_episode` GROUP BY `podcast_episode`.`podcast`) AS `episode_count` SET `podcast`.`episodes` = `episode_count`.`episodes` WHERE `podcast`.`episodes` != `episode_count`.`episodes` AND `podcast`.`id` = `episode_count`.`podcast`;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_500015\n     *\n     * Add ui option ('hide_genres') Hide the Genre column in browse table rows\n     */\n    public static function update_500015(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('hide_genres', '0', 'Hide the Genre column in browse table rows', 25, 'boolean', 'interface', 'browse')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_510000\n     *\n     * Add podcast to the object_count table\n     */\n    public static function update_510000(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `object_count` MODIFY COLUMN `object_type` enum('album', 'artist', 'song', 'playlist', 'genre', 'catalog', 'live_stream', 'video', 'podcast', 'podcast_episode');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_510001\n     *\n     * Add podcast to the cache_object_count tables\n     */\n    public static function update_510001(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `cache_object_count_run` MODIFY COLUMN `object_type` enum('album', 'artist', 'song', 'playlist', 'genre', 'catalog', 'live_stream', 'video', 'podcast', 'podcast_episode');\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `cache_object_count` MODIFY COLUMN `object_type` enum('album', 'artist', 'song', 'playlist', 'genre', 'catalog', 'live_stream', 'video', 'podcast', 'podcast_episode');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_510002\n     *\n     * Removed.\n     */\n    public static function update_510002(): bool\n    {\n        return true;\n    }\n\n    /**\n     * update_510003\n     *\n     * Add live_stream to the rating table\n     */\n    public static function update_510003(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `rating` MODIFY COLUMN `object_type` enum('artist', 'album', 'song', 'stream', 'live_stream', 'video', 'playlist', 'tvshow', 'tvshow_season', 'podcast', 'podcast_episode');\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_510004\n     *\n     * Add waveform column to podcast_episode table\n     */\n    public static function update_510004(): bool\n    {\n        $retval = true;\n\n        $sql = \"ALTER TABLE `podcast_episode` ADD COLUMN `waveform` mediumblob DEFAULT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_510005\n     *\n     * Add ui option ('subsonic_always_download') Force Subsonic streams to download. (Enable scrobble in your client to record stats)\n     */\n    public static function update_510005(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('subsonic_always_download', '0', 'Force Subsonic streams to download. (Enable scrobble in your client to record stats)', 25, 'boolean', 'options', 'subsonic')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520000\n     *\n     * Add ui options ('api_enable_3', 'api_enable_4', 'api_enable_5') to enable/disable specific API versions\n     * Add ui option ('api_force_version') to force a specific API response (even if that version is disabled)\n     */\n    public static function update_520000(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_enable_3', '1', 'Enable API3 responses', 25, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_enable_4', '1', 'Enable API4 responses', 25, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_enable_5', '1', 'Enable API5 responses', 25, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_force_version', '0', 'Force a specific API response (even if that version is disabled)', 25, 'special', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520001\n     *\n     * Make sure preference names are always unique\n     */\n    public static function update_520001(): bool\n    {\n        $sql             = \"SELECT `id` FROM `preference` WHERE `name` IN (SELECT `name` FROM `preference` GROUP BY `name` HAVING count(`name`) >1) AND `id` NOT IN (SELECT MIN(`id`) FROM `preference` GROUP by `name`);\";\n        $dupe_prefs      = Dba::read($sql);\n        $pref_list       = array();\n        while ($results  = Dba::fetch_assoc($dupe_prefs)) {\n            $pref_list[] = (int)$results['id'];\n        }\n        // delete duplicates (if they exist)\n        foreach ($pref_list as $pref_id) {\n            $sql    = \"DELETE FROM `preference` WHERE `id` = ?;\";\n            Dba::write($sql, array($pref_id));\n        }\n        $sql    = \"DELETE FROM `user_preference` WHERE `preference` NOT IN (SELECT `id` FROM `preference`);\";\n        Dba::write($sql);\n        $sql    = \"ALTER TABLE `preference` ADD CONSTRAINT preference_UN UNIQUE KEY (`name`);\";\n        $retval = (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520002\n     *\n     * Add ui option ('show_playlist_username') Show playlist owner username in titles\n     */\n    public static function update_520002(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('show_playlist_username', '1', 'Show playlist owner username in titles', 25, 'boolean', 'interface', 'browse')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520003\n     *\n     * Add ui option ('api_hidden_playlists') Hide playlists in Subsonic and API clients that start with this string\n     */\n    public static function update_520003(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_hidden_playlists', '', 'Hide playlists in Subsonic and API clients that start with this string', 25, 'string', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520004\n     *\n     * Set 'plugins' category to lastfm_challenge preference\n     */\n    public static function update_520004(): bool\n    {\n        $retval = true;\n        $sql    = \"UPDATE `preference` SET `preference`.`catagory` = 'plugins' WHERE `preference`.`name` = 'lastfm_challenge'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_520005\n     *\n     * Add ui option ('api_hide_dupe_searches') Hide smartlists that match playlist names in Subsonic and API clients\n     */\n    public static function update_520005(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('api_hide_dupe_searches', '0', 'Hide smartlists that match playlist names in Subsonic and API clients', 25, 'boolean', 'options')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530000\n     *\n     * Create artist_map table and fill it with data\n     */\n    public static function update_530000(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = 'MyISAM';\n        // create the table\n        $sql = \"CREATE TABLE IF NOT EXISTS `artist_map` (`artist_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, UNIQUE KEY `unique_artist_map` (`object_id`, `object_type`, `artist_id`), INDEX `object_id_index` (`object_id`), INDEX `artist_id_index` (`artist_id`), INDEX `artist_id_type_index` (`artist_id`, `object_type`), INDEX `object_id_type_index` (`object_id`, `object_type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n        // fill the data\n        $sql = \"INSERT IGNORE INTO `artist_map` (`artist_id`, `object_type`, `object_id`) SELECT DISTINCT `song`.`artist` AS `artist_id`, 'song', `song`.`id` FROM `song` WHERE `song`.`artist` > 0 UNION SELECT DISTINCT `album`.`album_artist` AS `artist_id`, 'album', `album`.`id` FROM `album` WHERE `album`.`album_artist` > 0;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530001\n     *\n     * Create album_map table and fill it with data\n     */\n    public static function update_530001(): bool\n    {\n        $retval    = true;\n        $collation = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset   = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine    = 'MyISAM';\n        // create the table\n        $sql = \"CREATE TABLE IF NOT EXISTS `album_map` (`album_id` int(11) UNSIGNED NOT NULL, `object_id` int(11) UNSIGNED NOT NULL, `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, UNIQUE KEY `unique_album_map` (`object_id`, `object_type`, `album_id`), INDEX `object_id_index` (`object_id`), INDEX `album_id_type_index` (`album_id`, `object_type`), INDEX `object_id_type_index` (`object_id`, `object_type`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n        // fill the data\n        $sql = \"INSERT IGNORE INTO `album_map` (`album_id`, `object_type`, `object_id`)  SELECT DISTINCT `artist_map`.`object_id` AS `album_id`, 'album' AS `object_type`, `artist_map`.`artist_id` AS `object_id` FROM `artist_map` WHERE `artist_map`.`object_type` = 'album' AND `artist_map`.`object_id` IS NOT NULL UNION SELECT DISTINCT `song`.`album` AS `album_id`, 'song' AS `object_type`, `song`.`artist` AS `object_id` FROM `song` WHERE `song`.`album` IS NOT NULL UNION SELECT DISTINCT `song`.`album` AS `album_id`, 'song' AS `object_type`, `artist_map`.`artist_id` AS `object_id` FROM `artist_map` LEFT JOIN `song` ON `artist_map`.`object_type` = 'song' AND `artist_map`.`object_id` = `song`.`id` WHERE `song`.`album` IS NOT NULL AND `artist_map`.`object_type` = 'song';\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530002\n     *\n     * Use song_count & artist_count with album_map\n     */\n    public static function update_530002(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `album` ADD `song_artist_count` smallint(5) unsigned DEFAULT 0 NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `album`, (SELECT COUNT(`song`.`id`) AS `song_count`, `album` FROM `song` LEFT JOIN `catalog` ON `catalog`.`id` = `song`.`catalog` WHERE `catalog`.`enabled` = '1' GROUP BY `album`) AS `song` SET `album`.`song_count` = `song`.`song_count` WHERE `album`.`song_count` != `song`.`song_count` AND `album`.`id` = `song`.`album`;\";\n        Dba::write($sql);\n        $sql = \"UPDATE `album`, (SELECT COUNT(DISTINCT(`album_map`.`object_id`)) AS `artist_count`, `album_id` FROM `album_map` LEFT JOIN `album` ON `album`.`id` = `album_map`.`album_id` LEFT JOIN `catalog` ON `catalog`.`id` = `album`.`catalog` WHERE `album_map`.`object_type` = 'song' AND `catalog`.`enabled` = '1' GROUP BY `album_id`) AS `album_map` SET `album`.`song_artist_count` = `album_map`.`artist_count` WHERE `album`.`id` = `album_map`.`album_id`;\";\n        Dba::write($sql);\n\n        return $retval;\n    }\n\n    /**\n     * update_530003\n     *\n     * Drop id column from catalog_map\n     * Alter `catalog_map` object_type charset and collation\n     */\n    public static function update_530003(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `catalog_map` DROP COLUMN `id`;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `catalog_map` MODIFY COLUMN object_type varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530004\n     *\n     * Alter `album_map` charset and engine to MyISAM if engine set\n     */\n    public static function update_530004(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `album_map` ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `album_map` MODIFY COLUMN `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530005\n     *\n     * Alter `artist_map` charset and engine to MyISAM if engine set\n     */\n    public static function update_530005(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `artist_map` ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `artist_map` MODIFY COLUMN `object_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530006\n     *\n     * Make sure the object_count table has all the correct primary artist/album rows\n     */\n    public static function update_530006(): bool\n    {\n        $retval = true;\n        $sql    = \"INSERT INTO `object_count` (object_type, object_id, `date`, `user`, agent, geo_latitude, geo_longitude, geo_name, count_type) SELECT 'album', `song`.`album`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `song` ON `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` = `song`.`id` LEFT JOIN `object_count` AS `album_count` ON `album_count`.`object_type` = 'album' AND `object_count`.`date` = `album_count`.`date` AND `object_count`.`user` = `album_count`.`user` AND `object_count`.`agent` = `album_count`.`agent` AND `object_count`.`count_type` = `album_count`.`count_type` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `album_count`.`id` IS NULL AND `song`.`album` IS NOT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"INSERT INTO `object_count` (object_type, object_id, `date`, `user`, agent, geo_latitude, geo_longitude, geo_name, count_type) SELECT 'artist', `song`.`artist`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `song` ON `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` = `song`.`id` LEFT JOIN `object_count` AS `artist_count` ON `artist_count`.`object_type` = 'artist' AND `object_count`.`date` = `artist_count`.`date` AND `object_count`.`user` = `artist_count`.`user` AND `object_count`.`agent` = `artist_count`.`agent` AND `object_count`.`count_type` = `artist_count`.`count_type` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `artist_count`.`id` IS NULL AND `song`.`artist` IS NOT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530007\n     *\n     * Convert basic text columns into utf8/utf8_unicode_ci\n     */\n    public static function update_530007(): bool\n    {\n        $retval = true;\n        Dba::write(\"UPDATE `album` SET `mbid` = NULL WHERE CHAR_LENGTH(`mbid`) > 36;\");\n        Dba::write(\"UPDATE `album` SET `mbid_group` = NULL WHERE CHAR_LENGTH(`mbid`) > 36;\");\n\n        $retval &= (Dba::write(\"ALTER TABLE `album` MODIFY COLUMN `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `album` MODIFY COLUMN `mbid_group` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `object_count` MODIFY COLUMN `object_type` enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `rating` MODIFY COLUMN `object_type` enum('artist','album','song','stream','video','playlist','tvshow','tvshow_season','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_flag` MODIFY COLUMN `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_shout` MODIFY COLUMN `object_type` varchar(32) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `video` MODIFY COLUMN `mode` enum('abr','vbr','cbr') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530008\n     *\n     * Remove `user_activity` columns that are useless\n     */\n    public static function update_530008(): bool\n    {\n        $retval = true;\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `name_track`;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `name_artist`;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `name_album`;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `mbid_track`;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `mbid_artist`;\") !== false);\n        $retval &= (Dba::write(\"ALTER TABLE `user_activity` DROP COLUMN `mbid_album`;\") !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530009\n     *\n     * Compact `object_count` columns\n     */\n    public static function update_530009(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `object_count` MODIFY COLUMN `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `object_count` MODIFY COLUMN `agent` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `object_count` MODIFY COLUMN `geo_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530010\n     *\n     * Compact mbid columns back to 36 characters\n     */\n    public static function update_530010(): bool\n    {\n        $retval = true;\n        Dba::write(\"UPDATE `artist` SET `mbid` = NULL WHERE CHAR_LENGTH(`mbid`) > 36;\");\n        Dba::write(\"UPDATE `recommendation_item` SET `mbid` = NULL WHERE CHAR_LENGTH(`mbid`) > 36;\");\n        $sql    = \"ALTER TABLE `artist` MODIFY COLUMN `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `recommendation_item` MODIFY COLUMN `mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `song_preview` MODIFY COLUMN `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `wanted` MODIFY COLUMN `artist_mbid` varchar(36) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530011\n     *\n     * Compact `user` columns and enum `object_count`.`count_type`\n     */\n    public static function update_530011(): bool\n    {\n        $retval     = true;\n        $collation  = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset    = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $rsstoken   = false;\n        $sql        = \"DESCRIBE `user`\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            if ($row['Field'] == 'rsstoken') {\n                $rsstoken = true;\n            }\n        }\n        if (!$rsstoken) {\n            $sql = \"ALTER TABLE `user` ADD `rsstoken` VARCHAR(255) NULL;\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        $sql = \"ALTER TABLE `user` MODIFY COLUMN `rsstoken` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user` MODIFY COLUMN `validation` varchar(128) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user` MODIFY COLUMN `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user` MODIFY COLUMN `apikey` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `user` MODIFY COLUMN `username` varchar(128) CHARACTER SET $charset COLLATE $collation DEFAULT NULL NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530012\n     *\n     * Index data on object_count\n     */\n    public static function update_530012(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `object_count` DROP KEY `object_count_full_index`;\";\n        Dba::write($sql);\n        $sql = \"ALTER TABLE `object_count` DROP KEY `object_count_type_IDX`;\";\n        Dba::write($sql);\n        $sql = \"ALTER TABLE `object_count` DROP KEY `object_count_date_IDX`;\";\n        Dba::write($sql);\n        $sql = \"ALTER TABLE `object_count` DROP KEY `object_count_user_IDX`;\";\n        Dba::write($sql);\n        $sql = \"ALTER TABLE `object_count` DROP KEY `object_count_unique`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `object_count_full_index` USING BTREE ON `object_count` (`object_type`, `object_id`, `date`, `user`, `agent`, `count_type`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE INDEX `object_count_type_IDX` USING BTREE ON `object_count` (`object_type`, `object_id`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE INDEX `object_count_date_IDX` USING BTREE ON `object_count` (`date`, `count_type`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"CREATE INDEX `object_count_user_IDX` USING BTREE ON `object_count` (`object_type`, `object_id`, `user`, `count_type`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530013\n     *\n     * Compact `cache_object_count`, `cache_object_count_run` columns\n     */\n    public static function update_530013(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `cache_object_count` MODIFY COLUMN `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `cache_object_count_run` MODIFY COLUMN `count_type` enum('download','stream','skip') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530014\n     *\n     * Use a smaller unique index on `object_count`\n     */\n    public static function update_530014(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `object_count` DROP KEY `object_count_UNIQUE_IDX`;\";\n        Dba::write($sql);\n        // delete duplicates and make sure they're gone\n        $sql = \"DELETE FROM `object_count` WHERE `id` IN (SELECT `id` FROM (SELECT `id` FROM `object_count` WHERE `object_id` IN (SELECT `object_id` FROM `object_count` GROUP BY `object_type`, `object_id`, `date`, `user`, `agent`, `count_type` HAVING COUNT(`object_id`) > 1) AND `id` NOT IN (SELECT MIN(`id`) FROM `object_count` GROUP BY `object_type`, `object_id`, `date`, `user`, `agent`, `count_type`)) AS `count`);\";\n        Dba::write($sql);\n        $sql = \"CREATE UNIQUE INDEX `object_count_UNIQUE_IDX` USING BTREE ON `object_count` (`object_type`, `object_id`, `date`, `user`, `agent`, `count_type`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530015\n     *\n     * Add `show_album_artist` and `show_artist` preferences to show/hide Sidebar Browse menu links. (Fallback to Album Artist if both disabled)\n     */\n    public static function update_530015(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('show_album_artist', '1', 'Show \\'Album Artists\\' link in the main sidebar', 25, 'boolean', 'interface', 'theme')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '1')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`, `subcatagory`) VALUES ('show_artist', '0', 'Show \\'Artists\\' link in the main sidebar', 25, 'boolean', 'interface', 'theme')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_530016\n     *\n     * Missing type compared to previous version\n     */\n    public static function update_530016(): bool\n    {\n        return (Dba::write(\"ALTER TABLE `rating` MODIFY COLUMN `object_type` enum('artist','album','song','stream','live_stream','video','playlist','tvshow','tvshow_season','podcast','podcast_episode') CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL;\") !== false);\n    }\n\n    /**\n     * update_540000\n     *\n     * Index `title` with `enabled` on `song` table to speed up searching\n     */\n    public static function update_540000(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `song` DROP KEY `title_enabled_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `title_enabled_IDX` USING BTREE ON `song` (`title`, `enabled`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_540001\n     *\n     * Index album tables. `catalog`, `album_artist`, `original_year`, `release_type`, `release_status`, `mbid`, `mbid_group`\n     */\n    public static function update_540001(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `album` DROP KEY `catalog_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `catalog_IDX` USING BTREE ON `album` (`catalog`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `album_artist_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `album_artist_IDX` USING BTREE ON `album` (`album_artist`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `original_year_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `original_year_IDX` USING BTREE ON `album` (`original_year`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `release_type_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `release_type_IDX` USING BTREE ON `album` (`release_type`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `release_status_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `release_status_IDX` USING BTREE ON `album` (`release_status`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `mbid_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `mbid_IDX` USING BTREE ON `album` (`mbid`);\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql    = \"ALTER TABLE `album` DROP KEY `mbid_group_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `mbid_group_IDX` USING BTREE ON `album` (`mbid_group`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /**\n     * update_540002\n     *\n     * Index `object_type` with `date` in `object_count` table\n     */\n    public static function update_540002(): bool\n    {\n        $retval = true;\n        $sql    = \"ALTER TABLE `object_count` DROP KEY `object_type_date_IDX`;\";\n        Dba::write($sql);\n        $sql = \"CREATE INDEX `object_type_date_IDX` USING BTREE ON `object_count` (`object_type`, `date`);\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /** update_550001\n     *\n     * Add tables `catalog_filter_group` and `catalog_filter_group_map` for catalog filtering by groups\n     * Add column `catalog_filter_group` to `user` table to assign a filter group\n     * Create a DEFAULT group\n     */\n    public static function update_550001(): bool\n    {\n        $retval     = true;\n        $collation  = (AmpConfig::get('database_collation', 'utf8mb4_unicode_ci'));\n        $charset    = (AmpConfig::get('database_charset', 'utf8mb4'));\n        $engine     = ($charset == 'utf8mb4') ? 'InnoDB' : 'MYISAM';\n\n        // Add the new catalog_filter_group table\n        $sql = \"CREATE TABLE IF NOT EXISTS `catalog_filter_group` (`id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Add the default group (autoincrement starts at 1 so force it to be 0)\n        $sql = \"INSERT IGNORE INTO `catalog_filter_group` (`name`) VALUES ('DEFAULT');\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"UPDATE `catalog_filter_group` SET `id` = 0 WHERE `name` = 'DEFAULT';\";\n        $retval &= (Dba::write($sql) !== false);\n        $sql = \"ALTER TABLE `catalog_filter_group` AUTO_INCREMENT = 1;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Add the new catalog_filter_group_map table\n        $sql = \"CREATE TABLE IF NOT EXISTS `catalog_filter_group_map` (`group_id` int(11) UNSIGNED NOT NULL, `catalog_id` int(11) UNSIGNED NOT NULL, `enabled` tinyint(1) UNSIGNED NOT NULL DEFAULT 0, UNIQUE KEY (group_id,catalog_id)) ENGINE=$engine DEFAULT CHARSET=$charset COLLATE=$collation;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        // Add the default access group to the user table\n        $sql = \"ALTER TABLE `user` ADD `catalog_filter_group` INT(11) UNSIGNED NOT NULL DEFAULT 0;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /** update_550002\n     *\n     * Migrate catalog `filter_user` settings to catalog_filter groups\n     * Assign all public catalogs to the DEFAULT group\n     * Drop table `user_catalog`\n     * Remove `filter_user` from the `catalog` table\n     */\n    public static function update_550002(): bool\n    {\n        $retval = true;\n\n        // Copy existing filters into individual groups for each user. (if a user only has access to public catalogs they are given the default list)\n        $sql        = \"SELECT `id`, `username` FROM `user`;\";\n        $db_results = Dba::read($sql);\n        $user_list  = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $user_list[$row['id']] = $row['username'];\n        }\n        // If the user had a private catalog, create an individual group for them using the current filter and public catalogs.\n        foreach ($user_list as $key => $value) {\n            $group_id   = 0;\n            $sql        = 'SELECT `filter_user` FROM `catalog` WHERE `filter_user` = ?;';\n            $db_results = Dba::read($sql, array($key));\n            if (Dba::num_rows($db_results)) {\n                $sql = \"INSERT IGNORE INTO `catalog_filter_group` (`name`) VALUES ('\" . Dba::escape($value) . \"');\";\n                Dba::write($sql);\n                $group_id = (int)Dba::insert_id();\n            }\n            if ($group_id > 0) {\n                $sql        = \"SELECT `id`, `filter_user` FROM `catalog`;\";\n                $db_results = Dba::read($sql);\n                while ($row = Dba::fetch_assoc($db_results)) {\n                    $catalog = $row['id'];\n                    $enabled = ($row['filter_user'] == 0 || $row['filter_user'] == $key)\n                        ? 1\n                        : 0;\n                    $sql = \"INSERT IGNORE INTO `catalog_filter_group_map` (`group_id`, `catalog_id`, `enabled`) VALUES ($group_id, $catalog, $enabled);\";\n                    $retval &= (Dba::write($sql) !== false);\n                }\n                $sql = \"UPDATE `user` SET `catalog_filter_group` = ? WHERE `id` = ?\";\n                Dba::write($sql, array($group_id, $key));\n            }\n        }\n\n        // Add all public catalogs in the DEFAULT profile.\n        $sql        = \"SELECT `id` FROM `catalog` WHERE `filter_user` = 0;\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $catalog = (int)$row['id'];\n            $sql     = \"INSERT IGNORE INTO `catalog_filter_group_map` (`group_id`, `catalog_id`, `enabled`) VALUES (0, $catalog, 1);\";\n            $retval &= (Dba::write($sql) !== false);\n        }\n        $sql = \"DROP TABLE IF EXISTS `user_catalog`;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        if ($retval) {\n            // Drop filter_user but only if the migration has worked\n            $sql = \"ALTER TABLE `catalog` DROP COLUMN `filter_user`;\";\n            Dba::write($sql);\n        }\n\n        return $retval;\n    }\n\n    /** update_550003\n     *\n     * Add system preference `demo_use_search`, Use smartlists for base playlist in Democratic play\n     */\n    public static function update_550003(): bool\n    {\n        $retval = true;\n\n        $sql = \"INSERT INTO `preference` (`name`, `value`, `description`, `level`, `type`, `catagory`) VALUES ('demo_use_search', '0', 'Democratic - Use smartlists for base playlist', 25, 'boolean', 'playlist')\";\n        $retval &= (Dba::write($sql) !== false);\n        $row_id = Dba::insert_id();\n        $sql    = \"INSERT INTO `user_preference` VALUES (-1, ?, '0')\";\n        $retval &= (Dba::write($sql, array($row_id)) !== false);\n\n        return $retval;\n    }\n\n    /** update_550004\n     *\n     * Make `demo_use_search`a system preference correctly\n     */\n    public static function update_550004(): bool\n    {\n        $retval = true;\n\n        // Update previous update preference\n        $sql = \"UPDATE `preference` SET `catagory`='system' WHERE `name`='demo_use_search'\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n\n    /** update_550005\n     *\n     * Add `song_artist` and `album_artist` maps to catalog_map\n     */\n    public static function update_550005(): bool\n    {\n        $retval = true;\n\n        // delete bad maps if they exist\n        $tables = ['album', 'song', 'video', 'podcast', 'podcast_episode', 'live_stream'];\n        foreach ($tables as $type) {\n            $sql = \"DELETE FROM `catalog_map` USING `catalog_map` LEFT JOIN (SELECT DISTINCT `$type`.`catalog` AS `catalog_id`, '$type' AS `map_type`, `$type`.`id` AS `object_id` FROM `$type` GROUP BY `$type`.`catalog`, `map_type`, `$type`.`id`) AS `valid_maps` ON `valid_maps`.`catalog_id` = `catalog_map`.`catalog_id` AND `valid_maps`.`object_id` = `catalog_map`.`object_id` AND `valid_maps`.`map_type` = `catalog_map`.`object_type` WHERE `catalog_map`.`object_type` = '$type' AND `valid_maps`.`object_id` IS NULL;\";\n            Dba::write($sql);\n        }\n        // delete catalog_map artists\n        $sql = \"DELETE FROM `catalog_map` USING `catalog_map` LEFT JOIN (SELECT DISTINCT `song`.`catalog` AS `catalog_id`, 'artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `song` INNER JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `album`.`catalog` AS `catalog_id`, 'artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `album` INNER JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `song`.`catalog` AS `catalog_id`, 'song_artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `song` INNER JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `album`.`catalog` AS `catalog_id`, 'album_artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `album` INNER JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`object_type` IS NOT NULL GROUP BY `album`.`catalog`, `artist_map`.`object_type`, `artist_map`.`artist_id`) AS `valid_maps` ON `valid_maps`.`catalog_id` = `catalog_map`.`catalog_id` AND `valid_maps`.`object_id` = `catalog_map`.`object_id` AND `valid_maps`.`map_type` = `catalog_map`.`object_type` WHERE `catalog_map`.`object_type` IN ('artist', 'song_artist', 'album_artist') AND `valid_maps`.`object_id` IS NULL;\";\n        Dba::write($sql);\n        // insert catalog_map artists\n        $sql = \"INSERT IGNORE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT DISTINCT `song`.`catalog` AS `catalog_id`, 'artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `album`.`catalog` AS `catalog_id`, 'artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `song`.`catalog` AS `catalog_id`, 'song_artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`object_type` IS NOT NULL UNION SELECT DISTINCT `album`.`catalog` AS `catalog_id`, 'album_artist' AS `map_type`, `artist_map`.`artist_id` AS `object_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`object_type` IS NOT NULL GROUP BY `catalog`, `artist_map`.`object_type`, `artist_map`.`artist_id`;\";\n        $retval &= (Dba::write($sql) !== false);\n\n        return $retval;\n    }\n} // end update.class\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Repository\\Model;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\Art\\Collector\\MetaTagCollectorModule;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\System\\Session;\nuse Ampache\\Module\\Util\\ObjectTypeToClassNameMapper;\nuse Ampache\\Module\\Util\\Ui;\nuse Ampache\\Module\\Api\\Ajax;\nuse Ampache\\Module\\Util\\UtilityFactoryInterface;\nuse Ampache\\Module\\Util\\InterfaceImplementationChecker;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Repository\\SongRepositoryInterface;\nuse Exception;\nuse getID3;\nuse PDOStatement;\nuse Requests;\nuse RuntimeException;\n\n/**\n * This class handles the images / artwork in ampache\n * This was initially in the album class, but was pulled out\n * to be more general and potentially apply to albums, artists, movies etc\n */\nclass Art extends database_object\n{\n    protected const DB_TABLENAME = 'art';\n    public const VALID_TYPES     = array('bmp', 'gif', 'jp2', 'jpeg', 'jpg', 'png', 'webp');\n\n    /**\n     * @var integer $id\n     */\n    public $id;\n    /**\n     * @var string $type\n     */\n    public $type;\n    /**\n     * @var integer $uid\n     */\n    public $uid; // UID of the object not ID because it's not the ART.ID\n    /**\n     * @var string $raw\n     */\n    public $raw; // Raw art data\n    /**\n     * @var string $raw_mime\n     */\n    public $raw_mime;\n    /**\n     * @var string $kind\n     */\n    public $kind;\n\n    /**\n     * @var string $thumb\n     */\n    public $thumb;\n    /**\n     * @var string $thumb_mime\n     */\n    public $thumb_mime;\n\n    /**\n     * Constructor\n     * Art constructor, takes the UID of the object and the\n     * object type.\n     * @param integer $uid\n     * @param string $type\n     * @param string $kind\n     */\n    public function __construct($uid, $type = 'album', $kind = 'default')\n    {\n        if (Art::is_valid_type($type)) {\n            $this->type = $type;\n            $this->uid  = (int)($uid);\n            $this->kind = $kind;\n        }\n    } // constructor\n\n    public function getId(): int\n    {\n        return (int)$this->id;\n    }\n\n    /**\n     * @param string $type\n     * @return boolean\n     */\n    public static function is_valid_type($type)\n    {\n        if (!$type) {\n            return false;\n        }\n\n        return (InterfaceImplementationChecker::is_library_item($type) || $type == 'user');\n    }\n\n    /**\n     * build_cache\n     * This attempts to reduce # of queries by asking for everything in the\n     * browse all at once and storing it in the cache, this can help if the\n     * db connection is the slow point\n     * @param integer[] $object_ids\n     * @param string $type\n     * @return boolean\n     */\n    public static function build_cache($object_ids, $type = null)\n    {\n        if (empty($object_ids)) {\n            return false;\n        }\n        $idlist = '(' . implode(',', $object_ids) . ')';\n        $sql    = \"SELECT `object_type`, `object_id`, `mime`, `size` FROM `image` WHERE `object_id` IN $idlist\";\n        if ($type !== null) {\n            $sql .= \" AND `object_type` = '$type'\";\n        }\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            parent::add_to_cache('art', $row['object_type'] . $row['object_id'] . $row['size'], $row);\n        }\n\n        return true;\n    } // build_cache\n\n    /**\n     * extension\n     * This returns the file extension for the currently loaded art\n     * @param string $mime\n     * @return string\n     */\n    public static function extension($mime)\n    {\n        if (empty($mime)) {\n            return '';\n        }\n        $data      = explode('/', $mime);\n        $extension = $data['1'] ?? '';\n\n        if ($extension == 'jpeg') {\n            $extension = 'jpg';\n        }\n\n        return (string)$extension;\n    } // extension\n\n    /**\n     * test_image\n     * Runs some sanity checks on the putative image\n     * @param string $source\n     * @return boolean\n     * @throws RuntimeException\n     */\n    public static function test_image($source)\n    {\n        if (strlen((string) $source) < 10) {\n            debug_event(self::class, 'Invalid image passed', 1);\n\n            return false;\n        }\n        $max_upload_size = (int)AmpConfig::get('max_upload_size', 0);\n\n        // Check image size doesn't exceed the limit\n        if ($max_upload_size > 0 && strlen((string) $source) > $max_upload_size) {\n            debug_event(self::class, 'Image size (' . strlen((string) $source) . ') exceed the limit (' . $max_upload_size . ').', 1);\n\n            return false;\n        }\n\n        // Check to make sure PHP:GD exists. Don't test things you can't change\n        if (!function_exists('imagecreatefromstring')) {\n            return true;\n        }\n\n        $test  = false;\n        $image = false;\n        if (is_string($source)) {\n            $test  = true;\n            $image = imagecreatefromstring($source);\n            if ($image == false || imagesx($image) < 5 || imagesy($image) < 5) {\n                debug_event(self::class, 'Image failed PHP-GD test', 1);\n                $test = false;\n            }\n        }\n        if ($test && $image != false) {\n            if (imagedestroy($image) === false) {\n                throw new RuntimeException('The image handle from source: ' . $source . ' could not be destroyed');\n            }\n        }\n\n        return $test;\n    } // test_image\n\n    /**\n     * get\n     * This returns the art for our current object, this can\n     * look in the database and will return the thumb if it\n     * exists, if it doesn't depending on settings it will try\n     * to create it.\n     * @param boolean $raw\n     * @param boolean $fallback\n     * @return string\n     */\n    public function get($raw = false, $fallback = false)\n    {\n        // Get the data either way (allow forcing to fallback image)\n        if (!$this->has_db_info($fallback)) {\n            return '';\n        }\n\n        if ($raw || !$this->thumb) {\n            return $this->raw;\n        } else {\n            return $this->thumb;\n        }\n    } // get\n\n    /**\n     * has_db_info\n     * This pulls the information out from the database, depending\n     * on if we want to resize and if there is not a thumbnail go\n     * ahead and try to resize\n     * @return boolean\n     */\n    public function has_db_info($fallback = false)\n    {\n        $sql         = \"SELECT `id`, `image`, `mime`, `size` FROM `image` WHERE `object_type` = ? AND `object_id` = ? AND `kind` = ?\";\n        $db_results  = Dba::read($sql, array($this->type, $this->uid, $this->kind));\n        $default_art = false;\n\n        while ($results = Dba::fetch_assoc($db_results)) {\n            if ($results['size'] == 'original') {\n                if (AmpConfig::get('album_art_store_disk')) {\n                    $this->raw = self::read_from_dir($results['size'], $this->type, $this->uid, $this->kind, $results['mime']);\n                } else {\n                    $this->raw = $results['image'];\n                }\n                $this->raw_mime = $results['mime'];\n            } elseif (AmpConfig::get('resize_images')) {\n                if (AmpConfig::get('album_art_store_disk')) {\n                    $this->thumb = self::read_from_dir($results['size'], $this->type, $this->uid, $this->kind, $results['mime']);\n                } elseif ($results['size'] == '275x275') {\n                    $this->thumb = $results['image'];\n                }\n                $this->raw_mime = $results['mime'];\n            }\n            $this->id = (int)$results['id'];\n        }\n        // return a default image if fallback is requested\n        if (!$this->raw && $fallback) {\n            $this->raw      = self::read_from_images();\n            $this->raw_mime = 'image/png';\n            $default_art    = true;\n        }\n        // If we get nothing return false\n        if (!$this->raw) {\n            return false;\n        }\n\n        // If there is no thumb and we want thumbs\n        if (!$this->thumb && AmpConfig::get('resize_images')) {\n            $size = array('width' => 275, 'height' => 275);\n            $data = $this->generate_thumb($this->raw, $size, $this->raw_mime);\n            // If it works save it!\n            if (!empty($data)) {\n                if (!$default_art) {\n                    $this->save_thumb($data['thumb'], $data['thumb_mime'], $size);\n                }\n                $this->thumb      = $data['thumb'];\n                $this->thumb_mime = $data['thumb_mime'];\n            } else {\n                debug_event(self::class, 'Art id {' . $this->id . '} Unable to generate thumbnail for ' . $this->type . ': ' . $this->uid, 1);\n            }\n        } // if no thumb, but art and we want to resize\n\n        return true;\n    } // has_db_info\n\n    /**\n     * This check if an object has an associated image in db.\n     * @param integer $object_id\n     * @param string $object_type\n     * @param string $kind\n     * @return boolean\n     */\n    public static function has_db($object_id, $object_type, $kind = 'default')\n    {\n        $sql        = \"SELECT COUNT(`id`) AS `nb_img` FROM `image` WHERE `object_type` = ? AND `object_id` = ? AND `kind` = ?\";\n        $db_results = Dba::read($sql, array($object_type, $object_id, $kind));\n        $nb_img     = 0;\n        if ($results = Dba::fetch_assoc($db_results)) {\n            $nb_img = $results['nb_img'];\n        }\n\n        return ($nb_img > 0);\n    }\n\n    /**\n     * This insert art from url.\n     * @param string $url\n     */\n    public function insert_url($url)\n    {\n        debug_event(self::class, 'Insert art from url ' . $url, 4);\n        $image = self::get_from_source(array('url' => $url), $this->type);\n        $rurl  = pathinfo($url);\n        $mime  = \"image/\" . $rurl['extension'];\n        $this->insert($image, $mime);\n    }\n\n    /**\n     * insert\n     * This takes the string representation of an image and inserts it into\n     * the database. You must also pass the mime type.\n     * @param string $source\n     * @param string $mime\n     * @return boolean\n     */\n    public function insert($source, $mime = '')\n    {\n        // Disabled in demo mode cause people suck and upload porn\n        if (AmpConfig::get('demo_mode')) {\n            return false;\n        }\n\n        // Check to make sure we like this image\n        if (!self::test_image($source)) {\n            debug_event(self::class, 'Not inserting image for ' . $this->type . ' ' . $this->uid . ', invalid data passed', 1);\n\n            return false;\n        }\n\n        $dimensions = Core::image_dimensions($source);\n        $width      = (int)($dimensions['width']);\n        $height     = (int)($dimensions['height']);\n        $sizetext   = 'original';\n\n        if (!self::check_dimensions($dimensions)) {\n            return false;\n        }\n\n        // Default to image/jpeg if they don't pass anything\n        $mime = $mime ?? 'image/jpeg';\n        // Blow it away!\n        $this->reset();\n        $current_picturetypeid = ($this->type == 'album') ? 3 : 8;\n\n        if (AmpConfig::get('write_tags', false)) {\n            $class_name = ObjectTypeToClassNameMapper::map($this->type);\n            $object     = new $class_name($this->uid);\n            $songs      = array();\n            debug_event(__CLASS__, 'Inserting ' . $this->type . ' image' . $object->name . ' for song files.', 5);\n            if ($this->type === 'album') {\n                /** Use special treatment for albums */\n                $songs = $this->getSongRepository()->getByAlbum($object->id);\n            } elseif ($this->type === 'artist') {\n                /** Use special treatment for artists */\n                $songs = $this->getSongRepository()->getByArtist($object->id);\n            }\n            global $dic;\n            $utilityFactory = $dic->get(UtilityFactoryInterface::class);\n\n            foreach ($songs as $song_id) {\n                $song   = new Song($song_id);\n                $song->format();\n                $description = ($this->type == 'artist') ? $song->f_artist_full : $object->full_name;\n                $vainfo      = $utilityFactory->createVaInfo(\n                    $song->file\n                );\n\n                $ndata      = array();\n                $data       = $vainfo->read_id3();\n                $fileformat = $data['fileformat'];\n                if ($fileformat == 'flac' || $fileformat == 'ogg') {\n                    $apics = $data['flac']['PICTURE'];\n                } else {\n                    $apics = $data['id3v2']['APIC'];\n                }\n                /* is the file flac or mp3? */\n                $apic_typeid   = ($fileformat == 'flac' || $fileformat == 'ogg') ? 'typeid' : 'picturetypeid';\n                $apic_mimetype = ($fileformat == 'flac' || $fileformat == 'ogg') ? 'image_mime' : 'mime';\n                $new_pic       = array(\n                    'data' => $source,\n                    'mime' => $mime,\n                    'picturetypeid' => $current_picturetypeid,\n                    'description' => $description\n                );\n\n                if (is_null($apics)) {\n                    $ndata['attached_picture'][]    = $new_pic;\n                } else {\n                    switch (count($apics)) {\n                        case 1:\n                            $idx = $this->check_for_duplicate($apics, $ndata, $new_pic, $apic_typeid);\n                            if (is_null($idx)) {\n                                $ndata['attached_picture'][] = $new_pic;\n                                $ndata['attached_picture'][] = array(\n                                    'data' => $apics[0]['data'],\n                                    'description' => $apics[0]['description'],\n                                    'mime' => $apics[0]['mime'],\n                                    'picturetypeid' => $apics[0]['picturetypeid']\n                                );\n                            }\n                            break;\n                        case 2:\n                            $idx = $this->check_for_duplicate($apics, $ndata, $new_pic, $apic_typeid);\n                            /* If $idx is null, it means both images are of opposite types\n                             * of the new image. Either image could be replaced to have\n                             * one cover and one artist image.\n                             */\n                            if (is_null($idx)) {\n                                $ndata['attached_picture'][0] = $new_pic;\n                            } else {\n                                $apicsId                              = ($idx == 0) ? 1 : 0;\n                                $ndata['attached_picture'][$apicsId]  = array(\n                                    'data' => $apics[$apicsId]['data'],\n                                    'mime' => $apics[$apicsId][$apic_mimetype],\n                                    'picturetypeid' => $apics[$apicsId][$apic_typeid],\n                                    'description' => $apics[$apicsId]['description']\n                                );\n                            }\n\n                            break;\n                    }\n                }\n                unset($apics);\n                $tags    = ($fileformat == 'flac' || $fileformat == 'ogg') ? 'vorbiscomment' : 'id3v2';\n                $ndata   = array_merge($ndata, $vainfo->prepare_metadata_for_writing($data['tags'][$tags]));\n                $vainfo->write_id3($ndata);\n            } // foreach song\n        } // write_id3\n\n        if (AmpConfig::get('album_art_store_disk')) {\n            self::write_to_dir($source, $sizetext, $this->type, $this->uid, $this->kind, $mime);\n            $source = null;\n        }\n        // Insert it!\n        $sql = \"INSERT INTO `image` (`image`, `mime`, `size`, `width`, `height`, `object_type`, `object_id`, `kind`) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\";\n        Dba::write($sql, array($source, $mime, $sizetext, $width, $height, $this->type, $this->uid, $this->kind));\n\n        return true;\n    } // insert\n\n    /**\n     * check_for_duplicate\n     * @param array $apics\n     * @param array $ndata\n     * @param array $new_pic\n     * @param string $apic_typeid\n     * @return int|null\n     */\n    private function check_for_duplicate($apics, &$ndata, $new_pic, $apic_typeid)\n    {\n        $idx = null;\n        $cnt = count($apics);\n        for ($i=0; $i < $cnt; $i++) {\n            if ($new_pic['picturetypeid'] == $apics[$i][$apic_typeid]) {\n                $ndata['attached_picture'][$i]['description']       = $new_pic['description'];\n                $ndata['attached_picture'][$i]['data']              = $new_pic['data'];\n                $ndata['attached_picture'][$i]['mime']              = $new_pic['mime'];\n                $ndata['attached_picture'][$i]['picturetypeid']     = $new_pic['picturetypeid'];\n                $idx                                                = $i;\n                break;\n            }\n        }\n\n        return $idx;\n    }\n\n    /**\n     * Prepares images to be written to file tag.\n     * @param array $pics\n     * @return array\n     */\n    public static function prepare_pics($pics)\n    {\n        $ndata = array();\n        $i     = 0;\n        foreach ($pics as $pic) {\n            $ndata['attached_picture'][$i]['description']   = $pic['description'];\n            $ndata['attached_picture'][$i]['data']          = $pic['data'];\n            $ndata['attached_picture'][$i]['picturetypeid'] = $pic['picturetypeid'];\n            $ndata['attached_picture'][$i]['mime']          = $pic['mime'];\n\n            $i++;\n        }\n\n        return $ndata;\n    }\n\n    /**\n     * check_dimensions\n     * @param array $dimensions\n     * @return boolean\n     */\n    public static function check_dimensions($dimensions)\n    {\n        $width  = (int)($dimensions['width']);\n        $height = (int)($dimensions['height']);\n\n        if ($width > 0 && $height > 0) {\n            $minw = AmpConfig::get('album_art_min_width', 0);\n            $maxw = AmpConfig::get('album_art_max_width', 0);\n            $minh = AmpConfig::get('album_art_min_height', 0);\n            $maxh = AmpConfig::get('album_art_max_height', 0);\n\n            // minimum width is set and current width is too low\n            if ($minw > 0 && $width < $minw) {\n                debug_event(self::class, \"Image width not in range (min=$minw, max=$maxw, current=$width).\", 1);\n\n                return false;\n            }\n            // max width is set and current width is too high\n            if ($maxw > 0 && $width > $maxw) {\n                debug_event(self::class, \"Image width not in range (min=$minw, max=$maxw, current=$width).\", 1);\n\n                return false;\n            }\n            if ($minh > 0 && $height < $minh) {\n                debug_event(self::class, \"Image height not in range (min=$minh, max=$maxh, current=$height).\", 1);\n\n                return false;\n            }\n            if ($maxh > 0 && $height > $maxh) {\n                debug_event(self::class, \"Image height not in range (min=$minh, max=$maxh, current=$height).\", 1);\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * clear_image\n     * Clear the image column (if you have the image on disk)\n     */\n    public static function clear_image($image_id)\n    {\n        $sql = \"UPDATE `image` SET `image` = NULL WHERE `id` = ?\";\n        Dba::write($sql, array($image_id));\n    } // clear_image\n\n    /**\n     * get_dir_on_disk\n     * @param string $type\n     * @param string $uid\n     * @param string $kind\n     * @param boolean $autocreate\n     * @return false|string\n     */\n    public static function get_dir_on_disk($type, $uid, $kind = '', $autocreate = false)\n    {\n        $path = AmpConfig::get('local_metadata_dir');\n        if (!$path) {\n            debug_event(self::class, 'local_metadata_dir setting is required to store art on disk.', 1);\n\n            return false;\n        }\n\n        // Correctly detect the slash we need to use here\n        if (strpos($path, '/') !== false) {\n            $slash_type = '/';\n        } else {\n            $slash_type = '\\\\';\n        }\n\n        $path .= $slash_type . $type;\n        if ($autocreate && !Core::is_readable($path)) {\n            mkdir($path);\n        }\n\n        $path .= $slash_type . $uid;\n        if ($autocreate && !Core::is_readable($path)) {\n            mkdir($path);\n        }\n\n        if (!empty($kind)) {\n            $path .= $slash_type . $kind;\n            if ($autocreate && !Core::is_readable($path)) {\n                mkdir($path);\n            }\n        }\n        $path .= $slash_type;\n\n        return $path;\n    }\n\n    /**\n     * write_to_dir\n     * @param string $source\n     * @param string $sizetext\n     * @param string $type\n     * @param integer $uid\n     * @param $kind\n     * @param $mime\n     * @return boolean\n     */\n    private static function write_to_dir($source, $sizetext, $type, $uid, $kind, $mime)\n    {\n        $path = self::get_dir_on_disk($type, $uid, $kind, true);\n        if ($path === false) {\n            return false;\n        }\n        $path .= \"art-\" . $sizetext . \".\" . self::extension($mime);\n        if (Core::is_readable($path)) {\n            unlink($path);\n        }\n        $filepath = fopen($path, \"wb\");\n        fwrite($filepath, $source);\n        fclose($filepath);\n\n        return true;\n    }\n\n    /**\n     * read_from_images\n     */\n    private static function read_from_images()\n    {\n        $path = __DIR__ . '/../../../public/images/blankalbum.png';\n        if (!Core::is_readable($path)) {\n            debug_event(self::class, 'read_from_images ' . $path . ' cannot be read.', 1);\n\n            return null;\n        }\n\n        $image    = '';\n        $filepath = fopen($path, \"rb\");\n        do {\n            $image .= fread($filepath, 2048);\n        } while (!feof($filepath));\n        fclose($filepath);\n\n        return $image;\n    }\n\n    /**\n     * read_from_dir\n     * @param $sizetext\n     * @param string $type\n     * @param integer $uid\n     * @param string $kind\n     * @param $mime\n     * @return string|null\n     */\n    private static function read_from_dir($sizetext, $type, $uid, $kind, $mime)\n    {\n        $path = self::get_dir_on_disk($type, $uid, $kind);\n        if ($path === false) {\n            return null;\n        }\n        $path .= \"art-\" . $sizetext . '.' . self::extension($mime);\n        if (!Core::is_readable($path)) {\n            debug_event(self::class, 'Local image art ' . $path . ' cannot be read.', 1);\n\n            return null;\n        }\n\n        $image    = '';\n        $filepath = fopen($path, \"rb\");\n        do {\n            $image .= fread($filepath, 2048);\n        } while (!feof($filepath));\n        fclose($filepath);\n\n        return $image;\n    }\n\n    /**\n     * delete_from_dir\n     * @param string $type\n     * @param string $uid\n     * @param string $kind\n     */\n    private static function delete_from_dir($type, $uid, $kind = '')\n    {\n        if ($type && $uid) {\n            $path = self::get_dir_on_disk($type, $uid, $kind);\n            if ($path !== false) {\n                self::delete_rec_dir(rtrim($path, '/'));\n            }\n        }\n    }\n\n    /**\n     * delete_rec_dir\n     * @param string $path\n     */\n    private static function delete_rec_dir($path)\n    {\n        debug_event(self::class, 'Deleting ' . (string) $path . ' directory...', 5);\n\n        if (Core::is_readable($path)) {\n            foreach (scandir($path) as $file) {\n                if ('.' === $file || '..' === $file) {\n                    continue;\n                } elseif (is_dir($path . '/' . $file)) {\n                    self::delete_rec_dir(rtrim($path, '/') . '/' . $file);\n                } else {\n                    unlink($path . '/' . $file);\n                }\n            }\n            rmdir($path);\n        }\n    }\n\n    /**\n     * reset\n     * This resets the art in the database\n     */\n    public function reset()\n    {\n        if (AmpConfig::get('album_art_store_disk')) {\n            self::delete_from_dir($this->type, $this->uid, $this->kind);\n        }\n        $sql = \"DELETE FROM `image` WHERE `object_id` = ? AND `object_type` = ? AND `kind` = ?\";\n        Dba::write($sql, array($this->uid, $this->type, $this->kind));\n    } // reset\n\n    /**\n     * save_thumb\n     * This saves the thumbnail that we're passed\n     * @param string $source\n     * @param string $mime\n     * @param array $size\n     * @return boolean\n     */\n    public function save_thumb($source, $mime, $size)\n    {\n        // Quick sanity check\n        if (!self::test_image($source)) {\n            debug_event(self::class, 'Not inserting thumbnail, invalid data passed', 1);\n\n            return false;\n        }\n\n        $width    = $size['width'];\n        $height   = $size['height'];\n        $sizetext = $width . 'x' . $height;\n\n        $sql = \"DELETE FROM `image` WHERE `object_id` = ? AND `object_type` = ? AND `size` = ? AND `kind` = ?\";\n        Dba::write($sql, array($this->uid, $this->type, $sizetext, $this->kind));\n\n        if (AmpConfig::get('album_art_store_disk')) {\n            self::write_to_dir($source, $sizetext, $this->type, $this->uid, $this->kind, $mime);\n            $source = null;\n        }\n        $sql = \"INSERT INTO `image` (`image`, `mime`, `size`, `width`, `height`, `object_type`, `object_id`, `kind`) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\";\n        Dba::write($sql, array($source, $mime, $sizetext, $width, $height, $this->type, $this->uid, $this->kind));\n\n        return true;\n    } // save_thumb\n\n    /**\n     * get_thumb\n     * Returns the specified resized image.  If the requested size doesn't\n     * already exist, create and cache it.\n     * @param array $size\n     * @return array\n     */\n    public function get_thumb($size)\n    {\n        $sizetext   = $size['width'] . 'x' . $size['height'];\n        $sql        = \"SELECT `image`, `mime` FROM `image` WHERE `size` = ? AND `object_type` = ? AND `object_id` = ? AND `kind` = ?\";\n        $db_results = Dba::read($sql, array($sizetext, $this->type, $this->uid, $this->kind));\n\n        $results = Dba::fetch_assoc($db_results);\n        if (count($results)) {\n            if (AmpConfig::get('album_art_store_disk')) {\n                $image = self::read_from_dir($sizetext, $this->type, $this->uid, $this->kind, $results['mime']);\n            } else {\n                $image = $results['image'];\n            }\n\n            if ($image != null) {\n                return array(\n                    'thumb' => (AmpConfig::get('album_art_store_disk'))\n                        ? self::read_from_dir($sizetext, $this->type, $this->uid, $this->kind, $results['mime'])\n                        : $results['image'],\n                    'thumb_mime' => $results['mime']\n                );\n            } else {\n                debug_event(self::class, 'Thumb entry found in database but associated data cannot be found.', 3);\n            }\n        }\n\n        // If we didn't get a result try again\n        $results = array();\n        if (!$this->raw && $this->thumb) {\n            $results = $this->generate_thumb($this->thumb, $size, $this->raw_mime);\n        }\n        if ($this->raw) {\n            $results = $this->generate_thumb($this->raw, $size, $this->raw_mime);\n        }\n        if (!empty($results)) {\n            $this->save_thumb($results['thumb'], $results['thumb_mime'], $size);\n        }\n\n        return $results;\n    } // get_thumb\n\n    /**\n     * generate_thumb\n     * Automatically resizes the image for thumbnail viewing.\n     * Only works on gif/jpg/png/bmp. Fails if PHP-GD isn't available\n     * or lacks support for the requested image type.\n     * @param string $image\n     * @param array $size\n     * @param string $mime\n     * @return array\n     */\n    public function generate_thumb($image, $size, $mime)\n    {\n        $data = explode('/', (string) $mime);\n        $type = ((string)($data[1] ?? '') !== '') ? strtolower((string) $data[1]) : 'jpg';\n\n        if (!self::test_image($image)) {\n            debug_event(self::class, 'Not trying to generate thumbnail, invalid data passed', 1);\n\n            return array();\n        }\n\n        if (!function_exists('gd_info')) {\n            debug_event(self::class, 'PHP-GD Not found - unable to resize art', 1);\n\n            return array();\n        }\n\n        // Check and make sure we can resize what you've asked us to\n        if (($type == 'jpg' || $type == 'jpeg' || $type == 'jpg?v=2') && !(imagetypes() & IMG_JPG)) {\n            debug_event(self::class, 'PHP-GD Does not support JPGs - unable to resize', 1);\n\n            return array();\n        }\n        if ($type == 'png' && !imagetypes() & IMG_PNG) {\n            debug_event(self::class, 'PHP-GD Does not support PNGs - unable to resize', 1);\n\n            return array();\n        }\n        if ($type == 'gif' && !imagetypes() & IMG_GIF) {\n            debug_event(self::class, 'PHP-GD Does not support GIFs - unable to resize', 1);\n\n            return array();\n        }\n        if ($type == 'bmp' && !imagetypes() & IMG_WBMP) {\n            debug_event(self::class, 'PHP-GD Does not support BMPs - unable to resize', 1);\n\n            return array();\n        }\n\n        $source = imagecreatefromstring($image);\n\n        if (!$source) {\n            debug_event(self::class, 'Failed to create Image from string - Source Image is damaged / malformed', 2);\n\n            return array();\n        }\n\n        $source_size = array('height' => imagesy($source), 'width' => imagesx($source));\n\n        // Create a new blank image of the correct size\n        $thumbnail = imagecreatetruecolor((int) $size['width'], (int) $size['height']);\n\n        if ($source_size['width'] > $source_size['height']) {\n            // landscape\n            $new_height = $size['height'];\n            $new_width  = floor($source_size['width'] * ($new_height / $source_size['height']));\n            $crop_x     = ceil(($source_size['width'] - $source_size['height']) / 2);\n            $crop_y     = 0;\n        } elseif ($source_size['height'] > $source_size['width']) {\n            // portrait\n            $new_width  = $size['width'];\n            $new_height = floor($source_size['height'] * ($new_width / $source_size['width']));\n            $crop_x     = 0;\n            $crop_y     = ceil(($source_size['height'] - $source_size['width']) / 3); // assuming most portrait images would have faces closer to the top\n        } else {\n            // square\n            $new_width  = $size['width'];\n            $new_height = $size['height'];\n            $crop_x     = 0;\n            $crop_y     = 0;\n        }\n\n        if (!imagecopyresampled($thumbnail, $source, 0, 0, $crop_x, $crop_y, $new_width, $new_height, $source_size['width'], $source_size['height'])) {\n            debug_event(self::class, 'Unable to create resized image', 1);\n            imagedestroy($source);\n            imagedestroy($thumbnail);\n\n            return array();\n        }\n        imagedestroy($source);\n\n        // Start output buffer\n        ob_start();\n\n        // Generate the image to our OB\n        switch ($type) {\n            case 'jpg':\n            case 'jpeg':\n            case 'jpg?v=2':\n            case '(null)':\n                imagejpeg($thumbnail, null, 75);\n                $mime_type = image_type_to_mime_type(IMAGETYPE_JPEG);\n                break;\n            case 'gif':\n                imagegif($thumbnail);\n                $mime_type = image_type_to_mime_type(IMAGETYPE_GIF);\n                break;\n            // Turn bmps into pngs\n            case 'bmp':\n            case 'png':\n                imagepng($thumbnail);\n                $mime_type = image_type_to_mime_type(IMAGETYPE_PNG);\n                break;\n            case 'webp':\n                imagewebp($thumbnail);\n                $mime_type = image_type_to_mime_type(IMAGETYPE_WEBP);\n                break;\n            default:\n                $mime_type = null;\n        } // resized\n\n        if ($mime_type === null) {\n            debug_event(self::class, 'Error: No mime type found using: ' . $mime, 2);\n\n            return array();\n        }\n\n        $data = ob_get_contents();\n        ob_end_clean();\n\n        imagedestroy($thumbnail);\n\n        if (!strlen((string) $data)) {\n            debug_event(self::class, 'Unknown Error resizing art', 1);\n\n            return array();\n        }\n\n        return array('thumb' => $data, 'thumb_mime' => $mime_type);\n    } // generate_thumb\n\n    /**\n     * get_from_source\n     * This gets an image for the album art from a source as\n     * defined in the passed array. Because we don't know where\n     * it's coming from we are a passed an array that can look like\n     * ['url']      = URL *** OPTIONAL ***\n     * ['file']     = FILENAME *** OPTIONAL ***\n     * ['raw']      = Actual Image data, already captured\n     * @param array $data\n     * @param string $type\n     * @return string\n     */\n    public static function get_from_source($data, $type)\n    {\n        if (!isset($type)) {\n            $type = (AmpConfig::get('show_song_art')) ? 'song' : 'album';\n        }\n        if (empty($data) || !is_array($data)) {\n            return '';\n        }\n\n        // Already have the data, this often comes from id3tags\n        if (isset($data['raw'])) {\n            return $data['raw'];\n        }\n\n        // If it came from the database\n        if (isset($data['db'])) {\n            $sql        = \"SELECT * FROM `image` WHERE `object_type` = ? AND `object_id` = ? AND `size`='original'\";\n            $db_results = Dba::read($sql, array($type, $data['db']));\n            $row        = Dba::fetch_assoc($db_results);\n\n            return $row['art'];\n        } // came from the db\n\n        // Check to see if it's a URL\n        if (array_key_exists('url', $data) && filter_var($data['url'], FILTER_VALIDATE_URL)) {\n            debug_event(self::class, 'CHECKING URL ' . $data['url'], 2);\n            $options = array();\n            try {\n                $options['timeout'] = 10;\n                Requests::register_autoloader();\n                $request = Requests::get($data['url'], array(), Core::requests_options($options));\n                $raw     = $request->body;\n            } catch (Exception $error) {\n                debug_event(self::class, 'Error getting art: ' . $error->getMessage(), 2);\n                $raw = '';\n            }\n\n            return $raw;\n        }\n\n        // Check to see if it's a FILE\n        if (isset($data['file'])) {\n            $handle     = fopen($data['file'], 'rb');\n            $image_data = (string)fread($handle, Core::get_filesize($data['file']));\n            fclose($handle);\n\n            return $image_data;\n        }\n\n        // Check to see if it is embedded in id3 of a song\n        if (isset($data['song'])) {\n            // If we find a good one, stop looking\n            $getID3 = new getID3();\n            $id3    = $getID3->analyze($data['song']);\n\n            if (isset($id3['asf']['extended_content_description_object']['content_descriptors']['13'])) {\n                return $id3['asf']['extended_content_description_object']['content_descriptors']['13'];\n            }\n\n            if (isset($id3['id3v2']['APIC'])) {\n                // Foreach in case they have more than one\n                foreach ($id3['id3v2']['APIC'] as $image) {\n                    if (isset($image['picturetypeid']) && array_key_exists('data', $image)) {\n                        if ($data['title'] == MetaTagCollectorModule::getPictureType((int)$image['picturetypeid'])) {\n                            return $image['data'];\n                        }\n                    }\n                }\n            }\n\n            if (isset($id3['id3v2']['PIC'])) {\n                // Foreach in case they have more than one\n                foreach ($id3['id3v2']['PIC'] as $image) {\n                    if (isset($image['picturetypeid']) && array_key_exists('data', $image)) {\n                        if ($data['title'] == MetaTagCollectorModule::getPictureType((int)$image['picturetypeid'])) {\n                            return $image['data'];\n                        }\n                    }\n                }\n            }\n\n            if (isset($id3['flac']['PICTURE'])) {\n                // Foreach in case they have more than one\n                foreach ($id3['flac']['PICTURE'] as $image) {\n                    if (isset($image['typeid']) && array_key_exists('data', $image)) {\n                        $title = 'ID3 ' . MetaTagCollectorModule::getPictureType((int)$image['typeid']);\n                        if ($data['title'] == $title) {\n                            return $image['data'];\n                        }\n                    }\n                }\n            }\n\n            if (isset($id3['comments']['picture'])) {\n                // Foreach in case they have more than one\n                foreach ($id3['comments']['picture'] as $image) {\n                    if (isset($image['picturetype']) && array_key_exists('data', $image)) {\n                        if ($data['title'] == 'ID3 ' . $image['picturetype']) {\n                            return $image['data'];\n                        }\n                    }\n                    if (isset($image['description']) && array_key_exists('data', $image)) {\n                        if ($data['title'] == 'ID3 ' . $image['description']) {\n                            return $image['data'];\n                        }\n                    }\n                }\n            }\n        } // if data song\n\n        return '';\n    } // get_from_source\n\n    /**\n     * url\n     * This returns the constructed URL for the art in question\n     * @param integer $uid\n     * @param string $type\n     * @param string $sid\n     * @param integer|null $thumb\n     * @return string\n     */\n    public static function url($uid, $type, $sid = null, $thumb = null)\n    {\n        if (!self::is_valid_type($type)) {\n            return null;\n        }\n\n        if (AmpConfig::get('use_auth') && AmpConfig::get('require_session')) {\n            $sid = $sid ? scrub_out($sid) : scrub_out(session_id());\n            if ($sid == null) {\n                $sid = Session::create(array(\n                    'type' => 'api'\n                ));\n            }\n        } else {\n            $sid = 'none';\n        }\n\n        $key = $type . $uid;\n\n        if (parent::is_cached('art', $key . '275x275') && AmpConfig::get('resize_images')) {\n            $row  = parent::get_from_cache('art', $key . '275x275');\n            $mime = $row['mime'];\n        }\n        if (parent::is_cached('art', $key . 'original')) {\n            $row        = parent::get_from_cache('art', $key . 'original');\n            $thumb_mime = $row['mime'];\n        }\n        if (!isset($mime) && !isset($thumb_mime)) {\n            $sql        = \"SELECT `object_type`, `object_id`, `mime`, `size` FROM `image` WHERE `object_type` = ? AND `object_id` = ?\";\n            $db_results = Dba::read($sql, array($type, $uid));\n\n            while ($row = Dba::fetch_assoc($db_results)) {\n                parent::add_to_cache('art', $key . $row['size'], $row);\n                if ($row['size'] == 'original') {\n                    $mime = $row['mime'];\n                } else {\n                    if ($row['size'] == '275x275' && AmpConfig::get('resize_images')) {\n                        $thumb_mime = $row['mime'];\n                    }\n                }\n            }\n        }\n\n        $mime      = $thumb_mime ?? ($mime ?? null);\n        $extension = self::extension($mime);\n\n        if (AmpConfig::get('stream_beautiful_url')) {\n            if (empty($extension)) {\n                $extension = 'jpg';\n            }\n            $url = AmpConfig::get('web_path') . '/play/art/' . $sid . '/' . scrub_out($type) . '/' . scrub_out($uid) . '/thumb';\n            if ($thumb !== null) {\n                $url .= $thumb;\n            }\n            $url .= '.' . $extension;\n        } else {\n            $url = AmpConfig::get('web_path') . '/image.php?object_id=' . scrub_out($uid) . '&object_type=' . scrub_out($type) . '&auth=' . $sid;\n            if ($thumb !== null) {\n                $url .= '&thumb=' . $thumb;\n            }\n            if (!empty($extension)) {\n                $name = 'art.' . $extension;\n                $url .= '&name=' . $name;\n            }\n        }\n\n        return $url;\n    } // url\n\n    /**\n     * garbage_collection\n     * This cleans up art that no longer has a corresponding object\n     * @param string $object_type\n     * @param integer $object_id\n     */\n    public static function garbage_collection($object_type = null, $object_id = null)\n    {\n        $types = array(\n            'album',\n            'artist',\n            'tvshow',\n            'tvshow_season',\n            'video',\n            'user',\n            'live_stream',\n            'playlist',\n            'song'\n        );\n\n        if ($object_type !== null) {\n            if (in_array($object_type, $types)) {\n                if (AmpConfig::get('album_art_store_disk')) {\n                    self::delete_from_dir($object_type, $object_id);\n                }\n                $sql = \"DELETE FROM `image` WHERE `object_type` = ? AND `object_id` = ?\";\n                Dba::write($sql, array($object_type, $object_id));\n            } else {\n                debug_event(self::class, 'Garbage collect on type `' . $object_type . '` is not supported.', 1);\n            }\n        } else {\n            $album_art_store_disk = AmpConfig::get('album_art_store_disk');\n            // iterate over our types and delete the images\n            foreach ($types as $type) {\n                if ($album_art_store_disk) {\n                    $sql        = \"SELECT `image`.`object_id`, `image`.`object_type` FROM `image` LEFT JOIN `\" . $type . \"` ON `\" . $type . \"`.`id`=\" . \"`image`.`object_id` WHERE `object_type`='\" . $type . \"' AND `\" . $type . \"`.`id` IS NULL\";\n                    $db_results = Dba::read($sql);\n                    while ($row = Dba::fetch_row($db_results)) {\n                        self::delete_from_dir($row[1], $row[0]);\n                    }\n                }\n                $sql = \"DELETE FROM `image` USING `image` LEFT JOIN `\" . $type . \"` ON `\" . $type . \"`.`id`=\" . \"`image`.`object_id` WHERE `object_type`='\" . $type . \"' AND `\" . $type . \"`.`id` IS NULL\";\n                Dba::write($sql);\n            } // foreach\n        }\n    }\n\n    /**\n     * Migrate an object associate images to a new object\n     * @param string $object_type\n     * @param integer $old_object_id\n     * @param integer $new_object_id\n     * @return PDOStatement|boolean\n     */\n    public static function migrate($object_type, $old_object_id, $new_object_id)\n    {\n        $sql = \"UPDATE `image` SET `object_id` = ? WHERE `object_type` = ? AND `object_id` = ?\";\n\n        return Dba::write($sql, array($new_object_id, $object_type, $old_object_id));\n    }\n\n    /**\n     * Duplicate an object associate images to a new object\n     * @param string $object_type\n     * @param integer $old_object_id\n     * @param integer $new_object_id\n     * @param string $new_object_type\n     * @return PDOStatement|boolean\n     */\n    public static function duplicate($object_type, $old_object_id, $new_object_id, $new_object_type = null)\n    {\n        $write_type = (self::is_valid_type($new_object_type))\n            ? $new_object_type\n            : $object_type;\n        if (Art::has_db($new_object_id, $write_type) || $old_object_id == $new_object_id) {\n            return false;\n        }\n\n        debug_event(self::class, 'duplicate... type:' . $object_type . ' old_id:' . $old_object_id . ' new_type:' . $write_type . ' new_id:' . $new_object_id, 5);\n        if (AmpConfig::get('album_art_store_disk')) {\n            $sql        = \"SELECT `size`, `kind`, `mime` FROM `image` WHERE `object_type` = ? AND `object_id` = ?\";\n            $db_results = Dba::read($sql, array($object_type, $old_object_id));\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $image = self::read_from_dir($row['size'], $object_type, $old_object_id, $row['kind'], $row['mime']);\n                if ($image !== null) {\n                    self::write_to_dir($image, $row['size'], $write_type, $new_object_id, $row['kind'], $row['mime']);\n                }\n            }\n        }\n\n        $sql = \"INSERT INTO `image` (`image`, `mime`, `size`, `object_type`, `object_id`, `kind`) SELECT `image`, `mime`, `size`, ? AS `object_type`, ? AS `object_id`, `kind` FROM `image` WHERE `object_type` = ? AND `object_id` = ?\";\n\n        return Dba::write($sql, array($write_type, $new_object_id, $object_type, $old_object_id));\n    }\n\n    /**\n     * Gather metadata from plugin.\n     * @param $plugin\n     * @param string $type\n     * @param array $options\n     * @return array\n     */\n    public static function gather_metadata_plugin($plugin, $type, $options)\n    {\n        $gtypes     = array();\n        $media_info = array();\n        switch ($type) {\n            case 'tvshow':\n            case 'tvshow_season':\n            case 'tvshow_episode':\n                $gtypes[]                                   = 'tvshow';\n                $media_info['tvshow']                       = $options['tvshow'];\n                $media_info['tvshow_season']                = $options['tvshow_season'];\n                $media_info['tvshow_episode']               = $options['tvshow_episode'];\n                break;\n            case 'song':\n                $media_info['mb_trackid'] = $options['mb_trackid'];\n                $media_info['title']      = $options['title'];\n                $media_info['artist']     = $options['artist'];\n                $media_info['album']      = $options['album'];\n                $gtypes[]                 = 'song';\n                break;\n            case 'album':\n                $media_info['mb_albumid']       = $options['mb_albumid'];\n                $media_info['mb_albumid_group'] = $options['mb_albumid_group'];\n                $media_info['artist']           = $options['artist'];\n                $media_info['title']            = $options['album'];\n                $gtypes[]                       = 'music';\n                $gtypes[]                       = 'album';\n                break;\n            case 'artist':\n                $media_info['mb_artistid'] = $options['mb_artistid'];\n                $media_info['title']       = $options['artist'];\n                $gtypes[]                  = 'music';\n                $gtypes[]                  = 'artist';\n                break;\n            case 'movie':\n                $gtypes[]            = 'movie';\n                $media_info['title'] = $options['keyword'];\n                break;\n        }\n\n        $meta   = $plugin->get_metadata($gtypes, $media_info);\n        $images = array();\n\n        if (array_key_exists('art', $meta)) {\n            $url      = $meta['art'];\n            $ures     = pathinfo($url);\n            $images[] = array('url' => $url, 'mime' => 'image/' . ($ures['extension'] ?? 'jpg'), 'title' => $plugin->name);\n        }\n        if (array_key_exists('tvshow_season_art', $meta)) {\n            $url      = $meta['tvshow_season_art'];\n            $ures     = pathinfo($url);\n            $images[] = array('url' => $url, 'mime' => 'image/' . ($ures['extension'] ?? 'jpg'), 'title' => $plugin->name);\n        }\n        if (array_key_exists('tvshow_art', $meta)) {\n            $url      = $meta['tvshow_art'];\n            $ures     = pathinfo($url);\n            $images[] = array('url' => $url, 'mime' => 'image/' . ($ures['extension'] ?? 'jpg'), 'title' => $plugin->name);\n        }\n\n        return $images;\n    }\n\n    /**\n     * Get thumb size from thumb type.\n     * @param integer $thumb\n     * @return array\n     */\n    public static function get_thumb_size($thumb)\n    {\n        $size = array();\n\n        switch ($thumb) {\n            case 1:\n                // This is used by the now_playing / browse stuff\n                $size['height'] = 100;\n                $size['width']  = 100;\n                break;\n            case 2:\n                // live stream, artist pages\n                $size['height'] = 128;\n                $size['width']  = 128;\n                break;\n            case 22:\n                $size['height'] = 256;\n                $size['width']  = 256;\n                break;\n            case 32:\n                // Single Album & Podcast pages\n                $size['height'] = 384;\n                $size['width']  = 384;\n                break;\n            case 3:\n                // This is used by the embedded web player\n                $size['height'] = 80;\n                $size['width']  = 80;\n                break;\n            case 5:\n                // Web Player size\n                $size['height'] = 32;\n                $size['width']  = 32;\n                break;\n            case 6:\n                // Video browsing size\n                $size['height'] = 150;\n                $size['width']  = 100;\n                break;\n            case 34:\n                // small 34x34\n                $size['height'] = 34;\n                $size['width']  = 34;\n                break;\n            case 64:\n                // medium 64x64\n                $size['height'] = 64;\n                $size['width']  = 64;\n                break;\n            case 174:\n                // large 174x174\n                $size['height'] = 174;\n                $size['width']  = 174;\n                break;\n            case 300:\n                // extralarge, mega 300x300\n            case 7:\n                // Video page size\n                $size['height'] = 300;\n                $size['width']  = 200;\n                break;\n            case 8:\n                // Video preview size\n                $size['height'] = 200;\n                $size['width']  = 470;\n                break;\n            case 9:\n                // Video preview size\n                $size['height'] = 84;\n                $size['width']  = 150; // cel_cover max-width is 150px\n                break;\n            case 10:\n                // Search preview size\n                $size['height'] = 24;\n                $size['width']  = 24;\n                break;\n            case 4:\n                // Popup Web Player size\n            case 11:\n                // Large view browse size\n            case 12:\n                // Search preview size\n                $size['height'] = 150;\n                $size['width']  = 150;\n                break;\n            default:\n                $size['height'] = 200;\n                $size['width']  = 200;\n                break;\n        }\n\n        // For @2x output\n        $size['height'] *= 2;\n        $size['width'] *= 2;\n\n        return $size;\n    }\n\n    /**\n     * Display an item art.\n     * @param string $object_type\n     * @param integer $object_id\n     * @param string $name\n     * @param integer $thumb\n     * @param string $link\n     * @param boolean $show_default\n     * @param string $kind\n     * @return boolean\n     */\n    public static function display(\n        $object_type,\n        $object_id,\n        $name,\n        $thumb,\n        $link = null,\n        $show_default = true,\n        $kind = 'default'\n    ) {\n        if (!self::is_valid_type($object_type)) {\n            return false;\n        }\n\n        if (!$show_default) {\n            // Don't show any image if not available\n            if (!self::has_db($object_id, $object_type, $kind)) {\n                return false;\n            }\n        }\n        $size        = self::get_thumb_size($thumb);\n        $prettyPhoto = ($link === null);\n        if ($link === null) {\n            $link = AmpConfig::get('web_path') . \"/image.php?object_id=\" . $object_id . \"&object_type=\" . $object_type . \"&thumb=\" . $thumb;\n            if (AmpConfig::get('use_auth') && AmpConfig::get('require_session')) {\n                $link .= \"&auth=\" . session_id();\n            }\n            if ($kind != 'default') {\n                $link .= '&kind=' . $kind;\n            }\n        }\n        echo \"<div class=\\\"item_art\\\">\";\n        echo \"<a href=\\\"\" . $link . \"\\\" title=\\\"\" . $name . \"\\\"\";\n        if ($prettyPhoto) {\n            echo \" rel=\\\"prettyPhoto\\\"\";\n        }\n        echo \">\";\n        $imgurl = AmpConfig::get('web_path') . \"/image.php?object_id=\" . $object_id . \"&object_type=\" . $object_type . \"&thumb=\" . $thumb;\n        if ($kind != 'default') {\n            $imgurl .= '&kind=' . $kind;\n        }\n        // This to keep browser cache feature but force a refresh in case image just changed\n        if (Art::has_db($object_id, $object_type)) {\n            $art = new Art($object_id, $object_type);\n            if ($art->has_db_info()) {\n                $imgurl .= '&fooid=' . $art->id;\n            }\n        }\n\n        // For @2x output\n        $size['height'] /= 2;\n        $size['width'] /= 2;\n\n        echo \"<img src=\\\"\" . $imgurl . \"\\\" alt=\\\"\" . $name . \"\\\" height=\\\"\" . $size['height'] . \"\\\" width=\\\"\" . $size['width'] . \"\\\" />\";\n\n        // don't put the play icon on really large images.\n        if ($size['height'] >= 150 && $size['height'] <= 300) {\n            echo \"<div class=\\\"item_art_play\\\">\";\n            echo Ajax::text('?page=stream&action=directplay&object_type=' . $object_type . '&object_id=' . $object_id . '\\' + getPagePlaySettings() + \\'',\n                '<span class=\"item_art_play_icon\" title=\"' . T_('Play') . '\" />',\n                'directplay_art_' . $object_type . '_' . $object_id);\n            echo \"</div>\";\n        }\n\n        if ($prettyPhoto) {\n            $class_name  = ObjectTypeToClassNameMapper::map($object_type);\n            $libitem     = new $class_name($object_id);\n            echo \"<div class=\\\"item_art_actions\\\">\";\n            if ((!empty(Core::get_global('user')) && Core::get_global('user')->has_access(50)) || (Core::get_global('user')->has_access(25) && Core::get_global('user')->id == $libitem->get_user_owner())) {\n                echo \"<a href=\\\"javascript:NavigateTo('\" . AmpConfig::get('web_path') . \"/arts.php?action=show_art_dlg&object_type=\" . $object_type . \"&object_id=\" . $object_id . \"&burl=' + getCurrentPage());\\\">\";\n                echo Ui::get_icon('edit', T_('Edit/Find Art'));\n                echo \"</a>\";\n                echo \"<a href=\\\"javascript:NavigateTo('\" . AmpConfig::get('web_path') . \"/arts.php?action=clear_art&object_type=\" . $object_type . \"&object_id=\" . $object_id . \"&burl=' + getCurrentPage());\\\" onclick=\\\"return confirm('\" . T_('Do you really want to reset art?') . \"');\\\">\";\n                echo Ui::get_icon('delete', T_('Reset Art'));\n                echo \"</a>\";\n            }\n            echo \"</div>\";\n        }\n\n        echo \"</a>\\n\";\n        echo \"</div>\";\n\n        return true;\n    }\n\n    /**\n     * Display an item art, bypassing the return value.\n     * @deprecated Temporary as legacy Art::display outputs boolean when used with return\n     * @param string $object_type\n     * @param integer $object_id\n     * @param string $name\n     * @param integer $thumb\n     * @param string $link\n     * @param boolean $show_default\n     * @param string $kind\n     * @return string\n     */\n    public static function display_without_return(\n        $object_type,\n        $object_id,\n        $name,\n        $thumb,\n        $link = null,\n        $show_default = true,\n        $kind = 'default'\n    ) {\n        self::display(\n            $object_type,\n            $object_id,\n            $name,\n            $thumb,\n            $link,\n            $show_default,\n            $kind\n        );\n\n        return '';\n    }\n\n    /**\n     * Get the object details for the art table\n     * @return array\n     */\n    public static function get_art_array()\n    {\n        $results    = array();\n        $sql        = \"SELECT `id`, `object_id`, `object_type`, `size`, `mime` FROM `image` WHERE `image` IS NOT NULL;\";\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row;\n        }\n\n        return $results;\n    }\n\n    /**\n     * Get the object details for the art table\n     * @param  array $data\n     * @return string\n     */\n    public static function get_raw_image($data)\n    {\n        $sql        = \"SELECT `image` FROM `image` WHERE `object_id` = ? AND `object_type` = ? AND `size` = ? AND `mime` = ?;\";\n        $db_results = Dba::read($sql, $data);\n        $row        = Dba::fetch_assoc($db_results);\n        if (empty($row)) {\n            return '';\n        }\n\n        return (string)$row['image'];\n    }\n\n    /**\n     * @deprecated\n     */\n    private function getSongRepository(): SongRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(SongRepositoryInterface::class);\n    }\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Repository\\Model;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Config\\ConfigContainerInterface;\nuse Ampache\\Config\\ConfigurationKeyEnum;\nuse Ampache\\Module\\Art\\Collector\\ArtCollectorInterface;\nuse Ampache\\Module\\Authorization\\Access;\nuse Ampache\\Module\\Catalog\\Catalog_beets;\nuse Ampache\\Module\\Catalog\\Catalog_beetsremote;\nuse Ampache\\Module\\Catalog\\Catalog_dropbox;\nuse Ampache\\Module\\Catalog\\Catalog_local;\nuse Ampache\\Module\\Catalog\\Catalog_remote;\nuse Ampache\\Module\\Catalog\\Catalog_Seafile;\nuse Ampache\\Module\\Catalog\\Catalog_soundcloud;\nuse Ampache\\Module\\Catalog\\Catalog_subsonic;\nuse Ampache\\Module\\Catalog\\GarbageCollector\\CatalogGarbageCollectorInterface;\nuse Ampache\\Module\\Playback\\Stream_Url;\nuse Ampache\\Module\\Song\\Tag\\SongTagWriterInterface;\nuse Ampache\\Module\\Statistics\\Stats;\nuse Ampache\\Module\\System\\AmpError;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\Util\\ObjectTypeToClassNameMapper;\nuse Ampache\\Module\\Util\\Recommendation;\nuse Ampache\\Module\\Util\\Ui;\nuse Ampache\\Module\\Util\\UtilityFactoryInterface;\nuse Ampache\\Module\\Util\\VaInfo;\nuse Ampache\\Repository\\AlbumRepositoryInterface;\nuse Ampache\\Repository\\LabelRepositoryInterface;\nuse Ampache\\Repository\\LicenseRepositoryInterface;\nuse Ampache\\Repository\\Model\\Metadata\\Repository\\Metadata;\nuse Ampache\\Repository\\SongRepositoryInterface;\nuse Ampache\\Repository\\UserRepositoryInterface;\nuse Exception;\nuse PDOStatement;\nuse RecursiveDirectoryIterator;\nuse RecursiveIteratorIterator;\nuse ReflectionException;\nuse RegexIterator;\n\n/**\n * This class handles all actual work in regards to the catalog,\n * it contains functions for creating/listing/updated the catalogs.\n */\nabstract class Catalog extends database_object\n{\n    protected const DB_TABLENAME = 'catalog';\n\n    private const CATALOG_TYPES = [\n        'beets' => Catalog_beets::class,\n        'beetsremote' => Catalog_beetsremote::class,\n        'dropbox' => Catalog_dropbox::class,\n        'local' => Catalog_local::class,\n        'remote' => Catalog_remote::class,\n        'seafile' => Catalog_Seafile::class,\n        'soundcloud' => Catalog_soundcloud::class,\n        'subsonic' => Catalog_subsonic::class,\n    ];\n\n    /**\n     * @var integer $id\n     */\n    public $id;\n    /**\n     * @var string $name\n     */\n    public $name;\n    /**\n     * @var integer $last_update\n     */\n    public $last_update;\n    /**\n     * @var integer $last_add\n     */\n    public $last_add;\n    /**\n     * @var integer $last_clean\n     */\n    public $last_clean;\n    /**\n     * @var string $key\n     */\n    public $key;\n    /**\n     * @var string $rename_pattern\n     */\n    public $rename_pattern;\n    /**\n     * @var string $sort_pattern\n     */\n    public $sort_pattern;\n    /**\n     * @var string $catalog_type\n     */\n    public $catalog_type;\n    /**\n     * @var string $gather_types\n     */\n    public $gather_types;\n\n    /**\n     * @var string $f_name\n     */\n    public $f_name;\n    /**\n     * @var string $link\n     */\n    public $link;\n    /**\n     * @var string $f_link\n     */\n    public $f_link;\n    /**\n     * @var string $f_update\n     */\n    public $f_update;\n    /**\n     * @var string $f_add\n     */\n    public $f_add;\n    /**\n     * @var string $f_clean\n     */\n    public $f_clean;\n    /**\n     * alias for catalog paths, urls, etc etc\n     * @var string $f_full_info\n     */\n    public $f_full_info;\n    /**\n     * alias for catalog paths, urls, etc etc\n     * @var string $f_info\n     */\n    public $f_info;\n    /**\n     * @var integer $enabled\n     */\n    public $enabled;\n\n    /**\n     * This is a private var that's used during catalog builds\n     * @var array $_playlists\n     */\n    protected $_playlists = array();\n\n    /**\n     * Cache all files in catalog for quick lookup during add\n     * @var array $_filecache\n     */\n    protected $_filecache = array();\n\n    // Used in functions\n    /**\n     * @var array $albums\n     */\n    protected static $albums = array();\n    /**\n     * @var array $artists\n     */\n    protected static $artists = array();\n    /**\n     * @var array $tags\n     */\n    protected static $tags = array();\n\n    /**\n     * @return string\n     */\n    abstract public function get_type();\n\n    /**\n     * @return string\n     */\n    abstract public function get_description();\n\n    /**\n     * @return string\n     */\n    abstract public function get_version();\n\n    /**\n     * @return string\n     */\n    abstract public function get_create_help();\n\n    /**\n     * @return bool\n     */\n    abstract public function is_installed();\n\n    /**\n     * @return bool\n     */\n    abstract public function install();\n\n    /**\n     * @param array $options\n     * @return mixed\n     */\n    abstract public function add_to_catalog($options = null);\n\n    /**\n     * @return mixed\n     */\n    abstract public function verify_catalog_proc();\n\n    /**\n     * @return int\n     */\n    abstract public function clean_catalog_proc();\n\n    /**\n     * @return array\n     */\n    abstract public function check_catalog_proc();\n\n    /**\n     * @param string $new_path\n     * @return boolean\n     */\n    abstract public function move_catalog_proc($new_path);\n\n    /**\n     * @return bool\n     */\n    abstract public function cache_catalog_proc();\n\n    /**\n     * @return array\n     */\n    abstract public function catalog_fields();\n\n    /**\n     * @param string $file_path\n     * @return string\n     */\n    abstract public function get_rel_path($file_path);\n\n    /**\n     * @param Song|Podcast_Episode|Song_Preview|Video $media\n     * @return Media|null\n     */\n    abstract public function prepare_media($media);\n\n    public function getId(): int\n    {\n        return (int)$this->id;\n    }\n\n    /**\n     * Check if the catalog is ready to perform actions (configuration completed, ...)\n     * @return boolean\n     */\n    public function isReady()\n    {\n        return true;\n    }\n\n    /**\n     * Show a message to make the catalog ready.\n     */\n    public function show_ready_process()\n    {\n        // Do nothing.\n    }\n\n    /**\n     * Perform the last step process to make the catalog ready.\n     */\n    public function perform_ready()\n    {\n        // Do nothing.\n    }\n\n    /**\n     * uninstall\n     * This removes the remote catalog\n     * @return boolean\n     */\n    public function uninstall()\n    {\n        $sql = \"DELETE FROM `catalog` WHERE `catalog_type` = ?\";\n        Dba::query($sql, array($this->get_type()));\n\n        $sql = \"DROP TABLE `catalog_\" . $this->get_type() . \"`\";\n        Dba::query($sql);\n\n        return true;\n    } // uninstall\n\n    /**\n     * Create a catalog from its id.\n     * @param integer $catalog_id\n     * @return Catalog|null\n     */\n    public static function create_from_id($catalog_id)\n    {\n        $sql        = 'SELECT `catalog_type` FROM `catalog` WHERE `id` = ?';\n        $db_results = Dba::read($sql, array($catalog_id));\n        $row        = Dba::fetch_assoc($db_results);\n        if (empty($row)) {\n            return null;\n        }\n\n        return self::create_catalog_type($row['catalog_type'], $catalog_id);\n    }\n\n    /**\n     * create_catalog_type\n     * This function attempts to create a catalog type\n     * @param string $type\n     * @param integer $catalog_id\n     * @return Catalog|null\n     */\n    public static function create_catalog_type($type, $catalog_id = 0)\n    {\n        if (!$type) {\n            return null;\n        }\n\n        $controller = self::CATALOG_TYPES[$type] ?? null;\n\n        if ($controller === null) {\n            /* Throw Error Here */\n            debug_event(__CLASS__, 'Unable to load ' . $type . ' catalog type', 2);\n\n            return null;\n        } // include\n        if ($catalog_id > 0) {\n            $catalog = new $controller($catalog_id);\n        } else {\n            $catalog = new $controller();\n        }\n        if (!($catalog instanceof Catalog)) {\n            debug_event(__CLASS__, $type . ' not an instance of Catalog abstract, unable to load', 1);\n\n            return null;\n        }\n        // identify if it's actually enabled\n        $sql        = 'SELECT `enabled` FROM `catalog` WHERE `id` = ?';\n        $db_results = Dba::read($sql, array($catalog->id));\n\n        while ($results = Dba::fetch_assoc($db_results)) {\n            $catalog->enabled = $results['enabled'];\n        }\n\n        return $catalog;\n    }\n\n    /**\n     * Show dropdown catalog types.\n     * @param string $divback\n     */\n    public static function show_catalog_types($divback = 'catalog_type_fields')\n    {\n        echo '<script>' . \"var type_fields = new Array();type_fields['none'] = '';\";\n        $seltypes = '<option value=\"none\">[' . T_(\"Select\") . ']</option>';\n        $types    = self::get_catalog_types();\n        foreach ($types as $type) {\n            $catalog = self::create_catalog_type($type);\n            if ($catalog->is_installed()) {\n                $seltypes .= '<option value=\"' . $type . '\">' . $type . '</option>';\n                echo \"type_fields['\" . $type . \"'] = \\\"\";\n                $fields = $catalog->catalog_fields();\n                $help   = $catalog->get_create_help();\n                if (!empty($help)) {\n                    echo \"<tr><td></td><td>\" . $help . \"</td></tr>\";\n                }\n                foreach ($fields as $key => $field) {\n                    echo \"<tr><td style='width: 25%;'>\" . $field['description'] . \":</td><td>\";\n                    $value = (array_key_exists('value', $field)) ? $field['value'] : '';\n\n                    switch ($field['type']) {\n                        case 'checkbox':\n                            echo \"<input type='checkbox' name='\" . $key . \"' value='1' \" . ((!empty($value)) ? 'checked' : '') . \"/>\";\n                            break;\n                        default:\n                            echo \"<input type='\" . $field['type'] . \"' name='\" . $key . \"' value='\" . $value . \"' />\";\n                            break;\n                    }\n                    echo \"</td></tr>\";\n                }\n                echo \"\\\";\";\n            }\n        }\n\n        echo \"function catalogTypeChanged() {var sel = document.getElementById('catalog_type');var seltype = sel.options[sel.selectedIndex].value;var ftbl = document.getElementById('\" . $divback . \"');ftbl.innerHTML = '<table class=\\\"tabledata\\\">' + type_fields[seltype] + '</table>';} </script><select name=\\\"type\\\" id=\\\"catalog_type\\\" onChange=\\\"catalogTypeChanged();\\\">\" . $seltypes . \"</select>\";\n    }\n\n    /**\n     * get_catalog_types\n     * This returns the catalog types that are available\n     * @return string[]\n     */\n    public static function get_catalog_types()\n    {\n        return array_keys(self::CATALOG_TYPES);\n    }\n\n    /**\n     * get_catalog_filters\n     * This returns the filters, sorting by name or by id as indicated by $sort\n     * $sort = field to sort on (id or name)\n     * @return string[]\n     */\n    public static function get_catalog_filters($sort = 'name')\n    {\n        $results = array();\n        // Now fetch the rest;\n        $sql        = \"SELECT `id`,`name` FROM `catalog_filter_group` ORDER BY `$sort` \";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row;\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_catalog_filter_names\n     * This returns the names of the catalog filters that are available with the default filter listed first.\n     * @return string[]\n     */\n    public static function get_catalog_filter_names()\n    {\n        $results = array();\n\n        // Get the default filter and name\n        // Default filter is always the first one.\n        $sql        = \"SELECT `name` FROM `catalog_filter_group` WHERE `id` = 0\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_assoc($db_results);\n        $results[]  = $row['name'];\n\n        // Now fetch the rest;\n        $sql        = \"SELECT `name` FROM `catalog_filter_group` WHERE `id` > 0 ORDER BY `name`\";\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row['name'];\n        }\n\n        return $results;\n    }\n\n    public static function get_catalog_filter_name($id = 0)\n    {\n        $sql        = \"SELECT `name` FROM `catalog_filter_group` WHERE `id` = ?\";\n        $db_results = Dba::read($sql, array($id));\n        $row        = Dba::fetch_assoc($db_results);\n\n        return $row['name'];\n    }\n\n    public static function get_catalog_filter_by_name($filter_name)\n    {\n        $sql        = \"SELECT `id` FROM `catalog_filter_group` WHERE `name` = ?\";\n        $db_results = Dba::read($sql, array($filter_name));\n        $row        = Dba::fetch_assoc($db_results);\n\n        return (int)$row['id'];\n    }\n\n    /**\n     * get_catalog_filter_name\n     * This returns the catalog filter name with the given ID.\n     * @return string\n     */\n    public static function get_catalog_name($filter_id = 0)\n    {\n        $sql        = \"SELECT `name` FROM `catalog` WHERE `id` = ?\";\n        $db_results = Dba::read($sql, array($filter_id));\n        $row        = Dba::fetch_assoc($db_results);\n\n        return $row['name'];\n    }\n\n    /**\n     * filter_user_count\n     * Returns the number of users assigned to a particular filter.\n     * @return int\n     */\n    public static function filter_user_count($filter_id)\n    {\n        $sql        = \"SELECT COUNT(1) AS `count` FROM `user` WHERE `catalog_filter_group` = ?\";\n        $db_results = Dba::read($sql, array($filter_id));\n        $row        = Dba::fetch_assoc($db_results);\n\n        return $row['count'];\n    }\n\n    /**\n     * filter_catalog_count\n     * This returns the number of catalogs assigned to a filter.\n     * @return string\n     */\n    public static function filter_catalog_count($filter_id)\n    {\n        $sql        = \"SELECT COUNT(1) AS `count` FROM `catalog_filter_group_map` WHERE `group_id` = ? AND `enabled` = 1\";\n        $db_results = Dba::read($sql, array($filter_id));\n        $row        = Dba::fetch_assoc($db_results);\n\n        return $row['count'];\n    }\n\n    /**\n     * filter_count\n     * This returns the number of filters.\n     * @return int\n     */\n    public static function filter_count()\n    {\n        $sql        = \"SELECT COUNT(1) AS `count` FROM `catalog_filter_group`\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_assoc($db_results);\n\n        return (int)$row['count'] ?? 0;\n    }\n\n    /**\n     * filter_name_exists\n     * can specifiy an ID to ignore in this check, useful for filter names.\n     * @return bool\n     */\n    public static function filter_name_exists($filter_name, $exclude_id = 0)\n    {\n        $params = array($filter_name);\n        $sql    = \"SELECT `id` FROM `catalog_filter_group` WHERE `name` = ?\";\n        if ($exclude_id >= 0) {\n            $sql .= \" AND `id` != ?\";\n            $params[] = $exclude_id;\n        }\n\n        $db_results = Dba::read($sql, $params);\n        if (Dba::num_rows($db_results) > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * check_filter_catalog_enabled\n     * Returns the `enabled` status of the filter/catalog combination\n     * @return bool\n     */\n    public static function check_filter_catalog_enabled($filter_id, $catalog_id)\n    {\n        $sql        = \"SELECT `enabled` FROM `catalog_filter_group_map` WHERE `group_id` = ? AND `catalog_id` = ? AND `enabled` = 1;\";\n        $db_results = Dba::read($sql, array($filter_id, $catalog_id));\n        if (Dba::num_rows($db_results)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * add_catalog_filter_group_map\n     * Adds appropriate rows when a catalog is added.\n     * @return PDOStatement|boolean\n     */\n    public static function add_catalog_filter_group_map($catalog_id)\n    {\n        $results    = array();\n        $sql        = \"SELECT `id` FROM `catalog_filter_group` ORDER BY `id`\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        $sql = \"INSERT IGNORE INTO `catalog_filter_group_map` (`group_id`, `catalog_id`, `enabled`) VALUES \";\n        foreach ($results as $filter_id) {\n            $sql .= \"\" . (int)$filter_id . \", \" . (int)$catalog_id . \", 0),\";\n        }\n        // Remove last comma to avoid SQL error\n        $sql = substr($sql, 0, -1);\n\n        return Dba::write($sql);\n    }\n\n    /**\n     * add_catalog_filter_group\n     * @return PDOStatement|boolean\n     */\n    public static function add_catalog_filter_group($filter_name, $catalogs)\n    {\n        // Create the filter\n        $params = array($filter_name);\n        $sql    = \"INSERT INTO `catalog_filter_group` (`name`) VALUES ('$filter_name')\";\n        Dba::write($sql, $params);\n        $filter_id = Dba::insert_id();\n\n        // Fill in catalog_filter_group_map table for the new filter\n        $results    = array();\n        $sql        = \"SELECT `id` FROM `catalog` ORDER BY `id`\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        $sql = \"INSERT INTO `catalog_filter_group_map` (`group_id`, `catalog_id`, `enabled`) VALUES \";\n        foreach ($results as $catalog_id) {\n            $cn      = self::get_catalog_name($catalog_id);\n            $enabled = $catalogs[$cn];\n            $sql .= \"($filter_id, $catalog_id, $enabled),\";\n        }\n        // Remove last comma to avoid SQL error\n        $sql = substr($sql, 0, -1);\n\n        return Dba::write($sql);\n    }\n\n    /**\n     * edit_catalog_filter\n     * @return bool\n     */\n    public static function edit_catalog_filter($filter_id, $filter_name, $catalogs)\n    {\n        // Modify the filter name\n        $results = array();\n        $sql     = \"UPDATE `catalog_filter_group` SET `name` = ? WHERE `id` = ?;\";\n        Dba::write($sql, array($filter_name, $filter_id));\n\n        // Fill in catalog_filter_group_map table for the filter\n        $sql        = \"SELECT `id` FROM `catalog` ORDER BY `id`\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        foreach ($results as $catalog_id) {\n            $sql        = \"SELECT `catalog_id` FROM `catalog_filter_group_map` WHERE `group_id` = ? AND `catalog_id` = ?\";\n            $db_results = Dba::read($sql, array($filter_id, $catalog_id));\n            $enabled    = $catalogs[$catalog_id];\n            if (Dba::num_rows($db_results)) {\n                // update the values\n                $sql     = \"UPDATE `catalog_filter_group_map` SET `enabled` = ? WHERE `group_id` = ? AND `catalog_id` = ?\";\n                if (!Dba::write($sql, array($enabled, $filter_id, $catalog_id))) {\n                    return false;\n                }\n            } else {\n                // missing group map? add it in\n                $sql = \"INSERT INTO `catalog_filter_group_map` SET `enabled` = ?, `group_id` = ?, `catalog_id` = ?\";\n                if (!Dba::write($sql, array($enabled, $filter_id, $catalog_id))) {\n                    return false;\n                }\n            }\n        }\n        self::garbage_collect_filters();\n\n        return true;\n    }\n\n    /**\n     * delete_catalog_filter\n     * @return PDOStatement|boolean\n     */\n    public static function delete_catalog_filter($filter_id)\n    {\n        if ($filter_id > 0) {\n            $params = array($filter_id);\n            $sql    = \"DELETE FROM `catalog_filter_group` WHERE `id` = ?\";\n            if (Dba::write($sql, $params)) {\n                $sql = \"DELETE FROM `catalog_filter_group_map` WHERE `group_id` = ?\";\n\n                return Dba::write($sql, $params);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * reset_user_filter\n     * reset a users's catalog filter to DEFAULT after deleting a filter group\n     */\n    public static function reset_user_filter($filter_id)\n    {\n        $sql = \"UPDATE `user` SET `catalog_filter_group` = 0 WHERE `catalog_filter_group` = ?\";\n        Dba::write($sql, array($filter_id));\n    }\n\n    /**\n     * Check if a file is an audio.\n     * @param string $file\n     * @return boolean\n     */\n    public static function is_audio_file($file)\n    {\n        $ignore_pattern = AmpConfig::get('catalog_ignore_pattern');\n        $ignore_check   = !($ignore_pattern) || preg_match(\"/(\" . $ignore_pattern . \")/i\", $file) === 0;\n        $file_pattern   = AmpConfig::get('catalog_file_pattern');\n        $pattern        = \"/\\.(\" . $file_pattern . \")$/i\";\n\n        return ($ignore_check && preg_match($pattern, $file));\n    }\n\n    /**\n     * Check if a file is a video.\n     * @param string $file\n     * @return boolean\n     */\n    public static function is_video_file($file)\n    {\n        $ignore_pattern = AmpConfig::get('catalog_ignore_pattern');\n        $ignore_check   = !($ignore_pattern) || preg_match(\"/(\" . $ignore_pattern . \")/i\", $file) === 0;\n        $video_pattern  = \"/\\.(\" . AmpConfig::get('catalog_video_pattern') . \")$/i\";\n\n        return ($ignore_check && preg_match($video_pattern, $file));\n    }\n\n    /**\n     * Check if a file is a playlist.\n     * @param string $file\n     * @return bool\n     */\n    public static function is_playlist_file($file)\n    {\n        $ignore_pattern   = AmpConfig::get('catalog_ignore_pattern');\n        $ignore_check     = !($ignore_pattern) || preg_match(\"/(\" . $ignore_pattern . \")/i\", $file) === 0;\n        $playlist_pattern = \"/\\.(\" . AmpConfig::get('catalog_playlist_pattern') . \")$/i\";\n\n        return ($ignore_check && preg_match($playlist_pattern, $file));\n    }\n\n    /**\n     * Get catalog info from table.\n     * @param integer $object_id\n     * @param string $table_name\n     * @return array\n     */\n    public function get_info($object_id, $table_name = 'catalog')\n    {\n        $info = parent::get_info($object_id, $table_name);\n\n        $table      = 'catalog_' . $this->get_type();\n        $sql        = \"SELECT `id` FROM `$table` WHERE `catalog_id` = ?\";\n        $db_results = Dba::read($sql, array($object_id));\n\n        if ($results = Dba::fetch_assoc($db_results)) {\n            $info_type = parent::get_info($results['id'], $table);\n            foreach ($info_type as $key => $value) {\n                if (!array_key_exists($key, $info) || !$info[$key]) {\n                    $info[$key] = $value;\n                }\n            }\n        }\n\n        return $info;\n    }\n\n    /**\n     * Get enable sql filter;\n     * @param string $type\n     * @param string $catalog_id\n     * @return string\n     */\n    public static function get_enable_filter($type, $catalog_id)\n    {\n        $sql = \"\";\n        if ($type == \"song\" || $type == \"album\" || $type == \"artist\") {\n            if ($type == \"song\") {\n                $type = \"id\";\n            }\n            $sql = \"(SELECT COUNT(`song_dis`.`id`) FROM `song` AS `song_dis` LEFT JOIN `catalog` AS `catalog_dis` ON `catalog_dis`.`id` = `song_dis`.`catalog` WHERE `song_dis`.`\" . $type . \"` = \" . $catalog_id . \" AND `catalog_dis`.`enabled` = '1' GROUP BY `song_dis`.`\" . $type . \"`) > 0\";\n        } elseif ($type == \"video\") {\n            $sql = \"(SELECT COUNT(`video_dis`.`id`) FROM `video` AS `video_dis` LEFT JOIN `catalog` AS `catalog_dis` ON `catalog_dis`.`id` = `video_dis`.`catalog` WHERE `video_dis`.`id` = \" . $catalog_id . \" AND `catalog_dis`.`enabled` = '1' GROUP BY `video_dis`.`id`) > 0\";\n        }\n\n        return $sql;\n    }\n\n    /**\n     * Get filter_user sql filter;\n     * @param string $type\n     * @param integer $user_id\n     * @return string\n     */\n    public static function get_user_filter($type, $user_id)\n    {\n        switch ($type) {\n            case \"album\":\n            case \"song\":\n            case \"video\":\n            case \"podcast\":\n            case \"podcast_episode\":\n            case \"live_stream\":\n            case \"artist\":\n                $sql = \" `$type`.`id` IN (SELECT `object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            case \"song_artist\":\n            case \"song_album\":\n                $type = str_replace('song_', '', (string) $type);\n                $sql  = \" `song`.`$type` IN (SELECT `object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            case \"album_artist\":\n                $sql  = \" `song`.`$type` IN (SELECT `object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            case \"label\":\n                $sql = \" `label`.`id` IN (SELECT `label` FROM `label_asso` LEFT JOIN `artist` ON `label_asso`.`artist` = `artist`.`id` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'artist'  AND `catalog_map`.`object_id` = `artist`.`id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = 'artist' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1) GROUP BY `label_asso`.`label`) \";\n                break;\n            case \"playlist\":\n                $sql = \" `playlist`.`id` IN (SELECT `playlist` FROM `playlist_data` LEFT JOIN `song` ON `playlist_data`.`object_id` = `song`.`id` AND `playlist_data`.`object_type` = 'song' LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'song'  AND `catalog_map`.`object_id` = `song`.`id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = 'song' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `playlist_data`.`playlist`) \";\n                break;\n            case \"share\":\n                $sql = \" `share`.`object_id` IN (SELECT `share`.`object_id` FROM `share` LEFT JOIN `catalog_map` ON `share`.`object_type` = `catalog_map`.`object_type` AND `share`.`object_id` = `catalog_map`.`object_id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)   GROUP BY `share`.`object_id`, `share`.`object_type`) \";\n                break;\n            case \"tag\":\n                $sql = \" `tag`.`id` IN (SELECT `tag_id` FROM `tag_map` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = `tag_map`.`object_type` AND `catalog_map`.`object_id` = `tag_map`.`object_id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `tag_map`.`tag_id`) \";\n                break;\n            case 'tvshow':\n                $sql = \" `tvshow`.`id` IN (SELECT `tvshow` FROM `tvshow_season` LEFT JOIN `tvshow_episode` ON `tvshow_episode`.`season` = `tvshow_season`.`id` LEFT JOIN `video` ON `tvshow_episode`.`id` = `video`.`id` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'video' AND `catalog_map`.`object_id` = `video`.`id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `tvshow_season`.`tvshow`) \";\n                break;\n            case 'tvshow_season':\n                $sql = \" `tvshow_season`.`tvshow` IN (SELECT `season` FROM `tvshow_episode` LEFT JOIN `video` ON `tvshow_episode`.`id` = `video`.`id` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'video' AND `catalog_map`.`object_id` = `video`.`id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1) GROUP BY `tvshow_episode`.`season`) \";\n                break;\n            case 'tvshow_episode':\n            case 'movie':\n            case 'personal_video':\n            case 'clip':\n                $sql = \" `$type`.`id` IN (SELECT `video`.`id` FROM `video` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'video' AND `catalog_map`.`object_id` = `video`.`id` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `video`.`id`) \";\n                break;\n            // enum('album','artist','song','playlist','genre','catalog','live_stream','video','podcast','podcast_episode')\n            case \"object_count_artist\":\n            case \"object_count_album\":\n            case \"object_count_song\":\n            case \"object_count_playlist\":\n            case \"object_count_genre\":\n            case \"object_count_catalog\":\n            case \"object_count_live_stream\":\n            case \"object_count_video\":\n            case \"object_count_podcast\":\n            case \"object_count_podcast_episode\":\n                $type = str_replace('object_count_', '', (string) $type);\n                $sql  = \" `object_count`.`object_id` IN (SELECT `catalog_map`.`object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            // enum('artist','album','song','stream','live_stream','video','playlist','tvshow','tvshow_season','podcast','podcast_episode')\n            case \"rating_artist\":\n            case \"rating_album\":\n            case \"rating_song\":\n            case \"rating_stream\":\n            case \"rating_live_stream\":\n            case \"rating_video\":\n            case \"rating_tvshow\":\n            case \"rating_tvshow_season\":\n            case \"rating_podcast\":\n            case \"rating_podcast_episode\":\n                $type = str_replace('rating_', '', (string) $type);\n                $sql  = \" `rating`.`object_id` IN (SELECT `catalog_map`.`object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            case \"user_flag_artist\":\n            case \"user_flag_album\":\n            case \"user_flag_song\":\n            case \"user_flag_video\":\n            case \"user_flag_podcast_episode\":\n                $type = str_replace('user_flag_', '', (string) $type);\n                $sql  = \" `user_flag`.`object_id` IN (SELECT `catalog_map`.`object_id` FROM `catalog_map` LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog_map`.`object_type` = '$type' AND `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `catalog_map`.`object_id`) \";\n                break;\n            case \"rating_playlist\":\n                $sql  = \" `rating`.`object_id` IN (SELECT DISTINCT(`playlist`.`id`) FROM `playlist` LEFT JOIN `playlist_data` ON `playlist_data`.`playlist` = `playlist`.`id` LEFT JOIN `catalog_map` ON `playlist_data`.`object_id` = `catalog_map`.`object_id` AND `playlist_data`.`object_type` = 'song' LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `playlist`.`id`) \";\n                break;\n            case \"user_flag_playlist\":\n                $sql  = \" `user_flag`.`object_id` IN (SELECT DISTINCT(`playlist`.`id`) FROM `playlist` LEFT JOIN `playlist_data` ON `playlist_data`.`playlist` = `playlist`.`id` LEFT JOIN `catalog_map` ON `playlist_data`.`object_id` = `catalog_map`.`object_id` AND `playlist_data`.`object_type` = 'song' LEFT JOIN `catalog` ON `catalog_map`.`catalog_id` = `catalog`.`id` WHERE `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  GROUP BY `playlist`.`id`) \";\n                break;\n            case \"catalog\":\n                $sql = \" `catalog`.`id` IN (SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id` = $user_id AND `catalog_filter_group_map`.`enabled`=1)  \";\n                break;\n            default:\n                $sql = \"\";\n        }\n\n        return $sql;\n    }\n\n    /**\n     * _create_filecache\n     *\n     * This populates an array which is used to speed up the add process.\n     * @return boolean\n     */\n    protected function _create_filecache()\n    {\n        if (count($this->_filecache) == 0) {\n            // Get _EVERYTHING_\n            $sql        = 'SELECT `id`, `file` FROM `song` WHERE `catalog` = ?';\n            $db_results = Dba::read($sql, array($this->id));\n\n            // Populate the filecache\n            while ($results = Dba::fetch_assoc($db_results)) {\n                $this->_filecache[strtolower((string)$results['file'])] = $results['id'];\n            }\n\n            $sql        = 'SELECT `id`, `file` FROM `video` WHERE `catalog` = ?';\n            $db_results = Dba::read($sql, array($this->id));\n\n            while ($results = Dba::fetch_assoc($db_results)) {\n                $this->_filecache[strtolower((string)$results['file'])] = 'v_' . $results['id'];\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * get_update_info\n     *\n     * return the counts from update info to speed up responses\n     * @param string $key\n     * @return int\n     */\n    public static function get_update_info(string $key)\n    {\n        if ($key == 'joined') {\n            $sql        = \"SELECT 'playlist' AS `key`, SUM(value) AS `value` FROM `update_info` WHERE `key` IN ('playlist', 'search')\";\n            $db_results = Dba::read($sql);\n        } else {\n            $sql        = \"SELECT `key`, `value` FROM `update_info` WHERE `key` = ?\";\n            $db_results = Dba::read($sql, array($key));\n        }\n        $results = Dba::fetch_assoc($db_results);\n\n        return (int)($results['value'] ?? 0);\n    } // get_update_info\n\n    /**\n     * set_update_info\n     *\n     * write the total_counts to update_info\n     * @param string $key\n     * @param int $value\n     */\n    public static function set_update_info(string $key, int $value)\n    {\n        Dba::write(\"REPLACE INTO `update_info` SET `key` = ?, `value` = ?;\", array($key, $value));\n    } // set_update_info\n\n    /**\n     * update_enabled\n     * sets the enabled flag\n     * @param bool $new_enabled\n     * @param integer $catalog_id\n     */\n    public static function update_enabled($new_enabled, $catalog_id)\n    {\n        self::_update_item('enabled', (int)$new_enabled, $catalog_id, '75');\n    } // update_enabled\n\n    /**\n     * _update_item\n     * This is a private function that should only be called from within the catalog class.\n     * It takes a field, value, catalog id and level. first and foremost it checks the level\n     * against Core::get_global('user') to make sure they are allowed to update this record\n     * it then updates it and sets $this->{$field} to the new value\n     * @param string $field\n     * @param boolean $value\n     * @param integer $catalog_id\n     * @param integer $level\n     * @return PDOStatement|boolean\n     */\n    private static function _update_item($field, $value, $catalog_id, $level)\n    {\n        /* Check them Rights! */\n        if (!Access::check('interface', $level)) {\n            return false;\n        }\n\n        /* Can't update to blank */\n        if (!strlen(trim((string)$value))) {\n            return false;\n        }\n        $sql = \"UPDATE `catalog` SET `$field` = ? WHERE `id` = ?\";\n\n        return Dba::write($sql, array($value, $catalog_id));\n    } // _update_item\n\n    /**\n     * format\n     *\n     * This makes the object human-readable.\n     */\n    public function format()\n    {\n        $this->f_name        = scrub_out($this->name);\n        $this->link          = AmpConfig::get('web_path') . '/admin/catalog.php?action=show_customize_catalog&catalog_id=' . $this->id;\n        $this->f_link        = '<a href=\"' . $this->link . '\" title=\"' . $this->f_name . '\">' . $this->f_name . '</a>';\n        $this->f_update      = $this->last_update ? get_datetime((int)$this->last_update) : T_('Never');\n        $this->f_add         = $this->last_add ? get_datetime((int)$this->last_add) : T_('Never');\n        $this->f_clean       = $this->last_clean ? get_datetime((int)$this->last_clean) : T_('Never');\n    }\n\n    /**\n     * get_catalogs\n     *\n     * Pull all the current catalogs and return an array of ids\n     * of what you find\n     * @param string $filter_type\n     * @param int $user_id\n     * @return integer[]\n     */\n    public static function get_catalogs($filter_type = '', $user_id = null)\n    {\n        $params = array();\n        $sql    = \"SELECT `id` FROM `catalog` \";\n        $join   = 'WHERE';\n        if (!empty($filter_type)) {\n            $sql .= \"$join `gather_types` = ? \";\n            $params[] = $filter_type;\n            $join     = 'AND';\n        }\n        if (AmpConfig::get('catalog_filter') && $user_id > 0) {\n            $sql .= $join . self::get_user_filter('catalog', $user_id);\n        }\n        $sql .= \"ORDER BY `name`\";\n        $db_results = Dba::read($sql, $params);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * Run the cache_catalog_proc() on music catalogs.\n     */\n    public static function cache_catalogs()\n    {\n        $target = AmpConfig::get('cache_target');\n        $path   = (string)AmpConfig::get('cache_path', '');\n        // need a destination and target filetype\n        if (is_dir($path) && $target) {\n            $catalogs = self::get_catalogs('music');\n            foreach ($catalogs as $catalogid) {\n                debug_event(__CLASS__, 'cache_catalogs: ' . $catalogid, 5);\n                $catalog = self::create_from_id($catalogid);\n                $catalog->cache_catalog_proc();\n            }\n            $catalog_dirs  = new RecursiveDirectoryIterator($path);\n            $dir_files     = new RecursiveIteratorIterator($catalog_dirs);\n            $cache_files   = new RegexIterator($dir_files, \"/\\.$target$/i\");\n            debug_event(__CLASS__, 'cache_catalogs: cleaning old files', 5);\n            foreach ($cache_files as $file) {\n                $path    = pathinfo($file);\n                $song_id = $path['filename'];\n                if (!Song::has_id($song_id)) {\n                    unlink($file);\n                    debug_event(__CLASS__, 'cache_catalogs: removed {' . $file . '}', 4);\n                }\n            }\n        }\n    }\n\n    /**\n     * Get last catalogs update.\n     * @param integer[]|null $catalogs\n     * @return integer\n     */\n    public static function getLastUpdate($catalogs = null)\n    {\n        $last_update = 0;\n        if ($catalogs == null || !is_array($catalogs)) {\n            $catalogs = self::get_catalogs();\n        }\n        foreach ($catalogs as $catalogid) {\n            $catalog = self::create_from_id($catalogid);\n            if ($catalog->last_add > $last_update) {\n                $last_update = $catalog->last_add;\n            }\n            if ($catalog->last_update > $last_update) {\n                $last_update = $catalog->last_update;\n            }\n            if ($catalog->last_clean > $last_update) {\n                $last_update = $catalog->last_clean;\n            }\n        }\n\n        return $last_update;\n    }\n\n    /**\n     * get_stats\n     *\n     * This returns an hash with the #'s for the different\n     * objects that are associated with this catalog. This is used\n     * to build the stats box, it also calculates time.\n     * @param integer|null $catalog_id\n     * @return array\n     */\n    public static function get_stats($catalog_id = null)\n    {\n        $counts         = ($catalog_id) ? self::count_catalog($catalog_id) : self::get_server_counts(0);\n        $counts         = array_merge(User::count(), $counts);\n        $counts['tags'] = self::count_tags();\n\n        $counts['formatted_size'] = Ui::format_bytes($counts['size']);\n\n        $hours = floor($counts['time'] / 3600);\n        $days  = floor($hours / 24);\n        $hours = $hours % 24;\n\n        $time_text = \"$days \";\n        $time_text .= nT_('day', 'days', $days);\n        $time_text .= \", $hours \";\n        $time_text .= nT_('hour', 'hours', $hours);\n\n        $counts['time_text'] = $time_text;\n\n        return $counts;\n    }\n\n    /**\n     * create\n     *\n     * This creates a new catalog entry and associate it to current instance\n     * @param array $data\n     * @return integer\n     */\n    public static function create($data)\n    {\n        $name           = $data['name'];\n        $type           = $data['type'];\n        $rename_pattern = $data['rename_pattern'];\n        $sort_pattern   = $data['sort_pattern'];\n        $gather_types   = $data['gather_media'];\n\n        // Should it be an array? Not now.\n        if (!in_array($gather_types,\n            array('music', 'clip', 'tvshow', 'movie', 'personal_video', 'podcast'))) {\n            return 0;\n        }\n\n        $insert_id = 0;\n\n        $classname = self::CATALOG_TYPES[$type] ?? null;\n\n        if ($classname === null) {\n            return $insert_id;\n        }\n\n        $sql = 'INSERT INTO `catalog` (`name`, `catalog_type`, ' . '`rename_pattern`, `sort_pattern`, `gather_types`) VALUES (?, ?, ?, ?, ?)';\n        Dba::write($sql, array(\n            $name,\n            $type,\n            $rename_pattern,\n            $sort_pattern,\n            $gather_types\n        ));\n\n        $insert_id = Dba::insert_id();\n\n        if (!$insert_id) {\n            AmpError::add('general', T_('Failed to create the catalog, check the debug logs'));\n            debug_event(__CLASS__, 'Insert failed: ' . json_encode($data), 2);\n\n            return 0;\n        }\n\n        /** @var Catalog $classname */\n        if (!$classname::create_type($insert_id, $data)) {\n            $sql = 'DELETE FROM `catalog` WHERE `id` = ?';\n            Dba::write($sql, array($insert_id));\n            $insert_id = 0;\n        }\n\n        return (int)$insert_id;\n    }\n\n    /**\n     * count_tags\n     *\n     * This returns the current number of unique tags in the database.\n     * @return integer\n     */\n    public static function count_tags()\n    {\n        // FIXME: Ignores catalog_id\n        $sql        = \"SELECT COUNT(`id`) FROM `tag`\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_row($db_results);\n        if (empty($row)) {\n            return 0;\n        }\n\n        return $row[0];\n    }\n\n    /**\n     * has_access\n     *\n     * When filtering catalogs you shouldn't be able to play the files\n     * @param int $catalog_id\n     * @param int $user_id\n     * @return bool\n     */\n    public static function has_access($catalog_id, $user_id)\n    {\n        if (!AmpConfig::get('catalog_filter')) {\n            return true;\n        }\n        $params = array($catalog_id, $user_id);\n        $sql    = \"SELECT `catalog_id` FROM `catalog_filter_group_map` WHERE `catalog_id` = ? AND `group_id` IN (SELECT `catalog_filter_group` FROM `user` WHERE `id` = ?);\";\n\n        $db_results = Dba::read($sql, $params);\n        if (Dba::num_rows($db_results)) {\n            return true;\n        }\n\n        return false;\n    } // has_access\n\n    /**\n     * get_server_counts\n     *\n     * This returns the current number of songs, videos, albums, artists, items, etc across all catalogs on the server\n     * @param int $user_id\n     * @return array\n     */\n    public static function get_server_counts($user_id)\n    {\n        $results = array();\n        if ($user_id > 0) {\n            $sql        = \"SELECT `key`, `value` FROM `user_data` WHERE `user` = ?;\";\n            $db_results = Dba::read($sql, array($user_id));\n        } else {\n            $sql        = \"SELECT `key`, `value` FROM `update_info`;\";\n            $db_results = Dba::read($sql);\n        }\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['key']] = (int)$row['value'];\n        }\n\n        return $results;\n    } // get_server_counts\n\n    /**\n     * count_table\n     *\n     * Update a specific table count when adding/removing from the server\n     * @param string $table\n     * @return array\n     */\n    public static function count_table($table)\n    {\n        $sql        = \"SELECT COUNT(`id`) FROM `$table`\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_row($db_results);\n        if (empty($row)) {\n            return array();\n        }\n        self::set_update_info($table, (int)$row[0]);\n\n        return $row;\n    } // count_table\n\n    /**\n     * count_catalog\n     *\n     * This returns the current number of songs, videos, podcast_episodes in this catalog.\n     * @param integer $catalog_id\n     * @return array\n     */\n    public static function count_catalog($catalog_id)\n    {\n        $where_sql = $catalog_id ? 'WHERE `catalog` = ?' : '';\n        $params    = $catalog_id ? array($catalog_id) : array();\n        $results   = array();\n        $catalog   = self::create_from_id($catalog_id);\n\n        if ($catalog->id) {\n            $table = self::get_table_from_type($catalog->gather_types);\n            if ($table == 'podcast_episode' && $catalog_id) {\n                $where_sql = \"WHERE `podcast` IN (SELECT `id` FROM `podcast` WHERE `catalog` = ?)\";\n            }\n            $sql              = \"SELECT COUNT(`id`), IFNULL(SUM(`time`), 0), IFNULL(SUM(`size`), 0) FROM `\" . $table . \"` \" . $where_sql;\n            $db_results       = Dba::read($sql, $params);\n            $row              = Dba::fetch_row($db_results);\n            $results['items'] = ($row[0] ?? 0);\n            $results['time']  = ($row[1] ?? 0);\n            $results['size']  = ($row[2] ?? 0);\n        }\n\n        return $results;\n    } // count_catalog\n\n    /**\n     * get_uploads_sql\n     *\n     * @param string $type\n     * @param integer|null $user_id\n     * @return string\n     */\n    public static function get_uploads_sql($type, $user_id = null)\n    {\n        if ($user_id === null) {\n            $user    = Core::get_global('user');\n            $user_id = $user->id ?? 0;\n        }\n\n        switch ($type) {\n            case 'song':\n                $sql = \"SELECT `song`.`id` AS `id` FROM `song` WHERE `song`.`user_upload` = '\" . $user_id . \"'\";\n                break;\n            case 'album':\n                $sql = \"SELECT `album`.`id` AS `id` FROM `album` JOIN `song` ON `song`.`album` = `album`.`id` WHERE `song`.`user_upload` = '\" . $user_id . \"' GROUP BY `album`.`id`\";\n                break;\n            case 'artist':\n            default:\n                $sql = \"SELECT `artist`.`id` AS `id` FROM `artist` JOIN `song` ON `song`.`artist` = `artist`.`id` WHERE `song`.`user_upload` = '\" . $user_id . \"' GROUP BY `artist`.`id`\";\n                break;\n        }\n\n        return $sql;\n    } // get_uploads_sql\n\n    /**\n     * get_album_ids\n     *\n     * This returns an array of ids of albums that have songs in this\n     * catalog's\n     * @param string $filter\n     * @return integer[]\n     */\n    public function get_album_ids($filter = '')\n    {\n        $results = array();\n\n        $sql = 'SELECT `album`.`id` FROM `album` WHERE `album`.`catalog` = ?';\n        if ($filter === 'art') {\n            $sql = \"SELECT `album`.`id` FROM `album` LEFT JOIN `image` ON `album`.`id` = `image`.`object_id` AND `object_type` = 'album' WHERE `album`.`catalog` = ? AND `image`.`object_id` IS NULL\";\n        }\n        $db_results = Dba::read($sql, array($this->id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return array_reverse($results);\n    }\n\n    /**\n     * get_video_ids\n     *\n     * This returns an array of ids of videos in this catalog\n     * @param string $type\n     * @return integer[]\n     */\n    public function get_video_ids($type = '')\n    {\n        $results = array();\n\n        $sql = 'SELECT DISTINCT(`video`.`id`) AS `id` FROM `video` ';\n        if (!empty($type)) {\n            $sql .= 'JOIN `' . $type . '` ON `' . $type . '`.`id` = `video`.`id`';\n        }\n        $sql .= 'WHERE `video`.`catalog` = ?';\n        $db_results = Dba::read($sql, array($this->id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     *\n     * @param integer[]|null $catalogs\n     * @param string $type\n     * @return Video[]\n     */\n    public static function get_videos($catalogs = null, $type = '')\n    {\n        if (!$catalogs) {\n            $catalogs = self::get_catalogs();\n        }\n\n        $results = array();\n        foreach ($catalogs as $catalog_id) {\n            $catalog   = self::create_from_id($catalog_id);\n            $video_ids = $catalog->get_video_ids($type);\n            foreach ($video_ids as $video_id) {\n                $results[] = Video::create_from_id($video_id);\n            }\n        }\n\n        return $results;\n    }\n\n    /**\n     *\n     * @param integer|null $catalog_id\n     * @param string $type\n     * @return integer\n     */\n    public static function get_videos_count($catalog_id = null, $type = '')\n    {\n        $sql = \"SELECT COUNT(`video`.`id`) AS `video_cnt` FROM `video` \";\n        if (!empty($type)) {\n            $sql .= \"JOIN `\" . $type . \"` ON `\" . $type . \"`.`id` = `video`.`id` \";\n        }\n        if ($catalog_id) {\n            $sql .= \"WHERE `video`.`catalog` = `\" . (string)($catalog_id) . \"`\";\n        }\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_row($db_results);\n        if (empty($row)) {\n            return 0;\n        }\n\n        return $row[0];\n    }\n\n    /**\n     * get_tvshow_ids\n     *\n     * This returns an array of ids of tvshows in this catalog\n     * @return integer[]\n     */\n    public function get_tvshow_ids()\n    {\n        $results = array();\n\n        $sql = 'SELECT DISTINCT(`tvshow`.`id`) AS `id` FROM `tvshow` ';\n        $sql .= 'JOIN `tvshow_season` ON `tvshow_season`.`tvshow` = `tvshow`.`id` ';\n        $sql .= 'JOIN `tvshow_episode` ON `tvshow_episode`.`season` = `tvshow_season`.`id` ';\n        $sql .= 'JOIN `video` ON `video`.`id` = `tvshow_episode`.`id` ';\n        $sql .= 'WHERE `video`.`catalog` = ?';\n\n        $db_results = Dba::read($sql, array($this->id));\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_tvshows\n     * @param integer[]|null $catalogs\n     * @return TvShow[]\n     */\n    public static function get_tvshows($catalogs = null)\n    {\n        if (!$catalogs) {\n            $catalogs = self::get_catalogs();\n        }\n\n        $results = array();\n        foreach ($catalogs as $catalog_id) {\n            $catalog    = self::create_from_id($catalog_id);\n            $tvshow_ids = $catalog->get_tvshow_ids();\n            foreach ($tvshow_ids as $tvshow_id) {\n                $results[] = new TvShow($tvshow_id);\n            }\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_artist_arrays\n     *\n     * Get each array of [id, f_name, name, album_count, catalog_id, has_art] for artists in an array of catalog id's\n     * @param array $catalogs\n     * @return array\n     */\n    public static function get_artist_arrays($catalogs)\n    {\n        $sql  = (count($catalogs) == 1)\n            ? \"SELECT DISTINCT `artist`.`id`, LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) AS `f_name`, `artist`.`name`, `artist`.`album_count`, `catalog_map`.`catalog_id` AS `catalog_id`, `image`.`object_id` AS `has_art` FROM `artist` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'artist' AND `catalog_map`.`object_id` = `artist`.`id` AND `catalog_map`.`catalog_id` = \" . (int)$catalogs[0] . \" LEFT JOIN `image` ON `image`.`object_type` = 'artist' AND `image`.`object_id` = `artist`.`id` AND `image`.`size` = 'original' WHERE `catalog_map`.`catalog_id` IS NOT NULL ORDER BY `f_name`;\"\n            : \"SELECT DISTINCT `artist`.`id`, LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) AS `f_name`, `artist`.`name`, `artist`.`album_count`, MIN(`catalog_map`.`catalog_id`) AS `catalog_id`, `image`.`object_id` AS `has_art` FROM `artist` LEFT JOIN `catalog_map` ON `catalog_map`.`object_type` = 'artist' AND `catalog_map`.`object_id` = `artist`.`id` AND `catalog_map`.`catalog_id` IN (\" . Dba::escape(implode(',', $catalogs)) . \") LEFT JOIN `image` ON `image`.`object_type` = 'artist' AND `image`.`object_id` = `artist`.`id` AND `image`.`size` = 'original' WHERE `catalog_map`.`catalog_id` IS NOT NULL GROUP BY `artist`.`id`, `f_name`, `artist`.`name`, `artist`.`album_count`, `image`.`object_id` ORDER BY `f_name`;\";\n\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results, false)) {\n            $results[] = $row;\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_artist_ids\n     *\n     * This returns an array of ids of artist that have songs in this catalog\n     * @param string $filter\n     * @return integer[]\n     */\n    public function get_artist_ids($filter = '')\n    {\n        $results = array();\n\n        $sql = 'SELECT DISTINCT(`song`.`artist`) AS `artist` FROM `song` WHERE `song`.`catalog` = ?';\n        if ($filter === 'art') {\n            $sql = \"SELECT DISTINCT(`song`.`artist`) AS `artist` FROM `song` LEFT JOIN `image` ON `song`.`artist` = `image`.`object_id` AND `object_type` = 'artist' WHERE `song`.`catalog` = ? AND `image`.`object_id` IS NULL\";\n        }\n        if ($filter === 'info') {\n            // used for recommendations / similar artists\n            $sql = \"SELECT DISTINCT(`artist`.`id`) AS `artist` FROM `artist` WHERE `artist`.`id` NOT IN (SELECT `object_id` FROM `recommendation` WHERE `object_type` = 'artist') ORDER BY RAND() LIMIT 500;\";\n        }\n        if ($filter === 'time') {\n            // used checking musicbrainz and other plugins\n            $sql = \"SELECT DISTINCT(`artist`.`id`) AS `artist` FROM `artist` WHERE (`artist`.`last_update` < (UNIX_TIMESTAMP() - 2629800) AND `artist`.`mbid` LIKE '%-%-%-%-%') ORDER BY RAND();\";\n        }\n        if ($filter === 'count') {\n            // Update for things added in the last run or empty ones\n            $sql = \"SELECT DISTINCT(`artist`.`id`) AS `artist` FROM `artist` WHERE `artist`.`id` IN (SELECT DISTINCT `song`.`artist` FROM `song` WHERE `song`.`catalog` = ? AND `addition_time` > \" . $this->last_add . \") OR (`album_count` = 0 AND `song_count` = 0) \";\n        }\n        $db_results = Dba::read($sql, array($this->id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int) $row['artist'];\n        }\n\n        return array_reverse($results);\n    }\n\n    /**\n     * get_artists\n     *\n     * This returns an array of artists that have songs in the catalogs parameter\n     * @param array|null $catalogs\n     * @param integer $size\n     * @param integer $offset\n     * @return Artist[]\n     */\n    public static function get_artists($catalogs = null, $size = 0, $offset = 0)\n    {\n        $sql_where = \"\";\n        if (is_array($catalogs) && count($catalogs)) {\n            $catlist   = '(' . implode(',', $catalogs) . ')';\n            $sql_where = \"WHERE `song`.`catalog` IN $catlist\";\n        }\n\n        $sql_limit = \"\";\n        if ($offset > 0 && $size > 0) {\n            $sql_limit = \"LIMIT \" . $offset . \", \" . $size;\n        } elseif ($size > 0) {\n            $sql_limit = \"LIMIT \" . $size;\n        } elseif ($offset > 0) {\n            // MySQL doesn't have notation for last row, so we have to use the largest possible BIGINT value\n            // https://dev.mysql.com/doc/refman/5.0/en/select.html  // TODO mysql8 test\n            $sql_limit = \"LIMIT \" . $offset . \", 18446744073709551615\";\n        }\n        $album_type = (AmpConfig::get('album_group')) ? '`artist`.`album_group_count`' : '`artist`.`album_count`';\n\n        $sql = \"SELECT `artist`.`id`, `artist`.`name`, `artist`.`prefix`, `artist`.`summary`, $album_type AS `albums` FROM `song` LEFT JOIN `artist` ON `artist`.`id` = `song`.`artist` $sql_where GROUP BY `artist`.`id`, `artist`.`name`, `artist`.`prefix`, `artist`.`summary`, `song`.`artist`, $album_type ORDER BY `artist`.`name` \" . $sql_limit;\n\n        $results    = array();\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = Artist::construct_from_array($row);\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_catalog_map\n     *\n     * This returns an id of artist that have songs in this catalog\n     * @param string $object_type\n     * @param string $object_id\n     * @return integer\n     */\n    public static function get_catalog_map($object_type, $object_id)\n    {\n        $sql = \"SELECT MIN(`catalog_map`.`catalog_id`) AS `catalog_id` FROM `catalog_map` WHERE `object_type` = ? AND `object_id` = ?\";\n\n        $db_results = Dba::read($sql, array($object_type, $object_id));\n        if ($row = Dba::fetch_assoc($db_results)) {\n            return (int) $row['catalog_id'];\n        }\n\n        return 0;\n    }\n\n    /**\n     * get_id_from_file\n     *\n     * Get media id from the file path.\n     *\n     * @param string $file_path\n     * @param string $media_type\n     * @return integer\n     */\n    public static function get_id_from_file($file_path, $media_type)\n    {\n        $sql        = \"SELECT `id` FROM `$media_type` WHERE `file` = ?;\";\n        $db_results = Dba::read($sql, array($file_path));\n\n        if ($results = Dba::fetch_assoc($db_results)) {\n            return (int)$results['id'];\n        }\n\n        return 0;\n    }\n\n    /**\n     * get_label_ids\n     *\n     * This returns an array of ids of labels\n     * @param string $filter\n     * @return integer[]\n     */\n    public function get_label_ids($filter)\n    {\n        $results = array();\n\n        $sql        = 'SELECT `id` FROM `label` WHERE `category` = ? OR `mbid` IS NULL';\n        $db_results = Dba::read($sql, array($filter));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * @param string $name\n     * @param integer $catalog_id\n     * @return array\n     */\n    public static function search_childrens($name, $catalog_id = 0)\n    {\n        $search                    = array();\n        $search['type']            = \"artist\";\n        $search['rule_0_input']    = $name;\n        $search['rule_0_operator'] = 4;\n        $search['rule_0']          = \"name\";\n        if ($catalog_id > 0) {\n            $search['rule_1_input']    = $catalog_id;\n            $search['rule_1_operator'] = 0;\n            $search['rule_1']          = \"catalog\";\n        }\n        $artists = Search::run($search);\n\n        $childrens = array();\n        foreach ($artists as $artist_id) {\n            $childrens[] = array(\n                'object_type' => 'artist',\n                'object_id' => $artist_id\n            );\n        }\n\n        return $childrens;\n    }\n\n    /**\n     * get_albums\n     *\n     * Returns an array of ids of albums that have songs in the catalogs parameter\n     * @param integer $size\n     * @param integer $offset\n     * @param integer[]|null $catalogs\n     * @return integer[]\n     */\n    public static function get_albums($size = 0, $offset = 0, $catalogs = null)\n    {\n        $sql = \"SELECT `album`.`id` FROM `album` \";\n        if (is_array($catalogs) && count($catalogs)) {\n            $catlist = '(' . implode(',', $catalogs) . ')';\n            $sql     = \"SELECT `album`.`id` FROM `song` LEFT JOIN `album` ON `album`.`id` = `song`.`album` WHERE `song`.`catalog` IN $catlist \";\n        }\n\n        $sql_limit = \"\";\n        if ($offset > 0 && $size > 0) {\n            $sql_limit = \"LIMIT $offset, $size\";\n        } elseif ($size > 0) {\n            $sql_limit = \"LIMIT $size\";\n        } elseif ($offset > 0) {\n            // MySQL doesn't have notation for last row, so we have to use the largest possible BIGINT value\n            // https://dev.mysql.com/doc/refman/5.0/en/select.html\n            $sql_limit = \"LIMIT $offset, 18446744073709551615\";\n        }\n\n        $sql .= \"GROUP BY `album`.`id` ORDER BY `album`.`name` $sql_limit\";\n\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_albums_by_artist\n     *\n     * Returns an array of ids of albums that have songs in the catalogs parameter, grouped by artist\n     * @param integer $size\n     * @param integer $offset\n     * @param integer[]|null $catalogs\n     * @return integer[]\n     * @oaram int $offset\n     */\n    public static function get_albums_by_artist($size = 0, $offset = 0, $catalogs = null)\n    {\n        $sql       = \"SELECT `album`.`id` FROM `album` \";\n        $sql_where = \"\";\n        $sql_group = \"GROUP BY `album`.`id`, `artist`.`name`, `artist`.`id`, `album`.`name`, `album`.`mbid`\";\n        if (is_array($catalogs) && count($catalogs)) {\n            $catlist   = '(' . implode(',', $catalogs) . ')';\n            $sql       = \"SELECT `song`.`album` as 'id' FROM `song` LEFT JOIN `album` ON `album`.`id` = `song`.`album` \";\n            $sql_where = \"WHERE `song`.`catalog` IN $catlist\";\n            $sql_group = \"GROUP BY `song`.`album`, `artist`.`name`, `artist`.`id`, `album`.`name`, `album`.`mbid`\";\n        }\n\n        $sql_limit = \"\";\n        if ($offset > 0 && $size > 0) {\n            $sql_limit = \"LIMIT $offset, $size\";\n        } elseif ($size > 0) {\n            $sql_limit = \"LIMIT $size\";\n        } elseif ($offset > 0) {\n            // MySQL doesn't have notation for last row, so we have to use the largest possible BIGINT value\n            // https://dev.mysql.com/doc/refman/5.0/en/select.html  // TODO mysql8 test\n            $sql_limit = \"LIMIT $offset, 18446744073709551615\";\n        }\n\n        $sql .= \"LEFT JOIN `artist` ON `artist`.`id` = `album`.`album_artist` $sql_where $sql_group ORDER BY `artist`.`name`, `artist`.`id`, `album`.`name` $sql_limit\";\n\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_podcast_ids\n     *\n     * This returns an array of ids of podcasts in this catalog\n     * @return integer[]\n     */\n    public function get_podcast_ids()\n    {\n        $results = array();\n\n        $sql = 'SELECT `podcast`.`id` FROM `podcast` ';\n        $sql .= 'WHERE `podcast`.`catalog` = ?';\n        $db_results = Dba::read($sql, array($this->id));\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     *\n     * @param integer[]|null $catalogs\n     * @return Podcast[]\n     */\n    public static function get_podcasts($catalogs = null)\n    {\n        if (!$catalogs) {\n            $catalogs = self::get_catalogs('podcast');\n        }\n\n        $results = array();\n        foreach ($catalogs as $catalog_id) {\n            $catalog     = self::create_from_id($catalog_id);\n            $podcast_ids = $catalog->get_podcast_ids();\n            foreach ($podcast_ids as $podcast_id) {\n                $results[] = new Podcast($podcast_id);\n            }\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_newest_podcasts_ids\n     *\n     * This returns an array of ids of latest podcast episodes in this catalog\n     * @param integer $count\n     * @return integer[]\n     */\n    public function get_newest_podcasts_ids($count)\n    {\n        $results = array();\n\n        $sql = 'SELECT `podcast_episode`.`id` FROM `podcast_episode` INNER JOIN `podcast` ON `podcast`.`id` = `podcast_episode`.`podcast` WHERE `podcast`.`catalog` = ? ORDER BY `podcast_episode`.`pubdate` DESC';\n        if ($count > 0) {\n            $sql .= ' LIMIT ' . (string)$count;\n        }\n        $db_results = Dba::read($sql, array($this->id));\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     *\n     * @param integer $count\n     * @return Podcast_Episode[]\n     */\n    public static function get_newest_podcasts($count)\n    {\n        $catalogs = self::get_catalogs('podcast');\n        $results  = array();\n\n        foreach ($catalogs as $catalog_id) {\n            $catalog     = self::create_from_id($catalog_id);\n            $episode_ids = $catalog->get_newest_podcasts_ids($count);\n            foreach ($episode_ids as $episode_id) {\n                $results[] = new Podcast_Episode($episode_id);\n            }\n        }\n\n        return $results;\n    }\n\n    /**\n     * gather_art_item\n     * @param string $type\n     * @param integer $object_id\n     * @param boolean $db_art_first\n     * @param boolean $api\n     * @return boolean\n     */\n    public static function gather_art_item($type, $object_id, $db_art_first = false, $api = false)\n    {\n        // Should be more generic !\n        if ($type == 'video') {\n            $libitem = Video::create_from_id($object_id);\n        } else {\n            $class_name = ObjectTypeToClassNameMapper::map($type);\n            $libitem    = new $class_name($object_id);\n        }\n        $inserted = false;\n        $options  = array();\n        $libitem->format();\n        if ($libitem->id) {\n            // Only search on items with default art kind AS `default`.\n            if ($libitem->get_default_art_kind() == 'default') {\n                $keywords = $libitem->get_keywords();\n                $keyword  = '';\n                foreach ($keywords as $key => $word) {\n                    $options[$key] = $word['value'];\n                    if (array_key_exists('important', $word) && !empty($word['value'])) {\n                        $keyword .= ' ' . $word['value'];\n                    }\n                }\n                $options['keyword'] = $keyword;\n            }\n\n            $parent = $libitem->get_parent();\n            if (!empty($parent) && $type !== 'album') {\n                self::gather_art_item($parent['object_type'], $parent['object_id'], $db_art_first, $api);\n            }\n        }\n\n        $art = new Art($object_id, $type);\n        // don't search for art when you already have it\n        if ($art->has_db_info() && $db_art_first) {\n            debug_event(__CLASS__, \"gather_art_item $type: {{$object_id}} blocked\", 5);\n            $results = array();\n        } else {\n            debug_event(__CLASS__, \"gather_art_item $type: {{$object_id}} searching\", 4);\n\n            global $dic;\n            $results = $dic->get(ArtCollectorInterface::class)->collect(\n                $art,\n                $options\n            );\n        }\n\n        foreach ($results as $result) {\n            // Pull the string representation from the source\n            $image = Art::get_from_source($result, $type);\n            if (strlen((string)$image) > '5') {\n                $inserted = $art->insert($image, $result['mime']);\n                // If they've enabled resizing of images generate a thumbnail\n                if (AmpConfig::get('resize_images')) {\n                    $size  = array('width' => 275, 'height' => 275);\n                    $thumb = $art->generate_thumb($image, $size, $result['mime']);\n                    if (!empty($thumb)) {\n                        $art->save_thumb($thumb['thumb'], $thumb['thumb_mime'], $size);\n                    }\n                }\n                if ($inserted) {\n                    break;\n                }\n            } elseif ($result === true) {\n                debug_event(__CLASS__, 'Database already has image.', 3);\n            } else {\n                debug_event(__CLASS__, 'Image less than 5 chars, not inserting', 3);\n            }\n        }\n\n        if ($type == 'video' && AmpConfig::get('generate_video_preview')) {\n            Video::generate_preview($object_id);\n        }\n\n        if (Ui::check_ticker() && !$api) {\n            Ui::update_text('read_art_' . $object_id, $libitem->get_fullname());\n        }\n        if ($inserted) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * gather_art\n     *\n     * This runs through all of the albums and finds art for them\n     * This runs through all of the needs art albums and tries\n     * to find the art for them from the mp3s\n     * @param integer[]|null $songs\n     * @param integer[]|null $videos\n     * @return boolean\n     */\n    public function gather_art($songs = null, $videos = null)\n    {\n        // Make sure they've actually got methods\n        $art_order       = AmpConfig::get('art_order');\n        $gather_song_art = AmpConfig::get('gather_song_art', false);\n        $db_art_first    = ($art_order[0] == 'db');\n        if (!count($art_order)) {\n            debug_event(__CLASS__, 'art_order not set, self::gather_art aborting', 3);\n\n            return false;\n        }\n\n        // Prevent the script from timing out\n        set_time_limit(0);\n\n        $search_count = 0;\n        $searches     = array();\n        if ($songs == null) {\n            $searches['album']  = $this->get_album_ids('art');\n            $searches['artist'] = $this->get_artist_ids('art');\n            if ($gather_song_art) {\n                $searches['song'] = $this->get_song_ids();\n            }\n        } else {\n            $searches['album']  = array();\n            $searches['artist'] = array();\n            if ($gather_song_art) {\n                $searches['song'] = array();\n            }\n            foreach ($songs as $song_id) {\n                $song = new Song($song_id);\n                if ($song->id) {\n                    if (!in_array($song->album, $searches['album'])) {\n                        $searches['album'][] = $song->album;\n                    }\n                    if (!in_array($song->artist, $searches['artist'])) {\n                        $searches['artist'][] = $song->artist;\n                    }\n                    if ($gather_song_art) {\n                        $searches['song'][] = $song->id;\n                    }\n                }\n            }\n        }\n        if ($videos == null) {\n            $searches['video'] = $this->get_video_ids();\n        } else {\n            $searches['video'] = $videos;\n        }\n\n        debug_event(__CLASS__, 'gather_art found ' . (string) count($searches) . ' items missing art', 4);\n        // Run through items and get the art!\n        foreach ($searches as $key => $values) {\n            foreach ($values as $object_id) {\n                self::gather_art_item($key, $object_id, $db_art_first);\n\n                // Stupid little cutesie thing\n                $search_count++;\n                if (Ui::check_ticker()) {\n                    Ui::update_text('count_art_' . $this->id, $search_count);\n                }\n            }\n        }\n        // One last time for good measure\n        Ui::update_text('count_art_' . $this->id, $search_count);\n\n        return true;\n    }\n\n    /**\n     * gather_artist_info\n     *\n     * This runs through all of the artists and refreshes last.fm information\n     * including similar artists that exist in your catalog.\n     * @param array $artist_list\n     */\n    public function gather_artist_info($artist_list = array())\n    {\n        // Prevent the script from timing out\n        set_time_limit(0);\n\n        $search_count = 0;\n        debug_event(__CLASS__, 'gather_artist_info found ' . (string) count($artist_list) . ' items to check', 4);\n        // Run through items and refresh info\n        foreach ($artist_list as $object_id) {\n            Recommendation::get_artist_info($object_id);\n            Recommendation::get_artists_like($object_id);\n            Artist::set_last_update($object_id);\n            // get similar songs too\n            $artistSongs = static::getSongRepository()->getAllByArtist($object_id);\n            foreach ($artistSongs as $song_id) {\n                Recommendation::get_songs_like($song_id);\n            }\n\n            // Stupid little cutesie thing\n            $search_count++;\n            if (Ui::check_ticker()) {\n                Ui::update_text('count_artist_' . $object_id, $search_count);\n            }\n        }\n\n        // One last time for good measure\n        Ui::update_text('count_artist_complete', $search_count);\n    }\n\n    /**\n     * update_from_external\n     *\n     * This runs through all of the labels and refreshes information from musicbrainz\n     * @param array $object_list\n     * @param string $object_type\n     */\n    public function update_from_external($object_list, $object_type)\n    {\n        // Prevent the script from timing out\n        set_time_limit(0);\n\n        debug_event(__CLASS__, 'update_from_external found ' . (string) count($object_list) . ' ' . $object_type . '\\'s to check', 4);\n\n        // only allow your primary external metadata source to update values\n        $overwrites   = true;\n        $meta_order   = array_map('strtolower', static::getConfigContainer()->get(ConfigurationKeyEnum::METADATA_ORDER));\n        $plugin_list  = Plugin::get_plugins('get_external_metadata');\n        $user         = (!empty(Core::get_global('user')))\n            ? Core::get_global('user')\n            : new User(-1);\n        foreach ($meta_order as $plugin_name) {\n            if (in_array($plugin_name, $plugin_list)) {\n                // only load metadata plugins you enable\n                $plugin = new Plugin($plugin_name);\n                if ($plugin->load($user) && $overwrites) {\n                    debug_event(__CLASS__, \"get_external_metadata with: \" . $plugin_name, 3);\n                    // Run through items and refresh info\n                    switch ($object_type) {\n                        case 'label':\n                            foreach ($object_list as $label_id) {\n                                $label = new Label($label_id);\n                                $plugin->_plugin->get_external_metadata($label, 'label');\n                            }\n                            break;\n                        case 'artist':\n                            foreach ($object_list as $artist_id) {\n                                $artist = new Artist($artist_id);\n                                $plugin->_plugin->get_external_metadata($artist, 'artist');\n                            }\n                            $overwrites = false;\n                            break;\n                        default:\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * get_songs\n     *\n     * Returns an array of song objects.\n     * @return Song[]\n     */\n    public function get_songs()\n    {\n        $songs   = array();\n        $results = array();\n\n        $sql        = \"SELECT `id` FROM `song` WHERE `catalog` = ? AND `enabled` = '1' ORDER BY `album`\";\n        $db_results = Dba::read($sql, array($this->id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $songs[] = (int)$row['id'];\n        }\n\n        if (AmpConfig::get('memory_cache')) {\n            Song::build_cache($songs);\n        }\n\n        foreach ($songs as $song_id) {\n            $results[] = new Song($song_id);\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_song_ids\n     *\n     * Returns an array of song ids.\n     * @return integer[]\n     */\n    public function get_song_ids()\n    {\n        $songs = array();\n\n        $sql        = \"SELECT `id` FROM `song` WHERE `catalog` = ? AND `enabled` = '1'\";\n        $db_results = Dba::read($sql, array($this->id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $songs[] = (int)$row['id'];\n        }\n\n        return $songs;\n    }\n\n    /**\n     * update_last_update\n     * updates the last_update of the catalog\n     */\n    protected function update_last_update()\n    {\n        $date = time();\n        $sql  = \"UPDATE `catalog` SET `last_update` = ? WHERE `id` = ?\";\n        Dba::write($sql, array($date, $this->id));\n    } // update_last_update\n\n    /**\n     * update_last_add\n     * updates the last_add of the catalog\n     */\n    public function update_last_add()\n    {\n        $date = time();\n        $sql  = \"UPDATE `catalog` SET `last_add` = ? WHERE `id` = ?\";\n        Dba::write($sql, array($date, $this->id));\n    } // update_last_add\n\n    /**\n     * update_last_clean\n     * This updates the last clean information\n     */\n    public function update_last_clean()\n    {\n        $date = time();\n        $sql  = \"UPDATE `catalog` SET `last_clean` = ? WHERE `id` = ?\";\n        Dba::write($sql, array($date, $this->id));\n    } // update_last_clean\n\n    /**\n     * update_settings\n     * This function updates the basic setting of the catalog\n     * @param array $data\n     * @return boolean\n     */\n    public static function update_settings($data)\n    {\n        $sql    = \"UPDATE `catalog` SET `name` = ?, `rename_pattern` = ?, `sort_pattern` = ? WHERE `id` = ?\";\n        $params = array($data['name'], $data['rename_pattern'], $data['sort_pattern'], $data['catalog_id']);\n        Dba::write($sql, $params);\n\n        return true;\n    } // update_settings\n\n    /**\n     * update_single_item\n     * updates a single album,artist,song from the tag data and return the id. (if the artist/album changes it's updated)\n     * this can be done by 75+\n     * @param string $type\n     * @param integer $object_id\n     * @param boolean $api\n     * @return array\n     */\n    public static function update_single_item($type, $object_id, $api = false)\n    {\n        // Because single items are large numbers of things too\n        set_time_limit(0);\n\n        $songs   = array();\n        $result  = $object_id;\n        $libitem = 0;\n\n        switch ($type) {\n            case 'album':\n                $libitem = new Album($object_id);\n                $songs   = static::getSongRepository()->getByAlbum($object_id);\n                break;\n            case 'artist':\n                $libitem = new Artist($object_id);\n                $songs   = static::getSongRepository()->getAllByArtist($object_id);\n                break;\n            case 'song':\n                $songs[] = $object_id;\n                break;\n            case 'podcast_episode':\n                $episode = new Podcast_Episode($object_id);\n                self::update_media_from_tags($episode);\n\n                return array(\n                    'object_id' => $object_id,\n                    'change' => true\n                );\n        } // end switch type\n\n        if (!$api) {\n            echo '<table class=\"tabledata striped-rows\">' . \"\\n\";\n            echo '<thead><tr class=\"th-top\">' . \"\\n\";\n            echo \"<th>\" . T_(\"Song\") . \"</th><th>\" . T_(\"Status\") . \"</th>\\n\";\n            echo \"<tbody>\\n\";\n        }\n        $album  = false;\n        $artist = false;\n        $tags   = false;\n        $maps   = false;\n        foreach ($songs as $song_id) {\n            $song   = new Song($song_id);\n            $info   = self::update_media_from_tags($song);\n            $file   = scrub_out($song->file);\n            $diff   = array_key_exists('element', $info) && is_array($info['element']) && !empty($info['element']);\n            $album  = ($album == true) || ($diff && array_key_exists('album', $info['element']));\n            $artist = ($artist == true) || ($diff && array_key_exists('artist', $info['element']));\n            $tags   = ($tags == true) || ($diff && array_key_exists('tags', $info['element']));\n            $maps   = ($maps == true) || ($diff && array_key_exists('maps', $info));\n            // don't echo useless info when using api\n            if (array_key_exists('change', $info) && $info['change'] && (!$api)) {\n                if ($diff && array_key_exists($type, $info['element'])) {\n                    $element = explode(' --> ', (string)$info['element'][$type]);\n                    $result  = (int)$element[1];\n                }\n                echo \"<tr><td>\" . $file . \"</td><td>\" . T_('Updated') . \"</td></tr>\\n\";\n            } elseif (array_key_exists('error', $info) && $info['error'] && (!$api)) {\n                echo '<tr><td>' . $file . \"</td><td>\" . T_('Error') . \"</td></tr>\\n\";\n            } elseif (!$api) {\n                echo '<tr><td>' . $file . \"</td><td>\" . T_('No Update Needed') . \"</td></tr>\\n\";\n            }\n            flush();\n        } // foreach songs\n        if (!$api) {\n            echo \"</tbody></table>\\n\";\n        }\n        // Update the tags for parent items (Songs -> Albums -> Artist)\n        if ($libitem instanceof Album) {\n            $tags    = self::getSongTags('album', $libitem->id);\n            Tag::update_tag_list(implode(',', $tags), 'album', $libitem->id, true);\n            if ($artist || $album || $tags || $maps) {\n                $artists = array();\n                // update the album artists\n                foreach (Album::get_artist_map('album', $libitem->id) as $albumArtist_id) {\n                    $artists[] = $albumArtist_id;\n                    $tags      = self::getSongTags('artist', $albumArtist_id);\n                    Tag::update_tag_list(implode(',', $tags), 'artist', $albumArtist_id, true);\n                }\n                // update the song artists too\n                foreach (Album::get_artist_map('song', $libitem->id) as $songArtist_id) {\n                    if (!in_array($songArtist_id, $artists)) {\n                        $tags = self::getSongTags('artist', $songArtist_id);\n                        Tag::update_tag_list(implode(',', $tags), 'artist', $songArtist_id, true);\n                    }\n                }\n            }\n        }\n        // artist\n        if ($libitem instanceof Artist) {\n            // make sure albums are updated before the artist (include if you're just a song artist too)\n            foreach (static::getAlbumRepository()->getByArtist($object_id) as $album_id) {\n                $album_tags = self::getSongTags('album', $album_id);\n                Tag::update_tag_list(implode(',', $album_tags), 'album', $album_id, true);\n            }\n            // refresh the artist tags after everything else\n            $tags = self::getSongTags('artist', $libitem->id);\n            Tag::update_tag_list(implode(',', $tags), 'artist', $libitem->id, true);\n        }\n        // check counts\n        if ($album || $maps || $type == 'album') {\n            Album::update_album_counts();\n        }\n        if ($artist || $maps || $type == 'artist') {\n            Artist::update_artist_counts();\n        }\n        // collect the garbage too\n        if ($album || $artist || $maps) {\n            Artist::garbage_collection();\n            static::getAlbumRepository()->collectGarbage();\n        }\n\n        return array(\n            'object_id' => $result,\n            'change' => ($album || $artist || $maps || $tags)\n        );\n    } // update_single_item\n\n    /**\n     * update_media_from_tags\n     * This is a 'wrapper' function calls the update function for the media\n     * type in question\n     * @param Song|Video|Podcast_Episode $media\n     * @param array $gather_types\n     * @param string $sort_pattern\n     * @param string $rename_pattern\n     * @return array\n     */\n    public static function update_media_from_tags(\n        $media,\n        $gather_types = array('music'),\n        $sort_pattern = '',\n        $rename_pattern = ''\n    ) {\n        $array   = array();\n        $catalog = self::create_from_id($media->catalog);\n        if ($catalog === null) {\n            debug_event(__CLASS__, 'update_media_from_tags: Error loading catalog ' . $media->catalog, 2);\n            $array['error']  = true;\n\n            return $array;\n        }\n\n        //retrieve the file if needed\n        $media = $catalog->prepare_media($media);\n\n        if (Core::get_filesize(Core::conv_lc_file($media->file)) == 0) {\n            debug_event(__CLASS__, 'update_media_from_tags: Error loading file ' . $media->file, 2);\n            $array['error']  = true;\n\n            return $array;\n        }\n\n        $type      = ObjectTypeToClassNameMapper::reverseMap(get_class($media));\n        $functions = [\n            'song' => static function ($results, $media) {\n                return self::update_song_from_tags($results, $media);\n            },\n            'video' => static function ($results, $media) {\n                return self::update_video_from_tags($results, $media);\n            },\n            'podcast_episode' => static function ($results, $media) {\n                return self::update_podcast_episode_from_tags($results, $media);\n            },\n        ];\n\n        $callable = $functions[$type];\n\n        // try and get the tags from your file\n        debug_event(__CLASS__, 'Reading tags from ' . $media->file, 4);\n        $extension = strtolower(pathinfo($media->file, PATHINFO_EXTENSION));\n        $results   = $catalog->get_media_tags($media, $gather_types, $sort_pattern, $rename_pattern);\n        // for files without tags try to update from their file name instead\n        if ($media->id && in_array($extension, array('wav', 'shn'))) {\n            // match against your catalog 'Filename Pattern' and 'Folder Pattern'\n            $patres  = vainfo::parse_pattern($media->file, $catalog->sort_pattern, $catalog->rename_pattern);\n            $results = array_merge($results, $patres);\n        }\n        $update = $callable($results, $media);\n\n        // remote catalogs should unlink the temp files if needed //TODO add other types of remote catalog\n        if ($catalog instanceof Catalog_Seafile) {\n            $catalog->clean_tmp_file($media->file);\n        }\n\n        return $update;\n    } // update_media_from_tags\n\n    /**\n     * update_song_from_tags\n     * Updates the song info based on tags; this is called from a bunch of\n     * different places and passes in a full fledged song object, so it's a\n     * static function.\n     * FIXME: This is an ugly mess, this really needs to be consolidated and cleaned up.\n     * @param array $results\n     * @param Song $song\n     * @return array\n     * @throws ReflectionException\n     */\n    public static function update_song_from_tags($results, Song $song)\n    {\n        //debug_event(__CLASS__, \"update_song_from_tags results: \" . print_r($results, true), 4);\n        // info for the song table. This is all the primary file data that is song related\n        $new_song       = new Song();\n        $new_song->file = $results['file'];\n        $new_song->year = (strlen((string)$results['year']) > 4)\n            ? (int)substr($results['year'], -4, 4)\n            : (int)($results['year']);\n        $new_song->title   = self::check_length(self::check_title($results['title'], $new_song->file));\n        $new_song->bitrate = $results['bitrate'];\n        $new_song->rate    = $results['rate'];\n        $new_song->mode    = ($results['mode'] == 'cbr') ? 'cbr' : 'vbr';\n        $new_song->size    = $results['size'];\n        $new_song->time    = (strlen((string)$results['time']) > 5)\n            ? (int)substr($results['time'], -5, 5)\n            : (int)($results['time']);\n        if ($new_song->time < 0) {\n            // fall back to last time if you fail to scan correctly\n            $new_song->time = $song->time;\n        }\n        $new_song->track    = self::check_track((string)$results['track']);\n        $new_song->mbid     = $results['mb_trackid'];\n        $new_song->composer = self::check_length($results['composer']);\n        $new_song->mime     = $results['mime'];\n\n        // info for the song_data table. used in Song::update_song\n        $new_song->comment     = $results['comment'];\n        $new_song->lyrics      = str_replace(\n            [\"\\r\\n\", \"\\r\", \"\\n\"],\n            '<br />',\n            strip_tags($results['lyrics'])\n        );\n        if (isset($results['license'])) {\n            $licenseRepository = static::getLicenseRepository();\n            $licenseName       = (string) $results['license'];\n            $licenseId         = $licenseRepository->find($licenseName);\n\n            $new_song->license = $licenseId === 0 ? $licenseRepository->create($licenseName, '', '') : $licenseId;\n        } else {\n            $new_song->license = null;\n        }\n        $new_song->label = isset($results['publisher']) ? self::check_length($results['publisher'], 128) : null;\n        if ($song->label && AmpConfig::get('label')) {\n            // create the label if missing\n            foreach (array_map('trim', explode(';', $new_song->label)) as $label_name) {\n                Label::helper($label_name);\n            }\n        }\n        $new_song->language              = self::check_length($results['language'], 128);\n        $new_song->replaygain_track_gain = (!is_null($results['replaygain_track_gain'])) ? (float) $results['replaygain_track_gain'] : null;\n        $new_song->replaygain_track_peak = (!is_null($results['replaygain_track_peak'])) ? (float) $results['replaygain_track_peak'] : null;\n        $new_song->replaygain_album_gain = (!is_null($results['replaygain_album_gain'])) ? (float) $results['replaygain_album_gain'] : null;\n        $new_song->replaygain_album_peak = (!is_null($results['replaygain_album_peak'])) ? (float) $results['replaygain_album_peak'] : null;\n        $new_song->r128_track_gain       = (!is_null($results['r128_track_gain'])) ? (int) $results['r128_track_gain'] : null;\n        $new_song->r128_album_gain       = (!is_null($results['r128_album_gain'])) ? (int) $results['r128_album_gain'] : null;\n\n        // genre is used in the tag and tag_map tables\n        $tag_array = array();\n        if (!empty($results['genre'])) {\n            if (!is_array($results['genre'])) {\n                $results['genre'] = array($results['genre']);\n            }\n            // check if this thing has been renamed into something else\n            foreach ($results['genre'] as $tagName) {\n                $merged = Tag::construct_from_name($tagName);\n                if ($merged && $merged->is_hidden) {\n                    foreach ($merged->get_merged_tags() as $merged_tag) {\n                        $tag_array[] = $merged_tag['name'];\n                    }\n                } else {\n                    $tag_array[] = $tagName;\n                }\n            }\n        }\n        $new_song->tags = $tag_array;\n        $tags           = Tag::get_object_tags('song', $song->id);\n        if ($tags) {\n            foreach ($tags as $tag) {\n                $song->tags[] = $tag['name'];\n            }\n        }\n        // info for the artist table.\n        $artist           = self::check_length($results['artist']);\n        $artist_mbid      = $results['mb_artistid'];\n        $albumartist_mbid = $results['mb_albumartistid'];\n        // info for the album table.\n        $album      = self::check_length($results['album']);\n        $album_mbid = $results['mb_albumid'];\n        $disk       = $results['disk'];\n        // year is also included in album\n        $album_mbid_group = $results['mb_albumid_group'];\n        $release_type     = self::check_length($results['release_type'], 32);\n        $release_status   = $results['release_status'];\n        $albumartist      = self::check_length($results['albumartist']) ?? $song->get_album_artist_fullname();\n        $albumartist      = $albumartist ?? null;\n        $original_year    = $results['original_year'];\n        $barcode          = self::check_length($results['barcode'], 64);\n        $catalog_number   = self::check_length($results['catalog_number'], 64);\n        // info for the artist_map table.\n        $artists_array          = $results['artists'] ?? array();\n        $artist_mbid_array      = $results['mb_artistid_array'] ?? array();\n        $albumartist_mbid_array = $results['mb_albumartistid_array'] ?? array();\n        // if you have an artist array this will be named better than what your tags will give you\n        if (!empty($artists_array)) {\n            if (!empty($artist) && !empty($albumartist) && $artist == $albumartist) {\n                $albumartist = $artists_array[0];\n            }\n            $artist = $artists_array[0];\n        }\n        $is_upload_artist = false;\n        if ($song->artist) {\n            $is_upload_artist = Artist::is_upload($song->artist);\n            if ($is_upload_artist) {\n                debug_event(__CLASS__, \"$song->artist : is an uploaded song artist\", 4);\n                $artist_mbid_array = array();\n            }\n        }\n        $is_upload_albumartist = false;\n        if ($song->album) {\n            $is_upload_albumartist = Artist::is_upload($song->albumartist);\n            if ($is_upload_albumartist) {\n                debug_event(__CLASS__, \"$song->albumartist : is an uploaded album artist\", 4);\n                $albumartist_mbid_array = array();\n            }\n        }\n        // check whether this artist exists (and the album_artist)\n        $new_song->artist = ($is_upload_artist)\n            ? $song->artist\n            : Artist::check($artist, $artist_mbid);\n        if ($albumartist || !empty($song->albumartist)) {\n            $new_song->albumartist = ($is_upload_albumartist)\n                ? $song->albumartist\n                : Artist::check($albumartist, $albumartist_mbid);\n            if (!$new_song->albumartist) {\n                $new_song->albumartist = $song->albumartist;\n            }\n        }\n        if (!$new_song->artist) {\n            $new_song->artist = $song->artist;\n        }\n\n        // check whether this album exists\n        $new_song->album = ($is_upload_albumartist)\n            ? $song->album\n            : Album::check($song->catalog, $album, $new_song->year, $disk, $album_mbid, $album_mbid_group, $new_song->albumartist, $release_type, $release_status, $original_year, $barcode, $catalog_number);\n        if (!$new_song->album) {\n            $new_song->album = $song->album;\n        }\n\n        // get the artists / album_artists for this song\n        $songArtist_array  = array($new_song->artist);\n        $albumArtist_array = array($new_song->albumartist);\n        // artist_map stores song and album against the artist_id\n        $artist_map_song  = Artist::get_artist_map('song', $song->id);\n        $artist_map_album = Artist::get_artist_map('album', $new_song->album);\n        // album_map stores song_artist and album_artist against the album_id\n        $album_map_songArtist  = Album::get_artist_map('song', $new_song->album);\n        $album_map_albumArtist = Album::get_artist_map('album', $new_song->album);\n        // don't update counts unless something changes\n        $map_change = false;\n\n        // add song artists with a valid mbid to the list\n        if (!empty($artist_mbid_array)) {\n            foreach ($artist_mbid_array as $song_artist_mbid) {\n                $songArtist_id = Artist::check_mbid($song_artist_mbid);\n                if ($songArtist_id > 0 && !in_array($songArtist_id, $songArtist_array)) {\n                    $songArtist_array[] = $songArtist_id;\n                }\n            }\n        }\n        // add song artists found by name to the list (Ignore artist names when we have the same amount of MBID's)\n        if (!empty($artists_array) && count($artists_array) > count($artist_mbid_array)) {\n            foreach ($artists_array as $artist_name) {\n                $songArtist_id = Artist::check($artist_name);\n                if ($songArtist_id > 0 && !in_array($songArtist_id, $songArtist_array)) {\n                    $songArtist_array[] = $songArtist_id;\n                }\n            }\n        }\n        // map every song artist we've found\n        foreach ($songArtist_array as $songArtist_id) {\n            if (!in_array($songArtist_id, $artist_map_song)) {\n                $artist_map_song[] = (int)$songArtist_id;\n                Artist::add_artist_map($songArtist_id, 'song', $song->id);\n                if ($song->played) {\n                    Stats::duplicate_map('song', $song->id, 'artist', $songArtist_id);\n                }\n                $map_change = true;\n            }\n            if (!in_array($songArtist_id, $album_map_songArtist)) {\n                $album_map_songArtist[] = $songArtist_id;\n                Album::add_album_map($new_song->album, 'song', $songArtist_id);\n                if ($song->played) {\n                    Stats::duplicate_map('song', $song->id, 'artist', $songArtist_id);\n                }\n                $map_change = true;\n            }\n        }\n        // add album artists to the list\n        if (!empty($albumartist_mbid_array)) {\n            foreach ($albumartist_mbid_array as $album_artist_mbid) {\n                $albumArtist_id = Artist::check_mbid($album_artist_mbid);\n                if ($albumArtist_id > 0 && !in_array($albumArtist_id, $albumArtist_array)) {\n                    $albumArtist_array[] = $albumArtist_id;\n                }\n            }\n        }\n        // map every album artist we've found\n        foreach ($albumArtist_array as $albumArtist_id) {\n            if (!in_array($albumArtist_id, $artist_map_album)) {\n                $artist_map_album[] = $albumArtist_id;\n                Artist::add_artist_map($albumArtist_id, 'album', $new_song->album);\n                $map_change = true;\n            }\n            if (!in_array($albumArtist_id, $album_map_albumArtist)) {\n                $album_map_albumArtist[] = $albumArtist_id;\n                Album::add_album_map($new_song->album, 'album', $albumArtist_id);\n                $map_change = true;\n            }\n        }\n        // clean up the mapped things that are missing after the update\n        foreach ($artist_map_song as $existing_map) {\n            if (!in_array($existing_map, $songArtist_array)) {\n                Artist::remove_artist_map($existing_map, 'song', $song->id);\n                Album::check_album_map($song->album, 'song', $existing_map);\n                if ($song->played) {\n                    Stats::delete_map('song', $song->id, 'artist', $existing_map);\n                }\n                $map_change = true;\n            }\n        }\n        foreach ($artist_map_song as $existing_map) {\n            $not_found = !in_array($existing_map, $songArtist_array);\n            // remove album song map if song artist is changed OR album changes\n            if ($not_found || ($song->album != $new_song->album)) {\n                Album::check_album_map($song->album, 'song', $existing_map);\n                $map_change = true;\n            }\n            // only delete play count on song artist change\n            if ($not_found && $song->played) {\n                Stats::delete_map('song', $song->id, 'artist', $existing_map);\n                $map_change = true;\n            }\n        }\n        foreach ($artist_map_album as $existing_map) {\n            if (!in_array($existing_map, $albumArtist_array)) {\n                Artist::remove_artist_map($existing_map, 'album', $song->album);\n                Album::check_album_map($song->album, 'album', $existing_map);\n                $map_change = true;\n            }\n        }\n        foreach ($album_map_songArtist as $existing_map) {\n            // check song maps in the album_map table (because this is per song we need to check the whole album)\n            if (Album::check_album_map($song->album, 'song', $existing_map)) {\n                $map_change = true;\n            }\n        }\n        foreach ($album_map_albumArtist as $existing_map) {\n            if (!in_array($existing_map, $albumArtist_array)) {\n                Album::remove_album_map($song->album, 'album', $existing_map);\n                $map_change = true;\n            }\n        }\n\n        if ($artist_mbid) {\n            $new_song->artist_mbid = $artist_mbid;\n        }\n        if ($album_mbid) {\n            $new_song->album_mbid = $album_mbid;\n        }\n        if ($albumartist_mbid) {\n            $new_song->albumartist_mbid = $albumartist_mbid;\n        }\n\n        /* Since we're doing a full compare make sure we fill the extended information */\n        $song->fill_ext_info();\n\n        if (AmpConfig::get('enable_custom_metadata')) {\n            $ctags = self::get_clean_metadata($song, $results);\n            //debug_event(__CLASS__, \"get_clean_metadata \" . print_r($ctags, true), 4);\n            if (method_exists($song, 'updateOrInsertMetadata')) {\n                $ctags = array_diff_key($ctags, array_flip($song->getDisabledMetadataFields()));\n                foreach ($ctags as $tag => $value) {\n                    $field = $song->getField($tag);\n                    $song->updateOrInsertMetadata($field, $value);\n                }\n            }\n            if (method_exists($song, 'deleteMetadata')) {\n                foreach ($song->getMetadata() as $metadata) {\n                    $metaName = $metadata->getField()->getName();\n                    if (!array_key_exists($metaName, $ctags)) {\n                        debug_event(__CLASS__, \"delete metadata field \" . $metaName, 4);\n                        $song->deleteMetadata($metadata);\n                    }\n                }\n            }\n        }\n\n        // Duplicate arts if required\n        if (($song->artist && $new_song->artist) && $song->artist != $new_song->artist) {\n            if (!Art::has_db($new_song->artist, 'artist')) {\n                Art::duplicate('artist', $song->artist, $new_song->artist);\n            }\n        }\n        if (($song->albumartist && $new_song->albumartist) && $song->albumartist != $new_song->albumartist) {\n            if (!Art::has_db($new_song->albumartist, 'artist')) {\n                Art::duplicate('artist', $song->albumartist, $new_song->albumartist);\n            }\n        }\n        if (($song->album && $new_song->album) && $song->album != $new_song->album) {\n            if (!Art::has_db($new_song->album, 'album')) {\n                Art::duplicate('album', $song->album, $new_song->album);\n            }\n        }\n        if ($song->label && AmpConfig::get('label')) {\n            $labelRepository = static::getLabelRepository();\n\n            foreach (array_map('trim', explode(';', $song->label)) as $label_name) {\n                $label_id = Label::helper($label_name) ?? $labelRepository->lookup($label_name);\n                if ($label_id > 0) {\n                    $label   = new Label($label_id);\n                    $artists = $label->get_artists();\n                    if (!in_array($song->artist, $artists)) {\n                        debug_event(__CLASS__, \"$song->artist: adding association to $label->name\", 4);\n                        $labelRepository->addArtistAssoc($label->id, $song->artist);\n                    }\n                }\n            }\n        }\n\n        $info = Song::compare_song_information($song, $new_song);\n        if ($info['change']) {\n            debug_event(__CLASS__, \"$song->file : differences found, updating database\", 4);\n\n            // Update the song and song_data table\n            Song::update_song($song->id, $new_song);\n\n            // If you've migrated the album/artist you need to migrate their data here\n            self::migrate('artist', $song->artist, $new_song->artist, $song->id);\n            self::migrate('album', $song->album, $new_song->album, $song->id);\n\n            if ($song->tags != $new_song->tags) {\n                // we do still care if there are no tags on your object\n                $tag_comma = (!empty($new_song->tags))\n                    ? implode(',', $new_song->tags)\n                    : '';\n                Tag::update_tag_list($tag_comma, 'song', $song->id, true);\n            }\n            if ($song->license != $new_song->license) {\n                Song::update_license($new_song->license, $song->id);\n            }\n        }\n\n        // If song rating tag exists and is well formed (array user=>rating), update it\n        if ($song->id && is_array($results) && array_key_exists('rating', $results) && is_array($results['rating'])) {\n            // For each user's ratings, call the function\n            foreach ($results['rating'] as $user => $rating) {\n                debug_event(__CLASS__, \"Updating rating for Song \" . $song->id . \" to $rating for user $user\", 5);\n                $o_rating = new Rating($song->id, 'song');\n                $o_rating->set_rating($rating, $user);\n            }\n        }\n        // lets always update the time when you update\n        $update_time = time();\n        Song::update_utime($song->id, $update_time);\n        if ($map_change) {\n            $info['change'] = true;\n            $info['maps']   = true;\n            self::updateArtistTags($song->id);\n            self::updateAlbumArtistTags($song->album);\n        }\n\n        return $info;\n    } // update_song_from_tags\n\n    /**\n     * @param $results\n     * @param Video $video\n     * @return array\n     */\n    public static function update_video_from_tags($results, Video $video)\n    {\n        /* Setup the vars */\n        $new_video                = new Video();\n        $new_video->file          = $results['file'];\n        $new_video->title         = $results['title'];\n        $new_video->size          = $results['size'];\n        $new_video->video_codec   = $results['video_codec'];\n        $new_video->audio_codec   = $results['audio_codec'];\n        $new_video->resolution_x  = $results['resolution_x'];\n        $new_video->resolution_y  = $results['resolution_y'];\n        $new_video->time          = $results['time'];\n        $new_video->release_date  = $results['release_date'] ?? null;\n        $new_video->bitrate       = $results['bitrate'];\n        $new_video->mode          = $results['mode'];\n        $new_video->channels      = $results['channels'];\n        $new_video->display_x     = $results['display_x'];\n        $new_video->display_y     = $results['display_y'];\n        $new_video->frame_rate    = $results['frame_rate'];\n        $new_video->video_bitrate = (int) self::check_int($results['video_bitrate'], 4294967294, 0);\n        $tags                     = Tag::get_object_tags('video', $video->id);\n        if ($tags) {\n            foreach ($tags as $tag) {\n                $video->tags[]     = $tag['name'];\n            }\n        }\n        $new_video->tags        = $results['genre'];\n\n        $info = Video::compare_video_information($video, $new_video);\n        if ($info['change']) {\n            debug_event(__CLASS__, $video->file . \" : differences found, updating database\", 5);\n\n            Video::update_video($video->id, $new_video);\n\n            if ($video->tags != $new_video->tags) {\n                Tag::update_tag_list(implode(',', $new_video->tags), 'video', $video->id, true);\n            }\n            Video::update_video_counts($video->id);\n        }\n        // lets always update the time when you update\n        $update_time = time();\n        Video::update_utime($video->id, $update_time);\n\n        return $info;\n    }\n\n    /**\n     * @param $results\n     * @param Podcast_Episode $podcast_episode\n     * @return array\n     */\n    public static function update_podcast_episode_from_tags($results, Podcast_Episode $podcast_episode)\n    {\n        $sql = \"UPDATE `podcast_episode` SET `file` = ?, `size` = ?, `time` = ?, `state` = 'completed' WHERE `id` = ?\";\n        Dba::write($sql, array($podcast_episode->file, $results['size'], $results['time'], $podcast_episode->id));\n\n        $podcast_episode->size = $results['size'];\n        $podcast_episode->time = $results['time'];\n\n        $array            = array();\n        $array['change']  = true;\n        $array['element'] = false;\n\n        return $array;\n    }\n\n    /**\n     * Get rid of all tags found in the libraryItem\n     * @param library_item $libraryItem\n     * @param array $metadata\n     * @return array\n     */\n    private static function get_clean_metadata(library_item $libraryItem, $metadata)\n    {\n        // these fields seem to be ignored but should be removed\n        $databaseFields = array(\n            'artists' => null,\n            'mb_albumartistid_array' => null,\n            'mb_artistid_array' => null,\n            'original_year' => null,\n            'release_status' => null,\n            'release_type' => null,\n            'originalyear' => null,\n            'dynamic range (r128)' => null,\n            'volume level (r128)' => null,\n            'volume level (replaygain)' => null,\n            'peak level (r128)' => null,\n            'peak level (sample)' => null\n        );\n        $tags = array_diff_key($metadata, get_object_vars($libraryItem), array_flip($libraryItem::$aliases ?? array()), $databaseFields);\n\n        return array_filter($tags);\n    }\n\n    /**\n     * update the artist or album counts on catalog changes\n     */\n    public static function update_counts()\n    {\n        $update_time = self::get_update_info('update_counts');\n        $now_time    = time();\n        // give the server a 30 min break for this help with load\n        if ($update_time !== 0 && $update_time > ($now_time - 1800)) {\n            return;\n        }\n        self::set_update_info('update_counts', $now_time);\n        debug_event(__CLASS__, 'update_counts after catalog changes', 5);\n        // missing map tables are pretty important\n        $sql = \"INSERT IGNORE INTO `artist_map` (`artist_id`, `object_type`, `object_id`) SELECT DISTINCT `song`.`artist` AS `artist_id`, 'song', `song`.`id` FROM `song` WHERE `song`.`artist` > 0 UNION SELECT DISTINCT `album`.`album_artist` AS `artist_id`, 'album', `album`.`id` FROM `album` WHERE `album`.`album_artist` > 0;\";\n        Dba::write($sql);\n        $sql = \"INSERT IGNORE INTO `album_map` (`album_id`, `object_type`, `object_id`)  SELECT DISTINCT `artist_map`.`object_id` AS `album_id`, 'album' AS `object_type`, `artist_map`.`artist_id` AS `object_id` FROM `artist_map` WHERE `artist_map`.`object_type` = 'album' AND `artist_map`.`object_id` IS NOT NULL UNION SELECT DISTINCT `song`.`album` AS `album_id`, 'song' AS `object_type`, `song`.`artist` AS `object_id` FROM `song` WHERE `song`.`album` IS NOT NULL UNION SELECT DISTINCT `song`.`album` AS `album_id`, 'song' AS `object_type`, `artist_map`.`artist_id` AS `object_id` FROM `artist_map` LEFT JOIN `song` ON `artist_map`.`object_type` = 'song' AND `artist_map`.`object_id` = `song`.`id` WHERE `song`.`album` IS NOT NULL AND `artist_map`.`object_type` = 'song';\";\n        Dba::write($sql);\n        // do the longer updates over a larger stretch of time\n        if ($update_time !== 0 && $update_time < ($now_time - 86400)) {\n            // delete old maps in album_map table\n            $sql        = \"SELECT `album_map`.`album_id`, `album_map`.`object_id`, `album_map`.`object_type` FROM (SELECT * FROM `album_map` WHERE `object_type` = 'song') AS `album_map` LEFT JOIN (SELECT DISTINCT `artist_id`, `album` FROM (SELECT `artist_id`, `object_id` AS `song_id` FROM `artist_map` WHERE `object_type` = 'song') AS `artist_songs`, `song` WHERE `song_id` = `id`) AS `artist_map` ON `album_map`.`object_id` = `artist_map`.`artist_id` AND `album_map`.`album_id` = `artist_map`.`album` WHERE `artist_map`.`album` IS NULL;\";\n            $db_results = Dba::read($sql);\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $sql = \"DELETE FROM `album_map` WHERE `album_id` = ? AND `object_id` = ? AND `object_type` = ?;\";\n                Dba::write($sql, array($row['album_id'], $row['object_id'], $row['object_type']));\n            }\n            // this isn't really needed often and is slow\n            Dba::write(\"DELETE FROM `recommendation_item` WHERE `recommendation` NOT IN (SELECT `id` FROM `recommendation`);\");\n            // Fill in null Agents with a value\n            $sql = \"UPDATE `object_count` SET `agent` = 'Unknown' WHERE `agent` IS NULL;\";\n            Dba::write($sql);\n            // object_count.album\n            $sql = \"UPDATE IGNORE `object_count`, (SELECT `song_count`.`date`, `song`.`id` AS `songid`, `song`.`album`, `album_count`.`object_id` AS `albumid`, `album_count`.`user`, `album_count`.`agent`, `album_count`.`count_type` FROM `song` LEFT JOIN `object_count` AS `song_count` ON `song_count`.`object_type` = 'song' AND `song_count`.`count_type` = 'stream' AND `song_count`.`object_id` = `song`.`id` LEFT JOIN `object_count` AS `album_count` ON `album_count`.`object_type` = 'album' AND `album_count`.`count_type` = 'stream' AND `album_count`.`date` = `song_count`.`date` WHERE `song_count`.`date` IS NOT NULL AND `song`.`album` != `album_count`.`object_id` AND `album_count`.`count_type` = 'stream') AS `album_check` SET `object_count`.`object_id` = `album_check`.`album` WHERE `object_count`.`object_id` != `album_check`.`album` AND `object_count`.`object_type` = 'album' AND `object_count`.`date` = `album_check`.`date` AND `object_count`.`user` = `album_check`.`user` AND `object_count`.`agent` = `album_check`.`agent` AND `object_count`.`count_type` = `album_check`.`count_type`;\";\n            Dba::write($sql);\n            // object_count.artist\n            $sql = \"UPDATE IGNORE `object_count`, (SELECT `song_count`.`date`, MIN(`song`.`id`) AS `songid`, MIN(`song`.`artist`) AS `artist`, `artist_count`.`object_id` AS `artistid`, `artist_count`.`user`, `artist_count`.`agent`, `artist_count`.`count_type` FROM `song` LEFT JOIN `object_count` AS `song_count` ON `song_count`.`object_type` = 'song' AND `song_count`.`count_type` = 'stream' AND `song_count`.`object_id` = `song`.`id` LEFT JOIN `object_count` AS `artist_count` ON `artist_count`.`object_type` = 'artist' AND `artist_count`.`count_type` = 'stream' AND `artist_count`.`date` = `song_count`.`date` WHERE `song_count`.`date` IS NOT NULL AND `song`.`artist` != `artist_count`.`object_id` AND `artist_count`.`count_type` = 'stream' GROUP BY `artist_count`.`object_id`, `date`, `user`, `agent`, `count_type`) AS `artist_check` SET `object_count`.`object_id` = `artist_check`.`artist` WHERE `object_count`.`object_id` != `artist_check`.`artist` AND `object_count`.`object_type` = 'artist' AND `object_count`.`date` = `artist_check`.`date` AND `object_count`.`user` = `artist_check`.`user` AND `object_count`.`agent` = `artist_check`.`agent` AND `object_count`.`count_type` = `artist_check`.`count_type`;\";\n            Dba::write($sql);\n        }\n        // fix object_count table missing artist row\n        debug_event(__CLASS__, 'update_counts object_count table missing artist row', 5);\n        $sql = \"INSERT IGNORE INTO `object_count` (`object_type`, `object_id`, `date`, `user`, `agent`, `geo_latitude`, `geo_longitude`, `geo_name`, `count_type`) SELECT 'artist', `artist_map`.`artist_id`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `artist_map` on `object_count`.`object_type` = `artist_map`.`object_type` AND `object_count`.`object_id` = `artist_map`.`object_id` LEFT JOIN `object_count` AS `artist_check` ON `object_count`.`date` = `artist_check`.`date` AND `artist_check`.`object_type` = 'artist' AND `artist_check`.`object_id` = `artist_map`.`artist_id` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` IN (SELECT `id` FROM `song` WHERE `id` IN (SELECT `object_id` FROM `artist_map` WHERE `object_type` = 'song')) AND `artist_check`.`object_id` IS NULL UNION SELECT 'artist', `artist_map`.`artist_id`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `artist_map` ON `object_count`.`object_type` = `artist_map`.`object_type` AND `object_count`.`object_id` = `artist_map`.`object_id` LEFT JOIN `object_count` AS `artist_check` ON `object_count`.`date` = `artist_check`.`date` AND `artist_check`.`object_type` = 'artist' AND `artist_check`.`object_id` = `artist_map`.`artist_id` WHERE `object_count`.`object_type` = 'album' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` IN (SELECT `id` FROM `song` WHERE `id` IN (SELECT `object_id` FROM `artist_map` WHERE `object_type` = 'album')) AND `artist_check`.`object_id` IS NULL GROUP BY `artist_map`.`artist_id`, `object_count`.`object_type`, `object_count`.`object_id`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type`;\";\n        Dba::write($sql);\n        // fix object_count table missing album row\n        debug_event(__CLASS__, 'update_counts object_count table missing album row', 5);\n        $sql = \"INSERT IGNORE INTO `object_count` (`object_type`, `object_id`, `date`, `user`, `agent`, `geo_latitude`, `geo_longitude`, `geo_name`, `count_type`) SELECT 'album', `song`.`album`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `song` ON `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` = `song`.`id` LEFT JOIN `object_count` AS `album_count` ON `album_count`.`object_type` = 'album' AND `object_count`.`date` = `album_count`.`date` AND `object_count`.`user` = `album_count`.`user` AND `object_count`.`agent` = `album_count`.`agent` AND `object_count`.`count_type` = `album_count`.`count_type` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' AND `album_count`.`id` IS NULL;\";\n        Dba::write($sql);\n        // also clean up some bad data that might creep in\n        Dba::write(\"UPDATE `artist` SET `prefix` = NULL WHERE `prefix` = '';\");\n        Dba::write(\"UPDATE `artist` SET `mbid` = NULL WHERE `mbid` = '';\");\n        Dba::write(\"UPDATE `artist` SET `summary` = NULL WHERE `summary` = '';\");\n        Dba::write(\"UPDATE `artist` SET `placeformed` = NULL WHERE `placeformed` = '';\");\n        Dba::write(\"UPDATE `artist` SET `yearformed` = NULL WHERE `yearformed` = 0;\");\n        Dba::write(\"UPDATE `album` SET `album_artist` = NULL WHERE `album_artist` = 0;\");\n        Dba::write(\"UPDATE `album` SET `prefix` = NULL WHERE `prefix` = '';\");\n        Dba::write(\"UPDATE `album` SET `mbid` = NULL WHERE `mbid` = '';\");\n        Dba::write(\"UPDATE `album` SET `mbid_group` = NULL WHERE `mbid_group` = '';\");\n        Dba::write(\"UPDATE `album` SET `release_type` = NULL WHERE `release_type` = '';\");\n        Dba::write(\"UPDATE `album` SET `original_year` = NULL WHERE `original_year` = 0;\");\n        Dba::write(\"UPDATE `album` SET `barcode` = NULL WHERE `barcode` = '';\");\n        Dba::write(\"UPDATE `album` SET `catalog_number` = NULL WHERE `catalog_number` = '';\");\n        Dba::write(\"UPDATE `album` SET `release_status` = NULL WHERE `release_status` = '';\");\n        // song.played might have had issues\n        $sql = \"UPDATE `song` SET `song`.`played` = 0 WHERE `song`.`played` = 1 AND `song`.`id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'song' AND `count_type` = 'stream');\";\n        Dba::write($sql);\n        $sql = \"UPDATE `song` SET `song`.`played` = 1 WHERE `song`.`played` = 0 AND `song`.`id` IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'song' AND `count_type` = 'stream');\";\n        Dba::write($sql);\n        // fix up incorrect total_count values too\n        $sql = \"UPDATE `song` SET `total_count` = 0 WHERE `total_count` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream');\";\n        Dba::write($sql);\n        $sql = \"UPDATE `song` SET `total_skip` = 0 WHERE `total_skip` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream');\";\n        Dba::write($sql);\n        if (AmpConfig::get('podcast')) {\n            //debug_event(__CLASS__, 'update_counts podcast_episode table', 5);\n            // fix object_count table missing podcast row\n            $sql        = \"SELECT `podcast_episode`.`podcast`, `object_count`.`date`, `object_count`.`user`, `object_count`.`agent`, `object_count`.`geo_latitude`, `object_count`.`geo_longitude`, `object_count`.`geo_name`, `object_count`.`count_type` FROM `object_count` LEFT JOIN `podcast_episode` ON `object_count`.`object_type` = 'podcast_episode' AND `object_count`.`count_type` = 'stream' AND `object_count`.`object_id` = `podcast_episode`.`id` LEFT JOIN `object_count` AS `podcast_count` ON `podcast_count`.`object_type` = 'podcast' AND `object_count`.`date` = `podcast_count`.`date` AND `object_count`.`user` = `podcast_count`.`user` AND `object_count`.`agent` = `podcast_count`.`agent` AND `object_count`.`count_type` = `podcast_count`.`count_type` WHERE `object_count`.`count_type` = 'stream' AND `object_count`.`object_type` = 'podcast_episode' AND `podcast_count`.`id` IS NULL LIMIT 100;\";\n            $db_results = Dba::read($sql);\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $sql = \"INSERT IGNORE INTO `object_count` (`object_type`, `object_id`, `count_type`, `date`, `user`, `agent`, `geo_latitude`, `geo_longitude`, `geo_name`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\";\n                Dba::write($sql, array('podcast', $row['podcast'], $row['count_type'], $row['date'], $row['user'], $row['agent'], $row['geo_latitude'], $row['geo_longitude'], $row['geo_name']));\n            }\n            $sql = \"UPDATE `podcast_episode` SET `total_count` = 0 WHERE `total_count` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'podcast_episode' AND `object_count`.`count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `podcast_episode` SET `total_skip` = 0 WHERE `total_skip` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'podcast_episode' AND `object_count`.`count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `podcast_episode` SET `podcast_episode`.`played` = 0 WHERE `podcast_episode`.`played` = 1 AND `podcast_episode`.`id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'podcast_episode' AND `count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `podcast_episode` SET `podcast_episode`.`played` = 1 WHERE `podcast_episode`.`played` = 0 AND `podcast_episode`.`id` IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'podcast_episode' AND `count_type` = 'stream');\";\n            Dba::write($sql);\n            // podcast_episode.total_count\n            $sql = \"UPDATE `podcast_episode`, (SELECT COUNT(`object_count`.`object_id`) AS `total_count`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'podcast_episode' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS `object_count` SET `podcast_episode`.`total_count` = `object_count`.`total_count` WHERE `podcast_episode`.`total_count` != `object_count`.`total_count` AND `podcast_episode`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n            // podcast.total_count\n            $sql = \"UPDATE `podcast`, (SELECT SUM(`podcast_episode`.`total_count`) AS `total_count`, `podcast` FROM `podcast_episode` GROUP BY `podcast_episode`.`podcast`) AS `object_count` SET `podcast`.`total_count` = `object_count`.`total_count` WHERE `podcast`.`total_count` != `object_count`.`total_count` AND `podcast`.`id` = `object_count`.`podcast`;\";\n            Dba::write($sql);\n            // song.total_count\n            $sql = \"UPDATE `song`, (SELECT COUNT(`object_count`.`object_id`) AS `total_count`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS `object_count` SET `song`.`total_count` = `object_count`.`total_count` WHERE `song`.`total_count` != `object_count`.`total_count` AND `song`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n            // song.total_skip\n            $sql = \"UPDATE `song`, (SELECT COUNT(`object_count`.`object_id`) AS `total_skip`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'skip' GROUP BY `object_count`.`object_id`) AS `object_count` SET `song`.`total_skip` = `object_count`.`total_skip` WHERE `song`.`total_skip` != `object_count`.`total_skip` AND `song`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n        }\n        if (AmpConfig::get('allow_video')) {\n            //debug_event(__CLASS__, 'update_counts video table', 5);\n            $sql = \"UPDATE `video` SET `total_count` = 0 WHERE `total_count` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'video' AND `object_count`.`count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `video` SET `total_skip` = 0 WHERE `total_skip` > 0 AND `id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'video' AND `object_count`.`count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `video` SET `video`.`played` = 0 WHERE `video`.`played` = 1 AND `video`.`id` NOT IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'video' AND `count_type` = 'stream');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `video` SET `video`.`played` = 1 WHERE `video`.`played` = 0 AND `video`.`id` IN (SELECT `object_id` FROM `object_count` WHERE `object_type` = 'video' AND `count_type` = 'stream');\";\n            Dba::write($sql);\n            // video.total_count\n            $sql = \"UPDATE `video`, (SELECT COUNT(`object_count`.`object_id`) AS `total_count`, `object_id` FROM `object_count` WHERE `object_count`.`object_type` = 'video' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS `object_count` SET `video`.`total_count` = `object_count`.`total_count` WHERE `video`.`total_count` != `object_count`.`total_count` AND `video`.`id` = `object_count`.`object_id`;\";\n            Dba::write($sql);\n        }\n        Artist::update_artist_counts();\n        Album::update_album_counts();\n\n        // update server total counts\n        debug_event(__CLASS__, 'update_counts server total counts', 5);\n        $catalog_disable = AmpConfig::get('catalog_disable');\n        // tables with media items to count, song-related tables and the rest\n        $media_tables = array('song', 'video', 'podcast_episode');\n        $items        = 0;\n        $time         = 0;\n        $size         = 0;\n        foreach ($media_tables as $table) {\n            $enabled_sql = ($catalog_disable && $table !== 'podcast_episode') ? \" WHERE `$table`.`enabled` = '1'\" : '';\n            $sql         = \"SELECT COUNT(`id`), IFNULL(SUM(`time`), 0), IFNULL(SUM(`size`), 0) FROM `$table`\" . $enabled_sql;\n            $db_results  = Dba::read($sql);\n            $row         = Dba::fetch_row($db_results);\n            // save the object and add to the current size\n            $items += (int)($row[0] ?? 0);\n            $time += (int)($row[1] ?? 0);\n            $size += (int)($row[2] ?? 0);\n            self::set_update_info($table, (int)($row[0] ?? 0));\n        }\n        self::set_update_info('items', $items);\n        self::set_update_info('time', $time);\n        self::set_update_info('size', $size);\n\n        $song_tables = array('artist', 'album');\n        foreach ($song_tables as $table) {\n            $sql        = \"SELECT COUNT(DISTINCT(`$table`)) FROM `song`\";\n            $db_results = Dba::read($sql);\n            $row        = Dba::fetch_row($db_results);\n            self::set_update_info($table, (int)($row[0] ?? 0));\n        }\n        // grouped album counts\n        $sql        = \"SELECT COUNT(DISTINCT(`album`.`id`)) AS `count` FROM `album` WHERE `id` in (SELECT MIN(`id`) FROM `album` GROUP BY `album`.`prefix`, `album`.`name`, `album`.`album_artist`, `album`.`release_type`, `album`.`release_status`, `album`.`mbid`, `album`.`year`, `album`.`original_year`, `album`.`mbid_group`);\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_row($db_results);\n        self::set_update_info('album_group', (int)($row[0] ?? 0));\n\n        $list_tables = array('search', 'playlist', 'live_stream', 'podcast', 'user', 'catalog', 'label', 'tag', 'share', 'license');\n        foreach ($list_tables as $table) {\n            $sql        = \"SELECT COUNT(`id`) FROM `$table`\";\n            $db_results = Dba::read($sql);\n            $row        = Dba::fetch_row($db_results);\n            self::set_update_info($table, (int)($row[0] ?? 0));\n        }\n        debug_event(__CLASS__, 'update_counts User::update_counts()', 5);\n        // user accounts may have different items to return based on catalog_filter so lets set those too\n        User::update_counts();\n        debug_event(__CLASS__, 'update_counts completed', 5);\n    }\n\n    /**\n     *\n     * @param library_item $libraryItem\n     * @param array $metadata\n     */\n    public static function add_metadata(library_item $libraryItem, $metadata)\n    {\n        $tags = self::get_clean_metadata($libraryItem, $metadata);\n\n        foreach ($tags as $tag => $value) {\n            $field = $libraryItem->getField($tag);\n            $libraryItem->addMetadata($field, $value);\n        }\n    }\n\n    /**\n     * get_media_tags\n     * @param Song|Video|Podcast_Episode $media\n     * @param array $gather_types\n     * @param string $sort_pattern\n     * @param string $rename_pattern\n     * @return array\n     */\n    public function get_media_tags($media, $gather_types, $sort_pattern, $rename_pattern)\n    {\n        // Check for patterns\n        if (!$sort_pattern || !$rename_pattern) {\n            $sort_pattern   = $this->sort_pattern;\n            $rename_pattern = $this->rename_pattern;\n        }\n\n        $vainfo = $this->getUtilityFactory()->createVaInfo(\n            $media->file,\n            $gather_types,\n            '',\n            '',\n            $sort_pattern,\n            $rename_pattern\n        );\n        try {\n            $vainfo->get_info();\n        } catch (Exception $error) {\n            debug_event(__CLASS__, 'Error ' . $error->getMessage(), 1);\n\n            return array();\n        }\n\n        $key = VaInfo::get_tag_type($vainfo->tags);\n\n        return VaInfo::clean_tag_info($vainfo->tags, $key, $media->file);\n    }\n\n    /**\n     * get_gather_types\n     * @param string $media_type\n     * @return array\n     */\n    public function get_gather_types($media_type = '')\n    {\n        $gtypes = $this->gather_types;\n        if (empty($gtypes)) {\n            $gtypes = \"music\";\n        }\n        $types = explode(',', $gtypes);\n\n        if ($media_type == \"video\") {\n            $types = array_diff($types, array('music'));\n        }\n\n        if ($media_type == \"music\") {\n            $types = array_diff($types, array('personal_video', 'movie', 'tvshow', 'clip'));\n        }\n\n        return $types;\n    }\n\n    /**\n     * get_gather_type\n     * @return string\n     */\n    public function get_gather_type()\n    {\n        $sql        = \"SELECT `gather_types` FROM `catalog` WHERE `id` = ?;\";\n        $db_results = Dba::read($sql, array($this->id));\n        if ($row = Dba::fetch_assoc($db_results)) {\n            return $row['gather_types'];\n        }\n\n        return '';\n    }\n\n    /**\n     * get_table_from_type\n     * @param string $gather_type\n     * @return string\n     */\n    public static function get_table_from_type($gather_type)\n    {\n        switch ($gather_type) {\n            case 'clip':\n            case 'tvshow':\n            case 'movie':\n            case 'personal_video':\n                $table = 'video';\n                break;\n            case 'podcast':\n                $table = 'podcast_episode';\n                break;\n            case 'music':\n            default:\n                $table = 'song';\n                break;\n        }\n\n        return $table;\n    }\n\n    /**\n     * clean_empty_albums\n     */\n    public static function clean_empty_albums()\n    {\n        $sql        = \"SELECT `id`, `album_artist` FROM `album` WHERE NOT EXISTS (SELECT `id` FROM `song` WHERE `song`.`album` = `album`.`id`);\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $sql       = \"DELETE FROM `album` WHERE `id` = ?\";\n            Dba::write($sql, array($row['id']));\n        }\n        // these files have missing albums so you can't verify them without updating from tags first\n        $sql        = \"SELECT `id` FROM `song` WHERE `album` in (SELECT `album_id` FROM `album_map` WHERE `album_id` NOT IN (SELECT `id` from `album`));\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            self::update_single_item('song', $row['id'], true);\n        }\n    }\n\n    /**\n     * clean_duplicate_artists\n     *\n     * Artists that have the same mbid shouldn't be duplicated but can be created and updated based on names\n     */\n    public static function clean_duplicate_artists()\n    {\n        debug_event(__CLASS__, \"Clean Artists with duplicate mbid's\", 5);\n        $sql        = \"SELECT `mbid`, min(`id`) AS `minid`, max(`id`) AS `maxid` FROM `artist` WHERE `mbid` IS NOT NULL GROUP BY `mbid` HAVING count(`mbid`) >1;\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            debug_event(__CLASS__, \"clean_duplicate_artists \" . $row['maxid'] . \"=>\" . $row['minid'], 5);\n            // migrate linked tables first\n            //Stats::migrate('artist', $row['maxid'], $row['minid']);\n            Useractivity::migrate('artist', $row['maxid'], $row['minid']);\n            Recommendation::migrate('artist', $row['maxid'], $row['minid']);\n            Share::migrate('artist', $row['maxid'], $row['minid']);\n            Shoutbox::migrate('artist', $row['maxid'], $row['minid']);\n            Tag::migrate('artist', $row['maxid'], $row['minid']);\n            Userflag::migrate('artist', $row['maxid'], $row['minid']);\n            Label::migrate('artist', $row['maxid'], $row['minid']);\n            Rating::migrate('artist', $row['maxid'], $row['minid']);\n            Wanted::migrate('artist', $row['maxid'], $row['minid']);\n            Clip::migrate('artist', $row['maxid'], $row['minid']);\n            self::migrate_map('artist', $row['maxid'], $row['minid']);\n\n            // replace all songs and albums with the original artist\n            Artist::migrate($row['maxid'], $row['minid']);\n        }\n        // remove the duplicates after moving everything\n        Artist::garbage_collection();\n        static::getAlbumRepository()->collectGarbage();\n    }\n\n    /**\n     * clean_catalog\n     *\n     * Cleans the catalog of files that no longer exist.\n     */\n    public function clean_catalog()\n    {\n        // We don't want to run out of time\n        set_time_limit(0);\n\n        debug_event(__CLASS__, 'Starting clean on ' . $this->name, 5);\n\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            require Ui::find_template('show_clean_catalog.inc.php');\n            ob_flush();\n            flush();\n        }\n\n        $dead_total = $this->clean_catalog_proc();\n        self::clean_empty_albums();\n        self::clean_duplicate_artists();\n\n        debug_event(__CLASS__, 'clean finished, ' . $dead_total . ' removed from ' . $this->name, 4);\n\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            Ui::show_box_top();\n        }\n        Ui::update_text(T_(\"Catalog Cleaned\"),\n            sprintf(nT_(\"%d file removed.\", \"%d files removed.\", $dead_total), $dead_total));\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            Ui::show_box_bottom();\n        }\n\n        $this->update_last_clean();\n    } // clean_catalog\n\n    /**\n     * verify_catalog\n     * This function verify the catalog\n     */\n    public function verify_catalog()\n    {\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            require Ui::find_template('show_verify_catalog.inc.php');\n            ob_flush();\n            flush();\n        }\n\n        $verified = $this->verify_catalog_proc();\n\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            Ui::show_box_top();\n        }\n        Ui::update_text(T_(\"Catalog Verified\"),\n            sprintf(nT_('%d file updated.', '%d files updated.', $verified['updated']), $verified['updated']));\n        if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n            Ui::show_box_bottom();\n        }\n\n        return true;\n    } // verify_catalog\n\n    /**\n     * trim_prefix\n     * Splits the prefix from the string\n     * @param string $string\n     * @return array\n     */\n    public static function trim_prefix($string)\n    {\n        $prefix_pattern = '/^(' . implode('\\\\s|', explode('|', AmpConfig::get('catalog_prefix_pattern'))) . '\\\\s)(.*)/i';\n        if (preg_match($prefix_pattern, $string, $matches)) {\n            $string = trim((string)$matches[2]);\n            $prefix = trim((string)$matches[1]);\n        } else {\n            $prefix = null;\n        }\n\n        return array('string' => $string, 'prefix' => $prefix);\n    } // trim_prefix\n\n    /**\n     * @param $year\n     * @return integer\n     */\n    public static function normalize_year($year)\n    {\n        if (empty($year)) {\n            return 0;\n        }\n\n        $year = (int)($year);\n        if ($year < 0 || $year > 9999) {\n            return 0;\n        }\n\n        return $year;\n    }\n\n    /**\n     * trim_slashed_list\n     * Split items by configurable delimiter\n     * Return first item as string = default\n     * Return all items as array if doTrim = false passed as optional parameter\n     * @param string $string\n     * @param bool $doTrim\n     * @return string|array\n     */\n    public static function trim_slashed_list($string, $doTrim = true)\n    {\n        $delimiters = static::getConfigContainer()->get(ConfigurationKeyEnum::ADDITIONAL_DELIMITERS);\n        $pattern    = '~[\\s]?(' . $delimiters . ')[\\s]?~';\n        $items      = preg_split($pattern, $string);\n        $items      = array_map('trim', $items);\n\n        if ((isset($items) && isset($items[0])) && $doTrim) {\n            return $items[0];\n        }\n\n        return $items;\n    } // trim_slashed_list\n\n    /**\n     * trim_featuring\n     * Splits artists featuring from the string\n     * @param string $string\n     * @return array\n     */\n    public static function trim_featuring($string)\n    {\n        return array_map('trim', preg_split(\"/ feat\\. /i\", $string));\n    } // trim_featuring\n\n    /**\n     * check_title\n     * this checks to make sure something is\n     * set on the title, if it isn't it looks at the\n     * filename and tries to set the title based on that\n     * @param string $title\n     * @param string $file\n     * @return string\n     */\n    public static function check_title($title, $file = '')\n    {\n        if (strlen(trim((string)$title)) < 1) {\n            $title = Dba::escape($file);\n        }\n\n        return $title;\n    } // check_title\n\n    /**\n     * check_length\n     * Check to make sure the string fits into the database\n     * max_length is the maximum number of characters that the (varchar) column can hold\n     * @param string $string\n     * @param integer $max_length\n     * @return string\n     */\n    public static function check_length($string, $max_length = 255)\n    {\n        $string = (string)$string;\n        if (false !== $encoding = mb_detect_encoding($string, null, true)) {\n            $string = trim(mb_substr($string, 0, $max_length, $encoding));\n        } else {\n            $string = trim(substr($string, 0, $max_length));\n        }\n\n        return $string;\n    }\n\n    /**\n     * check_track\n     * Check to make sure the track number fits into the database: max 32767, min -32767\n     *\n     * @param string $track\n     * @return integer\n     */\n    public static function check_track($track)\n    {\n        $retval = ((int)$track > 32767 || (int)$track < -32767) ? (int)substr($track, -4, 4) : (int)$track;\n        if ((int)$track !== $retval) {\n            debug_event(__CLASS__, \"check_track: '{$track}' out of range. Changed into '{$retval}'\", 4);\n        }\n\n        return $retval;\n    }\n\n    /**\n     * check_int\n     * Check to make sure a number fits into the database\n     *\n     * @param integer $my_int\n     * @param integer $max\n     * @param integer $min\n     * @return integer\n     */\n    public static function check_int($my_int, $max, $min)\n    {\n        if ($my_int > $max) {\n            return $max;\n        }\n        if ($my_int < $min) {\n            return $min;\n        }\n\n        return $my_int;\n    }\n\n    /**\n     * get_unique_string\n     * Check to make sure the string doesn't have duplicate strings ({)e.g. \"Enough Records; Enough Records\")\n     *\n     * @param string $str_array\n     * @return string\n     */\n    public static function get_unique_string($str_array)\n    {\n        $array = array_unique(array_map('trim', explode(';', $str_array)));\n\n        return implode($array);\n    }\n\n    /**\n     * playlist_import\n     * Attempts to create a Public Playlist based on the playlist file\n     * @param string $playlist_file\n     * @param int $user_id\n     * @param string $playlist_type (public|private)\n     * @return array\n     */\n    public static function import_playlist($playlist_file, $user_id, $playlist_type)\n    {\n        $data = file_get_contents($playlist_file);\n        if (substr($playlist_file, -3, 3) == 'm3u' || substr($playlist_file, -4, 4) == 'm3u8') {\n            $files = self::parse_m3u($data);\n        } elseif (substr($playlist_file, -3, 3) == 'pls') {\n            $files = self::parse_pls($data);\n        } elseif (substr($playlist_file, -3, 3) == 'asx') {\n            $files = self::parse_asx($data);\n        } elseif (substr($playlist_file, -4, 4) == 'xspf') {\n            $files = self::parse_xspf($data);\n        }\n\n        $songs    = array();\n        $import   = array();\n        $pinfo    = pathinfo($playlist_file);\n        $track    = 1;\n        $web_path = AmpConfig::get('web_path');\n        if (isset($files)) {\n            foreach ($files as $file) {\n                $found = false;\n                $file  = trim((string)$file);\n                $orig  = $file;\n                // Check to see if it's a url from this ampache instance\n                if (!empty($web_path) && substr($file, 0, strlen($web_path)) == $web_path) {\n                    $url_data   = Stream_Url::parse($file);\n                    $sql        = 'SELECT COUNT(*) FROM `song` WHERE `id` = ?';\n                    $db_results = Dba::read($sql, array($url_data['id']));\n                    if (Dba::num_rows($db_results) && (int)$url_data['id'] > 0) {\n                        debug_event(__CLASS__, \"import_playlist identified: {\" . $url_data['id'] . \"}\", 5);\n                        $songs[$track] = $url_data['id'];\n                        $track++;\n                        $found = true;\n                    }\n                } else {\n                    // Remove file:// prefix if any\n                    if (strpos($file, \"file://\") !== false) {\n                        $file = urldecode(substr($file, 7));\n                        if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n                            // Removing starting / on Windows OS.\n                            if (substr($file, 0, 1) == '/') {\n                                $file = substr($file, 1);\n                            }\n                            // Restore real directory separator\n                            $file = str_replace(\"/\", DIRECTORY_SEPARATOR, $file);\n                        }\n                    }\n\n                    // First, try to find the file as absolute path\n                    $sql        = \"SELECT `id` FROM `song` WHERE `file` = ?\";\n                    $db_results = Dba::read($sql, array($file));\n                    $results    = Dba::fetch_assoc($db_results);\n\n                    if (array_key_exists('id', $results) && (int)($results['id']) > 0) {\n                        debug_event(__CLASS__, \"import_playlist identified: {\" . (int)$results['id'] . \"}\", 5);\n                        $songs[$track] = (int)$results['id'];\n                        $track++;\n                        $found = true;\n                    } else {\n                        // Not found in absolute path, create it from relative path\n                        $file = $pinfo['dirname'] . DIRECTORY_SEPARATOR . $file;\n                        // Normalize the file path. realpath requires the files to exists.\n                        $file = realpath($file);\n                        if ($file) {\n                            $sql        = \"SELECT `id` FROM `song` WHERE `file` = ?\";\n                            $db_results = Dba::read($sql, array($file));\n                            $results    = Dba::fetch_assoc($db_results);\n\n                            if ((int)$results['id'] > 0) {\n                                debug_event(__CLASS__, \"import_playlist identified: {\" . (int)$results['id'] . \"}\", 5);\n                                $songs[$track] = (int)$results['id'];\n                                $track++;\n                                $found = true;\n                            }\n                        }\n                    }\n                } // if it's a file\n                if (!$found) {\n                    debug_event(__CLASS__, \"import_playlist skipped: {{$orig}}\", 5);\n                }\n                // add the results to an array to display after\n                $import[] = array(\n                    'track' => $track - 1,\n                    'file' => $orig,\n                    'found' => (int)$found\n                );\n            }\n        }\n\n        debug_event(__CLASS__, \"import_playlist Parsed \" . $playlist_file . \", found \" . count($songs) . \" songs\", 5);\n\n        if (count($songs)) {\n            $name        = $pinfo['filename'];\n            $playlist_id = (int)Playlist::create($name, $playlist_type, $user_id);\n\n            if ($playlist_id < 1) {\n                return array(\n                    'success' => false,\n                    'error' => T_('Failed to create playlist'),\n                );\n            }\n\n            $playlist = new Playlist($playlist_id);\n            $playlist->delete_all();\n            $playlist->add_songs($songs);\n\n            return array(\n                'success' => true,\n                'id' => $playlist_id,\n                'count' => count($songs),\n                'results' => $import\n            );\n        }\n\n        return array(\n            'success' => false,\n            'error' => T_('No valid songs found in playlist file'),\n            'results' => $import\n        );\n    }\n\n    /**\n     * parse_m3u\n     * this takes m3u filename and then attempts to found song filenames listed in the m3u\n     * @param string $data\n     * @return array\n     */\n    public static function parse_m3u($data)\n    {\n        $files   = array();\n        $results = explode(\"\\n\", $data);\n\n        foreach ($results as $value) {\n            $value = trim((string)$value);\n            if (!empty($value) && substr($value, 0, 1) != '#') {\n                $files[] = $value;\n            }\n        }\n\n        return $files;\n    } // parse_m3u\n\n    /**\n     * parse_pls\n     * this takes pls filename and then attempts to found song filenames listed in the pls\n     * @param string $data\n     * @return array\n     */\n    public static function parse_pls($data)\n    {\n        $files   = array();\n        $results = explode(\"\\n\", $data);\n\n        foreach ($results as $value) {\n            $value = trim((string)$value);\n            if (preg_match(\"/file[0-9]+[\\s]*\\=(.*)/i\", $value, $matches)) {\n                $file = trim((string)$matches[1]);\n                if (!empty($file)) {\n                    $files[] = $file;\n                }\n            }\n        }\n\n        return $files;\n    } // parse_pls\n\n    /**\n     * parse_asx\n     * this takes asx filename and then attempts to found song filenames listed in the asx\n     * @param string $data\n     * @return array\n     */\n    public static function parse_asx($data)\n    {\n        $files = array();\n        $xml   = simplexml_load_string($data);\n\n        if ($xml) {\n            foreach ($xml->entry as $entry) {\n                $file = trim((string)$entry->ref['href']);\n                if (!empty($file)) {\n                    $files[] = $file;\n                }\n            }\n        }\n\n        return $files;\n    } // parse_asx\n\n    /**\n     * parse_xspf\n     * this takes xspf filename and then attempts to found song filenames listed in the xspf\n     * @param string $data\n     * @return array\n     */\n    public static function parse_xspf($data)\n    {\n        $files = array();\n        $xml   = simplexml_load_string($data);\n        if ($xml) {\n            foreach ($xml->trackList->track as $track) {\n                $file = trim((string)$track->location);\n                if (!empty($file)) {\n                    $files[] = $file;\n                }\n            }\n        }\n\n        return $files;\n    } // parse_xspf\n\n    /**\n     * delete\n     * Deletes the catalog and everything associated with it\n     * it takes the catalog id\n     * @param integer $catalog_id\n     * @return boolean\n     */\n    public static function delete($catalog_id)\n    {\n        // Large catalog deletion can take time\n        set_time_limit(0);\n        $params = array($catalog_id);\n\n        // First remove the songs in this catalog\n        $sql        = \"DELETE FROM `song` WHERE `catalog` = ?\";\n        $db_results = Dba::write($sql, $params);\n\n        // Only if the previous one works do we go on\n        if (!$db_results) {\n            return false;\n        }\n        self::clean_empty_albums();\n\n        $sql        = \"DELETE FROM `video` WHERE `catalog` = ?\";\n        $db_results = Dba::write($sql, $params);\n\n        if (!$db_results) {\n            return false;\n        }\n\n        $sql        = \"DELETE FROM `podcast` WHERE `catalog` = ?\";\n        $db_results = Dba::write($sql, $params);\n\n        if (!$db_results) {\n            return false;\n        }\n\n        $sql        = \"DELETE FROM `live_stream` WHERE `catalog` = ?\";\n        $db_results = Dba::write($sql, $params);\n\n        if (!$db_results) {\n            return false;\n        }\n\n        $catalog = self::create_from_id($catalog_id);\n\n        if (!$catalog) {\n            return false;\n        }\n\n        $sql        = 'DELETE FROM `catalog_' . $catalog->get_type() . '` WHERE catalog_id = ?';\n        $db_results = Dba::write($sql, $params);\n\n        if (!$db_results) {\n            return false;\n        }\n\n        // Next Remove the Catalog Entry it's self\n        $sql = \"DELETE FROM `catalog` WHERE `id` = ?\";\n        Dba::write($sql, $params);\n\n        // run garbage collection\n        static::getCatalogGarbageCollector()->collect();\n\n        return true;\n    } // delete\n\n    /**\n     * exports the catalog\n     * it exports all songs in the database to the given export type.\n     * @param string $type\n     * @param integer|null $catalog_id\n     */\n    public static function export($type, $catalog_id = null)\n    {\n        // Select all songs in catalog\n        $params = array();\n        if ($catalog_id) {\n            $sql      = \"SELECT `id` FROM `song` WHERE `catalog` = ? ORDER BY `album`, `track`\";\n            $params[] = $catalog_id;\n        } else {\n            $sql = 'SELECT `id` FROM `song` ORDER BY `album`, `track`';\n        }\n        $db_results = Dba::read($sql, $params);\n\n        switch ($type) {\n            case 'itunes':\n                echo static::xml_get_header('itunes');\n                while ($results = Dba::fetch_assoc($db_results)) {\n                    $song = new Song($results['id']);\n                    $song->format();\n\n                    $xml                         = array();\n                    $xml['key']                  = $results['id'];\n                    $xml['dict']['Track ID']     = (int)($results['id']);\n                    $xml['dict']['Name']         = $song->title;\n                    $xml['dict']['Artist']       = $song->f_artist_full;\n                    $xml['dict']['Album']        = $song->f_album_full;\n                    $xml['dict']['Total Time']   = (int) ($song->time) * 1000; // iTunes uses milliseconds\n                    $xml['dict']['Track Number'] = (int) ($song->track);\n                    $xml['dict']['Year']         = (int) ($song->year);\n                    $xml['dict']['Date Added']   = get_datetime((int) $song->addition_time, 'short', 'short', \"Y-m-d\\TH:i:s\\Z\");\n                    $xml['dict']['Bit Rate']     = (int) ($song->bitrate / 1000);\n                    $xml['dict']['Sample Rate']  = (int) ($song->rate);\n                    $xml['dict']['Play Count']   = (int) ($song->played);\n                    $xml['dict']['Track Type']   = \"URL\";\n                    $xml['dict']['Location']     = $song->play_url();\n                    echo (string) xoutput_from_array($xml, true, 'itunes');\n                    // flush output buffer\n                } // while result\n                echo static::xml_get_footer('itunes');\n                break;\n            case 'csv':\n                echo \"ID,Title,Artist,Album,Length,Track,Year,Date Added,Bitrate,Played,File\\n\";\n                while ($results = Dba::fetch_assoc($db_results)) {\n                    $song = new Song($results['id']);\n                    $song->format();\n                    echo '\"' . $song->id . '\",\"' . $song->title . '\",\"' . $song->f_artist_full . '\",\"' . $song->f_album_full . '\",\"' . $song->f_time . '\",\"' . $song->f_track . '\",\"' . $song->year . '\",\"' . get_datetime((int)$song->addition_time) . '\",\"' . $song->f_bitrate . '\",\"' . $song->played . '\",\"' . $song->file . '\"' . \"\\n\";\n                }\n                break;\n        } // end switch\n    } // export\n\n    /**\n     * Update the catalog mapping for various types\n     * @param string $table\n     */\n    public static function update_mapping($table)\n    {\n        // fill the data\n        debug_event(__CLASS__, 'Update mapping for table: ' . $table, 5);\n        if ($table == 'artist') {\n            $sql = \"INSERT IGNORE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT DISTINCT `song`.`catalog`, 'artist', `artist_map`.`artist_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `song`.`catalog` > 0 UNION SELECT DISTINCT `album`.`catalog`, 'artist', `artist_map`.`artist_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `album`.`catalog` > 0 AND `artist_map`.`object_type` = 'album' GROUP BY `catalog`, 'artist', `artist_map`.`artist_id`;\";\n            Dba::write($sql);\n        } elseif ($table == 'playlist') {\n            $sql = \"INSERT IGNORE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `song`.`catalog`, 'playlist', `playlist`.`id` FROM `playlist` LEFT JOIN `playlist_data` ON `playlist`.`id`=`playlist_data`.`playlist` LEFT JOIN `song` ON `song`.`id` = `playlist_data`.`object_id` AND `playlist_data`.`object_type` = 'song' WHERE `song`.`catalog` > 0 GROUP BY `song`.`catalog`, 'playlist', `playlist`.`id`;\";\n            Dba::write($sql);\n        } else {\n            // 'album', 'song', 'video', 'podcast', 'podcast_episode', 'live_stream'\n            $sql = \"INSERT IGNORE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT `$table`.`catalog`, '$table', `$table`.`id` FROM `$table` WHERE `$table`.`catalog` > 0 GROUP BY `$table`.`catalog`, '$table', `$table`.`id`;\";\n            Dba::write($sql);\n        }\n    }\n\n    /**\n     * Update the catalog mapping for various types\n     */\n    public static function garbage_collect_mapping()\n    {\n        // delete non-existent maps\n        $tables = ['album', 'song', 'video', 'podcast', 'podcast_episode', 'live_stream'];\n        foreach ($tables as $type) {\n            $sql = \"DELETE FROM `catalog_map` USING `catalog_map` LEFT JOIN (SELECT DISTINCT `$type`.`catalog` AS `catalog_id`, '$type' AS `object_type`, `$type`.`id` AS `object_id` FROM `$type` WHERE `$type`.`catalog` > 0 GROUP BY `$type`.`catalog`, '$type', `$type`.`id`) AS `valid_maps` ON `valid_maps`.`catalog_id` = `catalog_map`.`catalog_id` AND `valid_maps`.`object_id` = `catalog_map`.`object_id` AND `valid_maps`.`object_type` = `catalog_map`.`object_type` WHERE `catalog_map`.`object_type` = '$type' AND `valid_maps`.`object_id` IS NULL;\";\n            Dba::write($sql);\n        }\n        // artists are different\n        $sql = \"DELETE FROM `catalog_map` USING `catalog_map` LEFT JOIN (SELECT DISTINCT `song`.`catalog` AS `catalog_id`, 'artist' AS `object_type`, `artist_map`.`artist_id` AS `object_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `song`.`catalog` > 0 UNION SELECT DISTINCT `album`.`catalog`, 'artist', `artist_map`.`artist_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `album`.`catalog` > 0 AND `artist_map`.`object_type` = 'album' GROUP BY `catalog`, 'artist', `artist_map`.`artist_id`) AS `valid_maps` ON `valid_maps`.`catalog_id` = `catalog_map`.`catalog_id` AND `valid_maps`.`object_id` = `catalog_map`.`object_id` AND `valid_maps`.`object_type` = `catalog_map`.`object_type` WHERE `catalog_map`.`object_type` = 'artist' AND `valid_maps`.`object_id` IS NULL;\";\n        Dba::write($sql);\n\n        $sql = \"DELETE FROM `catalog_map` WHERE `catalog_id` = 0\";\n        Dba::write($sql);\n    }\n\n    /**\n     * Delete catalog filters that might have gone missing\n     */\n    public static function garbage_collect_filters()\n    {\n        Dba::write(\"DELETE FROM `catalog_filter_group_map` WHERE `group_id` NOT IN (SELECT `id` FROM `catalog_filter_group`);\");\n        Dba::write(\"UPDATE `user` SET `catalog_filter_group` = 0 WHERE `catalog_filter_group` NOT IN (SELECT `id` FROM `catalog_filter_group`);\");\n        Dba::write(\"UPDATE IGNORE `catalog_filter_group` SET `id` = 0 WHERE `name` = 'DEFAULT' AND `id` > 0;\");\n    }\n\n    /**\n     * Update the catalog map for a single item\n     */\n    public static function update_map($catalog, $object_type, $object_id)\n    {\n        if ($catalog > 0) {\n            debug_event(__CLASS__, \"update_map $object_type: {{$object_id}}\", 5);\n            if ($object_type == 'artist') {\n                $sql = \"INSERT IGNORE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) SELECT DISTINCT `song`.`catalog`, 'artist' AS `object_type`, `artist_map`.`artist_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`artist_id` = ? AND `song`.`catalog` > 0 AND `artist_map`.`object_type` = 'song' UNION SELECT DISTINCT `album`.`catalog`, 'artist' AS `object_type`, `artist_map`.`artist_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`artist_id` = ? AND `album`.`catalog` > 0 AND `artist_map`.`object_type` = 'album'  UNION  SELECT DISTINCT `song`.`catalog`, 'song_artist' AS `object_type`, `artist_map`.`artist_id` FROM `song` LEFT JOIN `artist_map` ON `song`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'song' WHERE `artist_map`.`artist_id` = ? AND `song`.`catalog` > 0 AND `artist_map`.`object_type` = 'song' UNION  SELECT DISTINCT `album`.`catalog`, 'album_artist' AS `object_type`, `artist_map`.`artist_id` FROM `album` LEFT JOIN `artist_map` ON `album`.`id` = `artist_map`.`object_id` AND `artist_map`.`object_type` = 'album' WHERE `artist_map`.`artist_id` = ? AND `album`.`catalog` > 0 AND `artist_map`.`object_type` = 'album' GROUP BY `catalog`, `object_type`, `artist_map`.`artist_id`;\";\n                Dba::write($sql, array($object_id, $object_id, $object_id, $object_id));\n            } else {\n                $sql = \"REPLACE INTO `catalog_map` (`catalog_id`, `object_type`, `object_id`) VALUES (?, ?, ?);\";\n                Dba::write($sql, array($catalog, $object_type, $object_id));\n            }\n        }\n    }\n\n    /**\n     * Migrate an object associated catalog to a new object\n     * @param string $object_type\n     * @param integer $old_object_id\n     * @param integer $new_object_id\n     * @return PDOStatement|boolean\n     */\n    public static function migrate_map($object_type, $old_object_id, $new_object_id)\n    {\n        $sql    = \"UPDATE IGNORE `catalog_map` SET `object_id` = ? WHERE `object_type` = ? AND `object_id` = ?\";\n        $params = array($new_object_id, $object_type, $old_object_id);\n\n        return Dba::write($sql, $params);\n    }\n\n    /**\n     * Updates album tags from given album id\n     * @param int $album_id\n     */\n    protected static function updateAlbumTags(int $album_id)\n    {\n        $tags = self::getSongTags('album', $album_id);\n        Tag::update_tag_list(implode(',', $tags), 'album', $album_id, true);\n    }\n\n    /**\n     * Updates artist tags from given song id\n     * @param int $song_id\n     */\n    protected static function updateArtistTags(int $song_id)\n    {\n        foreach (Song::get_parent_array($song_id) as $artist_id) {\n            $tags = self::getSongTags('artist', $artist_id);\n            Tag::update_tag_list(implode(',', $tags), 'artist', $artist_id, true);\n        }\n    }\n\n    /**\n     * Updates artist tags from given song id\n     * @param int $album_id\n     */\n    protected static function updateAlbumArtistTags(int $album_id)\n    {\n        foreach (Song::get_parent_array($album_id, 'album') as $artist_id) {\n            $tags = self::getSongTags('artist', $artist_id);\n            Tag::update_tag_list(implode(',', $tags), 'artist', $artist_id, true);\n        }\n    }\n\n    /**\n     * Get all tags from all Songs from [type] (artist, album, ...)\n     * @param string $type\n     * @param integer $object_id\n     * @return array\n     */\n    protected static function getSongTags($type, $object_id)\n    {\n        $tags       = array();\n        $sql        = ($type == 'artist')\n            ? \"SELECT `tag`.`name` FROM `tag` JOIN `tag_map` ON `tag`.`id` = `tag_map`.`tag_id` JOIN `song` ON `tag_map`.`object_id` = `song`.`id` WHERE `song`.`id` IN (SELECT `object_id` FROM `artist_map` WHERE `artist_id` = ? AND `object_type` = 'song') AND `tag_map`.`object_type` = 'song' GROUP BY `tag`.`id`, `tag`.`name`;\"\n            : \"SELECT `tag`.`name` FROM `tag` JOIN `tag_map` ON `tag`.`id` = `tag_map`.`tag_id` JOIN `song` ON `tag_map`.`object_id` = `song`.`id` WHERE `song`.`$type` = ? AND `tag_map`.`object_type` = 'song' GROUP BY `tag`.`id`, `tag`.`name`;\";\n        $db_results = Dba::read($sql, array($object_id));\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $tags[] = $row['name'];\n        }\n\n        return $tags;\n    }\n\n    /**\n     * @param Artist|Album|Song|Video|Podcast_Episode|TvShow|TVShow_Episode|Label|TVShow_Season $libitem\n     * @param integer|null $user_id\n     * @return boolean\n     */\n    public static function can_remove($libitem, $user_id = null)\n    {\n        if (!$user_id) {\n            $user    = Core::get_global('user');\n            $user_id = $user->id ?? false;\n        }\n\n        if (!$user_id) {\n            return false;\n        }\n\n        if (!AmpConfig::get('delete_from_disk')) {\n            return false;\n        }\n\n        return (\n            Access::check('interface', 75) ||\n            ($libitem->get_user_owner() == $user_id && AmpConfig::get('upload_allow_remove'))\n        );\n    }\n\n    /**\n     * Return full path of the cached music file.\n     * @param integer $object_id\n     * @param string $catalog_id\n     * @return false|string\n     */\n    public static function get_cache_path($object_id, $catalog_id)\n    {\n        $path   = (string)AmpConfig::get('cache_path', '');\n        $target = AmpConfig::get('cache_target');\n        // need a destination and target filetype\n        if ((!is_dir($path) || !$target)) {\n            return false;\n        }\n        // make a folder per catalog\n        if (!is_dir(rtrim(trim($path), '/') . '/' . $catalog_id)) {\n            mkdir(rtrim(trim($path), '/') . '/' . $catalog_id, 0775, true);\n        }\n        // Create subdirectory based on the 2 last digit of the SongID. We prevent having thousands of file in one directory.\n        $path .= '/' . $catalog_id . '/' . substr($object_id, -1, 1) . '/' . substr($object_id, -2, 1) . '/';\n        if (!file_exists($path)) {\n            mkdir($path, 0755, true);\n        }\n\n        return rtrim(trim($path), '/') . '/' . $object_id . '.' . $target;\n    }\n\n    /**\n     * process_action\n     * @param string $action\n     * @param $catalogs\n     * @param array $options\n     * @noinspection PhpMissingBreakStatementInspection\n     */\n    public static function process_action($action, $catalogs, $options = null)\n    {\n        if (empty($options)) {\n            $options = array(\n                'gather_art' => false,\n                'parse_playlist' => false\n            );\n        }\n        // make sure parse_playlist is set\n        if ($action == 'import_to_catalog') {\n            $options['parse_playlist'] = true;\n        }\n        $catalog = null;\n\n        switch ($action) {\n            case 'add_to_all_catalogs':\n                $catalogs = self::get_catalogs();\n                // Intentional break fall-through\n            case 'add_to_catalog':\n            case 'import_to_catalog':\n                if ($catalogs) {\n                    foreach ($catalogs as $catalog_id) {\n                        $catalog = self::create_from_id($catalog_id);\n                        if ($catalog !== null) {\n                            $catalog->add_to_catalog($options);\n                        }\n                    }\n\n                    if (!defined('SSE_OUTPUT') && !defined('CLI')) {\n                        echo AmpError::display('catalog_add');\n                    }\n                }\n                Artist::update_artist_counts();\n                Album::update_album_counts();\n                break;\n            case 'update_all_catalogs':\n                $catalogs = self::get_catalogs();\n                // Intentional break fall-through\n            case 'update_catalog':\n                if ($catalogs) {\n                    foreach ($catalogs as $catalog_id) {\n                        $catalog = self::create_from_id($catalog_id);\n                        if ($catalog !== null) {\n                            $catalog->verify_catalog();\n                        }\n                    }\n                }\n                break;\n            case 'full_service':\n                if (!$catalogs) {\n                    $catalogs = self::get_catalogs();\n                }\n\n                /* This runs the clean/verify/add in that order */\n                foreach ($catalogs as $catalog_id) {\n                    $catalog = self::create_from_id($catalog_id);\n                    if ($catalog !== null) {\n                        $catalog->clean_catalog();\n                        $catalog->verify_catalog();\n                        $catalog->add_to_catalog();\n                    }\n                }\n                break;\n            case 'clean_all_catalogs':\n                $catalogs = self::get_catalogs();\n                // Intentional break fall-through\n            case 'clean_catalog':\n                if ($catalogs) {\n                    foreach ($catalogs as $catalog_id) {\n                        $catalog = self::create_from_id($catalog_id);\n                        if ($catalog !== null) {\n                            $catalog->clean_catalog();\n                        }\n                    } // end foreach catalogs\n                    Dba::optimize_tables();\n                    Artist::update_artist_counts();\n                    Album::update_album_counts();\n                }\n                break;\n            case 'update_from':\n                $catalog_id = 0;\n                // First see if we need to do an add\n                if ($options['add_path'] != '/' && strlen((string)$options['add_path'])) {\n                    if ($catalog_id = Catalog_local::get_from_path($options['add_path'])) {\n                        $catalog = self::create_from_id($catalog_id);\n                        if ($catalog !== null) {\n                            $catalog->add_to_catalog(array('subdirectory' => $options['add_path']));\n                        }\n                    }\n                } // end if add\n\n                // Now check for an update\n                if ($options['update_path'] != '/' && strlen((string)$options['update_path'])) {\n                    if ($catalog_id = Catalog_local::get_from_path($options['update_path'])) {\n                        $songs = Song::get_from_path($options['update_path']);\n                        foreach ($songs as $song_id) {\n                            self::update_single_item('song', $song_id);\n                        }\n                    }\n                } // end if update\n\n                if ($catalog_id < 1) {\n                    AmpError::add('general',\n                        T_(\"This subdirectory is not inside an existing Catalog. The update can not be processed.\"));\n                }\n                break;\n            case 'gather_media_art':\n                if (!$catalogs) {\n                    $catalogs = self::get_catalogs();\n                }\n\n                // Iterate throughout the catalogs and gather as needed\n                foreach ($catalogs as $catalog_id) {\n                    $catalog = self::create_from_id($catalog_id);\n                    if ($catalog !== null) {\n                        require Ui::find_template('show_gather_art.inc.php');\n                        flush();\n                        $catalog->gather_art();\n                    }\n                }\n                break;\n            case 'update_all_file_tags':\n                $catalogs = self::get_catalogs();\n                // Intentional break fall-through\n            case 'update_file_tags':\n                $write_tags     = AmpConfig::get('write_tags', false);\n                AmpConfig::set_by_array(['write_tags' => 'true'], true);\n\n                $songTagWriter = static::getSongTagWriter();\n                set_time_limit(0);\n                foreach ($catalogs as $catalog_id) {\n                    $catalog = self::create_from_id($catalog_id);\n                    if ($catalog !== null) {\n                        $song_ids = $catalog->get_song_ids();\n                        foreach ($song_ids as $song_id) {\n                            $song = new Song($song_id);\n                            $song->format();\n\n                            $songTagWriter->write($song);\n                        }\n                    }\n                }\n                AmpConfig::set_by_array(['write_tags' => $write_tags], true);\n        }\n\n        if ($catalog) {\n            // clean up after the action\n            debug_event(__CLASS__, 'Run Garbage collection', 5);\n            static::getCatalogGarbageCollector()->collect();\n            $catalog_media_type = $catalog->get_gather_type();\n            if ($catalog_media_type == 'music') {\n                self::clean_empty_albums();\n                Album::update_album_artist();\n                self::update_mapping('artist');\n                self::update_mapping('album');\n            } elseif ($catalog_media_type == 'podcast') {\n                self::update_mapping('podcast');\n                self::update_mapping('podcast_episode');\n            } elseif (in_array($catalog_media_type, array('clip', 'tvshow', 'movie', 'personal_video'))) {\n                self::update_mapping('video');\n            }\n            self::update_counts();\n        }\n    }\n\n    /**\n     * Migrate an object associate images to a new object\n     * @param string $object_type\n     * @param integer $old_object_id\n     * @param integer $new_object_id\n     * @param integer $song_id\n     * @return boolean\n     */\n    public static function migrate($object_type, $old_object_id, $new_object_id, $song_id)\n    {\n        if ($old_object_id != $new_object_id) {\n            debug_event(__CLASS__, \"migrate $song_id $object_type: {{$old_object_id}} to {{$new_object_id}}\", 4);\n\n            Stats::migrate($object_type, $old_object_id, $new_object_id, $song_id);\n            Useractivity::migrate($object_type, $old_object_id, $new_object_id);\n            Recommendation::migrate($object_type, $old_object_id);\n            Share::migrate($object_type, $old_object_id, $new_object_id);\n            Shoutbox::migrate($object_type, $old_object_id, $new_object_id);\n            Tag::migrate($object_type, $old_object_id, $new_object_id);\n            Userflag::migrate($object_type, $old_object_id, $new_object_id);\n            Rating::migrate($object_type, $old_object_id, $new_object_id);\n            Art::duplicate($object_type, $old_object_id, $new_object_id);\n            Playlist::migrate($object_type, $old_object_id, $new_object_id);\n            Label::migrate($object_type, $old_object_id, $new_object_id);\n            Wanted::migrate($object_type, $old_object_id, $new_object_id);\n            Metadata::migrate($object_type, $old_object_id, $new_object_id);\n            Bookmark::migrate($object_type, $old_object_id, $new_object_id);\n            self::migrate_map($object_type, $old_object_id, $new_object_id);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * xml_get_footer\n     * This takes the type and returns the correct xml footer\n     * @param string $type\n     * @return string\n     */\n    private static function xml_get_footer($type)\n    {\n        switch ($type) {\n            case 'itunes':\n                return \"      </dict>\\n\" .\n                    \"</dict>\\n\" .\n                    \"</plist>\\n\";\n            case 'xspf':\n                return \"      </trackList>\\n\" .\n                    \"</playlist>\\n\";\n            default:\n                return '';\n        }\n    } // xml_get_footer\n\n    /**\n     * xml_get_header\n     * This takes the type and returns the correct xml header\n     * @param string $type\n     * @return string\n     */\n    private static function xml_get_header($type)\n    {\n        switch ($type) {\n            case 'itunes':\n                return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" .\n                    \"<!DOCTYPE plist PUBLIC \\\"-//Apple Computer//DTD PLIST 1.0//EN\\\"\\n\" .\n                    \"\\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\">\\n\" .\n                    \"<plist version=\\\"1.0\\\">\\n\" .\n                    \"<dict>\\n\" .\n                    \"       <key>Major Version</key><integer>1</integer>\\n\" .\n                    \"       <key>Minor Version</key><integer>1</integer>\\n\" .\n                    \"       <key>Application Version</key><string>7.0.2</string>\\n\" .\n                    \"       <key>Features</key><integer>1</integer>\\n\" .\n                    \"       <key>Show Content Ratings</key><true/>\\n\" .\n                    \"       <key>Tracks</key>\\n\" .\n                    \"       <dict>\\n\";\n            case 'xspf':\n                return \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\\n\" .\n                    \"<!-- XML Generated by Ampache v.\" . AmpConfig::get('version') . \" -->\";\n            default:\n                return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n        }\n    } // xml_get_header\n\n    /**\n     * @deprecated\n     */\n    private static function getSongRepository(): SongRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(SongRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private static function getAlbumRepository(): AlbumRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(AlbumRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private static function getCatalogGarbageCollector(): CatalogGarbageCollectorInterface\n    {\n        global $dic;\n\n        return $dic->get(CatalogGarbageCollectorInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private static function getSongTagWriter(): SongTagWriterInterface\n    {\n        global $dic;\n\n        return $dic->get(SongTagWriterInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private static function getLabelRepository(): LabelRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(LabelRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private static function getLicenseRepository(): LicenseRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(LicenseRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated inject by constructor\n     */\n    private static function getConfigContainer(): ConfigContainerInterface\n    {\n        global $dic;\n\n        return $dic->get(ConfigContainerInterface::class);\n    }\n\n    /**\n     * @deprecated Inject by constructor\n     */\n    private function getUtilityFactory(): UtilityFactoryInterface\n    {\n        global $dic;\n\n        return $dic->get(UtilityFactoryInterface::class);\n    }\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Repository\\Model;\n\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\ShoutRepositoryInterface;\nuse Ampache\\Repository\\UserActivityRepositoryInterface;\nuse PDOStatement;\n\nclass TVShow_Season extends database_object implements library_item, GarbageCollectibleInterface\n{\n    protected const DB_TABLENAME = 'tvshow_season';\n\n    /* Variables from DB */\n    public $id;\n    public $season_number;\n    public $tvshow;\n\n    public $catalog_id;\n    public $episodes;\n    public $f_name;\n    public $f_tvshow;\n    public $f_tvshow_link;\n    public $link;\n    public $f_link;\n\n    // Constructed vars\n    private static $_mapcache = array();\n\n    /**\n     * TV Show\n     * Takes the ID of the tv show season and pulls the info from the db\n     * @param $show_id\n     */\n    public function __construct($show_id)\n    {\n        /* Get the information from the db */\n        $info = $this->get_info($show_id);\n\n        foreach ($info as $key => $value) {\n            $this->$key = $value;\n        } // foreach info\n\n        return true;\n    } // constructor\n\n    public function getId(): int\n    {\n        return (int)$this->id;\n    }\n\n    /**\n     * garbage_collection\n     *\n     * This cleans out unused tv shows seasons\n     */\n    public static function garbage_collection()\n    {\n        $sql = \"DELETE FROM `tvshow_season` USING `tvshow_season` LEFT JOIN `tvshow_episode` ON `tvshow_episode`.`season` = `tvshow_season`.`id` WHERE `tvshow_episode`.`id` IS NULL\";\n        Dba::write($sql);\n    }\n\n    /**\n     * get_songs\n     * gets all episodes for this tv show season\n     * @return array\n     */\n    public function get_episodes()\n    {\n        $sql = (AmpConfig::get('catalog_disable'))\n            ? \"SELECT `tvshow_episode`.`id` FROM `tvshow_episode` LEFT JOIN `video` ON `video`.`id` = `tvshow_episode`.`id` LEFT JOIN `catalog` ON `catalog`.`id` = `video`.`catalog` WHERE `tvshow_episode`.`season`='\" . Dba::escape($this->id) . \"' AND `catalog`.`enabled` = '1' \"\n            : \"SELECT `tvshow_episode`.`id` FROM `tvshow_episode` WHERE `tvshow_episode`.`season`='\" . Dba::escape($this->id) . \"' \";\n        $sql .= \"ORDER BY `tvshow_episode`.`episode_number`\";\n\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row['id'];\n        }\n\n        return $results;\n    } // get_episodes\n\n    /**\n     * _get_extra info\n     * This returns the extra information for the tv show season, this means totals etc\n     * @return array\n     */\n    private function _get_extra_info()\n    {\n        // Try to find it in the cache and save ourselves the trouble\n        if (parent::is_cached('tvshow_extra', $this->id)) {\n            $row = parent::get_from_cache('tvshow_extra', $this->id);\n        } else {\n            $sql = \"SELECT COUNT(`tvshow_episode`.`id`) AS `episode_count`, `video`.`catalog` AS `catalog_id` FROM `tvshow_episode` LEFT JOIN `video` ON `video`.`id` = `tvshow_episode`.`id` WHERE `tvshow_episode`.`season` = ? GROUP BY `catalog_id`\";\n\n            $db_results = Dba::read($sql, array($this->id));\n            $row        = Dba::fetch_assoc($db_results);\n            parent::add_to_cache('tvshow_extra', $this->id, $row);\n        }\n\n        /* Set Object Vars */\n        $this->episodes   = $row['episode_count'];\n        $this->catalog_id = $row['catalog_id'];\n\n        return $row;\n    } // _get_extra_info\n\n    /**\n     * format\n     * this function takes the object and formats some values\n     * @param boolean $details\n     * @return boolean\n     */\n    public function format($details = true)\n    {\n        $tvshow = new TvShow($this->tvshow);\n        $tvshow->format($details);\n        $this->f_tvshow      = $tvshow->get_link();\n        $this->f_tvshow_link = $tvshow->f_link;\n\n        $this->f_link = '<a href=\"' . $this->get_link() . '\" title=\"' . $tvshow->get_fullname() . ' - ' . scrub_out($this->get_fullname()) . '\">' . scrub_out($this->get_fullname()) . '</a>';\n\n        if ($details) {\n            $this->_get_extra_info();\n        }\n\n        return true;\n    }\n\n    /**\n     * Get item keywords for metadata searches.\n     * @return array\n     */\n    public function get_keywords()\n    {\n        $keywords           = array();\n        $keywords['tvshow'] = array(\n            'important' => true,\n            'label' => T_('TV Show'),\n            'value' => $this->f_tvshow\n        );\n        $keywords['tvshow_season'] = array(\n            'important' => false,\n            'label' => T_('Season'),\n            'value' => $this->season_number\n        );\n        $keywords['type'] = array(\n            'important' => false,\n            'label' => null,\n            'value' => 'tvshow'\n        );\n\n        return $keywords;\n    }\n\n    /**\n     * @return string\n     */\n    public function get_fullname()\n    {\n        // don't do anything if it's formatted\n        if (!isset($this->f_name)) {\n            $this->f_name = T_('Season') . ' ' . $this->season_number;\n        }\n\n        return $this->f_name;\n    }\n\n    /**\n     * Get item link.\n     * @return string\n     */\n    public function get_link()\n    {\n        // don't do anything if it's formatted\n        if (!isset($this->link)) {\n            $web_path   = AmpConfig::get('web_path');\n            $this->link = $web_path . '/tvshow_seasons.php?action=show&season=' . $this->id;\n        }\n\n        return $this->link;\n    }\n\n    /**\n     * @return array\n     */\n    public function get_parent()\n    {\n        return array('object_type' => 'tvshow', 'object_id' => $this->tvshow);\n    }\n\n    /**\n     * @return array\n     */\n    public function get_childrens()\n    {\n        return array('tvshow_episode' => $this->get_episodes());\n    }\n\n    /**\n     * @param string $name\n     * @return array\n     */\n    public function search_childrens($name)\n    {\n        debug_event(self::class, 'search_childrens ' . $name, 5);\n\n        return array();\n    }\n\n    /**\n     * get_medias\n     * @param string $filter_type\n     * @return array\n     */\n    public function get_medias($filter_type = null)\n    {\n        $medias = array();\n        if ($filter_type === null || $filter_type == 'video') {\n            $episodes = $this->get_episodes();\n            foreach ($episodes as $episode_id) {\n                $medias[] = array(\n                    'object_type' => 'video',\n                    'object_id' => $episode_id\n                );\n            }\n        }\n\n        return $medias;\n    }\n\n    /**\n     * get_catalogs\n     *\n     * Get all catalog ids related to this item.\n     * @return integer[]\n     */\n    public function get_catalogs()\n    {\n        return array($this->catalog_id);\n    }\n\n    /**\n     * @return mixed|null\n     */\n    public function get_user_owner()\n    {\n        return null;\n    }\n\n    /**\n     * @return string\n     */\n    public function get_default_art_kind()\n    {\n        return 'default';\n    }\n\n    /**\n     * @return mixed\n     */\n    public function get_description()\n    {\n        // No season description for now, always return tvshow description\n        $tvshow = new TvShow($this->tvshow);\n\n        return $tvshow->get_description();\n    }\n\n    /**\n     * display_art\n     * @param integer $thumb\n     * @param boolean $force\n     */\n    public function display_art($thumb = 2, $force = false)\n    {\n        $tvshow_id = null;\n        $type      = null;\n\n        if (Art::has_db($this->id, 'tvshow_season')) {\n            $tvshow_id = $this->id;\n            $type      = 'tvshow_season';\n        } else {\n            if (Art::has_db($this->tvshow, 'tvshow') || $force) {\n                $tvshow_id = $this->tvshow;\n                $type      = 'tvshow';\n            }\n        }\n\n        if ($tvshow_id !== null && $type !== null) {\n            Art::display($type, $tvshow_id, $this->get_fullname(), $thumb, $this->get_link());\n        }\n    }\n\n    /**\n     * check\n     *\n     * Checks for an existing tv show season; if none exists, insert one.\n     * @param $tvshow\n     * @param $season_number\n     * @param boolean $readonly\n     * @return string|null\n     */\n    public static function check($tvshow, $season_number, $readonly = false)\n    {\n        $name = $tvshow . '_' . $season_number;\n        // null because we don't have any unique id like mbid for now\n        if (isset(self::$_mapcache[$name]['null'])) {\n            return self::$_mapcache[$name]['null'];\n        }\n\n        $object_id  = 0;\n        $exists     = false;\n        $sql        = 'SELECT `id` FROM `tvshow_season` WHERE `tvshow` = ? AND `season_number` = ?';\n        $db_results = Dba::read($sql, array($tvshow, $season_number));\n        $id_array   = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $key            = 'null';\n            $id_array[$key] = $row['id'];\n        }\n\n        if (count($id_array)) {\n            $object_id = array_shift($id_array);\n            $exists    = true;\n        }\n\n        if ($exists && (int)$object_id > 0) {\n            self::$_mapcache[$name]['null'] = $object_id;\n\n            return $object_id;\n        }\n\n        if ($readonly) {\n            return null;\n        }\n\n        $sql = 'INSERT INTO `tvshow_season` (`tvshow`, `season_number`) ' . 'VALUES(?, ?)';\n\n        $db_results = Dba::write($sql, array($tvshow, $season_number));\n        if (!$db_results) {\n            return null;\n        }\n        $object_id = Dba::insert_id();\n\n        self::$_mapcache[$name]['null'] = $object_id;\n\n        return $object_id;\n    }\n\n    /**\n     * update\n     * This takes a key'd array of data and updates the current tv show\n     * @param array $data\n     * @return mixed\n     */\n    public function update(array $data)\n    {\n        $sql = 'UPDATE `tvshow_season` SET `season_number` = ?, `tvshow` = ? WHERE `id` = ?';\n        Dba::write($sql, array($data['season_number'], $data['tvshow'], $this->id));\n\n        return $this->id;\n    } // update\n\n    /**\n     * @return PDOStatement|boolean\n     */\n    public function remove()\n    {\n        $deleted = true;\n        $videos  = $this->get_episodes();\n        foreach ($videos as $video_id) {\n            $video   = Video::create_from_id($video_id);\n            $deleted = $video->remove();\n            if (!$deleted) {\n                debug_event(self::class, 'Error when deleting the video `' . $video_id . '`.', 1);\n                break;\n            }\n        }\n\n        if ($deleted) {\n            $sql     = \"DELETE FROM `tvshow_season` WHERE `id` = ?\";\n            $deleted = Dba::write($sql, array($this->id));\n            if ($deleted) {\n                Art::garbage_collection('tvshow_season', $this->id);\n                Userflag::garbage_collection('tvshow_season', $this->id);\n                Rating::garbage_collection('tvshow_season', $this->id);\n                $this->getShoutRepository()->collectGarbage('tvshow_season', $this->getId());\n                $this->getUseractivityRepository()->collectGarbage('tvshow_season', $this->getId());\n            }\n        }\n\n        return $deleted;\n    }\n\n    /**\n     * @param $tvshow_id\n     * @param $season_id\n     * @return PDOStatement|boolean\n     */\n    public static function update_tvshow($tvshow_id, $season_id)\n    {\n        $sql = \"UPDATE `tvshow_season` SET `tvshow` = ? WHERE `id` = ?\";\n\n        return Dba::write($sql, array($tvshow_id, $season_id));\n    }\n\n    /**\n     * @deprecated\n     */\n    private function getShoutRepository(): ShoutRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(ShoutRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated\n     */\n    private function getUseractivityRepository(): UserActivityRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(UserActivityRepositoryInterface::class);\n    }\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Repository\\Model;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\Util\\InterfaceImplementationChecker;\nuse PDOStatement;\n\n/**\n * Tag Class\n *\n * This class handles all of the genre related operations\n *\n */\nclass Tag extends database_object implements library_item, GarbageCollectibleInterface\n{\n    protected const DB_TABLENAME = 'tag';\n\n    public $id;\n    public $name;\n    public $f_name;\n    public $is_hidden;\n\n    /**\n     * constructor\n     * This takes a tag id and returns all of the relevant information\n     * @param $tag_id\n     */\n    public function __construct($tag_id)\n    {\n        if (!$tag_id) {\n            return false;\n        }\n\n        $info = $this->get_info($tag_id);\n        if (empty($info)) {\n            return false;\n        }\n\n        foreach ($info as $key => $value) {\n            $this->$key = $value;\n        } // end foreach\n\n        // the ui is sometimes looking for a formatted name...\n        $this->f_name = scrub_out($this->name);\n\n        return true;\n    } // constructor\n\n    public function getId(): int\n    {\n        return (int)$this->id;\n    }\n\n    /**\n     * construct_from_name\n     * This attempts to construct the tag from a name, rather then the ID\n     * @param string $name\n     * @return Tag\n     */\n    public static function construct_from_name($name)\n    {\n        $tag_id = self::tag_exists($name);\n\n        return new Tag($tag_id);\n    } // construct_from_name\n\n    /**\n     * build_cache\n     * This takes an array of object ids and caches all of their information\n     * in a single query, cuts down on the connections\n     * @param array $ids\n     * @return boolean\n     */\n    public static function build_cache($ids)\n    {\n        if (empty($ids)) {\n            return false;\n        }\n        $idlist     = '(' . implode(',', $ids) . ')';\n        $sql        = \"SELECT * FROM `tag` WHERE `id` IN $idlist\";\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            parent::add_to_cache('tag', $row['id'], $row);\n        }\n\n        return true;\n    } // build_cache\n\n    /**\n     * build_map_cache\n     * This builds a cache of the mappings for the specified object, no limit is given\n     * @param string $type\n     * @param $ids\n     * @return boolean\n     * @params array $ids\n     */\n    public static function build_map_cache($type, $ids)\n    {\n        if (!is_array($ids) || !count($ids)) {\n            return false;\n        }\n\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return false;\n        }\n\n        $idlist = '(' . implode(',', $ids) . ')';\n\n        $sql = \"SELECT `tag_map`.`id`, `tag_map`.`tag_id`, `tag`.`name`, `tag_map`.`object_id`, `tag_map`.`user` FROM `tag` LEFT JOIN `tag_map` ON `tag_map`.`tag_id`=`tag`.`id` WHERE `tag`.`is_hidden` = false AND `tag_map`.`object_type`='$type' AND `tag_map`.`object_id` IN $idlist\";\n\n        $db_results = Dba::read($sql);\n\n        $tags    = array();\n        $tag_map = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $tags[$row['object_id']][$row['tag_id']] = array(\n                'user' => $row['user'],\n                'id' => $row['tag_id'],\n                'name' => $row['name']\n            );\n            $tag_map[$row['object_id']] = array(\n                'id' => $row['id'],\n                'tag_id' => $row['tag_id'],\n                'user' => $row['user'],\n                'object_type' => $type,\n                'object_id' => $row['object_id']\n            );\n        }\n\n        // Run through our original ids as we also want to cache NULL\n        // results\n        foreach ($ids as $tagid) {\n            if (!isset($tags[$tagid])) {\n                $tags[$tagid]    = null;\n                $tag_map[$tagid] = null;\n            }\n            parent::add_to_cache('tag_top_' . $type, $tagid, array($tags[$tagid]));\n            parent::add_to_cache('tag_map_' . $type, $tagid, array($tag_map[$tagid]));\n        }\n\n        return true;\n    } // build_map_cache\n\n    /**\n     * add\n     * This is a wrapper function, it figures out what we need to add, be it a tag\n     * and map, or just the mapping\n     * @param string $type\n     * @param integer $object_id\n     * @param string $value\n     * @param boolean $user\n     * @return bool|int\n     */\n    public static function add($type, $object_id, $value, $user = true)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return false;\n        }\n\n        if (!is_numeric($object_id)) {\n            return false;\n        }\n\n        $cleaned_value = str_replace('Folk, World, & Country', 'Folk World & Country', $value);\n\n        if (!strlen((string)$cleaned_value)) {\n            return false;\n        }\n\n        if ($user === true) {\n            $uid = (int)(Core::get_global('user')->id);\n        } else {\n            $uid = (int)($user);\n        }\n\n        // Check and see if the tag exists, if not create it, we need the tag id from this\n        if (!$tag_id = self::tag_exists($cleaned_value)) {\n            debug_event(self::class, 'Adding new tag {' . $cleaned_value . '}', 5);\n            $tag_id = self::add_tag($cleaned_value);\n        }\n\n        if (!$tag_id) {\n            debug_event(self::class, 'Error unable to create tag value:' . $cleaned_value . ' unknown error', 1);\n\n            return false;\n        }\n\n        // We've got the tag id, let's see if it's already got a map, if not then create the map and return the value\n        if (!$map_id = self::tag_map_exists($type, $object_id, (int)$tag_id, $uid)) {\n            $map_id = self::add_tag_map($type, $object_id, (int)$tag_id, $user);\n        }\n\n        return (int)$map_id;\n    } // add\n\n    /**\n     * add_tag\n     * This function adds a new tag, for now we're going to limit the tagging a bit\n     * @param string $value\n     * @return int|null\n     */\n    public static function add_tag($value)\n    {\n        if (!strlen((string)$value)) {\n            return null;\n        }\n\n        $sql = \"REPLACE INTO `tag` SET `name` = ?\";\n        Dba::write($sql, array($value));\n        $insert_id = (int)Dba::insert_id();\n\n        parent::add_to_cache('tag_name', $value, array($insert_id));\n\n        return $insert_id;\n    } // add_tag\n\n    /**\n     * update\n     * Update the name of the tag\n     * @param array $data\n     * @return boolean\n     */\n    public function update(array $data)\n    {\n        if (!strlen((string)$data['name'])) {\n            return false;\n        }\n        $name      = $data['name'] ?? $this->name;\n        $is_hidden = (array_key_exists('is_hidden', $data))\n            ? (int)$data['is_hidden']\n            : 0;\n\n        if ($name != $this->name) {\n            debug_event(self::class, 'Updating tag {' . $this->id . '} with name {' . $data['name'] . '}...', 5);\n            $sql = 'UPDATE `tag` SET `name` = ? WHERE `id` = ?';\n            Dba::write($sql, array($name, $this->id));\n        }\n        if ($is_hidden != (int)$this->is_hidden) {\n            debug_event(self::class, 'Hidden tag {' . $this->id . '} with status {' . $is_hidden . '}...', 5);\n            $sql = 'UPDATE `tag` SET `is_hidden` = ? WHERE `id` = ?';\n            Dba::write($sql, array($is_hidden, $this->id));\n            // if you had previously hidden this tag then remove the merges too\n            if ($is_hidden == 0 && (int)$this->is_hidden == 1) {\n                debug_event(self::class, 'Unhiding tag {' . $this->id . '} removing all previous merges', 5);\n                $this->remove_merges();\n            }\n            $this->is_hidden = $is_hidden;\n        }\n\n        if (array_key_exists('edit_tags', $data) && $data['edit_tags']) {\n            $filterfolk  = str_replace('Folk, World, & Country', 'Folk World & Country', $data['edit_tags']);\n            $filterunder = str_replace('_', ', ', $filterfolk);\n            $filter      = str_replace(';', ', ', $filterunder);\n            $filter_list = preg_split('/(\\s*,*\\s*)*,+(\\s*,*\\s*)*/', $filter);\n            $tag_names   = (is_array($filter_list)) ? array_unique($filter_list) : array();\n\n            foreach ($tag_names as $tag) {\n                $merge_to = self::construct_from_name($tag);\n                if ($merge_to->id == 0) {\n                    self::add_tag($tag);\n                    $merge_to = self::construct_from_name($tag);\n                }\n                $this->merge($merge_to->id, array_key_exists('merge_persist', $data));\n            }\n            if (!array_key_exists('keep_existing', $data)) {\n                $sql = \"DELETE FROM `tag_map` WHERE `tag_map`.`tag_id` = ? \";\n                Dba::write($sql, array($this->id));\n                if (!array_key_exists('merge_persist', $data)) {\n                    $this->delete();\n                } else {\n                    $sql = \"UPDATE `tag` SET `is_hidden` = 1 WHERE `tag`.`id` = ? \";\n                    Dba::write($sql, array($this->id));\n                }\n            }\n        }\n\n        return $this->id;\n    } // add_tag\n\n    /**\n     * merge\n     * merges this tag to another one.\n     * @param integer $merge_to\n     * @param boolean $is_persistent\n     */\n    public function merge($merge_to, $is_persistent)\n    {\n        if ($this->id != $merge_to) {\n            debug_event(self::class, 'Merging tag ' . $this->id . ' into ' . $merge_to . ')...', 5);\n\n            $sql = \"REPLACE INTO `tag_map` (`tag_id`, `user`, `object_type`, `object_id`) SELECT \" . $merge_to . \",`user`, `object_type`, `object_id` FROM `tag_map` AS `tm` WHERE `tm`.`tag_id` = \" . $this->id . \" AND NOT EXISTS (SELECT 1 FROM `tag_map` WHERE `tag_map`.`tag_id` = \" . $merge_to . \" AND `tag_map`.`object_id` = `tm`.`object_id` AND `tag_map`.`object_type` = `tm`.`object_type` AND `tag_map`.`user` = `tm`.`user`)\";\n            Dba::write($sql);\n            if ($is_persistent) {\n                $sql = \"REPLACE INTO `tag_merge` (`tag_id`, `merged_to`) VALUES (?, ?)\";\n                Dba::write($sql, array($this->id, $merge_to));\n            }\n        }\n    }\n\n    /**\n     * get_merged_tags\n     * Get merged tags to this tag.\n     * @return array\n     */\n    public function get_merged_tags()\n    {\n        $sql = \"SELECT `tag`.`id`, `tag`.`name`FROM `tag_merge` INNER JOIN `tag` ON `tag`.`id` = `tag_merge`.`merged_to` WHERE `tag_merge`.`tag_id` = ? ORDER BY `tag`.`name` \";\n\n        $db_results = Dba::read($sql, array($this->id));\n\n        $results = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['id']] = array('id' => $row['id'], 'name' => $row['name']);\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_merged_count\n     * @return int\n     */\n    public static function get_merged_count()\n    {\n        $results    = 0;\n        $sql        = \"SELECT COUNT(DISTINCT `tag_id`) AS `tag_count` FROM `tag_merge`;\";\n        $db_results = Dba::read($sql);\n\n        if ($row = Dba::fetch_assoc($db_results)) {\n            $results = (int)$row['tag_count'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * has_merge\n     * Get merged tags to this tag.\n     * @param string $name\n     * @return bool\n     */\n    public function has_merge($name)\n    {\n        $sql        = \"SELECT `tag`.`name` FROM `tag_merge` INNER JOIN `tag` ON `tag`.`id` = `tag_merge`.`merged_to` WHERE `tag_merge`.`tag_id` = ? ORDER BY `tag`.`name` \";\n        $db_results = Dba::read($sql, array($this->id));\n        while ($row = Dba::fetch_assoc($db_results)) {\n            if ($name == $row['name']) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * remove_merges\n     * Remove merged tags from this tag.\n     */\n    public function remove_merges()\n    {\n        $sql = \"DELETE FROM `tag_merge` WHERE `tag_merge`.`tag_id` = ?;\";\n        Dba::write($sql, array($this->id));\n    }\n\n    /**\n     * add_tag_map\n     * This adds a specific tag to the map for specified object\n     * @param string $type\n     * @param integer|string $object_id\n     * @param integer|string $tag_id\n     * @param boolean $user\n     * @return boolean|int\n     */\n    public static function add_tag_map($type, $object_id, $tag_id, $user = true)\n    {\n        if ($user === true) {\n            $uid = (int)(Core::get_global('user')->id);\n        } else {\n            $uid = (int)($user);\n        }\n\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            debug_event(__CLASS__, $type . \" is not a library item.\", 3);\n\n            return false;\n        }\n        $tag_id  = (int)($tag_id);\n        $item_id = (int)($object_id);\n\n        if (!$tag_id || !$item_id) {\n            return false;\n        }\n\n        // If tag merged to another one, add reference to the merge destination\n        $parent = new Tag($tag_id);\n        $merges = $parent->get_merged_tags();\n        if (!$parent->is_hidden) {\n            $merges[] = array('id' => $parent->id, 'name' => $parent->name);\n        }\n        foreach ($merges as $tag) {\n            $sql = \"INSERT IGNORE INTO `tag_map` (`tag_id`, `user`, `object_type`, `object_id`) VALUES (?, ?, ?, ?)\";\n            Dba::write($sql, array($tag['id'], $uid, $type, $item_id));\n        }\n        $insert_id = (int)Dba::insert_id();\n\n        parent::add_to_cache('tag_map_' . $type, $insert_id, array('tag_id' => $tag_id, 'user' => $uid, 'object_type' => $type, 'object_id' => $item_id));\n\n        return $insert_id;\n    } // add_tag_map\n\n    /**\n     * garbage_collection\n     *\n     * This cleans out tag_maps that are obsolete and then removes tags that\n     * have no maps.\n     */\n    public static function garbage_collection()\n    {\n        $sql = \"DELETE FROM `tag_map` USING `tag_map` LEFT JOIN `song` ON `song`.`id`=`tag_map`.`object_id` WHERE `tag_map`.`object_type`='song' AND `song`.`id` IS NULL\";\n        Dba::write($sql);\n\n        $sql = \"DELETE FROM `tag_map` USING `tag_map` LEFT JOIN `album` ON `album`.`id`=`tag_map`.`object_id` WHERE `tag_map`.`object_type`='album' AND `album`.`id` IS NULL\";\n        Dba::write($sql);\n\n        $sql = \"DELETE FROM `tag_map` USING `tag_map` LEFT JOIN `artist` ON `artist`.`id`=`tag_map`.`object_id` WHERE `tag_map`.`object_type`='artist' AND `artist`.`id` IS NULL\";\n        Dba::write($sql);\n\n        // Now nuke the tags themselves\n        $sql = \"DELETE FROM `tag` USING `tag` LEFT JOIN `tag_map` ON `tag`.`id`=`tag_map`.`tag_id` WHERE `tag_map`.`id` IS NULL AND NOT EXISTS (SELECT 1 FROM `tag_merge` WHERE `tag_merge`.`tag_id` = `tag`.`id`)\";\n        Dba::write($sql);\n\n        // delete duplicates\n        $sql = \"DELETE `b` FROM `tag_map` AS `a`, `tag_map` AS `b` WHERE `a`.`id` < `b`.`id` AND `a`.`tag_id` <=> `b`.`tag_id` AND `a`.`object_id` <=> `b`.`object_id` AND `a`.`object_type` <=> `b`.`object_type`\";\n        Dba::write($sql);\n    }\n\n    /**\n     * delete\n     *\n     * Delete the tag and all maps\n     */\n    public function delete()\n    {\n        $sql = \"DELETE FROM `tag_map` WHERE `tag_map`.`tag_id` = ?\";\n        Dba::write($sql, array($this->id));\n\n        $sql = \"DELETE FROM `tag_merge` WHERE `tag_merge`.`tag_id` = ?\";\n        Dba::write($sql, array($this->id));\n\n        $sql = \"DELETE FROM `tag` WHERE `tag`.`id` = ? \";\n        Dba::write($sql, array($this->id));\n\n        // Call the garbage collector to clean everything\n        self::garbage_collection();\n\n        parent::clear_cache();\n    }\n\n    /**\n     * tag_exists\n     * This checks to see if a tag exists, this has nothing to do with objects or maps\n     * @param string $value\n     * @return integer\n     */\n    public static function tag_exists($value)\n    {\n        if (parent::is_cached('tag_name', $value)) {\n            return (int)(parent::get_from_cache('tag_name', $value))[0];\n        }\n\n        $sql        = \"SELECT `id` FROM `tag` WHERE `name` = ?\";\n        $db_results = Dba::read($sql, array($value));\n        $results    = Dba::fetch_assoc($db_results);\n\n        if (array_key_exists('id', $results)) {\n            parent::add_to_cache('tag_name', $value, array($results['id']));\n\n            return (int)$results['id'];\n        }\n\n        return 0;\n    } // tag_exists\n\n    /**\n     * tag_map_exists\n     * This looks to see if the current mapping of the current object of the current tag of the current\n     * user exists, lots of currents... taste good in scones.\n     * @param string $type\n     * @param integer $object_id\n     * @param integer $tag_id\n     * @param integer $user\n     * @return bool|int\n     */\n    public static function tag_map_exists($type, $object_id, $tag_id, $user)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            debug_event(__CLASS__, 'Requested type is not a library item.', 3);\n\n            return false;\n        }\n\n        $sql        = \"SELECT * FROM `tag_map` LEFT JOIN `tag` ON `tag`.`id` = `tag_map`.`tag_id` LEFT JOIN `tag_merge` ON `tag`.`id`=`tag_merge`.`tag_id` WHERE (`tag_map`.`tag_id` = ? OR `tag_map`.`tag_id` = `tag_merge`.`merged_to`) AND `tag_map`.`user` = ? AND `tag_map`.`object_id` = ? AND `tag_map`.`object_type` = ?\";\n        $db_results = Dba::read($sql, array($tag_id, $user, $object_id, $type));\n        $results    = Dba::fetch_assoc($db_results);\n\n        if (array_key_exists('id', $results)) {\n            return (int)$results['id'];\n        }\n\n        return false;\n    } // tag_map_exists\n\n    /**\n     * get_top_tags\n     * This gets the top tags for the specified object using limit\n     * @param string $type\n     * @param integer $object_id\n     * @param integer $limit\n     * @return array\n     */\n    public static function get_top_tags($type, $object_id, $limit = 10)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return array();\n        }\n\n        $object_id = (int)($object_id);\n\n        $limit = (int)($limit);\n        $sql   = \"SELECT `tag_map`.`id`, `tag_map`.`tag_id`, `tag`.`name`, `tag_map`.`user` FROM `tag` LEFT JOIN `tag_map` ON `tag_map`.`tag_id`=`tag`.`id` WHERE `tag`.`is_hidden` = false AND `tag_map`.`object_type` = ? AND `tag_map`.`object_id` = ? LIMIT $limit\";\n\n        $db_results = Dba::read($sql, array($type, $object_id));\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['id']] = array('user' => $row['user'], 'id' => $row['tag_id'], 'name' => $row['name']);\n        }\n\n        return $results;\n    } // get_top_tags\n\n    /**\n     * get_object_tags\n     * Display all tags that apply to matching target type of the specified id\n     * @param string $type\n     * @param integer $object_id\n     * @return array|boolean\n     */\n    public static function get_object_tags($type, $object_id = null)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return false;\n        }\n\n        $params = array($type);\n        $sql    = \"SELECT `tag_map`.`id`, `tag`.`name`, `tag_map`.`user` FROM `tag` LEFT JOIN `tag_map` ON `tag_map`.`tag_id`=`tag`.`id` WHERE `tag`.`is_hidden` = false AND `tag_map`.`object_type` = ?\";\n        if ($object_id !== null) {\n            $sql .= \" AND `tag_map`.`object_id` = ?\";\n            $params[] = $object_id;\n        }\n        $results    = array();\n        $db_results = Dba::read($sql, $params);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row;\n        }\n\n        return $results;\n    } // get_object_tags\n\n    /**\n     * get_tag_objects\n     * This gets the objects from a specified tag and returns an array of object ids, nothing more\n     * @param string $type\n     * @param $tag_id\n     * @param string $count\n     * @param string $offset\n     * @return integer[]\n     */\n    public static function get_tag_objects($type, $tag_id, $count = '', $offset = '')\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return array();\n        }\n        $tag_sql   = ((int) $tag_id == 0) ? \"\" : \"`tag_map`.`tag_id` = ? AND\";\n        $sql_param = ($tag_sql == \"\") ? array($type) : array($tag_id, $type);\n        $limit_sql = \"\";\n        if ($count) {\n            $limit_sql = \" LIMIT \";\n            if ($offset) {\n                $limit_sql .= (string)($offset) . ', ';\n            }\n            $limit_sql .= (string)($count);\n        }\n\n        $sql = ($type == 'album')\n            ? \"SELECT DISTINCT MIN(`tag_map`.`object_id`) AS `object_id` FROM `tag_map` LEFT JOIN `album` ON `tag_map`.`object_id` = `album`.`id` \"\n            : \"SELECT DISTINCT `tag_map`.`object_id` FROM `tag_map` \";\n        $sql .= \"WHERE $tag_sql `tag_map`.`object_type` = ?\";\n        if (AmpConfig::get('catalog_disable') && in_array($type, array('song', 'artist', 'album'))) {\n            $sql .= \"AND \" . Catalog::get_enable_filter($type, '`tag_map`.`object_id`');\n        }\n        if ($type == 'album') {\n            if (AmpConfig::get('album_group')) {\n                $sql .= \" GROUP BY `album`.`prefix`, `album`.`name`, `album`.`album_artist`, `album`.`release_type`, `album`.`release_status`, `album`.`mbid`, `album`.`year`, `album`.`original_year`, `album`.`mbid_group`\";\n            } else {\n                $sql .= \" GROUP BY `album`.`id`, `album`.`disk`\";\n            }\n        }\n        $sql .= $limit_sql;\n        $db_results = Dba::read($sql, $sql_param);\n\n        $results = array();\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['object_id'];\n        }\n\n        return $results;\n    } // get_tag_objects\n\n    /**\n     * get_tag_ids\n     * This gets the objects from a specified tag and returns an array of object ids, nothing more\n     * @param string $type\n     * @param string $count\n     * @param string $offset\n     * @return integer[]\n     */\n    public static function get_tag_ids($type, $count = '', $offset = '')\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return array();\n        }\n\n        $limit_sql = \"\";\n        if ($count) {\n            $limit_sql = \" LIMIT \";\n            if ($offset) {\n                $limit_sql .= (string)($offset) . ', ';\n            }\n            $limit_sql .= (string)($count);\n        }\n\n        $sql = \"SELECT DISTINCT `tag_map`.`tag_id` FROM `tag_map` WHERE `tag_map`.`object_type` = ? \";\n        if (AmpConfig::get('catalog_disable') && in_array($type, array('song', 'artist', 'album'))) {\n            $sql .= \"AND \" . Catalog::get_enable_filter($type, '`tag_map`.`object_id`');\n        }\n        $sql .= $limit_sql;\n        $db_results = Dba::read($sql, array($type));\n\n        $results = array();\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int)$row['tag_id'];\n        }\n\n        return $results;\n    } // get_tag_ids\n\n    /**\n     * get_tags\n     * This is a non-object non type dependent function that just returns tags\n     * we've got, it can take filters (this is used by the tag cloud)\n     * @param string $type\n     * @param integer $limit\n     * @param string $order\n     * @return array\n     */\n    public static function get_tags($type = '', $limit = 0, $order = 'count')\n    {\n        if (parent::is_cached('tags_list', 'no_name')) {\n            //debug_event(self::class, 'Tags list found into cache memory!', 5);\n            return parent::get_from_cache('tags_list', 'no_name');\n        }\n\n        $results  = array();\n        if ($type == 'tag_hidden') {\n            $sql = \"SELECT `tag`.`id` AS `tag_id`, `tag`.`name`, `tag`.`is_hidden` FROM `tag` WHERE `tag`.`is_hidden` = true \";\n        } else {\n            $type_sql = (!empty($type))\n                ? \"AND `tag_map`.`object_type` = '\" . (string)scrub_in($type) . \"'\"\n                : \"\";\n            $sql = (AmpConfig::get('catalog_filter') && !empty(Core::get_global('user')))\n                ? \"SELECT `tag_map`.`tag_id`, `tag`.`name`, `tag`.`is_hidden`, COUNT(`tag_map`.`object_id`) AS `count` FROM `tag_map` LEFT JOIN `tag` ON `tag`.`id`=`tag_map`.`tag_id` $type_sql AND `tag`.`is_hidden` = false WHERE\" . Catalog::get_user_filter('tag', Core::get_global('user')->id) . \" AND `name` IS NOT NULL \"\n                : \"SELECT `tag_map`.`tag_id`, `tag`.`name`, `tag`.`is_hidden`, COUNT(`tag_map`.`object_id`) AS `count` FROM `tag_map` LEFT JOIN `tag` ON `tag`.`id`=`tag_map`.`tag_id` $type_sql AND `tag`.`is_hidden` = false WHERE `name` IS NOT NULL \";\n\n            $sql .= \"GROUP BY `tag_map`.`tag_id`, `tag`.`name`, `tag`.`is_hidden` \";\n        }\n        $order = \"`\" . $order . \"`\";\n        if ($order == 'count') {\n            $order .= \" DESC\";\n        }\n        $sql .= \"ORDER BY \" . $order;\n\n        if ($limit > 0) {\n            $sql .= \" LIMIT $limit\";\n        }\n        //debug_event(self::class, 'get_tags ' . $sql, 5);\n\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['tag_id']] = array(\n                'id' => $row['tag_id'],\n                'name' => $row['name'],\n                'is_hidden' => $row['is_hidden'],\n                'count' => $row['count'] ?? 0\n            );\n        }\n\n        parent::add_to_cache('tags_list', 'no_name', $results);\n\n        return $results;\n    } // get_tags\n\n    /**\n     * get_display\n     * This returns a csv formatted version of the tags that we are given\n     * it also takes a type so that it knows how to return it, this is used\n     * by the formatting functions of the different objects\n     * @param array $tags\n     * @param boolean $link\n     * @param string $filter_type\n     * @return string\n     */\n    public static function get_display($tags, $link = false, $filter_type = '')\n    {\n        //debug_event(self::class, 'Get display tags called...', 5);\n        if (!is_array($tags)) {\n            return '';\n        }\n\n        $web_path = AmpConfig::get('web_path');\n        $results  = '';\n\n        // Iterate through the tags, format them according to type and element id\n        foreach ($tags as $value) {\n            if ($link) {\n                $results .= '<a href=\"' . $web_path . '/browse.php?action=tag&show_tag=' . $value['id'] . (!empty($filter_type) ? '&type=' . $filter_type : '') . '\" title=\"' . scrub_out($value['name']) . '\">';\n            }\n            $results .= $value['name'];\n            if ($link) {\n                $results .= '</a>';\n            }\n            $results .= ', ';\n        }\n\n        $results = rtrim((string)$results, ', ');\n\n        return $results;\n    } // get_display\n\n    /**\n     * update_tag_list\n     * Update the tags list based on a comma-separated list\n     *  (ex. tag1,tag2,tag3,..)\n     * @param string $tags_comma\n     * @param string $object_type\n     * @param integer $object_id\n     * @param boolean $overwrite\n     * @return boolean\n     */\n    public static function update_tag_list($tags_comma, $object_type, $object_id, $overwrite)\n    {\n        if (!strlen((string) $tags_comma) > 0) {\n            return self::remove_all_map($object_type, $object_id);\n        }\n        debug_event(self::class, \"update_tag_list $object_type: {{$object_id}}\", 5);\n        // tags from your file can be in a terrible format\n        $filterfolk  = str_replace('Folk, World, & Country', 'Folk World & Country', $tags_comma);\n        $filterunder = str_replace('_', ', ', $filterfolk);\n        $filter      = str_replace(';', ', ', $filterunder);\n        $filter_list = preg_split('/(\\s*,*\\s*)*,+(\\s*,*\\s*)*/', $filter);\n        $editedTags  = (is_array($filter_list)) ? array_unique($filter_list) : array();\n\n        $ctags = self::get_top_tags($object_type, $object_id, 50);\n        foreach ($ctags as $ctid => $ctv) {\n            //debug_event(self::class, 'ctag {' . $ctid . '} = ' . print_r($ctv, true), 5);\n            $found = false;\n            if ($ctv['id'] != '') {\n                $ctag  = new Tag($ctv['id']);\n                foreach ($editedTags as $tk => $tv) {\n                    //debug_event(self::class, 'from_tags {' . $tk . '} = ' . $tv, 5);\n                    if (strtolower($ctag->name) == strtolower($tv)) {\n                        $found = true;\n                        break;\n                    }\n                    // check if this thing has been renamed into something else\n                    $merged = self::construct_from_name($tv);\n                    if ($merged && $merged->is_hidden && $merged->has_merge($ctag->name)) {\n                        $found = true;\n                        break;\n                    }\n                }\n\n                if ($found) {\n                    unset($editedTags[$ctag->name]);\n                }\n                if (!$found && $overwrite && $ctv['user'] == 0) {\n                    debug_event(self::class, 'update_tag_list {' . $ctag->name . '} not found. Delete it.', 5);\n                    $ctag->remove_map($object_type, $object_id, false);\n                }\n            }\n        }\n        // Look if we need to add some new tags\n        foreach ($editedTags as $tk => $tv) {\n            if ($tv != '') {\n                self::add($object_type, $object_id, $tv, false);\n            }\n        }\n\n        return true;\n    } // update_tag_list\n\n    /**\n     * clean_to_existing\n     * Clean tag list to existing tag list only\n     * @param array|string $tags\n     * @return array|string\n     */\n    public static function clean_to_existing($tags)\n    {\n        if (is_array($tags)) {\n            $taglist = $tags;\n        } else {\n            $filterfolk  = str_replace('Folk, World, & Country', 'Folk World & Country', $tags);\n            $filterunder = str_replace('_', ', ', $filterfolk);\n            $filter      = str_replace(';', ', ', $filterunder);\n            $filter_list = preg_split('/(\\s*,*\\s*)*,+(\\s*,*\\s*)*/', $filter);\n            $taglist     = (is_array($filter_list)) ? array_unique($filter_list) : array();\n        }\n\n        $ret = array();\n        foreach ($taglist as $tag) {\n            $tag = trim((string)$tag);\n            if (!empty($tag)) {\n                if (self::tag_exists($tag)) {\n                    $ret[] = $tag;\n                }\n            }\n        }\n\n        return (is_array($tags) ? $ret : implode(\",\", $ret));\n    }\n\n    /**\n     * count\n     * This returns the count for the all objects associated with this tag\n     * If a type is specific only counts for said type are returned\n     * @param string $type\n     * @param integer $user_id\n     * @return array\n     */\n    public function count($type = '', $user_id = 0)\n    {\n        $params = array($this->id);\n\n        $filter_sql = \"\";\n        if ($user_id > 0) {\n            $filter_sql = \" AND `user` = ?\";\n            $params[]   = $user_id;\n        }\n        if ($type) {\n            $filter_sql = \" AND `object_type` = ?\";\n            $params[]   = $type;\n        }\n\n        $results = array();\n\n        $sql        = \"SELECT DISTINCT(`object_type`), COUNT(`object_id`) AS `count` FROM `tag_map` WHERE `tag_id` = ?\" . $filter_sql . \" GROUP BY `object_type`\";\n        $db_results = Dba::read($sql, $params);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['object_type']] = (int)$row['count'];\n        }\n\n        return $results;\n    } // count\n\n    /**\n     * remove_map\n     * This will only remove tag maps for the current user\n     * @param string $type\n     * @param integer $object_id\n     * @param boolean $user\n     * @return boolean\n     */\n    public function remove_map($type, $object_id, $user = true)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($type)) {\n            return false;\n        }\n\n        $uid = 0;\n        if ($user === true) {\n            $uid = (int)(Core::get_global('user')->id);\n        }\n\n        $sql = \"DELETE FROM `tag_map` WHERE `tag_id` = ? AND `object_type` = ? AND `object_id` = ? AND `user` = ?\";\n        Dba::write($sql, array($this->id, $type, $object_id, $uid));\n\n        return true;\n    } // remove_map\n\n    /**\n     * remove_all_map\n     * Clear all the tags from an object when there isn't anything there\n     * @param string $object_type\n     * @param integer $object_id\n     * @return boolean\n     */\n    public static function remove_all_map($object_type, $object_id)\n    {\n        if (!InterfaceImplementationChecker::is_library_item($object_type)) {\n            return false;\n        }\n\n        $sql = \"DELETE FROM `tag_map` WHERE `object_type` = ? AND `object_id` = ?\";\n        Dba::write($sql, array($object_type, $object_id));\n\n        return true;\n    } // remove_all_map\n\n    /**\n     * @param boolean $details\n     */\n    public function format($details = true)\n    {\n        unset($details); //dead code but called from other format calls\n    }\n\n    /**\n     * Get item keywords for metadata searches.\n     * @return array\n     */\n    public function get_keywords()\n    {\n        $keywords        = [];\n        $keywords['tag'] = [\n            'important' => true,\n            'label' => T_('Genre'),\n            'value' => $this->name\n        ];\n\n        return $keywords;\n    }\n\n    /**\n     * get_fullname\n     * @return string\n     */\n    public function get_fullname()\n    {\n        return $this->name;\n    }\n\n    /**\n     * Get item link.\n     * @return string\n     */\n    public function get_link()\n    {\n        return '';\n    }\n\n    /**\n     * Get item f_link.\n     * @return string\n     */\n    public function get_f_link()\n    {\n        return '';\n    }\n\n    /**\n     * @return null\n     */\n    public function get_parent()\n    {\n        return null;\n    }\n\n    /**\n     * @return array\n     */\n    public function get_childrens()\n    {\n        return array();\n    }\n\n    /**\n     * search_childrens\n     * @param string $name\n     * @return array\n     */\n    public function search_childrens($name)\n    {\n        debug_event(self::class, 'search_childrens ' . $name, 5);\n\n        return array();\n    }\n\n    /**\n     * get_medias\n     * @param string $filter_type\n     * @return array\n     */\n    public function get_medias($filter_type = null)\n    {\n        $medias = array();\n        if ($filter_type) {\n            $ids = self::get_tag_objects($filter_type, $this->id);\n            foreach ($ids as $object_id) {\n                $medias[] = array(\n                    'object_type' => $filter_type,\n                    'object_id' => $object_id\n                );\n            }\n        }\n\n        return $medias;\n    }\n\n    /**\n     * get_catalogs\n     *\n     * Get all catalog ids related to this item.\n     * @return integer[]\n     */\n    public function get_catalogs()\n    {\n        return array();\n    }\n\n    /**\n     * @return mixed|null\n     */\n    public function get_user_owner()\n    {\n        return null;\n    }\n\n    /**\n     * get_default_art_kind\n     * @return string\n     */\n    public function get_default_art_kind()\n    {\n        return 'default';\n    }\n\n    /**\n     * get_description\n     * @return string\n     */\n    public function get_description()\n    {\n        return '';\n    }\n\n    /**\n     * display_art\n     * @param integer $thumb\n     * @param boolean $force\n     */\n    public function display_art($thumb = 2, $force = false)\n    {\n        if (Art::has_db($this->id, 'tag') || $force) {\n            Art::display('tag', $this->id, $this->get_fullname(), $thumb);\n        }\n    }\n\n    /**\n     * Migrate an object associate stats to a new object\n     * @param string $object_type\n     * @param integer $old_object_id\n     * @param integer $new_object_id\n     * @return PDOStatement|boolean\n     */\n    public static function migrate($object_type, $old_object_id, $new_object_id)\n    {\n        $sql = \"UPDATE IGNORE `tag_map` SET `object_id` = ? WHERE `object_type` = ? AND `object_id` = ?\";\n\n        return Dba::write($sql, array($new_object_id, $object_type, $old_object_id));\n    }\n}\n", "<?php\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Repository\\Model;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\Authorization\\AccessLevelEnum;\nuse Ampache\\Module\\Statistics\\Stats;\nuse Ampache\\Module\\System\\AmpError;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\Util\\Ui;\nuse Ampache\\Repository\\IpHistoryRepositoryInterface;\nuse Ampache\\Repository\\UserRepositoryInterface;\nuse Exception;\nuse PDOStatement;\n\n/**\n * This class handles all of the user related functions including the creation\n * and deletion of the user objects from the database by default you construct it\n * with a user_id from user.id\n */\nclass User extends database_object\n{\n    protected const DB_TABLENAME = 'user';\n\n    // Basic Components\n    /**\n     * @var integer $id\n     */\n    public $id;\n    /**\n     * @var string $username\n     */\n    public $username;\n    /**\n     * @var string $fullname\n     */\n    public $fullname;\n    /**\n     * @var boolean $fullname_public\n     */\n    public $fullname_public;\n    /**\n     * @var integer $access\n     */\n    public $access;\n    /**\n     * @var boolean $disabled\n     */\n    public $disabled;\n    /**\n     * @var string $email\n     */\n    public $email;\n    /**\n     * @var integer $last_seen\n     */\n    public $last_seen;\n    /**\n     * @var integer $create_date\n     */\n    public $create_date;\n    /**\n     * @var string $validation\n     */\n    public $validation;\n    /**\n     * @var string $website\n     */\n    public $website;\n    /**\n     * @var string $state\n     */\n    public $state;\n    /**\n     * @var string $city\n     */\n    public $city;\n    /**\n     * @var string $apikey\n     */\n    public $apikey;\n    /**\n     * @var string $rsstoken\n     */\n    public $rsstoken;\n\n    // Constructed variables\n    /**\n     * @var array $prefs\n     */\n    public $prefs = array();\n\n    /**\n     * @var Tmp_Playlist $playlist\n     */\n    public $playlist;\n\n    /**\n     * @var string $f_name\n     */\n    public $f_name;\n    /**\n     * @var string $f_last_seen\n     */\n    public $f_last_seen;\n    /**\n     * @var string $f_create_date\n     */\n    public $f_create_date;\n    /**\n     * @var string $link\n     */\n    public $link;\n    /**\n     * @var string $f_link\n     */\n    public $f_link;\n    /**\n     * @var string $f_usage\n     */\n    public $f_usage;\n    /**\n     * @var string $ip_history\n     */\n    public $ip_history;\n    /**\n     * @var string $f_avatar\n     */\n    public $f_avatar;\n    /**\n     * @var string $f_avatar_mini\n     */\n    public $f_avatar_mini;\n    /**\n     * @var string $f_avatar_medium\n     */\n    public $f_avatar_medium;\n\n    /**\n     * @var int $catalog_filter_group;\n     */\n    public $catalog_filter_group;\n\n    /**\n     * Constructor\n     * This function is the constructor object for the user\n     * class, it currently takes a username\n     * @param integer $user_id\n     */\n    public function __construct($user_id = 0)\n    {\n        if (!$user_id) {\n            return false;\n        }\n\n        $this->id = (int)($user_id);\n\n        $info = $this->has_info();\n\n        foreach ($info as $key => $value) {\n            // Let's not save the password in this object :S\n            if ($key == 'password') {\n                continue;\n            }\n            $this->$key = $value;\n        }\n\n        // Make sure the Full name is always filled\n        if (strlen((string)$this->fullname) < 1) {\n            $this->fullname = $this->username;\n        }\n\n        return true;\n    } // Constructor\n\n    public function getId(): int\n    {\n        return (int)$this->id;\n    }\n\n    /**\n     * count\n     *\n     * This returns the number of user accounts that exist.\n     */\n    public static function count()\n    {\n        $sql              = 'SELECT COUNT(`id`) FROM `user`';\n        $db_results       = Dba::read($sql);\n        $row              = Dba::fetch_row($db_results);\n        $results          = array();\n        $results['users'] = $row[0] ?? 0;\n\n        $time                 = time();\n        $last_seen            = $time - 1200;\n        $sql                  = \"SELECT COUNT(DISTINCT `session`.`username`) FROM `session` INNER JOIN `user` ON `session`.`username` = `user`.`username` WHERE `session`.`expire` > ? AND `user`.`last_seen` > ?\";\n        $db_results           = Dba::read($sql, array($time, $last_seen));\n        $row                  = Dba::fetch_row($db_results);\n        $results['connected'] = $row[0] ?? 0;\n\n        return $results;\n    }\n\n    /**\n     * has_info\n     * This function returns the information for this object\n     * @return array\n     */\n    private function has_info()\n    {\n        $user_id = (int)($this->id);\n\n        if (User::is_cached('user', $user_id)) {\n            return User::get_from_cache('user', $user_id);\n        }\n\n        $data = array();\n        // If the ID is -1 then\n        if ($user_id == '-1') {\n            $data['username'] = 'System';\n            $data['fullname'] = 'Ampache User';\n            $data['access']   = '25';\n\n            return $data;\n        }\n\n        $sql        = \"SELECT * FROM `user` WHERE `id`='$user_id'\";\n        $db_results = Dba::read($sql);\n\n        $data = Dba::fetch_assoc($db_results);\n\n        User::add_to_cache('user', $user_id, $data);\n\n        return $data;\n    } // has_info\n\n    /**\n     * load_playlist\n     * This is called once per page load it makes sure that this session\n     * has a tmp_playlist, creating it if it doesn't, then sets $this->playlist\n     * as a tmp_playlist object that can be fiddled with later on\n     */\n    public function load_playlist()\n    {\n        $session_id = session_id();\n\n        $this->playlist = Tmp_Playlist::get_from_session($session_id);\n    } // load_playlist\n\n    /**\n     * get_from_username\n     * This returns a built user from a username. This is a\n     * static function so it doesn't require an instance\n     * @param string $username\n     * @return User|null $user\n     */\n    public static function get_from_username($username)\n    {\n        return static::getUserRepository()->findByUsername($username);\n    } // get_from_username\n\n    /**\n     * get_from_apikey\n     * This returns a built user from a username. This is a\n     * static function so it doesn't require an instance\n     * @param string $apikey\n     * @return User|null\n     */\n    public static function get_from_apikey($apikey)\n    {\n        return static::getUserRepository()->findByApiKey($apikey);\n    } // get_from_apikey\n\n    /**\n     * get_from_email\n     * This returns a built user from an email address. This is a\n     * static function so it doesn't require an instance\n     * @param string $emailAddress\n     * @return User|null $user\n     */\n    public static function get_from_email($emailAddress)\n    {\n        return static::getUserRepository()->findByEmail($emailAddress);\n    } // get_from_email\n\n    /**\n     * id_from_username\n     * This returns a built user from a username. This is a\n     * static function so it doesn't require an instance\n     * @param string $username\n     * @return int\n     */\n    public static function id_from_username($username)\n    {\n        return static::getUserRepository()->idByUsername($username);\n    } // id_from_username\n\n    /**\n     * id_from_email\n     * This returns a built user from an email address. This is a\n     * static function so it doesn't require an instance\n     * @param string $emailAddress\n     * @return int\n     */\n    public static function id_from_email($emailAddress)\n    {\n        return static::getUserRepository()->idByEmail($emailAddress);\n    } // id_from_email\n\n    /**\n     * get_user_catalogs\n     * This returns the catalogs as an array of ids that this user is allowed to access\n     * @return integer[]\n     */\n    public static function get_user_catalogs($userid)\n    {\n        if (parent::is_cached('user_catalog', $userid)) {\n            return parent::get_from_cache('user_catalog', $userid);\n        }\n\n        $sql        = \"SELECT `catalog_id` FROM `catalog_filter_group_map` INNER JOIN `user` ON `user`.`catalog_filter_group` = `catalog_filter_group_map`.`group_id` WHERE `user`.`id`= ? AND `catalog_filter_group_map`.`enabled` = 1 ORDER BY `catalog_filter_group_map`.`catalog_id`\";\n        $db_results = Dba::read($sql, array($userid));\n\n        $catalogs = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $catalogs[] = (int)$row['catalog_id'];\n        }\n\n        parent::add_to_cache('user_catalog', $userid, $catalogs);\n\n        return $catalogs;\n    } // get_catalogs\n\n    /**\n     * get_catalogs\n     * This returns the catalogs as an array of ids that this user is allowed to access\n     * @return integer[]\n     */\n    public function get_catalogs()\n    {\n        return self::get_user_catalogs($this->id);\n    } // get_catalogs\n\n    /**\n     * get_preferences\n     * This is a little more complicate now that we've got many types of preferences\n     * This function pulls all of them an arranges them into a spiffy little array\n     * You can specify a type to limit it to a single type of preference\n     * []['title'] = uppercase type name\n     * []['prefs'] = array(array('name', 'display', 'value'));\n     * []['admin'] = t/f value if this is an admin only section\n     * @param integer $type\n     * @param boolean $system\n     * @return array\n     */\n    public function get_preferences($type = 0, $system = false)\n    {\n        $user_limit = \"\";\n        if (!$system) {\n            $user_id    = $this->id;\n            $user_limit = \"AND preference.catagory != 'system'\";\n        } else {\n            $user_id =  -1;\n            if ($type != '0') {\n                $user_limit = \"AND preference.catagory = '\" . Dba::escape($type) . \"'\";\n            }\n        }\n\n        $sql        = \"SELECT `preference`.`name`, `preference`.`description`, `preference`.`catagory`, `preference`.`subcatagory`, preference.level, user_preference.value FROM `preference` INNER JOIN `user_preference` ON `user_preference`.`preference` = `preference`.`id` WHERE `user_preference`.`user` = ? \" . $user_limit . \" ORDER BY `preference`.`catagory`, `preference`.`subcatagory`, `preference`.`description`\";\n        $db_results = Dba::read($sql, array($user_id));\n        $results    = array();\n        $type_array = array();\n        /* Ok this is crappy, need to clean this up or improve the code FIXME */\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $type  = $row['catagory'];\n            $admin = false;\n            if ($type == 'system') {\n                $admin = true;\n            }\n            $type_array[$type][$row['name']] = array(\n                'name' => $row['name'],\n                'level' => $row['level'],\n                'description' => $row['description'],\n                'value' => $row['value'],\n                'subcategory' => $row['subcatagory']\n            );\n            $results[$type] = array(\n                'title' => ucwords((string)$type),\n                'admin' => $admin,\n                'prefs' => $type_array[$type]\n            );\n        } // end while\n\n        return $results;\n    } // get_preferences\n\n    /**\n     * set_preferences\n     * sets the prefs for this specific user\n     */\n    public function set_preferences()\n    {\n        $user_id    = Dba::escape($this->id);\n        $sql        = \"SELECT `preference`.`name`, `user_preference`.`value` FROM `preference`, `user_preference` WHERE `user_preference`.`user` = ? AND `user_preference`.`preference` = `preference`.`id` AND `preference`.`type` != 'system';\";\n        $db_results = Dba::read($sql, array($user_id));\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $key               = $row['name'];\n            $this->prefs[$key] = $row['value'];\n        }\n    } // set_preferences\n\n    /**\n     * get_favorites\n     * returns an array of your $type favorites\n     * @param string $type\n     * @return array\n     */\n    public function get_favorites($type)\n    {\n        $count   = AmpConfig::get('popular_threshold', 10);\n        $results = Stats::get_user($count, $type, $this->id, 1);\n\n        $items = array();\n\n        foreach ($results as $row) {\n            // If its a song\n            if ($type == 'song') {\n                $data        = new Song($row['object_id']);\n                $data->count = $row['count'];\n                $data->format();\n                $items[] = $data;\n            } elseif ($type == 'album') {\n                // If its an album\n                $data = new Album($row['object_id']);\n                $data->format();\n                $items[] = $data;\n            } elseif ($type == 'artist') {\n                // If its an artist\n                $data = new Artist($row['object_id']);\n                $data->format();\n                $data->f_name = $data->f_link;\n                $items[]      = $data;\n            } elseif (($type == 'genre' || $type == 'tag')) {\n                // If it's a genre\n                $data    = new Tag($row['object_id']);\n                $items[] = $data;\n            }\n        } // end foreach\n\n        return $items;\n    } // get_favorites\n\n    /**\n     * is_logged_in\n     * checks to see if $this user is logged in returns their current IP if they are logged in\n     */\n    public function is_logged_in()\n    {\n        $sql        = \"SELECT `id`, `ip` FROM `session` WHERE `username`= ? AND `expire` > ?;\";\n        $db_results = Dba::read($sql, array($this->username, time()));\n\n        if ($row = Dba::fetch_assoc($db_results)) {\n            return $row['ip'] ?? null;\n        }\n\n        return false;\n    } // is_logged_in\n\n    /**\n     * has_access\n     * this function checks to see if this user has access\n     * to the passed action (pass a level requirement)\n     * @param integer $needed_level\n     * @return boolean\n     */\n    public function has_access($needed_level)\n    {\n        if (AmpConfig::get('demo_mode')) {\n            return true;\n        }\n\n        if ($this->access >= $needed_level) {\n            return true;\n        }\n\n        return false;\n    } // has_access\n\n    /**\n     * is_registered\n     * Check if the user is registered\n     * @return boolean\n     */\n    public static function is_registered()\n    {\n        if (empty(Core::get_global('user'))) {\n            return false;\n        }\n        if (!Core::get_global('user')->id) {\n            return false;\n        }\n\n        if (!AmpConfig::get('use_auth') && Core::get_global('user')->access < 5) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * set_user_data\n     * This updates some background data for user specific function\n     * @param int $user_id\n     * @param string $key\n     * @param string|integer $value\n     */\n    public static function set_user_data(int $user_id, string $key, $value)\n    {\n        Dba::write(\"REPLACE INTO `user_data` SET `user`= ?, `key`= ?, `value`= ?;\", array($user_id, $key, $value));\n    } // set_user_data\n\n    /**\n     * get_user_data\n     * This updates some background data for user specific function\n     * @param int $user_id\n     * @param string $key\n     * @return array\n     */\n    public static function get_user_data($user_id, $key = null)\n    {\n        $sql    = \"SELECT `key`, `value` FROM `user_data` WHERE `user` = ?\";\n        $params = array($user_id);\n        if ($key) {\n            $sql .= \" AND `key` = ?\";\n            $params[] = $key;\n        }\n\n        $db_results = Dba::read($sql, $params);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[$row['key']] = $row['value'];\n        }\n\n        return $results;\n    } // get_user_data\n\n    /**\n     * update\n     * This function is an all encompassing update function that\n     * calls the mini ones does all the error checking and all that\n     * good stuff\n     * @param array $data\n     * @return boolean|int\n     */\n    public function update(array $data)\n    {\n        if (empty($data['username'])) {\n            AmpError::add('username', T_('Username is required'));\n        }\n\n        if ($data['password1'] != $data['password2'] && !empty($data['password1'])) {\n            AmpError::add('password', T_(\"Passwords do not match\"));\n        }\n\n        if (AmpError::occurred()) {\n            return false;\n        }\n\n        if (!isset($data['fullname_public'])) {\n            $data['fullname_public'] = false;\n        }\n\n        foreach ($data as $name => $value) {\n            if ($name == 'password1') {\n                $name = 'password';\n            } else {\n                $value = scrub_in($value);\n            }\n\n            switch ($name) {\n                case 'password':\n                case 'access':\n                case 'email':\n                case 'username':\n                case 'fullname':\n                case 'fullname_public':\n                case 'website':\n                case 'state':\n                case 'city':\n                case 'catalog_filter_group':\n                    if ($this->$name != $value) {\n                        $function = 'update_' . $name;\n                        $this->$function($value);\n                    }\n                    break;\n                case 'clear_stats':\n                    Stats::clear($this->id);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        return $this->id;\n    }\n\n    /**\n     * update_catalog_filter_group\n     * updates their catalog filter\n     * @param $new_filter\n     */\n    public function update_catalog_filter_group($new_filter)\n    {\n        $sql = \"UPDATE `user` SET `catalog_filter_group` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating catalog access group', 4);\n\n        Dba::write($sql, array($new_filter, $this->id));\n    } // update_catalog_filter_group\n\n    /**\n     * update_username\n     * updates their username\n     * @param $new_username\n     */\n    public function update_username($new_username)\n    {\n        $sql            = \"UPDATE `user` SET `username` = ? WHERE `id` = ?\";\n        $this->username = $new_username;\n\n        debug_event(self::class, 'Updating username', 4);\n\n        Dba::write($sql, array($new_username, $this->id));\n    } // update_username\n\n    /**\n     * update_validation\n     * This is used by the registration mumbojumbo\n     * Use this function to update the validation key\n     * NOTE: crap this doesn't have update_item the humanity of it all\n     * @param $new_validation\n     * @return PDOStatement|boolean\n     */\n    public function update_validation($new_validation)\n    {\n        $sql              = \"UPDATE `user` SET `validation` = ?, `disabled`='1' WHERE `id` = ?\";\n        $db_results       = Dba::write($sql, array($new_validation, $this->id));\n        $this->validation = $new_validation;\n\n        return $db_results;\n    } // update_validation\n\n    /**\n     * update_fullname\n     * updates their fullname\n     * @param $new_fullname\n     */\n    public function update_fullname($new_fullname)\n    {\n        $sql = \"UPDATE `user` SET `fullname` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating fullname', 4);\n\n        Dba::write($sql, array($new_fullname, $this->id));\n    } // update_fullname\n\n    /**\n     * update_fullname_public\n     * updates their fullname public\n     * @param $new_fullname_public\n     */\n    public function update_fullname_public($new_fullname_public)\n    {\n        $sql = \"UPDATE `user` SET `fullname_public` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating fullname public', 4);\n\n        Dba::write($sql, array($new_fullname_public ? '1' : '0', $this->id));\n    } // update_fullname_public\n\n    /**\n     * update_email\n     * updates their email address\n     * @param string $new_email\n     */\n    public function update_email($new_email)\n    {\n        $sql = \"UPDATE `user` SET `email` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating email', 4);\n\n        Dba::write($sql, array($new_email, $this->id));\n    } // update_email\n\n    /**\n     * update_website\n     * updates their website address\n     * @param $new_website\n     */\n    public function update_website($new_website)\n    {\n        $new_website = rtrim((string)$new_website, \"/\");\n        $sql         = \"UPDATE `user` SET `website` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating website', 4);\n\n        Dba::write($sql, array($new_website, $this->id));\n    } // update_website\n\n    /**\n     * update_state\n     * updates their state\n     * @param $new_state\n     */\n    public function update_state($new_state)\n    {\n        $sql = \"UPDATE `user` SET `state` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating state', 4);\n\n        Dba::write($sql, array($new_state, $this->id));\n    } // update_state\n\n    /**\n     * update_city\n     * updates their city\n     * @param $new_city\n     */\n    public function update_city($new_city)\n    {\n        $sql = \"UPDATE `user` SET `city` = ? WHERE `id` = ?\";\n\n        debug_event(self::class, 'Updating city', 4);\n\n        Dba::write($sql, array($new_city, $this->id));\n    } // update_city\n\n    /**\n     * update_counts for individual users\n     */\n    public static function update_counts()\n    {\n        $catalog_disable = AmpConfig::get('catalog_disable');\n        $catalog_filter  = AmpConfig::get('catalog_filter');\n        $sql             = \"SELECT `id` FROM `user`\";\n        $db_results      = Dba::read($sql);\n        $user_list       = array();\n        while ($results  = Dba::fetch_assoc($db_results)) {\n            $user_list[] = (int)$results['id'];\n        }\n        if (!$catalog_filter) {\n            // no filter means no need for filtering or counting per user\n            $count_array   = array('song', 'video', 'podcast_episode', 'artist', 'album', 'search', 'playlist', 'live_stream', 'podcast', 'user', 'catalog', 'label', 'tag', 'share', 'license', 'album_group', 'items', 'time', 'size');\n            $server_counts = Catalog::get_server_counts(0);\n            foreach ($user_list as $user_id) {\n                debug_event(self::class, 'Update counts for ' . $user_id, 5);\n                foreach ($server_counts as $table => $count) {\n                    if (in_array($table, $count_array)) {\n                        self::set_user_data($user_id, $table, $count);\n                    }\n                }\n            }\n\n            return;\n        }\n\n        $count_array = array('song', 'video', 'podcast_episode', 'artist', 'album', 'search', 'playlist', 'live_stream', 'podcast', 'user', 'catalog', 'label', 'tag', 'share', 'license');\n        foreach ($user_list as $user_id) {\n            debug_event(self::class, 'Update counts for ' . $user_id, 5);\n            // get counts per user (filtered catalogs aren't counted)\n            foreach ($count_array as $table) {\n                $sql        = (in_array($table, array('search', 'user', 'license')))\n                    ? \"SELECT COUNT(`id`) FROM `$table`\"\n                    : \"SELECT COUNT(`id`) FROM `$table` WHERE\" . Catalog::get_user_filter($table, $user_id);\n                $db_results = Dba::read($sql);\n                $row        = Dba::fetch_row($db_results);\n\n                self::set_user_data($user_id, $table, (int)($row[0] ?? 0));\n            }\n            // tables with media items to count, song-related tables and the rest\n            $media_tables = array('song', 'video', 'podcast_episode');\n            $items        = 0;\n            $time         = 0;\n            $size         = 0;\n            foreach ($media_tables as $table) {\n                $enabled_sql = ($catalog_disable && $table !== 'podcast_episode')\n                    ? \" WHERE `$table`.`enabled`='1' AND\"\n                    : ' WHERE';\n                $sql        = \"SELECT COUNT(`id`), IFNULL(SUM(`time`), 0), IFNULL(SUM(`size`), 0) FROM `$table`\" . $enabled_sql . Catalog::get_user_filter($table, $user_id);\n                $db_results = Dba::read($sql);\n                $row        = Dba::fetch_row($db_results);\n                // save the object and add to the current size\n                $items += (int)($row[0] ?? 0);\n                $time += (int)($row[1] ?? 0);\n                $size += (int)($row[2] ?? 0);\n                self::set_user_data($user_id, $table, (int)($row[0] ?? 0));\n            }\n            self::set_user_data($user_id, 'items', $items);\n            self::set_user_data($user_id, 'time', $time);\n            self::set_user_data($user_id, 'size', $size);\n            // grouped album counts\n            $sql        = \"SELECT COUNT(DISTINCT(`album`.`id`)) AS `count` FROM `album` WHERE `id` in (SELECT MIN(`id`) FROM `album` GROUP BY `album`.`prefix`, `album`.`name`, `album`.`album_artist`, `album`.`release_type`, `album`.`release_status`, `album`.`mbid`, `album`.`year`, `album`.`original_year`, `album`.`mbid_group`) AND\" . Catalog::get_user_filter('album', $user_id);\n            $db_results = Dba::read($sql);\n            $row        = Dba::fetch_row($db_results);\n            self::set_user_data($user_id, 'album_group', (int)($row[0] ?? 0));\n        }\n    } // update_counts\n\n    /**\n     * disable\n     * This disables the current user\n     */\n    public function disable()\n    {\n        // Make sure we aren't disabling the last admin\n        $sql        = \"SELECT `id` FROM `user` WHERE `disabled` = '0' AND `id` != '\" . $this->id . \"' AND `access`='100'\";\n        $db_results = Dba::read($sql);\n\n        if (!Dba::num_rows($db_results)) {\n            return false;\n        }\n\n        $sql = \"UPDATE `user` SET `disabled`='1' WHERE id='\" . $this->id . \"'\";\n        Dba::write($sql);\n\n        // Delete any sessions they may have\n        $sql = \"DELETE FROM `session` WHERE `username`='\" . Dba::escape($this->username) . \"'\";\n        Dba::write($sql);\n\n        return true;\n    } // disable\n\n    /**\n     * update_access\n     * updates their access level\n     * @param $new_access\n     * @return boolean\n     */\n    public function update_access($new_access)\n    {\n        /* Prevent Only User accounts */\n        if ($new_access < '100') {\n            $sql        = \"SELECT `id` FROM `user` WHERE `access`='100' AND `id` != '$this->id'\";\n            $db_results = Dba::read($sql);\n            if (!Dba::num_rows($db_results)) {\n                return false;\n            }\n        }\n\n        $new_access = Dba::escape($new_access);\n        $sql        = \"UPDATE `user` SET `access` = ? WHERE `id` = ?;\";\n\n        debug_event(self::class, 'Updating access level for ' . $this->id, 4);\n\n        Dba::write($sql, array($new_access, $this->id));\n\n        return true;\n    } // update_access\n\n    /**\n     * save_mediaplay\n     * @param User $user\n     * @param Song $media\n     */\n    public static function save_mediaplay($user, $media)\n    {\n        foreach (Plugin::get_plugins('save_mediaplay') as $plugin_name) {\n            try {\n                $plugin = new Plugin($plugin_name);\n                if ($plugin->load($user)) {\n                    debug_event(self::class, 'save_mediaplay... ' . $plugin->_plugin->name, 5);\n                    $plugin->_plugin->save_mediaplay($media);\n                }\n            } catch (Exception $error) {\n                debug_event(self::class, 'save_mediaplay plugin error: ' . $error->getMessage(), 1);\n            }\n        }\n    }\n\n    /**\n     * insert_ip_history\n     * This inserts a row into the IP History recording this user at this\n     * address at this time in this place, doing this thing.. you get the point\n     */\n    public function insert_ip_history()\n    {\n        $sip = (isset($_SERVER['HTTP_X_FORWARDED_FOR']))\n            ? filter_var($_SERVER['HTTP_X_FORWARDED_FOR'], FILTER_VALIDATE_IP)\n            : filter_var($_SERVER['REMOTE_ADDR'], FILTER_VALIDATE_IP);\n        debug_event(self::class, 'Login from IP address: ' . (string) $sip, 3);\n\n        // Remove port information if any\n        if (!empty($sip)) {\n            // Use parse_url to support easily ipv6\n            if (filter_var($sip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) === true) {\n                $sipar = parse_url(\"http://\" . $sip);\n            } else {\n                $sipar = parse_url(\"http://[\" . $sip . \"]\");\n            }\n            $sip = $sipar['host'];\n        }\n\n        $uip     = (!empty($sip)) ? Dba::escape(inet_pton(trim((string)$sip, \"[]\"))) : '';\n        $date    = time();\n        $user_id = (int)$this->id;\n        $agent   = Dba::escape(Core::get_server('HTTP_USER_AGENT'));\n\n        $sql = \"INSERT INTO `ip_history` (`ip`, `user`, `date`, `agent`) VALUES ('$uip', '$user_id', '$date', '$agent')\";\n        Dba::write($sql);\n\n        /* Clean up old records... sometimes  */\n        if (rand(1, 100) > 60) {\n            $date = time() - (86400 * AmpConfig::get('user_ip_cardinality'));\n            $sql  = \"DELETE FROM `ip_history` WHERE `date` < $date\";\n            Dba::write($sql);\n        }\n\n        return true;\n    } // insert_ip_history\n\n    /**\n     * create\n     * inserts a new user into Ampache\n     * @param string $username\n     * @param string $fullname\n     * @param string $email\n     * @param string $website\n     * @param string $password\n     * @param integer $access\n     * @param string $state\n     * @param string $city\n     * @param boolean $disabled\n     * @param boolean $encrypted\n     * @return integer\n     */\n    public static function create(\n        $username,\n        $fullname,\n        $email,\n        $website,\n        $password,\n        $access,\n        $catalog_filter_group = 0,\n        $state = '',\n        $city = '',\n        $disabled = false,\n        $encrypted = false\n    ) {\n        // don't try to overwrite users that already exist\n        if (static::getUserRepository()->idByUsername($username) > 0 || static::getUserRepository()->idByEmail($email) > 0) {\n            return 0;\n        }\n        $website = rtrim((string)$website, \"/\");\n        if (!$encrypted) {\n            $password = hash('sha256', $password);\n        }\n        $disabled = $disabled ? 1 : 0;\n\n        // Just in case a zero value slipped in from upper layers...\n        $catalog_filter_group = $catalog_filter_group ?? 0;\n\n        /* Now Insert this new user */\n        $sql    = \"INSERT INTO `user` (`username`, `disabled`, `fullname`, `email`, `password`, `access`, `catalog_filter_group`, `create_date`\";\n        $params = array($username, $disabled, $fullname, $email, $password, $access, $catalog_filter_group, time());\n\n        if (!empty($website)) {\n            $sql .= \", `website`\";\n            $params[] = $website;\n        }\n        if (!empty($state)) {\n            $sql .= \", `state`\";\n            $params[] = $state;\n        }\n        if (!empty($city)) {\n            $sql .= \", `city`\";\n            $params[] = $city;\n        }\n\n        $sql .= \") VALUES(?, ?, ?, ?, ?, ?, ?, ?\";\n\n        if (!empty($website)) {\n            $sql .= \", ?\";\n        }\n        if (!empty($state)) {\n            $sql .= \", ?\";\n        }\n        if (!empty($city)) {\n            $sql .= \", ?\";\n        }\n\n        $sql .= \")\";\n        $db_results = Dba::write($sql, $params);\n\n        if (!$db_results) {\n            return 0;\n        }\n        // Get the insert_id\n        $insert_id = (int)Dba::insert_id();\n\n        // Populates any missing preferences, in this case all of them\n        self::fix_preferences($insert_id);\n\n        Catalog::count_table('user');\n\n        return (int)$insert_id;\n    } // create\n\n    /**\n     * update_password\n     * updates a users password\n     * @param string $new_password\n     * @param string $hashed_password\n     */\n    public function update_password($new_password, $hashed_password = null)\n    {\n        debug_event(self::class, 'Updating password', 1);\n        if (!$hashed_password) {\n            $hashed_password = hash('sha256', $new_password);\n        }\n\n        $escaped_password = Dba::escape($hashed_password);\n        $sql              = \"UPDATE `user` SET `password` = ? WHERE `id` = ?\";\n        $db_results       = Dba::write($sql, array($escaped_password, $this->id));\n\n        // Clear this (temp fix)\n        if ($db_results) {\n            unset($_SESSION['userdata']['password']);\n        }\n    } // update_password\n\n    /**\n     * format\n     * This function sets up the extra variables we need when we are displaying a\n     * user for an admin, these should not be normally called when creating a\n     * user object\n     * @param boolean $details\n     */\n    public function format($details = true)\n    {\n        if (!$this->id) {\n            return;\n        }\n        /* If they have a last seen date */\n        if (!$this->last_seen) {\n            $this->f_last_seen = T_('Never');\n        } else {\n            $this->f_last_seen = get_datetime((int)$this->last_seen);\n        }\n\n        /* If they have a create date */\n        if (!$this->create_date) {\n            $this->f_create_date = T_('Unknown');\n        } else {\n            $this->f_create_date = get_datetime((int)$this->create_date);\n        }\n\n        // Base link\n        $this->f_link = '<a href=\"' . $this->get_link() . '\">' . scrub_out($this->get_fullname()) . '</a>';\n\n        if ($details) {\n            $user_data = self::get_user_data($this->id);\n            if (!isset($user_data['play_size'])) {\n                // Calculate their total Bandwidth Usage\n                $sql        = \"SELECT SUM(`song`.`size`) AS `play_size` FROM `object_count` LEFT JOIN `song` ON `song`.`id`=`object_count`.`object_id` WHERE `object_count`.`user` = ? AND `object_count`.`object_type` IN ('song', 'video', 'podcast_episode') GROUP BY `user`;\";\n                $db_results = Dba::read($sql, array($this->id));\n                $result     = Dba::fetch_assoc($db_results);\n                $play_size  = $result['play_size'] ?? 0;\n                // set the value for next time\n                self::set_user_data($this->id, 'play_size', (int)$play_size);\n                $user_data['play_size'] = $play_size;\n            }\n\n            $this->f_usage = Ui::format_bytes((int)$user_data['play_size']);\n\n            // Get Users Last ip\n            if (count($data = $this->getIpHistoryRepository()->getHistory($this->getId()))) {\n                $user_ip          = inet_ntop($data['0']['ip']);\n                $this->ip_history = (!empty($user_ip) && filter_var($user_ip, FILTER_VALIDATE_IP)) ? $user_ip : T_('Invalid');\n            } else {\n                $this->ip_history = T_('Not Enough Data');\n            }\n        }\n\n        $avatar = $this->get_avatar();\n        if (!empty($avatar['url'])) {\n            $this->f_avatar = '<img src=\"' . $avatar['url'] . '\" title=\"' . $avatar['title'] . '\"' . ' width=\"256px\" height=\"auto\" />';\n        }\n        if (!empty($avatar['url_mini'])) {\n            $this->f_avatar_mini = '<img src=\"' . $avatar['url_mini'] . '\" title=\"' . $avatar['title'] . '\" style=\"width: 32px; height: 32px;\" />';\n        }\n        if (!empty($avatar['url_medium'])) {\n            $this->f_avatar_medium = '<img src=\"' . $avatar['url_medium'] . '\" title=\"' . $avatar['title'] . '\" style=\"width: 64px; height: 64px;\" />';\n        }\n    } // format_user\n\n    /**\n     * access_name_to_level\n     * This takes the access name for the user and returns the level\n     * @param string $name\n     * @return integer\n     */\n    public static function access_name_to_level($name)\n    {\n        switch ($name) {\n            case 'admin':\n                return AccessLevelEnum::LEVEL_ADMIN;\n            case 'user':\n                return AccessLevelEnum::LEVEL_USER;\n            case 'manager':\n                return AccessLevelEnum::LEVEL_MANAGER;\n            // FIXME why is content manager not here?\n            //case 'manager':\n                //return AccessLevelEnum::LEVEL_CONTENT_MANAGER;\n            case 'guest':\n                return AccessLevelEnum::LEVEL_GUEST;\n            default:\n                return AccessLevelEnum::LEVEL_DEFAULT;\n        }\n    } // access_name_to_level\n\n    /**\n     * access_level_to_name\n     * This takes the access level for the user and returns the translated name for that level\n     * @param string $level\n     * @return string\n     */\n    public static function access_level_to_name($level)\n    {\n        switch ($level) {\n            case '100':\n                return T_('Admin');\n            case '75':\n                return T_('Catalog Manager');\n            case '50':\n                return T_('Content Manager');\n            case '25':\n                return T_('User');\n            case '5':\n                return T_('Guest');\n            default:\n                return T_('Unknown');\n        }\n    } // access_level_to_name\n\n    /**\n     * fix_preferences\n     * This is the new fix_preferences function, it does the following\n     * Remove Duplicates from user, add in missing\n     * If -1 is passed it also removes duplicates from the `preferences`\n     * table.\n     * @param integer $user_id\n     */\n    public static function fix_preferences($user_id)\n    {\n        // Check default group (autoincrement starts at 1 so force it to be 0)\n        $sql        = \"SELECT `id`, `name` FROM `catalog_filter_group` WHERE `name` = 'DEFAULT';\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_assoc($db_results);\n        if (!array_key_exists('id', $row) || ($row['id'] ?? '') != 0) {\n            debug_event(self::class, 'fix_preferences restore DEFAULT catalog_filter_group', 2);\n            // reinsert missing default group\n            $sql = \"INSERT IGNORE INTO `catalog_filter_group` (`name`) VALUES ('DEFAULT');\";\n            Dba::write($sql);\n            $sql = \"UPDATE `catalog_filter_group` SET `id` = 0 WHERE `name` = 'DEFAULT';\";\n            Dba::write($sql);\n            $sql        = \"SELECT MAX(`id`) AS `filter_count` FROM `catalog_filter_group`;\";\n            $db_results = Dba::read($sql);\n            $row        = Dba::fetch_assoc($db_results);\n            $increment  = (int)($row['filter_count'] ?? 0) + 1;\n            $sql        = \"ALTER TABLE `catalog_filter_group` AUTO_INCREMENT = $increment;\";\n            Dba::write($sql);\n        }\n\n        /* Get All Preferences for the current user */\n        $sql          = \"SELECT * FROM `user_preference` WHERE `user` = ?\";\n        $db_results   = Dba::read($sql, array($user_id));\n        $results      = array();\n        $zero_results = array();\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $pref_id = $row['preference'];\n            // Check for duplicates\n            if (isset($results[$pref_id])) {\n                $sql = \"DELETE FROM `user_preference` WHERE `user` = ? AND `preference`= ? AND `value` = ?;\";\n                Dba::write($sql, array($user_id, $row['preference'], $row['value']));\n            } else {\n                // if its set\n                $results[$pref_id] = 1;\n            }\n        } // end while\n\n        // If your user is missing preferences we copy the value from system (Except for plugins and system prefs)\n        if ($user_id != '-1') {\n            $sql        = \"SELECT `user_preference`.`preference`, `user_preference`.`value` FROM `user_preference`, `preference` WHERE `user_preference`.`preference` = `preference`.`id` AND `user_preference`.`user`='-1' AND `preference`.`catagory` NOT IN ('plugins', 'system');\";\n            $db_results = Dba::read($sql);\n            /* While through our base stuff */\n            while ($row = Dba::fetch_assoc($db_results)) {\n                $key                = $row['preference'];\n                $zero_results[$key] = $row['value'];\n            }\n        } // if not user -1\n\n        // get me _EVERYTHING_\n        $sql = \"SELECT * FROM `preference`\";\n\n        // If not system, exclude system... *gasp*\n        if ($user_id != '-1') {\n            $sql .= \" WHERE catagory !='system';\";\n        }\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $key = $row['id'];\n\n            // Check if this preference is set\n            if (!isset($results[$key])) {\n                if (isset($zero_results[$key])) {\n                    $row['value'] = $zero_results[$key];\n                }\n                $sql   = \"INSERT INTO user_preference (`user`, `preference`, `value`) VALUES (?, ?, ?)\";\n                Dba::write($sql, array($user_id, $key, $row['value']));\n            }\n        } // while preferences\n    } // fix_preferences\n\n    /**\n     * delete\n     * deletes this user and everything associated with it. This will affect\n     * ratings and total stats\n     * @return boolean\n     */\n    public function delete()\n    {\n        // Before we do anything make sure that they aren't the last admin\n        if ($this->has_access(100)) {\n            $sql        = \"SELECT `id` FROM `user` WHERE `access`='100' AND id != ?\";\n            $db_results = Dba::read($sql, array($this->id));\n            if (!Dba::num_rows($db_results)) {\n                return false;\n            }\n        } // if this is an admin check for others\n\n        // Delete the user itself\n        $sql = \"DELETE FROM `user` WHERE `id` = ?\";\n        Dba::write($sql, array($this->id));\n\n        // Delete custom access settings\n        $sql = \"DELETE FROM `access_list` WHERE `user` = ?\";\n        Dba::write($sql, array($this->id));\n\n        $sql = \"DELETE FROM `session` WHERE `username` = ?\";\n        Dba::write($sql, array($this->username));\n\n        Catalog::count_table('user');\n        static::getUserRepository()->collectGarbage();\n\n        return true;\n    } // delete\n\n    /**\n     * is_online\n     * delay how long since last_seen in seconds default of 20 min\n     * calculates difference between now and last_seen\n     * if less than delay, we consider them still online\n     * @param integer $delay\n     * @return boolean\n     */\n    public function is_online($delay = 1200)\n    {\n        return time() - $this->last_seen <= $delay;\n    } // is_online\n\n    /**\n     * get_recently_played\n     * This gets the recently played items for this user respecting\n     * the limit passed. ger recent by default or oldest if $newest is false.\n     * @param string $type\n     * @param integer $count\n     * @param integer $offset\n     * @param boolean $newest\n     * @return array\n     */\n    public function get_recently_played($type, $count, $offset = 0, $newest = true)\n    {\n        $ordersql = ($newest === true) ? 'DESC' : 'ASC';\n        $limit    = ($offset < 1) ? $count : $offset . \",\" . $count;\n\n        $sql        = \"SELECT `object_id`, MAX(`date`) AS `date` FROM `object_count` WHERE `object_type` = ? AND `user` = ? GROUP BY `object_id` ORDER BY `date` \" . $ordersql . \" LIMIT \" . $limit . \" \";\n        $db_results = Dba::read($sql, array($type, $this->id));\n\n        $results = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row['object_id'];\n        }\n\n        return $results;\n    } // get_recently_played\n\n    /**\n     * Get item fullname.\n     * @return string\n     */\n    public function get_fullname()\n    {\n        if (!isset($this->f_name)) {\n            $this->f_name = ($this->fullname_public)\n                ? $this->fullname\n                : $this->username;\n        }\n\n        return $this->f_name;\n    }\n\n    /**\n     * Get item link.\n     * @return string\n     */\n    public function get_link()\n    {\n        // don't do anything if it's formatted\n        if (!isset($this->link)) {\n            $web_path   = AmpConfig::get('web_path');\n            $this->link = $web_path . '/stats.php?action=show_user&user_id=' . $this->id;\n        }\n\n        return $this->link;\n    }\n\n    /**\n     * Get item name based on whether they allow public fullname access.\n     * @param int $user_id\n     * @return string\n     */\n    public static function get_username($user_id)\n    {\n        $users = static::getUserRepository()->getValidArray(true);\n\n        return (isset($users[$user_id]))\n            ? $users[$user_id]\n            : T_('System');\n    }\n\n    /**\n     * get_avatar\n     * Get the user avatar\n     * @param boolean $local\n     * @param array $session\n     * @return array\n     */\n    public function get_avatar($local = false, $session = array())\n    {\n        $avatar = array();\n        $auth   = '';\n        if (array_key_exists('t', $session) && $session['s']) {\n            $auth = '&t=' . $session['t'] . '&s=' . $session['s'];\n        } elseif (array_key_exists('auth', $session)) {\n            $auth = '&auth=' . $session['auth'];\n        }\n        $avatar['title'] = T_('User avatar');\n        $upavatar        = new Art($this->id, 'user');\n        if ($upavatar->has_db_info()) {\n            $avatar['url']        = ($local ? AmpConfig::get('local_web_path') : AmpConfig::get('web_path')) . '/image.php?object_type=user&object_id=' . $this->id . $auth;\n            $avatar['url_mini']   = $avatar['url'];\n            $avatar['url_medium'] = $avatar['url'];\n            $avatar['url'] .= '&thumb=4';\n            $avatar['url_mini'] .= '&thumb=5';\n            $avatar['url_medium'] .= '&thumb=3';\n        } else {\n            foreach (Plugin::get_plugins('get_avatar_url') as $plugin_name) {\n                $plugin = new Plugin($plugin_name);\n                if ($plugin->load(Core::get_global('user'))) {\n                    $avatar['url'] = $plugin->_plugin->get_avatar_url($this);\n                    if (!empty($avatar['url'])) {\n                        $avatar['url_mini']   = $plugin->_plugin->get_avatar_url($this, 32);\n                        $avatar['url_medium'] = $plugin->_plugin->get_avatar_url($this, 64);\n                        $avatar['title'] .= ' (' . $plugin->_plugin->name . ')';\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (!array_key_exists('url', $avatar)) {\n            $avatar['url']        = ($local ? AmpConfig::get('local_web_path') : AmpConfig::get('web_path')) . '/images/blankuser.png';\n            $avatar['url_mini']   = $avatar['url'];\n            $avatar['url_medium'] = $avatar['url'];\n        }\n\n        return $avatar;\n    } // get_avatar\n\n    /**\n     * @param string $data\n     * @param string $mime\n     * @return boolean\n     */\n    public function update_avatar($data, $mime = '')\n    {\n        debug_event(self::class, 'Updating avatar for ' . $this->id, 4);\n\n        $art = new Art($this->id, 'user');\n\n        return $art->insert($data, $mime);\n    }\n\n    /**\n     *\n     * @return boolean\n     */\n    public function upload_avatar()\n    {\n        $upload = array();\n        if (!empty($_FILES['avatar']['tmp_name']) && $_FILES['avatar']['size'] <= AmpConfig::get('max_upload_size')) {\n            $path_info      = pathinfo($_FILES['avatar']['name']);\n            $upload['file'] = $_FILES['avatar']['tmp_name'];\n            $upload['mime'] = 'image/' . $path_info['extension'];\n            if (!in_array(strtolower($path_info['extension']), Art::VALID_TYPES)) {\n                return false;\n            }\n\n            $image_data = Art::get_from_source($upload, 'user');\n            if ($image_data !== '') {\n                return $this->update_avatar($image_data, $upload['mime']);\n            }\n        }\n\n        return true; // only worry about failed uploads\n    }\n\n    public function delete_avatar()\n    {\n        $art = new Art($this->id, 'user');\n        $art->reset();\n    }\n\n    /**\n     * rebuild_all_preferences\n     * This rebuilds the user preferences for all installed users, called by the plugin functions\n     */\n    public static function rebuild_all_preferences()\n    {\n        // Garbage collection\n        $sql = \"DELETE `user_preference`.* FROM `user_preference` LEFT JOIN `user` ON `user_preference`.`user` = `user`.`id` WHERE `user_preference`.`user` != -1 AND `user`.`id` IS NULL;\";\n        Dba::write($sql);\n        // delete system prefs from users\n        $sql = \"DELETE `user_preference`.* FROM `user_preference` LEFT JOIN `preference` ON `user_preference`.`preference` = `preference`.`id` WHERE `user_preference`.`user` != -1 AND `preference`.`catagory` = 'system';\";\n        Dba::write($sql);\n\n        // How many preferences should we have?\n        $sql        = \"SELECT COUNT(`id`) AS `pref_count` FROM `preference` WHERE `catagory` != 'system';\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_assoc($db_results);\n        $pref_count = (int)$row['pref_count'];\n        // Get only users who have less preferences than excepted otherwise it would have significant performance issue with large user database\n        $sql        = \"SELECT `user` FROM `user_preference` GROUP BY `user` HAVING COUNT(*) < $pref_count\";\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            self::fix_preferences($row['user']);\n        }\n        // Fix the system user preferences\n        self::fix_preferences(-1);\n\n        return true;\n    } // rebuild_all_preferences\n\n    /**\n     * stream_control\n     * Check all stream control plugins\n     * @param array $media_ids\n     * @param User|null $user\n     * @return boolean\n     */\n    public static function stream_control($media_ids, User $user = null)\n    {\n        if ($user === null) {\n            $user = Core::get_global('user');\n        }\n\n        foreach (Plugin::get_plugins('stream_control') as $plugin_name) {\n            $plugin = new Plugin($plugin_name);\n            if ($plugin->load($user)) {\n                if (!$plugin->_plugin->stream_control($media_ids)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @deprecated inject dependency\n     */\n    private function getIpHistoryRepository(): IpHistoryRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(IpHistoryRepositoryInterface::class);\n    }\n\n    /**\n     * @deprecated inject dependency\n     */\n    private static function getUserRepository(): UserRepositoryInterface\n    {\n        global $dic;\n\n        return $dic->get(UserRepositoryInterface::class);\n    }\n}\n"], "filenames": ["docs/CHANGELOG.md", "public/templates/show_artist_info.inc.php", "resources/sql/ampache.sql", "src/Module/Art/Collector/FolderCollectorModule.php", "src/Module/Playback/Localplay/Mpd/AmpacheMpd.php", "src/Module/Playback/Localplay/Upnp/UPnPDevice.php", "src/Module/Playback/Localplay/Vlc/VlcPlayer.php", "src/Module/Playback/Stream_Playlist.php", "src/Module/System/Update.php", "src/Repository/Model/Art.php", "src/Repository/Model/Catalog.php", "src/Repository/Model/TVShow_Season.php", "src/Repository/Model/Tag.php", "src/Repository/Model/User.php"], "buggy_code_start_loc": [20, 51, 21, 88, 376, 37, 294, 763, 2371, 51, 3823, 118, 556, 357], "buggy_code_end_loc": [20, 53, 38, 158, 377, 38, 295, 764, 2373, 1502, 3823, 119, 557, 1445], "fixing_code_start_loc": [21, 51, 21, 87, 375, 36, 293, 762, 2370, 52, 3824, 118, 556, 356], "fixing_code_end_loc": [23, 53, 38, 148, 375, 36, 293, 762, 2370, 1518, 3825, 119, 557, 1446], "type": "CWE-434", "message": "Unrestricted Upload of File with Dangerous Type in GitHub repository ampache/ampache prior to 5.5.6.", "other": {"cve": {"id": "CVE-2022-4665", "sourceIdentifier": "security@huntr.dev", "published": "2022-12-23T01:15:10.013", "lastModified": "2022-12-30T21:57:00.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unrestricted Upload of File with Dangerous Type in GitHub repository ampache/ampache prior to 5.5.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ampache:ampache:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.5.6", "matchCriteriaId": "8006783E-D0AF-457B-8E93-5E0F48A65512"}]}]}], "references": [{"url": "https://github.com/ampache/ampache/commit/8293fa86e5f50a168b7f5c892ffbd6aa555134bd", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/5e7f3ecc-3b08-4e0e-8bf8-ae7ae229941f", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ampache/ampache/commit/8293fa86e5f50a168b7f5c892ffbd6aa555134bd"}}