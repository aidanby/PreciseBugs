{"buggy_code": ["/*\n * Copyright (c) 2007-2021, Arshan Dabirsiaghi, Jason Li\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n * Neither the name of OWASP nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.owasp.validator.html.scan;\n\nimport org.apache.batik.css.parser.ParseException;\nimport org.apache.xerces.dom.DocumentImpl;\nimport net.sourceforge.htmlunit.cyberneko.parsers.DOMFragmentParser;\nimport org.owasp.validator.css.CssScanner;\nimport org.owasp.validator.html.CleanResults;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.PolicyException;\nimport org.owasp.validator.html.ScanException;\nimport org.owasp.validator.html.model.Attribute;\nimport org.owasp.validator.html.model.Tag;\nimport org.owasp.validator.html.util.ErrorMessageUtil;\nimport org.owasp.validator.html.util.HTMLEntityEncoder;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.DocumentFragment;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\nimport org.w3c.dom.Text;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This is where the magic lives. All the scanning/filtration logic resides\n * here, but it should not be called directly. All scanning should be done\n * through an <code>AntiSamy.scan()</code> method.\n * \n * @author Arshan Dabirsiaghi\n */\npublic class AntiSamyDOMScanner extends AbstractAntiSamyScanner {\n    private Document document = new DocumentImpl();\n    private DocumentFragment dom = document.createDocumentFragment();\n    private CleanResults results = null;\n    private static final int maxDepth = 250;\n    private static final Pattern invalidXmlCharacters =\n            Pattern.compile(\"[\\\\u0000-\\\\u001F\\\\uD800-\\\\uDFFF\\\\uFFFE-\\\\uFFFF&&[^\\\\u0009\\\\u000A\\\\u000D]]\");\n    private static final Pattern conditionalDirectives = Pattern.compile(\"<?!?\\\\[\\\\s*(?:end)?if[^]]*\\\\]>?\");\n\n    private static final Queue<CachedItem> cachedItems = new ConcurrentLinkedQueue<CachedItem>();\n\n    static class CachedItem {\n        private final DOMFragmentParser parser;\n        private final Matcher invalidXmlCharMatcher = invalidXmlCharacters.matcher(\"\");\n\n\n        CachedItem() throws SAXNotSupportedException, SAXNotRecognizedException {\n            this.parser = getDomParser();\n        }\n\n        DOMFragmentParser getDomFragmentParser()  {\n            return parser;\n        }\n    }\n\n    public AntiSamyDOMScanner(Policy policy) {\n        super(policy);\n    }\n\n    /* UnusedDeclaration TODO Investigate */\n    public AntiSamyDOMScanner() throws PolicyException {\n        super();\n    }\n\n    /**\n     * This is where the magic lives.\n     *\n     * @param html A String whose contents we want to scan.\n     * @return A <code>CleanResults</code> object with an\n     *         <code>XMLDocumentFragment</code> object and its String\n     *         representation, as well as some scan statistics.\n     * @throws ScanException When there is a problem encountered\n\t *         while scanning the HTML.\n\t */\n    @Override\n    public CleanResults scan(String html) throws ScanException {\n\n        if (html == null) {\n            throw new ScanException(new NullPointerException(\"Null html input\"));\n        }\n\n        errorMessages.clear();\n        int maxInputSize = policy.getMaxInputSize();\n\n        if (maxInputSize < html.length()) {\n            addError(ErrorMessageUtil.ERROR_INPUT_SIZE, new Object[]{html.length(), maxInputSize});\n            throw new ScanException(errorMessages.get(0));\n        }\n\n        isNofollowAnchors = policy.isNofollowAnchors();\n        isNoopenerAndNoreferrerAnchors = policy.isNoopenerAndNoreferrerAnchors();\n        isValidateParamAsEmbed = policy.isValidateParamAsEmbed();\n\n        long startOfScan = System.currentTimeMillis();\n\n        try {\n\n            CachedItem cachedItem;\n            cachedItem = cachedItems.poll();\n            if (cachedItem == null){\n                cachedItem = new CachedItem();\n            }\n\n            /*\n             * We have to replace any invalid XML characters to prevent NekoHTML\n             * from breaking when it gets passed encodings like %21.\n             */\n\n            html = stripNonValidXMLCharacters(html, cachedItem.invalidXmlCharMatcher);\n\n            /*\n             * First thing we do is call the HTML cleaner (\"NekoHTML\") on it\n             * with the appropriate options. We choose not to omit tags due to\n             * the fallibility of our own listing in the ever changing world of\n             * W3C.\n             */\n\n            DOMFragmentParser parser = cachedItem.getDomFragmentParser();\n\n            try {\n                parser.parse(new InputSource(new StringReader(html)), dom);\n            } catch (Exception e) {\n                throw new ScanException(e);\n            }\n\n            processChildren(dom, 0);\n\n            /*\n             * Serialize the output and then return the resulting DOM object and\n             * its string representation.\n             */\n\n            final String trimmedHtml = html;\n\n            StringWriter out = new StringWriter();\n\n            @SuppressWarnings(\"deprecation\")\n            org.apache.xml.serialize.OutputFormat format = getOutputFormat();\n\n            //noinspection deprecation\n            org.apache.xml.serialize.HTMLSerializer serializer = getHTMLSerializer(out, format);\n            serializer.serialize(dom);\n\n            /*\n             * Get the String out of the StringWriter and rip out the XML\n             * declaration if the Policy says we should.\n             */\n            final String trimmed = trim( trimmedHtml, out.getBuffer().toString() );\n\n            Callable<String> cleanHtml = new Callable<String>() {\n                public String call() throws Exception {\n                    return trimmed;\n                }\n            };\n\n            /*\n             * Return the DOM object as well as string HTML.\n             */\n            results = new CleanResults(startOfScan, cleanHtml, dom, errorMessages);\n\n            cachedItems.add( cachedItem);\n            return results;\n\n        } catch (SAXException | IOException e) {\n            throw new ScanException(e);\n        }\n\n    }\n\n    static DOMFragmentParser getDomParser()\n            throws SAXNotRecognizedException, SAXNotSupportedException {\n        DOMFragmentParser parser = new DOMFragmentParser();\n        parser.setProperty(\"http://cyberneko.org/html/properties/names/elems\", \"lower\");\n\n        parser.setFeature(\"http://cyberneko.org/html/features/scanner/style/strip-cdata-delims\", false);\n        parser.setFeature(\"http://cyberneko.org/html/features/scanner/cdata-sections\", true);\n\n        try {\n            parser.setFeature(\"http://cyberneko.org/html/features/enforce-strict-attribute-names\", true);\n        } catch (SAXNotRecognizedException se) {\n            // this indicates that the patched nekohtml is not on the\n            // classpath\n        }\n        return parser;\n    }\n\n    /**\n     * The workhorse of the scanner. Recursively scans document elements\n     * according to the policy. This should be called implicitly through the\n     * AntiSamy.scan() method.\n     *\n     * @param node The node to validate.\n     */\n    private void recursiveValidateTag(final Node node, int currentStackDepth) throws ScanException {\n\n        currentStackDepth++;\n\n        if(currentStackDepth > maxDepth) {\n            throw new ScanException(\"Too many nested tags\");\n        }\n\n        if (node instanceof Comment) {\n            processCommentNode(node);\n            return;\n        }\n\n        boolean isElement = node instanceof Element;\n        NodeList eleChildNodes = node.getChildNodes();\n        if (isElement && eleChildNodes.getLength() == 0) {\n            if (removeDisallowedEmpty(node)){\n                return;\n            }\n        }\n\n        if (node instanceof Text && Node.CDATA_SECTION_NODE == node.getNodeType()) {\n            stripCData(node);\n            return;\n        }\n\n        if (node instanceof ProcessingInstruction) {\n            removePI(node);\n        }\n\n        if (!isElement) {\n            return;\n        }\n\n        final Element ele = (Element) node;\n        final Node parentNode = ele.getParentNode();\n\n        final String tagName = ele.getNodeName();\n        final String tagNameLowerCase = tagName.toLowerCase();\n        Tag tagRule = policy.getTagByLowercaseName(tagNameLowerCase);\n\n        /*\n         * If <param> and no policy and isValidateParamAsEmbed and policy in\n         * place for <embed> and <embed> policy is to validate, use custom\n         * policy to get the tag through to the validator.\n         */\n        Tag embedTag = policy.getEmbedTag();\n        boolean masqueradingParam = isMasqueradingParam(tagRule, embedTag, tagNameLowerCase);\n        if (masqueradingParam){\n            tagRule = Constants.BASIC_PARAM_TAG_RULE;\n        }\n\n        if ((tagRule == null && policy.isEncodeUnknownTag()) || (tagRule != null && tagRule.isAction( \"encode\"))) {\n            encodeTag(currentStackDepth, ele, tagName, eleChildNodes);\n        } else if (tagRule == null || tagRule.isAction( Policy.ACTION_FILTER)) {\n            actionFilter(currentStackDepth, ele, tagName, tagRule, eleChildNodes);\n        } else if (tagRule.isAction( Policy.ACTION_VALIDATE)) {\n            actionValidate(currentStackDepth, ele, parentNode, tagName, tagNameLowerCase, tagRule, masqueradingParam, embedTag, eleChildNodes);\n        } else if (tagRule.isAction( Policy.ACTION_TRUNCATE)) {\n            actionTruncate(ele, tagName, eleChildNodes);\n        } else {\n            /*\n             * If we reached this that means that the tag's action is \"remove\",\n             * which means to remove the tag (including its contents).\n             */\n            addError(ErrorMessageUtil.ERROR_TAG_DISALLOWED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(tagName)});\n            removeNode(ele);\n        }\n    }\n\n    private boolean isMasqueradingParam(Tag tagRule, Tag embedTag, String tagNameLowerCase){\n        if (tagRule == null && isValidateParamAsEmbed && \"param\".equals(tagNameLowerCase)) {\n            return embedTag != null && embedTag.isAction(Policy.ACTION_VALIDATE);\n        }\n        return false;\n    }\n\n    private void encodeTag(int currentStackDepth, Element ele, String tagName, NodeList eleChildNodes) throws ScanException {\n        addError(ErrorMessageUtil.ERROR_TAG_ENCODED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(tagName)});\n        processChildren(eleChildNodes, currentStackDepth);\n\n   /*\n    * Transform the tag to text, HTML-encode it and promote the\n    * children. The tag will be kept in the fragment as one or two text\n    * Nodes located before and after the children; representing how the\n    * tag used to wrap them.\n    */\n\n        encodeAndPromoteChildren(ele);\n    }\n\n    private void actionFilter(int currentStackDepth, Element ele, String tagName, Tag tag, NodeList eleChildNodes) throws ScanException {\n        if (tag == null) {\n            addError(ErrorMessageUtil.ERROR_TAG_NOT_IN_POLICY, new Object[]{HTMLEntityEncoder.htmlEntityEncode(tagName)});\n        } else {\n            addError(ErrorMessageUtil.ERROR_TAG_FILTERED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(tagName)});\n        }\n\n        processChildren(eleChildNodes, currentStackDepth);\n        promoteChildren(ele);\n    }\n\n    private void actionValidate(int currentStackDepth, Element ele, Node parentNode, String tagName, String tagNameLowerCase, Tag tag, boolean masqueradingParam, Tag embedTag, NodeList eleChildNodes) throws ScanException {\n   /*\n    * If doing <param> as <embed>, now is the time to convert it.\n    */\n        String nameValue = null;\n        if (masqueradingParam) {\n            nameValue = ele.getAttribute(\"name\");\n            if (nameValue != null && !\"\".equals(nameValue)) {\n                String valueValue = ele.getAttribute(\"value\");\n                ele.setAttribute(nameValue, valueValue);\n                ele.removeAttribute(\"name\");\n                ele.removeAttribute(\"value\");\n                tag = embedTag;\n            }\n        }\n\n   /*\n    * Check to see if it's a <style> tag. We have to special case this\n    * tag so we can hand it off to the custom style sheet validating\n    * parser.\n    */\n\n        if (\"style\".equals(tagNameLowerCase) && policy.getStyleTag() != null) {\n            if (processStyleTag(ele, parentNode)) return;\n        }\n\n   /*\n    * Go through the attributes in the tainted tag and validate them\n    * against the values we have for them.\n    *\n    * If we don't have a rule for the attribute we remove the\n    * attribute.\n    */\n\n        if (processAttributes(ele, tagName, tag, currentStackDepth)) return; // can't process any more if we\n\n        if (\"a\".equals(tagNameLowerCase)) {\n            boolean addNofollow = isNofollowAnchors;\n            boolean addNoopenerAndNoreferrer = false;\n\n            if (isNoopenerAndNoreferrerAnchors) {\n                Node targetAttribute = ele.getAttributes().getNamedItem(\"target\");\n                if (targetAttribute != null && targetAttribute.getNodeValue().equalsIgnoreCase(\"_blank\")) {\n                    addNoopenerAndNoreferrer = true;\n                }\n            }\n\n            Node relAttribute = ele.getAttributes().getNamedItem(\"rel\");\n            String relValue = Attribute.mergeRelValuesInAnchor(addNofollow, addNoopenerAndNoreferrer, relAttribute == null ? \"\" : relAttribute.getNodeValue());\n            if (!relValue.isEmpty()){\n                ele.setAttribute(\"rel\", relValue.trim());\n            }\n        }\n\n        processChildren(eleChildNodes, currentStackDepth);\n\n   /*\n    * If we have been dealing with a <param> that has been converted to\n    * an <embed>, convert it back\n    */\n        if (masqueradingParam && nameValue != null && !\"\".equals(nameValue)) {\n            String valueValue = ele.getAttribute(nameValue);\n            ele.setAttribute(\"name\", nameValue);\n            ele.setAttribute(\"value\", valueValue);\n            ele.removeAttribute(nameValue);\n        }\n    }\n\n    private boolean processStyleTag(Element ele, Node parentNode) {\n        /*\n         * Invoke the css parser on this element.\n         */\n        CssScanner styleScanner = new CssScanner(policy, messages, policy.isEmbedStyleSheets());\n\n        try {\n            Node firstChild = ele.getFirstChild();\n            if (firstChild != null) {\n\n                String toScan = firstChild.getNodeValue();\n                CleanResults cr = styleScanner.scanStyleSheet(toScan, policy.getMaxInputSize());\n                errorMessages.addAll(cr.getErrorMessages());\n\n                /*\n                 * If IE gets an empty style tag, i.e. <style/> it will\n                 * break all CSS on the page. I wish I was kidding. So,\n                 * if after validation no CSS properties are left, we\n                 * would normally be left with an empty style tag and\n                 * break all CSS. To prevent that, we have this check.\n                 */\n\n                final String cleanHTML = cr.getCleanHTML();\n\n                if (cleanHTML == null || cleanHTML.equals(\"\")) {\n                    firstChild.setNodeValue(\"/* */\");\n                } else {\n                    firstChild.setNodeValue(cleanHTML);\n                }\n            }\n\n        } catch (DOMException | ScanException | ParseException | NumberFormatException e) {\n\n            /*\n             * ParseException shouldn't be possible anymore, but we'll leave it\n             * here because I (Arshan) am hilariously dumb sometimes.\n             * Batik can throw NumberFormatExceptions (see bug #48).\n             */\n\n            addError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(ele.getFirstChild().getNodeValue())});\n            parentNode.removeChild(ele);\n            return true;\n        }\n        return false;\n    }\n\n    private void actionTruncate(Element ele, String tagName, NodeList eleChildNodes) {\n   /*\n    * Remove all attributes. This is for tags like i, b, u, etc. Purely\n    * formatting without any need for attributes. It also removes any\n    * children.\n    */\n\n        NamedNodeMap nnmap = ele.getAttributes();\n        while (nnmap.getLength() > 0) {\n            addError(ErrorMessageUtil.ERROR_ATTRIBUTE_NOT_IN_POLICY,\n                new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(nnmap.item(0).getNodeName())});\n            ele.removeAttribute(nnmap.item(0).getNodeName());\n        }\n\n        int i = 0;\n        int j = 0;\n        int length = eleChildNodes.getLength();\n\n        while (i < length) {\n            Node nodeToRemove = eleChildNodes.item(j);\n            if (nodeToRemove.getNodeType() != Node.TEXT_NODE) {\n                ele.removeChild(nodeToRemove);\n            } else {\n                j++;\n            }\n            i++;\n        }\n    }\n\n    private boolean processAttributes(Element ele, String tagName, Tag tag, int currentStackDepth) throws ScanException {\n        Node attribute;\n\n        NamedNodeMap attributes = ele.getAttributes();\n        for (int currentAttributeIndex = 0; currentAttributeIndex < attributes.getLength(); currentAttributeIndex++) {\n\n            attribute = attributes.item(currentAttributeIndex);\n\n            String name = attribute.getNodeName();\n            String value = attribute.getNodeValue();\n\n            Attribute attr = tag.getAttributeByName(name.toLowerCase());\n\n            /*\n             * If we there isn't an attribute by that name in our policy\n             * check to see if it's a globally defined attribute. Validate\n             * against that if so.\n             */\n            if (attr == null) {\n                attr = policy.getGlobalAttributeByName(name);\n                if (attr == null && policy.isAllowDynamicAttributes()) {\n                    // not a global attribute, perhaps it is a dynamic attribute, if allowed\n                    attr = policy.getDynamicAttributeByName(name);\n                }\n            }\n\n            /*\n             * We have to special case the \"style\" attribute since it's\n             * validated quite differently.\n             */\n            if (\"style\".equals(name.toLowerCase()) && attr != null) {\n\n                /*\n                 * Invoke the CSS parser on this element.\n                 */\n                CssScanner styleScanner = new CssScanner(policy, messages, false);\n\n                try {\n                    CleanResults cr = styleScanner.scanInlineStyle(value, tagName, policy.getMaxInputSize());\n                    attribute.setNodeValue(cr.getCleanHTML());\n                    List<String> cssScanErrorMessages = cr.getErrorMessages();\n                    errorMessages.addAll(cssScanErrorMessages);\n\n                } catch (DOMException | ScanException e) {\n\n                    addError(ErrorMessageUtil.ERROR_CSS_ATTRIBUTE_MALFORMED,\n                        new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(ele.getNodeValue())});\n                    ele.removeAttribute(attribute.getNodeName());\n                    currentAttributeIndex--;\n                }\n\n            } else {\n\n                if (attr != null) {\n\n                    // See if attribute is invalid\n                    if (!(attr.containsAllowedValue( value.toLowerCase()) ||\n                         (attr.matchesAllowedExpression( value ))) ) {\n\n                        /*\n                         * Attribute is NOT valid, so: Document transgression and perform the\n                         * \"onInvalid\" action. The default action is to\n                         * strip the attribute and leave the rest intact.\n                         */\n\n                        String onInvalidAction = attr.getOnInvalid();\n\n                        if (\"removeTag\".equals(onInvalidAction)) {\n\n                            /*\n                             * Remove the tag and its contents.\n                             */\n\n                            removeNode(ele);\n\n                            addError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID_REMOVED,\n                              new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)});\n                            return true;\n\n                        } else if (\"filterTag\".equals(onInvalidAction)) {\n\n                            /*\n                             * Remove the attribute and keep the rest of the tag.\n                             */\n\n                            processChildren(ele, currentStackDepth);\n                            promoteChildren(ele);\n                            addError(ErrorMessageUtil.ERROR_ATTRIBUTE_CAUSE_FILTER,\n                              new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)});\n                            return true;\n                        } else if (\"encodeTag\".equals(onInvalidAction)) {\n\n                            /*\n                             * Remove the attribute and keep the rest of the tag.\n                             */\n\n                            processChildren(ele, currentStackDepth);\n                            encodeAndPromoteChildren(ele);\n                            addError(ErrorMessageUtil.ERROR_ATTRIBUTE_CAUSE_ENCODE,\n                              new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)});\n                            return true;\n                        } else {\n\n                            /*\n                             * onInvalidAction = \"removeAttribute\"\n                             */\n\n                            ele.removeAttribute(attribute.getNodeName());\n                            currentAttributeIndex--;\n                            addError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID,\n                              new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)});\n                            \n                        }\n                    }\n\n                } else {\n                    /*\n                     * the attribute they specified isn't in our policy\n                     * - remove it (whitelisting!)\n                     */\n\n                    addError(ErrorMessageUtil.ERROR_ATTRIBUTE_NOT_IN_POLICY,\n                      new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)});\n                    ele.removeAttribute(attribute.getNodeName());\n                    currentAttributeIndex--;\n\n                } // end if attribute is found in policy file\n\n            } // end while loop through attributes\n\n        } // loop through each attribute\n        return false;\n    }\n\n    private void processChildren(Node ele, int currentStackDepth) throws ScanException {\n        processChildren(ele.getChildNodes(), currentStackDepth);\n    }\n\n    private void processChildren(NodeList childNodes, int currentStackDepth ) throws ScanException {\n        Node tmp;\n        for (int i = 0; i < childNodes.getLength(); i++) {\n\n            tmp = childNodes.item(i);\n            recursiveValidateTag(tmp, currentStackDepth);\n\n            /*\n             * This indicates the node was removed/failed validation.\n             */\n            if (tmp.getParentNode() == null) {\n                i--;\n            }\n        }\n    }\n\n    private void removePI(Node node) {\n        addError(ErrorMessageUtil.ERROR_PI_FOUND, new Object[]{HTMLEntityEncoder.htmlEntityEncode(node.getTextContent())});\n        removeNode(node);\n    }\n\n    private void stripCData(Node node) {\n        addError(ErrorMessageUtil.ERROR_CDATA_FOUND, new Object[]{HTMLEntityEncoder.htmlEntityEncode(node.getTextContent())});\n        Node text = document.createTextNode(node.getTextContent());\n        node.getParentNode().insertBefore(text, node);\n        node.getParentNode().removeChild(node);\n    }\n\n    private void processCommentNode(Node node) {\n        if (!policy.isPreserveComments()) {\n            node.getParentNode().removeChild(node);\n        } else {\n            String value = ((Comment) node).getData();\n            // Strip conditional directives regardless of the\n            // PRESERVE_COMMENTS setting.\n            if (value != null) {\n                ((Comment) node).setData(conditionalDirectives.matcher(value).replaceAll(\"\"));\n            }\n        }\n    }\n\n    private boolean removeDisallowedEmpty(Node node){\n        String tagName = node.getNodeName();\n\n        if (!isAllowedEmptyTag(tagName)) {\n           /*\n            * Wasn't in the list of allowed elements, so we'll nuke it.\n            */\n            addError(ErrorMessageUtil.ERROR_TAG_EMPTY, new Object[]{HTMLEntityEncoder.htmlEntityEncode(node.getNodeName())});\n            removeNode(node);\n            return true;\n        }\n        return false;\n    }\n\n    private void removeNode(Node node) {\n\t\tNode parent = node.getParentNode();\n\t\tparent.removeChild(node);\n\t\tString tagName = parent.getNodeName();\n\t\tif(\tparent instanceof Element && \n\t\t\tparent.getChildNodes().getLength() == 0 && \n\t\t\t!isAllowedEmptyTag(tagName)) {\n\t\t\tremoveNode(parent);\n\t\t}\n\t}\n\n\tprivate boolean isAllowedEmptyTag(String tagName) {\n        return \"head\".equals(tagName ) || policy.getAllowedEmptyTags().matches(tagName);\n\t}\n\t\n    /**\n     * Used to promote the children of a parent to accomplish the \"filterTag\" action.\n     *\n     * @param ele The Element we want to filter.\n     */\n    private void promoteChildren(Element ele) {\n        promoteChildren(ele, ele.getChildNodes());\n    }\n\n    private void promoteChildren(Element ele, NodeList eleChildNodes) {\n\n        Node parent = ele.getParentNode();\n\n        while (eleChildNodes.getLength() > 0) {\n            Node node = ele.removeChild(eleChildNodes.item(0));\n            parent.insertBefore(node, ele);\n        }\n\n        if (parent != null) {\n            removeNode(ele);\n        }\n    }\n\n    /**\n     * This method was borrowed from Mark McLaren, to whom I owe much beer.\n     *\n     * This method ensures that the output has only valid XML unicode characters\n     * as specified by the XML 1.0 standard. For reference, please see <a\n     * href=\"http://www.w3.org/TR/2000/REC-xml-20001006#NT-Char\">the\n     * standard</a>. This method will return an empty String if the input is\n     * null or empty.\n     *\n     * @param in The String whose non-valid characters we want to remove.\n     * @param invalidXmlCharsMatcher  The reusable regex matcher\n     * @return The in String, stripped of non-valid characters.\n     */\n    private String stripNonValidXMLCharacters(String in, Matcher invalidXmlCharsMatcher) {\n\n        if (in == null || (\"\".equals(in))) {\n            return \"\"; // vacancy test.\n        }\n        invalidXmlCharsMatcher.reset(in);\n        return invalidXmlCharsMatcher.matches() ? invalidXmlCharsMatcher.replaceAll(\"\") : in;\n    }\n\n    /**\n     * Transform the element to text, HTML-encode it and promote the children.\n     * The element will be kept in the fragment as one or two text Nodes located\n     * before and after the children; representing how the tag used to wrap\n     * them. If the element didn't have any children then only one text Node is\n     * created representing an empty element.\n     *\n     * @param ele Element to be encoded\n     */\n    private void encodeAndPromoteChildren(Element ele) {\n        Node parent = ele.getParentNode();\n        String tagName = ele.getTagName();\n        Node openingTag = parent.getOwnerDocument().createTextNode(toString(ele));\n        parent.insertBefore(openingTag, ele);\n        if (ele.hasChildNodes()) {\n            Node closingTag = parent.getOwnerDocument().createTextNode(\"</\" + tagName + \">\");\n            parent.insertBefore(closingTag, ele.getNextSibling());\n        }\n        promoteChildren(ele);\n    }\n\n    /**\n     * Returns a text version of the passed element\n     *\n     * @param ele Element to be converted\n     * @return String representation of the element\n     */\n    private String toString(Element ele) {\n        StringBuilder eleAsString = new StringBuilder(\"<\" + ele.getNodeName());\n        NamedNodeMap attributes = ele.getAttributes();\n        Node attribute;\n        for (int i = 0; i < attributes.getLength(); i++) {\n            attribute = attributes.item(i);\n\n            String name = attribute.getNodeName();\n            String value = attribute.getNodeValue();\n\n            eleAsString.append(\" \");\n            eleAsString.append(HTMLEntityEncoder.htmlEntityEncode(name));\n            eleAsString.append(\"=\\\"\");\n            eleAsString.append(HTMLEntityEncoder.htmlEntityEncode(value));\n            eleAsString.append(\"\\\"\");\n        }\n        if (ele.hasChildNodes()) {\n            eleAsString.append(\">\");\n        } else {\n            eleAsString.append(\"/>\");\n        }\n        return eleAsString.toString();\n    }\n\n    @Override\n    public CleanResults getResults() {\n        return results;\n    }\n}\n", "/*\n * Copyright (c) 2007-2022, Arshan Dabirsiaghi, Jason Li\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this list\n * of conditions and the following disclaimer.  Redistributions in binary form must\n * reproduce the above copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials provided with the distribution.\n * Neither the name of OWASP nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.owasp.validator.html.test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.hamcrest.CoreMatchers.both;\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.not;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\nimport org.hamcrest.text.MatchesPattern;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.concurrent.ExecutionException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.codec.binary.Base64;\n\nimport org.owasp.validator.html.AntiSamy;\nimport org.owasp.validator.html.CleanResults;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.PolicyException;\nimport org.owasp.validator.html.ScanException;\nimport org.owasp.validator.html.model.Attribute;\nimport org.owasp.validator.html.model.Property;\nimport org.owasp.validator.html.model.Tag;\n\n/**\n * This class tests AntiSamy functionality and the basic policy file which\n * should be immune to XSS and CSS phishing attacks.\n * \n * The test cases titled issue##() map to the issues identified in the original AntiSamy \n * source code repo at: https://code.google.com/archive/p/owaspantisamy/issues.\n * \n * The test cases titled githubIssue##() map to the issues documented at: \n *     https://github.com/nahsra/antisamy/issues\n *\n * @author Arshan Dabirsiaghi\n */\n\npublic class AntiSamyTest {\n\n    private static final String[] BASE64_BAD_XML_STRINGS = new String[]{\n            // first string is\n            // \"<a - href=\\\"http://www.owasp.org\\\">click here</a>\"\n            \"PGEgLSBocmVmPSJodHRwOi8vd3d3Lm93YXNwLm9yZyI+Y2xpY2sgaGVyZTwvYT4=\",\n            // the rest are randomly generated 300 byte sequences which generate\n            // parser errors, turned into Strings\n            \"uz0sEy5aDiok6oufQRaYPyYOxbtlACRnfrOnUVIbOstiaoB95iw+dJYuO5sI9nudhRtSYLANlcdgO0pRb+65qKDwZ5o6GJRMWv4YajZk+7Q3W/GN295XmyWUpxuyPGVi7d5fhmtYaYNW6vxyKK1Wjn9IEhIrfvNNjtEF90vlERnz3wde4WMaKMeciqgDXuZHEApYmUcu6Wbx4Q6WcNDqohAN/qCli74tvC+Umy0ZsQGU7E+BvJJ1tLfMcSzYiz7Q15ByZOYrA2aa0wDu0no3gSatjGt6aB4h30D9xUP31LuPGZ2GdWwMfZbFcfRgDSh42JPwa1bODmt5cw0Y8ACeyrIbfk9IkX1bPpYfIgtO7TwuXjBbhh2EEixOZ2YkcsvmcOSVTvraChbxv6kP\",\n            \"PIWjMV4y+MpuNLtcY3vBRG4ZcNaCkB9wXJr3pghmFA6rVXAik+d5lei48TtnHvfvb5rQZVceWKv9cR/9IIsLokMyN0omkd8j3TV0DOh3JyBjPHFCu1Gp4Weo96h5C6RBoB0xsE4QdS2Y1sq/yiha9IebyHThAfnGU8AMC4AvZ7DDBccD2leZy2Q617ekz5grvxEG6tEcZ3fCbJn4leQVVo9MNoerim8KFHGloT+LxdgQR6YN5y1ii3bVGreM51S4TeANujdqJXp8B7B1Gk3PKCRS2T1SNFZedut45y+/w7wp5AUQCBUpIPUj6RLp+y3byWhcbZbJ70KOzTSZuYYIKLLo8047Fej43bIaghJm0F9yIKk3C5gtBcw8T5pciJoVXrTdBAK/8fMVo29P\",\n            \"uCk7HocubT6KzJw2eXpSUItZFGkr7U+D89mJw70rxdqXP2JaG04SNjx3dd84G4bz+UVPPhPO2gBAx2vHI0xhgJG9T4vffAYh2D1kenmr+8gIHt6WDNeD+HwJeAbJYhfVFMJsTuIGlYIw8+I+TARK0vqjACyRwMDAndhXnDrk4E5U3hyjqS14XX0kIDZYM6FGFPXe/s+ba2886Q8o1a7WosgqqAmt4u6R3IHOvVf5/PIeZrBJKrVptxjdjelP8Xwjq2ujWNtR3/HM1kjRlJi4xedvMRe4Rlxek0NDLC9hNd18RYi0EjzQ0bGSDDl0813yv6s6tcT6xHMzKvDcUcFRkX6BbxmoIcMsVeHM/ur6yRv834o/TT5IdiM9/wpkuICFOWIfM+Y8OWhiU6BK\",\n            \"Bb6Cqy6stJ0YhtPirRAQ8OXrPFKAeYHeuZXuC1qdHJRlweEzl4F2z/ZFG7hzr5NLZtzrRG3wm5TXl6Aua5G6v0WKcjJiS2V43WB8uY1BFK1d2y68c1gTRSF0u+VTThGjz+q/R6zE8HG8uchO+KPw64RehXDbPQ4uadiL+UwfZ4BzY1OHhvM5+2lVlibG+awtH6qzzx6zOWemTih932Lt9mMnm3FzEw7uGzPEYZ3aBV5xnbQ2a2N4UXIdm7RtIUiYFzHcLe5PZM/utJF8NdHKy0SPaKYkdXHli7g3tarzAabLZqLT4k7oemKYCn/eKRreZjqTB2E8Kc9Swf3jHDkmSvzOYE8wi1vQ3X7JtPcQ2O4muvpSa70NIE+XK1CgnnsL79Qzci1/1xgkBlNq\",\n            \"FZNVr4nOICD1cNfAvQwZvZWi+P4I2Gubzrt+wK+7gLEY144BosgKeK7snwlA/vJjPAnkFW72APTBjY6kk4EOyoUef0MxRnZEU11vby5Ru19eixZBFB/SVXDJleLK0z3zXXE8U5Zl5RzLActHakG8Psvdt8TDscQc4MPZ1K7mXDhi7FQdpjRTwVxFyCFoybQ9WNJNGPsAkkm84NtFb4KjGpwVC70oq87tM2gYCrNgMhBfdBl0bnQHoNBCp76RKdpq1UAY01t1ipfgt7BoaAr0eTw1S32DezjfkAz04WyPTzkdBKd3b44rX9dXEbm6szAz0SjgztRPDJKSMELjq16W2Ua8d1AHq2Dz8JlsvGzi2jICUjpFsIfRmQ/STSvOT8VsaCFhwL1zDLbn5jCr\",\n            \"RuiRkvYjH2FcCjNzFPT2PJWh7Q6vUbfMadMIEnw49GvzTmhk4OUFyjY13GL52JVyqdyFrnpgEOtXiTu88Cm+TiBI7JRh0jRs3VJRP3N+5GpyjKX7cJA46w8PrH3ovJo3PES7o8CSYKRa3eUs7BnFt7kUCvMqBBqIhTIKlnQd2JkMNnhhCcYdPygLx7E1Vg+H3KybcETsYWBeUVrhRl/RAyYJkn6LddjPuWkDdgIcnKhNvpQu4MMqF3YbzHgyTh7bdWjy1liZle7xR/uRbOrRIRKTxkUinQGEWyW3bbXOvPO71E7xyKywBanwg2FtvzOoRFRVF7V9mLzPSqdvbM7VMQoLFob2UgeNLbVHkWeQtEqQWIV5RMu3+knhoqGYxP/3Srszp0ELRQy/xyyD\",\n            \"mqBEVbNnL929CUA3sjkOmPB5dL0/a0spq8LgbIsJa22SfP580XduzUIKnCtdeC9TjPB/GEPp/LvEUFaLTUgPDQQGu3H5UCZyjVTAMHl45me/0qISEf903zFFqW5Lk3TS6iPrithqMMvhdK29Eg5OhhcoHS+ALpn0EjzUe86NywuFNb6ID4o8aF/ztZlKJegnpDAm3JuhCBauJ+0gcOB8GNdWd5a06qkokmwk1tgwWat7cQGFIH1NOvBwRMKhD51MJ7V28806a3zkOVwwhOiyyTXR+EcDA/aq5acX0yailLWB82g/2GR/DiaqNtusV+gpcMTNYemEv3c/xLkClJc29DSfTsJGKsmIDMqeBMM7RRBNinNAriY9iNX1UuHZLr/tUrRNrfuNT5CvvK1K\",\n            \"IMcfbWZ/iCa/LDcvMlk6LEJ0gDe4ohy2Vi0pVBd9aqR5PnRj8zGit8G2rLuNUkDmQ95bMURasmaPw2Xjf6SQjRk8coIHDLtbg/YNQVMabE8pKd6EaFdsGWJkcFoonxhPR29aH0xvjC4Mp3cJX3mjqyVsOp9xdk6d0Y2hzV3W/oPCq0DV03pm7P3+jH2OzoVVIDYgG1FD12S03otJrCXuzDmE2LOQ0xwgBQ9sREBLXwQzUKfXH8ogZzjdR19pX9qe0rRKMNz8k5lqcF9R2z+XIS1QAfeV9xopXA0CeyrhtoOkXV2i8kBxyodDp7tIeOvbEfvaqZGJgaJyV8UMTDi7zjwNeVdyKa8USH7zrXSoCl+Ud5eflI9vxKS+u9Bt1ufBHJtULOCHGA2vimkU\",\n            \"AqC2sr44HVueGzgW13zHvJkqOEBWA8XA66ZEb3EoL1ehypSnJ07cFoWZlO8kf3k57L1fuHFWJ6quEdLXQaT9SJKHlUaYQvanvjbBlqWwaH3hODNsBGoK0DatpoQ+FxcSkdVE/ki3rbEUuJiZzU0BnDxH+Q6FiNsBaJuwau29w24MlD28ELJsjCcUVwtTQkaNtUxIlFKHLj0++T+IVrQH8KZlmVLvDefJ6llWbrFNVuh674HfKr/GEUatG6KI4gWNtGKKRYh76mMl5xH5qDfBZqxyRaKylJaDIYbx5xP5I4DDm4gOnxH+h/Pu6dq6FJ/U3eDio/KQ9xwFqTuyjH0BIRBsvWWgbTNURVBheq+am92YBhkj1QmdKTxQ9fQM55O8DpyWzRhky0NevM9j\",\n            \"qkFfS3WfLyj3QTQT9i/s57uOPQCTN1jrab8bwxaxyeYUlz2tEtYyKGGUufua8WzdBT2VvWTvH0JkK0LfUJ+vChvcnMFna+tEaCKCFMIOWMLYVZSJDcYMIqaIr8d0Bi2bpbVf5z4WNma0pbCKaXpkYgeg1Sb8HpKG0p0fAez7Q/QRASlvyM5vuIOH8/CM4fF5Ga6aWkTRG0lfxiyeZ2vi3q7uNmsZF490J79r/6tnPPXIIC4XGnijwho5NmhZG0XcQeyW5KnT7VmGACFdTHOb9oS5WxZZU29/oZ5Y23rBBoSDX/xZ1LNFiZk6Xfl4ih207jzogv+3nOro93JHQydNeKEwxOtbKqEe7WWJLDw/EzVdJTODrhBYKbjUce10XsavuiTvv+H1Qh4lo2Vx\",\n            \"O900/Gn82AjyLYqiWZ4ILXBBv/ZaXpTpQL0p9nv7gwF2MWsS2OWEImcVDa+1ElrjUumG6CVEv/rvax53krqJJDg+4Z/XcHxv58w6hNrXiWqFNjxlu5RZHvj1oQQXnS2n8qw8e/c+8ea2TiDIVr4OmgZz1G9uSPBeOZJvySqdgNPMpgfjZwkL2ez9/x31sLuQxi/FW3DFXU6kGSUjaq8g/iGXlaaAcQ0t9Gy+y005Z9wpr2JWWzishL+1JZp9D4SY/r3NHDphN4MNdLHMNBRPSIgfsaSqfLraIt+zWIycsd+nksVxtPv9wcyXy51E1qlHr6Uygz2VZYD9q9zyxEX4wRP2VEewHYUomL9d1F6gGG5fN3z82bQ4hI9uDirWhneWazUOQBRud5otPOm9\",\n            \"C3c+d5Q9lyTafPLdelG1TKaLFinw1TOjyI6KkrQyHKkttfnO58WFvScl1TiRcB/iHxKahskoE2+VRLUIhctuDU4sUvQh/g9Arw0LAA4QTxuLFt01XYdigurz4FT15ox2oDGGGrRb3VGjDTXK1OWVJoLMW95EVqyMc9F+Fdej85LHE+8WesIfacjUQtTG1tzYVQTfubZq0+qxXws8QrxMLFtVE38tbeXo+Ok1/U5TUa6FjWflEfvKY3XVcl8RKkXua7fVz/Blj8Gh+dWe2cOxa0lpM75ZHyz9adQrB2Pb4571E4u2xI5un0R0MFJZBQuPDc1G5rPhyk+Hb4LRG3dS0m8IASQUOskv93z978L1+Abu9CLP6d6s5p+BzWxhMUqwQXC/CCpTywrkJ0RG\",\n    };\n\n    private AntiSamy as = new AntiSamy();\n    private TestPolicy policy = null;\n\n    @Before\n    public void setUp() throws Exception {\n\n        /*\n         * Load the policy. You may have to change the path to find the Policy\n         * file for your environment.\n         */\n\n        //get Policy instance from a URL.\n        URL url = getClass().getResource(\"/antisamy.xml\");\n        policy = TestPolicy.getInstance(url);\n    }\n\n    @Test\n    public void SAX() {\n        try {\n            CleanResults cr = as.scan(\"<b>test</i></b>test thsidfshidf<script>sdfsdf\", policy, AntiSamy.SAX);\n            assertTrue(cr != null && cr.getCleanXMLDocumentFragment() == null && cr.getCleanHTML().length() > 0);\n        } catch (ScanException | PolicyException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /*\n     * Test basic XSS cases.\n     */\n\n    @Test\n    public void scriptAttacks() throws ScanException, PolicyException {\n    \t\n        assertTrue(!as.scan(\"test<script>alert(document.cookie)</script>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"script\"));\n        assertTrue(!as.scan(\"test<script>alert(document.cookie)</script>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"script\"));\n\n        assertTrue(!as.scan(\"<<<><<script src=http://fake-evil.ru/test.js>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<<<><<script src=http://fake-evil.ru/test.js>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<script<script src=http://fake-evil.ru/test.js>>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<script<script src=http://fake-evil.ru/test.js>>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT/XSS SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT/XSS SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<BODY onload!#$%&()*~+-_.,:;?@[/|\\\\]^`=alert(\\\"XSS\\\")>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"onload\"));\n        assertTrue(!as.scan(\"<BODY onload!#$%&()*~+-_.,:;?@[/|\\\\]^`=alert(\\\"XSS\\\")>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"onload\"));\n\n        assertTrue(!as.scan(\"<BODY ONLOAD=alert('XSS')>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n        assertTrue(!as.scan(\"<BODY ONLOAD=alert('XSS')>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n        assertTrue(!as.scan(\"<iframe src=http://ha.ckers.org/scriptlet.html <\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<iframe\"));\n        assertTrue(!as.scan(\"<iframe src=http://ha.ckers.org/scriptlet.html <\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<iframe\"));\n\n        assertTrue(!as.scan(\"<INPUT TYPE=\\\"IMAGE\\\" SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"src\"));\n        assertTrue(!as.scan(\"<INPUT TYPE=\\\"IMAGE\\\" SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"src\"));\n\n        as.scan(\"<a onblur=\\\"alert(secret)\\\" href=\\\"http://www.google.com\\\">Google</a>\", policy, AntiSamy.DOM);\n        as.scan(\"<a onblur=\\\"alert(secret)\\\" href=\\\"http://www.google.com\\\">Google</a>\", policy, AntiSamy.SAX);\n    }\n\n    @Test\n    public void imgAttacks() throws ScanException, PolicyException {\n\n        assertTrue(as.scan(\"<img src=\\\"http://www.myspace.com/img.gif\\\"/>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n        assertTrue(as.scan(\"<img src=\\\"http://www.myspace.com/img.gif\\\"/>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<img\"));\n\n        assertTrue(!as.scan(\"<img src=javascript:alert(document.cookie)>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n        assertTrue(!as.scan(\"<img src=javascript:alert(document.cookie)>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<img\"));\n\n        assertTrue(!as.scan(\"<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n        assertTrue(!as.scan(\"<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>\", policy, AntiSamy.SAX)\n                .getCleanHTML().contains(\"<img\"));\n\n        assertTrue(!as.scan(\n                        \"<IMG SRC='&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041'>\",\n                        policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n        assertTrue(!as.scan(\n                        \"<IMG SRC='&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041'>\",\n                        policy, AntiSamy.SAX).getCleanHTML().contains(\"<img\"));\n\n        assertTrue(!as.scan(\"<IMG SRC=\\\"jav&#x0D;ascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n        assertTrue(!as.scan(\"<IMG SRC=\\\"jav&#x0D;ascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n        String s = as.scan(\n                        \"<IMG SRC=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>\",\n                        policy, AntiSamy.DOM).getCleanHTML();\n        assertTrue(s.length() == 0 || s.contains(\"&amp;\"));\n        s = as.scan( \"<IMG SRC=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>\",\n                        policy, AntiSamy.SAX).getCleanHTML();\n        assertTrue(s.length() == 0 || s.contains(\"&amp;\"));\n\n        as.scan(\"<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>\", policy, AntiSamy.DOM);\n        as.scan(\"<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>\", policy, AntiSamy.SAX);\n\n        assertTrue(!as.scan(\"<IMG SRC=\\\"javascript:alert('XSS')\\\"\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<IMG SRC=\\\"javascript:alert('XSS')\\\"\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<IMG LOWSRC=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<IMG LOWSRC=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<BGSOUND SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<BGSOUND SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n    }\n\n    @Test\n    public void hrefAttacks() throws ScanException, PolicyException {\n\n        assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"href\"));\n        assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"href\"));\n\n        assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"http://ha.ckers.org/xss.css\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"href\"));\n        assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"http://ha.ckers.org/xss.css\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"href\"));\n\n        assertTrue(!as.scan(\"<STYLE>@import'http://ha.ckers.org/xss.css';</STYLE>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"ha.ckers.org\"));\n        assertTrue(!as.scan(\"<STYLE>@import'http://ha.ckers.org/xss.css';</STYLE>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"ha.ckers.org\"));\n\n        assertTrue(!as.scan(\"<STYLE>BODY{-moz-binding:url(\\\"http://ha.ckers.org/xssmoz.xml#xss\\\")}</STYLE>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"ha.ckers.org\"));\n        assertTrue(!as.scan(\"<STYLE>BODY{-moz-binding:url(\\\"http://ha.ckers.org/xssmoz.xml#xss\\\")}</STYLE>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"ha.ckers.org\"));\n\n        assertTrue(!as.scan(\"<STYLE>li {list-style-image: url(\\\"javascript:alert('XSS')\\\");}</STYLE><UL><LI>XSS\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<STYLE>li {list-style-image: url(\\\"javascript:alert('XSS')\\\");}</STYLE><UL><LI>XSS\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<IMG SRC='vbscript:msgbox(\\\"XSS\\\")'>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"vbscript\"));\n        assertTrue(!as.scan(\"<IMG SRC='vbscript:msgbox(\\\"XSS\\\")'>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"vbscript\"));\n\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0; URL=http://;URL=javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<meta\"));\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0; URL=http://;URL=javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<meta\"));\n\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<meta\"));\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<meta\"));\n\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<meta\"));\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<meta\"));\n\n        assertTrue(!as.scan(\"<IFRAME SRC=\\\"javascript:alert('XSS');\\\"></IFRAME>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"iframe\"));\n        assertTrue(!as.scan(\"<IFRAME SRC=\\\"javascript:alert('XSS');\\\"></IFRAME>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"iframe\"));\n\n        assertTrue(!as.scan(\"<FRAMESET><FRAME SRC=\\\"javascript:alert('XSS');\\\"></FRAMESET>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<FRAMESET><FRAME SRC=\\\"javascript:alert('XSS');\\\"></FRAMESET>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<TABLE BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"background\"));\n        assertTrue(!as.scan(\"<TABLE BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"background\"));\n\n        assertTrue(!as.scan(\"<TABLE><TD BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"background\"));\n        assertTrue(!as.scan(\"<TABLE><TD BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"background\"));\n\n        assertTrue(!as.scan(\"<DIV STYLE=\\\"background-image: url(javascript:alert('XSS'))\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<DIV STYLE=\\\"background-image: url(javascript:alert('XSS'))\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<DIV STYLE=\\\"width: expression(alert('XSS'));\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n        assertTrue(!as.scan(\"<DIV STYLE=\\\"width: expression(alert('XSS'));\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n        assertTrue(!as.scan(\"<IMG STYLE=\\\"xss:expr/*XSS*/ession(alert('XSS'))\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n        assertTrue(!as.scan(\"<IMG STYLE=\\\"xss:expr/*XSS*/ession(alert('XSS'))\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n        assertTrue(!as.scan(\"<STYLE>@im\\\\port'\\\\ja\\\\vasc\\\\ript:alert(\\\"XSS\\\")';</STYLE>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"ript:alert\"));\n        assertTrue(!as.scan(\"<STYLE>@im\\\\port'\\\\ja\\\\vasc\\\\ript:alert(\\\"XSS\\\")';</STYLE>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"ript:alert\"));\n\n        assertTrue(!as.scan(\"<BASE HREF=\\\"javascript:alert('XSS');//\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<BASE HREF=\\\"javascript:alert('XSS');//\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<BaSe hReF=\\\"http://arbitrary.com/\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<base\"));\n        assertTrue(!as.scan(\"<BaSe hReF=\\\"http://arbitrary.com/\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<base\"));\n\n        assertTrue(!as.scan(\"<OBJECT TYPE=\\\"text/x-scriptlet\\\" DATA=\\\"http://ha.ckers.org/scriptlet.html\\\"></OBJECT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<object\"));\n        assertTrue(!as.scan(\"<OBJECT TYPE=\\\"text/x-scriptlet\\\" DATA=\\\"http://ha.ckers.org/scriptlet.html\\\"></OBJECT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<object\"));\n\n        assertTrue(!as.scan(\"<OBJECT classid=clsid:ae24fdae-03c6-11d1-8b76-0080c744f389><param name=url value=javascript:alert('XSS')></OBJECT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n\n        CleanResults cr = as.scan(\"<OBJECT classid=clsid:ae24fdae-03c6-11d1-8b76-0080c744f389><param name=url value=javascript:alert('XSS')></OBJECT>\", policy, AntiSamy.SAX);\n        // System.out.println(cr.getErrorMessages().get(0));\n        assertTrue(!cr.getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<EMBED SRC=\\\"http://ha.ckers.org/xss.swf\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<embed\"));\n        assertTrue(!as.scan(\"<EMBED SRC=\\\"http://ha.ckers.org/xss.swf\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<embed\"));\n\n        assertTrue(!as.scan(\n                        \"<EMBED SRC=\\\"data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==\\\" type=\\\"image/svg+xml\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\",\n                        policy, AntiSamy.DOM).getCleanHTML().contains(\"<embed\"));\n        assertTrue(!as.scan(\n                        \"<EMBED SRC=\\\"data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==\\\" type=\\\"image/svg+xml\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\",\n                        policy, AntiSamy.SAX).getCleanHTML().contains(\"<embed\"));\n\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" '' SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" '' SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT a=`>` SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT a=`>` SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">'>\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">'>\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT>document.write(\\\"<SCRI\\\");</SCRIPT>PT SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"script\"));\n        assertTrue(!as.scan(\"<SCRIPT>document.write(\\\"<SCRI\\\");</SCRIPT>PT SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT SRC=http://ha.ckers.org/xss.js\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT SRC=http://ha.ckers.org/xss.js\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\n                        \"<div/style=&#92&#45&#92&#109&#111&#92&#122&#92&#45&#98&#92&#105&#92&#110&#100&#92&#105&#110&#92&#103:&#92&#117&#114&#108&#40&#47&#47&#98&#117&#115&#105&#110&#101&#115&#115&#92&#105&#92&#110&#102&#111&#46&#99&#111&#46&#117&#107&#92&#47&#108&#97&#98&#115&#92&#47&#120&#98&#108&#92&#47&#120&#98&#108&#92&#46&#120&#109&#108&#92&#35&#120&#115&#115&#41&>\",\n                        policy, AntiSamy.DOM).getCleanHTML().contains(\"style\"));\n        assertTrue(!as.scan(\n                        \"<div/style=&#92&#45&#92&#109&#111&#92&#122&#92&#45&#98&#92&#105&#92&#110&#100&#92&#105&#110&#92&#103:&#92&#117&#114&#108&#40&#47&#47&#98&#117&#115&#105&#110&#101&#115&#115&#92&#105&#92&#110&#102&#111&#46&#99&#111&#46&#117&#107&#92&#47&#108&#97&#98&#115&#92&#47&#120&#98&#108&#92&#47&#120&#98&#108&#92&#46&#120&#109&#108&#92&#35&#120&#115&#115&#41&>\",\n                        policy, AntiSamy.SAX).getCleanHTML().contains(\"style\"));\n\n        assertTrue(!as.scan(\"<a href='aim: &c:\\\\windows\\\\system32\\\\calc.exe' ini='C:\\\\Documents and Settings\\\\All Users\\\\Start Menu\\\\Programs\\\\Startup\\\\pwnd.bat'>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"aim.exe\"));\n        assertTrue(!as.scan(\"<a href='aim: &c:\\\\windows\\\\system32\\\\calc.exe' ini='C:\\\\Documents and Settings\\\\All Users\\\\Start Menu\\\\Programs\\\\Startup\\\\pwnd.bat'>\", policy, AntiSamy.SAX)\n                .getCleanHTML().contains(\"aim.exe\"));\n\n        assertTrue(!as.scan(\"<!--\\n<A href=\\n- --><a href=javascript:alert:document.domain>test-->\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<!--\\n<A href=\\n- --><a href=javascript:alert:document.domain>test-->\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<a></a style=\\\"\\\"xx:expr/**/ession(document.appendChild(document.createElement('script')).src='http://h4k.in/i.js')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"document\"));\n        assertTrue(!as.scan(\"<a></a style=\\\"\\\"xx:expr/**/ession(document.appendChild(document.createElement('script')).src='http://h4k.in/i.js')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"document\"));\n    }\n\n    /*\n     * Test CSS protections.\n     */\n\n    @Test\n    public void cssAttacks() throws ScanException, PolicyException {\n\n        assertTrue(!as.scan(\"<div style=\\\"position:absolute\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"position\"));\n        assertTrue(!as.scan(\"<div style=\\\"position:absolute\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"position\"));\n\n        assertTrue(!as.scan(\"<style>b { position:absolute }</style>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"position\"));\n        assertTrue(!as.scan(\"<style>b { position:absolute }</style>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"position\"));\n\n        assertTrue(!as.scan(\"<div style=\\\"z-index:25\\\">test</div>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"z-index\"));\n        assertTrue(!as.scan(\"<div style=\\\"z-index:25\\\">test</div>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"z-index\"));\n\n        assertTrue(!as.scan(\"<style>z-index:25</style>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"z-index\"));\n        assertTrue(!as.scan(\"<style>z-index:25</style>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"z-index\"));\n    }\n\n    /*\n     * Test a bunch of strings that have tweaked the XML parsing capabilities of\n     * NekoHTML.\n     */\n    @Test\n    public void IllegalXML() throws PolicyException {\n\n        for (String BASE64_BAD_XML_STRING : BASE64_BAD_XML_STRINGS) {\n\n            try {\n                String testStr = new String(Base64.decodeBase64(BASE64_BAD_XML_STRING.getBytes()));\n                as.scan(testStr, policy, AntiSamy.DOM);\n                as.scan(testStr, policy, AntiSamy.SAX);\n\n            } catch (ScanException ex) {\n                // still success!\n            }\n        }\n\n        // This fails due to a bug in NekoHTML\n        // try {\n        // assertTrue (\n        // as.scan(\"<a . href=\\\"http://www.test.com\\\">\",policy, AntiSamy.DOM).getCleanHTML().indexOf(\"href\")\n        // != -1 );\n        // } catch (Exception e) {\n        // e.printStackTrace();\n        // fail(\"Couldn't parse malformed HTML: \" + e.getMessage());\n        // }\n\n        // This fails due to a bug in NekoHTML\n        // try {\n        // assertTrue (\n        // as.scan(\"<a - href=\\\"http://www.test.com\\\">\",policy, AntiSamy.DOM).getCleanHTML().indexOf(\"href\")\n        // != -1 );\n        // } catch (Exception e) {\n        // e.printStackTrace();\n        // fail(\"Couldn't parse malformed HTML: \" + e.getMessage());\n        // }\n\n        try {\n            assertTrue(as.scan(\"<style>\", policy, AntiSamy.DOM) != null);\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(\"Couldn't parse malformed HTML: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    public void issue12() throws ScanException, PolicyException {\n\n        /*\n         * issues 12 (and 36, which was similar). empty tags cause display\n         * problems/\"formjacking\"\n         */\n\n        Pattern p = Pattern.compile(\".*<strong(\\\\s*)/>.*\");\n        String s1 = as.scan(\"<br ><strong></strong><a>hello world</a><b /><i/><hr>\", policy, AntiSamy.DOM).getCleanHTML();\n        String s2 = as.scan(\"<br ><strong></strong><a>hello world</a><b /><i/><hr>\", policy, AntiSamy.SAX).getCleanHTML();\n\n        assertFalse(p.matcher(s1).matches());\n\n        p = Pattern.compile(\".*<b(\\\\s*)/>.*\");\n        assertFalse(p.matcher(s1).matches());\n        assertFalse(p.matcher(s2).matches());\n\n        p = Pattern.compile(\".*<i(\\\\s*)/>.*\");\n        assertFalse(p.matcher(s1).matches());\n        assertFalse(p.matcher(s2).matches());\n\n        assertTrue(s1.contains(\"<hr />\") || s1.contains(\"<hr/>\"));\n        assertTrue(s2.contains(\"<hr />\") || s2.contains(\"<hr/>\"));\n    }\n\n    @Test\n    public void issue20() throws ScanException, PolicyException {\n        String s = as.scan(\"<b><i>Some Text</b></i>\", policy, AntiSamy.DOM).getCleanHTML();\n        assertTrue(!s.contains(\"<i />\"));\n\n        s = as.scan(\"<b><i>Some Text</b></i>\", policy, AntiSamy.SAX).getCleanHTML();\n        assertTrue(!s.contains(\"<i />\"));\n    }\n\n    @Test\n    public void issue25() throws ScanException, PolicyException {\n        String s = \"<div style=\\\"margin: -5em\\\">Test</div>\";\n        String expected = \"<div style=\\\"\\\">Test</div>\";\n\n        String crDom = as.scan(s, policy, AntiSamy.DOM).getCleanHTML();\n        assertEquals(crDom, expected);\n        String crSax = as.scan(s, policy, AntiSamy.SAX).getCleanHTML();\n        assertEquals(crSax, expected);\n    }\n\n\n    @Test\n    public void issue28() throws ScanException, PolicyException {\n        String s1 = as.scan(\"<div style=\\\"font-family: Geneva, Arial, courier new, sans-serif\\\">Test</div>\", policy, AntiSamy.DOM).getCleanHTML();\n        String s2 = as.scan(\"<div style=\\\"font-family: Geneva, Arial, courier new, sans-serif\\\">Test</div>\", policy, AntiSamy.SAX).getCleanHTML();\n        assertTrue(s1.contains(\"font-family\"));\n        assertTrue(s2.contains(\"font-family\"));\n    }\n\n    @Test\n    public void issue29() throws ScanException, PolicyException {\n        /* issue #29 - missing quotes around properties with spaces */\n        String s = \"<style type=\\\"text/css\\\"><![CDATA[P {\\n\tfont-family: \\\"Arial Unicode MS\\\";\\n}\\n]]></style>\";\n        CleanResults cr = as.scan(s, policy, AntiSamy.DOM);\n        assertEquals(s, cr.getCleanHTML());\n    }\n\n    @Test\n    public void issue30() throws ScanException, PolicyException {\n\n        String s = \"<style type=\\\"text/css\\\"><![CDATA[P { margin-bottom: 0.08in; } ]]></style>\";\n\n        as.scan(s, policy, AntiSamy.DOM);\n        CleanResults cr;\n\n        /* followup - does the patch fix multiline CSS? */\n        String s2 = \"<style type=\\\"text/css\\\"><![CDATA[\\r\\nP {\\r\\n margin-bottom: 0.08in;\\r\\n}\\r\\n]]></style>\";\n        cr = as.scan(s2, policy, AntiSamy.DOM);\n        assertEquals(\"<style type=\\\"text/css\\\"><![CDATA[P {\\n\\tmargin-bottom: 0.08in;\\n}\\n]]></style>\", cr.getCleanHTML());\n\n        /* next followup - does non-CDATA parsing still work? */\n\n        String s3 = \"<style>P {\\n\\tmargin-bottom: 0.08in;\\n}\\n\";\n        cr = as.scan(s3, policy.cloneWithDirective(Policy.USE_XHTML, \"false\"), AntiSamy.DOM);\n        assertEquals(\"<style>P {\\n\\tmargin-bottom: 0.08in;\\n}\\n</style>\\n\", cr.getCleanHTML());\n    }\n\n    @Test\n    public void issue31() throws ScanException, PolicyException {\n\n        String test = \"<b><u><g>foo</g></u></b>\";\n        Policy revised = policy.cloneWithDirective(\"onUnknownTag\", \"encode\");\n        CleanResults cr = as.scan(test, revised, AntiSamy.DOM);\n        String s = cr.getCleanHTML();\n        assertFalse(!s.contains(\"&lt;g&gt;\"));\n        assertFalse(!s.contains(\"&lt;/g&gt;\"));\n        s = as.scan(test, revised, AntiSamy.SAX).getCleanHTML();\n        assertFalse(!s.contains(\"&lt;g&gt;\"));\n        assertFalse(!s.contains(\"&lt;/g&gt;\"));\n\n        Tag tag = policy.getTagByLowercaseName(\"b\").mutateAction(\"encode\");\n        Policy policy1 = policy.mutateTag(tag);\n\n        cr = as.scan(test, policy1, AntiSamy.DOM);\n        s = cr.getCleanHTML();\n\n        assertFalse(!s.contains(\"&lt;b&gt;\"));\n        assertFalse(!s.contains(\"&lt;/b&gt;\"));\n\n        cr = as.scan(test, policy1, AntiSamy.SAX);\n        s = cr.getCleanHTML();\n\n        assertFalse(!s.contains(\"&lt;b&gt;\"));\n        assertFalse(!s.contains(\"&lt;/b&gt;\"));\n    }\n\n    @Test\n    public void issue32() throws ScanException, PolicyException {\n        /* issue #32 - nekos problem */\n        String s = \"<SCRIPT =\\\">\\\" SRC=\\\"\\\"></SCRIPT>\";\n        as.scan(s, policy, AntiSamy.DOM);\n        as.scan(s, policy, AntiSamy.SAX);\n    }\n\n    @Test\n    public void issue37() throws ScanException, PolicyException {\n\n        String dirty = \"<a onblur=\\\"try {parent.deselectBloggerImageGracefully();}\" + \"catch(e) {}\\\"\"\n                + \"href=\\\"http://www.charityadvantage.com/ChildrensmuseumEaston/images/BookswithBill.jpg\\\"><img\" + \"style=\\\"FLOAT: right; MARGIN: 0px 0px 10px 10px; WIDTH: 150px; CURSOR:\"\n                + \"hand; HEIGHT: 100px\\\" alt=\\\"\\\"\" + \"src=\\\"http://www.charityadvantage.com/ChildrensmuseumEaston/images/BookswithBill.jpg\\\"\"\n                + \"border=\\\"0\\\" /></a><br />Poor Bill, couldn't make it to the Museum's <span\" + \"class=\\\"blsp-spelling-corrected\\\" id=\\\"SPELLING_ERROR_0\\\">story time</span>\"\n                + \"today, he was so busy shoveling! Well, we sure missed you Bill! So since\" + \"ou were busy moving snow we read books about snow. We found a clue in one\"\n                + \"book which revealed a snowplow at the end of the story - we wish it had\" + \"driven to your driveway Bill. We also read a story which shared fourteen\"\n                + \"<em>Names For Snow. </em>We'll catch up with you next week....wonder which\" + \"hat Bill will wear?<br />Jane\";\n\n        Policy mySpacePolicy = Policy.getInstance(getClass().getResource(\"/antisamy-myspace.xml\"));\n        CleanResults cr = as.scan(dirty, mySpacePolicy, AntiSamy.DOM);\n        assertNotNull(cr.getCleanHTML());\n        cr = as.scan(dirty, mySpacePolicy, AntiSamy.SAX);\n        assertNotNull(cr.getCleanHTML());\n\n        Policy ebayPolicy = Policy.getInstance(getClass().getResource(\"/antisamy-ebay.xml\"));\n        cr = as.scan(dirty, ebayPolicy, AntiSamy.DOM);\n        assertNotNull(cr.getCleanHTML());\n        cr = as.scan(dirty, mySpacePolicy, AntiSamy.SAX);\n        assertNotNull(cr.getCleanHTML());\n\n        Policy slashdotPolicy = Policy.getInstance(getClass().getResource(\"/antisamy-slashdot.xml\"));\n        cr = as.scan(dirty, slashdotPolicy, AntiSamy.DOM);\n        assertNotNull(cr.getCleanHTML());\n        cr = as.scan(dirty, slashdotPolicy, AntiSamy.SAX);\n        assertNotNull(cr.getCleanHTML());\n    }\n\n    @Test\n    public void issue38() throws ScanException, PolicyException {\n\n        /* issue #38 - color problem/color combinations */\n        String s = \"<font color=\\\"#fff\\\">Test</font>\";\n        String expected = \"<font color=\\\"#fff\\\">Test</font>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<div style=\\\"color: #fff\\\">Test 3 letter code</div>\";\n        expected = \"<div style=\\\"color: rgb(255,255,255);\\\">Test 3 letter code</div>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<font color=\\\"red\\\">Test</font>\";\n        expected = \"<font color=\\\"red\\\">Test</font>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<font color=\\\"neonpink\\\">Test</font>\";\n        expected = \"<font>Test</font>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<font color=\\\"#0000\\\">Test</font>\";\n        expected = \"<font>Test</font>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<div style=\\\"color: #0000\\\">Test</div>\";\n        expected = \"<div style=\\\"\\\">Test</div>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<font color=\\\"#000000\\\">Test</font>\";\n        expected = \"<font color=\\\"#000000\\\">Test</font>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<div style=\\\"color: #000000\\\">Test</div>\";\n        expected = \"<div style=\\\"color: rgb(0,0,0);\\\">Test</div>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        /*\n        * This test case was failing because of the following code from the\n        * batik CSS library, which throws an exception if any character\n        * other than a '!' follows a beginning token of '<'. The\n        * ParseException is now caught in the node a CssScanner.java and\n        * the outside AntiSamyDOMScanner.java.\n        *\n        * 0398 nextChar(); 0399 if (current != '!') { 0400 throw new\n        * ParseException(\"character\", 0401 reader.getLine(), 0402\n        * reader.getColumn());\n        */\n        s = \"<b><u>foo<style><script>alert(1)</script></style>@import 'x';</u>bar\";\n        as.scan(s, policy, AntiSamy.DOM);\n        as.scan(s, policy, AntiSamy.SAX);\n    }\n\n    @Test\n    public void issue40() throws ScanException, PolicyException {\n\n        /* issue #40 - handling <style> media attributes right */\n\n        String s = \"<style media=\\\"print, projection, screen\\\"> P { margin: 1em; }</style>\";\n        Policy revised = policy.cloneWithDirective(Policy.PRESERVE_SPACE, \"true\");\n\n        CleanResults cr = as.scan(s, revised, AntiSamy.DOM);\n        assertTrue(cr.getCleanHTML().contains(\"print, projection, screen\"));\n\n        cr = as.scan(s, revised, AntiSamy.SAX);\n        assertTrue(cr.getCleanHTML().contains(\"print, projection, screen\"));\n    }\n\n    @Test\n    public void issue41() throws ScanException, PolicyException {\n        /* issue #41 - comment handling */\n\n        Policy revised = policy.cloneWithDirective(Policy.PRESERVE_SPACE, \"true\");\n\n        policy.cloneWithDirective(Policy.PRESERVE_COMMENTS, \"false\");\n\n        assertEquals(\"text \", as.scan(\"text <!-- comment -->\", revised, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"text \", as.scan(\"text <!-- comment -->\", revised, AntiSamy.SAX).getCleanHTML());\n\n        Policy revised2 = policy.cloneWithDirective(Policy.PRESERVE_COMMENTS, \"true\").cloneWithDirective(Policy.PRESERVE_SPACE, \"true\").cloneWithDirective(Policy.FORMAT_OUTPUT, \"false\");\n\n        /*\n        * These make sure the regular comments are kept alive and that\n        * conditional comments are ripped out.\n        */\n        assertEquals(\"<div>text <!-- comment --></div>\", as.scan(\"<div>text <!-- comment --></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"<div>text <!-- comment --></div>\", as.scan(\"<div>text <!-- comment --></div>\", revised2, AntiSamy.SAX).getCleanHTML());\n\n        assertEquals(\"<div>text <!-- comment --></div>\", as.scan(\"<div>text <!--[if IE]> comment <[endif]--></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"<div>text <!-- comment --></div>\", as.scan(\"<div>text <!--[if IE]> comment <[endif]--></div>\", revised2, AntiSamy.SAX).getCleanHTML());\n\n        /*\n        * Check to see how nested conditional comments are handled. This is\n        * not very clean but the main goal is to avoid any tags. Not sure\n        * on encodings allowed in comments.\n        */\n        String input = \"<div>text <!--[if IE]> <!--[if gte 6]> comment <[endif]--><[endif]--></div>\";\n        String expected = \"<div>text <!-- <!-- comment -->&lt;[endif]--&gt;</div>\";\n        String output = as.scan(input, revised2, AntiSamy.DOM).getCleanHTML();\n        assertEquals(expected, output);\n\n        input = \"<div>text <!--[if IE]> <!--[if gte 6]> comment <[endif]--><[endif]--></div>\";\n        expected = \"<div>text <!-- <!-- comment -->&lt;[endif]--&gt;</div>\";\n        output = as.scan(input, revised2, AntiSamy.SAX).getCleanHTML();\n\n        assertEquals(expected, output);\n\n        /*\n        * Regular comment nested inside conditional comment. Test makes\n        * sure\n        */\n        assertEquals(\"<div>text <!-- <!-- IE specific --> comment &lt;[endif]--&gt;</div>\", as.scan(\"<div>text <!--[if IE]> <!-- IE specific --> comment <[endif]--></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n\n        /*\n        * These play with whitespace and have invalid comment syntax.\n        */\n        assertEquals(\"<div>text <!-- \\ncomment --></div>\", as.scan(\"<div>text <!-- [ if lte 6 ]>\\ncomment <[ endif\\n]--></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"<div>text  comment </div>\", as.scan(\"<div>text <![if !IE]> comment <![endif]></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"<div>text  comment </div>\", as.scan(\"<div>text <![ if !IE]> comment <![endif]></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n\n        String attack = \"[if lte 8]<script>\";\n        String spacer = \"<![if IE]>\";\n\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(\"<div>text<!\");\n\n        for (int i = 0; i < attack.length(); i++) {\n            sb.append(attack.charAt(i));\n            sb.append(spacer);\n        }\n\n        sb.append(\"<![endif]>\");\n\n        String s = sb.toString();\n\n        assertTrue(!as.scan(s, revised2, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(s, revised2, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n    }\n\n    @Test\n    public void issue44() throws ScanException, PolicyException {\n        /*\n         * issue #44 - childless nodes of non-allowed elements won't cause an error\n         */\n        String s = \"<iframe src='http://foo.com/'></iframe>\" + \"<script src=''></script>\" + \"<link href='/foo.css'>\";\n        as.scan(s, policy, AntiSamy.DOM);\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getNumberOfErrors(), 3);\n\n        CleanResults cr = as.scan(s, policy, AntiSamy.SAX);\n\n        assertEquals(cr.getNumberOfErrors(), 3);\n    }\n\n    @Test\n    public void issue51() throws ScanException, PolicyException {\n        /* issue #51 - offsite URLs with () are found to be invalid */\n        String s = \"<a href='http://subdomain.domain/(S(ke0lpq54bw0fvp53a10e1a45))/MyPage.aspx'>test</a>\";\n        CleanResults cr = as.scan(s, policy, AntiSamy.DOM);\n\n        assertEquals(cr.getNumberOfErrors(), 0);\n\n        cr = as.scan(s, policy, AntiSamy.SAX);\n        assertEquals(cr.getNumberOfErrors(), 0);\n    }\n\n    @Test\n    public void issue56() throws ScanException, PolicyException {\n        /* issue #56 - unnecessary spaces */\n\n        String s = \"<SPAN style='font-weight: bold;'>Hello World!</SPAN>\";\n        String expected = \"<span style=\\\"font-weight: bold;\\\">Hello World!</span>\";\n\n        CleanResults cr = as.scan(s, policy, AntiSamy.DOM);\n        String s2 = cr.getCleanHTML();\n\n        assertEquals(expected, s2);\n\n        cr = as.scan(s, policy, AntiSamy.SAX);\n        s2 = cr.getCleanHTML();\n\n        assertEquals(expected, s2);\n    }\n\n    @Test\n    public void issue58() throws ScanException, PolicyException {\n        /* issue #58 - input not in list of allowed-to-be-empty tags */\n        String s = \"tgdan <input/> g  h\";\n        CleanResults cr = as.scan(s, policy, AntiSamy.DOM);\n        assertTrue(cr.getErrorMessages().size() == 0);\n\n        cr = as.scan(s, policy, AntiSamy.SAX);\n        assertTrue(cr.getErrorMessages().size() == 0);\n    }\n\n    @Test\n    public void issue61() throws ScanException, PolicyException {\n        /* issue #61 - input has newline appended if ends with an accepted tag */\n        String dirtyInput = \"blah <b>blah</b>.\";\n        Policy revised = policy.cloneWithDirective(Policy.FORMAT_OUTPUT, \"false\");\n        CleanResults cr = as.scan(dirtyInput, revised, AntiSamy.DOM);\n        assertEquals(dirtyInput, cr.getCleanHTML());\n\n        cr = as.scan(dirtyInput, revised, AntiSamy.SAX);\n        assertEquals(dirtyInput, cr.getCleanHTML());\n    }\n\n    @Test\n    public void issue69() throws ScanException, PolicyException {\n\n        /* issue #69 - char attribute should allow single char or entity ref */\n\n        String s = \"<table><tr><td char='.'>test</td></tr></table>\";\n        CleanResults crDom = as.scan(s, policy, AntiSamy.DOM);\n        CleanResults crSax = as.scan(s, policy, AntiSamy.SAX);\n        String domValue = crDom.getCleanHTML();\n        String saxValue = crSax.getCleanHTML();\n        assertTrue(domValue.contains(\"char\"));\n        assertTrue(saxValue.contains(\"char\"));\n\n        s = \"<table><tr><td char='..'>test</td></tr></table>\";\n        assertTrue(!as.scan(s, policy, AntiSamy.DOM).getCleanHTML().contains(\"char\"));\n        assertTrue(!as.scan(s, policy, AntiSamy.SAX).getCleanHTML().contains(\"char\"));\n\n        s = \"<table><tr><td char='&quot;'>test</td></tr></table>\";\n        assertTrue(as.scan(s, policy, AntiSamy.DOM).getCleanHTML().contains(\"char\"));\n        assertTrue(as.scan(s, policy, AntiSamy.SAX).getCleanHTML().contains(\"char\"));\n\n        s = \"<table><tr><td char='&quot;a'>test</td></tr></table>\";\n        assertTrue(!as.scan(s, policy, AntiSamy.DOM).getCleanHTML().contains(\"char\"));\n        assertTrue(!as.scan(s, policy, AntiSamy.SAX).getCleanHTML().contains(\"char\"));\n\n        s = \"<table><tr><td char='&quot;&amp;'>test</td></tr></table>\";\n        assertTrue(!as.scan(s, policy, AntiSamy.DOM).getCleanHTML().contains(\"char\"));\n        assertTrue(!as.scan(s, policy, AntiSamy.SAX).getCleanHTML().contains(\"char\"));\n    }\n\n    @Test\n    public void CDATAByPass() throws ScanException, PolicyException {\n        String malInput = \"<![CDATA[]><script>alert(1)</script>]]>\";\n        CleanResults crd = as.scan(malInput, policy, AntiSamy.DOM);\n        CleanResults crs = as.scan(malInput, policy, AntiSamy.SAX);\n        String crDom = crd.getCleanHTML();\n        String crSax = crs.getCleanHTML();\n\n        assertTrue(crd.getErrorMessages().size() > 0);\n        assertTrue(crs.getErrorMessages().size() > 0);\n\n        assertTrue(crSax.contains(\"&lt;script\") && !crDom.contains(\"<script\"));\n        assertTrue(crDom.contains(\"&lt;script\") && !crDom.contains(\"<script\"));\n    }\n\n    @Test\n    public void literalLists() throws ScanException, PolicyException {\n\n        /* this test is for confirming literal-lists work as\n         * advertised. it turned out to be an invalid / non-\n         * reproducible bug report but the test seemed useful\n         * enough to keep.\n         */\n        String malInput = \"hello<p align='invalid'>world</p>\";\n\n        CleanResults crd = as.scan(malInput, policy, AntiSamy.DOM);\n        String crDom = crd.getCleanHTML();\n        CleanResults crs = as.scan(malInput, policy, AntiSamy.SAX);\n        String crSax = crs.getCleanHTML();\n\n        assertTrue(!crSax.contains(\"invalid\"));\n        assertTrue(!crDom.contains(\"invalid\"));\n\n        assertTrue(crd.getErrorMessages().size() == 1);\n        assertTrue(crs.getErrorMessages().size() == 1);\n\n        String goodInput = \"hello<p align='left'>world</p>\";\n        crDom = as.scan(goodInput, policy, AntiSamy.DOM).getCleanHTML();\n        crSax = as.scan(goodInput, policy, AntiSamy.SAX).getCleanHTML();\n\n        assertTrue(crSax.contains(\"left\"));\n        assertTrue(crDom.contains(\"left\"));\n    }\n\n    @Test\n    public void stackExhaustion() throws ScanException, PolicyException {\n        /*\n        * Test Julian Cohen's stack exhaustion bug.\n        */\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 249; i++) {\n            sb.append(\"<div>\");\n        }\n        /*\n        * First, make sure this attack is useless against the\n        * SAX parser.\n        */\n        as.scan(sb.toString(), policy, AntiSamy.SAX);\n\n        /*\n        * Scan this really deep tree (depth=249, 1 less than the\n        * max) and make sure it doesn't blow up.\n        */\n\n        CleanResults crd = as.scan(sb.toString(), policy, AntiSamy.DOM);\n\n        String crDom = crd.getCleanHTML();\n        assertTrue(crDom.length() != 0);\n        /*\n        * Now push it over the limit to 251 and make sure we blow\n        * up safely.\n        */\n        sb.append(\"<div><div>\"); // this makes 251\n\n        try {\n            as.scan(sb.toString(), policy, AntiSamy.DOM);\n            fail(\"DOM depth exceeded max - should've errored\");\n        } catch (ScanException e) {\n            // An error is expected. Pass\n        }\n    }\n\n    @Test\n    public void issue107() throws ScanException, PolicyException {\n        StringBuilder sb = new StringBuilder();\n\n        /*\n         * #107 - erroneous newlines appearing? couldn't reproduce this\n         * error but the test seems worthy of keeping.\n         */\n        String nl = \"\\n\";\n\n        String header = \"<h1>Header</h1>\";\n        String para = \"<p>Paragraph</p>\";\n        sb.append(header);\n        sb.append(nl);\n        sb.append(para);\n\n        String html = sb.toString();\n\n        String crDom = as.scan(html, policy, AntiSamy.DOM).getCleanHTML();\n        String crSax = as.scan(html, policy, AntiSamy.SAX).getCleanHTML();\n\n        /* Make sure only 1 newline appears */\n        assertTrue(crDom.lastIndexOf(nl) == crDom.indexOf(nl));\n        assertTrue(crSax.lastIndexOf(nl) == crSax.indexOf(nl));\n\n        int expectedLoc = header.length();\n        int actualLoc = crSax.indexOf(nl);\n        assertTrue(expectedLoc == actualLoc);\n\n        actualLoc = crDom.indexOf(nl);\n        // account for line separator length difference across OSes.\n        assertTrue(expectedLoc == actualLoc || expectedLoc == actualLoc + 1);\n    }\n\n    @Test\n    public void issue112() throws ScanException, PolicyException {\n        TestPolicy revised = policy.cloneWithDirective(Policy.PRESERVE_COMMENTS, \"true\").cloneWithDirective(Policy.PRESERVE_SPACE, \"true\").cloneWithDirective(Policy.FORMAT_OUTPUT, \"false\");\n\n        /*\n        * #112 - empty tag becomes self closing\n        */\n\n        String html = \"text <strong></strong> text <strong><em></em></strong> text\";\n\n        String crDom = as.scan(html, revised, AntiSamy.DOM).getCleanHTML();\n        String crSax = as.scan(html, revised, AntiSamy.SAX).getCleanHTML();\n\n        assertTrue(!crDom.contains(\"<strong />\") && !crDom.contains(\"<strong/>\"));\n        assertTrue(!crSax.contains(\"<strong />\") && !crSax.contains(\"<strong/>\"));\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<html><head><title>foobar</title></head><body>\");\n        sb.append(\"<img src=\\\"http://foobar.com/pic.gif\\\" /></body></html>\");\n\n        html = sb.toString();\n\n        Policy aTrue = revised.cloneWithDirective(Policy.USE_XHTML, \"true\");\n        crDom = as.scan(html, aTrue, AntiSamy.DOM).getCleanHTML();\n        crSax = as.scan(html, aTrue, AntiSamy.SAX).getCleanHTML();\n\n        assertTrue(html.equals(crDom));\n        assertTrue(html.equals(crSax));\n    }\n\n\n    @Test\n    public void nestedCdataAttacks() throws ScanException, PolicyException {\n\n        /*\n        * Testing for nested CDATA attacks against the SAX parser.\n        */\n\n        String html = \"<![CDATA[]><script>alert(1)</script><![CDATA[]>]]><script>alert(2)</script>>]]>\";\n        String crDom = as.scan(html, policy, AntiSamy.DOM).getCleanHTML();\n        String crSax = as.scan(html, policy, AntiSamy.SAX).getCleanHTML();\n        assertTrue(!crDom.contains(\"<script>\"));\n        assertTrue(!crSax.contains(\"<script>\"));\n    }\n\n    @Test\n    public void issue101InternationalCharacterSupport() throws ScanException, PolicyException {\n        Policy revised = policy.cloneWithDirective(Policy.ENTITY_ENCODE_INTL_CHARS, \"false\");\n\n        String html = \"<b>letter 'a' with umlaut: \\u00e4\";\n        String crDom = as.scan(html, revised, AntiSamy.DOM).getCleanHTML();\n        String crSax = as.scan(html, revised, AntiSamy.SAX).getCleanHTML();\n        assertTrue(crDom.contains(\"\\u00e4\"));\n        assertTrue(crSax.contains(\"\\u00e4\"));\n\n        Policy revised2 = policy.cloneWithDirective(Policy.USE_XHTML, \"false\").cloneWithDirective(Policy.ENTITY_ENCODE_INTL_CHARS, \"true\");\n        crDom = as.scan(html, revised2, AntiSamy.DOM).getCleanHTML();\n        crSax = as.scan(html, revised2, AntiSamy.SAX).getCleanHTML();\n        assertTrue(!crDom.contains(\"\\u00e4\"));\n        assertTrue(crDom.contains(\"&auml;\"));\n        assertTrue(!crSax.contains(\"\\u00e4\"));\n        assertTrue(crSax.contains(\"&auml;\"));\n\n        Policy revised3 = policy.cloneWithDirective(Policy.USE_XHTML, \"true\").cloneWithDirective(Policy.ENTITY_ENCODE_INTL_CHARS, \"true\");\n        crDom = as.scan(html, revised3, AntiSamy.DOM).getCleanHTML();\n        crSax = as.scan(html, revised3, AntiSamy.SAX).getCleanHTML();\n        assertTrue(!crDom.contains(\"\\u00e4\"));\n        assertTrue(crDom.contains(\"&auml;\"));\n        assertTrue(!crSax.contains(\"\\u00e4\"));\n        assertTrue(crSax.contains(\"&auml;\"));\n    }\n\n    @Test\n    public void iframeAsReportedByOndrej() throws ScanException, PolicyException {\n        String html = \"<iframe></iframe>\";\n\n        Tag tag = new Tag(\"iframe\", Collections.<String, Attribute>emptyMap(), Policy.ACTION_VALIDATE);\n        Policy revised = policy.addTagRule(tag);\n\n        String crDom = as.scan(html, revised, AntiSamy.DOM).getCleanHTML();\n        String crSax = as.scan(html, revised, AntiSamy.SAX).getCleanHTML();\n\n        assertTrue(html.equals(crDom));\n        assertTrue(html.equals(crSax));\n    }\n\n    /*\n\t * Tests cases dealing with nofollowAnchors directive. Assumes anchor tags\n\t * have an action set to \"validate\" (may be implicit) in the policy file.\n\t */\n    @Test\n    public void nofollowAnchors() throws ScanException, PolicyException {\n\n        // if we have activated nofollowAnchors\n        Policy revisedPolicy = policy.cloneWithDirective(Policy.ANCHORS_NOFOLLOW, \"true\");\n\n        // adds when not present\n        assertTrue(as.scan(\"<a href=\\\"blah\\\">link</a>\", revisedPolicy, AntiSamy.DOM).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n        assertTrue(as.scan(\"<a href=\\\"blah\\\">link</a>\", revisedPolicy, AntiSamy.SAX).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n\n        // adds properly even with bad attr\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" bad=\\\"true\\\">link</a>\", revisedPolicy, AntiSamy.DOM).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" bad=\\\"true\\\">link</a>\", revisedPolicy, AntiSamy.SAX).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n\n        // rel with bad value gets corrected\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"blh\\\">link</a>\", revisedPolicy, AntiSamy.DOM).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"blh\\\">link</a>\", revisedPolicy, AntiSamy.SAX).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n\n        // correct attribute doesn't get messed with\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n\n        // if two correct attributes, only one remaining after scan\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\" rel=\\\"nofollow\\\">link</a>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\" rel=\\\"nofollow\\\">link</a>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n\n        // test if value is off - does it add?\n        assertTrue(!as.scan(\"a href=\\\"blah\\\">link</a>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"nofollow\"));\n        assertTrue(!as.scan(\"a href=\\\"blah\\\">link</a>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"nofollow\"));\n    }\n\n    @Test\n    public void validateParamAsEmbed() throws ScanException, PolicyException {\n        // activate policy setting for this test\n        Policy revised = policy.cloneWithDirective(Policy.VALIDATE_PARAM_AS_EMBED, \"true\").cloneWithDirective(Policy.FORMAT_OUTPUT, \"false\").cloneWithDirective(Policy.USE_XHTML, \"true\");\n\n        // let's start with a YouTube embed\n        String input = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&hl=en&fs=1&\\\"></param><param name=\\\"allowFullScreen\\\" value=\\\"true\\\"></param><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\"></param><embed src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&hl=en&fs=1&\\\" type=\\\"application/x-shockwave-flash\\\" allowscriptaccess=\\\"always\\\" allowfullscreen=\\\"true\\\" width=\\\"560\\\" height=\\\"340\\\"></embed></object>\";\n        String expectedOutput = \"<object height=\\\"340\\\" width=\\\"560\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" /><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /><embed allowfullscreen=\\\"true\\\" allowscriptaccess=\\\"always\\\" height=\\\"340\\\" src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" type=\\\"application/x-shockwave-flash\\\" width=\\\"560\\\" /></object>\";\n        CleanResults cr = as.scan(input, revised, AntiSamy.DOM);\n        assertThat(cr.getCleanHTML(), containsString(expectedOutput));\n\n        String saxExpectedOutput = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" /><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /><embed src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" type=\\\"application/x-shockwave-flash\\\" allowscriptaccess=\\\"always\\\" allowfullscreen=\\\"true\\\" width=\\\"560\\\" height=\\\"340\\\" /></object>\";\n        cr = as.scan(input, revised, AntiSamy.SAX);\n        assertThat(cr.getCleanHTML(), equalTo(saxExpectedOutput));\n\n        // now what if someone sticks malicious URL in the value of the\n        // value attribute in the param tag? remove that param tag\n        input = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"movie\\\" value=\\\"http://supermaliciouscode.com/badstuff.swf\\\"></param><param name=\\\"allowFullScreen\\\" value=\\\"true\\\"></param><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\"></param><embed src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&hl=en&fs=1&\\\" type=\\\"application/x-shockwave-flash\\\" allowscriptaccess=\\\"always\\\" allowfullscreen=\\\"true\\\" width=\\\"560\\\" height=\\\"340\\\"></embed></object>\";\n        expectedOutput = \"<object height=\\\"340\\\" width=\\\"560\\\"><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /><embed allowfullscreen=\\\"true\\\" allowscriptaccess=\\\"always\\\" height=\\\"340\\\" src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" type=\\\"application/x-shockwave-flash\\\" width=\\\"560\\\" /></object>\";\n        saxExpectedOutput = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /><embed src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" type=\\\"application/x-shockwave-flash\\\" allowscriptaccess=\\\"always\\\" allowfullscreen=\\\"true\\\" width=\\\"560\\\" height=\\\"340\\\" /></object>\";\n        cr = as.scan(input, revised, AntiSamy.DOM);\n        assertThat(cr.getCleanHTML(), containsString(expectedOutput));\n\n        cr = as.scan(input, revised, AntiSamy.SAX);\n        assertThat(cr.getCleanHTML(), equalTo(saxExpectedOutput));\n\n        // now what if someone sticks malicious URL in the value of the src\n        // attribute in the embed tag? remove that embed tag\n        input = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&hl=en&fs=1&\\\"></param><param name=\\\"allowFullScreen\\\" value=\\\"true\\\"></param><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\"></param><embed src=\\\"http://hereswhereikeepbadcode.com/ohnoscary.swf\\\" type=\\\"application/x-shockwave-flash\\\" allowscriptaccess=\\\"always\\\" allowfullscreen=\\\"true\\\" width=\\\"560\\\" height=\\\"340\\\"></embed></object>\";\n        expectedOutput = \"<object height=\\\"340\\\" width=\\\"560\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" /><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /></object>\";\n        saxExpectedOutput = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" /><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /></object>\";\n\n        cr = as.scan(input, revised, AntiSamy.DOM);\n        assertThat(cr.getCleanHTML(), containsString(expectedOutput));\n        CleanResults scan = as.scan(input, revised, AntiSamy.SAX);\n        assertThat(scan.getCleanHTML(), equalTo(saxExpectedOutput));\n    }\n\n    @Test\n    public void compareSpeedsShortStrings() throws IOException, ScanException, PolicyException {\n\n        double totalDomTime = 0;\n        double totalSaxTime = 0;\n\n        int testReps = 1000;\n\n        String html = \"<body> hey you <img/> out there on your own </body>\";\n\n        for (int j = 0; j < testReps; j++) {\n            totalDomTime += as.scan(html, policy, AntiSamy.DOM).getScanTime();\n            totalSaxTime += as.scan(html, policy, AntiSamy.SAX).getScanTime();\n        }\n\n        System.out.println(\"Total DOM time short string: \" + totalDomTime);\n        System.out.println(\"Total SAX time short string: \" + totalSaxTime);\n    }\n\n    @Test\n    public void profileDom() throws IOException, ScanException, PolicyException {\n        runProfiledTest(AntiSamy.DOM);\n    }\n\n    @Test\n    public void profileSax() throws IOException, ScanException, PolicyException {\n        runProfiledTest(AntiSamy.SAX);\n    }\n\n    private void runProfiledTest(int scanType) throws ScanException, PolicyException {\n        double totalDomTime;\n\n        warmup(scanType);\n\n        int testReps = 9999;\n\n        String html = \"<body> hey you <img/> out there on your own </body>\";\n\n        Double each = 0D;\n        int repeats = 10;\n        for (int i = 0; i < repeats; i++) {\n            totalDomTime = 0;\n            for (int j = 0; j < testReps; j++) {\n                totalDomTime += as.scan(html, policy, scanType).getScanTime();\n            }\n            each = each + totalDomTime;\n            System.out.println(\"Total \" + (scanType == AntiSamy.DOM ? \"DOM\" : \"SAX\") + \" time 9999 reps short string: \" + totalDomTime);\n        }\n        System.out.println(\"Average time: \" + (each / repeats));\n    }\n\n    private void warmup(int scanType) throws ScanException, PolicyException {\n        int warmupReps = 15000;\n\n        String html = \"<body> hey you <img/> out there on your own </body>\";\n\n        for (int j = 0; j < warmupReps; j++) {\n            as.scan(html, policy, scanType).getScanTime();\n        }\n    }\n\n    @Test\n    public void comparePatternSpeed() throws IOException, ScanException, PolicyException {\n\n        final Pattern invalidXmlCharacters =\n                Pattern.compile(\"[\\\\u0000-\\\\u001F\\\\uD800-\\\\uDFFF\\\\uFFFE-\\\\uFFFF&&[^\\\\u0009\\\\u000A\\\\u000D]]\");\n\n        int testReps = 10000;\n\n        String html = \"<body> hey you <img/> out there on your own </body>\";\n\n        String s = null;\n        //long start = System.currentTimeMillis();\n        for (int j = 0; j < testReps; j++) {\n            s = invalidXmlCharacters.matcher(html).replaceAll(\"\");\n        }\n        //long total = System.currentTimeMillis() - start;\n\n        //start = System.currentTimeMillis();\n        Matcher matcher;\n        for (int j = 0; j < testReps; j++) {\n            matcher = invalidXmlCharacters.matcher(html);\n            if (matcher.matches()) {\n                s = matcher.replaceAll(\"\");\n            }\n        }\n        //long total2 = System.currentTimeMillis() - start;\n\n        assertNotNull(s);\n        //System.out.println(\"replaceAllDirect \" + total);\n        //System.out.println(\"match then replace: \" + total2);\n    }\n\n    @Test\n    public void testOnsiteRegex() throws ScanException, PolicyException {\n    \tassertIsGoodOnsiteURL(\"foo\");\n    \tassertIsGoodOnsiteURL(\"/foo/bar\");\n    \tassertIsGoodOnsiteURL(\"../../di.cgi?foo&amp;3D~\");\n    \tassertIsGoodOnsiteURL(\"/foo/bar/1/sdf;jsessiond=1f1f12312_123123\");\n    }\n    \n    void assertIsGoodOnsiteURL(String url) throws ScanException, PolicyException {\n    \tString html = as.scan(\"<a href=\\\"\" + url + \"\\\">X</a>\", policy, AntiSamy.DOM).getCleanHTML();\n        assertThat(html, containsString(\"href=\\\"\"));\n\t}\n    \n\t@Test\n    public void issue10() throws ScanException, PolicyException {\n    \tassertFalse(as.scan(\"<a href=\\\"javascript&colon;alert&lpar;1&rpar;\\\">X</a>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertFalse(as.scan(\"<a href=\\\"javascript&colon;alert&lpar;1&rpar;\\\">X</a>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n    }\n    \n    @Test\n    public void issue147() throws ScanException, PolicyException {\n        URL url = getClass().getResource(\"/antisamy-tinymce.xml\");\n\n        Policy pol = Policy.getInstance(url);\n        as.scan(\"<table><tr><td></td></tr></table>\", pol, AntiSamy.DOM);\n    }\n\n    @Test\n    public void issue75() throws ScanException, PolicyException {\n        URL url = getClass().getResource(\"/antisamy-tinymce.xml\");\n        Policy pol = Policy.getInstance(url);\n        as.scan(\"<script src=\\\"<. \\\">\\\"></script>\", pol, AntiSamy.DOM);\n        as.scan(\"<script src=\\\"<. \\\">\\\"></script>\", pol, AntiSamy.SAX);\n    }\n\n    @Test\n    public void issue144() throws ScanException, PolicyException {\n        String pinata = \"pi\\u00f1ata\";\n        CleanResults results = as.scan(pinata, policy, AntiSamy.DOM);\n        String cleanHTML = results.getCleanHTML();\n        assertEquals(pinata, cleanHTML);\n    }\n\n    @Test\n    public void testWhitespaceNotBeingMangled() throws ScanException, PolicyException {\n        String test = \"<select name=\\\"name\\\"><option value=\\\"Something\\\">Something</select>\";\n        String expected = \"<select name=\\\"name\\\"><option value=\\\"Something\\\">Something</option></select>\";\n        Policy preserveSpace = policy.cloneWithDirective( Policy.PRESERVE_SPACE, \"true\" );\n        CleanResults preserveSpaceResults = as.scan(test, preserveSpace, AntiSamy.SAX);\n        assertEquals( expected, preserveSpaceResults.getCleanHTML() );\n    }\n\n    @Test\n    public void testDataTag159() throws ScanException, PolicyException {\n        /* issue #159 - allow dynamic HTML5 data-* attribute */\n        String good = \"<p data-tag=\\\"abc123\\\">Hello World!</p>\";\n        String bad = \"<p dat-tag=\\\"abc123\\\">Hello World!</p>\";\n        String goodExpected = \"<p data-tag=\\\"abc123\\\">Hello World!</p>\";\n        String badExpected = \"<p>Hello World!</p>\";\n        // test good attribute \"data-\"\n        CleanResults cr = as.scan(good, policy, AntiSamy.SAX);\n        String s = cr.getCleanHTML();\n        assertEquals(goodExpected, s);\n        cr = as.scan(good, policy, AntiSamy.DOM);\n        s = cr.getCleanHTML();\n        assertEquals(goodExpected, s);\n\n        // test bad attribute \"dat-\"\n        cr = as.scan(bad, policy, AntiSamy.SAX);\n        s = cr.getCleanHTML();\n        assertEquals(badExpected, s);\n        cr = as.scan(bad, policy, AntiSamy.DOM);\n        s = cr.getCleanHTML();\n        assertEquals(badExpected, s);\n    }\n\n    @Test\n    public void testXSSInAntiSamy151() throws ScanException, PolicyException {\n        String test = \"<bogus>whatever</bogus><img src=\\\"https://ssl.gstatic.com/codesite/ph/images/defaultlogo.png\\\" \"\n            + \"onmouseover=\\\"alert('xss')\\\">\";\n        CleanResults results_sax = as.scan(test, policy, AntiSamy.SAX);\n        CleanResults results_dom = as.scan(test, policy, AntiSamy.DOM);\n\n        assertEquals( results_sax.getCleanHTML(), results_dom.getCleanHTML());\n        assertEquals(\"whatever<img src=\\\"https://ssl.gstatic.com/codesite/ph/images/defaultlogo.png\\\" />\", results_dom.getCleanHTML());\n    }\n\n    @Test\n    public void testAnotherXSS() throws ScanException, PolicyException {\n        String test = \"<a href=\\\"http://example.com\\\"&amp;/onclick=alert(9)>foo</a>\";\n        CleanResults results_sax = as.scan(test, policy, AntiSamy.SAX);\n        CleanResults results_dom = as.scan(test, policy, AntiSamy.DOM);\n\n        assertEquals( results_sax.getCleanHTML(), results_dom.getCleanHTML());\n        assertEquals(\"<a href=\\\"http://example.com\\\" rel=\\\"nofollow\\\">foo</a>\", results_dom.getCleanHTML());\n    }\n\n    @Test\n    public void testIssue2() throws ScanException, PolicyException {\n        String test = \"<style onload=alert(1)>h1 {color:red;}</style>\";\n        assertThat(as.scan(test, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"alert\")));\n        assertThat(as.scan(test, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"alert\")));\n    }\n    \n    /*\n     * Mailing list user sent this in. Didn't work, but good test to leave in.\n     */\n    @Test\n    public void testUnknownTags() throws ScanException, PolicyException {\n        String test = \"<%/onmouseover=prompt(1)>\";\n        CleanResults saxResults = as.scan(test, policy, AntiSamy.SAX);\n        CleanResults domResults = as.scan(test, policy, AntiSamy.DOM);\n        assertThat(saxResults.getCleanHTML(), not(containsString(\"<%/\")));\n        assertThat(domResults.getCleanHTML(), not(containsString(\"<%/\")));\n    }\n    \n    @Test\n    public void testStreamScan() throws ScanException, PolicyException, InterruptedException, ExecutionException {\n        String testImgSrcURL = \"<img src=\\\"https://ssl.gstatic.com/codesite/ph/images/defaultlogo.png\\\" \";\n        Reader reader = new StringReader(\"<bogus>whatever</bogus>\" + testImgSrcURL + \"onmouseover=\\\"alert('xss')\\\">\");\n        Writer writer = new StringWriter();\n        as.scan(reader, writer, policy);\n        String cleanHtml = writer.toString().trim();\n        assertEquals(\"whatever\" + testImgSrcURL + \"/>\", cleanHtml);\n    }\n    \n    @Test\n    public void testGithubIssue23() throws ScanException, PolicyException {\n    \t\n        // Antisamy Stripping nested lists and tables\n    \tString test23 = \"<ul><li>one</li><li>two</li><li>three<ul><li>a</li><li>b</li></ul></li></ul>\";\n    \t// Issue claims you end up with this:\n    \t//    <ul><li>one</li><li>two</li><li>three<ul></ul></li><li>a</li><li>b</li></ul>\n    \t// Meaning the <li>a</li><li>b</li> elements were moved outside of the nested <ul> list they were in\n    \t\n    \t// The a.replaceAll(\"\\\\s\",\"\") is used to strip out all the whitespace in the CleanHTML so we can successfully find\n    \t// what we expect to find.\n        assertThat(as.scan(test23, policy, AntiSamy.SAX).getCleanHTML().replaceAll(\"\\\\s\",\"\"), containsString(\"<ul><li>a</li>\"));\n        assertThat(as.scan(test23, policy, AntiSamy.DOM).getCleanHTML().replaceAll(\"\\\\s\",\"\"), containsString(\"<ul><li>a</li>\"));\n        \n        // However, the test above can't replicate this misbehavior.\n    }\n    \n    // TODO: This issue is a valid enhancement request we plan to implement in the future.\n    // Commenting out the test case for now so test failures aren't included in a released version of AntiSamy.\n/*    @Test\n    public void testGithubIssue24() throws ScanException, PolicyException {\n    \t\n        // if we have onUnknownTag set to encode, it still strips out the @ and everything else after the it\n    \t// DOM Parser actually rips out the entire <name@mail.com> value even with onUnknownTag set\n        TestPolicy revisedPolicy = policy.cloneWithDirective(\"onUnknownTag\", \"encode\");\n\n    \tString email = \"name@mail.com\";\n        String test24 = \"firstname,lastname<\" + email + \">\";\n        assertThat(as.scan(test24, revisedPolicy, AntiSamy.SAX).getCleanHTML(), containsString(email));\n        assertThat(as.scan(test24, revisedPolicy, AntiSamy.DOM).getCleanHTML(), containsString(email));\n    }\n*/\n    @Test\n    public void testGithubIssue26() throws ScanException, PolicyException {\n        // Potential bypass (False positive)\n    \tString test26 = \"&#x22;&#x3E;&#x3C;&#x69;&#x6D;&#x67;&#x20;&#x73;&#x72;&#x63;&#x3D;&#x61;&#x20;&#x6F;&#x6E;&#x65;&#x72;&#x72;&#x6F;&#x72;&#x3D;&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;&#x3E;\";\n    \t// Issue claims you end up with this:\n    \t//   ><img src=a onerror=alert(1)>\n    \t\n        assertThat(as.scan(test26, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"<img src=a onerror=alert(1)>\")));\n        assertThat(as.scan(test26, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"<img src=a onerror=alert(1)>\")));\n        \n        // But you actually end up with this: &quot;&gt;&lt;img src=a onerror=alert(1)&gt; -- Which is as expected\n    }\n    \n    @Test\n    public void testGithubIssue27() throws ScanException, PolicyException {\n    \t// This test doesn't cause an ArrayIndexOutOfBoundsException, as reported in this issue even though it\n    \t// replicates the test as described.\n        String test27 = \"my &test\";\n        assertThat(as.scan(test27, policy, AntiSamy.DOM).getCleanHTML(), containsString(\"test\"));\n        assertThat(as.scan(test27, policy, AntiSamy.SAX).getCleanHTML(), containsString(\"test\"));\n    }\n\nstatic final String test33 = \"<html>\\n\"\n    \t  + \"<head>\\n\"\n    \t  + \"  <title>Test</title>\\n\"\n    \t  + \"</head>\\n\"\n    \t  + \"<body>\\n\"\n    \t  + \"  <h1>Tricky Encoding</h1>\\n\"\n    \t  + \"  <h2>NOT Sanitized by AntiSamy</h2>\\n\"\n    \t  + \"  <ol>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#00058x=alert,x%281%29\\\">X&#00058;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#00058y=alert,y%281%29\\\">X&#00058;y</a></li>\\n\"\n\n    \t  + \"    <li><a href=\\\"javascript&#58x=alert,x%281%29\\\">X&#58;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#58y=alert,y%281%29\\\">X&#58;y</a></li>\\n\"\n\n    \t  + \"    <li><a href=\\\"javascript&#x0003Ax=alert,x%281%29\\\">X&#x0003A;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#x0003Ay=alert,y%281%29\\\">X&#x0003A;y</a></li>\\n\"\n\n    \t  + \"    <li><a href=\\\"javascript&#x3Ax=alert,x%281%29\\\">X&#x3A;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#x3Ay=alert,y%281%29\\\">X&#x3A;y</a></li>\\n\"\n    \t  + \"  </ol>\\n\"\n    \t  + \"  <h1>Tricky Encoding with Ampersand Encoding</h1>\\n\"\n    \t  + \"  <p>AntiSamy turns harmless payload into XSS by just decoding the encoded ampersands in the href attribute</a>\\n\"\n    \t  + \"  <ol>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&amp;#x3Ax=alert,x%281%29\\\">X&amp;#x3A;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&AMP;#x3Ax=alert,x%281%29\\\">X&AMP;#x3A;x</a></li>\\n\"\n\n    \t  + \"    <li><a href=\\\"javascript&#38;#x3Ax=alert,x%281%29\\\">X&#38;#x3A;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#00038;#x3Ax=alert,x%281%29\\\">X&#00038;#x3A;x</a></li>\\n\"\n\n    \t  + \"    <li><a href=\\\"javascript&#x26;#x3Ax=alert,x%281%29\\\">X&#x26;#x3A;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#x00026;#x3Ax=alert,x%281%29\\\">X&#x00026;#x3A;x</a></li>\\n\"\n    \t  + \"  </ol>\\n\"\n    \t  + \"  <p><a href=\\\"javascript&#x3Ax=alert,x%281%29\\\">Original without ampersand encoding</a></p>\\n\"\n    \t  + \"</body>\\n\"\n    \t  + \"</html>\";\n    \t\t\t\n    @Test\n    public void testGithubIssue33() throws ScanException, PolicyException {\n        \t\n        // Potential bypass\n\n        // Issue claims you end up with this:\n        //   javascript:x=alert and other similar problems (javascript&#00058x=alert,x%281%29) but you don't.\n        //   So issue is a false positive and has been closed.\n        //System.out.println(as.scan(test33, policy, AntiSamy.SAX).getCleanHTML());\n\n        assertThat(as.scan(test33, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"javascript&#00058x=alert,x%281%29\")));\n        assertThat(as.scan(test33, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"javascript&#00058x=alert,x%281%29\")));\n    }\n    \n    // TODO: This issue is a valid enhancement request. We are trying to decide whether to implement in the future.\n    // Commenting out the test case for now so test failures aren't included in a released version of AntiSamy.\n/*\n    @Test\n    public void testGithubIssue34a() throws ScanException, PolicyException {\n\n    \t// bypass stripNonValidXMLCharacters\n    \t// Issue indicates: \"<div>Hello\\\\uD83D\\\\uDC95</div>\" should be sanitized to: \"<div>Hello</div>\"\n    \t\n        String test34a = \"<div>Hello\\uD83D\\uDC95</div>\";\n        assertEquals(\"<div>Hello</div>\", as.scan(test34a, policy, AntiSamy.SAX).getCleanHTML());\n        assertEquals(\"<div>Hello</div>\", as.scan(test34a, policy, AntiSamy.DOM).getCleanHTML());\n    }\n\n    @Test\n    public void testGithubIssue34b() throws ScanException, PolicyException {\n\n    \t// bypass stripNonValidXMLCharacters\n    \t// Issue indicates: \"<div>Hello\\\\uD83D\\\\uDC95</div>\" should be sanitized to: \"<div>Hello</div>\"\n    \t\n        String test34b = \"\\uD888\";\n        assertEquals(\"\", as.scan(test34b, policy, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"\", as.scan(test34b, policy, AntiSamy.SAX).getCleanHTML());\n    }\n*/\n\n    static final String test40 = \"<html>\\n\"\n          + \"<head>\\n\"\n          + \"  <title>Test</title>\\n\"\n          + \"</head>\\n\"\n          + \"<body>\\n\"\n          + \"  <h1>Tricky Encoding</h1>\\n\"\n          + \"  <h2>NOT Sanitized by AntiSamy</h2>\\n\"\n          + \"  <ol>\\n\"\n          + \"    <li><h3>svg onload=alert follows:</h3><svg onload=alert(1)//</li>\\n\"\n          + \"  </ol>\\n\"\n          + \"</body>\\n\"\n          + \"</html>\";\n\n    @Test\n    public void testGithubIssue40() throws ScanException, PolicyException {\n\n        // Concern is that: <svg onload=alert(1)//  does not get cleansed.\n        // Based on these test results, it does get cleaned so this issue is a false positive, so we closed it.\n\n        assertThat(as.scan(test40, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"<svg onload=alert(1)//\")));\n        //System.out.println(\"SAX parser: \" + as.scan(test40, policy, AntiSamy.SAX).getCleanHTML());\n        assertThat(as.scan(test40, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"<svg onload=alert(1)//\")));\n        //System.out.println(\"DOM parser: \" + as.scan(test40, policy, AntiSamy.DOM).getCleanHTML());\n    }\n\n    @Test\n    public void testGithubIssue48() throws ScanException, PolicyException {\n\n        // Concern is that onsiteURL regex is not safe for URLs that start with //.\n        // For example:  //evilactor.com?param=foo\n\n        final String phishingAttempt = \"<a href=\\\"//evilactor.com/stealinfo?a=xxx&b=xxx\\\"><span style=\\\"color:red;font-size:100px\\\">\"\n                + \"You must click me</span></a>\";\n\n        // Output: <a rel=\"nofollow\"><span style=\"color: red;font-size: 100.0px;\">You must click me</span></a>\n\n        assertThat(as.scan(phishingAttempt, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n        assertThat(as.scan(phishingAttempt, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n\n        // This ones never failed, they're just to prove a dangling markup attack on the following resulting HTML won't work.\n        // Less probable case (steal more tags):\n        final String danglingMarkup = \"<div>User input: \" +\n                \"<input type=\\\"text\\\" name=\\\"input\\\" value=\\\"\\\"><a href='//evilactor.com?\"+\n                \"\\\"> all this info wants to be stolen with <i>danlging markup attack</i>\" +\n                \" until a single quote to close is found'</div>\";\n\n        assertThat(as.scan(danglingMarkup, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n        assertThat(as.scan(danglingMarkup, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n\n        // More probable case (steal just an attribute):\n        //      HTML before attack: <input type=\"text\" name=\"input\" value=\"\" data-attribute-to-steal=\"some value\">\n        final String danglingMarkup2 = \"<div>User input: \" +\n                \"<input type=\\\"text\\\" name=\\\"input\\\" value=\\\"\\\" data-attribute-to-steal=\\\"some value\\\">\";\n        \n        assertThat(as.scan(danglingMarkup2, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n        assertThat(as.scan(danglingMarkup2, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n    }\n\n @Test\n    public void testGithubIssue62() {\n        // Concern is that when a processing instruction is at the root level, node removal gets messy and Null pointer exception arises.\n        // More test cases are added for PI removal.\n\n        try{\n            assertThat(as.scan(\"|<?ai aaa\", policy, AntiSamy.DOM).getCleanHTML(), is(\"|\"));\n            assertThat(as.scan(\"|<?ai aaa\", policy, AntiSamy.SAX).getCleanHTML(), is(\"|\"));\n\n            assertThat(as.scan(\"<div>|<?ai aaa\", policy, AntiSamy.DOM).getCleanHTML(), is(\"<div>|</div>\"));\n            assertThat(as.scan(\"<div>|<?ai aaa\", policy, AntiSamy.SAX).getCleanHTML(), is(\"<div>|</div>\"));\n\n            assertThat(as.scan(\"<div><?foo note=\\\"I am XML processing instruction. I wish to be excluded\\\" ?></div>\", policy, AntiSamy.DOM)\n                    .getCleanHTML(), not(containsString(\"<?foo\")));\n            assertThat(as.scan(\"<div><?foo note=\\\"I am XML processing instruction. I wish to be excluded\\\" ?></div>\", policy, AntiSamy.SAX)\n                    .getCleanHTML(), not(containsString(\"<?foo\")));\n\n            assertThat(as.scan(\"<?xml-stylesheet type=\\\"text/css\\\" href=\\\"style.css\\\"?>\", policy, AntiSamy.DOM).getCleanHTML(), is(\"\"));\n            assertThat(as.scan(\"<?xml-stylesheet type=\\\"text/css\\\" href=\\\"style.css\\\"?>\", policy, AntiSamy.SAX).getCleanHTML(), is(\"\"));\n\n        } catch (Exception exc) {\n            fail(exc.getMessage());\n        }\n    }\n\n    @Test\n    public void testGithubIssue81() throws ScanException, PolicyException {\n        // Concern is that \"!important\" is missing after processing CSS\n        assertThat(as.scan(\"<p style=\\\"color: red !important\\\">Some Text</p>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"!important\"));\n        assertThat(as.scan(\"<p style=\\\"color: red !important\\\">Some Text</p>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"!important\"));\n\n        // Just to check scan keeps working accordingly without \"!important\"\n        assertThat(as.scan(\"<p style=\\\"color: red\\\">Some Text</p>\", policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"!important\")));\n        assertThat(as.scan(\"<p style=\\\"color: red\\\">Some Text</p>\", policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"!important\")));\n    }\n\n    @Test\n    public void entityReferenceEncodedInHtmlAttribute() throws ScanException, PolicyException {\n        // Concern is that \"&\" is not being encoded and \"#00058\" was not being interpreted as \":\"\n        // so the validations based on regexp passed and a browser would load \"&:\" together.\n        // All this when not using the XHTML serializer.\n        Policy revised = policy.cloneWithDirective(\"useXHTML\",\"false\");\n        assertThat(as.scan(\"<p><a href=\\\"javascript&#00058x=1,%61%6c%65%72%74%28%22%62%6f%6f%6d%22%29\\\">xss</a></p>\", revised, AntiSamy.DOM).getCleanHTML(),\n                containsString(\"javascript&amp;#00058\"));\n        assertThat(as.scan(\"<p><a href=\\\"javascript&#00058x=1,%61%6c%65%72%74%28%22%62%6f%6f%6d%22%29\\\">xss</a></p>\", revised, AntiSamy.SAX).getCleanHTML(),\n                containsString(\"javascript&amp;#00058\"));\n    }\n\n    @Test\n    public void testGithubIssue99() throws ScanException, PolicyException {\n        // Test that the IANA subtags is not lost\n        assertThat(as.scan(\"<p lang=\\\"en-GB\\\">This paragraph is defined as British English.</p>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"lang=\\\"en-GB\\\"\"));\n        assertThat(as.scan(\"<p lang=\\\"en-GB\\\">This paragraph is defined as British English.</p>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"lang=\\\"en-GB\\\"\"));\n    }\n\n    @Test\n    public void testGithubIssue101() throws ScanException, PolicyException {\n        // Test that margin attribute is not removed when value has too much significant figures.\n        // Current behavior is that decimals like 0.0001 are internally translated to 1.0E-4, this\n        // is reflected on regex validation and actual output. The inconsistency is due to Batik CSS.\n        assertThat(as.scan(\"<p style=\\\"margin: 0.0001pt;\\\">Some text.</p>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"margin\"));\n        assertThat(as.scan(\"<p style=\\\"margin: 0.0001pt;\\\">Some text.</p>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"margin\"));\n        assertThat(as.scan(\"<p style=\\\"margin: 10000000pt;\\\">Some text.</p>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"margin\"));\n        assertThat(as.scan(\"<p style=\\\"margin: 10000000pt;\\\">Some text.</p>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"margin\"));\n        assertThat(as.scan(\"<p style=\\\"margin: 1.0E-4pt;\\\">Some text.</p>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"margin\"));\n        assertThat(as.scan(\"<p style=\\\"margin: 1.0E-4pt;\\\">Some text.</p>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"margin\"));\n        // When using exponential directly the \"e\" or \"E\" is internally considered as the start of\n        // the dimension/unit type. This creates inconsistencies that make the regex validation fail,\n        // also in cases like 1e4pt where \"e\" is considered as dimension instead of \"pt\".\n        assertThat(as.scan(\"<p style=\\\"margin: 1.0E+4pt;\\\">Some text.</p>\", policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"margin\")));\n        assertThat(as.scan(\"<p style=\\\"margin: 1.0E+4pt;\\\">Some text.</p>\", policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"margin\")));\n    }\n\n    @Test\n    public void testCSSUnits() throws ScanException, PolicyException {\n        String input = \"<div style=\\\"width:50vw;height:50vh;padding:1rpc;\\\">\\n\" +\n                \"\\t<p style=\\\"font-size:1.5ex;padding-left:1rem;padding-top:16px;\\\">Some text.</p>\\n\" +\n                \"</div>\";\n        CleanResults cr = as.scan(input, policy, AntiSamy.DOM);\n        assertThat(cr.getCleanHTML(), containsString(\"ex\"));\n        assertThat(cr.getCleanHTML(), containsString(\"px\"));\n        assertThat(cr.getCleanHTML(), containsString(\"rem\"));\n        assertThat(cr.getCleanHTML(), containsString(\"vw\"));\n        assertThat(cr.getCleanHTML(), containsString(\"vh\"));\n        assertThat(cr.getCleanHTML(), not(containsString(\"rpc\")));\n        cr = as.scan(input, policy, AntiSamy.SAX);\n        assertThat(cr.getCleanHTML(), containsString(\"ex\"));\n        assertThat(cr.getCleanHTML(), containsString(\"px\"));\n        assertThat(cr.getCleanHTML(), containsString(\"rem\"));\n        assertThat(cr.getCleanHTML(), containsString(\"vw\"));\n        assertThat(cr.getCleanHTML(), containsString(\"vh\"));\n        assertThat(cr.getCleanHTML(), not(containsString(\"rpc\")));\n    }\n\n    @Test\n    public void testXSSInsideSelectOptionStyle() throws ScanException, PolicyException {\n        // Tests for CVE-2021-42575, XSS nested into <select>+<option>+<style>\n\n        // Safe case, to test legit style\n        assertThat(as.scan(\"<select><option><style>h1{color:black;}</style></option></select>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"black\"));\n        assertThat(as.scan(\"<select><option><style>h1{color:black;}</style></option></select>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"black\"));\n        // Unsafe case\n        assertThat(as.scan(\"<select><option><style><script>alert(1)</script></style></option></select>\", policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"<script>\")));\n        assertThat(as.scan(\"<select><option><style><script>alert(1)</script></style></option></select>\", policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"<script>\")));\n    }\n\n    @Test\n    public void testImportedStylesParsing() throws ScanException, PolicyException {\n        // Test that imported style sheets can be parsed and order is correct\n        final String input = \"<style type='text/css'>\\n\" +\n                \"\\t@import url(https://raw.githubusercontent.com/nahsra/antisamy/main/src/test/resources/s/slashdot.org_files/classic.css);\\n\" +\n                \"\\t@import url(https://raw.githubusercontent.com/nahsra/antisamy/main/src/test/resources/s/slashdot.org_files/providers.css);\\n\" +\n                \"\\t.very-specific-antisamy {font: 15pt \\\"Arial\\\"; color: blue;}\\n\" +\n                \"</style>\";\n        Policy revised = policy.cloneWithDirective(Policy.EMBED_STYLESHEETS,\"true\").cloneWithDirective(Policy.FORMAT_OUTPUT,\"false\");\n        // Styles are imported\n        String cleanHtmlDOM = as.scan(input, revised, AntiSamy.DOM).getCleanHTML();\n        String cleanHtmlSAX = as.scan(input, revised, AntiSamy.SAX).getCleanHTML();\n        assertThat(cleanHtmlDOM, not(containsString(\"<![CDATA[/* */]]>\")));\n        assertThat(cleanHtmlSAX, not(containsString(\"<![CDATA[/* */]]>\")));\n        // Order is correct:\n        //  First import: grid_1 class\n        //  Second import: janrain-provider150-sprit class\n        //  Original styles: very-specific-antisamy class\n        final Pattern p = Pattern.compile(\".*?\\\\.grid_1.*?\\\\.janrain-provider150-sprit.*?\\\\.very-specific-antisamy.*?\", Pattern.DOTALL);\n        assertThat(cleanHtmlDOM, MatchesPattern.matchesPattern(p));\n        assertThat(cleanHtmlSAX, MatchesPattern.matchesPattern(p));\n\n        Policy revised2 = policy.cloneWithDirective(Policy.EMBED_STYLESHEETS,\"false\").cloneWithDirective(Policy.FORMAT_OUTPUT,\"false\");\n        // Styles are not imported\n        cleanHtmlDOM = as.scan(input, revised2, AntiSamy.DOM).getCleanHTML();\n        cleanHtmlSAX = as.scan(input, revised2, AntiSamy.SAX).getCleanHTML();\n        assertThat(cleanHtmlDOM, not(containsString(\".grid_1\")));\n        assertThat(cleanHtmlSAX, not(containsString(\".grid_1\")));\n        assertThat(cleanHtmlDOM, not(containsString(\".janrain-provider150-sprit\")));\n        assertThat(cleanHtmlSAX, not(containsString(\".janrain-provider150-sprit\")));\n    }\n\n    @Test\n    public void testNoopenerAndNoreferrer() throws ScanException, PolicyException {\n        Map<String, Attribute> map = new HashMap<>();\n        map.put(\"target\", new Attribute(\"a\", Collections.<Pattern>emptyList(), Arrays.asList( \"_blank\", \"_self\" ), \"\",\"\"));\n        map.put(\"rel\", new Attribute(\"a\", Collections.<Pattern>emptyList(), Arrays.asList( \"nofollow\", \"noopener\", \"noreferrer\"), \"\",\"\"));\n        Tag tag = new Tag(\"a\", map, Policy.ACTION_VALIDATE);\n        Policy basePolicy = policy.mutateTag(tag);\n        Policy revised = basePolicy.cloneWithDirective(Policy.ANCHORS_NOFOLLOW,\"true\").cloneWithDirective(Policy.ANCHORS_NOOPENER_NOREFERRER,\"true\");\n        // No target=\"_blank\", so only nofollow can be added.\n        assertThat(as.scan(\"<a>Link text</a>\", revised, AntiSamy.DOM).getCleanHTML(), both(containsString(\"nofollow\")).and(not(containsString(\"noopener noreferrer\"))));\n        assertThat(as.scan(\"<a>Link text</a>\", revised, AntiSamy.SAX).getCleanHTML(), both(containsString(\"nofollow\")).and(not(containsString(\"noopener noreferrer\"))));\n        // target=\"_blank\", can have both.\n        assertThat(as.scan(\"<a target=\\\"_blank\\\">Link text</a>\", revised, AntiSamy.DOM).getCleanHTML(), containsString(\"nofollow noopener noreferrer\"));\n        assertThat(as.scan(\"<a target=\\\"_blank\\\">Link text</a>\", revised, AntiSamy.SAX).getCleanHTML(), containsString(\"nofollow noopener noreferrer\"));\n\n        Policy revised2 = basePolicy.cloneWithDirective(Policy.ANCHORS_NOFOLLOW,\"false\").cloneWithDirective(Policy.ANCHORS_NOOPENER_NOREFERRER,\"true\");\n        // No target=\"_blank\", no rel added.\n        assertThat(as.scan(\"<a>Link text</a>\", revised2, AntiSamy.DOM).getCleanHTML(), not(containsString(\"rel=\")));\n        assertThat(as.scan(\"<a>Link text</a>\", revised2, AntiSamy.SAX).getCleanHTML(), not(containsString(\"rel=\")));\n        // target=\"_blank\", everything present.\n        assertThat(as.scan(\"<a target='_blank' rel='nofollow'>Link text</a>\", revised2, AntiSamy.DOM).getCleanHTML(), containsString(\"nofollow noopener noreferrer\"));\n        assertThat(as.scan(\"<a target='_blank' rel='nofollow'>Link text</a>\", revised2, AntiSamy.SAX).getCleanHTML(), containsString(\"nofollow noopener noreferrer\"));\n        // target=\"_self\", no rel added.\n        assertThat(as.scan(\"<a target='_self'>Link text</a>\", revised2, AntiSamy.DOM).getCleanHTML(), not(containsString(\"rel=\")));\n        assertThat(as.scan(\"<a target='_self'>Link text</a>\", revised2, AntiSamy.SAX).getCleanHTML(), not(containsString(\"rel=\")));\n        // target=\"_self\", only nofollow present.\n        assertThat(as.scan(\"<a target='_self' rel='nofollow'>Link text</a>\", revised2, AntiSamy.DOM).getCleanHTML(), both(containsString(\"nofollow\")).and(not(containsString(\"noopener noreferrer\"))));\n        assertThat(as.scan(\"<a target='_self' rel='nofollow'>Link text</a>\", revised2, AntiSamy.SAX).getCleanHTML(), both(containsString(\"nofollow\")).and(not(containsString(\"noopener noreferrer\"))));\n        // noopener is not repeated\n        assertThat(as.scan(\"<a target='_blank' rel='noopener'>Link text</a>\", revised2, AntiSamy.DOM).getCleanHTML().split(\"noopener\").length, is(2));\n        assertThat(as.scan(\"<a target='_blank' rel='noopener'>Link text</a>\", revised2, AntiSamy.SAX).getCleanHTML().split(\"noopener\").length, is(2));\n\n        Policy revised3 = basePolicy.cloneWithDirective(Policy.ANCHORS_NOFOLLOW,\"false\").cloneWithDirective(Policy.ANCHORS_NOOPENER_NOREFERRER,\"false\");\n        // No rel added\n        assertThat(as.scan(\"<a>Link text</a>\", revised3, AntiSamy.DOM).getCleanHTML(), not(containsString(\"rel=\")));\n        assertThat(as.scan(\"<a>Link text</a>\", revised3, AntiSamy.SAX).getCleanHTML(), not(containsString(\"rel=\")));\n        // noopener is not repeated\n        assertThat(as.scan(\"<a target='_blank' rel='noopener'>Link text</a>\", revised3, AntiSamy.DOM).getCleanHTML().split(\"noopener\").length, is(2));\n        assertThat(as.scan(\"<a target='_blank' rel='noopener'>Link text</a>\", revised3, AntiSamy.SAX).getCleanHTML().split(\"noopener\").length, is(2));\n    }\n\n    @Test\n    public void testLeadingDashOnPropertyName() throws ScanException, PolicyException {\n        // Test that property names with leading dash are supported, reported on issue #125.\n        final String input = \"<style type='text/css'>\\n\" +\n                \"\\t.very-specific-antisamy { -moz-border-radius: inherit ; -webkit-border-radius: 25px 10px 5px 10px;}\\n\" +\n                \"</style>\";\n        // Define new properties for the policy\n        Pattern customPattern = Pattern.compile(\"\\\\d+(\\\\.\\\\d+)?px( \\\\d+(\\\\.\\\\d+)?px){0,3}\", Pattern.DOTALL);\n        Property leadingDashProperty1 = new Property(\"-webkit-border-radius\", Arrays.asList(customPattern), Collections.<String>emptyList(),Collections.<String>emptyList(),\"\",\"\");\n        Property leadingDashProperty2 = new Property(\"-moz-border-radius\", Collections.<Pattern>emptyList(), Arrays.asList(\"inherit\"),Collections.<String>emptyList(),\"\",\"\");\n        Policy revised = policy.addCssProperty(leadingDashProperty1).addCssProperty(leadingDashProperty2);\n        // Test properties\n        assertThat(as.scan(input, revised, AntiSamy.DOM).getCleanHTML(), both(containsString(\"-webkit-border-radius\")).and(containsString(\"-moz-border-radius\")));\n        assertThat(as.scan(input, revised, AntiSamy.SAX).getCleanHTML(), both(containsString(\"-webkit-border-radius\")).and(containsString(\"-moz-border-radius\")));\n    }\n\n    @Test\n    public void testScansWithDifferentPolicyLoading() throws ScanException, PolicyException, URISyntaxException {\n        final String input = \"<span>text</span>\";\n        // Preload policy, do not specify scan type.\n        AntiSamy asInstance = new AntiSamy(policy);\n        assertThat(asInstance.scan(input).getCleanHTML(), is(input));\n        // Pass policy, assume DOM scan type.\n        assertThat(asInstance.scan(input, policy).getCleanHTML(), is(input));\n        // Pass policy as File.\n        File policyFile = new File(getClass().getResource(\"/antisamy.xml\").toURI());\n        assertThat(asInstance.scan(input, policyFile).getCleanHTML(), is(input));\n        // Pass policy filename.\n        String path = getClass().getResource(\"/antisamy.xml\").getPath();\n        path = System.getProperty(\"file.separator\").equals(\"\\\\\") && path.startsWith(\"/\") ? path.substring(1) : path;\n        assertThat(asInstance.scan(input, path).getCleanHTML(), is(input));\n        // No preloaded nor passed policy, expected to fail.\n        try {\n            as.scan(input, null, AntiSamy.DOM);\n            fail(\"Scan with no policy must have thrown an exception.\");\n        } catch (PolicyException e) {\n            // An error is expected. Pass.\n        }\n    }\n\n    @Test\n    public void testGithubIssue151() throws ScanException, PolicyException {\n        // Concern is error messages when parsing stylesheets are no longer returned in AntiSamy 1.6.5\n        String input = \"<img style=\\\"FLOAT: right; CURSOR: hand\\\" src=\\\"http://site.com/pic.jpg\\\" />\";\n\n        CleanResults result = as.scan(input, policy, AntiSamy.DOM);\n        assertThat(result.getErrorMessages().size(), is(1));\n        assertThat(result.getCleanHTML(), both(containsString(\"img\")).and(not(containsString(\"CURSOR\"))));\n\n        result = as.scan(input, policy, AntiSamy.SAX);\n        assertThat(result.getErrorMessages().size(), is(1));\n        assertThat(result.getCleanHTML(), both(containsString(\"img\")).and(not(containsString(\"CURSOR\"))));\n    }\n}\n\n", "/*\n * Copyright (c) 2013, Kristian Rosenvold\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n * Neither the name of OWASP nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.owasp.validator.html.test;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.owasp.validator.html.InternalPolicy;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.PolicyException;\nimport org.owasp.validator.html.model.Property;\nimport org.owasp.validator.html.model.Tag;\n\n/**\n * @author Kristian Rosenvold\n */\npublic class TestPolicy extends InternalPolicy {\n\n    protected TestPolicy(Policy.ParseContext parseContext) throws PolicyException {\n        super(parseContext);\n    }\n\n    protected TestPolicy(Policy old, Map<String, String> directives, Map<String, Tag> tagRules, Map<String, Property> cssRules) {\n        super(old, directives, tagRules, cssRules);\n    }\n\n    public static TestPolicy getInstance() throws PolicyException {\n        return getInstance(Policy.class.getClassLoader().getResource(DEFAULT_POLICY_URI));\n    }\n\n    public static TestPolicy getInstance(String filename) throws PolicyException {\n        File file = new File(filename);\n        return getInstance(file);\n    }\n\n    public static TestPolicy getInstance(File file) throws PolicyException {\n        try {\n            URI uri = file.toURI();\n            return getInstance(uri.toURL());\n        } catch (IOException e) {\n            throw new PolicyException(e);\n        }\n    }\n\n    public static TestPolicy getInstance(URL url) throws PolicyException {\n        return new TestPolicy(getParseContext(getTopLevelElement(url), url));\n    }\n\n    public TestPolicy cloneWithDirective(String name, String value) {\n        Map<String, String> directives = new HashMap<String, String>(this.directives);\n        directives.put(name, value);\n        return new TestPolicy(this, Collections.unmodifiableMap(directives), tagRules, cssRules);\n    }\n\n    public TestPolicy addTagRule(Tag tag) {\n        Map<String, Tag> newTagRules = new HashMap<String, Tag>(tagRules);\n        newTagRules.put(tag.getName().toLowerCase(), tag);\n        return new TestPolicy(this, this.directives, newTagRules, cssRules);\n    }\n\n    public TestPolicy mutateTag(Tag tag) {\n        Map<String, Tag> newRules = new HashMap<String, Tag>(this.tagRules);\n        newRules.put( tag.getName().toLowerCase(), tag);\n        return new TestPolicy(this, this.directives, newRules, cssRules);\n    }\n\n    public TestPolicy addCssProperty(Property property) {\n        Map<String, Property> newCssRules = new HashMap<String, Property>(cssRules);\n        newCssRules.put(property.getName().toLowerCase(), property);\n        return new TestPolicy(this, this.directives, tagRules, newCssRules);\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2007-2021, Arshan Dabirsiaghi, Jason Li\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n * Neither the name of OWASP nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.owasp.validator.html.scan;\n\nimport org.apache.batik.css.parser.ParseException;\nimport org.apache.xerces.dom.DocumentImpl;\nimport net.sourceforge.htmlunit.cyberneko.parsers.DOMFragmentParser;\nimport org.owasp.validator.css.CssScanner;\nimport org.owasp.validator.html.CleanResults;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.PolicyException;\nimport org.owasp.validator.html.ScanException;\nimport org.owasp.validator.html.model.Attribute;\nimport org.owasp.validator.html.model.Tag;\nimport org.owasp.validator.html.util.ErrorMessageUtil;\nimport org.owasp.validator.html.util.HTMLEntityEncoder;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.DocumentFragment;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\nimport org.w3c.dom.Text;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This is where the magic lives. All the scanning/filtration logic resides\n * here, but it should not be called directly. All scanning should be done\n * through an <code>AntiSamy.scan()</code> method.\n * \n * @author Arshan Dabirsiaghi\n */\npublic class AntiSamyDOMScanner extends AbstractAntiSamyScanner {\n    private Document document = new DocumentImpl();\n    private DocumentFragment dom = document.createDocumentFragment();\n    private CleanResults results = null;\n    private static final int maxDepth = 250;\n    private static final Pattern invalidXmlCharacters =\n            Pattern.compile(\"[\\\\u0000-\\\\u001F\\\\uD800-\\\\uDFFF\\\\uFFFE-\\\\uFFFF&&[^\\\\u0009\\\\u000A\\\\u000D]]\");\n    private static final Pattern conditionalDirectives = Pattern.compile(\"<?!?\\\\[\\\\s*(?:end)?if[^]]*\\\\]>?\");\n\n    private static final Queue<CachedItem> cachedItems = new ConcurrentLinkedQueue<CachedItem>();\n\n    static class CachedItem {\n        private final DOMFragmentParser parser;\n        private final Matcher invalidXmlCharMatcher = invalidXmlCharacters.matcher(\"\");\n\n\n        CachedItem() throws SAXNotSupportedException, SAXNotRecognizedException {\n            this.parser = getDomParser();\n        }\n\n        DOMFragmentParser getDomFragmentParser()  {\n            return parser;\n        }\n    }\n\n    public AntiSamyDOMScanner(Policy policy) {\n        super(policy);\n    }\n\n    /* UnusedDeclaration TODO Investigate */\n    public AntiSamyDOMScanner() throws PolicyException {\n        super();\n    }\n\n    /**\n     * This is where the magic lives.\n     *\n     * @param html A String whose contents we want to scan.\n     * @return A <code>CleanResults</code> object with an\n     *         <code>XMLDocumentFragment</code> object and its String\n     *         representation, as well as some scan statistics.\n     * @throws ScanException When there is a problem encountered\n\t *         while scanning the HTML.\n\t */\n    @Override\n    public CleanResults scan(String html) throws ScanException {\n\n        if (html == null) {\n            throw new ScanException(new NullPointerException(\"Null html input\"));\n        }\n\n        errorMessages.clear();\n        int maxInputSize = policy.getMaxInputSize();\n\n        if (maxInputSize < html.length()) {\n            addError(ErrorMessageUtil.ERROR_INPUT_SIZE, new Object[]{html.length(), maxInputSize});\n            throw new ScanException(errorMessages.get(0));\n        }\n\n        isNofollowAnchors = policy.isNofollowAnchors();\n        isNoopenerAndNoreferrerAnchors = policy.isNoopenerAndNoreferrerAnchors();\n        isValidateParamAsEmbed = policy.isValidateParamAsEmbed();\n\n        long startOfScan = System.currentTimeMillis();\n\n        try {\n\n            CachedItem cachedItem;\n            cachedItem = cachedItems.poll();\n            if (cachedItem == null){\n                cachedItem = new CachedItem();\n            }\n\n            /*\n             * We have to replace any invalid XML characters to prevent NekoHTML\n             * from breaking when it gets passed encodings like %21.\n             */\n\n            html = stripNonValidXMLCharacters(html, cachedItem.invalidXmlCharMatcher);\n\n            /*\n             * First thing we do is call the HTML cleaner (\"NekoHTML\") on it\n             * with the appropriate options. We choose not to omit tags due to\n             * the fallibility of our own listing in the ever changing world of\n             * W3C.\n             */\n\n            DOMFragmentParser parser = cachedItem.getDomFragmentParser();\n\n            try {\n                parser.parse(new InputSource(new StringReader(html)), dom);\n            } catch (Exception e) {\n                throw new ScanException(e);\n            }\n\n            processChildren(dom, 0);\n\n            /*\n             * Serialize the output and then return the resulting DOM object and\n             * its string representation.\n             */\n\n            final String trimmedHtml = html;\n\n            StringWriter out = new StringWriter();\n\n            @SuppressWarnings(\"deprecation\")\n            org.apache.xml.serialize.OutputFormat format = getOutputFormat();\n\n            //noinspection deprecation\n            org.apache.xml.serialize.HTMLSerializer serializer = getHTMLSerializer(out, format);\n            serializer.serialize(dom);\n\n            /*\n             * Get the String out of the StringWriter and rip out the XML\n             * declaration if the Policy says we should.\n             */\n            final String trimmed = trim( trimmedHtml, out.getBuffer().toString() );\n\n            Callable<String> cleanHtml = new Callable<String>() {\n                public String call() throws Exception {\n                    return trimmed;\n                }\n            };\n\n            /*\n             * Return the DOM object as well as string HTML.\n             */\n            results = new CleanResults(startOfScan, cleanHtml, dom, errorMessages);\n\n            cachedItems.add( cachedItem);\n            return results;\n\n        } catch (SAXException | IOException e) {\n            throw new ScanException(e);\n        }\n\n    }\n\n    static DOMFragmentParser getDomParser()\n            throws SAXNotRecognizedException, SAXNotSupportedException {\n        DOMFragmentParser parser = new DOMFragmentParser();\n        parser.setProperty(\"http://cyberneko.org/html/properties/names/elems\", \"lower\");\n\n        parser.setFeature(\"http://cyberneko.org/html/features/scanner/style/strip-cdata-delims\", false);\n        parser.setFeature(\"http://cyberneko.org/html/features/scanner/cdata-sections\", true);\n\n        try {\n            parser.setFeature(\"http://cyberneko.org/html/features/enforce-strict-attribute-names\", true);\n        } catch (SAXNotRecognizedException se) {\n            // this indicates that the patched nekohtml is not on the\n            // classpath\n        }\n        return parser;\n    }\n\n    /**\n     * The workhorse of the scanner. Recursively scans document elements\n     * according to the policy. This should be called implicitly through the\n     * AntiSamy.scan() method.\n     *\n     * @param node The node to validate.\n     */\n    private void recursiveValidateTag(final Node node, int currentStackDepth) throws ScanException {\n\n        currentStackDepth++;\n\n        if(currentStackDepth > maxDepth) {\n            throw new ScanException(\"Too many nested tags\");\n        }\n\n        if (node instanceof Comment) {\n            processCommentNode(node);\n            return;\n        }\n\n        boolean isElement = node instanceof Element;\n        NodeList eleChildNodes = node.getChildNodes();\n        if (isElement && eleChildNodes.getLength() == 0) {\n            if (removeDisallowedEmpty(node)){\n                return;\n            }\n        }\n\n        if (node instanceof Text && Node.CDATA_SECTION_NODE == node.getNodeType()) {\n            stripCData(node);\n            return;\n        }\n\n        if (node instanceof ProcessingInstruction) {\n            removePI(node);\n        }\n\n        if (!isElement) {\n            return;\n        }\n\n        final Element ele = (Element) node;\n        final Node parentNode = ele.getParentNode();\n\n        final String tagName = ele.getNodeName();\n        final String tagNameLowerCase = tagName.toLowerCase();\n        Tag tagRule = policy.getTagByLowercaseName(tagNameLowerCase);\n\n        /*\n         * If <param> and no policy and isValidateParamAsEmbed and policy in\n         * place for <embed> and <embed> policy is to validate, use custom\n         * policy to get the tag through to the validator.\n         */\n        Tag embedTag = policy.getEmbedTag();\n        boolean masqueradingParam = isMasqueradingParam(tagRule, embedTag, tagNameLowerCase);\n        if (masqueradingParam){\n            tagRule = Constants.BASIC_PARAM_TAG_RULE;\n        }\n\n        if ((tagRule == null && policy.isEncodeUnknownTag()) || (tagRule != null && tagRule.isAction( \"encode\"))) {\n            encodeTag(currentStackDepth, ele, tagName, eleChildNodes);\n        } else if (tagRule == null || tagRule.isAction( Policy.ACTION_FILTER)) {\n            actionFilter(currentStackDepth, ele, tagName, tagRule, eleChildNodes);\n        } else if (tagRule.isAction( Policy.ACTION_VALIDATE)) {\n            actionValidate(currentStackDepth, ele, parentNode, tagName, tagNameLowerCase, tagRule, masqueradingParam, embedTag, eleChildNodes);\n        } else if (tagRule.isAction( Policy.ACTION_TRUNCATE)) {\n            actionTruncate(ele, tagName, eleChildNodes);\n        } else {\n            /*\n             * If we reached this that means that the tag's action is \"remove\",\n             * which means to remove the tag (including its contents).\n             */\n            addError(ErrorMessageUtil.ERROR_TAG_DISALLOWED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(tagName)});\n            removeNode(ele);\n        }\n    }\n\n    private boolean isMasqueradingParam(Tag tagRule, Tag embedTag, String tagNameLowerCase){\n        if (tagRule == null && isValidateParamAsEmbed && \"param\".equals(tagNameLowerCase)) {\n            return embedTag != null && embedTag.isAction(Policy.ACTION_VALIDATE);\n        }\n        return false;\n    }\n\n    private void encodeTag(int currentStackDepth, Element ele, String tagName, NodeList eleChildNodes) throws ScanException {\n        addError(ErrorMessageUtil.ERROR_TAG_ENCODED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(tagName)});\n        processChildren(eleChildNodes, currentStackDepth);\n\n   /*\n    * Transform the tag to text, HTML-encode it and promote the\n    * children. The tag will be kept in the fragment as one or two text\n    * Nodes located before and after the children; representing how the\n    * tag used to wrap them.\n    */\n\n        encodeAndPromoteChildren(ele);\n    }\n\n    private void actionFilter(int currentStackDepth, Element ele, String tagName, Tag tag, NodeList eleChildNodes) throws ScanException {\n        if (tag == null) {\n            addError(ErrorMessageUtil.ERROR_TAG_NOT_IN_POLICY, new Object[]{HTMLEntityEncoder.htmlEntityEncode(tagName)});\n        } else {\n            addError(ErrorMessageUtil.ERROR_TAG_FILTERED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(tagName)});\n        }\n\n        processChildren(eleChildNodes, currentStackDepth);\n        promoteChildren(ele);\n    }\n\n    private void actionValidate(int currentStackDepth, Element ele, Node parentNode, String tagName, String tagNameLowerCase, Tag tag, boolean masqueradingParam, Tag embedTag, NodeList eleChildNodes) throws ScanException {\n   /*\n    * If doing <param> as <embed>, now is the time to convert it.\n    */\n        String nameValue = null;\n        if (masqueradingParam) {\n            nameValue = ele.getAttribute(\"name\");\n            if (nameValue != null && !\"\".equals(nameValue)) {\n                String valueValue = ele.getAttribute(\"value\");\n                ele.setAttribute(nameValue, valueValue);\n                ele.removeAttribute(\"name\");\n                ele.removeAttribute(\"value\");\n                tag = embedTag;\n            }\n        }\n\n   /*\n    * Check to see if it's a <style> tag. We have to special case this\n    * tag so we can hand it off to the custom style sheet validating\n    * parser.\n    */\n\n        if (\"style\".equals(tagNameLowerCase) && policy.getStyleTag() != null) {\n            if (processStyleTag(ele, parentNode)) return;\n        }\n\n   /*\n    * Go through the attributes in the tainted tag and validate them\n    * against the values we have for them.\n    *\n    * If we don't have a rule for the attribute we remove the\n    * attribute.\n    */\n\n        if (processAttributes(ele, tagName, tag, currentStackDepth)) return; // can't process any more if we\n\n        if (\"a\".equals(tagNameLowerCase)) {\n            boolean addNofollow = isNofollowAnchors;\n            boolean addNoopenerAndNoreferrer = false;\n\n            if (isNoopenerAndNoreferrerAnchors) {\n                Node targetAttribute = ele.getAttributes().getNamedItem(\"target\");\n                if (targetAttribute != null && targetAttribute.getNodeValue().equalsIgnoreCase(\"_blank\")) {\n                    addNoopenerAndNoreferrer = true;\n                }\n            }\n\n            Node relAttribute = ele.getAttributes().getNamedItem(\"rel\");\n            String relValue = Attribute.mergeRelValuesInAnchor(addNofollow, addNoopenerAndNoreferrer, relAttribute == null ? \"\" : relAttribute.getNodeValue());\n            if (!relValue.isEmpty()){\n                ele.setAttribute(\"rel\", relValue.trim());\n            }\n        }\n\n        processChildren(eleChildNodes, currentStackDepth);\n\n   /*\n    * If we have been dealing with a <param> that has been converted to\n    * an <embed>, convert it back\n    */\n        if (masqueradingParam && nameValue != null && !\"\".equals(nameValue)) {\n            String valueValue = ele.getAttribute(nameValue);\n            ele.setAttribute(\"name\", nameValue);\n            ele.setAttribute(\"value\", valueValue);\n            ele.removeAttribute(nameValue);\n        }\n    }\n\n    private boolean processStyleTag(Element ele, Node parentNode) {\n        /*\n         * Invoke the css parser on this element.\n         */\n        CssScanner styleScanner = new CssScanner(policy, messages, policy.isEmbedStyleSheets());\n\n        try {\n            if (ele.getChildNodes().getLength() > 0) {\n                String toScan = \"\";\n\n                for (int i = 0; i < ele.getChildNodes().getLength(); i++) {\n                    Node childNode = ele.getChildNodes().item(i);\n                    if (!toScan.isEmpty()){\n                        toScan += \"\\n\";\n                    }\n                    toScan += childNode.getTextContent();\n                }\n\n                CleanResults cr = styleScanner.scanStyleSheet(toScan, policy.getMaxInputSize());\n                errorMessages.addAll(cr.getErrorMessages());\n\n                /*\n                 * If IE gets an empty style tag, i.e. <style/> it will\n                 * break all CSS on the page. I wish I was kidding. So,\n                 * if after validation no CSS properties are left, we\n                 * would normally be left with an empty style tag and\n                 * break all CSS. To prevent that, we have this check.\n                 */\n\n                String cleanHTML = cr.getCleanHTML();\n                cleanHTML = cleanHTML == null || cleanHTML.equals(\"\") ? \"/* */\" : cleanHTML;\n\n                ele.getFirstChild().setNodeValue(cleanHTML);\n                /*\n                 * Remove every other node after cleaning CSS, there will\n                 * be only one node in the end, as it always should have.\n                 */\n                for (int i = 1; i < ele.getChildNodes().getLength(); i++) {\n                    Node childNode = ele.getChildNodes().item(i);\n                    ele.removeChild(childNode);\n                }\n            }\n\n        } catch (DOMException | ScanException | ParseException | NumberFormatException e) {\n\n            /*\n             * ParseException shouldn't be possible anymore, but we'll leave it\n             * here because I (Arshan) am hilariously dumb sometimes.\n             * Batik can throw NumberFormatExceptions (see bug #48).\n             */\n\n            addError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(ele.getFirstChild().getNodeValue())});\n            parentNode.removeChild(ele);\n            return true;\n        }\n        return false;\n    }\n\n    private void actionTruncate(Element ele, String tagName, NodeList eleChildNodes) {\n   /*\n    * Remove all attributes. This is for tags like i, b, u, etc. Purely\n    * formatting without any need for attributes. It also removes any\n    * children.\n    */\n\n        NamedNodeMap nnmap = ele.getAttributes();\n        while (nnmap.getLength() > 0) {\n            addError(ErrorMessageUtil.ERROR_ATTRIBUTE_NOT_IN_POLICY,\n                new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(nnmap.item(0).getNodeName())});\n            ele.removeAttribute(nnmap.item(0).getNodeName());\n        }\n\n        int i = 0;\n        int j = 0;\n        int length = eleChildNodes.getLength();\n\n        while (i < length) {\n            Node nodeToRemove = eleChildNodes.item(j);\n            if (nodeToRemove.getNodeType() != Node.TEXT_NODE) {\n                ele.removeChild(nodeToRemove);\n            } else {\n                j++;\n            }\n            i++;\n        }\n    }\n\n    private boolean processAttributes(Element ele, String tagName, Tag tag, int currentStackDepth) throws ScanException {\n        Node attribute;\n\n        NamedNodeMap attributes = ele.getAttributes();\n        for (int currentAttributeIndex = 0; currentAttributeIndex < attributes.getLength(); currentAttributeIndex++) {\n\n            attribute = attributes.item(currentAttributeIndex);\n\n            String name = attribute.getNodeName();\n            String value = attribute.getNodeValue();\n\n            Attribute attr = tag.getAttributeByName(name.toLowerCase());\n\n            /*\n             * If we there isn't an attribute by that name in our policy\n             * check to see if it's a globally defined attribute. Validate\n             * against that if so.\n             */\n            if (attr == null) {\n                attr = policy.getGlobalAttributeByName(name);\n                if (attr == null && policy.isAllowDynamicAttributes()) {\n                    // not a global attribute, perhaps it is a dynamic attribute, if allowed\n                    attr = policy.getDynamicAttributeByName(name);\n                }\n            }\n\n            /*\n             * We have to special case the \"style\" attribute since it's\n             * validated quite differently.\n             */\n            if (\"style\".equals(name.toLowerCase()) && attr != null) {\n\n                /*\n                 * Invoke the CSS parser on this element.\n                 */\n                CssScanner styleScanner = new CssScanner(policy, messages, false);\n\n                try {\n                    CleanResults cr = styleScanner.scanInlineStyle(value, tagName, policy.getMaxInputSize());\n                    attribute.setNodeValue(cr.getCleanHTML());\n                    List<String> cssScanErrorMessages = cr.getErrorMessages();\n                    errorMessages.addAll(cssScanErrorMessages);\n\n                } catch (DOMException | ScanException e) {\n\n                    addError(ErrorMessageUtil.ERROR_CSS_ATTRIBUTE_MALFORMED,\n                        new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(ele.getNodeValue())});\n                    ele.removeAttribute(attribute.getNodeName());\n                    currentAttributeIndex--;\n                }\n\n            } else {\n\n                if (attr != null) {\n\n                    // See if attribute is invalid\n                    if (!(attr.containsAllowedValue( value.toLowerCase()) ||\n                         (attr.matchesAllowedExpression( value ))) ) {\n\n                        /*\n                         * Attribute is NOT valid, so: Document transgression and perform the\n                         * \"onInvalid\" action. The default action is to\n                         * strip the attribute and leave the rest intact.\n                         */\n\n                        String onInvalidAction = attr.getOnInvalid();\n\n                        if (\"removeTag\".equals(onInvalidAction)) {\n\n                            /*\n                             * Remove the tag and its contents.\n                             */\n\n                            removeNode(ele);\n\n                            addError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID_REMOVED,\n                              new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)});\n                            return true;\n\n                        } else if (\"filterTag\".equals(onInvalidAction)) {\n\n                            /*\n                             * Remove the attribute and keep the rest of the tag.\n                             */\n\n                            processChildren(ele, currentStackDepth);\n                            promoteChildren(ele);\n                            addError(ErrorMessageUtil.ERROR_ATTRIBUTE_CAUSE_FILTER,\n                              new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)});\n                            return true;\n                        } else if (\"encodeTag\".equals(onInvalidAction)) {\n\n                            /*\n                             * Remove the attribute and keep the rest of the tag.\n                             */\n\n                            processChildren(ele, currentStackDepth);\n                            encodeAndPromoteChildren(ele);\n                            addError(ErrorMessageUtil.ERROR_ATTRIBUTE_CAUSE_ENCODE,\n                              new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)});\n                            return true;\n                        } else {\n\n                            /*\n                             * onInvalidAction = \"removeAttribute\"\n                             */\n\n                            ele.removeAttribute(attribute.getNodeName());\n                            currentAttributeIndex--;\n                            addError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID,\n                              new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)});\n                            \n                        }\n                    }\n\n                } else {\n                    /*\n                     * the attribute they specified isn't in our policy\n                     * - remove it (whitelisting!)\n                     */\n\n                    addError(ErrorMessageUtil.ERROR_ATTRIBUTE_NOT_IN_POLICY,\n                      new Object[]{tagName, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)});\n                    ele.removeAttribute(attribute.getNodeName());\n                    currentAttributeIndex--;\n\n                } // end if attribute is found in policy file\n\n            } // end while loop through attributes\n\n        } // loop through each attribute\n        return false;\n    }\n\n    private void processChildren(Node ele, int currentStackDepth) throws ScanException {\n        processChildren(ele.getChildNodes(), currentStackDepth);\n    }\n\n    private void processChildren(NodeList childNodes, int currentStackDepth ) throws ScanException {\n        Node tmp;\n        for (int i = 0; i < childNodes.getLength(); i++) {\n\n            tmp = childNodes.item(i);\n            recursiveValidateTag(tmp, currentStackDepth);\n\n            /*\n             * This indicates the node was removed/failed validation.\n             */\n            if (tmp.getParentNode() == null) {\n                i--;\n            }\n        }\n    }\n\n    private void removePI(Node node) {\n        addError(ErrorMessageUtil.ERROR_PI_FOUND, new Object[]{HTMLEntityEncoder.htmlEntityEncode(node.getTextContent())});\n        removeNode(node);\n    }\n\n    private void stripCData(Node node) {\n        addError(ErrorMessageUtil.ERROR_CDATA_FOUND, new Object[]{HTMLEntityEncoder.htmlEntityEncode(node.getTextContent())});\n        Node text = document.createTextNode(node.getTextContent());\n        node.getParentNode().insertBefore(text, node);\n        node.getParentNode().removeChild(node);\n    }\n\n    private void processCommentNode(Node node) {\n        if (!policy.isPreserveComments()) {\n            node.getParentNode().removeChild(node);\n        } else {\n            String value = ((Comment) node).getData();\n            // Strip conditional directives regardless of the\n            // PRESERVE_COMMENTS setting.\n            if (value != null) {\n                ((Comment) node).setData(conditionalDirectives.matcher(value).replaceAll(\"\"));\n            }\n        }\n    }\n\n    private boolean removeDisallowedEmpty(Node node){\n        String tagName = node.getNodeName();\n\n        if (!isAllowedEmptyTag(tagName)) {\n           /*\n            * Wasn't in the list of allowed elements, so we'll nuke it.\n            */\n            addError(ErrorMessageUtil.ERROR_TAG_EMPTY, new Object[]{HTMLEntityEncoder.htmlEntityEncode(node.getNodeName())});\n            removeNode(node);\n            return true;\n        }\n        return false;\n    }\n\n    private void removeNode(Node node) {\n\t\tNode parent = node.getParentNode();\n\t\tparent.removeChild(node);\n\t\tString tagName = parent.getNodeName();\n\t\tif(\tparent instanceof Element && \n\t\t\tparent.getChildNodes().getLength() == 0 && \n\t\t\t!isAllowedEmptyTag(tagName)) {\n\t\t\tremoveNode(parent);\n\t\t}\n\t}\n\n\tprivate boolean isAllowedEmptyTag(String tagName) {\n        return \"head\".equals(tagName ) || policy.getAllowedEmptyTags().matches(tagName);\n\t}\n\t\n    /**\n     * Used to promote the children of a parent to accomplish the \"filterTag\" action.\n     *\n     * @param ele The Element we want to filter.\n     */\n    private void promoteChildren(Element ele) {\n        promoteChildren(ele, ele.getChildNodes());\n    }\n\n    private void promoteChildren(Element ele, NodeList eleChildNodes) {\n\n        Node parent = ele.getParentNode();\n\n        while (eleChildNodes.getLength() > 0) {\n            Node node = ele.removeChild(eleChildNodes.item(0));\n            parent.insertBefore(node, ele);\n        }\n\n        if (parent != null) {\n            removeNode(ele);\n        }\n    }\n\n    /**\n     * This method was borrowed from Mark McLaren, to whom I owe much beer.\n     *\n     * This method ensures that the output has only valid XML unicode characters\n     * as specified by the XML 1.0 standard. For reference, please see <a\n     * href=\"http://www.w3.org/TR/2000/REC-xml-20001006#NT-Char\">the\n     * standard</a>. This method will return an empty String if the input is\n     * null or empty.\n     *\n     * @param in The String whose non-valid characters we want to remove.\n     * @param invalidXmlCharsMatcher  The reusable regex matcher\n     * @return The in String, stripped of non-valid characters.\n     */\n    private String stripNonValidXMLCharacters(String in, Matcher invalidXmlCharsMatcher) {\n\n        if (in == null || (\"\".equals(in))) {\n            return \"\"; // vacancy test.\n        }\n        invalidXmlCharsMatcher.reset(in);\n        return invalidXmlCharsMatcher.matches() ? invalidXmlCharsMatcher.replaceAll(\"\") : in;\n    }\n\n    /**\n     * Transform the element to text, HTML-encode it and promote the children.\n     * The element will be kept in the fragment as one or two text Nodes located\n     * before and after the children; representing how the tag used to wrap\n     * them. If the element didn't have any children then only one text Node is\n     * created representing an empty element.\n     *\n     * @param ele Element to be encoded\n     */\n    private void encodeAndPromoteChildren(Element ele) {\n        Node parent = ele.getParentNode();\n        String tagName = ele.getTagName();\n        Node openingTag = parent.getOwnerDocument().createTextNode(toString(ele));\n        parent.insertBefore(openingTag, ele);\n        if (ele.hasChildNodes()) {\n            Node closingTag = parent.getOwnerDocument().createTextNode(\"</\" + tagName + \">\");\n            parent.insertBefore(closingTag, ele.getNextSibling());\n        }\n        promoteChildren(ele);\n    }\n\n    /**\n     * Returns a text version of the passed element\n     *\n     * @param ele Element to be converted\n     * @return String representation of the element\n     */\n    private String toString(Element ele) {\n        StringBuilder eleAsString = new StringBuilder(\"<\" + ele.getNodeName());\n        NamedNodeMap attributes = ele.getAttributes();\n        Node attribute;\n        for (int i = 0; i < attributes.getLength(); i++) {\n            attribute = attributes.item(i);\n\n            String name = attribute.getNodeName();\n            String value = attribute.getNodeValue();\n\n            eleAsString.append(\" \");\n            eleAsString.append(HTMLEntityEncoder.htmlEntityEncode(name));\n            eleAsString.append(\"=\\\"\");\n            eleAsString.append(HTMLEntityEncoder.htmlEntityEncode(value));\n            eleAsString.append(\"\\\"\");\n        }\n        if (ele.hasChildNodes()) {\n            eleAsString.append(\">\");\n        } else {\n            eleAsString.append(\"/>\");\n        }\n        return eleAsString.toString();\n    }\n\n    @Override\n    public CleanResults getResults() {\n        return results;\n    }\n}\n", "/*\n * Copyright (c) 2007-2022, Arshan Dabirsiaghi, Jason Li\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this list\n * of conditions and the following disclaimer.  Redistributions in binary form must\n * reproduce the above copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials provided with the distribution.\n * Neither the name of OWASP nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.owasp.validator.html.test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.hamcrest.CoreMatchers.both;\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.not;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\nimport org.hamcrest.text.MatchesPattern;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.concurrent.ExecutionException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.codec.binary.Base64;\n\nimport org.owasp.validator.html.AntiSamy;\nimport org.owasp.validator.html.CleanResults;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.PolicyException;\nimport org.owasp.validator.html.ScanException;\nimport org.owasp.validator.html.model.Attribute;\nimport org.owasp.validator.html.model.Property;\nimport org.owasp.validator.html.model.Tag;\n\n/**\n * This class tests AntiSamy functionality and the basic policy file which\n * should be immune to XSS and CSS phishing attacks.\n * \n * The test cases titled issue##() map to the issues identified in the original AntiSamy \n * source code repo at: https://code.google.com/archive/p/owaspantisamy/issues.\n * \n * The test cases titled githubIssue##() map to the issues documented at: \n *     https://github.com/nahsra/antisamy/issues\n *\n * @author Arshan Dabirsiaghi\n */\n\npublic class AntiSamyTest {\n\n    private static final String[] BASE64_BAD_XML_STRINGS = new String[]{\n            // first string is\n            // \"<a - href=\\\"http://www.owasp.org\\\">click here</a>\"\n            \"PGEgLSBocmVmPSJodHRwOi8vd3d3Lm93YXNwLm9yZyI+Y2xpY2sgaGVyZTwvYT4=\",\n            // the rest are randomly generated 300 byte sequences which generate\n            // parser errors, turned into Strings\n            \"uz0sEy5aDiok6oufQRaYPyYOxbtlACRnfrOnUVIbOstiaoB95iw+dJYuO5sI9nudhRtSYLANlcdgO0pRb+65qKDwZ5o6GJRMWv4YajZk+7Q3W/GN295XmyWUpxuyPGVi7d5fhmtYaYNW6vxyKK1Wjn9IEhIrfvNNjtEF90vlERnz3wde4WMaKMeciqgDXuZHEApYmUcu6Wbx4Q6WcNDqohAN/qCli74tvC+Umy0ZsQGU7E+BvJJ1tLfMcSzYiz7Q15ByZOYrA2aa0wDu0no3gSatjGt6aB4h30D9xUP31LuPGZ2GdWwMfZbFcfRgDSh42JPwa1bODmt5cw0Y8ACeyrIbfk9IkX1bPpYfIgtO7TwuXjBbhh2EEixOZ2YkcsvmcOSVTvraChbxv6kP\",\n            \"PIWjMV4y+MpuNLtcY3vBRG4ZcNaCkB9wXJr3pghmFA6rVXAik+d5lei48TtnHvfvb5rQZVceWKv9cR/9IIsLokMyN0omkd8j3TV0DOh3JyBjPHFCu1Gp4Weo96h5C6RBoB0xsE4QdS2Y1sq/yiha9IebyHThAfnGU8AMC4AvZ7DDBccD2leZy2Q617ekz5grvxEG6tEcZ3fCbJn4leQVVo9MNoerim8KFHGloT+LxdgQR6YN5y1ii3bVGreM51S4TeANujdqJXp8B7B1Gk3PKCRS2T1SNFZedut45y+/w7wp5AUQCBUpIPUj6RLp+y3byWhcbZbJ70KOzTSZuYYIKLLo8047Fej43bIaghJm0F9yIKk3C5gtBcw8T5pciJoVXrTdBAK/8fMVo29P\",\n            \"uCk7HocubT6KzJw2eXpSUItZFGkr7U+D89mJw70rxdqXP2JaG04SNjx3dd84G4bz+UVPPhPO2gBAx2vHI0xhgJG9T4vffAYh2D1kenmr+8gIHt6WDNeD+HwJeAbJYhfVFMJsTuIGlYIw8+I+TARK0vqjACyRwMDAndhXnDrk4E5U3hyjqS14XX0kIDZYM6FGFPXe/s+ba2886Q8o1a7WosgqqAmt4u6R3IHOvVf5/PIeZrBJKrVptxjdjelP8Xwjq2ujWNtR3/HM1kjRlJi4xedvMRe4Rlxek0NDLC9hNd18RYi0EjzQ0bGSDDl0813yv6s6tcT6xHMzKvDcUcFRkX6BbxmoIcMsVeHM/ur6yRv834o/TT5IdiM9/wpkuICFOWIfM+Y8OWhiU6BK\",\n            \"Bb6Cqy6stJ0YhtPirRAQ8OXrPFKAeYHeuZXuC1qdHJRlweEzl4F2z/ZFG7hzr5NLZtzrRG3wm5TXl6Aua5G6v0WKcjJiS2V43WB8uY1BFK1d2y68c1gTRSF0u+VTThGjz+q/R6zE8HG8uchO+KPw64RehXDbPQ4uadiL+UwfZ4BzY1OHhvM5+2lVlibG+awtH6qzzx6zOWemTih932Lt9mMnm3FzEw7uGzPEYZ3aBV5xnbQ2a2N4UXIdm7RtIUiYFzHcLe5PZM/utJF8NdHKy0SPaKYkdXHli7g3tarzAabLZqLT4k7oemKYCn/eKRreZjqTB2E8Kc9Swf3jHDkmSvzOYE8wi1vQ3X7JtPcQ2O4muvpSa70NIE+XK1CgnnsL79Qzci1/1xgkBlNq\",\n            \"FZNVr4nOICD1cNfAvQwZvZWi+P4I2Gubzrt+wK+7gLEY144BosgKeK7snwlA/vJjPAnkFW72APTBjY6kk4EOyoUef0MxRnZEU11vby5Ru19eixZBFB/SVXDJleLK0z3zXXE8U5Zl5RzLActHakG8Psvdt8TDscQc4MPZ1K7mXDhi7FQdpjRTwVxFyCFoybQ9WNJNGPsAkkm84NtFb4KjGpwVC70oq87tM2gYCrNgMhBfdBl0bnQHoNBCp76RKdpq1UAY01t1ipfgt7BoaAr0eTw1S32DezjfkAz04WyPTzkdBKd3b44rX9dXEbm6szAz0SjgztRPDJKSMELjq16W2Ua8d1AHq2Dz8JlsvGzi2jICUjpFsIfRmQ/STSvOT8VsaCFhwL1zDLbn5jCr\",\n            \"RuiRkvYjH2FcCjNzFPT2PJWh7Q6vUbfMadMIEnw49GvzTmhk4OUFyjY13GL52JVyqdyFrnpgEOtXiTu88Cm+TiBI7JRh0jRs3VJRP3N+5GpyjKX7cJA46w8PrH3ovJo3PES7o8CSYKRa3eUs7BnFt7kUCvMqBBqIhTIKlnQd2JkMNnhhCcYdPygLx7E1Vg+H3KybcETsYWBeUVrhRl/RAyYJkn6LddjPuWkDdgIcnKhNvpQu4MMqF3YbzHgyTh7bdWjy1liZle7xR/uRbOrRIRKTxkUinQGEWyW3bbXOvPO71E7xyKywBanwg2FtvzOoRFRVF7V9mLzPSqdvbM7VMQoLFob2UgeNLbVHkWeQtEqQWIV5RMu3+knhoqGYxP/3Srszp0ELRQy/xyyD\",\n            \"mqBEVbNnL929CUA3sjkOmPB5dL0/a0spq8LgbIsJa22SfP580XduzUIKnCtdeC9TjPB/GEPp/LvEUFaLTUgPDQQGu3H5UCZyjVTAMHl45me/0qISEf903zFFqW5Lk3TS6iPrithqMMvhdK29Eg5OhhcoHS+ALpn0EjzUe86NywuFNb6ID4o8aF/ztZlKJegnpDAm3JuhCBauJ+0gcOB8GNdWd5a06qkokmwk1tgwWat7cQGFIH1NOvBwRMKhD51MJ7V28806a3zkOVwwhOiyyTXR+EcDA/aq5acX0yailLWB82g/2GR/DiaqNtusV+gpcMTNYemEv3c/xLkClJc29DSfTsJGKsmIDMqeBMM7RRBNinNAriY9iNX1UuHZLr/tUrRNrfuNT5CvvK1K\",\n            \"IMcfbWZ/iCa/LDcvMlk6LEJ0gDe4ohy2Vi0pVBd9aqR5PnRj8zGit8G2rLuNUkDmQ95bMURasmaPw2Xjf6SQjRk8coIHDLtbg/YNQVMabE8pKd6EaFdsGWJkcFoonxhPR29aH0xvjC4Mp3cJX3mjqyVsOp9xdk6d0Y2hzV3W/oPCq0DV03pm7P3+jH2OzoVVIDYgG1FD12S03otJrCXuzDmE2LOQ0xwgBQ9sREBLXwQzUKfXH8ogZzjdR19pX9qe0rRKMNz8k5lqcF9R2z+XIS1QAfeV9xopXA0CeyrhtoOkXV2i8kBxyodDp7tIeOvbEfvaqZGJgaJyV8UMTDi7zjwNeVdyKa8USH7zrXSoCl+Ud5eflI9vxKS+u9Bt1ufBHJtULOCHGA2vimkU\",\n            \"AqC2sr44HVueGzgW13zHvJkqOEBWA8XA66ZEb3EoL1ehypSnJ07cFoWZlO8kf3k57L1fuHFWJ6quEdLXQaT9SJKHlUaYQvanvjbBlqWwaH3hODNsBGoK0DatpoQ+FxcSkdVE/ki3rbEUuJiZzU0BnDxH+Q6FiNsBaJuwau29w24MlD28ELJsjCcUVwtTQkaNtUxIlFKHLj0++T+IVrQH8KZlmVLvDefJ6llWbrFNVuh674HfKr/GEUatG6KI4gWNtGKKRYh76mMl5xH5qDfBZqxyRaKylJaDIYbx5xP5I4DDm4gOnxH+h/Pu6dq6FJ/U3eDio/KQ9xwFqTuyjH0BIRBsvWWgbTNURVBheq+am92YBhkj1QmdKTxQ9fQM55O8DpyWzRhky0NevM9j\",\n            \"qkFfS3WfLyj3QTQT9i/s57uOPQCTN1jrab8bwxaxyeYUlz2tEtYyKGGUufua8WzdBT2VvWTvH0JkK0LfUJ+vChvcnMFna+tEaCKCFMIOWMLYVZSJDcYMIqaIr8d0Bi2bpbVf5z4WNma0pbCKaXpkYgeg1Sb8HpKG0p0fAez7Q/QRASlvyM5vuIOH8/CM4fF5Ga6aWkTRG0lfxiyeZ2vi3q7uNmsZF490J79r/6tnPPXIIC4XGnijwho5NmhZG0XcQeyW5KnT7VmGACFdTHOb9oS5WxZZU29/oZ5Y23rBBoSDX/xZ1LNFiZk6Xfl4ih207jzogv+3nOro93JHQydNeKEwxOtbKqEe7WWJLDw/EzVdJTODrhBYKbjUce10XsavuiTvv+H1Qh4lo2Vx\",\n            \"O900/Gn82AjyLYqiWZ4ILXBBv/ZaXpTpQL0p9nv7gwF2MWsS2OWEImcVDa+1ElrjUumG6CVEv/rvax53krqJJDg+4Z/XcHxv58w6hNrXiWqFNjxlu5RZHvj1oQQXnS2n8qw8e/c+8ea2TiDIVr4OmgZz1G9uSPBeOZJvySqdgNPMpgfjZwkL2ez9/x31sLuQxi/FW3DFXU6kGSUjaq8g/iGXlaaAcQ0t9Gy+y005Z9wpr2JWWzishL+1JZp9D4SY/r3NHDphN4MNdLHMNBRPSIgfsaSqfLraIt+zWIycsd+nksVxtPv9wcyXy51E1qlHr6Uygz2VZYD9q9zyxEX4wRP2VEewHYUomL9d1F6gGG5fN3z82bQ4hI9uDirWhneWazUOQBRud5otPOm9\",\n            \"C3c+d5Q9lyTafPLdelG1TKaLFinw1TOjyI6KkrQyHKkttfnO58WFvScl1TiRcB/iHxKahskoE2+VRLUIhctuDU4sUvQh/g9Arw0LAA4QTxuLFt01XYdigurz4FT15ox2oDGGGrRb3VGjDTXK1OWVJoLMW95EVqyMc9F+Fdej85LHE+8WesIfacjUQtTG1tzYVQTfubZq0+qxXws8QrxMLFtVE38tbeXo+Ok1/U5TUa6FjWflEfvKY3XVcl8RKkXua7fVz/Blj8Gh+dWe2cOxa0lpM75ZHyz9adQrB2Pb4571E4u2xI5un0R0MFJZBQuPDc1G5rPhyk+Hb4LRG3dS0m8IASQUOskv93z978L1+Abu9CLP6d6s5p+BzWxhMUqwQXC/CCpTywrkJ0RG\",\n    };\n\n    private AntiSamy as = new AntiSamy();\n    private TestPolicy policy = null;\n\n    @Before\n    public void setUp() throws Exception {\n\n        /*\n         * Load the policy. You may have to change the path to find the Policy\n         * file for your environment.\n         */\n\n        //get Policy instance from a URL.\n        URL url = getClass().getResource(\"/antisamy.xml\");\n        policy = TestPolicy.getInstance(url);\n    }\n\n    @Test\n    public void SAX() {\n        try {\n            CleanResults cr = as.scan(\"<b>test</i></b>test thsidfshidf<script>sdfsdf\", policy, AntiSamy.SAX);\n            assertTrue(cr != null && cr.getCleanXMLDocumentFragment() == null && cr.getCleanHTML().length() > 0);\n        } catch (ScanException | PolicyException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /*\n     * Test basic XSS cases.\n     */\n\n    @Test\n    public void scriptAttacks() throws ScanException, PolicyException {\n    \t\n        assertTrue(!as.scan(\"test<script>alert(document.cookie)</script>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"script\"));\n        assertTrue(!as.scan(\"test<script>alert(document.cookie)</script>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"script\"));\n\n        assertTrue(!as.scan(\"<<<><<script src=http://fake-evil.ru/test.js>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<<<><<script src=http://fake-evil.ru/test.js>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<script<script src=http://fake-evil.ru/test.js>>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<script<script src=http://fake-evil.ru/test.js>>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT/XSS SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT/XSS SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<BODY onload!#$%&()*~+-_.,:;?@[/|\\\\]^`=alert(\\\"XSS\\\")>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"onload\"));\n        assertTrue(!as.scan(\"<BODY onload!#$%&()*~+-_.,:;?@[/|\\\\]^`=alert(\\\"XSS\\\")>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"onload\"));\n\n        assertTrue(!as.scan(\"<BODY ONLOAD=alert('XSS')>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n        assertTrue(!as.scan(\"<BODY ONLOAD=alert('XSS')>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n        assertTrue(!as.scan(\"<iframe src=http://ha.ckers.org/scriptlet.html <\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<iframe\"));\n        assertTrue(!as.scan(\"<iframe src=http://ha.ckers.org/scriptlet.html <\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<iframe\"));\n\n        assertTrue(!as.scan(\"<INPUT TYPE=\\\"IMAGE\\\" SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"src\"));\n        assertTrue(!as.scan(\"<INPUT TYPE=\\\"IMAGE\\\" SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"src\"));\n\n        as.scan(\"<a onblur=\\\"alert(secret)\\\" href=\\\"http://www.google.com\\\">Google</a>\", policy, AntiSamy.DOM);\n        as.scan(\"<a onblur=\\\"alert(secret)\\\" href=\\\"http://www.google.com\\\">Google</a>\", policy, AntiSamy.SAX);\n    }\n\n    @Test\n    public void imgAttacks() throws ScanException, PolicyException {\n\n        assertTrue(as.scan(\"<img src=\\\"http://www.myspace.com/img.gif\\\"/>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n        assertTrue(as.scan(\"<img src=\\\"http://www.myspace.com/img.gif\\\"/>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<img\"));\n\n        assertTrue(!as.scan(\"<img src=javascript:alert(document.cookie)>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n        assertTrue(!as.scan(\"<img src=javascript:alert(document.cookie)>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<img\"));\n\n        assertTrue(!as.scan(\"<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n        assertTrue(!as.scan(\"<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>\", policy, AntiSamy.SAX)\n                .getCleanHTML().contains(\"<img\"));\n\n        assertTrue(!as.scan(\n                        \"<IMG SRC='&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041'>\",\n                        policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n        assertTrue(!as.scan(\n                        \"<IMG SRC='&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041'>\",\n                        policy, AntiSamy.SAX).getCleanHTML().contains(\"<img\"));\n\n        assertTrue(!as.scan(\"<IMG SRC=\\\"jav&#x0D;ascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n        assertTrue(!as.scan(\"<IMG SRC=\\\"jav&#x0D;ascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n        String s = as.scan(\n                        \"<IMG SRC=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>\",\n                        policy, AntiSamy.DOM).getCleanHTML();\n        assertTrue(s.length() == 0 || s.contains(\"&amp;\"));\n        s = as.scan( \"<IMG SRC=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>\",\n                        policy, AntiSamy.SAX).getCleanHTML();\n        assertTrue(s.length() == 0 || s.contains(\"&amp;\"));\n\n        as.scan(\"<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>\", policy, AntiSamy.DOM);\n        as.scan(\"<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>\", policy, AntiSamy.SAX);\n\n        assertTrue(!as.scan(\"<IMG SRC=\\\"javascript:alert('XSS')\\\"\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<IMG SRC=\\\"javascript:alert('XSS')\\\"\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<IMG LOWSRC=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<IMG LOWSRC=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<BGSOUND SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<BGSOUND SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n    }\n\n    @Test\n    public void hrefAttacks() throws ScanException, PolicyException {\n\n        assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"href\"));\n        assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"href\"));\n\n        assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"http://ha.ckers.org/xss.css\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"href\"));\n        assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"http://ha.ckers.org/xss.css\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"href\"));\n\n        assertTrue(!as.scan(\"<STYLE>@import'http://ha.ckers.org/xss.css';</STYLE>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"ha.ckers.org\"));\n        assertTrue(!as.scan(\"<STYLE>@import'http://ha.ckers.org/xss.css';</STYLE>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"ha.ckers.org\"));\n\n        assertTrue(!as.scan(\"<STYLE>BODY{-moz-binding:url(\\\"http://ha.ckers.org/xssmoz.xml#xss\\\")}</STYLE>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"ha.ckers.org\"));\n        assertTrue(!as.scan(\"<STYLE>BODY{-moz-binding:url(\\\"http://ha.ckers.org/xssmoz.xml#xss\\\")}</STYLE>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"ha.ckers.org\"));\n\n        assertTrue(!as.scan(\"<STYLE>li {list-style-image: url(\\\"javascript:alert('XSS')\\\");}</STYLE><UL><LI>XSS\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<STYLE>li {list-style-image: url(\\\"javascript:alert('XSS')\\\");}</STYLE><UL><LI>XSS\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<IMG SRC='vbscript:msgbox(\\\"XSS\\\")'>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"vbscript\"));\n        assertTrue(!as.scan(\"<IMG SRC='vbscript:msgbox(\\\"XSS\\\")'>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"vbscript\"));\n\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0; URL=http://;URL=javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<meta\"));\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0; URL=http://;URL=javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<meta\"));\n\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<meta\"));\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<meta\"));\n\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<meta\"));\n        assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<meta\"));\n\n        assertTrue(!as.scan(\"<IFRAME SRC=\\\"javascript:alert('XSS');\\\"></IFRAME>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"iframe\"));\n        assertTrue(!as.scan(\"<IFRAME SRC=\\\"javascript:alert('XSS');\\\"></IFRAME>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"iframe\"));\n\n        assertTrue(!as.scan(\"<FRAMESET><FRAME SRC=\\\"javascript:alert('XSS');\\\"></FRAMESET>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<FRAMESET><FRAME SRC=\\\"javascript:alert('XSS');\\\"></FRAMESET>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<TABLE BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"background\"));\n        assertTrue(!as.scan(\"<TABLE BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"background\"));\n\n        assertTrue(!as.scan(\"<TABLE><TD BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"background\"));\n        assertTrue(!as.scan(\"<TABLE><TD BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"background\"));\n\n        assertTrue(!as.scan(\"<DIV STYLE=\\\"background-image: url(javascript:alert('XSS'))\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<DIV STYLE=\\\"background-image: url(javascript:alert('XSS'))\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<DIV STYLE=\\\"width: expression(alert('XSS'));\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n        assertTrue(!as.scan(\"<DIV STYLE=\\\"width: expression(alert('XSS'));\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n        assertTrue(!as.scan(\"<IMG STYLE=\\\"xss:expr/*XSS*/ession(alert('XSS'))\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n        assertTrue(!as.scan(\"<IMG STYLE=\\\"xss:expr/*XSS*/ession(alert('XSS'))\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n        assertTrue(!as.scan(\"<STYLE>@im\\\\port'\\\\ja\\\\vasc\\\\ript:alert(\\\"XSS\\\")';</STYLE>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"ript:alert\"));\n        assertTrue(!as.scan(\"<STYLE>@im\\\\port'\\\\ja\\\\vasc\\\\ript:alert(\\\"XSS\\\")';</STYLE>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"ript:alert\"));\n\n        assertTrue(!as.scan(\"<BASE HREF=\\\"javascript:alert('XSS');//\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<BASE HREF=\\\"javascript:alert('XSS');//\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<BaSe hReF=\\\"http://arbitrary.com/\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<base\"));\n        assertTrue(!as.scan(\"<BaSe hReF=\\\"http://arbitrary.com/\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<base\"));\n\n        assertTrue(!as.scan(\"<OBJECT TYPE=\\\"text/x-scriptlet\\\" DATA=\\\"http://ha.ckers.org/scriptlet.html\\\"></OBJECT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<object\"));\n        assertTrue(!as.scan(\"<OBJECT TYPE=\\\"text/x-scriptlet\\\" DATA=\\\"http://ha.ckers.org/scriptlet.html\\\"></OBJECT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<object\"));\n\n        assertTrue(!as.scan(\"<OBJECT classid=clsid:ae24fdae-03c6-11d1-8b76-0080c744f389><param name=url value=javascript:alert('XSS')></OBJECT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n\n        CleanResults cr = as.scan(\"<OBJECT classid=clsid:ae24fdae-03c6-11d1-8b76-0080c744f389><param name=url value=javascript:alert('XSS')></OBJECT>\", policy, AntiSamy.SAX);\n        // System.out.println(cr.getErrorMessages().get(0));\n        assertTrue(!cr.getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<EMBED SRC=\\\"http://ha.ckers.org/xss.swf\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<embed\"));\n        assertTrue(!as.scan(\"<EMBED SRC=\\\"http://ha.ckers.org/xss.swf\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<embed\"));\n\n        assertTrue(!as.scan(\n                        \"<EMBED SRC=\\\"data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==\\\" type=\\\"image/svg+xml\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\",\n                        policy, AntiSamy.DOM).getCleanHTML().contains(\"<embed\"));\n        assertTrue(!as.scan(\n                        \"<EMBED SRC=\\\"data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==\\\" type=\\\"image/svg+xml\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\",\n                        policy, AntiSamy.SAX).getCleanHTML().contains(\"<embed\"));\n\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" '' SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" '' SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT a=`>` SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT a=`>` SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">'>\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT a=\\\">'>\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT>document.write(\\\"<SCRI\\\");</SCRIPT>PT SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"script\"));\n        assertTrue(!as.scan(\"<SCRIPT>document.write(\\\"<SCRI\\\");</SCRIPT>PT SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"script\"));\n\n        assertTrue(!as.scan(\"<SCRIPT SRC=http://ha.ckers.org/xss.js\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(\"<SCRIPT SRC=http://ha.ckers.org/xss.js\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n        assertTrue(!as.scan(\n                        \"<div/style=&#92&#45&#92&#109&#111&#92&#122&#92&#45&#98&#92&#105&#92&#110&#100&#92&#105&#110&#92&#103:&#92&#117&#114&#108&#40&#47&#47&#98&#117&#115&#105&#110&#101&#115&#115&#92&#105&#92&#110&#102&#111&#46&#99&#111&#46&#117&#107&#92&#47&#108&#97&#98&#115&#92&#47&#120&#98&#108&#92&#47&#120&#98&#108&#92&#46&#120&#109&#108&#92&#35&#120&#115&#115&#41&>\",\n                        policy, AntiSamy.DOM).getCleanHTML().contains(\"style\"));\n        assertTrue(!as.scan(\n                        \"<div/style=&#92&#45&#92&#109&#111&#92&#122&#92&#45&#98&#92&#105&#92&#110&#100&#92&#105&#110&#92&#103:&#92&#117&#114&#108&#40&#47&#47&#98&#117&#115&#105&#110&#101&#115&#115&#92&#105&#92&#110&#102&#111&#46&#99&#111&#46&#117&#107&#92&#47&#108&#97&#98&#115&#92&#47&#120&#98&#108&#92&#47&#120&#98&#108&#92&#46&#120&#109&#108&#92&#35&#120&#115&#115&#41&>\",\n                        policy, AntiSamy.SAX).getCleanHTML().contains(\"style\"));\n\n        assertTrue(!as.scan(\"<a href='aim: &c:\\\\windows\\\\system32\\\\calc.exe' ini='C:\\\\Documents and Settings\\\\All Users\\\\Start Menu\\\\Programs\\\\Startup\\\\pwnd.bat'>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"aim.exe\"));\n        assertTrue(!as.scan(\"<a href='aim: &c:\\\\windows\\\\system32\\\\calc.exe' ini='C:\\\\Documents and Settings\\\\All Users\\\\Start Menu\\\\Programs\\\\Startup\\\\pwnd.bat'>\", policy, AntiSamy.SAX)\n                .getCleanHTML().contains(\"aim.exe\"));\n\n        assertTrue(!as.scan(\"<!--\\n<A href=\\n- --><a href=javascript:alert:document.domain>test-->\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertTrue(!as.scan(\"<!--\\n<A href=\\n- --><a href=javascript:alert:document.domain>test-->\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        assertTrue(!as.scan(\"<a></a style=\\\"\\\"xx:expr/**/ession(document.appendChild(document.createElement('script')).src='http://h4k.in/i.js')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"document\"));\n        assertTrue(!as.scan(\"<a></a style=\\\"\\\"xx:expr/**/ession(document.appendChild(document.createElement('script')).src='http://h4k.in/i.js')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"document\"));\n    }\n\n    /*\n     * Test CSS protections.\n     */\n\n    @Test\n    public void cssAttacks() throws ScanException, PolicyException {\n\n        assertTrue(!as.scan(\"<div style=\\\"position:absolute\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"position\"));\n        assertTrue(!as.scan(\"<div style=\\\"position:absolute\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"position\"));\n\n        assertTrue(!as.scan(\"<style>b { position:absolute }</style>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"position\"));\n        assertTrue(!as.scan(\"<style>b { position:absolute }</style>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"position\"));\n\n        assertTrue(!as.scan(\"<div style=\\\"z-index:25\\\">test</div>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"z-index\"));\n        assertTrue(!as.scan(\"<div style=\\\"z-index:25\\\">test</div>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"z-index\"));\n\n        assertTrue(!as.scan(\"<style>z-index:25</style>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"z-index\"));\n        assertTrue(!as.scan(\"<style>z-index:25</style>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"z-index\"));\n    }\n\n    /*\n     * Test a bunch of strings that have tweaked the XML parsing capabilities of\n     * NekoHTML.\n     */\n    @Test\n    public void IllegalXML() throws PolicyException {\n\n        for (String BASE64_BAD_XML_STRING : BASE64_BAD_XML_STRINGS) {\n\n            try {\n                String testStr = new String(Base64.decodeBase64(BASE64_BAD_XML_STRING.getBytes()));\n                as.scan(testStr, policy, AntiSamy.DOM);\n                as.scan(testStr, policy, AntiSamy.SAX);\n\n            } catch (ScanException ex) {\n                // still success!\n            }\n        }\n\n        // This fails due to a bug in NekoHTML\n        // try {\n        // assertTrue (\n        // as.scan(\"<a . href=\\\"http://www.test.com\\\">\",policy, AntiSamy.DOM).getCleanHTML().indexOf(\"href\")\n        // != -1 );\n        // } catch (Exception e) {\n        // e.printStackTrace();\n        // fail(\"Couldn't parse malformed HTML: \" + e.getMessage());\n        // }\n\n        // This fails due to a bug in NekoHTML\n        // try {\n        // assertTrue (\n        // as.scan(\"<a - href=\\\"http://www.test.com\\\">\",policy, AntiSamy.DOM).getCleanHTML().indexOf(\"href\")\n        // != -1 );\n        // } catch (Exception e) {\n        // e.printStackTrace();\n        // fail(\"Couldn't parse malformed HTML: \" + e.getMessage());\n        // }\n\n        try {\n            assertTrue(as.scan(\"<style>\", policy, AntiSamy.DOM) != null);\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(\"Couldn't parse malformed HTML: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    public void issue12() throws ScanException, PolicyException {\n\n        /*\n         * issues 12 (and 36, which was similar). empty tags cause display\n         * problems/\"formjacking\"\n         */\n\n        Pattern p = Pattern.compile(\".*<strong(\\\\s*)/>.*\");\n        String s1 = as.scan(\"<br ><strong></strong><a>hello world</a><b /><i/><hr>\", policy, AntiSamy.DOM).getCleanHTML();\n        String s2 = as.scan(\"<br ><strong></strong><a>hello world</a><b /><i/><hr>\", policy, AntiSamy.SAX).getCleanHTML();\n\n        assertFalse(p.matcher(s1).matches());\n\n        p = Pattern.compile(\".*<b(\\\\s*)/>.*\");\n        assertFalse(p.matcher(s1).matches());\n        assertFalse(p.matcher(s2).matches());\n\n        p = Pattern.compile(\".*<i(\\\\s*)/>.*\");\n        assertFalse(p.matcher(s1).matches());\n        assertFalse(p.matcher(s2).matches());\n\n        assertTrue(s1.contains(\"<hr />\") || s1.contains(\"<hr/>\"));\n        assertTrue(s2.contains(\"<hr />\") || s2.contains(\"<hr/>\"));\n    }\n\n    @Test\n    public void issue20() throws ScanException, PolicyException {\n        String s = as.scan(\"<b><i>Some Text</b></i>\", policy, AntiSamy.DOM).getCleanHTML();\n        assertTrue(!s.contains(\"<i />\"));\n\n        s = as.scan(\"<b><i>Some Text</b></i>\", policy, AntiSamy.SAX).getCleanHTML();\n        assertTrue(!s.contains(\"<i />\"));\n    }\n\n    @Test\n    public void issue25() throws ScanException, PolicyException {\n        String s = \"<div style=\\\"margin: -5em\\\">Test</div>\";\n        String expected = \"<div style=\\\"\\\">Test</div>\";\n\n        String crDom = as.scan(s, policy, AntiSamy.DOM).getCleanHTML();\n        assertEquals(crDom, expected);\n        String crSax = as.scan(s, policy, AntiSamy.SAX).getCleanHTML();\n        assertEquals(crSax, expected);\n    }\n\n\n    @Test\n    public void issue28() throws ScanException, PolicyException {\n        String s1 = as.scan(\"<div style=\\\"font-family: Geneva, Arial, courier new, sans-serif\\\">Test</div>\", policy, AntiSamy.DOM).getCleanHTML();\n        String s2 = as.scan(\"<div style=\\\"font-family: Geneva, Arial, courier new, sans-serif\\\">Test</div>\", policy, AntiSamy.SAX).getCleanHTML();\n        assertTrue(s1.contains(\"font-family\"));\n        assertTrue(s2.contains(\"font-family\"));\n    }\n\n    @Test\n    public void issue29() throws ScanException, PolicyException {\n        /* issue #29 - missing quotes around properties with spaces */\n        String s = \"<style type=\\\"text/css\\\"><![CDATA[P {\\n\tfont-family: \\\"Arial Unicode MS\\\";\\n}\\n]]></style>\";\n        CleanResults cr = as.scan(s, policy, AntiSamy.DOM);\n        assertEquals(s, cr.getCleanHTML());\n    }\n\n    @Test\n    public void issue30() throws ScanException, PolicyException {\n\n        String s = \"<style type=\\\"text/css\\\"><![CDATA[P { margin-bottom: 0.08in; } ]]></style>\";\n\n        as.scan(s, policy, AntiSamy.DOM);\n        CleanResults cr;\n\n        /* followup - does the patch fix multiline CSS? */\n        String s2 = \"<style type=\\\"text/css\\\"><![CDATA[\\r\\nP {\\r\\n margin-bottom: 0.08in;\\r\\n}\\r\\n]]></style>\";\n        cr = as.scan(s2, policy, AntiSamy.DOM);\n        assertEquals(\"<style type=\\\"text/css\\\"><![CDATA[P {\\n\\tmargin-bottom: 0.08in;\\n}\\n]]></style>\", cr.getCleanHTML());\n\n        /* next followup - does non-CDATA parsing still work? */\n\n        String s3 = \"<style>P {\\n\\tmargin-bottom: 0.08in;\\n}\\n\";\n        cr = as.scan(s3, policy.cloneWithDirective(Policy.USE_XHTML, \"false\"), AntiSamy.DOM);\n        assertEquals(\"<style>P {\\n\\tmargin-bottom: 0.08in;\\n}\\n</style>\\n\", cr.getCleanHTML());\n    }\n\n    @Test\n    public void issue31() throws ScanException, PolicyException {\n\n        String test = \"<b><u><g>foo</g></u></b>\";\n        Policy revised = policy.cloneWithDirective(\"onUnknownTag\", \"encode\");\n        CleanResults cr = as.scan(test, revised, AntiSamy.DOM);\n        String s = cr.getCleanHTML();\n        assertFalse(!s.contains(\"&lt;g&gt;\"));\n        assertFalse(!s.contains(\"&lt;/g&gt;\"));\n        s = as.scan(test, revised, AntiSamy.SAX).getCleanHTML();\n        assertFalse(!s.contains(\"&lt;g&gt;\"));\n        assertFalse(!s.contains(\"&lt;/g&gt;\"));\n\n        Tag tag = policy.getTagByLowercaseName(\"b\").mutateAction(\"encode\");\n        Policy policy1 = policy.mutateTag(tag);\n\n        cr = as.scan(test, policy1, AntiSamy.DOM);\n        s = cr.getCleanHTML();\n\n        assertFalse(!s.contains(\"&lt;b&gt;\"));\n        assertFalse(!s.contains(\"&lt;/b&gt;\"));\n\n        cr = as.scan(test, policy1, AntiSamy.SAX);\n        s = cr.getCleanHTML();\n\n        assertFalse(!s.contains(\"&lt;b&gt;\"));\n        assertFalse(!s.contains(\"&lt;/b&gt;\"));\n    }\n\n    @Test\n    public void issue32() throws ScanException, PolicyException {\n        /* issue #32 - nekos problem */\n        String s = \"<SCRIPT =\\\">\\\" SRC=\\\"\\\"></SCRIPT>\";\n        as.scan(s, policy, AntiSamy.DOM);\n        as.scan(s, policy, AntiSamy.SAX);\n    }\n\n    @Test\n    public void issue37() throws ScanException, PolicyException {\n\n        String dirty = \"<a onblur=\\\"try {parent.deselectBloggerImageGracefully();}\" + \"catch(e) {}\\\"\"\n                + \"href=\\\"http://www.charityadvantage.com/ChildrensmuseumEaston/images/BookswithBill.jpg\\\"><img\" + \"style=\\\"FLOAT: right; MARGIN: 0px 0px 10px 10px; WIDTH: 150px; CURSOR:\"\n                + \"hand; HEIGHT: 100px\\\" alt=\\\"\\\"\" + \"src=\\\"http://www.charityadvantage.com/ChildrensmuseumEaston/images/BookswithBill.jpg\\\"\"\n                + \"border=\\\"0\\\" /></a><br />Poor Bill, couldn't make it to the Museum's <span\" + \"class=\\\"blsp-spelling-corrected\\\" id=\\\"SPELLING_ERROR_0\\\">story time</span>\"\n                + \"today, he was so busy shoveling! Well, we sure missed you Bill! So since\" + \"ou were busy moving snow we read books about snow. We found a clue in one\"\n                + \"book which revealed a snowplow at the end of the story - we wish it had\" + \"driven to your driveway Bill. We also read a story which shared fourteen\"\n                + \"<em>Names For Snow. </em>We'll catch up with you next week....wonder which\" + \"hat Bill will wear?<br />Jane\";\n\n        Policy mySpacePolicy = Policy.getInstance(getClass().getResource(\"/antisamy-myspace.xml\"));\n        CleanResults cr = as.scan(dirty, mySpacePolicy, AntiSamy.DOM);\n        assertNotNull(cr.getCleanHTML());\n        cr = as.scan(dirty, mySpacePolicy, AntiSamy.SAX);\n        assertNotNull(cr.getCleanHTML());\n\n        Policy ebayPolicy = Policy.getInstance(getClass().getResource(\"/antisamy-ebay.xml\"));\n        cr = as.scan(dirty, ebayPolicy, AntiSamy.DOM);\n        assertNotNull(cr.getCleanHTML());\n        cr = as.scan(dirty, mySpacePolicy, AntiSamy.SAX);\n        assertNotNull(cr.getCleanHTML());\n\n        Policy slashdotPolicy = Policy.getInstance(getClass().getResource(\"/antisamy-slashdot.xml\"));\n        cr = as.scan(dirty, slashdotPolicy, AntiSamy.DOM);\n        assertNotNull(cr.getCleanHTML());\n        cr = as.scan(dirty, slashdotPolicy, AntiSamy.SAX);\n        assertNotNull(cr.getCleanHTML());\n    }\n\n    @Test\n    public void issue38() throws ScanException, PolicyException {\n\n        /* issue #38 - color problem/color combinations */\n        String s = \"<font color=\\\"#fff\\\">Test</font>\";\n        String expected = \"<font color=\\\"#fff\\\">Test</font>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<div style=\\\"color: #fff\\\">Test 3 letter code</div>\";\n        expected = \"<div style=\\\"color: rgb(255,255,255);\\\">Test 3 letter code</div>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<font color=\\\"red\\\">Test</font>\";\n        expected = \"<font color=\\\"red\\\">Test</font>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<font color=\\\"neonpink\\\">Test</font>\";\n        expected = \"<font>Test</font>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<font color=\\\"#0000\\\">Test</font>\";\n        expected = \"<font>Test</font>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<div style=\\\"color: #0000\\\">Test</div>\";\n        expected = \"<div style=\\\"\\\">Test</div>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<font color=\\\"#000000\\\">Test</font>\";\n        expected = \"<font color=\\\"#000000\\\">Test</font>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        s = \"<div style=\\\"color: #000000\\\">Test</div>\";\n        expected = \"<div style=\\\"color: rgb(0,0,0);\\\">Test</div>\";\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getCleanHTML(), expected);\n        assertEquals(as.scan(s, policy, AntiSamy.SAX).getCleanHTML(), expected);\n\n        /*\n        * This test case was failing because of the following code from the\n        * batik CSS library, which throws an exception if any character\n        * other than a '!' follows a beginning token of '<'. The\n        * ParseException is now caught in the node a CssScanner.java and\n        * the outside AntiSamyDOMScanner.java.\n        *\n        * 0398 nextChar(); 0399 if (current != '!') { 0400 throw new\n        * ParseException(\"character\", 0401 reader.getLine(), 0402\n        * reader.getColumn());\n        */\n        s = \"<b><u>foo<style><script>alert(1)</script></style>@import 'x';</u>bar\";\n        as.scan(s, policy, AntiSamy.DOM);\n        as.scan(s, policy, AntiSamy.SAX);\n    }\n\n    @Test\n    public void issue40() throws ScanException, PolicyException {\n\n        /* issue #40 - handling <style> media attributes right */\n\n        String s = \"<style media=\\\"print, projection, screen\\\"> P { margin: 1em; }</style>\";\n        Policy revised = policy.cloneWithDirective(Policy.PRESERVE_SPACE, \"true\");\n\n        CleanResults cr = as.scan(s, revised, AntiSamy.DOM);\n        assertTrue(cr.getCleanHTML().contains(\"print, projection, screen\"));\n\n        cr = as.scan(s, revised, AntiSamy.SAX);\n        assertTrue(cr.getCleanHTML().contains(\"print, projection, screen\"));\n    }\n\n    @Test\n    public void issue41() throws ScanException, PolicyException {\n        /* issue #41 - comment handling */\n\n        Policy revised = policy.cloneWithDirective(Policy.PRESERVE_SPACE, \"true\");\n\n        policy.cloneWithDirective(Policy.PRESERVE_COMMENTS, \"false\");\n\n        assertEquals(\"text \", as.scan(\"text <!-- comment -->\", revised, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"text \", as.scan(\"text <!-- comment -->\", revised, AntiSamy.SAX).getCleanHTML());\n\n        Policy revised2 = policy.cloneWithDirective(Policy.PRESERVE_COMMENTS, \"true\").cloneWithDirective(Policy.PRESERVE_SPACE, \"true\").cloneWithDirective(Policy.FORMAT_OUTPUT, \"false\");\n\n        /*\n        * These make sure the regular comments are kept alive and that\n        * conditional comments are ripped out.\n        */\n        assertEquals(\"<div>text <!-- comment --></div>\", as.scan(\"<div>text <!-- comment --></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"<div>text <!-- comment --></div>\", as.scan(\"<div>text <!-- comment --></div>\", revised2, AntiSamy.SAX).getCleanHTML());\n\n        assertEquals(\"<div>text <!-- comment --></div>\", as.scan(\"<div>text <!--[if IE]> comment <[endif]--></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"<div>text <!-- comment --></div>\", as.scan(\"<div>text <!--[if IE]> comment <[endif]--></div>\", revised2, AntiSamy.SAX).getCleanHTML());\n\n        /*\n        * Check to see how nested conditional comments are handled. This is\n        * not very clean but the main goal is to avoid any tags. Not sure\n        * on encodings allowed in comments.\n        */\n        String input = \"<div>text <!--[if IE]> <!--[if gte 6]> comment <[endif]--><[endif]--></div>\";\n        String expected = \"<div>text <!-- <!-- comment -->&lt;[endif]--&gt;</div>\";\n        String output = as.scan(input, revised2, AntiSamy.DOM).getCleanHTML();\n        assertEquals(expected, output);\n\n        input = \"<div>text <!--[if IE]> <!--[if gte 6]> comment <[endif]--><[endif]--></div>\";\n        expected = \"<div>text <!-- <!-- comment -->&lt;[endif]--&gt;</div>\";\n        output = as.scan(input, revised2, AntiSamy.SAX).getCleanHTML();\n\n        assertEquals(expected, output);\n\n        /*\n        * Regular comment nested inside conditional comment. Test makes\n        * sure\n        */\n        assertEquals(\"<div>text <!-- <!-- IE specific --> comment &lt;[endif]--&gt;</div>\", as.scan(\"<div>text <!--[if IE]> <!-- IE specific --> comment <[endif]--></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n\n        /*\n        * These play with whitespace and have invalid comment syntax.\n        */\n        assertEquals(\"<div>text <!-- \\ncomment --></div>\", as.scan(\"<div>text <!-- [ if lte 6 ]>\\ncomment <[ endif\\n]--></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"<div>text  comment </div>\", as.scan(\"<div>text <![if !IE]> comment <![endif]></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"<div>text  comment </div>\", as.scan(\"<div>text <![ if !IE]> comment <![endif]></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n\n        String attack = \"[if lte 8]<script>\";\n        String spacer = \"<![if IE]>\";\n\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(\"<div>text<!\");\n\n        for (int i = 0; i < attack.length(); i++) {\n            sb.append(attack.charAt(i));\n            sb.append(spacer);\n        }\n\n        sb.append(\"<![endif]>\");\n\n        String s = sb.toString();\n\n        assertTrue(!as.scan(s, revised2, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n        assertTrue(!as.scan(s, revised2, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n    }\n\n    @Test\n    public void issue44() throws ScanException, PolicyException {\n        /*\n         * issue #44 - childless nodes of non-allowed elements won't cause an error\n         */\n        String s = \"<iframe src='http://foo.com/'></iframe>\" + \"<script src=''></script>\" + \"<link href='/foo.css'>\";\n        as.scan(s, policy, AntiSamy.DOM);\n        assertEquals(as.scan(s, policy, AntiSamy.DOM).getNumberOfErrors(), 3);\n\n        CleanResults cr = as.scan(s, policy, AntiSamy.SAX);\n\n        assertEquals(cr.getNumberOfErrors(), 3);\n    }\n\n    @Test\n    public void issue51() throws ScanException, PolicyException {\n        /* issue #51 - offsite URLs with () are found to be invalid */\n        String s = \"<a href='http://subdomain.domain/(S(ke0lpq54bw0fvp53a10e1a45))/MyPage.aspx'>test</a>\";\n        CleanResults cr = as.scan(s, policy, AntiSamy.DOM);\n\n        assertEquals(cr.getNumberOfErrors(), 0);\n\n        cr = as.scan(s, policy, AntiSamy.SAX);\n        assertEquals(cr.getNumberOfErrors(), 0);\n    }\n\n    @Test\n    public void issue56() throws ScanException, PolicyException {\n        /* issue #56 - unnecessary spaces */\n\n        String s = \"<SPAN style='font-weight: bold;'>Hello World!</SPAN>\";\n        String expected = \"<span style=\\\"font-weight: bold;\\\">Hello World!</span>\";\n\n        CleanResults cr = as.scan(s, policy, AntiSamy.DOM);\n        String s2 = cr.getCleanHTML();\n\n        assertEquals(expected, s2);\n\n        cr = as.scan(s, policy, AntiSamy.SAX);\n        s2 = cr.getCleanHTML();\n\n        assertEquals(expected, s2);\n    }\n\n    @Test\n    public void issue58() throws ScanException, PolicyException {\n        /* issue #58 - input not in list of allowed-to-be-empty tags */\n        String s = \"tgdan <input/> g  h\";\n        CleanResults cr = as.scan(s, policy, AntiSamy.DOM);\n        assertTrue(cr.getErrorMessages().size() == 0);\n\n        cr = as.scan(s, policy, AntiSamy.SAX);\n        assertTrue(cr.getErrorMessages().size() == 0);\n    }\n\n    @Test\n    public void issue61() throws ScanException, PolicyException {\n        /* issue #61 - input has newline appended if ends with an accepted tag */\n        String dirtyInput = \"blah <b>blah</b>.\";\n        Policy revised = policy.cloneWithDirective(Policy.FORMAT_OUTPUT, \"false\");\n        CleanResults cr = as.scan(dirtyInput, revised, AntiSamy.DOM);\n        assertEquals(dirtyInput, cr.getCleanHTML());\n\n        cr = as.scan(dirtyInput, revised, AntiSamy.SAX);\n        assertEquals(dirtyInput, cr.getCleanHTML());\n    }\n\n    @Test\n    public void issue69() throws ScanException, PolicyException {\n\n        /* issue #69 - char attribute should allow single char or entity ref */\n\n        String s = \"<table><tr><td char='.'>test</td></tr></table>\";\n        CleanResults crDom = as.scan(s, policy, AntiSamy.DOM);\n        CleanResults crSax = as.scan(s, policy, AntiSamy.SAX);\n        String domValue = crDom.getCleanHTML();\n        String saxValue = crSax.getCleanHTML();\n        assertTrue(domValue.contains(\"char\"));\n        assertTrue(saxValue.contains(\"char\"));\n\n        s = \"<table><tr><td char='..'>test</td></tr></table>\";\n        assertTrue(!as.scan(s, policy, AntiSamy.DOM).getCleanHTML().contains(\"char\"));\n        assertTrue(!as.scan(s, policy, AntiSamy.SAX).getCleanHTML().contains(\"char\"));\n\n        s = \"<table><tr><td char='&quot;'>test</td></tr></table>\";\n        assertTrue(as.scan(s, policy, AntiSamy.DOM).getCleanHTML().contains(\"char\"));\n        assertTrue(as.scan(s, policy, AntiSamy.SAX).getCleanHTML().contains(\"char\"));\n\n        s = \"<table><tr><td char='&quot;a'>test</td></tr></table>\";\n        assertTrue(!as.scan(s, policy, AntiSamy.DOM).getCleanHTML().contains(\"char\"));\n        assertTrue(!as.scan(s, policy, AntiSamy.SAX).getCleanHTML().contains(\"char\"));\n\n        s = \"<table><tr><td char='&quot;&amp;'>test</td></tr></table>\";\n        assertTrue(!as.scan(s, policy, AntiSamy.DOM).getCleanHTML().contains(\"char\"));\n        assertTrue(!as.scan(s, policy, AntiSamy.SAX).getCleanHTML().contains(\"char\"));\n    }\n\n    @Test\n    public void CDATAByPass() throws ScanException, PolicyException {\n        String malInput = \"<![CDATA[]><script>alert(1)</script>]]>\";\n        CleanResults crd = as.scan(malInput, policy, AntiSamy.DOM);\n        CleanResults crs = as.scan(malInput, policy, AntiSamy.SAX);\n        String crDom = crd.getCleanHTML();\n        String crSax = crs.getCleanHTML();\n\n        assertTrue(crd.getErrorMessages().size() > 0);\n        assertTrue(crs.getErrorMessages().size() > 0);\n\n        assertTrue(crSax.contains(\"&lt;script\") && !crDom.contains(\"<script\"));\n        assertTrue(crDom.contains(\"&lt;script\") && !crDom.contains(\"<script\"));\n    }\n\n    @Test\n    public void literalLists() throws ScanException, PolicyException {\n\n        /* this test is for confirming literal-lists work as\n         * advertised. it turned out to be an invalid / non-\n         * reproducible bug report but the test seemed useful\n         * enough to keep.\n         */\n        String malInput = \"hello<p align='invalid'>world</p>\";\n\n        CleanResults crd = as.scan(malInput, policy, AntiSamy.DOM);\n        String crDom = crd.getCleanHTML();\n        CleanResults crs = as.scan(malInput, policy, AntiSamy.SAX);\n        String crSax = crs.getCleanHTML();\n\n        assertTrue(!crSax.contains(\"invalid\"));\n        assertTrue(!crDom.contains(\"invalid\"));\n\n        assertTrue(crd.getErrorMessages().size() == 1);\n        assertTrue(crs.getErrorMessages().size() == 1);\n\n        String goodInput = \"hello<p align='left'>world</p>\";\n        crDom = as.scan(goodInput, policy, AntiSamy.DOM).getCleanHTML();\n        crSax = as.scan(goodInput, policy, AntiSamy.SAX).getCleanHTML();\n\n        assertTrue(crSax.contains(\"left\"));\n        assertTrue(crDom.contains(\"left\"));\n    }\n\n    @Test\n    public void stackExhaustion() throws ScanException, PolicyException {\n        /*\n        * Test Julian Cohen's stack exhaustion bug.\n        */\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 249; i++) {\n            sb.append(\"<div>\");\n        }\n        /*\n        * First, make sure this attack is useless against the\n        * SAX parser.\n        */\n        as.scan(sb.toString(), policy, AntiSamy.SAX);\n\n        /*\n        * Scan this really deep tree (depth=249, 1 less than the\n        * max) and make sure it doesn't blow up.\n        */\n\n        CleanResults crd = as.scan(sb.toString(), policy, AntiSamy.DOM);\n\n        String crDom = crd.getCleanHTML();\n        assertTrue(crDom.length() != 0);\n        /*\n        * Now push it over the limit to 251 and make sure we blow\n        * up safely.\n        */\n        sb.append(\"<div><div>\"); // this makes 251\n\n        try {\n            as.scan(sb.toString(), policy, AntiSamy.DOM);\n            fail(\"DOM depth exceeded max - should've errored\");\n        } catch (ScanException e) {\n            // An error is expected. Pass\n        }\n    }\n\n    @Test\n    public void issue107() throws ScanException, PolicyException {\n        StringBuilder sb = new StringBuilder();\n\n        /*\n         * #107 - erroneous newlines appearing? couldn't reproduce this\n         * error but the test seems worthy of keeping.\n         */\n        String nl = \"\\n\";\n\n        String header = \"<h1>Header</h1>\";\n        String para = \"<p>Paragraph</p>\";\n        sb.append(header);\n        sb.append(nl);\n        sb.append(para);\n\n        String html = sb.toString();\n\n        String crDom = as.scan(html, policy, AntiSamy.DOM).getCleanHTML();\n        String crSax = as.scan(html, policy, AntiSamy.SAX).getCleanHTML();\n\n        /* Make sure only 1 newline appears */\n        assertTrue(crDom.lastIndexOf(nl) == crDom.indexOf(nl));\n        assertTrue(crSax.lastIndexOf(nl) == crSax.indexOf(nl));\n\n        int expectedLoc = header.length();\n        int actualLoc = crSax.indexOf(nl);\n        assertTrue(expectedLoc == actualLoc);\n\n        actualLoc = crDom.indexOf(nl);\n        // account for line separator length difference across OSes.\n        assertTrue(expectedLoc == actualLoc || expectedLoc == actualLoc + 1);\n    }\n\n    @Test\n    public void issue112() throws ScanException, PolicyException {\n        TestPolicy revised = policy.cloneWithDirective(Policy.PRESERVE_COMMENTS, \"true\").cloneWithDirective(Policy.PRESERVE_SPACE, \"true\").cloneWithDirective(Policy.FORMAT_OUTPUT, \"false\");\n\n        /*\n        * #112 - empty tag becomes self closing\n        */\n\n        String html = \"text <strong></strong> text <strong><em></em></strong> text\";\n\n        String crDom = as.scan(html, revised, AntiSamy.DOM).getCleanHTML();\n        String crSax = as.scan(html, revised, AntiSamy.SAX).getCleanHTML();\n\n        assertTrue(!crDom.contains(\"<strong />\") && !crDom.contains(\"<strong/>\"));\n        assertTrue(!crSax.contains(\"<strong />\") && !crSax.contains(\"<strong/>\"));\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<html><head><title>foobar</title></head><body>\");\n        sb.append(\"<img src=\\\"http://foobar.com/pic.gif\\\" /></body></html>\");\n\n        html = sb.toString();\n\n        Policy aTrue = revised.cloneWithDirective(Policy.USE_XHTML, \"true\");\n        crDom = as.scan(html, aTrue, AntiSamy.DOM).getCleanHTML();\n        crSax = as.scan(html, aTrue, AntiSamy.SAX).getCleanHTML();\n\n        assertTrue(html.equals(crDom));\n        assertTrue(html.equals(crSax));\n    }\n\n\n    @Test\n    public void nestedCdataAttacks() throws ScanException, PolicyException {\n\n        /*\n        * Testing for nested CDATA attacks against the SAX parser.\n        */\n\n        String html = \"<![CDATA[]><script>alert(1)</script><![CDATA[]>]]><script>alert(2)</script>>]]>\";\n        String crDom = as.scan(html, policy, AntiSamy.DOM).getCleanHTML();\n        String crSax = as.scan(html, policy, AntiSamy.SAX).getCleanHTML();\n        assertTrue(!crDom.contains(\"<script>\"));\n        assertTrue(!crSax.contains(\"<script>\"));\n    }\n\n    @Test\n    public void issue101InternationalCharacterSupport() throws ScanException, PolicyException {\n        Policy revised = policy.cloneWithDirective(Policy.ENTITY_ENCODE_INTL_CHARS, \"false\");\n\n        String html = \"<b>letter 'a' with umlaut: \\u00e4\";\n        String crDom = as.scan(html, revised, AntiSamy.DOM).getCleanHTML();\n        String crSax = as.scan(html, revised, AntiSamy.SAX).getCleanHTML();\n        assertTrue(crDom.contains(\"\\u00e4\"));\n        assertTrue(crSax.contains(\"\\u00e4\"));\n\n        Policy revised2 = policy.cloneWithDirective(Policy.USE_XHTML, \"false\").cloneWithDirective(Policy.ENTITY_ENCODE_INTL_CHARS, \"true\");\n        crDom = as.scan(html, revised2, AntiSamy.DOM).getCleanHTML();\n        crSax = as.scan(html, revised2, AntiSamy.SAX).getCleanHTML();\n        assertTrue(!crDom.contains(\"\\u00e4\"));\n        assertTrue(crDom.contains(\"&auml;\"));\n        assertTrue(!crSax.contains(\"\\u00e4\"));\n        assertTrue(crSax.contains(\"&auml;\"));\n\n        Policy revised3 = policy.cloneWithDirective(Policy.USE_XHTML, \"true\").cloneWithDirective(Policy.ENTITY_ENCODE_INTL_CHARS, \"true\");\n        crDom = as.scan(html, revised3, AntiSamy.DOM).getCleanHTML();\n        crSax = as.scan(html, revised3, AntiSamy.SAX).getCleanHTML();\n        assertTrue(!crDom.contains(\"\\u00e4\"));\n        assertTrue(crDom.contains(\"&auml;\"));\n        assertTrue(!crSax.contains(\"\\u00e4\"));\n        assertTrue(crSax.contains(\"&auml;\"));\n    }\n\n    @Test\n    public void iframeAsReportedByOndrej() throws ScanException, PolicyException {\n        String html = \"<iframe></iframe>\";\n\n        Tag tag = new Tag(\"iframe\", Collections.<String, Attribute>emptyMap(), Policy.ACTION_VALIDATE);\n        Policy revised = policy.addTagRule(tag);\n\n        String crDom = as.scan(html, revised, AntiSamy.DOM).getCleanHTML();\n        String crSax = as.scan(html, revised, AntiSamy.SAX).getCleanHTML();\n\n        assertTrue(html.equals(crDom));\n        assertTrue(html.equals(crSax));\n    }\n\n    /*\n\t * Tests cases dealing with nofollowAnchors directive. Assumes anchor tags\n\t * have an action set to \"validate\" (may be implicit) in the policy file.\n\t */\n    @Test\n    public void nofollowAnchors() throws ScanException, PolicyException {\n\n        // if we have activated nofollowAnchors\n        Policy revisedPolicy = policy.cloneWithDirective(Policy.ANCHORS_NOFOLLOW, \"true\");\n\n        // adds when not present\n        assertTrue(as.scan(\"<a href=\\\"blah\\\">link</a>\", revisedPolicy, AntiSamy.DOM).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n        assertTrue(as.scan(\"<a href=\\\"blah\\\">link</a>\", revisedPolicy, AntiSamy.SAX).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n\n        // adds properly even with bad attr\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" bad=\\\"true\\\">link</a>\", revisedPolicy, AntiSamy.DOM).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" bad=\\\"true\\\">link</a>\", revisedPolicy, AntiSamy.SAX).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n\n        // rel with bad value gets corrected\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"blh\\\">link</a>\", revisedPolicy, AntiSamy.DOM).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"blh\\\">link</a>\", revisedPolicy, AntiSamy.SAX).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n\n        // correct attribute doesn't get messed with\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n\n        // if two correct attributes, only one remaining after scan\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\" rel=\\\"nofollow\\\">link</a>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n        assertTrue(as.scan(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\" rel=\\\"nofollow\\\">link</a>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<a href=\\\"blah\\\" rel=\\\"nofollow\\\">link</a>\"));\n\n        // test if value is off - does it add?\n        assertTrue(!as.scan(\"a href=\\\"blah\\\">link</a>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"nofollow\"));\n        assertTrue(!as.scan(\"a href=\\\"blah\\\">link</a>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"nofollow\"));\n    }\n\n    @Test\n    public void validateParamAsEmbed() throws ScanException, PolicyException {\n        // activate policy setting for this test\n        Policy revised = policy.cloneWithDirective(Policy.VALIDATE_PARAM_AS_EMBED, \"true\").cloneWithDirective(Policy.FORMAT_OUTPUT, \"false\").cloneWithDirective(Policy.USE_XHTML, \"true\");\n\n        // let's start with a YouTube embed\n        String input = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&hl=en&fs=1&\\\"></param><param name=\\\"allowFullScreen\\\" value=\\\"true\\\"></param><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\"></param><embed src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&hl=en&fs=1&\\\" type=\\\"application/x-shockwave-flash\\\" allowscriptaccess=\\\"always\\\" allowfullscreen=\\\"true\\\" width=\\\"560\\\" height=\\\"340\\\"></embed></object>\";\n        String expectedOutput = \"<object height=\\\"340\\\" width=\\\"560\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" /><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /><embed allowfullscreen=\\\"true\\\" allowscriptaccess=\\\"always\\\" height=\\\"340\\\" src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" type=\\\"application/x-shockwave-flash\\\" width=\\\"560\\\" /></object>\";\n        CleanResults cr = as.scan(input, revised, AntiSamy.DOM);\n        assertThat(cr.getCleanHTML(), containsString(expectedOutput));\n\n        String saxExpectedOutput = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" /><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /><embed src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" type=\\\"application/x-shockwave-flash\\\" allowscriptaccess=\\\"always\\\" allowfullscreen=\\\"true\\\" width=\\\"560\\\" height=\\\"340\\\" /></object>\";\n        cr = as.scan(input, revised, AntiSamy.SAX);\n        assertThat(cr.getCleanHTML(), equalTo(saxExpectedOutput));\n\n        // now what if someone sticks malicious URL in the value of the\n        // value attribute in the param tag? remove that param tag\n        input = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"movie\\\" value=\\\"http://supermaliciouscode.com/badstuff.swf\\\"></param><param name=\\\"allowFullScreen\\\" value=\\\"true\\\"></param><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\"></param><embed src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&hl=en&fs=1&\\\" type=\\\"application/x-shockwave-flash\\\" allowscriptaccess=\\\"always\\\" allowfullscreen=\\\"true\\\" width=\\\"560\\\" height=\\\"340\\\"></embed></object>\";\n        expectedOutput = \"<object height=\\\"340\\\" width=\\\"560\\\"><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /><embed allowfullscreen=\\\"true\\\" allowscriptaccess=\\\"always\\\" height=\\\"340\\\" src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" type=\\\"application/x-shockwave-flash\\\" width=\\\"560\\\" /></object>\";\n        saxExpectedOutput = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /><embed src=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" type=\\\"application/x-shockwave-flash\\\" allowscriptaccess=\\\"always\\\" allowfullscreen=\\\"true\\\" width=\\\"560\\\" height=\\\"340\\\" /></object>\";\n        cr = as.scan(input, revised, AntiSamy.DOM);\n        assertThat(cr.getCleanHTML(), containsString(expectedOutput));\n\n        cr = as.scan(input, revised, AntiSamy.SAX);\n        assertThat(cr.getCleanHTML(), equalTo(saxExpectedOutput));\n\n        // now what if someone sticks malicious URL in the value of the src\n        // attribute in the embed tag? remove that embed tag\n        input = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&hl=en&fs=1&\\\"></param><param name=\\\"allowFullScreen\\\" value=\\\"true\\\"></param><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\"></param><embed src=\\\"http://hereswhereikeepbadcode.com/ohnoscary.swf\\\" type=\\\"application/x-shockwave-flash\\\" allowscriptaccess=\\\"always\\\" allowfullscreen=\\\"true\\\" width=\\\"560\\\" height=\\\"340\\\"></embed></object>\";\n        expectedOutput = \"<object height=\\\"340\\\" width=\\\"560\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" /><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /></object>\";\n        saxExpectedOutput = \"<object width=\\\"560\\\" height=\\\"340\\\"><param name=\\\"movie\\\" value=\\\"http://www.youtube.com/v/IyAyd4WnvhU&amp;hl=en&amp;fs=1&amp;\\\" /><param name=\\\"allowFullScreen\\\" value=\\\"true\\\" /><param name=\\\"allowscriptaccess\\\" value=\\\"always\\\" /></object>\";\n\n        cr = as.scan(input, revised, AntiSamy.DOM);\n        assertThat(cr.getCleanHTML(), containsString(expectedOutput));\n        CleanResults scan = as.scan(input, revised, AntiSamy.SAX);\n        assertThat(scan.getCleanHTML(), equalTo(saxExpectedOutput));\n    }\n\n    @Test\n    public void compareSpeedsShortStrings() throws IOException, ScanException, PolicyException {\n\n        double totalDomTime = 0;\n        double totalSaxTime = 0;\n\n        int testReps = 1000;\n\n        String html = \"<body> hey you <img/> out there on your own </body>\";\n\n        for (int j = 0; j < testReps; j++) {\n            totalDomTime += as.scan(html, policy, AntiSamy.DOM).getScanTime();\n            totalSaxTime += as.scan(html, policy, AntiSamy.SAX).getScanTime();\n        }\n\n        System.out.println(\"Total DOM time short string: \" + totalDomTime);\n        System.out.println(\"Total SAX time short string: \" + totalSaxTime);\n    }\n\n    @Test\n    public void profileDom() throws IOException, ScanException, PolicyException {\n        runProfiledTest(AntiSamy.DOM);\n    }\n\n    @Test\n    public void profileSax() throws IOException, ScanException, PolicyException {\n        runProfiledTest(AntiSamy.SAX);\n    }\n\n    private void runProfiledTest(int scanType) throws ScanException, PolicyException {\n        double totalDomTime;\n\n        warmup(scanType);\n\n        int testReps = 9999;\n\n        String html = \"<body> hey you <img/> out there on your own </body>\";\n\n        Double each = 0D;\n        int repeats = 10;\n        for (int i = 0; i < repeats; i++) {\n            totalDomTime = 0;\n            for (int j = 0; j < testReps; j++) {\n                totalDomTime += as.scan(html, policy, scanType).getScanTime();\n            }\n            each = each + totalDomTime;\n            System.out.println(\"Total \" + (scanType == AntiSamy.DOM ? \"DOM\" : \"SAX\") + \" time 9999 reps short string: \" + totalDomTime);\n        }\n        System.out.println(\"Average time: \" + (each / repeats));\n    }\n\n    private void warmup(int scanType) throws ScanException, PolicyException {\n        int warmupReps = 15000;\n\n        String html = \"<body> hey you <img/> out there on your own </body>\";\n\n        for (int j = 0; j < warmupReps; j++) {\n            as.scan(html, policy, scanType).getScanTime();\n        }\n    }\n\n    @Test\n    public void comparePatternSpeed() throws IOException, ScanException, PolicyException {\n\n        final Pattern invalidXmlCharacters =\n                Pattern.compile(\"[\\\\u0000-\\\\u001F\\\\uD800-\\\\uDFFF\\\\uFFFE-\\\\uFFFF&&[^\\\\u0009\\\\u000A\\\\u000D]]\");\n\n        int testReps = 10000;\n\n        String html = \"<body> hey you <img/> out there on your own </body>\";\n\n        String s = null;\n        //long start = System.currentTimeMillis();\n        for (int j = 0; j < testReps; j++) {\n            s = invalidXmlCharacters.matcher(html).replaceAll(\"\");\n        }\n        //long total = System.currentTimeMillis() - start;\n\n        //start = System.currentTimeMillis();\n        Matcher matcher;\n        for (int j = 0; j < testReps; j++) {\n            matcher = invalidXmlCharacters.matcher(html);\n            if (matcher.matches()) {\n                s = matcher.replaceAll(\"\");\n            }\n        }\n        //long total2 = System.currentTimeMillis() - start;\n\n        assertNotNull(s);\n        //System.out.println(\"replaceAllDirect \" + total);\n        //System.out.println(\"match then replace: \" + total2);\n    }\n\n    @Test\n    public void testOnsiteRegex() throws ScanException, PolicyException {\n    \tassertIsGoodOnsiteURL(\"foo\");\n    \tassertIsGoodOnsiteURL(\"/foo/bar\");\n    \tassertIsGoodOnsiteURL(\"../../di.cgi?foo&amp;3D~\");\n    \tassertIsGoodOnsiteURL(\"/foo/bar/1/sdf;jsessiond=1f1f12312_123123\");\n    }\n    \n    void assertIsGoodOnsiteURL(String url) throws ScanException, PolicyException {\n    \tString html = as.scan(\"<a href=\\\"\" + url + \"\\\">X</a>\", policy, AntiSamy.DOM).getCleanHTML();\n        assertThat(html, containsString(\"href=\\\"\"));\n\t}\n    \n\t@Test\n    public void issue10() throws ScanException, PolicyException {\n    \tassertFalse(as.scan(\"<a href=\\\"javascript&colon;alert&lpar;1&rpar;\\\">X</a>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n        assertFalse(as.scan(\"<a href=\\\"javascript&colon;alert&lpar;1&rpar;\\\">X</a>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n    }\n    \n    @Test\n    public void issue147() throws ScanException, PolicyException {\n        URL url = getClass().getResource(\"/antisamy-tinymce.xml\");\n\n        Policy pol = Policy.getInstance(url);\n        as.scan(\"<table><tr><td></td></tr></table>\", pol, AntiSamy.DOM);\n    }\n\n    @Test\n    public void issue75() throws ScanException, PolicyException {\n        URL url = getClass().getResource(\"/antisamy-tinymce.xml\");\n        Policy pol = Policy.getInstance(url);\n        as.scan(\"<script src=\\\"<. \\\">\\\"></script>\", pol, AntiSamy.DOM);\n        as.scan(\"<script src=\\\"<. \\\">\\\"></script>\", pol, AntiSamy.SAX);\n    }\n\n    @Test\n    public void issue144() throws ScanException, PolicyException {\n        String pinata = \"pi\\u00f1ata\";\n        CleanResults results = as.scan(pinata, policy, AntiSamy.DOM);\n        String cleanHTML = results.getCleanHTML();\n        assertEquals(pinata, cleanHTML);\n    }\n\n    @Test\n    public void testWhitespaceNotBeingMangled() throws ScanException, PolicyException {\n        String test = \"<select name=\\\"name\\\"><option value=\\\"Something\\\">Something</select>\";\n        String expected = \"<select name=\\\"name\\\"><option value=\\\"Something\\\">Something</option></select>\";\n        Policy preserveSpace = policy.cloneWithDirective( Policy.PRESERVE_SPACE, \"true\" );\n        CleanResults preserveSpaceResults = as.scan(test, preserveSpace, AntiSamy.SAX);\n        assertEquals( expected, preserveSpaceResults.getCleanHTML() );\n    }\n\n    @Test\n    public void testDataTag159() throws ScanException, PolicyException {\n        /* issue #159 - allow dynamic HTML5 data-* attribute */\n        String good = \"<p data-tag=\\\"abc123\\\">Hello World!</p>\";\n        String bad = \"<p dat-tag=\\\"abc123\\\">Hello World!</p>\";\n        String goodExpected = \"<p data-tag=\\\"abc123\\\">Hello World!</p>\";\n        String badExpected = \"<p>Hello World!</p>\";\n        // test good attribute \"data-\"\n        CleanResults cr = as.scan(good, policy, AntiSamy.SAX);\n        String s = cr.getCleanHTML();\n        assertEquals(goodExpected, s);\n        cr = as.scan(good, policy, AntiSamy.DOM);\n        s = cr.getCleanHTML();\n        assertEquals(goodExpected, s);\n\n        // test bad attribute \"dat-\"\n        cr = as.scan(bad, policy, AntiSamy.SAX);\n        s = cr.getCleanHTML();\n        assertEquals(badExpected, s);\n        cr = as.scan(bad, policy, AntiSamy.DOM);\n        s = cr.getCleanHTML();\n        assertEquals(badExpected, s);\n    }\n\n    @Test\n    public void testXSSInAntiSamy151() throws ScanException, PolicyException {\n        String test = \"<bogus>whatever</bogus><img src=\\\"https://ssl.gstatic.com/codesite/ph/images/defaultlogo.png\\\" \"\n            + \"onmouseover=\\\"alert('xss')\\\">\";\n        CleanResults results_sax = as.scan(test, policy, AntiSamy.SAX);\n        CleanResults results_dom = as.scan(test, policy, AntiSamy.DOM);\n\n        assertEquals( results_sax.getCleanHTML(), results_dom.getCleanHTML());\n        assertEquals(\"whatever<img src=\\\"https://ssl.gstatic.com/codesite/ph/images/defaultlogo.png\\\" />\", results_dom.getCleanHTML());\n    }\n\n    @Test\n    public void testAnotherXSS() throws ScanException, PolicyException {\n        String test = \"<a href=\\\"http://example.com\\\"&amp;/onclick=alert(9)>foo</a>\";\n        CleanResults results_sax = as.scan(test, policy, AntiSamy.SAX);\n        CleanResults results_dom = as.scan(test, policy, AntiSamy.DOM);\n\n        assertEquals( results_sax.getCleanHTML(), results_dom.getCleanHTML());\n        assertEquals(\"<a href=\\\"http://example.com\\\" rel=\\\"nofollow\\\">foo</a>\", results_dom.getCleanHTML());\n    }\n\n    @Test\n    public void testIssue2() throws ScanException, PolicyException {\n        String test = \"<style onload=alert(1)>h1 {color:red;}</style>\";\n        assertThat(as.scan(test, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"alert\")));\n        assertThat(as.scan(test, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"alert\")));\n    }\n    \n    /*\n     * Mailing list user sent this in. Didn't work, but good test to leave in.\n     */\n    @Test\n    public void testUnknownTags() throws ScanException, PolicyException {\n        String test = \"<%/onmouseover=prompt(1)>\";\n        CleanResults saxResults = as.scan(test, policy, AntiSamy.SAX);\n        CleanResults domResults = as.scan(test, policy, AntiSamy.DOM);\n        assertThat(saxResults.getCleanHTML(), not(containsString(\"<%/\")));\n        assertThat(domResults.getCleanHTML(), not(containsString(\"<%/\")));\n    }\n    \n    @Test\n    public void testStreamScan() throws ScanException, PolicyException, InterruptedException, ExecutionException {\n        String testImgSrcURL = \"<img src=\\\"https://ssl.gstatic.com/codesite/ph/images/defaultlogo.png\\\" \";\n        Reader reader = new StringReader(\"<bogus>whatever</bogus>\" + testImgSrcURL + \"onmouseover=\\\"alert('xss')\\\">\");\n        Writer writer = new StringWriter();\n        as.scan(reader, writer, policy);\n        String cleanHtml = writer.toString().trim();\n        assertEquals(\"whatever\" + testImgSrcURL + \"/>\", cleanHtml);\n    }\n    \n    @Test\n    public void testGithubIssue23() throws ScanException, PolicyException {\n    \t\n        // Antisamy Stripping nested lists and tables\n    \tString test23 = \"<ul><li>one</li><li>two</li><li>three<ul><li>a</li><li>b</li></ul></li></ul>\";\n    \t// Issue claims you end up with this:\n    \t//    <ul><li>one</li><li>two</li><li>three<ul></ul></li><li>a</li><li>b</li></ul>\n    \t// Meaning the <li>a</li><li>b</li> elements were moved outside of the nested <ul> list they were in\n    \t\n    \t// The a.replaceAll(\"\\\\s\",\"\") is used to strip out all the whitespace in the CleanHTML so we can successfully find\n    \t// what we expect to find.\n        assertThat(as.scan(test23, policy, AntiSamy.SAX).getCleanHTML().replaceAll(\"\\\\s\",\"\"), containsString(\"<ul><li>a</li>\"));\n        assertThat(as.scan(test23, policy, AntiSamy.DOM).getCleanHTML().replaceAll(\"\\\\s\",\"\"), containsString(\"<ul><li>a</li>\"));\n        \n        // However, the test above can't replicate this misbehavior.\n    }\n    \n    // TODO: This issue is a valid enhancement request we plan to implement in the future.\n    // Commenting out the test case for now so test failures aren't included in a released version of AntiSamy.\n/*    @Test\n    public void testGithubIssue24() throws ScanException, PolicyException {\n    \t\n        // if we have onUnknownTag set to encode, it still strips out the @ and everything else after the it\n    \t// DOM Parser actually rips out the entire <name@mail.com> value even with onUnknownTag set\n        TestPolicy revisedPolicy = policy.cloneWithDirective(\"onUnknownTag\", \"encode\");\n\n    \tString email = \"name@mail.com\";\n        String test24 = \"firstname,lastname<\" + email + \">\";\n        assertThat(as.scan(test24, revisedPolicy, AntiSamy.SAX).getCleanHTML(), containsString(email));\n        assertThat(as.scan(test24, revisedPolicy, AntiSamy.DOM).getCleanHTML(), containsString(email));\n    }\n*/\n    @Test\n    public void testGithubIssue26() throws ScanException, PolicyException {\n        // Potential bypass (False positive)\n    \tString test26 = \"&#x22;&#x3E;&#x3C;&#x69;&#x6D;&#x67;&#x20;&#x73;&#x72;&#x63;&#x3D;&#x61;&#x20;&#x6F;&#x6E;&#x65;&#x72;&#x72;&#x6F;&#x72;&#x3D;&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;&#x3E;\";\n    \t// Issue claims you end up with this:\n    \t//   ><img src=a onerror=alert(1)>\n    \t\n        assertThat(as.scan(test26, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"<img src=a onerror=alert(1)>\")));\n        assertThat(as.scan(test26, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"<img src=a onerror=alert(1)>\")));\n        \n        // But you actually end up with this: &quot;&gt;&lt;img src=a onerror=alert(1)&gt; -- Which is as expected\n    }\n    \n    @Test\n    public void testGithubIssue27() throws ScanException, PolicyException {\n    \t// This test doesn't cause an ArrayIndexOutOfBoundsException, as reported in this issue even though it\n    \t// replicates the test as described.\n        String test27 = \"my &test\";\n        assertThat(as.scan(test27, policy, AntiSamy.DOM).getCleanHTML(), containsString(\"test\"));\n        assertThat(as.scan(test27, policy, AntiSamy.SAX).getCleanHTML(), containsString(\"test\"));\n    }\n\nstatic final String test33 = \"<html>\\n\"\n    \t  + \"<head>\\n\"\n    \t  + \"  <title>Test</title>\\n\"\n    \t  + \"</head>\\n\"\n    \t  + \"<body>\\n\"\n    \t  + \"  <h1>Tricky Encoding</h1>\\n\"\n    \t  + \"  <h2>NOT Sanitized by AntiSamy</h2>\\n\"\n    \t  + \"  <ol>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#00058x=alert,x%281%29\\\">X&#00058;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#00058y=alert,y%281%29\\\">X&#00058;y</a></li>\\n\"\n\n    \t  + \"    <li><a href=\\\"javascript&#58x=alert,x%281%29\\\">X&#58;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#58y=alert,y%281%29\\\">X&#58;y</a></li>\\n\"\n\n    \t  + \"    <li><a href=\\\"javascript&#x0003Ax=alert,x%281%29\\\">X&#x0003A;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#x0003Ay=alert,y%281%29\\\">X&#x0003A;y</a></li>\\n\"\n\n    \t  + \"    <li><a href=\\\"javascript&#x3Ax=alert,x%281%29\\\">X&#x3A;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#x3Ay=alert,y%281%29\\\">X&#x3A;y</a></li>\\n\"\n    \t  + \"  </ol>\\n\"\n    \t  + \"  <h1>Tricky Encoding with Ampersand Encoding</h1>\\n\"\n    \t  + \"  <p>AntiSamy turns harmless payload into XSS by just decoding the encoded ampersands in the href attribute</a>\\n\"\n    \t  + \"  <ol>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&amp;#x3Ax=alert,x%281%29\\\">X&amp;#x3A;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&AMP;#x3Ax=alert,x%281%29\\\">X&AMP;#x3A;x</a></li>\\n\"\n\n    \t  + \"    <li><a href=\\\"javascript&#38;#x3Ax=alert,x%281%29\\\">X&#38;#x3A;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#00038;#x3Ax=alert,x%281%29\\\">X&#00038;#x3A;x</a></li>\\n\"\n\n    \t  + \"    <li><a href=\\\"javascript&#x26;#x3Ax=alert,x%281%29\\\">X&#x26;#x3A;x</a></li>\\n\"\n    \t  + \"    <li><a href=\\\"javascript&#x00026;#x3Ax=alert,x%281%29\\\">X&#x00026;#x3A;x</a></li>\\n\"\n    \t  + \"  </ol>\\n\"\n    \t  + \"  <p><a href=\\\"javascript&#x3Ax=alert,x%281%29\\\">Original without ampersand encoding</a></p>\\n\"\n    \t  + \"</body>\\n\"\n    \t  + \"</html>\";\n    \t\t\t\n    @Test\n    public void testGithubIssue33() throws ScanException, PolicyException {\n        \t\n        // Potential bypass\n\n        // Issue claims you end up with this:\n        //   javascript:x=alert and other similar problems (javascript&#00058x=alert,x%281%29) but you don't.\n        //   So issue is a false positive and has been closed.\n        //System.out.println(as.scan(test33, policy, AntiSamy.SAX).getCleanHTML());\n\n        assertThat(as.scan(test33, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"javascript&#00058x=alert,x%281%29\")));\n        assertThat(as.scan(test33, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"javascript&#00058x=alert,x%281%29\")));\n    }\n    \n    // TODO: This issue is a valid enhancement request. We are trying to decide whether to implement in the future.\n    // Commenting out the test case for now so test failures aren't included in a released version of AntiSamy.\n/*\n    @Test\n    public void testGithubIssue34a() throws ScanException, PolicyException {\n\n    \t// bypass stripNonValidXMLCharacters\n    \t// Issue indicates: \"<div>Hello\\\\uD83D\\\\uDC95</div>\" should be sanitized to: \"<div>Hello</div>\"\n    \t\n        String test34a = \"<div>Hello\\uD83D\\uDC95</div>\";\n        assertEquals(\"<div>Hello</div>\", as.scan(test34a, policy, AntiSamy.SAX).getCleanHTML());\n        assertEquals(\"<div>Hello</div>\", as.scan(test34a, policy, AntiSamy.DOM).getCleanHTML());\n    }\n\n    @Test\n    public void testGithubIssue34b() throws ScanException, PolicyException {\n\n    \t// bypass stripNonValidXMLCharacters\n    \t// Issue indicates: \"<div>Hello\\\\uD83D\\\\uDC95</div>\" should be sanitized to: \"<div>Hello</div>\"\n    \t\n        String test34b = \"\\uD888\";\n        assertEquals(\"\", as.scan(test34b, policy, AntiSamy.DOM).getCleanHTML());\n        assertEquals(\"\", as.scan(test34b, policy, AntiSamy.SAX).getCleanHTML());\n    }\n*/\n\n    static final String test40 = \"<html>\\n\"\n          + \"<head>\\n\"\n          + \"  <title>Test</title>\\n\"\n          + \"</head>\\n\"\n          + \"<body>\\n\"\n          + \"  <h1>Tricky Encoding</h1>\\n\"\n          + \"  <h2>NOT Sanitized by AntiSamy</h2>\\n\"\n          + \"  <ol>\\n\"\n          + \"    <li><h3>svg onload=alert follows:</h3><svg onload=alert(1)//</li>\\n\"\n          + \"  </ol>\\n\"\n          + \"</body>\\n\"\n          + \"</html>\";\n\n    @Test\n    public void testGithubIssue40() throws ScanException, PolicyException {\n\n        // Concern is that: <svg onload=alert(1)//  does not get cleansed.\n        // Based on these test results, it does get cleaned so this issue is a false positive, so we closed it.\n\n        assertThat(as.scan(test40, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"<svg onload=alert(1)//\")));\n        //System.out.println(\"SAX parser: \" + as.scan(test40, policy, AntiSamy.SAX).getCleanHTML());\n        assertThat(as.scan(test40, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"<svg onload=alert(1)//\")));\n        //System.out.println(\"DOM parser: \" + as.scan(test40, policy, AntiSamy.DOM).getCleanHTML());\n    }\n\n    @Test\n    public void testGithubIssue48() throws ScanException, PolicyException {\n\n        // Concern is that onsiteURL regex is not safe for URLs that start with //.\n        // For example:  //evilactor.com?param=foo\n\n        final String phishingAttempt = \"<a href=\\\"//evilactor.com/stealinfo?a=xxx&b=xxx\\\"><span style=\\\"color:red;font-size:100px\\\">\"\n                + \"You must click me</span></a>\";\n\n        // Output: <a rel=\"nofollow\"><span style=\"color: red;font-size: 100.0px;\">You must click me</span></a>\n\n        assertThat(as.scan(phishingAttempt, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n        assertThat(as.scan(phishingAttempt, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n\n        // This ones never failed, they're just to prove a dangling markup attack on the following resulting HTML won't work.\n        // Less probable case (steal more tags):\n        final String danglingMarkup = \"<div>User input: \" +\n                \"<input type=\\\"text\\\" name=\\\"input\\\" value=\\\"\\\"><a href='//evilactor.com?\"+\n                \"\\\"> all this info wants to be stolen with <i>danlging markup attack</i>\" +\n                \" until a single quote to close is found'</div>\";\n\n        assertThat(as.scan(danglingMarkup, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n        assertThat(as.scan(danglingMarkup, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n\n        // More probable case (steal just an attribute):\n        //      HTML before attack: <input type=\"text\" name=\"input\" value=\"\" data-attribute-to-steal=\"some value\">\n        final String danglingMarkup2 = \"<div>User input: \" +\n                \"<input type=\\\"text\\\" name=\\\"input\\\" value=\\\"\\\" data-attribute-to-steal=\\\"some value\\\">\";\n        \n        assertThat(as.scan(danglingMarkup2, policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n        assertThat(as.scan(danglingMarkup2, policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"//evilactor.com/\")));\n    }\n\n @Test\n    public void testGithubIssue62() {\n        // Concern is that when a processing instruction is at the root level, node removal gets messy and Null pointer exception arises.\n        // More test cases are added for PI removal.\n\n        try{\n            assertThat(as.scan(\"|<?ai aaa\", policy, AntiSamy.DOM).getCleanHTML(), is(\"|\"));\n            assertThat(as.scan(\"|<?ai aaa\", policy, AntiSamy.SAX).getCleanHTML(), is(\"|\"));\n\n            assertThat(as.scan(\"<div>|<?ai aaa\", policy, AntiSamy.DOM).getCleanHTML(), is(\"<div>|</div>\"));\n            assertThat(as.scan(\"<div>|<?ai aaa\", policy, AntiSamy.SAX).getCleanHTML(), is(\"<div>|</div>\"));\n\n            assertThat(as.scan(\"<div><?foo note=\\\"I am XML processing instruction. I wish to be excluded\\\" ?></div>\", policy, AntiSamy.DOM)\n                    .getCleanHTML(), not(containsString(\"<?foo\")));\n            assertThat(as.scan(\"<div><?foo note=\\\"I am XML processing instruction. I wish to be excluded\\\" ?></div>\", policy, AntiSamy.SAX)\n                    .getCleanHTML(), not(containsString(\"<?foo\")));\n\n            assertThat(as.scan(\"<?xml-stylesheet type=\\\"text/css\\\" href=\\\"style.css\\\"?>\", policy, AntiSamy.DOM).getCleanHTML(), is(\"\"));\n            assertThat(as.scan(\"<?xml-stylesheet type=\\\"text/css\\\" href=\\\"style.css\\\"?>\", policy, AntiSamy.SAX).getCleanHTML(), is(\"\"));\n\n        } catch (Exception exc) {\n            fail(exc.getMessage());\n        }\n    }\n\n    @Test\n    public void testGithubIssue81() throws ScanException, PolicyException {\n        // Concern is that \"!important\" is missing after processing CSS\n        assertThat(as.scan(\"<p style=\\\"color: red !important\\\">Some Text</p>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"!important\"));\n        assertThat(as.scan(\"<p style=\\\"color: red !important\\\">Some Text</p>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"!important\"));\n\n        // Just to check scan keeps working accordingly without \"!important\"\n        assertThat(as.scan(\"<p style=\\\"color: red\\\">Some Text</p>\", policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"!important\")));\n        assertThat(as.scan(\"<p style=\\\"color: red\\\">Some Text</p>\", policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"!important\")));\n    }\n\n    @Test\n    public void entityReferenceEncodedInHtmlAttribute() throws ScanException, PolicyException {\n        // Concern is that \"&\" is not being encoded and \"#00058\" was not being interpreted as \":\"\n        // so the validations based on regexp passed and a browser would load \"&:\" together.\n        // All this when not using the XHTML serializer.\n        Policy revised = policy.cloneWithDirective(\"useXHTML\",\"false\");\n        assertThat(as.scan(\"<p><a href=\\\"javascript&#00058x=1,%61%6c%65%72%74%28%22%62%6f%6f%6d%22%29\\\">xss</a></p>\", revised, AntiSamy.DOM).getCleanHTML(),\n                containsString(\"javascript&amp;#00058\"));\n        assertThat(as.scan(\"<p><a href=\\\"javascript&#00058x=1,%61%6c%65%72%74%28%22%62%6f%6f%6d%22%29\\\">xss</a></p>\", revised, AntiSamy.SAX).getCleanHTML(),\n                containsString(\"javascript&amp;#00058\"));\n    }\n\n    @Test\n    public void testGithubIssue99() throws ScanException, PolicyException {\n        // Test that the IANA subtags is not lost\n        assertThat(as.scan(\"<p lang=\\\"en-GB\\\">This paragraph is defined as British English.</p>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"lang=\\\"en-GB\\\"\"));\n        assertThat(as.scan(\"<p lang=\\\"en-GB\\\">This paragraph is defined as British English.</p>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"lang=\\\"en-GB\\\"\"));\n    }\n\n    @Test\n    public void testGithubIssue101() throws ScanException, PolicyException {\n        // Test that margin attribute is not removed when value has too much significant figures.\n        // Current behavior is that decimals like 0.0001 are internally translated to 1.0E-4, this\n        // is reflected on regex validation and actual output. The inconsistency is due to Batik CSS.\n        assertThat(as.scan(\"<p style=\\\"margin: 0.0001pt;\\\">Some text.</p>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"margin\"));\n        assertThat(as.scan(\"<p style=\\\"margin: 0.0001pt;\\\">Some text.</p>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"margin\"));\n        assertThat(as.scan(\"<p style=\\\"margin: 10000000pt;\\\">Some text.</p>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"margin\"));\n        assertThat(as.scan(\"<p style=\\\"margin: 10000000pt;\\\">Some text.</p>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"margin\"));\n        assertThat(as.scan(\"<p style=\\\"margin: 1.0E-4pt;\\\">Some text.</p>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"margin\"));\n        assertThat(as.scan(\"<p style=\\\"margin: 1.0E-4pt;\\\">Some text.</p>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"margin\"));\n        // When using exponential directly the \"e\" or \"E\" is internally considered as the start of\n        // the dimension/unit type. This creates inconsistencies that make the regex validation fail,\n        // also in cases like 1e4pt where \"e\" is considered as dimension instead of \"pt\".\n        assertThat(as.scan(\"<p style=\\\"margin: 1.0E+4pt;\\\">Some text.</p>\", policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"margin\")));\n        assertThat(as.scan(\"<p style=\\\"margin: 1.0E+4pt;\\\">Some text.</p>\", policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"margin\")));\n    }\n\n    @Test\n    public void testCSSUnits() throws ScanException, PolicyException {\n        String input = \"<div style=\\\"width:50vw;height:50vh;padding:1rpc;\\\">\\n\" +\n                \"\\t<p style=\\\"font-size:1.5ex;padding-left:1rem;padding-top:16px;\\\">Some text.</p>\\n\" +\n                \"</div>\";\n        CleanResults cr = as.scan(input, policy, AntiSamy.DOM);\n        assertThat(cr.getCleanHTML(), containsString(\"ex\"));\n        assertThat(cr.getCleanHTML(), containsString(\"px\"));\n        assertThat(cr.getCleanHTML(), containsString(\"rem\"));\n        assertThat(cr.getCleanHTML(), containsString(\"vw\"));\n        assertThat(cr.getCleanHTML(), containsString(\"vh\"));\n        assertThat(cr.getCleanHTML(), not(containsString(\"rpc\")));\n        cr = as.scan(input, policy, AntiSamy.SAX);\n        assertThat(cr.getCleanHTML(), containsString(\"ex\"));\n        assertThat(cr.getCleanHTML(), containsString(\"px\"));\n        assertThat(cr.getCleanHTML(), containsString(\"rem\"));\n        assertThat(cr.getCleanHTML(), containsString(\"vw\"));\n        assertThat(cr.getCleanHTML(), containsString(\"vh\"));\n        assertThat(cr.getCleanHTML(), not(containsString(\"rpc\")));\n    }\n\n    @Test\n    public void testXSSInsideSelectOptionStyle() throws ScanException, PolicyException {\n        // Tests for CVE-2021-42575, XSS nested into <select>+<option>+<style>\n\n        // Safe case, to test legit style\n        assertThat(as.scan(\"<select><option><style>h1{color:black;}</style></option></select>\", policy, AntiSamy.DOM).getCleanHTML(), containsString(\"black\"));\n        assertThat(as.scan(\"<select><option><style>h1{color:black;}</style></option></select>\", policy, AntiSamy.SAX).getCleanHTML(), containsString(\"black\"));\n        // Unsafe case\n        assertThat(as.scan(\"<select><option><style><script>alert(1)</script></style></option></select>\", policy, AntiSamy.DOM).getCleanHTML(), not(containsString(\"<script>\")));\n        assertThat(as.scan(\"<select><option><style><script>alert(1)</script></style></option></select>\", policy, AntiSamy.SAX).getCleanHTML(), not(containsString(\"<script>\")));\n    }\n\n    @Test\n    public void testImportedStylesParsing() throws ScanException, PolicyException {\n        // Test that imported style sheets can be parsed and order is correct\n        final String input = \"<style type='text/css'>\\n\" +\n                \"\\t@import url(https://raw.githubusercontent.com/nahsra/antisamy/main/src/test/resources/s/slashdot.org_files/classic.css);\\n\" +\n                \"\\t@import url(https://raw.githubusercontent.com/nahsra/antisamy/main/src/test/resources/s/slashdot.org_files/providers.css);\\n\" +\n                \"\\t.very-specific-antisamy {font: 15pt \\\"Arial\\\"; color: blue;}\\n\" +\n                \"</style>\";\n        Policy revised = policy.cloneWithDirective(Policy.EMBED_STYLESHEETS,\"true\").cloneWithDirective(Policy.FORMAT_OUTPUT,\"false\");\n        // Styles are imported\n        String cleanHtmlDOM = as.scan(input, revised, AntiSamy.DOM).getCleanHTML();\n        String cleanHtmlSAX = as.scan(input, revised, AntiSamy.SAX).getCleanHTML();\n        assertThat(cleanHtmlDOM, not(containsString(\"<![CDATA[/* */]]>\")));\n        assertThat(cleanHtmlSAX, not(containsString(\"<![CDATA[/* */]]>\")));\n        // Order is correct:\n        //  First import: grid_1 class\n        //  Second import: janrain-provider150-sprit class\n        //  Original styles: very-specific-antisamy class\n        final Pattern p = Pattern.compile(\".*?\\\\.grid_1.*?\\\\.janrain-provider150-sprit.*?\\\\.very-specific-antisamy.*?\", Pattern.DOTALL);\n        assertThat(cleanHtmlDOM, MatchesPattern.matchesPattern(p));\n        assertThat(cleanHtmlSAX, MatchesPattern.matchesPattern(p));\n\n        Policy revised2 = policy.cloneWithDirective(Policy.EMBED_STYLESHEETS,\"false\").cloneWithDirective(Policy.FORMAT_OUTPUT,\"false\");\n        // Styles are not imported\n        cleanHtmlDOM = as.scan(input, revised2, AntiSamy.DOM).getCleanHTML();\n        cleanHtmlSAX = as.scan(input, revised2, AntiSamy.SAX).getCleanHTML();\n        assertThat(cleanHtmlDOM, not(containsString(\".grid_1\")));\n        assertThat(cleanHtmlSAX, not(containsString(\".grid_1\")));\n        assertThat(cleanHtmlDOM, not(containsString(\".janrain-provider150-sprit\")));\n        assertThat(cleanHtmlSAX, not(containsString(\".janrain-provider150-sprit\")));\n    }\n\n    @Test\n    public void testNoopenerAndNoreferrer() throws ScanException, PolicyException {\n        Map<String, Attribute> map = new HashMap<>();\n        map.put(\"target\", new Attribute(\"a\", Collections.<Pattern>emptyList(), Arrays.asList( \"_blank\", \"_self\" ), \"\",\"\"));\n        map.put(\"rel\", new Attribute(\"a\", Collections.<Pattern>emptyList(), Arrays.asList( \"nofollow\", \"noopener\", \"noreferrer\"), \"\",\"\"));\n        Tag tag = new Tag(\"a\", map, Policy.ACTION_VALIDATE);\n        Policy basePolicy = policy.mutateTag(tag);\n        Policy revised = basePolicy.cloneWithDirective(Policy.ANCHORS_NOFOLLOW,\"true\").cloneWithDirective(Policy.ANCHORS_NOOPENER_NOREFERRER,\"true\");\n        // No target=\"_blank\", so only nofollow can be added.\n        assertThat(as.scan(\"<a>Link text</a>\", revised, AntiSamy.DOM).getCleanHTML(), both(containsString(\"nofollow\")).and(not(containsString(\"noopener noreferrer\"))));\n        assertThat(as.scan(\"<a>Link text</a>\", revised, AntiSamy.SAX).getCleanHTML(), both(containsString(\"nofollow\")).and(not(containsString(\"noopener noreferrer\"))));\n        // target=\"_blank\", can have both.\n        assertThat(as.scan(\"<a target=\\\"_blank\\\">Link text</a>\", revised, AntiSamy.DOM).getCleanHTML(), containsString(\"nofollow noopener noreferrer\"));\n        assertThat(as.scan(\"<a target=\\\"_blank\\\">Link text</a>\", revised, AntiSamy.SAX).getCleanHTML(), containsString(\"nofollow noopener noreferrer\"));\n\n        Policy revised2 = basePolicy.cloneWithDirective(Policy.ANCHORS_NOFOLLOW,\"false\").cloneWithDirective(Policy.ANCHORS_NOOPENER_NOREFERRER,\"true\");\n        // No target=\"_blank\", no rel added.\n        assertThat(as.scan(\"<a>Link text</a>\", revised2, AntiSamy.DOM).getCleanHTML(), not(containsString(\"rel=\")));\n        assertThat(as.scan(\"<a>Link text</a>\", revised2, AntiSamy.SAX).getCleanHTML(), not(containsString(\"rel=\")));\n        // target=\"_blank\", everything present.\n        assertThat(as.scan(\"<a target='_blank' rel='nofollow'>Link text</a>\", revised2, AntiSamy.DOM).getCleanHTML(), containsString(\"nofollow noopener noreferrer\"));\n        assertThat(as.scan(\"<a target='_blank' rel='nofollow'>Link text</a>\", revised2, AntiSamy.SAX).getCleanHTML(), containsString(\"nofollow noopener noreferrer\"));\n        // target=\"_self\", no rel added.\n        assertThat(as.scan(\"<a target='_self'>Link text</a>\", revised2, AntiSamy.DOM).getCleanHTML(), not(containsString(\"rel=\")));\n        assertThat(as.scan(\"<a target='_self'>Link text</a>\", revised2, AntiSamy.SAX).getCleanHTML(), not(containsString(\"rel=\")));\n        // target=\"_self\", only nofollow present.\n        assertThat(as.scan(\"<a target='_self' rel='nofollow'>Link text</a>\", revised2, AntiSamy.DOM).getCleanHTML(), both(containsString(\"nofollow\")).and(not(containsString(\"noopener noreferrer\"))));\n        assertThat(as.scan(\"<a target='_self' rel='nofollow'>Link text</a>\", revised2, AntiSamy.SAX).getCleanHTML(), both(containsString(\"nofollow\")).and(not(containsString(\"noopener noreferrer\"))));\n        // noopener is not repeated\n        assertThat(as.scan(\"<a target='_blank' rel='noopener'>Link text</a>\", revised2, AntiSamy.DOM).getCleanHTML().split(\"noopener\").length, is(2));\n        assertThat(as.scan(\"<a target='_blank' rel='noopener'>Link text</a>\", revised2, AntiSamy.SAX).getCleanHTML().split(\"noopener\").length, is(2));\n\n        Policy revised3 = basePolicy.cloneWithDirective(Policy.ANCHORS_NOFOLLOW,\"false\").cloneWithDirective(Policy.ANCHORS_NOOPENER_NOREFERRER,\"false\");\n        // No rel added\n        assertThat(as.scan(\"<a>Link text</a>\", revised3, AntiSamy.DOM).getCleanHTML(), not(containsString(\"rel=\")));\n        assertThat(as.scan(\"<a>Link text</a>\", revised3, AntiSamy.SAX).getCleanHTML(), not(containsString(\"rel=\")));\n        // noopener is not repeated\n        assertThat(as.scan(\"<a target='_blank' rel='noopener'>Link text</a>\", revised3, AntiSamy.DOM).getCleanHTML().split(\"noopener\").length, is(2));\n        assertThat(as.scan(\"<a target='_blank' rel='noopener'>Link text</a>\", revised3, AntiSamy.SAX).getCleanHTML().split(\"noopener\").length, is(2));\n    }\n\n    @Test\n    public void testLeadingDashOnPropertyName() throws ScanException, PolicyException {\n        // Test that property names with leading dash are supported, reported on issue #125.\n        final String input = \"<style type='text/css'>\\n\" +\n                \"\\t.very-specific-antisamy { -moz-border-radius: inherit ; -webkit-border-radius: 25px 10px 5px 10px;}\\n\" +\n                \"</style>\";\n        // Define new properties for the policy\n        Pattern customPattern = Pattern.compile(\"\\\\d+(\\\\.\\\\d+)?px( \\\\d+(\\\\.\\\\d+)?px){0,3}\", Pattern.DOTALL);\n        Property leadingDashProperty1 = new Property(\"-webkit-border-radius\", Arrays.asList(customPattern), Collections.<String>emptyList(),Collections.<String>emptyList(),\"\",\"\");\n        Property leadingDashProperty2 = new Property(\"-moz-border-radius\", Collections.<Pattern>emptyList(), Arrays.asList(\"inherit\"),Collections.<String>emptyList(),\"\",\"\");\n        Policy revised = policy.addCssProperty(leadingDashProperty1).addCssProperty(leadingDashProperty2);\n        // Test properties\n        assertThat(as.scan(input, revised, AntiSamy.DOM).getCleanHTML(), both(containsString(\"-webkit-border-radius\")).and(containsString(\"-moz-border-radius\")));\n        assertThat(as.scan(input, revised, AntiSamy.SAX).getCleanHTML(), both(containsString(\"-webkit-border-radius\")).and(containsString(\"-moz-border-radius\")));\n    }\n\n    @Test\n    public void testScansWithDifferentPolicyLoading() throws ScanException, PolicyException, URISyntaxException {\n        final String input = \"<span>text</span>\";\n        // Preload policy, do not specify scan type.\n        AntiSamy asInstance = new AntiSamy(policy);\n        assertThat(asInstance.scan(input).getCleanHTML(), is(input));\n        // Pass policy, assume DOM scan type.\n        assertThat(asInstance.scan(input, policy).getCleanHTML(), is(input));\n        // Pass policy as File.\n        File policyFile = new File(getClass().getResource(\"/antisamy.xml\").toURI());\n        assertThat(asInstance.scan(input, policyFile).getCleanHTML(), is(input));\n        // Pass policy filename.\n        String path = getClass().getResource(\"/antisamy.xml\").getPath();\n        path = System.getProperty(\"file.separator\").equals(\"\\\\\") && path.startsWith(\"/\") ? path.substring(1) : path;\n        assertThat(asInstance.scan(input, path).getCleanHTML(), is(input));\n        // No preloaded nor passed policy, expected to fail.\n        try {\n            as.scan(input, null, AntiSamy.DOM);\n            fail(\"Scan with no policy must have thrown an exception.\");\n        } catch (PolicyException e) {\n            // An error is expected. Pass.\n        }\n    }\n\n    @Test\n    public void testGithubIssue151() throws ScanException, PolicyException {\n        // Concern is error messages when parsing stylesheets are no longer returned in AntiSamy 1.6.5\n        String input = \"<img style=\\\"FLOAT: right; CURSOR: hand\\\" src=\\\"http://site.com/pic.jpg\\\" />\";\n\n        CleanResults result = as.scan(input, policy, AntiSamy.DOM);\n        assertThat(result.getErrorMessages().size(), is(1));\n        assertThat(result.getCleanHTML(), both(containsString(\"img\")).and(not(containsString(\"CURSOR\"))));\n\n        result = as.scan(input, policy, AntiSamy.SAX);\n        assertThat(result.getErrorMessages().size(), is(1));\n        assertThat(result.getCleanHTML(), both(containsString(\"img\")).and(not(containsString(\"CURSOR\"))));\n    }\n\n    @Test\n    public void testSmuggledTagsInStyleContent() throws ScanException, PolicyException {\n        // HTML tags may be smuggled into a style tag after parsing input to an internal representation.\n        // If that happens, they should be treated as text content and not as children nodes.\n\n        Policy revised = policy.cloneWithDirective(Policy.USE_XHTML,\"true\");\n        assertThat(as.scan(\"<style/>b<![cdata[</style><a href=javascript:alert(1)>test\", revised, AntiSamy.DOM).getCleanHTML(), not(containsString(\"javascript\")));\n        assertThat(as.scan(\"<style/>b<![cdata[</style><a href=javascript:alert(1)>test\", revised, AntiSamy.SAX).getCleanHTML(), not(containsString(\"javascript\")));\n\n        Policy revised2 = policy.cloneWithDirective(Policy.USE_XHTML,\"false\");\n        assertThat(as.scan(\"<select<style/>W<xmp<script>alert(1)</script>\", revised2, AntiSamy.DOM).getCleanHTML(), not(containsString(\"script\")));\n        assertThat(as.scan(\"<select<style/>W<xmp<script>alert(1)</script>\", revised2, AntiSamy.SAX).getCleanHTML(), not(containsString(\"script\")));\n    }\n}\n\n", "/*\n * Copyright (c) 2013, Kristian Rosenvold\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n * Neither the name of OWASP nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.owasp.validator.html.test;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.owasp.validator.html.InternalPolicy;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.PolicyException;\nimport org.owasp.validator.html.model.Property;\nimport org.owasp.validator.html.model.Tag;\n\n/**\n * @author Kristian Rosenvold\n */\npublic class TestPolicy extends InternalPolicy {\n\n    protected TestPolicy(Policy.ParseContext parseContext) {\n        super(parseContext);\n    }\n\n    protected TestPolicy(Policy old, Map<String, String> directives, Map<String, Tag> tagRules, Map<String, Property> cssRules) {\n        super(old, directives, tagRules, cssRules);\n    }\n\n    public static TestPolicy getInstance() throws PolicyException {\n        return getInstance(Policy.class.getClassLoader().getResource(DEFAULT_POLICY_URI));\n    }\n\n    public static TestPolicy getInstance(String filename) throws PolicyException {\n        File file = new File(filename);\n        return getInstance(file);\n    }\n\n    public static TestPolicy getInstance(File file) throws PolicyException {\n        try {\n            URI uri = file.toURI();\n            return getInstance(uri.toURL());\n        } catch (IOException e) {\n            throw new PolicyException(e);\n        }\n    }\n\n    public static TestPolicy getInstance(URL url) throws PolicyException {\n        return new TestPolicy(getParseContext(getTopLevelElement(url), url));\n    }\n\n    public TestPolicy cloneWithDirective(String name, String value) {\n        Map<String, String> directives = new HashMap<String, String>(this.directives);\n        directives.put(name, value);\n        return new TestPolicy(this, Collections.unmodifiableMap(directives), tagRules, cssRules);\n    }\n\n    public TestPolicy addTagRule(Tag tag) {\n        Map<String, Tag> newTagRules = new HashMap<String, Tag>(tagRules);\n        newTagRules.put(tag.getName().toLowerCase(), tag);\n        return new TestPolicy(this, this.directives, newTagRules, cssRules);\n    }\n\n    public TestPolicy mutateTag(Tag tag) {\n        Map<String, Tag> newRules = new HashMap<String, Tag>(this.tagRules);\n        newRules.put( tag.getName().toLowerCase(), tag);\n        return new TestPolicy(this, this.directives, newRules, cssRules);\n    }\n\n    public TestPolicy addCssProperty(Property property) {\n        Map<String, Property> newCssRules = new HashMap<String, Property>(cssRules);\n        newCssRules.put(property.getName().toLowerCase(), property);\n        return new TestPolicy(this, this.directives, tagRules, newCssRules);\n    }\n}\n"], "filenames": ["src/main/java/org/owasp/validator/html/scan/AntiSamyDOMScanner.java", "src/test/java/org/owasp/validator/html/test/AntiSamyTest.java", "src/test/java/org/owasp/validator/html/test/TestPolicy.java"], "buggy_code_start_loc": [410, 1704, 46], "buggy_code_end_loc": [431, 1704, 47], "fixing_code_start_loc": [410, 1705, 46], "fixing_code_end_loc": [443, 1719, 47], "type": "CWE-79", "message": "OWASP AntiSamy before 1.6.6 allows XSS via HTML tag smuggling on STYLE content with crafted input. The output serializer does not properly encode the supposed Cascading Style Sheets (CSS) content.", "other": {"cve": {"id": "CVE-2022-28367", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-21T23:15:10.427", "lastModified": "2022-05-03T20:49:00.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OWASP AntiSamy before 1.6.6 allows XSS via HTML tag smuggling on STYLE content with crafted input. The output serializer does not properly encode the supposed Cascading Style Sheets (CSS) content."}, {"lang": "es", "value": "OWASP AntiSamy versiones anteriores a 1.6.6, permite un ataque de tipo XSS por medio de contrabando de etiquetas HTML en contenido STYLE con entrada dise\u00f1ada. El serializador de salida no codifica apropiadamente el supuesto contenido de las hojas de estilo en cascada (CSS)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:antisamy_project:antisamy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.6", "matchCriteriaId": "5A45C3A9-2368-4E15-83BC-DEE9004FA9B7"}]}]}], "references": [{"url": "https://github.com/nahsra/antisamy/commit/0199e7e194dba5e7d7197703f43ebe22401e61ae", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nahsra/antisamy/releases/tag/v1.6.6", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nahsra/antisamy/commit/0199e7e194dba5e7d7197703f43ebe22401e61ae"}}