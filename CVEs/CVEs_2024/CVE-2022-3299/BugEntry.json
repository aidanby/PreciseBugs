{"buggy_code": ["/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"ogs-sbi.h\"\n\n#include \"curl/curl.h\"\n\ntypedef struct sockinfo_s {\n    ogs_poll_t *poll;\n    curl_socket_t sockfd;\n    int action;\n    CURL *easy;\n    ogs_sbi_client_t *client;\n} sockinfo_t;\n\ntypedef struct connection_s {\n    ogs_lnode_t lnode;\n\n    void *data;\n\n    char *method;\n\n    int num_of_header;\n    char **headers;\n    struct curl_slist *header_list;\n\n    char *content;\n\n    char *memory;\n    size_t size;\n\n    char *location;\n\n    ogs_timer_t *timer;\n    CURL *easy;\n\n    char error[CURL_ERROR_SIZE];\n\n    ogs_sbi_client_t *client;\n    ogs_sbi_client_cb_f client_cb;\n} connection_t;\n\nstatic OGS_POOL(client_pool, ogs_sbi_client_t);\nstatic OGS_POOL(sockinfo_pool, sockinfo_t);\nstatic OGS_POOL(connection_pool, connection_t);\n\nstatic size_t write_cb(void *contents, size_t size, size_t nmemb, void *data);\nstatic size_t header_cb(void *ptr, size_t size, size_t nmemb, void *data);\nstatic int sock_cb(CURL *e, curl_socket_t s, int what, void *cbp, void *sockp);\nstatic int multi_timer_cb(CURLM *multi, long timeout_ms, void *cbp);\nstatic void multi_timer_expired(void *data);\nstatic void connection_timer_expired(void *data);\nstatic void connection_remove_all(ogs_sbi_client_t *client);\n\nvoid ogs_sbi_client_init(int num_of_sockinfo_pool, int num_of_connection_pool)\n{\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    ogs_list_init(&ogs_sbi_self()->client_list);\n    ogs_pool_init(&client_pool, ogs_app()->pool.nf);\n\n    ogs_pool_init(&sockinfo_pool, num_of_sockinfo_pool);\n    ogs_pool_init(&connection_pool, num_of_connection_pool);\n\n}\nvoid ogs_sbi_client_final(void)\n{\n    ogs_sbi_client_remove_all();\n\n    ogs_pool_final(&client_pool);\n    ogs_pool_final(&sockinfo_pool);\n    ogs_pool_final(&connection_pool);\n\n    curl_global_cleanup();\n}\n\nogs_sbi_client_t *ogs_sbi_client_add(ogs_sockaddr_t *addr)\n{\n    ogs_sbi_client_t *client = NULL;\n    CURLM *multi = NULL;\n\n    ogs_assert(addr);\n\n    ogs_pool_alloc(&client_pool, &client);\n    ogs_assert(client);\n    memset(client, 0, sizeof(ogs_sbi_client_t));\n\n    ogs_debug(\"ogs_sbi_client_add()\");\n    OGS_OBJECT_REF(client);\n\n    ogs_assert(OGS_OK == ogs_copyaddrinfo(&client->node.addr, addr));\n\n    client->t_curl = ogs_timer_add(\n            ogs_app()->timer_mgr, multi_timer_expired, client);\n    if (!client->t_curl) {\n        ogs_error(\"ogs_timer_add() failed\");\n        ogs_pool_free(&client_pool, client);\n        return NULL;\n    }\n\n    multi = client->multi = curl_multi_init();\n    ogs_assert(multi);\n    curl_multi_setopt(multi, CURLMOPT_SOCKETFUNCTION, sock_cb);\n    curl_multi_setopt(multi, CURLMOPT_SOCKETDATA, client);\n    curl_multi_setopt(multi, CURLMOPT_TIMERFUNCTION, multi_timer_cb);\n    curl_multi_setopt(multi, CURLMOPT_TIMERDATA, client);\n#ifdef CURLMOPT_MAX_CONCURRENT_STREAMS\n    curl_multi_setopt(multi, CURLMOPT_MAX_CONCURRENT_STREAMS,\n                        ogs_app()->pool.stream);\n#endif\n\n    ogs_list_init(&client->connection_list);\n\n    ogs_list_add(&ogs_sbi_self()->client_list, client);\n\n    return client;\n}\n\nvoid ogs_sbi_client_remove(ogs_sbi_client_t *client)\n{\n    ogs_sockaddr_t *addr = NULL;\n    char buf[OGS_ADDRSTRLEN];\n\n    ogs_assert(client);\n\n    addr = client->node.addr;\n    ogs_assert(addr);\n    ogs_debug(\"ogs_sbi_client_remove() [%s:%d]\",\n                OGS_ADDR(addr, buf), OGS_PORT(addr));\n\n    /* ogs_sbi_client_t is always created with reference context */\n    if (OGS_OBJECT_IS_REF(client)) {\n        OGS_OBJECT_UNREF(client);\n        return;\n    }\n\n    ogs_list_remove(&ogs_sbi_self()->client_list, client);\n\n    connection_remove_all(client);\n\n    ogs_assert(client->t_curl);\n    ogs_timer_delete(client->t_curl);\n    client->t_curl = NULL;\n\n    ogs_assert(client->multi);\n    curl_multi_cleanup(client->multi);\n\n    ogs_assert(client->node.addr);\n    ogs_freeaddrinfo(client->node.addr);\n\n    ogs_pool_free(&client_pool, client);\n}\n\nvoid ogs_sbi_client_remove_all(void)\n{\n    ogs_sbi_client_t *client = NULL, *next_client = NULL;\n\n    ogs_list_for_each_safe(&ogs_sbi_self()->client_list, next_client, client)\n        ogs_sbi_client_remove(client);\n}\n\nogs_sbi_client_t *ogs_sbi_client_find(ogs_sockaddr_t *addr)\n{\n    ogs_sbi_client_t *client = NULL;\n\n    ogs_assert(addr);\n\n    ogs_list_for_each(&ogs_sbi_self()->client_list, client) {\n        if (ogs_sockaddr_is_equal(client->node.addr, addr) == true)\n            break;\n    }\n\n    return client;\n}\n\nvoid ogs_sbi_client_stop(ogs_sbi_client_t *client)\n{\n    connection_t *conn = NULL;\n\n    ogs_assert(client);\n\n    ogs_list_for_each(&client->connection_list, conn) {\n        ogs_assert(conn->client_cb);\n        conn->client_cb(OGS_DONE, NULL, conn->data);\n    }\n}\n\nvoid ogs_sbi_client_stop_all(void)\n{\n    ogs_sbi_client_t *client = NULL;\n\n    ogs_list_for_each(&ogs_sbi_self()->client_list, client)\n        ogs_sbi_client_stop(client);\n}\n\n#define mycase(code) \\\n  case code: s = OGS_STRINGIFY(code)\n\nstatic void mcode_or_die(const char *where, CURLMcode code)\n{\n    if(CURLM_OK != code) {\n        const char *s;\n        switch(code) {\n            mycase(CURLM_BAD_HANDLE); break;\n            mycase(CURLM_BAD_EASY_HANDLE); break;\n            mycase(CURLM_OUT_OF_MEMORY); break;\n            mycase(CURLM_INTERNAL_ERROR); break;\n            mycase(CURLM_UNKNOWN_OPTION); break;\n            mycase(CURLM_LAST); break;\n            default: s = \"CURLM_unknown\"; break;\n            mycase(CURLM_BAD_SOCKET);\n            ogs_error(\"ERROR: %s returns %s\", where, s);\n            /* ignore this error */\n            return;\n        }\n        ogs_fatal(\"ERROR: %s returns %s\", where, s);\n        ogs_assert_if_reached();\n    }\n}\n\nstatic char *add_params_to_uri(CURL *easy, char *uri, ogs_hash_t *params)\n{\n    ogs_hash_index_t *hi;\n    int has_params = 0;\n    const char *fp = \"?\", *np = \"&\";\n\n    ogs_assert(easy);\n    ogs_assert(uri);\n    ogs_assert(params);\n    ogs_assert(ogs_hash_count(params));\n\n    has_params = (strchr(uri, '?') != NULL);\n\n    for (hi = ogs_hash_first(params); hi; hi = ogs_hash_next(hi)) {\n        const char *key = NULL;\n        char *key_esc = NULL;\n        char *val = NULL;\n        char *val_esc = NULL;\n\n        key = ogs_hash_this_key(hi);\n        ogs_assert(key);\n        val = ogs_hash_this_val(hi);\n        ogs_assert(val);\n\n        key_esc = curl_easy_escape(easy, key, 0);\n        ogs_assert(key_esc);\n        val_esc = curl_easy_escape(easy, val, 0);\n        ogs_assert(val_esc);\n\n        if (!has_params) {\n            uri = ogs_mstrcatf(uri, \"%s%s=%s\", fp, key_esc, val_esc);\n            ogs_expect(uri);\n            has_params = 1;\n        } else {\n            uri = ogs_mstrcatf(uri, \"%s%s=%s\", np, key_esc, val_esc);\n            ogs_expect(uri);\n        }\n\n        curl_free(val_esc);\n        curl_free(key_esc);\n    }\n\n    return uri;\n}\n\nstatic void _connection_remove(connection_t *conn);\n\nstatic connection_t *connection_add(\n        ogs_sbi_client_t *client, ogs_sbi_client_cb_f client_cb,\n        ogs_sbi_request_t *request, void *data)\n{\n    ogs_hash_index_t *hi;\n    int i;\n    connection_t *conn = NULL;\n    CURLMcode rc;\n\n    ogs_assert(client);\n    ogs_assert(client_cb);\n    ogs_assert(request);\n    ogs_assert(request->h.method);\n\n    ogs_pool_alloc(&connection_pool, &conn);\n    ogs_expect_or_return_val(conn, NULL);\n    memset(conn, 0, sizeof(connection_t));\n\n    conn->client = client;\n    conn->client_cb = client_cb;\n    conn->data = data;\n\n    conn->method = ogs_strdup(request->h.method);\n    if (!conn->method) {\n        ogs_error(\"conn->method is NULL\");\n        _connection_remove(conn);\n        return NULL;\n    }\n\n    conn->num_of_header = ogs_hash_count(request->http.headers);\n    if (conn->num_of_header) {\n        conn->headers = ogs_calloc(conn->num_of_header, sizeof(char *));\n        if (!conn->headers) {\n            ogs_error(\"conn->headers is NULL\");\n            _connection_remove(conn);\n            return NULL;\n        }\n        for (hi = ogs_hash_first(request->http.headers), i = 0;\n                hi && i < conn->num_of_header; hi = ogs_hash_next(hi), i++) {\n            const char *key = ogs_hash_this_key(hi);\n            char *val = ogs_hash_this_val(hi);\n\n            conn->headers[i] = ogs_msprintf(\"%s: %s\", key, val);\n            if (!conn->headers[i]) {\n                ogs_error(\"conn->headers[i=%d] is NULL\", i);\n                _connection_remove(conn);\n                return NULL;\n            }\n            conn->header_list = curl_slist_append(\n                    conn->header_list, conn->headers[i]);\n        }\n    }\n\n    conn->timer = ogs_timer_add(\n            ogs_app()->timer_mgr, connection_timer_expired, conn);\n    if (!conn->timer) {\n        ogs_error(\"conn->timer is NULL\");\n        _connection_remove(conn);\n        return NULL;\n    }\n\n    /* If http response is not received within deadline,\n     * Open5GS will discard this request. */\n    ogs_timer_start(conn->timer,\n            ogs_app()->time.message.sbi.connection_deadline);\n\n    conn->easy = curl_easy_init();\n    if (!conn->easy) {\n        ogs_error(\"conn->easy is NULL\");\n        _connection_remove(conn);\n        return NULL;\n    }\n\n    if (ogs_hash_count(request->http.params)) {\n        char *uri = add_params_to_uri(conn->easy,\n                            request->h.uri, request->http.params);\n        if (!uri) {\n            ogs_error(\"add_params_to_uri() failed\");\n            _connection_remove(conn);\n            return NULL;\n        }\n\n        request->h.uri = uri;\n    }\n\n    /* HTTP Method */\n    if (strcmp(request->h.method, OGS_SBI_HTTP_METHOD_PUT) == 0 ||\n        strcmp(request->h.method, OGS_SBI_HTTP_METHOD_PATCH) == 0 ||\n        strcmp(request->h.method, OGS_SBI_HTTP_METHOD_DELETE) == 0 ||\n        strcmp(request->h.method, OGS_SBI_HTTP_METHOD_POST) == 0) {\n\n        curl_easy_setopt(conn->easy,\n                CURLOPT_CUSTOMREQUEST, request->h.method);\n        if (request->http.content) {\n            conn->content = ogs_memdup(\n                    request->http.content, request->http.content_length);\n            if (!conn->content) {\n                ogs_error(\"conn->content is NULL\");\n                _connection_remove(conn);\n                return NULL;\n            }\n            curl_easy_setopt(conn->easy,\n                    CURLOPT_POSTFIELDS, conn->content);\n            curl_easy_setopt(conn->easy,\n                CURLOPT_POSTFIELDSIZE, request->http.content_length);\n#if 1 /* Disable HTTP/1.1 100 Continue : Use \"Expect:\" in libcurl */\n            conn->header_list = curl_slist_append(\n                    conn->header_list, \"Expect:\");\n#else\n            curl_easy_setopt(conn->easy, CURLOPT_EXPECT_100_TIMEOUT_MS, 0L);\n#endif\n            ogs_debug(\"SENDING...[%d]\", (int)request->http.content_length);\n            if (request->http.content_length)\n                ogs_debug(\"%s\", request->http.content);\n        }\n    }\n\n    curl_easy_setopt(conn->easy, CURLOPT_HTTPHEADER, conn->header_list);\n\n#if 1 /* Use HTTP2 */\n    curl_easy_setopt(conn->easy,\n            CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE);\n#endif\n\n    ogs_list_add(&client->connection_list, conn);\n\n    curl_easy_setopt(conn->easy, CURLOPT_URL, request->h.uri);\n\n    curl_easy_setopt(conn->easy, CURLOPT_PRIVATE, conn);\n    curl_easy_setopt(conn->easy, CURLOPT_WRITEFUNCTION, write_cb);\n    curl_easy_setopt(conn->easy, CURLOPT_WRITEDATA, conn);\n    curl_easy_setopt(conn->easy, CURLOPT_HEADERFUNCTION, header_cb);\n    curl_easy_setopt(conn->easy, CURLOPT_HEADERDATA, conn);\n    curl_easy_setopt(conn->easy, CURLOPT_ERRORBUFFER, conn->error);\n\n    ogs_assert(client->multi);\n    rc = curl_multi_add_handle(client->multi, conn->easy);\n    mcode_or_die(\"connection_add: curl_multi_add_handle\", rc);\n\n    return conn;\n}\n\nstatic void _connection_remove(connection_t *conn)\n{\n    int i;\n\n    ogs_assert(conn);\n\n    if (conn->content)\n        ogs_free(conn->content);\n\n    if (conn->location)\n        ogs_free(conn->location);\n\n    if (conn->memory)\n        ogs_free(conn->memory);\n\n    if (conn->easy)\n        curl_easy_cleanup(conn->easy);\n\n    if (conn->timer)\n        ogs_timer_delete(conn->timer);\n\n    if (conn->num_of_header) {\n        for (i = 0; i < conn->num_of_header; i++)\n            if (conn->headers[i])\n                ogs_free(conn->headers[i]);\n        ogs_free(conn->headers);\n    }\n    curl_slist_free_all(conn->header_list);\n\n    if (conn->method)\n        ogs_free(conn->method);\n\n    ogs_pool_free(&connection_pool, conn);\n}\n\nstatic void connection_remove(connection_t *conn)\n{\n    ogs_sbi_client_t *client = NULL;\n\n    ogs_assert(conn);\n    client = conn->client;\n    ogs_assert(client);\n\n    ogs_list_remove(&client->connection_list, conn);\n\n    ogs_assert(client->multi);\n    curl_multi_remove_handle(client->multi, conn->easy);\n\n    _connection_remove(conn);\n}\n\nstatic void connection_remove_all(ogs_sbi_client_t *client)\n{\n    connection_t *conn = NULL, *next_conn = NULL;\n\n    ogs_assert(client);\n\n    ogs_list_for_each_safe(&client->connection_list, next_conn, conn)\n        connection_remove(conn);\n}\n\nstatic void connection_timer_expired(void *data)\n{\n    connection_t *conn = NULL;\n\n    conn = data;\n    ogs_assert(conn);\n\n    ogs_error(\"Connection timer expired\");\n\n    ogs_assert(conn->client_cb);\n    conn->client_cb(OGS_TIMEUP, NULL, conn->data);\n\n    connection_remove(conn);\n}\n\nstatic void check_multi_info(ogs_sbi_client_t *client)\n{\n    CURLM *multi = NULL;\n    CURLMsg *resource;\n    int pending;\n    CURL *easy = NULL;\n    CURLcode res;\n    connection_t *conn = NULL;\n    ogs_sbi_response_t *response = NULL;\n\n    ogs_assert(client);\n    multi = client->multi;\n    ogs_assert(multi);\n\n    while ((resource = curl_multi_info_read(multi, &pending))) {\n        char *url;\n        char *content_type = NULL;\n        long res_status;\n        ogs_assert(resource);\n\n        switch (resource->msg) {\n        case CURLMSG_DONE:\n            easy = resource->easy_handle;\n            ogs_assert(easy);\n\n            curl_easy_getinfo(easy, CURLINFO_PRIVATE, &conn);\n            ogs_assert(conn);\n\n            curl_easy_getinfo(easy, CURLINFO_EFFECTIVE_URL, &url);\n            curl_easy_getinfo(easy, CURLINFO_RESPONSE_CODE, &res_status);\n            curl_easy_getinfo(easy, CURLINFO_CONTENT_TYPE, &content_type);\n\n            res = resource->data.result;\n            if (res == CURLE_OK) {\n                response = ogs_sbi_response_new();\n                ogs_assert(response);\n\n                response->status = res_status;\n\n                ogs_assert(conn->method);\n                response->h.method = ogs_strdup(conn->method);\n                ogs_assert(response->h.method);\n\n                /* remove https://localhost:8000 */\n                response->h.uri = ogs_strdup(url);\n                ogs_assert(response->h.uri);\n\n                ogs_debug(\"[%d:%s] %s\",\n                        response->status, response->h.method, response->h.uri);\n\n                if (conn->memory) {\n                    response->http.content =\n                        ogs_memdup(conn->memory, conn->size + 1);\n                    ogs_assert(response->http.content);\n                    response->http.content_length = conn->size;\n                    ogs_assert(response->http.content_length);\n                }\n\n                ogs_debug(\"RECEIVED[%d]\", (int)response->http.content_length);\n                if (response->http.content_length && response->http.content)\n                    ogs_debug(\"%s\", response->http.content);\n\n                if (content_type)\n                    ogs_sbi_header_set(response->http.headers,\n                            OGS_SBI_CONTENT_TYPE, content_type);\n                if (conn->location)\n                    ogs_sbi_header_set(response->http.headers,\n                            OGS_SBI_LOCATION, conn->location);\n            } else\n                ogs_warn(\"[%d] %s\", res, conn->error);\n\n            ogs_assert(conn->client_cb);\n            conn->client_cb(res == CURLE_OK ? OGS_OK : OGS_ERROR,\n                            response, conn->data);\n            connection_remove(conn);\n            break;\n        default:\n            ogs_error(\"Unknown CURL resource[%d]\", resource->msg);\n            break;\n        }\n    }\n}\n\nbool ogs_sbi_client_send_reqmem_persistent(\n        ogs_sbi_client_t *client, ogs_sbi_client_cb_f client_cb,\n        ogs_sbi_request_t *request, void *data)\n{\n    connection_t *conn = NULL;\n\n    ogs_assert(client);\n    ogs_assert(request);\n\n    if (request->h.uri == NULL) {\n        request->h.uri = ogs_sbi_client_uri(client, &request->h);\n        ogs_expect_or_return_val(request->h.uri, false);\n    }\n    ogs_debug(\"[%s] %s\", request->h.method, request->h.uri);\n\n    conn = connection_add(client, client_cb, request, data);\n    ogs_expect_or_return_val(conn, false);\n\n    return true;\n}\n\nbool ogs_sbi_client_send_request(\n        ogs_sbi_client_t *client, ogs_sbi_client_cb_f client_cb,\n        ogs_sbi_request_t *request, void *data)\n{\n    bool rc;\n\n    ogs_assert(client);\n    ogs_assert(request);\n\n    rc = ogs_sbi_client_send_reqmem_persistent(\n            client, client_cb, request, data);\n    ogs_expect(rc == true);\n\n    ogs_sbi_request_free(request);\n\n    return rc;\n}\n\nbool ogs_sbi_scp_send_reqmem_persistent(\n        ogs_sbi_client_t *client, ogs_sbi_client_cb_f client_cb,\n        ogs_sbi_request_t *request, void *data)\n{\n    ogs_sbi_nf_instance_t *scp_instance = NULL;\n    connection_t *conn = NULL;\n    char *apiroot = NULL;\n\n    ogs_assert(client);\n    ogs_assert(request);\n\n    scp_instance = ogs_sbi_self()->scp_instance;\n\n    if (scp_instance) {\n        /*\n         * In case of indirect communication using SCP,\n         * add 3gpp-Sbi-Target-apiRoot to HTTP header and\n         * change CLIENT instance to SCP.\n         */\n        apiroot = ogs_sbi_client_apiroot(client);\n        ogs_assert(apiroot);\n\n        ogs_sbi_header_set(request->http.headers,\n                OGS_SBI_CUSTOM_TARGET_APIROOT, apiroot);\n\n        ogs_free(apiroot);\n\n        client = scp_instance->client;\n        ogs_assert(client);\n    }\n\n    if (request->h.uri == NULL) {\n        /*\n         * Regardless of direct or indirect communication,\n         * if there is no URI, we automatically creates a URI\n         * with Client Address and request->h\n         */\n        request->h.uri = ogs_sbi_client_uri(client, &request->h);\n        ogs_assert(request->h.uri);\n\n        ogs_debug(\"[%s] %s\", request->h.method, request->h.uri);\n\n    } else if (scp_instance) {\n        /*\n         * In case of indirect communication using SCP,\n         * If the full URI is already defined, change full URI to SCP as below.\n         *\n         * OLD: http://127.0.0.5:7777/nnrf-nfm/v1/nf-status-notify\n         * NEW: https://scp.open5gs.org/nnrf-nfm/v1/nf-status-notify\n         */\n        char *path = NULL;\n        char *old = NULL;\n\n        old = request->h.uri;\n\n        apiroot = ogs_sbi_client_apiroot(client);\n        ogs_assert(apiroot);\n\n        path = ogs_sbi_getpath_from_uri(request->h.uri);\n        ogs_assert(path);\n\n        request->h.uri = ogs_msprintf(\"%s/%s\", apiroot, path);\n        ogs_assert(request->h.uri);\n\n        ogs_free(apiroot);\n        ogs_free(path);\n        ogs_free(old);\n\n        ogs_debug(\"[%s] %s\", request->h.method, request->h.uri);\n    }\n\n    conn = connection_add(client, client_cb, request, data);\n    ogs_expect_or_return_val(conn, false);\n\n    return true;\n}\n\nbool ogs_sbi_scp_send_request(\n        ogs_sbi_client_t *client, ogs_sbi_client_cb_f client_cb,\n        ogs_sbi_request_t *request, void *data)\n{\n    bool rc;\n\n    ogs_assert(client);\n    ogs_assert(request);\n\n    rc = ogs_sbi_scp_send_reqmem_persistent(client, client_cb, request, data);\n    ogs_expect(rc == true);\n\n    ogs_sbi_request_free(request);\n\n    return rc;\n}\n\nstatic size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)\n{\n    size_t realsize = 0;\n    connection_t *conn = NULL;\n    char *ptr = NULL;\n\n    conn = data;\n    ogs_assert(conn);\n\n    realsize = size * nmemb;\n    ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);\n    if(!ptr) {\n        ogs_fatal(\"not enough memory (realloc returned NULL)\");\n        ogs_assert_if_reached();\n        return 0;\n    }\n\n    conn->memory = ptr;\n    memcpy(&(conn->memory[conn->size]), contents, realsize);\n    conn->size += realsize;\n    conn->memory[conn->size] = 0;\n\n    return realsize;\n}\n\nstatic size_t header_cb(void *ptr, size_t size, size_t nmemb, void *data)\n{\n    connection_t *conn = NULL;\n\n    conn = data;\n    ogs_assert(conn);\n\n    if (ogs_strncasecmp(ptr, OGS_SBI_LOCATION, strlen(OGS_SBI_LOCATION)) == 0) {\n        /* ptr : \"Location: http://xxx/xxx/xxx\\r\\n\"\n           We need to truncate \"Location\" + \": \" + \"\\r\\n\" in 'ptr' string */\n        int len = strlen(ptr) - strlen(OGS_SBI_LOCATION) - 2 - 2;\n        if (len) {\n            /* Only copy http://xxx/xxx/xxx\" from 'ptr' string */\n            conn->location = ogs_memdup(\n                    (char *)ptr + strlen(OGS_SBI_LOCATION) + 2, len+1);\n            ogs_assert(conn->location);\n            conn->location[len] = 0;\n        }\n    }\n\n    return (nmemb*size);\n}\n\nstatic void event_cb(short when, ogs_socket_t fd, void *data)\n{\n    sockinfo_t *sockinfo = NULL;\n    ogs_sbi_client_t *client = NULL;\n    CURLM *multi = NULL;\n\n    CURLMcode rc;\n    int action = ((when & OGS_POLLIN) ? CURL_CSELECT_IN : 0) |\n                    ((when & OGS_POLLOUT) ? CURL_CSELECT_OUT : 0);\n\n    sockinfo = data;\n    ogs_assert(sockinfo);\n    client = sockinfo->client;\n    ogs_assert(client);\n    multi = client->multi;\n    ogs_assert(multi);\n\n    rc = curl_multi_socket_action(multi, fd, action, &client->still_running);\n    mcode_or_die(\"event_cb: curl_multi_socket_action\", rc);\n\n    check_multi_info(client);\n    if (client->still_running <= 0) {\n        ogs_timer_t *timer;\n\n        timer = client->t_curl;\n        if (timer)\n            ogs_timer_stop(timer);\n    }\n}\n\n/* Assign information to a sockinfo_t structure */\nstatic void sock_set(sockinfo_t *sockinfo, curl_socket_t s,\n        CURL *e, int act, ogs_sbi_client_t *client)\n{\n    int kind = ((act & CURL_POLL_IN) ? OGS_POLLIN : 0) |\n                ((act & CURL_POLL_OUT) ? OGS_POLLOUT : 0);\n\n    if (sockinfo->sockfd)\n        ogs_pollset_remove(sockinfo->poll);\n\n    sockinfo->sockfd = s;\n    sockinfo->action = act;\n    sockinfo->easy = e;\n\n    sockinfo->poll = ogs_pollset_add(\n            ogs_app()->pollset, kind, s, event_cb, sockinfo);\n    ogs_assert(sockinfo->poll);\n}\n\n/* Initialize a new sockinfo_t structure */\nstatic void sock_new(curl_socket_t s,\n        CURL *easy, int action, ogs_sbi_client_t *client)\n{\n    sockinfo_t *sockinfo = NULL;\n    CURLM *multi = NULL;\n\n    ogs_assert(client);\n    multi = client->multi;\n    ogs_assert(multi);\n\n    ogs_pool_alloc(&sockinfo_pool, &sockinfo);\n    ogs_assert(sockinfo);\n    memset(sockinfo, 0, sizeof(sockinfo_t));\n\n    sockinfo->client = client;\n    sock_set(sockinfo, s, easy, action, client);\n    curl_multi_assign(multi, s, sockinfo);\n}\n\n/* Clean up the sockinfo_t structure */\nstatic void sock_free(sockinfo_t *sockinfo, ogs_sbi_client_t *client)\n{\n    ogs_assert(sockinfo);\n    ogs_assert(sockinfo->poll);\n\n    ogs_pollset_remove(sockinfo->poll);\n    ogs_pool_free(&sockinfo_pool, sockinfo);\n}\n\n/* CURLMOPT_SOCKETFUNCTION */\nstatic int sock_cb(CURL *e, curl_socket_t s, int what, void *cbp, void *sockp)\n{\n    ogs_sbi_client_t *client = (ogs_sbi_client_t *)cbp;\n    sockinfo_t *sockinfo = (sockinfo_t *) sockp;\n\n    if (what == CURL_POLL_REMOVE) {\n        sock_free(sockinfo, client);\n    } else {\n        if (!sockinfo) {\n            sock_new(s, e, what, client);\n        } else {\n            sock_set(sockinfo, s, e, what, client);\n        }\n    }\n    return 0;\n}\n\nstatic void multi_timer_expired(void *data)\n{\n    CURLMcode rc;\n    ogs_sbi_client_t *client = NULL;\n    CURLM *multi = NULL;\n\n    client = data;\n    ogs_assert(client);\n    multi = client->multi;\n    ogs_assert(multi);\n\n    rc = curl_multi_socket_action(\n            multi, CURL_SOCKET_TIMEOUT, 0, &client->still_running);\n    mcode_or_die(\"multi_timer_expired: curl_multi_socket_action\", rc);\n    check_multi_info(client);\n}\n\nstatic int multi_timer_cb(CURLM *multi, long timeout_ms, void *cbp)\n{\n    ogs_sbi_client_t *client = NULL;\n    ogs_timer_t *timer = NULL;\n\n    client = cbp;\n    ogs_assert(client);\n    timer = client->t_curl;\n    ogs_assert(timer);\n\n    if (timeout_ms > 0) {\n        ogs_timer_start(timer, ogs_time_from_msec(timeout_ms));\n    } else if (timeout_ms == 0) {\n        /* libcurl wants us to timeout now.\n         * The closest we can do is to schedule the timer to fire in 1 us. */\n        ogs_timer_start(timer, 1);\n    } else {\n        ogs_timer_stop(timer);\n    }\n\n    return 0;\n}\n", "/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"ogs-sbi.h\"\n#include \"yuarel.h\"\n\n#include <netinet/tcp.h>\n#include <nghttp2/nghttp2.h>\n\n#define USE_SEND_DATA_WITH_NO_COPY 1\n\nstatic void server_init(int num_of_session_pool, int num_of_stream_pool);\nstatic void server_final(void);\n\nstatic int server_start(ogs_sbi_server_t *server,\n        int (*cb)(ogs_sbi_request_t *request, void *data));\nstatic void server_stop(ogs_sbi_server_t *server);\n\nstatic bool server_send_rspmem_persistent(\n        ogs_sbi_stream_t *stream, ogs_sbi_response_t *response);\nstatic bool server_send_response(\n        ogs_sbi_stream_t *stream, ogs_sbi_response_t *response);\n\nstatic ogs_sbi_server_t *server_from_stream(ogs_sbi_stream_t *stream);\n\nconst ogs_sbi_server_actions_t ogs_nghttp2_server_actions = {\n    server_init,\n    server_final,\n\n    server_start,\n    server_stop,\n\n    server_send_rspmem_persistent,\n    server_send_response,\n\n    server_from_stream,\n};\n\nstruct h2_settings {\n    uint32_t max_concurrent_streams;\n    bool enable_push;\n};\n\ntypedef struct ogs_sbi_session_s {\n    ogs_lnode_t             lnode;\n\n    ogs_sock_t              *sock;\n    ogs_sockaddr_t          *addr;\n    struct {\n        ogs_poll_t          *read;\n        ogs_poll_t          *write;\n    } poll;\n\n    nghttp2_session         *session;\n    ogs_list_t              write_queue;\n\n    ogs_sbi_server_t        *server;\n    ogs_list_t              stream_list;\n    int32_t                 last_stream_id;\n\n    struct h2_settings      settings;\n} ogs_sbi_session_t;\n\ntypedef struct ogs_sbi_stream_s {\n    ogs_lnode_t             lnode;\n\n    int32_t                 stream_id;\n    ogs_sbi_request_t       *request;\n\n    ogs_sbi_session_t       *session;\n} ogs_sbi_stream_t;\n\nstatic void session_remove(ogs_sbi_session_t *sbi_sess);\nstatic void session_remove_all(ogs_sbi_server_t *server);\n\nstatic void stream_remove(ogs_sbi_stream_t *stream);\n\nstatic void accept_handler(short when, ogs_socket_t fd, void *data);\nstatic void recv_handler(short when, ogs_socket_t fd, void *data);\n\nstatic int session_set_callbacks(ogs_sbi_session_t *sbi_sess);\nstatic int session_send_preface(ogs_sbi_session_t *sbi_sess);\nstatic int session_send(ogs_sbi_session_t *sbi_sess);\nstatic void session_write_to_buffer(\n        ogs_sbi_session_t *sbi_sess, ogs_pkbuf_t *pkbuf);\n\nstatic OGS_POOL(session_pool, ogs_sbi_session_t);\nstatic OGS_POOL(stream_pool, ogs_sbi_stream_t);\n\nstatic void server_init(int num_of_session_pool, int num_of_stream_pool)\n{\n    ogs_pool_init(&session_pool, num_of_session_pool);\n    ogs_pool_init(&stream_pool, num_of_stream_pool);\n}\n\nstatic void server_final(void)\n{\n    ogs_pool_final(&stream_pool);\n    ogs_pool_final(&session_pool);\n}\n\nstatic int server_start(ogs_sbi_server_t *server,\n        int (*cb)(ogs_sbi_request_t *request, void *data))\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sock_t *sock = NULL;\n    ogs_sockaddr_t *addr = NULL;\n    char *hostname = NULL;\n\n    addr = server->node.addr;\n    ogs_assert(addr);\n\n    sock = ogs_tcp_server(addr, server->node.option);\n    if (!sock) {\n        ogs_error(\"Cannot start SBI server\");\n        return OGS_ERROR;\n    }\n\n    server->node.sock = sock;\n\n    /* Setup callback function */\n    server->cb = cb;\n\n    /* Setup poll for server listening socket */\n    server->node.poll = ogs_pollset_add(ogs_app()->pollset,\n            OGS_POLLIN, sock->fd, accept_handler, server);\n    ogs_assert(server->node.poll);\n\n    hostname = ogs_gethostname(addr);\n    if (hostname)\n        ogs_info(\"nghttp2_server() [%s]:%d\", hostname, OGS_PORT(addr));\n    else\n        ogs_info(\"nghttp2_server() [%s]:%d\",\n                OGS_ADDR(addr, buf), OGS_PORT(addr));\n\n    return OGS_OK;\n}\n\nstatic void server_stop(ogs_sbi_server_t *server)\n{\n    ogs_assert(server);\n\n    if (server->node.poll)\n        ogs_pollset_remove(server->node.poll);\n\n    if (server->node.sock)\n        ogs_sock_destroy(server->node.sock);\n\n    session_remove_all(server);\n}\n\nstatic void add_header(nghttp2_nv *nv, const char *key, const char *value)\n{\n    nv->name = (uint8_t *)key;\n    nv->namelen = strlen(key);\n    nv->value = (uint8_t *)value;\n    nv->valuelen = strlen(value);\n    nv->flags = NGHTTP2_NV_FLAG_NONE;\n}\n\nstatic char status_string[600][4] = {\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"100\", \"101\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"200\", \"201\", \"202\", \"203\", \"204\", \"205\", \"206\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"300\", \"301\", \"302\", \"303\", \"304\", \"305\", \"306\", \"307\", \"308\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"400\", \"401\", \"402\", \"403\", \"404\", \"405\", \"406\", \"407\", \"408\", \"409\",\n \"410\", \"411\", \"412\", \"413\", \"414\", \"415\", \"416\", \"417\", \"\", \"\",\n \"\", \"421\", \"\", \"\", \"\", \"\", \"426\", \"\", \"428\", \"429\", \"\", \"431\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"451\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"500\", \"501\", \"502\", \"503\", \"504\", \"505\", \"\", \"\", \"\", \"\", \"\", \"511\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\n};\n\n#define DATE_STRLEN 128\nstatic char *get_date_string(char *date)\n{\n    static const char *const days[] = {\n        \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n    };\n    static const char *const mons[] = {\n        \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n        \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n    };\n\n    ogs_assert(date);\n\n    struct tm tm;\n    ogs_gmtime(ogs_time_sec(ogs_time_now()), &tm);\n\n    ogs_snprintf(date, DATE_STRLEN, \"%3s, %02u %3s %04u %02u:%02u:%02u GMT\",\n            days[tm.tm_wday % 7],\n            (unsigned int)tm.tm_mday,\n            mons[tm.tm_mon % 12],\n            (unsigned int)(1900 + tm.tm_year),\n            (unsigned int)tm.tm_hour,\n            (unsigned int)tm.tm_min,\n            (unsigned int)tm.tm_sec);\n\n    return date;\n}\n\nstatic ssize_t response_read_callback(nghttp2_session *session,\n                                      int32_t stream_id,\n                                      uint8_t *buf, size_t length,\n                                      uint32_t *data_flags,\n                                      nghttp2_data_source *source,\n                                      void *user_data)\n{\n#if USE_SEND_DATA_WITH_NO_COPY\n    int rv;\n#endif\n\n    ogs_sbi_response_t *response = NULL;\n    ogs_sbi_stream_t *stream = NULL;\n\n    ogs_assert(session);\n\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n\n    ogs_assert(source);\n    response = source->ptr;\n    ogs_assert(response);\n\n    ogs_assert(response->http.content);\n    ogs_assert(response->http.content_length);\n\n#if USE_SEND_DATA_WITH_NO_COPY\n    *data_flags |= NGHTTP2_DATA_FLAG_NO_COPY;\n#else\n    memcpy(buf, response->http.content, response->http.content_length);\n#endif\n\n    *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n\n#if USE_SEND_DATA_WITH_NO_COPY\n    rv = nghttp2_session_get_stream_remote_close(session, stream_id);\n    if (rv == 0) {\n        ogs_warn(\"nghttp2_session_get_stream_remote_close() failed\");\n        nghttp2_submit_rst_stream(\n                session, NGHTTP2_FLAG_NONE, stream_id, NGHTTP2_NO_ERROR);\n    } else if (rv != 1) {\n        ogs_error(\"nghttp2_session_get_stream_remote_close() failed[%d]\", rv);\n    }\n#endif\n\n    return response->http.content_length;\n}\n\nstatic bool server_send_rspmem_persistent(\n        ogs_sbi_stream_t *stream, ogs_sbi_response_t *response)\n{\n    ogs_sbi_session_t *sbi_sess = NULL;\n    ogs_sock_t *sock = NULL;\n    ogs_socket_t fd = INVALID_SOCKET;\n\n    ogs_hash_index_t *hi;\n    nghttp2_nv *nva;\n    size_t nvlen;\n    int i, rv;\n    char datebuf[DATE_STRLEN];\n    char srv_version[128];\n    char clen[128];\n\n    ogs_assert(response);\n\n    stream = ogs_pool_cycle(&stream_pool, stream);\n    if (!stream) {\n        ogs_error(\"stream has already been removed\");\n        return true;\n    }\n\n    sbi_sess = stream->session;\n    ogs_assert(sbi_sess);\n    ogs_assert(sbi_sess->session);\n\n    sock = sbi_sess->sock;\n    ogs_assert(sock);\n    fd = sock->fd;\n    ogs_assert(fd != INVALID_SOCKET); /* Check if session is removed */\n\n    nvlen = 3; /* :status && server && date */\n\n    for (hi = ogs_hash_first(response->http.headers);\n            hi; hi = ogs_hash_next(hi))\n        nvlen++;\n\n    if (response->http.content && response->http.content_length)\n        nvlen++;\n\n    nva = ogs_calloc(nvlen, sizeof(nghttp2_nv));\n    ogs_expect_or_return_val(nva, false);\n\n    i = 0;\n\n    ogs_expect_or_return_val(response->status < 600, false);\n    ogs_assert(strlen(status_string[response->status]) == 3);\n    add_header(&nva[i++], \":status\", status_string[response->status]);\n\n    ogs_snprintf(srv_version, sizeof(srv_version),\n            \"Open5GS %s\", ogs_app()->version ? ogs_app()->version : \"TEST\");\n    add_header(&nva[i++], \"server\", srv_version);\n    add_header(&nva[i++], \"date\", get_date_string(datebuf));\n\n    if (response->http.content && response->http.content_length) {\n        ogs_snprintf(clen, sizeof(clen),\n                \"%d\", (int)response->http.content_length);\n        add_header(&nva[i++], \"content-length\", clen);\n    }\n\n    for (hi = ogs_hash_first(response->http.headers);\n            hi; hi = ogs_hash_next(hi)) {\n        add_header(&nva[i++], ogs_hash_this_key(hi), ogs_hash_this_val(hi));\n    }\n\n    ogs_debug(\"STATUS [%d]\", response->status);\n\n    if (response->http.content && response->http.content_length) {\n        nghttp2_data_provider data_prd;\n\n        data_prd.source.ptr = response;\n        data_prd.read_callback = response_read_callback;\n\n        ogs_debug(\"SENDING...: %d\", (int)response->http.content_length);\n        ogs_debug(\"%s\", response->http.content);\n\n        rv = nghttp2_submit_response(sbi_sess->session,\n                stream->stream_id, nva, nvlen, &data_prd);\n    } else {\n        rv = nghttp2_submit_response(sbi_sess->session,\n                stream->stream_id, nva, nvlen, NULL);\n    }\n\n    if (rv != OGS_OK) {\n        ogs_error(\"nghttp2_submit_response(%d) failed (%d:%s)\",\n                    (int)response->http.content_length,\n                    rv, nghttp2_strerror(rv));\n        nghttp2_submit_rst_stream(\n                sbi_sess->session, NGHTTP2_FLAG_NONE, stream->stream_id, rv);\n    }\n\n    if (session_send(sbi_sess) != OGS_OK) {\n        ogs_error(\"session_send() failed\");\n        session_remove(sbi_sess);\n    }\n\n    ogs_free(nva);\n\n    return true;\n}\n\nstatic bool server_send_response(\n        ogs_sbi_stream_t *stream, ogs_sbi_response_t *response)\n{\n    bool rc;\n\n    ogs_assert(response);\n\n    rc = server_send_rspmem_persistent(stream, response);\n\n    ogs_sbi_response_free(response);\n\n    return rc;\n}\n\nstatic ogs_sbi_server_t *server_from_stream(ogs_sbi_stream_t *stream)\n{\n    ogs_sbi_session_t *sbi_sess = NULL;\n\n    ogs_assert(stream);\n    sbi_sess = stream->session;\n    ogs_assert(sbi_sess);\n    ogs_assert(sbi_sess->server);\n\n    return sbi_sess->server;\n}\n\nstatic ogs_sbi_stream_t *stream_add(\n        ogs_sbi_session_t *sbi_sess, int32_t stream_id)\n{\n    ogs_sbi_stream_t *stream = NULL;\n\n    ogs_assert(sbi_sess);\n\n    ogs_pool_alloc(&stream_pool, &stream);\n    ogs_expect_or_return_val(stream, NULL);\n    memset(stream, 0, sizeof(ogs_sbi_stream_t));\n\n    stream->request = ogs_sbi_request_new();\n    ogs_expect_or_return_val(stream->request, NULL);\n\n    stream->stream_id = stream_id;\n    sbi_sess->last_stream_id = stream_id;\n\n    stream->session = sbi_sess;\n\n    ogs_list_add(&sbi_sess->stream_list, stream);\n\n    return stream;\n}\n\nstatic void stream_remove(ogs_sbi_stream_t *stream)\n{\n    ogs_sbi_session_t *sbi_sess = NULL;\n\n    ogs_assert(stream);\n    sbi_sess = stream->session;\n    ogs_assert(sbi_sess);\n\n    ogs_list_remove(&sbi_sess->stream_list, stream);\n\n    ogs_assert(stream->request);\n    ogs_sbi_request_free(stream->request);\n\n    ogs_pool_free(&stream_pool, stream);\n}\n\nstatic void stream_remove_all(ogs_sbi_session_t *sbi_sess)\n{\n    ogs_sbi_stream_t *stream = NULL, *next_stream = NULL;\n\n    ogs_assert(sbi_sess);\n\n    ogs_list_for_each_safe(&sbi_sess->stream_list, next_stream, stream)\n        stream_remove(stream);\n}\n\nstatic ogs_sbi_session_t *session_add(\n        ogs_sbi_server_t *server, ogs_sock_t *sock)\n{\n    ogs_sbi_session_t *sbi_sess = NULL;\n\n    ogs_assert(server);\n    ogs_assert(sock);\n\n    ogs_pool_alloc(&session_pool, &sbi_sess);\n    ogs_expect_or_return_val(sbi_sess, NULL);\n    memset(sbi_sess, 0, sizeof(ogs_sbi_session_t));\n\n    sbi_sess->server = server;\n    sbi_sess->sock = sock;\n\n    sbi_sess->addr = ogs_calloc(1, sizeof(ogs_sockaddr_t));\n    ogs_expect_or_return_val(sbi_sess->addr, NULL);\n    memcpy(sbi_sess->addr, &sock->remote_addr, sizeof(ogs_sockaddr_t));\n\n    ogs_list_add(&server->session_list, sbi_sess);\n\n    return sbi_sess;\n}\n\nstatic void session_remove(ogs_sbi_session_t *sbi_sess)\n{\n    ogs_sbi_server_t *server = NULL;\n    ogs_pkbuf_t *pkbuf = NULL, *next_pkbuf = NULL;\n\n    ogs_assert(sbi_sess);\n    server = sbi_sess->server;\n    ogs_assert(server);\n\n    ogs_list_remove(&server->session_list, sbi_sess);\n\n    stream_remove_all(sbi_sess);\n    nghttp2_session_del(sbi_sess->session);\n\n    ogs_assert(sbi_sess->poll.read);\n    ogs_pollset_remove(sbi_sess->poll.read);\n\n    if (sbi_sess->poll.write)\n        ogs_pollset_remove(sbi_sess->poll.write);\n\n    ogs_list_for_each_safe(&sbi_sess->write_queue, next_pkbuf, pkbuf) {\n        ogs_list_remove(&sbi_sess->write_queue, pkbuf);\n        ogs_pkbuf_free(pkbuf);\n    }\n\n    ogs_assert(sbi_sess->addr);\n    ogs_free(sbi_sess->addr);\n\n    ogs_assert(sbi_sess->sock);\n    ogs_sock_destroy(sbi_sess->sock);\n\n    ogs_pool_free(&session_pool, sbi_sess);\n}\n\nstatic void session_remove_all(ogs_sbi_server_t *server)\n{\n    ogs_sbi_session_t *sbi_sess = NULL, *next_sbi_sess = NULL;\n\n    ogs_assert(server);\n\n    ogs_list_for_each_safe(&server->session_list, next_sbi_sess, sbi_sess)\n        session_remove(sbi_sess);\n}\n\nstatic void accept_handler(short when, ogs_socket_t fd, void *data)\n{\n    ogs_sbi_server_t *server = data;\n    ogs_sbi_session_t *sbi_sess = NULL;\n    ogs_sock_t *sock = NULL;\n    ogs_sock_t *new = NULL;\n\n    int on;\n\n    ogs_assert(data);\n    ogs_assert(fd != INVALID_SOCKET);\n\n    sock = server->node.sock;\n\n    new = ogs_sock_accept(sock);\n    if (!new) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, \"accept() failed\");\n        return;\n    }\n    ogs_assert(new->fd != INVALID_SOCKET);\n\n    on = 1;\n    if (setsockopt(new->fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) != 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"setsockopt() for SCTP_NODELAY failed\");\n        ogs_sock_destroy(new);\n        return;\n    }\n\n    sbi_sess = session_add(server, new);\n    ogs_assert(sbi_sess);\n\n    sbi_sess->poll.read = ogs_pollset_add(ogs_app()->pollset,\n        OGS_POLLIN, new->fd, recv_handler, sbi_sess);\n    ogs_assert(sbi_sess->poll.read);\n\n    if (session_set_callbacks(sbi_sess) != OGS_OK ||\n        session_send_preface(sbi_sess) != OGS_OK) {\n        ogs_error(\"session_add() failed\");\n        session_remove(sbi_sess);\n    }\n}\n\nstatic void recv_handler(short when, ogs_socket_t fd, void *data)\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sockaddr_t *addr = NULL;\n\n    ogs_sbi_session_t *sbi_sess = data;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ssize_t readlen;\n    int n;\n\n    ogs_assert(sbi_sess);\n    ogs_assert(fd != INVALID_SOCKET);\n    addr = sbi_sess->addr;\n    ogs_assert(addr);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n\n    n = ogs_recv(fd, pkbuf->data, OGS_MAX_SDU_LEN, 0);\n    if (n > 0) {\n        ogs_pkbuf_put(pkbuf, n);\n\n        ogs_assert(sbi_sess->session);\n        readlen = nghttp2_session_mem_recv(\n                sbi_sess->session, pkbuf->data, pkbuf->len);\n        if (readlen < 0) {\n            ogs_error(\"nghttp2_session_mem_recv() failed (%d:%s)\",\n                        (int)readlen, nghttp2_strerror((int)readlen));\n            session_remove(sbi_sess);\n        }\n    } else {\n        if (n < 0) {\n            if (errno != OGS_ECONNRESET)\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                                \"lost connection [%s]:%d\",\n                                OGS_ADDR(addr, buf), OGS_PORT(addr));\n        } else if (n == 0) {\n            ogs_debug(\"connection closed [%s]:%d\",\n                        OGS_ADDR(addr, buf), OGS_PORT(addr));\n        }\n\n        session_remove(sbi_sess);\n    }\n\n    ogs_pkbuf_free(pkbuf);\n}\n\nstatic int on_frame_recv(nghttp2_session *session,\n                         const nghttp2_frame *frame, void *user_data);\nstatic int on_stream_close(nghttp2_session *session, int32_t stream_id,\n                           uint32_t error_code, void *user_data);\nstatic int on_header(nghttp2_session *session,\n                     const nghttp2_frame *frame,\n                     nghttp2_rcbuf *name, nghttp2_rcbuf *value,\n                     uint8_t flags, void *user_data);\nstatic int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,\n                              int32_t stream_id, const uint8_t *data,\n                              size_t len, void *user_data);\nstatic int error_callback(nghttp2_session *session,\n                          const char *msg, size_t len, void *user_data);\nstatic int on_invalid_frame_recv(nghttp2_session *session,\n                                 const nghttp2_frame *frame,\n                                 int error_code, void *user_data);\nstatic int on_invalid_header(nghttp2_session *session,\n                             const nghttp2_frame *frame,\n                             const uint8_t *name, size_t namelen,\n                             const uint8_t *value, size_t valuelen,\n                             uint8_t flags, void *user_data);\nstatic int on_begin_frame(nghttp2_session *session,\n                          const nghttp2_frame_hd *hd, void *user_data);\nstatic int on_begin_headers(nghttp2_session *session,\n                            const nghttp2_frame *frame,\n                                     void *user_data);\n#if USE_SEND_DATA_WITH_NO_COPY\nstatic int on_send_data(nghttp2_session *session, nghttp2_frame *frame,\n                        const uint8_t *framehd, size_t length,\n                        nghttp2_data_source *source, void *user_data);\n#else\nstatic ssize_t send_callback(nghttp2_session *session, const uint8_t *data,\n                             size_t length, int flags, void *user_data);\n#endif\n\nstatic int session_set_callbacks(ogs_sbi_session_t *sbi_sess)\n{\n    int rv;\n    nghttp2_session_callbacks *callbacks = NULL;\n\n    ogs_assert(sbi_sess);\n\n    rv = nghttp2_session_callbacks_new(&callbacks);\n    if (rv != 0) {\n        ogs_error(\"nghttp2_session_callbacks_new() failed (%d:%s)\",\n                    rv, nghttp2_strerror(rv));\n        return OGS_ERROR;\n    }\n\n    nghttp2_session_callbacks_set_on_frame_recv_callback(\n            callbacks, on_frame_recv);\n\n    nghttp2_session_callbacks_set_on_stream_close_callback(\n            callbacks, on_stream_close);\n\n    nghttp2_session_callbacks_set_on_header_callback2(callbacks, on_header);\n\n    nghttp2_session_callbacks_set_on_data_chunk_recv_callback(\n            callbacks, on_data_chunk_recv);\n\n    nghttp2_session_callbacks_set_error_callback(callbacks, error_callback);\n\n    nghttp2_session_callbacks_set_on_invalid_frame_recv_callback(\n            callbacks, on_invalid_frame_recv);\n\n    nghttp2_session_callbacks_set_on_invalid_header_callback(\n            callbacks, on_invalid_header);\n\n    nghttp2_session_callbacks_set_on_begin_frame_callback(\n            callbacks, on_begin_frame);\n\n    nghttp2_session_callbacks_set_on_begin_headers_callback(\n            callbacks, on_begin_headers);\n\n#if USE_SEND_DATA_WITH_NO_COPY\n    nghttp2_session_callbacks_set_send_data_callback(callbacks, on_send_data);\n#else\n    nghttp2_session_callbacks_set_send_callback(callbacks, send_callback);\n#endif\n\n    rv = nghttp2_session_server_new(&sbi_sess->session, callbacks, sbi_sess);\n    if (rv != 0) {\n        ogs_error(\"nghttp2_session_callbacks_new() failed (%d:%s)\",\n                    rv, nghttp2_strerror(rv));\n        return OGS_ERROR;\n    }\n\n    nghttp2_session_callbacks_del(callbacks);\n\n    return OGS_OK;\n}\n\nstatic int on_frame_recv(nghttp2_session *session,\n                         const nghttp2_frame *frame, void *user_data)\n{\n    int rv;\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_sbi_server_t *server = NULL;\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n\n    ogs_assert(sbi_sess);\n    server = sbi_sess->server;\n    ogs_assert(server);\n    ogs_assert(server->cb);\n\n    ogs_assert(session);\n    ogs_assert(frame);\n\n    stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);\n    if (!stream) {\n        if (frame->hd.type == NGHTTP2_SETTINGS) {\n            sbi_sess->settings.max_concurrent_streams =\n                nghttp2_session_get_remote_settings(\n                    session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);\n            sbi_sess->settings.enable_push =\n                nghttp2_session_get_remote_settings(\n                    session, NGHTTP2_SETTINGS_ENABLE_PUSH);\n            ogs_debug(\"MAX_CONCURRENT_STREAMS = %d\",\n                sbi_sess->settings.max_concurrent_streams);\n            ogs_debug(\"ENABLE_PUSH = %s\",\n                sbi_sess->settings.enable_push ? \"TRUE\" : \"false\");\n\n        } else if (frame->hd.type == NGHTTP2_GOAWAY) {\n            rv = nghttp2_submit_goaway(\n                 session, NGHTTP2_FLAG_NONE, sbi_sess->last_stream_id,\n                 NGHTTP2_NO_ERROR, NULL, 0);\n            if (rv != 0) {\n                ogs_error(\"nghttp2_submit_goaway() failed (%d:%s)\",\n                            rv, nghttp2_strerror(rv));\n                return OGS_ERROR;\n            }\n\n            session_send(sbi_sess);\n        }\n        return 0;\n    }\n\n    request = stream->request;\n    ogs_assert(request);\n\n    switch (frame->hd.type) {\n    case NGHTTP2_HEADERS:\n        if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) {\n            const char *expect100 =\n                ogs_sbi_header_get(request->http.headers, OGS_SBI_EXPECT);\n            if (expect100 && ogs_strcasecmp(expect100, \"100-continue\") == 0) {\n                nghttp2_nv nva;\n\n                add_header(&nva, \":status\", status_string[100]);\n                rv = nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE,\n                           stream->stream_id, NULL, &nva, 1, NULL);\n                if (rv != 0) {\n                    ogs_error(\"nghttp2_submit_headers() failed (%d:%s)\",\n                            rv, nghttp2_strerror(rv));\n                    nghttp2_submit_rst_stream(\n                            session, NGHTTP2_FLAG_NONE, stream->stream_id, rv);\n                    return 0;\n                }\n            }\n        }\n        /* fallthrough */\n        OGS_GNUC_FALLTHROUGH;\n\n    case NGHTTP2_DATA:\n        /* HEADERS or DATA frame with +END_STREAM flag */\n        if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n\n            ogs_debug(\"[%s] %s\", request->h.method, request->h.uri);\n\n            if (request->http.content_length && request->http.content) {\n                ogs_debug(\"RECEIVED: %d\", (int)request->http.content_length);\n                ogs_debug(\"%s\", request->http.content);\n            }\n\n            if (server->cb(request, stream) != OGS_OK) {\n                ogs_warn(\"server callback error\");\n                ogs_assert(true ==\n                    ogs_sbi_server_send_error(stream,\n                        OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR, NULL,\n                        \"server callback error\", NULL));\n\n                return 0;\n            }\n            break;\n        }\n    default:\n        break;\n    }\n\n    return 0;\n}\n\nstatic int on_stream_close(nghttp2_session *session, int32_t stream_id,\n                           uint32_t error_code, void *user_data)\n{\n    ogs_sbi_stream_t *stream = NULL;\n\n    ogs_assert(session);\n\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n\n    if (error_code) {\n        ogs_error(\"on_stream_close_callback() failed (%d:%s)\",\n                    error_code, nghttp2_http2_strerror(error_code));\n        nghttp2_submit_rst_stream(\n                session, NGHTTP2_FLAG_NONE, stream_id, error_code);\n    }\n\n    ogs_debug(\"STREAM closed [%d]\", stream_id);\n    stream_remove(stream);\n    return 0;\n}\n\nstatic int on_header(nghttp2_session *session, const nghttp2_frame *frame,\n                     nghttp2_rcbuf *name, nghttp2_rcbuf *value,\n                     uint8_t flags, void *user_data)\n{\n    ogs_sbi_session_t *sbi_sess = user_data;\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n\n    const char PATH[] = \":path\";\n    const char METHOD[] = \":method\";\n\n    nghttp2_vec namebuf, valuebuf;\n    char *namestr = NULL, *valuestr = NULL;\n\n    ogs_assert(session);\n    ogs_assert(frame);\n\n    if (frame->hd.type != NGHTTP2_HEADERS ||\n        frame->headers.cat != NGHTTP2_HCAT_REQUEST) {\n        return 0;\n    }\n\n    stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", frame->hd.stream_id);\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n\n    ogs_assert(sbi_sess);\n\n    request = stream->request;\n    ogs_assert(request);\n\n    ogs_assert(name);\n    namebuf = nghttp2_rcbuf_get_buf(name);\n    ogs_assert(namebuf.base);\n    ogs_assert(namebuf.len);\n\n    ogs_assert(value);\n    valuebuf = nghttp2_rcbuf_get_buf(value);\n    ogs_assert(valuebuf.base);\n\n    if (valuebuf.len == 0) return 0;\n\n    namestr = ogs_strndup((const char *)namebuf.base, namebuf.len);\n    ogs_assert(namestr);\n\n    valuestr = ogs_strndup((const char *)valuebuf.base, valuebuf.len);\n    ogs_assert(valuestr);\n\n    if (namebuf.len == sizeof(PATH) - 1 &&\n            memcmp(PATH, namebuf.base, namebuf.len) == 0) {\n        char *saveptr = NULL, *query;\n#define MAX_NUM_OF_PARAM_IN_QUERY 16\n        struct yuarel_param params[MAX_NUM_OF_PARAM_IN_QUERY+2];\n        int j;\n\n        ogs_assert(request->h.uri == NULL);\n        request->h.uri = ogs_sbi_parse_uri(valuestr, \"?\", &saveptr);\n        ogs_assert(request->h.uri);\n\n        memset(params, 0, sizeof(params));\n\n        query = ogs_sbi_parse_uri(NULL, \"?\", &saveptr);\n        if (query && *query && strlen(query))\n            yuarel_parse_query(query, '&', params, MAX_NUM_OF_PARAM_IN_QUERY+1);\n\n        j = 0;\n        while(params[j].key && params[j].val) {\n            ogs_sbi_header_set(request->http.params,\n                    params[j].key, params[j].val);\n            j++;\n        }\n\n        if (j >= MAX_NUM_OF_PARAM_IN_QUERY+1) {\n            ogs_fatal(\"Maximum number(%d) of query params reached\",\n                    MAX_NUM_OF_PARAM_IN_QUERY);\n            ogs_assert_if_reached();\n        }\n\n        ogs_free(query);\n\n    } else if (namebuf.len == sizeof(METHOD) - 1 &&\n            memcmp(METHOD, namebuf.base, namebuf.len) == 0) {\n\n        ogs_assert(request->h.method == NULL);\n        request->h.method = ogs_strdup(valuestr);\n        ogs_assert(request->h.method);\n\n    } else {\n\n        ogs_sbi_header_set(request->http.headers, namestr, valuestr);\n\n    }\n\n    ogs_free(namestr);\n    ogs_free(valuestr);\n\n    return 0;\n}\n\nstatic int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,\n                              int32_t stream_id, const uint8_t *data,\n                              size_t len, void *user_data)\n{\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n\n    size_t offset = 0;\n\n    ogs_assert(session);\n\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return 0;\n    }\n\n    request = stream->request;\n    ogs_assert(request);\n\n    ogs_assert(data);\n    ogs_assert(len);\n\n    if (request->http.content == NULL) {\n        request->http.content_length = len;\n        request->http.content =\n            (char*)ogs_malloc(request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    } else {\n        offset = request->http.content_length;\n        if ((request->http.content_length + len) > OGS_HUGE_LEN) {\n            ogs_error(\"Overflow : Content-Length[%d], len[%d]\",\n                        (int)request->http.content_length, (int)len);\n            ogs_assert_if_reached();\n        }\n        request->http.content_length += len;\n        request->http.content = (char *)ogs_realloc(\n                request->http.content, request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    }\n\n    memcpy(request->http.content + offset, data, len);\n    request->http.content[request->http.content_length] = '\\0';\n\n    return 0;\n}\n\nstatic int error_callback(nghttp2_session *session,\n                          const char *msg, size_t len, void *user_data)\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sockaddr_t *addr = NULL;\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_assert(sbi_sess);\n    addr = sbi_sess->addr;\n    ogs_assert(addr);\n\n    ogs_assert(msg);\n\n    ogs_error(\"[%s]:%d http2 error: %.*s\",\n            OGS_ADDR(addr, buf), OGS_PORT(addr), (int)len, msg);\n\n    return 0;\n}\n\nstatic int on_invalid_frame_recv(nghttp2_session *session,\n                                 const nghttp2_frame *frame,\n                                 int error_code, void *user_data)\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sockaddr_t *addr = NULL;\n\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_assert(sbi_sess);\n    addr = sbi_sess->addr;\n    ogs_assert(addr);\n\n    ogs_error(\"[%s]:%d invalid frame (%d:%s)\",\n            OGS_ADDR(addr, buf), OGS_PORT(addr),\n            error_code, nghttp2_strerror(error_code));\n    return 0;\n}\n\nstatic int on_invalid_header(nghttp2_session *session,\n                             const nghttp2_frame *frame,\n                             const uint8_t *name, size_t namelen,\n                             const uint8_t *value, size_t valuelen,\n                             uint8_t flags, void *user_data)\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sockaddr_t *addr = NULL;\n    char *namestr = NULL, *valuestr = NULL;\n\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_assert(sbi_sess);\n    addr = sbi_sess->addr;\n    ogs_assert(addr);\n\n    namestr = ogs_strndup((const char *)name, namelen);\n    ogs_assert(namestr);\n\n    valuestr = ogs_strndup((const char *)value, valuelen);\n    ogs_assert(valuestr);\n\n    ogs_error(\"[%s]:%d invalid header (%s:%s)\",\n            OGS_ADDR(addr, buf), OGS_PORT(addr), namestr, valuestr);\n\n    ogs_free(namestr);\n    ogs_free(valuestr);\n\n    return 0;\n}\n\nstatic int on_begin_frame(nghttp2_session *session, const nghttp2_frame_hd *hd,\n                          void *user_data)\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sockaddr_t *addr = NULL;\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_assert(sbi_sess);\n    addr = sbi_sess->addr;\n    ogs_assert(addr);\n\n    ogs_assert(hd);\n\n    if ((hd->type == NGHTTP2_HEADERS) &&\n        (hd->stream_id < sbi_sess->last_stream_id)) {\n        ogs_error(\"[%s]:%d invalid stream id(%d) >= last stream id(%d)\",\n                OGS_ADDR(addr, buf), OGS_PORT(addr),\n                hd->stream_id, sbi_sess->last_stream_id);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n\n    return 0;\n}\n\nstatic int on_begin_headers(nghttp2_session *session,\n                            const nghttp2_frame *frame, void *user_data)\n{\n    ogs_sbi_session_t *sbi_sess = user_data;\n    ogs_sbi_stream_t *stream = NULL;\n\n    ogs_assert(sbi_sess);\n    ogs_assert(session);\n    ogs_assert(frame);\n\n    if (frame->hd.type != NGHTTP2_HEADERS ||\n        frame->headers.cat != NGHTTP2_HCAT_REQUEST) {\n        return 0;\n    }\n\n    stream = stream_add(sbi_sess, frame->hd.stream_id);\n    ogs_assert(stream);\n    ogs_debug(\"STREAM added [%d]\", frame->hd.stream_id);\n\n    nghttp2_session_set_stream_user_data(session, frame->hd.stream_id, stream);\n\n    return 0;\n}\n\nstatic int session_send_preface(ogs_sbi_session_t *sbi_sess)\n{\n    int rv;\n    nghttp2_settings_entry iv[1] = {\n        { NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, ogs_app()->pool.stream }\n    };\n\n    ogs_assert(sbi_sess);\n    ogs_assert(sbi_sess->session);\n\n    rv = nghttp2_submit_settings(\n            sbi_sess->session, NGHTTP2_FLAG_NONE, iv, OGS_ARRAY_SIZE(iv));\n    if (rv != 0) {\n        ogs_error(\"nghttp2_submit_settings() failed (%d:%s)\",\n                    rv, nghttp2_strerror(rv));\n        return OGS_ERROR;\n    }\n\n    return session_send(sbi_sess);\n}\n\n#if USE_SEND_DATA_WITH_NO_COPY\nstatic int on_send_data(nghttp2_session *session, nghttp2_frame *frame,\n                        const uint8_t *framehd, size_t length,\n                        nghttp2_data_source *source, void *user_data)\n{\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_sbi_response_t *response = NULL;\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_pkbuf_t *pkbuf = NULL;\n    size_t padlen = 0;\n\n    ogs_assert(session);\n    ogs_assert(frame);\n\n    stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", frame->hd.stream_id);\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n\n    ogs_assert(sbi_sess);\n\n    ogs_assert(source);\n    response = source->ptr;\n    ogs_assert(response);\n\n    ogs_assert(response->http.content);\n    ogs_assert(response->http.content_length);\n\n    ogs_assert(framehd);\n    ogs_assert(length);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put_data(pkbuf, framehd, 9);\n\n    padlen = frame->data.padlen;\n\n    if (padlen > 0) {\n        ogs_pkbuf_put_u8(pkbuf, padlen-1);\n    }\n\n    ogs_pkbuf_put_data(pkbuf,\n            response->http.content, response->http.content_length);\n\n    if (padlen > 0) {\n        memset(pkbuf->tail, 0, padlen-1);\n        ogs_pkbuf_put(pkbuf, padlen-1);\n    }\n\n    session_write_to_buffer(sbi_sess, pkbuf);\n\n    return 0;\n}\n#else\nstatic ssize_t send_callback(nghttp2_session *session, const uint8_t *data,\n                             size_t length, int flags, void *user_data)\n{\n    ogs_sbi_session_t *sbi_sess = user_data;\n    ogs_sock_t *sock = NULL;\n    ogs_socket_t fd = INVALID_SOCKET;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    ogs_assert(sbi_sess);\n    sock = sbi_sess->sock;\n    ogs_assert(sock);\n    fd = sock->fd;\n    ogs_assert(fd != INVALID_SOCKET);\n\n    ogs_assert(data);\n    ogs_assert(length);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, length);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put_data(pkbuf, data, length);\n\n    session_write_to_buffer(sbi_sess, pkbuf);\n\n    return length;\n}\n#endif\n\nstatic int session_send(ogs_sbi_session_t *sbi_sess)\n{\n#if USE_SEND_DATA_WITH_NO_COPY\n    ogs_pkbuf_t *pkbuf = NULL;\n#else\n    int rv;\n#endif\n\n    ogs_assert(sbi_sess);\n    ogs_assert(sbi_sess->session);\n\n#if USE_SEND_DATA_WITH_NO_COPY\n    for (;;) {\n        const uint8_t *data = NULL;\n        ssize_t data_len;\n\n        data_len = nghttp2_session_mem_send(sbi_sess->session, &data);\n        if (data_len < 0) {\n            ogs_error(\"nghttp2_session_mem_send() failed (%d:%s)\",\n                        (int)data_len, nghttp2_strerror((int)data_len));\n            return OGS_ERROR;\n        }\n\n        if (data_len == 0) {\n            break;\n        }\n\n        pkbuf = ogs_pkbuf_alloc(NULL, data_len);\n        ogs_assert(pkbuf);\n        ogs_pkbuf_put_data(pkbuf, data, data_len);\n\n        session_write_to_buffer(sbi_sess, pkbuf);\n    }\n#else\n    rv = nghttp2_session_send(sbi_sess->session);\n    if (rv != 0) {\n        ogs_error(\"nghttp_session_send() failed (%d:%s)\",\n                    rv, nghttp2_strerror(rv));\n        return OGS_ERROR;\n    }\n#endif\n\n    return OGS_OK;\n}\n\nstatic void session_write_callback(short when, ogs_socket_t fd, void *data)\n{\n    ogs_sbi_session_t *sbi_sess = data;\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    ogs_assert(sbi_sess);\n\n    if (ogs_list_empty(&sbi_sess->write_queue) == true) {\n        ogs_assert(sbi_sess->poll.write);\n        ogs_pollset_remove(sbi_sess->poll.write);\n        sbi_sess->poll.write = NULL;\n        return;\n    }\n\n    pkbuf = ogs_list_first(&sbi_sess->write_queue);\n    ogs_assert(pkbuf);\n    ogs_list_remove(&sbi_sess->write_queue, pkbuf);\n\n    ogs_send(fd, pkbuf->data, pkbuf->len, 0);\n    ogs_log_hexdump(OGS_LOG_DEBUG, pkbuf->data, pkbuf->len);\n\n    ogs_pkbuf_free(pkbuf);\n}\n\nstatic void session_write_to_buffer(\n        ogs_sbi_session_t *sbi_sess, ogs_pkbuf_t *pkbuf)\n{\n    ogs_sock_t *sock = NULL;\n    ogs_socket_t fd = INVALID_SOCKET;\n\n    ogs_assert(pkbuf);\n\n    ogs_assert(sbi_sess);\n    sock = sbi_sess->sock;\n    ogs_assert(sock);\n    fd = sock->fd;\n    ogs_assert(fd != INVALID_SOCKET);\n\n    ogs_list_add(&sbi_sess->write_queue, pkbuf);\n\n    if (!sbi_sess->poll.write) {\n        sbi_sess->poll.write = ogs_pollset_add(ogs_app()->pollset,\n            OGS_POLLOUT, fd, session_write_callback, sbi_sess);\n        ogs_assert(sbi_sess->poll.write);\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"ogs-sbi.h\"\n\n#include \"curl/curl.h\"\n\ntypedef struct sockinfo_s {\n    ogs_poll_t *poll;\n    curl_socket_t sockfd;\n    int action;\n    CURL *easy;\n    ogs_sbi_client_t *client;\n} sockinfo_t;\n\ntypedef struct connection_s {\n    ogs_lnode_t lnode;\n\n    void *data;\n\n    char *method;\n\n    int num_of_header;\n    char **headers;\n    struct curl_slist *header_list;\n\n    char *content;\n\n    char *memory;\n    size_t size;\n    bool memory_overflow;\n\n    char *location;\n\n    ogs_timer_t *timer;\n    CURL *easy;\n\n    char error[CURL_ERROR_SIZE];\n\n    ogs_sbi_client_t *client;\n    ogs_sbi_client_cb_f client_cb;\n} connection_t;\n\nstatic OGS_POOL(client_pool, ogs_sbi_client_t);\nstatic OGS_POOL(sockinfo_pool, sockinfo_t);\nstatic OGS_POOL(connection_pool, connection_t);\n\nstatic size_t write_cb(void *contents, size_t size, size_t nmemb, void *data);\nstatic size_t header_cb(void *ptr, size_t size, size_t nmemb, void *data);\nstatic int sock_cb(CURL *e, curl_socket_t s, int what, void *cbp, void *sockp);\nstatic int multi_timer_cb(CURLM *multi, long timeout_ms, void *cbp);\nstatic void multi_timer_expired(void *data);\nstatic void connection_timer_expired(void *data);\nstatic void connection_remove_all(ogs_sbi_client_t *client);\n\nvoid ogs_sbi_client_init(int num_of_sockinfo_pool, int num_of_connection_pool)\n{\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    ogs_list_init(&ogs_sbi_self()->client_list);\n    ogs_pool_init(&client_pool, ogs_app()->pool.nf);\n\n    ogs_pool_init(&sockinfo_pool, num_of_sockinfo_pool);\n    ogs_pool_init(&connection_pool, num_of_connection_pool);\n\n}\nvoid ogs_sbi_client_final(void)\n{\n    ogs_sbi_client_remove_all();\n\n    ogs_pool_final(&client_pool);\n    ogs_pool_final(&sockinfo_pool);\n    ogs_pool_final(&connection_pool);\n\n    curl_global_cleanup();\n}\n\nogs_sbi_client_t *ogs_sbi_client_add(ogs_sockaddr_t *addr)\n{\n    ogs_sbi_client_t *client = NULL;\n    CURLM *multi = NULL;\n\n    ogs_assert(addr);\n\n    ogs_pool_alloc(&client_pool, &client);\n    ogs_assert(client);\n    memset(client, 0, sizeof(ogs_sbi_client_t));\n\n    ogs_debug(\"ogs_sbi_client_add()\");\n    OGS_OBJECT_REF(client);\n\n    ogs_assert(OGS_OK == ogs_copyaddrinfo(&client->node.addr, addr));\n\n    client->t_curl = ogs_timer_add(\n            ogs_app()->timer_mgr, multi_timer_expired, client);\n    if (!client->t_curl) {\n        ogs_error(\"ogs_timer_add() failed\");\n        ogs_pool_free(&client_pool, client);\n        return NULL;\n    }\n\n    multi = client->multi = curl_multi_init();\n    ogs_assert(multi);\n    curl_multi_setopt(multi, CURLMOPT_SOCKETFUNCTION, sock_cb);\n    curl_multi_setopt(multi, CURLMOPT_SOCKETDATA, client);\n    curl_multi_setopt(multi, CURLMOPT_TIMERFUNCTION, multi_timer_cb);\n    curl_multi_setopt(multi, CURLMOPT_TIMERDATA, client);\n#ifdef CURLMOPT_MAX_CONCURRENT_STREAMS\n    curl_multi_setopt(multi, CURLMOPT_MAX_CONCURRENT_STREAMS,\n                        ogs_app()->pool.stream);\n#endif\n\n    ogs_list_init(&client->connection_list);\n\n    ogs_list_add(&ogs_sbi_self()->client_list, client);\n\n    return client;\n}\n\nvoid ogs_sbi_client_remove(ogs_sbi_client_t *client)\n{\n    ogs_sockaddr_t *addr = NULL;\n    char buf[OGS_ADDRSTRLEN];\n\n    ogs_assert(client);\n\n    addr = client->node.addr;\n    ogs_assert(addr);\n    ogs_debug(\"ogs_sbi_client_remove() [%s:%d]\",\n                OGS_ADDR(addr, buf), OGS_PORT(addr));\n\n    /* ogs_sbi_client_t is always created with reference context */\n    if (OGS_OBJECT_IS_REF(client)) {\n        OGS_OBJECT_UNREF(client);\n        return;\n    }\n\n    ogs_list_remove(&ogs_sbi_self()->client_list, client);\n\n    connection_remove_all(client);\n\n    ogs_assert(client->t_curl);\n    ogs_timer_delete(client->t_curl);\n    client->t_curl = NULL;\n\n    ogs_assert(client->multi);\n    curl_multi_cleanup(client->multi);\n\n    ogs_assert(client->node.addr);\n    ogs_freeaddrinfo(client->node.addr);\n\n    ogs_pool_free(&client_pool, client);\n}\n\nvoid ogs_sbi_client_remove_all(void)\n{\n    ogs_sbi_client_t *client = NULL, *next_client = NULL;\n\n    ogs_list_for_each_safe(&ogs_sbi_self()->client_list, next_client, client)\n        ogs_sbi_client_remove(client);\n}\n\nogs_sbi_client_t *ogs_sbi_client_find(ogs_sockaddr_t *addr)\n{\n    ogs_sbi_client_t *client = NULL;\n\n    ogs_assert(addr);\n\n    ogs_list_for_each(&ogs_sbi_self()->client_list, client) {\n        if (ogs_sockaddr_is_equal(client->node.addr, addr) == true)\n            break;\n    }\n\n    return client;\n}\n\nvoid ogs_sbi_client_stop(ogs_sbi_client_t *client)\n{\n    connection_t *conn = NULL;\n\n    ogs_assert(client);\n\n    ogs_list_for_each(&client->connection_list, conn) {\n        ogs_assert(conn->client_cb);\n        conn->client_cb(OGS_DONE, NULL, conn->data);\n    }\n}\n\nvoid ogs_sbi_client_stop_all(void)\n{\n    ogs_sbi_client_t *client = NULL;\n\n    ogs_list_for_each(&ogs_sbi_self()->client_list, client)\n        ogs_sbi_client_stop(client);\n}\n\n#define mycase(code) \\\n  case code: s = OGS_STRINGIFY(code)\n\nstatic void mcode_or_die(const char *where, CURLMcode code)\n{\n    if(CURLM_OK != code) {\n        const char *s;\n        switch(code) {\n            mycase(CURLM_BAD_HANDLE); break;\n            mycase(CURLM_BAD_EASY_HANDLE); break;\n            mycase(CURLM_OUT_OF_MEMORY); break;\n            mycase(CURLM_INTERNAL_ERROR); break;\n            mycase(CURLM_UNKNOWN_OPTION); break;\n            mycase(CURLM_LAST); break;\n            default: s = \"CURLM_unknown\"; break;\n            mycase(CURLM_BAD_SOCKET);\n            ogs_error(\"ERROR: %s returns %s\", where, s);\n            /* ignore this error */\n            return;\n        }\n        ogs_fatal(\"ERROR: %s returns %s\", where, s);\n        ogs_assert_if_reached();\n    }\n}\n\nstatic char *add_params_to_uri(CURL *easy, char *uri, ogs_hash_t *params)\n{\n    ogs_hash_index_t *hi;\n    int has_params = 0;\n    const char *fp = \"?\", *np = \"&\";\n\n    ogs_assert(easy);\n    ogs_assert(uri);\n    ogs_assert(params);\n    ogs_assert(ogs_hash_count(params));\n\n    has_params = (strchr(uri, '?') != NULL);\n\n    for (hi = ogs_hash_first(params); hi; hi = ogs_hash_next(hi)) {\n        const char *key = NULL;\n        char *key_esc = NULL;\n        char *val = NULL;\n        char *val_esc = NULL;\n\n        key = ogs_hash_this_key(hi);\n        ogs_assert(key);\n        val = ogs_hash_this_val(hi);\n        ogs_assert(val);\n\n        key_esc = curl_easy_escape(easy, key, 0);\n        ogs_assert(key_esc);\n        val_esc = curl_easy_escape(easy, val, 0);\n        ogs_assert(val_esc);\n\n        if (!has_params) {\n            uri = ogs_mstrcatf(uri, \"%s%s=%s\", fp, key_esc, val_esc);\n            ogs_expect(uri);\n            has_params = 1;\n        } else {\n            uri = ogs_mstrcatf(uri, \"%s%s=%s\", np, key_esc, val_esc);\n            ogs_expect(uri);\n        }\n\n        curl_free(val_esc);\n        curl_free(key_esc);\n    }\n\n    return uri;\n}\n\nstatic void _connection_remove(connection_t *conn);\n\nstatic connection_t *connection_add(\n        ogs_sbi_client_t *client, ogs_sbi_client_cb_f client_cb,\n        ogs_sbi_request_t *request, void *data)\n{\n    ogs_hash_index_t *hi;\n    int i;\n    connection_t *conn = NULL;\n    CURLMcode rc;\n\n    ogs_assert(client);\n    ogs_assert(client_cb);\n    ogs_assert(request);\n    ogs_assert(request->h.method);\n\n    ogs_pool_alloc(&connection_pool, &conn);\n    ogs_expect_or_return_val(conn, NULL);\n    memset(conn, 0, sizeof(connection_t));\n\n    conn->client = client;\n    conn->client_cb = client_cb;\n    conn->data = data;\n\n    conn->method = ogs_strdup(request->h.method);\n    if (!conn->method) {\n        ogs_error(\"conn->method is NULL\");\n        _connection_remove(conn);\n        return NULL;\n    }\n\n    conn->num_of_header = ogs_hash_count(request->http.headers);\n    if (conn->num_of_header) {\n        conn->headers = ogs_calloc(conn->num_of_header, sizeof(char *));\n        if (!conn->headers) {\n            ogs_error(\"conn->headers is NULL\");\n            _connection_remove(conn);\n            return NULL;\n        }\n        for (hi = ogs_hash_first(request->http.headers), i = 0;\n                hi && i < conn->num_of_header; hi = ogs_hash_next(hi), i++) {\n            const char *key = ogs_hash_this_key(hi);\n            char *val = ogs_hash_this_val(hi);\n\n            conn->headers[i] = ogs_msprintf(\"%s: %s\", key, val);\n            if (!conn->headers[i]) {\n                ogs_error(\"conn->headers[i=%d] is NULL\", i);\n                _connection_remove(conn);\n                return NULL;\n            }\n            conn->header_list = curl_slist_append(\n                    conn->header_list, conn->headers[i]);\n        }\n    }\n\n    conn->timer = ogs_timer_add(\n            ogs_app()->timer_mgr, connection_timer_expired, conn);\n    if (!conn->timer) {\n        ogs_error(\"conn->timer is NULL\");\n        _connection_remove(conn);\n        return NULL;\n    }\n\n    /* If http response is not received within deadline,\n     * Open5GS will discard this request. */\n    ogs_timer_start(conn->timer,\n            ogs_app()->time.message.sbi.connection_deadline);\n\n    conn->easy = curl_easy_init();\n    if (!conn->easy) {\n        ogs_error(\"conn->easy is NULL\");\n        _connection_remove(conn);\n        return NULL;\n    }\n\n    if (ogs_hash_count(request->http.params)) {\n        char *uri = add_params_to_uri(conn->easy,\n                            request->h.uri, request->http.params);\n        if (!uri) {\n            ogs_error(\"add_params_to_uri() failed\");\n            _connection_remove(conn);\n            return NULL;\n        }\n\n        request->h.uri = uri;\n    }\n\n    /* HTTP Method */\n    if (strcmp(request->h.method, OGS_SBI_HTTP_METHOD_PUT) == 0 ||\n        strcmp(request->h.method, OGS_SBI_HTTP_METHOD_PATCH) == 0 ||\n        strcmp(request->h.method, OGS_SBI_HTTP_METHOD_DELETE) == 0 ||\n        strcmp(request->h.method, OGS_SBI_HTTP_METHOD_POST) == 0) {\n\n        curl_easy_setopt(conn->easy,\n                CURLOPT_CUSTOMREQUEST, request->h.method);\n        if (request->http.content) {\n            conn->content = ogs_memdup(\n                    request->http.content, request->http.content_length);\n            if (!conn->content) {\n                ogs_error(\"conn->content is NULL\");\n                _connection_remove(conn);\n                return NULL;\n            }\n            curl_easy_setopt(conn->easy,\n                    CURLOPT_POSTFIELDS, conn->content);\n            curl_easy_setopt(conn->easy,\n                CURLOPT_POSTFIELDSIZE, request->http.content_length);\n#if 1 /* Disable HTTP/1.1 100 Continue : Use \"Expect:\" in libcurl */\n            conn->header_list = curl_slist_append(\n                    conn->header_list, \"Expect:\");\n#else\n            curl_easy_setopt(conn->easy, CURLOPT_EXPECT_100_TIMEOUT_MS, 0L);\n#endif\n            ogs_debug(\"SENDING...[%d]\", (int)request->http.content_length);\n            if (request->http.content_length)\n                ogs_debug(\"%s\", request->http.content);\n        }\n    }\n\n    curl_easy_setopt(conn->easy, CURLOPT_HTTPHEADER, conn->header_list);\n\n#if 1 /* Use HTTP2 */\n    curl_easy_setopt(conn->easy,\n            CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE);\n#endif\n\n    ogs_list_add(&client->connection_list, conn);\n\n    curl_easy_setopt(conn->easy, CURLOPT_URL, request->h.uri);\n\n    curl_easy_setopt(conn->easy, CURLOPT_PRIVATE, conn);\n    curl_easy_setopt(conn->easy, CURLOPT_WRITEFUNCTION, write_cb);\n    curl_easy_setopt(conn->easy, CURLOPT_WRITEDATA, conn);\n    curl_easy_setopt(conn->easy, CURLOPT_HEADERFUNCTION, header_cb);\n    curl_easy_setopt(conn->easy, CURLOPT_HEADERDATA, conn);\n    curl_easy_setopt(conn->easy, CURLOPT_ERRORBUFFER, conn->error);\n\n    ogs_assert(client->multi);\n    rc = curl_multi_add_handle(client->multi, conn->easy);\n    mcode_or_die(\"connection_add: curl_multi_add_handle\", rc);\n\n    return conn;\n}\n\nstatic void _connection_remove(connection_t *conn)\n{\n    int i;\n\n    ogs_assert(conn);\n\n    if (conn->content)\n        ogs_free(conn->content);\n\n    if (conn->location)\n        ogs_free(conn->location);\n\n    if (conn->memory)\n        ogs_free(conn->memory);\n\n    if (conn->easy)\n        curl_easy_cleanup(conn->easy);\n\n    if (conn->timer)\n        ogs_timer_delete(conn->timer);\n\n    if (conn->num_of_header) {\n        for (i = 0; i < conn->num_of_header; i++)\n            if (conn->headers[i])\n                ogs_free(conn->headers[i]);\n        ogs_free(conn->headers);\n    }\n    curl_slist_free_all(conn->header_list);\n\n    if (conn->method)\n        ogs_free(conn->method);\n\n    ogs_pool_free(&connection_pool, conn);\n}\n\nstatic void connection_remove(connection_t *conn)\n{\n    ogs_sbi_client_t *client = NULL;\n\n    ogs_assert(conn);\n    client = conn->client;\n    ogs_assert(client);\n\n    ogs_list_remove(&client->connection_list, conn);\n\n    ogs_assert(client->multi);\n    curl_multi_remove_handle(client->multi, conn->easy);\n\n    _connection_remove(conn);\n}\n\nstatic void connection_remove_all(ogs_sbi_client_t *client)\n{\n    connection_t *conn = NULL, *next_conn = NULL;\n\n    ogs_assert(client);\n\n    ogs_list_for_each_safe(&client->connection_list, next_conn, conn)\n        connection_remove(conn);\n}\n\nstatic void connection_timer_expired(void *data)\n{\n    connection_t *conn = NULL;\n\n    conn = data;\n    ogs_assert(conn);\n\n    ogs_error(\"Connection timer expired\");\n\n    ogs_assert(conn->client_cb);\n    conn->client_cb(OGS_TIMEUP, NULL, conn->data);\n\n    connection_remove(conn);\n}\n\nstatic void check_multi_info(ogs_sbi_client_t *client)\n{\n    CURLM *multi = NULL;\n    CURLMsg *resource;\n    int pending;\n    CURL *easy = NULL;\n    CURLcode res;\n    connection_t *conn = NULL;\n    ogs_sbi_response_t *response = NULL;\n\n    ogs_assert(client);\n    multi = client->multi;\n    ogs_assert(multi);\n\n    while ((resource = curl_multi_info_read(multi, &pending))) {\n        char *url;\n        char *content_type = NULL;\n        long res_status;\n        ogs_assert(resource);\n\n        switch (resource->msg) {\n        case CURLMSG_DONE:\n            easy = resource->easy_handle;\n            ogs_assert(easy);\n\n            curl_easy_getinfo(easy, CURLINFO_PRIVATE, &conn);\n            ogs_assert(conn);\n\n            curl_easy_getinfo(easy, CURLINFO_EFFECTIVE_URL, &url);\n            curl_easy_getinfo(easy, CURLINFO_RESPONSE_CODE, &res_status);\n            curl_easy_getinfo(easy, CURLINFO_CONTENT_TYPE, &content_type);\n\n            res = resource->data.result;\n            if (res == CURLE_OK) {\n                ogs_log_level_e level = OGS_LOG_DEBUG;\n\n                response = ogs_sbi_response_new();\n                ogs_assert(response);\n\n                response->status = res_status;\n\n                ogs_assert(conn->method);\n                response->h.method = ogs_strdup(conn->method);\n                ogs_assert(response->h.method);\n\n                /* remove https://localhost:8000 */\n                response->h.uri = ogs_strdup(url);\n                ogs_assert(response->h.uri);\n\n                if (content_type)\n                    ogs_sbi_header_set(response->http.headers,\n                            OGS_SBI_CONTENT_TYPE, content_type);\n                if (conn->location)\n                    ogs_sbi_header_set(response->http.headers,\n                            OGS_SBI_LOCATION, conn->location);\n\n                if (conn->memory_overflow == true)\n                    level = OGS_LOG_ERROR;\n\n                ogs_log_message(level, 0, \"[%d:%s] %s\",\n                        response->status, response->h.method, response->h.uri);\n\n                if (conn->memory) {\n                    response->http.content =\n                        ogs_memdup(conn->memory, conn->size + 1);\n                    ogs_assert(response->http.content);\n                    response->http.content_length = conn->size;\n                    ogs_assert(response->http.content_length);\n                }\n\n                ogs_log_message(level, 0, \"RECEIVED[%d]\",\n                        (int)response->http.content_length);\n                if (response->http.content_length && response->http.content)\n                    ogs_log_message(level, 0, \"%s\", response->http.content);\n\n                if (conn->memory_overflow == true) {\n                    ogs_sbi_response_free(response);\n                    connection_remove(conn);\n                    break;\n                }\n\n            } else\n                ogs_warn(\"[%d] %s\", res, conn->error);\n\n            ogs_assert(conn->client_cb);\n            conn->client_cb(res == CURLE_OK ? OGS_OK : OGS_ERROR,\n                            response, conn->data);\n            connection_remove(conn);\n            break;\n        default:\n            ogs_error(\"Unknown CURL resource[%d]\", resource->msg);\n            break;\n        }\n    }\n}\n\nbool ogs_sbi_client_send_reqmem_persistent(\n        ogs_sbi_client_t *client, ogs_sbi_client_cb_f client_cb,\n        ogs_sbi_request_t *request, void *data)\n{\n    connection_t *conn = NULL;\n\n    ogs_assert(client);\n    ogs_assert(request);\n\n    if (request->h.uri == NULL) {\n        request->h.uri = ogs_sbi_client_uri(client, &request->h);\n        ogs_expect_or_return_val(request->h.uri, false);\n    }\n    ogs_debug(\"[%s] %s\", request->h.method, request->h.uri);\n\n    conn = connection_add(client, client_cb, request, data);\n    ogs_expect_or_return_val(conn, false);\n\n    return true;\n}\n\nbool ogs_sbi_client_send_request(\n        ogs_sbi_client_t *client, ogs_sbi_client_cb_f client_cb,\n        ogs_sbi_request_t *request, void *data)\n{\n    bool rc;\n\n    ogs_assert(client);\n    ogs_assert(request);\n\n    rc = ogs_sbi_client_send_reqmem_persistent(\n            client, client_cb, request, data);\n    ogs_expect(rc == true);\n\n    ogs_sbi_request_free(request);\n\n    return rc;\n}\n\nbool ogs_sbi_scp_send_reqmem_persistent(\n        ogs_sbi_client_t *client, ogs_sbi_client_cb_f client_cb,\n        ogs_sbi_request_t *request, void *data)\n{\n    ogs_sbi_nf_instance_t *scp_instance = NULL;\n    connection_t *conn = NULL;\n    char *apiroot = NULL;\n\n    ogs_assert(client);\n    ogs_assert(request);\n\n    scp_instance = ogs_sbi_self()->scp_instance;\n\n    if (scp_instance) {\n        /*\n         * In case of indirect communication using SCP,\n         * add 3gpp-Sbi-Target-apiRoot to HTTP header and\n         * change CLIENT instance to SCP.\n         */\n        apiroot = ogs_sbi_client_apiroot(client);\n        ogs_assert(apiroot);\n\n        ogs_sbi_header_set(request->http.headers,\n                OGS_SBI_CUSTOM_TARGET_APIROOT, apiroot);\n\n        ogs_free(apiroot);\n\n        client = scp_instance->client;\n        ogs_assert(client);\n    }\n\n    if (request->h.uri == NULL) {\n        /*\n         * Regardless of direct or indirect communication,\n         * if there is no URI, we automatically creates a URI\n         * with Client Address and request->h\n         */\n        request->h.uri = ogs_sbi_client_uri(client, &request->h);\n        ogs_assert(request->h.uri);\n\n        ogs_debug(\"[%s] %s\", request->h.method, request->h.uri);\n\n    } else if (scp_instance) {\n        /*\n         * In case of indirect communication using SCP,\n         * If the full URI is already defined, change full URI to SCP as below.\n         *\n         * OLD: http://127.0.0.5:7777/nnrf-nfm/v1/nf-status-notify\n         * NEW: https://scp.open5gs.org/nnrf-nfm/v1/nf-status-notify\n         */\n        char *path = NULL;\n        char *old = NULL;\n\n        old = request->h.uri;\n\n        apiroot = ogs_sbi_client_apiroot(client);\n        ogs_assert(apiroot);\n\n        path = ogs_sbi_getpath_from_uri(request->h.uri);\n        ogs_assert(path);\n\n        request->h.uri = ogs_msprintf(\"%s/%s\", apiroot, path);\n        ogs_assert(request->h.uri);\n\n        ogs_free(apiroot);\n        ogs_free(path);\n        ogs_free(old);\n\n        ogs_debug(\"[%s] %s\", request->h.method, request->h.uri);\n    }\n\n    conn = connection_add(client, client_cb, request, data);\n    ogs_expect_or_return_val(conn, false);\n\n    return true;\n}\n\nbool ogs_sbi_scp_send_request(\n        ogs_sbi_client_t *client, ogs_sbi_client_cb_f client_cb,\n        ogs_sbi_request_t *request, void *data)\n{\n    bool rc;\n\n    ogs_assert(client);\n    ogs_assert(request);\n\n    rc = ogs_sbi_scp_send_reqmem_persistent(client, client_cb, request, data);\n    ogs_expect(rc == true);\n\n    ogs_sbi_request_free(request);\n\n    return rc;\n}\n\nstatic size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)\n{\n    size_t realsize = 0;\n    connection_t *conn = NULL;\n    char *ptr = NULL;\n\n    conn = data;\n    ogs_assert(conn);\n\n    realsize = size * nmemb;\n    ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);\n    if(!ptr) {\n        conn->memory_overflow = true;\n\n        ogs_error(\"Overflow : conn->size[%d], realsize[%d]\",\n                    (int)conn->size, (int)realsize);\n        ogs_log_hexdump(OGS_LOG_ERROR, contents, realsize);\n\n        return 0;\n    }\n\n    conn->memory = ptr;\n    memcpy(&(conn->memory[conn->size]), contents, realsize);\n    conn->size += realsize;\n    conn->memory[conn->size] = 0;\n\n    return realsize;\n}\n\nstatic size_t header_cb(void *ptr, size_t size, size_t nmemb, void *data)\n{\n    connection_t *conn = NULL;\n\n    conn = data;\n    ogs_assert(conn);\n\n    if (ogs_strncasecmp(ptr, OGS_SBI_LOCATION, strlen(OGS_SBI_LOCATION)) == 0) {\n        /* ptr : \"Location: http://xxx/xxx/xxx\\r\\n\"\n           We need to truncate \"Location\" + \": \" + \"\\r\\n\" in 'ptr' string */\n        int len = strlen(ptr) - strlen(OGS_SBI_LOCATION) - 2 - 2;\n        if (len) {\n            /* Only copy http://xxx/xxx/xxx\" from 'ptr' string */\n            conn->location = ogs_memdup(\n                    (char *)ptr + strlen(OGS_SBI_LOCATION) + 2, len+1);\n            ogs_assert(conn->location);\n            conn->location[len] = 0;\n        }\n    }\n\n    return (nmemb*size);\n}\n\nstatic void event_cb(short when, ogs_socket_t fd, void *data)\n{\n    sockinfo_t *sockinfo = NULL;\n    ogs_sbi_client_t *client = NULL;\n    CURLM *multi = NULL;\n\n    CURLMcode rc;\n    int action = ((when & OGS_POLLIN) ? CURL_CSELECT_IN : 0) |\n                    ((when & OGS_POLLOUT) ? CURL_CSELECT_OUT : 0);\n\n    sockinfo = data;\n    ogs_assert(sockinfo);\n    client = sockinfo->client;\n    ogs_assert(client);\n    multi = client->multi;\n    ogs_assert(multi);\n\n    rc = curl_multi_socket_action(multi, fd, action, &client->still_running);\n    mcode_or_die(\"event_cb: curl_multi_socket_action\", rc);\n\n    check_multi_info(client);\n    if (client->still_running <= 0) {\n        ogs_timer_t *timer;\n\n        timer = client->t_curl;\n        if (timer)\n            ogs_timer_stop(timer);\n    }\n}\n\n/* Assign information to a sockinfo_t structure */\nstatic void sock_set(sockinfo_t *sockinfo, curl_socket_t s,\n        CURL *e, int act, ogs_sbi_client_t *client)\n{\n    int kind = ((act & CURL_POLL_IN) ? OGS_POLLIN : 0) |\n                ((act & CURL_POLL_OUT) ? OGS_POLLOUT : 0);\n\n    if (sockinfo->sockfd)\n        ogs_pollset_remove(sockinfo->poll);\n\n    sockinfo->sockfd = s;\n    sockinfo->action = act;\n    sockinfo->easy = e;\n\n    sockinfo->poll = ogs_pollset_add(\n            ogs_app()->pollset, kind, s, event_cb, sockinfo);\n    ogs_assert(sockinfo->poll);\n}\n\n/* Initialize a new sockinfo_t structure */\nstatic void sock_new(curl_socket_t s,\n        CURL *easy, int action, ogs_sbi_client_t *client)\n{\n    sockinfo_t *sockinfo = NULL;\n    CURLM *multi = NULL;\n\n    ogs_assert(client);\n    multi = client->multi;\n    ogs_assert(multi);\n\n    ogs_pool_alloc(&sockinfo_pool, &sockinfo);\n    ogs_assert(sockinfo);\n    memset(sockinfo, 0, sizeof(sockinfo_t));\n\n    sockinfo->client = client;\n    sock_set(sockinfo, s, easy, action, client);\n    curl_multi_assign(multi, s, sockinfo);\n}\n\n/* Clean up the sockinfo_t structure */\nstatic void sock_free(sockinfo_t *sockinfo, ogs_sbi_client_t *client)\n{\n    ogs_assert(sockinfo);\n    ogs_assert(sockinfo->poll);\n\n    ogs_pollset_remove(sockinfo->poll);\n    ogs_pool_free(&sockinfo_pool, sockinfo);\n}\n\n/* CURLMOPT_SOCKETFUNCTION */\nstatic int sock_cb(CURL *e, curl_socket_t s, int what, void *cbp, void *sockp)\n{\n    ogs_sbi_client_t *client = (ogs_sbi_client_t *)cbp;\n    sockinfo_t *sockinfo = (sockinfo_t *) sockp;\n\n    if (what == CURL_POLL_REMOVE) {\n        sock_free(sockinfo, client);\n    } else {\n        if (!sockinfo) {\n            sock_new(s, e, what, client);\n        } else {\n            sock_set(sockinfo, s, e, what, client);\n        }\n    }\n    return 0;\n}\n\nstatic void multi_timer_expired(void *data)\n{\n    CURLMcode rc;\n    ogs_sbi_client_t *client = NULL;\n    CURLM *multi = NULL;\n\n    client = data;\n    ogs_assert(client);\n    multi = client->multi;\n    ogs_assert(multi);\n\n    rc = curl_multi_socket_action(\n            multi, CURL_SOCKET_TIMEOUT, 0, &client->still_running);\n    mcode_or_die(\"multi_timer_expired: curl_multi_socket_action\", rc);\n    check_multi_info(client);\n}\n\nstatic int multi_timer_cb(CURLM *multi, long timeout_ms, void *cbp)\n{\n    ogs_sbi_client_t *client = NULL;\n    ogs_timer_t *timer = NULL;\n\n    client = cbp;\n    ogs_assert(client);\n    timer = client->t_curl;\n    ogs_assert(timer);\n\n    if (timeout_ms > 0) {\n        ogs_timer_start(timer, ogs_time_from_msec(timeout_ms));\n    } else if (timeout_ms == 0) {\n        /* libcurl wants us to timeout now.\n         * The closest we can do is to schedule the timer to fire in 1 us. */\n        ogs_timer_start(timer, 1);\n    } else {\n        ogs_timer_stop(timer);\n    }\n\n    return 0;\n}\n", "/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"ogs-sbi.h\"\n#include \"yuarel.h\"\n\n#include <netinet/tcp.h>\n#include <nghttp2/nghttp2.h>\n\n#define USE_SEND_DATA_WITH_NO_COPY 1\n\nstatic void server_init(int num_of_session_pool, int num_of_stream_pool);\nstatic void server_final(void);\n\nstatic int server_start(ogs_sbi_server_t *server,\n        int (*cb)(ogs_sbi_request_t *request, void *data));\nstatic void server_stop(ogs_sbi_server_t *server);\n\nstatic bool server_send_rspmem_persistent(\n        ogs_sbi_stream_t *stream, ogs_sbi_response_t *response);\nstatic bool server_send_response(\n        ogs_sbi_stream_t *stream, ogs_sbi_response_t *response);\n\nstatic ogs_sbi_server_t *server_from_stream(ogs_sbi_stream_t *stream);\n\nconst ogs_sbi_server_actions_t ogs_nghttp2_server_actions = {\n    server_init,\n    server_final,\n\n    server_start,\n    server_stop,\n\n    server_send_rspmem_persistent,\n    server_send_response,\n\n    server_from_stream,\n};\n\nstruct h2_settings {\n    uint32_t max_concurrent_streams;\n    bool enable_push;\n};\n\ntypedef struct ogs_sbi_session_s {\n    ogs_lnode_t             lnode;\n\n    ogs_sock_t              *sock;\n    ogs_sockaddr_t          *addr;\n    struct {\n        ogs_poll_t          *read;\n        ogs_poll_t          *write;\n    } poll;\n\n    nghttp2_session         *session;\n    ogs_list_t              write_queue;\n\n    ogs_sbi_server_t        *server;\n    ogs_list_t              stream_list;\n    int32_t                 last_stream_id;\n\n    struct h2_settings      settings;\n} ogs_sbi_session_t;\n\ntypedef struct ogs_sbi_stream_s {\n    ogs_lnode_t             lnode;\n\n    int32_t                 stream_id;\n    ogs_sbi_request_t       *request;\n    bool                    memory_overflow;\n\n    ogs_sbi_session_t       *session;\n} ogs_sbi_stream_t;\n\nstatic void session_remove(ogs_sbi_session_t *sbi_sess);\nstatic void session_remove_all(ogs_sbi_server_t *server);\n\nstatic void stream_remove(ogs_sbi_stream_t *stream);\n\nstatic void accept_handler(short when, ogs_socket_t fd, void *data);\nstatic void recv_handler(short when, ogs_socket_t fd, void *data);\n\nstatic int session_set_callbacks(ogs_sbi_session_t *sbi_sess);\nstatic int session_send_preface(ogs_sbi_session_t *sbi_sess);\nstatic int session_send(ogs_sbi_session_t *sbi_sess);\nstatic void session_write_to_buffer(\n        ogs_sbi_session_t *sbi_sess, ogs_pkbuf_t *pkbuf);\n\nstatic OGS_POOL(session_pool, ogs_sbi_session_t);\nstatic OGS_POOL(stream_pool, ogs_sbi_stream_t);\n\nstatic void server_init(int num_of_session_pool, int num_of_stream_pool)\n{\n    ogs_pool_init(&session_pool, num_of_session_pool);\n    ogs_pool_init(&stream_pool, num_of_stream_pool);\n}\n\nstatic void server_final(void)\n{\n    ogs_pool_final(&stream_pool);\n    ogs_pool_final(&session_pool);\n}\n\nstatic int server_start(ogs_sbi_server_t *server,\n        int (*cb)(ogs_sbi_request_t *request, void *data))\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sock_t *sock = NULL;\n    ogs_sockaddr_t *addr = NULL;\n    char *hostname = NULL;\n\n    addr = server->node.addr;\n    ogs_assert(addr);\n\n    sock = ogs_tcp_server(addr, server->node.option);\n    if (!sock) {\n        ogs_error(\"Cannot start SBI server\");\n        return OGS_ERROR;\n    }\n\n    server->node.sock = sock;\n\n    /* Setup callback function */\n    server->cb = cb;\n\n    /* Setup poll for server listening socket */\n    server->node.poll = ogs_pollset_add(ogs_app()->pollset,\n            OGS_POLLIN, sock->fd, accept_handler, server);\n    ogs_assert(server->node.poll);\n\n    hostname = ogs_gethostname(addr);\n    if (hostname)\n        ogs_info(\"nghttp2_server() [%s]:%d\", hostname, OGS_PORT(addr));\n    else\n        ogs_info(\"nghttp2_server() [%s]:%d\",\n                OGS_ADDR(addr, buf), OGS_PORT(addr));\n\n    return OGS_OK;\n}\n\nstatic void server_stop(ogs_sbi_server_t *server)\n{\n    ogs_assert(server);\n\n    if (server->node.poll)\n        ogs_pollset_remove(server->node.poll);\n\n    if (server->node.sock)\n        ogs_sock_destroy(server->node.sock);\n\n    session_remove_all(server);\n}\n\nstatic void add_header(nghttp2_nv *nv, const char *key, const char *value)\n{\n    nv->name = (uint8_t *)key;\n    nv->namelen = strlen(key);\n    nv->value = (uint8_t *)value;\n    nv->valuelen = strlen(value);\n    nv->flags = NGHTTP2_NV_FLAG_NONE;\n}\n\nstatic char status_string[600][4] = {\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"100\", \"101\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"200\", \"201\", \"202\", \"203\", \"204\", \"205\", \"206\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"300\", \"301\", \"302\", \"303\", \"304\", \"305\", \"306\", \"307\", \"308\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"400\", \"401\", \"402\", \"403\", \"404\", \"405\", \"406\", \"407\", \"408\", \"409\",\n \"410\", \"411\", \"412\", \"413\", \"414\", \"415\", \"416\", \"417\", \"\", \"\",\n \"\", \"421\", \"\", \"\", \"\", \"\", \"426\", \"\", \"428\", \"429\", \"\", \"431\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"451\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"500\", \"501\", \"502\", \"503\", \"504\", \"505\", \"\", \"\", \"\", \"\", \"\", \"511\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\n};\n\n#define DATE_STRLEN 128\nstatic char *get_date_string(char *date)\n{\n    static const char *const days[] = {\n        \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n    };\n    static const char *const mons[] = {\n        \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n        \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n    };\n\n    ogs_assert(date);\n\n    struct tm tm;\n    ogs_gmtime(ogs_time_sec(ogs_time_now()), &tm);\n\n    ogs_snprintf(date, DATE_STRLEN, \"%3s, %02u %3s %04u %02u:%02u:%02u GMT\",\n            days[tm.tm_wday % 7],\n            (unsigned int)tm.tm_mday,\n            mons[tm.tm_mon % 12],\n            (unsigned int)(1900 + tm.tm_year),\n            (unsigned int)tm.tm_hour,\n            (unsigned int)tm.tm_min,\n            (unsigned int)tm.tm_sec);\n\n    return date;\n}\n\nstatic ssize_t response_read_callback(nghttp2_session *session,\n                                      int32_t stream_id,\n                                      uint8_t *buf, size_t length,\n                                      uint32_t *data_flags,\n                                      nghttp2_data_source *source,\n                                      void *user_data)\n{\n#if USE_SEND_DATA_WITH_NO_COPY\n    int rv;\n#endif\n\n    ogs_sbi_response_t *response = NULL;\n    ogs_sbi_stream_t *stream = NULL;\n\n    ogs_assert(session);\n\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n\n    ogs_assert(source);\n    response = source->ptr;\n    ogs_assert(response);\n\n    ogs_assert(response->http.content);\n    ogs_assert(response->http.content_length);\n\n#if USE_SEND_DATA_WITH_NO_COPY\n    *data_flags |= NGHTTP2_DATA_FLAG_NO_COPY;\n#else\n    memcpy(buf, response->http.content, response->http.content_length);\n#endif\n\n    *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n\n#if USE_SEND_DATA_WITH_NO_COPY\n    rv = nghttp2_session_get_stream_remote_close(session, stream_id);\n    if (rv == 0) {\n        ogs_warn(\"nghttp2_session_get_stream_remote_close() failed\");\n        nghttp2_submit_rst_stream(\n                session, NGHTTP2_FLAG_NONE, stream_id, NGHTTP2_NO_ERROR);\n    } else if (rv != 1) {\n        ogs_error(\"nghttp2_session_get_stream_remote_close() failed[%d]\", rv);\n    }\n#endif\n\n    return response->http.content_length;\n}\n\nstatic bool server_send_rspmem_persistent(\n        ogs_sbi_stream_t *stream, ogs_sbi_response_t *response)\n{\n    ogs_sbi_session_t *sbi_sess = NULL;\n    ogs_sock_t *sock = NULL;\n    ogs_socket_t fd = INVALID_SOCKET;\n\n    ogs_hash_index_t *hi;\n    nghttp2_nv *nva;\n    size_t nvlen;\n    int i, rv;\n    char datebuf[DATE_STRLEN];\n    char srv_version[128];\n    char clen[128];\n\n    ogs_assert(response);\n\n    stream = ogs_pool_cycle(&stream_pool, stream);\n    if (!stream) {\n        ogs_error(\"stream has already been removed\");\n        return true;\n    }\n\n    sbi_sess = stream->session;\n    ogs_assert(sbi_sess);\n    ogs_assert(sbi_sess->session);\n\n    sock = sbi_sess->sock;\n    ogs_assert(sock);\n    fd = sock->fd;\n    ogs_assert(fd != INVALID_SOCKET); /* Check if session is removed */\n\n    nvlen = 3; /* :status && server && date */\n\n    for (hi = ogs_hash_first(response->http.headers);\n            hi; hi = ogs_hash_next(hi))\n        nvlen++;\n\n    if (response->http.content && response->http.content_length)\n        nvlen++;\n\n    nva = ogs_calloc(nvlen, sizeof(nghttp2_nv));\n    ogs_expect_or_return_val(nva, false);\n\n    i = 0;\n\n    ogs_expect_or_return_val(response->status < 600, false);\n    ogs_assert(strlen(status_string[response->status]) == 3);\n    add_header(&nva[i++], \":status\", status_string[response->status]);\n\n    ogs_snprintf(srv_version, sizeof(srv_version),\n            \"Open5GS %s\", ogs_app()->version ? ogs_app()->version : \"TEST\");\n    add_header(&nva[i++], \"server\", srv_version);\n    add_header(&nva[i++], \"date\", get_date_string(datebuf));\n\n    if (response->http.content && response->http.content_length) {\n        ogs_snprintf(clen, sizeof(clen),\n                \"%d\", (int)response->http.content_length);\n        add_header(&nva[i++], \"content-length\", clen);\n    }\n\n    for (hi = ogs_hash_first(response->http.headers);\n            hi; hi = ogs_hash_next(hi)) {\n        add_header(&nva[i++], ogs_hash_this_key(hi), ogs_hash_this_val(hi));\n    }\n\n    ogs_debug(\"STATUS [%d]\", response->status);\n\n    if (response->http.content && response->http.content_length) {\n        nghttp2_data_provider data_prd;\n\n        data_prd.source.ptr = response;\n        data_prd.read_callback = response_read_callback;\n\n        ogs_debug(\"SENDING...: %d\", (int)response->http.content_length);\n        ogs_debug(\"%s\", response->http.content);\n\n        rv = nghttp2_submit_response(sbi_sess->session,\n                stream->stream_id, nva, nvlen, &data_prd);\n    } else {\n        rv = nghttp2_submit_response(sbi_sess->session,\n                stream->stream_id, nva, nvlen, NULL);\n    }\n\n    if (rv != OGS_OK) {\n        ogs_error(\"nghttp2_submit_response(%d) failed (%d:%s)\",\n                    (int)response->http.content_length,\n                    rv, nghttp2_strerror(rv));\n        nghttp2_submit_rst_stream(\n                sbi_sess->session, NGHTTP2_FLAG_NONE, stream->stream_id, rv);\n    }\n\n    if (session_send(sbi_sess) != OGS_OK) {\n        ogs_error(\"session_send() failed\");\n        session_remove(sbi_sess);\n    }\n\n    ogs_free(nva);\n\n    return true;\n}\n\nstatic bool server_send_response(\n        ogs_sbi_stream_t *stream, ogs_sbi_response_t *response)\n{\n    bool rc;\n\n    ogs_assert(response);\n\n    rc = server_send_rspmem_persistent(stream, response);\n\n    ogs_sbi_response_free(response);\n\n    return rc;\n}\n\nstatic ogs_sbi_server_t *server_from_stream(ogs_sbi_stream_t *stream)\n{\n    ogs_sbi_session_t *sbi_sess = NULL;\n\n    ogs_assert(stream);\n    sbi_sess = stream->session;\n    ogs_assert(sbi_sess);\n    ogs_assert(sbi_sess->server);\n\n    return sbi_sess->server;\n}\n\nstatic ogs_sbi_stream_t *stream_add(\n        ogs_sbi_session_t *sbi_sess, int32_t stream_id)\n{\n    ogs_sbi_stream_t *stream = NULL;\n\n    ogs_assert(sbi_sess);\n\n    ogs_pool_alloc(&stream_pool, &stream);\n    ogs_expect_or_return_val(stream, NULL);\n    memset(stream, 0, sizeof(ogs_sbi_stream_t));\n\n    stream->request = ogs_sbi_request_new();\n    ogs_expect_or_return_val(stream->request, NULL);\n\n    stream->stream_id = stream_id;\n    sbi_sess->last_stream_id = stream_id;\n\n    stream->session = sbi_sess;\n\n    ogs_list_add(&sbi_sess->stream_list, stream);\n\n    return stream;\n}\n\nstatic void stream_remove(ogs_sbi_stream_t *stream)\n{\n    ogs_sbi_session_t *sbi_sess = NULL;\n\n    ogs_assert(stream);\n    sbi_sess = stream->session;\n    ogs_assert(sbi_sess);\n\n    ogs_list_remove(&sbi_sess->stream_list, stream);\n\n    ogs_assert(stream->request);\n    ogs_sbi_request_free(stream->request);\n\n    ogs_pool_free(&stream_pool, stream);\n}\n\nstatic void stream_remove_all(ogs_sbi_session_t *sbi_sess)\n{\n    ogs_sbi_stream_t *stream = NULL, *next_stream = NULL;\n\n    ogs_assert(sbi_sess);\n\n    ogs_list_for_each_safe(&sbi_sess->stream_list, next_stream, stream)\n        stream_remove(stream);\n}\n\nstatic ogs_sbi_session_t *session_add(\n        ogs_sbi_server_t *server, ogs_sock_t *sock)\n{\n    ogs_sbi_session_t *sbi_sess = NULL;\n\n    ogs_assert(server);\n    ogs_assert(sock);\n\n    ogs_pool_alloc(&session_pool, &sbi_sess);\n    ogs_expect_or_return_val(sbi_sess, NULL);\n    memset(sbi_sess, 0, sizeof(ogs_sbi_session_t));\n\n    sbi_sess->server = server;\n    sbi_sess->sock = sock;\n\n    sbi_sess->addr = ogs_calloc(1, sizeof(ogs_sockaddr_t));\n    ogs_expect_or_return_val(sbi_sess->addr, NULL);\n    memcpy(sbi_sess->addr, &sock->remote_addr, sizeof(ogs_sockaddr_t));\n\n    ogs_list_add(&server->session_list, sbi_sess);\n\n    return sbi_sess;\n}\n\nstatic void session_remove(ogs_sbi_session_t *sbi_sess)\n{\n    ogs_sbi_server_t *server = NULL;\n    ogs_pkbuf_t *pkbuf = NULL, *next_pkbuf = NULL;\n\n    ogs_assert(sbi_sess);\n    server = sbi_sess->server;\n    ogs_assert(server);\n\n    ogs_list_remove(&server->session_list, sbi_sess);\n\n    stream_remove_all(sbi_sess);\n    nghttp2_session_del(sbi_sess->session);\n\n    ogs_assert(sbi_sess->poll.read);\n    ogs_pollset_remove(sbi_sess->poll.read);\n\n    if (sbi_sess->poll.write)\n        ogs_pollset_remove(sbi_sess->poll.write);\n\n    ogs_list_for_each_safe(&sbi_sess->write_queue, next_pkbuf, pkbuf) {\n        ogs_list_remove(&sbi_sess->write_queue, pkbuf);\n        ogs_pkbuf_free(pkbuf);\n    }\n\n    ogs_assert(sbi_sess->addr);\n    ogs_free(sbi_sess->addr);\n\n    ogs_assert(sbi_sess->sock);\n    ogs_sock_destroy(sbi_sess->sock);\n\n    ogs_pool_free(&session_pool, sbi_sess);\n}\n\nstatic void session_remove_all(ogs_sbi_server_t *server)\n{\n    ogs_sbi_session_t *sbi_sess = NULL, *next_sbi_sess = NULL;\n\n    ogs_assert(server);\n\n    ogs_list_for_each_safe(&server->session_list, next_sbi_sess, sbi_sess)\n        session_remove(sbi_sess);\n}\n\nstatic void accept_handler(short when, ogs_socket_t fd, void *data)\n{\n    ogs_sbi_server_t *server = data;\n    ogs_sbi_session_t *sbi_sess = NULL;\n    ogs_sock_t *sock = NULL;\n    ogs_sock_t *new = NULL;\n\n    int on;\n\n    ogs_assert(data);\n    ogs_assert(fd != INVALID_SOCKET);\n\n    sock = server->node.sock;\n\n    new = ogs_sock_accept(sock);\n    if (!new) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, \"accept() failed\");\n        return;\n    }\n    ogs_assert(new->fd != INVALID_SOCKET);\n\n    on = 1;\n    if (setsockopt(new->fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) != 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"setsockopt() for SCTP_NODELAY failed\");\n        ogs_sock_destroy(new);\n        return;\n    }\n\n    sbi_sess = session_add(server, new);\n    ogs_assert(sbi_sess);\n\n    sbi_sess->poll.read = ogs_pollset_add(ogs_app()->pollset,\n        OGS_POLLIN, new->fd, recv_handler, sbi_sess);\n    ogs_assert(sbi_sess->poll.read);\n\n    if (session_set_callbacks(sbi_sess) != OGS_OK ||\n        session_send_preface(sbi_sess) != OGS_OK) {\n        ogs_error(\"session_add() failed\");\n        session_remove(sbi_sess);\n    }\n}\n\nstatic void recv_handler(short when, ogs_socket_t fd, void *data)\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sockaddr_t *addr = NULL;\n\n    ogs_sbi_session_t *sbi_sess = data;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ssize_t readlen;\n    int n;\n\n    ogs_assert(sbi_sess);\n    ogs_assert(fd != INVALID_SOCKET);\n    addr = sbi_sess->addr;\n    ogs_assert(addr);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n\n    n = ogs_recv(fd, pkbuf->data, OGS_MAX_SDU_LEN, 0);\n    if (n > 0) {\n        ogs_pkbuf_put(pkbuf, n);\n\n        ogs_assert(sbi_sess->session);\n        readlen = nghttp2_session_mem_recv(\n                sbi_sess->session, pkbuf->data, pkbuf->len);\n        if (readlen < 0) {\n            ogs_error(\"nghttp2_session_mem_recv() failed (%d:%s)\",\n                        (int)readlen, nghttp2_strerror((int)readlen));\n            session_remove(sbi_sess);\n        }\n    } else {\n        if (n < 0) {\n            if (errno != OGS_ECONNRESET)\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                                \"lost connection [%s]:%d\",\n                                OGS_ADDR(addr, buf), OGS_PORT(addr));\n        } else if (n == 0) {\n            ogs_debug(\"connection closed [%s]:%d\",\n                        OGS_ADDR(addr, buf), OGS_PORT(addr));\n        }\n\n        session_remove(sbi_sess);\n    }\n\n    ogs_pkbuf_free(pkbuf);\n}\n\nstatic int on_frame_recv(nghttp2_session *session,\n                         const nghttp2_frame *frame, void *user_data);\nstatic int on_stream_close(nghttp2_session *session, int32_t stream_id,\n                           uint32_t error_code, void *user_data);\nstatic int on_header(nghttp2_session *session,\n                     const nghttp2_frame *frame,\n                     nghttp2_rcbuf *name, nghttp2_rcbuf *value,\n                     uint8_t flags, void *user_data);\nstatic int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,\n                              int32_t stream_id, const uint8_t *data,\n                              size_t len, void *user_data);\nstatic int error_callback(nghttp2_session *session,\n                          const char *msg, size_t len, void *user_data);\nstatic int on_invalid_frame_recv(nghttp2_session *session,\n                                 const nghttp2_frame *frame,\n                                 int error_code, void *user_data);\nstatic int on_invalid_header(nghttp2_session *session,\n                             const nghttp2_frame *frame,\n                             const uint8_t *name, size_t namelen,\n                             const uint8_t *value, size_t valuelen,\n                             uint8_t flags, void *user_data);\nstatic int on_begin_frame(nghttp2_session *session,\n                          const nghttp2_frame_hd *hd, void *user_data);\nstatic int on_begin_headers(nghttp2_session *session,\n                            const nghttp2_frame *frame,\n                                     void *user_data);\n#if USE_SEND_DATA_WITH_NO_COPY\nstatic int on_send_data(nghttp2_session *session, nghttp2_frame *frame,\n                        const uint8_t *framehd, size_t length,\n                        nghttp2_data_source *source, void *user_data);\n#else\nstatic ssize_t send_callback(nghttp2_session *session, const uint8_t *data,\n                             size_t length, int flags, void *user_data);\n#endif\n\nstatic int session_set_callbacks(ogs_sbi_session_t *sbi_sess)\n{\n    int rv;\n    nghttp2_session_callbacks *callbacks = NULL;\n\n    ogs_assert(sbi_sess);\n\n    rv = nghttp2_session_callbacks_new(&callbacks);\n    if (rv != 0) {\n        ogs_error(\"nghttp2_session_callbacks_new() failed (%d:%s)\",\n                    rv, nghttp2_strerror(rv));\n        return OGS_ERROR;\n    }\n\n    nghttp2_session_callbacks_set_on_frame_recv_callback(\n            callbacks, on_frame_recv);\n\n    nghttp2_session_callbacks_set_on_stream_close_callback(\n            callbacks, on_stream_close);\n\n    nghttp2_session_callbacks_set_on_header_callback2(callbacks, on_header);\n\n    nghttp2_session_callbacks_set_on_data_chunk_recv_callback(\n            callbacks, on_data_chunk_recv);\n\n    nghttp2_session_callbacks_set_error_callback(callbacks, error_callback);\n\n    nghttp2_session_callbacks_set_on_invalid_frame_recv_callback(\n            callbacks, on_invalid_frame_recv);\n\n    nghttp2_session_callbacks_set_on_invalid_header_callback(\n            callbacks, on_invalid_header);\n\n    nghttp2_session_callbacks_set_on_begin_frame_callback(\n            callbacks, on_begin_frame);\n\n    nghttp2_session_callbacks_set_on_begin_headers_callback(\n            callbacks, on_begin_headers);\n\n#if USE_SEND_DATA_WITH_NO_COPY\n    nghttp2_session_callbacks_set_send_data_callback(callbacks, on_send_data);\n#else\n    nghttp2_session_callbacks_set_send_callback(callbacks, send_callback);\n#endif\n\n    rv = nghttp2_session_server_new(&sbi_sess->session, callbacks, sbi_sess);\n    if (rv != 0) {\n        ogs_error(\"nghttp2_session_callbacks_new() failed (%d:%s)\",\n                    rv, nghttp2_strerror(rv));\n        return OGS_ERROR;\n    }\n\n    nghttp2_session_callbacks_del(callbacks);\n\n    return OGS_OK;\n}\n\nstatic int on_frame_recv(nghttp2_session *session,\n                         const nghttp2_frame *frame, void *user_data)\n{\n    int rv;\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_sbi_server_t *server = NULL;\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n\n    ogs_assert(sbi_sess);\n    server = sbi_sess->server;\n    ogs_assert(server);\n    ogs_assert(server->cb);\n\n    ogs_assert(session);\n    ogs_assert(frame);\n\n    stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);\n    if (!stream) {\n        if (frame->hd.type == NGHTTP2_SETTINGS) {\n            sbi_sess->settings.max_concurrent_streams =\n                nghttp2_session_get_remote_settings(\n                    session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);\n            sbi_sess->settings.enable_push =\n                nghttp2_session_get_remote_settings(\n                    session, NGHTTP2_SETTINGS_ENABLE_PUSH);\n            ogs_debug(\"MAX_CONCURRENT_STREAMS = %d\",\n                sbi_sess->settings.max_concurrent_streams);\n            ogs_debug(\"ENABLE_PUSH = %s\",\n                sbi_sess->settings.enable_push ? \"TRUE\" : \"false\");\n\n        } else if (frame->hd.type == NGHTTP2_GOAWAY) {\n            rv = nghttp2_submit_goaway(\n                 session, NGHTTP2_FLAG_NONE, sbi_sess->last_stream_id,\n                 NGHTTP2_NO_ERROR, NULL, 0);\n            if (rv != 0) {\n                ogs_error(\"nghttp2_submit_goaway() failed (%d:%s)\",\n                            rv, nghttp2_strerror(rv));\n                return OGS_ERROR;\n            }\n\n            session_send(sbi_sess);\n        }\n        return 0;\n    }\n\n    request = stream->request;\n    ogs_assert(request);\n\n    switch (frame->hd.type) {\n    case NGHTTP2_HEADERS:\n        if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) {\n            const char *expect100 =\n                ogs_sbi_header_get(request->http.headers, OGS_SBI_EXPECT);\n            if (expect100 && ogs_strcasecmp(expect100, \"100-continue\") == 0) {\n                nghttp2_nv nva;\n\n                add_header(&nva, \":status\", status_string[100]);\n                rv = nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE,\n                           stream->stream_id, NULL, &nva, 1, NULL);\n                if (rv != 0) {\n                    ogs_error(\"nghttp2_submit_headers() failed (%d:%s)\",\n                            rv, nghttp2_strerror(rv));\n                    nghttp2_submit_rst_stream(\n                            session, NGHTTP2_FLAG_NONE, stream->stream_id, rv);\n                    return 0;\n                }\n            }\n        }\n        /* fallthrough */\n        OGS_GNUC_FALLTHROUGH;\n\n    case NGHTTP2_DATA:\n        /* HEADERS or DATA frame with +END_STREAM flag */\n        if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n            ogs_log_level_e level = OGS_LOG_DEBUG;\n\n            if (stream->memory_overflow == true)\n                level = OGS_LOG_ERROR;\n\n            ogs_log_message(level, 0,\n                    \"[%s] %s\", request->h.method, request->h.uri);\n\n            if (request->http.content_length && request->http.content) {\n                ogs_log_message(level, 0,\n                        \"RECEIVED: %d\", (int)request->http.content_length);\n                ogs_log_message(level, 0, \"%s\", request->http.content);\n            }\n\n            if (stream->memory_overflow == true) {\n                ogs_error(\"[DROP] Overflow\");\n                break;\n            }\n\n            if (server->cb(request, stream) != OGS_OK) {\n                ogs_warn(\"server callback error\");\n                ogs_assert(true ==\n                    ogs_sbi_server_send_error(stream,\n                        OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR, NULL,\n                        \"server callback error\", NULL));\n\n                return 0;\n            }\n            break;\n        }\n    default:\n        break;\n    }\n\n    return 0;\n}\n\nstatic int on_stream_close(nghttp2_session *session, int32_t stream_id,\n                           uint32_t error_code, void *user_data)\n{\n    ogs_sbi_stream_t *stream = NULL;\n\n    ogs_assert(session);\n\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n\n    if (error_code) {\n        ogs_error(\"on_stream_close_callback() failed (%d:%s)\",\n                    error_code, nghttp2_http2_strerror(error_code));\n        nghttp2_submit_rst_stream(\n                session, NGHTTP2_FLAG_NONE, stream_id, error_code);\n    }\n\n    ogs_debug(\"STREAM closed [%d]\", stream_id);\n    stream_remove(stream);\n    return 0;\n}\n\nstatic int on_header(nghttp2_session *session, const nghttp2_frame *frame,\n                     nghttp2_rcbuf *name, nghttp2_rcbuf *value,\n                     uint8_t flags, void *user_data)\n{\n    ogs_sbi_session_t *sbi_sess = user_data;\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n\n    const char PATH[] = \":path\";\n    const char METHOD[] = \":method\";\n\n    nghttp2_vec namebuf, valuebuf;\n    char *namestr = NULL, *valuestr = NULL;\n\n    ogs_assert(session);\n    ogs_assert(frame);\n\n    if (frame->hd.type != NGHTTP2_HEADERS ||\n        frame->headers.cat != NGHTTP2_HCAT_REQUEST) {\n        return 0;\n    }\n\n    stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", frame->hd.stream_id);\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n\n    ogs_assert(sbi_sess);\n\n    request = stream->request;\n    ogs_assert(request);\n\n    ogs_assert(name);\n    namebuf = nghttp2_rcbuf_get_buf(name);\n    ogs_assert(namebuf.base);\n    ogs_assert(namebuf.len);\n\n    ogs_assert(value);\n    valuebuf = nghttp2_rcbuf_get_buf(value);\n    ogs_assert(valuebuf.base);\n\n    if (valuebuf.len == 0) return 0;\n\n    namestr = ogs_strndup((const char *)namebuf.base, namebuf.len);\n    ogs_assert(namestr);\n\n    valuestr = ogs_strndup((const char *)valuebuf.base, valuebuf.len);\n    ogs_assert(valuestr);\n\n    if (namebuf.len == sizeof(PATH) - 1 &&\n            memcmp(PATH, namebuf.base, namebuf.len) == 0) {\n        char *saveptr = NULL, *query;\n#define MAX_NUM_OF_PARAM_IN_QUERY 16\n        struct yuarel_param params[MAX_NUM_OF_PARAM_IN_QUERY+2];\n        int j;\n\n        ogs_assert(request->h.uri == NULL);\n        request->h.uri = ogs_sbi_parse_uri(valuestr, \"?\", &saveptr);\n        ogs_assert(request->h.uri);\n\n        memset(params, 0, sizeof(params));\n\n        query = ogs_sbi_parse_uri(NULL, \"?\", &saveptr);\n        if (query && *query && strlen(query))\n            yuarel_parse_query(query, '&', params, MAX_NUM_OF_PARAM_IN_QUERY+1);\n\n        j = 0;\n        while(params[j].key && params[j].val) {\n            ogs_sbi_header_set(request->http.params,\n                    params[j].key, params[j].val);\n            j++;\n        }\n\n        if (j >= MAX_NUM_OF_PARAM_IN_QUERY+1) {\n            ogs_fatal(\"Maximum number(%d) of query params reached\",\n                    MAX_NUM_OF_PARAM_IN_QUERY);\n            ogs_assert_if_reached();\n        }\n\n        ogs_free(query);\n\n    } else if (namebuf.len == sizeof(METHOD) - 1 &&\n            memcmp(METHOD, namebuf.base, namebuf.len) == 0) {\n\n        ogs_assert(request->h.method == NULL);\n        request->h.method = ogs_strdup(valuestr);\n        ogs_assert(request->h.method);\n\n    } else {\n\n        ogs_sbi_header_set(request->http.headers, namestr, valuestr);\n\n    }\n\n    ogs_free(namestr);\n    ogs_free(valuestr);\n\n    return 0;\n}\n\nstatic int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,\n                              int32_t stream_id, const uint8_t *data,\n                              size_t len, void *user_data)\n{\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n\n    size_t offset = 0;\n\n    ogs_assert(session);\n\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return 0;\n    }\n\n    request = stream->request;\n    ogs_assert(request);\n\n    ogs_assert(data);\n    ogs_assert(len);\n\n    if (request->http.content == NULL) {\n        ogs_assert(request->http.content_length == 0);\n        ogs_assert(offset == 0);\n\n        request->http.content = (char*)ogs_malloc(len + 1);\n    } else {\n        ogs_assert(request->http.content_length != 0);\n\n        request->http.content = (char*)ogs_realloc(\n                request->http.content, request->http.content_length + len + 1);\n    }\n\n    if (!request->http.content) {\n        stream->memory_overflow = true;\n\n        ogs_error(\"Overflow : Content-Length[%d], len[%d]\",\n                    (int)request->http.content_length, (int)len);\n        ogs_log_hexdump(OGS_LOG_ERROR, data, len);\n\n        return 0;\n    }\n\n    offset = request->http.content_length;\n    request->http.content_length += len;\n\n    memcpy(request->http.content + offset, data, len);\n    request->http.content[request->http.content_length] = '\\0';\n\n    return 0;\n}\n\nstatic int error_callback(nghttp2_session *session,\n                          const char *msg, size_t len, void *user_data)\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sockaddr_t *addr = NULL;\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_assert(sbi_sess);\n    addr = sbi_sess->addr;\n    ogs_assert(addr);\n\n    ogs_assert(msg);\n\n    ogs_error(\"[%s]:%d http2 error: %.*s\",\n            OGS_ADDR(addr, buf), OGS_PORT(addr), (int)len, msg);\n\n    return 0;\n}\n\nstatic int on_invalid_frame_recv(nghttp2_session *session,\n                                 const nghttp2_frame *frame,\n                                 int error_code, void *user_data)\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sockaddr_t *addr = NULL;\n\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_assert(sbi_sess);\n    addr = sbi_sess->addr;\n    ogs_assert(addr);\n\n    ogs_error(\"[%s]:%d invalid frame (%d:%s)\",\n            OGS_ADDR(addr, buf), OGS_PORT(addr),\n            error_code, nghttp2_strerror(error_code));\n    return 0;\n}\n\nstatic int on_invalid_header(nghttp2_session *session,\n                             const nghttp2_frame *frame,\n                             const uint8_t *name, size_t namelen,\n                             const uint8_t *value, size_t valuelen,\n                             uint8_t flags, void *user_data)\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sockaddr_t *addr = NULL;\n    char *namestr = NULL, *valuestr = NULL;\n\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_assert(sbi_sess);\n    addr = sbi_sess->addr;\n    ogs_assert(addr);\n\n    namestr = ogs_strndup((const char *)name, namelen);\n    ogs_assert(namestr);\n\n    valuestr = ogs_strndup((const char *)value, valuelen);\n    ogs_assert(valuestr);\n\n    ogs_error(\"[%s]:%d invalid header (%s:%s)\",\n            OGS_ADDR(addr, buf), OGS_PORT(addr), namestr, valuestr);\n\n    ogs_free(namestr);\n    ogs_free(valuestr);\n\n    return 0;\n}\n\nstatic int on_begin_frame(nghttp2_session *session, const nghttp2_frame_hd *hd,\n                          void *user_data)\n{\n    char buf[OGS_ADDRSTRLEN];\n    ogs_sockaddr_t *addr = NULL;\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_assert(sbi_sess);\n    addr = sbi_sess->addr;\n    ogs_assert(addr);\n\n    ogs_assert(hd);\n\n    if ((hd->type == NGHTTP2_HEADERS) &&\n        (hd->stream_id < sbi_sess->last_stream_id)) {\n        ogs_error(\"[%s]:%d invalid stream id(%d) >= last stream id(%d)\",\n                OGS_ADDR(addr, buf), OGS_PORT(addr),\n                hd->stream_id, sbi_sess->last_stream_id);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n\n    return 0;\n}\n\nstatic int on_begin_headers(nghttp2_session *session,\n                            const nghttp2_frame *frame, void *user_data)\n{\n    ogs_sbi_session_t *sbi_sess = user_data;\n    ogs_sbi_stream_t *stream = NULL;\n\n    ogs_assert(sbi_sess);\n    ogs_assert(session);\n    ogs_assert(frame);\n\n    if (frame->hd.type != NGHTTP2_HEADERS ||\n        frame->headers.cat != NGHTTP2_HCAT_REQUEST) {\n        return 0;\n    }\n\n    stream = stream_add(sbi_sess, frame->hd.stream_id);\n    ogs_assert(stream);\n    ogs_debug(\"STREAM added [%d]\", frame->hd.stream_id);\n\n    nghttp2_session_set_stream_user_data(session, frame->hd.stream_id, stream);\n\n    return 0;\n}\n\nstatic int session_send_preface(ogs_sbi_session_t *sbi_sess)\n{\n    int rv;\n    nghttp2_settings_entry iv[1] = {\n        { NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, ogs_app()->pool.stream }\n    };\n\n    ogs_assert(sbi_sess);\n    ogs_assert(sbi_sess->session);\n\n    rv = nghttp2_submit_settings(\n            sbi_sess->session, NGHTTP2_FLAG_NONE, iv, OGS_ARRAY_SIZE(iv));\n    if (rv != 0) {\n        ogs_error(\"nghttp2_submit_settings() failed (%d:%s)\",\n                    rv, nghttp2_strerror(rv));\n        return OGS_ERROR;\n    }\n\n    return session_send(sbi_sess);\n}\n\n#if USE_SEND_DATA_WITH_NO_COPY\nstatic int on_send_data(nghttp2_session *session, nghttp2_frame *frame,\n                        const uint8_t *framehd, size_t length,\n                        nghttp2_data_source *source, void *user_data)\n{\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_sbi_response_t *response = NULL;\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_pkbuf_t *pkbuf = NULL;\n    size_t padlen = 0;\n\n    ogs_assert(session);\n    ogs_assert(frame);\n\n    stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", frame->hd.stream_id);\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n\n    ogs_assert(sbi_sess);\n\n    ogs_assert(source);\n    response = source->ptr;\n    ogs_assert(response);\n\n    ogs_assert(response->http.content);\n    ogs_assert(response->http.content_length);\n\n    ogs_assert(framehd);\n    ogs_assert(length);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put_data(pkbuf, framehd, 9);\n\n    padlen = frame->data.padlen;\n\n    if (padlen > 0) {\n        ogs_pkbuf_put_u8(pkbuf, padlen-1);\n    }\n\n    ogs_pkbuf_put_data(pkbuf,\n            response->http.content, response->http.content_length);\n\n    if (padlen > 0) {\n        memset(pkbuf->tail, 0, padlen-1);\n        ogs_pkbuf_put(pkbuf, padlen-1);\n    }\n\n    session_write_to_buffer(sbi_sess, pkbuf);\n\n    return 0;\n}\n#else\nstatic ssize_t send_callback(nghttp2_session *session, const uint8_t *data,\n                             size_t length, int flags, void *user_data)\n{\n    ogs_sbi_session_t *sbi_sess = user_data;\n    ogs_sock_t *sock = NULL;\n    ogs_socket_t fd = INVALID_SOCKET;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    ogs_assert(sbi_sess);\n    sock = sbi_sess->sock;\n    ogs_assert(sock);\n    fd = sock->fd;\n    ogs_assert(fd != INVALID_SOCKET);\n\n    ogs_assert(data);\n    ogs_assert(length);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, length);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put_data(pkbuf, data, length);\n\n    session_write_to_buffer(sbi_sess, pkbuf);\n\n    return length;\n}\n#endif\n\nstatic int session_send(ogs_sbi_session_t *sbi_sess)\n{\n#if USE_SEND_DATA_WITH_NO_COPY\n    ogs_pkbuf_t *pkbuf = NULL;\n#else\n    int rv;\n#endif\n\n    ogs_assert(sbi_sess);\n    ogs_assert(sbi_sess->session);\n\n#if USE_SEND_DATA_WITH_NO_COPY\n    for (;;) {\n        const uint8_t *data = NULL;\n        ssize_t data_len;\n\n        data_len = nghttp2_session_mem_send(sbi_sess->session, &data);\n        if (data_len < 0) {\n            ogs_error(\"nghttp2_session_mem_send() failed (%d:%s)\",\n                        (int)data_len, nghttp2_strerror((int)data_len));\n            return OGS_ERROR;\n        }\n\n        if (data_len == 0) {\n            break;\n        }\n\n        pkbuf = ogs_pkbuf_alloc(NULL, data_len);\n        ogs_assert(pkbuf);\n        ogs_pkbuf_put_data(pkbuf, data, data_len);\n\n        session_write_to_buffer(sbi_sess, pkbuf);\n    }\n#else\n    rv = nghttp2_session_send(sbi_sess->session);\n    if (rv != 0) {\n        ogs_error(\"nghttp_session_send() failed (%d:%s)\",\n                    rv, nghttp2_strerror(rv));\n        return OGS_ERROR;\n    }\n#endif\n\n    return OGS_OK;\n}\n\nstatic void session_write_callback(short when, ogs_socket_t fd, void *data)\n{\n    ogs_sbi_session_t *sbi_sess = data;\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    ogs_assert(sbi_sess);\n\n    if (ogs_list_empty(&sbi_sess->write_queue) == true) {\n        ogs_assert(sbi_sess->poll.write);\n        ogs_pollset_remove(sbi_sess->poll.write);\n        sbi_sess->poll.write = NULL;\n        return;\n    }\n\n    pkbuf = ogs_list_first(&sbi_sess->write_queue);\n    ogs_assert(pkbuf);\n    ogs_list_remove(&sbi_sess->write_queue, pkbuf);\n\n    ogs_send(fd, pkbuf->data, pkbuf->len, 0);\n    ogs_log_hexdump(OGS_LOG_DEBUG, pkbuf->data, pkbuf->len);\n\n    ogs_pkbuf_free(pkbuf);\n}\n\nstatic void session_write_to_buffer(\n        ogs_sbi_session_t *sbi_sess, ogs_pkbuf_t *pkbuf)\n{\n    ogs_sock_t *sock = NULL;\n    ogs_socket_t fd = INVALID_SOCKET;\n\n    ogs_assert(pkbuf);\n\n    ogs_assert(sbi_sess);\n    sock = sbi_sess->sock;\n    ogs_assert(sock);\n    fd = sock->fd;\n    ogs_assert(fd != INVALID_SOCKET);\n\n    ogs_list_add(&sbi_sess->write_queue, pkbuf);\n\n    if (!sbi_sess->poll.write) {\n        sbi_sess->poll.write = ogs_pollset_add(ogs_app()->pollset,\n            OGS_POLLOUT, fd, session_write_callback, sbi_sess);\n        ogs_assert(sbi_sess->poll.write);\n    }\n}\n"], "filenames": ["lib/sbi/client.c", "lib/sbi/nghttp2-server.c"], "buggy_code_start_loc": [46, 84], "buggy_code_end_loc": [732, 986], "fixing_code_start_loc": [47, 85], "fixing_code_end_loc": [750, 1005], "type": "CWE-404", "message": "A vulnerability was found in Open5GS up to 2.4.10. It has been declared as problematic. Affected by this vulnerability is an unknown functionality in the library lib/sbi/client.c of the component AMF. The manipulation leads to denial of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88. It is recommended to apply a patch to fix this issue. The identifier VDB-209545 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-3299", "sourceIdentifier": "cna@vuldb.com", "published": "2022-09-26T13:15:11.410", "lastModified": "2022-10-03T17:21:29.903", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Open5GS up to 2.4.10. It has been declared as problematic. Affected by this vulnerability is an unknown functionality in the library lib/sbi/client.c of the component AMF. The manipulation leads to denial of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88. It is recommended to apply a patch to fix this issue. The identifier VDB-209545 was assigned to this vulnerability."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad en Open5GS versiones hasta 2.4.10. Se ha declarado como problem\u00e1tica. Esta vulnerabilidad afecta a una funcionalidad desconocida en la biblioteca lib/sbi/client.c del componente AMF. La manipulaci\u00f3n conlleva a una denegaci\u00f3n de servicio. El ataque puede ser lanzado remotamente. El nombre del parche es 724fa568435dae45ef0c3a48b2aabde052afae88. Es recomendado aplicar un parche para corregir este problema. Se ha asignado el identificador VDB-209545 a esta vulnerabilidad.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:open5gs:open5gs:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndIncluding": "2.4.10", "matchCriteriaId": "B2AEE117-9611-459B-9FC0-18A16FFD9781"}]}]}], "references": [{"url": "https://github.com/open5gs/open5gs/commit/724fa568435dae45ef0c3a48b2aabde052afae88", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/open5gs/open5gs/issues/1769", "source": "cna@vuldb.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.209545", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/open5gs/open5gs/commit/724fa568435dae45ef0c3a48b2aabde052afae88"}}