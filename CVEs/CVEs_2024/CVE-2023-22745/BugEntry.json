{"buggy_code": ["/* SPDX-License-Identifier: BSD-2-Clause */\n\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"tss2_rc.h\"\n#include \"tss2_sys.h\"\n#include \"util/aux_util.h\"\n\n/**\n * The maximum size of a layer name.\n */\n#define TSS2_ERR_LAYER_NAME_MAX  (16 + 1)\n\n/**\n * The maximum size for layer specific error strings.\n */\n#define TSS2_ERR_LAYER_ERROR_STR_MAX  512\n\n/**\n * Concatenates (safely) onto a static buffer given a format and varaidic\n * arguments similar to sprintf.\n * @param b\n *   The static buffer to concatenate onto.\n * @param fmt\n *   The format specifier as understood by printf followed by the variadic\n *   parameters for the specifier.\n */\n#define catbuf(b, fmt, ...) _catbuf(b, sizeof(b), fmt, ##__VA_ARGS__)\n\n/**\n * Clears out a static buffer by setting index 0 to the null byte.\n * @param buffer\n *  The buffer to clear out.\n */\nstatic void\nclearbuf(char *buffer)\n{\n    buffer[0] = '\\0';\n}\n\n/**\n * Prints to a buffer using snprintf(3) using the supplied fmt\n * and varaiadic arguments.\n * @param buf\n *  The buffer to print into.\n * @param len\n *  The length of that buffer.\n * @param fmt\n *  The format string\n * @warning\n *  DO NOT CALL DIRECTLY, use the catbuf() macro.\n */\nstatic void COMPILER_ATTR(format (printf, 3, 4))\n_catbuf(char *buf, size_t len, const char *fmt, ...)\n{\n    va_list argptr;\n    va_start(argptr, fmt);\n    size_t offset = strlen(buf);\n    vsnprintf(&buf[offset], len - offset, fmt, argptr);\n    va_end(argptr);\n}\n\n/**\n * Number of error layers\n */\n#define TPM2_ERROR_TSS2_RC_LAYER_COUNT (TSS2_RC_LAYER_MASK >> TSS2_RC_LAYER_SHIFT)\n\n/**\n * Mask for the error bits of tpm2 compliant return code.\n */\n#define TPM2_ERROR_TSS2_RC_ERROR_MASK 0xFFFF\n\n/**\n * Retrieves the error bits from a TSS2_RC. The error bits are\n * contained in the first 2 octets.\n * @param rc\n *  The rc to query for the error bits.\n * @return\n *  The error bits.\n */\nstatic inline UINT16\ntpm2_error_get(TSS2_RC rc)\n{\n    return ((rc & TPM2_ERROR_TSS2_RC_ERROR_MASK));\n}\n\n/**\n * Retrieves the layer number. The layer number is in the 3rd\n * octet and is thus 1 byte big.\n *\n * @param rc\n *  The rc to query for the layer number.\n * @return\n *  The layer number.\n */\nstatic inline UINT8\ntss2_rc_layer_number_get(TSS2_RC rc)\n{\n    return ((rc & TSS2_RC_LAYER_MASK) >> TSS2_RC_LAYER_SHIFT);\n}\n\n/**\n * Queries a TPM format 1 error codes N field. The N field\n * is a 4 bit field located at bits 8:12.\n * @param rc\n *  The rc to query the N field for.\n * @return\n *  The N field value.\n */\nstatic inline UINT8\ntpm2_rc_fmt1_N_get(TPM2_RC rc)\n{\n    return ((rc & (0xF << 8)) >> 8);\n}\n\n/**\n * Queries the index bits out of the N field contained in a TPM format 1\n * error code. The index bits are the low 3 bits of the N field.\n * @param rc\n *  The TPM format 1 error code to query for the index bits.\n * @return\n *  The index bits from the N field.\n */\nstatic inline UINT8\ntpm2_rc_fmt1_N_index_get(TPM2_RC rc)\n{\n    return (tpm2_rc_fmt1_N_get(rc) & 0x7);\n}\n\n/**\n * Determines if the N field in a TPM format 1 error code is\n * a handle or not.\n * @param rc\n *  The TPM format 1 error code to query.\n * @return\n *  True if it is a handle, false otherwise.\n */\nstatic inline bool\ntpm2_rc_fmt1_N_is_handle(TPM2_RC rc)\n{\n    return ((tpm2_rc_fmt1_N_get(rc) & 0x8) == 0);\n}\n\nstatic inline UINT8\ntpm2_rc_fmt1_P_get(TPM2_RC rc)\n{\n    return ((rc & (1 << 6)) >> 6);\n}\n\nstatic inline UINT8\ntpm2_rc_fmt1_error_get(TPM2_RC rc)\n{\n    return (rc & 0x3F);\n}\n\nstatic inline UINT8\ntpm2_rc_fmt0_error_get(TPM2_RC rc)\n{\n    return (rc & 0x7F);\n}\n\nstatic inline UINT8\ntpm2_rc_tpm_fmt0_V_get(TPM2_RC rc)\n{\n    return ((rc & (1 << 8)) >> 8);\n}\n\nstatic inline UINT8\ntpm2_rc_fmt0_T_get(TPM2_RC rc)\n{\n    return ((rc & (1 << 10)) >> 8);\n}\n\nstatic inline UINT8\ntpm2_rc_fmt0_S_get(TSS2_RC rc)\n{\n    return ((rc & (1 << 11)) >> 8);\n}\n\n/**\n * Helper macro for adding a layer handler to the layer\n * registration array.\n */\n#define ADD_HANDLER(name, handler) \\\n    { name, handler }\n\n/**\n * Same as ADD_HANDLER but sets it to NULL. Used as a placeholder\n * for non-registered indexes into the handler array.\n */\n#define ADD_NULL_HANDLER ADD_HANDLER(\"\\0\", NULL)\n\nconst char *\ntss2_fmt1_err_strs_get(TSS2_RC error)\n{\n    /*\n     * format 1 error codes start at 1, so\n     * add a NULL entry to index 0.\n     */\n    static const char *fmt1_err_strs[] = {\n        /* 0x0 - EMPTY */\n        NULL,\n        /* 0x1 - TPM2_RC_ASYMMETRIC */\n        \"asymmetric algorithm not supported or not correct\",\n        /* 0x2 - TPM2_RC_ATTRIBUTES */\n        \"inconsistent attributes\",\n        /* 0x3 - TPM2_RC_HASH */\n        \"hash algorithm not supported or not appropriate\",\n        /* 0x4 - TPM2_RC_VALUE */\n        \"value is out of range or is not correct for the context\",\n        /* 0x5 - TPM2_RC_HIERARCHY */\n        \"hierarchy is not enabled or is not correct for the use\",\n        /* 0x6 - EMPTY */\n        NULL,\n        /* 0x7 - TPM2_RC_KEY_SIZE */\n        \"key size is not supported\",\n        /* 0x8 - TPM2_RC_MGF */\n        \"mask generation function not supported\",\n        /* 0x9 - TPM2_RC_MODE */\n        \"mode of operation not supported\",\n        /* 0xA - TPM2_RC_TYPE */\n        \"the type of the value is not appropriate for the use\",\n        /* 0xB - TPM2_RC_HANDLE */\n        \"the handle is not correct for the use\",\n        /* 0xC - TPM2_RC_KDF */\n        \"unsupported key derivation function or function not appropriate for \"\n        \"use\",\n        /* 0xD - TPM2_RC_RANGE */\n        \"value was out of allowed range\",\n        /* 0xE - TPM2_RC_AUTH_FAIL */\n        \"the authorization HMAC check failed and DA counter incremented\",\n        /* 0xF - TPM2_RC_NONCE */\n        \"invalid nonce size or nonce value mismatch\",\n        /* 0x10 - TPM2_RC_PP */\n        \"authorization requires assertion of PP\",\n        /* 0x11 - EMPTY */\n        NULL,\n        /* 0x12 - TPM2_RC_SCHEME */\n        \"unsupported or incompatible scheme\",\n        /* 0x13 - EMPTY */\n        NULL,\n        /* 0x14 - EMPTY */\n        NULL,\n        /* 0x15 - TPM2_RC_SIZE */\n        \"structure is the wrong size\",\n        /* 0x16 - TPM2_RC_SYMMETRIC */\n        \"unsupported symmetric algorithm or key size or not appropriate for\"\n        \" instance\",\n        /* 0x17 - TPM2_RC_TAG */\n        \"incorrect structure tag\",\n        /* 0x18 - TPM2_RC_SELECTOR */\n        \"union selector is incorrect\",\n        /* 0x19 - EMPTY */\n        NULL,\n        /* 0x1A - TPM2_RC_INSUFFICIENT */\n        \"the TPM was unable to unmarshal a value because there were not enough\"\n        \" octets in the input buffer\",\n        /* 0x1B - TPM2_RC_SIGNATURE */\n        \"the signature is not valid\",\n        /* 0x1C - TPM2_RC_KEY */\n        \"key fields are not compatible with the selected use\",\n        /* 0x1D - TPM2_RC_POLICY_FAIL */\n        \"a policy check failed\",\n        /* 0x1E - EMPTY */\n        NULL,\n        /* 0x1F - TPM2_RC_INTEGRITY */\n        \"integrity check failed\",\n        /* 0x20 - TPM2_RC_TICKET */\n        \"invalid ticket\",\n        /* 0x21 - TPM2_RC_RESERVED_BITS */\n        \"reserved bits not set to zero as required\",\n        /* 0x22 - TPM2_RC_BAD_AUTH */\n        \"authorization failure without DA implications\",\n        /* 0x23 - TPM2_RC_EXPIRED */\n        \"the policy has expired\",\n        /* 0x24 - TPM2_RC_POLICY_CC */\n        \"the commandCode in the policy is not the commandCode of the command\"\n        \" or the command code in a policy command references a command that\"\n        \" is not implemented\",\n        /* 0x25 - TPM2_RC_BINDING */\n        \"public and sensitive portions of an object are not cryptographically bound\",\n        /* 0x26 - TPM2_RC_CURVE */\n        \"curve not supported\",\n        /* 0x27 - TPM2_RC_ECC_POINT */\n        \"point is not on the required curve\",\n    };\n\n    if (error < ARRAY_LEN(fmt1_err_strs)) {\n        return fmt1_err_strs[error];\n    }\n\n    return NULL;\n}\n\nconst char *\ntss2_fmt0_err_strs_get(TSS2_RC rc)\n{\n    /*\n     * format 0 error codes start at 1, so\n     * add a NULL entry to index 0.\n     * Thus, no need to offset the error bits\n     * and fmt0 and fmt1 arrays can be used\n     * in-place of each other for lookups.\n     */\n    static const char *fmt0_warn_strs[] = {\n            /* 0x0 - EMPTY */\n            NULL,\n            /* 0x1 - TPM2_RC_CONTEXT_GAP */\n            \"gap for context ID is too large\",\n            /* 0x2 - TPM2_RC_OBJECT_MEMORY */\n            \"out of memory for object contexts\",\n            /* 0x3 - TPM2_RC_SESSION_MEMORY */\n            \"out of memory for session contexts\",\n            /* 0x4 - TPM2_RC_MEMORY */\n            \"out of shared objectsession memory or need space for internal\"\n            \" operations\",\n            /* 0x5 - TPM2_RC_SESSION_HANDLES */\n            \"out of session handles\",\n            /* 0x6 - TPM2_RC_OBJECT_HANDLES */\n            \"out of object handles\",\n            /* 0x7 - TPM2_RC_LOCALITY */\n            \"bad locality\",\n            /* 0x8 - TPM2_RC_YIELDED */\n            \"the TPM has suspended operation on the command forward progress\"\n            \" was made and the command may be retried\",\n            /* 0x9 - TPM2_RC_CANCELED */\n            \"the command was canceled\",\n            /* 0xA - TPM2_RC_TESTING */\n            \"TPM is performing selftests\",\n            /* 0xB - EMPTY */\n            NULL,\n            /* 0xC - EMPTY */\n            NULL,\n            /* 0xD - EMPTY */\n            NULL,\n            /* 0xE - EMPTY */\n            NULL,\n            /* 0xF - EMPTY */\n            NULL,\n            /* 0x10 - TPM2_RC_REFERENCE_H0 */\n            \"the 1st handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x11 - TPM2_RC_REFERENCE_H1 */\n            \"the 2nd handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x12 - TPM2_RC_REFERENCE_H2 */\n            \"the 3rd handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x13 - TPM2_RC_REFERENCE_H3 */\n            \"the 4th handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x14 - TPM2_RC_REFERENCE_H4 */\n            \"the 5th handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x15 - TPM2_RC_REFERENCE_H5 */\n            \"the 6th handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x16 - TPM2_RC_REFERENCE_H6 */\n            \"the 7th handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x17 - EMPTY, */\n            NULL,\n            /* 0x18 - TPM2_RC_REFERENCE_S0 */\n            \"the 1st authorization session handle references a session that\"\n            \" is not loaded\",\n            /* 0x19 - TPM2_RC_REFERENCE_S1 */\n            \"the 2nd authorization session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1A - TPM2_RC_REFERENCE_S2 */\n            \"the 3rd authorization session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1B - TPM2_RC_REFERENCE_S3 */\n            \"the 4th authorization session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1C - TPM2_RC_REFERENCE_S4 */\n            \"the 5th session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1D - TPM2_RC_REFERENCE_S5 */\n            \"the 6th session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1E - TPM2_RC_REFERENCE_S6 */\n            \"the 7th authorization session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1F - EMPTY, */\n            NULL,\n            /* 0x20 -TPM2_RC_NV_RATE */\n            \"the TPM is rate limiting accesses to prevent wearout of NV\",\n            /* 0x21 - TPM2_RC_LOCKOUT */\n            \"authorizations for objects subject to DA protection are not\"\n            \" allowed at this time because the TPM is in DA lockout mode\",\n            /* 0x22 - TPM2_RC_RETRY */\n            \"the TPM was not able to start the command\",\n            /* 0x23 - TPM2_RC_NV_UNAVAILABLE */\n            \"the command may require writing of NV and NV is not current\"\n            \" accessible\",\n    };\n\n    /*\n     * format 1 error codes start at 0, so\n     * no need to offset the error bits.\n     */\n    static const char *fmt0_err_strs[] = {\n        /* 0x0 - TPM2_RC_INITIALIZE */\n        \"TPM not initialized by TPM2_Startup or already initialized\",\n        /* 0x1 - TPM2_RC_FAILURE */\n        \"commands not being accepted because of a TPM failure\",\n        /* 0x2 - EMPTY */\n        NULL,\n        /* 0x3 - TPM2_RC_SEQUENCE */\n        \"improper use of a sequence handle\",\n        /* 0x4 - EMPTY */\n        NULL,\n        /* 0x5 - EMPTY */\n        NULL,\n        /* 0x6 - EMPTY */\n        NULL,\n        /* 0x7 - EMPTY */\n        NULL,\n        /* 0x8 - EMPTY */\n        NULL,\n        /* 0x9 - EMPTY */\n        NULL,\n        /* 0xA - EMPTY */\n        NULL,\n        /* 0xB - TPM2_RC_PRIVATE */\n        \"not currently used\",\n        /* 0xC - EMPTY */\n        NULL,\n        /* 0xD - EMPTY */\n        NULL,\n        /* 0xE - EMPTY */\n        NULL,\n        /* 0xF - EMPTY */\n        NULL,\n        /* 0x10 - EMPTY */\n        NULL,\n        /* 0x11 - EMPTY */\n        NULL,\n        /* 0x12 - EMPTY */\n        NULL,\n        /* 0x13 - EMPTY */\n        NULL,\n        /* 0x14 - EMPTY */\n        NULL,\n        /* 0x15 - EMPTY */\n        NULL,\n        /* 0x16 - EMPTY */\n        NULL,\n        /* 0x17 - EMPTY */\n        NULL,\n        /* 0x18 - EMPTY */\n        NULL,\n        /* 0x19 - TPM2_RC_HMAC */\n        \"not currently used\",\n        /* 0x1A - EMPTY */\n        NULL,\n        /* 0x1B - EMPTY */\n        NULL,\n        /* 0x1C - EMPTY */\n        NULL,\n        /* 0x1D - EMPTY */\n        NULL,\n        /* 0x1E - EMPTY */\n        NULL,\n        /* 0x1F - EMPTY */\n        NULL,\n        /* 0x20 - TPM2_RC_DISABLED */\n        \"the command is disabled\",\n        /* 0x21 - TPM2_RC_EXCLUSIVE */\n        \"command failed because audit sequence required exclusivity\",\n        /* 0x22 - EMPTY */\n        NULL,\n        /* 0x23 - EMPTY, */\n        NULL,\n        /* 0x24 - TPM2_RC_AUTH_TYPE */\n        \"authorization handle is not correct for command\",\n        /* 0x25 - TPM2_RC_AUTH_MISSING */\n        \"command requires an authorization session for handle and it is\"\n        \" not present\",\n        /* 0x26 - TPM2_RC_POLICY */\n        \"policy failure in math operation or an invalid authPolicy value\",\n        /* 0x27 - TPM2_RC_PCR */\n        \"PCR check fail\",\n        /* 0x28 - TPM2_RC_PCR_CHANGED */\n        \"PCR have changed since checked\",\n        /* 0x29 - EMPTY */\n        NULL,\n        /* 0x2A - EMPTY */\n        NULL,\n        /* 0x2B - EMPTY */\n        NULL,\n        /* 0x2C - EMPTY */\n        NULL,\n        /* 0x2D - TPM2_RC_UPGRADE */\n        \"For all commands, other than TPM2_FieldUpgradeData, \"\n        \"this code indicates that the TPM is in field upgrade mode. \"\n        \"For TPM2_FieldUpgradeData, this code indicates that the TPM \"\n        \"is not in field upgrade mode\",\n        /* 0x2E - TPM2_RC_TOO_MANY_CONTEXTS */\n        \"context ID counter is at maximum\",\n        /* 0x2F - TPM2_RC_AUTH_UNAVAILABLE */\n        \"authValue or authPolicy is not available for selected entity\",\n        /* 0x30 - TPM2_RC_REBOOT */\n        \"a _TPM_Init and StartupCLEAR is required before the TPM can\"\n        \" resume operation\",\n        /* 0x31 - TPM2_RC_UNBALANCED */\n        \"the protection algorithms hash and symmetric are not reasonably\"\n        \" balanced. The digest size of the hash must be larger than the key\"\n        \" size of the symmetric algorithm.\",\n        /* 0x32 - EMPTY */\n        NULL,\n        /* 0x33 - EMPTY */\n        NULL,\n        /* 0x34 - EMPTY */\n        NULL,\n        /* 0x35 - EMPTY */\n        NULL,\n        /* 0x36 - EMPTY */\n        NULL,\n        /* 0x37 - EMPTY */\n        NULL,\n        /* 0x38 - EMPTY */\n        NULL,\n        /* 0x39 - EMPTY */\n        NULL,\n        /* 0x3A - EMPTY */\n        NULL,\n        /* 0x3B - EMPTY */\n        NULL,\n        /* 0x3C - EMPTY */\n        NULL,\n        /* 0x3D - EMPTY */\n        NULL,\n        /* 0x3E - EMPTY */\n        NULL,\n        /* 0x3F - EMPTY */\n        NULL,\n        /* 0x40 - EMPTY */\n        NULL,\n        /* 0x41 - EMPTY */\n        NULL,\n        /* 0x42 - TPM2_RC_COMMAND_SIZE */\n        \"command commandSize value is inconsistent with contents of the\"\n        \" command buffer. Either the size is not the same as the octets\"\n        \" loaded by the hardware interface layer or the value is not large\"\n        \" enough to hold a command header\",\n        /* 0x43 - TPM2_RC_COMMAND_CODE */\n        \"command code not supported\",\n        /* 0x44 - TPM2_RC_AUTHSIZE */\n        \"the value of authorizationSize is out of range or the number of\"\n        \" octets in the Authorization Area is greater than required\",\n        /* 0x45 - TPM2_RC_AUTH_CONTEXT */\n        \"use of an authorization session with a context command or another\"\n        \" command that cannot have an authorization session\",\n        /* 0x46 - TPM2_RC_NV_RANGE */\n        \"NV offset+size is out of range\",\n        /* 0x47 - TPM2_RC_NV_SIZE */\n        \"Requested allocation size is larger than allowed\",\n        /* 0x48 - TPM2_RC_NV_LOCKED */\n        \"NV access locked\",\n        /* 0x49 - TPM2_RC_NV_AUTHORIZATION */\n        \"NV access authorization fails in command actions\",\n        /* 0x4A - TPM2_RC_NV_UNINITIALIZED */\n        \"an NV Index is used before being initialized or the state saved\"\n        \" by TPM2_ShutdownSTATE could not be restored\",\n        /* 0x4B - TPM2_RC_NV_SPACE */\n        \"insufficient space for NV allocation\",\n        /* 0x4C - TPM2_RC_NV_DEFINED */\n        \"NV Index or persistent object already defined\",\n        /* 0x4D - EMPTY */\n        NULL,\n        /* 0x4E - EMPTY */\n        NULL,\n        /* 0x4F - EMPTY */\n        NULL,\n        /* 0x50 - TPM2_RC_BAD_CONTEXT */\n        \"context in TPM2_ContextLoad is not valid\",\n        /* 0x51 - TPM2_RC_CPHASH */\n        \"cpHash value already set or not correct for use\",\n        /* 0x52 - TPM2_RC_PARENT */\n        \"handle for parent is not a valid parent\",\n        /* 0x53 - TPM2_RC_NEEDS_TEST */\n        \"some function needs testing\",\n        /* 0x54 - TPM2_RC_NO_RESULT */\n        \"returned when an internal function cannot process a request due to\"\n        \" an unspecified problem. This code is usually related to invalid\"\n        \" parameters that are not properly filtered by the input\"\n        \" unmarshaling code\",\n        /* 0x55 - TPM2_RC_SENSITIVE */\n        \"the sensitive area did not unmarshal correctly after decryption\",\n    };\n\n    UINT8 errnum = tpm2_rc_fmt0_error_get(rc);\n    /* is it a warning (version 2 error string) or is it a 1.2 error? */\n    size_t len = tpm2_rc_fmt0_S_get(rc) ? ARRAY_LEN(fmt0_warn_strs) : ARRAY_LEN(fmt0_err_strs);\n    const char **selection = tpm2_rc_fmt0_S_get(rc) ? fmt0_warn_strs : fmt0_err_strs;\n    if (errnum >= len) {\n        return NULL;\n    }\n\n    return selection[errnum];\n}\n\nstatic const char *\ntpm2_err_handler_fmt1(TPM2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n\n    clearbuf(buf);\n\n    /* Print whether or not the error is caused by a bad\n     * handle or parameter. On the case of a Handle (P == 0)\n     * then the N field top bit will be set. Un-set this bit\n     * to get the handle index by subtracting 8 as N is a 4\n     * bit field.\n     *\n     * the lower 3 bits of N indicate index, and the high bit\n     * indicates\n     */\n    UINT8 index = tpm2_rc_fmt1_N_index_get(rc);\n\n    bool is_handle = tpm2_rc_fmt1_N_is_handle(rc);\n    const char *m = tpm2_rc_fmt1_P_get(rc) ? \"parameter\" :\n                    is_handle ? \"handle\" : \"session\";\n    catbuf(buf, \"%s\", m);\n\n    if (index) {\n        catbuf(buf, \"(%u):\", index);\n    } else {\n        catbuf(buf, \"%s\", \"(unk):\");\n    }\n\n    UINT8 errnum = tpm2_rc_fmt1_error_get(rc);\n    m = tss2_fmt1_err_strs_get(errnum);\n    if (m) {\n        catbuf(buf, \"%s\", m);\n    } else {\n        catbuf(buf, \"unknown error num: 0x%X\", errnum);\n    }\n\n    return buf;\n}\n\nstatic const char *\ntpm2_err_handler_fmt0(TSS2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n\n    clearbuf(buf);\n\n    char *e = tpm2_rc_fmt0_S_get(rc) ? \"warn\" : \"error\";\n    char *v = tpm2_rc_tpm_fmt0_V_get(rc) ? \"2.0\" : \"1.2\";\n    catbuf(buf, \"%s(%s): \", e, v);\n\n    UINT8 errnum = tpm2_rc_fmt0_error_get(rc);\n    /* We only have version 2.0 spec codes defined */\n    if (tpm2_rc_tpm_fmt0_V_get(rc)) {\n        /* TCG specific error code */\n        if (tpm2_rc_fmt0_T_get(rc)) {\n            catbuf(buf, \"Vendor specific error: 0x%X\", errnum);\n            return buf;\n        }\n\n        const char *m = tss2_fmt0_err_strs_get(rc);\n        if (!m) {\n            return NULL;\n        }\n\n        catbuf(buf, \"%s\", m);\n        return buf;\n    }\n\n    catbuf(buf, \"%s\", \"unknown version 1.2 error code\");\n\n    return buf;\n}\n\n/**\n * Retrieves the layer field from a TSS2_RC code.\n * @param rc\n *  The rc to query the layer index of.\n * @return\n *  The layer index.\n */\nstatic inline UINT8\ntss2_rc_layer_format_get(TSS2_RC rc)\n{\n    return ((rc & (1 << 7)) >> 7);\n}\n\n/**\n * Handler for tpm2 error codes. ie codes\n * coming from the tpm layer aka layer 0.\n * @param rc\n *  The rc to decode.\n * @return\n *  An error string.\n */\nstatic const char *\ntpm2_ehandler(TSS2_RC rc)\n{\n    bool is_fmt_1 = tss2_rc_layer_format_get(rc);\n\n    return is_fmt_1 ? tpm2_err_handler_fmt1(rc) : tpm2_err_handler_fmt0(rc);\n}\n\n/**\n * The default system code handler. This handles codes\n * from the RM (itself and simulated tpm responses), the marshaling\n * library (mu), the tcti layers, sapi, esys and fapi.\n * @param rc\n *  The rc to decode.\n * @return\n *  An error string.\n */\nstatic const char *\ntss_err_handler (TSS2_RC rc)\n{\n    /*\n     * subtract 1 from the error number\n     * before indexing into this array.\n     *\n     * Commented offsets are for the corresponding\n     * error number *before* subtraction. Ie error\n     * number 4 is at array index 3.\n     */\n    static const char *errors[] =   {\n        /* 1 - TSS2_BASE_RC_GENERAL_FAILURE */\n        \"Catch all for all errors not otherwise specified\",\n        /* 2 - TSS2_BASE_RC_NOT_IMPLEMENTED */\n        \"If called functionality isn't implemented\",\n        /* 3 - TSS2_BASE_RC_BAD_CONTEXT */\n        \"A context structure is bad\",\n        /* 4 - TSS2_BASE_RC_ABI_MISMATCH */\n        \"Passed in ABI version doesn't match called module's ABI version\",\n        /* 5 - TSS2_BASE_RC_BAD_REFERENCE */\n        \"A pointer is NULL that isn't allowed to be NULL.\",\n        /* 6 - TSS2_BASE_RC_INSUFFICIENT_BUFFER */\n        \"A buffer isn't large enough\",\n        /* 7 - TSS2_BASE_RC_BAD_SEQUENCE */\n        \"Function called in the wrong order\",\n        /* 8 - TSS2_BASE_RC_NO_CONNECTION */\n        \"Fails to connect to next lower layer\",\n        /* 9 - TSS2_BASE_RC_TRY_AGAIN */\n        \"Operation timed out; function must be called again to be completed\",\n        /* 10 - TSS2_BASE_RC_IO_ERROR */\n        \"IO failure\",\n        /* 11 - TSS2_BASE_RC_BAD_VALUE */\n        \"A parameter has a bad value\",\n        /* 12 - TSS2_BASE_RC_NOT_PERMITTED */\n        \"Operation not permitted.\",\n        /* 13 - TSS2_BASE_RC_INVALID_SESSIONS */\n        \"Session structures were sent, but command doesn't use them or doesn't\"\n        \" use the specified number of them\",\n        /* 14 - TSS2_BASE_RC_NO_DECRYPT_PARAM */\n        \"If function called that uses decrypt parameter, but command doesn't\"\n        \" support decrypt parameter.\",\n        /* 15 - TSS2_BASE_RC_NO_ENCRYPT_PARAM */\n        \"If function called that uses encrypt parameter, but command doesn't\"\n        \" support decrypt parameter.\",\n        /* 16 - TSS2_BASE_RC_BAD_SIZE */\n        \"If size of a parameter is incorrect\",\n        /* 17 - TSS2_BASE_RC_MALFORMED_RESPONSE */\n        \"Response is malformed\",\n        /* 18 - TSS2_BASE_RC_INSUFFICIENT_CONTEXT */\n        \"Context not large enough\",\n        /* 19 - TSS2_BASE_RC_INSUFFICIENT_RESPONSE */\n        \"Response is not long enough\",\n        /* 20 - TSS2_BASE_RC_INCOMPATIBLE_TCTI */\n        \"Unknown or unusable TCTI version\",\n        /* 21 - TSS2_BASE_RC_NOT_SUPPORTED */\n        \"Functionality not supported\",\n        /* 22 - TSS2_BASE_RC_BAD_TCTI_STRUCTURE */\n        \"TCTI context is bad\",\n        /* 23 - TSS2_BASE_RC_MEMORY */\n        \"Failed to allocate memory\",\n        /* 24 - TSS2_BASE_RC_BAD_TR */\n        \"The ESYS_TR resource object is bad\",\n        /* 25 - TSS2_BASE_RC_MULTIPLE_DECRYPT_SESSIONS */\n        \"Multiple sessions were marked with attribute decrypt\",\n        /* 26 - TSS2_BASE_RC_MULTIPLE_ENCRYPT_SESSIONS */\n        \"Multiple sessions were marked with attribute encrypt\",\n        /* 27 - TSS2_BASE_RC_RSP_AUTH_FAILED */\n        \"Authorizing the TPM response failed\",\n        /* 28 - TSS2_BASE_RC_NO_CONFIG */\n        \"No config is available\",\n        /* 29 - TSS2_BASE_RC_BAD_PATH */\n        \"The provided path is bad\",\n        /* 30 - TSS2_BASE_RC_NOT_DELETABLE */\n        \"The object is not deletable\",\n        /* 31 - TSS2_BASE_RC_PATH_ALREADY_EXISTS */\n        \"The provided path already exists\",\n        /* 32 - TSS2_BASE_RC_KEY_NOT_FOUND */\n        \"The key was not found\",\n        /* 33 - TSS2_BASE_RC_SIGNATURE_VERIFICATION_FAILED */\n        \"Signature verification failed\",\n        /* 34 - TSS2_BASE_RC_HASH_MISMATCH */\n        \"Hashes mismatch\",\n        /* 35 - TSS2_BASE_RC_KEY_NOT_DUPLICABLE */\n        \"Key is not duplicatable\",\n        /* 36 - TSS2_BASE_RC_PATH_NOT_FOUND */\n        \"The path was not found\",\n        /* 37 - TSS2_BASE_RC_NO_CERT */\n        \"No certificate\",\n        /* 38 - TSS2_BASE_RC_NO_PCR */\n        \"No PCR\",\n        /* 39 - TSS2_BASE_RC_PCR_NOT_RESETTABLE */\n        \"PCR not resettable\",\n        /* 40 - TSS2_BASE_RC_BAD_TEMPLATE */\n        \"The template is bad\",\n        /* 41 - TSS2_BASE_RC_AUTHORIZATION_FAILED */\n        \"Authorization failed\",\n        /* 42 - TSS2_BASE_RC_AUTHORIZATION_UNKNOWN */\n        \"Authorization is unknown\",\n        /* 43 - TSS2_BASE_RC_NV_NOT_READABLE */\n        \"NV is not readable\",\n        /* 44 - TSS2_BASE_RC_NV_TOO_SMALL */\n        \"NV is too small\",\n        /* 45 - TSS2_BASE_RC_NV_NOT_WRITEABLE */\n        \"NV is not writable\",\n        /* 46 - TSS2_BASE_RC_POLICY_UNKNOWN */\n        \"The policy is unknown\",\n        /* 47 - TSS2_BASE_RC_NV_WRONG_TYPE */\n        \"The NV type is wrong\",\n        /* 48 - TSS2_BASE_RC_NAME_ALREADY_EXISTS */\n        \"The name already exists\",\n        /* 49 - TSS2_BASE_RC_NO_TPM */\n        \"No TPM available\",\n        /* 50 - TSS2_BASE_RC_BAD_KEY */\n        \"The key is bad\",\n        /* 51 - TSS2_BASE_RC_NO_HANDLE */\n        \"No handle provided\",\n        /* 52 - TSS2_BASE_RC_NOT_PROVISIONED */\n        \"Provisioning was not executed.\",\n        /* 53 - TSS2_FAPI_RC_ALREADY_PROVISIONED */\n        \"Already provisioned\"\n  };\n\n    return (rc - 1u < ARRAY_LEN(errors)) ? errors[rc - 1u] : NULL;\n}\n\n\nstatic struct {\n    char name[TSS2_ERR_LAYER_NAME_MAX];\n    TSS2_RC_HANDLER handler;\n} layer_handler[TPM2_ERROR_TSS2_RC_LAYER_COUNT] = {\n    ADD_HANDLER(\"tpm\" , tpm2_ehandler),\n    ADD_NULL_HANDLER,                       /* layer 1  is unused */\n    ADD_NULL_HANDLER,                       /* layer 2  is unused */\n    ADD_NULL_HANDLER,                       /* layer 3  is unused */\n    ADD_NULL_HANDLER,                       /* layer 4  is unused */\n    ADD_NULL_HANDLER,                       /* layer 5  is unused */\n    ADD_HANDLER(\"fapi\", tss_err_handler),   /* layer 6  is the fapi rc */\n    ADD_HANDLER(\"esapi\", tss_err_handler),  /* layer 7  is the esapi rc */\n    ADD_HANDLER(\"sys\", tss_err_handler),    /* layer 8  is the sys rc */\n    ADD_HANDLER(\"mu\",  tss_err_handler),    /* layer 9  is the mu rc */\n                                            /* Defaults to the system handler */\n    ADD_HANDLER(\"tcti\", tss_err_handler),   /* layer 10 is the tcti rc */\n                                            /* Defaults to the system handler */\n    ADD_HANDLER(\"rmt\", tpm2_ehandler),      /* layer 11 is the resource manager TPM RC */\n                                            /* The RM usually duplicates TPM responses */\n                                            /* So just default the handler to tpm2. */\n    ADD_HANDLER(\"rm\", NULL),                /* layer 12 is the rm rc */\n    ADD_HANDLER(\"policy\", tss_err_handler), /* layer 13 is the policy rc */\n};\n\n/**\n * If a layer has no handler registered, default to this\n * handler that prints the error number in hex.\n * @param rc\n *  The rc to print the error number of.\n * @return\n *  The string.\n */\nstatic const char *\nunknown_layer_handler(TSS2_RC rc)\n{\n    static __thread char buf[32];\n\n    clearbuf(buf);\n    catbuf(buf, \"0x%X\", tpm2_error_get(rc));\n\n    return buf;\n}\n\n/**\n * Register or unregister a custom layer error handler.\n * @param layer\n *  The layer in which to register a handler for.\n * @param name\n *  A friendly layer name. If the name is NULL or a\n *  length 0 string, then the name is output in base\n *  10 string of the layer number. If the length of\n *  name is greater than 16 characters, then the string\n *  is truncated to 16 characters.\n * @param handler\n *  The handler function to register or NULL to unregister.\n * @return\n *  True on success or False on error.\n */\nTSS2_RC_HANDLER\nTss2_RC_SetHandler(UINT8 layer, const char *name,\n                        TSS2_RC_HANDLER handler)\n{\n    TSS2_RC_HANDLER old = layer_handler[layer].handler;\n\n    layer_handler[layer].handler = handler;\n\n    if (handler && name) {\n        snprintf(layer_handler[layer].name, sizeof(layer_handler[layer].name),\n             \"%s\", name);\n    } else {\n        memset(layer_handler[layer].name, 0, sizeof(layer_handler[layer].name));\n    }\n\n    return old;\n}\n\n/**\n * Given a TSS2_RC return code, provides a static error string in the format:\n * <layer-name>:<layer-specific-msg>.\n *\n * The layer-name section will either be the friendly name, or if no layer\n * handler is registered, the base10 layer number.\n *\n * The \"layer-specific-msg\" is layer specific and will contain details on the\n * error that occurred or the error code if it couldn't look it up.\n *\n * Known layer specific substrings:\n * TPM - The tpm layer produces 2 distinct format codes that align with:\n *   - Section 6.6 of: https://trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-2-Structures-01.38.pdf\n *   - Section 39.4 of: https://trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-1-Architecture-01.38.pdf\n *\n *   The two formats are format 0 and format 1.\n *   Format 0 string format:\n *     - \"<error|warn>(<version>): <description>\n *     - Examples:\n *       - error(1.2): bad tag\n *       - warn(2.0): the 1st handle in the handle area references a transient object or session that is not loaded\n *\n *   Format 1 string format:\n *      - <handle|session|parameter>(<index>):<description>\n *      - Examples:\n *        - handle(unk):value is out of range or is not correct for the context\n *        - tpm:handle(5):value is out of range or is not correct for the context\n *\n *   Note that passing TPM2_RC_SUCCESS results in the layer specific message of \"success\".\n *\n *   The System, TCTI and Marshaling (MU) layers, all define simple string\n *   returns analogous to strerror(3).\n *\n *   Unknown layers will have the layer number in decimal and then a layer specific string of\n *   a hex value representing the error code. For example: 9:0x3\n *\n * @param rc\n *  The error code to decode.\n * @return\n *  A human understandable error description string.\n */\nconst char *\nTss2_RC_Decode(TSS2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_NAME_MAX + TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n\n    clearbuf(buf);\n\n    UINT8 layer = tss2_rc_layer_number_get(rc);\n\n    TSS2_RC_HANDLER handler = layer_handler[layer].handler;\n    const char *lname = layer_handler[layer].name;\n\n    if (lname[0]) {\n        catbuf(buf, \"%s:\", lname);\n    } else {\n        catbuf(buf, \"%u:\", layer);\n    }\n\n    handler = !handler ? unknown_layer_handler : handler;\n\n    /*\n     * Handlers only need the error bits. This way they don't\n     * need to concern themselves with masking off the layer\n     * bits or anything else.\n     */\n    UINT16 err_bits = tpm2_error_get(rc);\n    const char *e = err_bits ? handler(err_bits) : \"success\";\n    if (e) {\n        catbuf(buf, \"%s\", e);\n    } else {\n        catbuf(buf, \"0x%X\", err_bits);\n    }\n\n    return buf;\n}\n\n/** Function to extract information from a response code.\n *\n * This function decodes the different bitfields in TSS2_RC.\n *\n * @param[in]  rc the response code to decode.\n * @param[out] info the structure containing the decoded fields.\n * @retval TSS2_RC_SUCCESS if the function call was a success.\n * @retval TSS2_ESYS_RC_BAD_REFERENCE if info is a NULL pointer.\n */\nTSS2_RC\nTss2_RC_DecodeInfo(TSS2_RC rc, TSS2_RC_INFO *info)\n{\n    UINT8 n;\n\n    if (!info) {\n        return TSS2_BASE_RC_BAD_REFERENCE;\n    }\n\n    memset(info, 0, sizeof(TSS2_RC_INFO));\n\n    info->layer = tss2_rc_layer_number_get(rc);\n    info->format = tss2_rc_layer_format_get(rc);\n\n    if (info->format) {\n        info->error = tpm2_rc_fmt1_error_get(rc) | TPM2_RC_FMT1;\n        n = tpm2_rc_fmt1_N_index_get(rc);\n        if (tpm2_rc_fmt1_P_get(rc)) {\n\t    info->parameter = n;\n        } else if (tpm2_rc_fmt1_N_is_handle(rc)) {\n            info->handle = n;\n        } else {\n          info->session = n;\n        }\n    } else {\n        info->error = tpm2_error_get(rc);\n    }\n\n    return TSS2_RC_SUCCESS;\n}\n\n/** Function to get a human readable error from a TSS2_RC_INFO\n *\n * This function returns the human readable eror for the underlying\n * error, ignoring the layer, parameters, handles and sessions.\n *\n * @param[int] info the structure containing the decoded fields.\n * @retval A human understandable error description string.\n * @retval NULL if info is a NULL pointer.\n */\nconst char *\nTss2_RC_DecodeInfoError(TSS2_RC_INFO *info)\n{\n    static __thread char buf[TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n    const char *m = NULL;\n\n    if (!info) {\n        return NULL;\n    }\n    clearbuf(buf);\n\n    if (info->format) {\n        m = tss2_fmt1_err_strs_get(info->error ^ TPM2_RC_FMT1);\n    } else {\n        m = tss2_fmt0_err_strs_get(info->error ^ TPM2_RC_VER1);\n    }\n\n    if (m) {\n        catbuf(buf, \"%s\", m);\n    } else {\n        catbuf(buf, \"0x%X\", info->error);\n    }\n\n    return buf;\n}\n", "/* SPDX-License-Identifier: BSD-2-Clause */\n\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <setjmp.h>\n#include <cmocka.h>\n\n#include \"tss2_rc.h\"\n#include \"util/aux_util.h\"\n\n#define TPM2_ERROR_TSS2_RC_LAYER_COUNT (TSS2_RC_LAYER_MASK >> TSS2_RC_LAYER_SHIFT)\n\n#define assert_string_prefix(str, prefix) \\\n    assert_memory_equal(str, prefix, strlen(prefix))\n\nstatic void\ntest_layers(void **state)\n{\n    UNUSED(state);\n\n    static const char *known_layers[TPM2_ERROR_TSS2_RC_LAYER_COUNT] = {\n        \"tpm:\",\n        NULL,\n        NULL,\n        NULL,\n        NULL,\n        NULL,\n        \"fapi:\",\n        \"esapi:\",\n        \"sys:\",\n        \"mu:\",\n        \"tcti:\",\n        \"rmt\",\n        \"rm\",\n        \"policy\",\n    };\n\n    UINT8 layer;\n    for (layer = 0; layer < TPM2_ERROR_TSS2_RC_LAYER_COUNT; layer++) {\n        TSS2_RC rc = TSS2_RC_LAYER(layer);\n\n        const char *got = Tss2_RC_Decode(rc);\n\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"%u:\", layer);\n\n        const char *expected = known_layers[layer] ? known_layers[layer] : buf;\n        assert_string_prefix(got, expected);\n    }\n}\n\nstatic void\ntest_tpm_format_0_version2_0_error(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_SEQUENCE);\n    assert_string_equal(m, \"tpm:error(2.0): improper use of a sequence\"\n            \" handle\");\n}\n\nstatic void test_tpm_format_0_version2_0_warn(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_REFERENCE_H0);\n    assert_string_equal(m,\n            \"tpm:warn(2.0): the 1st handle in the handle area references a\"\n                    \" transient object or session that is not loaded\");\n}\n\nstatic void\ntest_tpm2_format_0_unknown(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_NOT_USED + 0x80);\n    assert_string_equal(m, \"tpm:parameter(1):unknown error num: 0x3F\");\n}\n\nstatic void\ntest_tpm_format_1_unk_handle(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_HASH);\n    assert_string_equal(m,\n            \"tpm:handle(unk):hash algorithm not supported or not appropriate\");\n}\n\nstatic void\ntest_tpm_format_1_unk_parameter(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_HASH + TPM2_RC_P);\n    assert_string_equal(m,\n            \"tpm:parameter(unk):hash algorithm not supported or not appropriate\");\n}\n\nstatic void\ntest_tpm_format_1_unk_session(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_HASH + TPM2_RC_S);\n    assert_string_equal(m,\n            \"tpm:session(unk):hash algorithm not supported or not appropriate\");\n}\n\nstatic void\ntest_tpm_format_1_5_handle(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_HASH + TPM2_RC_5);\n    assert_string_equal(m,\n            \"tpm:handle(5):hash algorithm not supported or not appropriate\");\n}\n\nstatic void\ntest_tpm2_format_1_unknown(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_NOT_USED + 0x80);\n    assert_string_equal(m, \"tpm:parameter(1):unknown error num: 0x3F\");\n}\n\nstatic void\ntest_tpm2_format_1_success(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_SUCCESS);\n    assert_string_equal(m, \"tpm:success\");\n}\n\nstatic const char *\ncustom_err_handler(TSS2_RC rc)\n{\n\n    static const char *err_map[] = { \"error 1\", \"error 2\", \"error 3\" };\n\n    if (rc - 1u >= ARRAY_LEN(err_map)) {\n        return NULL;\n    }\n\n    return err_map[rc - 1];\n}\n\nstatic void\ntest_custom_handler(void **state)\n{\n    (void) state;\n\n    /*\n     * Test registering a custom handler\n     */\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(1, \"cstm\", custom_err_handler);\n    assert_null(old);\n\n    /*\n     * Test getting error strings\n     */\n    unsigned i;\n    for (i = 1; i < 4; i++) {\n        // Make a layer 1 error with an error number of i.\n        TSS2_RC rc = TSS2_RC_LAYER(1) | i;\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"cstm:error %u\", i);\n\n        const char *e = Tss2_RC_Decode(rc);\n        assert_string_equal(e, buf);\n    }\n\n    TSS2_RC rc = TSS2_RC_LAYER(1) | 42;\n\n    /*\n     * Test an unknown error\n     */\n    const char *e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"cstm:0x2A\");\n\n    /*\n     * Test clearing a handler\n     */\n    old = Tss2_RC_SetHandler(1, \"cstm\", NULL);\n    assert_ptr_equal(old, custom_err_handler);\n\n    /*\n     * Test an unknown layer\n     */\n    e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"1:0x2A\");\n}\n\nstatic void\ntest_zero_length_name(void **state)\n{\n    (void) state;\n\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(TSS2_TPM_RC_LAYER, \"\",\n            custom_err_handler);\n    assert_non_null(old);\n\n    old = Tss2_RC_SetHandler(TSS2_TPM_RC_LAYER, \"\",\n            custom_err_handler);\n    assert_ptr_equal(old, custom_err_handler);\n}\n\nstatic void\ntest_over_length_name(void **state)\n{\n    (void) state;\n\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(1, \"way to long of name\", custom_err_handler);\n    assert_null(old);\n\n    old = Tss2_RC_SetHandler(1, \"way to long of name\", custom_err_handler);\n    assert_ptr_equal(old, custom_err_handler);\n}\n\nstatic void\ntest_null_name(void **state)\n{\n    (void) state;\n\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(1,\n    NULL, custom_err_handler);\n    assert_ptr_equal(old, custom_err_handler);\n\n    old = Tss2_RC_SetHandler(1,\n                             NULL, custom_err_handler);\n    assert_ptr_equal(old, custom_err_handler);\n}\n\nstatic void\ntest_sys(void **state)\n{\n    (void) state;\n\n    const char *e = Tss2_RC_Decode(TSS2_SYS_RC_ABI_MISMATCH);\n    assert_string_equal(e,\n            \"sys:Passed in ABI version doesn't match called module's ABI version\");\n}\n\nstatic void\ntest_esys(void **state)\n{\n    (void) state;\n\n    const char *e = Tss2_RC_Decode(TSS2_ESYS_RC_BAD_VALUE);\n    assert_string_equal(e,\n            \"esapi:A parameter has a bad value\");\n}\n\nstatic void\ntest_mu(void **state)\n{\n    (void) state;\n\n    const char *e = Tss2_RC_Decode(TSS2_MU_RC_BAD_REFERENCE);\n    assert_string_equal(e,\n            \"mu:A pointer is NULL that isn't allowed to be NULL.\");\n\n}\n\nstatic void\ntest_tcti(void **state)\n{\n    (void) state;\n\n    const char *e = Tss2_RC_Decode(TSS2_TCTI_RC_NO_CONNECTION);\n    assert_string_equal(e, \"tcti:Fails to connect to next lower layer\");\n}\n\nstatic void\ntest_info_fmt0(void **state)\n{\n    TSS2_RC_INFO info = { 1, 2, 3, 4, 5, 6 };\n    TSS2_RC test_rc = TSS2_MU_RC_LAYER | TPM2_RC_SESSION_HANDLES;\n    TSS2_RC r = Tss2_RC_DecodeInfo(test_rc, &info);\n    assert_int_equal(info.layer, 9);\n    assert_int_equal(info.format, 0);\n    assert_int_equal(info.error, TPM2_RC_SESSION_HANDLES);\n    assert_int_equal(info.parameter, 0);\n    assert_int_equal(info.handle, 0);\n    assert_int_equal(info.session, 0);\n    assert_int_equal(r, TSS2_RC_SUCCESS);\n}\n\nstatic void\ntest_info_fmt1_parameter(void **state)\n{\n    TSS2_RC_INFO info;\n    TSS2_RC test_rc = TSS2_SYS_RC_LAYER | TPM2_RC_ASYMMETRIC | TPM2_RC_P | TPM2_RC_1;\n    TSS2_RC r = Tss2_RC_DecodeInfo(test_rc, &info);\n    assert_int_equal(info.layer, 8);\n    assert_int_equal(info.format, 1);\n    assert_int_equal(info.error, TPM2_RC_ASYMMETRIC);\n    assert_int_equal(info.parameter, 1);\n    assert_int_equal(info.handle, 0);\n    assert_int_equal(info.session, 0);\n    assert_int_equal(r, TSS2_RC_SUCCESS);\n}\n\nstatic void\ntest_info_fmt1_handle(void **state)\n{\n    TSS2_RC_INFO info;\n    TSS2_RC test_rc = TSS2_ESAPI_RC_LAYER | TPM2_RC_HANDLE | TPM2_RC_H | TPM2_RC_2;\n    TSS2_RC r = Tss2_RC_DecodeInfo(test_rc, &info);\n    assert_int_equal(info.layer, 7);\n    assert_int_equal(info.error, TPM2_RC_HANDLE);\n    assert_int_equal(info.parameter, 0);\n    assert_int_equal(info.handle, 2);\n    assert_int_equal(info.session, 0);\n    assert_int_equal(r, TSS2_RC_SUCCESS);\n}\n\nstatic void\ntest_info_fmt1_session(void **state)\n{\n    TSS2_RC_INFO info;\n    TSS2_RC test_rc = TSS2_FEATURE_RC_LAYER | TPM2_RC_EXPIRED | TPM2_RC_S | TPM2_RC_3;\n    TSS2_RC r = Tss2_RC_DecodeInfo(test_rc, &info);\n    assert_int_equal(info.layer, 6);\n    assert_int_equal(info.error, TPM2_RC_EXPIRED);\n    assert_int_equal(info.parameter, 0);\n    assert_int_equal(info.handle, 0);\n    assert_int_equal(info.session, 3);\n    assert_int_equal(r, TSS2_RC_SUCCESS);\n}\n\nstatic void\ntest_info_null(void **state)\n{\n    TSS2_RC r = Tss2_RC_DecodeInfo(TSS2_RC_SUCCESS, NULL);\n    assert_int_equal(r, TSS2_BASE_RC_BAD_REFERENCE);\n}\n\nstatic void\ntest_info_str_fmt1(void **state)\n{\n    TSS2_RC_INFO info = {\n        .error = TPM2_RC_EXPIRED,\n        .format = 1,\n    };\n    const char *m = Tss2_RC_DecodeInfoError(&info);\n    assert_string_equal(m, \"the policy has expired\");\n}\n\nstatic void\ntest_info_str_fmt1_ff(void **state)\n{\n    TSS2_RC_INFO info = {\n        .error = 0xFF,\n        .format = 1,\n    };\n    const char *m = Tss2_RC_DecodeInfoError(&info);\n    assert_string_equal(m, \"0xFF\");\n}\n\nstatic void\ntest_info_str_fmt0_err(void **state)\n{\n    TSS2_RC_INFO info = {\n        .error = TPM2_RC_COMMAND_CODE,\n        .format = 0,\n    };\n    const char *m = Tss2_RC_DecodeInfoError(&info);\n    assert_string_equal(m, \"command code not supported\");\n}\n\nstatic void\ntest_info_str_fmt0_warn(void **state)\n{\n    TSS2_RC_INFO info = {\n        .error = TPM2_RC_TESTING,\n        .format = 0,\n    };\n    const char *m = Tss2_RC_DecodeInfoError(&info);\n    assert_string_equal(m, \"TPM is performing selftests\");\n}\n\nstatic void\ntest_info_str_fmt0_ff(void **state)\n{\n    TSS2_RC_INFO info = {\n        .error = 0xFF,\n        .format = 0,\n    };\n    const char *m = Tss2_RC_DecodeInfoError(&info);\n    assert_string_equal(m, \"0xFF\");\n}\n\nstatic void\ntest_info_str_null(void **state)\n{\n    const char *m = Tss2_RC_DecodeInfoError(NULL);\n    assert_null(m);\n}\n\n/* link required symbol, but tpm2_tool.c declares it AND main, which\n * we have a main below for cmocka tests.\n */\nbool output_enabled = true;\n\nint\nmain(int argc, char* argv[])\n{\n    (void) argc;\n    (void) argv;\n\n    const struct CMUnitTest tests[] = {\n            /* Layer tests */\n            cmocka_unit_test(test_layers),\n            cmocka_unit_test(test_tpm_format_0_version2_0_error),\n            cmocka_unit_test(test_tpm_format_0_version2_0_warn),\n            cmocka_unit_test(test_tpm2_format_0_unknown),\n            cmocka_unit_test(test_tpm_format_1_unk_handle),\n            cmocka_unit_test(test_tpm_format_1_unk_parameter),\n            cmocka_unit_test(test_tpm_format_1_unk_session),\n            cmocka_unit_test(test_tpm_format_1_5_handle),\n            cmocka_unit_test(test_tpm2_format_1_unknown),\n            cmocka_unit_test(test_tpm2_format_1_success),\n            cmocka_unit_test(test_custom_handler),\n            cmocka_unit_test(test_zero_length_name),\n            cmocka_unit_test(test_over_length_name),\n            cmocka_unit_test(test_null_name),\n            cmocka_unit_test(test_sys),\n            cmocka_unit_test(test_esys),\n            cmocka_unit_test(test_mu),\n            cmocka_unit_test(test_tcti),\n            cmocka_unit_test(test_info_fmt0),\n            cmocka_unit_test(test_info_fmt1_parameter),\n            cmocka_unit_test(test_info_fmt1_handle),\n            cmocka_unit_test(test_info_fmt1_session),\n            cmocka_unit_test(test_info_null),\n            cmocka_unit_test(test_info_str_fmt1),\n            cmocka_unit_test(test_info_str_fmt1_ff),\n            cmocka_unit_test(test_info_str_fmt0_err),\n            cmocka_unit_test(test_info_str_fmt0_warn),\n            cmocka_unit_test(test_info_str_fmt0_ff),\n            cmocka_unit_test(test_info_str_null),\n    };\n\n    return cmocka_run_group_tests(tests, NULL, NULL);\n}\n"], "fixing_code": ["/* SPDX-License-Identifier: BSD-2-Clause */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <assert.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"tss2_rc.h\"\n#include \"tss2_sys.h\"\n#include \"util/aux_util.h\"\n\n/**\n * The maximum size of a layer name.\n */\n#define TSS2_ERR_LAYER_NAME_MAX  (16 + 1)\n\n/**\n * The maximum size for layer specific error strings.\n */\n#define TSS2_ERR_LAYER_ERROR_STR_MAX  512\n\n/**\n * Concatenates (safely) onto a static buffer given a format and varaidic\n * arguments similar to sprintf.\n * @param b\n *   The static buffer to concatenate onto.\n * @param fmt\n *   The format specifier as understood by printf followed by the variadic\n *   parameters for the specifier.\n */\n#define catbuf(b, fmt, ...) _catbuf(b, sizeof(b), fmt, ##__VA_ARGS__)\n\n/**\n * Clears out a static buffer by setting index 0 to the null byte.\n * @param buffer\n *  The buffer to clear out.\n */\nstatic void\nclearbuf(char *buffer)\n{\n    buffer[0] = '\\0';\n}\n\n/**\n * Prints to a buffer using snprintf(3) using the supplied fmt\n * and varaiadic arguments.\n * @param buf\n *  The buffer to print into.\n * @param len\n *  The length of that buffer.\n * @param fmt\n *  The format string\n * @warning\n *  DO NOT CALL DIRECTLY, use the catbuf() macro.\n */\nstatic void COMPILER_ATTR(format (printf, 3, 4))\n_catbuf(char *buf, size_t len, const char *fmt, ...)\n{\n    va_list argptr;\n    va_start(argptr, fmt);\n    size_t offset = strlen(buf);\n    vsnprintf(&buf[offset], len - offset, fmt, argptr);\n    va_end(argptr);\n}\n\n/**\n * Number of error layers\n */\n#define TPM2_ERROR_TSS2_RC_LAYER_COUNT (TSS2_RC_LAYER_MASK >> TSS2_RC_LAYER_SHIFT)\n\n/**\n * Mask for the error bits of tpm2 compliant return code.\n */\n#define TPM2_ERROR_TSS2_RC_ERROR_MASK 0xFFFF\n\n/**\n * Retrieves the error bits from a TSS2_RC. The error bits are\n * contained in the first 2 octets.\n * @param rc\n *  The rc to query for the error bits.\n * @return\n *  The error bits.\n */\nstatic inline UINT16\ntpm2_error_get(TSS2_RC rc)\n{\n    return ((rc & TPM2_ERROR_TSS2_RC_ERROR_MASK));\n}\n\n/**\n * Retrieves the layer number. The layer number is in the 3rd\n * octet and is thus 1 byte big.\n *\n * @param rc\n *  The rc to query for the layer number.\n * @return\n *  The layer number.\n */\nstatic inline UINT8\ntss2_rc_layer_number_get(TSS2_RC rc)\n{\n    return ((rc & TSS2_RC_LAYER_MASK) >> TSS2_RC_LAYER_SHIFT);\n}\n\n/**\n * Queries a TPM format 1 error codes N field. The N field\n * is a 4 bit field located at bits 8:12.\n * @param rc\n *  The rc to query the N field for.\n * @return\n *  The N field value.\n */\nstatic inline UINT8\ntpm2_rc_fmt1_N_get(TPM2_RC rc)\n{\n    return ((rc & (0xF << 8)) >> 8);\n}\n\n/**\n * Queries the index bits out of the N field contained in a TPM format 1\n * error code. The index bits are the low 3 bits of the N field.\n * @param rc\n *  The TPM format 1 error code to query for the index bits.\n * @return\n *  The index bits from the N field.\n */\nstatic inline UINT8\ntpm2_rc_fmt1_N_index_get(TPM2_RC rc)\n{\n    return (tpm2_rc_fmt1_N_get(rc) & 0x7);\n}\n\n/**\n * Determines if the N field in a TPM format 1 error code is\n * a handle or not.\n * @param rc\n *  The TPM format 1 error code to query.\n * @return\n *  True if it is a handle, false otherwise.\n */\nstatic inline bool\ntpm2_rc_fmt1_N_is_handle(TPM2_RC rc)\n{\n    return ((tpm2_rc_fmt1_N_get(rc) & 0x8) == 0);\n}\n\nstatic inline UINT8\ntpm2_rc_fmt1_P_get(TPM2_RC rc)\n{\n    return ((rc & (1 << 6)) >> 6);\n}\n\nstatic inline UINT8\ntpm2_rc_fmt1_error_get(TPM2_RC rc)\n{\n    return (rc & 0x3F);\n}\n\nstatic inline UINT8\ntpm2_rc_fmt0_error_get(TPM2_RC rc)\n{\n    return (rc & 0x7F);\n}\n\nstatic inline UINT8\ntpm2_rc_tpm_fmt0_V_get(TPM2_RC rc)\n{\n    return ((rc & (1 << 8)) >> 8);\n}\n\nstatic inline UINT8\ntpm2_rc_fmt0_T_get(TPM2_RC rc)\n{\n    return ((rc & (1 << 10)) >> 8);\n}\n\nstatic inline UINT8\ntpm2_rc_fmt0_S_get(TSS2_RC rc)\n{\n    return ((rc & (1 << 11)) >> 8);\n}\n\n/**\n * Helper macro for adding a layer handler to the layer\n * registration array.\n */\n#define ADD_HANDLER(name, handler) \\\n    { name, handler }\n\n/**\n * Same as ADD_HANDLER but sets it to NULL. Used as a placeholder\n * for non-registered indexes into the handler array.\n */\n#define ADD_NULL_HANDLER ADD_HANDLER(\"\\0\", NULL)\n\nconst char *\ntss2_fmt1_err_strs_get(TSS2_RC error)\n{\n    /*\n     * format 1 error codes start at 1, so\n     * add a NULL entry to index 0.\n     */\n    static const char *fmt1_err_strs[] = {\n        /* 0x0 - EMPTY */\n        NULL,\n        /* 0x1 - TPM2_RC_ASYMMETRIC */\n        \"asymmetric algorithm not supported or not correct\",\n        /* 0x2 - TPM2_RC_ATTRIBUTES */\n        \"inconsistent attributes\",\n        /* 0x3 - TPM2_RC_HASH */\n        \"hash algorithm not supported or not appropriate\",\n        /* 0x4 - TPM2_RC_VALUE */\n        \"value is out of range or is not correct for the context\",\n        /* 0x5 - TPM2_RC_HIERARCHY */\n        \"hierarchy is not enabled or is not correct for the use\",\n        /* 0x6 - EMPTY */\n        NULL,\n        /* 0x7 - TPM2_RC_KEY_SIZE */\n        \"key size is not supported\",\n        /* 0x8 - TPM2_RC_MGF */\n        \"mask generation function not supported\",\n        /* 0x9 - TPM2_RC_MODE */\n        \"mode of operation not supported\",\n        /* 0xA - TPM2_RC_TYPE */\n        \"the type of the value is not appropriate for the use\",\n        /* 0xB - TPM2_RC_HANDLE */\n        \"the handle is not correct for the use\",\n        /* 0xC - TPM2_RC_KDF */\n        \"unsupported key derivation function or function not appropriate for \"\n        \"use\",\n        /* 0xD - TPM2_RC_RANGE */\n        \"value was out of allowed range\",\n        /* 0xE - TPM2_RC_AUTH_FAIL */\n        \"the authorization HMAC check failed and DA counter incremented\",\n        /* 0xF - TPM2_RC_NONCE */\n        \"invalid nonce size or nonce value mismatch\",\n        /* 0x10 - TPM2_RC_PP */\n        \"authorization requires assertion of PP\",\n        /* 0x11 - EMPTY */\n        NULL,\n        /* 0x12 - TPM2_RC_SCHEME */\n        \"unsupported or incompatible scheme\",\n        /* 0x13 - EMPTY */\n        NULL,\n        /* 0x14 - EMPTY */\n        NULL,\n        /* 0x15 - TPM2_RC_SIZE */\n        \"structure is the wrong size\",\n        /* 0x16 - TPM2_RC_SYMMETRIC */\n        \"unsupported symmetric algorithm or key size or not appropriate for\"\n        \" instance\",\n        /* 0x17 - TPM2_RC_TAG */\n        \"incorrect structure tag\",\n        /* 0x18 - TPM2_RC_SELECTOR */\n        \"union selector is incorrect\",\n        /* 0x19 - EMPTY */\n        NULL,\n        /* 0x1A - TPM2_RC_INSUFFICIENT */\n        \"the TPM was unable to unmarshal a value because there were not enough\"\n        \" octets in the input buffer\",\n        /* 0x1B - TPM2_RC_SIGNATURE */\n        \"the signature is not valid\",\n        /* 0x1C - TPM2_RC_KEY */\n        \"key fields are not compatible with the selected use\",\n        /* 0x1D - TPM2_RC_POLICY_FAIL */\n        \"a policy check failed\",\n        /* 0x1E - EMPTY */\n        NULL,\n        /* 0x1F - TPM2_RC_INTEGRITY */\n        \"integrity check failed\",\n        /* 0x20 - TPM2_RC_TICKET */\n        \"invalid ticket\",\n        /* 0x21 - TPM2_RC_RESERVED_BITS */\n        \"reserved bits not set to zero as required\",\n        /* 0x22 - TPM2_RC_BAD_AUTH */\n        \"authorization failure without DA implications\",\n        /* 0x23 - TPM2_RC_EXPIRED */\n        \"the policy has expired\",\n        /* 0x24 - TPM2_RC_POLICY_CC */\n        \"the commandCode in the policy is not the commandCode of the command\"\n        \" or the command code in a policy command references a command that\"\n        \" is not implemented\",\n        /* 0x25 - TPM2_RC_BINDING */\n        \"public and sensitive portions of an object are not cryptographically bound\",\n        /* 0x26 - TPM2_RC_CURVE */\n        \"curve not supported\",\n        /* 0x27 - TPM2_RC_ECC_POINT */\n        \"point is not on the required curve\",\n    };\n\n    if (error < ARRAY_LEN(fmt1_err_strs)) {\n        return fmt1_err_strs[error];\n    }\n\n    return NULL;\n}\n\nconst char *\ntss2_fmt0_err_strs_get(TSS2_RC rc)\n{\n    /*\n     * format 0 error codes start at 1, so\n     * add a NULL entry to index 0.\n     * Thus, no need to offset the error bits\n     * and fmt0 and fmt1 arrays can be used\n     * in-place of each other for lookups.\n     */\n    static const char *fmt0_warn_strs[] = {\n            /* 0x0 - EMPTY */\n            NULL,\n            /* 0x1 - TPM2_RC_CONTEXT_GAP */\n            \"gap for context ID is too large\",\n            /* 0x2 - TPM2_RC_OBJECT_MEMORY */\n            \"out of memory for object contexts\",\n            /* 0x3 - TPM2_RC_SESSION_MEMORY */\n            \"out of memory for session contexts\",\n            /* 0x4 - TPM2_RC_MEMORY */\n            \"out of shared objectsession memory or need space for internal\"\n            \" operations\",\n            /* 0x5 - TPM2_RC_SESSION_HANDLES */\n            \"out of session handles\",\n            /* 0x6 - TPM2_RC_OBJECT_HANDLES */\n            \"out of object handles\",\n            /* 0x7 - TPM2_RC_LOCALITY */\n            \"bad locality\",\n            /* 0x8 - TPM2_RC_YIELDED */\n            \"the TPM has suspended operation on the command forward progress\"\n            \" was made and the command may be retried\",\n            /* 0x9 - TPM2_RC_CANCELED */\n            \"the command was canceled\",\n            /* 0xA - TPM2_RC_TESTING */\n            \"TPM is performing selftests\",\n            /* 0xB - EMPTY */\n            NULL,\n            /* 0xC - EMPTY */\n            NULL,\n            /* 0xD - EMPTY */\n            NULL,\n            /* 0xE - EMPTY */\n            NULL,\n            /* 0xF - EMPTY */\n            NULL,\n            /* 0x10 - TPM2_RC_REFERENCE_H0 */\n            \"the 1st handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x11 - TPM2_RC_REFERENCE_H1 */\n            \"the 2nd handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x12 - TPM2_RC_REFERENCE_H2 */\n            \"the 3rd handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x13 - TPM2_RC_REFERENCE_H3 */\n            \"the 4th handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x14 - TPM2_RC_REFERENCE_H4 */\n            \"the 5th handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x15 - TPM2_RC_REFERENCE_H5 */\n            \"the 6th handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x16 - TPM2_RC_REFERENCE_H6 */\n            \"the 7th handle in the handle area references a transient object\"\n            \" or session that is not loaded\",\n            /* 0x17 - EMPTY, */\n            NULL,\n            /* 0x18 - TPM2_RC_REFERENCE_S0 */\n            \"the 1st authorization session handle references a session that\"\n            \" is not loaded\",\n            /* 0x19 - TPM2_RC_REFERENCE_S1 */\n            \"the 2nd authorization session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1A - TPM2_RC_REFERENCE_S2 */\n            \"the 3rd authorization session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1B - TPM2_RC_REFERENCE_S3 */\n            \"the 4th authorization session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1C - TPM2_RC_REFERENCE_S4 */\n            \"the 5th session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1D - TPM2_RC_REFERENCE_S5 */\n            \"the 6th session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1E - TPM2_RC_REFERENCE_S6 */\n            \"the 7th authorization session handle references a session that\"\n            \" is not loaded\",\n            /* 0x1F - EMPTY, */\n            NULL,\n            /* 0x20 -TPM2_RC_NV_RATE */\n            \"the TPM is rate limiting accesses to prevent wearout of NV\",\n            /* 0x21 - TPM2_RC_LOCKOUT */\n            \"authorizations for objects subject to DA protection are not\"\n            \" allowed at this time because the TPM is in DA lockout mode\",\n            /* 0x22 - TPM2_RC_RETRY */\n            \"the TPM was not able to start the command\",\n            /* 0x23 - TPM2_RC_NV_UNAVAILABLE */\n            \"the command may require writing of NV and NV is not current\"\n            \" accessible\",\n    };\n\n    /*\n     * format 1 error codes start at 0, so\n     * no need to offset the error bits.\n     */\n    static const char *fmt0_err_strs[] = {\n        /* 0x0 - TPM2_RC_INITIALIZE */\n        \"TPM not initialized by TPM2_Startup or already initialized\",\n        /* 0x1 - TPM2_RC_FAILURE */\n        \"commands not being accepted because of a TPM failure\",\n        /* 0x2 - EMPTY */\n        NULL,\n        /* 0x3 - TPM2_RC_SEQUENCE */\n        \"improper use of a sequence handle\",\n        /* 0x4 - EMPTY */\n        NULL,\n        /* 0x5 - EMPTY */\n        NULL,\n        /* 0x6 - EMPTY */\n        NULL,\n        /* 0x7 - EMPTY */\n        NULL,\n        /* 0x8 - EMPTY */\n        NULL,\n        /* 0x9 - EMPTY */\n        NULL,\n        /* 0xA - EMPTY */\n        NULL,\n        /* 0xB - TPM2_RC_PRIVATE */\n        \"not currently used\",\n        /* 0xC - EMPTY */\n        NULL,\n        /* 0xD - EMPTY */\n        NULL,\n        /* 0xE - EMPTY */\n        NULL,\n        /* 0xF - EMPTY */\n        NULL,\n        /* 0x10 - EMPTY */\n        NULL,\n        /* 0x11 - EMPTY */\n        NULL,\n        /* 0x12 - EMPTY */\n        NULL,\n        /* 0x13 - EMPTY */\n        NULL,\n        /* 0x14 - EMPTY */\n        NULL,\n        /* 0x15 - EMPTY */\n        NULL,\n        /* 0x16 - EMPTY */\n        NULL,\n        /* 0x17 - EMPTY */\n        NULL,\n        /* 0x18 - EMPTY */\n        NULL,\n        /* 0x19 - TPM2_RC_HMAC */\n        \"not currently used\",\n        /* 0x1A - EMPTY */\n        NULL,\n        /* 0x1B - EMPTY */\n        NULL,\n        /* 0x1C - EMPTY */\n        NULL,\n        /* 0x1D - EMPTY */\n        NULL,\n        /* 0x1E - EMPTY */\n        NULL,\n        /* 0x1F - EMPTY */\n        NULL,\n        /* 0x20 - TPM2_RC_DISABLED */\n        \"the command is disabled\",\n        /* 0x21 - TPM2_RC_EXCLUSIVE */\n        \"command failed because audit sequence required exclusivity\",\n        /* 0x22 - EMPTY */\n        NULL,\n        /* 0x23 - EMPTY, */\n        NULL,\n        /* 0x24 - TPM2_RC_AUTH_TYPE */\n        \"authorization handle is not correct for command\",\n        /* 0x25 - TPM2_RC_AUTH_MISSING */\n        \"command requires an authorization session for handle and it is\"\n        \" not present\",\n        /* 0x26 - TPM2_RC_POLICY */\n        \"policy failure in math operation or an invalid authPolicy value\",\n        /* 0x27 - TPM2_RC_PCR */\n        \"PCR check fail\",\n        /* 0x28 - TPM2_RC_PCR_CHANGED */\n        \"PCR have changed since checked\",\n        /* 0x29 - EMPTY */\n        NULL,\n        /* 0x2A - EMPTY */\n        NULL,\n        /* 0x2B - EMPTY */\n        NULL,\n        /* 0x2C - EMPTY */\n        NULL,\n        /* 0x2D - TPM2_RC_UPGRADE */\n        \"For all commands, other than TPM2_FieldUpgradeData, \"\n        \"this code indicates that the TPM is in field upgrade mode. \"\n        \"For TPM2_FieldUpgradeData, this code indicates that the TPM \"\n        \"is not in field upgrade mode\",\n        /* 0x2E - TPM2_RC_TOO_MANY_CONTEXTS */\n        \"context ID counter is at maximum\",\n        /* 0x2F - TPM2_RC_AUTH_UNAVAILABLE */\n        \"authValue or authPolicy is not available for selected entity\",\n        /* 0x30 - TPM2_RC_REBOOT */\n        \"a _TPM_Init and StartupCLEAR is required before the TPM can\"\n        \" resume operation\",\n        /* 0x31 - TPM2_RC_UNBALANCED */\n        \"the protection algorithms hash and symmetric are not reasonably\"\n        \" balanced. The digest size of the hash must be larger than the key\"\n        \" size of the symmetric algorithm.\",\n        /* 0x32 - EMPTY */\n        NULL,\n        /* 0x33 - EMPTY */\n        NULL,\n        /* 0x34 - EMPTY */\n        NULL,\n        /* 0x35 - EMPTY */\n        NULL,\n        /* 0x36 - EMPTY */\n        NULL,\n        /* 0x37 - EMPTY */\n        NULL,\n        /* 0x38 - EMPTY */\n        NULL,\n        /* 0x39 - EMPTY */\n        NULL,\n        /* 0x3A - EMPTY */\n        NULL,\n        /* 0x3B - EMPTY */\n        NULL,\n        /* 0x3C - EMPTY */\n        NULL,\n        /* 0x3D - EMPTY */\n        NULL,\n        /* 0x3E - EMPTY */\n        NULL,\n        /* 0x3F - EMPTY */\n        NULL,\n        /* 0x40 - EMPTY */\n        NULL,\n        /* 0x41 - EMPTY */\n        NULL,\n        /* 0x42 - TPM2_RC_COMMAND_SIZE */\n        \"command commandSize value is inconsistent with contents of the\"\n        \" command buffer. Either the size is not the same as the octets\"\n        \" loaded by the hardware interface layer or the value is not large\"\n        \" enough to hold a command header\",\n        /* 0x43 - TPM2_RC_COMMAND_CODE */\n        \"command code not supported\",\n        /* 0x44 - TPM2_RC_AUTHSIZE */\n        \"the value of authorizationSize is out of range or the number of\"\n        \" octets in the Authorization Area is greater than required\",\n        /* 0x45 - TPM2_RC_AUTH_CONTEXT */\n        \"use of an authorization session with a context command or another\"\n        \" command that cannot have an authorization session\",\n        /* 0x46 - TPM2_RC_NV_RANGE */\n        \"NV offset+size is out of range\",\n        /* 0x47 - TPM2_RC_NV_SIZE */\n        \"Requested allocation size is larger than allowed\",\n        /* 0x48 - TPM2_RC_NV_LOCKED */\n        \"NV access locked\",\n        /* 0x49 - TPM2_RC_NV_AUTHORIZATION */\n        \"NV access authorization fails in command actions\",\n        /* 0x4A - TPM2_RC_NV_UNINITIALIZED */\n        \"an NV Index is used before being initialized or the state saved\"\n        \" by TPM2_ShutdownSTATE could not be restored\",\n        /* 0x4B - TPM2_RC_NV_SPACE */\n        \"insufficient space for NV allocation\",\n        /* 0x4C - TPM2_RC_NV_DEFINED */\n        \"NV Index or persistent object already defined\",\n        /* 0x4D - EMPTY */\n        NULL,\n        /* 0x4E - EMPTY */\n        NULL,\n        /* 0x4F - EMPTY */\n        NULL,\n        /* 0x50 - TPM2_RC_BAD_CONTEXT */\n        \"context in TPM2_ContextLoad is not valid\",\n        /* 0x51 - TPM2_RC_CPHASH */\n        \"cpHash value already set or not correct for use\",\n        /* 0x52 - TPM2_RC_PARENT */\n        \"handle for parent is not a valid parent\",\n        /* 0x53 - TPM2_RC_NEEDS_TEST */\n        \"some function needs testing\",\n        /* 0x54 - TPM2_RC_NO_RESULT */\n        \"returned when an internal function cannot process a request due to\"\n        \" an unspecified problem. This code is usually related to invalid\"\n        \" parameters that are not properly filtered by the input\"\n        \" unmarshaling code\",\n        /* 0x55 - TPM2_RC_SENSITIVE */\n        \"the sensitive area did not unmarshal correctly after decryption\",\n    };\n\n    UINT8 errnum = tpm2_rc_fmt0_error_get(rc);\n    /* is it a warning (version 2 error string) or is it a 1.2 error? */\n    size_t len = tpm2_rc_fmt0_S_get(rc) ? ARRAY_LEN(fmt0_warn_strs) : ARRAY_LEN(fmt0_err_strs);\n    const char **selection = tpm2_rc_fmt0_S_get(rc) ? fmt0_warn_strs : fmt0_err_strs;\n    if (errnum >= len) {\n        return NULL;\n    }\n\n    return selection[errnum];\n}\n\nstatic const char *\ntpm2_err_handler_fmt1(TPM2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n\n    clearbuf(buf);\n\n    /* Print whether or not the error is caused by a bad\n     * handle or parameter. On the case of a Handle (P == 0)\n     * then the N field top bit will be set. Un-set this bit\n     * to get the handle index by subtracting 8 as N is a 4\n     * bit field.\n     *\n     * the lower 3 bits of N indicate index, and the high bit\n     * indicates\n     */\n    UINT8 index = tpm2_rc_fmt1_N_index_get(rc);\n\n    bool is_handle = tpm2_rc_fmt1_N_is_handle(rc);\n    const char *m = tpm2_rc_fmt1_P_get(rc) ? \"parameter\" :\n                    is_handle ? \"handle\" : \"session\";\n    catbuf(buf, \"%s\", m);\n\n    if (index) {\n        catbuf(buf, \"(%u):\", index);\n    } else {\n        catbuf(buf, \"%s\", \"(unk):\");\n    }\n\n    UINT8 errnum = tpm2_rc_fmt1_error_get(rc);\n    m = tss2_fmt1_err_strs_get(errnum);\n    if (m) {\n        catbuf(buf, \"%s\", m);\n    } else {\n        catbuf(buf, \"unknown error num: 0x%X\", errnum);\n    }\n\n    return buf;\n}\n\nstatic const char *\ntpm2_err_handler_fmt0(TSS2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n\n    clearbuf(buf);\n\n    char *e = tpm2_rc_fmt0_S_get(rc) ? \"warn\" : \"error\";\n    char *v = tpm2_rc_tpm_fmt0_V_get(rc) ? \"2.0\" : \"1.2\";\n    catbuf(buf, \"%s(%s): \", e, v);\n\n    UINT8 errnum = tpm2_rc_fmt0_error_get(rc);\n    /* We only have version 2.0 spec codes defined */\n    if (tpm2_rc_tpm_fmt0_V_get(rc)) {\n        /* TCG specific error code */\n        if (tpm2_rc_fmt0_T_get(rc)) {\n            catbuf(buf, \"Vendor specific error: 0x%X\", errnum);\n            return buf;\n        }\n\n        const char *m = tss2_fmt0_err_strs_get(rc);\n        if (!m) {\n            return NULL;\n        }\n\n        catbuf(buf, \"%s\", m);\n        return buf;\n    }\n\n    catbuf(buf, \"%s\", \"unknown version 1.2 error code\");\n\n    return buf;\n}\n\n/**\n * Retrieves the layer field from a TSS2_RC code.\n * @param rc\n *  The rc to query the layer index of.\n * @return\n *  The layer index.\n */\nstatic inline UINT8\ntss2_rc_layer_format_get(TSS2_RC rc)\n{\n    return ((rc & (1 << 7)) >> 7);\n}\n\n/**\n * Handler for tpm2 error codes. ie codes\n * coming from the tpm layer aka layer 0.\n * @param rc\n *  The rc to decode.\n * @return\n *  An error string.\n */\nstatic const char *\ntpm2_ehandler(TSS2_RC rc)\n{\n    bool is_fmt_1 = tss2_rc_layer_format_get(rc);\n\n    return is_fmt_1 ? tpm2_err_handler_fmt1(rc) : tpm2_err_handler_fmt0(rc);\n}\n\n/**\n * The default system code handler. This handles codes\n * from the RM (itself and simulated tpm responses), the marshaling\n * library (mu), the tcti layers, sapi, esys and fapi.\n * @param rc\n *  The rc to decode.\n * @return\n *  An error string.\n */\nstatic const char *\ntss_err_handler (TSS2_RC rc)\n{\n    /*\n     * subtract 1 from the error number\n     * before indexing into this array.\n     *\n     * Commented offsets are for the corresponding\n     * error number *before* subtraction. Ie error\n     * number 4 is at array index 3.\n     */\n    static const char *errors[] =   {\n        /* 1 - TSS2_BASE_RC_GENERAL_FAILURE */\n        \"Catch all for all errors not otherwise specified\",\n        /* 2 - TSS2_BASE_RC_NOT_IMPLEMENTED */\n        \"If called functionality isn't implemented\",\n        /* 3 - TSS2_BASE_RC_BAD_CONTEXT */\n        \"A context structure is bad\",\n        /* 4 - TSS2_BASE_RC_ABI_MISMATCH */\n        \"Passed in ABI version doesn't match called module's ABI version\",\n        /* 5 - TSS2_BASE_RC_BAD_REFERENCE */\n        \"A pointer is NULL that isn't allowed to be NULL.\",\n        /* 6 - TSS2_BASE_RC_INSUFFICIENT_BUFFER */\n        \"A buffer isn't large enough\",\n        /* 7 - TSS2_BASE_RC_BAD_SEQUENCE */\n        \"Function called in the wrong order\",\n        /* 8 - TSS2_BASE_RC_NO_CONNECTION */\n        \"Fails to connect to next lower layer\",\n        /* 9 - TSS2_BASE_RC_TRY_AGAIN */\n        \"Operation timed out; function must be called again to be completed\",\n        /* 10 - TSS2_BASE_RC_IO_ERROR */\n        \"IO failure\",\n        /* 11 - TSS2_BASE_RC_BAD_VALUE */\n        \"A parameter has a bad value\",\n        /* 12 - TSS2_BASE_RC_NOT_PERMITTED */\n        \"Operation not permitted.\",\n        /* 13 - TSS2_BASE_RC_INVALID_SESSIONS */\n        \"Session structures were sent, but command doesn't use them or doesn't\"\n        \" use the specified number of them\",\n        /* 14 - TSS2_BASE_RC_NO_DECRYPT_PARAM */\n        \"If function called that uses decrypt parameter, but command doesn't\"\n        \" support decrypt parameter.\",\n        /* 15 - TSS2_BASE_RC_NO_ENCRYPT_PARAM */\n        \"If function called that uses encrypt parameter, but command doesn't\"\n        \" support decrypt parameter.\",\n        /* 16 - TSS2_BASE_RC_BAD_SIZE */\n        \"If size of a parameter is incorrect\",\n        /* 17 - TSS2_BASE_RC_MALFORMED_RESPONSE */\n        \"Response is malformed\",\n        /* 18 - TSS2_BASE_RC_INSUFFICIENT_CONTEXT */\n        \"Context not large enough\",\n        /* 19 - TSS2_BASE_RC_INSUFFICIENT_RESPONSE */\n        \"Response is not long enough\",\n        /* 20 - TSS2_BASE_RC_INCOMPATIBLE_TCTI */\n        \"Unknown or unusable TCTI version\",\n        /* 21 - TSS2_BASE_RC_NOT_SUPPORTED */\n        \"Functionality not supported\",\n        /* 22 - TSS2_BASE_RC_BAD_TCTI_STRUCTURE */\n        \"TCTI context is bad\",\n        /* 23 - TSS2_BASE_RC_MEMORY */\n        \"Failed to allocate memory\",\n        /* 24 - TSS2_BASE_RC_BAD_TR */\n        \"The ESYS_TR resource object is bad\",\n        /* 25 - TSS2_BASE_RC_MULTIPLE_DECRYPT_SESSIONS */\n        \"Multiple sessions were marked with attribute decrypt\",\n        /* 26 - TSS2_BASE_RC_MULTIPLE_ENCRYPT_SESSIONS */\n        \"Multiple sessions were marked with attribute encrypt\",\n        /* 27 - TSS2_BASE_RC_RSP_AUTH_FAILED */\n        \"Authorizing the TPM response failed\",\n        /* 28 - TSS2_BASE_RC_NO_CONFIG */\n        \"No config is available\",\n        /* 29 - TSS2_BASE_RC_BAD_PATH */\n        \"The provided path is bad\",\n        /* 30 - TSS2_BASE_RC_NOT_DELETABLE */\n        \"The object is not deletable\",\n        /* 31 - TSS2_BASE_RC_PATH_ALREADY_EXISTS */\n        \"The provided path already exists\",\n        /* 32 - TSS2_BASE_RC_KEY_NOT_FOUND */\n        \"The key was not found\",\n        /* 33 - TSS2_BASE_RC_SIGNATURE_VERIFICATION_FAILED */\n        \"Signature verification failed\",\n        /* 34 - TSS2_BASE_RC_HASH_MISMATCH */\n        \"Hashes mismatch\",\n        /* 35 - TSS2_BASE_RC_KEY_NOT_DUPLICABLE */\n        \"Key is not duplicatable\",\n        /* 36 - TSS2_BASE_RC_PATH_NOT_FOUND */\n        \"The path was not found\",\n        /* 37 - TSS2_BASE_RC_NO_CERT */\n        \"No certificate\",\n        /* 38 - TSS2_BASE_RC_NO_PCR */\n        \"No PCR\",\n        /* 39 - TSS2_BASE_RC_PCR_NOT_RESETTABLE */\n        \"PCR not resettable\",\n        /* 40 - TSS2_BASE_RC_BAD_TEMPLATE */\n        \"The template is bad\",\n        /* 41 - TSS2_BASE_RC_AUTHORIZATION_FAILED */\n        \"Authorization failed\",\n        /* 42 - TSS2_BASE_RC_AUTHORIZATION_UNKNOWN */\n        \"Authorization is unknown\",\n        /* 43 - TSS2_BASE_RC_NV_NOT_READABLE */\n        \"NV is not readable\",\n        /* 44 - TSS2_BASE_RC_NV_TOO_SMALL */\n        \"NV is too small\",\n        /* 45 - TSS2_BASE_RC_NV_NOT_WRITEABLE */\n        \"NV is not writable\",\n        /* 46 - TSS2_BASE_RC_POLICY_UNKNOWN */\n        \"The policy is unknown\",\n        /* 47 - TSS2_BASE_RC_NV_WRONG_TYPE */\n        \"The NV type is wrong\",\n        /* 48 - TSS2_BASE_RC_NAME_ALREADY_EXISTS */\n        \"The name already exists\",\n        /* 49 - TSS2_BASE_RC_NO_TPM */\n        \"No TPM available\",\n        /* 50 - TSS2_BASE_RC_BAD_KEY */\n        \"The key is bad\",\n        /* 51 - TSS2_BASE_RC_NO_HANDLE */\n        \"No handle provided\",\n        /* 52 - TSS2_BASE_RC_NOT_PROVISIONED */\n        \"Provisioning was not executed.\",\n        /* 53 - TSS2_FAPI_RC_ALREADY_PROVISIONED */\n        \"Already provisioned\"\n  };\n\n    return (rc - 1u < ARRAY_LEN(errors)) ? errors[rc - 1u] : NULL;\n}\n\n\nstatic struct {\n    char name[TSS2_ERR_LAYER_NAME_MAX];\n    TSS2_RC_HANDLER handler;\n} layer_handler[TPM2_ERROR_TSS2_RC_LAYER_COUNT + 1] = {\n    ADD_HANDLER(\"tpm\" , tpm2_ehandler),\n    ADD_NULL_HANDLER,                       /* layer 1  is unused */\n    ADD_NULL_HANDLER,                       /* layer 2  is unused */\n    ADD_NULL_HANDLER,                       /* layer 3  is unused */\n    ADD_NULL_HANDLER,                       /* layer 4  is unused */\n    ADD_NULL_HANDLER,                       /* layer 5  is unused */\n    ADD_HANDLER(\"fapi\", tss_err_handler),   /* layer 6  is the fapi rc */\n    ADD_HANDLER(\"esapi\", tss_err_handler),  /* layer 7  is the esapi rc */\n    ADD_HANDLER(\"sys\", tss_err_handler),    /* layer 8  is the sys rc */\n    ADD_HANDLER(\"mu\",  tss_err_handler),    /* layer 9  is the mu rc */\n                                            /* Defaults to the system handler */\n    ADD_HANDLER(\"tcti\", tss_err_handler),   /* layer 10 is the tcti rc */\n                                            /* Defaults to the system handler */\n    ADD_HANDLER(\"rmt\", tpm2_ehandler),      /* layer 11 is the resource manager TPM RC */\n                                            /* The RM usually duplicates TPM responses */\n                                            /* So just default the handler to tpm2. */\n    ADD_HANDLER(\"rm\", NULL),                /* layer 12 is the rm rc */\n    ADD_HANDLER(\"policy\", tss_err_handler), /* layer 13 is the policy rc */\n};\n\n/**\n * If a layer has no handler registered, default to this\n * handler that prints the error number in hex.\n * @param rc\n *  The rc to print the error number of.\n * @return\n *  The string.\n */\nstatic const char *\nunknown_layer_handler(TSS2_RC rc)\n{\n    static __thread char buf[32];\n\n    clearbuf(buf);\n    catbuf(buf, \"0x%X\", rc);\n\n    return buf;\n}\n\n/**\n * Register or unregister a custom layer error handler.\n * @param layer\n *  The layer in which to register a handler for.\n * @param name\n *  A friendly layer name. If the name is NULL or a\n *  length 0 string, then the name is output in base\n *  10 string of the layer number. If the length of\n *  name is greater than 16 characters, then the string\n *  is truncated to 16 characters.\n * @param handler\n *  The handler function to register or NULL to unregister.\n * @return\n *  True on success or False on error.\n */\nTSS2_RC_HANDLER\nTss2_RC_SetHandler(UINT8 layer, const char *name,\n                        TSS2_RC_HANDLER handler)\n{\n    TSS2_RC_HANDLER old = layer_handler[layer].handler;\n\n    layer_handler[layer].handler = handler;\n\n    if (handler && name) {\n        snprintf(layer_handler[layer].name, sizeof(layer_handler[layer].name),\n             \"%s\", name);\n    } else {\n        memset(layer_handler[layer].name, 0, sizeof(layer_handler[layer].name));\n    }\n\n    return old;\n}\n\n/**\n * Given a TSS2_RC return code, provides a static error string in the format:\n * <layer-name>:<layer-specific-msg>.\n *\n * The layer-name section will either be the friendly name, or if no layer\n * handler is registered, the base10 layer number.\n *\n * The \"layer-specific-msg\" is layer specific and will contain details on the\n * error that occurred or the error code if it couldn't look it up.\n *\n * Known layer specific substrings:\n * TPM - The tpm layer produces 2 distinct format codes that align with:\n *   - Section 6.6 of: https://trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-2-Structures-01.38.pdf\n *   - Section 39.4 of: https://trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-1-Architecture-01.38.pdf\n *\n *   The two formats are format 0 and format 1.\n *   Format 0 string format:\n *     - \"<error|warn>(<version>): <description>\n *     - Examples:\n *       - error(1.2): bad tag\n *       - warn(2.0): the 1st handle in the handle area references a transient object or session that is not loaded\n *\n *   Format 1 string format:\n *      - <handle|session|parameter>(<index>):<description>\n *      - Examples:\n *        - handle(unk):value is out of range or is not correct for the context\n *        - tpm:handle(5):value is out of range or is not correct for the context\n *\n *   Note that passing TPM2_RC_SUCCESS results in the layer specific message of \"success\".\n *\n *   The System, TCTI and Marshaling (MU) layers, all define simple string\n *   returns analogous to strerror(3).\n *\n *   Unknown layers will have the layer number in decimal and then a layer specific string of\n *   a hex value representing the error code. For example: 9:0x3\n *\n * @param rc\n *  The error code to decode.\n * @return\n *  A human understandable error description string.\n */\nconst char *\nTss2_RC_Decode(TSS2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_NAME_MAX + TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n\n    clearbuf(buf);\n\n    UINT8 layer = tss2_rc_layer_number_get(rc);\n\n    TSS2_RC_HANDLER handler = layer_handler[layer].handler;\n    const char *lname = layer_handler[layer].name;\n\n    if (lname[0]) {\n        catbuf(buf, \"%s:\", lname);\n    } else {\n        catbuf(buf, \"%u:\", layer);\n    }\n\n    /*\n     * Handlers only need the error bits. This way they don't\n     * need to concern themselves with masking off the layer\n     * bits or anything else.\n     */\n    if (handler) {\n        UINT16 err_bits = tpm2_error_get(rc);\n        const char *e = err_bits ? handler(err_bits) : \"success\";\n        if (e) {\n            catbuf(buf, \"%s\", e);\n        } else {\n            catbuf(buf, \"0x%X\", err_bits);\n        }\n    } else {\n        /*\n         * we don't want to drop any bits if we don't know what to do with it\n         * so drop the layer byte since we we already have that.\n         */\n        const char *e = unknown_layer_handler(rc >> 8);\n        assert(e);\n        catbuf(buf, \"%s\", e);\n    }\n\n    return buf;\n}\n\n/** Function to extract information from a response code.\n *\n * This function decodes the different bitfields in TSS2_RC.\n *\n * @param[in]  rc the response code to decode.\n * @param[out] info the structure containing the decoded fields.\n * @retval TSS2_RC_SUCCESS if the function call was a success.\n * @retval TSS2_ESYS_RC_BAD_REFERENCE if info is a NULL pointer.\n */\nTSS2_RC\nTss2_RC_DecodeInfo(TSS2_RC rc, TSS2_RC_INFO *info)\n{\n    UINT8 n;\n\n    if (!info) {\n        return TSS2_BASE_RC_BAD_REFERENCE;\n    }\n\n    memset(info, 0, sizeof(TSS2_RC_INFO));\n\n    info->layer = tss2_rc_layer_number_get(rc);\n    info->format = tss2_rc_layer_format_get(rc);\n\n    if (info->format) {\n        info->error = tpm2_rc_fmt1_error_get(rc) | TPM2_RC_FMT1;\n        n = tpm2_rc_fmt1_N_index_get(rc);\n        if (tpm2_rc_fmt1_P_get(rc)) {\n\t    info->parameter = n;\n        } else if (tpm2_rc_fmt1_N_is_handle(rc)) {\n            info->handle = n;\n        } else {\n          info->session = n;\n        }\n    } else {\n        info->error = tpm2_error_get(rc);\n    }\n\n    return TSS2_RC_SUCCESS;\n}\n\n/** Function to get a human readable error from a TSS2_RC_INFO\n *\n * This function returns the human readable eror for the underlying\n * error, ignoring the layer, parameters, handles and sessions.\n *\n * @param[int] info the structure containing the decoded fields.\n * @retval A human understandable error description string.\n * @retval NULL if info is a NULL pointer.\n */\nconst char *\nTss2_RC_DecodeInfoError(TSS2_RC_INFO *info)\n{\n    static __thread char buf[TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n    const char *m = NULL;\n\n    if (!info) {\n        return NULL;\n    }\n    clearbuf(buf);\n\n    if (info->format) {\n        m = tss2_fmt1_err_strs_get(info->error ^ TPM2_RC_FMT1);\n    } else {\n        m = tss2_fmt0_err_strs_get(info->error ^ TPM2_RC_VER1);\n    }\n\n    if (m) {\n        catbuf(buf, \"%s\", m);\n    } else {\n        catbuf(buf, \"0x%X\", info->error);\n    }\n\n    return buf;\n}\n", "/* SPDX-License-Identifier: BSD-2-Clause */\n\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <setjmp.h>\n#include <cmocka.h>\n\n#include \"tss2_rc.h\"\n#include \"util/aux_util.h\"\n\n#define TPM2_ERROR_TSS2_RC_LAYER_COUNT (TSS2_RC_LAYER_MASK >> TSS2_RC_LAYER_SHIFT)\n\n#define assert_string_prefix(str, prefix) \\\n    assert_memory_equal(str, prefix, strlen(prefix))\n\nstatic void\ntest_layers(void **state)\n{\n    UNUSED(state);\n\n    static const char *known_layers[TPM2_ERROR_TSS2_RC_LAYER_COUNT] = {\n        \"tpm:\",\n        NULL,\n        NULL,\n        NULL,\n        NULL,\n        NULL,\n        \"fapi:\",\n        \"esapi:\",\n        \"sys:\",\n        \"mu:\",\n        \"tcti:\",\n        \"rmt\",\n        \"rm\",\n        \"policy\",\n    };\n\n    UINT8 layer;\n    for (layer = 0; layer < TPM2_ERROR_TSS2_RC_LAYER_COUNT; layer++) {\n        TSS2_RC rc = TSS2_RC_LAYER(layer);\n\n        const char *got = Tss2_RC_Decode(rc);\n\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"%u:\", layer);\n\n        const char *expected = known_layers[layer] ? known_layers[layer] : buf;\n        assert_string_prefix(got, expected);\n    }\n}\n\nstatic void\ntest_tpm_format_0_version2_0_error(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_SEQUENCE);\n    assert_string_equal(m, \"tpm:error(2.0): improper use of a sequence\"\n            \" handle\");\n}\n\nstatic void test_tpm_format_0_version2_0_warn(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_REFERENCE_H0);\n    assert_string_equal(m,\n            \"tpm:warn(2.0): the 1st handle in the handle area references a\"\n                    \" transient object or session that is not loaded\");\n}\n\nstatic void\ntest_tpm2_format_0_unknown(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_NOT_USED + 0x80);\n    assert_string_equal(m, \"tpm:parameter(1):unknown error num: 0x3F\");\n}\n\nstatic void\ntest_tpm_format_1_unk_handle(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_HASH);\n    assert_string_equal(m,\n            \"tpm:handle(unk):hash algorithm not supported or not appropriate\");\n}\n\nstatic void\ntest_tpm_format_1_unk_parameter(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_HASH + TPM2_RC_P);\n    assert_string_equal(m,\n            \"tpm:parameter(unk):hash algorithm not supported or not appropriate\");\n}\n\nstatic void\ntest_tpm_format_1_unk_session(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_HASH + TPM2_RC_S);\n    assert_string_equal(m,\n            \"tpm:session(unk):hash algorithm not supported or not appropriate\");\n}\n\nstatic void\ntest_tpm_format_1_5_handle(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_HASH + TPM2_RC_5);\n    assert_string_equal(m,\n            \"tpm:handle(5):hash algorithm not supported or not appropriate\");\n}\n\nstatic void\ntest_tpm2_format_1_unknown(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_NOT_USED + 0x80);\n    assert_string_equal(m, \"tpm:parameter(1):unknown error num: 0x3F\");\n}\n\nstatic void\ntest_tpm2_format_1_success(void **state)\n{\n    (void) state;\n\n    const char *m = Tss2_RC_Decode(TPM2_RC_SUCCESS);\n    assert_string_equal(m, \"tpm:success\");\n}\n\nstatic const char *\ncustom_err_handler(TSS2_RC rc)\n{\n\n    static const char *err_map[] = { \"error 1\", \"error 2\", \"error 3\" };\n\n    if (rc - 1u >= ARRAY_LEN(err_map)) {\n        return NULL;\n    }\n\n    return err_map[rc - 1];\n}\n\nstatic void\ntest_custom_handler(void **state)\n{\n    (void) state;\n\n    /*\n     * Test registering a custom handler\n     */\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(1, \"cstm\", custom_err_handler);\n    assert_null(old);\n\n    /*\n     * Test getting error strings\n     */\n    unsigned i;\n    for (i = 1; i < 4; i++) {\n        // Make a layer 1 error with an error number of i.\n        TSS2_RC rc = TSS2_RC_LAYER(1) | i;\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"cstm:error %u\", i);\n\n        const char *e = Tss2_RC_Decode(rc);\n        assert_string_equal(e, buf);\n    }\n\n    TSS2_RC rc = TSS2_RC_LAYER(1) | 42;\n\n    /*\n     * Test an unknown error\n     */\n    const char *e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"cstm:0x2A\");\n\n    /*\n     * Test clearing a handler\n     */\n    old = Tss2_RC_SetHandler(1, \"cstm\", NULL);\n    assert_ptr_equal(old, custom_err_handler);\n\n    /*\n     * Test an unknown layer\n     */\n    e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"1:0x100\");\n}\n\nstatic void\ntest_zero_length_name(void **state)\n{\n    (void) state;\n\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(TSS2_TPM_RC_LAYER, \"\",\n            custom_err_handler);\n    assert_non_null(old);\n\n    old = Tss2_RC_SetHandler(TSS2_TPM_RC_LAYER, \"\",\n            custom_err_handler);\n    assert_ptr_equal(old, custom_err_handler);\n}\n\nstatic void\ntest_over_length_name(void **state)\n{\n    (void) state;\n\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(1, \"way to long of name\", custom_err_handler);\n    assert_null(old);\n\n    old = Tss2_RC_SetHandler(1, \"way to long of name\", custom_err_handler);\n    assert_ptr_equal(old, custom_err_handler);\n}\n\nstatic void\ntest_null_name(void **state)\n{\n    (void) state;\n\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(1,\n    NULL, custom_err_handler);\n    assert_ptr_equal(old, custom_err_handler);\n\n    old = Tss2_RC_SetHandler(1,\n                             NULL, custom_err_handler);\n    assert_ptr_equal(old, custom_err_handler);\n}\n\nstatic void\ntest_sys(void **state)\n{\n    (void) state;\n\n    const char *e = Tss2_RC_Decode(TSS2_SYS_RC_ABI_MISMATCH);\n    assert_string_equal(e,\n            \"sys:Passed in ABI version doesn't match called module's ABI version\");\n}\n\nstatic void\ntest_esys(void **state)\n{\n    (void) state;\n\n    const char *e = Tss2_RC_Decode(TSS2_ESYS_RC_BAD_VALUE);\n    assert_string_equal(e,\n            \"esapi:A parameter has a bad value\");\n}\n\nstatic void\ntest_mu(void **state)\n{\n    (void) state;\n\n    const char *e = Tss2_RC_Decode(TSS2_MU_RC_BAD_REFERENCE);\n    assert_string_equal(e,\n            \"mu:A pointer is NULL that isn't allowed to be NULL.\");\n\n}\n\nstatic void\ntest_tcti(void **state)\n{\n    (void) state;\n\n    const char *e = Tss2_RC_Decode(TSS2_TCTI_RC_NO_CONNECTION);\n    assert_string_equal(e, \"tcti:Fails to connect to next lower layer\");\n}\n\nstatic void\ntest_info_fmt0(void **state)\n{\n    TSS2_RC_INFO info = { 1, 2, 3, 4, 5, 6 };\n    TSS2_RC test_rc = TSS2_MU_RC_LAYER | TPM2_RC_SESSION_HANDLES;\n    TSS2_RC r = Tss2_RC_DecodeInfo(test_rc, &info);\n    assert_int_equal(info.layer, 9);\n    assert_int_equal(info.format, 0);\n    assert_int_equal(info.error, TPM2_RC_SESSION_HANDLES);\n    assert_int_equal(info.parameter, 0);\n    assert_int_equal(info.handle, 0);\n    assert_int_equal(info.session, 0);\n    assert_int_equal(r, TSS2_RC_SUCCESS);\n}\n\nstatic void\ntest_info_fmt1_parameter(void **state)\n{\n    TSS2_RC_INFO info;\n    TSS2_RC test_rc = TSS2_SYS_RC_LAYER | TPM2_RC_ASYMMETRIC | TPM2_RC_P | TPM2_RC_1;\n    TSS2_RC r = Tss2_RC_DecodeInfo(test_rc, &info);\n    assert_int_equal(info.layer, 8);\n    assert_int_equal(info.format, 1);\n    assert_int_equal(info.error, TPM2_RC_ASYMMETRIC);\n    assert_int_equal(info.parameter, 1);\n    assert_int_equal(info.handle, 0);\n    assert_int_equal(info.session, 0);\n    assert_int_equal(r, TSS2_RC_SUCCESS);\n}\n\nstatic void\ntest_info_fmt1_handle(void **state)\n{\n    TSS2_RC_INFO info;\n    TSS2_RC test_rc = TSS2_ESAPI_RC_LAYER | TPM2_RC_HANDLE | TPM2_RC_H | TPM2_RC_2;\n    TSS2_RC r = Tss2_RC_DecodeInfo(test_rc, &info);\n    assert_int_equal(info.layer, 7);\n    assert_int_equal(info.error, TPM2_RC_HANDLE);\n    assert_int_equal(info.parameter, 0);\n    assert_int_equal(info.handle, 2);\n    assert_int_equal(info.session, 0);\n    assert_int_equal(r, TSS2_RC_SUCCESS);\n}\n\nstatic void\ntest_info_fmt1_session(void **state)\n{\n    TSS2_RC_INFO info;\n    TSS2_RC test_rc = TSS2_FEATURE_RC_LAYER | TPM2_RC_EXPIRED | TPM2_RC_S | TPM2_RC_3;\n    TSS2_RC r = Tss2_RC_DecodeInfo(test_rc, &info);\n    assert_int_equal(info.layer, 6);\n    assert_int_equal(info.error, TPM2_RC_EXPIRED);\n    assert_int_equal(info.parameter, 0);\n    assert_int_equal(info.handle, 0);\n    assert_int_equal(info.session, 3);\n    assert_int_equal(r, TSS2_RC_SUCCESS);\n}\n\nstatic void\ntest_info_null(void **state)\n{\n    TSS2_RC r = Tss2_RC_DecodeInfo(TSS2_RC_SUCCESS, NULL);\n    assert_int_equal(r, TSS2_BASE_RC_BAD_REFERENCE);\n}\n\nstatic void\ntest_info_str_fmt1(void **state)\n{\n    TSS2_RC_INFO info = {\n        .error = TPM2_RC_EXPIRED,\n        .format = 1,\n    };\n    const char *m = Tss2_RC_DecodeInfoError(&info);\n    assert_string_equal(m, \"the policy has expired\");\n}\n\nstatic void\ntest_info_str_fmt1_ff(void **state)\n{\n    TSS2_RC_INFO info = {\n        .error = 0xFF,\n        .format = 1,\n    };\n    const char *m = Tss2_RC_DecodeInfoError(&info);\n    assert_string_equal(m, \"0xFF\");\n}\n\nstatic void\ntest_info_str_fmt0_err(void **state)\n{\n    TSS2_RC_INFO info = {\n        .error = TPM2_RC_COMMAND_CODE,\n        .format = 0,\n    };\n    const char *m = Tss2_RC_DecodeInfoError(&info);\n    assert_string_equal(m, \"command code not supported\");\n}\n\nstatic void\ntest_info_str_fmt0_warn(void **state)\n{\n    TSS2_RC_INFO info = {\n        .error = TPM2_RC_TESTING,\n        .format = 0,\n    };\n    const char *m = Tss2_RC_DecodeInfoError(&info);\n    assert_string_equal(m, \"TPM is performing selftests\");\n}\n\nstatic void\ntest_info_str_fmt0_ff(void **state)\n{\n    TSS2_RC_INFO info = {\n        .error = 0xFF,\n        .format = 0,\n    };\n    const char *m = Tss2_RC_DecodeInfoError(&info);\n    assert_string_equal(m, \"0xFF\");\n}\n\nstatic void\ntest_info_str_null(void **state)\n{\n    const char *m = Tss2_RC_DecodeInfoError(NULL);\n    assert_null(m);\n}\n\nstatic void\ntest_all_FFs(void **state)\n{\n    (void) state;\n\n    const char *e = Tss2_RC_Decode(0xFFFFFFFF);\n    assert_string_equal(e, \"255:0xFFFFFF\");\n}\n\nstatic void\ntest_all_FFs_set_handler(void **state)\n{\n    (void) state;\n    Tss2_RC_SetHandler(0xFF, \"garbage\", custom_err_handler);\n    Tss2_RC_SetHandler(0xFF, NULL, NULL);\n}\n\n/* link required symbol, but tpm2_tool.c declares it AND main, which\n * we have a main below for cmocka tests.\n */\nbool output_enabled = true;\n\nint\nmain(int argc, char* argv[])\n{\n    (void) argc;\n    (void) argv;\n\n    const struct CMUnitTest tests[] = {\n            /* Layer tests */\n            cmocka_unit_test(test_layers),\n            cmocka_unit_test(test_tpm_format_0_version2_0_error),\n            cmocka_unit_test(test_tpm_format_0_version2_0_warn),\n            cmocka_unit_test(test_tpm2_format_0_unknown),\n            cmocka_unit_test(test_tpm_format_1_unk_handle),\n            cmocka_unit_test(test_tpm_format_1_unk_parameter),\n            cmocka_unit_test(test_tpm_format_1_unk_session),\n            cmocka_unit_test(test_tpm_format_1_5_handle),\n            cmocka_unit_test(test_tpm2_format_1_unknown),\n            cmocka_unit_test(test_tpm2_format_1_success),\n            cmocka_unit_test(test_custom_handler),\n            cmocka_unit_test(test_zero_length_name),\n            cmocka_unit_test(test_over_length_name),\n            cmocka_unit_test(test_null_name),\n            cmocka_unit_test(test_sys),\n            cmocka_unit_test(test_esys),\n            cmocka_unit_test(test_mu),\n            cmocka_unit_test(test_tcti),\n            cmocka_unit_test(test_info_fmt0),\n            cmocka_unit_test(test_info_fmt1_parameter),\n            cmocka_unit_test(test_info_fmt1_handle),\n            cmocka_unit_test(test_info_fmt1_session),\n            cmocka_unit_test(test_info_null),\n            cmocka_unit_test(test_info_str_fmt1),\n            cmocka_unit_test(test_info_str_fmt1_ff),\n            cmocka_unit_test(test_info_str_fmt0_err),\n            cmocka_unit_test(test_info_str_fmt0_warn),\n            cmocka_unit_test(test_info_str_fmt0_ff),\n            cmocka_unit_test(test_info_str_null),\n            cmocka_unit_test(test_all_FFs),\n            cmocka_unit_test(test_all_FFs_set_handler)\n    };\n\n    return cmocka_run_group_tests(tests, NULL, NULL);\n}\n"], "filenames": ["src/tss2-rc/tss2_rc.c", "test/unit/test_tss2_rc.c"], "buggy_code_start_loc": [2, 200], "buggy_code_end_loc": [994, 451], "fixing_code_start_loc": [2, 200], "fixing_code_end_loc": [1004, 471], "type": "CWE-120", "message": "tpm2-tss is an open source software implementation of the Trusted Computing Group (TCG) Trusted Platform Module (TPM) 2 Software Stack (TSS2). In affected versions `Tss2_RC_SetHandler` and `Tss2_RC_Decode` both index into `layer_handler` with an 8 bit layer number, but the array only has `TPM2_ERROR_TSS2_RC_LAYER_COUNT` entries, so trying to add a handler for higher-numbered layers or decode a response code with such a layer number reads/writes past the end of the buffer. This Buffer overrun, could result in arbitrary code execution. An example attack would be a MiTM bus attack that returns 0xFFFFFFFF for the RC. Given the common use case of TPM modules an attacker must have local access to the target machine with local system privileges which allows access to the TPM system. Usually TPM access requires administrative privilege.", "other": {"cve": {"id": "CVE-2023-22745", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-19T23:15:26.907", "lastModified": "2023-01-26T20:25:23.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "tpm2-tss is an open source software implementation of the Trusted Computing Group (TCG) Trusted Platform Module (TPM) 2 Software Stack (TSS2). In affected versions `Tss2_RC_SetHandler` and `Tss2_RC_Decode` both index into `layer_handler` with an 8 bit layer number, but the array only has `TPM2_ERROR_TSS2_RC_LAYER_COUNT` entries, so trying to add a handler for higher-numbered layers or decode a response code with such a layer number reads/writes past the end of the buffer. This Buffer overrun, could result in arbitrary code execution. An example attack would be a MiTM bus attack that returns 0xFFFFFFFF for the RC. Given the common use case of TPM modules an attacker must have local access to the target machine with local system privileges which allows access to the TPM system. Usually TPM access requires administrative privilege."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tpm2_software_stack_project:tpm2_software_stack:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.0.0", "matchCriteriaId": "07A6A7AC-2EB7-4E1D-8DE1-F6043F2C263F"}]}]}], "references": [{"url": "https://github.com/tpm2-software/tpm2-tss/commit/306490c8d848c367faa2d9df81f5e69dab46ffb5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tpm2-software/tpm2-tss/security/advisories/GHSA-4j3v-fh23-vx67", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tpm2-software/tpm2-tss/commit/306490c8d848c367faa2d9df81f5e69dab46ffb5"}}