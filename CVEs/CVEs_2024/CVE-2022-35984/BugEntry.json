{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/random_ops.cc.\n// NOTE: If the algorithm is changed, please run the test\n// .../python/kernel_tests:parameterized_truncated_normal_op_test\n// commenting out the \"tf.set_random_seed(seed)\" lines, and using the\n// \"--runs-per-test=1000\" flag. This tests the statistical correctness of the\n// op results.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/kernels/parameterized_truncated_normal_op.h\"\n\n#include <algorithm>\n#include <cmath>\n#include <memory>\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/kernels/stateless_random_ops.h\"\n#include \"tensorflow/core/lib/random/random_distributions.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/util/guarded_philox_random.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace functor {\nusing random::PhiloxRandom;\n\nstatic constexpr int kMaxIterations = 1000;\n\ntemplate <typename T>\nstruct TruncatedNormalFunctor<CPUDevice, T> {\n  void operator()(OpKernelContext* ctx, const CPUDevice& d, int64_t num_batches,\n                  int64_t samples_per_batch, int64_t num_elements,\n                  typename TTypes<T>::ConstFlat means,\n                  typename TTypes<T>::ConstFlat stddevs,\n                  typename TTypes<T>::ConstFlat minvals,\n                  typename TTypes<T>::ConstFlat maxvals,\n                  const random::PhiloxRandom& gen,\n                  typename TTypes<T>::Flat output) {\n    // The randn rejection sampling is used when the mean and at least this many\n    // standard deviations are inside the bounds.\n    // The uniform proposal samplers become less efficient as the bounds are\n    // further from the mean, the reverse is true for the randn sampler.\n    // This number was chosen by empirical benchmarking. If modified, the\n    // benchmarks in parameterized_truncated_normal_op_test should also be\n    // changed.\n    const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3);\n    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n\n    auto do_work = [samples_per_batch, num_elements, &ctx, &means, &stddevs,\n                    &minvals, &maxvals, &gen, &output,\n                    kStdDevsInsideBoundsToUseRandnSampler](\n                       int64_t start_batch, int64_t limit_batch) {\n      // Capturing \"gen\" by-value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // \"gen\" by reference and explicitly do a copy assignment here.\n      random::PhiloxRandom gen_copy = gen;\n      // Skip takes units of 128 bytes.  +3 is so rounding doesn't lead to\n      // us using the same state in different batches.\n      // The sample from each iteration uses 2 random numbers.\n      gen_copy.Skip(start_batch * 2 * kMaxIterations * (samples_per_batch + 3) /\n                    4);\n      using Uniform = random::UniformDistribution<random::PhiloxRandom, T>;\n      Uniform dist;\n      using Normal = random::NormalDistribution<random::PhiloxRandom, T>;\n      Normal normal_dist;\n\n      // Vectorized intermediate calculations for uniform rejection sampling.\n      // We always generate at most 4 samples.\n      Eigen::array<T, 4> z;\n      Eigen::array<T, 4> g;\n\n      for (int64_t b = start_batch; b < limit_batch; ++b) {\n        // We are passed a flat array for each of the parameter tensors.\n        // The input is either a scalar broadcasted to all batches or a vector\n        // with length num_batches, but the scalar becomes an array of length 1.\n        T mean = means((means.dimension(0) == 1) ? 0 : b);\n        T stddev = stddevs((stddevs.dimension(0) == 1) ? 0 : b);\n        T minval = minvals((minvals.dimension(0) == 1) ? 0 : b);\n        T maxval = maxvals((maxvals.dimension(0) == 1) ? 0 : b);\n\n        // The last batch can be short, if we adjusted num_batches and\n        // samples_per_batch.\n        const int64_t limit_sample =\n            std::min((b + 1) * samples_per_batch, num_elements);\n        int64_t sample = b * samples_per_batch;\n\n        // On GPU, this check will just fill samples with NAN if it fails.\n        OP_REQUIRES(ctx,\n                    stddev > T(0) && minval < maxval &&\n                        (Eigen::numext::isfinite(minval) ||\n                         Eigen::numext::isfinite(maxval)),\n                    errors::InvalidArgument(\"Invalid parameters\"));\n\n        int num_iterations = 0;\n\n        // If possible, make one-sided bound be the lower bound, or make both\n        // bounds positive. Otherwise, the bounds are on either side of the\n        // mean.\n        if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) {\n          // Reverse all calculations. normMin and normMax will be flipped.\n          std::swap(minval, maxval);\n          stddev = -stddev;\n        }\n\n        // Calculate normalized samples, then convert them.\n        const T normMin = (minval - mean) / stddev;\n        const T normMax = (maxval - mean) / stddev;\n\n        // Determine the method to use.\n        const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4));\n        const T cutoff =\n            T(2) *\n            Eigen::numext::exp(T(0.5) +\n                               (normMin * (normMin - sqrtFactor)) / T(4)) /\n            (normMin + sqrtFactor);\n        const T diff = normMax - normMin;\n\n        if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMax >= T(0.))) ||\n            ((normMax > kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMin <= T(0.)))) {\n          // If the bounds are a least 3 standard deviations from the mean\n          // on at least one side then we rejection sample by sampling\n          // from the normal distribution and rejecting samples outside\n          // the bounds.\n          // Under this condition the acceptance rate per iteration should\n          // always be ~ 50%. This sampler is more efficient (and more\n          // numerically stable when one or both bounds is far from the mean).\n\n          while (sample < limit_sample) {\n            const auto randn_sample = normal_dist(&gen_copy);\n            const int size = randn_sample.size();\n\n            for (int i = 0; i < size; i++) {\n              if ((randn_sample[i] >= normMin) &&\n                  (randn_sample[i] <= normMax)) {\n                output(sample) = randn_sample[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n                if (num_iterations > kMaxIterations) {\n                  // This should never occur because this sampler should\n                  // (by the selection criteria above) be used if at least 3\n                  // standard deviations of one side of the distribution\n                  // is within the limits (so acceptance probability per\n                  // iterations >~ 1/2 per iteration).\n                  LOG(ERROR) << \"TruncatedNormal randn rejection sampler \"\n                             << \"exceeded maximum iterations for \"\n                             << \"normMin=\" << normMin << \" normMax=\" << normMax\n                             << \" kMaxIterations=\" << kMaxIterations;\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal randn rejection sampler failed to accept\"\n                      \" a sample.\"));\n                  return;\n                }\n              }\n            }\n          }\n        } else if (diff < cutoff) {\n          // Sample from a uniform distribution on [normMin, normMax].\n\n          const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin;\n\n          while (sample < limit_sample) {\n            const auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            // NOTE(ringwalt): These loops seem to only generate packed AVX\n            // instructions for float32.\n            for (int i = 0; i < size; i++) {\n              z[i] = rand[i] * diff + normMin;\n            }\n            for (int i = 0; i < size; i++) {\n              g[i] = (plusFactor - z[i] * z[i]) / T(2.0);\n            }\n\n            const auto u = dist(&gen_copy);\n            for (int i = 0; i < size; i++) {\n              auto accept = u[i] <= Eigen::numext::exp(g[i]);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                // Accept the sample z.\n                // If we run out of iterations, just use the current uniform\n                // sample, but emit a warning.\n                // TODO(jjhunt) For small entropies (relative to the bounds),\n                // this sampler is poor and may take many iterations since\n                // the proposal distribution is the uniform distribution\n                // U(lower_bound, upper_bound).\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal uniform rejection sampler \"\n                             << \"exceeded max iterations. Sample may contain \"\n                             << \"outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal uniform rejection sampler failed to \"\n                      \" accept a sample.\"));\n                  return;\n                }\n                output(sample) = z[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        } else {\n          // Sample from an exponential distribution with alpha maximizing\n          // acceptance probability, offset by normMin from the origin.\n          // Accept only if less than normMax.\n          const T alpha =\n              (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) /\n              T(2);\n          while (sample < limit_sample) {\n            auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            int i = 0;\n            while (i < size) {\n              const T z = -Eigen::numext::log(rand[i]) / alpha + normMin;\n              i++;\n              const T x = normMin < alpha ? alpha - z : normMin - alpha;\n              const T g = Eigen::numext::exp(-x * x / T(2.0));\n              const T u = rand[i];\n              i++;\n              auto accept = (u <= g && z < normMax);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal exponential distribution \"\n                             << \"rejection sampler exceeds max iterations. \"\n                             << \"Sample may contain outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal exponential distribution rejection\"\n                      \" sampler failed to accept a sample.\"));\n                  return;\n                }\n                output(sample) = z * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        }\n      }\n    };\n    // The cost of the initial calculations for the batch.\n    const int64_t batchInitCost =\n        // normMin, normMax\n        (Eigen::TensorOpCost::AddCost<T>() +\n         Eigen::TensorOpCost::MulCost<T>()) *\n            2\n        // sqrtFactor\n        + Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_sqrt_op<T>>::Cost\n        // cutoff\n        + Eigen::TensorOpCost::MulCost<T>() * 4 +\n        Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost\n        // diff\n        + Eigen::TensorOpCost::AddCost<T>();\n    const int64_t uniformSampleCost =\n        random::PhiloxRandom::kElementCost +\n        random::UniformDistribution<random::PhiloxRandom, T>::kElementCost;\n    // The cost of a single uniform sampling round.\n    const int64_t uniformRejectionSamplingCost =\n        uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() * 2 +\n        Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_exp_op<T>>::Cost +\n        Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>();\n    // Estimate the cost for an entire batch.\n    // Assume we use uniform sampling, and accept the 2nd sample on average.\n    const int64_t batchCost =\n        batchInitCost + uniformRejectionSamplingCost * 2 * samples_per_batch;\n    Shard(worker_threads.num_threads, worker_threads.workers, num_batches,\n          batchCost, do_work);\n  }\n};\n\ntemplate <typename T>\nstruct TruncatedNormalFunctorV2<CPUDevice, T> {\n  void operator()(OpKernelContext* ctx, const CPUDevice& d, int64_t num_batches,\n                  int64_t samples_per_batch, int64_t num_elements,\n                  const BCastList<4>& bcast,\n                  typename TTypes<T>::ConstFlat means,\n                  typename TTypes<T>::ConstFlat stddevs,\n                  typename TTypes<T>::ConstFlat minvals,\n                  typename TTypes<T>::ConstFlat maxvals,\n                  const random::PhiloxRandom& gen,\n                  typename TTypes<T>::Flat output) {\n    // The randn rejection sampling is used when the mean and at least this many\n    // standard deviations are inside the bounds.\n    // The uniform proposal samplers become less efficient as the bounds are\n    // further from the mean, the reverse is true for the randn sampler.\n    // This number was chosen by empirical benchmarking. If modified, the\n    // benchmarks in parameterized_truncated_normal_op_test should also be\n    // changed.\n    const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3);\n    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n\n    auto do_work = [num_batches, samples_per_batch, &ctx, &bcast, &means,\n                    &stddevs, &minvals, &maxvals, &gen, &output,\n                    kStdDevsInsideBoundsToUseRandnSampler](\n                       int64_t start_output, int64_t limit_output) {\n      // Capturing \"gen\" by-value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // \"gen\" by reference and explicitly do a copy assignment here.\n      random::PhiloxRandom gen_copy = gen;\n      using Uniform = random::UniformDistribution<random::PhiloxRandom, T>;\n      Uniform dist;\n      using Normal = random::NormalDistribution<random::PhiloxRandom, T>;\n      Normal normal_dist;\n      // Skip takes units of 128 bits. The Uniform::kResultElementCount - 1\n      // is so rounding doesn't lead to\n      // us using the same state in different workloads.\n      // The sample from each iteration uses 2 random numbers.\n      gen_copy.Skip((start_output * 2 * kMaxIterations +\n                     Uniform::kResultElementCount - 1) /\n                    Uniform::kResultElementCount);\n\n      // Vectorized intermediate calculations for uniform rejection sampling.\n      // We always generate at most 4 samples.\n      Eigen::array<T, Uniform::kResultElementCount> z;\n      Eigen::array<T, Uniform::kResultElementCount> g;\n\n      const bool should_bcast = bcast.IsBroadcastingRequired();\n      const auto& means_batch_indices = bcast.batch_indices(0);\n      const auto& stddevs_batch_indices = bcast.batch_indices(1);\n      const auto& minvals_batch_indices = bcast.batch_indices(2);\n      const auto& maxvals_batch_indices = bcast.batch_indices(3);\n      auto output_flat = output.data();\n\n      // We partition work across batches and then across samples\n      // per batch member, to avoid extra work.\n      for (int64_t output_idx = start_output; output_idx < limit_output;\n           // output_idx is incremented with the inner loops below.\n      ) {\n        int64_t batch_idx = output_idx / samples_per_batch;\n        // The output layout is [samples_per_batch, num_batches]. Thus\n        // the output address is sample_idx * num_batches + batch_idx.\n        // Below, code will index at output_batch_offset[sample_idx *\n        // num_batches] matching this.\n        T* const output_batch_offset = output_flat + batch_idx;\n        // Generate batch counts from BCast, as it has the right indices to loop\n        // over.\n        T mean, stddev, minval, maxval;\n        if (should_bcast) {\n          mean = means(means_batch_indices[batch_idx]);\n          stddev = stddevs(stddevs_batch_indices[batch_idx]);\n          minval = minvals(minvals_batch_indices[batch_idx]);\n          maxval = maxvals(maxvals_batch_indices[batch_idx]);\n        } else {\n          mean = means(batch_idx);\n          stddev = stddevs(batch_idx);\n          minval = minvals(batch_idx);\n          maxval = maxvals(batch_idx);\n        }\n\n        // On GPU, this check will just fill samples with NAN if it fails.\n        OP_REQUIRES(ctx,\n                    stddev > T(0) && minval < maxval &&\n                        (Eigen::numext::isfinite(minval) ||\n                         Eigen::numext::isfinite(maxval)),\n                    errors::InvalidArgument(\"Invalid parameters\"));\n\n        int num_iterations = 0;\n\n        // If possible, make one-sided bound be the lower bound, or make both\n        // bounds positive. Otherwise, the bounds are on either side of the\n        // mean.\n        if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) {\n          // Reverse all calculations. normMin and normMax will be flipped.\n          std::swap(minval, maxval);\n          stddev = -stddev;\n        }\n\n        // Calculate normalized samples, then convert them.\n        const T normMin = (minval - mean) / stddev;\n        const T normMax = (maxval - mean) / stddev;\n\n        // Determine the method to use.\n        const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4));\n        const T cutoff =\n            T(2) *\n            Eigen::numext::exp(T(0.5) +\n                               (normMin * (normMin - sqrtFactor)) / T(4)) /\n            (normMin + sqrtFactor);\n        const T diff = normMax - normMin;\n\n        if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMax >= T(0.))) ||\n            ((normMax > kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMin <= T(0.)))) {\n          // If the bounds are a least 3 standard deviations from the mean\n          // on at least one side then we rejection sample by sampling\n          // from the normal distribution and rejecting samples outside\n          // the bounds.\n          // Under this condition the acceptance rate per iteration should\n          // always be ~ 50%. This sampler is more efficient (and more\n          // numerically stable when one or both bounds is far from the mean).\n          for (int64_t sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            const auto randn_sample = normal_dist(&gen_copy);\n            const int size = randn_sample.size();\n            for (int i = 0; i < size; ++i) {\n              if ((randn_sample[i] >= normMin) &&\n                  (randn_sample[i] <= normMax)) {\n                output_batch_offset[sample_idx * num_batches] =\n                    randn_sample[i] * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                ++num_iterations;\n                if (num_iterations > kMaxIterations) {\n                  // This should never occur because this sampler should\n                  // (by the selection criteria above) be used if at least 3\n                  // standard deviations of one side of the distribution\n                  // is within the limits (so acceptance probability per\n                  // iterations >~ 1/2 per iteration).\n                  LOG(ERROR) << \"TruncatedNormal randn rejection sampler \"\n                             << \"exceeded maximum iterations for \"\n                             << \"normMin=\" << normMin << \" normMax=\" << normMax\n                             << \" kMaxIterations=\" << kMaxIterations;\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal randn rejection sampler failed to accept\"\n                      \" a sample.\"));\n                  return;\n                }\n              }\n            }\n          }\n        } else if (diff < cutoff) {\n          // Sample from a uniform distribution on [normMin, normMax].\n\n          const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin;\n\n          for (int64_t sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            const auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            // NOTE(ringwalt): These loops seem to only generate packed AVX\n            // instructions for float32.\n            for (int i = 0; i < size; i++) {\n              z[i] = rand[i] * diff + normMin;\n              g[i] = (plusFactor - z[i] * z[i]) / T(2.0);\n            }\n\n            const auto u = dist(&gen_copy);\n            for (int i = 0; i < size; i++) {\n              auto accept = u[i] <= Eigen::numext::exp(g[i]);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                // Accept the sample z.\n                // If we run out of iterations, just use the current uniform\n                // sample, but emit a warning.\n                // TODO(jjhunt) For small entropies (relative to the bounds),\n                // this sampler is poor and may take many iterations since\n                // the proposal distribution is the uniform distribution\n                // U(lower_bound, upper_bound).\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal uniform rejection sampler \"\n                             << \"exceeded max iterations. Sample may contain \"\n                             << \"outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal uniform rejection sampler failed to \"\n                      \" accept a sample.\"));\n                  return;\n                }\n                output_batch_offset[sample_idx * num_batches] =\n                    z[i] * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        } else {\n          // Sample from an exponential distribution with alpha maximizing\n          // acceptance probability, offset by normMin from the origin.\n          // Accept only if less than normMax.\n          const T alpha =\n              (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) /\n              T(2);\n          for (int64_t sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            int i = 0;\n            while (i < size) {\n              const T z = -Eigen::numext::log(rand[i]) / alpha + normMin;\n              i++;\n              const T x = normMin < alpha ? alpha - z : normMin - alpha;\n              const T g = Eigen::numext::exp(-x * x / T(2.0));\n              const T u = rand[i];\n              i++;\n              auto accept = (u <= g && z < normMax);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal exponential distribution \"\n                             << \"rejection sampler exceeds max iterations. \"\n                             << \"Sample may contain outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal exponential distribution rejection\"\n                      \" sampler failed to accept a sample.\"));\n                  return;\n                }\n                output_batch_offset[sample_idx * num_batches] =\n                    z * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        }\n      }\n    };\n    // The cost of the initial calculations for the batch.\n    const int64_t batchInitCost =\n        // normMin, normMax\n        (Eigen::TensorOpCost::AddCost<T>() +\n         Eigen::TensorOpCost::MulCost<T>()) *\n            2\n        // sqrtFactor\n        + Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_sqrt_op<T>>::Cost\n        // cutoff\n        + Eigen::TensorOpCost::MulCost<T>() * 4 +\n        Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost\n        // diff\n        + Eigen::TensorOpCost::AddCost<T>();\n    const int64_t uniformSampleCost =\n        random::PhiloxRandom::kElementCost +\n        random::UniformDistribution<random::PhiloxRandom, T>::kElementCost;\n    // The cost of a single uniform sampling round.\n    const int64_t uniformRejectionSamplingCost =\n        uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() * 2 +\n        Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_exp_op<T>>::Cost +\n        Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>();\n    // Estimate the cost for an entire batch.\n    // Assume we use uniform sampling, and accept the 2nd sample on average.\n    const int64_t batchCost = batchInitCost + uniformRejectionSamplingCost * 2;\n    Shard(worker_threads.num_threads, worker_threads.workers, num_elements,\n          batchCost, do_work);\n  }\n};\n\n}  // namespace functor\n\nnamespace {\n\n// Samples from a truncated normal distribution, using the given parameters.\ntemplate <typename Device, typename T>\nclass ParameterizedTruncatedNormalOp : public OpKernel {\n  // Reshape batches so each batch is this size if possible.\n  static constexpr int32_t kDesiredBatchSize = 100;\n\n public:\n  explicit ParameterizedTruncatedNormalOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, generator_.Init(context));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_tensor = ctx->input(0);\n    const Tensor& means_tensor = ctx->input(1);\n    const Tensor& stddevs_tensor = ctx->input(2);\n    const Tensor& minvals_tensor = ctx->input(3);\n    const Tensor& maxvals_tensor = ctx->input(4);\n\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsVector(shape_tensor.shape()),\n        errors::InvalidArgument(\"Input shape should be a vector, got shape: \",\n                                shape_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, shape_tensor.NumElements() > 0,\n                errors::InvalidArgument(\"Shape tensor must not be empty, got \",\n                                        shape_tensor.DebugString()));\n    int32_t num_batches = shape_tensor.flat<int32>()(0);\n\n    int32_t samples_per_batch = 1;\n    const int32_t num_dims = shape_tensor.dim_size(0);\n    for (int32_t i = 1; i < num_dims; i++) {\n      samples_per_batch *= shape_tensor.flat<int32>()(i);\n    }\n    const int32_t num_elements = num_batches * samples_per_batch;\n\n    // Allocate the output before fudging num_batches and samples_per_batch.\n    auto shape_vec = shape_tensor.flat<int32>();\n    TensorShape tensor_shape;\n    OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(\n                            shape_vec.data(), shape_vec.size(), &tensor_shape));\n    Tensor* samples_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, tensor_shape, &samples_tensor));\n\n    // Parameters must be 0-d or 1-d.\n    OP_REQUIRES(ctx, means_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input means should be a scalar or vector, got shape: \",\n                    means_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, stddevs_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input stddevs should be a scalar or vector, got shape: \",\n                    stddevs_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, minvals_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input minvals should be a scalar or vector, got shape: \",\n                    minvals_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, maxvals_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input maxvals should be a scalar or vector, got shape: \",\n                    maxvals_tensor.shape().DebugString()));\n\n    if ((means_tensor.dims() == 0 || means_tensor.dim_size(0) == 1) &&\n        (stddevs_tensor.dims() == 0 || stddevs_tensor.dim_size(0) == 1) &&\n        minvals_tensor.dims() == 0 && maxvals_tensor.dims() == 0) {\n      // All batches have the same parameters, so we can update the batch size\n      // to a reasonable value to improve parallelism (ensure enough batches,\n      // and no very small batches which have high overhead).\n      int32_t size = num_batches * samples_per_batch;\n      int32_t adjusted_samples = kDesiredBatchSize;\n      // Ensure adjusted_batches * adjusted_samples >= size.\n      int32_t adjusted_batches = Eigen::divup(size, adjusted_samples);\n      num_batches = adjusted_batches;\n      samples_per_batch = adjusted_samples;\n    } else {\n      // Parameters must be broadcastable to the shape [num_batches].\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(means_tensor.shape()) ||\n              means_tensor.dim_size(0) == 1 ||\n              means_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input means should have length 1 or shape[0], got shape: \",\n              means_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(stddevs_tensor.shape()) ||\n              stddevs_tensor.dim_size(0) == 1 ||\n              stddevs_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input stddevs should have length 1 or shape[0], got shape: \",\n              stddevs_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(minvals_tensor.shape()) ||\n              minvals_tensor.dim_size(0) == 1 ||\n              minvals_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input minvals should have length 1 or shape[0], got shape: \",\n              minvals_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(maxvals_tensor.shape()) ||\n              maxvals_tensor.dim_size(0) == 1 ||\n              maxvals_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input maxvals should have length 1 or shape[0], got shape: \",\n              maxvals_tensor.shape().DebugString()));\n    }\n\n    auto truncFunctor = functor::TruncatedNormalFunctor<Device, T>();\n    // Each worker has the fudge factor for samples_per_batch, so use it here.\n    random::PhiloxRandom rng =\n        generator_.ReserveSamples128(num_batches * 2 * functor::kMaxIterations *\n                                     (samples_per_batch + 3) / 4);\n    truncFunctor(ctx, ctx->eigen_device<Device>(), num_batches,\n                 samples_per_batch, num_elements, means_tensor.flat<T>(),\n                 stddevs_tensor.flat<T>(), minvals_tensor.flat<T>(),\n                 maxvals_tensor.flat<T>(), rng, samples_tensor->flat<T>());\n  }\n\n private:\n  GuardedPhiloxRandom generator_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(ParameterizedTruncatedNormalOp);\n};\n\n// Samples from a truncated normal distribution, using the given parameters.\ntemplate <typename Device, typename T>\nclass StatelessParameterizedTruncatedNormal : public OpKernel {\n  // Reshape batches so each batch is this size if possible.\n  static const int32_t kDesiredBatchSize = 100;\n\n public:\n  explicit StatelessParameterizedTruncatedNormal(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_tensor = ctx->input(0);\n    const Tensor& seed_tensor = ctx->input(1);\n    const Tensor& means_tensor = ctx->input(2);\n    const Tensor& stddevs_tensor = ctx->input(3);\n    const Tensor& minvals_tensor = ctx->input(4);\n    const Tensor& maxvals_tensor = ctx->input(5);\n\n    OP_REQUIRES(ctx, seed_tensor.dims() == 1 && seed_tensor.dim_size(0) == 2,\n                errors::InvalidArgument(\"seed must have shape [2], not \",\n                                        seed_tensor.shape().DebugString()));\n\n    tensorflow::BCastList<4> bcast(\n        {means_tensor.shape().dim_sizes(), stddevs_tensor.shape().dim_sizes(),\n         minvals_tensor.shape().dim_sizes(),\n         maxvals_tensor.shape().dim_sizes()},\n        /*fewer_dims_optimization=*/false,\n        /*return_flattened_batch_indices=*/true);\n\n    OP_REQUIRES(ctx, bcast.IsValid(),\n                errors::InvalidArgument(\n                    \"means, stddevs, minvals, maxvals must have compatible \"\n                    \"batch dimensions: \",\n                    means_tensor.shape().DebugString(), \" vs. \",\n                    stddevs_tensor.shape().DebugString(), \" vs. \",\n                    minvals_tensor.shape().DebugString(), \" vs. \",\n                    maxvals_tensor.shape().DebugString()));\n\n    // Let's check that the shape tensor dominates the broadcasted tensor.\n    TensorShape bcast_shape = BCast::ToShape(bcast.output_shape());\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsVector(shape_tensor.shape()),\n        errors::InvalidArgument(\"Input shape should be a vector, got shape: \",\n                                shape_tensor.shape().DebugString()));\n    TensorShape output_shape;\n    if (shape_tensor.dtype() == DataType::DT_INT32) {\n      OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(shape_tensor.vec<int32>(),\n                                                      &output_shape));\n    } else {\n      OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(\n                              shape_tensor.vec<int64_t>(), &output_shape));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::EndsWith(output_shape, bcast_shape),\n                errors::InvalidArgument(\n                    \"Shape passed in must end with broadcasted shape.\"));\n\n    int64_t samples_per_batch = 1;\n    const int64_t num_sample_dims =\n        (shape_tensor.dim_size(0) - bcast.output_shape().size());\n    for (int64_t i = 0; i < num_sample_dims; ++i) {\n      samples_per_batch *= output_shape.dim_size(i);\n    }\n    int64_t num_batches = 1;\n    for (int64_t i = num_sample_dims; i < shape_tensor.dim_size(0); ++i) {\n      num_batches *= output_shape.dim_size(i);\n    }\n    const int64_t num_elements = num_batches * samples_per_batch;\n\n    Tensor* samples_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape, &samples_tensor));\n\n    auto truncFunctor = functor::TruncatedNormalFunctorV2<Device, T>();\n    // Each worker has the same fudge factor, so use it here.\n    random::PhiloxRandom::Key key;\n    random::PhiloxRandom::ResultType counter;\n    OP_REQUIRES_OK(ctx, GenerateKey(seed_tensor, &key, &counter));\n\n    auto philox = random::PhiloxRandom(counter, key);\n\n    truncFunctor(ctx, ctx->eigen_device<Device>(), num_batches,\n                 samples_per_batch, num_elements, bcast, means_tensor.flat<T>(),\n                 stddevs_tensor.flat<T>(), minvals_tensor.flat<T>(),\n                 maxvals_tensor.flat<T>(), philox, samples_tensor->flat<T>());\n  }\n\n private:\n  TF_DISALLOW_COPY_AND_ASSIGN(StatelessParameterizedTruncatedNormal);\n};\n\n}  // namespace\n\n#define REGISTER(TYPE)                                                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParameterizedTruncatedNormal\")             \\\n                              .Device(DEVICE_CPU)                          \\\n                              .TypeConstraint<TYPE>(\"dtype\"),              \\\n                          ParameterizedTruncatedNormalOp<CPUDevice, TYPE>) \\\n  REGISTER_KERNEL_BUILDER(                                                 \\\n      Name(\"StatelessParameterizedTruncatedNormal\")                        \\\n          .HostMemory(\"shape\")                                             \\\n          .HostMemory(\"seed\")                                              \\\n          .HostMemory(\"means\")                                             \\\n          .HostMemory(\"stddevs\")                                           \\\n          .HostMemory(\"minvals\")                                           \\\n          .HostMemory(\"maxvals\")                                           \\\n          .Device(DEVICE_CPU)                                              \\\n          .TypeConstraint<TYPE>(\"dtype\"),                                  \\\n      StatelessParameterizedTruncatedNormal<CPUDevice, TYPE>)\n\nTF_CALL_half(REGISTER);\nTF_CALL_float(REGISTER);\nTF_CALL_double(REGISTER);\n\n#undef REGISTER\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#define REGISTER(TYPE)                                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParameterizedTruncatedNormal\") \\\n                              .Device(DEVICE_GPU)              \\\n                              .HostMemory(\"shape\")             \\\n                              .TypeConstraint<TYPE>(\"dtype\"),  \\\n                          ParameterizedTruncatedNormalOp<GPUDevice, TYPE>)\n\nTF_CALL_half(REGISTER);\nTF_CALL_float(REGISTER);\nTF_CALL_double(REGISTER);\n\n#undef REGISTER\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // end namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for ParameterizedTruncatedNormalOp.\"\"\"\n\nimport functools\nimport math\nimport timeit\n\nimport numpy as np\nfrom six.moves import range  # pylint: disable=redefined-builtin\n\nfrom tensorflow.core.protobuf import config_pb2\nfrom tensorflow.python.client import session\nfrom tensorflow.python.eager import backprop\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import random_seed\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import random_ops\nfrom tensorflow.python.ops import stateless_random_ops as stateless\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\nfrom tensorflow.python.platform import tf_logging\n\n\ndef _get_stddev_inside_bounds_before_using_randn(gpu):\n  # The boundary where the randn sampler is used varies between CPU and GPU.\n  if gpu:\n    return 1.3\n  else:\n    return 1.7\n\n\nclass TruncatedNormalMoments(object):\n  memoized_moments = None\n  mean = None\n  stddev = None\n  minval = None\n  maxval = None\n\n  def __init__(self, mean, stddev, minval, maxval):\n    self.memoized_moments = [1.0]  # 0th moment\n    self.mean = np.double(mean)\n    self.stddev = np.double(stddev)\n    # NOTE(ringwalt): The formula doesn't handle infinite values.\n    self.minval = np.double(max(-10, minval))\n    self.maxval = np.double(min(10, maxval))\n\n  def __getitem__(self, moment):\n    \"\"\"Calculates the truncated normal moments.\n\n    Args:\n      moment: The number for the moment.\n\n    Returns:\n      The value for the given moment.\n\n    Uses the recurrence relation described in:\n        http://www.smp.uq.edu.au/people/YoniNazarathy/teaching_projects\n            /studentWork/EricOrjebin_TruncatedNormalMoments.pdf\n    \"\"\"\n    assert moment > 0\n    # The test case must ensure it can import scipy.stats before this point.\n    import scipy.stats  # pylint: disable=g-import-not-at-top\n    dist = scipy.stats.norm(loc=self.mean, scale=self.stddev)\n    for k in range(len(self.memoized_moments), moment + 1):\n      m_k_minus_2 = self.memoized_moments[k - 2] if k > 1 else np.double(0.0)\n      m_k_minus_1 = self.memoized_moments[k - 1]\n      numerator = (np.power(self.maxval, k - 1) * dist.pdf(self.maxval) -\n                   np.power(self.minval, k - 1) * dist.pdf(self.minval))\n      denominator = dist.cdf(self.maxval) - dist.cdf(self.minval)\n      m = ((k - 1) * self.stddev**2 * m_k_minus_2 + self.mean * m_k_minus_1 -\n           self.stddev * numerator / denominator)\n      assert abs(m) < 1e50  # ensure numerical accuracy\n      self.memoized_moments.append(m)\n    return self.memoized_moments[moment]\n\n\ndef calculate_moments(samples, max_moment):\n  moments = [0.0] * (max_moment + 1)\n  for k in range(len(moments)):\n    moments[k] = np.mean(samples**k, axis=0)\n  return moments\n\n\ndef z_test(real, expected, i, num_samples):\n  numerical_error = 1e-6  # per-operation error\n  moment_mean = expected[i]\n  moment_squared = expected[2 * i]\n  moment_var = moment_squared - moment_mean * moment_mean\n\n  error_per_moment = i * numerical_error\n  total_variance = moment_var / float(num_samples) + error_per_moment\n  return abs((real[i] - moment_mean) / math.sqrt(total_variance))\n\n\nclass ParameterizedTruncatedNormalTest(test.TestCase):\n  z_limit = 6.0\n\n  # Stop at moment 10 to avoid numerical errors in the theoretical moments.\n  max_moment = 10\n\n  def validateMoments(self,\n                      shape,\n                      mean,\n                      stddev,\n                      minval,\n                      maxval,\n                      use_stateless=False,\n                      seed=1618):\n    try:\n      # TruncatedNormalMoments requires scipy.stats.\n      # Give up early if we are unable to import it.\n      random_seed.set_random_seed(seed)\n      with self.cached_session():\n        if use_stateless:\n          # Generate a seed that stateless ops can use.\n          new_seed = random_ops.random_uniform([2],\n                                               seed=seed,\n                                               minval=0,\n                                               maxval=(2**31 - 1),\n                                               dtype=np.int32)\n          samples = stateless.stateless_parameterized_truncated_normal(\n              shape, new_seed, mean, stddev, minval, maxval).eval()\n        else:\n          samples = random_ops.parameterized_truncated_normal(\n              shape, mean, stddev, minval, maxval).eval()\n        assert (~np.isnan(samples)).all()\n      moments = calculate_moments(samples, self.max_moment)\n      expected_moments = TruncatedNormalMoments(mean, stddev, minval, maxval)\n      num_samples = functools.reduce(lambda x, y: x * y, shape, 1)\n      for i in range(1, len(moments)):\n        self.assertLess(\n            z_test(moments, expected_moments, i, num_samples), self.z_limit)\n    except ImportError as e:\n      tf_logging.warn(\"Cannot test truncated normal op: %s\" % str(e))\n\n  def validateKolmogorovSmirnov(self,\n                                shape,\n                                mean,\n                                stddev,\n                                minval,\n                                maxval,\n                                use_stateless=False,\n                                seed=1618):\n    try:\n      import scipy.stats  # pylint: disable=g-import-not-at-top\n      random_seed.set_random_seed(seed)\n      with self.cached_session():\n        if use_stateless:\n          new_seed = random_ops.random_uniform([2],\n                                               seed=seed,\n                                               minval=0,\n                                               maxval=(2**31 - 1),\n                                               dtype=np.int32)\n          samples = stateless.stateless_parameterized_truncated_normal(\n              shape, new_seed, mean, stddev, minval, maxval).eval()\n        else:\n          samples = random_ops.parameterized_truncated_normal(\n              shape, mean, stddev, minval, maxval).eval()\n\n      assert (~np.isnan(samples)).all()\n      minval = max(mean - stddev * 10, minval)\n      maxval = min(mean + stddev * 10, maxval)\n      dist = scipy.stats.norm(loc=mean, scale=stddev)\n      cdf_min = dist.cdf(minval)\n      cdf_max = dist.cdf(maxval)\n\n      def truncated_cdf(x):\n        return np.clip((dist.cdf(x) - cdf_min) / (cdf_max - cdf_min), 0.0, 1.0)\n\n      pvalue = scipy.stats.kstest(samples, truncated_cdf)[1]\n      self.assertGreater(pvalue, 1e-10)\n    except ImportError as e:\n      tf_logging.warn(\"Cannot test truncated normal op: %s\" % str(e))\n\n  @test_util.run_deprecated_v1\n  def testDefaults(self):\n    self.validateMoments([int(1e5)], 0.0, 1.0, -2.0, 2.0)\n    self.validateMoments([int(1e5)], 0.0, 1.0, -2.0, 2.0, use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testShifted(self):\n    self.validateMoments([int(1e5)], -1.0, 1.0, -2.0, 2.0)\n    self.validateMoments([int(1e5)], -1.0, 1.0, -2.0, 2.0, use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testRightTail(self):\n    self.validateMoments([int(1e5)], 0.0, 1.0, 4.0, np.infty)\n    self.validateMoments([int(1e5)],\n                         0.0,\n                         1.0,\n                         4.0,\n                         np.infty,\n                         use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testLeftTail(self):\n    self.validateMoments([int(1e5)], 0.0, 1.0, -np.infty, -4.0)\n    self.validateMoments([int(1e5)],\n                         0.0,\n                         1.0,\n                         -np.infty,\n                         -4.0,\n                         use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testLeftTailTwoSidedBounds(self):\n    self.validateMoments([int(1e5)], 0.0, 1.0, -6.0, -3.0)\n    self.validateMoments([int(1e5)], 0.0, 1.0, -6.0, -3.0, use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  @test_util.disable_xla(\"Low probability region\")\n  def testTwoSidedLeftTailShifted(self):\n    self.validateKolmogorovSmirnov([int(1e5)], 6.0, 1.0, -1.0, 1.0)\n    self.validateKolmogorovSmirnov([int(1e5)],\n                                   6.0,\n                                   1.0,\n                                   -1.0,\n                                   1.0,\n                                   use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  @test_util.disable_xla(\"Low probability region\")\n  def testRightTailShifted(self):\n    self.validateMoments([int(1e5)], -5.0, 1.0, 2.0, np.infty)\n    self.validateMoments([int(1e5)],\n                         -5.0,\n                         1.0,\n                         2.0,\n                         np.infty,\n                         use_stateless=True)\n\n  # Take the normal distribution around the mean, but truncating the left tail\n  # far from the mean.\n  @test_util.run_deprecated_v1\n  def testTruncateOnLeft_entireTailOnRight(self):\n    self.validateKolmogorovSmirnov([int(1e5)], 10.0, 1.0, 4.0, np.infty)\n    self.validateKolmogorovSmirnov([int(1e5)],\n                                   10.0,\n                                   1.0,\n                                   4.0,\n                                   np.infty,\n                                   use_stateless=True)\n\n  # Take the normal distribution around the mean, but truncating the right tail.\n  @test_util.run_deprecated_v1\n  def testTruncateOnRight_entireTailOnLeft(self):\n    self.validateKolmogorovSmirnov([int(1e5)], -8, 1.0, -np.infty, -4.0)\n    self.validateKolmogorovSmirnov([int(1e5)],\n                                   -8.,\n                                   1.0,\n                                   -np.infty,\n                                   -4.0,\n                                   use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testSmallStddev(self):\n    self.validateKolmogorovSmirnov([int(1e5)], 0.0, 0.1, 0.05, 0.10)\n    self.validateKolmogorovSmirnov([int(1e5)],\n                                   0.0,\n                                   0.1,\n                                   0.05,\n                                   0.10,\n                                   use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testSamplingWithSmallStdDevFarFromBound(self):\n    sample_op = random_ops.parameterized_truncated_normal(\n        shape=(int(1e5),), means=0.8, stddevs=0.05, minvals=-1., maxvals=1.)\n    new_seed = random_ops.random_uniform([2],\n                                         seed=1234,\n                                         minval=0,\n                                         maxval=(2**31 - 1),\n                                         dtype=np.int32)\n    sample_op_stateless = stateless.stateless_parameterized_truncated_normal(\n        shape=(int(1e5),),\n        seed=new_seed,\n        means=0.8,\n        stddevs=0.05,\n        minvals=-1.,\n        maxvals=1.)\n\n    with self.session() as sess:\n      samples, samples_stateless = sess.run([sample_op, sample_op_stateless])\n      # 0. is more than 16 standard deviations from the mean, and\n      # should have a likelihood < 1e-57.\n      assert (~np.isnan(samples)).all()\n      assert (~np.isnan(samples_stateless)).all()\n      self.assertAllGreater(samples, 0.)\n      self.assertAllGreater(samples_stateless, 0.)\n\n  def testStatelessParameterizedTruncatedNormalHasGrads(self):\n    mean = variables.Variable(0.01)\n    stddev = variables.Variable(1.)\n    minval = variables.Variable(-1.)\n    maxval = variables.Variable(1.)\n\n    with self.cached_session() as sess:\n      with backprop.GradientTape(persistent=True) as tape:\n        samples = stateless.stateless_parameterized_truncated_normal(\n            [1], [1, 2], mean, stddev, minval, maxval)\n\n      sess.run(variables.variables_initializer([mean, stddev, minval, maxval]))\n      [mean_grad, std_grad], mean_actual_grad, std_actual_grad = sess.run([\n          tape.gradient(samples, [mean, stddev]),\n          array_ops.ones_like(mean),\n          (samples - mean) / stddev])\n      self.assertAllClose(mean_grad, mean_actual_grad)\n      self.assertAllClose(std_grad, std_actual_grad[0])\n\n      try:\n        import scipy.stats  # pylint:disable=g-import-not-at-top\n        truncnorm = scipy.stats.truncnorm(a=-1., b=1., loc=0., scale=1.)\n        samples_np, [minval_grad, maxval_grad] = sess.run([\n            samples, tape.gradient(samples, [minval, maxval])])\n\n        sample_cdf = truncnorm.cdf(samples_np)\n        # These come from the implicit reparameterization trick.\n        scipy_maxval_grad = np.exp(\n            0.5 * (samples_np ** 2 - ((1. - 0.01) / 1.) ** 2) +\n            np.log(sample_cdf))\n\n        scipy_minval_grad = np.exp(\n            0.5 * (samples_np ** 2 - ((-1. - 0.01) / 1.) ** 2) +\n            np.log1p(-sample_cdf))\n\n        self.assertAllClose(minval_grad, scipy_minval_grad[0], rtol=1e-2)\n        self.assertAllClose(maxval_grad, scipy_maxval_grad[0], rtol=1e-2)\n\n      except ImportError as e:\n        tf_logging.warn(\"Cannot test truncated normal op: %s\" % str(e))\n\n  @test_util.run_deprecated_v1\n  def testSamplingAtRandnSwitchover(self):\n    # The randn sampler is used as the bounds are moved farther from the mean,\n    # and the probability of accepting a sample increases the farther the\n    # bounds are from the mean.\n    # This test asserts that at the point of switchover, both samplers are\n    # working (not raising an error or returning nan) and returning the\n    # expected moments.\n    use_gpu = test.is_gpu_available()\n    stddev_inside_bounds_before_using_randn = (\n        _get_stddev_inside_bounds_before_using_randn(use_gpu))\n\n    epsilon = 0.001\n    self.validateMoments(\n        shape=[int(1e6)],\n        mean=0.,\n        stddev=1.0,\n        minval=-epsilon,\n        maxval=stddev_inside_bounds_before_using_randn - epsilon)\n    self.validateMoments(\n        shape=[int(1e6)],\n        mean=0.,\n        stddev=1.0,\n        minval=-epsilon,\n        maxval=stddev_inside_bounds_before_using_randn + epsilon)\n\n    self.validateMoments(\n        shape=[int(1e6)],\n        mean=0.,\n        stddev=1.0,\n        minval=-epsilon,\n        maxval=stddev_inside_bounds_before_using_randn - epsilon,\n        use_stateless=True)\n    self.validateMoments(\n        shape=[int(1e6)],\n        mean=0.,\n        stddev=1.0,\n        minval=-epsilon,\n        maxval=stddev_inside_bounds_before_using_randn + epsilon,\n        use_stateless=True)\n\n\n# Benchmarking code\ndef parameterized_vs_naive(shape, num_iters, use_gpu=False):\n  np.random.seed(1618)  # Make it reproducible.\n\n  # No CSE/CF.\n  optimizer_options = config_pb2.OptimizerOptions(\n      opt_level=config_pb2.OptimizerOptions.L0)\n  config = config_pb2.ConfigProto(graph_options=config_pb2.GraphOptions(\n      optimizer_options=optimizer_options))\n\n  with session.Session(config=config) as sess:\n    with ops.device(\"/cpu:0\" if not use_gpu else None):\n      param_op = control_flow_ops.group(\n          random_ops.parameterized_truncated_normal(shape))\n      naive_op = control_flow_ops.group(random_ops.truncated_normal(shape))\n\n    # Burn-in to avoid session setup costs in the timing.\n    sess.run(param_op)\n    sess.run(param_op)\n    param_dt = timeit.timeit(lambda: sess.run(param_op), number=num_iters)\n    sess.run(naive_op)\n    sess.run(naive_op)\n    naive_dt = timeit.timeit(lambda: sess.run(naive_op), number=num_iters)\n    return param_dt, naive_dt\n\n\ndef randn_sampler_switchover(shape, num_iters, use_gpu=False):\n  # Benchmark by constructing samplers on the threshold of using the randn\n  # rejection sampling and check that this threshold is set correctly by\n  # benchmarking with bounds just above and below this threshold.\n  # The uniform and randn samplers should have about the same performance\n  # at this point.\n\n  stddev_inside_bounds_before_using_randn = (\n      _get_stddev_inside_bounds_before_using_randn(use_gpu))\n\n  epsilon = 0.001\n\n  np.random.seed(1618)  # Make it reproducible.\n\n  # No CSE/CF.\n  optimizer_options = config_pb2.OptimizerOptions(\n      opt_level=config_pb2.OptimizerOptions.L0)\n  config = config_pb2.ConfigProto(\n      graph_options=config_pb2.GraphOptions(\n          optimizer_options=optimizer_options))\n\n  with session.Session(config=config) as sess:\n    with ops.device(\"/cpu:0\" if not use_gpu else \"/gpu:0\"):\n      uniform_sampler_op = control_flow_ops.group(\n          random_ops.parameterized_truncated_normal(\n              shape,\n              means=0.,\n              stddevs=1.0,\n              minvals=-stddev_inside_bounds_before_using_randn + epsilon,\n              maxvals=0.01))\n      randn_sampler_op = control_flow_ops.group(\n          random_ops.parameterized_truncated_normal(\n              shape,\n              means=0.,\n              stddevs=1.0,\n              minvals=-stddev_inside_bounds_before_using_randn - epsilon,\n              maxvals=0.01))\n\n    # Burn-in to avoid session setup costs in the timing.\n    sess.run(uniform_sampler_op)\n    sess.run(uniform_sampler_op)\n    uniform_dt = timeit.timeit(\n        lambda: sess.run(uniform_sampler_op), number=num_iters)\n\n    sess.run(randn_sampler_op)\n    sess.run(randn_sampler_op)\n    randn_dt = timeit.timeit(\n        lambda: sess.run(randn_sampler_op), number=num_iters)\n\n    return randn_dt, uniform_dt\n\n\nclass TruncatedNormalBenchmark(test.Benchmark):\n\n  def benchmarkParameterizedOpVsNaiveOpCpu(self):\n    self._benchmarkParameterizedOpVsNaiveOp(False)\n\n  def benchmarkParameterizedOpVsNaiveOpGpu(self):\n    self._benchmarkParameterizedOpVsNaiveOp(True)\n\n  def _benchmarkParameterizedOpVsNaiveOp(self, use_gpu):\n    num_iters = 50\n    print((\"Composition of new ParameterizedTruncatedNormalOp vs. \"\n           \"naive TruncatedNormalOp [%d iters]\") % num_iters)\n    print(\"Shape\\tsec(parameterized)\\tsec(naive)\\tspeedup\")\n\n    for shape in [[10000, 100], [1000, 1000], [1000000], [100, 100, 100],\n                  [20, 20, 20, 20]]:\n      p_dt, n_dt = parameterized_vs_naive(shape, num_iters, use_gpu)\n      print(\"%s\\t%.3f\\t%.3f\\t%.2f\" % (shape, p_dt, n_dt, p_dt / n_dt))\n\n      shape_str = \"-\".join(map(str, shape))\n      self.report_benchmark(\n          name=\"parameterized_shape\" + shape_str,\n          iters=num_iters,\n          wall_time=p_dt)\n      self.report_benchmark(\n          name=\"naive_shape\" + shape_str, iters=num_iters, wall_time=n_dt)\n\n  def benchmarkRandnSamplerCPU(self):\n    self._benchmarkRandnSampler(False)\n\n  def benchmarkRandnSamplerGPU(self):\n    self._benchmarkRandnSampler(True)\n\n  def _benchmarkRandnSampler(self, use_gpu):\n    num_iters = 100\n    shape = [int(1e6)]\n    randn_dt, uniform_dt = randn_sampler_switchover(shape, num_iters, use_gpu)\n\n    print((\"Randn Sampler vs uniform samplers [%d iters]\\t%.4f\\t%.4f\") %\n          (num_iters, randn_dt, uniform_dt))\n\n    gpu_str = \"_gpu\" if use_gpu else \"_cpu\"\n    self.report_benchmark(\n        name=\"randn_sampler\" + gpu_str, iters=num_iters, wall_time=randn_dt)\n    self.report_benchmark(\n        name=\"uniform_sampler\" + gpu_str, iters=num_iters, wall_time=uniform_dt)\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/random_ops.cc.\n// NOTE: If the algorithm is changed, please run the test\n// .../python/kernel_tests:parameterized_truncated_normal_op_test\n// commenting out the \"tf.set_random_seed(seed)\" lines, and using the\n// \"--runs-per-test=1000\" flag. This tests the statistical correctness of the\n// op results.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/kernels/parameterized_truncated_normal_op.h\"\n\n#include <algorithm>\n#include <cmath>\n#include <memory>\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/kernels/stateless_random_ops.h\"\n#include \"tensorflow/core/lib/random/random_distributions.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/util/guarded_philox_random.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace functor {\nusing random::PhiloxRandom;\n\nstatic constexpr int kMaxIterations = 1000;\n\ntemplate <typename T>\nstruct TruncatedNormalFunctor<CPUDevice, T> {\n  void operator()(OpKernelContext* ctx, const CPUDevice& d, int64_t num_batches,\n                  int64_t samples_per_batch, int64_t num_elements,\n                  typename TTypes<T>::ConstFlat means,\n                  typename TTypes<T>::ConstFlat stddevs,\n                  typename TTypes<T>::ConstFlat minvals,\n                  typename TTypes<T>::ConstFlat maxvals,\n                  const random::PhiloxRandom& gen,\n                  typename TTypes<T>::Flat output) {\n    // The randn rejection sampling is used when the mean and at least this many\n    // standard deviations are inside the bounds.\n    // The uniform proposal samplers become less efficient as the bounds are\n    // further from the mean, the reverse is true for the randn sampler.\n    // This number was chosen by empirical benchmarking. If modified, the\n    // benchmarks in parameterized_truncated_normal_op_test should also be\n    // changed.\n    const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3);\n    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n\n    auto do_work = [samples_per_batch, num_elements, &ctx, &means, &stddevs,\n                    &minvals, &maxvals, &gen, &output,\n                    kStdDevsInsideBoundsToUseRandnSampler](\n                       int64_t start_batch, int64_t limit_batch) {\n      // Capturing \"gen\" by-value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // \"gen\" by reference and explicitly do a copy assignment here.\n      random::PhiloxRandom gen_copy = gen;\n      // Skip takes units of 128 bytes.  +3 is so rounding doesn't lead to\n      // us using the same state in different batches.\n      // The sample from each iteration uses 2 random numbers.\n      gen_copy.Skip(start_batch * 2 * kMaxIterations * (samples_per_batch + 3) /\n                    4);\n      using Uniform = random::UniformDistribution<random::PhiloxRandom, T>;\n      Uniform dist;\n      using Normal = random::NormalDistribution<random::PhiloxRandom, T>;\n      Normal normal_dist;\n\n      // Vectorized intermediate calculations for uniform rejection sampling.\n      // We always generate at most 4 samples.\n      Eigen::array<T, 4> z;\n      Eigen::array<T, 4> g;\n\n      for (int64_t b = start_batch; b < limit_batch; ++b) {\n        // We are passed a flat array for each of the parameter tensors.\n        // The input is either a scalar broadcasted to all batches or a vector\n        // with length num_batches, but the scalar becomes an array of length 1.\n        T mean = means((means.dimension(0) == 1) ? 0 : b);\n        T stddev = stddevs((stddevs.dimension(0) == 1) ? 0 : b);\n        T minval = minvals((minvals.dimension(0) == 1) ? 0 : b);\n        T maxval = maxvals((maxvals.dimension(0) == 1) ? 0 : b);\n\n        // The last batch can be short, if we adjusted num_batches and\n        // samples_per_batch.\n        const int64_t limit_sample =\n            std::min((b + 1) * samples_per_batch, num_elements);\n        int64_t sample = b * samples_per_batch;\n\n        // On GPU, this check will just fill samples with NAN if it fails.\n        OP_REQUIRES(ctx,\n                    stddev > T(0) && minval < maxval &&\n                        (Eigen::numext::isfinite(minval) ||\n                         Eigen::numext::isfinite(maxval)),\n                    errors::InvalidArgument(\"Invalid parameters\"));\n\n        int num_iterations = 0;\n\n        // If possible, make one-sided bound be the lower bound, or make both\n        // bounds positive. Otherwise, the bounds are on either side of the\n        // mean.\n        if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) {\n          // Reverse all calculations. normMin and normMax will be flipped.\n          std::swap(minval, maxval);\n          stddev = -stddev;\n        }\n\n        // Calculate normalized samples, then convert them.\n        const T normMin = (minval - mean) / stddev;\n        const T normMax = (maxval - mean) / stddev;\n\n        // Determine the method to use.\n        const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4));\n        const T cutoff =\n            T(2) *\n            Eigen::numext::exp(T(0.5) +\n                               (normMin * (normMin - sqrtFactor)) / T(4)) /\n            (normMin + sqrtFactor);\n        const T diff = normMax - normMin;\n\n        if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMax >= T(0.))) ||\n            ((normMax > kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMin <= T(0.)))) {\n          // If the bounds are a least 3 standard deviations from the mean\n          // on at least one side then we rejection sample by sampling\n          // from the normal distribution and rejecting samples outside\n          // the bounds.\n          // Under this condition the acceptance rate per iteration should\n          // always be ~ 50%. This sampler is more efficient (and more\n          // numerically stable when one or both bounds is far from the mean).\n\n          while (sample < limit_sample) {\n            const auto randn_sample = normal_dist(&gen_copy);\n            const int size = randn_sample.size();\n\n            for (int i = 0; i < size; i++) {\n              if ((randn_sample[i] >= normMin) &&\n                  (randn_sample[i] <= normMax)) {\n                output(sample) = randn_sample[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n                if (num_iterations > kMaxIterations) {\n                  // This should never occur because this sampler should\n                  // (by the selection criteria above) be used if at least 3\n                  // standard deviations of one side of the distribution\n                  // is within the limits (so acceptance probability per\n                  // iterations >~ 1/2 per iteration).\n                  LOG(ERROR) << \"TruncatedNormal randn rejection sampler \"\n                             << \"exceeded maximum iterations for \"\n                             << \"normMin=\" << normMin << \" normMax=\" << normMax\n                             << \" kMaxIterations=\" << kMaxIterations;\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal randn rejection sampler failed to accept\"\n                      \" a sample.\"));\n                  return;\n                }\n              }\n            }\n          }\n        } else if (diff < cutoff) {\n          // Sample from a uniform distribution on [normMin, normMax].\n\n          const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin;\n\n          while (sample < limit_sample) {\n            const auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            // NOTE(ringwalt): These loops seem to only generate packed AVX\n            // instructions for float32.\n            for (int i = 0; i < size; i++) {\n              z[i] = rand[i] * diff + normMin;\n            }\n            for (int i = 0; i < size; i++) {\n              g[i] = (plusFactor - z[i] * z[i]) / T(2.0);\n            }\n\n            const auto u = dist(&gen_copy);\n            for (int i = 0; i < size; i++) {\n              auto accept = u[i] <= Eigen::numext::exp(g[i]);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                // Accept the sample z.\n                // If we run out of iterations, just use the current uniform\n                // sample, but emit a warning.\n                // TODO(jjhunt) For small entropies (relative to the bounds),\n                // this sampler is poor and may take many iterations since\n                // the proposal distribution is the uniform distribution\n                // U(lower_bound, upper_bound).\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal uniform rejection sampler \"\n                             << \"exceeded max iterations. Sample may contain \"\n                             << \"outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal uniform rejection sampler failed to \"\n                      \" accept a sample.\"));\n                  return;\n                }\n                output(sample) = z[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        } else {\n          // Sample from an exponential distribution with alpha maximizing\n          // acceptance probability, offset by normMin from the origin.\n          // Accept only if less than normMax.\n          const T alpha =\n              (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) /\n              T(2);\n          while (sample < limit_sample) {\n            auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            int i = 0;\n            while (i < size) {\n              const T z = -Eigen::numext::log(rand[i]) / alpha + normMin;\n              i++;\n              const T x = normMin < alpha ? alpha - z : normMin - alpha;\n              const T g = Eigen::numext::exp(-x * x / T(2.0));\n              const T u = rand[i];\n              i++;\n              auto accept = (u <= g && z < normMax);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal exponential distribution \"\n                             << \"rejection sampler exceeds max iterations. \"\n                             << \"Sample may contain outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal exponential distribution rejection\"\n                      \" sampler failed to accept a sample.\"));\n                  return;\n                }\n                output(sample) = z * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        }\n      }\n    };\n    // The cost of the initial calculations for the batch.\n    const int64_t batchInitCost =\n        // normMin, normMax\n        (Eigen::TensorOpCost::AddCost<T>() +\n         Eigen::TensorOpCost::MulCost<T>()) *\n            2\n        // sqrtFactor\n        + Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_sqrt_op<T>>::Cost\n        // cutoff\n        + Eigen::TensorOpCost::MulCost<T>() * 4 +\n        Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost\n        // diff\n        + Eigen::TensorOpCost::AddCost<T>();\n    const int64_t uniformSampleCost =\n        random::PhiloxRandom::kElementCost +\n        random::UniformDistribution<random::PhiloxRandom, T>::kElementCost;\n    // The cost of a single uniform sampling round.\n    const int64_t uniformRejectionSamplingCost =\n        uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() * 2 +\n        Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_exp_op<T>>::Cost +\n        Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>();\n    // Estimate the cost for an entire batch.\n    // Assume we use uniform sampling, and accept the 2nd sample on average.\n    const int64_t batchCost =\n        batchInitCost + uniformRejectionSamplingCost * 2 * samples_per_batch;\n    Shard(worker_threads.num_threads, worker_threads.workers, num_batches,\n          batchCost, do_work);\n  }\n};\n\ntemplate <typename T>\nstruct TruncatedNormalFunctorV2<CPUDevice, T> {\n  void operator()(OpKernelContext* ctx, const CPUDevice& d, int64_t num_batches,\n                  int64_t samples_per_batch, int64_t num_elements,\n                  const BCastList<4>& bcast,\n                  typename TTypes<T>::ConstFlat means,\n                  typename TTypes<T>::ConstFlat stddevs,\n                  typename TTypes<T>::ConstFlat minvals,\n                  typename TTypes<T>::ConstFlat maxvals,\n                  const random::PhiloxRandom& gen,\n                  typename TTypes<T>::Flat output) {\n    // The randn rejection sampling is used when the mean and at least this many\n    // standard deviations are inside the bounds.\n    // The uniform proposal samplers become less efficient as the bounds are\n    // further from the mean, the reverse is true for the randn sampler.\n    // This number was chosen by empirical benchmarking. If modified, the\n    // benchmarks in parameterized_truncated_normal_op_test should also be\n    // changed.\n    const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3);\n    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n\n    auto do_work = [num_batches, samples_per_batch, &ctx, &bcast, &means,\n                    &stddevs, &minvals, &maxvals, &gen, &output,\n                    kStdDevsInsideBoundsToUseRandnSampler](\n                       int64_t start_output, int64_t limit_output) {\n      // Capturing \"gen\" by-value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // \"gen\" by reference and explicitly do a copy assignment here.\n      random::PhiloxRandom gen_copy = gen;\n      using Uniform = random::UniformDistribution<random::PhiloxRandom, T>;\n      Uniform dist;\n      using Normal = random::NormalDistribution<random::PhiloxRandom, T>;\n      Normal normal_dist;\n      // Skip takes units of 128 bits. The Uniform::kResultElementCount - 1\n      // is so rounding doesn't lead to\n      // us using the same state in different workloads.\n      // The sample from each iteration uses 2 random numbers.\n      gen_copy.Skip((start_output * 2 * kMaxIterations +\n                     Uniform::kResultElementCount - 1) /\n                    Uniform::kResultElementCount);\n\n      // Vectorized intermediate calculations for uniform rejection sampling.\n      // We always generate at most 4 samples.\n      Eigen::array<T, Uniform::kResultElementCount> z;\n      Eigen::array<T, Uniform::kResultElementCount> g;\n\n      const bool should_bcast = bcast.IsBroadcastingRequired();\n      const auto& means_batch_indices = bcast.batch_indices(0);\n      const auto& stddevs_batch_indices = bcast.batch_indices(1);\n      const auto& minvals_batch_indices = bcast.batch_indices(2);\n      const auto& maxvals_batch_indices = bcast.batch_indices(3);\n      auto output_flat = output.data();\n\n      // We partition work across batches and then across samples\n      // per batch member, to avoid extra work.\n      for (int64_t output_idx = start_output; output_idx < limit_output;\n           // output_idx is incremented with the inner loops below.\n      ) {\n        int64_t batch_idx = output_idx / samples_per_batch;\n        // The output layout is [samples_per_batch, num_batches]. Thus\n        // the output address is sample_idx * num_batches + batch_idx.\n        // Below, code will index at output_batch_offset[sample_idx *\n        // num_batches] matching this.\n        T* const output_batch_offset = output_flat + batch_idx;\n        // Generate batch counts from BCast, as it has the right indices to loop\n        // over.\n        T mean, stddev, minval, maxval;\n        if (should_bcast) {\n          mean = means(means_batch_indices[batch_idx]);\n          stddev = stddevs(stddevs_batch_indices[batch_idx]);\n          minval = minvals(minvals_batch_indices[batch_idx]);\n          maxval = maxvals(maxvals_batch_indices[batch_idx]);\n        } else {\n          mean = means(batch_idx);\n          stddev = stddevs(batch_idx);\n          minval = minvals(batch_idx);\n          maxval = maxvals(batch_idx);\n        }\n\n        // On GPU, this check will just fill samples with NAN if it fails.\n        OP_REQUIRES(ctx,\n                    stddev > T(0) && minval < maxval &&\n                        (Eigen::numext::isfinite(minval) ||\n                         Eigen::numext::isfinite(maxval)),\n                    errors::InvalidArgument(\"Invalid parameters\"));\n\n        int num_iterations = 0;\n\n        // If possible, make one-sided bound be the lower bound, or make both\n        // bounds positive. Otherwise, the bounds are on either side of the\n        // mean.\n        if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) {\n          // Reverse all calculations. normMin and normMax will be flipped.\n          std::swap(minval, maxval);\n          stddev = -stddev;\n        }\n\n        // Calculate normalized samples, then convert them.\n        const T normMin = (minval - mean) / stddev;\n        const T normMax = (maxval - mean) / stddev;\n\n        // Determine the method to use.\n        const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4));\n        const T cutoff =\n            T(2) *\n            Eigen::numext::exp(T(0.5) +\n                               (normMin * (normMin - sqrtFactor)) / T(4)) /\n            (normMin + sqrtFactor);\n        const T diff = normMax - normMin;\n\n        if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMax >= T(0.))) ||\n            ((normMax > kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMin <= T(0.)))) {\n          // If the bounds are a least 3 standard deviations from the mean\n          // on at least one side then we rejection sample by sampling\n          // from the normal distribution and rejecting samples outside\n          // the bounds.\n          // Under this condition the acceptance rate per iteration should\n          // always be ~ 50%. This sampler is more efficient (and more\n          // numerically stable when one or both bounds is far from the mean).\n          for (int64_t sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            const auto randn_sample = normal_dist(&gen_copy);\n            const int size = randn_sample.size();\n            for (int i = 0; i < size; ++i) {\n              if ((randn_sample[i] >= normMin) &&\n                  (randn_sample[i] <= normMax)) {\n                output_batch_offset[sample_idx * num_batches] =\n                    randn_sample[i] * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                ++num_iterations;\n                if (num_iterations > kMaxIterations) {\n                  // This should never occur because this sampler should\n                  // (by the selection criteria above) be used if at least 3\n                  // standard deviations of one side of the distribution\n                  // is within the limits (so acceptance probability per\n                  // iterations >~ 1/2 per iteration).\n                  LOG(ERROR) << \"TruncatedNormal randn rejection sampler \"\n                             << \"exceeded maximum iterations for \"\n                             << \"normMin=\" << normMin << \" normMax=\" << normMax\n                             << \" kMaxIterations=\" << kMaxIterations;\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal randn rejection sampler failed to accept\"\n                      \" a sample.\"));\n                  return;\n                }\n              }\n            }\n          }\n        } else if (diff < cutoff) {\n          // Sample from a uniform distribution on [normMin, normMax].\n\n          const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin;\n\n          for (int64_t sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            const auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            // NOTE(ringwalt): These loops seem to only generate packed AVX\n            // instructions for float32.\n            for (int i = 0; i < size; i++) {\n              z[i] = rand[i] * diff + normMin;\n              g[i] = (plusFactor - z[i] * z[i]) / T(2.0);\n            }\n\n            const auto u = dist(&gen_copy);\n            for (int i = 0; i < size; i++) {\n              auto accept = u[i] <= Eigen::numext::exp(g[i]);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                // Accept the sample z.\n                // If we run out of iterations, just use the current uniform\n                // sample, but emit a warning.\n                // TODO(jjhunt) For small entropies (relative to the bounds),\n                // this sampler is poor and may take many iterations since\n                // the proposal distribution is the uniform distribution\n                // U(lower_bound, upper_bound).\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal uniform rejection sampler \"\n                             << \"exceeded max iterations. Sample may contain \"\n                             << \"outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal uniform rejection sampler failed to \"\n                      \" accept a sample.\"));\n                  return;\n                }\n                output_batch_offset[sample_idx * num_batches] =\n                    z[i] * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        } else {\n          // Sample from an exponential distribution with alpha maximizing\n          // acceptance probability, offset by normMin from the origin.\n          // Accept only if less than normMax.\n          const T alpha =\n              (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) /\n              T(2);\n          for (int64_t sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            int i = 0;\n            while (i < size) {\n              const T z = -Eigen::numext::log(rand[i]) / alpha + normMin;\n              i++;\n              const T x = normMin < alpha ? alpha - z : normMin - alpha;\n              const T g = Eigen::numext::exp(-x * x / T(2.0));\n              const T u = rand[i];\n              i++;\n              auto accept = (u <= g && z < normMax);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal exponential distribution \"\n                             << \"rejection sampler exceeds max iterations. \"\n                             << \"Sample may contain outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal exponential distribution rejection\"\n                      \" sampler failed to accept a sample.\"));\n                  return;\n                }\n                output_batch_offset[sample_idx * num_batches] =\n                    z * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        }\n      }\n    };\n    // The cost of the initial calculations for the batch.\n    const int64_t batchInitCost =\n        // normMin, normMax\n        (Eigen::TensorOpCost::AddCost<T>() +\n         Eigen::TensorOpCost::MulCost<T>()) *\n            2\n        // sqrtFactor\n        + Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_sqrt_op<T>>::Cost\n        // cutoff\n        + Eigen::TensorOpCost::MulCost<T>() * 4 +\n        Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost\n        // diff\n        + Eigen::TensorOpCost::AddCost<T>();\n    const int64_t uniformSampleCost =\n        random::PhiloxRandom::kElementCost +\n        random::UniformDistribution<random::PhiloxRandom, T>::kElementCost;\n    // The cost of a single uniform sampling round.\n    const int64_t uniformRejectionSamplingCost =\n        uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() * 2 +\n        Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_exp_op<T>>::Cost +\n        Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>();\n    // Estimate the cost for an entire batch.\n    // Assume we use uniform sampling, and accept the 2nd sample on average.\n    const int64_t batchCost = batchInitCost + uniformRejectionSamplingCost * 2;\n    Shard(worker_threads.num_threads, worker_threads.workers, num_elements,\n          batchCost, do_work);\n  }\n};\n\n}  // namespace functor\n\nnamespace {\n\n// Samples from a truncated normal distribution, using the given parameters.\ntemplate <typename Device, typename T>\nclass ParameterizedTruncatedNormalOp : public OpKernel {\n  // Reshape batches so each batch is this size if possible.\n  static constexpr int32_t kDesiredBatchSize = 100;\n\n public:\n  explicit ParameterizedTruncatedNormalOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, generator_.Init(context));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_tensor = ctx->input(0);\n    const Tensor& means_tensor = ctx->input(1);\n    const Tensor& stddevs_tensor = ctx->input(2);\n    const Tensor& minvals_tensor = ctx->input(3);\n    const Tensor& maxvals_tensor = ctx->input(4);\n\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsVector(shape_tensor.shape()),\n        errors::InvalidArgument(\"Input shape should be a vector, got shape: \",\n                                shape_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, shape_tensor.NumElements() > 0,\n                errors::InvalidArgument(\"Shape tensor must not be empty, got \",\n                                        shape_tensor.DebugString()));\n    TensorShape tensor_shape;\n    OP_REQUIRES_OK(ctx, tensor::MakeShape(shape_tensor, &tensor_shape));\n\n    int32_t num_batches = tensor_shape.dim_size(0);\n    int32_t samples_per_batch = 1;\n    const int32_t num_dims = tensor_shape.dims();\n    for (int32_t i = 1; i < num_dims; i++) {\n      samples_per_batch *= tensor_shape.dim_size(i);\n    }\n    const int32_t num_elements = num_batches * samples_per_batch;\n\n    // Allocate the output before fudging num_batches and samples_per_batch.\n    Tensor* samples_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, tensor_shape, &samples_tensor));\n\n    // Parameters must be 0-d or 1-d.\n    OP_REQUIRES(ctx, means_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input means should be a scalar or vector, got shape: \",\n                    means_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, stddevs_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input stddevs should be a scalar or vector, got shape: \",\n                    stddevs_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, minvals_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input minvals should be a scalar or vector, got shape: \",\n                    minvals_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, maxvals_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input maxvals should be a scalar or vector, got shape: \",\n                    maxvals_tensor.shape().DebugString()));\n\n    if ((means_tensor.dims() == 0 || means_tensor.dim_size(0) == 1) &&\n        (stddevs_tensor.dims() == 0 || stddevs_tensor.dim_size(0) == 1) &&\n        minvals_tensor.dims() == 0 && maxvals_tensor.dims() == 0) {\n      // All batches have the same parameters, so we can update the batch size\n      // to a reasonable value to improve parallelism (ensure enough batches,\n      // and no very small batches which have high overhead).\n      int32_t size = num_batches * samples_per_batch;\n      int32_t adjusted_samples = kDesiredBatchSize;\n      // Ensure adjusted_batches * adjusted_samples >= size.\n      int32_t adjusted_batches = Eigen::divup(size, adjusted_samples);\n      num_batches = adjusted_batches;\n      samples_per_batch = adjusted_samples;\n    } else {\n      // Parameters must be broadcastable to the shape [num_batches].\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(means_tensor.shape()) ||\n              means_tensor.dim_size(0) == 1 ||\n              means_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input means should have length 1 or shape[0], got shape: \",\n              means_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(stddevs_tensor.shape()) ||\n              stddevs_tensor.dim_size(0) == 1 ||\n              stddevs_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input stddevs should have length 1 or shape[0], got shape: \",\n              stddevs_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(minvals_tensor.shape()) ||\n              minvals_tensor.dim_size(0) == 1 ||\n              minvals_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input minvals should have length 1 or shape[0], got shape: \",\n              minvals_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(maxvals_tensor.shape()) ||\n              maxvals_tensor.dim_size(0) == 1 ||\n              maxvals_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input maxvals should have length 1 or shape[0], got shape: \",\n              maxvals_tensor.shape().DebugString()));\n    }\n\n    auto truncFunctor = functor::TruncatedNormalFunctor<Device, T>();\n    // Each worker has the fudge factor for samples_per_batch, so use it here.\n    random::PhiloxRandom rng =\n        generator_.ReserveSamples128(num_batches * 2 * functor::kMaxIterations *\n                                     (samples_per_batch + 3) / 4);\n    truncFunctor(ctx, ctx->eigen_device<Device>(), num_batches,\n                 samples_per_batch, num_elements, means_tensor.flat<T>(),\n                 stddevs_tensor.flat<T>(), minvals_tensor.flat<T>(),\n                 maxvals_tensor.flat<T>(), rng, samples_tensor->flat<T>());\n  }\n\n private:\n  GuardedPhiloxRandom generator_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(ParameterizedTruncatedNormalOp);\n};\n\n// Samples from a truncated normal distribution, using the given parameters.\ntemplate <typename Device, typename T>\nclass StatelessParameterizedTruncatedNormal : public OpKernel {\n  // Reshape batches so each batch is this size if possible.\n  static const int32_t kDesiredBatchSize = 100;\n\n public:\n  explicit StatelessParameterizedTruncatedNormal(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_tensor = ctx->input(0);\n    const Tensor& seed_tensor = ctx->input(1);\n    const Tensor& means_tensor = ctx->input(2);\n    const Tensor& stddevs_tensor = ctx->input(3);\n    const Tensor& minvals_tensor = ctx->input(4);\n    const Tensor& maxvals_tensor = ctx->input(5);\n\n    OP_REQUIRES(ctx, seed_tensor.dims() == 1 && seed_tensor.dim_size(0) == 2,\n                errors::InvalidArgument(\"seed must have shape [2], not \",\n                                        seed_tensor.shape().DebugString()));\n\n    tensorflow::BCastList<4> bcast(\n        {means_tensor.shape().dim_sizes(), stddevs_tensor.shape().dim_sizes(),\n         minvals_tensor.shape().dim_sizes(),\n         maxvals_tensor.shape().dim_sizes()},\n        /*fewer_dims_optimization=*/false,\n        /*return_flattened_batch_indices=*/true);\n\n    OP_REQUIRES(ctx, bcast.IsValid(),\n                errors::InvalidArgument(\n                    \"means, stddevs, minvals, maxvals must have compatible \"\n                    \"batch dimensions: \",\n                    means_tensor.shape().DebugString(), \" vs. \",\n                    stddevs_tensor.shape().DebugString(), \" vs. \",\n                    minvals_tensor.shape().DebugString(), \" vs. \",\n                    maxvals_tensor.shape().DebugString()));\n\n    // Let's check that the shape tensor dominates the broadcasted tensor.\n    TensorShape bcast_shape = BCast::ToShape(bcast.output_shape());\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsVector(shape_tensor.shape()),\n        errors::InvalidArgument(\"Input shape should be a vector, got shape: \",\n                                shape_tensor.shape().DebugString()));\n    TensorShape output_shape;\n    if (shape_tensor.dtype() == DataType::DT_INT32) {\n      OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(shape_tensor.vec<int32>(),\n                                                      &output_shape));\n    } else {\n      OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(\n                              shape_tensor.vec<int64_t>(), &output_shape));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::EndsWith(output_shape, bcast_shape),\n                errors::InvalidArgument(\n                    \"Shape passed in must end with broadcasted shape.\"));\n\n    int64_t samples_per_batch = 1;\n    const int64_t num_sample_dims =\n        (shape_tensor.dim_size(0) - bcast.output_shape().size());\n    for (int64_t i = 0; i < num_sample_dims; ++i) {\n      samples_per_batch *= output_shape.dim_size(i);\n    }\n    int64_t num_batches = 1;\n    for (int64_t i = num_sample_dims; i < shape_tensor.dim_size(0); ++i) {\n      num_batches *= output_shape.dim_size(i);\n    }\n    const int64_t num_elements = num_batches * samples_per_batch;\n\n    Tensor* samples_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape, &samples_tensor));\n\n    auto truncFunctor = functor::TruncatedNormalFunctorV2<Device, T>();\n    // Each worker has the same fudge factor, so use it here.\n    random::PhiloxRandom::Key key;\n    random::PhiloxRandom::ResultType counter;\n    OP_REQUIRES_OK(ctx, GenerateKey(seed_tensor, &key, &counter));\n\n    auto philox = random::PhiloxRandom(counter, key);\n\n    truncFunctor(ctx, ctx->eigen_device<Device>(), num_batches,\n                 samples_per_batch, num_elements, bcast, means_tensor.flat<T>(),\n                 stddevs_tensor.flat<T>(), minvals_tensor.flat<T>(),\n                 maxvals_tensor.flat<T>(), philox, samples_tensor->flat<T>());\n  }\n\n private:\n  TF_DISALLOW_COPY_AND_ASSIGN(StatelessParameterizedTruncatedNormal);\n};\n\n}  // namespace\n\n#define REGISTER(TYPE)                                                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParameterizedTruncatedNormal\")             \\\n                              .Device(DEVICE_CPU)                          \\\n                              .TypeConstraint<TYPE>(\"dtype\"),              \\\n                          ParameterizedTruncatedNormalOp<CPUDevice, TYPE>) \\\n  REGISTER_KERNEL_BUILDER(                                                 \\\n      Name(\"StatelessParameterizedTruncatedNormal\")                        \\\n          .HostMemory(\"shape\")                                             \\\n          .HostMemory(\"seed\")                                              \\\n          .HostMemory(\"means\")                                             \\\n          .HostMemory(\"stddevs\")                                           \\\n          .HostMemory(\"minvals\")                                           \\\n          .HostMemory(\"maxvals\")                                           \\\n          .Device(DEVICE_CPU)                                              \\\n          .TypeConstraint<TYPE>(\"dtype\"),                                  \\\n      StatelessParameterizedTruncatedNormal<CPUDevice, TYPE>)\n\nTF_CALL_half(REGISTER);\nTF_CALL_float(REGISTER);\nTF_CALL_double(REGISTER);\n\n#undef REGISTER\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#define REGISTER(TYPE)                                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParameterizedTruncatedNormal\") \\\n                              .Device(DEVICE_GPU)              \\\n                              .HostMemory(\"shape\")             \\\n                              .TypeConstraint<TYPE>(\"dtype\"),  \\\n                          ParameterizedTruncatedNormalOp<GPUDevice, TYPE>)\n\nTF_CALL_half(REGISTER);\nTF_CALL_float(REGISTER);\nTF_CALL_double(REGISTER);\n\n#undef REGISTER\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // end namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for ParameterizedTruncatedNormalOp.\"\"\"\n\nimport functools\nimport math\nimport timeit\n\nimport numpy as np\nfrom six.moves import range  # pylint: disable=redefined-builtin\n\nfrom tensorflow.core.protobuf import config_pb2\nfrom tensorflow.python.client import session\nfrom tensorflow.python.eager import backprop\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import random_seed\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import random_ops\nfrom tensorflow.python.ops import stateless_random_ops as stateless\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\nfrom tensorflow.python.platform import tf_logging\n\n\ndef _get_stddev_inside_bounds_before_using_randn(gpu):\n  # The boundary where the randn sampler is used varies between CPU and GPU.\n  if gpu:\n    return 1.3\n  else:\n    return 1.7\n\n\nclass TruncatedNormalMoments(object):\n  memoized_moments = None\n  mean = None\n  stddev = None\n  minval = None\n  maxval = None\n\n  def __init__(self, mean, stddev, minval, maxval):\n    self.memoized_moments = [1.0]  # 0th moment\n    self.mean = np.double(mean)\n    self.stddev = np.double(stddev)\n    # NOTE(ringwalt): The formula doesn't handle infinite values.\n    self.minval = np.double(max(-10, minval))\n    self.maxval = np.double(min(10, maxval))\n\n  def __getitem__(self, moment):\n    \"\"\"Calculates the truncated normal moments.\n\n    Args:\n      moment: The number for the moment.\n\n    Returns:\n      The value for the given moment.\n\n    Uses the recurrence relation described in:\n        http://www.smp.uq.edu.au/people/YoniNazarathy/teaching_projects\n            /studentWork/EricOrjebin_TruncatedNormalMoments.pdf\n    \"\"\"\n    assert moment > 0\n    # The test case must ensure it can import scipy.stats before this point.\n    import scipy.stats  # pylint: disable=g-import-not-at-top\n    dist = scipy.stats.norm(loc=self.mean, scale=self.stddev)\n    for k in range(len(self.memoized_moments), moment + 1):\n      m_k_minus_2 = self.memoized_moments[k - 2] if k > 1 else np.double(0.0)\n      m_k_minus_1 = self.memoized_moments[k - 1]\n      numerator = (np.power(self.maxval, k - 1) * dist.pdf(self.maxval) -\n                   np.power(self.minval, k - 1) * dist.pdf(self.minval))\n      denominator = dist.cdf(self.maxval) - dist.cdf(self.minval)\n      m = ((k - 1) * self.stddev**2 * m_k_minus_2 + self.mean * m_k_minus_1 -\n           self.stddev * numerator / denominator)\n      assert abs(m) < 1e50  # ensure numerical accuracy\n      self.memoized_moments.append(m)\n    return self.memoized_moments[moment]\n\n\ndef calculate_moments(samples, max_moment):\n  moments = [0.0] * (max_moment + 1)\n  for k in range(len(moments)):\n    moments[k] = np.mean(samples**k, axis=0)\n  return moments\n\n\ndef z_test(real, expected, i, num_samples):\n  numerical_error = 1e-6  # per-operation error\n  moment_mean = expected[i]\n  moment_squared = expected[2 * i]\n  moment_var = moment_squared - moment_mean * moment_mean\n\n  error_per_moment = i * numerical_error\n  total_variance = moment_var / float(num_samples) + error_per_moment\n  return abs((real[i] - moment_mean) / math.sqrt(total_variance))\n\n\nclass ParameterizedTruncatedNormalTest(test.TestCase):\n  z_limit = 6.0\n\n  # Stop at moment 10 to avoid numerical errors in the theoretical moments.\n  max_moment = 10\n\n  def validateMoments(self,\n                      shape,\n                      mean,\n                      stddev,\n                      minval,\n                      maxval,\n                      use_stateless=False,\n                      seed=1618):\n    try:\n      # TruncatedNormalMoments requires scipy.stats.\n      # Give up early if we are unable to import it.\n      random_seed.set_random_seed(seed)\n      with self.cached_session():\n        if use_stateless:\n          # Generate a seed that stateless ops can use.\n          new_seed = random_ops.random_uniform([2],\n                                               seed=seed,\n                                               minval=0,\n                                               maxval=(2**31 - 1),\n                                               dtype=np.int32)\n          samples = stateless.stateless_parameterized_truncated_normal(\n              shape, new_seed, mean, stddev, minval, maxval).eval()\n        else:\n          samples = random_ops.parameterized_truncated_normal(\n              shape, mean, stddev, minval, maxval).eval()\n        assert (~np.isnan(samples)).all()\n      moments = calculate_moments(samples, self.max_moment)\n      expected_moments = TruncatedNormalMoments(mean, stddev, minval, maxval)\n      num_samples = functools.reduce(lambda x, y: x * y, shape, 1)\n      for i in range(1, len(moments)):\n        self.assertLess(\n            z_test(moments, expected_moments, i, num_samples), self.z_limit)\n    except ImportError as e:\n      tf_logging.warn(\"Cannot test truncated normal op: %s\" % str(e))\n\n  def validateKolmogorovSmirnov(self,\n                                shape,\n                                mean,\n                                stddev,\n                                minval,\n                                maxval,\n                                use_stateless=False,\n                                seed=1618):\n    try:\n      import scipy.stats  # pylint: disable=g-import-not-at-top\n      random_seed.set_random_seed(seed)\n      with self.cached_session():\n        if use_stateless:\n          new_seed = random_ops.random_uniform([2],\n                                               seed=seed,\n                                               minval=0,\n                                               maxval=(2**31 - 1),\n                                               dtype=np.int32)\n          samples = stateless.stateless_parameterized_truncated_normal(\n              shape, new_seed, mean, stddev, minval, maxval).eval()\n        else:\n          samples = random_ops.parameterized_truncated_normal(\n              shape, mean, stddev, minval, maxval).eval()\n\n      assert (~np.isnan(samples)).all()\n      minval = max(mean - stddev * 10, minval)\n      maxval = min(mean + stddev * 10, maxval)\n      dist = scipy.stats.norm(loc=mean, scale=stddev)\n      cdf_min = dist.cdf(minval)\n      cdf_max = dist.cdf(maxval)\n\n      def truncated_cdf(x):\n        return np.clip((dist.cdf(x) - cdf_min) / (cdf_max - cdf_min), 0.0, 1.0)\n\n      pvalue = scipy.stats.kstest(samples, truncated_cdf)[1]\n      self.assertGreater(pvalue, 1e-10)\n    except ImportError as e:\n      tf_logging.warn(\"Cannot test truncated normal op: %s\" % str(e))\n\n  @test_util.run_deprecated_v1\n  def testDefaults(self):\n    self.validateMoments([int(1e5)], 0.0, 1.0, -2.0, 2.0)\n    self.validateMoments([int(1e5)], 0.0, 1.0, -2.0, 2.0, use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testShifted(self):\n    self.validateMoments([int(1e5)], -1.0, 1.0, -2.0, 2.0)\n    self.validateMoments([int(1e5)], -1.0, 1.0, -2.0, 2.0, use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testRightTail(self):\n    self.validateMoments([int(1e5)], 0.0, 1.0, 4.0, np.infty)\n    self.validateMoments([int(1e5)],\n                         0.0,\n                         1.0,\n                         4.0,\n                         np.infty,\n                         use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testLeftTail(self):\n    self.validateMoments([int(1e5)], 0.0, 1.0, -np.infty, -4.0)\n    self.validateMoments([int(1e5)],\n                         0.0,\n                         1.0,\n                         -np.infty,\n                         -4.0,\n                         use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testLeftTailTwoSidedBounds(self):\n    self.validateMoments([int(1e5)], 0.0, 1.0, -6.0, -3.0)\n    self.validateMoments([int(1e5)], 0.0, 1.0, -6.0, -3.0, use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  @test_util.disable_xla(\"Low probability region\")\n  def testTwoSidedLeftTailShifted(self):\n    self.validateKolmogorovSmirnov([int(1e5)], 6.0, 1.0, -1.0, 1.0)\n    self.validateKolmogorovSmirnov([int(1e5)],\n                                   6.0,\n                                   1.0,\n                                   -1.0,\n                                   1.0,\n                                   use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  @test_util.disable_xla(\"Low probability region\")\n  def testRightTailShifted(self):\n    self.validateMoments([int(1e5)], -5.0, 1.0, 2.0, np.infty)\n    self.validateMoments([int(1e5)],\n                         -5.0,\n                         1.0,\n                         2.0,\n                         np.infty,\n                         use_stateless=True)\n\n  # Take the normal distribution around the mean, but truncating the left tail\n  # far from the mean.\n  @test_util.run_deprecated_v1\n  def testTruncateOnLeft_entireTailOnRight(self):\n    self.validateKolmogorovSmirnov([int(1e5)], 10.0, 1.0, 4.0, np.infty)\n    self.validateKolmogorovSmirnov([int(1e5)],\n                                   10.0,\n                                   1.0,\n                                   4.0,\n                                   np.infty,\n                                   use_stateless=True)\n\n  # Take the normal distribution around the mean, but truncating the right tail.\n  @test_util.run_deprecated_v1\n  def testTruncateOnRight_entireTailOnLeft(self):\n    self.validateKolmogorovSmirnov([int(1e5)], -8, 1.0, -np.infty, -4.0)\n    self.validateKolmogorovSmirnov([int(1e5)],\n                                   -8.,\n                                   1.0,\n                                   -np.infty,\n                                   -4.0,\n                                   use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testSmallStddev(self):\n    self.validateKolmogorovSmirnov([int(1e5)], 0.0, 0.1, 0.05, 0.10)\n    self.validateKolmogorovSmirnov([int(1e5)],\n                                   0.0,\n                                   0.1,\n                                   0.05,\n                                   0.10,\n                                   use_stateless=True)\n\n  @test_util.run_deprecated_v1\n  def testSamplingWithSmallStdDevFarFromBound(self):\n    sample_op = random_ops.parameterized_truncated_normal(\n        shape=(int(1e5),), means=0.8, stddevs=0.05, minvals=-1., maxvals=1.)\n    new_seed = random_ops.random_uniform([2],\n                                         seed=1234,\n                                         minval=0,\n                                         maxval=(2**31 - 1),\n                                         dtype=np.int32)\n    sample_op_stateless = stateless.stateless_parameterized_truncated_normal(\n        shape=(int(1e5),),\n        seed=new_seed,\n        means=0.8,\n        stddevs=0.05,\n        minvals=-1.,\n        maxvals=1.)\n\n    with self.session() as sess:\n      samples, samples_stateless = sess.run([sample_op, sample_op_stateless])\n      # 0. is more than 16 standard deviations from the mean, and\n      # should have a likelihood < 1e-57.\n      assert (~np.isnan(samples)).all()\n      assert (~np.isnan(samples_stateless)).all()\n      self.assertAllGreater(samples, 0.)\n      self.assertAllGreater(samples_stateless, 0.)\n\n  def testShapeTypes(self):\n    for shape_dtype in [np.int32, np.int64]:\n      shape = np.array([1000], dtype=shape_dtype)\n      sample_op = random_ops.parameterized_truncated_normal(\n          shape=shape, means=0.0, stddevs=0.1, minvals=-1., maxvals=1.)\n      new_seed = random_ops.random_uniform([2],\n                                           seed=1234,\n                                           minval=0,\n                                           maxval=(2**31 - 1),\n                                           dtype=np.int32)\n      sample_op_stateless = stateless.stateless_parameterized_truncated_normal(\n          shape=shape,\n          seed=new_seed,\n          means=0.0,\n          stddevs=0.1,\n          minvals=-1.,\n          maxvals=1.)\n\n      samples = self.evaluate(sample_op)\n      stateless_samples = self.evaluate(sample_op_stateless)\n      self.assertAllEqual(samples.shape, shape)\n      self.assertAllEqual(stateless_samples.shape, shape)\n\n  def testStatelessParameterizedTruncatedNormalHasGrads(self):\n    mean = variables.Variable(0.01)\n    stddev = variables.Variable(1.)\n    minval = variables.Variable(-1.)\n    maxval = variables.Variable(1.)\n\n    with self.cached_session() as sess:\n      with backprop.GradientTape(persistent=True) as tape:\n        samples = stateless.stateless_parameterized_truncated_normal(\n            [1], [1, 2], mean, stddev, minval, maxval)\n\n      sess.run(variables.variables_initializer([mean, stddev, minval, maxval]))\n      [mean_grad, std_grad], mean_actual_grad, std_actual_grad = sess.run([\n          tape.gradient(samples, [mean, stddev]),\n          array_ops.ones_like(mean),\n          (samples - mean) / stddev])\n      self.assertAllClose(mean_grad, mean_actual_grad)\n      self.assertAllClose(std_grad, std_actual_grad[0])\n\n      try:\n        import scipy.stats  # pylint:disable=g-import-not-at-top\n        truncnorm = scipy.stats.truncnorm(a=-1., b=1., loc=0., scale=1.)\n        samples_np, [minval_grad, maxval_grad] = sess.run([\n            samples, tape.gradient(samples, [minval, maxval])])\n\n        sample_cdf = truncnorm.cdf(samples_np)\n        # These come from the implicit reparameterization trick.\n        scipy_maxval_grad = np.exp(\n            0.5 * (samples_np ** 2 - ((1. - 0.01) / 1.) ** 2) +\n            np.log(sample_cdf))\n\n        scipy_minval_grad = np.exp(\n            0.5 * (samples_np ** 2 - ((-1. - 0.01) / 1.) ** 2) +\n            np.log1p(-sample_cdf))\n\n        self.assertAllClose(minval_grad, scipy_minval_grad[0], rtol=1e-2)\n        self.assertAllClose(maxval_grad, scipy_maxval_grad[0], rtol=1e-2)\n\n      except ImportError as e:\n        tf_logging.warn(\"Cannot test truncated normal op: %s\" % str(e))\n\n  @test_util.run_deprecated_v1\n  def testSamplingAtRandnSwitchover(self):\n    # The randn sampler is used as the bounds are moved farther from the mean,\n    # and the probability of accepting a sample increases the farther the\n    # bounds are from the mean.\n    # This test asserts that at the point of switchover, both samplers are\n    # working (not raising an error or returning nan) and returning the\n    # expected moments.\n    use_gpu = test.is_gpu_available()\n    stddev_inside_bounds_before_using_randn = (\n        _get_stddev_inside_bounds_before_using_randn(use_gpu))\n\n    epsilon = 0.001\n    self.validateMoments(\n        shape=[int(1e6)],\n        mean=0.,\n        stddev=1.0,\n        minval=-epsilon,\n        maxval=stddev_inside_bounds_before_using_randn - epsilon)\n    self.validateMoments(\n        shape=[int(1e6)],\n        mean=0.,\n        stddev=1.0,\n        minval=-epsilon,\n        maxval=stddev_inside_bounds_before_using_randn + epsilon)\n\n    self.validateMoments(\n        shape=[int(1e6)],\n        mean=0.,\n        stddev=1.0,\n        minval=-epsilon,\n        maxval=stddev_inside_bounds_before_using_randn - epsilon,\n        use_stateless=True)\n    self.validateMoments(\n        shape=[int(1e6)],\n        mean=0.,\n        stddev=1.0,\n        minval=-epsilon,\n        maxval=stddev_inside_bounds_before_using_randn + epsilon,\n        use_stateless=True)\n\n\n# Benchmarking code\ndef parameterized_vs_naive(shape, num_iters, use_gpu=False):\n  np.random.seed(1618)  # Make it reproducible.\n\n  # No CSE/CF.\n  optimizer_options = config_pb2.OptimizerOptions(\n      opt_level=config_pb2.OptimizerOptions.L0)\n  config = config_pb2.ConfigProto(graph_options=config_pb2.GraphOptions(\n      optimizer_options=optimizer_options))\n\n  with session.Session(config=config) as sess:\n    with ops.device(\"/cpu:0\" if not use_gpu else None):\n      param_op = control_flow_ops.group(\n          random_ops.parameterized_truncated_normal(shape))\n      naive_op = control_flow_ops.group(random_ops.truncated_normal(shape))\n\n    # Burn-in to avoid session setup costs in the timing.\n    sess.run(param_op)\n    sess.run(param_op)\n    param_dt = timeit.timeit(lambda: sess.run(param_op), number=num_iters)\n    sess.run(naive_op)\n    sess.run(naive_op)\n    naive_dt = timeit.timeit(lambda: sess.run(naive_op), number=num_iters)\n    return param_dt, naive_dt\n\n\ndef randn_sampler_switchover(shape, num_iters, use_gpu=False):\n  # Benchmark by constructing samplers on the threshold of using the randn\n  # rejection sampling and check that this threshold is set correctly by\n  # benchmarking with bounds just above and below this threshold.\n  # The uniform and randn samplers should have about the same performance\n  # at this point.\n\n  stddev_inside_bounds_before_using_randn = (\n      _get_stddev_inside_bounds_before_using_randn(use_gpu))\n\n  epsilon = 0.001\n\n  np.random.seed(1618)  # Make it reproducible.\n\n  # No CSE/CF.\n  optimizer_options = config_pb2.OptimizerOptions(\n      opt_level=config_pb2.OptimizerOptions.L0)\n  config = config_pb2.ConfigProto(\n      graph_options=config_pb2.GraphOptions(\n          optimizer_options=optimizer_options))\n\n  with session.Session(config=config) as sess:\n    with ops.device(\"/cpu:0\" if not use_gpu else \"/gpu:0\"):\n      uniform_sampler_op = control_flow_ops.group(\n          random_ops.parameterized_truncated_normal(\n              shape,\n              means=0.,\n              stddevs=1.0,\n              minvals=-stddev_inside_bounds_before_using_randn + epsilon,\n              maxvals=0.01))\n      randn_sampler_op = control_flow_ops.group(\n          random_ops.parameterized_truncated_normal(\n              shape,\n              means=0.,\n              stddevs=1.0,\n              minvals=-stddev_inside_bounds_before_using_randn - epsilon,\n              maxvals=0.01))\n\n    # Burn-in to avoid session setup costs in the timing.\n    sess.run(uniform_sampler_op)\n    sess.run(uniform_sampler_op)\n    uniform_dt = timeit.timeit(\n        lambda: sess.run(uniform_sampler_op), number=num_iters)\n\n    sess.run(randn_sampler_op)\n    sess.run(randn_sampler_op)\n    randn_dt = timeit.timeit(\n        lambda: sess.run(randn_sampler_op), number=num_iters)\n\n    return randn_dt, uniform_dt\n\n\nclass TruncatedNormalBenchmark(test.Benchmark):\n\n  def benchmarkParameterizedOpVsNaiveOpCpu(self):\n    self._benchmarkParameterizedOpVsNaiveOp(False)\n\n  def benchmarkParameterizedOpVsNaiveOpGpu(self):\n    self._benchmarkParameterizedOpVsNaiveOp(True)\n\n  def _benchmarkParameterizedOpVsNaiveOp(self, use_gpu):\n    num_iters = 50\n    print((\"Composition of new ParameterizedTruncatedNormalOp vs. \"\n           \"naive TruncatedNormalOp [%d iters]\") % num_iters)\n    print(\"Shape\\tsec(parameterized)\\tsec(naive)\\tspeedup\")\n\n    for shape in [[10000, 100], [1000, 1000], [1000000], [100, 100, 100],\n                  [20, 20, 20, 20]]:\n      p_dt, n_dt = parameterized_vs_naive(shape, num_iters, use_gpu)\n      print(\"%s\\t%.3f\\t%.3f\\t%.2f\" % (shape, p_dt, n_dt, p_dt / n_dt))\n\n      shape_str = \"-\".join(map(str, shape))\n      self.report_benchmark(\n          name=\"parameterized_shape\" + shape_str,\n          iters=num_iters,\n          wall_time=p_dt)\n      self.report_benchmark(\n          name=\"naive_shape\" + shape_str, iters=num_iters, wall_time=n_dt)\n\n  def benchmarkRandnSamplerCPU(self):\n    self._benchmarkRandnSampler(False)\n\n  def benchmarkRandnSamplerGPU(self):\n    self._benchmarkRandnSampler(True)\n\n  def _benchmarkRandnSampler(self, use_gpu):\n    num_iters = 100\n    shape = [int(1e6)]\n    randn_dt, uniform_dt = randn_sampler_switchover(shape, num_iters, use_gpu)\n\n    print((\"Randn Sampler vs uniform samplers [%d iters]\\t%.4f\\t%.4f\") %\n          (num_iters, randn_dt, uniform_dt))\n\n    gpu_str = \"_gpu\" if use_gpu else \"_cpu\"\n    self.report_benchmark(\n        name=\"randn_sampler\" + gpu_str, iters=num_iters, wall_time=randn_dt)\n    self.report_benchmark(\n        name=\"uniform_sampler\" + gpu_str, iters=num_iters, wall_time=uniform_dt)\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/parameterized_truncated_normal_op.cc", "tensorflow/python/kernel_tests/random/parameterized_truncated_normal_op_test.py"], "buggy_code_start_loc": [34, 305], "buggy_code_end_loc": [647, 305], "fixing_code_start_loc": [35, 306], "fixing_code_end_loc": [645, 329], "type": "CWE-617", "message": "TensorFlow is an open source platform for machine learning. `ParameterizedTruncatedNormal` assumes `shape` is of type `int32`. A valid `shape` of type `int64` results in a mismatched type `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 72180be03447a10810edca700cbc9af690dfeb51. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-35984", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-16T22:15:11.367", "lastModified": "2022-09-20T14:53:45.860", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. `ParameterizedTruncatedNormal` assumes `shape` is of type `int32`. A valid `shape` of type `int64` results in a mismatched type `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 72180be03447a10810edca700cbc9af690dfeb51. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. \"ParameterizedTruncatedNormal\" asume que \"shape\" es de tipo \"int32\". Una forma v\u00e1lida de tipo \"int64\" resulta en un fallo de tipo \"CHECK\" que puede ser usado para desencadenar un ataque de denegaci\u00f3n de servicio. Hemos parcheado el problema en el commit 72180be03447a10810edca700cbc9af690dfeb51 de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.10.0. Tambi\u00e9n seleccionaremos este compromiso en TensorFlow versi\u00f3n 2.9.1, TensorFlow versi\u00f3n 2.8.1, y TensorFlow versi\u00f3n 2.7.2, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C6622D95-1C86-45C5-AB55-E6EEEA0996DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.1", "matchCriteriaId": "0F9D273D-02DC-441E-AA91-EAC8DEAA4B44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.1", "matchCriteriaId": "FE4F8A81-6CC2-4F7F-9602-C170FDD926E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc0:*:*:*:*:*:*", "matchCriteriaId": "1DBFBCE2-0A01-4575-BE45-6775ABFB8B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "89806CF9-E423-4CA6-A01A-8175C260CB24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "F2B80690-A257-4E16-BD27-9AE045BC56ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc3:*:*:*:*:*:*", "matchCriteriaId": "F335F9A4-5AB8-4E53-BC18-E01F7C653E5E"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/72180be03447a10810edca700cbc9af690dfeb51", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-p2xf-8hgm-hpw5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/72180be03447a10810edca700cbc9af690dfeb51"}}