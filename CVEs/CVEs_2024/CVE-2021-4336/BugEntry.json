{"buggy_code": ["<?php defined('SYSPATH') OR die('No direct access allowed.');\n\n/**\n * Model for scheduled reports\n */\nclass Scheduled_reports_Model extends Model\n{\n\tconst USERFIELD = 'username'; /**< Name of username column in database */\n\n\t/**\n\t * Given a scheduled report id, delet it from db\n\t */\n\tstatic function delete_scheduled_report($id=false)\n\t{\n\t\t$id = (int)$id;\n\t\tif (empty($id)) return false;\n\t\t$sql = \"DELETE FROM scheduled_reports WHERE id=\".$id;\n\t\t$db = Database::instance();\n\t\t$db->query($sql);\n\t\treturn true;\n\t}\n\n\t/**\n\t*\tDelete ALL schedules for a certain report_id and type\n\t*/\n\tstatic function delete_all_scheduled_reports($type='avail',$id=false)\n\t{\n\t\t$type = strtolower($type);\n\t\t$db = Database::instance();\n\n\t\t# what report_type_id do we have?\n\t\t$sql = \"SELECT id FROM scheduled_report_types WHERE identifier=\".$db->escape($type);\n\t\t$res = $db->query($sql);\n\t\tif (!count($res))\n\t\t\treturn false;\n\t\t\t# bail out if we can't find report_type\n\n\t\t$row = $res->current();\n\t\t$report_type_id = $row->id;\n\t\t$sql = \"DELETE FROM scheduled_reports WHERE report_type_id=\".$report_type_id.\" AND report_id=\".$id;\n\t\ttry {\n\t\t\t$db->query($sql);\n\t\t} catch (Kohana_Database_Exception $e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Fetches all scheduled reports of current report type (avail/sla)\n\t *\n\t * @param $type string: {avail, sla, summary}\n\t * @return res\n\t */\n\tpublic static function get_scheduled_reports($type)\n\t{\n\t\t$type = strtolower($type);\n\n\t\t$db = Database::instance();\n\n\t\t$sql_xtra = '';\n\t\t$auth = op5auth::instance();\n\t\tif (!$auth->authorized_for('host_view_all')) {\n\t\t\t$sql_xtra = ' AND sr.'.self::USERFIELD.'='.$db->escape(Auth::instance()->get_user()->get_username()).' ';\n\t\t}\n\n\t\t$sql = \"SELECT\n\t\t\t\tsr.*,\n\t\t\t\trp.periodname,\n\t\t\t\tr.report_name AS reportname\n\t\t\tFROM\n\t\t\t\tscheduled_reports sr,\n\t\t\t\tscheduled_report_types rt,\n\t\t\t\tscheduled_report_periods rp,\n\t\t\t\tsaved_reports r\n\t\t\tWHERE\n\t\t\t\trt.identifier='\".$type.\"' AND\n\t\t\t\tsr.report_type_id=rt.id AND\n\t\t\t\trp.id=sr.period_id AND\n\t\t\t\tsr.report_id=r.id\".$sql_xtra.\"\n\t\t\tORDER BY\n\t\t\t\treportname\";\n\n\t\t$res = $db->query($sql);\n\t\treturn $res;\n\t}\n\n\t/**\n\t * Checks if a report is scheduled in autoreports\n\t *\n\t * @param $type string: {avail, sla}\n\t * @param $id int The report id\n\t * @return Array on success. False on error.\n\t */\n\tstatic function report_is_scheduled($type='avail', $id=false)\n\t{\n\t\t$type = strtolower($type);\n\n\t\t$id = (int)$id;\n\t\tif (!$id) return false;\n\t\t$res = self::get_scheduled_reports($type);\n\t\tif (!$res || count($res)==0) {\n\t\t\treturn false;\n\t\t}\n\t\t$return = false;\n\t\t$res->result(false);\n\t\tforeach ($res as $row) {\n\t\t\tif ($row['report_id'] == $id) {\n\t\t\t\t$return[] = $row;\n\t\t\t}\n\t\t}\n\t\treturn $return;\n\t}\n\n\t/**\n\t * Get available report periods\n\t * @return array [id] => string. False on errors.\n\t */\n\tstatic function get_available_report_periods()\n\t{\n\t\t$sql = \"SELECT * from scheduled_report_periods\";\n\t\t$db = Database::instance();\n\t\t$res = $db->query($sql);\n\t\tif(!$res || count($res)==0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$periods = array();\n\t\tforeach ($res as $period_row) {\n\t\t\t$periods[$period_row->id] = $period_row->periodname;\n\t\t}\n\t\treturn $periods;\n\t}\n\n\t/**\n\t * Retrieves the value of a db field for a report id\n\t * @param $type the database column\n\t * @param $id the id of the scheduled report\n\t */\n\tstatic function fetch_scheduled_field_value($type=false, $id=false)\n\t{\n\t\t$id = (int)$id;\n\t\t$type = trim($type);\n\t\tif (empty($type) || empty($id)) return false;\n\t\t$sql = \"SELECT $type FROM scheduled_reports WHERE id=\".$id;\n\t\t$db = Database::instance();\n\t\t$res = $db->query($sql);\n\t\tif (!$res || count($res) == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t$row = $res->current();\n\t\treturn $row->{$type};\n\t}\n\n\t/**\n\t * @param $id = false\n\t * @param $rep_type = false\n\t * @param $saved_report_id = false\n\t * @param $period = false\n\t * @param $recipients = false comma separated\n\t * @param $filename = ''\n\t * @param $description = ''\n\t * @param $local_persistent_filepath = ''\n\t * @param $attach_description = ''\n\t * @param $report_time = false\n\t * @param $report_on = false\n\t * @param $report_period = false\n\t * @return string|int either error string or the report's id\n\t */\n\tstatic public function edit_report($id=false, $rep_type=false, $saved_report_id=false, $period=false, $recipients=false, $filename='', $description='', $local_persistent_filepath = '', $attach_description = 0, $report_time=false, $report_on=false, $report_period=false)\n\t{\n\n\t\t$local_persistent_filepath = trim($local_persistent_filepath);\n\t\tif($local_persistent_filepath && !is_writable(rtrim($local_persistent_filepath, '/').'/')) {\n\t\t\treturn _(\"File path '$local_persistent_filepath' is not writable\");\n\t\t}\n\t\t$db = Database::instance();\n\t\t$id = (int)$id;\n\t\t$rep_type = (int)$rep_type;\n\t\t$saved_report_id = (int)$saved_report_id;\n\t\t$period\t= (int)$period;\n\t\t$report_time = trim($report_time);\n\t\t$report_on = trim($report_on);\n\t\t$report_period = trim($report_period);\n\t\t$recipients = trim($recipients);\n\t\t$filename = trim($filename);\n\t\t$description = trim($description);\n\t\t$attach_description = (int) $attach_description;\n\t\t$user = Auth::instance()->get_user()->get_username();\n\n\t\tif (!$rep_type || !$saved_report_id || !$period || empty($recipients)) return _('Missing data');\n\n\t\t// some users might use ';' to separate email adresses\n\t\t// just replace it with ',' and continue\n\t\t$recipients = str_replace(';', ',', $recipients);\n\t\t$rec_arr = explode(',', $recipients);\n\t\tif (!empty($rec_arr)) {\n\t\t\tforeach ($rec_arr as $recipient) {\n\t\t\t\tif (trim($recipient)!='') {\n\t\t\t\t\t$checked_recipients[] = trim($recipient);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$recipients = implode(', ', $checked_recipients);\n\t\t}\n\n\t\tif ($id) {\n\t\t\t// UPDATE\n\t\t\t$sql = \"UPDATE scheduled_reports SET \".self::USERFIELD.\"=\".$db->escape($user).\", report_type_id=\".$rep_type.\", report_id=\".$saved_report_id.\", recipients=\".$db->escape($recipients).\", period_id=\".$period.\", filename=\".$db->escape($filename).\", description=\".$db->escape($description).\", local_persistent_filepath = \".$db->escape($local_persistent_filepath).\", attach_description = \".$db->escape($attach_description).\" WHERE id=\".$id;\n\t\t} else {\n\t\t\t$sql = \"INSERT INTO scheduled_reports (\".self::USERFIELD.\", report_type_id, report_id, recipients, period_id, filename, description, local_persistent_filepath, attach_description, report_time, report_on, report_period)VALUES(\".$db->escape($user).\", \".$rep_type.\", \".$saved_report_id.\", \".$db->escape($recipients).\", \".$period.\", \".$db->escape($filename).\", \".$db->escape($description).\", \".$db->escape($local_persistent_filepath).\", \".$db->escape($attach_description).\", '\".$report_time.\"', '\".$report_on.\"', '\".$report_period.\"' )\";\n\n\t\t}\n\n\t\ttry {\n\t\t\t$res = $db->query($sql);\n\t\t} catch (Kohana_Database_Exception $e) {\n\t\t\treturn _('DATABASE ERROR').\": {$e->getMessage()}; $sql\";\n\t\t}\n\n\t\tif (!$id) {\n\t\t\t$id = $res->insert_id();\n\t\t}\n\t\treturn $id;\n\t}\n\n\t/**\n\t * Update specific field for certain scheduled report\n\t * Called from reports_Controller::save_schedule_item() through ajax\n\t *\n\t * @param $id int: The id of the report.\n\t * @param $field string: The report field to update.\n\t * @param $value string: The new value.\n\t * @return true on succes. false on errors.\n\t */\n\tstatic function update_report_field($id=false, $field=false, $value=false)\n\t{\n\t\t$id = (int)$id;\n\t\t$field = trim($field);\n\t\t$value = trim($value);\n\t\t$db = Database::instance();\n\t\t$sql = \"UPDATE scheduled_reports SET \".$field.\"= \".$db->escape($value).\" WHERE id=\".$id;\n\t\ttry {\n\t\t\t$res = $db->query($sql);\n\t\t} catch (Kohana_Database_Exception $e) {\n\t\t\tprint $e->getMessage();\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get the type of a report.\n\t *\n\t * @param $id The id of the report.\n\t * @return Report type on success. False on errors.\n\t */\n\tstatic function get_typeof_report($id=false)\n\t{\n\t\t$sql = \"SELECT t.identifier FROM scheduled_reports sr, scheduled_report_types t WHERE \".\"sr.id=\".(int)$id.\" AND t.id=sr.report_type_id\";\n\t\t$db = Database::instance();\n\t\ttry {\n\t\t\t$res = $db->query($sql);\n\t\t} catch (Kohana_Database_Exception $e) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn count($res)!=0 ? $res->current()->identifier : false;\n\t}\n\n\t/**\n\t * Get the id of a named report\n\t *\n\t * @param $identifier string: The name of the report\n\t * @return False on errors. Id of the report on success.\n\t */\n\tstatic function get_report_type_id($identifier=false)\n\t{\n\t\t$db = Database::instance();\n\t\t$sql = \"SELECT id FROM scheduled_report_types WHERE identifier=\".$db->escape($identifier);\n\t\ttry {\n\t\t\t$res = $db->query($sql);\n\t\t} catch (Kohana_Database_Exception $e) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$id = false;\n\t\tif (count($res)!=0) {\n\t\t\t$res = $res->current();\n\t\t\t$id = $res->id;\n\t\t}\n\t\treturn $id;\n\t}\n\n\t/**\n\t*\tFetch info on all defined report types, i.e all\n\t* \ttypes we can schedule\n\t*/\n\tstatic function get_all_report_types()\n\t{\n\t\t$db = Database::instance();\n\t\t$sql = \"SELECT * FROM scheduled_report_types ORDER BY id\";\n\t\t$res = $db->query($sql);\n\t\treturn count($res) != 0 ? $res : false;\n\t}\n\n\t/**\n\t * Fetch all info for a specific schedule.\n\t * This includes all relevant data about both schedule\n\t * and the report.\n\t *\n\t * @param $schedule_id The id of the schedule we're interested in.\n\t * @return False on errors. Array with scheduling information on success.\n\t */\n\tstatic function get_scheduled_data($schedule_id=false)\n\t{\n\t\t$schedule_id = (int)$schedule_id;\n\t\tif (!$schedule_id) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$sql = \"SELECT sr.recipients, sr.filename, sr.local_persistent_filepath, sr.report_id FROM \".\"scheduled_reports sr \".\"WHERE sr.id=\".$schedule_id;\n\t\t$db = Database::instance();\n\t\t$res = $db->query($sql)->result_array(false);\n\t\tif (!$res)\n\t\t\treturn false;\n\t\treturn $res[0];\n\t}\n\n\t/**\n\t * Fetch info on reports to be sent for specific\n\t * period (daily/weekly/monthly)\n\t *\n\t * @param $period_str string: { schedule }\n\t * @return array\n\t */\n\tstatic function get_period_schedules($period_str)\n\t{\n\t\t$schedules = array();\n\t\t$send_date = array();\n\t\t$default_timezone = date_default_timezone_get();\n\n\t\t$db = Database::instance();\n\n\t\t$sql = <<<'SQL'\n\t\tSELECT sr.*, rp.periodname, opt.value AS timezone\n\t\tFROM scheduled_reports sr\n\t\tINNER JOIN scheduled_report_periods rp ON rp.id = sr.period_id\n\t\tLEFT JOIN saved_reports_options opt ON opt.report_id = sr.report_id\n\t\t\tAND opt.name = 'report_timezone'\nSQL;\n\t\t$res = $db->query($sql);\n\n\t\tforeach($res as $row){\n\t\t\t$report_period = json_decode($row->report_period);\n\t\t\t$report_time = $row->report_time;\n\t\t\tif($row->timezone){\n\t\t\t\t// All times for this schedule use the timezone of the associated report.\n\t\t\t\tdate_default_timezone_set($row->timezone);\n\t\t\t}\n\n\t\t\t$repeat_no = $report_period->no;\n\t\t\t$last_sent = $row->last_sent;\n\t\t\t$now = new DateTime();\n\n\t\t\t/* Avoid sending reports before report_time each day, even if they\n\t\t\t * are late for some reason. This means that a report that is due\n\t\t\t * to be sent at tuesday 08:00 but for some reason couldn't be sent\n\t\t\t * on tuesday, it will be sent the next day, but not before 08:00.\n\t\t\t */\n\t\t\t$report_time_of_day = new DateTime($now->format('Y-m-d') . \" $report_time\");\n\t\t\tif ($now < $report_time_of_day) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ($row->periodname == 'Daily') {\n\t\t\t\t$last_sent_date = $last_sent ? $last_sent : \"today - $repeat_no days\";\n\t\t\t\t$prev_period_start = new DateTime(\"$last_sent_date $report_time\");\n\n\t\t\t\t// Period where report should be generated next time.\n\t\t\t\t$period_start = new DateTime(\n\t\t\t\t\t$prev_period_start->format('c') . \" + $repeat_no days\");\n\n\t\t\t\tif ($now >= $period_start) {\n\t\t\t\t\t// We're beyond period_start, create the report.\n\t\t\t\t\t$schedules[] = $row->id;\n\t\t\t\t\t$send_date[] = $now->format('Y-m-d');\n\t\t\t\t}\n\t\t\t}\n\t\t\telseif ($row->periodname == 'Weekly') {\n\t\t\t\t$last_sent_date = $last_sent ? $last_sent : \"today - $repeat_no weeks\";\n\t\t\t\t$prev_period_start = new DateTime(\"$last_sent_date $report_time\");\n\n\t\t\t\t// Period where report should be generated next time.\n\t\t\t\t$period_start = new DateTime(\n\t\t\t\t\t$prev_period_start->format('c') . \" + $repeat_no weeks\");\n\n\t\t\t\t$report_days = json_decode($row->report_on);\n\n\t\t\t\tif ($now >= $period_start) {\n\t\t\t\t\t// We're beyond period_start, in a new period, proceed with\n\t\t\t\t\t// creating the report if correct day of week.\n\t\t\t\t\tforeach ($report_days as $day) {\n\t\t\t\t\t\tif ($day->day == $now->format('w')) {\n\t\t\t\t\t\t\t$schedules[] = $row->id;\n\t\t\t\t\t\t\t$send_date[] = $now->format('Y-m-d');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telseif ($now > $prev_period_start) {\n\t\t\t\t\t// Skip if day of week is the same as that of last_sent.\n\t\t\t\t\tif ($now->format('w') == $prev_period_start->format('w')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Still in previous period, check if report should be\n\t\t\t\t\t// created this weekday also.\n\t\t\t\t\tforeach ($report_days as $day) {\n\t\t\t\t\t\tif ($day->day == $now->format('w')) {\n\t\t\t\t\t\t\t$schedules[] = $row->id;\n\t\t\t\t\t\t\t$send_date[] = $now->format('Y-m-d');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telseif ($row->periodname == 'Monthly') {\n\t\t\t\t$last_sent_month = new DateTime(\n\t\t\t\t\t$last_sent ? $last_sent : \"today - $repeat_no months\");\n\t\t\t\t// Reset to first day of month, since day of month is not relevant.\n\t\t\t\t$last_sent_month->modify('first day of this month');\n\n\t\t\t\t// Month in which report should be generated next time.\n\t\t\t\t$next_send_month = new DateTime(\n\t\t\t\t\t$last_sent_month->format('Y-m-d') . \"+ $repeat_no months\");\n\n\t\t\t\t// Skip if we're not yet in next_send_month.\n\t\t\t\tif ($now < $next_send_month) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$report_on = json_decode($row->report_on);\n\t\t\t\t$day_of_week = $report_on->day;  # 1-7, last, first\n\n\t\t\t\t$is_report_day = false;\n\t\t\t\tif ($day_of_week == 'last') {\n\t\t\t\t\t// Send if this is the last day of the month.\n\t\t\t\t\t$tomorrow = strtotime('+ 1 day', $now->getTimestamp());\n\t\t\t\t\tif (date('n', $tomorrow) != $now->format('n')) {\n\t\t\t\t\t\t$is_report_day = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telseif ($day_of_week == 'first') {\n\t\t\t\t\t// Send if this is the first day of the month.\n\t\t\t\t\tif ($now->format('j') == '1') {\n\t\t\t\t\t\t$is_report_day = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telseif ($day_of_week == $now->format('w')) {\n\t\t\t\t\t$day_ordinal = $report_on->day_no;  # 1-4, last\n\t\t\t\t\tif ($day_ordinal == 'last') {\n\t\t\t\t\t\t// Check if this is the last $day_of_week of the month\n\t\t\t\t\t\t$next_week = strtotime('+ 1 week', $now->getTimestamp());\n\t\t\t\t\t\tif (date('n', $next_week) != $now->format('n')) {\n\t\t\t\t\t\t\t$is_report_day = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Check if today is $day_ordinal $day_of_week (e.g. 3rd Friday)\n\t\t\t\t\t\t$check_weeks_before = $day_ordinal - 1;\n\t\t\t\t\t\t$this_month = new DateTime(\"- $check_weeks_before week\");\n\t\t\t\t\t\t$prev_month = new DateTime(\"- $day_ordinal week\");\n\t\t\t\t\t\tif ($this_month->format('n') == $now->format('n')\n\t\t\t\t\t\t\t\t&& $prev_month->format('n') != $now->format('n')) {\n\t\t\t\t\t\t\t$is_report_day = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Send report if today is the report day and if time of day\n\t\t\t\t// has passed the scheduled report time.\n\t\t\t\tif ($is_report_day) {\n\t\t\t\t\t$schedules[] = $row->id;\n\t\t\t\t\t$send_date[] = $now->format('Y-m-d');\n\t\t\t\t}\n\t\t\t}\n\t\t\tdate_default_timezone_set($default_timezone);\n\t\t}\n\n\t\tforeach($schedules as $i => $schedule_id ){\n\t\t\tself::update_report_field($schedule_id, \"last_sent\", $send_date[$i]);\n\t\t}\n\n\t\treturn $schedules;\n\t}\n}\n"], "fixing_code": ["<?php defined('SYSPATH') OR die('No direct access allowed.');\n\n/**\n * Model for scheduled reports\n */\nclass Scheduled_reports_Model extends Model\n{\n\tconst USERFIELD = 'username'; /**< Name of username column in database */\n\n\t/**\n\t * Given a scheduled report id, delet it from db\n\t */\n\tstatic function delete_scheduled_report($id=false)\n\t{\n\t\t$id = (int)$id;\n\t\tif (empty($id)) return false;\n\t\t$sql = \"DELETE FROM scheduled_reports WHERE id=\".$id;\n\t\t$db = Database::instance();\n\t\t$db->query($sql);\n\t\treturn true;\n\t}\n\n\t/**\n\t*\tDelete ALL schedules for a certain report_id and type\n\t*/\n\tstatic function delete_all_scheduled_reports($type='avail',$id=false)\n\t{\n\t\t$type = strtolower($type);\n\t\t$db = Database::instance();\n\n\t\t# what report_type_id do we have?\n\t\t$sql = \"SELECT id FROM scheduled_report_types WHERE identifier=\".$db->escape($type);\n\t\t$res = $db->query($sql);\n\t\tif (!count($res))\n\t\t\treturn false;\n\t\t\t# bail out if we can't find report_type\n\n\t\t$row = $res->current();\n\t\t$report_type_id = $row->id;\n\t\t$sql = \"DELETE FROM scheduled_reports WHERE report_type_id=\".$db->escape($report_type_id).\" AND report_id=\".$db->escape($id);\n\t\ttry {\n\t\t\t$db->query($sql);\n\t\t} catch (Kohana_Database_Exception $e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Fetches all scheduled reports of current report type (avail/sla)\n\t *\n\t * @param $type string: {avail, sla, summary}\n\t * @return res\n\t */\n\tpublic static function get_scheduled_reports($type)\n\t{\n\t\t$type = strtolower($type);\n\n\t\t$db = Database::instance();\n\n\t\t$sql_xtra = '';\n\t\t$auth = op5auth::instance();\n\t\tif (!$auth->authorized_for('host_view_all')) {\n\t\t\t$sql_xtra = ' AND sr.'.self::USERFIELD.'='.$db->escape(Auth::instance()->get_user()->get_username()).' ';\n\t\t}\n\n\t\t$sql = \"SELECT\n\t\t\t\tsr.*,\n\t\t\t\trp.periodname,\n\t\t\t\tr.report_name AS reportname\n\t\t\tFROM\n\t\t\t\tscheduled_reports sr,\n\t\t\t\tscheduled_report_types rt,\n\t\t\t\tscheduled_report_periods rp,\n\t\t\t\tsaved_reports r\n\t\t\tWHERE\n\t\t\t\trt.identifier=\".$db->escape($type).\" AND\n\t\t\t\tsr.report_type_id=rt.id AND\n\t\t\t\trp.id=sr.period_id AND\n\t\t\t\tsr.report_id=r.id\".$sql_xtra.\"\n\t\t\tORDER BY\n\t\t\t\treportname\";\n\n\t\t$res = $db->query($sql);\n\t\treturn $res;\n\t}\n\n\t/**\n\t * Checks if a report is scheduled in autoreports\n\t *\n\t * @param $type string: {avail, sla}\n\t * @param $id int The report id\n\t * @return Array on success. False on error.\n\t */\n\tstatic function report_is_scheduled($type='avail', $id=false)\n\t{\n\t\t$type = strtolower($type);\n\n\t\t$id = (int)$id;\n\t\tif (!$id) return false;\n\t\t$res = self::get_scheduled_reports($type);\n\t\tif (!$res || count($res)==0) {\n\t\t\treturn false;\n\t\t}\n\t\t$return = false;\n\t\t$res->result(false);\n\t\tforeach ($res as $row) {\n\t\t\tif ($row['report_id'] == $id) {\n\t\t\t\t$return[] = $row;\n\t\t\t}\n\t\t}\n\t\treturn $return;\n\t}\n\n\t/**\n\t * Get available report periods\n\t * @return array [id] => string. False on errors.\n\t */\n\tstatic function get_available_report_periods()\n\t{\n\t\t$sql = \"SELECT * from scheduled_report_periods\";\n\t\t$db = Database::instance();\n\t\t$res = $db->query($sql);\n\t\tif(!$res || count($res)==0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$periods = array();\n\t\tforeach ($res as $period_row) {\n\t\t\t$periods[$period_row->id] = $period_row->periodname;\n\t\t}\n\t\treturn $periods;\n\t}\n\n\t/**\n\t * Retrieves the value of a db field for a report id\n\t * @param $type the database column\n\t * @param $id the id of the scheduled report\n\t */\n\tstatic function fetch_scheduled_field_value($type=false, $id=false)\n\t{\n\t\t$id = (int)$id;\n\t\t$type = trim($type);\n\t\tif (empty($type) || empty($id)) return false;\n\t\t$sql = \"SELECT $type FROM scheduled_reports WHERE id=\".$id;\n\t\t$db = Database::instance();\n\t\t$res = $db->query($sql);\n\t\tif (!$res || count($res) == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t$row = $res->current();\n\t\treturn $row->{$type};\n\t}\n\n\t/**\n\t * @param $id = false\n\t * @param $rep_type = false\n\t * @param $saved_report_id = false\n\t * @param $period = false\n\t * @param $recipients = false comma separated\n\t * @param $filename = ''\n\t * @param $description = ''\n\t * @param $local_persistent_filepath = ''\n\t * @param $attach_description = ''\n\t * @param $report_time = false\n\t * @param $report_on = false\n\t * @param $report_period = false\n\t * @return string|int either error string or the report's id\n\t */\n\tstatic public function edit_report($id=false, $rep_type=false, $saved_report_id=false, $period=false, $recipients=false, $filename='', $description='', $local_persistent_filepath = '', $attach_description = 0, $report_time=false, $report_on=false, $report_period=false)\n\t{\n\n\t\t$local_persistent_filepath = trim($local_persistent_filepath);\n\t\tif($local_persistent_filepath && !is_writable(rtrim($local_persistent_filepath, '/').'/')) {\n\t\t\treturn _(\"File path '$local_persistent_filepath' is not writable\");\n\t\t}\n\t\t$db = Database::instance();\n\t\t$id = (int)$id;\n\t\t$rep_type = (int)$rep_type;\n\t\t$saved_report_id = (int)$saved_report_id;\n\t\t$period\t= (int)$period;\n\t\t$report_time = trim($report_time);\n\t\t$report_on = trim($report_on);\n\t\t$report_period = trim($report_period);\n\t\t$recipients = trim($recipients);\n\t\t$filename = trim($filename);\n\t\t$description = trim($description);\n\t\t$attach_description = (int) $attach_description;\n\t\t$user = Auth::instance()->get_user()->get_username();\n\n\t\tif (!$rep_type || !$saved_report_id || !$period || empty($recipients)) return _('Missing data');\n\n\t\t// some users might use ';' to separate email adresses\n\t\t// just replace it with ',' and continue\n\t\t$recipients = str_replace(';', ',', $recipients);\n\t\t$rec_arr = explode(',', $recipients);\n\t\tif (!empty($rec_arr)) {\n\t\t\tforeach ($rec_arr as $recipient) {\n\t\t\t\tif (trim($recipient)!='') {\n\t\t\t\t\t$checked_recipients[] = trim($recipient);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$recipients = implode(', ', $checked_recipients);\n\t\t}\n\n\t\tif ($id) {\n\t\t\t// UPDATE\n\t\t\t$sql = \"UPDATE scheduled_reports SET \".self::USERFIELD.\"=\".$db->escape($user).\", report_type_id=\".$db->escape($rep_type).\", report_id=\".$db->escape($saved_report_id).\", recipients=\".$db->escape($recipients).\", period_id=\".$db->escape($period).\", filename=\".$db->escape($filename).\", description=\".$db->escape($description).\", local_persistent_filepath = \".$db->escape($local_persistent_filepath).\", attach_description = \".$db->escape($attach_description).\" WHERE id=\".$db->escape($id);\n\t\t} else {\n\t\t\t$sql = \"INSERT INTO scheduled_reports (\".self::USERFIELD.\", report_type_id, report_id, recipients, period_id, filename, description, local_persistent_filepath, attach_description, report_time, report_on, report_period)VALUES(\".$db->escape($user).\", \".$db->escape($rep_type).\", \".$db->escape($saved_report_id).\", \".$db->escape($recipients).\", \".$db->escape($period).\", \".$db->escape($filename).\", \".$db->escape($description).\", \".$db->escape($local_persistent_filepath).\", \".$db->escape($attach_description).\", \".$db->escape($report_time).\", \".$db->escape($report_on).\", \".$db->escape($report_period).\")\";\n\n\t\t}\n\n\t\ttry {\n\t\t\t$res = $db->query($sql);\n\t\t} catch (Kohana_Database_Exception $e) {\n\t\t\treturn _('DATABASE ERROR').\": {$e->getMessage()}; $sql\";\n\t\t}\n\n\t\tif (!$id) {\n\t\t\t$id = $res->insert_id();\n\t\t}\n\t\treturn $id;\n\t}\n\n\t/**\n\t * Update specific field for certain scheduled report\n\t * Called from reports_Controller::save_schedule_item() through ajax\n\t *\n\t * @param $id int: The id of the report.\n\t * @param $field string: The report field to update.\n\t * @param $value string: The new value.\n\t * @return true on succes. false on errors.\n\t */\n\tstatic function update_report_field($id=false, $field=false, $value=false)\n\t{\n\t\t$db = Database::instance();\n\t\t$id = (int)$id;\n\t\t$field = $db->escape_column(trim($field));\n\t\t$value = $db->escape(trim($value));\n\t\t$sql = \"UPDATE scheduled_reports SET {$field}={$value} WHERE id={$id}\";\n\t\ttry {\n\t\t\t$res = $db->query($sql);\n\t\t} catch (Kohana_Database_Exception $e) {\n\t\t\tprint $e->getMessage();\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get the type of a report.\n\t *\n\t * @param $id The id of the report.\n\t * @return Report type on success. False on errors.\n\t */\n\tstatic function get_typeof_report($id=false)\n\t{\n\t\t$sql = \"SELECT t.identifier FROM scheduled_reports sr, scheduled_report_types t WHERE \".\"sr.id=\".(int)$id.\" AND t.id=sr.report_type_id\";\n\t\t$db = Database::instance();\n\t\ttry {\n\t\t\t$res = $db->query($sql);\n\t\t} catch (Kohana_Database_Exception $e) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn count($res)!=0 ? $res->current()->identifier : false;\n\t}\n\n\t/**\n\t * Get the id of a named report\n\t *\n\t * @param $identifier string: The name of the report\n\t * @return False on errors. Id of the report on success.\n\t */\n\tstatic function get_report_type_id($identifier=false)\n\t{\n\t\t$db = Database::instance();\n\t\t$sql = \"SELECT id FROM scheduled_report_types WHERE identifier=\".$db->escape($identifier);\n\t\ttry {\n\t\t\t$res = $db->query($sql);\n\t\t} catch (Kohana_Database_Exception $e) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$id = false;\n\t\tif (count($res)!=0) {\n\t\t\t$res = $res->current();\n\t\t\t$id = $res->id;\n\t\t}\n\t\treturn $id;\n\t}\n\n\t/**\n\t*\tFetch info on all defined report types, i.e all\n\t* \ttypes we can schedule\n\t*/\n\tstatic function get_all_report_types()\n\t{\n\t\t$db = Database::instance();\n\t\t$sql = \"SELECT * FROM scheduled_report_types ORDER BY id\";\n\t\t$res = $db->query($sql);\n\t\treturn count($res) != 0 ? $res : false;\n\t}\n\n\t/**\n\t * Fetch all info for a specific schedule.\n\t * This includes all relevant data about both schedule\n\t * and the report.\n\t *\n\t * @param $schedule_id The id of the schedule we're interested in.\n\t * @return False on errors. Array with scheduling information on success.\n\t */\n\tstatic function get_scheduled_data($schedule_id=false)\n\t{\n\t\t$schedule_id = (int)$schedule_id;\n\t\tif (!$schedule_id) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$sql = \"SELECT sr.recipients, sr.filename, sr.local_persistent_filepath, sr.report_id FROM \".\"scheduled_reports sr \".\"WHERE sr.id=\".$schedule_id;\n\t\t$db = Database::instance();\n\t\t$res = $db->query($sql)->result_array(false);\n\t\tif (!$res)\n\t\t\treturn false;\n\t\treturn $res[0];\n\t}\n\n\t/**\n\t * Fetch info on reports to be sent for specific\n\t * period (daily/weekly/monthly)\n\t *\n\t * @param $period_str string: { schedule }\n\t * @return array\n\t */\n\tstatic function get_period_schedules($period_str)\n\t{\n\t\t$schedules = array();\n\t\t$send_date = array();\n\t\t$default_timezone = date_default_timezone_get();\n\n\t\t$db = Database::instance();\n\n\t\t$sql = <<<'SQL'\n\t\tSELECT sr.*, rp.periodname, opt.value AS timezone\n\t\tFROM scheduled_reports sr\n\t\tINNER JOIN scheduled_report_periods rp ON rp.id = sr.period_id\n\t\tLEFT JOIN saved_reports_options opt ON opt.report_id = sr.report_id\n\t\t\tAND opt.name = 'report_timezone'\nSQL;\n\t\t$res = $db->query($sql);\n\n\t\tforeach($res as $row){\n\t\t\t$report_period = json_decode($row->report_period);\n\t\t\t$report_time = $row->report_time;\n\t\t\tif($row->timezone){\n\t\t\t\t// All times for this schedule use the timezone of the associated report.\n\t\t\t\tdate_default_timezone_set($row->timezone);\n\t\t\t}\n\n\t\t\t$repeat_no = $report_period->no;\n\t\t\t$last_sent = $row->last_sent;\n\t\t\t$now = new DateTime();\n\n\t\t\t/* Avoid sending reports before report_time each day, even if they\n\t\t\t * are late for some reason. This means that a report that is due\n\t\t\t * to be sent at tuesday 08:00 but for some reason couldn't be sent\n\t\t\t * on tuesday, it will be sent the next day, but not before 08:00.\n\t\t\t */\n\t\t\t$report_time_of_day = new DateTime($now->format('Y-m-d') . \" $report_time\");\n\t\t\tif ($now < $report_time_of_day) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ($row->periodname == 'Daily') {\n\t\t\t\t$last_sent_date = $last_sent ? $last_sent : \"today - $repeat_no days\";\n\t\t\t\t$prev_period_start = new DateTime(\"$last_sent_date $report_time\");\n\n\t\t\t\t// Period where report should be generated next time.\n\t\t\t\t$period_start = new DateTime(\n\t\t\t\t\t$prev_period_start->format('c') . \" + $repeat_no days\");\n\n\t\t\t\tif ($now >= $period_start) {\n\t\t\t\t\t// We're beyond period_start, create the report.\n\t\t\t\t\t$schedules[] = $row->id;\n\t\t\t\t\t$send_date[] = $now->format('Y-m-d');\n\t\t\t\t}\n\t\t\t}\n\t\t\telseif ($row->periodname == 'Weekly') {\n\t\t\t\t$last_sent_date = $last_sent ? $last_sent : \"today - $repeat_no weeks\";\n\t\t\t\t$prev_period_start = new DateTime(\"$last_sent_date $report_time\");\n\n\t\t\t\t// Period where report should be generated next time.\n\t\t\t\t$period_start = new DateTime(\n\t\t\t\t\t$prev_period_start->format('c') . \" + $repeat_no weeks\");\n\n\t\t\t\t$report_days = json_decode($row->report_on);\n\n\t\t\t\tif ($now >= $period_start) {\n\t\t\t\t\t// We're beyond period_start, in a new period, proceed with\n\t\t\t\t\t// creating the report if correct day of week.\n\t\t\t\t\tforeach ($report_days as $day) {\n\t\t\t\t\t\tif ($day->day == $now->format('w')) {\n\t\t\t\t\t\t\t$schedules[] = $row->id;\n\t\t\t\t\t\t\t$send_date[] = $now->format('Y-m-d');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telseif ($now > $prev_period_start) {\n\t\t\t\t\t// Skip if day of week is the same as that of last_sent.\n\t\t\t\t\tif ($now->format('w') == $prev_period_start->format('w')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Still in previous period, check if report should be\n\t\t\t\t\t// created this weekday also.\n\t\t\t\t\tforeach ($report_days as $day) {\n\t\t\t\t\t\tif ($day->day == $now->format('w')) {\n\t\t\t\t\t\t\t$schedules[] = $row->id;\n\t\t\t\t\t\t\t$send_date[] = $now->format('Y-m-d');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telseif ($row->periodname == 'Monthly') {\n\t\t\t\t$last_sent_month = new DateTime(\n\t\t\t\t\t$last_sent ? $last_sent : \"today - $repeat_no months\");\n\t\t\t\t// Reset to first day of month, since day of month is not relevant.\n\t\t\t\t$last_sent_month->modify('first day of this month');\n\n\t\t\t\t// Month in which report should be generated next time.\n\t\t\t\t$next_send_month = new DateTime(\n\t\t\t\t\t$last_sent_month->format('Y-m-d') . \"+ $repeat_no months\");\n\n\t\t\t\t// Skip if we're not yet in next_send_month.\n\t\t\t\tif ($now < $next_send_month) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$report_on = json_decode($row->report_on);\n\t\t\t\t$day_of_week = $report_on->day;  # 1-7, last, first\n\n\t\t\t\t$is_report_day = false;\n\t\t\t\tif ($day_of_week == 'last') {\n\t\t\t\t\t// Send if this is the last day of the month.\n\t\t\t\t\t$tomorrow = strtotime('+ 1 day', $now->getTimestamp());\n\t\t\t\t\tif (date('n', $tomorrow) != $now->format('n')) {\n\t\t\t\t\t\t$is_report_day = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telseif ($day_of_week == 'first') {\n\t\t\t\t\t// Send if this is the first day of the month.\n\t\t\t\t\tif ($now->format('j') == '1') {\n\t\t\t\t\t\t$is_report_day = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telseif ($day_of_week == $now->format('w')) {\n\t\t\t\t\t$day_ordinal = $report_on->day_no;  # 1-4, last\n\t\t\t\t\tif ($day_ordinal == 'last') {\n\t\t\t\t\t\t// Check if this is the last $day_of_week of the month\n\t\t\t\t\t\t$next_week = strtotime('+ 1 week', $now->getTimestamp());\n\t\t\t\t\t\tif (date('n', $next_week) != $now->format('n')) {\n\t\t\t\t\t\t\t$is_report_day = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Check if today is $day_ordinal $day_of_week (e.g. 3rd Friday)\n\t\t\t\t\t\t$check_weeks_before = $day_ordinal - 1;\n\t\t\t\t\t\t$this_month = new DateTime(\"- $check_weeks_before week\");\n\t\t\t\t\t\t$prev_month = new DateTime(\"- $day_ordinal week\");\n\t\t\t\t\t\tif ($this_month->format('n') == $now->format('n')\n\t\t\t\t\t\t\t\t&& $prev_month->format('n') != $now->format('n')) {\n\t\t\t\t\t\t\t$is_report_day = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Send report if today is the report day and if time of day\n\t\t\t\t// has passed the scheduled report time.\n\t\t\t\tif ($is_report_day) {\n\t\t\t\t\t$schedules[] = $row->id;\n\t\t\t\t\t$send_date[] = $now->format('Y-m-d');\n\t\t\t\t}\n\t\t\t}\n\t\t\tdate_default_timezone_set($default_timezone);\n\t\t}\n\n\t\tforeach($schedules as $i => $schedule_id ){\n\t\t\tself::update_report_field($schedule_id, \"last_sent\", $send_date[$i]);\n\t\t}\n\n\t\treturn $schedules;\n\t}\n}\n"], "filenames": ["modules/reports/models/scheduled_reports.php"], "buggy_code_start_loc": [40], "buggy_code_end_loc": [242], "fixing_code_start_loc": [40], "fixing_code_end_loc": [242], "type": "CWE-89", "message": "A vulnerability was found in ITRS Group monitor-ninja up to 2021.11.1. It has been rated as critical. Affected by this issue is some unknown functionality of the file modules/reports/models/scheduled_reports.php. The manipulation leads to sql injection. Upgrading to version 2021.11.30 is able to address this issue. The name of the patch is 6da9080faec9bca1ca5342386c0421dca0a6c0cc. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-230084.", "other": {"cve": {"id": "CVE-2021-4336", "sourceIdentifier": "cna@vuldb.com", "published": "2023-05-28T22:15:09.337", "lastModified": "2023-06-02T19:50:45.197", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in ITRS Group monitor-ninja up to 2021.11.1. It has been rated as critical. Affected by this issue is some unknown functionality of the file modules/reports/models/scheduled_reports.php. The manipulation leads to sql injection. Upgrading to version 2021.11.30 is able to address this issue. The name of the patch is 6da9080faec9bca1ca5342386c0421dca0a6c0cc. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-230084."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:itrsgroup:ninja:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021.11.30", "matchCriteriaId": "A38A4AE4-965E-4F09-B03E-7DE67A0AB9A2"}]}]}], "references": [{"url": "https://github.com/ITRS-Group/monitor-ninja/commit/6da9080faec9bca1ca5342386c0421dca0a6c0cc", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/ITRS-Group/monitor-ninja/releases/tag/v2021.11.30", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.230084", "source": "cna@vuldb.com", "tags": ["Permissions Required"]}, {"url": "https://vuldb.com/?id.230084", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ITRS-Group/monitor-ninja/commit/6da9080faec9bca1ca5342386c0421dca0a6c0cc"}}