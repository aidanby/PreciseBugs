{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/base_coding.h>\n#include <gpac/mpeg4_odf.h>\n#include <gpac/constants.h>\n#include <gpac/maths.h>\n#include <gpac/internal/ietf_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid gf_media_get_sample_average_infos(GF_ISOFile *file, u32 Track, u32 *avgSize, u32 *MaxSize, u32 *TimeDelta, u32 *maxCTSDelta, u32 *const_duration, u32 *bandwidth)\n{\n\tu32 i, count, ts_diff;\n\tu64 prevTS, tdelta;\n\tDouble bw;\n\tGF_ISOSample *samp;\n\n\t*avgSize = *MaxSize = 0;\n\t*TimeDelta = 0;\n\t*maxCTSDelta = 0;\n\tbw = 0;\n\tprevTS = 0;\n\ttdelta = 0;\n\n\tcount = gf_isom_get_sample_count(file, Track);\n\tif (!count) return;\n\t*const_duration = 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tsamp = gf_isom_get_sample_info(file, Track, i+1, NULL, NULL);\n\t\tif (!samp) break;\n\t\t\n\t\t//get the size\n\t\t*avgSize += samp->dataLength;\n\t\tif (*MaxSize < samp->dataLength) *MaxSize = samp->dataLength;\n\t\tts_diff = (u32) (samp->DTS+samp->CTS_Offset - prevTS);\n\t\t//get the time\n\t\ttdelta += ts_diff;\n\n\t\tif (i==1) {\n\t\t\t*const_duration = ts_diff;\n\t\t} else if ( (i<count-1) && (*const_duration != ts_diff) ) {\n\t\t\t*const_duration = 0;\n\t\t}\n\n\t\tprevTS = samp->DTS+samp->CTS_Offset;\n\t\tbw += 8*samp->dataLength;\n\n\t\t//get the CTS delta\n\t\tif ((samp->CTS_Offset>=0) && ((u32)samp->CTS_Offset > *maxCTSDelta))\n\t\t\t*maxCTSDelta = samp->CTS_Offset;\n\t\tgf_isom_sample_del(&samp);\n\t}\n\tif (count>1) *TimeDelta = (u32) (tdelta/ (count-1) );\n\telse *TimeDelta = (u32) tdelta;\n\t*avgSize /= count;\n\tbw *= gf_isom_get_media_timescale(file, Track);\n\tbw /= (s64) gf_isom_get_media_duration(file, Track);\n\tbw /= 1000;\n\t(*bandwidth) = (u32) (bw+0.5);\n\n\t//delta is NOT an average, we need to know exactly how many bits are\n\t//needed to encode CTS-DTS for ANY samples\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n/*RTP track hinter*/\nstruct __tag_isom_hinter\n{\n\tGF_ISOFile *file;\n\t/*IDs are kept for mp4 hint sample building*/\n\tu32 TrackNum, TrackID, HintTrack, HintID;\n\t/*current Hint sample and associated RTP time*/\n\tu32 HintSample, RTPTime;\n\n\t/*track has composition time offset*/\n\tBool has_ctts;\n\t/*remember if first SL packet in RTP packet is RAP*/\n\tu8 SampleIsRAP;\n\tu32 base_offset_in_sample;\n\tu32 OrigTimeScale;\n\t/*rtp builder*/\n\tGP_RTPPacketizer *rtp_p;\n\n\tu32 bandwidth, nb_chan;\n\n\t/*NALU size for H264/AVC*/\n\tu32 avc_nalu_size;\n\n\t/*stats*/\n\tu32 TotalSample, CurrentSample;\n};\n\n\n/*\n\toffset for group ID for hint tracks in SimpleAV mode when all media data\n\tis copied to the hint track (no use interleaving hint and original in this case)\n\tthis offset is applied internally by the track hinter. Thus you shouldn't\n\tspecify a GroupID >= OFFSET_HINT_GROUP_ID if you want the lib to perform efficient\n\tinterleaving in any cases (referenced or copied media)\n*/\n#define OFFSET_HINT_GROUP_ID\t0x8000\n\nvoid InitSL_RTP(GF_SLConfig *slc)\n{\n\tmemset(slc, 0, sizeof(GF_SLConfig));\n\tslc->tag = GF_ODF_SLC_TAG;\n\tslc->useTimestampsFlag = 1;\n\tslc->timestampLength = 32;\n}\n\nvoid InitSL_NULL(GF_SLConfig *slc)\n{\n\tmemset(slc, 0, sizeof(GF_SLConfig));\n\tslc->tag = GF_ODF_SLC_TAG;\n\tslc->predefined = 0x01;\n}\n\n\n\nvoid MP4T_OnPacketDone(void *cbk, GF_RTPHeader *header)\n{\n\tu8 disposable;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint || !tkHint->HintSample) return;\n\tassert(header->TimeStamp == tkHint->RTPTime);\n\n\tdisposable = 0;\n\tif (tkHint->avc_nalu_size) {\n\t\tdisposable = tkHint->rtp_p->avc_non_idr ? 1 : 0;\n\t}\n\t/*for all other, assume that CTS=DTS means B-frame -> disposable*/\n\telse if (tkHint->has_ctts && (tkHint->rtp_p->sl_header.compositionTimeStamp==tkHint->rtp_p->sl_header.decodingTimeStamp)) {\n\t\tdisposable = 1;\n\t}\n\n\tgf_isom_rtp_packet_set_flags(tkHint->file, tkHint->HintTrack, 0, 0, header->Marker, disposable, 0);\n}\n\n\nvoid MP4T_OnDataRef(void *cbk, u32 payload_size, u32 offset_from_orig)\n{\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint || !payload_size) return;\n\n\t/*add reference*/\n\tgf_isom_hint_sample_data(tkHint->file, tkHint->HintTrack, tkHint->TrackID,\n\t                         tkHint->CurrentSample, (u16) payload_size, offset_from_orig + tkHint->base_offset_in_sample,\n\t                         NULL, 0);\n}\n\nvoid MP4T_OnData(void *cbk, u8 *data, u32 data_size, Bool is_header)\n{\n\tu8 at_begin;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!data_size) return;\n\n\tat_begin = is_header ? 1 : 0;\n\tif (data_size <= 14) {\n\t\tgf_isom_hint_direct_data(tkHint->file, tkHint->HintTrack, data, data_size, at_begin);\n\t} else {\n\t\tgf_isom_hint_sample_data(tkHint->file, tkHint->HintTrack, tkHint->HintID, 0, (u16) data_size, 0, data, at_begin);\n\t}\n}\n\n\nvoid MP4T_OnNewPacket(void *cbk, GF_RTPHeader *header)\n{\n\ts32 res;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint) return;\n\n\tres = (s32) (tkHint->rtp_p->sl_header.compositionTimeStamp - tkHint->rtp_p->sl_header.decodingTimeStamp);\n\tassert( !res || tkHint->has_ctts);\n\t/*do we need a new sample*/\n\tif (!tkHint->HintSample || (tkHint->RTPTime != header->TimeStamp)) {\n\t\t/*close current sample*/\n\t\tif (tkHint->HintSample) gf_isom_end_hint_sample(tkHint->file, tkHint->HintTrack, tkHint->SampleIsRAP);\n\n\t\t/*start new sample: We use DTS as the sampling instant (RTP TS) to make sure\n\t\tall packets are sent in order*/\n\t\tgf_isom_begin_hint_sample(tkHint->file, tkHint->HintTrack, 1, header->TimeStamp-res);\n\t\ttkHint->HintSample ++;\n\t\ttkHint->RTPTime = header->TimeStamp;\n\t\ttkHint->SampleIsRAP = tkHint->rtp_p->sl_config.hasRandomAccessUnitsOnlyFlag ? 1 : tkHint->rtp_p->sl_header.randomAccessPointFlag;\n\t}\n\t/*create an RTP Packet with the appropriated marker flag - note: the flags are temp ones,\n\tthey are set when the full packet is signaled (to handle multi AUs per RTP)*/\n\tgf_isom_rtp_packet_begin(tkHint->file, tkHint->HintTrack, 0, 0, 0, header->Marker, header->PayloadType, 0, 0, header->SequenceNumber);\n\t/*Add the delta TS to make sure RTP TS is indeed the CTS (sampling time)*/\n\tif (res) gf_isom_rtp_packet_set_offset(tkHint->file, tkHint->HintTrack, res);\n}\n\n\nGF_EXPORT\nGF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts>1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);\n\t\tif ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions & co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd && esd->decoderConfig) {\n\t\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\t\tcodecid = esd->decoderConfig->objectTypeIndication;\n\t\t\t\tif (esd->URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        && ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags & GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = \"AAC\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = \"CELP\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc && !svcc && !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp->file = file;\n\ttmp->TrackNum = TrackNum;\n\ttmp->avc_nalu_size = avc_nalu_size;\n\ttmp->nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags & GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp->TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp->HintID = tmp->TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;\n\n\ttmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp->rtp_p->slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\t*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);\n\t\tif (*e) {\n\t\t\tgf_hinter_track_del(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don't copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);\n\n\t*e = GF_OK;\n\treturn tmp;\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_force_no_offsets(GF_RTPHinter *tkHinter)\n{\n\tGF_Err e;\n\tif (!tkHinter) return GF_BAD_PARAM;\n\te = gf_isom_rtp_set_time_offset(tkHinter->file, tkHinter->HintTrack, 1, 0);\n\tif (e) return e;\n\treturn gf_isom_rtp_set_time_sequence_offset(tkHinter->file, tkHinter->HintTrack, 1, 0);\n}\n\nGF_EXPORT\nu32 gf_hinter_track_get_bandwidth(GF_RTPHinter *tkHinter)\n{\n\treturn tkHinter->bandwidth;\n}\n\nGF_EXPORT\nu32 gf_hinter_track_get_flags(GF_RTPHinter *tkHinter)\n{\n\treturn tkHinter->rtp_p->flags;\n}\nGF_EXPORT\nvoid gf_hinter_track_get_payload_name(GF_RTPHinter *tkHinter, char *payloadName)\n{\n\tchar mediaName[30];\n\tgf_rtp_builder_get_payload_name(tkHinter->rtp_p, payloadName, mediaName);\n}\n\nGF_EXPORT\nvoid gf_hinter_track_del(GF_RTPHinter *tkHinter)\n{\n\tif (!tkHinter) return;\n\n\tif (tkHinter->rtp_p) gf_rtp_builder_del(tkHinter->rtp_p);\n\tgf_free(tkHinter);\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)\n{\n\tGF_Err e;\n\tu32 i, descIndex, duration;\n\tu64 ts;\n\tu8 PadBits;\n\tGF_Fraction ft;\n\tGF_ISOSample *samp;\n\n\ttkHint->HintSample = tkHint->RTPTime = 0;\n\n\ttkHint->TotalSample = gf_isom_get_sample_count(tkHint->file, tkHint->TrackNum);\n\tft.num = tkHint->rtp_p->sl_config.timestampResolution;\n\tft.den = tkHint->OrigTimeScale;\n\n\te = GF_OK;\n\tfor (i=0; i<tkHint->TotalSample; i++) {\n\t\tsamp = gf_isom_get_sample(tkHint->file, tkHint->TrackNum, i+1, &descIndex);\n\t\tif (!samp) return gf_isom_last_error(tkHint->file);\n\n\t\t//setup SL\n\t\ttkHint->CurrentSample = i + 1;\n\n\t\t/*keep same AU indicator if sync shadow - TODO FIXME: this assumes shadows are placed interleaved with\n\t\tthe track content which is the case for GPAC scene carousel generation, but may not always be true*/\n\t\tif (samp->IsRAP==RAP_REDUNDANT) {\n\t\t\ttkHint->rtp_p->sl_header.AU_sequenceNumber -= 1;\n\t\t\tsamp->IsRAP = RAP;\n\t\t}\n\n\t\tts = ft.num * (samp->DTS+samp->CTS_Offset) / ft.den;\n\t\ttkHint->rtp_p->sl_header.compositionTimeStamp = ts;\n\n\t\tts = ft.num * samp->DTS / ft.den;\n\t\ttkHint->rtp_p->sl_header.decodingTimeStamp = ts;\n\t\ttkHint->rtp_p->sl_header.randomAccessPointFlag = samp->IsRAP;\n\n\t\ttkHint->base_offset_in_sample = 0;\n\t\t/*crypted*/\n\t\tif (tkHint->rtp_p->slMap.IV_length) {\n\t\t\tGF_ISMASample *s = gf_isom_get_ismacryp_sample(tkHint->file, tkHint->TrackNum, samp, descIndex);\n\t\t\t/*one byte take for selective_enc flag*/\n\t\t\tif (s->flags & GF_ISOM_ISMA_USE_SEL_ENC) tkHint->base_offset_in_sample += 1;\n\t\t\tif (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) tkHint->base_offset_in_sample += s->IV_length + s->KI_length;\n\t\t\tgf_free(samp->data);\n\t\t\tsamp->data = s->data;\n\t\t\tsamp->dataLength = s->dataLength;\n\t\t\tgf_rtp_builder_set_cryp_info(tkHint->rtp_p, s->IV, (char*)s->key_indicator, (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? 1 : 0);\n\t\t\ts->data = NULL;\n\t\t\ts->dataLength = 0;\n\t\t\tgf_isom_ismacryp_delete_sample(s);\n\t\t}\n\n\t\tif (tkHint->rtp_p->sl_config.usePaddingFlag) {\n\t\t\tgf_isom_get_sample_padding_bits(tkHint->file, tkHint->TrackNum, i+1, &PadBits);\n\t\t\ttkHint->rtp_p->sl_header.paddingBits = PadBits;\n\t\t} else {\n\t\t\ttkHint->rtp_p->sl_header.paddingBits = 0;\n\t\t}\n\n\t\tduration = gf_isom_get_sample_duration(tkHint->file, tkHint->TrackNum, i+1);\n//\t\tts = (u32) (ft * (s64) (duration));\n\n\t\t/*unpack nal units*/\n\t\tif (tkHint->avc_nalu_size) {\n\t\t\tu32 v, size;\n\t\t\tu32 remain = samp->dataLength;\n\t\t\tchar *ptr = samp->data;\n\n\t\t\ttkHint->rtp_p->sl_header.accessUnitStartFlag = 1;\n\t\t\ttkHint->rtp_p->sl_header.accessUnitEndFlag = 0;\n\t\t\twhile (remain) {\n\t\t\t\tsize = 0;\n\t\t\t\tv = tkHint->avc_nalu_size;\n\t\t\t\tif (v>remain) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size length is %d but only %d bytes left in sample %d\\n\", v, remain, tkHint->CurrentSample));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (v) {\n\t\t\t\t\tsize |= (u8) *ptr;\n\t\t\t\t\tptr++;\n\t\t\t\t\tremain--;\n\t\t\t\t\tv-=1;\n\t\t\t\t\tif (v) size<<=8;\n\t\t\t\t}\n\t\t\t\ttkHint->base_offset_in_sample = samp->dataLength-remain;\n\t\t\t\tif (remain < size) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is %d but only %d bytes left in sample %d\\n\", size, remain, tkHint->CurrentSample));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tremain -= size;\n\t\t\t\ttkHint->rtp_p->sl_header.accessUnitEndFlag = remain ? 0 : 1;\n\t\t\t\tif (!size) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is 0, ignoring it\\n\", size));\n\t\t\t\t} else {\n\t\t\t\t\te = gf_rtp_builder_process(tkHint->rtp_p, ptr, size, (u8) !remain, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );\n\t\t\t\t\tptr += size;\n\t\t\t\t}\n\t\t\t\ttkHint->rtp_p->sl_header.accessUnitStartFlag = 0;\n\t\t\t}\n\t\t} else {\n\t\t\te = gf_rtp_builder_process(tkHint->rtp_p, samp->data, samp->dataLength, 1, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );\n\t\t}\n\t\ttkHint->rtp_p->sl_header.packetSequenceNumber += 1;\n\n\t\t//signal some progress\n\t\tgf_set_progress(\"Hinting\", tkHint->CurrentSample, tkHint->TotalSample);\n\n\t\ttkHint->rtp_p->sl_header.AU_sequenceNumber += 1;\n\t\tgf_isom_sample_del(&samp);\n\n\t\tif (e) return e;\n\t}\n\n\t//flush\n\tgf_rtp_builder_process(tkHint->rtp_p, NULL, 0, 1, 0, 0, 0);\n\n\tgf_isom_end_hint_sample(tkHint->file, tkHint->HintTrack, (u8) tkHint->SampleIsRAP);\n\treturn GF_OK;\n}\n\nstatic u32 write_nalu_config_array(char *sdpLine, GF_List *nalus)\n{\n\tu32 i, count, b64s;\n\tchar b64[200];\n\n\tcount = gf_list_count(nalus);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(nalus, i);\n\t\tb64s = gf_base64_encode(sl->data, sl->size, b64, 200);\n\t\tb64[b64s]=0;\n\t\tstrcat(sdpLine, b64);\n\t\tif (i+1<count) strcat(sdpLine, \",\");\n\t}\n\treturn count;\n}\n\nstatic void write_avc_config(char *sdpLine, GF_AVCConfig *avcc, GF_AVCConfig *svcc)\n{\n\tu32 count = 0;\n\n\tif (avcc) count += gf_list_count(avcc->sequenceParameterSets) + gf_list_count(avcc->pictureParameterSets) + gf_list_count(avcc->sequenceParameterSetExtensions);\n\tif (svcc) count += gf_list_count(svcc->sequenceParameterSets) + gf_list_count(svcc->pictureParameterSets);\n\tif (!count) return;\n\n\tstrcat(sdpLine, \"; sprop-parameter-sets=\");\n\n\tif (avcc) {\n\t\tcount = write_nalu_config_array(sdpLine, avcc->sequenceParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, avcc->sequenceParameterSetExtensions);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, avcc->pictureParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t}\n\n\tif (svcc) {\n\t\tcount = write_nalu_config_array(sdpLine, svcc->sequenceParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, svcc->pictureParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t}\n\tcount = (u32) strlen(sdpLine);\n\tif (sdpLine[count-1] == ',')\n\t\tsdpLine[count-1] = 0;\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_finalize(GF_RTPHinter *tkHint, Bool AddSystemInfo)\n{\n\tu32 Width, Height;\n\tGF_ESD *esd;\n\tchar sdpLine[20000];\n\tchar mediaName[30], payloadName[30];\n    u32 mtype;\n\n\tWidth = Height = 0;\n\tgf_isom_sdp_clean_track(tkHint->file, tkHint->TrackNum);\n    mtype = gf_isom_get_media_type(tkHint->file, tkHint->TrackNum);\n    if (gf_isom_is_video_handler_type(mtype))\n\t\tgf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);\n\n\tgf_rtp_builder_get_payload_name(tkHint->rtp_p, payloadName, mediaName);\n\n\t/*TODO- extract out of rtp_p for future live tools*/\n\tsprintf(sdpLine, \"m=%s 0 RTP/%s %d\", mediaName, tkHint->rtp_p->slMap.IV_length ? \"SAVP\" : \"AVP\", tkHint->rtp_p->PayloadType);\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\tif (tkHint->bandwidth) {\n\t\tsprintf(sdpLine, \"b=AS:%d\", tkHint->bandwidth);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\tif (tkHint->nb_chan) {\n\t\tsprintf(sdpLine, \"a=rtpmap:%d %s/%d/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution, tkHint->nb_chan);\n\t} else {\n\t\tsprintf(sdpLine, \"a=rtpmap:%d %s/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution);\n\t}\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t/*control for MPEG-4*/\n\tif (AddSystemInfo) {\n\t\tsprintf(sdpLine, \"a=mpeg4-esid:%d\", gf_isom_get_track_id(tkHint->file, tkHint->TrackNum));\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*control for QTSS/DSS*/\n\tsprintf(sdpLine, \"a=control:trackID=%d\", gf_isom_get_track_id(tkHint->file, tkHint->HintTrack));\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\n\t/*H263 extensions*/\n\tif (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H263) {\n\t\tsprintf(sdpLine, \"a=cliprect:0,0,%d,%d\", Height, Width);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*AMR*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR_WB)) {\n\t\tsprintf(sdpLine, \"a=fmtp:%d octet-align=1\", tkHint->rtp_p->PayloadType);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*Text*/\n\telse if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {\n\t\tu32 w, h, i, m_w, m_h;\n\t\ts32 tx, ty;\n\t\ts16 l;\n\n\t\tgf_isom_get_track_layout_info(tkHint->file, tkHint->TrackNum, &w, &h, &tx, &ty, &l);\n\t\tm_w = w;\n\t\tm_h = h;\n\t\tfor (i=0; i<gf_isom_get_track_count(tkHint->file); i++) {\n\t\t\tswitch (gf_isom_get_media_type(tkHint->file, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tgf_isom_get_track_layout_info(tkHint->file, i+1, &w, &h, &tx, &ty, &l);\n\t\t\t\tif (w>m_w) m_w = w;\n\t\t\t\tif (h>m_h) m_h = h;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgf_media_format_ttxt_sdp(tkHint->rtp_p, payloadName, sdpLine, w, h, tx, ty, l, m_w, m_h, NULL);\n\n\t\tstrcat(sdpLine, \"; tx3g=\");\n\t\tfor (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {\n\t\t\tu8 *tx3g;\n\t\t\tchar buffer[2000];\n\t\t\tu32 tx3g_len, len;\n\t\t\tgf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);\n\t\t\tlen = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);\n\t\t\tgf_free(tx3g);\n\t\t\tbuffer[len] = 0;\n\t\t\tif (i) strcat(sdpLine, \", \");\n\t\t\tstrcat(sdpLine, buffer);\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*EVRC/SMV in non header-free mode*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (tkHint->rtp_p->auh_size>1)) {\n\t\tsprintf(sdpLine, \"a=fmtp:%d maxptime=%d\", tkHint->rtp_p->PayloadType, tkHint->rtp_p->auh_size*20);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*H264/AVC*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_AVC) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_SVC))  {\n\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(tkHint->file, tkHint->TrackNum, 1);\n\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(tkHint->file, tkHint->TrackNum, 1);\n\t\t/*TODO - check syntax for SVC (might be some extra signaling)*/\n\n\t\tif (avcc) {\n\t\t\tsprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t} else {\n\t\t\tif (!svcc)\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tsprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, svcc->AVCProfileIndication, svcc->profile_compatibility, svcc->AVCLevelIndication);\n\t\t}\n\n\t\twrite_avc_config(sdpLine, avcc, svcc);\n\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t\tgf_odf_avc_cfg_del(avcc);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\t/*MPEG-4 decoder config*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_MPEG4) {\n\t\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\n\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t} else {\n\t\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, NULL, 0);\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\tif (tkHint->rtp_p->slMap.IV_length) {\n\t\t\tconst char *kms;\n\t\t\tgf_isom_get_ismacryp_info(tkHint->file, tkHint->TrackNum, 1, NULL, NULL, NULL, NULL, &kms, NULL, NULL, NULL);\n\t\t\tif (!strnicmp(kms, \"(key)\", 5) || !strnicmp(kms, \"(ipmp)\", 6) || !strnicmp(kms, \"(uri)\", 5)) {\n\t\t\t\tstrcat(sdpLine, \"; ISMACrypKey=\");\n\t\t\t} else {\n\t\t\t\tstrcat(sdpLine, \"; ISMACrypKey=(uri)\");\n\t\t\t}\n\t\t\tstrcat(sdpLine, kms);\n\t\t}\n\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*MPEG-4 Audio LATM*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_LATM) {\n\t\tGF_BitStream *bs;\n\t\tu8 *config_bytes;\n\t\tu32 config_size;\n\n\t\t/* form config string */\n\t\tbs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_int(bs, 0, 1); /* AudioMuxVersion */\n\t\tgf_bs_write_int(bs, 1, 1); /* all streams same time */\n\t\tgf_bs_write_int(bs, 0, 6); /* numSubFrames */\n\t\tgf_bs_write_int(bs, 0, 4); /* numPrograms */\n\t\tgf_bs_write_int(bs, 0, 3); /* numLayer */\n\n\t\t/* audio-specific config */\n\t\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t/*PacketVideo patch: don't signal SBR and PS stuff, not allowed in LATM with audioMuxVersion=0*/\n\t\t\tgf_bs_write_data(bs, esd->decoderConfig->decoderSpecificInfo->data, MIN(esd->decoderConfig->decoderSpecificInfo->dataLength, 2) );\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\t/* other data */\n\t\tgf_bs_write_int(bs, 0, 3); /* frameLengthType */\n\t\tgf_bs_write_int(bs, 0xff, 8); /* latmBufferFullness */\n\t\tgf_bs_write_int(bs, 0, 1); /* otherDataPresent */\n\t\tgf_bs_write_int(bs, 0, 1); /* crcCheckPresent */\n\t\tgf_bs_get_content(bs, &config_bytes, &config_size);\n\t\tgf_bs_del(bs);\n\n\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, config_bytes, config_size);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t\tgf_free(config_bytes);\n\t}\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t/*3GPP DIMS*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {\n\t\tGF_DIMSDescription dims;\n\t\tgf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);\n\n\t\tgf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &dims);\n\t\tsprintf(sdpLine, \"a=fmtp:%d Version-profile=%d\", tkHint->rtp_p->PayloadType, dims.profile);\n\t\tif (! dims.fullRequestHost) {\n\t\t\tchar fmt[200];\n\t\t\tstrcat(sdpLine, \";useFullRequestHost=0\");\n\t\t\tsprintf(fmt, \";pathComponents=%d\", dims.pathComponents);\n\t\t\tstrcat(sdpLine, fmt);\n\t\t}\n\t\tif (!dims.streamType) strcat(sdpLine, \";stream-type=secondary\");\n\t\tif (dims.containsRedundant == 1) strcat(sdpLine, \";contains-redundant=main\");\n\t\telse if (dims.containsRedundant == 2) strcat(sdpLine, \";contains-redundant=redundant\");\n\n\t\tif (dims.textEncoding && strlen(dims.textEncoding)) {\n\t\t\tstrcat(sdpLine, \";text-encoding=\");\n\t\t\tstrcat(sdpLine, dims.textEncoding);\n\t\t}\n\t\tif (dims.contentEncoding && strlen(dims.contentEncoding)) {\n\t\t\tstrcat(sdpLine, \";content-coding=\");\n\t\t\tstrcat(sdpLine, dims.contentEncoding);\n\t\t}\n\t\tif (dims.contentEncoding && dims.content_script_types && strlen(dims.content_script_types) ) {\n\t\t\tstrcat(sdpLine, \";content-script-types=\");\n\t\t\tstrcat(sdpLine, dims.contentEncoding);\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n#endif\n\t/*extensions for some mobile phones*/\n\tif (Width && Height) {\n\t\tsprintf(sdpLine, \"a=framesize:%d %d-%d\", tkHint->rtp_p->PayloadType, Width, Height);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\n\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\tif (esd && esd->decoderConfig && (esd->decoderConfig->rvc_config || esd->decoderConfig->predefined_rvc_config)) {\n\t\tif (esd->decoderConfig->predefined_rvc_config) {\n\t\t\tsprintf(sdpLine, \"a=rvc-config-predef:%d\", esd->decoderConfig->predefined_rvc_config);\n\t\t} else {\n\t\t\t/*temporary ...*/\n\t\t\tif ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {\n\t\t\t\tsprintf(sdpLine, \"a=rvc-config:%s\", \"http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml\");\n\t\t\t} else {\n\t\t\t\tsprintf(sdpLine, \"a=rvc-config:%s\", \"http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml\");\n\t\t\t}\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\tgf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, GF_TRUE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_hinter_can_embbed_data(u8 *data, u32 data_size, u32 streamType)\n{\n\tchar data64[5000];\n\tu32 size64;\n\n\tsize64 = gf_base64_encode(data, data_size, data64, 5000);\n\tif (!size64) return 0;\n\tswitch (streamType) {\n\tcase GF_STREAM_OD:\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-od-au;base64,\");\n\t\tbreak;\n\tcase GF_STREAM_SCENE:\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-bifs-au;base64,\");\n\t\tbreak;\n\tdefault:\n\t\t/*NOT NORMATIVE*/\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-es-au;base64,\");\n\t\tbreak;\n\t}\n\tif (size64>=255) return 0;\n\treturn 1;\n}\n\n\nGF_EXPORT\nGF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \"b=AS:%d\", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \"a=x-copyright: %s\", \"MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\");\n    } else {\n        sprintf(buf64, \"a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-od-au;base64,%s\", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-bifs-au;base64,%s\", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \"a=isma-compliance:1,1.0,1\");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \"a=mpeg4-iod:\\\"data:application/mpeg4-iod;base64,%s\\\"\", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/base_coding.h>\n#include <gpac/mpeg4_odf.h>\n#include <gpac/constants.h>\n#include <gpac/maths.h>\n#include <gpac/internal/ietf_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid gf_media_get_sample_average_infos(GF_ISOFile *file, u32 Track, u32 *avgSize, u32 *MaxSize, u32 *TimeDelta, u32 *maxCTSDelta, u32 *const_duration, u32 *bandwidth)\n{\n\tu32 i, count, ts_diff;\n\tu64 prevTS, tdelta;\n\tDouble bw;\n\tGF_ISOSample *samp;\n\n\t*avgSize = *MaxSize = 0;\n\t*TimeDelta = 0;\n\t*maxCTSDelta = 0;\n\tbw = 0;\n\tprevTS = 0;\n\ttdelta = 0;\n\n\tcount = gf_isom_get_sample_count(file, Track);\n\tif (!count) return;\n\t*const_duration = 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tsamp = gf_isom_get_sample_info(file, Track, i+1, NULL, NULL);\n\t\tif (!samp) break;\n\t\t\n\t\t//get the size\n\t\t*avgSize += samp->dataLength;\n\t\tif (*MaxSize < samp->dataLength) *MaxSize = samp->dataLength;\n\t\tts_diff = (u32) (samp->DTS+samp->CTS_Offset - prevTS);\n\t\t//get the time\n\t\ttdelta += ts_diff;\n\n\t\tif (i==1) {\n\t\t\t*const_duration = ts_diff;\n\t\t} else if ( (i<count-1) && (*const_duration != ts_diff) ) {\n\t\t\t*const_duration = 0;\n\t\t}\n\n\t\tprevTS = samp->DTS+samp->CTS_Offset;\n\t\tbw += 8*samp->dataLength;\n\n\t\t//get the CTS delta\n\t\tif ((samp->CTS_Offset>=0) && ((u32)samp->CTS_Offset > *maxCTSDelta))\n\t\t\t*maxCTSDelta = samp->CTS_Offset;\n\t\tgf_isom_sample_del(&samp);\n\t}\n\tif (count>1) *TimeDelta = (u32) (tdelta/ (count-1) );\n\telse *TimeDelta = (u32) tdelta;\n\t*avgSize /= count;\n\tbw *= gf_isom_get_media_timescale(file, Track);\n\tbw /= (s64) gf_isom_get_media_duration(file, Track);\n\tbw /= 1000;\n\t(*bandwidth) = (u32) (bw+0.5);\n\n\t//delta is NOT an average, we need to know exactly how many bits are\n\t//needed to encode CTS-DTS for ANY samples\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n/*RTP track hinter*/\nstruct __tag_isom_hinter\n{\n\tGF_ISOFile *file;\n\t/*IDs are kept for mp4 hint sample building*/\n\tu32 TrackNum, TrackID, HintTrack, HintID;\n\t/*current Hint sample and associated RTP time*/\n\tu32 HintSample, RTPTime;\n\n\t/*track has composition time offset*/\n\tBool has_ctts;\n\t/*remember if first SL packet in RTP packet is RAP*/\n\tu8 SampleIsRAP;\n\tu32 base_offset_in_sample;\n\tu32 OrigTimeScale;\n\t/*rtp builder*/\n\tGP_RTPPacketizer *rtp_p;\n\n\tu32 bandwidth, nb_chan;\n\n\t/*NALU size for H264/AVC*/\n\tu32 avc_nalu_size;\n\n\t/*stats*/\n\tu32 TotalSample, CurrentSample;\n};\n\n\n/*\n\toffset for group ID for hint tracks in SimpleAV mode when all media data\n\tis copied to the hint track (no use interleaving hint and original in this case)\n\tthis offset is applied internally by the track hinter. Thus you shouldn't\n\tspecify a GroupID >= OFFSET_HINT_GROUP_ID if you want the lib to perform efficient\n\tinterleaving in any cases (referenced or copied media)\n*/\n#define OFFSET_HINT_GROUP_ID\t0x8000\n\nvoid InitSL_RTP(GF_SLConfig *slc)\n{\n\tmemset(slc, 0, sizeof(GF_SLConfig));\n\tslc->tag = GF_ODF_SLC_TAG;\n\tslc->useTimestampsFlag = 1;\n\tslc->timestampLength = 32;\n}\n\nvoid InitSL_NULL(GF_SLConfig *slc)\n{\n\tmemset(slc, 0, sizeof(GF_SLConfig));\n\tslc->tag = GF_ODF_SLC_TAG;\n\tslc->predefined = 0x01;\n}\n\n\n\nvoid MP4T_OnPacketDone(void *cbk, GF_RTPHeader *header)\n{\n\tu8 disposable;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint || !tkHint->HintSample) return;\n\tassert(header->TimeStamp == tkHint->RTPTime);\n\n\tdisposable = 0;\n\tif (tkHint->avc_nalu_size) {\n\t\tdisposable = tkHint->rtp_p->avc_non_idr ? 1 : 0;\n\t}\n\t/*for all other, assume that CTS=DTS means B-frame -> disposable*/\n\telse if (tkHint->has_ctts && (tkHint->rtp_p->sl_header.compositionTimeStamp==tkHint->rtp_p->sl_header.decodingTimeStamp)) {\n\t\tdisposable = 1;\n\t}\n\n\tgf_isom_rtp_packet_set_flags(tkHint->file, tkHint->HintTrack, 0, 0, header->Marker, disposable, 0);\n}\n\n\nvoid MP4T_OnDataRef(void *cbk, u32 payload_size, u32 offset_from_orig)\n{\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint || !payload_size) return;\n\n\t/*add reference*/\n\tgf_isom_hint_sample_data(tkHint->file, tkHint->HintTrack, tkHint->TrackID,\n\t                         tkHint->CurrentSample, (u16) payload_size, offset_from_orig + tkHint->base_offset_in_sample,\n\t                         NULL, 0);\n}\n\nvoid MP4T_OnData(void *cbk, u8 *data, u32 data_size, Bool is_header)\n{\n\tu8 at_begin;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!data_size) return;\n\n\tat_begin = is_header ? 1 : 0;\n\tif (data_size <= 14) {\n\t\tgf_isom_hint_direct_data(tkHint->file, tkHint->HintTrack, data, data_size, at_begin);\n\t} else {\n\t\tgf_isom_hint_sample_data(tkHint->file, tkHint->HintTrack, tkHint->HintID, 0, (u16) data_size, 0, data, at_begin);\n\t}\n}\n\n\nvoid MP4T_OnNewPacket(void *cbk, GF_RTPHeader *header)\n{\n\ts32 res;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint) return;\n\n\tres = (s32) (tkHint->rtp_p->sl_header.compositionTimeStamp - tkHint->rtp_p->sl_header.decodingTimeStamp);\n\tassert( !res || tkHint->has_ctts);\n\t/*do we need a new sample*/\n\tif (!tkHint->HintSample || (tkHint->RTPTime != header->TimeStamp)) {\n\t\t/*close current sample*/\n\t\tif (tkHint->HintSample) gf_isom_end_hint_sample(tkHint->file, tkHint->HintTrack, tkHint->SampleIsRAP);\n\n\t\t/*start new sample: We use DTS as the sampling instant (RTP TS) to make sure\n\t\tall packets are sent in order*/\n\t\tgf_isom_begin_hint_sample(tkHint->file, tkHint->HintTrack, 1, header->TimeStamp-res);\n\t\ttkHint->HintSample ++;\n\t\ttkHint->RTPTime = header->TimeStamp;\n\t\ttkHint->SampleIsRAP = tkHint->rtp_p->sl_config.hasRandomAccessUnitsOnlyFlag ? 1 : tkHint->rtp_p->sl_header.randomAccessPointFlag;\n\t}\n\t/*create an RTP Packet with the appropriated marker flag - note: the flags are temp ones,\n\tthey are set when the full packet is signaled (to handle multi AUs per RTP)*/\n\tgf_isom_rtp_packet_begin(tkHint->file, tkHint->HintTrack, 0, 0, 0, header->Marker, header->PayloadType, 0, 0, header->SequenceNumber);\n\t/*Add the delta TS to make sure RTP TS is indeed the CTS (sampling time)*/\n\tif (res) gf_isom_rtp_packet_set_offset(tkHint->file, tkHint->HintTrack, res);\n}\n\n\nGF_EXPORT\nGF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts>1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);\n\t\tif ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions & co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd && esd->decoderConfig) {\n\t\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\t\tcodecid = esd->decoderConfig->objectTypeIndication;\n\t\t\t\tif (esd->URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        && ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags & GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = \"AAC\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = \"CELP\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (esd)\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc && !svcc && !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp->file = file;\n\ttmp->TrackNum = TrackNum;\n\ttmp->avc_nalu_size = avc_nalu_size;\n\ttmp->nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags & GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp->TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp->HintID = tmp->TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;\n\n\ttmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp->rtp_p->slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\t*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);\n\t\tif (*e) {\n\t\t\tgf_hinter_track_del(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don't copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);\n\n\t*e = GF_OK;\n\treturn tmp;\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_force_no_offsets(GF_RTPHinter *tkHinter)\n{\n\tGF_Err e;\n\tif (!tkHinter) return GF_BAD_PARAM;\n\te = gf_isom_rtp_set_time_offset(tkHinter->file, tkHinter->HintTrack, 1, 0);\n\tif (e) return e;\n\treturn gf_isom_rtp_set_time_sequence_offset(tkHinter->file, tkHinter->HintTrack, 1, 0);\n}\n\nGF_EXPORT\nu32 gf_hinter_track_get_bandwidth(GF_RTPHinter *tkHinter)\n{\n\treturn tkHinter->bandwidth;\n}\n\nGF_EXPORT\nu32 gf_hinter_track_get_flags(GF_RTPHinter *tkHinter)\n{\n\treturn tkHinter->rtp_p->flags;\n}\nGF_EXPORT\nvoid gf_hinter_track_get_payload_name(GF_RTPHinter *tkHinter, char *payloadName)\n{\n\tchar mediaName[30];\n\tgf_rtp_builder_get_payload_name(tkHinter->rtp_p, payloadName, mediaName);\n}\n\nGF_EXPORT\nvoid gf_hinter_track_del(GF_RTPHinter *tkHinter)\n{\n\tif (!tkHinter) return;\n\n\tif (tkHinter->rtp_p) gf_rtp_builder_del(tkHinter->rtp_p);\n\tgf_free(tkHinter);\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)\n{\n\tGF_Err e;\n\tu32 i, descIndex, duration;\n\tu64 ts;\n\tu8 PadBits;\n\tGF_Fraction ft;\n\tGF_ISOSample *samp;\n\n\ttkHint->HintSample = tkHint->RTPTime = 0;\n\n\ttkHint->TotalSample = gf_isom_get_sample_count(tkHint->file, tkHint->TrackNum);\n\tft.num = tkHint->rtp_p->sl_config.timestampResolution;\n\tft.den = tkHint->OrigTimeScale;\n\n\te = GF_OK;\n\tfor (i=0; i<tkHint->TotalSample; i++) {\n\t\tsamp = gf_isom_get_sample(tkHint->file, tkHint->TrackNum, i+1, &descIndex);\n\t\tif (!samp) return gf_isom_last_error(tkHint->file);\n\n\t\t//setup SL\n\t\ttkHint->CurrentSample = i + 1;\n\n\t\t/*keep same AU indicator if sync shadow - TODO FIXME: this assumes shadows are placed interleaved with\n\t\tthe track content which is the case for GPAC scene carousel generation, but may not always be true*/\n\t\tif (samp->IsRAP==RAP_REDUNDANT) {\n\t\t\ttkHint->rtp_p->sl_header.AU_sequenceNumber -= 1;\n\t\t\tsamp->IsRAP = RAP;\n\t\t}\n\n\t\tts = ft.num * (samp->DTS+samp->CTS_Offset) / ft.den;\n\t\ttkHint->rtp_p->sl_header.compositionTimeStamp = ts;\n\n\t\tts = ft.num * samp->DTS / ft.den;\n\t\ttkHint->rtp_p->sl_header.decodingTimeStamp = ts;\n\t\ttkHint->rtp_p->sl_header.randomAccessPointFlag = samp->IsRAP;\n\n\t\ttkHint->base_offset_in_sample = 0;\n\t\t/*crypted*/\n\t\tif (tkHint->rtp_p->slMap.IV_length) {\n\t\t\tGF_ISMASample *s = gf_isom_get_ismacryp_sample(tkHint->file, tkHint->TrackNum, samp, descIndex);\n\t\t\t/*one byte take for selective_enc flag*/\n\t\t\tif (s->flags & GF_ISOM_ISMA_USE_SEL_ENC) tkHint->base_offset_in_sample += 1;\n\t\t\tif (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) tkHint->base_offset_in_sample += s->IV_length + s->KI_length;\n\t\t\tgf_free(samp->data);\n\t\t\tsamp->data = s->data;\n\t\t\tsamp->dataLength = s->dataLength;\n\t\t\tgf_rtp_builder_set_cryp_info(tkHint->rtp_p, s->IV, (char*)s->key_indicator, (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? 1 : 0);\n\t\t\ts->data = NULL;\n\t\t\ts->dataLength = 0;\n\t\t\tgf_isom_ismacryp_delete_sample(s);\n\t\t}\n\n\t\tif (tkHint->rtp_p->sl_config.usePaddingFlag) {\n\t\t\tgf_isom_get_sample_padding_bits(tkHint->file, tkHint->TrackNum, i+1, &PadBits);\n\t\t\ttkHint->rtp_p->sl_header.paddingBits = PadBits;\n\t\t} else {\n\t\t\ttkHint->rtp_p->sl_header.paddingBits = 0;\n\t\t}\n\n\t\tduration = gf_isom_get_sample_duration(tkHint->file, tkHint->TrackNum, i+1);\n//\t\tts = (u32) (ft * (s64) (duration));\n\n\t\t/*unpack nal units*/\n\t\tif (tkHint->avc_nalu_size) {\n\t\t\tu32 v, size;\n\t\t\tu32 remain = samp->dataLength;\n\t\t\tchar *ptr = samp->data;\n\n\t\t\ttkHint->rtp_p->sl_header.accessUnitStartFlag = 1;\n\t\t\ttkHint->rtp_p->sl_header.accessUnitEndFlag = 0;\n\t\t\twhile (remain) {\n\t\t\t\tsize = 0;\n\t\t\t\tv = tkHint->avc_nalu_size;\n\t\t\t\tif (v>remain) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size length is %d but only %d bytes left in sample %d\\n\", v, remain, tkHint->CurrentSample));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (v) {\n\t\t\t\t\tsize |= (u8) *ptr;\n\t\t\t\t\tptr++;\n\t\t\t\t\tremain--;\n\t\t\t\t\tv-=1;\n\t\t\t\t\tif (v) size<<=8;\n\t\t\t\t}\n\t\t\t\ttkHint->base_offset_in_sample = samp->dataLength-remain;\n\t\t\t\tif (remain < size) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is %d but only %d bytes left in sample %d\\n\", size, remain, tkHint->CurrentSample));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tremain -= size;\n\t\t\t\ttkHint->rtp_p->sl_header.accessUnitEndFlag = remain ? 0 : 1;\n\t\t\t\tif (!size) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is 0, ignoring it\\n\", size));\n\t\t\t\t} else {\n\t\t\t\t\te = gf_rtp_builder_process(tkHint->rtp_p, ptr, size, (u8) !remain, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );\n\t\t\t\t\tptr += size;\n\t\t\t\t}\n\t\t\t\ttkHint->rtp_p->sl_header.accessUnitStartFlag = 0;\n\t\t\t}\n\t\t} else {\n\t\t\te = gf_rtp_builder_process(tkHint->rtp_p, samp->data, samp->dataLength, 1, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );\n\t\t}\n\t\ttkHint->rtp_p->sl_header.packetSequenceNumber += 1;\n\n\t\t//signal some progress\n\t\tgf_set_progress(\"Hinting\", tkHint->CurrentSample, tkHint->TotalSample);\n\n\t\ttkHint->rtp_p->sl_header.AU_sequenceNumber += 1;\n\t\tgf_isom_sample_del(&samp);\n\n\t\tif (e) return e;\n\t}\n\n\t//flush\n\tgf_rtp_builder_process(tkHint->rtp_p, NULL, 0, 1, 0, 0, 0);\n\n\tgf_isom_end_hint_sample(tkHint->file, tkHint->HintTrack, (u8) tkHint->SampleIsRAP);\n\treturn GF_OK;\n}\n\nstatic u32 write_nalu_config_array(char *sdpLine, GF_List *nalus)\n{\n\tu32 i, count, b64s;\n\tchar b64[200];\n\n\tcount = gf_list_count(nalus);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(nalus, i);\n\t\tb64s = gf_base64_encode(sl->data, sl->size, b64, 200);\n\t\tb64[b64s]=0;\n\t\tstrcat(sdpLine, b64);\n\t\tif (i+1<count) strcat(sdpLine, \",\");\n\t}\n\treturn count;\n}\n\nstatic void write_avc_config(char *sdpLine, GF_AVCConfig *avcc, GF_AVCConfig *svcc)\n{\n\tu32 count = 0;\n\n\tif (avcc) count += gf_list_count(avcc->sequenceParameterSets) + gf_list_count(avcc->pictureParameterSets) + gf_list_count(avcc->sequenceParameterSetExtensions);\n\tif (svcc) count += gf_list_count(svcc->sequenceParameterSets) + gf_list_count(svcc->pictureParameterSets);\n\tif (!count) return;\n\n\tstrcat(sdpLine, \"; sprop-parameter-sets=\");\n\n\tif (avcc) {\n\t\tcount = write_nalu_config_array(sdpLine, avcc->sequenceParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, avcc->sequenceParameterSetExtensions);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, avcc->pictureParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t}\n\n\tif (svcc) {\n\t\tcount = write_nalu_config_array(sdpLine, svcc->sequenceParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, svcc->pictureParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t}\n\tcount = (u32) strlen(sdpLine);\n\tif (sdpLine[count-1] == ',')\n\t\tsdpLine[count-1] = 0;\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_finalize(GF_RTPHinter *tkHint, Bool AddSystemInfo)\n{\n\tu32 Width, Height;\n\tGF_ESD *esd;\n\tchar sdpLine[20000];\n\tchar mediaName[30], payloadName[30];\n    u32 mtype;\n\n\tWidth = Height = 0;\n\tgf_isom_sdp_clean_track(tkHint->file, tkHint->TrackNum);\n    mtype = gf_isom_get_media_type(tkHint->file, tkHint->TrackNum);\n    if (gf_isom_is_video_handler_type(mtype))\n\t\tgf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);\n\n\tgf_rtp_builder_get_payload_name(tkHint->rtp_p, payloadName, mediaName);\n\n\t/*TODO- extract out of rtp_p for future live tools*/\n\tsprintf(sdpLine, \"m=%s 0 RTP/%s %d\", mediaName, tkHint->rtp_p->slMap.IV_length ? \"SAVP\" : \"AVP\", tkHint->rtp_p->PayloadType);\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\tif (tkHint->bandwidth) {\n\t\tsprintf(sdpLine, \"b=AS:%d\", tkHint->bandwidth);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\tif (tkHint->nb_chan) {\n\t\tsprintf(sdpLine, \"a=rtpmap:%d %s/%d/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution, tkHint->nb_chan);\n\t} else {\n\t\tsprintf(sdpLine, \"a=rtpmap:%d %s/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution);\n\t}\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t/*control for MPEG-4*/\n\tif (AddSystemInfo) {\n\t\tsprintf(sdpLine, \"a=mpeg4-esid:%d\", gf_isom_get_track_id(tkHint->file, tkHint->TrackNum));\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*control for QTSS/DSS*/\n\tsprintf(sdpLine, \"a=control:trackID=%d\", gf_isom_get_track_id(tkHint->file, tkHint->HintTrack));\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\n\t/*H263 extensions*/\n\tif (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H263) {\n\t\tsprintf(sdpLine, \"a=cliprect:0,0,%d,%d\", Height, Width);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*AMR*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR_WB)) {\n\t\tsprintf(sdpLine, \"a=fmtp:%d octet-align=1\", tkHint->rtp_p->PayloadType);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*Text*/\n\telse if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {\n\t\tu32 w, h, i, m_w, m_h;\n\t\ts32 tx, ty;\n\t\ts16 l;\n\n\t\tgf_isom_get_track_layout_info(tkHint->file, tkHint->TrackNum, &w, &h, &tx, &ty, &l);\n\t\tm_w = w;\n\t\tm_h = h;\n\t\tfor (i=0; i<gf_isom_get_track_count(tkHint->file); i++) {\n\t\t\tswitch (gf_isom_get_media_type(tkHint->file, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tgf_isom_get_track_layout_info(tkHint->file, i+1, &w, &h, &tx, &ty, &l);\n\t\t\t\tif (w>m_w) m_w = w;\n\t\t\t\tif (h>m_h) m_h = h;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgf_media_format_ttxt_sdp(tkHint->rtp_p, payloadName, sdpLine, w, h, tx, ty, l, m_w, m_h, NULL);\n\n\t\tstrcat(sdpLine, \"; tx3g=\");\n\t\tfor (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {\n\t\t\tu8 *tx3g;\n\t\t\tchar buffer[2000];\n\t\t\tu32 tx3g_len, len;\n\t\t\tgf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);\n\t\t\tlen = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);\n\t\t\tgf_free(tx3g);\n\t\t\tbuffer[len] = 0;\n\t\t\tif (i) strcat(sdpLine, \", \");\n\t\t\tstrcat(sdpLine, buffer);\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*EVRC/SMV in non header-free mode*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (tkHint->rtp_p->auh_size>1)) {\n\t\tsprintf(sdpLine, \"a=fmtp:%d maxptime=%d\", tkHint->rtp_p->PayloadType, tkHint->rtp_p->auh_size*20);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*H264/AVC*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_AVC) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_SVC))  {\n\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(tkHint->file, tkHint->TrackNum, 1);\n\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(tkHint->file, tkHint->TrackNum, 1);\n\t\t/*TODO - check syntax for SVC (might be some extra signaling)*/\n\n\t\tif (avcc) {\n\t\t\tsprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t} else {\n\t\t\tif (!svcc)\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tsprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, svcc->AVCProfileIndication, svcc->profile_compatibility, svcc->AVCLevelIndication);\n\t\t}\n\n\t\twrite_avc_config(sdpLine, avcc, svcc);\n\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t\tgf_odf_avc_cfg_del(avcc);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\t/*MPEG-4 decoder config*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_MPEG4) {\n\t\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\n\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t} else {\n\t\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, NULL, 0);\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\tif (tkHint->rtp_p->slMap.IV_length) {\n\t\t\tconst char *kms;\n\t\t\tgf_isom_get_ismacryp_info(tkHint->file, tkHint->TrackNum, 1, NULL, NULL, NULL, NULL, &kms, NULL, NULL, NULL);\n\t\t\tif (!strnicmp(kms, \"(key)\", 5) || !strnicmp(kms, \"(ipmp)\", 6) || !strnicmp(kms, \"(uri)\", 5)) {\n\t\t\t\tstrcat(sdpLine, \"; ISMACrypKey=\");\n\t\t\t} else {\n\t\t\t\tstrcat(sdpLine, \"; ISMACrypKey=(uri)\");\n\t\t\t}\n\t\t\tstrcat(sdpLine, kms);\n\t\t}\n\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*MPEG-4 Audio LATM*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_LATM) {\n\t\tGF_BitStream *bs;\n\t\tu8 *config_bytes;\n\t\tu32 config_size;\n\n\t\t/* form config string */\n\t\tbs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_int(bs, 0, 1); /* AudioMuxVersion */\n\t\tgf_bs_write_int(bs, 1, 1); /* all streams same time */\n\t\tgf_bs_write_int(bs, 0, 6); /* numSubFrames */\n\t\tgf_bs_write_int(bs, 0, 4); /* numPrograms */\n\t\tgf_bs_write_int(bs, 0, 3); /* numLayer */\n\n\t\t/* audio-specific config */\n\t\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t/*PacketVideo patch: don't signal SBR and PS stuff, not allowed in LATM with audioMuxVersion=0*/\n\t\t\tgf_bs_write_data(bs, esd->decoderConfig->decoderSpecificInfo->data, MIN(esd->decoderConfig->decoderSpecificInfo->dataLength, 2) );\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\t/* other data */\n\t\tgf_bs_write_int(bs, 0, 3); /* frameLengthType */\n\t\tgf_bs_write_int(bs, 0xff, 8); /* latmBufferFullness */\n\t\tgf_bs_write_int(bs, 0, 1); /* otherDataPresent */\n\t\tgf_bs_write_int(bs, 0, 1); /* crcCheckPresent */\n\t\tgf_bs_get_content(bs, &config_bytes, &config_size);\n\t\tgf_bs_del(bs);\n\n\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, config_bytes, config_size);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t\tgf_free(config_bytes);\n\t}\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t/*3GPP DIMS*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {\n\t\tGF_DIMSDescription dims;\n\t\tgf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);\n\n\t\tgf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &dims);\n\t\tsprintf(sdpLine, \"a=fmtp:%d Version-profile=%d\", tkHint->rtp_p->PayloadType, dims.profile);\n\t\tif (! dims.fullRequestHost) {\n\t\t\tchar fmt[200];\n\t\t\tstrcat(sdpLine, \";useFullRequestHost=0\");\n\t\t\tsprintf(fmt, \";pathComponents=%d\", dims.pathComponents);\n\t\t\tstrcat(sdpLine, fmt);\n\t\t}\n\t\tif (!dims.streamType) strcat(sdpLine, \";stream-type=secondary\");\n\t\tif (dims.containsRedundant == 1) strcat(sdpLine, \";contains-redundant=main\");\n\t\telse if (dims.containsRedundant == 2) strcat(sdpLine, \";contains-redundant=redundant\");\n\n\t\tif (dims.textEncoding && strlen(dims.textEncoding)) {\n\t\t\tstrcat(sdpLine, \";text-encoding=\");\n\t\t\tstrcat(sdpLine, dims.textEncoding);\n\t\t}\n\t\tif (dims.contentEncoding && strlen(dims.contentEncoding)) {\n\t\t\tstrcat(sdpLine, \";content-coding=\");\n\t\t\tstrcat(sdpLine, dims.contentEncoding);\n\t\t}\n\t\tif (dims.contentEncoding && dims.content_script_types && strlen(dims.content_script_types) ) {\n\t\t\tstrcat(sdpLine, \";content-script-types=\");\n\t\t\tstrcat(sdpLine, dims.contentEncoding);\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n#endif\n\t/*extensions for some mobile phones*/\n\tif (Width && Height) {\n\t\tsprintf(sdpLine, \"a=framesize:%d %d-%d\", tkHint->rtp_p->PayloadType, Width, Height);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\n\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\tif (esd && esd->decoderConfig && (esd->decoderConfig->rvc_config || esd->decoderConfig->predefined_rvc_config)) {\n\t\tif (esd->decoderConfig->predefined_rvc_config) {\n\t\t\tsprintf(sdpLine, \"a=rvc-config-predef:%d\", esd->decoderConfig->predefined_rvc_config);\n\t\t} else {\n\t\t\t/*temporary ...*/\n\t\t\tif ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {\n\t\t\t\tsprintf(sdpLine, \"a=rvc-config:%s\", \"http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml\");\n\t\t\t} else {\n\t\t\t\tsprintf(sdpLine, \"a=rvc-config:%s\", \"http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml\");\n\t\t\t}\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\tgf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, GF_TRUE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_hinter_can_embbed_data(u8 *data, u32 data_size, u32 streamType)\n{\n\tchar data64[5000];\n\tu32 size64;\n\n\tsize64 = gf_base64_encode(data, data_size, data64, 5000);\n\tif (!size64) return 0;\n\tswitch (streamType) {\n\tcase GF_STREAM_OD:\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-od-au;base64,\");\n\t\tbreak;\n\tcase GF_STREAM_SCENE:\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-bifs-au;base64,\");\n\t\tbreak;\n\tdefault:\n\t\t/*NOT NORMATIVE*/\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-es-au;base64,\");\n\t\tbreak;\n\t}\n\tif (size64>=255) return 0;\n\treturn 1;\n}\n\n\nGF_EXPORT\nGF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \"b=AS:%d\", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \"a=x-copyright: %s\", \"MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\");\n    } else {\n        sprintf(buf64, \"a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-od-au;base64,%s\", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-bifs-au;base64,%s\", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \"a=isma-compliance:1,1.0,1\");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \"a=mpeg4-iod:\\\"data:application/mpeg4-iod;base64,%s\\\"\", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/media_tools/isom_hinter.c"], "buggy_code_start_loc": [404], "buggy_code_end_loc": [407], "fixing_code_start_loc": [405], "fixing_code_end_loc": [407], "type": "CWE-119", "message": "The gf_hinter_track_new function in GPAC 1.0.1 allows attackers to read memory via a crafted file in the MP4Box command.", "other": {"cve": {"id": "CVE-2021-31261", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-19T19:15:18.517", "lastModified": "2021-04-21T19:32:26.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The gf_hinter_track_new function in GPAC 1.0.1 allows attackers to read memory via a crafted file in the MP4Box command."}, {"lang": "es", "value": "La funci\u00f3n gf_hinter_track_new en GPAC versi\u00f3n 1.0.1, permite a atacantes leer la memoria por medio de un archivo dise\u00f1ado en el comando MP4Box"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/cd3738dea038dbd12e603ad48cd7373ae0440f65", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1737", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/cd3738dea038dbd12e603ad48cd7373ae0440f65"}}