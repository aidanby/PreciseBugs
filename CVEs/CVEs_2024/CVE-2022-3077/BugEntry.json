{"buggy_code": ["/*\n * This file is provided under a dual BSD/GPLv2 license.  When using or\n * redistributing this file, you may do so under either license.\n *\n * Copyright(c) 2012 Intel Corporation. All rights reserved.\n *\n * GPL LICENSE SUMMARY\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * The full GNU General Public License is included in this distribution\n * in the file called LICENSE.GPL.\n *\n * BSD LICENSE\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n *   * Neither the name of Intel Corporation nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n *  Supports the SMBus Message Transport (SMT) in the Intel Atom Processor\n *  S12xx Product Family.\n *\n *  Features supported by this driver:\n *  Hardware PEC                     yes\n *  Block buffer                     yes\n *  Block process call transaction   yes\n *  Slave mode                       no\n */\n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n\n#include <linux/io-64-nonatomic-lo-hi.h>\n\n/* PCI Address Constants */\n#define SMBBAR\t\t0\n\n/* PCI DIDs for the Intel SMBus Message Transport (SMT) Devices */\n#define PCI_DEVICE_ID_INTEL_S1200_SMT0\t0x0c59\n#define PCI_DEVICE_ID_INTEL_S1200_SMT1\t0x0c5a\n#define PCI_DEVICE_ID_INTEL_CDF_SMT\t0x18ac\n#define PCI_DEVICE_ID_INTEL_DNV_SMT\t0x19ac\n#define PCI_DEVICE_ID_INTEL_EBG_SMT\t0x1bff\n#define PCI_DEVICE_ID_INTEL_AVOTON_SMT\t0x1f15\n\n#define ISMT_DESC_ENTRIES\t2\t/* number of descriptor entries */\n#define ISMT_MAX_RETRIES\t3\t/* number of SMBus retries to attempt */\n#define ISMT_LOG_ENTRIES\t3\t/* number of interrupt cause log entries */\n\n/* Hardware Descriptor Constants - Control Field */\n#define ISMT_DESC_CWRL\t0x01\t/* Command/Write Length */\n#define ISMT_DESC_BLK\t0X04\t/* Perform Block Transaction */\n#define ISMT_DESC_FAIR\t0x08\t/* Set fairness flag upon successful arbit. */\n#define ISMT_DESC_PEC\t0x10\t/* Packet Error Code */\n#define ISMT_DESC_I2C\t0x20\t/* I2C Enable */\n#define ISMT_DESC_INT\t0x40\t/* Interrupt */\n#define ISMT_DESC_SOE\t0x80\t/* Stop On Error */\n\n/* Hardware Descriptor Constants - Status Field */\n#define ISMT_DESC_SCS\t0x01\t/* Success */\n#define ISMT_DESC_DLTO\t0x04\t/* Data Low Time Out */\n#define ISMT_DESC_NAK\t0x08\t/* NAK Received */\n#define ISMT_DESC_CRC\t0x10\t/* CRC Error */\n#define ISMT_DESC_CLTO\t0x20\t/* Clock Low Time Out */\n#define ISMT_DESC_COL\t0x40\t/* Collisions */\n#define ISMT_DESC_LPR\t0x80\t/* Large Packet Received */\n\n/* Macros */\n#define ISMT_DESC_ADDR_RW(addr, rw) (((addr) << 1) | (rw))\n\n/* iSMT General Register address offsets (SMBBAR + <addr>) */\n#define ISMT_GR_GCTRL\t\t0x000\t/* General Control */\n#define ISMT_GR_SMTICL\t\t0x008\t/* SMT Interrupt Cause Location */\n#define ISMT_GR_ERRINTMSK\t0x010\t/* Error Interrupt Mask */\n#define ISMT_GR_ERRAERMSK\t0x014\t/* Error AER Mask */\n#define ISMT_GR_ERRSTS\t\t0x018\t/* Error Status */\n#define ISMT_GR_ERRINFO\t\t0x01c\t/* Error Information */\n\n/* iSMT Master Registers */\n#define ISMT_MSTR_MDBA\t\t0x100\t/* Master Descriptor Base Address */\n#define ISMT_MSTR_MCTRL\t\t0x108\t/* Master Control */\n#define ISMT_MSTR_MSTS\t\t0x10c\t/* Master Status */\n#define ISMT_MSTR_MDS\t\t0x110\t/* Master Descriptor Size */\n#define ISMT_MSTR_RPOLICY\t0x114\t/* Retry Policy */\n\n/* iSMT Miscellaneous Registers */\n#define ISMT_SPGT\t0x300\t/* SMBus PHY Global Timing */\n\n/* General Control Register (GCTRL) bit definitions */\n#define ISMT_GCTRL_TRST\t0x04\t/* Target Reset */\n#define ISMT_GCTRL_KILL\t0x08\t/* Kill */\n#define ISMT_GCTRL_SRST\t0x40\t/* Soft Reset */\n\n/* Master Control Register (MCTRL) bit definitions */\n#define ISMT_MCTRL_SS\t0x01\t\t/* Start/Stop */\n#define ISMT_MCTRL_MEIE\t0x10\t\t/* Master Error Interrupt Enable */\n#define ISMT_MCTRL_FMHP\t0x00ff0000\t/* Firmware Master Head Ptr (FMHP) */\n\n/* Master Status Register (MSTS) bit definitions */\n#define ISMT_MSTS_HMTP\t0xff0000\t/* HW Master Tail Pointer (HMTP) */\n#define ISMT_MSTS_MIS\t0x20\t\t/* Master Interrupt Status (MIS) */\n#define ISMT_MSTS_MEIS\t0x10\t\t/* Master Error Int Status (MEIS) */\n#define ISMT_MSTS_IP\t0x01\t\t/* In Progress */\n\n/* Master Descriptor Size (MDS) bit definitions */\n#define ISMT_MDS_MASK\t0xff\t/* Master Descriptor Size mask (MDS) */\n\n/* SMBus PHY Global Timing Register (SPGT) bit definitions */\n#define ISMT_SPGT_SPD_MASK\t0xc0000000\t/* SMBus Speed mask */\n#define ISMT_SPGT_SPD_80K\t0x00\t\t/* 80 kHz */\n#define ISMT_SPGT_SPD_100K\t(0x1 << 30)\t/* 100 kHz */\n#define ISMT_SPGT_SPD_400K\t(0x2U << 30)\t/* 400 kHz */\n#define ISMT_SPGT_SPD_1M\t(0x3U << 30)\t/* 1 MHz */\n\n\n/* MSI Control Register (MSICTL) bit definitions */\n#define ISMT_MSICTL_MSIE\t0x01\t/* MSI Enable */\n\n/* iSMT Hardware Descriptor */\nstruct ismt_desc {\n\tu8 tgtaddr_rw;\t/* target address & r/w bit */\n\tu8 wr_len_cmd;\t/* write length in bytes or a command */\n\tu8 rd_len;\t/* read length */\n\tu8 control;\t/* control bits */\n\tu8 status;\t/* status bits */\n\tu8 retry;\t/* collision retry and retry count */\n\tu8 rxbytes;\t/* received bytes */\n\tu8 txbytes;\t/* transmitted bytes */\n\tu32 dptr_low;\t/* lower 32 bit of the data pointer */\n\tu32 dptr_high;\t/* upper 32 bit of the data pointer */\n} __packed;\n\nstruct ismt_priv {\n\tstruct i2c_adapter adapter;\n\tvoid __iomem *smba;\t\t\t/* PCI BAR */\n\tstruct pci_dev *pci_dev;\n\tstruct ismt_desc *hw;\t\t\t/* descriptor virt base addr */\n\tdma_addr_t io_rng_dma;\t\t\t/* descriptor HW base addr */\n\tu8 head;\t\t\t\t/* ring buffer head pointer */\n\tstruct completion cmp;\t\t\t/* interrupt completion */\n\tu8 buffer[I2C_SMBUS_BLOCK_MAX + 16];\t/* temp R/W data buffer */\n\tdma_addr_t log_dma;\n\tu32 *log;\n};\n\nstatic const struct pci_device_id ismt_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_S1200_SMT0) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_S1200_SMT1) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_CDF_SMT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_DNV_SMT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_EBG_SMT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_AVOTON_SMT) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, ismt_ids);\n\n/* Bus speed control bits for slow debuggers - refer to the docs for usage */\nstatic unsigned int bus_speed;\nmodule_param(bus_speed, uint, S_IRUGO);\nMODULE_PARM_DESC(bus_speed, \"Bus Speed in kHz (0 = BIOS default)\");\n\n/**\n * __ismt_desc_dump() - dump the contents of a specific descriptor\n * @dev: the iSMT device\n * @desc: the iSMT hardware descriptor\n */\nstatic void __ismt_desc_dump(struct device *dev, const struct ismt_desc *desc)\n{\n\n\tdev_dbg(dev, \"Descriptor struct:  %p\\n\", desc);\n\tdev_dbg(dev, \"\\ttgtaddr_rw=0x%02X\\n\", desc->tgtaddr_rw);\n\tdev_dbg(dev, \"\\twr_len_cmd=0x%02X\\n\", desc->wr_len_cmd);\n\tdev_dbg(dev, \"\\trd_len=    0x%02X\\n\", desc->rd_len);\n\tdev_dbg(dev, \"\\tcontrol=   0x%02X\\n\", desc->control);\n\tdev_dbg(dev, \"\\tstatus=    0x%02X\\n\", desc->status);\n\tdev_dbg(dev, \"\\tretry=     0x%02X\\n\", desc->retry);\n\tdev_dbg(dev, \"\\trxbytes=   0x%02X\\n\", desc->rxbytes);\n\tdev_dbg(dev, \"\\ttxbytes=   0x%02X\\n\", desc->txbytes);\n\tdev_dbg(dev, \"\\tdptr_low=  0x%08X\\n\", desc->dptr_low);\n\tdev_dbg(dev, \"\\tdptr_high= 0x%08X\\n\", desc->dptr_high);\n}\n/**\n * ismt_desc_dump() - dump the contents of a descriptor for debug purposes\n * @priv: iSMT private data\n */\nstatic void ismt_desc_dump(struct ismt_priv *priv)\n{\n\tstruct device *dev = &priv->pci_dev->dev;\n\tstruct ismt_desc *desc = &priv->hw[priv->head];\n\n\tdev_dbg(dev, \"Dump of the descriptor struct:  0x%X\\n\", priv->head);\n\t__ismt_desc_dump(dev, desc);\n}\n\n/**\n * ismt_gen_reg_dump() - dump the iSMT General Registers\n * @priv: iSMT private data\n */\nstatic void ismt_gen_reg_dump(struct ismt_priv *priv)\n{\n\tstruct device *dev = &priv->pci_dev->dev;\n\n\tdev_dbg(dev, \"Dump of the iSMT General Registers\\n\");\n\tdev_dbg(dev, \"  GCTRL.... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_GCTRL,\n\t\treadl(priv->smba + ISMT_GR_GCTRL));\n\tdev_dbg(dev, \"  SMTICL... : (0x%p)=0x%016llX\\n\",\n\t\tpriv->smba + ISMT_GR_SMTICL,\n\t\t(long long unsigned int)readq(priv->smba + ISMT_GR_SMTICL));\n\tdev_dbg(dev, \"  ERRINTMSK : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRINTMSK,\n\t\treadl(priv->smba + ISMT_GR_ERRINTMSK));\n\tdev_dbg(dev, \"  ERRAERMSK : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRAERMSK,\n\t\treadl(priv->smba + ISMT_GR_ERRAERMSK));\n\tdev_dbg(dev, \"  ERRSTS... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRSTS,\n\t\treadl(priv->smba + ISMT_GR_ERRSTS));\n\tdev_dbg(dev, \"  ERRINFO.. : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRINFO,\n\t\treadl(priv->smba + ISMT_GR_ERRINFO));\n}\n\n/**\n * ismt_mstr_reg_dump() - dump the iSMT Master Registers\n * @priv: iSMT private data\n */\nstatic void ismt_mstr_reg_dump(struct ismt_priv *priv)\n{\n\tstruct device *dev = &priv->pci_dev->dev;\n\n\tdev_dbg(dev, \"Dump of the iSMT Master Registers\\n\");\n\tdev_dbg(dev, \"  MDBA..... : (0x%p)=0x%016llX\\n\",\n\t\tpriv->smba + ISMT_MSTR_MDBA,\n\t\t(long long unsigned int)readq(priv->smba + ISMT_MSTR_MDBA));\n\tdev_dbg(dev, \"  MCTRL.... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_MCTRL,\n\t\treadl(priv->smba + ISMT_MSTR_MCTRL));\n\tdev_dbg(dev, \"  MSTS..... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_MSTS,\n\t\treadl(priv->smba + ISMT_MSTR_MSTS));\n\tdev_dbg(dev, \"  MDS...... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_MDS,\n\t\treadl(priv->smba + ISMT_MSTR_MDS));\n\tdev_dbg(dev, \"  RPOLICY.. : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_RPOLICY,\n\t\treadl(priv->smba + ISMT_MSTR_RPOLICY));\n\tdev_dbg(dev, \"  SPGT..... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_SPGT,\n\t\treadl(priv->smba + ISMT_SPGT));\n}\n\n/**\n * ismt_submit_desc() - add a descriptor to the ring\n * @priv: iSMT private data\n */\nstatic void ismt_submit_desc(struct ismt_priv *priv)\n{\n\tuint fmhp;\n\tuint val;\n\n\tismt_desc_dump(priv);\n\tismt_gen_reg_dump(priv);\n\tismt_mstr_reg_dump(priv);\n\n\t/* Set the FMHP (Firmware Master Head Pointer)*/\n\tfmhp = ((priv->head + 1) % ISMT_DESC_ENTRIES) << 16;\n\tval = readl(priv->smba + ISMT_MSTR_MCTRL);\n\twritel((val & ~ISMT_MCTRL_FMHP) | fmhp,\n\t       priv->smba + ISMT_MSTR_MCTRL);\n\n\t/* Set the start bit */\n\tval = readl(priv->smba + ISMT_MSTR_MCTRL);\n\twritel(val | ISMT_MCTRL_SS,\n\t       priv->smba + ISMT_MSTR_MCTRL);\n}\n\n/**\n * ismt_process_desc() - handle the completion of the descriptor\n * @desc: the iSMT hardware descriptor\n * @data: data buffer from the upper layer\n * @priv: ismt_priv struct holding our dma buffer\n * @size: SMBus transaction type\n * @read_write: flag to indicate if this is a read or write\n */\nstatic int ismt_process_desc(const struct ismt_desc *desc,\n\t\t\t     union i2c_smbus_data *data,\n\t\t\t     struct ismt_priv *priv, int size,\n\t\t\t     char read_write)\n{\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdev_dbg(&priv->pci_dev->dev, \"Processing completed descriptor\\n\");\n\t__ismt_desc_dump(&priv->pci_dev->dev, desc);\n\tismt_gen_reg_dump(priv);\n\tismt_mstr_reg_dump(priv);\n\n\tif (desc->status & ISMT_DESC_SCS) {\n\t\tif (read_write == I2C_SMBUS_WRITE &&\n\t\t    size != I2C_SMBUS_PROC_CALL &&\n\t\t    size != I2C_SMBUS_BLOCK_PROC_CALL)\n\t\t\treturn 0;\n\n\t\tswitch (size) {\n\t\tcase I2C_SMBUS_BYTE:\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\tdata->byte = dma_buffer[0];\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\tdata->word = dma_buffer[0] | (dma_buffer[1] << 8);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\t\tif (desc->rxbytes != dma_buffer[0] + 1)\n\t\t\t\treturn -EMSGSIZE;\n\n\t\t\tmemcpy(data->block, dma_buffer, desc->rxbytes);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t\tmemcpy(&data->block[1], dma_buffer, desc->rxbytes);\n\t\t\tdata->block[0] = desc->rxbytes;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (likely(desc->status & ISMT_DESC_NAK))\n\t\treturn -ENXIO;\n\n\tif (desc->status & ISMT_DESC_CRC)\n\t\treturn -EBADMSG;\n\n\tif (desc->status & ISMT_DESC_COL)\n\t\treturn -EAGAIN;\n\n\tif (desc->status & ISMT_DESC_LPR)\n\t\treturn -EPROTO;\n\n\tif (desc->status & (ISMT_DESC_DLTO | ISMT_DESC_CLTO))\n\t\treturn -ETIMEDOUT;\n\n\treturn -EIO;\n}\n\n/**\n * ismt_access() - process an SMBus command\n * @adap: the i2c host adapter\n * @addr: address of the i2c/SMBus target\n * @flags: command options\n * @read_write: read from or write to device\n * @command: the i2c/SMBus command to issue\n * @size: SMBus transaction type\n * @data: read/write data buffer\n */\nstatic int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; /* address of the data buffer */\n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdesc = &priv->hw[priv->head];\n\n\t/* Initialize the DMA buffer */\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\n\t/* Initialize the descriptor */\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\n\t/* Always clear the log entries */\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\n\t/* Initialize common control bits */\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Send Byte\n\t\t\t * The command field contains the write data\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\t/* Receive Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Write Byte\n\t\t\t * Command plus 1 data byte\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\t/* Read Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Write Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\t/* Read Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t/* Make sure the length is valid */\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* i2c Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* i2c Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\t/*\n\t\t\t * Per the \"Table 15-15. I2C Commands\",\n\t\t\t * in the External Design Specification (EDS),\n\t\t\t * (Document Number: 508084, Revision: 2.0),\n\t\t\t * the _rw bit must be 0\n\t\t\t */\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* map the data buffer */\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\n\treinit_completion(&priv->cmp);\n\n\t/* Add the descriptor */\n\tismt_submit_desc(priv);\n\n\t/* Now we wait for interrupt completion, 1s */\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\n\t/* unmap the data buffer */\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/* do any post processing of the descriptor here */\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\n\nout:\n\t/* Update the ring pointer */\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\n\treturn ret;\n}\n\n/**\n * ismt_func() - report which i2c commands are supported by this adapter\n * @adap: the i2c host adapter\n */\nstatic u32 ismt_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_QUICK\t\t|\n\t       I2C_FUNC_SMBUS_BYTE\t\t|\n\t       I2C_FUNC_SMBUS_BYTE_DATA\t\t|\n\t       I2C_FUNC_SMBUS_WORD_DATA\t\t|\n\t       I2C_FUNC_SMBUS_PROC_CALL\t\t|\n\t       I2C_FUNC_SMBUS_BLOCK_PROC_CALL\t|\n\t       I2C_FUNC_SMBUS_BLOCK_DATA\t|\n\t       I2C_FUNC_SMBUS_I2C_BLOCK\t\t|\n\t       I2C_FUNC_SMBUS_PEC;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= ismt_access,\n\t.functionality\t= ismt_func,\n};\n\n/**\n * ismt_handle_isr() - interrupt handler bottom half\n * @priv: iSMT private data\n */\nstatic irqreturn_t ismt_handle_isr(struct ismt_priv *priv)\n{\n\tcomplete(&priv->cmp);\n\n\treturn IRQ_HANDLED;\n}\n\n\n/**\n * ismt_do_interrupt() - IRQ interrupt handler\n * @vec: interrupt vector\n * @data: iSMT private data\n */\nstatic irqreturn_t ismt_do_interrupt(int vec, void *data)\n{\n\tu32 val;\n\tstruct ismt_priv *priv = data;\n\n\t/*\n\t * check to see it's our interrupt, return IRQ_NONE if not ours\n\t * since we are sharing interrupt\n\t */\n\tval = readl(priv->smba + ISMT_MSTR_MSTS);\n\n\tif (!(val & (ISMT_MSTS_MIS | ISMT_MSTS_MEIS)))\n\t\treturn IRQ_NONE;\n\telse\n\t\twritel(val | ISMT_MSTS_MIS | ISMT_MSTS_MEIS,\n\t\t       priv->smba + ISMT_MSTR_MSTS);\n\n\treturn ismt_handle_isr(priv);\n}\n\n/**\n * ismt_do_msi_interrupt() - MSI interrupt handler\n * @vec: interrupt vector\n * @data: iSMT private data\n */\nstatic irqreturn_t ismt_do_msi_interrupt(int vec, void *data)\n{\n\treturn ismt_handle_isr(data);\n}\n\n/**\n * ismt_hw_init() - initialize the iSMT hardware\n * @priv: iSMT private data\n */\nstatic void ismt_hw_init(struct ismt_priv *priv)\n{\n\tu32 val;\n\tstruct device *dev = &priv->pci_dev->dev;\n\n\t/* initialize the Master Descriptor Base Address (MDBA) */\n\twriteq(priv->io_rng_dma, priv->smba + ISMT_MSTR_MDBA);\n\n\twriteq(priv->log_dma, priv->smba + ISMT_GR_SMTICL);\n\n\t/* initialize the Master Control Register (MCTRL) */\n\twritel(ISMT_MCTRL_MEIE, priv->smba + ISMT_MSTR_MCTRL);\n\n\t/* initialize the Master Status Register (MSTS) */\n\twritel(0, priv->smba + ISMT_MSTR_MSTS);\n\n\t/* initialize the Master Descriptor Size (MDS) */\n\tval = readl(priv->smba + ISMT_MSTR_MDS);\n\twritel((val & ~ISMT_MDS_MASK) | (ISMT_DESC_ENTRIES - 1),\n\t\tpriv->smba + ISMT_MSTR_MDS);\n\n\t/*\n\t * Set the SMBus speed (could use this for slow HW debuggers)\n\t */\n\n\tval = readl(priv->smba + ISMT_SPGT);\n\n\tswitch (bus_speed) {\n\tcase 0:\n\t\tbreak;\n\n\tcase 80:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 80 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_80K),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tcase 100:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 100 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_100K),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tcase 400:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 400 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_400K),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tcase 1000:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 1000 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_1M),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(dev, \"Invalid SMBus clock speed, only 0, 80, 100, 400, and 1000 are valid\\n\");\n\t\tbreak;\n\t}\n\n\tval = readl(priv->smba + ISMT_SPGT);\n\n\tswitch (val & ISMT_SPGT_SPD_MASK) {\n\tcase ISMT_SPGT_SPD_80K:\n\t\tbus_speed = 80;\n\t\tbreak;\n\tcase ISMT_SPGT_SPD_100K:\n\t\tbus_speed = 100;\n\t\tbreak;\n\tcase ISMT_SPGT_SPD_400K:\n\t\tbus_speed = 400;\n\t\tbreak;\n\tcase ISMT_SPGT_SPD_1M:\n\t\tbus_speed = 1000;\n\t\tbreak;\n\t}\n\tdev_dbg(dev, \"SMBus clock is running at %d kHz\\n\", bus_speed);\n}\n\n/**\n * ismt_dev_init() - initialize the iSMT data structures\n * @priv: iSMT private data\n */\nstatic int ismt_dev_init(struct ismt_priv *priv)\n{\n\t/* allocate memory for the descriptor */\n\tpriv->hw = dmam_alloc_coherent(&priv->pci_dev->dev,\n\t\t\t\t       (ISMT_DESC_ENTRIES\n\t\t\t\t\t       * sizeof(struct ismt_desc)),\n\t\t\t\t       &priv->io_rng_dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (!priv->hw)\n\t\treturn -ENOMEM;\n\n\tpriv->head = 0;\n\tinit_completion(&priv->cmp);\n\n\tpriv->log = dmam_alloc_coherent(&priv->pci_dev->dev,\n\t\t\t\t\tISMT_LOG_ENTRIES * sizeof(u32),\n\t\t\t\t\t&priv->log_dma, GFP_KERNEL);\n\tif (!priv->log)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/**\n * ismt_int_init() - initialize interrupts\n * @priv: iSMT private data\n */\nstatic int ismt_int_init(struct ismt_priv *priv)\n{\n\tint err;\n\n\t/* Try using MSI interrupts */\n\terr = pci_enable_msi(priv->pci_dev);\n\tif (err)\n\t\tgoto intx;\n\n\terr = devm_request_irq(&priv->pci_dev->dev,\n\t\t\t       priv->pci_dev->irq,\n\t\t\t       ismt_do_msi_interrupt,\n\t\t\t       0,\n\t\t\t       \"ismt-msi\",\n\t\t\t       priv);\n\tif (err) {\n\t\tpci_disable_msi(priv->pci_dev);\n\t\tgoto intx;\n\t}\n\n\treturn 0;\n\n\t/* Try using legacy interrupts */\nintx:\n\tdev_warn(&priv->pci_dev->dev,\n\t\t \"Unable to use MSI interrupts, falling back to legacy\\n\");\n\n\terr = devm_request_irq(&priv->pci_dev->dev,\n\t\t\t       priv->pci_dev->irq,\n\t\t\t       ismt_do_interrupt,\n\t\t\t       IRQF_SHARED,\n\t\t\t       \"ismt-intx\",\n\t\t\t       priv);\n\tif (err) {\n\t\tdev_err(&priv->pci_dev->dev, \"no usable interrupts\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct pci_driver ismt_driver;\n\n/**\n * ismt_probe() - probe for iSMT devices\n * @pdev: PCI-Express device\n * @id: PCI-Express device ID\n */\nstatic int\nismt_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint err;\n\tstruct ismt_priv *priv;\n\tunsigned long start, len;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, priv);\n\n\ti2c_set_adapdata(&priv->adapter, priv);\n\tpriv->adapter.owner = THIS_MODULE;\n\tpriv->adapter.class = I2C_CLASS_HWMON;\n\tpriv->adapter.algo = &smbus_algorithm;\n\tpriv->adapter.dev.parent = &pdev->dev;\n\tACPI_COMPANION_SET(&priv->adapter.dev, ACPI_COMPANION(&pdev->dev));\n\tpriv->adapter.retries = ISMT_MAX_RETRIES;\n\n\tpriv->pci_dev = pdev;\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to enable SMBus PCI device (%d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t/* enable bus mastering */\n\tpci_set_master(pdev);\n\n\t/* Determine the address of the SMBus area */\n\tstart = pci_resource_start(pdev, SMBBAR);\n\tlen = pci_resource_len(pdev, SMBBAR);\n\tif (!start || !len) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"SMBus base address uninitialized, upgrade BIOS\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsnprintf(priv->adapter.name, sizeof(priv->adapter.name),\n\t\t \"SMBus iSMT adapter at %lx\", start);\n\n\tdev_dbg(&priv->pci_dev->dev, \" start=0x%lX\\n\", start);\n\tdev_dbg(&priv->pci_dev->dev, \" len=0x%lX\\n\", len);\n\n\terr = acpi_check_resource_conflict(&pdev->resource[SMBBAR]);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"ACPI resource conflict!\\n\");\n\t\treturn err;\n\t}\n\n\terr = pci_request_region(pdev, SMBBAR, ismt_driver.name);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to request SMBus region 0x%lx-0x%lx\\n\",\n\t\t\tstart, start + len);\n\t\treturn err;\n\t}\n\n\tpriv->smba = pcim_iomap(pdev, SMBBAR, len);\n\tif (!priv->smba) {\n\t\tdev_err(&pdev->dev, \"Unable to ioremap SMBus BAR\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"dma_set_mask fail\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\terr = ismt_dev_init(priv);\n\tif (err)\n\t\treturn err;\n\n\tismt_hw_init(priv);\n\n\terr = ismt_int_init(priv);\n\tif (err)\n\t\treturn err;\n\n\terr = i2c_add_adapter(&priv->adapter);\n\tif (err)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\n/**\n * ismt_remove() - release driver resources\n * @pdev: PCI-Express device\n */\nstatic void ismt_remove(struct pci_dev *pdev)\n{\n\tstruct ismt_priv *priv = pci_get_drvdata(pdev);\n\n\ti2c_del_adapter(&priv->adapter);\n}\n\nstatic struct pci_driver ismt_driver = {\n\t.name = \"ismt_smbus\",\n\t.id_table = ismt_ids,\n\t.probe = ismt_probe,\n\t.remove = ismt_remove,\n};\n\nmodule_pci_driver(ismt_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Bill E. Brown <bill.e.brown@intel.com>\");\nMODULE_DESCRIPTION(\"Intel SMBus Message Transport (iSMT) driver\");\n"], "fixing_code": ["/*\n * This file is provided under a dual BSD/GPLv2 license.  When using or\n * redistributing this file, you may do so under either license.\n *\n * Copyright(c) 2012 Intel Corporation. All rights reserved.\n *\n * GPL LICENSE SUMMARY\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * The full GNU General Public License is included in this distribution\n * in the file called LICENSE.GPL.\n *\n * BSD LICENSE\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n *   * Neither the name of Intel Corporation nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n *  Supports the SMBus Message Transport (SMT) in the Intel Atom Processor\n *  S12xx Product Family.\n *\n *  Features supported by this driver:\n *  Hardware PEC                     yes\n *  Block buffer                     yes\n *  Block process call transaction   yes\n *  Slave mode                       no\n */\n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n\n#include <linux/io-64-nonatomic-lo-hi.h>\n\n/* PCI Address Constants */\n#define SMBBAR\t\t0\n\n/* PCI DIDs for the Intel SMBus Message Transport (SMT) Devices */\n#define PCI_DEVICE_ID_INTEL_S1200_SMT0\t0x0c59\n#define PCI_DEVICE_ID_INTEL_S1200_SMT1\t0x0c5a\n#define PCI_DEVICE_ID_INTEL_CDF_SMT\t0x18ac\n#define PCI_DEVICE_ID_INTEL_DNV_SMT\t0x19ac\n#define PCI_DEVICE_ID_INTEL_EBG_SMT\t0x1bff\n#define PCI_DEVICE_ID_INTEL_AVOTON_SMT\t0x1f15\n\n#define ISMT_DESC_ENTRIES\t2\t/* number of descriptor entries */\n#define ISMT_MAX_RETRIES\t3\t/* number of SMBus retries to attempt */\n#define ISMT_LOG_ENTRIES\t3\t/* number of interrupt cause log entries */\n\n/* Hardware Descriptor Constants - Control Field */\n#define ISMT_DESC_CWRL\t0x01\t/* Command/Write Length */\n#define ISMT_DESC_BLK\t0X04\t/* Perform Block Transaction */\n#define ISMT_DESC_FAIR\t0x08\t/* Set fairness flag upon successful arbit. */\n#define ISMT_DESC_PEC\t0x10\t/* Packet Error Code */\n#define ISMT_DESC_I2C\t0x20\t/* I2C Enable */\n#define ISMT_DESC_INT\t0x40\t/* Interrupt */\n#define ISMT_DESC_SOE\t0x80\t/* Stop On Error */\n\n/* Hardware Descriptor Constants - Status Field */\n#define ISMT_DESC_SCS\t0x01\t/* Success */\n#define ISMT_DESC_DLTO\t0x04\t/* Data Low Time Out */\n#define ISMT_DESC_NAK\t0x08\t/* NAK Received */\n#define ISMT_DESC_CRC\t0x10\t/* CRC Error */\n#define ISMT_DESC_CLTO\t0x20\t/* Clock Low Time Out */\n#define ISMT_DESC_COL\t0x40\t/* Collisions */\n#define ISMT_DESC_LPR\t0x80\t/* Large Packet Received */\n\n/* Macros */\n#define ISMT_DESC_ADDR_RW(addr, rw) (((addr) << 1) | (rw))\n\n/* iSMT General Register address offsets (SMBBAR + <addr>) */\n#define ISMT_GR_GCTRL\t\t0x000\t/* General Control */\n#define ISMT_GR_SMTICL\t\t0x008\t/* SMT Interrupt Cause Location */\n#define ISMT_GR_ERRINTMSK\t0x010\t/* Error Interrupt Mask */\n#define ISMT_GR_ERRAERMSK\t0x014\t/* Error AER Mask */\n#define ISMT_GR_ERRSTS\t\t0x018\t/* Error Status */\n#define ISMT_GR_ERRINFO\t\t0x01c\t/* Error Information */\n\n/* iSMT Master Registers */\n#define ISMT_MSTR_MDBA\t\t0x100\t/* Master Descriptor Base Address */\n#define ISMT_MSTR_MCTRL\t\t0x108\t/* Master Control */\n#define ISMT_MSTR_MSTS\t\t0x10c\t/* Master Status */\n#define ISMT_MSTR_MDS\t\t0x110\t/* Master Descriptor Size */\n#define ISMT_MSTR_RPOLICY\t0x114\t/* Retry Policy */\n\n/* iSMT Miscellaneous Registers */\n#define ISMT_SPGT\t0x300\t/* SMBus PHY Global Timing */\n\n/* General Control Register (GCTRL) bit definitions */\n#define ISMT_GCTRL_TRST\t0x04\t/* Target Reset */\n#define ISMT_GCTRL_KILL\t0x08\t/* Kill */\n#define ISMT_GCTRL_SRST\t0x40\t/* Soft Reset */\n\n/* Master Control Register (MCTRL) bit definitions */\n#define ISMT_MCTRL_SS\t0x01\t\t/* Start/Stop */\n#define ISMT_MCTRL_MEIE\t0x10\t\t/* Master Error Interrupt Enable */\n#define ISMT_MCTRL_FMHP\t0x00ff0000\t/* Firmware Master Head Ptr (FMHP) */\n\n/* Master Status Register (MSTS) bit definitions */\n#define ISMT_MSTS_HMTP\t0xff0000\t/* HW Master Tail Pointer (HMTP) */\n#define ISMT_MSTS_MIS\t0x20\t\t/* Master Interrupt Status (MIS) */\n#define ISMT_MSTS_MEIS\t0x10\t\t/* Master Error Int Status (MEIS) */\n#define ISMT_MSTS_IP\t0x01\t\t/* In Progress */\n\n/* Master Descriptor Size (MDS) bit definitions */\n#define ISMT_MDS_MASK\t0xff\t/* Master Descriptor Size mask (MDS) */\n\n/* SMBus PHY Global Timing Register (SPGT) bit definitions */\n#define ISMT_SPGT_SPD_MASK\t0xc0000000\t/* SMBus Speed mask */\n#define ISMT_SPGT_SPD_80K\t0x00\t\t/* 80 kHz */\n#define ISMT_SPGT_SPD_100K\t(0x1 << 30)\t/* 100 kHz */\n#define ISMT_SPGT_SPD_400K\t(0x2U << 30)\t/* 400 kHz */\n#define ISMT_SPGT_SPD_1M\t(0x3U << 30)\t/* 1 MHz */\n\n\n/* MSI Control Register (MSICTL) bit definitions */\n#define ISMT_MSICTL_MSIE\t0x01\t/* MSI Enable */\n\n/* iSMT Hardware Descriptor */\nstruct ismt_desc {\n\tu8 tgtaddr_rw;\t/* target address & r/w bit */\n\tu8 wr_len_cmd;\t/* write length in bytes or a command */\n\tu8 rd_len;\t/* read length */\n\tu8 control;\t/* control bits */\n\tu8 status;\t/* status bits */\n\tu8 retry;\t/* collision retry and retry count */\n\tu8 rxbytes;\t/* received bytes */\n\tu8 txbytes;\t/* transmitted bytes */\n\tu32 dptr_low;\t/* lower 32 bit of the data pointer */\n\tu32 dptr_high;\t/* upper 32 bit of the data pointer */\n} __packed;\n\nstruct ismt_priv {\n\tstruct i2c_adapter adapter;\n\tvoid __iomem *smba;\t\t\t/* PCI BAR */\n\tstruct pci_dev *pci_dev;\n\tstruct ismt_desc *hw;\t\t\t/* descriptor virt base addr */\n\tdma_addr_t io_rng_dma;\t\t\t/* descriptor HW base addr */\n\tu8 head;\t\t\t\t/* ring buffer head pointer */\n\tstruct completion cmp;\t\t\t/* interrupt completion */\n\tu8 buffer[I2C_SMBUS_BLOCK_MAX + 16];\t/* temp R/W data buffer */\n\tdma_addr_t log_dma;\n\tu32 *log;\n};\n\nstatic const struct pci_device_id ismt_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_S1200_SMT0) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_S1200_SMT1) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_CDF_SMT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_DNV_SMT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_EBG_SMT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_AVOTON_SMT) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, ismt_ids);\n\n/* Bus speed control bits for slow debuggers - refer to the docs for usage */\nstatic unsigned int bus_speed;\nmodule_param(bus_speed, uint, S_IRUGO);\nMODULE_PARM_DESC(bus_speed, \"Bus Speed in kHz (0 = BIOS default)\");\n\n/**\n * __ismt_desc_dump() - dump the contents of a specific descriptor\n * @dev: the iSMT device\n * @desc: the iSMT hardware descriptor\n */\nstatic void __ismt_desc_dump(struct device *dev, const struct ismt_desc *desc)\n{\n\n\tdev_dbg(dev, \"Descriptor struct:  %p\\n\", desc);\n\tdev_dbg(dev, \"\\ttgtaddr_rw=0x%02X\\n\", desc->tgtaddr_rw);\n\tdev_dbg(dev, \"\\twr_len_cmd=0x%02X\\n\", desc->wr_len_cmd);\n\tdev_dbg(dev, \"\\trd_len=    0x%02X\\n\", desc->rd_len);\n\tdev_dbg(dev, \"\\tcontrol=   0x%02X\\n\", desc->control);\n\tdev_dbg(dev, \"\\tstatus=    0x%02X\\n\", desc->status);\n\tdev_dbg(dev, \"\\tretry=     0x%02X\\n\", desc->retry);\n\tdev_dbg(dev, \"\\trxbytes=   0x%02X\\n\", desc->rxbytes);\n\tdev_dbg(dev, \"\\ttxbytes=   0x%02X\\n\", desc->txbytes);\n\tdev_dbg(dev, \"\\tdptr_low=  0x%08X\\n\", desc->dptr_low);\n\tdev_dbg(dev, \"\\tdptr_high= 0x%08X\\n\", desc->dptr_high);\n}\n/**\n * ismt_desc_dump() - dump the contents of a descriptor for debug purposes\n * @priv: iSMT private data\n */\nstatic void ismt_desc_dump(struct ismt_priv *priv)\n{\n\tstruct device *dev = &priv->pci_dev->dev;\n\tstruct ismt_desc *desc = &priv->hw[priv->head];\n\n\tdev_dbg(dev, \"Dump of the descriptor struct:  0x%X\\n\", priv->head);\n\t__ismt_desc_dump(dev, desc);\n}\n\n/**\n * ismt_gen_reg_dump() - dump the iSMT General Registers\n * @priv: iSMT private data\n */\nstatic void ismt_gen_reg_dump(struct ismt_priv *priv)\n{\n\tstruct device *dev = &priv->pci_dev->dev;\n\n\tdev_dbg(dev, \"Dump of the iSMT General Registers\\n\");\n\tdev_dbg(dev, \"  GCTRL.... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_GCTRL,\n\t\treadl(priv->smba + ISMT_GR_GCTRL));\n\tdev_dbg(dev, \"  SMTICL... : (0x%p)=0x%016llX\\n\",\n\t\tpriv->smba + ISMT_GR_SMTICL,\n\t\t(long long unsigned int)readq(priv->smba + ISMT_GR_SMTICL));\n\tdev_dbg(dev, \"  ERRINTMSK : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRINTMSK,\n\t\treadl(priv->smba + ISMT_GR_ERRINTMSK));\n\tdev_dbg(dev, \"  ERRAERMSK : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRAERMSK,\n\t\treadl(priv->smba + ISMT_GR_ERRAERMSK));\n\tdev_dbg(dev, \"  ERRSTS... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRSTS,\n\t\treadl(priv->smba + ISMT_GR_ERRSTS));\n\tdev_dbg(dev, \"  ERRINFO.. : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRINFO,\n\t\treadl(priv->smba + ISMT_GR_ERRINFO));\n}\n\n/**\n * ismt_mstr_reg_dump() - dump the iSMT Master Registers\n * @priv: iSMT private data\n */\nstatic void ismt_mstr_reg_dump(struct ismt_priv *priv)\n{\n\tstruct device *dev = &priv->pci_dev->dev;\n\n\tdev_dbg(dev, \"Dump of the iSMT Master Registers\\n\");\n\tdev_dbg(dev, \"  MDBA..... : (0x%p)=0x%016llX\\n\",\n\t\tpriv->smba + ISMT_MSTR_MDBA,\n\t\t(long long unsigned int)readq(priv->smba + ISMT_MSTR_MDBA));\n\tdev_dbg(dev, \"  MCTRL.... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_MCTRL,\n\t\treadl(priv->smba + ISMT_MSTR_MCTRL));\n\tdev_dbg(dev, \"  MSTS..... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_MSTS,\n\t\treadl(priv->smba + ISMT_MSTR_MSTS));\n\tdev_dbg(dev, \"  MDS...... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_MDS,\n\t\treadl(priv->smba + ISMT_MSTR_MDS));\n\tdev_dbg(dev, \"  RPOLICY.. : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_RPOLICY,\n\t\treadl(priv->smba + ISMT_MSTR_RPOLICY));\n\tdev_dbg(dev, \"  SPGT..... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_SPGT,\n\t\treadl(priv->smba + ISMT_SPGT));\n}\n\n/**\n * ismt_submit_desc() - add a descriptor to the ring\n * @priv: iSMT private data\n */\nstatic void ismt_submit_desc(struct ismt_priv *priv)\n{\n\tuint fmhp;\n\tuint val;\n\n\tismt_desc_dump(priv);\n\tismt_gen_reg_dump(priv);\n\tismt_mstr_reg_dump(priv);\n\n\t/* Set the FMHP (Firmware Master Head Pointer)*/\n\tfmhp = ((priv->head + 1) % ISMT_DESC_ENTRIES) << 16;\n\tval = readl(priv->smba + ISMT_MSTR_MCTRL);\n\twritel((val & ~ISMT_MCTRL_FMHP) | fmhp,\n\t       priv->smba + ISMT_MSTR_MCTRL);\n\n\t/* Set the start bit */\n\tval = readl(priv->smba + ISMT_MSTR_MCTRL);\n\twritel(val | ISMT_MCTRL_SS,\n\t       priv->smba + ISMT_MSTR_MCTRL);\n}\n\n/**\n * ismt_process_desc() - handle the completion of the descriptor\n * @desc: the iSMT hardware descriptor\n * @data: data buffer from the upper layer\n * @priv: ismt_priv struct holding our dma buffer\n * @size: SMBus transaction type\n * @read_write: flag to indicate if this is a read or write\n */\nstatic int ismt_process_desc(const struct ismt_desc *desc,\n\t\t\t     union i2c_smbus_data *data,\n\t\t\t     struct ismt_priv *priv, int size,\n\t\t\t     char read_write)\n{\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdev_dbg(&priv->pci_dev->dev, \"Processing completed descriptor\\n\");\n\t__ismt_desc_dump(&priv->pci_dev->dev, desc);\n\tismt_gen_reg_dump(priv);\n\tismt_mstr_reg_dump(priv);\n\n\tif (desc->status & ISMT_DESC_SCS) {\n\t\tif (read_write == I2C_SMBUS_WRITE &&\n\t\t    size != I2C_SMBUS_PROC_CALL &&\n\t\t    size != I2C_SMBUS_BLOCK_PROC_CALL)\n\t\t\treturn 0;\n\n\t\tswitch (size) {\n\t\tcase I2C_SMBUS_BYTE:\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\tdata->byte = dma_buffer[0];\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\tdata->word = dma_buffer[0] | (dma_buffer[1] << 8);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\t\tif (desc->rxbytes != dma_buffer[0] + 1)\n\t\t\t\treturn -EMSGSIZE;\n\n\t\t\tmemcpy(data->block, dma_buffer, desc->rxbytes);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t\tmemcpy(&data->block[1], dma_buffer, desc->rxbytes);\n\t\t\tdata->block[0] = desc->rxbytes;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (likely(desc->status & ISMT_DESC_NAK))\n\t\treturn -ENXIO;\n\n\tif (desc->status & ISMT_DESC_CRC)\n\t\treturn -EBADMSG;\n\n\tif (desc->status & ISMT_DESC_COL)\n\t\treturn -EAGAIN;\n\n\tif (desc->status & ISMT_DESC_LPR)\n\t\treturn -EPROTO;\n\n\tif (desc->status & (ISMT_DESC_DLTO | ISMT_DESC_CLTO))\n\t\treturn -ETIMEDOUT;\n\n\treturn -EIO;\n}\n\n/**\n * ismt_access() - process an SMBus command\n * @adap: the i2c host adapter\n * @addr: address of the i2c/SMBus target\n * @flags: command options\n * @read_write: read from or write to device\n * @command: the i2c/SMBus command to issue\n * @size: SMBus transaction type\n * @data: read/write data buffer\n */\nstatic int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; /* address of the data buffer */\n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdesc = &priv->hw[priv->head];\n\n\t/* Initialize the DMA buffer */\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\n\t/* Initialize the descriptor */\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\n\t/* Always clear the log entries */\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\n\t/* Initialize common control bits */\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Send Byte\n\t\t\t * The command field contains the write data\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\t/* Receive Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Write Byte\n\t\t\t * Command plus 1 data byte\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\t/* Read Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Write Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\t/* Read Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t/* Make sure the length is valid */\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* i2c Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* i2c Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\t/*\n\t\t\t * Per the \"Table 15-15. I2C Commands\",\n\t\t\t * in the External Design Specification (EDS),\n\t\t\t * (Document Number: 508084, Revision: 2.0),\n\t\t\t * the _rw bit must be 0\n\t\t\t */\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* map the data buffer */\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\n\treinit_completion(&priv->cmp);\n\n\t/* Add the descriptor */\n\tismt_submit_desc(priv);\n\n\t/* Now we wait for interrupt completion, 1s */\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\n\t/* unmap the data buffer */\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/* do any post processing of the descriptor here */\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\n\nout:\n\t/* Update the ring pointer */\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\n\treturn ret;\n}\n\n/**\n * ismt_func() - report which i2c commands are supported by this adapter\n * @adap: the i2c host adapter\n */\nstatic u32 ismt_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_QUICK\t\t|\n\t       I2C_FUNC_SMBUS_BYTE\t\t|\n\t       I2C_FUNC_SMBUS_BYTE_DATA\t\t|\n\t       I2C_FUNC_SMBUS_WORD_DATA\t\t|\n\t       I2C_FUNC_SMBUS_PROC_CALL\t\t|\n\t       I2C_FUNC_SMBUS_BLOCK_PROC_CALL\t|\n\t       I2C_FUNC_SMBUS_BLOCK_DATA\t|\n\t       I2C_FUNC_SMBUS_I2C_BLOCK\t\t|\n\t       I2C_FUNC_SMBUS_PEC;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= ismt_access,\n\t.functionality\t= ismt_func,\n};\n\n/**\n * ismt_handle_isr() - interrupt handler bottom half\n * @priv: iSMT private data\n */\nstatic irqreturn_t ismt_handle_isr(struct ismt_priv *priv)\n{\n\tcomplete(&priv->cmp);\n\n\treturn IRQ_HANDLED;\n}\n\n\n/**\n * ismt_do_interrupt() - IRQ interrupt handler\n * @vec: interrupt vector\n * @data: iSMT private data\n */\nstatic irqreturn_t ismt_do_interrupt(int vec, void *data)\n{\n\tu32 val;\n\tstruct ismt_priv *priv = data;\n\n\t/*\n\t * check to see it's our interrupt, return IRQ_NONE if not ours\n\t * since we are sharing interrupt\n\t */\n\tval = readl(priv->smba + ISMT_MSTR_MSTS);\n\n\tif (!(val & (ISMT_MSTS_MIS | ISMT_MSTS_MEIS)))\n\t\treturn IRQ_NONE;\n\telse\n\t\twritel(val | ISMT_MSTS_MIS | ISMT_MSTS_MEIS,\n\t\t       priv->smba + ISMT_MSTR_MSTS);\n\n\treturn ismt_handle_isr(priv);\n}\n\n/**\n * ismt_do_msi_interrupt() - MSI interrupt handler\n * @vec: interrupt vector\n * @data: iSMT private data\n */\nstatic irqreturn_t ismt_do_msi_interrupt(int vec, void *data)\n{\n\treturn ismt_handle_isr(data);\n}\n\n/**\n * ismt_hw_init() - initialize the iSMT hardware\n * @priv: iSMT private data\n */\nstatic void ismt_hw_init(struct ismt_priv *priv)\n{\n\tu32 val;\n\tstruct device *dev = &priv->pci_dev->dev;\n\n\t/* initialize the Master Descriptor Base Address (MDBA) */\n\twriteq(priv->io_rng_dma, priv->smba + ISMT_MSTR_MDBA);\n\n\twriteq(priv->log_dma, priv->smba + ISMT_GR_SMTICL);\n\n\t/* initialize the Master Control Register (MCTRL) */\n\twritel(ISMT_MCTRL_MEIE, priv->smba + ISMT_MSTR_MCTRL);\n\n\t/* initialize the Master Status Register (MSTS) */\n\twritel(0, priv->smba + ISMT_MSTR_MSTS);\n\n\t/* initialize the Master Descriptor Size (MDS) */\n\tval = readl(priv->smba + ISMT_MSTR_MDS);\n\twritel((val & ~ISMT_MDS_MASK) | (ISMT_DESC_ENTRIES - 1),\n\t\tpriv->smba + ISMT_MSTR_MDS);\n\n\t/*\n\t * Set the SMBus speed (could use this for slow HW debuggers)\n\t */\n\n\tval = readl(priv->smba + ISMT_SPGT);\n\n\tswitch (bus_speed) {\n\tcase 0:\n\t\tbreak;\n\n\tcase 80:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 80 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_80K),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tcase 100:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 100 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_100K),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tcase 400:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 400 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_400K),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tcase 1000:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 1000 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_1M),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(dev, \"Invalid SMBus clock speed, only 0, 80, 100, 400, and 1000 are valid\\n\");\n\t\tbreak;\n\t}\n\n\tval = readl(priv->smba + ISMT_SPGT);\n\n\tswitch (val & ISMT_SPGT_SPD_MASK) {\n\tcase ISMT_SPGT_SPD_80K:\n\t\tbus_speed = 80;\n\t\tbreak;\n\tcase ISMT_SPGT_SPD_100K:\n\t\tbus_speed = 100;\n\t\tbreak;\n\tcase ISMT_SPGT_SPD_400K:\n\t\tbus_speed = 400;\n\t\tbreak;\n\tcase ISMT_SPGT_SPD_1M:\n\t\tbus_speed = 1000;\n\t\tbreak;\n\t}\n\tdev_dbg(dev, \"SMBus clock is running at %d kHz\\n\", bus_speed);\n}\n\n/**\n * ismt_dev_init() - initialize the iSMT data structures\n * @priv: iSMT private data\n */\nstatic int ismt_dev_init(struct ismt_priv *priv)\n{\n\t/* allocate memory for the descriptor */\n\tpriv->hw = dmam_alloc_coherent(&priv->pci_dev->dev,\n\t\t\t\t       (ISMT_DESC_ENTRIES\n\t\t\t\t\t       * sizeof(struct ismt_desc)),\n\t\t\t\t       &priv->io_rng_dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (!priv->hw)\n\t\treturn -ENOMEM;\n\n\tpriv->head = 0;\n\tinit_completion(&priv->cmp);\n\n\tpriv->log = dmam_alloc_coherent(&priv->pci_dev->dev,\n\t\t\t\t\tISMT_LOG_ENTRIES * sizeof(u32),\n\t\t\t\t\t&priv->log_dma, GFP_KERNEL);\n\tif (!priv->log)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/**\n * ismt_int_init() - initialize interrupts\n * @priv: iSMT private data\n */\nstatic int ismt_int_init(struct ismt_priv *priv)\n{\n\tint err;\n\n\t/* Try using MSI interrupts */\n\terr = pci_enable_msi(priv->pci_dev);\n\tif (err)\n\t\tgoto intx;\n\n\terr = devm_request_irq(&priv->pci_dev->dev,\n\t\t\t       priv->pci_dev->irq,\n\t\t\t       ismt_do_msi_interrupt,\n\t\t\t       0,\n\t\t\t       \"ismt-msi\",\n\t\t\t       priv);\n\tif (err) {\n\t\tpci_disable_msi(priv->pci_dev);\n\t\tgoto intx;\n\t}\n\n\treturn 0;\n\n\t/* Try using legacy interrupts */\nintx:\n\tdev_warn(&priv->pci_dev->dev,\n\t\t \"Unable to use MSI interrupts, falling back to legacy\\n\");\n\n\terr = devm_request_irq(&priv->pci_dev->dev,\n\t\t\t       priv->pci_dev->irq,\n\t\t\t       ismt_do_interrupt,\n\t\t\t       IRQF_SHARED,\n\t\t\t       \"ismt-intx\",\n\t\t\t       priv);\n\tif (err) {\n\t\tdev_err(&priv->pci_dev->dev, \"no usable interrupts\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct pci_driver ismt_driver;\n\n/**\n * ismt_probe() - probe for iSMT devices\n * @pdev: PCI-Express device\n * @id: PCI-Express device ID\n */\nstatic int\nismt_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint err;\n\tstruct ismt_priv *priv;\n\tunsigned long start, len;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, priv);\n\n\ti2c_set_adapdata(&priv->adapter, priv);\n\tpriv->adapter.owner = THIS_MODULE;\n\tpriv->adapter.class = I2C_CLASS_HWMON;\n\tpriv->adapter.algo = &smbus_algorithm;\n\tpriv->adapter.dev.parent = &pdev->dev;\n\tACPI_COMPANION_SET(&priv->adapter.dev, ACPI_COMPANION(&pdev->dev));\n\tpriv->adapter.retries = ISMT_MAX_RETRIES;\n\n\tpriv->pci_dev = pdev;\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to enable SMBus PCI device (%d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t/* enable bus mastering */\n\tpci_set_master(pdev);\n\n\t/* Determine the address of the SMBus area */\n\tstart = pci_resource_start(pdev, SMBBAR);\n\tlen = pci_resource_len(pdev, SMBBAR);\n\tif (!start || !len) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"SMBus base address uninitialized, upgrade BIOS\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsnprintf(priv->adapter.name, sizeof(priv->adapter.name),\n\t\t \"SMBus iSMT adapter at %lx\", start);\n\n\tdev_dbg(&priv->pci_dev->dev, \" start=0x%lX\\n\", start);\n\tdev_dbg(&priv->pci_dev->dev, \" len=0x%lX\\n\", len);\n\n\terr = acpi_check_resource_conflict(&pdev->resource[SMBBAR]);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"ACPI resource conflict!\\n\");\n\t\treturn err;\n\t}\n\n\terr = pci_request_region(pdev, SMBBAR, ismt_driver.name);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to request SMBus region 0x%lx-0x%lx\\n\",\n\t\t\tstart, start + len);\n\t\treturn err;\n\t}\n\n\tpriv->smba = pcim_iomap(pdev, SMBBAR, len);\n\tif (!priv->smba) {\n\t\tdev_err(&pdev->dev, \"Unable to ioremap SMBus BAR\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"dma_set_mask fail\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\terr = ismt_dev_init(priv);\n\tif (err)\n\t\treturn err;\n\n\tismt_hw_init(priv);\n\n\terr = ismt_int_init(priv);\n\tif (err)\n\t\treturn err;\n\n\terr = i2c_add_adapter(&priv->adapter);\n\tif (err)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\n/**\n * ismt_remove() - release driver resources\n * @pdev: PCI-Express device\n */\nstatic void ismt_remove(struct pci_dev *pdev)\n{\n\tstruct ismt_priv *priv = pci_get_drvdata(pdev);\n\n\ti2c_del_adapter(&priv->adapter);\n}\n\nstatic struct pci_driver ismt_driver = {\n\t.name = \"ismt_smbus\",\n\t.id_table = ismt_ids,\n\t.probe = ismt_probe,\n\t.remove = ismt_remove,\n};\n\nmodule_pci_driver(ismt_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Bill E. Brown <bill.e.brown@intel.com>\");\nMODULE_DESCRIPTION(\"Intel SMBus Message Transport (iSMT) driver\");\n"], "filenames": ["drivers/i2c/busses/i2c-ismt.c"], "buggy_code_start_loc": [530], "buggy_code_end_loc": [530], "fixing_code_start_loc": [531], "fixing_code_end_loc": [534], "type": "CWE-120", "message": "A buffer overflow vulnerability was found in the Linux kernel Intel\u2019s iSMT SMBus host controller driver in the way it handled the I2C_SMBUS_BLOCK_PROC_CALL case (via the ioctl I2C_SMBUS) with malicious input data. This flaw could allow a local user to crash the system.", "other": {"cve": {"id": "CVE-2022-3077", "sourceIdentifier": "secalert@redhat.com", "published": "2022-09-09T15:15:14.950", "lastModified": "2022-09-15T15:35:56.500", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A buffer overflow vulnerability was found in the Linux kernel Intel\u2019s iSMT SMBus host controller driver in the way it handled the I2C_SMBUS_BLOCK_PROC_CALL case (via the ioctl I2C_SMBUS) with malicious input data. This flaw could allow a local user to crash the system."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad de desbordamiento de b\u00fafer en el controlador de host iSMT SMBus del kernel de Linux en la forma en que manejaba el caso I2C_SMBUS_BLOCK_PROC_CALL (por el ioctl I2C_SMBUS) con datos de entrada maliciosos. Este fallo podr\u00eda permitir a un usuario local bloquear el sistema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.19", "matchCriteriaId": "E74E9AF8-BDF5-4917-A9CA-0AAD8E13149B"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/690b2549b19563ec5ad53e5c82f6a944d910086e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/690b2549b19563ec5ad53e5c82f6a944d910086e"}}