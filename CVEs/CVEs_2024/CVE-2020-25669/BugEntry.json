{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  Copyright (c) 1999-2001 Vojtech Pavlik\n */\n\n/*\n * Sun keyboard driver for Linux\n */\n\n/*\n */\n\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/workqueue.h>\n\n#define DRIVER_DESC\t\"Sun keyboard driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned char sunkbd_keycode[128] = {\n\t  0,128,114,129,115, 59, 60, 68, 61, 87, 62, 88, 63,100, 64,112,\n\t 65, 66, 67, 56,103,119, 99, 70,105,130,131,108,106,  1,  2,  3,\n\t  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 41, 14,110,113, 98, 55,\n\t116,132, 83,133,102, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n\t 26, 27,111,127, 71, 72, 73, 74,134,135,107,  0, 29, 30, 31, 32,\n\t 33, 34, 35, 36, 37, 38, 39, 40, 43, 28, 96, 75, 76, 77, 82,136,\n\t104,137, 69, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,101,\n\t 79, 80, 81,  0,  0,  0,138, 58,125, 57,126,109, 86, 78\n};\n\n#define SUNKBD_CMD_RESET\t0x1\n#define SUNKBD_CMD_BELLON\t0x2\n#define SUNKBD_CMD_BELLOFF\t0x3\n#define SUNKBD_CMD_CLICK\t0xa\n#define SUNKBD_CMD_NOCLICK\t0xb\n#define SUNKBD_CMD_SETLED\t0xe\n#define SUNKBD_CMD_LAYOUT\t0xf\n\n#define SUNKBD_RET_RESET\t0xff\n#define SUNKBD_RET_ALLUP\t0x7f\n#define SUNKBD_RET_LAYOUT\t0xfe\n\n#define SUNKBD_LAYOUT_5_MASK\t0x20\n#define SUNKBD_RELEASE\t\t0x80\n#define SUNKBD_KEY\t\t0x7f\n\n/*\n * Per-keyboard data.\n */\n\nstruct sunkbd {\n\tunsigned char keycode[ARRAY_SIZE(sunkbd_keycode)];\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\tstruct work_struct tq;\n\twait_queue_head_t wait;\n\tchar name[64];\n\tchar phys[32];\n\tchar type;\n\tbool enabled;\n\tvolatile s8 reset;\n\tvolatile s8 layout;\n};\n\n/*\n * sunkbd_interrupt() is called by the low level driver when a character\n * is received.\n */\n\nstatic irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\n\tif (sunkbd->reset <= -1) {\n\t\t/*\n\t\t * If cp[i] is 0xff, sunkbd->reset will stay -1.\n\t\t * The keyboard sends 0xff 0xff 0xID on powerup.\n\t\t */\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tswitch (data) {\n\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_ALLUP: /* All keys released */\n\t\tbreak;\n\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}\n\n/*\n * sunkbd_event() handles events from the input module.\n */\n\nstatic int sunkbd_event(struct input_dev *dev,\n\t\t\tunsigned int type, unsigned int code, int value)\n{\n\tstruct sunkbd *sunkbd = input_get_drvdata(dev);\n\n\tswitch (type) {\n\n\tcase EV_LED:\n\n\t\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\t\tserio_write(sunkbd->serio,\n\t\t\t(!!test_bit(LED_CAPSL,   dev->led) << 3) |\n\t\t\t(!!test_bit(LED_SCROLLL, dev->led) << 2) |\n\t\t\t(!!test_bit(LED_COMPOSE, dev->led) << 1) |\n\t\t\t !!test_bit(LED_NUML,    dev->led));\n\t\treturn 0;\n\n\tcase EV_SND:\n\n\t\tswitch (code) {\n\n\t\tcase SND_CLICK:\n\t\t\tserio_write(sunkbd->serio, SUNKBD_CMD_NOCLICK - value);\n\t\t\treturn 0;\n\n\t\tcase SND_BELL:\n\t\t\tserio_write(sunkbd->serio, SUNKBD_CMD_BELLOFF - value);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\n/*\n * sunkbd_initialize() checks for a Sun keyboard attached, and determines\n * its type.\n */\n\nstatic int sunkbd_initialize(struct sunkbd *sunkbd)\n{\n\tsunkbd->reset = -2;\n\tserio_write(sunkbd->serio, SUNKBD_CMD_RESET);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tif (sunkbd->reset < 0)\n\t\treturn -1;\n\n\tsunkbd->type = sunkbd->reset;\n\n\tif (sunkbd->type == 4) {\t/* Type 4 keyboard */\n\t\tsunkbd->layout = -2;\n\t\tserio_write(sunkbd->serio, SUNKBD_CMD_LAYOUT);\n\t\twait_event_interruptible_timeout(sunkbd->wait,\n\t\t\t\t\t\t sunkbd->layout >= 0, HZ / 4);\n\t\tif (sunkbd->layout < 0)\n\t\t\treturn -1;\n\t\tif (sunkbd->layout & SUNKBD_LAYOUT_5_MASK)\n\t\t\tsunkbd->type = 5;\n\t}\n\n\treturn 0;\n}\n\n/*\n * sunkbd_reinit() sets leds and beeps to a state the computer remembers they\n * were in.\n */\n\nstatic void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}\n\nstatic void sunkbd_enable(struct sunkbd *sunkbd, bool enable)\n{\n\tserio_pause_rx(sunkbd->serio);\n\tsunkbd->enabled = enable;\n\tserio_continue_rx(sunkbd->serio);\n}\n\n/*\n * sunkbd_connect() probes for a Sun keyboard and fills the necessary\n * structures.\n */\n\nstatic int sunkbd_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct sunkbd *sunkbd;\n\tstruct input_dev *input_dev;\n\tint err = -ENOMEM;\n\tint i;\n\n\tsunkbd = kzalloc(sizeof(struct sunkbd), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!sunkbd || !input_dev)\n\t\tgoto fail1;\n\n\tsunkbd->serio = serio;\n\tsunkbd->dev = input_dev;\n\tinit_waitqueue_head(&sunkbd->wait);\n\tINIT_WORK(&sunkbd->tq, sunkbd_reinit);\n\tsnprintf(sunkbd->phys, sizeof(sunkbd->phys), \"%s/input0\", serio->phys);\n\n\tserio_set_drvdata(serio, sunkbd);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\tif (sunkbd_initialize(sunkbd) < 0) {\n\t\terr = -ENODEV;\n\t\tgoto fail3;\n\t}\n\n\tsnprintf(sunkbd->name, sizeof(sunkbd->name),\n\t\t \"Sun Type %d keyboard\", sunkbd->type);\n\tmemcpy(sunkbd->keycode, sunkbd_keycode, sizeof(sunkbd->keycode));\n\n\tinput_dev->name = sunkbd->name;\n\tinput_dev->phys = sunkbd->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor  = SERIO_SUNKBD;\n\tinput_dev->id.product = sunkbd->type;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_set_drvdata(input_dev, sunkbd);\n\n\tinput_dev->event = sunkbd_event;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_LED) |\n\t\tBIT_MASK(EV_SND) | BIT_MASK(EV_REP);\n\tinput_dev->ledbit[0] = BIT_MASK(LED_CAPSL) | BIT_MASK(LED_COMPOSE) |\n\t\tBIT_MASK(LED_SCROLLL) | BIT_MASK(LED_NUML);\n\tinput_dev->sndbit[0] = BIT_MASK(SND_CLICK) | BIT_MASK(SND_BELL);\n\n\tinput_dev->keycode = sunkbd->keycode;\n\tinput_dev->keycodesize = sizeof(unsigned char);\n\tinput_dev->keycodemax = ARRAY_SIZE(sunkbd_keycode);\n\tfor (i = 0; i < ARRAY_SIZE(sunkbd_keycode); i++)\n\t\t__set_bit(sunkbd->keycode[i], input_dev->keybit);\n\t__clear_bit(KEY_RESERVED, input_dev->keybit);\n\n\tsunkbd_enable(sunkbd, true);\n\n\terr = input_register_device(sunkbd->dev);\n\tif (err)\n\t\tgoto fail4;\n\n\treturn 0;\n\n fail4:\tsunkbd_enable(sunkbd, false);\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(sunkbd);\n\treturn err;\n}\n\n/*\n * sunkbd_disconnect() unregisters and closes behind us.\n */\n\nstatic void sunkbd_disconnect(struct serio *serio)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\n\tsunkbd_enable(sunkbd, false);\n\tinput_unregister_device(sunkbd->dev);\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tkfree(sunkbd);\n}\n\nstatic const struct serio_device_id sunkbd_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_SUNKBD,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_UNKNOWN, /* sunkbd does probe */\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, sunkbd_serio_ids);\n\nstatic struct serio_driver sunkbd_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"sunkbd\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= sunkbd_serio_ids,\n\t.interrupt\t= sunkbd_interrupt,\n\t.connect\t= sunkbd_connect,\n\t.disconnect\t= sunkbd_disconnect,\n};\n\nmodule_serio_driver(sunkbd_drv);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  Copyright (c) 1999-2001 Vojtech Pavlik\n */\n\n/*\n * Sun keyboard driver for Linux\n */\n\n/*\n */\n\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/workqueue.h>\n\n#define DRIVER_DESC\t\"Sun keyboard driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned char sunkbd_keycode[128] = {\n\t  0,128,114,129,115, 59, 60, 68, 61, 87, 62, 88, 63,100, 64,112,\n\t 65, 66, 67, 56,103,119, 99, 70,105,130,131,108,106,  1,  2,  3,\n\t  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 41, 14,110,113, 98, 55,\n\t116,132, 83,133,102, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n\t 26, 27,111,127, 71, 72, 73, 74,134,135,107,  0, 29, 30, 31, 32,\n\t 33, 34, 35, 36, 37, 38, 39, 40, 43, 28, 96, 75, 76, 77, 82,136,\n\t104,137, 69, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,101,\n\t 79, 80, 81,  0,  0,  0,138, 58,125, 57,126,109, 86, 78\n};\n\n#define SUNKBD_CMD_RESET\t0x1\n#define SUNKBD_CMD_BELLON\t0x2\n#define SUNKBD_CMD_BELLOFF\t0x3\n#define SUNKBD_CMD_CLICK\t0xa\n#define SUNKBD_CMD_NOCLICK\t0xb\n#define SUNKBD_CMD_SETLED\t0xe\n#define SUNKBD_CMD_LAYOUT\t0xf\n\n#define SUNKBD_RET_RESET\t0xff\n#define SUNKBD_RET_ALLUP\t0x7f\n#define SUNKBD_RET_LAYOUT\t0xfe\n\n#define SUNKBD_LAYOUT_5_MASK\t0x20\n#define SUNKBD_RELEASE\t\t0x80\n#define SUNKBD_KEY\t\t0x7f\n\n/*\n * Per-keyboard data.\n */\n\nstruct sunkbd {\n\tunsigned char keycode[ARRAY_SIZE(sunkbd_keycode)];\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\tstruct work_struct tq;\n\twait_queue_head_t wait;\n\tchar name[64];\n\tchar phys[32];\n\tchar type;\n\tbool enabled;\n\tvolatile s8 reset;\n\tvolatile s8 layout;\n};\n\n/*\n * sunkbd_interrupt() is called by the low level driver when a character\n * is received.\n */\n\nstatic irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\n\tif (sunkbd->reset <= -1) {\n\t\t/*\n\t\t * If cp[i] is 0xff, sunkbd->reset will stay -1.\n\t\t * The keyboard sends 0xff 0xff 0xID on powerup.\n\t\t */\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tswitch (data) {\n\n\tcase SUNKBD_RET_RESET:\n\t\tif (sunkbd->enabled)\n\t\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_ALLUP: /* All keys released */\n\t\tbreak;\n\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}\n\n/*\n * sunkbd_event() handles events from the input module.\n */\n\nstatic int sunkbd_event(struct input_dev *dev,\n\t\t\tunsigned int type, unsigned int code, int value)\n{\n\tstruct sunkbd *sunkbd = input_get_drvdata(dev);\n\n\tswitch (type) {\n\n\tcase EV_LED:\n\n\t\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\t\tserio_write(sunkbd->serio,\n\t\t\t(!!test_bit(LED_CAPSL,   dev->led) << 3) |\n\t\t\t(!!test_bit(LED_SCROLLL, dev->led) << 2) |\n\t\t\t(!!test_bit(LED_COMPOSE, dev->led) << 1) |\n\t\t\t !!test_bit(LED_NUML,    dev->led));\n\t\treturn 0;\n\n\tcase EV_SND:\n\n\t\tswitch (code) {\n\n\t\tcase SND_CLICK:\n\t\t\tserio_write(sunkbd->serio, SUNKBD_CMD_NOCLICK - value);\n\t\t\treturn 0;\n\n\t\tcase SND_BELL:\n\t\t\tserio_write(sunkbd->serio, SUNKBD_CMD_BELLOFF - value);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\n/*\n * sunkbd_initialize() checks for a Sun keyboard attached, and determines\n * its type.\n */\n\nstatic int sunkbd_initialize(struct sunkbd *sunkbd)\n{\n\tsunkbd->reset = -2;\n\tserio_write(sunkbd->serio, SUNKBD_CMD_RESET);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tif (sunkbd->reset < 0)\n\t\treturn -1;\n\n\tsunkbd->type = sunkbd->reset;\n\n\tif (sunkbd->type == 4) {\t/* Type 4 keyboard */\n\t\tsunkbd->layout = -2;\n\t\tserio_write(sunkbd->serio, SUNKBD_CMD_LAYOUT);\n\t\twait_event_interruptible_timeout(sunkbd->wait,\n\t\t\t\t\t\t sunkbd->layout >= 0, HZ / 4);\n\t\tif (sunkbd->layout < 0)\n\t\t\treturn -1;\n\t\tif (sunkbd->layout & SUNKBD_LAYOUT_5_MASK)\n\t\t\tsunkbd->type = 5;\n\t}\n\n\treturn 0;\n}\n\n/*\n * sunkbd_set_leds_beeps() sets leds and beeps to a state the computer remembers\n * they were in.\n */\n\nstatic void sunkbd_set_leds_beeps(struct sunkbd *sunkbd)\n{\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}\n\n\n/*\n * sunkbd_reinit() wait for the keyboard reset to complete and restores state\n * of leds and beeps.\n */\n\nstatic void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\n\t/*\n\t * It is OK that we check sunkbd->enabled without pausing serio,\n\t * as we only want to catch true->false transition that will\n\t * happen once and we will be woken up for it.\n\t */\n\twait_event_interruptible_timeout(sunkbd->wait,\n\t\t\t\t\t sunkbd->reset >= 0 || !sunkbd->enabled,\n\t\t\t\t\t HZ);\n\n\tif (sunkbd->reset >= 0 && sunkbd->enabled)\n\t\tsunkbd_set_leds_beeps(sunkbd);\n}\n\nstatic void sunkbd_enable(struct sunkbd *sunkbd, bool enable)\n{\n\tserio_pause_rx(sunkbd->serio);\n\tsunkbd->enabled = enable;\n\tserio_continue_rx(sunkbd->serio);\n\n\tif (!enable) {\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tcancel_work_sync(&sunkbd->tq);\n\t}\n}\n\n/*\n * sunkbd_connect() probes for a Sun keyboard and fills the necessary\n * structures.\n */\n\nstatic int sunkbd_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct sunkbd *sunkbd;\n\tstruct input_dev *input_dev;\n\tint err = -ENOMEM;\n\tint i;\n\n\tsunkbd = kzalloc(sizeof(struct sunkbd), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!sunkbd || !input_dev)\n\t\tgoto fail1;\n\n\tsunkbd->serio = serio;\n\tsunkbd->dev = input_dev;\n\tinit_waitqueue_head(&sunkbd->wait);\n\tINIT_WORK(&sunkbd->tq, sunkbd_reinit);\n\tsnprintf(sunkbd->phys, sizeof(sunkbd->phys), \"%s/input0\", serio->phys);\n\n\tserio_set_drvdata(serio, sunkbd);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\tif (sunkbd_initialize(sunkbd) < 0) {\n\t\terr = -ENODEV;\n\t\tgoto fail3;\n\t}\n\n\tsnprintf(sunkbd->name, sizeof(sunkbd->name),\n\t\t \"Sun Type %d keyboard\", sunkbd->type);\n\tmemcpy(sunkbd->keycode, sunkbd_keycode, sizeof(sunkbd->keycode));\n\n\tinput_dev->name = sunkbd->name;\n\tinput_dev->phys = sunkbd->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor  = SERIO_SUNKBD;\n\tinput_dev->id.product = sunkbd->type;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_set_drvdata(input_dev, sunkbd);\n\n\tinput_dev->event = sunkbd_event;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_LED) |\n\t\tBIT_MASK(EV_SND) | BIT_MASK(EV_REP);\n\tinput_dev->ledbit[0] = BIT_MASK(LED_CAPSL) | BIT_MASK(LED_COMPOSE) |\n\t\tBIT_MASK(LED_SCROLLL) | BIT_MASK(LED_NUML);\n\tinput_dev->sndbit[0] = BIT_MASK(SND_CLICK) | BIT_MASK(SND_BELL);\n\n\tinput_dev->keycode = sunkbd->keycode;\n\tinput_dev->keycodesize = sizeof(unsigned char);\n\tinput_dev->keycodemax = ARRAY_SIZE(sunkbd_keycode);\n\tfor (i = 0; i < ARRAY_SIZE(sunkbd_keycode); i++)\n\t\t__set_bit(sunkbd->keycode[i], input_dev->keybit);\n\t__clear_bit(KEY_RESERVED, input_dev->keybit);\n\n\tsunkbd_enable(sunkbd, true);\n\n\terr = input_register_device(sunkbd->dev);\n\tif (err)\n\t\tgoto fail4;\n\n\treturn 0;\n\n fail4:\tsunkbd_enable(sunkbd, false);\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(sunkbd);\n\treturn err;\n}\n\n/*\n * sunkbd_disconnect() unregisters and closes behind us.\n */\n\nstatic void sunkbd_disconnect(struct serio *serio)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\n\tsunkbd_enable(sunkbd, false);\n\tinput_unregister_device(sunkbd->dev);\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tkfree(sunkbd);\n}\n\nstatic const struct serio_device_id sunkbd_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_SUNKBD,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_UNKNOWN, /* sunkbd does probe */\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, sunkbd_serio_ids);\n\nstatic struct serio_driver sunkbd_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"sunkbd\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= sunkbd_serio_ids,\n\t.interrupt\t= sunkbd_interrupt,\n\t.connect\t= sunkbd_connect,\n\t.disconnect\t= sunkbd_disconnect,\n};\n\nmodule_serio_driver(sunkbd_drv);\n"], "filenames": ["drivers/input/keyboard/sunkbd.c"], "buggy_code_start_loc": [102], "buggy_code_end_loc": [229], "fixing_code_start_loc": [102], "fixing_code_end_loc": [255], "type": "CWE-416", "message": "A vulnerability was found in the Linux Kernel where the function sunkbd_reinit having been scheduled by sunkbd_interrupt before sunkbd being freed. Though the dangling pointer is set to NULL in sunkbd_disconnect, there is still an alias in sunkbd_reinit causing Use After Free.", "other": {"cve": {"id": "CVE-2020-25669", "sourceIdentifier": "secalert@redhat.com", "published": "2021-05-26T12:15:15.743", "lastModified": "2023-02-24T18:41:56.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in the Linux Kernel where the function sunkbd_reinit having been scheduled by sunkbd_interrupt before sunkbd being freed. Though the dangling pointer is set to NULL in sunkbd_disconnect, there is still an alias in sunkbd_reinit causing Use After Free."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad en el Kernel de Linux donde la funci\u00f3n sunkbd_reinit habiendo sido programada por la funci\u00f3n sunkbd_interrupt antes de que sunkbd fuera liberada.&#xa0;Aunque el puntero colgante est\u00e1 establecido en NULL en la funci\u00f3n sunkbd_disconnect, todav\u00eda se presenta un alias en sunkbd_reinit causando un Uso de la Memoria Previamente Liberada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.4.245", "matchCriteriaId": "633A7002-5307-4004-870F-A5D67E43881C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.245", "matchCriteriaId": "4E984D1A-8713-4FE8-AF3B-003B9F444CC4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.208", "matchCriteriaId": "E11B2B8E-94D2-443B-84B7-E24FC9A21EE8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.19.159", "matchCriteriaId": "CCE57A6F-2998-4412-9145-A06B95F7C2B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.4.79", "matchCriteriaId": "A218F29C-5693-4950-AF2E-E7FBAC4B2901"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5", "versionEndExcluding": "5.9.10", "matchCriteriaId": "7B9D19AC-EE9C-4F21-AAA8-3E45A4AD9495"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "83FAD281-BF77-4A8A-8F29-B557A6903BE0"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2020/11/05/2", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/11/20/5", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/77e70d351db7de07a46ac49b87a6c3c7a60fca7e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00015.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00027.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210702-0006/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2020/11/05/2,", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2020/11/20/5,", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/77e70d351db7de07a46ac49b87a6c3c7a60fca7e"}}