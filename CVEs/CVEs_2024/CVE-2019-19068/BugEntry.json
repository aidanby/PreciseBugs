{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * RTL8XXXU mac80211 USB driver\n *\n * Copyright (c) 2014 - 2017 Jes Sorensen <Jes.Sorensen@gmail.com>\n *\n * Portions, notably calibration code:\n * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.\n *\n * This driver was written as a replacement for the vendor provided\n * rtl8723au driver. As the Realtek 8xxx chips are very similar in\n * their programming interface, I have started adding support for\n * additional 8xxx chips like the 8192cu, 8188cus, etc.\n */\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/wireless.h>\n#include <linux/firmware.h>\n#include <linux/moduleparam.h>\n#include <net/mac80211.h>\n#include \"rtl8xxxu.h\"\n#include \"rtl8xxxu_regs.h\"\n\n#define DRIVER_NAME \"rtl8xxxu\"\n\nint rtl8xxxu_debug = RTL8XXXU_DEBUG_EFUSE;\nstatic bool rtl8xxxu_ht40_2g;\nstatic bool rtl8xxxu_dma_aggregation;\nstatic int rtl8xxxu_dma_agg_timeout = -1;\nstatic int rtl8xxxu_dma_agg_pages = -1;\n\nMODULE_AUTHOR(\"Jes Sorensen <Jes.Sorensen@gmail.com>\");\nMODULE_DESCRIPTION(\"RTL8XXXu USB mac80211 Wireless LAN Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8723aufw_A.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8723aufw_B.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8723aufw_B_NoBT.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8192cufw_A.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8192cufw_B.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8192cufw_TMSC.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8192eu_nic.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8723bu_nic.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8723bu_bt.bin\");\n\nmodule_param_named(debug, rtl8xxxu_debug, int, 0600);\nMODULE_PARM_DESC(debug, \"Set debug mask\");\nmodule_param_named(ht40_2g, rtl8xxxu_ht40_2g, bool, 0600);\nMODULE_PARM_DESC(ht40_2g, \"Enable HT40 support on the 2.4GHz band\");\nmodule_param_named(dma_aggregation, rtl8xxxu_dma_aggregation, bool, 0600);\nMODULE_PARM_DESC(dma_aggregation, \"Enable DMA packet aggregation\");\nmodule_param_named(dma_agg_timeout, rtl8xxxu_dma_agg_timeout, int, 0600);\nMODULE_PARM_DESC(dma_agg_timeout, \"Set DMA aggregation timeout (range 1-127)\");\nmodule_param_named(dma_agg_pages, rtl8xxxu_dma_agg_pages, int, 0600);\nMODULE_PARM_DESC(dma_agg_pages, \"Set DMA aggregation pages (range 1-127, 0 to disable)\");\n\n#define USB_VENDOR_ID_REALTEK\t\t0x0bda\n#define RTL8XXXU_RX_URBS\t\t32\n#define RTL8XXXU_RX_URB_PENDING_WATER\t8\n#define RTL8XXXU_TX_URBS\t\t64\n#define RTL8XXXU_TX_URB_LOW_WATER\t25\n#define RTL8XXXU_TX_URB_HIGH_WATER\t32\n\nstatic int rtl8xxxu_submit_rx_urb(struct rtl8xxxu_priv *priv,\n\t\t\t\t  struct rtl8xxxu_rx_urb *rx_urb);\n\nstatic struct ieee80211_rate rtl8xxxu_rates[] = {\n\t{ .bitrate = 10, .hw_value = DESC_RATE_1M, .flags = 0 },\n\t{ .bitrate = 20, .hw_value = DESC_RATE_2M, .flags = 0 },\n\t{ .bitrate = 55, .hw_value = DESC_RATE_5_5M, .flags = 0 },\n\t{ .bitrate = 110, .hw_value = DESC_RATE_11M, .flags = 0 },\n\t{ .bitrate = 60, .hw_value = DESC_RATE_6M, .flags = 0 },\n\t{ .bitrate = 90, .hw_value = DESC_RATE_9M, .flags = 0 },\n\t{ .bitrate = 120, .hw_value = DESC_RATE_12M, .flags = 0 },\n\t{ .bitrate = 180, .hw_value = DESC_RATE_18M, .flags = 0 },\n\t{ .bitrate = 240, .hw_value = DESC_RATE_24M, .flags = 0 },\n\t{ .bitrate = 360, .hw_value = DESC_RATE_36M, .flags = 0 },\n\t{ .bitrate = 480, .hw_value = DESC_RATE_48M, .flags = 0 },\n\t{ .bitrate = 540, .hw_value = DESC_RATE_54M, .flags = 0 },\n};\n\nstatic struct ieee80211_channel rtl8xxxu_channels_2g[] = {\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2412,\n\t  .hw_value = 1, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2417,\n\t  .hw_value = 2, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2422,\n\t  .hw_value = 3, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2427,\n\t  .hw_value = 4, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2432,\n\t  .hw_value = 5, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2437,\n\t  .hw_value = 6, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2442,\n\t  .hw_value = 7, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2447,\n\t  .hw_value = 8, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2452,\n\t  .hw_value = 9, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2457,\n\t  .hw_value = 10, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2462,\n\t  .hw_value = 11, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2467,\n\t  .hw_value = 12, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2472,\n\t  .hw_value = 13, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2484,\n\t  .hw_value = 14, .max_power = 30 }\n};\n\nstatic struct ieee80211_supported_band rtl8xxxu_supported_band = {\n\t.channels = rtl8xxxu_channels_2g,\n\t.n_channels = ARRAY_SIZE(rtl8xxxu_channels_2g),\n\t.bitrates = rtl8xxxu_rates,\n\t.n_bitrates = ARRAY_SIZE(rtl8xxxu_rates),\n};\n\nstruct rtl8xxxu_reg8val rtl8xxxu_gen1_mac_init_table[] = {\n\t{0x420, 0x80}, {0x423, 0x00}, {0x430, 0x00}, {0x431, 0x00},\n\t{0x432, 0x00}, {0x433, 0x01}, {0x434, 0x04}, {0x435, 0x05},\n\t{0x436, 0x06}, {0x437, 0x07}, {0x438, 0x00}, {0x439, 0x00},\n\t{0x43a, 0x00}, {0x43b, 0x01}, {0x43c, 0x04}, {0x43d, 0x05},\n\t{0x43e, 0x06}, {0x43f, 0x07}, {0x440, 0x5d}, {0x441, 0x01},\n\t{0x442, 0x00}, {0x444, 0x15}, {0x445, 0xf0}, {0x446, 0x0f},\n\t{0x447, 0x00}, {0x458, 0x41}, {0x459, 0xa8}, {0x45a, 0x72},\n\t{0x45b, 0xb9}, {0x460, 0x66}, {0x461, 0x66}, {0x462, 0x08},\n\t{0x463, 0x03}, {0x4c8, 0xff}, {0x4c9, 0x08}, {0x4cc, 0xff},\n\t{0x4cd, 0xff}, {0x4ce, 0x01}, {0x500, 0x26}, {0x501, 0xa2},\n\t{0x502, 0x2f}, {0x503, 0x00}, {0x504, 0x28}, {0x505, 0xa3},\n\t{0x506, 0x5e}, {0x507, 0x00}, {0x508, 0x2b}, {0x509, 0xa4},\n\t{0x50a, 0x5e}, {0x50b, 0x00}, {0x50c, 0x4f}, {0x50d, 0xa4},\n\t{0x50e, 0x00}, {0x50f, 0x00}, {0x512, 0x1c}, {0x514, 0x0a},\n\t{0x515, 0x10}, {0x516, 0x0a}, {0x517, 0x10}, {0x51a, 0x16},\n\t{0x524, 0x0f}, {0x525, 0x4f}, {0x546, 0x40}, {0x547, 0x00},\n\t{0x550, 0x10}, {0x551, 0x10}, {0x559, 0x02}, {0x55a, 0x02},\n\t{0x55d, 0xff}, {0x605, 0x30}, {0x608, 0x0e}, {0x609, 0x2a},\n\t{0x652, 0x20}, {0x63c, 0x0a}, {0x63d, 0x0a}, {0x63e, 0x0e},\n\t{0x63f, 0x0e}, {0x66e, 0x05}, {0x700, 0x21}, {0x701, 0x43},\n\t{0x702, 0x65}, {0x703, 0x87}, {0x708, 0x21}, {0x709, 0x43},\n\t{0x70a, 0x65}, {0x70b, 0x87}, {0xffff, 0xff},\n};\n\nstatic struct rtl8xxxu_reg32val rtl8723a_phy_1t_init_table[] = {\n\t{0x800, 0x80040000}, {0x804, 0x00000003},\n\t{0x808, 0x0000fc00}, {0x80c, 0x0000000a},\n\t{0x810, 0x10001331}, {0x814, 0x020c3d10},\n\t{0x818, 0x02200385}, {0x81c, 0x00000000},\n\t{0x820, 0x01000100}, {0x824, 0x00390004},\n\t{0x828, 0x00000000}, {0x82c, 0x00000000},\n\t{0x830, 0x00000000}, {0x834, 0x00000000},\n\t{0x838, 0x00000000}, {0x83c, 0x00000000},\n\t{0x840, 0x00010000}, {0x844, 0x00000000},\n\t{0x848, 0x00000000}, {0x84c, 0x00000000},\n\t{0x850, 0x00000000}, {0x854, 0x00000000},\n\t{0x858, 0x569a569a}, {0x85c, 0x001b25a4},\n\t{0x860, 0x66f60110}, {0x864, 0x061f0130},\n\t{0x868, 0x00000000}, {0x86c, 0x32323200},\n\t{0x870, 0x07000760}, {0x874, 0x22004000},\n\t{0x878, 0x00000808}, {0x87c, 0x00000000},\n\t{0x880, 0xc0083070}, {0x884, 0x000004d5},\n\t{0x888, 0x00000000}, {0x88c, 0xccc000c0},\n\t{0x890, 0x00000800}, {0x894, 0xfffffffe},\n\t{0x898, 0x40302010}, {0x89c, 0x00706050},\n\t{0x900, 0x00000000}, {0x904, 0x00000023},\n\t{0x908, 0x00000000}, {0x90c, 0x81121111},\n\t{0xa00, 0x00d047c8}, {0xa04, 0x80ff000c},\n\t{0xa08, 0x8c838300}, {0xa0c, 0x2e68120f},\n\t{0xa10, 0x9500bb78}, {0xa14, 0x11144028},\n\t{0xa18, 0x00881117}, {0xa1c, 0x89140f00},\n\t{0xa20, 0x1a1b0000}, {0xa24, 0x090e1317},\n\t{0xa28, 0x00000204}, {0xa2c, 0x00d30000},\n\t{0xa70, 0x101fbf00}, {0xa74, 0x00000007},\n\t{0xa78, 0x00000900},\n\t{0xc00, 0x48071d40}, {0xc04, 0x03a05611},\n\t{0xc08, 0x000000e4}, {0xc0c, 0x6c6c6c6c},\n\t{0xc10, 0x08800000}, {0xc14, 0x40000100},\n\t{0xc18, 0x08800000}, {0xc1c, 0x40000100},\n\t{0xc20, 0x00000000}, {0xc24, 0x00000000},\n\t{0xc28, 0x00000000}, {0xc2c, 0x00000000},\n\t{0xc30, 0x69e9ac44}, {0xc34, 0x469652af},\n\t{0xc38, 0x49795994}, {0xc3c, 0x0a97971c},\n\t{0xc40, 0x1f7c403f}, {0xc44, 0x000100b7},\n\t{0xc48, 0xec020107}, {0xc4c, 0x007f037f},\n\t{0xc50, 0x69543420}, {0xc54, 0x43bc0094},\n\t{0xc58, 0x69543420}, {0xc5c, 0x433c0094},\n\t{0xc60, 0x00000000}, {0xc64, 0x7112848b},\n\t{0xc68, 0x47c00bff}, {0xc6c, 0x00000036},\n\t{0xc70, 0x2c7f000d}, {0xc74, 0x018610db},\n\t{0xc78, 0x0000001f}, {0xc7c, 0x00b91612},\n\t{0xc80, 0x40000100}, {0xc84, 0x20f60000},\n\t{0xc88, 0x40000100}, {0xc8c, 0x20200000},\n\t{0xc90, 0x00121820}, {0xc94, 0x00000000},\n\t{0xc98, 0x00121820}, {0xc9c, 0x00007f7f},\n\t{0xca0, 0x00000000}, {0xca4, 0x00000080},\n\t{0xca8, 0x00000000}, {0xcac, 0x00000000},\n\t{0xcb0, 0x00000000}, {0xcb4, 0x00000000},\n\t{0xcb8, 0x00000000}, {0xcbc, 0x28000000},\n\t{0xcc0, 0x00000000}, {0xcc4, 0x00000000},\n\t{0xcc8, 0x00000000}, {0xccc, 0x00000000},\n\t{0xcd0, 0x00000000}, {0xcd4, 0x00000000},\n\t{0xcd8, 0x64b22427}, {0xcdc, 0x00766932},\n\t{0xce0, 0x00222222}, {0xce4, 0x00000000},\n\t{0xce8, 0x37644302}, {0xcec, 0x2f97d40c},\n\t{0xd00, 0x00080740}, {0xd04, 0x00020401},\n\t{0xd08, 0x0000907f}, {0xd0c, 0x20010201},\n\t{0xd10, 0xa0633333}, {0xd14, 0x3333bc43},\n\t{0xd18, 0x7a8f5b6b}, {0xd2c, 0xcc979975},\n\t{0xd30, 0x00000000}, {0xd34, 0x80608000},\n\t{0xd38, 0x00000000}, {0xd3c, 0x00027293},\n\t{0xd40, 0x00000000}, {0xd44, 0x00000000},\n\t{0xd48, 0x00000000}, {0xd4c, 0x00000000},\n\t{0xd50, 0x6437140a}, {0xd54, 0x00000000},\n\t{0xd58, 0x00000000}, {0xd5c, 0x30032064},\n\t{0xd60, 0x4653de68}, {0xd64, 0x04518a3c},\n\t{0xd68, 0x00002101}, {0xd6c, 0x2a201c16},\n\t{0xd70, 0x1812362e}, {0xd74, 0x322c2220},\n\t{0xd78, 0x000e3c24}, {0xe00, 0x2a2a2a2a},\n\t{0xe04, 0x2a2a2a2a}, {0xe08, 0x03902a2a},\n\t{0xe10, 0x2a2a2a2a}, {0xe14, 0x2a2a2a2a},\n\t{0xe18, 0x2a2a2a2a}, {0xe1c, 0x2a2a2a2a},\n\t{0xe28, 0x00000000}, {0xe30, 0x1000dc1f},\n\t{0xe34, 0x10008c1f}, {0xe38, 0x02140102},\n\t{0xe3c, 0x681604c2}, {0xe40, 0x01007c00},\n\t{0xe44, 0x01004800}, {0xe48, 0xfb000000},\n\t{0xe4c, 0x000028d1}, {0xe50, 0x1000dc1f},\n\t{0xe54, 0x10008c1f}, {0xe58, 0x02140102},\n\t{0xe5c, 0x28160d05}, {0xe60, 0x00000008},\n\t{0xe68, 0x001b25a4}, {0xe6c, 0x631b25a0},\n\t{0xe70, 0x631b25a0}, {0xe74, 0x081b25a0},\n\t{0xe78, 0x081b25a0}, {0xe7c, 0x081b25a0},\n\t{0xe80, 0x081b25a0}, {0xe84, 0x631b25a0},\n\t{0xe88, 0x081b25a0}, {0xe8c, 0x631b25a0},\n\t{0xed0, 0x631b25a0}, {0xed4, 0x631b25a0},\n\t{0xed8, 0x631b25a0}, {0xedc, 0x001b25a0},\n\t{0xee0, 0x001b25a0}, {0xeec, 0x6b1b25a0},\n\t{0xf14, 0x00000003}, {0xf4c, 0x00000000},\n\t{0xf00, 0x00000300},\n\t{0xffff, 0xffffffff},\n};\n\nstatic struct rtl8xxxu_reg32val rtl8192cu_phy_2t_init_table[] = {\n\t{0x024, 0x0011800f}, {0x028, 0x00ffdb83},\n\t{0x800, 0x80040002}, {0x804, 0x00000003},\n\t{0x808, 0x0000fc00}, {0x80c, 0x0000000a},\n\t{0x810, 0x10000330}, {0x814, 0x020c3d10},\n\t{0x818, 0x02200385}, {0x81c, 0x00000000},\n\t{0x820, 0x01000100}, {0x824, 0x00390004},\n\t{0x828, 0x01000100}, {0x82c, 0x00390004},\n\t{0x830, 0x27272727}, {0x834, 0x27272727},\n\t{0x838, 0x27272727}, {0x83c, 0x27272727},\n\t{0x840, 0x00010000}, {0x844, 0x00010000},\n\t{0x848, 0x27272727}, {0x84c, 0x27272727},\n\t{0x850, 0x00000000}, {0x854, 0x00000000},\n\t{0x858, 0x569a569a}, {0x85c, 0x0c1b25a4},\n\t{0x860, 0x66e60230}, {0x864, 0x061f0130},\n\t{0x868, 0x27272727}, {0x86c, 0x2b2b2b27},\n\t{0x870, 0x07000700}, {0x874, 0x22184000},\n\t{0x878, 0x08080808}, {0x87c, 0x00000000},\n\t{0x880, 0xc0083070}, {0x884, 0x000004d5},\n\t{0x888, 0x00000000}, {0x88c, 0xcc0000c0},\n\t{0x890, 0x00000800}, {0x894, 0xfffffffe},\n\t{0x898, 0x40302010}, {0x89c, 0x00706050},\n\t{0x900, 0x00000000}, {0x904, 0x00000023},\n\t{0x908, 0x00000000}, {0x90c, 0x81121313},\n\t{0xa00, 0x00d047c8}, {0xa04, 0x80ff000c},\n\t{0xa08, 0x8c838300}, {0xa0c, 0x2e68120f},\n\t{0xa10, 0x9500bb78}, {0xa14, 0x11144028},\n\t{0xa18, 0x00881117}, {0xa1c, 0x89140f00},\n\t{0xa20, 0x1a1b0000}, {0xa24, 0x090e1317},\n\t{0xa28, 0x00000204}, {0xa2c, 0x00d30000},\n\t{0xa70, 0x101fbf00}, {0xa74, 0x00000007},\n\t{0xc00, 0x48071d40}, {0xc04, 0x03a05633},\n\t{0xc08, 0x000000e4}, {0xc0c, 0x6c6c6c6c},\n\t{0xc10, 0x08800000}, {0xc14, 0x40000100},\n\t{0xc18, 0x08800000}, {0xc1c, 0x40000100},\n\t{0xc20, 0x00000000}, {0xc24, 0x00000000},\n\t{0xc28, 0x00000000}, {0xc2c, 0x00000000},\n\t{0xc30, 0x69e9ac44}, {0xc34, 0x469652cf},\n\t{0xc38, 0x49795994}, {0xc3c, 0x0a97971c},\n\t{0xc40, 0x1f7c403f}, {0xc44, 0x000100b7},\n\t{0xc48, 0xec020107}, {0xc4c, 0x007f037f},\n\t{0xc50, 0x69543420}, {0xc54, 0x43bc0094},\n\t{0xc58, 0x69543420}, {0xc5c, 0x433c0094},\n\t{0xc60, 0x00000000}, {0xc64, 0x5116848b},\n\t{0xc68, 0x47c00bff}, {0xc6c, 0x00000036},\n\t{0xc70, 0x2c7f000d}, {0xc74, 0x2186115b},\n\t{0xc78, 0x0000001f}, {0xc7c, 0x00b99612},\n\t{0xc80, 0x40000100}, {0xc84, 0x20f60000},\n\t{0xc88, 0x40000100}, {0xc8c, 0xa0e40000},\n\t{0xc90, 0x00121820}, {0xc94, 0x00000000},\n\t{0xc98, 0x00121820}, {0xc9c, 0x00007f7f},\n\t{0xca0, 0x00000000}, {0xca4, 0x00000080},\n\t{0xca8, 0x00000000}, {0xcac, 0x00000000},\n\t{0xcb0, 0x00000000}, {0xcb4, 0x00000000},\n\t{0xcb8, 0x00000000}, {0xcbc, 0x28000000},\n\t{0xcc0, 0x00000000}, {0xcc4, 0x00000000},\n\t{0xcc8, 0x00000000}, {0xccc, 0x00000000},\n\t{0xcd0, 0x00000000}, {0xcd4, 0x00000000},\n\t{0xcd8, 0x64b22427}, {0xcdc, 0x00766932},\n\t{0xce0, 0x00222222}, {0xce4, 0x00000000},\n\t{0xce8, 0x37644302}, {0xcec, 0x2f97d40c},\n\t{0xd00, 0x00080740}, {0xd04, 0x00020403},\n\t{0xd08, 0x0000907f}, {0xd0c, 0x20010201},\n\t{0xd10, 0xa0633333}, {0xd14, 0x3333bc43},\n\t{0xd18, 0x7a8f5b6b}, {0xd2c, 0xcc979975},\n\t{0xd30, 0x00000000}, {0xd34, 0x80608000},\n\t{0xd38, 0x00000000}, {0xd3c, 0x00027293},\n\t{0xd40, 0x00000000}, {0xd44, 0x00000000},\n\t{0xd48, 0x00000000}, {0xd4c, 0x00000000},\n\t{0xd50, 0x6437140a}, {0xd54, 0x00000000},\n\t{0xd58, 0x00000000}, {0xd5c, 0x30032064},\n\t{0xd60, 0x4653de68}, {0xd64, 0x04518a3c},\n\t{0xd68, 0x00002101}, {0xd6c, 0x2a201c16},\n\t{0xd70, 0x1812362e}, {0xd74, 0x322c2220},\n\t{0xd78, 0x000e3c24}, {0xe00, 0x2a2a2a2a},\n\t{0xe04, 0x2a2a2a2a}, {0xe08, 0x03902a2a},\n\t{0xe10, 0x2a2a2a2a}, {0xe14, 0x2a2a2a2a},\n\t{0xe18, 0x2a2a2a2a}, {0xe1c, 0x2a2a2a2a},\n\t{0xe28, 0x00000000}, {0xe30, 0x1000dc1f},\n\t{0xe34, 0x10008c1f}, {0xe38, 0x02140102},\n\t{0xe3c, 0x681604c2}, {0xe40, 0x01007c00},\n\t{0xe44, 0x01004800}, {0xe48, 0xfb000000},\n\t{0xe4c, 0x000028d1}, {0xe50, 0x1000dc1f},\n\t{0xe54, 0x10008c1f}, {0xe58, 0x02140102},\n\t{0xe5c, 0x28160d05}, {0xe60, 0x00000010},\n\t{0xe68, 0x001b25a4}, {0xe6c, 0x63db25a4},\n\t{0xe70, 0x63db25a4}, {0xe74, 0x0c1b25a4},\n\t{0xe78, 0x0c1b25a4}, {0xe7c, 0x0c1b25a4},\n\t{0xe80, 0x0c1b25a4}, {0xe84, 0x63db25a4},\n\t{0xe88, 0x0c1b25a4}, {0xe8c, 0x63db25a4},\n\t{0xed0, 0x63db25a4}, {0xed4, 0x63db25a4},\n\t{0xed8, 0x63db25a4}, {0xedc, 0x001b25a4},\n\t{0xee0, 0x001b25a4}, {0xeec, 0x6fdb25a4},\n\t{0xf14, 0x00000003}, {0xf4c, 0x00000000},\n\t{0xf00, 0x00000300},\n\t{0xffff, 0xffffffff},\n};\n\nstatic struct rtl8xxxu_reg32val rtl8188ru_phy_1t_highpa_table[] = {\n\t{0x024, 0x0011800f}, {0x028, 0x00ffdb83},\n\t{0x040, 0x000c0004}, {0x800, 0x80040000},\n\t{0x804, 0x00000001}, {0x808, 0x0000fc00},\n\t{0x80c, 0x0000000a}, {0x810, 0x10005388},\n\t{0x814, 0x020c3d10}, {0x818, 0x02200385},\n\t{0x81c, 0x00000000}, {0x820, 0x01000100},\n\t{0x824, 0x00390204}, {0x828, 0x00000000},\n\t{0x82c, 0x00000000}, {0x830, 0x00000000},\n\t{0x834, 0x00000000}, {0x838, 0x00000000},\n\t{0x83c, 0x00000000}, {0x840, 0x00010000},\n\t{0x844, 0x00000000}, {0x848, 0x00000000},\n\t{0x84c, 0x00000000}, {0x850, 0x00000000},\n\t{0x854, 0x00000000}, {0x858, 0x569a569a},\n\t{0x85c, 0x001b25a4}, {0x860, 0x66e60230},\n\t{0x864, 0x061f0130}, {0x868, 0x00000000},\n\t{0x86c, 0x20202000}, {0x870, 0x03000300},\n\t{0x874, 0x22004000}, {0x878, 0x00000808},\n\t{0x87c, 0x00ffc3f1}, {0x880, 0xc0083070},\n\t{0x884, 0x000004d5}, {0x888, 0x00000000},\n\t{0x88c, 0xccc000c0}, {0x890, 0x00000800},\n\t{0x894, 0xfffffffe}, {0x898, 0x40302010},\n\t{0x89c, 0x00706050}, {0x900, 0x00000000},\n\t{0x904, 0x00000023}, {0x908, 0x00000000},\n\t{0x90c, 0x81121111}, {0xa00, 0x00d047c8},\n\t{0xa04, 0x80ff000c}, {0xa08, 0x8c838300},\n\t{0xa0c, 0x2e68120f}, {0xa10, 0x9500bb78},\n\t{0xa14, 0x11144028}, {0xa18, 0x00881117},\n\t{0xa1c, 0x89140f00}, {0xa20, 0x15160000},\n\t{0xa24, 0x070b0f12}, {0xa28, 0x00000104},\n\t{0xa2c, 0x00d30000}, {0xa70, 0x101fbf00},\n\t{0xa74, 0x00000007}, {0xc00, 0x48071d40},\n\t{0xc04, 0x03a05611}, {0xc08, 0x000000e4},\n\t{0xc0c, 0x6c6c6c6c}, {0xc10, 0x08800000},\n\t{0xc14, 0x40000100}, {0xc18, 0x08800000},\n\t{0xc1c, 0x40000100}, {0xc20, 0x00000000},\n\t{0xc24, 0x00000000}, {0xc28, 0x00000000},\n\t{0xc2c, 0x00000000}, {0xc30, 0x69e9ac44},\n\t{0xc34, 0x469652cf}, {0xc38, 0x49795994},\n\t{0xc3c, 0x0a97971c}, {0xc40, 0x1f7c403f},\n\t{0xc44, 0x000100b7}, {0xc48, 0xec020107},\n\t{0xc4c, 0x007f037f}, {0xc50, 0x6954342e},\n\t{0xc54, 0x43bc0094}, {0xc58, 0x6954342f},\n\t{0xc5c, 0x433c0094}, {0xc60, 0x00000000},\n\t{0xc64, 0x5116848b}, {0xc68, 0x47c00bff},\n\t{0xc6c, 0x00000036}, {0xc70, 0x2c46000d},\n\t{0xc74, 0x018610db}, {0xc78, 0x0000001f},\n\t{0xc7c, 0x00b91612}, {0xc80, 0x24000090},\n\t{0xc84, 0x20f60000}, {0xc88, 0x24000090},\n\t{0xc8c, 0x20200000}, {0xc90, 0x00121820},\n\t{0xc94, 0x00000000}, {0xc98, 0x00121820},\n\t{0xc9c, 0x00007f7f}, {0xca0, 0x00000000},\n\t{0xca4, 0x00000080}, {0xca8, 0x00000000},\n\t{0xcac, 0x00000000}, {0xcb0, 0x00000000},\n\t{0xcb4, 0x00000000}, {0xcb8, 0x00000000},\n\t{0xcbc, 0x28000000}, {0xcc0, 0x00000000},\n\t{0xcc4, 0x00000000}, {0xcc8, 0x00000000},\n\t{0xccc, 0x00000000}, {0xcd0, 0x00000000},\n\t{0xcd4, 0x00000000}, {0xcd8, 0x64b22427},\n\t{0xcdc, 0x00766932}, {0xce0, 0x00222222},\n\t{0xce4, 0x00000000}, {0xce8, 0x37644302},\n\t{0xcec, 0x2f97d40c}, {0xd00, 0x00080740},\n\t{0xd04, 0x00020401}, {0xd08, 0x0000907f},\n\t{0xd0c, 0x20010201}, {0xd10, 0xa0633333},\n\t{0xd14, 0x3333bc43}, {0xd18, 0x7a8f5b6b},\n\t{0xd2c, 0xcc979975}, {0xd30, 0x00000000},\n\t{0xd34, 0x80608000}, {0xd38, 0x00000000},\n\t{0xd3c, 0x00027293}, {0xd40, 0x00000000},\n\t{0xd44, 0x00000000}, {0xd48, 0x00000000},\n\t{0xd4c, 0x00000000}, {0xd50, 0x6437140a},\n\t{0xd54, 0x00000000}, {0xd58, 0x00000000},\n\t{0xd5c, 0x30032064}, {0xd60, 0x4653de68},\n\t{0xd64, 0x04518a3c}, {0xd68, 0x00002101},\n\t{0xd6c, 0x2a201c16}, {0xd70, 0x1812362e},\n\t{0xd74, 0x322c2220}, {0xd78, 0x000e3c24},\n\t{0xe00, 0x24242424}, {0xe04, 0x24242424},\n\t{0xe08, 0x03902024}, {0xe10, 0x24242424},\n\t{0xe14, 0x24242424}, {0xe18, 0x24242424},\n\t{0xe1c, 0x24242424}, {0xe28, 0x00000000},\n\t{0xe30, 0x1000dc1f}, {0xe34, 0x10008c1f},\n\t{0xe38, 0x02140102}, {0xe3c, 0x681604c2},\n\t{0xe40, 0x01007c00}, {0xe44, 0x01004800},\n\t{0xe48, 0xfb000000}, {0xe4c, 0x000028d1},\n\t{0xe50, 0x1000dc1f}, {0xe54, 0x10008c1f},\n\t{0xe58, 0x02140102}, {0xe5c, 0x28160d05},\n\t{0xe60, 0x00000008}, {0xe68, 0x001b25a4},\n\t{0xe6c, 0x631b25a0}, {0xe70, 0x631b25a0},\n\t{0xe74, 0x081b25a0}, {0xe78, 0x081b25a0},\n\t{0xe7c, 0x081b25a0}, {0xe80, 0x081b25a0},\n\t{0xe84, 0x631b25a0}, {0xe88, 0x081b25a0},\n\t{0xe8c, 0x631b25a0}, {0xed0, 0x631b25a0},\n\t{0xed4, 0x631b25a0}, {0xed8, 0x631b25a0},\n\t{0xedc, 0x001b25a0}, {0xee0, 0x001b25a0},\n\t{0xeec, 0x6b1b25a0}, {0xee8, 0x31555448},\n\t{0xf14, 0x00000003}, {0xf4c, 0x00000000},\n\t{0xf00, 0x00000300},\n\t{0xffff, 0xffffffff},\n};\n\nstatic struct rtl8xxxu_reg32val rtl8xxx_agc_standard_table[] = {\n\t{0xc78, 0x7b000001}, {0xc78, 0x7b010001},\n\t{0xc78, 0x7b020001}, {0xc78, 0x7b030001},\n\t{0xc78, 0x7b040001}, {0xc78, 0x7b050001},\n\t{0xc78, 0x7a060001}, {0xc78, 0x79070001},\n\t{0xc78, 0x78080001}, {0xc78, 0x77090001},\n\t{0xc78, 0x760a0001}, {0xc78, 0x750b0001},\n\t{0xc78, 0x740c0001}, {0xc78, 0x730d0001},\n\t{0xc78, 0x720e0001}, {0xc78, 0x710f0001},\n\t{0xc78, 0x70100001}, {0xc78, 0x6f110001},\n\t{0xc78, 0x6e120001}, {0xc78, 0x6d130001},\n\t{0xc78, 0x6c140001}, {0xc78, 0x6b150001},\n\t{0xc78, 0x6a160001}, {0xc78, 0x69170001},\n\t{0xc78, 0x68180001}, {0xc78, 0x67190001},\n\t{0xc78, 0x661a0001}, {0xc78, 0x651b0001},\n\t{0xc78, 0x641c0001}, {0xc78, 0x631d0001},\n\t{0xc78, 0x621e0001}, {0xc78, 0x611f0001},\n\t{0xc78, 0x60200001}, {0xc78, 0x49210001},\n\t{0xc78, 0x48220001}, {0xc78, 0x47230001},\n\t{0xc78, 0x46240001}, {0xc78, 0x45250001},\n\t{0xc78, 0x44260001}, {0xc78, 0x43270001},\n\t{0xc78, 0x42280001}, {0xc78, 0x41290001},\n\t{0xc78, 0x402a0001}, {0xc78, 0x262b0001},\n\t{0xc78, 0x252c0001}, {0xc78, 0x242d0001},\n\t{0xc78, 0x232e0001}, {0xc78, 0x222f0001},\n\t{0xc78, 0x21300001}, {0xc78, 0x20310001},\n\t{0xc78, 0x06320001}, {0xc78, 0x05330001},\n\t{0xc78, 0x04340001}, {0xc78, 0x03350001},\n\t{0xc78, 0x02360001}, {0xc78, 0x01370001},\n\t{0xc78, 0x00380001}, {0xc78, 0x00390001},\n\t{0xc78, 0x003a0001}, {0xc78, 0x003b0001},\n\t{0xc78, 0x003c0001}, {0xc78, 0x003d0001},\n\t{0xc78, 0x003e0001}, {0xc78, 0x003f0001},\n\t{0xc78, 0x7b400001}, {0xc78, 0x7b410001},\n\t{0xc78, 0x7b420001}, {0xc78, 0x7b430001},\n\t{0xc78, 0x7b440001}, {0xc78, 0x7b450001},\n\t{0xc78, 0x7a460001}, {0xc78, 0x79470001},\n\t{0xc78, 0x78480001}, {0xc78, 0x77490001},\n\t{0xc78, 0x764a0001}, {0xc78, 0x754b0001},\n\t{0xc78, 0x744c0001}, {0xc78, 0x734d0001},\n\t{0xc78, 0x724e0001}, {0xc78, 0x714f0001},\n\t{0xc78, 0x70500001}, {0xc78, 0x6f510001},\n\t{0xc78, 0x6e520001}, {0xc78, 0x6d530001},\n\t{0xc78, 0x6c540001}, {0xc78, 0x6b550001},\n\t{0xc78, 0x6a560001}, {0xc78, 0x69570001},\n\t{0xc78, 0x68580001}, {0xc78, 0x67590001},\n\t{0xc78, 0x665a0001}, {0xc78, 0x655b0001},\n\t{0xc78, 0x645c0001}, {0xc78, 0x635d0001},\n\t{0xc78, 0x625e0001}, {0xc78, 0x615f0001},\n\t{0xc78, 0x60600001}, {0xc78, 0x49610001},\n\t{0xc78, 0x48620001}, {0xc78, 0x47630001},\n\t{0xc78, 0x46640001}, {0xc78, 0x45650001},\n\t{0xc78, 0x44660001}, {0xc78, 0x43670001},\n\t{0xc78, 0x42680001}, {0xc78, 0x41690001},\n\t{0xc78, 0x406a0001}, {0xc78, 0x266b0001},\n\t{0xc78, 0x256c0001}, {0xc78, 0x246d0001},\n\t{0xc78, 0x236e0001}, {0xc78, 0x226f0001},\n\t{0xc78, 0x21700001}, {0xc78, 0x20710001},\n\t{0xc78, 0x06720001}, {0xc78, 0x05730001},\n\t{0xc78, 0x04740001}, {0xc78, 0x03750001},\n\t{0xc78, 0x02760001}, {0xc78, 0x01770001},\n\t{0xc78, 0x00780001}, {0xc78, 0x00790001},\n\t{0xc78, 0x007a0001}, {0xc78, 0x007b0001},\n\t{0xc78, 0x007c0001}, {0xc78, 0x007d0001},\n\t{0xc78, 0x007e0001}, {0xc78, 0x007f0001},\n\t{0xc78, 0x3800001e}, {0xc78, 0x3801001e},\n\t{0xc78, 0x3802001e}, {0xc78, 0x3803001e},\n\t{0xc78, 0x3804001e}, {0xc78, 0x3805001e},\n\t{0xc78, 0x3806001e}, {0xc78, 0x3807001e},\n\t{0xc78, 0x3808001e}, {0xc78, 0x3c09001e},\n\t{0xc78, 0x3e0a001e}, {0xc78, 0x400b001e},\n\t{0xc78, 0x440c001e}, {0xc78, 0x480d001e},\n\t{0xc78, 0x4c0e001e}, {0xc78, 0x500f001e},\n\t{0xc78, 0x5210001e}, {0xc78, 0x5611001e},\n\t{0xc78, 0x5a12001e}, {0xc78, 0x5e13001e},\n\t{0xc78, 0x6014001e}, {0xc78, 0x6015001e},\n\t{0xc78, 0x6016001e}, {0xc78, 0x6217001e},\n\t{0xc78, 0x6218001e}, {0xc78, 0x6219001e},\n\t{0xc78, 0x621a001e}, {0xc78, 0x621b001e},\n\t{0xc78, 0x621c001e}, {0xc78, 0x621d001e},\n\t{0xc78, 0x621e001e}, {0xc78, 0x621f001e},\n\t{0xffff, 0xffffffff}\n};\n\nstatic struct rtl8xxxu_reg32val rtl8xxx_agc_highpa_table[] = {\n\t{0xc78, 0x7b000001}, {0xc78, 0x7b010001},\n\t{0xc78, 0x7b020001}, {0xc78, 0x7b030001},\n\t{0xc78, 0x7b040001}, {0xc78, 0x7b050001},\n\t{0xc78, 0x7b060001}, {0xc78, 0x7b070001},\n\t{0xc78, 0x7b080001}, {0xc78, 0x7a090001},\n\t{0xc78, 0x790a0001}, {0xc78, 0x780b0001},\n\t{0xc78, 0x770c0001}, {0xc78, 0x760d0001},\n\t{0xc78, 0x750e0001}, {0xc78, 0x740f0001},\n\t{0xc78, 0x73100001}, {0xc78, 0x72110001},\n\t{0xc78, 0x71120001}, {0xc78, 0x70130001},\n\t{0xc78, 0x6f140001}, {0xc78, 0x6e150001},\n\t{0xc78, 0x6d160001}, {0xc78, 0x6c170001},\n\t{0xc78, 0x6b180001}, {0xc78, 0x6a190001},\n\t{0xc78, 0x691a0001}, {0xc78, 0x681b0001},\n\t{0xc78, 0x671c0001}, {0xc78, 0x661d0001},\n\t{0xc78, 0x651e0001}, {0xc78, 0x641f0001},\n\t{0xc78, 0x63200001}, {0xc78, 0x62210001},\n\t{0xc78, 0x61220001}, {0xc78, 0x60230001},\n\t{0xc78, 0x46240001}, {0xc78, 0x45250001},\n\t{0xc78, 0x44260001}, {0xc78, 0x43270001},\n\t{0xc78, 0x42280001}, {0xc78, 0x41290001},\n\t{0xc78, 0x402a0001}, {0xc78, 0x262b0001},\n\t{0xc78, 0x252c0001}, {0xc78, 0x242d0001},\n\t{0xc78, 0x232e0001}, {0xc78, 0x222f0001},\n\t{0xc78, 0x21300001}, {0xc78, 0x20310001},\n\t{0xc78, 0x06320001}, {0xc78, 0x05330001},\n\t{0xc78, 0x04340001}, {0xc78, 0x03350001},\n\t{0xc78, 0x02360001}, {0xc78, 0x01370001},\n\t{0xc78, 0x00380001}, {0xc78, 0x00390001},\n\t{0xc78, 0x003a0001}, {0xc78, 0x003b0001},\n\t{0xc78, 0x003c0001}, {0xc78, 0x003d0001},\n\t{0xc78, 0x003e0001}, {0xc78, 0x003f0001},\n\t{0xc78, 0x7b400001}, {0xc78, 0x7b410001},\n\t{0xc78, 0x7b420001}, {0xc78, 0x7b430001},\n\t{0xc78, 0x7b440001}, {0xc78, 0x7b450001},\n\t{0xc78, 0x7b460001}, {0xc78, 0x7b470001},\n\t{0xc78, 0x7b480001}, {0xc78, 0x7a490001},\n\t{0xc78, 0x794a0001}, {0xc78, 0x784b0001},\n\t{0xc78, 0x774c0001}, {0xc78, 0x764d0001},\n\t{0xc78, 0x754e0001}, {0xc78, 0x744f0001},\n\t{0xc78, 0x73500001}, {0xc78, 0x72510001},\n\t{0xc78, 0x71520001}, {0xc78, 0x70530001},\n\t{0xc78, 0x6f540001}, {0xc78, 0x6e550001},\n\t{0xc78, 0x6d560001}, {0xc78, 0x6c570001},\n\t{0xc78, 0x6b580001}, {0xc78, 0x6a590001},\n\t{0xc78, 0x695a0001}, {0xc78, 0x685b0001},\n\t{0xc78, 0x675c0001}, {0xc78, 0x665d0001},\n\t{0xc78, 0x655e0001}, {0xc78, 0x645f0001},\n\t{0xc78, 0x63600001}, {0xc78, 0x62610001},\n\t{0xc78, 0x61620001}, {0xc78, 0x60630001},\n\t{0xc78, 0x46640001}, {0xc78, 0x45650001},\n\t{0xc78, 0x44660001}, {0xc78, 0x43670001},\n\t{0xc78, 0x42680001}, {0xc78, 0x41690001},\n\t{0xc78, 0x406a0001}, {0xc78, 0x266b0001},\n\t{0xc78, 0x256c0001}, {0xc78, 0x246d0001},\n\t{0xc78, 0x236e0001}, {0xc78, 0x226f0001},\n\t{0xc78, 0x21700001}, {0xc78, 0x20710001},\n\t{0xc78, 0x06720001}, {0xc78, 0x05730001},\n\t{0xc78, 0x04740001}, {0xc78, 0x03750001},\n\t{0xc78, 0x02760001}, {0xc78, 0x01770001},\n\t{0xc78, 0x00780001}, {0xc78, 0x00790001},\n\t{0xc78, 0x007a0001}, {0xc78, 0x007b0001},\n\t{0xc78, 0x007c0001}, {0xc78, 0x007d0001},\n\t{0xc78, 0x007e0001}, {0xc78, 0x007f0001},\n\t{0xc78, 0x3800001e}, {0xc78, 0x3801001e},\n\t{0xc78, 0x3802001e}, {0xc78, 0x3803001e},\n\t{0xc78, 0x3804001e}, {0xc78, 0x3805001e},\n\t{0xc78, 0x3806001e}, {0xc78, 0x3807001e},\n\t{0xc78, 0x3808001e}, {0xc78, 0x3c09001e},\n\t{0xc78, 0x3e0a001e}, {0xc78, 0x400b001e},\n\t{0xc78, 0x440c001e}, {0xc78, 0x480d001e},\n\t{0xc78, 0x4c0e001e}, {0xc78, 0x500f001e},\n\t{0xc78, 0x5210001e}, {0xc78, 0x5611001e},\n\t{0xc78, 0x5a12001e}, {0xc78, 0x5e13001e},\n\t{0xc78, 0x6014001e}, {0xc78, 0x6015001e},\n\t{0xc78, 0x6016001e}, {0xc78, 0x6217001e},\n\t{0xc78, 0x6218001e}, {0xc78, 0x6219001e},\n\t{0xc78, 0x621a001e}, {0xc78, 0x621b001e},\n\t{0xc78, 0x621c001e}, {0xc78, 0x621d001e},\n\t{0xc78, 0x621e001e}, {0xc78, 0x621f001e},\n\t{0xffff, 0xffffffff}\n};\n\nstatic struct rtl8xxxu_rfregs rtl8xxxu_rfregs[] = {\n\t{\t/* RF_A */\n\t\t.hssiparm1 = REG_FPGA0_XA_HSSI_PARM1,\n\t\t.hssiparm2 = REG_FPGA0_XA_HSSI_PARM2,\n\t\t.lssiparm = REG_FPGA0_XA_LSSI_PARM,\n\t\t.hspiread = REG_HSPI_XA_READBACK,\n\t\t.lssiread = REG_FPGA0_XA_LSSI_READBACK,\n\t\t.rf_sw_ctrl = REG_FPGA0_XA_RF_SW_CTRL,\n\t},\n\t{\t/* RF_B */\n\t\t.hssiparm1 = REG_FPGA0_XB_HSSI_PARM1,\n\t\t.hssiparm2 = REG_FPGA0_XB_HSSI_PARM2,\n\t\t.lssiparm = REG_FPGA0_XB_LSSI_PARM,\n\t\t.hspiread = REG_HSPI_XB_READBACK,\n\t\t.lssiread = REG_FPGA0_XB_LSSI_READBACK,\n\t\t.rf_sw_ctrl = REG_FPGA0_XB_RF_SW_CTRL,\n\t},\n};\n\nconst u32 rtl8xxxu_iqk_phy_iq_bb_reg[RTL8XXXU_BB_REGS] = {\n\tREG_OFDM0_XA_RX_IQ_IMBALANCE,\n\tREG_OFDM0_XB_RX_IQ_IMBALANCE,\n\tREG_OFDM0_ENERGY_CCA_THRES,\n\tREG_OFDM0_AGCR_SSI_TABLE,\n\tREG_OFDM0_XA_TX_IQ_IMBALANCE,\n\tREG_OFDM0_XB_TX_IQ_IMBALANCE,\n\tREG_OFDM0_XC_TX_AFE,\n\tREG_OFDM0_XD_TX_AFE,\n\tREG_OFDM0_RX_IQ_EXT_ANTA\n};\n\nu8 rtl8xxxu_read8(struct rtl8xxxu_priv *priv, u16 addr)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint len;\n\tu8 data;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tlen = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_READ,\n\t\t\t      addr, 0, &priv->usb_buf.val8, sizeof(u8),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\tdata = priv->usb_buf.val8;\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_READ)\n\t\tdev_info(&udev->dev, \"%s(%04x)   = 0x%02x, len %i\\n\",\n\t\t\t __func__, addr, data, len);\n\treturn data;\n}\n\nu16 rtl8xxxu_read16(struct rtl8xxxu_priv *priv, u16 addr)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint len;\n\tu16 data;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tlen = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_READ,\n\t\t\t      addr, 0, &priv->usb_buf.val16, sizeof(u16),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\tdata = le16_to_cpu(priv->usb_buf.val16);\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_READ)\n\t\tdev_info(&udev->dev, \"%s(%04x)  = 0x%04x, len %i\\n\",\n\t\t\t __func__, addr, data, len);\n\treturn data;\n}\n\nu32 rtl8xxxu_read32(struct rtl8xxxu_priv *priv, u16 addr)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint len;\n\tu32 data;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tlen = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_READ,\n\t\t\t      addr, 0, &priv->usb_buf.val32, sizeof(u32),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\tdata = le32_to_cpu(priv->usb_buf.val32);\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_READ)\n\t\tdev_info(&udev->dev, \"%s(%04x)  = 0x%08x, len %i\\n\",\n\t\t\t __func__, addr, data, len);\n\treturn data;\n}\n\nint rtl8xxxu_write8(struct rtl8xxxu_priv *priv, u16 addr, u8 val)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint ret;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tpriv->usb_buf.val8 = val;\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\n\t\t\t      addr, 0, &priv->usb_buf.val8, sizeof(u8),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_WRITE)\n\t\tdev_info(&udev->dev, \"%s(%04x) = 0x%02x\\n\",\n\t\t\t __func__, addr, val);\n\treturn ret;\n}\n\nint rtl8xxxu_write16(struct rtl8xxxu_priv *priv, u16 addr, u16 val)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint ret;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tpriv->usb_buf.val16 = cpu_to_le16(val);\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\n\t\t\t      addr, 0, &priv->usb_buf.val16, sizeof(u16),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_WRITE)\n\t\tdev_info(&udev->dev, \"%s(%04x) = 0x%04x\\n\",\n\t\t\t __func__, addr, val);\n\treturn ret;\n}\n\nint rtl8xxxu_write32(struct rtl8xxxu_priv *priv, u16 addr, u32 val)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint ret;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tpriv->usb_buf.val32 = cpu_to_le32(val);\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\n\t\t\t      addr, 0, &priv->usb_buf.val32, sizeof(u32),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_WRITE)\n\t\tdev_info(&udev->dev, \"%s(%04x) = 0x%08x\\n\",\n\t\t\t __func__, addr, val);\n\treturn ret;\n}\n\nstatic int\nrtl8xxxu_writeN(struct rtl8xxxu_priv *priv, u16 addr, u8 *buf, u16 len)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint blocksize = priv->fops->writeN_block_size;\n\tint ret, i, count, remainder;\n\n\tcount = len / blocksize;\n\tremainder = len % blocksize;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\n\t\t\t\t      addr, 0, buf, blocksize,\n\t\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\t\tif (ret != blocksize)\n\t\t\tgoto write_error;\n\n\t\taddr += blocksize;\n\t\tbuf += blocksize;\n\t}\n\n\tif (remainder) {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\n\t\t\t\t      addr, 0, buf, remainder,\n\t\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\t\tif (ret != remainder)\n\t\t\tgoto write_error;\n\t}\n\n\treturn len;\n\nwrite_error:\n\tdev_info(&udev->dev,\n\t\t \"%s: Failed to write block at addr: %04x size: %04x\\n\",\n\t\t __func__, addr, blocksize);\n\treturn -EAGAIN;\n}\n\nu32 rtl8xxxu_read_rfreg(struct rtl8xxxu_priv *priv,\n\t\t\tenum rtl8xxxu_rfpath path, u8 reg)\n{\n\tu32 hssia, val32, retval;\n\n\thssia = rtl8xxxu_read32(priv, REG_FPGA0_XA_HSSI_PARM2);\n\tif (path != RF_A)\n\t\tval32 = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].hssiparm2);\n\telse\n\t\tval32 = hssia;\n\n\tval32 &= ~FPGA0_HSSI_PARM2_ADDR_MASK;\n\tval32 |= (reg << FPGA0_HSSI_PARM2_ADDR_SHIFT);\n\tval32 |= FPGA0_HSSI_PARM2_EDGE_READ;\n\thssia &= ~FPGA0_HSSI_PARM2_EDGE_READ;\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM2, hssia);\n\n\tudelay(10);\n\n\trtl8xxxu_write32(priv, rtl8xxxu_rfregs[path].hssiparm2, val32);\n\tudelay(100);\n\n\thssia |= FPGA0_HSSI_PARM2_EDGE_READ;\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM2, hssia);\n\tudelay(10);\n\n\tval32 = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].hssiparm1);\n\tif (val32 & FPGA0_HSSI_PARM1_PI)\n\t\tretval = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].hspiread);\n\telse\n\t\tretval = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].lssiread);\n\n\tretval &= 0xfffff;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_RFREG_READ)\n\t\tdev_info(&priv->udev->dev, \"%s(%02x) = 0x%06x\\n\",\n\t\t\t __func__, reg, retval);\n\treturn retval;\n}\n\n/*\n * The RTL8723BU driver indicates that registers 0xb2 and 0xb6 can\n * have write issues in high temperature conditions. We may have to\n * retry writing them.\n */\nint rtl8xxxu_write_rfreg(struct rtl8xxxu_priv *priv,\n\t\t\t enum rtl8xxxu_rfpath path, u8 reg, u32 data)\n{\n\tint ret, retval;\n\tu32 dataaddr, val32;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_RFREG_WRITE)\n\t\tdev_info(&priv->udev->dev, \"%s(%02x) = 0x%06x\\n\",\n\t\t\t __func__, reg, data);\n\n\tdata &= FPGA0_LSSI_PARM_DATA_MASK;\n\tdataaddr = (reg << FPGA0_LSSI_PARM_ADDR_SHIFT) | data;\n\n\tif (priv->rtl_chip == RTL8192E) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_POWER_SAVE);\n\t\tval32 &= ~0x20000;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_POWER_SAVE, val32);\n\t}\n\n\t/* Use XB for path B */\n\tret = rtl8xxxu_write32(priv, rtl8xxxu_rfregs[path].lssiparm, dataaddr);\n\tif (ret != sizeof(dataaddr))\n\t\tretval = -EIO;\n\telse\n\t\tretval = 0;\n\n\tudelay(1);\n\n\tif (priv->rtl_chip == RTL8192E) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_POWER_SAVE);\n\t\tval32 |= 0x20000;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_POWER_SAVE, val32);\n\t}\n\n\treturn retval;\n}\n\nstatic int\nrtl8xxxu_gen1_h2c_cmd(struct rtl8xxxu_priv *priv, struct h2c_cmd *h2c, int len)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint mbox_nr, retry, retval = 0;\n\tint mbox_reg, mbox_ext_reg;\n\tu8 val8;\n\n\tmutex_lock(&priv->h2c_mutex);\n\n\tmbox_nr = priv->next_mbox;\n\tmbox_reg = REG_HMBOX_0 + (mbox_nr * 4);\n\tmbox_ext_reg = REG_HMBOX_EXT_0 + (mbox_nr * 2);\n\n\t/*\n\t * MBOX ready?\n\t */\n\tretry = 100;\n\tdo {\n\t\tval8 = rtl8xxxu_read8(priv, REG_HMTFR);\n\t\tif (!(val8 & BIT(mbox_nr)))\n\t\t\tbreak;\n\t} while (retry--);\n\n\tif (!retry) {\n\t\tdev_info(dev, \"%s: Mailbox busy\\n\", __func__);\n\t\tretval = -EBUSY;\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Need to swap as it's being swapped again by rtl8xxxu_write16/32()\n\t */\n\tif (len > sizeof(u32)) {\n\t\trtl8xxxu_write16(priv, mbox_ext_reg, le16_to_cpu(h2c->raw.ext));\n\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_H2C)\n\t\t\tdev_info(dev, \"H2C_EXT %04x\\n\",\n\t\t\t\t le16_to_cpu(h2c->raw.ext));\n\t}\n\trtl8xxxu_write32(priv, mbox_reg, le32_to_cpu(h2c->raw.data));\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_H2C)\n\t\tdev_info(dev, \"H2C %08x\\n\", le32_to_cpu(h2c->raw.data));\n\n\tpriv->next_mbox = (mbox_nr + 1) % H2C_MAX_MBOX;\n\nerror:\n\tmutex_unlock(&priv->h2c_mutex);\n\treturn retval;\n}\n\nint\nrtl8xxxu_gen2_h2c_cmd(struct rtl8xxxu_priv *priv, struct h2c_cmd *h2c, int len)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint mbox_nr, retry, retval = 0;\n\tint mbox_reg, mbox_ext_reg;\n\tu8 val8;\n\n\tmutex_lock(&priv->h2c_mutex);\n\n\tmbox_nr = priv->next_mbox;\n\tmbox_reg = REG_HMBOX_0 + (mbox_nr * 4);\n\tmbox_ext_reg = REG_HMBOX_EXT0_8723B + (mbox_nr * 4);\n\n\t/*\n\t * MBOX ready?\n\t */\n\tretry = 100;\n\tdo {\n\t\tval8 = rtl8xxxu_read8(priv, REG_HMTFR);\n\t\tif (!(val8 & BIT(mbox_nr)))\n\t\t\tbreak;\n\t} while (retry--);\n\n\tif (!retry) {\n\t\tdev_info(dev, \"%s: Mailbox busy\\n\", __func__);\n\t\tretval = -EBUSY;\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Need to swap as it's being swapped again by rtl8xxxu_write16/32()\n\t */\n\tif (len > sizeof(u32)) {\n\t\trtl8xxxu_write32(priv, mbox_ext_reg,\n\t\t\t\t le32_to_cpu(h2c->raw_wide.ext));\n\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_H2C)\n\t\t\tdev_info(dev, \"H2C_EXT %08x\\n\",\n\t\t\t\t le32_to_cpu(h2c->raw_wide.ext));\n\t}\n\trtl8xxxu_write32(priv, mbox_reg, le32_to_cpu(h2c->raw.data));\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_H2C)\n\t\tdev_info(dev, \"H2C %08x\\n\", le32_to_cpu(h2c->raw.data));\n\n\tpriv->next_mbox = (mbox_nr + 1) % H2C_MAX_MBOX;\n\nerror:\n\tmutex_unlock(&priv->h2c_mutex);\n\treturn retval;\n}\n\nvoid rtl8xxxu_gen1_enable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu32 val32;\n\n\tval8 = rtl8xxxu_read8(priv, REG_SPS0_CTRL);\n\tval8 |= BIT(0) | BIT(3);\n\trtl8xxxu_write8(priv, REG_SPS0_CTRL, val8);\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XAB_RF_PARM);\n\tval32 &= ~(BIT(4) | BIT(5));\n\tval32 |= BIT(3);\n\tif (priv->rf_paths == 2) {\n\t\tval32 &= ~(BIT(20) | BIT(21));\n\t\tval32 |= BIT(19);\n\t}\n\trtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_PARM, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\tval32 &= ~OFDM_RF_PATH_TX_MASK;\n\tif (priv->tx_paths == 2)\n\t\tval32 |= OFDM_RF_PATH_TX_A | OFDM_RF_PATH_TX_B;\n\telse if (priv->rtl_chip == RTL8192C || priv->rtl_chip == RTL8191C)\n\t\tval32 |= OFDM_RF_PATH_TX_B;\n\telse\n\t\tval32 |= OFDM_RF_PATH_TX_A;\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\tval32 &= ~FPGA_RF_MODE_JAPAN;\n\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\tif (priv->rf_paths == 2)\n\t\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x63db25a0);\n\telse\n\t\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x631b25a0);\n\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, 0x32d95);\n\tif (priv->rf_paths == 2)\n\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC, 0x32d95);\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0x00);\n}\n\nvoid rtl8xxxu_gen1_disable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu8 sps0;\n\tu32 val32;\n\n\tsps0 = rtl8xxxu_read8(priv, REG_SPS0_CTRL);\n\n\t/* RF RX code for preamble power saving */\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XAB_RF_PARM);\n\tval32 &= ~(BIT(3) | BIT(4) | BIT(5));\n\tif (priv->rf_paths == 2)\n\t\tval32 &= ~(BIT(19) | BIT(20) | BIT(21));\n\trtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_PARM, val32);\n\n\t/* Disable TX for four paths */\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\tval32 &= ~OFDM_RF_PATH_TX_MASK;\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\t/* Enable power saving */\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\tval32 |= FPGA_RF_MODE_JAPAN;\n\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t/* AFE control register to power down bits [30:22] */\n\tif (priv->rf_paths == 2)\n\t\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x00db25a0);\n\telse\n\t\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x001b25a0);\n\n\t/* Power down RF module */\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, 0);\n\tif (priv->rf_paths == 2)\n\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC, 0);\n\n\tsps0 &= ~(BIT(0) | BIT(3));\n\trtl8xxxu_write8(priv, REG_SPS0_CTRL, sps0);\n}\n\nstatic void rtl8xxxu_stop_tx_beacon(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\n\tval8 = rtl8xxxu_read8(priv, REG_FWHW_TXQ_CTRL + 2);\n\tval8 &= ~BIT(6);\n\trtl8xxxu_write8(priv, REG_FWHW_TXQ_CTRL + 2, val8);\n\n\trtl8xxxu_write8(priv, REG_TBTT_PROHIBIT + 1, 0x64);\n\tval8 = rtl8xxxu_read8(priv, REG_TBTT_PROHIBIT + 2);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_TBTT_PROHIBIT + 2, val8);\n}\n\n\n/*\n * The rtl8723a has 3 channel groups for it's efuse settings. It only\n * supports the 2.4GHz band, so channels 1 - 14:\n *  group 0: channels 1 - 3\n *  group 1: channels 4 - 9\n *  group 2: channels 10 - 14\n *\n * Note: We index from 0 in the code\n */\nstatic int rtl8xxxu_gen1_channel_to_group(int channel)\n{\n\tint group;\n\n\tif (channel < 4)\n\t\tgroup = 0;\n\telse if (channel < 10)\n\t\tgroup = 1;\n\telse\n\t\tgroup = 2;\n\n\treturn group;\n}\n\n/*\n * Valid for rtl8723bu and rtl8192eu\n */\nint rtl8xxxu_gen2_channel_to_group(int channel)\n{\n\tint group;\n\n\tif (channel < 3)\n\t\tgroup = 0;\n\telse if (channel < 6)\n\t\tgroup = 1;\n\telse if (channel < 9)\n\t\tgroup = 2;\n\telse if (channel < 12)\n\t\tgroup = 3;\n\telse\n\t\tgroup = 4;\n\n\treturn group;\n}\n\nvoid rtl8xxxu_gen1_config_channel(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tu32 val32, rsr;\n\tu8 val8, opmode;\n\tbool ht = true;\n\tint sec_ch_above, channel;\n\tint i;\n\n\topmode = rtl8xxxu_read8(priv, REG_BW_OPMODE);\n\trsr = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\n\tchannel = hw->conf.chandef.chan->hw_value;\n\n\tswitch (hw->conf.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tht = false;\n\t\t/* fall through */\n\tcase NL80211_CHAN_WIDTH_20:\n\t\topmode |= BW_OPMODE_20MHZ;\n\t\trtl8xxxu_write8(priv, REG_BW_OPMODE, opmode);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tval32 &= ~FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\n\t\tval32 &= ~FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_ANALOG2);\n\t\tval32 |= FPGA0_ANALOG2_20MHZ;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_ANALOG2, val32);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (hw->conf.chandef.center_freq1 >\n\t\t    hw->conf.chandef.chan->center_freq) {\n\t\t\tsec_ch_above = 1;\n\t\t\tchannel += 2;\n\t\t} else {\n\t\t\tsec_ch_above = 0;\n\t\t\tchannel -= 2;\n\t\t}\n\n\t\topmode &= ~BW_OPMODE_20MHZ;\n\t\trtl8xxxu_write8(priv, REG_BW_OPMODE, opmode);\n\t\trsr &= ~RSR_RSC_BANDWIDTH_40M;\n\t\tif (sec_ch_above)\n\t\t\trsr |= RSR_RSC_UPPER_SUB_CHANNEL;\n\t\telse\n\t\t\trsr |= RSR_RSC_LOWER_SUB_CHANNEL;\n\t\trtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, rsr);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tval32 |= FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\n\t\tval32 |= FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\n\n\t\t/*\n\t\t * Set Control channel to upper or lower. These settings\n\t\t * are required only for 40MHz\n\t\t */\n\t\tval32 = rtl8xxxu_read32(priv, REG_CCK0_SYSTEM);\n\t\tval32 &= ~CCK0_SIDEBAND;\n\t\tif (!sec_ch_above)\n\t\t\tval32 |= CCK0_SIDEBAND;\n\t\trtl8xxxu_write32(priv, REG_CCK0_SYSTEM, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM1_LSTF);\n\t\tval32 &= ~OFDM_LSTF_PRIME_CH_MASK; /* 0xc00 */\n\t\tif (sec_ch_above)\n\t\t\tval32 |= OFDM_LSTF_PRIME_CH_LOW;\n\t\telse\n\t\t\tval32 |= OFDM_LSTF_PRIME_CH_HIGH;\n\t\trtl8xxxu_write32(priv, REG_OFDM1_LSTF, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_ANALOG2);\n\t\tval32 &= ~FPGA0_ANALOG2_20MHZ;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_ANALOG2, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_POWER_SAVE);\n\t\tval32 &= ~(FPGA0_PS_LOWER_CHANNEL | FPGA0_PS_UPPER_CHANNEL);\n\t\tif (sec_ch_above)\n\t\t\tval32 |= FPGA0_PS_UPPER_CHANNEL;\n\t\telse\n\t\t\tval32 |= FPGA0_PS_LOWER_CHANNEL;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_POWER_SAVE, val32);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = RF_A; i < priv->rf_paths; i++) {\n\t\tval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\n\t\tval32 &= ~MODE_AG_CHANNEL_MASK;\n\t\tval32 |= channel;\n\t\trtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\n\t}\n\n\tif (ht)\n\t\tval8 = 0x0e;\n\telse\n\t\tval8 = 0x0a;\n\n\trtl8xxxu_write8(priv, REG_SIFS_CCK + 1, val8);\n\trtl8xxxu_write8(priv, REG_SIFS_OFDM + 1, val8);\n\n\trtl8xxxu_write16(priv, REG_R2T_SIFS, 0x0808);\n\trtl8xxxu_write16(priv, REG_T2T_SIFS, 0x0a0a);\n\n\tfor (i = RF_A; i < priv->rf_paths; i++) {\n\t\tval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\n\t\tif (hw->conf.chandef.width == NL80211_CHAN_WIDTH_40)\n\t\t\tval32 &= ~MODE_AG_CHANNEL_20MHZ;\n\t\telse\n\t\t\tval32 |= MODE_AG_CHANNEL_20MHZ;\n\t\trtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\n\t}\n}\n\nvoid rtl8xxxu_gen2_config_channel(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tu32 val32, rsr;\n\tu8 val8, subchannel;\n\tu16 rf_mode_bw;\n\tbool ht = true;\n\tint sec_ch_above, channel;\n\tint i;\n\n\trf_mode_bw = rtl8xxxu_read16(priv, REG_WMAC_TRXPTCL_CTL);\n\trf_mode_bw &= ~WMAC_TRXPTCL_CTL_BW_MASK;\n\trsr = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\n\tchannel = hw->conf.chandef.chan->hw_value;\n\n/* Hack */\n\tsubchannel = 0;\n\n\tswitch (hw->conf.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tht = false;\n\t\t/* fall through */\n\tcase NL80211_CHAN_WIDTH_20:\n\t\trf_mode_bw |= WMAC_TRXPTCL_CTL_BW_20;\n\t\tsubchannel = 0;\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tval32 &= ~FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\n\t\tval32 &= ~FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT);\n\t\tval32 &= ~(BIT(30) | BIT(31));\n\t\trtl8xxxu_write32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT, val32);\n\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\trf_mode_bw |= WMAC_TRXPTCL_CTL_BW_40;\n\n\t\tif (hw->conf.chandef.center_freq1 >\n\t\t    hw->conf.chandef.chan->center_freq) {\n\t\t\tsec_ch_above = 1;\n\t\t\tchannel += 2;\n\t\t} else {\n\t\t\tsec_ch_above = 0;\n\t\t\tchannel -= 2;\n\t\t}\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tval32 |= FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\n\t\tval32 |= FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\n\n\t\t/*\n\t\t * Set Control channel to upper or lower. These settings\n\t\t * are required only for 40MHz\n\t\t */\n\t\tval32 = rtl8xxxu_read32(priv, REG_CCK0_SYSTEM);\n\t\tval32 &= ~CCK0_SIDEBAND;\n\t\tif (!sec_ch_above)\n\t\t\tval32 |= CCK0_SIDEBAND;\n\t\trtl8xxxu_write32(priv, REG_CCK0_SYSTEM, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM1_LSTF);\n\t\tval32 &= ~OFDM_LSTF_PRIME_CH_MASK; /* 0xc00 */\n\t\tif (sec_ch_above)\n\t\t\tval32 |= OFDM_LSTF_PRIME_CH_LOW;\n\t\telse\n\t\t\tval32 |= OFDM_LSTF_PRIME_CH_HIGH;\n\t\trtl8xxxu_write32(priv, REG_OFDM1_LSTF, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_POWER_SAVE);\n\t\tval32 &= ~(FPGA0_PS_LOWER_CHANNEL | FPGA0_PS_UPPER_CHANNEL);\n\t\tif (sec_ch_above)\n\t\t\tval32 |= FPGA0_PS_UPPER_CHANNEL;\n\t\telse\n\t\t\tval32 |= FPGA0_PS_LOWER_CHANNEL;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_POWER_SAVE, val32);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\trf_mode_bw |= WMAC_TRXPTCL_CTL_BW_80;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = RF_A; i < priv->rf_paths; i++) {\n\t\tval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\n\t\tval32 &= ~MODE_AG_CHANNEL_MASK;\n\t\tval32 |= channel;\n\t\trtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\n\t}\n\n\trtl8xxxu_write16(priv, REG_WMAC_TRXPTCL_CTL, rf_mode_bw);\n\trtl8xxxu_write8(priv, REG_DATA_SUBCHANNEL, subchannel);\n\n\tif (ht)\n\t\tval8 = 0x0e;\n\telse\n\t\tval8 = 0x0a;\n\n\trtl8xxxu_write8(priv, REG_SIFS_CCK + 1, val8);\n\trtl8xxxu_write8(priv, REG_SIFS_OFDM + 1, val8);\n\n\trtl8xxxu_write16(priv, REG_R2T_SIFS, 0x0808);\n\trtl8xxxu_write16(priv, REG_T2T_SIFS, 0x0a0a);\n\n\tfor (i = RF_A; i < priv->rf_paths; i++) {\n\t\tval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\n\t\tval32 &= ~MODE_AG_BW_MASK;\n\t\tswitch(hw->conf.chandef.width) {\n\t\tcase NL80211_CHAN_WIDTH_80:\n\t\t\tval32 |= MODE_AG_BW_80MHZ_8723B;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_40:\n\t\t\tval32 |= MODE_AG_BW_40MHZ_8723B;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval32 |= MODE_AG_BW_20MHZ_8723B;\n\t\t\tbreak;\n\t\t}\n\t\trtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\n\t}\n}\n\nvoid\nrtl8xxxu_gen1_set_tx_power(struct rtl8xxxu_priv *priv, int channel, bool ht40)\n{\n\tstruct rtl8xxxu_power_base *power_base = priv->power_base;\n\tu8 cck[RTL8723A_MAX_RF_PATHS], ofdm[RTL8723A_MAX_RF_PATHS];\n\tu8 ofdmbase[RTL8723A_MAX_RF_PATHS], mcsbase[RTL8723A_MAX_RF_PATHS];\n\tu32 val32, ofdm_a, ofdm_b, mcs_a, mcs_b;\n\tu8 val8;\n\tint group, i;\n\n\tgroup = rtl8xxxu_gen1_channel_to_group(channel);\n\n\tcck[0] = priv->cck_tx_power_index_A[group] - 1;\n\tcck[1] = priv->cck_tx_power_index_B[group] - 1;\n\n\tif (priv->hi_pa) {\n\t\tif (cck[0] > 0x20)\n\t\t\tcck[0] = 0x20;\n\t\tif (cck[1] > 0x20)\n\t\t\tcck[1] = 0x20;\n\t}\n\n\tofdm[0] = priv->ht40_1s_tx_power_index_A[group];\n\tofdm[1] = priv->ht40_1s_tx_power_index_B[group];\n\tif (ofdm[0])\n\t\tofdm[0] -= 1;\n\tif (ofdm[1])\n\t\tofdm[1] -= 1;\n\n\tofdmbase[0] = ofdm[0] +\tpriv->ofdm_tx_power_index_diff[group].a;\n\tofdmbase[1] = ofdm[1] +\tpriv->ofdm_tx_power_index_diff[group].b;\n\n\tmcsbase[0] = ofdm[0];\n\tmcsbase[1] = ofdm[1];\n\tif (!ht40) {\n\t\tmcsbase[0] += priv->ht20_tx_power_index_diff[group].a;\n\t\tmcsbase[1] += priv->ht20_tx_power_index_diff[group].b;\n\t}\n\n\tif (priv->tx_paths > 1) {\n\t\tif (ofdm[0] > priv->ht40_2s_tx_power_index_diff[group].a)\n\t\t\tofdm[0] -=  priv->ht40_2s_tx_power_index_diff[group].a;\n\t\tif (ofdm[1] > priv->ht40_2s_tx_power_index_diff[group].b)\n\t\t\tofdm[1] -=  priv->ht40_2s_tx_power_index_diff[group].b;\n\t}\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_CHANNEL)\n\t\tdev_info(&priv->udev->dev,\n\t\t\t \"%s: Setting TX power CCK A: %02x, \"\n\t\t\t \"CCK B: %02x, OFDM A: %02x, OFDM B: %02x\\n\",\n\t\t\t __func__, cck[0], cck[1], ofdm[0], ofdm[1]);\n\n\tfor (i = 0; i < RTL8723A_MAX_RF_PATHS; i++) {\n\t\tif (cck[i] > RF6052_MAX_TX_PWR)\n\t\t\tcck[i] = RF6052_MAX_TX_PWR;\n\t\tif (ofdm[i] > RF6052_MAX_TX_PWR)\n\t\t\tofdm[i] = RF6052_MAX_TX_PWR;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_A_CCK1_MCS32);\n\tval32 &= 0xffff00ff;\n\tval32 |= (cck[0] << 8);\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_CCK1_MCS32, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11);\n\tval32 &= 0xff;\n\tval32 |= ((cck[0] << 8) | (cck[0] << 16) | (cck[0] << 24));\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11);\n\tval32 &= 0xffffff00;\n\tval32 |= cck[1];\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK1_55_MCS32);\n\tval32 &= 0xff;\n\tval32 |= ((cck[1] << 8) | (cck[1] << 16) | (cck[1] << 24));\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_CCK1_55_MCS32, val32);\n\n\tofdm_a = ofdmbase[0] | ofdmbase[0] << 8 |\n\t\tofdmbase[0] << 16 | ofdmbase[0] << 24;\n\tofdm_b = ofdmbase[1] | ofdmbase[1] << 8 |\n\t\tofdmbase[1] << 16 | ofdmbase[1] << 24;\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_RATE18_06,\n\t\t\t ofdm_a + power_base->reg_0e00);\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_RATE18_06,\n\t\t\t ofdm_b + power_base->reg_0830);\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_RATE54_24,\n\t\t\t ofdm_a + power_base->reg_0e04);\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_RATE54_24,\n\t\t\t ofdm_b + power_base->reg_0834);\n\n\tmcs_a = mcsbase[0] | mcsbase[0] << 8 |\n\t\tmcsbase[0] << 16 | mcsbase[0] << 24;\n\tmcs_b = mcsbase[1] | mcsbase[1] << 8 |\n\t\tmcsbase[1] << 16 | mcsbase[1] << 24;\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS03_MCS00,\n\t\t\t mcs_a + power_base->reg_0e10);\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS03_MCS00,\n\t\t\t mcs_b + power_base->reg_083c);\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS07_MCS04,\n\t\t\t mcs_a + power_base->reg_0e14);\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS07_MCS04,\n\t\t\t mcs_b + power_base->reg_0848);\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS11_MCS08,\n\t\t\t mcs_a + power_base->reg_0e18);\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS11_MCS08,\n\t\t\t mcs_b + power_base->reg_084c);\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS15_MCS12,\n\t\t\t mcs_a + power_base->reg_0e1c);\n\tfor (i = 0; i < 3; i++) {\n\t\tif (i != 2)\n\t\t\tval8 = (mcsbase[0] > 8) ? (mcsbase[0] - 8) : 0;\n\t\telse\n\t\t\tval8 = (mcsbase[0] > 6) ? (mcsbase[0] - 6) : 0;\n\t\trtl8xxxu_write8(priv, REG_OFDM0_XC_TX_IQ_IMBALANCE + i, val8);\n\t}\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS15_MCS12,\n\t\t\t mcs_b + power_base->reg_0868);\n\tfor (i = 0; i < 3; i++) {\n\t\tif (i != 2)\n\t\t\tval8 = (mcsbase[1] > 8) ? (mcsbase[1] - 8) : 0;\n\t\telse\n\t\t\tval8 = (mcsbase[1] > 6) ? (mcsbase[1] - 6) : 0;\n\t\trtl8xxxu_write8(priv, REG_OFDM0_XD_TX_IQ_IMBALANCE + i, val8);\n\t}\n}\n\nstatic void rtl8xxxu_set_linktype(struct rtl8xxxu_priv *priv,\n\t\t\t\t  enum nl80211_iftype linktype)\n{\n\tu8 val8;\n\n\tval8 = rtl8xxxu_read8(priv, REG_MSR);\n\tval8 &= ~MSR_LINKTYPE_MASK;\n\n\tswitch (linktype) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\tval8 |= MSR_LINKTYPE_NONE;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tval8 |= MSR_LINKTYPE_ADHOC;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tval8 |= MSR_LINKTYPE_STATION;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tval8 |= MSR_LINKTYPE_AP;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\trtl8xxxu_write8(priv, REG_MSR, val8);\nout:\n\treturn;\n}\n\nstatic void\nrtl8xxxu_set_retry(struct rtl8xxxu_priv *priv, u16 short_retry, u16 long_retry)\n{\n\tu16 val16;\n\n\tval16 = ((short_retry << RETRY_LIMIT_SHORT_SHIFT) &\n\t\t RETRY_LIMIT_SHORT_MASK) |\n\t\t((long_retry << RETRY_LIMIT_LONG_SHIFT) &\n\t\t RETRY_LIMIT_LONG_MASK);\n\n\trtl8xxxu_write16(priv, REG_RETRY_LIMIT, val16);\n}\n\nstatic void\nrtl8xxxu_set_spec_sifs(struct rtl8xxxu_priv *priv, u16 cck, u16 ofdm)\n{\n\tu16 val16;\n\n\tval16 = ((cck << SPEC_SIFS_CCK_SHIFT) & SPEC_SIFS_CCK_MASK) |\n\t\t((ofdm << SPEC_SIFS_OFDM_SHIFT) & SPEC_SIFS_OFDM_MASK);\n\n\trtl8xxxu_write16(priv, REG_SPEC_SIFS, val16);\n}\n\nstatic void rtl8xxxu_print_chipinfo(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tchar *cut;\n\n\tswitch (priv->chip_cut) {\n\tcase 0:\n\t\tcut = \"A\";\n\t\tbreak;\n\tcase 1:\n\t\tcut = \"B\";\n\t\tbreak;\n\tcase 2:\n\t\tcut = \"C\";\n\t\tbreak;\n\tcase 3:\n\t\tcut = \"D\";\n\t\tbreak;\n\tcase 4:\n\t\tcut = \"E\";\n\t\tbreak;\n\tdefault:\n\t\tcut = \"unknown\";\n\t}\n\n\tdev_info(dev,\n\t\t \"RTL%s rev %s (%s) %iT%iR, TX queues %i, WiFi=%i, BT=%i, GPS=%i, HI PA=%i\\n\",\n\t\t priv->chip_name, cut, priv->chip_vendor, priv->tx_paths,\n\t\t priv->rx_paths, priv->ep_tx_count, priv->has_wifi,\n\t\t priv->has_bluetooth, priv->has_gps, priv->hi_pa);\n\n\tdev_info(dev, \"RTL%s MAC: %pM\\n\", priv->chip_name, priv->mac_addr);\n}\n\nstatic int rtl8xxxu_identify_chip(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 val32, bonding;\n\tu16 val16;\n\n\tval32 = rtl8xxxu_read32(priv, REG_SYS_CFG);\n\tpriv->chip_cut = (val32 & SYS_CFG_CHIP_VERSION_MASK) >>\n\t\tSYS_CFG_CHIP_VERSION_SHIFT;\n\tif (val32 & SYS_CFG_TRP_VAUX_EN) {\n\t\tdev_info(dev, \"Unsupported test chip\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (val32 & SYS_CFG_BT_FUNC) {\n\t\tif (priv->chip_cut >= 3) {\n\t\t\tsprintf(priv->chip_name, \"8723BU\");\n\t\t\tpriv->rtl_chip = RTL8723B;\n\t\t} else {\n\t\t\tsprintf(priv->chip_name, \"8723AU\");\n\t\t\tpriv->usb_interrupts = 1;\n\t\t\tpriv->rtl_chip = RTL8723A;\n\t\t}\n\n\t\tpriv->rf_paths = 1;\n\t\tpriv->rx_paths = 1;\n\t\tpriv->tx_paths = 1;\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_MULTI_FUNC_CTRL);\n\t\tif (val32 & MULTI_WIFI_FUNC_EN)\n\t\t\tpriv->has_wifi = 1;\n\t\tif (val32 & MULTI_BT_FUNC_EN)\n\t\t\tpriv->has_bluetooth = 1;\n\t\tif (val32 & MULTI_GPS_FUNC_EN)\n\t\t\tpriv->has_gps = 1;\n\t\tpriv->is_multi_func = 1;\n\t} else if (val32 & SYS_CFG_TYPE_ID) {\n\t\tbonding = rtl8xxxu_read32(priv, REG_HPON_FSM);\n\t\tbonding &= HPON_FSM_BONDING_MASK;\n\t\tif (priv->fops->tx_desc_size ==\n\t\t    sizeof(struct rtl8xxxu_txdesc40)) {\n\t\t\tif (bonding == HPON_FSM_BONDING_1T2R) {\n\t\t\t\tsprintf(priv->chip_name, \"8191EU\");\n\t\t\t\tpriv->rf_paths = 2;\n\t\t\t\tpriv->rx_paths = 2;\n\t\t\t\tpriv->tx_paths = 1;\n\t\t\t\tpriv->rtl_chip = RTL8191E;\n\t\t\t} else {\n\t\t\t\tsprintf(priv->chip_name, \"8192EU\");\n\t\t\t\tpriv->rf_paths = 2;\n\t\t\t\tpriv->rx_paths = 2;\n\t\t\t\tpriv->tx_paths = 2;\n\t\t\t\tpriv->rtl_chip = RTL8192E;\n\t\t\t}\n\t\t} else if (bonding == HPON_FSM_BONDING_1T2R) {\n\t\t\tsprintf(priv->chip_name, \"8191CU\");\n\t\t\tpriv->rf_paths = 2;\n\t\t\tpriv->rx_paths = 2;\n\t\t\tpriv->tx_paths = 1;\n\t\t\tpriv->usb_interrupts = 1;\n\t\t\tpriv->rtl_chip = RTL8191C;\n\t\t} else {\n\t\t\tsprintf(priv->chip_name, \"8192CU\");\n\t\t\tpriv->rf_paths = 2;\n\t\t\tpriv->rx_paths = 2;\n\t\t\tpriv->tx_paths = 2;\n\t\t\tpriv->usb_interrupts = 1;\n\t\t\tpriv->rtl_chip = RTL8192C;\n\t\t}\n\t\tpriv->has_wifi = 1;\n\t} else {\n\t\tsprintf(priv->chip_name, \"8188CU\");\n\t\tpriv->rf_paths = 1;\n\t\tpriv->rx_paths = 1;\n\t\tpriv->tx_paths = 1;\n\t\tpriv->rtl_chip = RTL8188C;\n\t\tpriv->usb_interrupts = 1;\n\t\tpriv->has_wifi = 1;\n\t}\n\n\tswitch (priv->rtl_chip) {\n\tcase RTL8188E:\n\tcase RTL8192E:\n\tcase RTL8723B:\n\t\tswitch (val32 & SYS_CFG_VENDOR_EXT_MASK) {\n\t\tcase SYS_CFG_VENDOR_ID_TSMC:\n\t\t\tsprintf(priv->chip_vendor, \"TSMC\");\n\t\t\tbreak;\n\t\tcase SYS_CFG_VENDOR_ID_SMIC:\n\t\t\tsprintf(priv->chip_vendor, \"SMIC\");\n\t\t\tpriv->vendor_smic = 1;\n\t\t\tbreak;\n\t\tcase SYS_CFG_VENDOR_ID_UMC:\n\t\t\tsprintf(priv->chip_vendor, \"UMC\");\n\t\t\tpriv->vendor_umc = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(priv->chip_vendor, \"unknown\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (val32 & SYS_CFG_VENDOR_ID) {\n\t\t\tsprintf(priv->chip_vendor, \"UMC\");\n\t\t\tpriv->vendor_umc = 1;\n\t\t} else {\n\t\t\tsprintf(priv->chip_vendor, \"TSMC\");\n\t\t}\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_GPIO_OUTSTS);\n\tpriv->rom_rev = (val32 & GPIO_RF_RL_ID) >> 28;\n\n\tval16 = rtl8xxxu_read16(priv, REG_NORMAL_SIE_EP_TX);\n\tif (val16 & NORMAL_SIE_EP_TX_HIGH_MASK) {\n\t\tpriv->ep_tx_high_queue = 1;\n\t\tpriv->ep_tx_count++;\n\t}\n\n\tif (val16 & NORMAL_SIE_EP_TX_NORMAL_MASK) {\n\t\tpriv->ep_tx_normal_queue = 1;\n\t\tpriv->ep_tx_count++;\n\t}\n\n\tif (val16 & NORMAL_SIE_EP_TX_LOW_MASK) {\n\t\tpriv->ep_tx_low_queue = 1;\n\t\tpriv->ep_tx_count++;\n\t}\n\n\t/*\n\t * Fallback for devices that do not provide REG_NORMAL_SIE_EP_TX\n\t */\n\tif (!priv->ep_tx_count) {\n\t\tswitch (priv->nr_out_eps) {\n\t\tcase 4:\n\t\tcase 3:\n\t\t\tpriv->ep_tx_low_queue = 1;\n\t\t\tpriv->ep_tx_count++;\n\t\t\t/* fall through */\n\t\tcase 2:\n\t\t\tpriv->ep_tx_normal_queue = 1;\n\t\t\tpriv->ep_tx_count++;\n\t\t\t/* fall through */\n\t\tcase 1:\n\t\t\tpriv->ep_tx_high_queue = 1;\n\t\t\tpriv->ep_tx_count++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(dev, \"Unsupported USB TX end-points\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nrtl8xxxu_read_efuse8(struct rtl8xxxu_priv *priv, u16 offset, u8 *data)\n{\n\tint i;\n\tu8 val8;\n\tu32 val32;\n\n\t/* Write Address */\n\trtl8xxxu_write8(priv, REG_EFUSE_CTRL + 1, offset & 0xff);\n\tval8 = rtl8xxxu_read8(priv, REG_EFUSE_CTRL + 2);\n\tval8 &= 0xfc;\n\tval8 |= (offset >> 8) & 0x03;\n\trtl8xxxu_write8(priv, REG_EFUSE_CTRL + 2, val8);\n\n\tval8 = rtl8xxxu_read8(priv, REG_EFUSE_CTRL + 3);\n\trtl8xxxu_write8(priv, REG_EFUSE_CTRL + 3, val8 & 0x7f);\n\n\t/* Poll for data read */\n\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\n\tfor (i = 0; i < RTL8XXXU_MAX_REG_POLL; i++) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\n\t\tif (val32 & BIT(31))\n\t\t\tbreak;\n\t}\n\n\tif (i == RTL8XXXU_MAX_REG_POLL)\n\t\treturn -EIO;\n\n\tudelay(50);\n\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\n\n\t*data = val32 & 0xff;\n\treturn 0;\n}\n\nstatic int rtl8xxxu_read_efuse(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint i, ret = 0;\n\tu8 val8, word_mask, header, extheader;\n\tu16 val16, efuse_addr, offset;\n\tu32 val32;\n\n\tval16 = rtl8xxxu_read16(priv, REG_9346CR);\n\tif (val16 & EEPROM_ENABLE)\n\t\tpriv->has_eeprom = 1;\n\tif (val16 & EEPROM_BOOT)\n\t\tpriv->boot_eeprom = 1;\n\n\tif (priv->is_multi_func) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_TEST);\n\t\tval32 = (val32 & ~EFUSE_SELECT_MASK) | EFUSE_WIFI_SELECT;\n\t\trtl8xxxu_write32(priv, REG_EFUSE_TEST, val32);\n\t}\n\n\tdev_dbg(dev, \"Booting from %s\\n\",\n\t\tpriv->boot_eeprom ? \"EEPROM\" : \"EFUSE\");\n\n\trtl8xxxu_write8(priv, REG_EFUSE_ACCESS, EFUSE_ACCESS_ENABLE);\n\n\t/*  1.2V Power: From VDDON with Power Cut(0x0000[15]), default valid */\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_ISO_CTRL);\n\tif (!(val16 & SYS_ISO_PWC_EV12V)) {\n\t\tval16 |= SYS_ISO_PWC_EV12V;\n\t\trtl8xxxu_write16(priv, REG_SYS_ISO_CTRL, val16);\n\t}\n\t/*  Reset: 0x0000[28], default valid */\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tif (!(val16 & SYS_FUNC_ELDR)) {\n\t\tval16 |= SYS_FUNC_ELDR;\n\t\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\t}\n\n\t/*\n\t * Clock: Gated(0x0008[5]) 8M(0x0008[1]) clock from ANA, default valid\n\t */\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_CLKR);\n\tif (!(val16 & SYS_CLK_LOADER_ENABLE) || !(val16 & SYS_CLK_ANA8M)) {\n\t\tval16 |= (SYS_CLK_LOADER_ENABLE | SYS_CLK_ANA8M);\n\t\trtl8xxxu_write16(priv, REG_SYS_CLKR, val16);\n\t}\n\n\t/* Default value is 0xff */\n\tmemset(priv->efuse_wifi.raw, 0xff, EFUSE_MAP_LEN);\n\n\tefuse_addr = 0;\n\twhile (efuse_addr < EFUSE_REAL_CONTENT_LEN_8723A) {\n\t\tu16 map_addr;\n\n\t\tret = rtl8xxxu_read_efuse8(priv, efuse_addr++, &header);\n\t\tif (ret || header == 0xff)\n\t\t\tgoto exit;\n\n\t\tif ((header & 0x1f) == 0x0f) {\t/* extended header */\n\t\t\toffset = (header & 0xe0) >> 5;\n\n\t\t\tret = rtl8xxxu_read_efuse8(priv, efuse_addr++,\n\t\t\t\t\t\t   &extheader);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t\t/* All words disabled */\n\t\t\tif ((extheader & 0x0f) == 0x0f)\n\t\t\t\tcontinue;\n\n\t\t\toffset |= ((extheader & 0xf0) >> 1);\n\t\t\tword_mask = extheader & 0x0f;\n\t\t} else {\n\t\t\toffset = (header >> 4) & 0x0f;\n\t\t\tword_mask = header & 0x0f;\n\t\t}\n\n\t\t/* Get word enable value from PG header */\n\n\t\t/* We have 8 bits to indicate validity */\n\t\tmap_addr = offset * 8;\n\t\tif (map_addr >= EFUSE_MAP_LEN) {\n\t\t\tdev_warn(dev, \"%s: Illegal map_addr (%04x), \"\n\t\t\t\t \"efuse corrupt!\\n\",\n\t\t\t\t __func__, map_addr);\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t\tfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\n\t\t\t/* Check word enable condition in the section */\n\t\t\tif (word_mask & BIT(i)) {\n\t\t\t\tmap_addr += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = rtl8xxxu_read_efuse8(priv, efuse_addr++, &val8);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t\tpriv->efuse_wifi.raw[map_addr++] = val8;\n\n\t\t\tret = rtl8xxxu_read_efuse8(priv, efuse_addr++, &val8);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t\tpriv->efuse_wifi.raw[map_addr++] = val8;\n\t\t}\n\t}\n\nexit:\n\trtl8xxxu_write8(priv, REG_EFUSE_ACCESS, EFUSE_ACCESS_DISABLE);\n\n\treturn ret;\n}\n\nvoid rtl8xxxu_reset_8051(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu16 sys_func;\n\n\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\n\n\tsys_func = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tsys_func &= ~SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, sys_func);\n\n\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\n\n\tsys_func |= SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, sys_func);\n}\n\nstatic int rtl8xxxu_start_firmware(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint ret = 0, i;\n\tu32 val32;\n\n\t/* Poll checksum report */\n\tfor (i = 0; i < RTL8XXXU_FIRMWARE_POLL_MAX; i++) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\n\t\tif (val32 & MCU_FW_DL_CSUM_REPORT)\n\t\t\tbreak;\n\t}\n\n\tif (i == RTL8XXXU_FIRMWARE_POLL_MAX) {\n\t\tdev_warn(dev, \"Firmware checksum poll timed out\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto exit;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\n\tval32 |= MCU_FW_DL_READY;\n\tval32 &= ~MCU_WINT_INIT_READY;\n\trtl8xxxu_write32(priv, REG_MCU_FW_DL, val32);\n\n\t/*\n\t * Reset the 8051 in order for the firmware to start running,\n\t * otherwise it won't come up on the 8192eu\n\t */\n\tpriv->fops->reset_8051(priv);\n\n\t/* Wait for firmware to become ready */\n\tfor (i = 0; i < RTL8XXXU_FIRMWARE_POLL_MAX; i++) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\n\t\tif (val32 & MCU_WINT_INIT_READY)\n\t\t\tbreak;\n\n\t\tudelay(100);\n\t}\n\n\tif (i == RTL8XXXU_FIRMWARE_POLL_MAX) {\n\t\tdev_warn(dev, \"Firmware failed to start\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * Init H2C command\n\t */\n\tif (priv->rtl_chip == RTL8723B)\n\t\trtl8xxxu_write8(priv, REG_HMTFR, 0x0f);\nexit:\n\treturn ret;\n}\n\nstatic int rtl8xxxu_download_firmware(struct rtl8xxxu_priv *priv)\n{\n\tint pages, remainder, i, ret;\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\tu8 *fwptr;\n\n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC + 1);\n\tval8 |= 4;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC + 1, val8);\n\n\t/* 8051 enable */\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tval16 |= SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\n\tval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL);\n\tif (val8 & MCU_FW_RAM_SEL) {\n\t\tpr_info(\"do the RAM reset\\n\");\n\t\trtl8xxxu_write8(priv, REG_MCU_FW_DL, 0x00);\n\t\tpriv->fops->reset_8051(priv);\n\t}\n\n\t/* MCU firmware download enable */\n\tval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL);\n\tval8 |= MCU_FW_DL_ENABLE;\n\trtl8xxxu_write8(priv, REG_MCU_FW_DL, val8);\n\n\t/* 8051 reset */\n\tval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\n\tval32 &= ~BIT(19);\n\trtl8xxxu_write32(priv, REG_MCU_FW_DL, val32);\n\n\t/* Reset firmware download checksum */\n\tval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL);\n\tval8 |= MCU_FW_DL_CSUM_REPORT;\n\trtl8xxxu_write8(priv, REG_MCU_FW_DL, val8);\n\n\tpages = priv->fw_size / RTL_FW_PAGE_SIZE;\n\tremainder = priv->fw_size % RTL_FW_PAGE_SIZE;\n\n\tfwptr = priv->fw_data->data;\n\n\tfor (i = 0; i < pages; i++) {\n\t\tval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL + 2) & 0xF8;\n\t\tval8 |= i;\n\t\trtl8xxxu_write8(priv, REG_MCU_FW_DL + 2, val8);\n\n\t\tret = rtl8xxxu_writeN(priv, REG_FW_START_ADDRESS,\n\t\t\t\t      fwptr, RTL_FW_PAGE_SIZE);\n\t\tif (ret != RTL_FW_PAGE_SIZE) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto fw_abort;\n\t\t}\n\n\t\tfwptr += RTL_FW_PAGE_SIZE;\n\t}\n\n\tif (remainder) {\n\t\tval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL + 2) & 0xF8;\n\t\tval8 |= i;\n\t\trtl8xxxu_write8(priv, REG_MCU_FW_DL + 2, val8);\n\t\tret = rtl8xxxu_writeN(priv, REG_FW_START_ADDRESS,\n\t\t\t\t      fwptr, remainder);\n\t\tif (ret != remainder) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto fw_abort;\n\t\t}\n\t}\n\n\tret = 0;\nfw_abort:\n\t/* MCU firmware download disable */\n\tval16 = rtl8xxxu_read16(priv, REG_MCU_FW_DL);\n\tval16 &= ~MCU_FW_DL_ENABLE;\n\trtl8xxxu_write16(priv, REG_MCU_FW_DL, val16);\n\n\treturn ret;\n}\n\nint rtl8xxxu_load_firmware(struct rtl8xxxu_priv *priv, char *fw_name)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tconst struct firmware *fw;\n\tint ret = 0;\n\tu16 signature;\n\n\tdev_info(dev, \"%s: Loading firmware %s\\n\", DRIVER_NAME, fw_name);\n\tif (request_firmware(&fw, fw_name, &priv->udev->dev)) {\n\t\tdev_warn(dev, \"request_firmware(%s) failed\\n\", fw_name);\n\t\tret = -EAGAIN;\n\t\tgoto exit;\n\t}\n\tif (!fw) {\n\t\tdev_warn(dev, \"Firmware data not available\\n\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tpriv->fw_data = kmemdup(fw->data, fw->size, GFP_KERNEL);\n\tif (!priv->fw_data) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tpriv->fw_size = fw->size - sizeof(struct rtl8xxxu_firmware_header);\n\n\tsignature = le16_to_cpu(priv->fw_data->signature);\n\tswitch (signature & 0xfff0) {\n\tcase 0x92e0:\n\tcase 0x92c0:\n\tcase 0x88c0:\n\tcase 0x5300:\n\tcase 0x2300:\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_warn(dev, \"%s: Invalid firmware signature: 0x%04x\\n\",\n\t\t\t __func__, signature);\n\t}\n\n\tdev_info(dev, \"Firmware revision %i.%i (signature 0x%04x)\\n\",\n\t\t le16_to_cpu(priv->fw_data->major_version),\n\t\t priv->fw_data->minor_version, signature);\n\nexit:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nvoid rtl8xxxu_firmware_self_reset(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16;\n\tint i = 100;\n\n\t/* Inform 8051 to perform reset */\n\trtl8xxxu_write8(priv, REG_HMTFR + 3, 0x20);\n\n\tfor (i = 100; i > 0; i--) {\n\t\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\n\t\tif (!(val16 & SYS_FUNC_CPU_ENABLE)) {\n\t\t\tdev_dbg(&priv->udev->dev,\n\t\t\t\t\"%s: Firmware self reset success!\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(50);\n\t}\n\n\tif (!i) {\n\t\t/* Force firmware reset */\n\t\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\t\tval16 &= ~SYS_FUNC_CPU_ENABLE;\n\t\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\t}\n}\n\nstatic int\nrtl8xxxu_init_mac(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8xxxu_reg8val *array = priv->fops->mactable;\n\tint i, ret;\n\tu16 reg;\n\tu8 val;\n\n\tfor (i = 0; ; i++) {\n\t\treg = array[i].reg;\n\t\tval = array[i].val;\n\n\t\tif (reg == 0xffff && val == 0xff)\n\t\t\tbreak;\n\n\t\tret = rtl8xxxu_write8(priv, reg, val);\n\t\tif (ret != 1) {\n\t\t\tdev_warn(&priv->udev->dev,\n\t\t\t\t \"Failed to initialize MAC \"\n\t\t\t\t \"(reg: %04x, val %02x)\\n\", reg, val);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tif (priv->rtl_chip != RTL8723B && priv->rtl_chip != RTL8192E)\n\t\trtl8xxxu_write8(priv, REG_MAX_AGGR_NUM, 0x0a);\n\n\treturn 0;\n}\n\nint rtl8xxxu_init_phy_regs(struct rtl8xxxu_priv *priv,\n\t\t\t   struct rtl8xxxu_reg32val *array)\n{\n\tint i, ret;\n\tu16 reg;\n\tu32 val;\n\n\tfor (i = 0; ; i++) {\n\t\treg = array[i].reg;\n\t\tval = array[i].val;\n\n\t\tif (reg == 0xffff && val == 0xffffffff)\n\t\t\tbreak;\n\n\t\tret = rtl8xxxu_write32(priv, reg, val);\n\t\tif (ret != sizeof(val)) {\n\t\t\tdev_warn(&priv->udev->dev,\n\t\t\t\t \"Failed to initialize PHY\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\nvoid rtl8xxxu_gen1_init_phy_bb(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8, ldoa15, ldov12d, lpldo, ldohci12;\n\tu16 val16;\n\tu32 val32;\n\n\tval8 = rtl8xxxu_read8(priv, REG_AFE_PLL_CTRL);\n\tudelay(2);\n\tval8 |= AFE_PLL_320_ENABLE;\n\trtl8xxxu_write8(priv, REG_AFE_PLL_CTRL, val8);\n\tudelay(2);\n\n\trtl8xxxu_write8(priv, REG_AFE_PLL_CTRL + 1, 0xff);\n\tudelay(2);\n\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tval16 |= SYS_FUNC_BB_GLB_RSTN | SYS_FUNC_BBRSTB;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\n\tval32 = rtl8xxxu_read32(priv, REG_AFE_XTAL_CTRL);\n\tval32 &= ~AFE_XTAL_RF_GATE;\n\tif (priv->has_bluetooth)\n\t\tval32 &= ~AFE_XTAL_BT_GATE;\n\trtl8xxxu_write32(priv, REG_AFE_XTAL_CTRL, val32);\n\n\t/* 6. 0x1f[7:0] = 0x07 */\n\tval8 = RF_ENABLE | RF_RSTB | RF_SDMRSTB;\n\trtl8xxxu_write8(priv, REG_RF_CTRL, val8);\n\n\tif (priv->hi_pa)\n\t\trtl8xxxu_init_phy_regs(priv, rtl8188ru_phy_1t_highpa_table);\n\telse if (priv->tx_paths == 2)\n\t\trtl8xxxu_init_phy_regs(priv, rtl8192cu_phy_2t_init_table);\n\telse\n\t\trtl8xxxu_init_phy_regs(priv, rtl8723a_phy_1t_init_table);\n\n\tif (priv->rtl_chip == RTL8188R && priv->hi_pa &&\n\t    priv->vendor_umc && priv->chip_cut == 1)\n\t\trtl8xxxu_write8(priv, REG_OFDM0_AGC_PARM1 + 2, 0x50);\n\n\tif (priv->hi_pa)\n\t\trtl8xxxu_init_phy_regs(priv, rtl8xxx_agc_highpa_table);\n\telse\n\t\trtl8xxxu_init_phy_regs(priv, rtl8xxx_agc_standard_table);\n\n\tldoa15 = LDOA15_ENABLE | LDOA15_OBUF;\n\tldov12d = LDOV12D_ENABLE | BIT(2) | (2 << LDOV12D_VADJ_SHIFT);\n\tldohci12 = 0x57;\n\tlpldo = 1;\n\tval32 = (lpldo << 24) | (ldohci12 << 16) | (ldov12d << 8) | ldoa15;\n\trtl8xxxu_write32(priv, REG_LDOA15_CTRL, val32);\n}\n\n/*\n * Most of this is black magic retrieved from the old rtl8723au driver\n */\nstatic int rtl8xxxu_init_phy_bb(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu32 val32;\n\n\tpriv->fops->init_phy_bb(priv);\n\n\tif (priv->tx_paths == 1 && priv->rx_paths == 2) {\n\t\t/*\n\t\t * For 1T2R boards, patch the registers.\n\t\t *\n\t\t * It looks like 8191/2 1T2R boards use path B for TX\n\t\t */\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_TX_INFO);\n\t\tval32 &= ~(BIT(0) | BIT(1));\n\t\tval32 |= BIT(1);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_TX_INFO, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_TX_INFO);\n\t\tval32 &= ~0x300033;\n\t\tval32 |= 0x200022;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_TX_INFO, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_CCK0_AFE_SETTING);\n\t\tval32 &= ~CCK0_AFE_RX_MASK;\n\t\tval32 &= 0x00ffffff;\n\t\tval32 |= 0x40000000;\n\t\tval32 |= CCK0_AFE_RX_ANT_B;\n\t\trtl8xxxu_write32(priv, REG_CCK0_AFE_SETTING, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\t\tval32 &= ~(OFDM_RF_PATH_RX_MASK | OFDM_RF_PATH_TX_MASK);\n\t\tval32 |= (OFDM_RF_PATH_RX_A | OFDM_RF_PATH_RX_B |\n\t\t\t  OFDM_RF_PATH_TX_B);\n\t\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_AGC_PARM1);\n\t\tval32 &= ~(BIT(4) | BIT(5));\n\t\tval32 |= BIT(4);\n\t\trtl8xxxu_write32(priv, REG_OFDM0_AGC_PARM1, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_CCK_RFON);\n\t\tval32 &= ~(BIT(27) | BIT(26));\n\t\tval32 |= BIT(27);\n\t\trtl8xxxu_write32(priv, REG_TX_CCK_RFON, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_CCK_BBON);\n\t\tval32 &= ~(BIT(27) | BIT(26));\n\t\tval32 |= BIT(27);\n\t\trtl8xxxu_write32(priv, REG_TX_CCK_BBON, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_OFDM_RFON);\n\t\tval32 &= ~(BIT(27) | BIT(26));\n\t\tval32 |= BIT(27);\n\t\trtl8xxxu_write32(priv, REG_TX_OFDM_RFON, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_OFDM_BBON);\n\t\tval32 &= ~(BIT(27) | BIT(26));\n\t\tval32 |= BIT(27);\n\t\trtl8xxxu_write32(priv, REG_TX_OFDM_BBON, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_TO_TX);\n\t\tval32 &= ~(BIT(27) | BIT(26));\n\t\tval32 |= BIT(27);\n\t\trtl8xxxu_write32(priv, REG_TX_TO_TX, val32);\n\t}\n\n\tif (priv->has_xtalk) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_MAC_PHY_CTRL);\n\n\t\tval8 = priv->xtalk;\n\t\tval32 &= 0xff000fff;\n\t\tval32 |= ((val8 | (val8 << 6)) << 12);\n\n\t\trtl8xxxu_write32(priv, REG_MAC_PHY_CTRL, val32);\n\t}\n\n\tif (priv->rtl_chip == RTL8192E)\n\t\trtl8xxxu_write32(priv, REG_AFE_XTAL_CTRL, 0x000f81fb);\n\n\treturn 0;\n}\n\nstatic int rtl8xxxu_init_rf_regs(struct rtl8xxxu_priv *priv,\n\t\t\t\t struct rtl8xxxu_rfregval *array,\n\t\t\t\t enum rtl8xxxu_rfpath path)\n{\n\tint i, ret;\n\tu8 reg;\n\tu32 val;\n\n\tfor (i = 0; ; i++) {\n\t\treg = array[i].reg;\n\t\tval = array[i].val;\n\n\t\tif (reg == 0xff && val == 0xffffffff)\n\t\t\tbreak;\n\n\t\tswitch (reg) {\n\t\tcase 0xfe:\n\t\t\tmsleep(50);\n\t\t\tcontinue;\n\t\tcase 0xfd:\n\t\t\tmdelay(5);\n\t\t\tcontinue;\n\t\tcase 0xfc:\n\t\t\tmdelay(1);\n\t\t\tcontinue;\n\t\tcase 0xfb:\n\t\t\tudelay(50);\n\t\t\tcontinue;\n\t\tcase 0xfa:\n\t\t\tudelay(5);\n\t\t\tcontinue;\n\t\tcase 0xf9:\n\t\t\tudelay(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = rtl8xxxu_write_rfreg(priv, path, reg, val);\n\t\tif (ret) {\n\t\t\tdev_warn(&priv->udev->dev,\n\t\t\t\t \"Failed to initialize RF\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\nint rtl8xxxu_init_phy_rf(struct rtl8xxxu_priv *priv,\n\t\t\t struct rtl8xxxu_rfregval *table,\n\t\t\t enum rtl8xxxu_rfpath path)\n{\n\tu32 val32;\n\tu16 val16, rfsi_rfenv;\n\tu16 reg_sw_ctrl, reg_int_oe, reg_hssi_parm2;\n\n\tswitch (path) {\n\tcase RF_A:\n\t\treg_sw_ctrl = REG_FPGA0_XA_RF_SW_CTRL;\n\t\treg_int_oe = REG_FPGA0_XA_RF_INT_OE;\n\t\treg_hssi_parm2 = REG_FPGA0_XA_HSSI_PARM2;\n\t\tbreak;\n\tcase RF_B:\n\t\treg_sw_ctrl = REG_FPGA0_XB_RF_SW_CTRL;\n\t\treg_int_oe = REG_FPGA0_XB_RF_INT_OE;\n\t\treg_hssi_parm2 = REG_FPGA0_XB_HSSI_PARM2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&priv->udev->dev, \"%s:Unsupported RF path %c\\n\",\n\t\t\t__func__, path + 'A');\n\t\treturn -EINVAL;\n\t}\n\t/* For path B, use XB */\n\trfsi_rfenv = rtl8xxxu_read16(priv, reg_sw_ctrl);\n\trfsi_rfenv &= FPGA0_RF_RFENV;\n\n\t/*\n\t * These two we might be able to optimize into one\n\t */\n\tval32 = rtl8xxxu_read32(priv, reg_int_oe);\n\tval32 |= BIT(20);\t/* 0x10 << 16 */\n\trtl8xxxu_write32(priv, reg_int_oe, val32);\n\tudelay(1);\n\n\tval32 = rtl8xxxu_read32(priv, reg_int_oe);\n\tval32 |= BIT(4);\n\trtl8xxxu_write32(priv, reg_int_oe, val32);\n\tudelay(1);\n\n\t/*\n\t * These two we might be able to optimize into one\n\t */\n\tval32 = rtl8xxxu_read32(priv, reg_hssi_parm2);\n\tval32 &= ~FPGA0_HSSI_3WIRE_ADDR_LEN;\n\trtl8xxxu_write32(priv, reg_hssi_parm2, val32);\n\tudelay(1);\n\n\tval32 = rtl8xxxu_read32(priv, reg_hssi_parm2);\n\tval32 &= ~FPGA0_HSSI_3WIRE_DATA_LEN;\n\trtl8xxxu_write32(priv, reg_hssi_parm2, val32);\n\tudelay(1);\n\n\trtl8xxxu_init_rf_regs(priv, table, path);\n\n\t/* For path B, use XB */\n\tval16 = rtl8xxxu_read16(priv, reg_sw_ctrl);\n\tval16 &= ~FPGA0_RF_RFENV;\n\tval16 |= rfsi_rfenv;\n\trtl8xxxu_write16(priv, reg_sw_ctrl, val16);\n\n\treturn 0;\n}\n\nstatic int rtl8xxxu_llt_write(struct rtl8xxxu_priv *priv, u8 address, u8 data)\n{\n\tint ret = -EBUSY;\n\tint count = 0;\n\tu32 value;\n\n\tvalue = LLT_OP_WRITE | address << 8 | data;\n\n\trtl8xxxu_write32(priv, REG_LLT_INIT, value);\n\n\tdo {\n\t\tvalue = rtl8xxxu_read32(priv, REG_LLT_INIT);\n\t\tif ((value & LLT_OP_MASK) == LLT_OP_INACTIVE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (count++ < 20);\n\n\treturn ret;\n}\n\nint rtl8xxxu_init_llt_table(struct rtl8xxxu_priv *priv)\n{\n\tint ret;\n\tint i;\n\tu8 last_tx_page;\n\n\tlast_tx_page = priv->fops->total_page_num;\n\n\tfor (i = 0; i < last_tx_page; i++) {\n\t\tret = rtl8xxxu_llt_write(priv, i, i + 1);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tret = rtl8xxxu_llt_write(priv, last_tx_page, 0xff);\n\tif (ret)\n\t\tgoto exit;\n\n\t/* Mark remaining pages as a ring buffer */\n\tfor (i = last_tx_page + 1; i < 0xff; i++) {\n\t\tret = rtl8xxxu_llt_write(priv, i, (i + 1));\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\t/*  Let last entry point to the start entry of ring buffer */\n\tret = rtl8xxxu_llt_write(priv, 0xff, last_tx_page + 1);\n\tif (ret)\n\t\tgoto exit;\n\nexit:\n\treturn ret;\n}\n\nint rtl8xxxu_auto_llt_table(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\tint ret = 0;\n\tint i;\n\n\tval32 = rtl8xxxu_read32(priv, REG_AUTO_LLT);\n\tval32 |= AUTO_LLT_INIT_LLT;\n\trtl8xxxu_write32(priv, REG_AUTO_LLT, val32);\n\n\tfor (i = 500; i; i--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_AUTO_LLT);\n\t\tif (!(val32 & AUTO_LLT_INIT_LLT))\n\t\t\tbreak;\n\t\tusleep_range(2, 4);\n\t}\n\n\tif (!i) {\n\t\tret = -EBUSY;\n\t\tdev_warn(&priv->udev->dev, \"LLT table init failed\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int rtl8xxxu_init_queue_priority(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16, hi, lo;\n\tu16 hiq, mgq, bkq, beq, viq, voq;\n\tint hip, mgp, bkp, bep, vip, vop;\n\tint ret = 0;\n\n\tswitch (priv->ep_tx_count) {\n\tcase 1:\n\t\tif (priv->ep_tx_high_queue) {\n\t\t\thi = TRXDMA_QUEUE_HIGH;\n\t\t} else if (priv->ep_tx_low_queue) {\n\t\t\thi = TRXDMA_QUEUE_LOW;\n\t\t} else if (priv->ep_tx_normal_queue) {\n\t\t\thi = TRXDMA_QUEUE_NORMAL;\n\t\t} else {\n\t\t\thi = 0;\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\thiq = hi;\n\t\tmgq = hi;\n\t\tbkq = hi;\n\t\tbeq = hi;\n\t\tviq = hi;\n\t\tvoq = hi;\n\n\t\thip = 0;\n\t\tmgp = 0;\n\t\tbkp = 0;\n\t\tbep = 0;\n\t\tvip = 0;\n\t\tvop = 0;\n\t\tbreak;\n\tcase 2:\n\t\tif (priv->ep_tx_high_queue && priv->ep_tx_low_queue) {\n\t\t\thi = TRXDMA_QUEUE_HIGH;\n\t\t\tlo = TRXDMA_QUEUE_LOW;\n\t\t} else if (priv->ep_tx_normal_queue && priv->ep_tx_low_queue) {\n\t\t\thi = TRXDMA_QUEUE_NORMAL;\n\t\t\tlo = TRXDMA_QUEUE_LOW;\n\t\t} else if (priv->ep_tx_high_queue && priv->ep_tx_normal_queue) {\n\t\t\thi = TRXDMA_QUEUE_HIGH;\n\t\t\tlo = TRXDMA_QUEUE_NORMAL;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\thi = 0;\n\t\t\tlo = 0;\n\t\t}\n\n\t\thiq = hi;\n\t\tmgq = hi;\n\t\tbkq = lo;\n\t\tbeq = lo;\n\t\tviq = hi;\n\t\tvoq = hi;\n\n\t\thip = 0;\n\t\tmgp = 0;\n\t\tbkp = 1;\n\t\tbep = 1;\n\t\tvip = 0;\n\t\tvop = 0;\n\t\tbreak;\n\tcase 3:\n\t\tbeq = TRXDMA_QUEUE_LOW;\n\t\tbkq = TRXDMA_QUEUE_LOW;\n\t\tviq = TRXDMA_QUEUE_NORMAL;\n\t\tvoq = TRXDMA_QUEUE_HIGH;\n\t\tmgq = TRXDMA_QUEUE_HIGH;\n\t\thiq = TRXDMA_QUEUE_HIGH;\n\n\t\thip = hiq ^ 3;\n\t\tmgp = mgq ^ 3;\n\t\tbkp = bkq ^ 3;\n\t\tbep = beq ^ 3;\n\t\tvip = viq ^ 3;\n\t\tvop = viq ^ 3;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * None of the vendor drivers are configuring the beacon\n\t * queue here .... why?\n\t */\n\tif (!ret) {\n\t\tval16 = rtl8xxxu_read16(priv, REG_TRXDMA_CTRL);\n\t\tval16 &= 0x7;\n\t\tval16 |= (voq << TRXDMA_CTRL_VOQ_SHIFT) |\n\t\t\t(viq << TRXDMA_CTRL_VIQ_SHIFT) |\n\t\t\t(beq << TRXDMA_CTRL_BEQ_SHIFT) |\n\t\t\t(bkq << TRXDMA_CTRL_BKQ_SHIFT) |\n\t\t\t(mgq << TRXDMA_CTRL_MGQ_SHIFT) |\n\t\t\t(hiq << TRXDMA_CTRL_HIQ_SHIFT);\n\t\trtl8xxxu_write16(priv, REG_TRXDMA_CTRL, val16);\n\n\t\tpriv->pipe_out[TXDESC_QUEUE_VO] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[vop]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_VI] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[vip]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_BE] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[bep]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_BK] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[bkp]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_BEACON] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[0]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_MGNT] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[mgp]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_HIGH] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[hip]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_CMD] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[0]);\n\t}\n\n\treturn ret;\n}\n\nvoid rtl8xxxu_fill_iqk_matrix_a(struct rtl8xxxu_priv *priv, bool iqk_ok,\n\t\t\t\tint result[][8], int candidate, bool tx_only)\n{\n\tu32 oldval, x, tx0_a, reg;\n\tint y, tx0_c;\n\tu32 val32;\n\n\tif (!iqk_ok)\n\t\treturn;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE);\n\toldval = val32 >> 22;\n\n\tx = result[candidate][0];\n\tif ((x & 0x00000200) != 0)\n\t\tx = x | 0xfffffc00;\n\ttx0_a = (x * oldval) >> 8;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE);\n\tval32 &= ~0x3ff;\n\tval32 |= tx0_a;\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\n\tval32 &= ~BIT(31);\n\tif ((x * oldval >> 7) & 0x1)\n\t\tval32 |= BIT(31);\n\trtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\n\n\ty = result[candidate][1];\n\tif ((y & 0x00000200) != 0)\n\t\ty = y | 0xfffffc00;\n\ttx0_c = (y * oldval) >> 8;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XC_TX_AFE);\n\tval32 &= ~0xf0000000;\n\tval32 |= (((tx0_c & 0x3c0) >> 6) << 28);\n\trtl8xxxu_write32(priv, REG_OFDM0_XC_TX_AFE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE);\n\tval32 &= ~0x003f0000;\n\tval32 |= ((tx0_c & 0x3f) << 16);\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\n\tval32 &= ~BIT(29);\n\tif ((y * oldval >> 7) & 0x1)\n\t\tval32 |= BIT(29);\n\trtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\n\n\tif (tx_only) {\n\t\tdev_dbg(&priv->udev->dev, \"%s: only TX\\n\", __func__);\n\t\treturn;\n\t}\n\n\treg = result[candidate][2];\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE);\n\tval32 &= ~0x3ff;\n\tval32 |= (reg & 0x3ff);\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE, val32);\n\n\treg = result[candidate][3] & 0x3F;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE);\n\tval32 &= ~0xfc00;\n\tval32 |= ((reg << 10) & 0xfc00);\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE, val32);\n\n\treg = (result[candidate][3] >> 6) & 0xF;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_RX_IQ_EXT_ANTA);\n\tval32 &= ~0xf0000000;\n\tval32 |= (reg << 28);\n\trtl8xxxu_write32(priv, REG_OFDM0_RX_IQ_EXT_ANTA, val32);\n}\n\nvoid rtl8xxxu_fill_iqk_matrix_b(struct rtl8xxxu_priv *priv, bool iqk_ok,\n\t\t\t\tint result[][8], int candidate, bool tx_only)\n{\n\tu32 oldval, x, tx1_a, reg;\n\tint y, tx1_c;\n\tu32 val32;\n\n\tif (!iqk_ok)\n\t\treturn;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE);\n\toldval = val32 >> 22;\n\n\tx = result[candidate][4];\n\tif ((x & 0x00000200) != 0)\n\t\tx = x | 0xfffffc00;\n\ttx1_a = (x * oldval) >> 8;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE);\n\tval32 &= ~0x3ff;\n\tval32 |= tx1_a;\n\trtl8xxxu_write32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\n\tval32 &= ~BIT(27);\n\tif ((x * oldval >> 7) & 0x1)\n\t\tval32 |= BIT(27);\n\trtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\n\n\ty = result[candidate][5];\n\tif ((y & 0x00000200) != 0)\n\t\ty = y | 0xfffffc00;\n\ttx1_c = (y * oldval) >> 8;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XD_TX_AFE);\n\tval32 &= ~0xf0000000;\n\tval32 |= (((tx1_c & 0x3c0) >> 6) << 28);\n\trtl8xxxu_write32(priv, REG_OFDM0_XD_TX_AFE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE);\n\tval32 &= ~0x003f0000;\n\tval32 |= ((tx1_c & 0x3f) << 16);\n\trtl8xxxu_write32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\n\tval32 &= ~BIT(25);\n\tif ((y * oldval >> 7) & 0x1)\n\t\tval32 |= BIT(25);\n\trtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\n\n\tif (tx_only) {\n\t\tdev_dbg(&priv->udev->dev, \"%s: only TX\\n\", __func__);\n\t\treturn;\n\t}\n\n\treg = result[candidate][6];\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE);\n\tval32 &= ~0x3ff;\n\tval32 |= (reg & 0x3ff);\n\trtl8xxxu_write32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE, val32);\n\n\treg = result[candidate][7] & 0x3f;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE);\n\tval32 &= ~0xfc00;\n\tval32 |= ((reg << 10) & 0xfc00);\n\trtl8xxxu_write32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE, val32);\n\n\treg = (result[candidate][7] >> 6) & 0xf;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_AGCR_SSI_TABLE);\n\tval32 &= ~0x0000f000;\n\tval32 |= (reg << 12);\n\trtl8xxxu_write32(priv, REG_OFDM0_AGCR_SSI_TABLE, val32);\n}\n\n#define MAX_TOLERANCE\t\t5\n\nstatic bool rtl8xxxu_simularity_compare(struct rtl8xxxu_priv *priv,\n\t\t\t\t\tint result[][8], int c1, int c2)\n{\n\tu32 i, j, diff, simubitmap, bound = 0;\n\tint candidate[2] = {-1, -1};\t/* for path A and path B */\n\tbool retval = true;\n\n\tif (priv->tx_paths > 1)\n\t\tbound = 8;\n\telse\n\t\tbound = 4;\n\n\tsimubitmap = 0;\n\n\tfor (i = 0; i < bound; i++) {\n\t\tdiff = (result[c1][i] > result[c2][i]) ?\n\t\t\t(result[c1][i] - result[c2][i]) :\n\t\t\t(result[c2][i] - result[c1][i]);\n\t\tif (diff > MAX_TOLERANCE) {\n\t\t\tif ((i == 2 || i == 6) && !simubitmap) {\n\t\t\t\tif (result[c1][i] + result[c1][i + 1] == 0)\n\t\t\t\t\tcandidate[(i / 4)] = c2;\n\t\t\t\telse if (result[c2][i] + result[c2][i + 1] == 0)\n\t\t\t\t\tcandidate[(i / 4)] = c1;\n\t\t\t\telse\n\t\t\t\t\tsimubitmap = simubitmap | (1 << i);\n\t\t\t} else {\n\t\t\t\tsimubitmap = simubitmap | (1 << i);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (simubitmap == 0) {\n\t\tfor (i = 0; i < (bound / 4); i++) {\n\t\t\tif (candidate[i] >= 0) {\n\t\t\t\tfor (j = i * 4; j < (i + 1) * 4 - 2; j++)\n\t\t\t\t\tresult[3][j] = result[candidate[i]][j];\n\t\t\t\tretval = false;\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t} else if (!(simubitmap & 0x0f)) {\n\t\t/* path A OK */\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tresult[3][i] = result[c1][i];\n\t} else if (!(simubitmap & 0xf0) && priv->tx_paths > 1) {\n\t\t/* path B OK */\n\t\tfor (i = 4; i < 8; i++)\n\t\t\tresult[3][i] = result[c1][i];\n\t}\n\n\treturn false;\n}\n\nbool rtl8xxxu_gen2_simularity_compare(struct rtl8xxxu_priv *priv,\n\t\t\t\t      int result[][8], int c1, int c2)\n{\n\tu32 i, j, diff, simubitmap, bound = 0;\n\tint candidate[2] = {-1, -1};\t/* for path A and path B */\n\tint tmp1, tmp2;\n\tbool retval = true;\n\n\tif (priv->tx_paths > 1)\n\t\tbound = 8;\n\telse\n\t\tbound = 4;\n\n\tsimubitmap = 0;\n\n\tfor (i = 0; i < bound; i++) {\n\t\tif (i & 1) {\n\t\t\tif ((result[c1][i] & 0x00000200))\n\t\t\t\ttmp1 = result[c1][i] | 0xfffffc00;\n\t\t\telse\n\t\t\t\ttmp1 = result[c1][i];\n\n\t\t\tif ((result[c2][i]& 0x00000200))\n\t\t\t\ttmp2 = result[c2][i] | 0xfffffc00;\n\t\t\telse\n\t\t\t\ttmp2 = result[c2][i];\n\t\t} else {\n\t\t\ttmp1 = result[c1][i];\n\t\t\ttmp2 = result[c2][i];\n\t\t}\n\n\t\tdiff = (tmp1 > tmp2) ? (tmp1 - tmp2) : (tmp2 - tmp1);\n\n\t\tif (diff > MAX_TOLERANCE) {\n\t\t\tif ((i == 2 || i == 6) && !simubitmap) {\n\t\t\t\tif (result[c1][i] + result[c1][i + 1] == 0)\n\t\t\t\t\tcandidate[(i / 4)] = c2;\n\t\t\t\telse if (result[c2][i] + result[c2][i + 1] == 0)\n\t\t\t\t\tcandidate[(i / 4)] = c1;\n\t\t\t\telse\n\t\t\t\t\tsimubitmap = simubitmap | (1 << i);\n\t\t\t} else {\n\t\t\t\tsimubitmap = simubitmap | (1 << i);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (simubitmap == 0) {\n\t\tfor (i = 0; i < (bound / 4); i++) {\n\t\t\tif (candidate[i] >= 0) {\n\t\t\t\tfor (j = i * 4; j < (i + 1) * 4 - 2; j++)\n\t\t\t\t\tresult[3][j] = result[candidate[i]][j];\n\t\t\t\tretval = false;\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t} else {\n\t\tif (!(simubitmap & 0x03)) {\n\t\t\t/* path A TX OK */\n\t\t\tfor (i = 0; i < 2; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\n\t\tif (!(simubitmap & 0x0c)) {\n\t\t\t/* path A RX OK */\n\t\t\tfor (i = 2; i < 4; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\n\t\tif (!(simubitmap & 0x30) && priv->tx_paths > 1) {\n\t\t\t/* path B RX OK */\n\t\t\tfor (i = 4; i < 6; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\n\t\tif (!(simubitmap & 0x30) && priv->tx_paths > 1) {\n\t\t\t/* path B RX OK */\n\t\t\tfor (i = 6; i < 8; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid\nrtl8xxxu_save_mac_regs(struct rtl8xxxu_priv *priv, const u32 *reg, u32 *backup)\n{\n\tint i;\n\n\tfor (i = 0; i < (RTL8XXXU_MAC_REGS - 1); i++)\n\t\tbackup[i] = rtl8xxxu_read8(priv, reg[i]);\n\n\tbackup[i] = rtl8xxxu_read32(priv, reg[i]);\n}\n\nvoid rtl8xxxu_restore_mac_regs(struct rtl8xxxu_priv *priv,\n\t\t\t       const u32 *reg, u32 *backup)\n{\n\tint i;\n\n\tfor (i = 0; i < (RTL8XXXU_MAC_REGS - 1); i++)\n\t\trtl8xxxu_write8(priv, reg[i], backup[i]);\n\n\trtl8xxxu_write32(priv, reg[i], backup[i]);\n}\n\nvoid rtl8xxxu_save_regs(struct rtl8xxxu_priv *priv, const u32 *regs,\n\t\t\tu32 *backup, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tbackup[i] = rtl8xxxu_read32(priv, regs[i]);\n}\n\nvoid rtl8xxxu_restore_regs(struct rtl8xxxu_priv *priv, const u32 *regs,\n\t\t\t   u32 *backup, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\trtl8xxxu_write32(priv, regs[i], backup[i]);\n}\n\n\nvoid rtl8xxxu_path_adda_on(struct rtl8xxxu_priv *priv, const u32 *regs,\n\t\t\t   bool path_a_on)\n{\n\tu32 path_on;\n\tint i;\n\n\tif (priv->tx_paths == 1) {\n\t\tpath_on = priv->fops->adda_1t_path_on;\n\t\trtl8xxxu_write32(priv, regs[0], priv->fops->adda_1t_init);\n\t} else {\n\t\tpath_on = path_a_on ? priv->fops->adda_2t_path_on_a :\n\t\t\tpriv->fops->adda_2t_path_on_b;\n\n\t\trtl8xxxu_write32(priv, regs[0], path_on);\n\t}\n\n\tfor (i = 1 ; i < RTL8XXXU_ADDA_REGS ; i++)\n\t\trtl8xxxu_write32(priv, regs[i], path_on);\n}\n\nvoid rtl8xxxu_mac_calibration(struct rtl8xxxu_priv *priv,\n\t\t\t      const u32 *regs, u32 *backup)\n{\n\tint i = 0;\n\n\trtl8xxxu_write8(priv, regs[i], 0x3f);\n\n\tfor (i = 1 ; i < (RTL8XXXU_MAC_REGS - 1); i++)\n\t\trtl8xxxu_write8(priv, regs[i], (u8)(backup[i] & ~BIT(3)));\n\n\trtl8xxxu_write8(priv, regs[i], (u8)(backup[i] & ~BIT(5)));\n}\n\nstatic int rtl8xxxu_iqk_path_a(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_eac, reg_e94, reg_e9c, reg_ea4, val32;\n\tint result = 0;\n\n\t/* path-A IQK setting */\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x10008c1f);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x10008c1f);\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x82140102);\n\n\tval32 = (priv->rf_paths > 1) ? 0x28160202 :\n\t\t/*IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID)?0x28160202: */\n\t\t0x28160502;\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, val32);\n\n\t/* path-B IQK setting */\n\tif (priv->rf_paths > 1) {\n\t\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x10008c22);\n\t\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x10008c22);\n\t\trtl8xxxu_write32(priv, REG_TX_IQK_PI_B, 0x82140102);\n\t\trtl8xxxu_write32(priv, REG_RX_IQK_PI_B, 0x28160202);\n\t}\n\n\t/* LO calibration setting */\n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x001028d1);\n\n\t/* One shot, path A LOK & IQK */\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf9000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(1);\n\n\t/* Check failed */\n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_e94 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\treg_e9c = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\treg_ea4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_A_2);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    ((reg_e94 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_e9c & 0x03ff0000) != 0x00420000))\n\t\tresult |= 0x01;\n\telse\t/* If TX not OK, ignore RX */\n\t\tgoto out;\n\n\t/* If TX is OK, check whether RX is OK */\n\tif (!(reg_eac & BIT(27)) &&\n\t    ((reg_ea4 & 0x03ff0000) != 0x01320000) &&\n\t    ((reg_eac & 0x03ff0000) != 0x00360000))\n\t\tresult |= 0x02;\n\telse\n\t\tdev_warn(&priv->udev->dev, \"%s: Path A RX IQK failed!\\n\",\n\t\t\t __func__);\nout:\n\treturn result;\n}\n\nstatic int rtl8xxxu_iqk_path_b(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_eac, reg_eb4, reg_ebc, reg_ec4, reg_ecc;\n\tint result = 0;\n\n\t/* One shot, path B LOK & IQK */\n\trtl8xxxu_write32(priv, REG_IQK_AGC_CONT, 0x00000002);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_CONT, 0x00000000);\n\n\tmdelay(1);\n\n\t/* Check failed */\n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_eb4 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\treg_ebc = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\treg_ec4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_B_2);\n\treg_ecc = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_B_2);\n\n\tif (!(reg_eac & BIT(31)) &&\n\t    ((reg_eb4 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_ebc & 0x03ff0000) != 0x00420000))\n\t\tresult |= 0x01;\n\telse\n\t\tgoto out;\n\n\tif (!(reg_eac & BIT(30)) &&\n\t    (((reg_ec4 & 0x03ff0000) >> 16) != 0x132) &&\n\t    (((reg_ecc & 0x03ff0000) >> 16) != 0x36))\n\t\tresult |= 0x02;\n\telse\n\t\tdev_warn(&priv->udev->dev, \"%s: Path B RX IQK failed!\\n\",\n\t\t\t __func__);\nout:\n\treturn result;\n}\n\nstatic void rtl8xxxu_phy_iqcalibrate(struct rtl8xxxu_priv *priv,\n\t\t\t\t     int result[][8], int t)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 i, val32;\n\tint path_a_ok, path_b_ok;\n\tint retry = 2;\n\tconst u32 adda_regs[RTL8XXXU_ADDA_REGS] = {\n\t\tREG_FPGA0_XCD_SWITCH_CTRL, REG_BLUETOOTH,\n\t\tREG_RX_WAIT_CCA, REG_TX_CCK_RFON,\n\t\tREG_TX_CCK_BBON, REG_TX_OFDM_RFON,\n\t\tREG_TX_OFDM_BBON, REG_TX_TO_RX,\n\t\tREG_TX_TO_TX, REG_RX_CCK,\n\t\tREG_RX_OFDM, REG_RX_WAIT_RIFS,\n\t\tREG_RX_TO_RX, REG_STANDBY,\n\t\tREG_SLEEP, REG_PMPD_ANAEN\n\t};\n\tconst u32 iqk_mac_regs[RTL8XXXU_MAC_REGS] = {\n\t\tREG_TXPAUSE, REG_BEACON_CTRL,\n\t\tREG_BEACON_CTRL_1, REG_GPIO_MUXCFG\n\t};\n\tconst u32 iqk_bb_regs[RTL8XXXU_BB_REGS] = {\n\t\tREG_OFDM0_TRX_PATH_ENABLE, REG_OFDM0_TR_MUX_PAR,\n\t\tREG_FPGA0_XCD_RF_SW_CTRL, REG_CONFIG_ANT_A, REG_CONFIG_ANT_B,\n\t\tREG_FPGA0_XAB_RF_SW_CTRL, REG_FPGA0_XA_RF_INT_OE,\n\t\tREG_FPGA0_XB_RF_INT_OE, REG_FPGA0_RF_MODE\n\t};\n\n\t/*\n\t * Note: IQ calibration must be performed after loading\n\t *       PHY_REG.txt , and radio_a, radio_b.txt\n\t */\n\n\tif (t == 0) {\n\t\t/* Save ADDA parameters, turn Path A ADDA on */\n\t\trtl8xxxu_save_regs(priv, adda_regs, priv->adda_backup,\n\t\t\t\t   RTL8XXXU_ADDA_REGS);\n\t\trtl8xxxu_save_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\t\trtl8xxxu_save_regs(priv, iqk_bb_regs,\n\t\t\t\t   priv->bb_backup, RTL8XXXU_BB_REGS);\n\t}\n\n\trtl8xxxu_path_adda_on(priv, adda_regs, true);\n\n\tif (t == 0) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XA_HSSI_PARM1);\n\t\tif (val32 & FPGA0_HSSI_PARM1_PI)\n\t\t\tpriv->pi_enabled = 1;\n\t}\n\n\tif (!priv->pi_enabled) {\n\t\t/* Switch BB to PI mode to do IQ Calibration. */\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000100);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XB_HSSI_PARM1, 0x01000100);\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\tval32 &= ~FPGA_RF_MODE_CCK;\n\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x03a05600);\n\trtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000800e4);\n\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x22204000);\n\n\tif (!priv->no_pape) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XAB_RF_SW_CTRL);\n\t\tval32 |= (FPGA0_RF_PAPE |\n\t\t\t  (FPGA0_RF_PAPE << FPGA0_RF_BD_CTRL_SHIFT));\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_SW_CTRL, val32);\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XA_RF_INT_OE);\n\tval32 &= ~BIT(10);\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_RF_INT_OE, val32);\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XB_RF_INT_OE);\n\tval32 &= ~BIT(10);\n\trtl8xxxu_write32(priv, REG_FPGA0_XB_RF_INT_OE, val32);\n\n\tif (priv->tx_paths > 1) {\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_LSSI_PARM, 0x00010000);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XB_LSSI_PARM, 0x00010000);\n\t}\n\n\t/* MAC settings */\n\trtl8xxxu_mac_calibration(priv, iqk_mac_regs, priv->mac_backup);\n\n\t/* Page B init */\n\trtl8xxxu_write32(priv, REG_CONFIG_ANT_A, 0x00080000);\n\n\tif (priv->tx_paths > 1)\n\t\trtl8xxxu_write32(priv, REG_CONFIG_ANT_B, 0x00080000);\n\n\t/* IQ calibration setting */\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\tfor (i = 0; i < retry; i++) {\n\t\tpath_a_ok = rtl8xxxu_iqk_path_a(priv);\n\t\tif (path_a_ok == 0x03) {\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_BEFORE_IQK_A);\n\t\t\tresult[t][0] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_AFTER_IQK_A);\n\t\t\tresult[t][1] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_RX_POWER_BEFORE_IQK_A_2);\n\t\t\tresult[t][2] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_RX_POWER_AFTER_IQK_A_2);\n\t\t\tresult[t][3] = (val32 >> 16) & 0x3ff;\n\t\t\tbreak;\n\t\t} else if (i == (retry - 1) && path_a_ok == 0x01) {\n\t\t\t/* TX IQK OK */\n\t\t\tdev_dbg(dev, \"%s: Path A IQK Only Tx Success!!\\n\",\n\t\t\t\t__func__);\n\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_BEFORE_IQK_A);\n\t\t\tresult[t][0] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_AFTER_IQK_A);\n\t\t\tresult[t][1] = (val32 >> 16) & 0x3ff;\n\t\t}\n\t}\n\n\tif (!path_a_ok)\n\t\tdev_dbg(dev, \"%s: Path A IQK failed!\\n\", __func__);\n\n\tif (priv->tx_paths > 1) {\n\t\t/*\n\t\t * Path A into standby\n\t\t */\n\t\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x0);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_LSSI_PARM, 0x00010000);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\n\t\t/* Turn Path B ADDA on */\n\t\trtl8xxxu_path_adda_on(priv, adda_regs, false);\n\n\t\tfor (i = 0; i < retry; i++) {\n\t\t\tpath_b_ok = rtl8xxxu_iqk_path_b(priv);\n\t\t\tif (path_b_ok == 0x03) {\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\t\t\t\tresult[t][4] = (val32 >> 16) & 0x3ff;\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\t\t\t\tresult[t][5] = (val32 >> 16) & 0x3ff;\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_B_2);\n\t\t\t\tresult[t][6] = (val32 >> 16) & 0x3ff;\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_B_2);\n\t\t\t\tresult[t][7] = (val32 >> 16) & 0x3ff;\n\t\t\t\tbreak;\n\t\t\t} else if (i == (retry - 1) && path_b_ok == 0x01) {\n\t\t\t\t/* TX IQK OK */\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\t\t\t\tresult[t][4] = (val32 >> 16) & 0x3ff;\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\t\t\t\tresult[t][5] = (val32 >> 16) & 0x3ff;\n\t\t\t}\n\t\t}\n\n\t\tif (!path_b_ok)\n\t\t\tdev_dbg(dev, \"%s: Path B IQK failed!\\n\", __func__);\n\t}\n\n\t/* Back to BB mode, load original value */\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0);\n\n\tif (t) {\n\t\tif (!priv->pi_enabled) {\n\t\t\t/*\n\t\t\t * Switch back BB to SI mode after finishing\n\t\t\t * IQ Calibration\n\t\t\t */\n\t\t\tval32 = 0x01000000;\n\t\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, val32);\n\t\t\trtl8xxxu_write32(priv, REG_FPGA0_XB_HSSI_PARM1, val32);\n\t\t}\n\n\t\t/* Reload ADDA power saving parameters */\n\t\trtl8xxxu_restore_regs(priv, adda_regs, priv->adda_backup,\n\t\t\t\t      RTL8XXXU_ADDA_REGS);\n\n\t\t/* Reload MAC parameters */\n\t\trtl8xxxu_restore_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\n\t\t/* Reload BB parameters */\n\t\trtl8xxxu_restore_regs(priv, iqk_bb_regs,\n\t\t\t\t      priv->bb_backup, RTL8XXXU_BB_REGS);\n\n\t\t/* Restore RX initial gain */\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_LSSI_PARM, 0x00032ed3);\n\n\t\tif (priv->tx_paths > 1) {\n\t\t\trtl8xxxu_write32(priv, REG_FPGA0_XB_LSSI_PARM,\n\t\t\t\t\t 0x00032ed3);\n\t\t}\n\n\t\t/* Load 0xe30 IQC default value */\n\t\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x01008c00);\n\t\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x01008c00);\n\t}\n}\n\nvoid rtl8xxxu_gen2_prepare_calibrate(struct rtl8xxxu_priv *priv, u8 start)\n{\n\tstruct h2c_cmd h2c;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\th2c.bt_wlan_calibration.cmd = H2C_8723B_BT_WLAN_CALIBRATION;\n\th2c.bt_wlan_calibration.data = start;\n\n\trtl8xxxu_gen2_h2c_cmd(priv, &h2c, sizeof(h2c.bt_wlan_calibration));\n}\n\nvoid rtl8xxxu_gen1_phy_iq_calibrate(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint result[4][8];\t/* last is final result */\n\tint i, candidate;\n\tbool path_a_ok, path_b_ok;\n\tu32 reg_e94, reg_e9c, reg_ea4, reg_eac;\n\tu32 reg_eb4, reg_ebc, reg_ec4, reg_ecc;\n\ts32 reg_tmp = 0;\n\tbool simu;\n\n\tmemset(result, 0, sizeof(result));\n\tcandidate = -1;\n\n\tpath_a_ok = false;\n\tpath_b_ok = false;\n\n\trtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\n\tfor (i = 0; i < 3; i++) {\n\t\trtl8xxxu_phy_iqcalibrate(priv, result, i);\n\n\t\tif (i == 1) {\n\t\t\tsimu = rtl8xxxu_simularity_compare(priv, result, 0, 1);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == 2) {\n\t\t\tsimu = rtl8xxxu_simularity_compare(priv, result, 0, 2);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsimu = rtl8xxxu_simularity_compare(priv, result, 1, 2);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 1;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t\treg_tmp += result[3][i];\n\n\t\t\t\tif (reg_tmp)\n\t\t\t\t\tcandidate = 3;\n\t\t\t\telse\n\t\t\t\t\tcandidate = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\treg_e94 = result[i][0];\n\t\treg_e9c = result[i][1];\n\t\treg_ea4 = result[i][2];\n\t\treg_eac = result[i][3];\n\t\treg_eb4 = result[i][4];\n\t\treg_ebc = result[i][5];\n\t\treg_ec4 = result[i][6];\n\t\treg_ecc = result[i][7];\n\t}\n\n\tif (candidate >= 0) {\n\t\treg_e94 = result[candidate][0];\n\t\tpriv->rege94 =  reg_e94;\n\t\treg_e9c = result[candidate][1];\n\t\tpriv->rege9c = reg_e9c;\n\t\treg_ea4 = result[candidate][2];\n\t\treg_eac = result[candidate][3];\n\t\treg_eb4 = result[candidate][4];\n\t\tpriv->regeb4 = reg_eb4;\n\t\treg_ebc = result[candidate][5];\n\t\tpriv->regebc = reg_ebc;\n\t\treg_ec4 = result[candidate][6];\n\t\treg_ecc = result[candidate][7];\n\t\tdev_dbg(dev, \"%s: candidate is %x\\n\", __func__, candidate);\n\t\tdev_dbg(dev,\n\t\t\t\"%s: e94 =%x e9c=%x ea4=%x eac=%x eb4=%x ebc=%x ec4=%x ecc=%x\\n\",\n\t\t\t__func__, reg_e94, reg_e9c,\n\t\t\treg_ea4, reg_eac, reg_eb4, reg_ebc, reg_ec4, reg_ecc);\n\t\tpath_a_ok = true;\n\t\tpath_b_ok = true;\n\t} else {\n\t\treg_e94 = reg_eb4 = priv->rege94 = priv->regeb4 = 0x100;\n\t\treg_e9c = reg_ebc = priv->rege9c = priv->regebc = 0x0;\n\t}\n\n\tif (reg_e94 && candidate >= 0)\n\t\trtl8xxxu_fill_iqk_matrix_a(priv, path_a_ok, result,\n\t\t\t\t\t   candidate, (reg_ea4 == 0));\n\n\tif (priv->tx_paths > 1 && reg_eb4)\n\t\trtl8xxxu_fill_iqk_matrix_b(priv, path_b_ok, result,\n\t\t\t\t\t   candidate, (reg_ec4 == 0));\n\n\trtl8xxxu_save_regs(priv, rtl8xxxu_iqk_phy_iq_bb_reg,\n\t\t\t   priv->bb_recovery_backup, RTL8XXXU_BB_REGS);\n}\n\nstatic void rtl8723a_phy_lc_calibrate(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\tu32 rf_amode, rf_bmode = 0, lstf;\n\n\t/* Check continuous TX and Packet TX */\n\tlstf = rtl8xxxu_read32(priv, REG_OFDM1_LSTF);\n\n\tif (lstf & OFDM_LSTF_MASK) {\n\t\t/* Disable all continuous TX */\n\t\tval32 = lstf & ~OFDM_LSTF_MASK;\n\t\trtl8xxxu_write32(priv, REG_OFDM1_LSTF, val32);\n\n\t\t/* Read original RF mode Path A */\n\t\trf_amode = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_AC);\n\n\t\t/* Set RF mode to standby Path A */\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC,\n\t\t\t\t     (rf_amode & 0x8ffff) | 0x10000);\n\n\t\t/* Path-B */\n\t\tif (priv->tx_paths > 1) {\n\t\t\trf_bmode = rtl8xxxu_read_rfreg(priv, RF_B,\n\t\t\t\t\t\t       RF6052_REG_AC);\n\n\t\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC,\n\t\t\t\t\t     (rf_bmode & 0x8ffff) | 0x10000);\n\t\t}\n\t} else {\n\t\t/*  Deal with Packet TX case */\n\t\t/*  block all queues */\n\t\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\t}\n\n\t/* Start LC calibration */\n\tif (priv->fops->has_s0s1)\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_S0S1, 0xdfbe0);\n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_MODE_AG);\n\tval32 |= 0x08000;\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_MODE_AG, val32);\n\n\tmsleep(100);\n\n\tif (priv->fops->has_s0s1)\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_S0S1, 0xdffe0);\n\n\t/* Restore original parameters */\n\tif (lstf & OFDM_LSTF_MASK) {\n\t\t/* Path-A */\n\t\trtl8xxxu_write32(priv, REG_OFDM1_LSTF, lstf);\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, rf_amode);\n\n\t\t/* Path-B */\n\t\tif (priv->tx_paths > 1)\n\t\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC,\n\t\t\t\t\t     rf_bmode);\n\t} else /*  Deal with Packet TX case */\n\t\trtl8xxxu_write8(priv, REG_TXPAUSE, 0x00);\n}\n\nstatic int rtl8xxxu_set_mac(struct rtl8xxxu_priv *priv)\n{\n\tint i;\n\tu16 reg;\n\n\treg = REG_MACID;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\trtl8xxxu_write8(priv, reg + i, priv->mac_addr[i]);\n\n\treturn 0;\n}\n\nstatic int rtl8xxxu_set_bssid(struct rtl8xxxu_priv *priv, const u8 *bssid)\n{\n\tint i;\n\tu16 reg;\n\n\tdev_dbg(&priv->udev->dev, \"%s: (%pM)\\n\", __func__, bssid);\n\n\treg = REG_BSSID;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\trtl8xxxu_write8(priv, reg + i, bssid[i]);\n\n\treturn 0;\n}\n\nstatic void\nrtl8xxxu_set_ampdu_factor(struct rtl8xxxu_priv *priv, u8 ampdu_factor)\n{\n\tu8 vals[4] = { 0x41, 0xa8, 0x72, 0xb9 };\n\tu8 max_agg = 0xf;\n\tint i;\n\n\tampdu_factor = 1 << (ampdu_factor + 2);\n\tif (ampdu_factor > max_agg)\n\t\tampdu_factor = max_agg;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif ((vals[i] & 0xf0) > (ampdu_factor << 4))\n\t\t\tvals[i] = (vals[i] & 0x0f) | (ampdu_factor << 4);\n\n\t\tif ((vals[i] & 0x0f) > ampdu_factor)\n\t\t\tvals[i] = (vals[i] & 0xf0) | ampdu_factor;\n\n\t\trtl8xxxu_write8(priv, REG_AGGLEN_LMT + i, vals[i]);\n\t}\n}\n\nstatic void rtl8xxxu_set_ampdu_min_space(struct rtl8xxxu_priv *priv, u8 density)\n{\n\tu8 val8;\n\n\tval8 = rtl8xxxu_read8(priv, REG_AMPDU_MIN_SPACE);\n\tval8 &= 0xf8;\n\tval8 |= density;\n\trtl8xxxu_write8(priv, REG_AMPDU_MIN_SPACE, val8);\n}\n\nstatic int rtl8xxxu_active_to_emu(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tint count, ret = 0;\n\n\t/* Start of rtl8723AU_card_enable_flow */\n\t/* Act to Cardemu sequence*/\n\t/* Turn off RF */\n\trtl8xxxu_write8(priv, REG_RF_CTRL, 0);\n\n\t/* 0x004E[7] = 0, switch DPDT_SEL_P output from register 0x0065[2] */\n\tval8 = rtl8xxxu_read8(priv, REG_LEDCFG2);\n\tval8 &= ~LEDCFG2_DPDT_SELECT;\n\trtl8xxxu_write8(priv, REG_LEDCFG2, val8);\n\n\t/* 0x0005[1] = 1 turn off MAC by HW state machine*/\n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 |= BIT(1);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\t\tif ((val8 & BIT(1)) == 0)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tif (!count) {\n\t\tdev_warn(&priv->udev->dev, \"%s: Disabling MAC timed out\\n\",\n\t\t\t __func__);\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t/* 0x0000[5] = 1 analog Ips to digital, 1:isolation */\n\tval8 = rtl8xxxu_read8(priv, REG_SYS_ISO_CTRL);\n\tval8 |= SYS_ISO_ANALOG_IPS;\n\trtl8xxxu_write8(priv, REG_SYS_ISO_CTRL, val8);\n\n\t/* 0x0020[0] = 0 disable LDOA12 MACRO block*/\n\tval8 = rtl8xxxu_read8(priv, REG_LDOA15_CTRL);\n\tval8 &= ~LDOA15_ENABLE;\n\trtl8xxxu_write8(priv, REG_LDOA15_CTRL, val8);\n\nexit:\n\treturn ret;\n}\n\nint rtl8xxxu_active_to_lps(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu8 val32;\n\tint count, ret = 0;\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\n\t/*\n\t * Poll - wait for RX packet to complete\n\t */\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, 0x5f8);\n\t\tif (!val32)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tif (!count) {\n\t\tdev_warn(&priv->udev->dev,\n\t\t\t \"%s: RX poll timed out (0x05f8)\\n\", __func__);\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t/* Disable CCK and OFDM, clock gated */\n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\n\tval8 &= ~SYS_FUNC_BBRSTB;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\n\n\tudelay(2);\n\n\t/* Reset baseband */\n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\n\tval8 &= ~SYS_FUNC_BB_GLB_RSTN;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\n\n\t/* Reset MAC TRX */\n\tval8 = rtl8xxxu_read8(priv, REG_CR);\n\tval8 = CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE;\n\trtl8xxxu_write8(priv, REG_CR, val8);\n\n\t/* Reset MAC TRX */\n\tval8 = rtl8xxxu_read8(priv, REG_CR + 1);\n\tval8 &= ~BIT(1); /* CR_SECURITY_ENABLE */\n\trtl8xxxu_write8(priv, REG_CR + 1, val8);\n\n\t/* Respond TX OK to scheduler */\n\tval8 = rtl8xxxu_read8(priv, REG_DUAL_TSF_RST);\n\tval8 |= DUAL_TSF_TX_OK;\n\trtl8xxxu_write8(priv, REG_DUAL_TSF_RST, val8);\n\nexit:\n\treturn ret;\n}\n\nvoid rtl8xxxu_disabled_to_emu(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\n\t/* Clear suspend enable and power down enable*/\n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~(BIT(3) | BIT(7));\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\t/* 0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/\n\tval8 = rtl8xxxu_read8(priv, REG_GPIO_INTM + 2);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_GPIO_INTM + 2, val8);\n\n\t/* 0x04[12:11] = 11 enable WL suspend*/\n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~(BIT(3) | BIT(4));\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n}\n\nstatic int rtl8xxxu_emu_to_disabled(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\n\t/* 0x0007[7:0] = 0x20 SOP option to disable BG/MB */\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 3, 0x20);\n\n\t/* 0x04[12:11] = 01 enable WL suspend */\n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~BIT(4);\n\tval8 |= BIT(3);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 |= BIT(7);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\t/* 0x48[16] = 1 to enable GPIO9 as EXT wakeup */\n\tval8 = rtl8xxxu_read8(priv, REG_GPIO_INTM + 2);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, REG_GPIO_INTM + 2, val8);\n\n\treturn 0;\n}\n\nint rtl8xxxu_flush_fifo(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 val32;\n\tint retry, retval;\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\n\tval32 = rtl8xxxu_read32(priv, REG_RXPKT_NUM);\n\tval32 |= RXPKT_NUM_RW_RELEASE_EN;\n\trtl8xxxu_write32(priv, REG_RXPKT_NUM, val32);\n\n\tretry = 100;\n\tretval = -EBUSY;\n\n\tdo {\n\t\tval32 = rtl8xxxu_read32(priv, REG_RXPKT_NUM);\n\t\tif (val32 & RXPKT_NUM_RXDMA_IDLE) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (retry--);\n\n\trtl8xxxu_write16(priv, REG_RQPN_NPQ, 0);\n\trtl8xxxu_write32(priv, REG_RQPN, 0x80000000);\n\tmdelay(2);\n\n\tif (!retry)\n\t\tdev_warn(dev, \"Failed to flush FIFO\\n\");\n\n\treturn retval;\n}\n\nvoid rtl8xxxu_gen1_usb_quirks(struct rtl8xxxu_priv *priv)\n{\n\t/* Fix USB interface interference issue */\n\trtl8xxxu_write8(priv, 0xfe40, 0xe0);\n\trtl8xxxu_write8(priv, 0xfe41, 0x8d);\n\trtl8xxxu_write8(priv, 0xfe42, 0x80);\n\t/*\n\t * This sets TXDMA_OFFSET_DROP_DATA_EN (bit 9) as well as bits\n\t * 8 and 5, for which I have found no documentation.\n\t */\n\trtl8xxxu_write32(priv, REG_TXDMA_OFFSET_CHK, 0xfd0320);\n\n\t/*\n\t * Solve too many protocol error on USB bus.\n\t * Can't do this for 8188/8192 UMC A cut parts\n\t */\n\tif (!(!priv->chip_cut && priv->vendor_umc)) {\n\t\trtl8xxxu_write8(priv, 0xfe40, 0xe6);\n\t\trtl8xxxu_write8(priv, 0xfe41, 0x94);\n\t\trtl8xxxu_write8(priv, 0xfe42, 0x80);\n\n\t\trtl8xxxu_write8(priv, 0xfe40, 0xe0);\n\t\trtl8xxxu_write8(priv, 0xfe41, 0x19);\n\t\trtl8xxxu_write8(priv, 0xfe42, 0x80);\n\n\t\trtl8xxxu_write8(priv, 0xfe40, 0xe5);\n\t\trtl8xxxu_write8(priv, 0xfe41, 0x91);\n\t\trtl8xxxu_write8(priv, 0xfe42, 0x80);\n\n\t\trtl8xxxu_write8(priv, 0xfe40, 0xe2);\n\t\trtl8xxxu_write8(priv, 0xfe41, 0x81);\n\t\trtl8xxxu_write8(priv, 0xfe42, 0x80);\n\t}\n}\n\nvoid rtl8xxxu_gen2_usb_quirks(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\n\tval32 = rtl8xxxu_read32(priv, REG_TXDMA_OFFSET_CHK);\n\tval32 |= TXDMA_OFFSET_DROP_DATA_EN;\n\trtl8xxxu_write32(priv, REG_TXDMA_OFFSET_CHK, val32);\n}\n\nvoid rtl8xxxu_power_off(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\n\t/*\n\t * Workaround for 8188RU LNA power leakage problem.\n\t */\n\tif (priv->rtl_chip == RTL8188R) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XCD_RF_PARM);\n\t\tval32 |= BIT(1);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_PARM, val32);\n\t}\n\n\trtl8xxxu_flush_fifo(priv);\n\n\trtl8xxxu_active_to_lps(priv);\n\n\t/* Turn off RF */\n\trtl8xxxu_write8(priv, REG_RF_CTRL, 0x00);\n\n\t/* Reset Firmware if running in RAM */\n\tif (rtl8xxxu_read8(priv, REG_MCU_FW_DL) & MCU_FW_RAM_SEL)\n\t\trtl8xxxu_firmware_self_reset(priv);\n\n\t/* Reset MCU */\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tval16 &= ~SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\n\t/* Reset MCU ready status */\n\trtl8xxxu_write8(priv, REG_MCU_FW_DL, 0x00);\n\n\trtl8xxxu_active_to_emu(priv);\n\trtl8xxxu_emu_to_disabled(priv);\n\n\t/* Reset MCU IO Wrapper */\n\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\n\n\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\n\n\t/* RSV_CTRL 0x1C[7:0] = 0x0e  lock ISO/CLK/Power control register */\n\trtl8xxxu_write8(priv, REG_RSV_CTRL, 0x0e);\n}\n\n#ifdef NEED_PS_TDMA\nstatic void rtl8723bu_set_ps_tdma(struct rtl8xxxu_priv *priv,\n\t\t\t\t  u8 arg1, u8 arg2, u8 arg3, u8 arg4, u8 arg5)\n{\n\tstruct h2c_cmd h2c;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\th2c.b_type_dma.cmd = H2C_8723B_B_TYPE_TDMA;\n\th2c.b_type_dma.data1 = arg1;\n\th2c.b_type_dma.data2 = arg2;\n\th2c.b_type_dma.data3 = arg3;\n\th2c.b_type_dma.data4 = arg4;\n\th2c.b_type_dma.data5 = arg5;\n\trtl8xxxu_gen2_h2c_cmd(priv, &h2c, sizeof(h2c.b_type_dma));\n}\n#endif\n\nvoid rtl8xxxu_gen2_disable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\n\tval32 = rtl8xxxu_read32(priv, REG_RX_WAIT_CCA);\n\tval32 &= ~(BIT(22) | BIT(23));\n\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, val32);\n}\n\nstatic void rtl8xxxu_init_queue_reserved_page(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8xxxu_fileops *fops = priv->fops;\n\tu32 hq, lq, nq, eq, pubq;\n\tu32 val32;\n\n\thq = 0;\n\tlq = 0;\n\tnq = 0;\n\teq = 0;\n\tpubq = 0;\n\n\tif (priv->ep_tx_high_queue)\n\t\thq = fops->page_num_hi;\n\tif (priv->ep_tx_low_queue)\n\t\tlq = fops->page_num_lo;\n\tif (priv->ep_tx_normal_queue)\n\t\tnq = fops->page_num_norm;\n\n\tval32 = (nq << RQPN_NPQ_SHIFT) | (eq << RQPN_EPQ_SHIFT);\n\trtl8xxxu_write32(priv, REG_RQPN_NPQ, val32);\n\n\tpubq = fops->total_page_num - hq - lq - nq - 1;\n\n\tval32 = RQPN_LOAD;\n\tval32 |= (hq << RQPN_HI_PQ_SHIFT);\n\tval32 |= (lq << RQPN_LO_PQ_SHIFT);\n\tval32 |= (pubq << RQPN_PUB_PQ_SHIFT);\n\n\trtl8xxxu_write32(priv, REG_RQPN, val32);\n}\n\nstatic int rtl8xxxu_init_device(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tstruct rtl8xxxu_fileops *fops = priv->fops;\n\tbool macpower;\n\tint ret;\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\n\t/* Check if MAC is already powered on */\n\tval8 = rtl8xxxu_read8(priv, REG_CR);\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_CLKR);\n\n\t/*\n\t * Fix 92DU-VC S3 hang with the reason is that secondary mac is not\n\t * initialized. First MAC returns 0xea, second MAC returns 0x00\n\t */\n\tif (val8 == 0xea || !(val16 & SYS_CLK_MAC_CLK_ENABLE))\n\t\tmacpower = false;\n\telse\n\t\tmacpower = true;\n\n\tret = fops->power_on(priv);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"%s: Failed power on\\n\", __func__);\n\t\tgoto exit;\n\t}\n\n\tif (!macpower)\n\t\trtl8xxxu_init_queue_reserved_page(priv);\n\n\tret = rtl8xxxu_init_queue_priority(priv);\n\tdev_dbg(dev, \"%s: init_queue_priority %i\\n\", __func__, ret);\n\tif (ret)\n\t\tgoto exit;\n\n\t/*\n\t * Set RX page boundary\n\t */\n\trtl8xxxu_write16(priv, REG_TRXFF_BNDY + 2, fops->trxff_boundary);\n\n\tret = rtl8xxxu_download_firmware(priv);\n\tdev_dbg(dev, \"%s: download_firmware %i\\n\", __func__, ret);\n\tif (ret)\n\t\tgoto exit;\n\tret = rtl8xxxu_start_firmware(priv);\n\tdev_dbg(dev, \"%s: start_firmware %i\\n\", __func__, ret);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (fops->phy_init_antenna_selection)\n\t\tfops->phy_init_antenna_selection(priv);\n\n\tret = rtl8xxxu_init_mac(priv);\n\n\tdev_dbg(dev, \"%s: init_mac %i\\n\", __func__, ret);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = rtl8xxxu_init_phy_bb(priv);\n\tdev_dbg(dev, \"%s: init_phy_bb %i\\n\", __func__, ret);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = fops->init_phy_rf(priv);\n\tif (ret)\n\t\tgoto exit;\n\n\t/* RFSW Control - clear bit 14 ?? */\n\tif (priv->rtl_chip != RTL8723B && priv->rtl_chip != RTL8192E)\n\t\trtl8xxxu_write32(priv, REG_FPGA0_TX_INFO, 0x00000003);\n\n\tval32 = FPGA0_RF_TRSW | FPGA0_RF_TRSWB | FPGA0_RF_ANTSW |\n\t\tFPGA0_RF_ANTSWB |\n\t\t((FPGA0_RF_ANTSW | FPGA0_RF_ANTSWB) << FPGA0_RF_BD_CTRL_SHIFT);\n\tif (!priv->no_pape) {\n\t\tval32 |= (FPGA0_RF_PAPE |\n\t\t\t  (FPGA0_RF_PAPE << FPGA0_RF_BD_CTRL_SHIFT));\n\t}\n\trtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_SW_CTRL, val32);\n\n\t/* 0x860[6:5]= 00 - why? - this sets antenna B */\n\tif (priv->rtl_chip != RTL8192E)\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_RF_INT_OE, 0x66f60210);\n\n\tif (!macpower) {\n\t\t/*\n\t\t * Set TX buffer boundary\n\t\t */\n\t\tval8 = fops->total_page_num + 1;\n\n\t\trtl8xxxu_write8(priv, REG_TXPKTBUF_BCNQ_BDNY, val8);\n\t\trtl8xxxu_write8(priv, REG_TXPKTBUF_MGQ_BDNY, val8);\n\t\trtl8xxxu_write8(priv, REG_TXPKTBUF_WMAC_LBK_BF_HD, val8);\n\t\trtl8xxxu_write8(priv, REG_TRXFF_BNDY, val8);\n\t\trtl8xxxu_write8(priv, REG_TDECTRL + 1, val8);\n\t}\n\n\t/*\n\t * The vendor drivers set PBP for all devices, except 8192e.\n\t * There is no explanation for this in any of the sources.\n\t */\n\tval8 = (fops->pbp_rx << PBP_PAGE_SIZE_RX_SHIFT) |\n\t\t(fops->pbp_tx << PBP_PAGE_SIZE_TX_SHIFT);\n\tif (priv->rtl_chip != RTL8192E)\n\t\trtl8xxxu_write8(priv, REG_PBP, val8);\n\n\tdev_dbg(dev, \"%s: macpower %i\\n\", __func__, macpower);\n\tif (!macpower) {\n\t\tret = fops->llt_init(priv);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"%s: LLT table init failed\\n\", __func__);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/*\n\t\t * Chip specific quirks\n\t\t */\n\t\tfops->usb_quirks(priv);\n\n\t\t/*\n\t\t * Enable TX report and TX report timer for 8723bu/8188eu/...\n\t\t */\n\t\tif (fops->has_tx_report) {\n\t\t\tval8 = rtl8xxxu_read8(priv, REG_TX_REPORT_CTRL);\n\t\t\tval8 |= TX_REPORT_CTRL_TIMER_ENABLE;\n\t\t\trtl8xxxu_write8(priv, REG_TX_REPORT_CTRL, val8);\n\t\t\t/* Set MAX RPT MACID */\n\t\t\trtl8xxxu_write8(priv, REG_TX_REPORT_CTRL + 1, 0x02);\n\t\t\t/* TX report Timer. Unit: 32us */\n\t\t\trtl8xxxu_write16(priv, REG_TX_REPORT_TIME, 0xcdf0);\n\n\t\t\t/* tmp ps ? */\n\t\t\tval8 = rtl8xxxu_read8(priv, 0xa3);\n\t\t\tval8 &= 0xf8;\n\t\t\trtl8xxxu_write8(priv, 0xa3, val8);\n\t\t}\n\t}\n\n\t/*\n\t * Unit in 8 bytes, not obvious what it is used for\n\t */\n\trtl8xxxu_write8(priv, REG_RX_DRVINFO_SZ, 4);\n\n\tif (priv->rtl_chip == RTL8192E) {\n\t\trtl8xxxu_write32(priv, REG_HIMR0, 0x00);\n\t\trtl8xxxu_write32(priv, REG_HIMR1, 0x00);\n\t} else {\n\t\t/*\n\t\t * Enable all interrupts - not obvious USB needs to do this\n\t\t */\n\t\trtl8xxxu_write32(priv, REG_HISR, 0xffffffff);\n\t\trtl8xxxu_write32(priv, REG_HIMR, 0xffffffff);\n\t}\n\n\trtl8xxxu_set_mac(priv);\n\trtl8xxxu_set_linktype(priv, NL80211_IFTYPE_STATION);\n\n\t/*\n\t * Configure initial WMAC settings\n\t */\n\tval32 = RCR_ACCEPT_PHYS_MATCH | RCR_ACCEPT_MCAST | RCR_ACCEPT_BCAST |\n\t\tRCR_ACCEPT_MGMT_FRAME | RCR_HTC_LOC_CTRL |\n\t\tRCR_APPEND_PHYSTAT | RCR_APPEND_ICV | RCR_APPEND_MIC;\n\trtl8xxxu_write32(priv, REG_RCR, val32);\n\n\t/*\n\t * Accept all multicast\n\t */\n\trtl8xxxu_write32(priv, REG_MAR, 0xffffffff);\n\trtl8xxxu_write32(priv, REG_MAR + 4, 0xffffffff);\n\n\t/*\n\t * Init adaptive controls\n\t */\n\tval32 = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\n\tval32 &= ~RESPONSE_RATE_BITMAP_ALL;\n\tval32 |= RESPONSE_RATE_RRSR_CCK_ONLY_1M;\n\trtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, val32);\n\n\t/* CCK = 0x0a, OFDM = 0x10 */\n\trtl8xxxu_set_spec_sifs(priv, 0x10, 0x10);\n\trtl8xxxu_set_retry(priv, 0x30, 0x30);\n\trtl8xxxu_set_spec_sifs(priv, 0x0a, 0x10);\n\n\t/*\n\t * Init EDCA\n\t */\n\trtl8xxxu_write16(priv, REG_MAC_SPEC_SIFS, 0x100a);\n\n\t/* Set CCK SIFS */\n\trtl8xxxu_write16(priv, REG_SIFS_CCK, 0x100a);\n\n\t/* Set OFDM SIFS */\n\trtl8xxxu_write16(priv, REG_SIFS_OFDM, 0x100a);\n\n\t/* TXOP */\n\trtl8xxxu_write32(priv, REG_EDCA_BE_PARAM, 0x005ea42b);\n\trtl8xxxu_write32(priv, REG_EDCA_BK_PARAM, 0x0000a44f);\n\trtl8xxxu_write32(priv, REG_EDCA_VI_PARAM, 0x005ea324);\n\trtl8xxxu_write32(priv, REG_EDCA_VO_PARAM, 0x002fa226);\n\n\t/* Set data auto rate fallback retry count */\n\trtl8xxxu_write32(priv, REG_DARFRC, 0x00000000);\n\trtl8xxxu_write32(priv, REG_DARFRC + 4, 0x10080404);\n\trtl8xxxu_write32(priv, REG_RARFRC, 0x04030201);\n\trtl8xxxu_write32(priv, REG_RARFRC + 4, 0x08070605);\n\n\tval8 = rtl8xxxu_read8(priv, REG_FWHW_TXQ_CTRL);\n\tval8 |= FWHW_TXQ_CTRL_AMPDU_RETRY;\n\trtl8xxxu_write8(priv, REG_FWHW_TXQ_CTRL, val8);\n\n\t/*  Set ACK timeout */\n\trtl8xxxu_write8(priv, REG_ACKTO, 0x40);\n\n\t/*\n\t * Initialize beacon parameters\n\t */\n\tval16 = BEACON_DISABLE_TSF_UPDATE | (BEACON_DISABLE_TSF_UPDATE << 8);\n\trtl8xxxu_write16(priv, REG_BEACON_CTRL, val16);\n\trtl8xxxu_write16(priv, REG_TBTT_PROHIBIT, 0x6404);\n\trtl8xxxu_write8(priv, REG_DRIVER_EARLY_INT, DRIVER_EARLY_INT_TIME);\n\trtl8xxxu_write8(priv, REG_BEACON_DMA_TIME, BEACON_DMA_ATIME_INT_TIME);\n\trtl8xxxu_write16(priv, REG_BEACON_TCFG, 0x660F);\n\n\t/*\n\t * Initialize burst parameters\n\t */\n\tif (priv->rtl_chip == RTL8723B) {\n\t\t/*\n\t\t * For USB high speed set 512B packets\n\t\t */\n\t\tval8 = rtl8xxxu_read8(priv, REG_RXDMA_PRO_8723B);\n\t\tval8 &= ~(BIT(4) | BIT(5));\n\t\tval8 |= BIT(4);\n\t\tval8 |= BIT(1) | BIT(2) | BIT(3);\n\t\trtl8xxxu_write8(priv, REG_RXDMA_PRO_8723B, val8);\n\n\t\t/*\n\t\t * For USB high speed set 512B packets\n\t\t */\n\t\tval8 = rtl8xxxu_read8(priv, REG_HT_SINGLE_AMPDU_8723B);\n\t\tval8 |= BIT(7);\n\t\trtl8xxxu_write8(priv, REG_HT_SINGLE_AMPDU_8723B, val8);\n\n\t\trtl8xxxu_write16(priv, REG_MAX_AGGR_NUM, 0x0c14);\n\t\trtl8xxxu_write8(priv, REG_AMPDU_MAX_TIME_8723B, 0x5e);\n\t\trtl8xxxu_write32(priv, REG_AGGLEN_LMT, 0xffffffff);\n\t\trtl8xxxu_write8(priv, REG_RX_PKT_LIMIT, 0x18);\n\t\trtl8xxxu_write8(priv, REG_PIFS, 0x00);\n\t\trtl8xxxu_write8(priv, REG_USTIME_TSF_8723B, 0x50);\n\t\trtl8xxxu_write8(priv, REG_USTIME_EDCA, 0x50);\n\n\t\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL);\n\t\tval8 |= BIT(5) | BIT(6);\n\t\trtl8xxxu_write8(priv, REG_RSV_CTRL, val8);\n\t}\n\n\tif (fops->init_aggregation)\n\t\tfops->init_aggregation(priv);\n\n\t/*\n\t * Enable CCK and OFDM block\n\t */\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\tval32 |= (FPGA_RF_MODE_CCK | FPGA_RF_MODE_OFDM);\n\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t/*\n\t * Invalidate all CAM entries - bit 30 is undocumented\n\t */\n\trtl8xxxu_write32(priv, REG_CAM_CMD, CAM_CMD_POLLING | BIT(30));\n\n\t/*\n\t * Start out with default power levels for channel 6, 20MHz\n\t */\n\tfops->set_tx_power(priv, 1, false);\n\n\t/* Let the 8051 take control of antenna setting */\n\tif (priv->rtl_chip != RTL8192E) {\n\t\tval8 = rtl8xxxu_read8(priv, REG_LEDCFG2);\n\t\tval8 |= LEDCFG2_DPDT_SELECT;\n\t\trtl8xxxu_write8(priv, REG_LEDCFG2, val8);\n\t}\n\n\trtl8xxxu_write8(priv, REG_HWSEQ_CTRL, 0xff);\n\n\t/* Disable BAR - not sure if this has any effect on USB */\n\trtl8xxxu_write32(priv, REG_BAR_MODE_CTRL, 0x0201ffff);\n\n\trtl8xxxu_write16(priv, REG_FAST_EDCA_CTRL, 0);\n\n\tif (fops->init_statistics)\n\t\tfops->init_statistics(priv);\n\n\tif (priv->rtl_chip == RTL8192E) {\n\t\t/*\n\t\t * 0x4c6[3] 1: RTS BW = Data BW\n\t\t * 0: RTS BW depends on CCA / secondary CCA result.\n\t\t */\n\t\tval8 = rtl8xxxu_read8(priv, REG_QUEUE_CTRL);\n\t\tval8 &= ~BIT(3);\n\t\trtl8xxxu_write8(priv, REG_QUEUE_CTRL, val8);\n\t\t/*\n\t\t * Reset USB mode switch setting\n\t\t */\n\t\trtl8xxxu_write8(priv, REG_ACLK_MON, 0x00);\n\t}\n\n\trtl8723a_phy_lc_calibrate(priv);\n\n\tfops->phy_iq_calibrate(priv);\n\n\t/*\n\t * This should enable thermal meter\n\t */\n\tif (fops->gen2_thermal_meter)\n\t\trtl8xxxu_write_rfreg(priv,\n\t\t\t\t     RF_A, RF6052_REG_T_METER_8723B, 0x37cf8);\n\telse\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_T_METER, 0x60);\n\n\t/* Set NAV_UPPER to 30000us */\n\tval8 = ((30000 + NAV_UPPER_UNIT - 1) / NAV_UPPER_UNIT);\n\trtl8xxxu_write8(priv, REG_NAV_UPPER, val8);\n\n\tif (priv->rtl_chip == RTL8723A) {\n\t\t/*\n\t\t * 2011/03/09 MH debug only, UMC-B cut pass 2500 S5 test,\n\t\t * but we need to find root cause.\n\t\t * This is 8723au only.\n\t\t */\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tif ((val32 & 0xff000000) != 0x83000000) {\n\t\t\tval32 |= FPGA_RF_MODE_CCK;\n\t\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\t\t}\n\t} else if (priv->rtl_chip == RTL8192E) {\n\t\trtl8xxxu_write8(priv, REG_USB_HRPWM, 0x00);\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_FWHW_TXQ_CTRL);\n\tval32 |= FWHW_TXQ_CTRL_XMIT_MGMT_ACK;\n\t/* ack for xmit mgmt frames. */\n\trtl8xxxu_write32(priv, REG_FWHW_TXQ_CTRL, val32);\n\n\tif (priv->rtl_chip == RTL8192E) {\n\t\t/*\n\t\t * Fix LDPC rx hang issue.\n\t\t */\n\t\tval32 = rtl8xxxu_read32(priv, REG_AFE_MISC);\n\t\trtl8xxxu_write8(priv, REG_8192E_LDOV12_CTRL, 0x75);\n\t\tval32 &= 0xfff00fff;\n\t\tval32 |= 0x0007e000;\n\t\trtl8xxxu_write32(priv, REG_AFE_MISC, val32);\n\t}\nexit:\n\treturn ret;\n}\n\nstatic void rtl8xxxu_cam_write(struct rtl8xxxu_priv *priv,\n\t\t\t       struct ieee80211_key_conf *key, const u8 *mac)\n{\n\tu32 cmd, val32, addr, ctrl;\n\tint j, i, tmp_debug;\n\n\ttmp_debug = rtl8xxxu_debug;\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_KEY)\n\t\trtl8xxxu_debug |= RTL8XXXU_DEBUG_REG_WRITE;\n\n\t/*\n\t * This is a bit of a hack - the lower bits of the cipher\n\t * suite selector happens to match the cipher index in the CAM\n\t */\n\taddr = key->keyidx << CAM_CMD_KEY_SHIFT;\n\tctrl = (key->cipher & 0x0f) << 2 | key->keyidx | CAM_WRITE_VALID;\n\n\tfor (j = 5; j >= 0; j--) {\n\t\tswitch (j) {\n\t\tcase 0:\n\t\t\tval32 = ctrl | (mac[0] << 16) | (mac[1] << 24);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tval32 = mac[2] | (mac[3] << 8) |\n\t\t\t\t(mac[4] << 16) | (mac[5] << 24);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ti = (j - 2) << 2;\n\t\t\tval32 = key->key[i] | (key->key[i + 1] << 8) |\n\t\t\t\tkey->key[i + 2] << 16 | key->key[i + 3] << 24;\n\t\t\tbreak;\n\t\t}\n\n\t\trtl8xxxu_write32(priv, REG_CAM_WRITE, val32);\n\t\tcmd = CAM_CMD_POLLING | CAM_CMD_WRITE | (addr + j);\n\t\trtl8xxxu_write32(priv, REG_CAM_CMD, cmd);\n\t\tudelay(100);\n\t}\n\n\trtl8xxxu_debug = tmp_debug;\n}\n\nstatic void rtl8xxxu_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif, const u8 *mac)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tu8 val8;\n\n\tval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\n\tval8 |= BEACON_DISABLE_TSF_UPDATE;\n\trtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\n}\n\nstatic void rtl8xxxu_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tu8 val8;\n\n\tval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\n\tval8 &= ~BEACON_DISABLE_TSF_UPDATE;\n\trtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\n}\n\nvoid rtl8xxxu_update_rate_mask(struct rtl8xxxu_priv *priv, u32 ramask, int sgi)\n{\n\tstruct h2c_cmd h2c;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\n\th2c.ramask.cmd = H2C_SET_RATE_MASK;\n\th2c.ramask.mask_lo = cpu_to_le16(ramask & 0xffff);\n\th2c.ramask.mask_hi = cpu_to_le16(ramask >> 16);\n\n\th2c.ramask.arg = 0x80;\n\tif (sgi)\n\t\th2c.ramask.arg |= 0x20;\n\n\tdev_dbg(&priv->udev->dev, \"%s: rate mask %08x, arg %02x, size %zi\\n\",\n\t\t__func__, ramask, h2c.ramask.arg, sizeof(h2c.ramask));\n\trtl8xxxu_gen1_h2c_cmd(priv, &h2c, sizeof(h2c.ramask));\n}\n\nvoid rtl8xxxu_gen2_update_rate_mask(struct rtl8xxxu_priv *priv,\n\t\t\t\t    u32 ramask, int sgi)\n{\n\tstruct h2c_cmd h2c;\n\tu8 bw = 0;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\n\th2c.b_macid_cfg.cmd = H2C_8723B_MACID_CFG_RAID;\n\th2c.b_macid_cfg.ramask0 = ramask & 0xff;\n\th2c.b_macid_cfg.ramask1 = (ramask >> 8) & 0xff;\n\th2c.b_macid_cfg.ramask2 = (ramask >> 16) & 0xff;\n\th2c.b_macid_cfg.ramask3 = (ramask >> 24) & 0xff;\n\n\th2c.ramask.arg = 0x80;\n\th2c.b_macid_cfg.data1 = 0;\n\tif (sgi)\n\t\th2c.b_macid_cfg.data1 |= BIT(7);\n\n\th2c.b_macid_cfg.data2 = bw;\n\n\tdev_dbg(&priv->udev->dev, \"%s: rate mask %08x, arg %02x, size %zi\\n\",\n\t\t__func__, ramask, h2c.ramask.arg, sizeof(h2c.b_macid_cfg));\n\trtl8xxxu_gen2_h2c_cmd(priv, &h2c, sizeof(h2c.b_macid_cfg));\n}\n\nvoid rtl8xxxu_gen1_report_connect(struct rtl8xxxu_priv *priv,\n\t\t\t\t  u8 macid, bool connect)\n{\n\tstruct h2c_cmd h2c;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\n\th2c.joinbss.cmd = H2C_JOIN_BSS_REPORT;\n\n\tif (connect)\n\t\th2c.joinbss.data = H2C_JOIN_BSS_CONNECT;\n\telse\n\t\th2c.joinbss.data = H2C_JOIN_BSS_DISCONNECT;\n\n\trtl8xxxu_gen1_h2c_cmd(priv, &h2c, sizeof(h2c.joinbss));\n}\n\nvoid rtl8xxxu_gen2_report_connect(struct rtl8xxxu_priv *priv,\n\t\t\t\t  u8 macid, bool connect)\n{\n#ifdef RTL8XXXU_GEN2_REPORT_CONNECT\n\t/*\n\t * Barry Day reports this causes issues with 8192eu and 8723bu\n\t * devices reconnecting. The reason for this is unclear, but\n\t * until it is better understood, leave the code in place but\n\t * disabled, so it is not lost.\n\t */\n\tstruct h2c_cmd h2c;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\n\th2c.media_status_rpt.cmd = H2C_8723B_MEDIA_STATUS_RPT;\n\tif (connect)\n\t\th2c.media_status_rpt.parm |= BIT(0);\n\telse\n\t\th2c.media_status_rpt.parm &= ~BIT(0);\n\n\trtl8xxxu_gen2_h2c_cmd(priv, &h2c, sizeof(h2c.media_status_rpt));\n#endif\n}\n\nvoid rtl8xxxu_gen1_init_aggregation(struct rtl8xxxu_priv *priv)\n{\n\tu8 agg_ctrl, usb_spec, page_thresh, timeout;\n\n\tusb_spec = rtl8xxxu_read8(priv, REG_USB_SPECIAL_OPTION);\n\tusb_spec &= ~USB_SPEC_USB_AGG_ENABLE;\n\trtl8xxxu_write8(priv, REG_USB_SPECIAL_OPTION, usb_spec);\n\n\tagg_ctrl = rtl8xxxu_read8(priv, REG_TRXDMA_CTRL);\n\tagg_ctrl &= ~TRXDMA_CTRL_RXDMA_AGG_EN;\n\n\tif (!rtl8xxxu_dma_aggregation) {\n\t\trtl8xxxu_write8(priv, REG_TRXDMA_CTRL, agg_ctrl);\n\t\treturn;\n\t}\n\n\tagg_ctrl |= TRXDMA_CTRL_RXDMA_AGG_EN;\n\trtl8xxxu_write8(priv, REG_TRXDMA_CTRL, agg_ctrl);\n\n\t/*\n\t * The number of packets we can take looks to be buffer size / 512\n\t * which matches the 512 byte rounding we have to do when de-muxing\n\t * the packets.\n\t *\n\t * Sample numbers from the vendor driver:\n\t * USB High-Speed mode values:\n\t *   RxAggBlockCount = 8 : 512 byte unit\n\t *   RxAggBlockTimeout = 6\n\t *   RxAggPageCount = 48 : 128 byte unit\n\t *   RxAggPageTimeout = 4 or 6 (absolute time 34ms/(2^6))\n\t */\n\n\tpage_thresh = (priv->fops->rx_agg_buf_size / 512);\n\tif (rtl8xxxu_dma_agg_pages >= 0) {\n\t\tif (rtl8xxxu_dma_agg_pages <= page_thresh)\n\t\t\ttimeout = page_thresh;\n\t\telse if (rtl8xxxu_dma_agg_pages <= 6)\n\t\t\tdev_err(&priv->udev->dev,\n\t\t\t\t\"%s: dma_agg_pages=%i too small, minimum is 6\\n\",\n\t\t\t\t__func__, rtl8xxxu_dma_agg_pages);\n\t\telse\n\t\t\tdev_err(&priv->udev->dev,\n\t\t\t\t\"%s: dma_agg_pages=%i larger than limit %i\\n\",\n\t\t\t\t__func__, rtl8xxxu_dma_agg_pages, page_thresh);\n\t}\n\trtl8xxxu_write8(priv, REG_RXDMA_AGG_PG_TH, page_thresh);\n\t/*\n\t * REG_RXDMA_AGG_PG_TH + 1 seems to be the timeout register on\n\t * gen2 chips and rtl8188eu. The rtl8723au seems unhappy if we\n\t * don't set it, so better set both.\n\t */\n\ttimeout = 4;\n\n\tif (rtl8xxxu_dma_agg_timeout >= 0) {\n\t\tif (rtl8xxxu_dma_agg_timeout <= 127)\n\t\t\ttimeout = rtl8xxxu_dma_agg_timeout;\n\t\telse\n\t\t\tdev_err(&priv->udev->dev,\n\t\t\t\t\"%s: Invalid dma_agg_timeout: %i\\n\",\n\t\t\t\t__func__, rtl8xxxu_dma_agg_timeout);\n\t}\n\n\trtl8xxxu_write8(priv, REG_RXDMA_AGG_PG_TH + 1, timeout);\n\trtl8xxxu_write8(priv, REG_USB_DMA_AGG_TO, timeout);\n\tpriv->rx_buf_aggregation = 1;\n}\n\nstatic void rtl8xxxu_set_basic_rates(struct rtl8xxxu_priv *priv, u32 rate_cfg)\n{\n\tu32 val32;\n\tu8 rate_idx = 0;\n\n\trate_cfg &= RESPONSE_RATE_BITMAP_ALL;\n\n\tval32 = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\n\tval32 &= ~RESPONSE_RATE_BITMAP_ALL;\n\tval32 |= rate_cfg;\n\trtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, val32);\n\n\tdev_dbg(&priv->udev->dev, \"%s: rates %08x\\n\", __func__,\trate_cfg);\n\n\twhile (rate_cfg) {\n\t\trate_cfg = (rate_cfg >> 1);\n\t\trate_idx++;\n\t}\n\trtl8xxxu_write8(priv, REG_INIRTS_RATE_SEL, rate_idx);\n}\n\nstatic void\nrtl8xxxu_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_bss_conf *bss_conf, u32 changed)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tstruct ieee80211_sta *sta;\n\tu32 val32;\n\tu8 val8;\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tdev_dbg(dev, \"Changed ASSOC: %i!\\n\", bss_conf->assoc);\n\n\t\trtl8xxxu_set_linktype(priv, vif->type);\n\n\t\tif (bss_conf->assoc) {\n\t\t\tu32 ramask;\n\t\t\tint sgi = 0;\n\n\t\t\trcu_read_lock();\n\t\t\tsta = ieee80211_find_sta(vif, bss_conf->bssid);\n\t\t\tif (!sta) {\n\t\t\t\tdev_info(dev, \"%s: ASSOC no sta found\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (sta->ht_cap.ht_supported)\n\t\t\t\tdev_info(dev, \"%s: HT supported\\n\", __func__);\n\t\t\tif (sta->vht_cap.vht_supported)\n\t\t\t\tdev_info(dev, \"%s: VHT supported\\n\", __func__);\n\n\t\t\t/* TODO: Set bits 28-31 for rate adaptive id */\n\t\t\tramask = (sta->supp_rates[0] & 0xfff) |\n\t\t\t\tsta->ht_cap.mcs.rx_mask[0] << 12 |\n\t\t\t\tsta->ht_cap.mcs.rx_mask[1] << 20;\n\t\t\tif (sta->ht_cap.cap &\n\t\t\t    (IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20))\n\t\t\t\tsgi = 1;\n\t\t\trcu_read_unlock();\n\n\t\t\tpriv->fops->update_rate_mask(priv, ramask, sgi);\n\n\t\t\trtl8xxxu_write8(priv, REG_BCN_MAX_ERR, 0xff);\n\n\t\t\trtl8xxxu_stop_tx_beacon(priv);\n\n\t\t\t/* joinbss sequence */\n\t\t\trtl8xxxu_write16(priv, REG_BCN_PSR_RPT,\n\t\t\t\t\t 0xc000 | bss_conf->aid);\n\n\t\t\tpriv->fops->report_connect(priv, 0, true);\n\t\t} else {\n\t\t\tval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\n\t\t\tval8 |= BEACON_DISABLE_TSF_UPDATE;\n\t\t\trtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\n\n\t\t\tpriv->fops->report_connect(priv, 0, false);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tdev_dbg(dev, \"Changed ERP_PREAMBLE: Use short preamble %i\\n\",\n\t\t\tbss_conf->use_short_preamble);\n\t\tval32 = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\n\t\tif (bss_conf->use_short_preamble)\n\t\t\tval32 |= RSR_ACK_SHORT_PREAMBLE;\n\t\telse\n\t\t\tval32 &= ~RSR_ACK_SHORT_PREAMBLE;\n\t\trtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, val32);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tdev_dbg(dev, \"Changed ERP_SLOT: short_slot_time %i\\n\",\n\t\t\tbss_conf->use_short_slot);\n\n\t\tif (bss_conf->use_short_slot)\n\t\t\tval8 = 9;\n\t\telse\n\t\t\tval8 = 20;\n\t\trtl8xxxu_write8(priv, REG_SLOT, val8);\n\t}\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tdev_dbg(dev, \"Changed BSSID!\\n\");\n\t\trtl8xxxu_set_bssid(priv, bss_conf->bssid);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\tdev_dbg(dev, \"Changed BASIC_RATES!\\n\");\n\t\trtl8xxxu_set_basic_rates(priv, bss_conf->basic_rates);\n\t}\nerror:\n\treturn;\n}\n\nstatic u32 rtl8xxxu_80211_to_rtl_queue(u32 queue)\n{\n\tu32 rtlqueue;\n\n\tswitch (queue) {\n\tcase IEEE80211_AC_VO:\n\t\trtlqueue = TXDESC_QUEUE_VO;\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\trtlqueue = TXDESC_QUEUE_VI;\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\trtlqueue = TXDESC_QUEUE_BE;\n\t\tbreak;\n\tcase IEEE80211_AC_BK:\n\t\trtlqueue = TXDESC_QUEUE_BK;\n\t\tbreak;\n\tdefault:\n\t\trtlqueue = TXDESC_QUEUE_BE;\n\t}\n\n\treturn rtlqueue;\n}\n\nstatic u32 rtl8xxxu_queue_select(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tu32 queue;\n\n\tif (ieee80211_is_mgmt(hdr->frame_control))\n\t\tqueue = TXDESC_QUEUE_MGNT;\n\telse\n\t\tqueue = rtl8xxxu_80211_to_rtl_queue(skb_get_queue_mapping(skb));\n\n\treturn queue;\n}\n\n/*\n * Despite newer chips 8723b/8812/8821 having a larger TX descriptor\n * format. The descriptor checksum is still only calculated over the\n * initial 32 bytes of the descriptor!\n */\nstatic void rtl8xxxu_calc_tx_desc_csum(struct rtl8xxxu_txdesc32 *tx_desc)\n{\n\t__le16 *ptr = (__le16 *)tx_desc;\n\tu16 csum = 0;\n\tint i;\n\n\t/*\n\t * Clear csum field before calculation, as the csum field is\n\t * in the middle of the struct.\n\t */\n\ttx_desc->csum = cpu_to_le16(0);\n\n\tfor (i = 0; i < (sizeof(struct rtl8xxxu_txdesc32) / sizeof(u16)); i++)\n\t\tcsum = csum ^ le16_to_cpu(ptr[i]);\n\n\ttx_desc->csum |= cpu_to_le16(csum);\n}\n\nstatic void rtl8xxxu_free_tx_resources(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8xxxu_tx_urb *tx_urb, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->tx_urb_lock, flags);\n\tlist_for_each_entry_safe(tx_urb, tmp, &priv->tx_urb_free_list, list) {\n\t\tlist_del(&tx_urb->list);\n\t\tpriv->tx_urb_free_count--;\n\t\tusb_free_urb(&tx_urb->urb);\n\t}\n\tspin_unlock_irqrestore(&priv->tx_urb_lock, flags);\n}\n\nstatic struct rtl8xxxu_tx_urb *\nrtl8xxxu_alloc_tx_urb(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8xxxu_tx_urb *tx_urb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->tx_urb_lock, flags);\n\ttx_urb = list_first_entry_or_null(&priv->tx_urb_free_list,\n\t\t\t\t\t  struct rtl8xxxu_tx_urb, list);\n\tif (tx_urb) {\n\t\tlist_del(&tx_urb->list);\n\t\tpriv->tx_urb_free_count--;\n\t\tif (priv->tx_urb_free_count < RTL8XXXU_TX_URB_LOW_WATER &&\n\t\t    !priv->tx_stopped) {\n\t\t\tpriv->tx_stopped = true;\n\t\t\tieee80211_stop_queues(priv->hw);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&priv->tx_urb_lock, flags);\n\n\treturn tx_urb;\n}\n\nstatic void rtl8xxxu_free_tx_urb(struct rtl8xxxu_priv *priv,\n\t\t\t\t struct rtl8xxxu_tx_urb *tx_urb)\n{\n\tunsigned long flags;\n\n\tINIT_LIST_HEAD(&tx_urb->list);\n\n\tspin_lock_irqsave(&priv->tx_urb_lock, flags);\n\n\tlist_add(&tx_urb->list, &priv->tx_urb_free_list);\n\tpriv->tx_urb_free_count++;\n\tif (priv->tx_urb_free_count > RTL8XXXU_TX_URB_HIGH_WATER &&\n\t    priv->tx_stopped) {\n\t\tpriv->tx_stopped = false;\n\t\tieee80211_wake_queues(priv->hw);\n\t}\n\n\tspin_unlock_irqrestore(&priv->tx_urb_lock, flags);\n}\n\nstatic void rtl8xxxu_tx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)urb->context;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ieee80211_hw *hw;\n\tstruct rtl8xxxu_priv *priv;\n\tstruct rtl8xxxu_tx_urb *tx_urb =\n\t\tcontainer_of(urb, struct rtl8xxxu_tx_urb, urb);\n\n\ttx_info = IEEE80211_SKB_CB(skb);\n\thw = tx_info->rate_driver_data[0];\n\tpriv = hw->priv;\n\n\tskb_pull(skb, priv->fops->tx_desc_size);\n\n\tieee80211_tx_info_clear_status(tx_info);\n\ttx_info->status.rates[0].idx = -1;\n\ttx_info->status.rates[0].count = 0;\n\n\tif (!urb->status)\n\t\ttx_info->flags |= IEEE80211_TX_STAT_ACK;\n\n\tieee80211_tx_status_irqsafe(hw, skb);\n\n\trtl8xxxu_free_tx_urb(priv, tx_urb);\n}\n\nstatic void rtl8xxxu_dump_action(struct device *dev,\n\t\t\t\t struct ieee80211_hdr *hdr)\n{\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)hdr;\n\tu16 cap, timeout;\n\n\tif (!(rtl8xxxu_debug & RTL8XXXU_DEBUG_ACTION))\n\t\treturn;\n\n\tswitch (mgmt->u.action.u.addba_resp.action_code) {\n\tcase WLAN_ACTION_ADDBA_RESP:\n\t\tcap = le16_to_cpu(mgmt->u.action.u.addba_resp.capab);\n\t\ttimeout = le16_to_cpu(mgmt->u.action.u.addba_resp.timeout);\n\t\tdev_info(dev, \"WLAN_ACTION_ADDBA_RESP: \"\n\t\t\t \"timeout %i, tid %02x, buf_size %02x, policy %02x, \"\n\t\t\t \"status %02x\\n\",\n\t\t\t timeout,\n\t\t\t (cap & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2,\n\t\t\t (cap & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6,\n\t\t\t (cap >> 1) & 0x1,\n\t\t\t le16_to_cpu(mgmt->u.action.u.addba_resp.status));\n\t\tbreak;\n\tcase WLAN_ACTION_ADDBA_REQ:\n\t\tcap = le16_to_cpu(mgmt->u.action.u.addba_req.capab);\n\t\ttimeout = le16_to_cpu(mgmt->u.action.u.addba_req.timeout);\n\t\tdev_info(dev, \"WLAN_ACTION_ADDBA_REQ: \"\n\t\t\t \"timeout %i, tid %02x, buf_size %02x, policy %02x\\n\",\n\t\t\t timeout,\n\t\t\t (cap & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2,\n\t\t\t (cap & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6,\n\t\t\t (cap >> 1) & 0x1);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(dev, \"action frame %02x\\n\",\n\t\t\t mgmt->u.action.u.addba_resp.action_code);\n\t\tbreak;\n\t}\n}\n\n/*\n * Fill in v1 (gen1) specific TX descriptor bits.\n * This format is used on 8188cu/8192cu/8723au\n */\nvoid\nrtl8xxxu_fill_txdesc_v1(struct ieee80211_hw *hw, struct ieee80211_hdr *hdr,\n\t\t\tstruct ieee80211_tx_info *tx_info,\n\t\t\tstruct rtl8xxxu_txdesc32 *tx_desc, bool sgi,\n\t\t\tbool short_preamble, bool ampdu_enable, u32 rts_rate)\n{\n\tstruct ieee80211_rate *tx_rate = ieee80211_get_tx_rate(hw, tx_info);\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tu32 rate;\n\tu16 rate_flags = tx_info->control.rates[0].flags;\n\tu16 seq_number;\n\n\tif (rate_flags & IEEE80211_TX_RC_MCS &&\n\t    !ieee80211_is_mgmt(hdr->frame_control))\n\t\trate = tx_info->control.rates[0].idx + DESC_RATE_MCS0;\n\telse\n\t\trate = tx_rate->hw_value;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_TX)\n\t\tdev_info(dev, \"%s: TX rate: %d, pkt size %d\\n\",\n\t\t\t __func__, rate, cpu_to_le16(tx_desc->pkt_size));\n\n\tseq_number = IEEE80211_SEQ_TO_SN(le16_to_cpu(hdr->seq_ctrl));\n\n\ttx_desc->txdw5 = cpu_to_le32(rate);\n\n\tif (ieee80211_is_data(hdr->frame_control))\n\t\ttx_desc->txdw5 |= cpu_to_le32(0x0001ff00);\n\n\ttx_desc->txdw3 = cpu_to_le32((u32)seq_number << TXDESC32_SEQ_SHIFT);\n\n\tif (ampdu_enable)\n\t\ttx_desc->txdw1 |= cpu_to_le32(TXDESC32_AGG_ENABLE);\n\telse\n\t\ttx_desc->txdw1 |= cpu_to_le32(TXDESC32_AGG_BREAK);\n\n\tif (ieee80211_is_mgmt(hdr->frame_control)) {\n\t\ttx_desc->txdw5 = cpu_to_le32(rate);\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_USE_DRIVER_RATE);\n\t\ttx_desc->txdw5 |= cpu_to_le32(6 << TXDESC32_RETRY_LIMIT_SHIFT);\n\t\ttx_desc->txdw5 |= cpu_to_le32(TXDESC32_RETRY_LIMIT_ENABLE);\n\t}\n\n\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_QOS);\n\n\tif (short_preamble)\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_SHORT_PREAMBLE);\n\n\tif (sgi)\n\t\ttx_desc->txdw5 |= cpu_to_le32(TXDESC32_SHORT_GI);\n\n\t/*\n\t * rts_rate is zero if RTS/CTS or CTS to SELF are not enabled\n\t */\n\ttx_desc->txdw4 |= cpu_to_le32(rts_rate << TXDESC32_RTS_RATE_SHIFT);\n\tif (rate_flags & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_RTS_CTS_ENABLE);\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_HW_RTS_ENABLE);\n\t} else if (rate_flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_CTS_SELF_ENABLE);\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_HW_RTS_ENABLE);\n\t}\n}\n\n/*\n * Fill in v2 (gen2) specific TX descriptor bits.\n * This format is used on 8192eu/8723bu\n */\nvoid\nrtl8xxxu_fill_txdesc_v2(struct ieee80211_hw *hw, struct ieee80211_hdr *hdr,\n\t\t\tstruct ieee80211_tx_info *tx_info,\n\t\t\tstruct rtl8xxxu_txdesc32 *tx_desc32, bool sgi,\n\t\t\tbool short_preamble, bool ampdu_enable, u32 rts_rate)\n{\n\tstruct ieee80211_rate *tx_rate = ieee80211_get_tx_rate(hw, tx_info);\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tstruct rtl8xxxu_txdesc40 *tx_desc40;\n\tu32 rate;\n\tu16 rate_flags = tx_info->control.rates[0].flags;\n\tu16 seq_number;\n\n\ttx_desc40 = (struct rtl8xxxu_txdesc40 *)tx_desc32;\n\n\tif (rate_flags & IEEE80211_TX_RC_MCS &&\n\t    !ieee80211_is_mgmt(hdr->frame_control))\n\t\trate = tx_info->control.rates[0].idx + DESC_RATE_MCS0;\n\telse\n\t\trate = tx_rate->hw_value;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_TX)\n\t\tdev_info(dev, \"%s: TX rate: %d, pkt size %d\\n\",\n\t\t\t __func__, rate, cpu_to_le16(tx_desc40->pkt_size));\n\n\tseq_number = IEEE80211_SEQ_TO_SN(le16_to_cpu(hdr->seq_ctrl));\n\n\ttx_desc40->txdw4 = cpu_to_le32(rate);\n\tif (ieee80211_is_data(hdr->frame_control)) {\n\t\ttx_desc40->txdw4 |= cpu_to_le32(0x1f <<\n\t\t\t\t\t\tTXDESC40_DATA_RATE_FB_SHIFT);\n\t}\n\n\ttx_desc40->txdw9 = cpu_to_le32((u32)seq_number << TXDESC40_SEQ_SHIFT);\n\n\tif (ampdu_enable)\n\t\ttx_desc40->txdw2 |= cpu_to_le32(TXDESC40_AGG_ENABLE);\n\telse\n\t\ttx_desc40->txdw2 |= cpu_to_le32(TXDESC40_AGG_BREAK);\n\n\tif (ieee80211_is_mgmt(hdr->frame_control)) {\n\t\ttx_desc40->txdw4 = cpu_to_le32(rate);\n\t\ttx_desc40->txdw3 |= cpu_to_le32(TXDESC40_USE_DRIVER_RATE);\n\t\ttx_desc40->txdw4 |=\n\t\t\tcpu_to_le32(6 << TXDESC40_RETRY_LIMIT_SHIFT);\n\t\ttx_desc40->txdw4 |= cpu_to_le32(TXDESC40_RETRY_LIMIT_ENABLE);\n\t}\n\n\tif (short_preamble)\n\t\ttx_desc40->txdw5 |= cpu_to_le32(TXDESC40_SHORT_PREAMBLE);\n\n\ttx_desc40->txdw4 |= cpu_to_le32(rts_rate << TXDESC40_RTS_RATE_SHIFT);\n\t/*\n\t * rts_rate is zero if RTS/CTS or CTS to SELF are not enabled\n\t */\n\tif (rate_flags & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\ttx_desc40->txdw3 |= cpu_to_le32(TXDESC40_RTS_CTS_ENABLE);\n\t\ttx_desc40->txdw3 |= cpu_to_le32(TXDESC40_HW_RTS_ENABLE);\n\t} else if (rate_flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\t/*\n\t\t * For some reason the vendor driver doesn't set\n\t\t * TXDESC40_HW_RTS_ENABLE for CTS to SELF\n\t\t */\n\t\ttx_desc40->txdw3 |= cpu_to_le32(TXDESC40_CTS_SELF_ENABLE);\n\t}\n}\n\nstatic void rtl8xxxu_tx(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_tx_control *control,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct rtl8xxxu_txdesc32 *tx_desc;\n\tstruct rtl8xxxu_tx_urb *tx_urb;\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct ieee80211_vif *vif = tx_info->control.vif;\n\tstruct device *dev = &priv->udev->dev;\n\tu32 queue, rts_rate;\n\tu16 pktlen = skb->len;\n\tu16 rate_flag = tx_info->control.rates[0].flags;\n\tint tx_desc_size = priv->fops->tx_desc_size;\n\tint ret;\n\tbool ampdu_enable, sgi = false, short_preamble = false;\n\n\tif (skb_headroom(skb) < tx_desc_size) {\n\t\tdev_warn(dev,\n\t\t\t \"%s: Not enough headroom (%i) for tx descriptor\\n\",\n\t\t\t __func__, skb_headroom(skb));\n\t\tgoto error;\n\t}\n\n\tif (unlikely(skb->len > (65535 - tx_desc_size))) {\n\t\tdev_warn(dev, \"%s: Trying to send over-sized skb (%i)\\n\",\n\t\t\t __func__, skb->len);\n\t\tgoto error;\n\t}\n\n\ttx_urb = rtl8xxxu_alloc_tx_urb(priv);\n\tif (!tx_urb) {\n\t\tdev_warn(dev, \"%s: Unable to allocate tx urb\\n\", __func__);\n\t\tgoto error;\n\t}\n\n\tif (ieee80211_is_action(hdr->frame_control))\n\t\trtl8xxxu_dump_action(dev, hdr);\n\n\ttx_info->rate_driver_data[0] = hw;\n\n\tif (control && control->sta)\n\t\tsta = control->sta;\n\n\ttx_desc = skb_push(skb, tx_desc_size);\n\n\tmemset(tx_desc, 0, tx_desc_size);\n\ttx_desc->pkt_size = cpu_to_le16(pktlen);\n\ttx_desc->pkt_offset = tx_desc_size;\n\n\ttx_desc->txdw0 =\n\t\tTXDESC_OWN | TXDESC_FIRST_SEGMENT | TXDESC_LAST_SEGMENT;\n\tif (is_multicast_ether_addr(ieee80211_get_DA(hdr)) ||\n\t    is_broadcast_ether_addr(ieee80211_get_DA(hdr)))\n\t\ttx_desc->txdw0 |= TXDESC_BROADMULTICAST;\n\n\tqueue = rtl8xxxu_queue_select(hw, skb);\n\ttx_desc->txdw1 = cpu_to_le32(queue << TXDESC_QUEUE_SHIFT);\n\n\tif (tx_info->control.hw_key) {\n\t\tswitch (tx_info->control.hw_key->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\ttx_desc->txdw1 |= cpu_to_le32(TXDESC_SEC_RC4);\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\ttx_desc->txdw1 |= cpu_to_le32(TXDESC_SEC_AES);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* (tx_info->flags & IEEE80211_TX_CTL_AMPDU) && */\n\tampdu_enable = false;\n\tif (ieee80211_is_data_qos(hdr->frame_control) && sta) {\n\t\tif (sta->ht_cap.ht_supported) {\n\t\t\tu32 ampdu, val32;\n\n\t\t\tampdu = (u32)sta->ht_cap.ampdu_density;\n\t\t\tval32 = ampdu << TXDESC_AMPDU_DENSITY_SHIFT;\n\t\t\ttx_desc->txdw2 |= cpu_to_le32(val32);\n\n\t\t\tampdu_enable = true;\n\t\t}\n\t}\n\n\tif (rate_flag & IEEE80211_TX_RC_SHORT_GI ||\n\t    (ieee80211_is_data_qos(hdr->frame_control) &&\n\t     sta && sta->ht_cap.cap &\n\t     (IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20)))\n\t\tsgi = true;\n\n\tif (rate_flag & IEEE80211_TX_RC_USE_SHORT_PREAMBLE ||\n\t    (sta && vif && vif->bss_conf.use_short_preamble))\n\t\tshort_preamble = true;\n\n\tif (rate_flag & IEEE80211_TX_RC_USE_RTS_CTS)\n\t\trts_rate = ieee80211_get_rts_cts_rate(hw, tx_info)->hw_value;\n\telse if (rate_flag & IEEE80211_TX_RC_USE_CTS_PROTECT)\n\t\trts_rate = ieee80211_get_rts_cts_rate(hw, tx_info)->hw_value;\n\telse\n\t\trts_rate = 0;\n\n\n\tpriv->fops->fill_txdesc(hw, hdr, tx_info, tx_desc, sgi, short_preamble,\n\t\t\t\tampdu_enable, rts_rate);\n\n\trtl8xxxu_calc_tx_desc_csum(tx_desc);\n\n\tusb_fill_bulk_urb(&tx_urb->urb, priv->udev, priv->pipe_out[queue],\n\t\t\t  skb->data, skb->len, rtl8xxxu_tx_complete, skb);\n\n\tusb_anchor_urb(&tx_urb->urb, &priv->tx_anchor);\n\tret = usb_submit_urb(&tx_urb->urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tusb_unanchor_urb(&tx_urb->urb);\n\t\trtl8xxxu_free_tx_urb(priv, tx_urb);\n\t\tgoto error;\n\t}\n\treturn;\nerror:\n\tdev_kfree_skb(skb);\n}\n\nstatic void rtl8xxxu_rx_parse_phystats(struct rtl8xxxu_priv *priv,\n\t\t\t\t       struct ieee80211_rx_status *rx_status,\n\t\t\t\t       struct rtl8723au_phy_stats *phy_stats,\n\t\t\t\t       u32 rxmcs)\n{\n\tif (phy_stats->sgi_en)\n\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\n\tif (rxmcs < DESC_RATE_6M) {\n\t\t/*\n\t\t * Handle PHY stats for CCK rates\n\t\t */\n\t\tu8 cck_agc_rpt = phy_stats->cck_agc_rpt_ofdm_cfosho_a;\n\n\t\tswitch (cck_agc_rpt & 0xc0) {\n\t\tcase 0xc0:\n\t\t\trx_status->signal = -46 - (cck_agc_rpt & 0x3e);\n\t\t\tbreak;\n\t\tcase 0x80:\n\t\t\trx_status->signal = -26 - (cck_agc_rpt & 0x3e);\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\t\trx_status->signal = -12 - (cck_agc_rpt & 0x3e);\n\t\t\tbreak;\n\t\tcase 0x00:\n\t\t\trx_status->signal = 16 - (cck_agc_rpt & 0x3e);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trx_status->signal =\n\t\t\t(phy_stats->cck_sig_qual_ofdm_pwdb_all >> 1) - 110;\n\t}\n}\n\nstatic void rtl8xxxu_free_rx_resources(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8xxxu_rx_urb *rx_urb, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->rx_urb_lock, flags);\n\n\tlist_for_each_entry_safe(rx_urb, tmp,\n\t\t\t\t &priv->rx_urb_pending_list, list) {\n\t\tlist_del(&rx_urb->list);\n\t\tpriv->rx_urb_pending_count--;\n\t\tusb_free_urb(&rx_urb->urb);\n\t}\n\n\tspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\n}\n\nstatic void rtl8xxxu_queue_rx_urb(struct rtl8xxxu_priv *priv,\n\t\t\t\t  struct rtl8xxxu_rx_urb *rx_urb)\n{\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tint pending = 0;\n\n\tspin_lock_irqsave(&priv->rx_urb_lock, flags);\n\n\tif (!priv->shutdown) {\n\t\tlist_add_tail(&rx_urb->list, &priv->rx_urb_pending_list);\n\t\tpriv->rx_urb_pending_count++;\n\t\tpending = priv->rx_urb_pending_count;\n\t} else {\n\t\tskb = (struct sk_buff *)rx_urb->urb.context;\n\t\tdev_kfree_skb(skb);\n\t\tusb_free_urb(&rx_urb->urb);\n\t}\n\n\tspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\n\n\tif (pending > RTL8XXXU_RX_URB_PENDING_WATER)\n\t\tschedule_work(&priv->rx_urb_wq);\n}\n\nstatic void rtl8xxxu_rx_urb_work(struct work_struct *work)\n{\n\tstruct rtl8xxxu_priv *priv;\n\tstruct rtl8xxxu_rx_urb *rx_urb, *tmp;\n\tstruct list_head local;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tint ret;\n\n\tpriv = container_of(work, struct rtl8xxxu_priv, rx_urb_wq);\n\tINIT_LIST_HEAD(&local);\n\n\tspin_lock_irqsave(&priv->rx_urb_lock, flags);\n\n\tlist_splice_init(&priv->rx_urb_pending_list, &local);\n\tpriv->rx_urb_pending_count = 0;\n\n\tspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\n\n\tlist_for_each_entry_safe(rx_urb, tmp, &local, list) {\n\t\tlist_del_init(&rx_urb->list);\n\t\tret = rtl8xxxu_submit_rx_urb(priv, rx_urb);\n\t\t/*\n\t\t * If out of memory or temporary error, put it back on the\n\t\t * queue and try again. Otherwise the device is dead/gone\n\t\t * and we should drop it.\n\t\t */\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -ENOMEM:\n\t\tcase -EAGAIN:\n\t\t\trtl8xxxu_queue_rx_urb(priv, rx_urb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"failed to requeue urb %i\\n\", ret);\n\t\t\tskb = (struct sk_buff *)rx_urb->urb.context;\n\t\t\tdev_kfree_skb(skb);\n\t\t\tusb_free_urb(&rx_urb->urb);\n\t\t}\n\t}\n}\n\nstatic void rtl8723bu_handle_c2h(struct rtl8xxxu_priv *priv,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct rtl8723bu_c2h *c2h = (struct rtl8723bu_c2h *)skb->data;\n\tstruct device *dev = &priv->udev->dev;\n\tint len;\n\n\tlen = skb->len - 2;\n\n\tdev_dbg(dev, \"C2H ID %02x seq %02x, len %02x source %02x\\n\",\n\t\tc2h->id, c2h->seq, len, c2h->bt_info.response_source);\n\n\tswitch(c2h->id) {\n\tcase C2H_8723B_BT_INFO:\n\t\tif (c2h->bt_info.response_source >\n\t\t    BT_INFO_SRC_8723B_BT_ACTIVE_SEND)\n\t\t\tdev_dbg(dev, \"C2H_BT_INFO WiFi only firmware\\n\");\n\t\telse\n\t\t\tdev_dbg(dev, \"C2H_BT_INFO BT/WiFi coexist firmware\\n\");\n\n\t\tif (c2h->bt_info.bt_has_reset)\n\t\t\tdev_dbg(dev, \"BT has been reset\\n\");\n\t\tif (c2h->bt_info.tx_rx_mask)\n\t\t\tdev_dbg(dev, \"BT TRx mask\\n\");\n\n\t\tbreak;\n\tcase C2H_8723B_BT_MP_INFO:\n\t\tdev_dbg(dev, \"C2H_MP_INFO ext ID %02x, status %02x\\n\",\n\t\t\tc2h->bt_mp_info.ext_id, c2h->bt_mp_info.status);\n\t\tbreak;\n\tcase C2H_8723B_RA_REPORT:\n\t\tdev_dbg(dev,\n\t\t\t\"C2H RA RPT: rate %02x, unk %i, macid %02x, noise %i\\n\",\n\t\t\tc2h->ra_report.rate, c2h->ra_report.dummy0_0,\n\t\t\tc2h->ra_report.macid, c2h->ra_report.noisy_state);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(dev, \"Unhandled C2H event %02x seq %02x\\n\",\n\t\t\t c2h->id, c2h->seq);\n\t\tprint_hex_dump(KERN_INFO, \"C2H content: \", DUMP_PREFIX_NONE,\n\t\t\t       16, 1, c2h->raw.payload, len, false);\n\t\tbreak;\n\t}\n}\n\nint rtl8xxxu_parse_rxdesc16(struct rtl8xxxu_priv *priv, struct sk_buff *skb)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct rtl8xxxu_rxdesc16 *rx_desc;\n\tstruct rtl8723au_phy_stats *phy_stats;\n\tstruct sk_buff *next_skb = NULL;\n\t__le32 *_rx_desc_le;\n\tu32 *_rx_desc;\n\tint drvinfo_sz, desc_shift;\n\tint i, pkt_cnt, pkt_len, urb_len, pkt_offset;\n\n\turb_len = skb->len;\n\tpkt_cnt = 0;\n\n\tdo {\n\t\trx_desc = (struct rtl8xxxu_rxdesc16 *)skb->data;\n\t\t_rx_desc_le = (__le32 *)skb->data;\n\t\t_rx_desc = (u32 *)skb->data;\n\n\t\tfor (i = 0;\n\t\t     i < (sizeof(struct rtl8xxxu_rxdesc16) / sizeof(u32)); i++)\n\t\t\t_rx_desc[i] = le32_to_cpu(_rx_desc_le[i]);\n\n\t\t/*\n\t\t * Only read pkt_cnt from the header if we're parsing the\n\t\t * first packet\n\t\t */\n\t\tif (!pkt_cnt)\n\t\t\tpkt_cnt = rx_desc->pkt_cnt;\n\t\tpkt_len = rx_desc->pktlen;\n\n\t\tdrvinfo_sz = rx_desc->drvinfo_sz * 8;\n\t\tdesc_shift = rx_desc->shift;\n\t\tpkt_offset = roundup(pkt_len + drvinfo_sz + desc_shift +\n\t\t\t\t     sizeof(struct rtl8xxxu_rxdesc16), 128);\n\n\t\t/*\n\t\t * Only clone the skb if there's enough data at the end to\n\t\t * at least cover the rx descriptor\n\t\t */\n\t\tif (pkt_cnt > 1 &&\n\t\t    urb_len > (pkt_offset + sizeof(struct rtl8xxxu_rxdesc16)))\n\t\t\tnext_skb = skb_clone(skb, GFP_ATOMIC);\n\n\t\trx_status = IEEE80211_SKB_RXCB(skb);\n\t\tmemset(rx_status, 0, sizeof(struct ieee80211_rx_status));\n\n\t\tskb_pull(skb, sizeof(struct rtl8xxxu_rxdesc16));\n\n\t\tphy_stats = (struct rtl8723au_phy_stats *)skb->data;\n\n\t\tskb_pull(skb, drvinfo_sz + desc_shift);\n\n\t\tskb_trim(skb, pkt_len);\n\n\t\tif (rx_desc->phy_stats)\n\t\t\trtl8xxxu_rx_parse_phystats(priv, rx_status, phy_stats,\n\t\t\t\t\t\t   rx_desc->rxmcs);\n\n\t\trx_status->mactime = rx_desc->tsfl;\n\t\trx_status->flag |= RX_FLAG_MACTIME_START;\n\n\t\tif (!rx_desc->swdec)\n\t\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\t\tif (rx_desc->crc32)\n\t\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\t\tif (rx_desc->bw)\n\t\t\trx_status->bw = RATE_INFO_BW_40;\n\n\t\tif (rx_desc->rxht) {\n\t\t\trx_status->encoding = RX_ENC_HT;\n\t\t\trx_status->rate_idx = rx_desc->rxmcs - DESC_RATE_MCS0;\n\t\t} else {\n\t\t\trx_status->rate_idx = rx_desc->rxmcs;\n\t\t}\n\n\t\trx_status->freq = hw->conf.chandef.chan->center_freq;\n\t\trx_status->band = hw->conf.chandef.chan->band;\n\n\t\tieee80211_rx_irqsafe(hw, skb);\n\n\t\tskb = next_skb;\n\t\tif (skb)\n\t\t\tskb_pull(next_skb, pkt_offset);\n\n\t\tpkt_cnt--;\n\t\turb_len -= pkt_offset;\n\t} while (skb && urb_len > 0 && pkt_cnt > 0);\n\n\treturn RX_TYPE_DATA_PKT;\n}\n\nint rtl8xxxu_parse_rxdesc24(struct rtl8xxxu_priv *priv, struct sk_buff *skb)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tstruct rtl8xxxu_rxdesc24 *rx_desc =\n\t\t(struct rtl8xxxu_rxdesc24 *)skb->data;\n\tstruct rtl8723au_phy_stats *phy_stats;\n\t__le32 *_rx_desc_le = (__le32 *)skb->data;\n\tu32 *_rx_desc = (u32 *)skb->data;\n\tint drvinfo_sz, desc_shift;\n\tint i;\n\n\tfor (i = 0; i < (sizeof(struct rtl8xxxu_rxdesc24) / sizeof(u32)); i++)\n\t\t_rx_desc[i] = le32_to_cpu(_rx_desc_le[i]);\n\n\tmemset(rx_status, 0, sizeof(struct ieee80211_rx_status));\n\n\tskb_pull(skb, sizeof(struct rtl8xxxu_rxdesc24));\n\n\tphy_stats = (struct rtl8723au_phy_stats *)skb->data;\n\n\tdrvinfo_sz = rx_desc->drvinfo_sz * 8;\n\tdesc_shift = rx_desc->shift;\n\tskb_pull(skb, drvinfo_sz + desc_shift);\n\n\tif (rx_desc->rpt_sel) {\n\t\tstruct device *dev = &priv->udev->dev;\n\t\tdev_dbg(dev, \"%s: C2H packet\\n\", __func__);\n\t\trtl8723bu_handle_c2h(priv, skb);\n\t\tdev_kfree_skb(skb);\n\t\treturn RX_TYPE_C2H;\n\t}\n\n\tif (rx_desc->phy_stats)\n\t\trtl8xxxu_rx_parse_phystats(priv, rx_status, phy_stats,\n\t\t\t\t\t   rx_desc->rxmcs);\n\n\trx_status->mactime = rx_desc->tsfl;\n\trx_status->flag |= RX_FLAG_MACTIME_START;\n\n\tif (!rx_desc->swdec)\n\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\tif (rx_desc->crc32)\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\tif (rx_desc->bw)\n\t\trx_status->bw = RATE_INFO_BW_40;\n\n\tif (rx_desc->rxmcs >= DESC_RATE_MCS0) {\n\t\trx_status->encoding = RX_ENC_HT;\n\t\trx_status->rate_idx = rx_desc->rxmcs - DESC_RATE_MCS0;\n\t} else {\n\t\trx_status->rate_idx = rx_desc->rxmcs;\n\t}\n\n\trx_status->freq = hw->conf.chandef.chan->center_freq;\n\trx_status->band = hw->conf.chandef.chan->band;\n\n\tieee80211_rx_irqsafe(hw, skb);\n\treturn RX_TYPE_DATA_PKT;\n}\n\nstatic void rtl8xxxu_rx_complete(struct urb *urb)\n{\n\tstruct rtl8xxxu_rx_urb *rx_urb =\n\t\tcontainer_of(urb, struct rtl8xxxu_rx_urb, urb);\n\tstruct ieee80211_hw *hw = rx_urb->hw;\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct sk_buff *skb = (struct sk_buff *)urb->context;\n\tstruct device *dev = &priv->udev->dev;\n\n\tskb_put(skb, urb->actual_length);\n\n\tif (urb->status == 0) {\n\t\tpriv->fops->parse_rx_desc(priv, skb);\n\n\t\tskb = NULL;\n\t\trx_urb->urb.context = NULL;\n\t\trtl8xxxu_queue_rx_urb(priv, rx_urb);\n\t} else {\n\t\tdev_dbg(dev, \"%s: status %i\\n\",\t__func__, urb->status);\n\t\tgoto cleanup;\n\t}\n\treturn;\n\ncleanup:\n\tusb_free_urb(urb);\n\tdev_kfree_skb(skb);\n\treturn;\n}\n\nstatic int rtl8xxxu_submit_rx_urb(struct rtl8xxxu_priv *priv,\n\t\t\t\t  struct rtl8xxxu_rx_urb *rx_urb)\n{\n\tstruct rtl8xxxu_fileops *fops = priv->fops;\n\tstruct sk_buff *skb;\n\tint skb_size;\n\tint ret, rx_desc_sz;\n\n\trx_desc_sz = fops->rx_desc_size;\n\n\tif (priv->rx_buf_aggregation && fops->rx_agg_buf_size) {\n\t\tskb_size = fops->rx_agg_buf_size;\n\t\tskb_size += (rx_desc_sz + sizeof(struct rtl8723au_phy_stats));\n\t} else {\n\t\tskb_size = IEEE80211_MAX_FRAME_LEN;\n\t}\n\n\tskb = __netdev_alloc_skb(NULL, skb_size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, rx_desc_sz);\n\tusb_fill_bulk_urb(&rx_urb->urb, priv->udev, priv->pipe_in, skb->data,\n\t\t\t  skb_size, rtl8xxxu_rx_complete, skb);\n\tusb_anchor_urb(&rx_urb->urb, &priv->rx_anchor);\n\tret = usb_submit_urb(&rx_urb->urb, GFP_ATOMIC);\n\tif (ret)\n\t\tusb_unanchor_urb(&rx_urb->urb);\n\treturn ret;\n}\n\nstatic void rtl8xxxu_int_complete(struct urb *urb)\n{\n\tstruct rtl8xxxu_priv *priv = (struct rtl8xxxu_priv *)urb->context;\n\tstruct device *dev = &priv->udev->dev;\n\tint ret;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_INTERRUPT)\n\t\tdev_dbg(dev, \"%s: status %i\\n\", __func__, urb->status);\n\tif (urb->status == 0) {\n\t\tusb_anchor_urb(urb, &priv->int_anchor);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret)\n\t\t\tusb_unanchor_urb(urb);\n\t} else {\n\t\tdev_dbg(dev, \"%s: Error %i\\n\", __func__, urb->status);\n\t}\n}\n\n\nstatic int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tgoto error;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\n\nerror:\n\treturn ret;\n}\n\nstatic int rtl8xxxu_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tint ret;\n\tu8 val8;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\trtl8xxxu_stop_tx_beacon(priv);\n\n\t\tval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\n\t\tval8 |= BEACON_ATIM | BEACON_FUNCTION_ENABLE |\n\t\t\tBEACON_DISABLE_TSF_UPDATE;\n\t\trtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\trtl8xxxu_set_linktype(priv, vif->type);\n\n\treturn ret;\n}\n\nstatic void rtl8xxxu_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\n\tdev_dbg(&priv->udev->dev, \"%s\\n\", __func__);\n}\n\nstatic int rtl8xxxu_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tu16 val16;\n\tint ret = 0, channel;\n\tbool ht40;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_CHANNEL)\n\t\tdev_info(dev,\n\t\t\t \"%s: channel: %i (changed %08x chandef.width %02x)\\n\",\n\t\t\t __func__, hw->conf.chandef.chan->hw_value,\n\t\t\t changed, hw->conf.chandef.width);\n\n\tif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {\n\t\tval16 = ((hw->conf.long_frame_max_tx_count <<\n\t\t\t  RETRY_LIMIT_LONG_SHIFT) & RETRY_LIMIT_LONG_MASK) |\n\t\t\t((hw->conf.short_frame_max_tx_count <<\n\t\t\t  RETRY_LIMIT_SHORT_SHIFT) & RETRY_LIMIT_SHORT_MASK);\n\t\trtl8xxxu_write16(priv, REG_RETRY_LIMIT, val16);\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tswitch (hw->conf.chandef.width) {\n\t\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tcase NL80211_CHAN_WIDTH_20:\n\t\t\tht40 = false;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_40:\n\t\t\tht40 = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tchannel = hw->conf.chandef.chan->hw_value;\n\n\t\tpriv->fops->set_tx_power(priv, channel, ht40);\n\n\t\tpriv->fops->config_channel(hw);\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int rtl8xxxu_conf_tx(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif, u16 queue,\n\t\t\t    const struct ieee80211_tx_queue_params *param)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tu32 val32;\n\tu8 aifs, acm_ctrl, acm_bit;\n\n\taifs = param->aifs;\n\n\tval32 = aifs |\n\t\tfls(param->cw_min) << EDCA_PARAM_ECW_MIN_SHIFT |\n\t\tfls(param->cw_max) << EDCA_PARAM_ECW_MAX_SHIFT |\n\t\t(u32)param->txop << EDCA_PARAM_TXOP_SHIFT;\n\n\tacm_ctrl = rtl8xxxu_read8(priv, REG_ACM_HW_CTRL);\n\tdev_dbg(dev,\n\t\t\"%s: IEEE80211 queue %02x val %08x, acm %i, acm_ctrl %02x\\n\",\n\t\t__func__, queue, val32, param->acm, acm_ctrl);\n\n\tswitch (queue) {\n\tcase IEEE80211_AC_VO:\n\t\tacm_bit = ACM_HW_CTRL_VO;\n\t\trtl8xxxu_write32(priv, REG_EDCA_VO_PARAM, val32);\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\tacm_bit = ACM_HW_CTRL_VI;\n\t\trtl8xxxu_write32(priv, REG_EDCA_VI_PARAM, val32);\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\tacm_bit = ACM_HW_CTRL_BE;\n\t\trtl8xxxu_write32(priv, REG_EDCA_BE_PARAM, val32);\n\t\tbreak;\n\tcase IEEE80211_AC_BK:\n\t\tacm_bit = ACM_HW_CTRL_BK;\n\t\trtl8xxxu_write32(priv, REG_EDCA_BK_PARAM, val32);\n\t\tbreak;\n\tdefault:\n\t\tacm_bit = 0;\n\t\tbreak;\n\t}\n\n\tif (param->acm)\n\t\tacm_ctrl |= acm_bit;\n\telse\n\t\tacm_ctrl &= ~acm_bit;\n\trtl8xxxu_write8(priv, REG_ACM_HW_CTRL, acm_ctrl);\n\n\treturn 0;\n}\n\nstatic void rtl8xxxu_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t      unsigned int changed_flags,\n\t\t\t\t      unsigned int *total_flags, u64 multicast)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tu32 rcr = rtl8xxxu_read32(priv, REG_RCR);\n\n\tdev_dbg(&priv->udev->dev, \"%s: changed_flags %08x, total_flags %08x\\n\",\n\t\t__func__, changed_flags, *total_flags);\n\n\t/*\n\t * FIF_ALLMULTI ignored as all multicast frames are accepted (REG_MAR)\n\t */\n\n\tif (*total_flags & FIF_FCSFAIL)\n\t\trcr |= RCR_ACCEPT_CRC32;\n\telse\n\t\trcr &= ~RCR_ACCEPT_CRC32;\n\n\t/*\n\t * FIF_PLCPFAIL not supported?\n\t */\n\n\tif (*total_flags & FIF_BCN_PRBRESP_PROMISC)\n\t\trcr &= ~RCR_CHECK_BSSID_BEACON;\n\telse\n\t\trcr |= RCR_CHECK_BSSID_BEACON;\n\n\tif (*total_flags & FIF_CONTROL)\n\t\trcr |= RCR_ACCEPT_CTRL_FRAME;\n\telse\n\t\trcr &= ~RCR_ACCEPT_CTRL_FRAME;\n\n\tif (*total_flags & FIF_OTHER_BSS) {\n\t\trcr |= RCR_ACCEPT_AP;\n\t\trcr &= ~RCR_CHECK_BSSID_MATCH;\n\t} else {\n\t\trcr &= ~RCR_ACCEPT_AP;\n\t\trcr |= RCR_CHECK_BSSID_MATCH;\n\t}\n\n\tif (*total_flags & FIF_PSPOLL)\n\t\trcr |= RCR_ACCEPT_PM;\n\telse\n\t\trcr &= ~RCR_ACCEPT_PM;\n\n\t/*\n\t * FIF_PROBE_REQ ignored as probe requests always seem to be accepted\n\t */\n\n\trtl8xxxu_write32(priv, REG_RCR, rcr);\n\n\t*total_flags &= (FIF_ALLMULTI | FIF_FCSFAIL | FIF_BCN_PRBRESP_PROMISC |\n\t\t\t FIF_CONTROL | FIF_OTHER_BSS | FIF_PSPOLL |\n\t\t\t FIF_PROBE_REQ);\n}\n\nstatic int rtl8xxxu_set_rts_threshold(struct ieee80211_hw *hw, u32 rts)\n{\n\tif (rts > 2347)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int rtl8xxxu_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct ieee80211_key_conf *key)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tu8 mac_addr[ETH_ALEN];\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\tint retval = -EOPNOTSUPP;\n\n\tdev_dbg(dev, \"%s: cmd %02x, cipher %08x, index %i\\n\",\n\t\t__func__, cmd, key->cipher, key->keyidx);\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (key->keyidx > 3)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\n\t\tdev_dbg(dev, \"%s: pairwise key\\n\", __func__);\n\t\tether_addr_copy(mac_addr, sta->addr);\n\t} else {\n\t\tdev_dbg(dev, \"%s: group key\\n\", __func__);\n\t\teth_broadcast_addr(mac_addr);\n\t}\n\n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 |= CR_SECURITY_ENABLE;\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\n\tval8 = SEC_CFG_TX_SEC_ENABLE | SEC_CFG_TXBC_USE_DEFKEY |\n\t\tSEC_CFG_RX_SEC_ENABLE | SEC_CFG_RXBC_USE_DEFKEY;\n\tval8 |= SEC_CFG_TX_USE_DEFKEY | SEC_CFG_RX_USE_DEFKEY;\n\trtl8xxxu_write8(priv, REG_SECURITY_CFG, val8);\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tkey->hw_key_idx = key->keyidx;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\trtl8xxxu_cam_write(priv, key, mac_addr);\n\t\tretval = 0;\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\trtl8xxxu_write32(priv, REG_CAM_WRITE, 0x00000000);\n\t\tval32 = CAM_CMD_POLLING | CAM_CMD_WRITE |\n\t\t\tkey->keyidx << CAM_CMD_KEY_SHIFT;\n\t\trtl8xxxu_write32(priv, REG_CAM_CMD, val32);\n\t\tretval = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"%s: Unsupported command %02x\\n\", __func__, cmd);\n\t}\n\n\treturn retval;\n}\n\nstatic int\nrtl8xxxu_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t      struct ieee80211_ampdu_params *params)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tu8 ampdu_factor, ampdu_density;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tdev_dbg(dev, \"%s: IEEE80211_AMPDU_TX_START\\n\", __func__);\n\t\tampdu_factor = sta->ht_cap.ampdu_factor;\n\t\tampdu_density = sta->ht_cap.ampdu_density;\n\t\trtl8xxxu_set_ampdu_factor(priv, ampdu_factor);\n\t\trtl8xxxu_set_ampdu_min_space(priv, ampdu_density);\n\t\tdev_dbg(dev,\n\t\t\t\"Changed HT: ampdu_factor %02x, ampdu_density %02x\\n\",\n\t\t\tampdu_factor, ampdu_density);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\t\tdev_dbg(dev, \"%s: IEEE80211_AMPDU_TX_STOP_FLUSH\\n\", __func__);\n\t\trtl8xxxu_set_ampdu_factor(priv, 0);\n\t\trtl8xxxu_set_ampdu_min_space(priv, 0);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tdev_dbg(dev, \"%s: IEEE80211_AMPDU_TX_STOP_FLUSH_CONT\\n\",\n\t\t\t __func__);\n\t\trtl8xxxu_set_ampdu_factor(priv, 0);\n\t\trtl8xxxu_set_ampdu_min_space(priv, 0);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tdev_dbg(dev, \"%s: IEEE80211_AMPDU_RX_START\\n\", __func__);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tdev_dbg(dev, \"%s: IEEE80211_AMPDU_RX_STOP\\n\", __func__);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rtl8xxxu_start(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct rtl8xxxu_rx_urb *rx_urb;\n\tstruct rtl8xxxu_tx_urb *tx_urb;\n\tunsigned long flags;\n\tint ret, i;\n\n\tret = 0;\n\n\tinit_usb_anchor(&priv->rx_anchor);\n\tinit_usb_anchor(&priv->tx_anchor);\n\tinit_usb_anchor(&priv->int_anchor);\n\n\tpriv->fops->enable_rf(priv);\n\tif (priv->usb_interrupts) {\n\t\tret = rtl8xxxu_submit_int_urb(hw);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < RTL8XXXU_TX_URBS; i++) {\n\t\ttx_urb = kmalloc(sizeof(struct rtl8xxxu_tx_urb), GFP_KERNEL);\n\t\tif (!tx_urb) {\n\t\t\tif (!i)\n\t\t\t\tret = -ENOMEM;\n\n\t\t\tgoto error_out;\n\t\t}\n\t\tusb_init_urb(&tx_urb->urb);\n\t\tINIT_LIST_HEAD(&tx_urb->list);\n\t\ttx_urb->hw = hw;\n\t\tlist_add(&tx_urb->list, &priv->tx_urb_free_list);\n\t\tpriv->tx_urb_free_count++;\n\t}\n\n\tpriv->tx_stopped = false;\n\n\tspin_lock_irqsave(&priv->rx_urb_lock, flags);\n\tpriv->shutdown = false;\n\tspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\n\n\tfor (i = 0; i < RTL8XXXU_RX_URBS; i++) {\n\t\trx_urb = kmalloc(sizeof(struct rtl8xxxu_rx_urb), GFP_KERNEL);\n\t\tif (!rx_urb) {\n\t\t\tif (!i)\n\t\t\t\tret = -ENOMEM;\n\n\t\t\tgoto error_out;\n\t\t}\n\t\tusb_init_urb(&rx_urb->urb);\n\t\tINIT_LIST_HEAD(&rx_urb->list);\n\t\trx_urb->hw = hw;\n\n\t\tret = rtl8xxxu_submit_rx_urb(priv, rx_urb);\n\t}\nexit:\n\t/*\n\t * Accept all data and mgmt frames\n\t */\n\trtl8xxxu_write16(priv, REG_RXFLTMAP2, 0xffff);\n\trtl8xxxu_write16(priv, REG_RXFLTMAP0, 0xffff);\n\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_AGC_CORE1, 0x6954341e);\n\n\treturn ret;\n\nerror_out:\n\trtl8xxxu_free_tx_resources(priv);\n\t/*\n\t * Disable all data and mgmt frames\n\t */\n\trtl8xxxu_write16(priv, REG_RXFLTMAP2, 0x0000);\n\trtl8xxxu_write16(priv, REG_RXFLTMAP0, 0x0000);\n\n\treturn ret;\n}\n\nstatic void rtl8xxxu_stop(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tunsigned long flags;\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\n\trtl8xxxu_write16(priv, REG_RXFLTMAP0, 0x0000);\n\trtl8xxxu_write16(priv, REG_RXFLTMAP2, 0x0000);\n\n\tspin_lock_irqsave(&priv->rx_urb_lock, flags);\n\tpriv->shutdown = true;\n\tspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\n\n\tusb_kill_anchored_urbs(&priv->rx_anchor);\n\tusb_kill_anchored_urbs(&priv->tx_anchor);\n\tif (priv->usb_interrupts)\n\t\tusb_kill_anchored_urbs(&priv->int_anchor);\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\n\tpriv->fops->disable_rf(priv);\n\n\t/*\n\t * Disable interrupts\n\t */\n\tif (priv->usb_interrupts)\n\t\trtl8xxxu_write32(priv, REG_USB_HIMR, 0);\n\n\trtl8xxxu_free_rx_resources(priv);\n\trtl8xxxu_free_tx_resources(priv);\n}\n\nstatic const struct ieee80211_ops rtl8xxxu_ops = {\n\t.tx = rtl8xxxu_tx,\n\t.add_interface = rtl8xxxu_add_interface,\n\t.remove_interface = rtl8xxxu_remove_interface,\n\t.config = rtl8xxxu_config,\n\t.conf_tx = rtl8xxxu_conf_tx,\n\t.bss_info_changed = rtl8xxxu_bss_info_changed,\n\t.configure_filter = rtl8xxxu_configure_filter,\n\t.set_rts_threshold = rtl8xxxu_set_rts_threshold,\n\t.start = rtl8xxxu_start,\n\t.stop = rtl8xxxu_stop,\n\t.sw_scan_start = rtl8xxxu_sw_scan_start,\n\t.sw_scan_complete = rtl8xxxu_sw_scan_complete,\n\t.set_key = rtl8xxxu_set_key,\n\t.ampdu_action = rtl8xxxu_ampdu_action,\n};\n\nstatic int rtl8xxxu_parse_usb(struct rtl8xxxu_priv *priv,\n\t\t\t      struct usb_interface *interface)\n{\n\tstruct usb_interface_descriptor *interface_desc;\n\tstruct usb_host_interface *host_interface;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct device *dev = &priv->udev->dev;\n\tint i, j = 0, endpoints;\n\tu8 dir, xtype, num;\n\tint ret = 0;\n\n\thost_interface = &interface->altsetting[0];\n\tinterface_desc = &host_interface->desc;\n\tendpoints = interface_desc->bNumEndpoints;\n\n\tfor (i = 0; i < endpoints; i++) {\n\t\tendpoint = &host_interface->endpoint[i].desc;\n\n\t\tdir = endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK;\n\t\tnum = usb_endpoint_num(endpoint);\n\t\txtype = usb_endpoint_type(endpoint);\n\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s: endpoint: dir %02x, # %02x, type %02x\\n\",\n\t\t\t\t__func__, dir, num, xtype);\n\t\tif (usb_endpoint_dir_in(endpoint) &&\n\t\t    usb_endpoint_xfer_bulk(endpoint)) {\n\t\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\n\t\t\t\tdev_dbg(dev, \"%s: in endpoint num %i\\n\",\n\t\t\t\t\t__func__, num);\n\n\t\t\tif (priv->pipe_in) {\n\t\t\t\tdev_warn(dev,\n\t\t\t\t\t \"%s: Too many IN pipes\\n\", __func__);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tpriv->pipe_in =\tusb_rcvbulkpipe(priv->udev, num);\n\t\t}\n\n\t\tif (usb_endpoint_dir_in(endpoint) &&\n\t\t    usb_endpoint_xfer_int(endpoint)) {\n\t\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\n\t\t\t\tdev_dbg(dev, \"%s: interrupt endpoint num %i\\n\",\n\t\t\t\t\t__func__, num);\n\n\t\t\tif (priv->pipe_interrupt) {\n\t\t\t\tdev_warn(dev, \"%s: Too many INTERRUPT pipes\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tpriv->pipe_interrupt = usb_rcvintpipe(priv->udev, num);\n\t\t}\n\n\t\tif (usb_endpoint_dir_out(endpoint) &&\n\t\t    usb_endpoint_xfer_bulk(endpoint)) {\n\t\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\n\t\t\t\tdev_dbg(dev, \"%s: out endpoint num %i\\n\",\n\t\t\t\t\t__func__, num);\n\t\t\tif (j >= RTL8XXXU_OUT_ENDPOINTS) {\n\t\t\t\tdev_warn(dev,\n\t\t\t\t\t \"%s: Too many OUT pipes\\n\", __func__);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tpriv->out_ep[j++] = num;\n\t\t}\n\t}\nexit:\n\tpriv->nr_out_eps = j;\n\treturn ret;\n}\n\nstatic int rtl8xxxu_probe(struct usb_interface *interface,\n\t\t\t  const struct usb_device_id *id)\n{\n\tstruct rtl8xxxu_priv *priv;\n\tstruct ieee80211_hw *hw;\n\tstruct usb_device *udev;\n\tstruct ieee80211_supported_band *sband;\n\tint ret;\n\tint untested = 1;\n\n\tudev = usb_get_dev(interface_to_usbdev(interface));\n\n\tswitch (id->idVendor) {\n\tcase USB_VENDOR_ID_REALTEK:\n\t\tswitch(id->idProduct) {\n\t\tcase 0x1724:\n\t\tcase 0x8176:\n\t\tcase 0x8178:\n\t\tcase 0x817f:\n\t\tcase 0x818b:\n\t\t\tuntested = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 0x7392:\n\t\tif (id->idProduct == 0x7811)\n\t\t\tuntested = 0;\n\t\tbreak;\n\tcase 0x050d:\n\t\tif (id->idProduct == 0x1004)\n\t\t\tuntested = 0;\n\t\tbreak;\n\tcase 0x20f4:\n\t\tif (id->idProduct == 0x648b)\n\t\t\tuntested = 0;\n\t\tbreak;\n\tcase 0x2001:\n\t\tif (id->idProduct == 0x3308)\n\t\t\tuntested = 0;\n\t\tbreak;\n\tcase 0x2357:\n\t\tif (id->idProduct == 0x0109)\n\t\t\tuntested = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (untested) {\n\t\trtl8xxxu_debug |= RTL8XXXU_DEBUG_EFUSE;\n\t\tdev_info(&udev->dev,\n\t\t\t \"This Realtek USB WiFi dongle (0x%04x:0x%04x) is untested!\\n\",\n\t\t\t id->idVendor, id->idProduct);\n\t\tdev_info(&udev->dev,\n\t\t\t \"Please report results to Jes.Sorensen@gmail.com\\n\");\n\t}\n\n\thw = ieee80211_alloc_hw(sizeof(struct rtl8xxxu_priv), &rtl8xxxu_ops);\n\tif (!hw) {\n\t\tret = -ENOMEM;\n\t\tpriv = NULL;\n\t\tgoto exit;\n\t}\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tpriv->udev = udev;\n\tpriv->fops = (struct rtl8xxxu_fileops *)id->driver_info;\n\tmutex_init(&priv->usb_buf_mutex);\n\tmutex_init(&priv->h2c_mutex);\n\tINIT_LIST_HEAD(&priv->tx_urb_free_list);\n\tspin_lock_init(&priv->tx_urb_lock);\n\tINIT_LIST_HEAD(&priv->rx_urb_pending_list);\n\tspin_lock_init(&priv->rx_urb_lock);\n\tINIT_WORK(&priv->rx_urb_wq, rtl8xxxu_rx_urb_work);\n\n\tusb_set_intfdata(interface, hw);\n\n\tret = rtl8xxxu_parse_usb(priv, interface);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = rtl8xxxu_identify_chip(priv);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"Fatal - failed to identify chip\\n\");\n\t\tgoto exit;\n\t}\n\n\tret = rtl8xxxu_read_efuse(priv);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"Fatal - failed to read EFuse\\n\");\n\t\tgoto exit;\n\t}\n\n\tret = priv->fops->parse_efuse(priv);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"Fatal - failed to parse EFuse\\n\");\n\t\tgoto exit;\n\t}\n\n\trtl8xxxu_print_chipinfo(priv);\n\n\tret = priv->fops->load_firmware(priv);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"Fatal - failed to load firmware\\n\");\n\t\tgoto exit;\n\t}\n\n\tret = rtl8xxxu_init_device(hw);\n\tif (ret)\n\t\tgoto exit;\n\n\thw->wiphy->max_scan_ssids = 1;\n\thw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\thw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\n\thw->queues = 4;\n\n\tsband = &rtl8xxxu_supported_band;\n\tsband->ht_cap.ht_supported = true;\n\tsband->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tsband->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;\n\tsband->ht_cap.cap = IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_SGI_40;\n\tmemset(&sband->ht_cap.mcs, 0, sizeof(sband->ht_cap.mcs));\n\tsband->ht_cap.mcs.rx_mask[0] = 0xff;\n\tsband->ht_cap.mcs.rx_mask[4] = 0x01;\n\tif (priv->rf_paths > 1) {\n\t\tsband->ht_cap.mcs.rx_mask[1] = 0xff;\n\t\tsband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\n\t}\n\tsband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\t/*\n\t * Some APs will negotiate HT20_40 in a noisy environment leading\n\t * to miserable performance. Rather than defaulting to this, only\n\t * enable it if explicitly requested at module load time.\n\t */\n\tif (rtl8xxxu_ht40_2g) {\n\t\tdev_info(&udev->dev, \"Enabling HT_20_40 on the 2.4GHz band\\n\");\n\t\tsband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\thw->wiphy->bands[NL80211_BAND_2GHZ] = sband;\n\n\thw->wiphy->rts_threshold = 2347;\n\n\tSET_IEEE80211_DEV(priv->hw, &interface->dev);\n\tSET_IEEE80211_PERM_ADDR(hw, priv->mac_addr);\n\n\thw->extra_tx_headroom = priv->fops->tx_desc_size;\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\t/*\n\t * The firmware handles rate control\n\t */\n\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tret = ieee80211_register_hw(priv->hw);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"%s: Failed to register: %i\\n\",\n\t\t\t__func__, ret);\n\t\tgoto exit;\n\t}\n\n\treturn 0;\n\nexit:\n\tusb_set_intfdata(interface, NULL);\n\n\tif (priv) {\n\t\tkfree(priv->fw_data);\n\t\tmutex_destroy(&priv->usb_buf_mutex);\n\t\tmutex_destroy(&priv->h2c_mutex);\n\t}\n\tusb_put_dev(udev);\n\n\tieee80211_free_hw(hw);\n\n\treturn ret;\n}\n\nstatic void rtl8xxxu_disconnect(struct usb_interface *interface)\n{\n\tstruct rtl8xxxu_priv *priv;\n\tstruct ieee80211_hw *hw;\n\n\thw = usb_get_intfdata(interface);\n\tpriv = hw->priv;\n\n\tieee80211_unregister_hw(hw);\n\n\tpriv->fops->power_off(priv);\n\n\tusb_set_intfdata(interface, NULL);\n\n\tdev_info(&priv->udev->dev, \"disconnecting\\n\");\n\n\tkfree(priv->fw_data);\n\tmutex_destroy(&priv->usb_buf_mutex);\n\tmutex_destroy(&priv->h2c_mutex);\n\n\tif (priv->udev->state != USB_STATE_NOTATTACHED) {\n\t\tdev_info(&priv->udev->dev,\n\t\t\t \"Device still attached, trying to reset\\n\");\n\t\tusb_reset_device(priv->udev);\n\t}\n\tusb_put_dev(priv->udev);\n\tieee80211_free_hw(hw);\n}\n\nstatic const struct usb_device_id dev_table[] = {\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8724, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8723au_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x1724, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8723au_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x0724, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8723au_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x818b, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n/* TP-Link TL-WN822N v4 */\n{USB_DEVICE_AND_INTERFACE_INFO(0x2357, 0x0108, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n/* D-Link DWA-131 rev E1, tested by David Pati\u00f1o */\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x3319, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n/* Tested by Myckel Habets */\n{USB_DEVICE_AND_INTERFACE_INFO(0x2357, 0x0109, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0xb720, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8723bu_fops},\n#ifdef CONFIG_RTL8XXXU_UNTESTED\n/* Still supported by rtlwifi */\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8176, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8178, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x817f, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Tested by Larry Finger */\n{USB_DEVICE_AND_INTERFACE_INFO(0x7392, 0x7811, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Tested by Andrea Merello */\n{USB_DEVICE_AND_INTERFACE_INFO(0x050d, 0x1004, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Tested by Jocelyn Mayer */\n{USB_DEVICE_AND_INTERFACE_INFO(0x20f4, 0x648b, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Tested by Stefano Bravi */\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x3308, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Currently untested 8188 series devices */\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x018a, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8191, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8170, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8177, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x817a, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x817b, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x817d, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x817e, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x818a, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x317f, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x1058, 0x0631, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04bb, 0x094c, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x050d, 0x1102, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x06f8, 0xe033, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x07b8, 0x8189, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0846, 0x9041, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0b05, 0x17ba, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x1e1e, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x5088, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0df6, 0x0052, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0df6, 0x005c, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0eb0, 0x9071, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x103c, 0x1629, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x13d3, 0x3357, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x330b, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0x4902, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xab2a, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xab2e, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xed17, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x4855, 0x0090, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x4856, 0x0091, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0xcdab, 0x8010, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaff7, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaff9, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaffa, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaff8, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaffb, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaffc, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0x1201, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Currently untested 8192 series devices */\n{USB_DEVICE_AND_INTERFACE_INFO(0x04bb, 0x0950, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x050d, 0x2102, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x050d, 0x2103, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0586, 0x341f, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x06f8, 0xe035, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0b05, 0x17ab, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0df6, 0x0061, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0df6, 0x0070, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0789, 0x016d, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x07aa, 0x0056, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x07b8, 0x8178, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0846, 0x9021, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0846, 0xf001, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x2e2e, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0e66, 0x0019, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0e66, 0x0020, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x3307, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x3309, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x330a, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xab2b, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x20f4, 0x624d, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2357, 0x0100, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x4855, 0x0091, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x7392, 0x7822, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* found in rtl8192eu vendor driver */\n{USB_DEVICE_AND_INTERFACE_INFO(0x2357, 0x0107, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xab33, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x818c, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n#endif\n{ }\n};\n\nstatic struct usb_driver rtl8xxxu_driver = {\n\t.name = DRIVER_NAME,\n\t.probe = rtl8xxxu_probe,\n\t.disconnect = rtl8xxxu_disconnect,\n\t.id_table = dev_table,\n\t.no_dynamic_id = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nstatic int __init rtl8xxxu_module_init(void)\n{\n\tint res;\n\n\tres = usb_register(&rtl8xxxu_driver);\n\tif (res < 0)\n\t\tpr_err(DRIVER_NAME \": usb_register() failed (%i)\\n\", res);\n\n\treturn res;\n}\n\nstatic void __exit rtl8xxxu_module_exit(void)\n{\n\tusb_deregister(&rtl8xxxu_driver);\n}\n\n\nMODULE_DEVICE_TABLE(usb, dev_table);\n\nmodule_init(rtl8xxxu_module_init);\nmodule_exit(rtl8xxxu_module_exit);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * RTL8XXXU mac80211 USB driver\n *\n * Copyright (c) 2014 - 2017 Jes Sorensen <Jes.Sorensen@gmail.com>\n *\n * Portions, notably calibration code:\n * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.\n *\n * This driver was written as a replacement for the vendor provided\n * rtl8723au driver. As the Realtek 8xxx chips are very similar in\n * their programming interface, I have started adding support for\n * additional 8xxx chips like the 8192cu, 8188cus, etc.\n */\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/wireless.h>\n#include <linux/firmware.h>\n#include <linux/moduleparam.h>\n#include <net/mac80211.h>\n#include \"rtl8xxxu.h\"\n#include \"rtl8xxxu_regs.h\"\n\n#define DRIVER_NAME \"rtl8xxxu\"\n\nint rtl8xxxu_debug = RTL8XXXU_DEBUG_EFUSE;\nstatic bool rtl8xxxu_ht40_2g;\nstatic bool rtl8xxxu_dma_aggregation;\nstatic int rtl8xxxu_dma_agg_timeout = -1;\nstatic int rtl8xxxu_dma_agg_pages = -1;\n\nMODULE_AUTHOR(\"Jes Sorensen <Jes.Sorensen@gmail.com>\");\nMODULE_DESCRIPTION(\"RTL8XXXu USB mac80211 Wireless LAN Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8723aufw_A.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8723aufw_B.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8723aufw_B_NoBT.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8192cufw_A.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8192cufw_B.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8192cufw_TMSC.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8192eu_nic.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8723bu_nic.bin\");\nMODULE_FIRMWARE(\"rtlwifi/rtl8723bu_bt.bin\");\n\nmodule_param_named(debug, rtl8xxxu_debug, int, 0600);\nMODULE_PARM_DESC(debug, \"Set debug mask\");\nmodule_param_named(ht40_2g, rtl8xxxu_ht40_2g, bool, 0600);\nMODULE_PARM_DESC(ht40_2g, \"Enable HT40 support on the 2.4GHz band\");\nmodule_param_named(dma_aggregation, rtl8xxxu_dma_aggregation, bool, 0600);\nMODULE_PARM_DESC(dma_aggregation, \"Enable DMA packet aggregation\");\nmodule_param_named(dma_agg_timeout, rtl8xxxu_dma_agg_timeout, int, 0600);\nMODULE_PARM_DESC(dma_agg_timeout, \"Set DMA aggregation timeout (range 1-127)\");\nmodule_param_named(dma_agg_pages, rtl8xxxu_dma_agg_pages, int, 0600);\nMODULE_PARM_DESC(dma_agg_pages, \"Set DMA aggregation pages (range 1-127, 0 to disable)\");\n\n#define USB_VENDOR_ID_REALTEK\t\t0x0bda\n#define RTL8XXXU_RX_URBS\t\t32\n#define RTL8XXXU_RX_URB_PENDING_WATER\t8\n#define RTL8XXXU_TX_URBS\t\t64\n#define RTL8XXXU_TX_URB_LOW_WATER\t25\n#define RTL8XXXU_TX_URB_HIGH_WATER\t32\n\nstatic int rtl8xxxu_submit_rx_urb(struct rtl8xxxu_priv *priv,\n\t\t\t\t  struct rtl8xxxu_rx_urb *rx_urb);\n\nstatic struct ieee80211_rate rtl8xxxu_rates[] = {\n\t{ .bitrate = 10, .hw_value = DESC_RATE_1M, .flags = 0 },\n\t{ .bitrate = 20, .hw_value = DESC_RATE_2M, .flags = 0 },\n\t{ .bitrate = 55, .hw_value = DESC_RATE_5_5M, .flags = 0 },\n\t{ .bitrate = 110, .hw_value = DESC_RATE_11M, .flags = 0 },\n\t{ .bitrate = 60, .hw_value = DESC_RATE_6M, .flags = 0 },\n\t{ .bitrate = 90, .hw_value = DESC_RATE_9M, .flags = 0 },\n\t{ .bitrate = 120, .hw_value = DESC_RATE_12M, .flags = 0 },\n\t{ .bitrate = 180, .hw_value = DESC_RATE_18M, .flags = 0 },\n\t{ .bitrate = 240, .hw_value = DESC_RATE_24M, .flags = 0 },\n\t{ .bitrate = 360, .hw_value = DESC_RATE_36M, .flags = 0 },\n\t{ .bitrate = 480, .hw_value = DESC_RATE_48M, .flags = 0 },\n\t{ .bitrate = 540, .hw_value = DESC_RATE_54M, .flags = 0 },\n};\n\nstatic struct ieee80211_channel rtl8xxxu_channels_2g[] = {\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2412,\n\t  .hw_value = 1, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2417,\n\t  .hw_value = 2, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2422,\n\t  .hw_value = 3, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2427,\n\t  .hw_value = 4, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2432,\n\t  .hw_value = 5, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2437,\n\t  .hw_value = 6, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2442,\n\t  .hw_value = 7, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2447,\n\t  .hw_value = 8, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2452,\n\t  .hw_value = 9, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2457,\n\t  .hw_value = 10, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2462,\n\t  .hw_value = 11, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2467,\n\t  .hw_value = 12, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2472,\n\t  .hw_value = 13, .max_power = 30 },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2484,\n\t  .hw_value = 14, .max_power = 30 }\n};\n\nstatic struct ieee80211_supported_band rtl8xxxu_supported_band = {\n\t.channels = rtl8xxxu_channels_2g,\n\t.n_channels = ARRAY_SIZE(rtl8xxxu_channels_2g),\n\t.bitrates = rtl8xxxu_rates,\n\t.n_bitrates = ARRAY_SIZE(rtl8xxxu_rates),\n};\n\nstruct rtl8xxxu_reg8val rtl8xxxu_gen1_mac_init_table[] = {\n\t{0x420, 0x80}, {0x423, 0x00}, {0x430, 0x00}, {0x431, 0x00},\n\t{0x432, 0x00}, {0x433, 0x01}, {0x434, 0x04}, {0x435, 0x05},\n\t{0x436, 0x06}, {0x437, 0x07}, {0x438, 0x00}, {0x439, 0x00},\n\t{0x43a, 0x00}, {0x43b, 0x01}, {0x43c, 0x04}, {0x43d, 0x05},\n\t{0x43e, 0x06}, {0x43f, 0x07}, {0x440, 0x5d}, {0x441, 0x01},\n\t{0x442, 0x00}, {0x444, 0x15}, {0x445, 0xf0}, {0x446, 0x0f},\n\t{0x447, 0x00}, {0x458, 0x41}, {0x459, 0xa8}, {0x45a, 0x72},\n\t{0x45b, 0xb9}, {0x460, 0x66}, {0x461, 0x66}, {0x462, 0x08},\n\t{0x463, 0x03}, {0x4c8, 0xff}, {0x4c9, 0x08}, {0x4cc, 0xff},\n\t{0x4cd, 0xff}, {0x4ce, 0x01}, {0x500, 0x26}, {0x501, 0xa2},\n\t{0x502, 0x2f}, {0x503, 0x00}, {0x504, 0x28}, {0x505, 0xa3},\n\t{0x506, 0x5e}, {0x507, 0x00}, {0x508, 0x2b}, {0x509, 0xa4},\n\t{0x50a, 0x5e}, {0x50b, 0x00}, {0x50c, 0x4f}, {0x50d, 0xa4},\n\t{0x50e, 0x00}, {0x50f, 0x00}, {0x512, 0x1c}, {0x514, 0x0a},\n\t{0x515, 0x10}, {0x516, 0x0a}, {0x517, 0x10}, {0x51a, 0x16},\n\t{0x524, 0x0f}, {0x525, 0x4f}, {0x546, 0x40}, {0x547, 0x00},\n\t{0x550, 0x10}, {0x551, 0x10}, {0x559, 0x02}, {0x55a, 0x02},\n\t{0x55d, 0xff}, {0x605, 0x30}, {0x608, 0x0e}, {0x609, 0x2a},\n\t{0x652, 0x20}, {0x63c, 0x0a}, {0x63d, 0x0a}, {0x63e, 0x0e},\n\t{0x63f, 0x0e}, {0x66e, 0x05}, {0x700, 0x21}, {0x701, 0x43},\n\t{0x702, 0x65}, {0x703, 0x87}, {0x708, 0x21}, {0x709, 0x43},\n\t{0x70a, 0x65}, {0x70b, 0x87}, {0xffff, 0xff},\n};\n\nstatic struct rtl8xxxu_reg32val rtl8723a_phy_1t_init_table[] = {\n\t{0x800, 0x80040000}, {0x804, 0x00000003},\n\t{0x808, 0x0000fc00}, {0x80c, 0x0000000a},\n\t{0x810, 0x10001331}, {0x814, 0x020c3d10},\n\t{0x818, 0x02200385}, {0x81c, 0x00000000},\n\t{0x820, 0x01000100}, {0x824, 0x00390004},\n\t{0x828, 0x00000000}, {0x82c, 0x00000000},\n\t{0x830, 0x00000000}, {0x834, 0x00000000},\n\t{0x838, 0x00000000}, {0x83c, 0x00000000},\n\t{0x840, 0x00010000}, {0x844, 0x00000000},\n\t{0x848, 0x00000000}, {0x84c, 0x00000000},\n\t{0x850, 0x00000000}, {0x854, 0x00000000},\n\t{0x858, 0x569a569a}, {0x85c, 0x001b25a4},\n\t{0x860, 0x66f60110}, {0x864, 0x061f0130},\n\t{0x868, 0x00000000}, {0x86c, 0x32323200},\n\t{0x870, 0x07000760}, {0x874, 0x22004000},\n\t{0x878, 0x00000808}, {0x87c, 0x00000000},\n\t{0x880, 0xc0083070}, {0x884, 0x000004d5},\n\t{0x888, 0x00000000}, {0x88c, 0xccc000c0},\n\t{0x890, 0x00000800}, {0x894, 0xfffffffe},\n\t{0x898, 0x40302010}, {0x89c, 0x00706050},\n\t{0x900, 0x00000000}, {0x904, 0x00000023},\n\t{0x908, 0x00000000}, {0x90c, 0x81121111},\n\t{0xa00, 0x00d047c8}, {0xa04, 0x80ff000c},\n\t{0xa08, 0x8c838300}, {0xa0c, 0x2e68120f},\n\t{0xa10, 0x9500bb78}, {0xa14, 0x11144028},\n\t{0xa18, 0x00881117}, {0xa1c, 0x89140f00},\n\t{0xa20, 0x1a1b0000}, {0xa24, 0x090e1317},\n\t{0xa28, 0x00000204}, {0xa2c, 0x00d30000},\n\t{0xa70, 0x101fbf00}, {0xa74, 0x00000007},\n\t{0xa78, 0x00000900},\n\t{0xc00, 0x48071d40}, {0xc04, 0x03a05611},\n\t{0xc08, 0x000000e4}, {0xc0c, 0x6c6c6c6c},\n\t{0xc10, 0x08800000}, {0xc14, 0x40000100},\n\t{0xc18, 0x08800000}, {0xc1c, 0x40000100},\n\t{0xc20, 0x00000000}, {0xc24, 0x00000000},\n\t{0xc28, 0x00000000}, {0xc2c, 0x00000000},\n\t{0xc30, 0x69e9ac44}, {0xc34, 0x469652af},\n\t{0xc38, 0x49795994}, {0xc3c, 0x0a97971c},\n\t{0xc40, 0x1f7c403f}, {0xc44, 0x000100b7},\n\t{0xc48, 0xec020107}, {0xc4c, 0x007f037f},\n\t{0xc50, 0x69543420}, {0xc54, 0x43bc0094},\n\t{0xc58, 0x69543420}, {0xc5c, 0x433c0094},\n\t{0xc60, 0x00000000}, {0xc64, 0x7112848b},\n\t{0xc68, 0x47c00bff}, {0xc6c, 0x00000036},\n\t{0xc70, 0x2c7f000d}, {0xc74, 0x018610db},\n\t{0xc78, 0x0000001f}, {0xc7c, 0x00b91612},\n\t{0xc80, 0x40000100}, {0xc84, 0x20f60000},\n\t{0xc88, 0x40000100}, {0xc8c, 0x20200000},\n\t{0xc90, 0x00121820}, {0xc94, 0x00000000},\n\t{0xc98, 0x00121820}, {0xc9c, 0x00007f7f},\n\t{0xca0, 0x00000000}, {0xca4, 0x00000080},\n\t{0xca8, 0x00000000}, {0xcac, 0x00000000},\n\t{0xcb0, 0x00000000}, {0xcb4, 0x00000000},\n\t{0xcb8, 0x00000000}, {0xcbc, 0x28000000},\n\t{0xcc0, 0x00000000}, {0xcc4, 0x00000000},\n\t{0xcc8, 0x00000000}, {0xccc, 0x00000000},\n\t{0xcd0, 0x00000000}, {0xcd4, 0x00000000},\n\t{0xcd8, 0x64b22427}, {0xcdc, 0x00766932},\n\t{0xce0, 0x00222222}, {0xce4, 0x00000000},\n\t{0xce8, 0x37644302}, {0xcec, 0x2f97d40c},\n\t{0xd00, 0x00080740}, {0xd04, 0x00020401},\n\t{0xd08, 0x0000907f}, {0xd0c, 0x20010201},\n\t{0xd10, 0xa0633333}, {0xd14, 0x3333bc43},\n\t{0xd18, 0x7a8f5b6b}, {0xd2c, 0xcc979975},\n\t{0xd30, 0x00000000}, {0xd34, 0x80608000},\n\t{0xd38, 0x00000000}, {0xd3c, 0x00027293},\n\t{0xd40, 0x00000000}, {0xd44, 0x00000000},\n\t{0xd48, 0x00000000}, {0xd4c, 0x00000000},\n\t{0xd50, 0x6437140a}, {0xd54, 0x00000000},\n\t{0xd58, 0x00000000}, {0xd5c, 0x30032064},\n\t{0xd60, 0x4653de68}, {0xd64, 0x04518a3c},\n\t{0xd68, 0x00002101}, {0xd6c, 0x2a201c16},\n\t{0xd70, 0x1812362e}, {0xd74, 0x322c2220},\n\t{0xd78, 0x000e3c24}, {0xe00, 0x2a2a2a2a},\n\t{0xe04, 0x2a2a2a2a}, {0xe08, 0x03902a2a},\n\t{0xe10, 0x2a2a2a2a}, {0xe14, 0x2a2a2a2a},\n\t{0xe18, 0x2a2a2a2a}, {0xe1c, 0x2a2a2a2a},\n\t{0xe28, 0x00000000}, {0xe30, 0x1000dc1f},\n\t{0xe34, 0x10008c1f}, {0xe38, 0x02140102},\n\t{0xe3c, 0x681604c2}, {0xe40, 0x01007c00},\n\t{0xe44, 0x01004800}, {0xe48, 0xfb000000},\n\t{0xe4c, 0x000028d1}, {0xe50, 0x1000dc1f},\n\t{0xe54, 0x10008c1f}, {0xe58, 0x02140102},\n\t{0xe5c, 0x28160d05}, {0xe60, 0x00000008},\n\t{0xe68, 0x001b25a4}, {0xe6c, 0x631b25a0},\n\t{0xe70, 0x631b25a0}, {0xe74, 0x081b25a0},\n\t{0xe78, 0x081b25a0}, {0xe7c, 0x081b25a0},\n\t{0xe80, 0x081b25a0}, {0xe84, 0x631b25a0},\n\t{0xe88, 0x081b25a0}, {0xe8c, 0x631b25a0},\n\t{0xed0, 0x631b25a0}, {0xed4, 0x631b25a0},\n\t{0xed8, 0x631b25a0}, {0xedc, 0x001b25a0},\n\t{0xee0, 0x001b25a0}, {0xeec, 0x6b1b25a0},\n\t{0xf14, 0x00000003}, {0xf4c, 0x00000000},\n\t{0xf00, 0x00000300},\n\t{0xffff, 0xffffffff},\n};\n\nstatic struct rtl8xxxu_reg32val rtl8192cu_phy_2t_init_table[] = {\n\t{0x024, 0x0011800f}, {0x028, 0x00ffdb83},\n\t{0x800, 0x80040002}, {0x804, 0x00000003},\n\t{0x808, 0x0000fc00}, {0x80c, 0x0000000a},\n\t{0x810, 0x10000330}, {0x814, 0x020c3d10},\n\t{0x818, 0x02200385}, {0x81c, 0x00000000},\n\t{0x820, 0x01000100}, {0x824, 0x00390004},\n\t{0x828, 0x01000100}, {0x82c, 0x00390004},\n\t{0x830, 0x27272727}, {0x834, 0x27272727},\n\t{0x838, 0x27272727}, {0x83c, 0x27272727},\n\t{0x840, 0x00010000}, {0x844, 0x00010000},\n\t{0x848, 0x27272727}, {0x84c, 0x27272727},\n\t{0x850, 0x00000000}, {0x854, 0x00000000},\n\t{0x858, 0x569a569a}, {0x85c, 0x0c1b25a4},\n\t{0x860, 0x66e60230}, {0x864, 0x061f0130},\n\t{0x868, 0x27272727}, {0x86c, 0x2b2b2b27},\n\t{0x870, 0x07000700}, {0x874, 0x22184000},\n\t{0x878, 0x08080808}, {0x87c, 0x00000000},\n\t{0x880, 0xc0083070}, {0x884, 0x000004d5},\n\t{0x888, 0x00000000}, {0x88c, 0xcc0000c0},\n\t{0x890, 0x00000800}, {0x894, 0xfffffffe},\n\t{0x898, 0x40302010}, {0x89c, 0x00706050},\n\t{0x900, 0x00000000}, {0x904, 0x00000023},\n\t{0x908, 0x00000000}, {0x90c, 0x81121313},\n\t{0xa00, 0x00d047c8}, {0xa04, 0x80ff000c},\n\t{0xa08, 0x8c838300}, {0xa0c, 0x2e68120f},\n\t{0xa10, 0x9500bb78}, {0xa14, 0x11144028},\n\t{0xa18, 0x00881117}, {0xa1c, 0x89140f00},\n\t{0xa20, 0x1a1b0000}, {0xa24, 0x090e1317},\n\t{0xa28, 0x00000204}, {0xa2c, 0x00d30000},\n\t{0xa70, 0x101fbf00}, {0xa74, 0x00000007},\n\t{0xc00, 0x48071d40}, {0xc04, 0x03a05633},\n\t{0xc08, 0x000000e4}, {0xc0c, 0x6c6c6c6c},\n\t{0xc10, 0x08800000}, {0xc14, 0x40000100},\n\t{0xc18, 0x08800000}, {0xc1c, 0x40000100},\n\t{0xc20, 0x00000000}, {0xc24, 0x00000000},\n\t{0xc28, 0x00000000}, {0xc2c, 0x00000000},\n\t{0xc30, 0x69e9ac44}, {0xc34, 0x469652cf},\n\t{0xc38, 0x49795994}, {0xc3c, 0x0a97971c},\n\t{0xc40, 0x1f7c403f}, {0xc44, 0x000100b7},\n\t{0xc48, 0xec020107}, {0xc4c, 0x007f037f},\n\t{0xc50, 0x69543420}, {0xc54, 0x43bc0094},\n\t{0xc58, 0x69543420}, {0xc5c, 0x433c0094},\n\t{0xc60, 0x00000000}, {0xc64, 0x5116848b},\n\t{0xc68, 0x47c00bff}, {0xc6c, 0x00000036},\n\t{0xc70, 0x2c7f000d}, {0xc74, 0x2186115b},\n\t{0xc78, 0x0000001f}, {0xc7c, 0x00b99612},\n\t{0xc80, 0x40000100}, {0xc84, 0x20f60000},\n\t{0xc88, 0x40000100}, {0xc8c, 0xa0e40000},\n\t{0xc90, 0x00121820}, {0xc94, 0x00000000},\n\t{0xc98, 0x00121820}, {0xc9c, 0x00007f7f},\n\t{0xca0, 0x00000000}, {0xca4, 0x00000080},\n\t{0xca8, 0x00000000}, {0xcac, 0x00000000},\n\t{0xcb0, 0x00000000}, {0xcb4, 0x00000000},\n\t{0xcb8, 0x00000000}, {0xcbc, 0x28000000},\n\t{0xcc0, 0x00000000}, {0xcc4, 0x00000000},\n\t{0xcc8, 0x00000000}, {0xccc, 0x00000000},\n\t{0xcd0, 0x00000000}, {0xcd4, 0x00000000},\n\t{0xcd8, 0x64b22427}, {0xcdc, 0x00766932},\n\t{0xce0, 0x00222222}, {0xce4, 0x00000000},\n\t{0xce8, 0x37644302}, {0xcec, 0x2f97d40c},\n\t{0xd00, 0x00080740}, {0xd04, 0x00020403},\n\t{0xd08, 0x0000907f}, {0xd0c, 0x20010201},\n\t{0xd10, 0xa0633333}, {0xd14, 0x3333bc43},\n\t{0xd18, 0x7a8f5b6b}, {0xd2c, 0xcc979975},\n\t{0xd30, 0x00000000}, {0xd34, 0x80608000},\n\t{0xd38, 0x00000000}, {0xd3c, 0x00027293},\n\t{0xd40, 0x00000000}, {0xd44, 0x00000000},\n\t{0xd48, 0x00000000}, {0xd4c, 0x00000000},\n\t{0xd50, 0x6437140a}, {0xd54, 0x00000000},\n\t{0xd58, 0x00000000}, {0xd5c, 0x30032064},\n\t{0xd60, 0x4653de68}, {0xd64, 0x04518a3c},\n\t{0xd68, 0x00002101}, {0xd6c, 0x2a201c16},\n\t{0xd70, 0x1812362e}, {0xd74, 0x322c2220},\n\t{0xd78, 0x000e3c24}, {0xe00, 0x2a2a2a2a},\n\t{0xe04, 0x2a2a2a2a}, {0xe08, 0x03902a2a},\n\t{0xe10, 0x2a2a2a2a}, {0xe14, 0x2a2a2a2a},\n\t{0xe18, 0x2a2a2a2a}, {0xe1c, 0x2a2a2a2a},\n\t{0xe28, 0x00000000}, {0xe30, 0x1000dc1f},\n\t{0xe34, 0x10008c1f}, {0xe38, 0x02140102},\n\t{0xe3c, 0x681604c2}, {0xe40, 0x01007c00},\n\t{0xe44, 0x01004800}, {0xe48, 0xfb000000},\n\t{0xe4c, 0x000028d1}, {0xe50, 0x1000dc1f},\n\t{0xe54, 0x10008c1f}, {0xe58, 0x02140102},\n\t{0xe5c, 0x28160d05}, {0xe60, 0x00000010},\n\t{0xe68, 0x001b25a4}, {0xe6c, 0x63db25a4},\n\t{0xe70, 0x63db25a4}, {0xe74, 0x0c1b25a4},\n\t{0xe78, 0x0c1b25a4}, {0xe7c, 0x0c1b25a4},\n\t{0xe80, 0x0c1b25a4}, {0xe84, 0x63db25a4},\n\t{0xe88, 0x0c1b25a4}, {0xe8c, 0x63db25a4},\n\t{0xed0, 0x63db25a4}, {0xed4, 0x63db25a4},\n\t{0xed8, 0x63db25a4}, {0xedc, 0x001b25a4},\n\t{0xee0, 0x001b25a4}, {0xeec, 0x6fdb25a4},\n\t{0xf14, 0x00000003}, {0xf4c, 0x00000000},\n\t{0xf00, 0x00000300},\n\t{0xffff, 0xffffffff},\n};\n\nstatic struct rtl8xxxu_reg32val rtl8188ru_phy_1t_highpa_table[] = {\n\t{0x024, 0x0011800f}, {0x028, 0x00ffdb83},\n\t{0x040, 0x000c0004}, {0x800, 0x80040000},\n\t{0x804, 0x00000001}, {0x808, 0x0000fc00},\n\t{0x80c, 0x0000000a}, {0x810, 0x10005388},\n\t{0x814, 0x020c3d10}, {0x818, 0x02200385},\n\t{0x81c, 0x00000000}, {0x820, 0x01000100},\n\t{0x824, 0x00390204}, {0x828, 0x00000000},\n\t{0x82c, 0x00000000}, {0x830, 0x00000000},\n\t{0x834, 0x00000000}, {0x838, 0x00000000},\n\t{0x83c, 0x00000000}, {0x840, 0x00010000},\n\t{0x844, 0x00000000}, {0x848, 0x00000000},\n\t{0x84c, 0x00000000}, {0x850, 0x00000000},\n\t{0x854, 0x00000000}, {0x858, 0x569a569a},\n\t{0x85c, 0x001b25a4}, {0x860, 0x66e60230},\n\t{0x864, 0x061f0130}, {0x868, 0x00000000},\n\t{0x86c, 0x20202000}, {0x870, 0x03000300},\n\t{0x874, 0x22004000}, {0x878, 0x00000808},\n\t{0x87c, 0x00ffc3f1}, {0x880, 0xc0083070},\n\t{0x884, 0x000004d5}, {0x888, 0x00000000},\n\t{0x88c, 0xccc000c0}, {0x890, 0x00000800},\n\t{0x894, 0xfffffffe}, {0x898, 0x40302010},\n\t{0x89c, 0x00706050}, {0x900, 0x00000000},\n\t{0x904, 0x00000023}, {0x908, 0x00000000},\n\t{0x90c, 0x81121111}, {0xa00, 0x00d047c8},\n\t{0xa04, 0x80ff000c}, {0xa08, 0x8c838300},\n\t{0xa0c, 0x2e68120f}, {0xa10, 0x9500bb78},\n\t{0xa14, 0x11144028}, {0xa18, 0x00881117},\n\t{0xa1c, 0x89140f00}, {0xa20, 0x15160000},\n\t{0xa24, 0x070b0f12}, {0xa28, 0x00000104},\n\t{0xa2c, 0x00d30000}, {0xa70, 0x101fbf00},\n\t{0xa74, 0x00000007}, {0xc00, 0x48071d40},\n\t{0xc04, 0x03a05611}, {0xc08, 0x000000e4},\n\t{0xc0c, 0x6c6c6c6c}, {0xc10, 0x08800000},\n\t{0xc14, 0x40000100}, {0xc18, 0x08800000},\n\t{0xc1c, 0x40000100}, {0xc20, 0x00000000},\n\t{0xc24, 0x00000000}, {0xc28, 0x00000000},\n\t{0xc2c, 0x00000000}, {0xc30, 0x69e9ac44},\n\t{0xc34, 0x469652cf}, {0xc38, 0x49795994},\n\t{0xc3c, 0x0a97971c}, {0xc40, 0x1f7c403f},\n\t{0xc44, 0x000100b7}, {0xc48, 0xec020107},\n\t{0xc4c, 0x007f037f}, {0xc50, 0x6954342e},\n\t{0xc54, 0x43bc0094}, {0xc58, 0x6954342f},\n\t{0xc5c, 0x433c0094}, {0xc60, 0x00000000},\n\t{0xc64, 0x5116848b}, {0xc68, 0x47c00bff},\n\t{0xc6c, 0x00000036}, {0xc70, 0x2c46000d},\n\t{0xc74, 0x018610db}, {0xc78, 0x0000001f},\n\t{0xc7c, 0x00b91612}, {0xc80, 0x24000090},\n\t{0xc84, 0x20f60000}, {0xc88, 0x24000090},\n\t{0xc8c, 0x20200000}, {0xc90, 0x00121820},\n\t{0xc94, 0x00000000}, {0xc98, 0x00121820},\n\t{0xc9c, 0x00007f7f}, {0xca0, 0x00000000},\n\t{0xca4, 0x00000080}, {0xca8, 0x00000000},\n\t{0xcac, 0x00000000}, {0xcb0, 0x00000000},\n\t{0xcb4, 0x00000000}, {0xcb8, 0x00000000},\n\t{0xcbc, 0x28000000}, {0xcc0, 0x00000000},\n\t{0xcc4, 0x00000000}, {0xcc8, 0x00000000},\n\t{0xccc, 0x00000000}, {0xcd0, 0x00000000},\n\t{0xcd4, 0x00000000}, {0xcd8, 0x64b22427},\n\t{0xcdc, 0x00766932}, {0xce0, 0x00222222},\n\t{0xce4, 0x00000000}, {0xce8, 0x37644302},\n\t{0xcec, 0x2f97d40c}, {0xd00, 0x00080740},\n\t{0xd04, 0x00020401}, {0xd08, 0x0000907f},\n\t{0xd0c, 0x20010201}, {0xd10, 0xa0633333},\n\t{0xd14, 0x3333bc43}, {0xd18, 0x7a8f5b6b},\n\t{0xd2c, 0xcc979975}, {0xd30, 0x00000000},\n\t{0xd34, 0x80608000}, {0xd38, 0x00000000},\n\t{0xd3c, 0x00027293}, {0xd40, 0x00000000},\n\t{0xd44, 0x00000000}, {0xd48, 0x00000000},\n\t{0xd4c, 0x00000000}, {0xd50, 0x6437140a},\n\t{0xd54, 0x00000000}, {0xd58, 0x00000000},\n\t{0xd5c, 0x30032064}, {0xd60, 0x4653de68},\n\t{0xd64, 0x04518a3c}, {0xd68, 0x00002101},\n\t{0xd6c, 0x2a201c16}, {0xd70, 0x1812362e},\n\t{0xd74, 0x322c2220}, {0xd78, 0x000e3c24},\n\t{0xe00, 0x24242424}, {0xe04, 0x24242424},\n\t{0xe08, 0x03902024}, {0xe10, 0x24242424},\n\t{0xe14, 0x24242424}, {0xe18, 0x24242424},\n\t{0xe1c, 0x24242424}, {0xe28, 0x00000000},\n\t{0xe30, 0x1000dc1f}, {0xe34, 0x10008c1f},\n\t{0xe38, 0x02140102}, {0xe3c, 0x681604c2},\n\t{0xe40, 0x01007c00}, {0xe44, 0x01004800},\n\t{0xe48, 0xfb000000}, {0xe4c, 0x000028d1},\n\t{0xe50, 0x1000dc1f}, {0xe54, 0x10008c1f},\n\t{0xe58, 0x02140102}, {0xe5c, 0x28160d05},\n\t{0xe60, 0x00000008}, {0xe68, 0x001b25a4},\n\t{0xe6c, 0x631b25a0}, {0xe70, 0x631b25a0},\n\t{0xe74, 0x081b25a0}, {0xe78, 0x081b25a0},\n\t{0xe7c, 0x081b25a0}, {0xe80, 0x081b25a0},\n\t{0xe84, 0x631b25a0}, {0xe88, 0x081b25a0},\n\t{0xe8c, 0x631b25a0}, {0xed0, 0x631b25a0},\n\t{0xed4, 0x631b25a0}, {0xed8, 0x631b25a0},\n\t{0xedc, 0x001b25a0}, {0xee0, 0x001b25a0},\n\t{0xeec, 0x6b1b25a0}, {0xee8, 0x31555448},\n\t{0xf14, 0x00000003}, {0xf4c, 0x00000000},\n\t{0xf00, 0x00000300},\n\t{0xffff, 0xffffffff},\n};\n\nstatic struct rtl8xxxu_reg32val rtl8xxx_agc_standard_table[] = {\n\t{0xc78, 0x7b000001}, {0xc78, 0x7b010001},\n\t{0xc78, 0x7b020001}, {0xc78, 0x7b030001},\n\t{0xc78, 0x7b040001}, {0xc78, 0x7b050001},\n\t{0xc78, 0x7a060001}, {0xc78, 0x79070001},\n\t{0xc78, 0x78080001}, {0xc78, 0x77090001},\n\t{0xc78, 0x760a0001}, {0xc78, 0x750b0001},\n\t{0xc78, 0x740c0001}, {0xc78, 0x730d0001},\n\t{0xc78, 0x720e0001}, {0xc78, 0x710f0001},\n\t{0xc78, 0x70100001}, {0xc78, 0x6f110001},\n\t{0xc78, 0x6e120001}, {0xc78, 0x6d130001},\n\t{0xc78, 0x6c140001}, {0xc78, 0x6b150001},\n\t{0xc78, 0x6a160001}, {0xc78, 0x69170001},\n\t{0xc78, 0x68180001}, {0xc78, 0x67190001},\n\t{0xc78, 0x661a0001}, {0xc78, 0x651b0001},\n\t{0xc78, 0x641c0001}, {0xc78, 0x631d0001},\n\t{0xc78, 0x621e0001}, {0xc78, 0x611f0001},\n\t{0xc78, 0x60200001}, {0xc78, 0x49210001},\n\t{0xc78, 0x48220001}, {0xc78, 0x47230001},\n\t{0xc78, 0x46240001}, {0xc78, 0x45250001},\n\t{0xc78, 0x44260001}, {0xc78, 0x43270001},\n\t{0xc78, 0x42280001}, {0xc78, 0x41290001},\n\t{0xc78, 0x402a0001}, {0xc78, 0x262b0001},\n\t{0xc78, 0x252c0001}, {0xc78, 0x242d0001},\n\t{0xc78, 0x232e0001}, {0xc78, 0x222f0001},\n\t{0xc78, 0x21300001}, {0xc78, 0x20310001},\n\t{0xc78, 0x06320001}, {0xc78, 0x05330001},\n\t{0xc78, 0x04340001}, {0xc78, 0x03350001},\n\t{0xc78, 0x02360001}, {0xc78, 0x01370001},\n\t{0xc78, 0x00380001}, {0xc78, 0x00390001},\n\t{0xc78, 0x003a0001}, {0xc78, 0x003b0001},\n\t{0xc78, 0x003c0001}, {0xc78, 0x003d0001},\n\t{0xc78, 0x003e0001}, {0xc78, 0x003f0001},\n\t{0xc78, 0x7b400001}, {0xc78, 0x7b410001},\n\t{0xc78, 0x7b420001}, {0xc78, 0x7b430001},\n\t{0xc78, 0x7b440001}, {0xc78, 0x7b450001},\n\t{0xc78, 0x7a460001}, {0xc78, 0x79470001},\n\t{0xc78, 0x78480001}, {0xc78, 0x77490001},\n\t{0xc78, 0x764a0001}, {0xc78, 0x754b0001},\n\t{0xc78, 0x744c0001}, {0xc78, 0x734d0001},\n\t{0xc78, 0x724e0001}, {0xc78, 0x714f0001},\n\t{0xc78, 0x70500001}, {0xc78, 0x6f510001},\n\t{0xc78, 0x6e520001}, {0xc78, 0x6d530001},\n\t{0xc78, 0x6c540001}, {0xc78, 0x6b550001},\n\t{0xc78, 0x6a560001}, {0xc78, 0x69570001},\n\t{0xc78, 0x68580001}, {0xc78, 0x67590001},\n\t{0xc78, 0x665a0001}, {0xc78, 0x655b0001},\n\t{0xc78, 0x645c0001}, {0xc78, 0x635d0001},\n\t{0xc78, 0x625e0001}, {0xc78, 0x615f0001},\n\t{0xc78, 0x60600001}, {0xc78, 0x49610001},\n\t{0xc78, 0x48620001}, {0xc78, 0x47630001},\n\t{0xc78, 0x46640001}, {0xc78, 0x45650001},\n\t{0xc78, 0x44660001}, {0xc78, 0x43670001},\n\t{0xc78, 0x42680001}, {0xc78, 0x41690001},\n\t{0xc78, 0x406a0001}, {0xc78, 0x266b0001},\n\t{0xc78, 0x256c0001}, {0xc78, 0x246d0001},\n\t{0xc78, 0x236e0001}, {0xc78, 0x226f0001},\n\t{0xc78, 0x21700001}, {0xc78, 0x20710001},\n\t{0xc78, 0x06720001}, {0xc78, 0x05730001},\n\t{0xc78, 0x04740001}, {0xc78, 0x03750001},\n\t{0xc78, 0x02760001}, {0xc78, 0x01770001},\n\t{0xc78, 0x00780001}, {0xc78, 0x00790001},\n\t{0xc78, 0x007a0001}, {0xc78, 0x007b0001},\n\t{0xc78, 0x007c0001}, {0xc78, 0x007d0001},\n\t{0xc78, 0x007e0001}, {0xc78, 0x007f0001},\n\t{0xc78, 0x3800001e}, {0xc78, 0x3801001e},\n\t{0xc78, 0x3802001e}, {0xc78, 0x3803001e},\n\t{0xc78, 0x3804001e}, {0xc78, 0x3805001e},\n\t{0xc78, 0x3806001e}, {0xc78, 0x3807001e},\n\t{0xc78, 0x3808001e}, {0xc78, 0x3c09001e},\n\t{0xc78, 0x3e0a001e}, {0xc78, 0x400b001e},\n\t{0xc78, 0x440c001e}, {0xc78, 0x480d001e},\n\t{0xc78, 0x4c0e001e}, {0xc78, 0x500f001e},\n\t{0xc78, 0x5210001e}, {0xc78, 0x5611001e},\n\t{0xc78, 0x5a12001e}, {0xc78, 0x5e13001e},\n\t{0xc78, 0x6014001e}, {0xc78, 0x6015001e},\n\t{0xc78, 0x6016001e}, {0xc78, 0x6217001e},\n\t{0xc78, 0x6218001e}, {0xc78, 0x6219001e},\n\t{0xc78, 0x621a001e}, {0xc78, 0x621b001e},\n\t{0xc78, 0x621c001e}, {0xc78, 0x621d001e},\n\t{0xc78, 0x621e001e}, {0xc78, 0x621f001e},\n\t{0xffff, 0xffffffff}\n};\n\nstatic struct rtl8xxxu_reg32val rtl8xxx_agc_highpa_table[] = {\n\t{0xc78, 0x7b000001}, {0xc78, 0x7b010001},\n\t{0xc78, 0x7b020001}, {0xc78, 0x7b030001},\n\t{0xc78, 0x7b040001}, {0xc78, 0x7b050001},\n\t{0xc78, 0x7b060001}, {0xc78, 0x7b070001},\n\t{0xc78, 0x7b080001}, {0xc78, 0x7a090001},\n\t{0xc78, 0x790a0001}, {0xc78, 0x780b0001},\n\t{0xc78, 0x770c0001}, {0xc78, 0x760d0001},\n\t{0xc78, 0x750e0001}, {0xc78, 0x740f0001},\n\t{0xc78, 0x73100001}, {0xc78, 0x72110001},\n\t{0xc78, 0x71120001}, {0xc78, 0x70130001},\n\t{0xc78, 0x6f140001}, {0xc78, 0x6e150001},\n\t{0xc78, 0x6d160001}, {0xc78, 0x6c170001},\n\t{0xc78, 0x6b180001}, {0xc78, 0x6a190001},\n\t{0xc78, 0x691a0001}, {0xc78, 0x681b0001},\n\t{0xc78, 0x671c0001}, {0xc78, 0x661d0001},\n\t{0xc78, 0x651e0001}, {0xc78, 0x641f0001},\n\t{0xc78, 0x63200001}, {0xc78, 0x62210001},\n\t{0xc78, 0x61220001}, {0xc78, 0x60230001},\n\t{0xc78, 0x46240001}, {0xc78, 0x45250001},\n\t{0xc78, 0x44260001}, {0xc78, 0x43270001},\n\t{0xc78, 0x42280001}, {0xc78, 0x41290001},\n\t{0xc78, 0x402a0001}, {0xc78, 0x262b0001},\n\t{0xc78, 0x252c0001}, {0xc78, 0x242d0001},\n\t{0xc78, 0x232e0001}, {0xc78, 0x222f0001},\n\t{0xc78, 0x21300001}, {0xc78, 0x20310001},\n\t{0xc78, 0x06320001}, {0xc78, 0x05330001},\n\t{0xc78, 0x04340001}, {0xc78, 0x03350001},\n\t{0xc78, 0x02360001}, {0xc78, 0x01370001},\n\t{0xc78, 0x00380001}, {0xc78, 0x00390001},\n\t{0xc78, 0x003a0001}, {0xc78, 0x003b0001},\n\t{0xc78, 0x003c0001}, {0xc78, 0x003d0001},\n\t{0xc78, 0x003e0001}, {0xc78, 0x003f0001},\n\t{0xc78, 0x7b400001}, {0xc78, 0x7b410001},\n\t{0xc78, 0x7b420001}, {0xc78, 0x7b430001},\n\t{0xc78, 0x7b440001}, {0xc78, 0x7b450001},\n\t{0xc78, 0x7b460001}, {0xc78, 0x7b470001},\n\t{0xc78, 0x7b480001}, {0xc78, 0x7a490001},\n\t{0xc78, 0x794a0001}, {0xc78, 0x784b0001},\n\t{0xc78, 0x774c0001}, {0xc78, 0x764d0001},\n\t{0xc78, 0x754e0001}, {0xc78, 0x744f0001},\n\t{0xc78, 0x73500001}, {0xc78, 0x72510001},\n\t{0xc78, 0x71520001}, {0xc78, 0x70530001},\n\t{0xc78, 0x6f540001}, {0xc78, 0x6e550001},\n\t{0xc78, 0x6d560001}, {0xc78, 0x6c570001},\n\t{0xc78, 0x6b580001}, {0xc78, 0x6a590001},\n\t{0xc78, 0x695a0001}, {0xc78, 0x685b0001},\n\t{0xc78, 0x675c0001}, {0xc78, 0x665d0001},\n\t{0xc78, 0x655e0001}, {0xc78, 0x645f0001},\n\t{0xc78, 0x63600001}, {0xc78, 0x62610001},\n\t{0xc78, 0x61620001}, {0xc78, 0x60630001},\n\t{0xc78, 0x46640001}, {0xc78, 0x45650001},\n\t{0xc78, 0x44660001}, {0xc78, 0x43670001},\n\t{0xc78, 0x42680001}, {0xc78, 0x41690001},\n\t{0xc78, 0x406a0001}, {0xc78, 0x266b0001},\n\t{0xc78, 0x256c0001}, {0xc78, 0x246d0001},\n\t{0xc78, 0x236e0001}, {0xc78, 0x226f0001},\n\t{0xc78, 0x21700001}, {0xc78, 0x20710001},\n\t{0xc78, 0x06720001}, {0xc78, 0x05730001},\n\t{0xc78, 0x04740001}, {0xc78, 0x03750001},\n\t{0xc78, 0x02760001}, {0xc78, 0x01770001},\n\t{0xc78, 0x00780001}, {0xc78, 0x00790001},\n\t{0xc78, 0x007a0001}, {0xc78, 0x007b0001},\n\t{0xc78, 0x007c0001}, {0xc78, 0x007d0001},\n\t{0xc78, 0x007e0001}, {0xc78, 0x007f0001},\n\t{0xc78, 0x3800001e}, {0xc78, 0x3801001e},\n\t{0xc78, 0x3802001e}, {0xc78, 0x3803001e},\n\t{0xc78, 0x3804001e}, {0xc78, 0x3805001e},\n\t{0xc78, 0x3806001e}, {0xc78, 0x3807001e},\n\t{0xc78, 0x3808001e}, {0xc78, 0x3c09001e},\n\t{0xc78, 0x3e0a001e}, {0xc78, 0x400b001e},\n\t{0xc78, 0x440c001e}, {0xc78, 0x480d001e},\n\t{0xc78, 0x4c0e001e}, {0xc78, 0x500f001e},\n\t{0xc78, 0x5210001e}, {0xc78, 0x5611001e},\n\t{0xc78, 0x5a12001e}, {0xc78, 0x5e13001e},\n\t{0xc78, 0x6014001e}, {0xc78, 0x6015001e},\n\t{0xc78, 0x6016001e}, {0xc78, 0x6217001e},\n\t{0xc78, 0x6218001e}, {0xc78, 0x6219001e},\n\t{0xc78, 0x621a001e}, {0xc78, 0x621b001e},\n\t{0xc78, 0x621c001e}, {0xc78, 0x621d001e},\n\t{0xc78, 0x621e001e}, {0xc78, 0x621f001e},\n\t{0xffff, 0xffffffff}\n};\n\nstatic struct rtl8xxxu_rfregs rtl8xxxu_rfregs[] = {\n\t{\t/* RF_A */\n\t\t.hssiparm1 = REG_FPGA0_XA_HSSI_PARM1,\n\t\t.hssiparm2 = REG_FPGA0_XA_HSSI_PARM2,\n\t\t.lssiparm = REG_FPGA0_XA_LSSI_PARM,\n\t\t.hspiread = REG_HSPI_XA_READBACK,\n\t\t.lssiread = REG_FPGA0_XA_LSSI_READBACK,\n\t\t.rf_sw_ctrl = REG_FPGA0_XA_RF_SW_CTRL,\n\t},\n\t{\t/* RF_B */\n\t\t.hssiparm1 = REG_FPGA0_XB_HSSI_PARM1,\n\t\t.hssiparm2 = REG_FPGA0_XB_HSSI_PARM2,\n\t\t.lssiparm = REG_FPGA0_XB_LSSI_PARM,\n\t\t.hspiread = REG_HSPI_XB_READBACK,\n\t\t.lssiread = REG_FPGA0_XB_LSSI_READBACK,\n\t\t.rf_sw_ctrl = REG_FPGA0_XB_RF_SW_CTRL,\n\t},\n};\n\nconst u32 rtl8xxxu_iqk_phy_iq_bb_reg[RTL8XXXU_BB_REGS] = {\n\tREG_OFDM0_XA_RX_IQ_IMBALANCE,\n\tREG_OFDM0_XB_RX_IQ_IMBALANCE,\n\tREG_OFDM0_ENERGY_CCA_THRES,\n\tREG_OFDM0_AGCR_SSI_TABLE,\n\tREG_OFDM0_XA_TX_IQ_IMBALANCE,\n\tREG_OFDM0_XB_TX_IQ_IMBALANCE,\n\tREG_OFDM0_XC_TX_AFE,\n\tREG_OFDM0_XD_TX_AFE,\n\tREG_OFDM0_RX_IQ_EXT_ANTA\n};\n\nu8 rtl8xxxu_read8(struct rtl8xxxu_priv *priv, u16 addr)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint len;\n\tu8 data;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tlen = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_READ,\n\t\t\t      addr, 0, &priv->usb_buf.val8, sizeof(u8),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\tdata = priv->usb_buf.val8;\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_READ)\n\t\tdev_info(&udev->dev, \"%s(%04x)   = 0x%02x, len %i\\n\",\n\t\t\t __func__, addr, data, len);\n\treturn data;\n}\n\nu16 rtl8xxxu_read16(struct rtl8xxxu_priv *priv, u16 addr)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint len;\n\tu16 data;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tlen = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_READ,\n\t\t\t      addr, 0, &priv->usb_buf.val16, sizeof(u16),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\tdata = le16_to_cpu(priv->usb_buf.val16);\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_READ)\n\t\tdev_info(&udev->dev, \"%s(%04x)  = 0x%04x, len %i\\n\",\n\t\t\t __func__, addr, data, len);\n\treturn data;\n}\n\nu32 rtl8xxxu_read32(struct rtl8xxxu_priv *priv, u16 addr)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint len;\n\tu32 data;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tlen = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_READ,\n\t\t\t      addr, 0, &priv->usb_buf.val32, sizeof(u32),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\tdata = le32_to_cpu(priv->usb_buf.val32);\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_READ)\n\t\tdev_info(&udev->dev, \"%s(%04x)  = 0x%08x, len %i\\n\",\n\t\t\t __func__, addr, data, len);\n\treturn data;\n}\n\nint rtl8xxxu_write8(struct rtl8xxxu_priv *priv, u16 addr, u8 val)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint ret;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tpriv->usb_buf.val8 = val;\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\n\t\t\t      addr, 0, &priv->usb_buf.val8, sizeof(u8),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_WRITE)\n\t\tdev_info(&udev->dev, \"%s(%04x) = 0x%02x\\n\",\n\t\t\t __func__, addr, val);\n\treturn ret;\n}\n\nint rtl8xxxu_write16(struct rtl8xxxu_priv *priv, u16 addr, u16 val)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint ret;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tpriv->usb_buf.val16 = cpu_to_le16(val);\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\n\t\t\t      addr, 0, &priv->usb_buf.val16, sizeof(u16),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_WRITE)\n\t\tdev_info(&udev->dev, \"%s(%04x) = 0x%04x\\n\",\n\t\t\t __func__, addr, val);\n\treturn ret;\n}\n\nint rtl8xxxu_write32(struct rtl8xxxu_priv *priv, u16 addr, u32 val)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint ret;\n\n\tmutex_lock(&priv->usb_buf_mutex);\n\tpriv->usb_buf.val32 = cpu_to_le32(val);\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\n\t\t\t      addr, 0, &priv->usb_buf.val32, sizeof(u32),\n\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\tmutex_unlock(&priv->usb_buf_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_WRITE)\n\t\tdev_info(&udev->dev, \"%s(%04x) = 0x%08x\\n\",\n\t\t\t __func__, addr, val);\n\treturn ret;\n}\n\nstatic int\nrtl8xxxu_writeN(struct rtl8xxxu_priv *priv, u16 addr, u8 *buf, u16 len)\n{\n\tstruct usb_device *udev = priv->udev;\n\tint blocksize = priv->fops->writeN_block_size;\n\tint ret, i, count, remainder;\n\n\tcount = len / blocksize;\n\tremainder = len % blocksize;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\n\t\t\t\t      addr, 0, buf, blocksize,\n\t\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\t\tif (ret != blocksize)\n\t\t\tgoto write_error;\n\n\t\taddr += blocksize;\n\t\tbuf += blocksize;\n\t}\n\n\tif (remainder) {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t      REALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\n\t\t\t\t      addr, 0, buf, remainder,\n\t\t\t\t      RTW_USB_CONTROL_MSG_TIMEOUT);\n\t\tif (ret != remainder)\n\t\t\tgoto write_error;\n\t}\n\n\treturn len;\n\nwrite_error:\n\tdev_info(&udev->dev,\n\t\t \"%s: Failed to write block at addr: %04x size: %04x\\n\",\n\t\t __func__, addr, blocksize);\n\treturn -EAGAIN;\n}\n\nu32 rtl8xxxu_read_rfreg(struct rtl8xxxu_priv *priv,\n\t\t\tenum rtl8xxxu_rfpath path, u8 reg)\n{\n\tu32 hssia, val32, retval;\n\n\thssia = rtl8xxxu_read32(priv, REG_FPGA0_XA_HSSI_PARM2);\n\tif (path != RF_A)\n\t\tval32 = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].hssiparm2);\n\telse\n\t\tval32 = hssia;\n\n\tval32 &= ~FPGA0_HSSI_PARM2_ADDR_MASK;\n\tval32 |= (reg << FPGA0_HSSI_PARM2_ADDR_SHIFT);\n\tval32 |= FPGA0_HSSI_PARM2_EDGE_READ;\n\thssia &= ~FPGA0_HSSI_PARM2_EDGE_READ;\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM2, hssia);\n\n\tudelay(10);\n\n\trtl8xxxu_write32(priv, rtl8xxxu_rfregs[path].hssiparm2, val32);\n\tudelay(100);\n\n\thssia |= FPGA0_HSSI_PARM2_EDGE_READ;\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM2, hssia);\n\tudelay(10);\n\n\tval32 = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].hssiparm1);\n\tif (val32 & FPGA0_HSSI_PARM1_PI)\n\t\tretval = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].hspiread);\n\telse\n\t\tretval = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].lssiread);\n\n\tretval &= 0xfffff;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_RFREG_READ)\n\t\tdev_info(&priv->udev->dev, \"%s(%02x) = 0x%06x\\n\",\n\t\t\t __func__, reg, retval);\n\treturn retval;\n}\n\n/*\n * The RTL8723BU driver indicates that registers 0xb2 and 0xb6 can\n * have write issues in high temperature conditions. We may have to\n * retry writing them.\n */\nint rtl8xxxu_write_rfreg(struct rtl8xxxu_priv *priv,\n\t\t\t enum rtl8xxxu_rfpath path, u8 reg, u32 data)\n{\n\tint ret, retval;\n\tu32 dataaddr, val32;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_RFREG_WRITE)\n\t\tdev_info(&priv->udev->dev, \"%s(%02x) = 0x%06x\\n\",\n\t\t\t __func__, reg, data);\n\n\tdata &= FPGA0_LSSI_PARM_DATA_MASK;\n\tdataaddr = (reg << FPGA0_LSSI_PARM_ADDR_SHIFT) | data;\n\n\tif (priv->rtl_chip == RTL8192E) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_POWER_SAVE);\n\t\tval32 &= ~0x20000;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_POWER_SAVE, val32);\n\t}\n\n\t/* Use XB for path B */\n\tret = rtl8xxxu_write32(priv, rtl8xxxu_rfregs[path].lssiparm, dataaddr);\n\tif (ret != sizeof(dataaddr))\n\t\tretval = -EIO;\n\telse\n\t\tretval = 0;\n\n\tudelay(1);\n\n\tif (priv->rtl_chip == RTL8192E) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_POWER_SAVE);\n\t\tval32 |= 0x20000;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_POWER_SAVE, val32);\n\t}\n\n\treturn retval;\n}\n\nstatic int\nrtl8xxxu_gen1_h2c_cmd(struct rtl8xxxu_priv *priv, struct h2c_cmd *h2c, int len)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint mbox_nr, retry, retval = 0;\n\tint mbox_reg, mbox_ext_reg;\n\tu8 val8;\n\n\tmutex_lock(&priv->h2c_mutex);\n\n\tmbox_nr = priv->next_mbox;\n\tmbox_reg = REG_HMBOX_0 + (mbox_nr * 4);\n\tmbox_ext_reg = REG_HMBOX_EXT_0 + (mbox_nr * 2);\n\n\t/*\n\t * MBOX ready?\n\t */\n\tretry = 100;\n\tdo {\n\t\tval8 = rtl8xxxu_read8(priv, REG_HMTFR);\n\t\tif (!(val8 & BIT(mbox_nr)))\n\t\t\tbreak;\n\t} while (retry--);\n\n\tif (!retry) {\n\t\tdev_info(dev, \"%s: Mailbox busy\\n\", __func__);\n\t\tretval = -EBUSY;\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Need to swap as it's being swapped again by rtl8xxxu_write16/32()\n\t */\n\tif (len > sizeof(u32)) {\n\t\trtl8xxxu_write16(priv, mbox_ext_reg, le16_to_cpu(h2c->raw.ext));\n\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_H2C)\n\t\t\tdev_info(dev, \"H2C_EXT %04x\\n\",\n\t\t\t\t le16_to_cpu(h2c->raw.ext));\n\t}\n\trtl8xxxu_write32(priv, mbox_reg, le32_to_cpu(h2c->raw.data));\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_H2C)\n\t\tdev_info(dev, \"H2C %08x\\n\", le32_to_cpu(h2c->raw.data));\n\n\tpriv->next_mbox = (mbox_nr + 1) % H2C_MAX_MBOX;\n\nerror:\n\tmutex_unlock(&priv->h2c_mutex);\n\treturn retval;\n}\n\nint\nrtl8xxxu_gen2_h2c_cmd(struct rtl8xxxu_priv *priv, struct h2c_cmd *h2c, int len)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint mbox_nr, retry, retval = 0;\n\tint mbox_reg, mbox_ext_reg;\n\tu8 val8;\n\n\tmutex_lock(&priv->h2c_mutex);\n\n\tmbox_nr = priv->next_mbox;\n\tmbox_reg = REG_HMBOX_0 + (mbox_nr * 4);\n\tmbox_ext_reg = REG_HMBOX_EXT0_8723B + (mbox_nr * 4);\n\n\t/*\n\t * MBOX ready?\n\t */\n\tretry = 100;\n\tdo {\n\t\tval8 = rtl8xxxu_read8(priv, REG_HMTFR);\n\t\tif (!(val8 & BIT(mbox_nr)))\n\t\t\tbreak;\n\t} while (retry--);\n\n\tif (!retry) {\n\t\tdev_info(dev, \"%s: Mailbox busy\\n\", __func__);\n\t\tretval = -EBUSY;\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Need to swap as it's being swapped again by rtl8xxxu_write16/32()\n\t */\n\tif (len > sizeof(u32)) {\n\t\trtl8xxxu_write32(priv, mbox_ext_reg,\n\t\t\t\t le32_to_cpu(h2c->raw_wide.ext));\n\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_H2C)\n\t\t\tdev_info(dev, \"H2C_EXT %08x\\n\",\n\t\t\t\t le32_to_cpu(h2c->raw_wide.ext));\n\t}\n\trtl8xxxu_write32(priv, mbox_reg, le32_to_cpu(h2c->raw.data));\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_H2C)\n\t\tdev_info(dev, \"H2C %08x\\n\", le32_to_cpu(h2c->raw.data));\n\n\tpriv->next_mbox = (mbox_nr + 1) % H2C_MAX_MBOX;\n\nerror:\n\tmutex_unlock(&priv->h2c_mutex);\n\treturn retval;\n}\n\nvoid rtl8xxxu_gen1_enable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu32 val32;\n\n\tval8 = rtl8xxxu_read8(priv, REG_SPS0_CTRL);\n\tval8 |= BIT(0) | BIT(3);\n\trtl8xxxu_write8(priv, REG_SPS0_CTRL, val8);\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XAB_RF_PARM);\n\tval32 &= ~(BIT(4) | BIT(5));\n\tval32 |= BIT(3);\n\tif (priv->rf_paths == 2) {\n\t\tval32 &= ~(BIT(20) | BIT(21));\n\t\tval32 |= BIT(19);\n\t}\n\trtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_PARM, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\tval32 &= ~OFDM_RF_PATH_TX_MASK;\n\tif (priv->tx_paths == 2)\n\t\tval32 |= OFDM_RF_PATH_TX_A | OFDM_RF_PATH_TX_B;\n\telse if (priv->rtl_chip == RTL8192C || priv->rtl_chip == RTL8191C)\n\t\tval32 |= OFDM_RF_PATH_TX_B;\n\telse\n\t\tval32 |= OFDM_RF_PATH_TX_A;\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\tval32 &= ~FPGA_RF_MODE_JAPAN;\n\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\tif (priv->rf_paths == 2)\n\t\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x63db25a0);\n\telse\n\t\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x631b25a0);\n\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, 0x32d95);\n\tif (priv->rf_paths == 2)\n\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC, 0x32d95);\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0x00);\n}\n\nvoid rtl8xxxu_gen1_disable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu8 sps0;\n\tu32 val32;\n\n\tsps0 = rtl8xxxu_read8(priv, REG_SPS0_CTRL);\n\n\t/* RF RX code for preamble power saving */\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XAB_RF_PARM);\n\tval32 &= ~(BIT(3) | BIT(4) | BIT(5));\n\tif (priv->rf_paths == 2)\n\t\tval32 &= ~(BIT(19) | BIT(20) | BIT(21));\n\trtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_PARM, val32);\n\n\t/* Disable TX for four paths */\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\tval32 &= ~OFDM_RF_PATH_TX_MASK;\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\t/* Enable power saving */\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\tval32 |= FPGA_RF_MODE_JAPAN;\n\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t/* AFE control register to power down bits [30:22] */\n\tif (priv->rf_paths == 2)\n\t\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x00db25a0);\n\telse\n\t\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x001b25a0);\n\n\t/* Power down RF module */\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, 0);\n\tif (priv->rf_paths == 2)\n\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC, 0);\n\n\tsps0 &= ~(BIT(0) | BIT(3));\n\trtl8xxxu_write8(priv, REG_SPS0_CTRL, sps0);\n}\n\nstatic void rtl8xxxu_stop_tx_beacon(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\n\tval8 = rtl8xxxu_read8(priv, REG_FWHW_TXQ_CTRL + 2);\n\tval8 &= ~BIT(6);\n\trtl8xxxu_write8(priv, REG_FWHW_TXQ_CTRL + 2, val8);\n\n\trtl8xxxu_write8(priv, REG_TBTT_PROHIBIT + 1, 0x64);\n\tval8 = rtl8xxxu_read8(priv, REG_TBTT_PROHIBIT + 2);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_TBTT_PROHIBIT + 2, val8);\n}\n\n\n/*\n * The rtl8723a has 3 channel groups for it's efuse settings. It only\n * supports the 2.4GHz band, so channels 1 - 14:\n *  group 0: channels 1 - 3\n *  group 1: channels 4 - 9\n *  group 2: channels 10 - 14\n *\n * Note: We index from 0 in the code\n */\nstatic int rtl8xxxu_gen1_channel_to_group(int channel)\n{\n\tint group;\n\n\tif (channel < 4)\n\t\tgroup = 0;\n\telse if (channel < 10)\n\t\tgroup = 1;\n\telse\n\t\tgroup = 2;\n\n\treturn group;\n}\n\n/*\n * Valid for rtl8723bu and rtl8192eu\n */\nint rtl8xxxu_gen2_channel_to_group(int channel)\n{\n\tint group;\n\n\tif (channel < 3)\n\t\tgroup = 0;\n\telse if (channel < 6)\n\t\tgroup = 1;\n\telse if (channel < 9)\n\t\tgroup = 2;\n\telse if (channel < 12)\n\t\tgroup = 3;\n\telse\n\t\tgroup = 4;\n\n\treturn group;\n}\n\nvoid rtl8xxxu_gen1_config_channel(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tu32 val32, rsr;\n\tu8 val8, opmode;\n\tbool ht = true;\n\tint sec_ch_above, channel;\n\tint i;\n\n\topmode = rtl8xxxu_read8(priv, REG_BW_OPMODE);\n\trsr = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\n\tchannel = hw->conf.chandef.chan->hw_value;\n\n\tswitch (hw->conf.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tht = false;\n\t\t/* fall through */\n\tcase NL80211_CHAN_WIDTH_20:\n\t\topmode |= BW_OPMODE_20MHZ;\n\t\trtl8xxxu_write8(priv, REG_BW_OPMODE, opmode);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tval32 &= ~FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\n\t\tval32 &= ~FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_ANALOG2);\n\t\tval32 |= FPGA0_ANALOG2_20MHZ;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_ANALOG2, val32);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (hw->conf.chandef.center_freq1 >\n\t\t    hw->conf.chandef.chan->center_freq) {\n\t\t\tsec_ch_above = 1;\n\t\t\tchannel += 2;\n\t\t} else {\n\t\t\tsec_ch_above = 0;\n\t\t\tchannel -= 2;\n\t\t}\n\n\t\topmode &= ~BW_OPMODE_20MHZ;\n\t\trtl8xxxu_write8(priv, REG_BW_OPMODE, opmode);\n\t\trsr &= ~RSR_RSC_BANDWIDTH_40M;\n\t\tif (sec_ch_above)\n\t\t\trsr |= RSR_RSC_UPPER_SUB_CHANNEL;\n\t\telse\n\t\t\trsr |= RSR_RSC_LOWER_SUB_CHANNEL;\n\t\trtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, rsr);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tval32 |= FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\n\t\tval32 |= FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\n\n\t\t/*\n\t\t * Set Control channel to upper or lower. These settings\n\t\t * are required only for 40MHz\n\t\t */\n\t\tval32 = rtl8xxxu_read32(priv, REG_CCK0_SYSTEM);\n\t\tval32 &= ~CCK0_SIDEBAND;\n\t\tif (!sec_ch_above)\n\t\t\tval32 |= CCK0_SIDEBAND;\n\t\trtl8xxxu_write32(priv, REG_CCK0_SYSTEM, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM1_LSTF);\n\t\tval32 &= ~OFDM_LSTF_PRIME_CH_MASK; /* 0xc00 */\n\t\tif (sec_ch_above)\n\t\t\tval32 |= OFDM_LSTF_PRIME_CH_LOW;\n\t\telse\n\t\t\tval32 |= OFDM_LSTF_PRIME_CH_HIGH;\n\t\trtl8xxxu_write32(priv, REG_OFDM1_LSTF, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_ANALOG2);\n\t\tval32 &= ~FPGA0_ANALOG2_20MHZ;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_ANALOG2, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_POWER_SAVE);\n\t\tval32 &= ~(FPGA0_PS_LOWER_CHANNEL | FPGA0_PS_UPPER_CHANNEL);\n\t\tif (sec_ch_above)\n\t\t\tval32 |= FPGA0_PS_UPPER_CHANNEL;\n\t\telse\n\t\t\tval32 |= FPGA0_PS_LOWER_CHANNEL;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_POWER_SAVE, val32);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = RF_A; i < priv->rf_paths; i++) {\n\t\tval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\n\t\tval32 &= ~MODE_AG_CHANNEL_MASK;\n\t\tval32 |= channel;\n\t\trtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\n\t}\n\n\tif (ht)\n\t\tval8 = 0x0e;\n\telse\n\t\tval8 = 0x0a;\n\n\trtl8xxxu_write8(priv, REG_SIFS_CCK + 1, val8);\n\trtl8xxxu_write8(priv, REG_SIFS_OFDM + 1, val8);\n\n\trtl8xxxu_write16(priv, REG_R2T_SIFS, 0x0808);\n\trtl8xxxu_write16(priv, REG_T2T_SIFS, 0x0a0a);\n\n\tfor (i = RF_A; i < priv->rf_paths; i++) {\n\t\tval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\n\t\tif (hw->conf.chandef.width == NL80211_CHAN_WIDTH_40)\n\t\t\tval32 &= ~MODE_AG_CHANNEL_20MHZ;\n\t\telse\n\t\t\tval32 |= MODE_AG_CHANNEL_20MHZ;\n\t\trtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\n\t}\n}\n\nvoid rtl8xxxu_gen2_config_channel(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tu32 val32, rsr;\n\tu8 val8, subchannel;\n\tu16 rf_mode_bw;\n\tbool ht = true;\n\tint sec_ch_above, channel;\n\tint i;\n\n\trf_mode_bw = rtl8xxxu_read16(priv, REG_WMAC_TRXPTCL_CTL);\n\trf_mode_bw &= ~WMAC_TRXPTCL_CTL_BW_MASK;\n\trsr = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\n\tchannel = hw->conf.chandef.chan->hw_value;\n\n/* Hack */\n\tsubchannel = 0;\n\n\tswitch (hw->conf.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tht = false;\n\t\t/* fall through */\n\tcase NL80211_CHAN_WIDTH_20:\n\t\trf_mode_bw |= WMAC_TRXPTCL_CTL_BW_20;\n\t\tsubchannel = 0;\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tval32 &= ~FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\n\t\tval32 &= ~FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT);\n\t\tval32 &= ~(BIT(30) | BIT(31));\n\t\trtl8xxxu_write32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT, val32);\n\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\trf_mode_bw |= WMAC_TRXPTCL_CTL_BW_40;\n\n\t\tif (hw->conf.chandef.center_freq1 >\n\t\t    hw->conf.chandef.chan->center_freq) {\n\t\t\tsec_ch_above = 1;\n\t\t\tchannel += 2;\n\t\t} else {\n\t\t\tsec_ch_above = 0;\n\t\t\tchannel -= 2;\n\t\t}\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tval32 |= FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\n\t\tval32 |= FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\n\n\t\t/*\n\t\t * Set Control channel to upper or lower. These settings\n\t\t * are required only for 40MHz\n\t\t */\n\t\tval32 = rtl8xxxu_read32(priv, REG_CCK0_SYSTEM);\n\t\tval32 &= ~CCK0_SIDEBAND;\n\t\tif (!sec_ch_above)\n\t\t\tval32 |= CCK0_SIDEBAND;\n\t\trtl8xxxu_write32(priv, REG_CCK0_SYSTEM, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM1_LSTF);\n\t\tval32 &= ~OFDM_LSTF_PRIME_CH_MASK; /* 0xc00 */\n\t\tif (sec_ch_above)\n\t\t\tval32 |= OFDM_LSTF_PRIME_CH_LOW;\n\t\telse\n\t\t\tval32 |= OFDM_LSTF_PRIME_CH_HIGH;\n\t\trtl8xxxu_write32(priv, REG_OFDM1_LSTF, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_POWER_SAVE);\n\t\tval32 &= ~(FPGA0_PS_LOWER_CHANNEL | FPGA0_PS_UPPER_CHANNEL);\n\t\tif (sec_ch_above)\n\t\t\tval32 |= FPGA0_PS_UPPER_CHANNEL;\n\t\telse\n\t\t\tval32 |= FPGA0_PS_LOWER_CHANNEL;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_POWER_SAVE, val32);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\trf_mode_bw |= WMAC_TRXPTCL_CTL_BW_80;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = RF_A; i < priv->rf_paths; i++) {\n\t\tval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\n\t\tval32 &= ~MODE_AG_CHANNEL_MASK;\n\t\tval32 |= channel;\n\t\trtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\n\t}\n\n\trtl8xxxu_write16(priv, REG_WMAC_TRXPTCL_CTL, rf_mode_bw);\n\trtl8xxxu_write8(priv, REG_DATA_SUBCHANNEL, subchannel);\n\n\tif (ht)\n\t\tval8 = 0x0e;\n\telse\n\t\tval8 = 0x0a;\n\n\trtl8xxxu_write8(priv, REG_SIFS_CCK + 1, val8);\n\trtl8xxxu_write8(priv, REG_SIFS_OFDM + 1, val8);\n\n\trtl8xxxu_write16(priv, REG_R2T_SIFS, 0x0808);\n\trtl8xxxu_write16(priv, REG_T2T_SIFS, 0x0a0a);\n\n\tfor (i = RF_A; i < priv->rf_paths; i++) {\n\t\tval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\n\t\tval32 &= ~MODE_AG_BW_MASK;\n\t\tswitch(hw->conf.chandef.width) {\n\t\tcase NL80211_CHAN_WIDTH_80:\n\t\t\tval32 |= MODE_AG_BW_80MHZ_8723B;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_40:\n\t\t\tval32 |= MODE_AG_BW_40MHZ_8723B;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval32 |= MODE_AG_BW_20MHZ_8723B;\n\t\t\tbreak;\n\t\t}\n\t\trtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\n\t}\n}\n\nvoid\nrtl8xxxu_gen1_set_tx_power(struct rtl8xxxu_priv *priv, int channel, bool ht40)\n{\n\tstruct rtl8xxxu_power_base *power_base = priv->power_base;\n\tu8 cck[RTL8723A_MAX_RF_PATHS], ofdm[RTL8723A_MAX_RF_PATHS];\n\tu8 ofdmbase[RTL8723A_MAX_RF_PATHS], mcsbase[RTL8723A_MAX_RF_PATHS];\n\tu32 val32, ofdm_a, ofdm_b, mcs_a, mcs_b;\n\tu8 val8;\n\tint group, i;\n\n\tgroup = rtl8xxxu_gen1_channel_to_group(channel);\n\n\tcck[0] = priv->cck_tx_power_index_A[group] - 1;\n\tcck[1] = priv->cck_tx_power_index_B[group] - 1;\n\n\tif (priv->hi_pa) {\n\t\tif (cck[0] > 0x20)\n\t\t\tcck[0] = 0x20;\n\t\tif (cck[1] > 0x20)\n\t\t\tcck[1] = 0x20;\n\t}\n\n\tofdm[0] = priv->ht40_1s_tx_power_index_A[group];\n\tofdm[1] = priv->ht40_1s_tx_power_index_B[group];\n\tif (ofdm[0])\n\t\tofdm[0] -= 1;\n\tif (ofdm[1])\n\t\tofdm[1] -= 1;\n\n\tofdmbase[0] = ofdm[0] +\tpriv->ofdm_tx_power_index_diff[group].a;\n\tofdmbase[1] = ofdm[1] +\tpriv->ofdm_tx_power_index_diff[group].b;\n\n\tmcsbase[0] = ofdm[0];\n\tmcsbase[1] = ofdm[1];\n\tif (!ht40) {\n\t\tmcsbase[0] += priv->ht20_tx_power_index_diff[group].a;\n\t\tmcsbase[1] += priv->ht20_tx_power_index_diff[group].b;\n\t}\n\n\tif (priv->tx_paths > 1) {\n\t\tif (ofdm[0] > priv->ht40_2s_tx_power_index_diff[group].a)\n\t\t\tofdm[0] -=  priv->ht40_2s_tx_power_index_diff[group].a;\n\t\tif (ofdm[1] > priv->ht40_2s_tx_power_index_diff[group].b)\n\t\t\tofdm[1] -=  priv->ht40_2s_tx_power_index_diff[group].b;\n\t}\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_CHANNEL)\n\t\tdev_info(&priv->udev->dev,\n\t\t\t \"%s: Setting TX power CCK A: %02x, \"\n\t\t\t \"CCK B: %02x, OFDM A: %02x, OFDM B: %02x\\n\",\n\t\t\t __func__, cck[0], cck[1], ofdm[0], ofdm[1]);\n\n\tfor (i = 0; i < RTL8723A_MAX_RF_PATHS; i++) {\n\t\tif (cck[i] > RF6052_MAX_TX_PWR)\n\t\t\tcck[i] = RF6052_MAX_TX_PWR;\n\t\tif (ofdm[i] > RF6052_MAX_TX_PWR)\n\t\t\tofdm[i] = RF6052_MAX_TX_PWR;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_A_CCK1_MCS32);\n\tval32 &= 0xffff00ff;\n\tval32 |= (cck[0] << 8);\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_CCK1_MCS32, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11);\n\tval32 &= 0xff;\n\tval32 |= ((cck[0] << 8) | (cck[0] << 16) | (cck[0] << 24));\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11);\n\tval32 &= 0xffffff00;\n\tval32 |= cck[1];\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK1_55_MCS32);\n\tval32 &= 0xff;\n\tval32 |= ((cck[1] << 8) | (cck[1] << 16) | (cck[1] << 24));\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_CCK1_55_MCS32, val32);\n\n\tofdm_a = ofdmbase[0] | ofdmbase[0] << 8 |\n\t\tofdmbase[0] << 16 | ofdmbase[0] << 24;\n\tofdm_b = ofdmbase[1] | ofdmbase[1] << 8 |\n\t\tofdmbase[1] << 16 | ofdmbase[1] << 24;\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_RATE18_06,\n\t\t\t ofdm_a + power_base->reg_0e00);\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_RATE18_06,\n\t\t\t ofdm_b + power_base->reg_0830);\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_RATE54_24,\n\t\t\t ofdm_a + power_base->reg_0e04);\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_RATE54_24,\n\t\t\t ofdm_b + power_base->reg_0834);\n\n\tmcs_a = mcsbase[0] | mcsbase[0] << 8 |\n\t\tmcsbase[0] << 16 | mcsbase[0] << 24;\n\tmcs_b = mcsbase[1] | mcsbase[1] << 8 |\n\t\tmcsbase[1] << 16 | mcsbase[1] << 24;\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS03_MCS00,\n\t\t\t mcs_a + power_base->reg_0e10);\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS03_MCS00,\n\t\t\t mcs_b + power_base->reg_083c);\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS07_MCS04,\n\t\t\t mcs_a + power_base->reg_0e14);\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS07_MCS04,\n\t\t\t mcs_b + power_base->reg_0848);\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS11_MCS08,\n\t\t\t mcs_a + power_base->reg_0e18);\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS11_MCS08,\n\t\t\t mcs_b + power_base->reg_084c);\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS15_MCS12,\n\t\t\t mcs_a + power_base->reg_0e1c);\n\tfor (i = 0; i < 3; i++) {\n\t\tif (i != 2)\n\t\t\tval8 = (mcsbase[0] > 8) ? (mcsbase[0] - 8) : 0;\n\t\telse\n\t\t\tval8 = (mcsbase[0] > 6) ? (mcsbase[0] - 6) : 0;\n\t\trtl8xxxu_write8(priv, REG_OFDM0_XC_TX_IQ_IMBALANCE + i, val8);\n\t}\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS15_MCS12,\n\t\t\t mcs_b + power_base->reg_0868);\n\tfor (i = 0; i < 3; i++) {\n\t\tif (i != 2)\n\t\t\tval8 = (mcsbase[1] > 8) ? (mcsbase[1] - 8) : 0;\n\t\telse\n\t\t\tval8 = (mcsbase[1] > 6) ? (mcsbase[1] - 6) : 0;\n\t\trtl8xxxu_write8(priv, REG_OFDM0_XD_TX_IQ_IMBALANCE + i, val8);\n\t}\n}\n\nstatic void rtl8xxxu_set_linktype(struct rtl8xxxu_priv *priv,\n\t\t\t\t  enum nl80211_iftype linktype)\n{\n\tu8 val8;\n\n\tval8 = rtl8xxxu_read8(priv, REG_MSR);\n\tval8 &= ~MSR_LINKTYPE_MASK;\n\n\tswitch (linktype) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\tval8 |= MSR_LINKTYPE_NONE;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tval8 |= MSR_LINKTYPE_ADHOC;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tval8 |= MSR_LINKTYPE_STATION;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tval8 |= MSR_LINKTYPE_AP;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\trtl8xxxu_write8(priv, REG_MSR, val8);\nout:\n\treturn;\n}\n\nstatic void\nrtl8xxxu_set_retry(struct rtl8xxxu_priv *priv, u16 short_retry, u16 long_retry)\n{\n\tu16 val16;\n\n\tval16 = ((short_retry << RETRY_LIMIT_SHORT_SHIFT) &\n\t\t RETRY_LIMIT_SHORT_MASK) |\n\t\t((long_retry << RETRY_LIMIT_LONG_SHIFT) &\n\t\t RETRY_LIMIT_LONG_MASK);\n\n\trtl8xxxu_write16(priv, REG_RETRY_LIMIT, val16);\n}\n\nstatic void\nrtl8xxxu_set_spec_sifs(struct rtl8xxxu_priv *priv, u16 cck, u16 ofdm)\n{\n\tu16 val16;\n\n\tval16 = ((cck << SPEC_SIFS_CCK_SHIFT) & SPEC_SIFS_CCK_MASK) |\n\t\t((ofdm << SPEC_SIFS_OFDM_SHIFT) & SPEC_SIFS_OFDM_MASK);\n\n\trtl8xxxu_write16(priv, REG_SPEC_SIFS, val16);\n}\n\nstatic void rtl8xxxu_print_chipinfo(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tchar *cut;\n\n\tswitch (priv->chip_cut) {\n\tcase 0:\n\t\tcut = \"A\";\n\t\tbreak;\n\tcase 1:\n\t\tcut = \"B\";\n\t\tbreak;\n\tcase 2:\n\t\tcut = \"C\";\n\t\tbreak;\n\tcase 3:\n\t\tcut = \"D\";\n\t\tbreak;\n\tcase 4:\n\t\tcut = \"E\";\n\t\tbreak;\n\tdefault:\n\t\tcut = \"unknown\";\n\t}\n\n\tdev_info(dev,\n\t\t \"RTL%s rev %s (%s) %iT%iR, TX queues %i, WiFi=%i, BT=%i, GPS=%i, HI PA=%i\\n\",\n\t\t priv->chip_name, cut, priv->chip_vendor, priv->tx_paths,\n\t\t priv->rx_paths, priv->ep_tx_count, priv->has_wifi,\n\t\t priv->has_bluetooth, priv->has_gps, priv->hi_pa);\n\n\tdev_info(dev, \"RTL%s MAC: %pM\\n\", priv->chip_name, priv->mac_addr);\n}\n\nstatic int rtl8xxxu_identify_chip(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 val32, bonding;\n\tu16 val16;\n\n\tval32 = rtl8xxxu_read32(priv, REG_SYS_CFG);\n\tpriv->chip_cut = (val32 & SYS_CFG_CHIP_VERSION_MASK) >>\n\t\tSYS_CFG_CHIP_VERSION_SHIFT;\n\tif (val32 & SYS_CFG_TRP_VAUX_EN) {\n\t\tdev_info(dev, \"Unsupported test chip\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (val32 & SYS_CFG_BT_FUNC) {\n\t\tif (priv->chip_cut >= 3) {\n\t\t\tsprintf(priv->chip_name, \"8723BU\");\n\t\t\tpriv->rtl_chip = RTL8723B;\n\t\t} else {\n\t\t\tsprintf(priv->chip_name, \"8723AU\");\n\t\t\tpriv->usb_interrupts = 1;\n\t\t\tpriv->rtl_chip = RTL8723A;\n\t\t}\n\n\t\tpriv->rf_paths = 1;\n\t\tpriv->rx_paths = 1;\n\t\tpriv->tx_paths = 1;\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_MULTI_FUNC_CTRL);\n\t\tif (val32 & MULTI_WIFI_FUNC_EN)\n\t\t\tpriv->has_wifi = 1;\n\t\tif (val32 & MULTI_BT_FUNC_EN)\n\t\t\tpriv->has_bluetooth = 1;\n\t\tif (val32 & MULTI_GPS_FUNC_EN)\n\t\t\tpriv->has_gps = 1;\n\t\tpriv->is_multi_func = 1;\n\t} else if (val32 & SYS_CFG_TYPE_ID) {\n\t\tbonding = rtl8xxxu_read32(priv, REG_HPON_FSM);\n\t\tbonding &= HPON_FSM_BONDING_MASK;\n\t\tif (priv->fops->tx_desc_size ==\n\t\t    sizeof(struct rtl8xxxu_txdesc40)) {\n\t\t\tif (bonding == HPON_FSM_BONDING_1T2R) {\n\t\t\t\tsprintf(priv->chip_name, \"8191EU\");\n\t\t\t\tpriv->rf_paths = 2;\n\t\t\t\tpriv->rx_paths = 2;\n\t\t\t\tpriv->tx_paths = 1;\n\t\t\t\tpriv->rtl_chip = RTL8191E;\n\t\t\t} else {\n\t\t\t\tsprintf(priv->chip_name, \"8192EU\");\n\t\t\t\tpriv->rf_paths = 2;\n\t\t\t\tpriv->rx_paths = 2;\n\t\t\t\tpriv->tx_paths = 2;\n\t\t\t\tpriv->rtl_chip = RTL8192E;\n\t\t\t}\n\t\t} else if (bonding == HPON_FSM_BONDING_1T2R) {\n\t\t\tsprintf(priv->chip_name, \"8191CU\");\n\t\t\tpriv->rf_paths = 2;\n\t\t\tpriv->rx_paths = 2;\n\t\t\tpriv->tx_paths = 1;\n\t\t\tpriv->usb_interrupts = 1;\n\t\t\tpriv->rtl_chip = RTL8191C;\n\t\t} else {\n\t\t\tsprintf(priv->chip_name, \"8192CU\");\n\t\t\tpriv->rf_paths = 2;\n\t\t\tpriv->rx_paths = 2;\n\t\t\tpriv->tx_paths = 2;\n\t\t\tpriv->usb_interrupts = 1;\n\t\t\tpriv->rtl_chip = RTL8192C;\n\t\t}\n\t\tpriv->has_wifi = 1;\n\t} else {\n\t\tsprintf(priv->chip_name, \"8188CU\");\n\t\tpriv->rf_paths = 1;\n\t\tpriv->rx_paths = 1;\n\t\tpriv->tx_paths = 1;\n\t\tpriv->rtl_chip = RTL8188C;\n\t\tpriv->usb_interrupts = 1;\n\t\tpriv->has_wifi = 1;\n\t}\n\n\tswitch (priv->rtl_chip) {\n\tcase RTL8188E:\n\tcase RTL8192E:\n\tcase RTL8723B:\n\t\tswitch (val32 & SYS_CFG_VENDOR_EXT_MASK) {\n\t\tcase SYS_CFG_VENDOR_ID_TSMC:\n\t\t\tsprintf(priv->chip_vendor, \"TSMC\");\n\t\t\tbreak;\n\t\tcase SYS_CFG_VENDOR_ID_SMIC:\n\t\t\tsprintf(priv->chip_vendor, \"SMIC\");\n\t\t\tpriv->vendor_smic = 1;\n\t\t\tbreak;\n\t\tcase SYS_CFG_VENDOR_ID_UMC:\n\t\t\tsprintf(priv->chip_vendor, \"UMC\");\n\t\t\tpriv->vendor_umc = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(priv->chip_vendor, \"unknown\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (val32 & SYS_CFG_VENDOR_ID) {\n\t\t\tsprintf(priv->chip_vendor, \"UMC\");\n\t\t\tpriv->vendor_umc = 1;\n\t\t} else {\n\t\t\tsprintf(priv->chip_vendor, \"TSMC\");\n\t\t}\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_GPIO_OUTSTS);\n\tpriv->rom_rev = (val32 & GPIO_RF_RL_ID) >> 28;\n\n\tval16 = rtl8xxxu_read16(priv, REG_NORMAL_SIE_EP_TX);\n\tif (val16 & NORMAL_SIE_EP_TX_HIGH_MASK) {\n\t\tpriv->ep_tx_high_queue = 1;\n\t\tpriv->ep_tx_count++;\n\t}\n\n\tif (val16 & NORMAL_SIE_EP_TX_NORMAL_MASK) {\n\t\tpriv->ep_tx_normal_queue = 1;\n\t\tpriv->ep_tx_count++;\n\t}\n\n\tif (val16 & NORMAL_SIE_EP_TX_LOW_MASK) {\n\t\tpriv->ep_tx_low_queue = 1;\n\t\tpriv->ep_tx_count++;\n\t}\n\n\t/*\n\t * Fallback for devices that do not provide REG_NORMAL_SIE_EP_TX\n\t */\n\tif (!priv->ep_tx_count) {\n\t\tswitch (priv->nr_out_eps) {\n\t\tcase 4:\n\t\tcase 3:\n\t\t\tpriv->ep_tx_low_queue = 1;\n\t\t\tpriv->ep_tx_count++;\n\t\t\t/* fall through */\n\t\tcase 2:\n\t\t\tpriv->ep_tx_normal_queue = 1;\n\t\t\tpriv->ep_tx_count++;\n\t\t\t/* fall through */\n\t\tcase 1:\n\t\t\tpriv->ep_tx_high_queue = 1;\n\t\t\tpriv->ep_tx_count++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(dev, \"Unsupported USB TX end-points\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nrtl8xxxu_read_efuse8(struct rtl8xxxu_priv *priv, u16 offset, u8 *data)\n{\n\tint i;\n\tu8 val8;\n\tu32 val32;\n\n\t/* Write Address */\n\trtl8xxxu_write8(priv, REG_EFUSE_CTRL + 1, offset & 0xff);\n\tval8 = rtl8xxxu_read8(priv, REG_EFUSE_CTRL + 2);\n\tval8 &= 0xfc;\n\tval8 |= (offset >> 8) & 0x03;\n\trtl8xxxu_write8(priv, REG_EFUSE_CTRL + 2, val8);\n\n\tval8 = rtl8xxxu_read8(priv, REG_EFUSE_CTRL + 3);\n\trtl8xxxu_write8(priv, REG_EFUSE_CTRL + 3, val8 & 0x7f);\n\n\t/* Poll for data read */\n\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\n\tfor (i = 0; i < RTL8XXXU_MAX_REG_POLL; i++) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\n\t\tif (val32 & BIT(31))\n\t\t\tbreak;\n\t}\n\n\tif (i == RTL8XXXU_MAX_REG_POLL)\n\t\treturn -EIO;\n\n\tudelay(50);\n\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\n\n\t*data = val32 & 0xff;\n\treturn 0;\n}\n\nstatic int rtl8xxxu_read_efuse(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint i, ret = 0;\n\tu8 val8, word_mask, header, extheader;\n\tu16 val16, efuse_addr, offset;\n\tu32 val32;\n\n\tval16 = rtl8xxxu_read16(priv, REG_9346CR);\n\tif (val16 & EEPROM_ENABLE)\n\t\tpriv->has_eeprom = 1;\n\tif (val16 & EEPROM_BOOT)\n\t\tpriv->boot_eeprom = 1;\n\n\tif (priv->is_multi_func) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_TEST);\n\t\tval32 = (val32 & ~EFUSE_SELECT_MASK) | EFUSE_WIFI_SELECT;\n\t\trtl8xxxu_write32(priv, REG_EFUSE_TEST, val32);\n\t}\n\n\tdev_dbg(dev, \"Booting from %s\\n\",\n\t\tpriv->boot_eeprom ? \"EEPROM\" : \"EFUSE\");\n\n\trtl8xxxu_write8(priv, REG_EFUSE_ACCESS, EFUSE_ACCESS_ENABLE);\n\n\t/*  1.2V Power: From VDDON with Power Cut(0x0000[15]), default valid */\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_ISO_CTRL);\n\tif (!(val16 & SYS_ISO_PWC_EV12V)) {\n\t\tval16 |= SYS_ISO_PWC_EV12V;\n\t\trtl8xxxu_write16(priv, REG_SYS_ISO_CTRL, val16);\n\t}\n\t/*  Reset: 0x0000[28], default valid */\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tif (!(val16 & SYS_FUNC_ELDR)) {\n\t\tval16 |= SYS_FUNC_ELDR;\n\t\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\t}\n\n\t/*\n\t * Clock: Gated(0x0008[5]) 8M(0x0008[1]) clock from ANA, default valid\n\t */\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_CLKR);\n\tif (!(val16 & SYS_CLK_LOADER_ENABLE) || !(val16 & SYS_CLK_ANA8M)) {\n\t\tval16 |= (SYS_CLK_LOADER_ENABLE | SYS_CLK_ANA8M);\n\t\trtl8xxxu_write16(priv, REG_SYS_CLKR, val16);\n\t}\n\n\t/* Default value is 0xff */\n\tmemset(priv->efuse_wifi.raw, 0xff, EFUSE_MAP_LEN);\n\n\tefuse_addr = 0;\n\twhile (efuse_addr < EFUSE_REAL_CONTENT_LEN_8723A) {\n\t\tu16 map_addr;\n\n\t\tret = rtl8xxxu_read_efuse8(priv, efuse_addr++, &header);\n\t\tif (ret || header == 0xff)\n\t\t\tgoto exit;\n\n\t\tif ((header & 0x1f) == 0x0f) {\t/* extended header */\n\t\t\toffset = (header & 0xe0) >> 5;\n\n\t\t\tret = rtl8xxxu_read_efuse8(priv, efuse_addr++,\n\t\t\t\t\t\t   &extheader);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t\t/* All words disabled */\n\t\t\tif ((extheader & 0x0f) == 0x0f)\n\t\t\t\tcontinue;\n\n\t\t\toffset |= ((extheader & 0xf0) >> 1);\n\t\t\tword_mask = extheader & 0x0f;\n\t\t} else {\n\t\t\toffset = (header >> 4) & 0x0f;\n\t\t\tword_mask = header & 0x0f;\n\t\t}\n\n\t\t/* Get word enable value from PG header */\n\n\t\t/* We have 8 bits to indicate validity */\n\t\tmap_addr = offset * 8;\n\t\tif (map_addr >= EFUSE_MAP_LEN) {\n\t\t\tdev_warn(dev, \"%s: Illegal map_addr (%04x), \"\n\t\t\t\t \"efuse corrupt!\\n\",\n\t\t\t\t __func__, map_addr);\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t\tfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\n\t\t\t/* Check word enable condition in the section */\n\t\t\tif (word_mask & BIT(i)) {\n\t\t\t\tmap_addr += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = rtl8xxxu_read_efuse8(priv, efuse_addr++, &val8);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t\tpriv->efuse_wifi.raw[map_addr++] = val8;\n\n\t\t\tret = rtl8xxxu_read_efuse8(priv, efuse_addr++, &val8);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t\tpriv->efuse_wifi.raw[map_addr++] = val8;\n\t\t}\n\t}\n\nexit:\n\trtl8xxxu_write8(priv, REG_EFUSE_ACCESS, EFUSE_ACCESS_DISABLE);\n\n\treturn ret;\n}\n\nvoid rtl8xxxu_reset_8051(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu16 sys_func;\n\n\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\n\n\tsys_func = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tsys_func &= ~SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, sys_func);\n\n\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\n\n\tsys_func |= SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, sys_func);\n}\n\nstatic int rtl8xxxu_start_firmware(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint ret = 0, i;\n\tu32 val32;\n\n\t/* Poll checksum report */\n\tfor (i = 0; i < RTL8XXXU_FIRMWARE_POLL_MAX; i++) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\n\t\tif (val32 & MCU_FW_DL_CSUM_REPORT)\n\t\t\tbreak;\n\t}\n\n\tif (i == RTL8XXXU_FIRMWARE_POLL_MAX) {\n\t\tdev_warn(dev, \"Firmware checksum poll timed out\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto exit;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\n\tval32 |= MCU_FW_DL_READY;\n\tval32 &= ~MCU_WINT_INIT_READY;\n\trtl8xxxu_write32(priv, REG_MCU_FW_DL, val32);\n\n\t/*\n\t * Reset the 8051 in order for the firmware to start running,\n\t * otherwise it won't come up on the 8192eu\n\t */\n\tpriv->fops->reset_8051(priv);\n\n\t/* Wait for firmware to become ready */\n\tfor (i = 0; i < RTL8XXXU_FIRMWARE_POLL_MAX; i++) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\n\t\tif (val32 & MCU_WINT_INIT_READY)\n\t\t\tbreak;\n\n\t\tudelay(100);\n\t}\n\n\tif (i == RTL8XXXU_FIRMWARE_POLL_MAX) {\n\t\tdev_warn(dev, \"Firmware failed to start\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * Init H2C command\n\t */\n\tif (priv->rtl_chip == RTL8723B)\n\t\trtl8xxxu_write8(priv, REG_HMTFR, 0x0f);\nexit:\n\treturn ret;\n}\n\nstatic int rtl8xxxu_download_firmware(struct rtl8xxxu_priv *priv)\n{\n\tint pages, remainder, i, ret;\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\tu8 *fwptr;\n\n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC + 1);\n\tval8 |= 4;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC + 1, val8);\n\n\t/* 8051 enable */\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tval16 |= SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\n\tval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL);\n\tif (val8 & MCU_FW_RAM_SEL) {\n\t\tpr_info(\"do the RAM reset\\n\");\n\t\trtl8xxxu_write8(priv, REG_MCU_FW_DL, 0x00);\n\t\tpriv->fops->reset_8051(priv);\n\t}\n\n\t/* MCU firmware download enable */\n\tval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL);\n\tval8 |= MCU_FW_DL_ENABLE;\n\trtl8xxxu_write8(priv, REG_MCU_FW_DL, val8);\n\n\t/* 8051 reset */\n\tval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\n\tval32 &= ~BIT(19);\n\trtl8xxxu_write32(priv, REG_MCU_FW_DL, val32);\n\n\t/* Reset firmware download checksum */\n\tval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL);\n\tval8 |= MCU_FW_DL_CSUM_REPORT;\n\trtl8xxxu_write8(priv, REG_MCU_FW_DL, val8);\n\n\tpages = priv->fw_size / RTL_FW_PAGE_SIZE;\n\tremainder = priv->fw_size % RTL_FW_PAGE_SIZE;\n\n\tfwptr = priv->fw_data->data;\n\n\tfor (i = 0; i < pages; i++) {\n\t\tval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL + 2) & 0xF8;\n\t\tval8 |= i;\n\t\trtl8xxxu_write8(priv, REG_MCU_FW_DL + 2, val8);\n\n\t\tret = rtl8xxxu_writeN(priv, REG_FW_START_ADDRESS,\n\t\t\t\t      fwptr, RTL_FW_PAGE_SIZE);\n\t\tif (ret != RTL_FW_PAGE_SIZE) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto fw_abort;\n\t\t}\n\n\t\tfwptr += RTL_FW_PAGE_SIZE;\n\t}\n\n\tif (remainder) {\n\t\tval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL + 2) & 0xF8;\n\t\tval8 |= i;\n\t\trtl8xxxu_write8(priv, REG_MCU_FW_DL + 2, val8);\n\t\tret = rtl8xxxu_writeN(priv, REG_FW_START_ADDRESS,\n\t\t\t\t      fwptr, remainder);\n\t\tif (ret != remainder) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto fw_abort;\n\t\t}\n\t}\n\n\tret = 0;\nfw_abort:\n\t/* MCU firmware download disable */\n\tval16 = rtl8xxxu_read16(priv, REG_MCU_FW_DL);\n\tval16 &= ~MCU_FW_DL_ENABLE;\n\trtl8xxxu_write16(priv, REG_MCU_FW_DL, val16);\n\n\treturn ret;\n}\n\nint rtl8xxxu_load_firmware(struct rtl8xxxu_priv *priv, char *fw_name)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tconst struct firmware *fw;\n\tint ret = 0;\n\tu16 signature;\n\n\tdev_info(dev, \"%s: Loading firmware %s\\n\", DRIVER_NAME, fw_name);\n\tif (request_firmware(&fw, fw_name, &priv->udev->dev)) {\n\t\tdev_warn(dev, \"request_firmware(%s) failed\\n\", fw_name);\n\t\tret = -EAGAIN;\n\t\tgoto exit;\n\t}\n\tif (!fw) {\n\t\tdev_warn(dev, \"Firmware data not available\\n\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tpriv->fw_data = kmemdup(fw->data, fw->size, GFP_KERNEL);\n\tif (!priv->fw_data) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tpriv->fw_size = fw->size - sizeof(struct rtl8xxxu_firmware_header);\n\n\tsignature = le16_to_cpu(priv->fw_data->signature);\n\tswitch (signature & 0xfff0) {\n\tcase 0x92e0:\n\tcase 0x92c0:\n\tcase 0x88c0:\n\tcase 0x5300:\n\tcase 0x2300:\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_warn(dev, \"%s: Invalid firmware signature: 0x%04x\\n\",\n\t\t\t __func__, signature);\n\t}\n\n\tdev_info(dev, \"Firmware revision %i.%i (signature 0x%04x)\\n\",\n\t\t le16_to_cpu(priv->fw_data->major_version),\n\t\t priv->fw_data->minor_version, signature);\n\nexit:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nvoid rtl8xxxu_firmware_self_reset(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16;\n\tint i = 100;\n\n\t/* Inform 8051 to perform reset */\n\trtl8xxxu_write8(priv, REG_HMTFR + 3, 0x20);\n\n\tfor (i = 100; i > 0; i--) {\n\t\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\n\t\tif (!(val16 & SYS_FUNC_CPU_ENABLE)) {\n\t\t\tdev_dbg(&priv->udev->dev,\n\t\t\t\t\"%s: Firmware self reset success!\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(50);\n\t}\n\n\tif (!i) {\n\t\t/* Force firmware reset */\n\t\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\t\tval16 &= ~SYS_FUNC_CPU_ENABLE;\n\t\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\t}\n}\n\nstatic int\nrtl8xxxu_init_mac(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8xxxu_reg8val *array = priv->fops->mactable;\n\tint i, ret;\n\tu16 reg;\n\tu8 val;\n\n\tfor (i = 0; ; i++) {\n\t\treg = array[i].reg;\n\t\tval = array[i].val;\n\n\t\tif (reg == 0xffff && val == 0xff)\n\t\t\tbreak;\n\n\t\tret = rtl8xxxu_write8(priv, reg, val);\n\t\tif (ret != 1) {\n\t\t\tdev_warn(&priv->udev->dev,\n\t\t\t\t \"Failed to initialize MAC \"\n\t\t\t\t \"(reg: %04x, val %02x)\\n\", reg, val);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tif (priv->rtl_chip != RTL8723B && priv->rtl_chip != RTL8192E)\n\t\trtl8xxxu_write8(priv, REG_MAX_AGGR_NUM, 0x0a);\n\n\treturn 0;\n}\n\nint rtl8xxxu_init_phy_regs(struct rtl8xxxu_priv *priv,\n\t\t\t   struct rtl8xxxu_reg32val *array)\n{\n\tint i, ret;\n\tu16 reg;\n\tu32 val;\n\n\tfor (i = 0; ; i++) {\n\t\treg = array[i].reg;\n\t\tval = array[i].val;\n\n\t\tif (reg == 0xffff && val == 0xffffffff)\n\t\t\tbreak;\n\n\t\tret = rtl8xxxu_write32(priv, reg, val);\n\t\tif (ret != sizeof(val)) {\n\t\t\tdev_warn(&priv->udev->dev,\n\t\t\t\t \"Failed to initialize PHY\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\nvoid rtl8xxxu_gen1_init_phy_bb(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8, ldoa15, ldov12d, lpldo, ldohci12;\n\tu16 val16;\n\tu32 val32;\n\n\tval8 = rtl8xxxu_read8(priv, REG_AFE_PLL_CTRL);\n\tudelay(2);\n\tval8 |= AFE_PLL_320_ENABLE;\n\trtl8xxxu_write8(priv, REG_AFE_PLL_CTRL, val8);\n\tudelay(2);\n\n\trtl8xxxu_write8(priv, REG_AFE_PLL_CTRL + 1, 0xff);\n\tudelay(2);\n\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tval16 |= SYS_FUNC_BB_GLB_RSTN | SYS_FUNC_BBRSTB;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\n\tval32 = rtl8xxxu_read32(priv, REG_AFE_XTAL_CTRL);\n\tval32 &= ~AFE_XTAL_RF_GATE;\n\tif (priv->has_bluetooth)\n\t\tval32 &= ~AFE_XTAL_BT_GATE;\n\trtl8xxxu_write32(priv, REG_AFE_XTAL_CTRL, val32);\n\n\t/* 6. 0x1f[7:0] = 0x07 */\n\tval8 = RF_ENABLE | RF_RSTB | RF_SDMRSTB;\n\trtl8xxxu_write8(priv, REG_RF_CTRL, val8);\n\n\tif (priv->hi_pa)\n\t\trtl8xxxu_init_phy_regs(priv, rtl8188ru_phy_1t_highpa_table);\n\telse if (priv->tx_paths == 2)\n\t\trtl8xxxu_init_phy_regs(priv, rtl8192cu_phy_2t_init_table);\n\telse\n\t\trtl8xxxu_init_phy_regs(priv, rtl8723a_phy_1t_init_table);\n\n\tif (priv->rtl_chip == RTL8188R && priv->hi_pa &&\n\t    priv->vendor_umc && priv->chip_cut == 1)\n\t\trtl8xxxu_write8(priv, REG_OFDM0_AGC_PARM1 + 2, 0x50);\n\n\tif (priv->hi_pa)\n\t\trtl8xxxu_init_phy_regs(priv, rtl8xxx_agc_highpa_table);\n\telse\n\t\trtl8xxxu_init_phy_regs(priv, rtl8xxx_agc_standard_table);\n\n\tldoa15 = LDOA15_ENABLE | LDOA15_OBUF;\n\tldov12d = LDOV12D_ENABLE | BIT(2) | (2 << LDOV12D_VADJ_SHIFT);\n\tldohci12 = 0x57;\n\tlpldo = 1;\n\tval32 = (lpldo << 24) | (ldohci12 << 16) | (ldov12d << 8) | ldoa15;\n\trtl8xxxu_write32(priv, REG_LDOA15_CTRL, val32);\n}\n\n/*\n * Most of this is black magic retrieved from the old rtl8723au driver\n */\nstatic int rtl8xxxu_init_phy_bb(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu32 val32;\n\n\tpriv->fops->init_phy_bb(priv);\n\n\tif (priv->tx_paths == 1 && priv->rx_paths == 2) {\n\t\t/*\n\t\t * For 1T2R boards, patch the registers.\n\t\t *\n\t\t * It looks like 8191/2 1T2R boards use path B for TX\n\t\t */\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_TX_INFO);\n\t\tval32 &= ~(BIT(0) | BIT(1));\n\t\tval32 |= BIT(1);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_TX_INFO, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_TX_INFO);\n\t\tval32 &= ~0x300033;\n\t\tval32 |= 0x200022;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_TX_INFO, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_CCK0_AFE_SETTING);\n\t\tval32 &= ~CCK0_AFE_RX_MASK;\n\t\tval32 &= 0x00ffffff;\n\t\tval32 |= 0x40000000;\n\t\tval32 |= CCK0_AFE_RX_ANT_B;\n\t\trtl8xxxu_write32(priv, REG_CCK0_AFE_SETTING, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\t\tval32 &= ~(OFDM_RF_PATH_RX_MASK | OFDM_RF_PATH_TX_MASK);\n\t\tval32 |= (OFDM_RF_PATH_RX_A | OFDM_RF_PATH_RX_B |\n\t\t\t  OFDM_RF_PATH_TX_B);\n\t\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_AGC_PARM1);\n\t\tval32 &= ~(BIT(4) | BIT(5));\n\t\tval32 |= BIT(4);\n\t\trtl8xxxu_write32(priv, REG_OFDM0_AGC_PARM1, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_CCK_RFON);\n\t\tval32 &= ~(BIT(27) | BIT(26));\n\t\tval32 |= BIT(27);\n\t\trtl8xxxu_write32(priv, REG_TX_CCK_RFON, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_CCK_BBON);\n\t\tval32 &= ~(BIT(27) | BIT(26));\n\t\tval32 |= BIT(27);\n\t\trtl8xxxu_write32(priv, REG_TX_CCK_BBON, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_OFDM_RFON);\n\t\tval32 &= ~(BIT(27) | BIT(26));\n\t\tval32 |= BIT(27);\n\t\trtl8xxxu_write32(priv, REG_TX_OFDM_RFON, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_OFDM_BBON);\n\t\tval32 &= ~(BIT(27) | BIT(26));\n\t\tval32 |= BIT(27);\n\t\trtl8xxxu_write32(priv, REG_TX_OFDM_BBON, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_TO_TX);\n\t\tval32 &= ~(BIT(27) | BIT(26));\n\t\tval32 |= BIT(27);\n\t\trtl8xxxu_write32(priv, REG_TX_TO_TX, val32);\n\t}\n\n\tif (priv->has_xtalk) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_MAC_PHY_CTRL);\n\n\t\tval8 = priv->xtalk;\n\t\tval32 &= 0xff000fff;\n\t\tval32 |= ((val8 | (val8 << 6)) << 12);\n\n\t\trtl8xxxu_write32(priv, REG_MAC_PHY_CTRL, val32);\n\t}\n\n\tif (priv->rtl_chip == RTL8192E)\n\t\trtl8xxxu_write32(priv, REG_AFE_XTAL_CTRL, 0x000f81fb);\n\n\treturn 0;\n}\n\nstatic int rtl8xxxu_init_rf_regs(struct rtl8xxxu_priv *priv,\n\t\t\t\t struct rtl8xxxu_rfregval *array,\n\t\t\t\t enum rtl8xxxu_rfpath path)\n{\n\tint i, ret;\n\tu8 reg;\n\tu32 val;\n\n\tfor (i = 0; ; i++) {\n\t\treg = array[i].reg;\n\t\tval = array[i].val;\n\n\t\tif (reg == 0xff && val == 0xffffffff)\n\t\t\tbreak;\n\n\t\tswitch (reg) {\n\t\tcase 0xfe:\n\t\t\tmsleep(50);\n\t\t\tcontinue;\n\t\tcase 0xfd:\n\t\t\tmdelay(5);\n\t\t\tcontinue;\n\t\tcase 0xfc:\n\t\t\tmdelay(1);\n\t\t\tcontinue;\n\t\tcase 0xfb:\n\t\t\tudelay(50);\n\t\t\tcontinue;\n\t\tcase 0xfa:\n\t\t\tudelay(5);\n\t\t\tcontinue;\n\t\tcase 0xf9:\n\t\t\tudelay(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = rtl8xxxu_write_rfreg(priv, path, reg, val);\n\t\tif (ret) {\n\t\t\tdev_warn(&priv->udev->dev,\n\t\t\t\t \"Failed to initialize RF\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\nint rtl8xxxu_init_phy_rf(struct rtl8xxxu_priv *priv,\n\t\t\t struct rtl8xxxu_rfregval *table,\n\t\t\t enum rtl8xxxu_rfpath path)\n{\n\tu32 val32;\n\tu16 val16, rfsi_rfenv;\n\tu16 reg_sw_ctrl, reg_int_oe, reg_hssi_parm2;\n\n\tswitch (path) {\n\tcase RF_A:\n\t\treg_sw_ctrl = REG_FPGA0_XA_RF_SW_CTRL;\n\t\treg_int_oe = REG_FPGA0_XA_RF_INT_OE;\n\t\treg_hssi_parm2 = REG_FPGA0_XA_HSSI_PARM2;\n\t\tbreak;\n\tcase RF_B:\n\t\treg_sw_ctrl = REG_FPGA0_XB_RF_SW_CTRL;\n\t\treg_int_oe = REG_FPGA0_XB_RF_INT_OE;\n\t\treg_hssi_parm2 = REG_FPGA0_XB_HSSI_PARM2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&priv->udev->dev, \"%s:Unsupported RF path %c\\n\",\n\t\t\t__func__, path + 'A');\n\t\treturn -EINVAL;\n\t}\n\t/* For path B, use XB */\n\trfsi_rfenv = rtl8xxxu_read16(priv, reg_sw_ctrl);\n\trfsi_rfenv &= FPGA0_RF_RFENV;\n\n\t/*\n\t * These two we might be able to optimize into one\n\t */\n\tval32 = rtl8xxxu_read32(priv, reg_int_oe);\n\tval32 |= BIT(20);\t/* 0x10 << 16 */\n\trtl8xxxu_write32(priv, reg_int_oe, val32);\n\tudelay(1);\n\n\tval32 = rtl8xxxu_read32(priv, reg_int_oe);\n\tval32 |= BIT(4);\n\trtl8xxxu_write32(priv, reg_int_oe, val32);\n\tudelay(1);\n\n\t/*\n\t * These two we might be able to optimize into one\n\t */\n\tval32 = rtl8xxxu_read32(priv, reg_hssi_parm2);\n\tval32 &= ~FPGA0_HSSI_3WIRE_ADDR_LEN;\n\trtl8xxxu_write32(priv, reg_hssi_parm2, val32);\n\tudelay(1);\n\n\tval32 = rtl8xxxu_read32(priv, reg_hssi_parm2);\n\tval32 &= ~FPGA0_HSSI_3WIRE_DATA_LEN;\n\trtl8xxxu_write32(priv, reg_hssi_parm2, val32);\n\tudelay(1);\n\n\trtl8xxxu_init_rf_regs(priv, table, path);\n\n\t/* For path B, use XB */\n\tval16 = rtl8xxxu_read16(priv, reg_sw_ctrl);\n\tval16 &= ~FPGA0_RF_RFENV;\n\tval16 |= rfsi_rfenv;\n\trtl8xxxu_write16(priv, reg_sw_ctrl, val16);\n\n\treturn 0;\n}\n\nstatic int rtl8xxxu_llt_write(struct rtl8xxxu_priv *priv, u8 address, u8 data)\n{\n\tint ret = -EBUSY;\n\tint count = 0;\n\tu32 value;\n\n\tvalue = LLT_OP_WRITE | address << 8 | data;\n\n\trtl8xxxu_write32(priv, REG_LLT_INIT, value);\n\n\tdo {\n\t\tvalue = rtl8xxxu_read32(priv, REG_LLT_INIT);\n\t\tif ((value & LLT_OP_MASK) == LLT_OP_INACTIVE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (count++ < 20);\n\n\treturn ret;\n}\n\nint rtl8xxxu_init_llt_table(struct rtl8xxxu_priv *priv)\n{\n\tint ret;\n\tint i;\n\tu8 last_tx_page;\n\n\tlast_tx_page = priv->fops->total_page_num;\n\n\tfor (i = 0; i < last_tx_page; i++) {\n\t\tret = rtl8xxxu_llt_write(priv, i, i + 1);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tret = rtl8xxxu_llt_write(priv, last_tx_page, 0xff);\n\tif (ret)\n\t\tgoto exit;\n\n\t/* Mark remaining pages as a ring buffer */\n\tfor (i = last_tx_page + 1; i < 0xff; i++) {\n\t\tret = rtl8xxxu_llt_write(priv, i, (i + 1));\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\t/*  Let last entry point to the start entry of ring buffer */\n\tret = rtl8xxxu_llt_write(priv, 0xff, last_tx_page + 1);\n\tif (ret)\n\t\tgoto exit;\n\nexit:\n\treturn ret;\n}\n\nint rtl8xxxu_auto_llt_table(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\tint ret = 0;\n\tint i;\n\n\tval32 = rtl8xxxu_read32(priv, REG_AUTO_LLT);\n\tval32 |= AUTO_LLT_INIT_LLT;\n\trtl8xxxu_write32(priv, REG_AUTO_LLT, val32);\n\n\tfor (i = 500; i; i--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_AUTO_LLT);\n\t\tif (!(val32 & AUTO_LLT_INIT_LLT))\n\t\t\tbreak;\n\t\tusleep_range(2, 4);\n\t}\n\n\tif (!i) {\n\t\tret = -EBUSY;\n\t\tdev_warn(&priv->udev->dev, \"LLT table init failed\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int rtl8xxxu_init_queue_priority(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16, hi, lo;\n\tu16 hiq, mgq, bkq, beq, viq, voq;\n\tint hip, mgp, bkp, bep, vip, vop;\n\tint ret = 0;\n\n\tswitch (priv->ep_tx_count) {\n\tcase 1:\n\t\tif (priv->ep_tx_high_queue) {\n\t\t\thi = TRXDMA_QUEUE_HIGH;\n\t\t} else if (priv->ep_tx_low_queue) {\n\t\t\thi = TRXDMA_QUEUE_LOW;\n\t\t} else if (priv->ep_tx_normal_queue) {\n\t\t\thi = TRXDMA_QUEUE_NORMAL;\n\t\t} else {\n\t\t\thi = 0;\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\thiq = hi;\n\t\tmgq = hi;\n\t\tbkq = hi;\n\t\tbeq = hi;\n\t\tviq = hi;\n\t\tvoq = hi;\n\n\t\thip = 0;\n\t\tmgp = 0;\n\t\tbkp = 0;\n\t\tbep = 0;\n\t\tvip = 0;\n\t\tvop = 0;\n\t\tbreak;\n\tcase 2:\n\t\tif (priv->ep_tx_high_queue && priv->ep_tx_low_queue) {\n\t\t\thi = TRXDMA_QUEUE_HIGH;\n\t\t\tlo = TRXDMA_QUEUE_LOW;\n\t\t} else if (priv->ep_tx_normal_queue && priv->ep_tx_low_queue) {\n\t\t\thi = TRXDMA_QUEUE_NORMAL;\n\t\t\tlo = TRXDMA_QUEUE_LOW;\n\t\t} else if (priv->ep_tx_high_queue && priv->ep_tx_normal_queue) {\n\t\t\thi = TRXDMA_QUEUE_HIGH;\n\t\t\tlo = TRXDMA_QUEUE_NORMAL;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\thi = 0;\n\t\t\tlo = 0;\n\t\t}\n\n\t\thiq = hi;\n\t\tmgq = hi;\n\t\tbkq = lo;\n\t\tbeq = lo;\n\t\tviq = hi;\n\t\tvoq = hi;\n\n\t\thip = 0;\n\t\tmgp = 0;\n\t\tbkp = 1;\n\t\tbep = 1;\n\t\tvip = 0;\n\t\tvop = 0;\n\t\tbreak;\n\tcase 3:\n\t\tbeq = TRXDMA_QUEUE_LOW;\n\t\tbkq = TRXDMA_QUEUE_LOW;\n\t\tviq = TRXDMA_QUEUE_NORMAL;\n\t\tvoq = TRXDMA_QUEUE_HIGH;\n\t\tmgq = TRXDMA_QUEUE_HIGH;\n\t\thiq = TRXDMA_QUEUE_HIGH;\n\n\t\thip = hiq ^ 3;\n\t\tmgp = mgq ^ 3;\n\t\tbkp = bkq ^ 3;\n\t\tbep = beq ^ 3;\n\t\tvip = viq ^ 3;\n\t\tvop = viq ^ 3;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * None of the vendor drivers are configuring the beacon\n\t * queue here .... why?\n\t */\n\tif (!ret) {\n\t\tval16 = rtl8xxxu_read16(priv, REG_TRXDMA_CTRL);\n\t\tval16 &= 0x7;\n\t\tval16 |= (voq << TRXDMA_CTRL_VOQ_SHIFT) |\n\t\t\t(viq << TRXDMA_CTRL_VIQ_SHIFT) |\n\t\t\t(beq << TRXDMA_CTRL_BEQ_SHIFT) |\n\t\t\t(bkq << TRXDMA_CTRL_BKQ_SHIFT) |\n\t\t\t(mgq << TRXDMA_CTRL_MGQ_SHIFT) |\n\t\t\t(hiq << TRXDMA_CTRL_HIQ_SHIFT);\n\t\trtl8xxxu_write16(priv, REG_TRXDMA_CTRL, val16);\n\n\t\tpriv->pipe_out[TXDESC_QUEUE_VO] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[vop]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_VI] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[vip]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_BE] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[bep]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_BK] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[bkp]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_BEACON] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[0]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_MGNT] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[mgp]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_HIGH] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[hip]);\n\t\tpriv->pipe_out[TXDESC_QUEUE_CMD] =\n\t\t\tusb_sndbulkpipe(priv->udev, priv->out_ep[0]);\n\t}\n\n\treturn ret;\n}\n\nvoid rtl8xxxu_fill_iqk_matrix_a(struct rtl8xxxu_priv *priv, bool iqk_ok,\n\t\t\t\tint result[][8], int candidate, bool tx_only)\n{\n\tu32 oldval, x, tx0_a, reg;\n\tint y, tx0_c;\n\tu32 val32;\n\n\tif (!iqk_ok)\n\t\treturn;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE);\n\toldval = val32 >> 22;\n\n\tx = result[candidate][0];\n\tif ((x & 0x00000200) != 0)\n\t\tx = x | 0xfffffc00;\n\ttx0_a = (x * oldval) >> 8;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE);\n\tval32 &= ~0x3ff;\n\tval32 |= tx0_a;\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\n\tval32 &= ~BIT(31);\n\tif ((x * oldval >> 7) & 0x1)\n\t\tval32 |= BIT(31);\n\trtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\n\n\ty = result[candidate][1];\n\tif ((y & 0x00000200) != 0)\n\t\ty = y | 0xfffffc00;\n\ttx0_c = (y * oldval) >> 8;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XC_TX_AFE);\n\tval32 &= ~0xf0000000;\n\tval32 |= (((tx0_c & 0x3c0) >> 6) << 28);\n\trtl8xxxu_write32(priv, REG_OFDM0_XC_TX_AFE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE);\n\tval32 &= ~0x003f0000;\n\tval32 |= ((tx0_c & 0x3f) << 16);\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\n\tval32 &= ~BIT(29);\n\tif ((y * oldval >> 7) & 0x1)\n\t\tval32 |= BIT(29);\n\trtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\n\n\tif (tx_only) {\n\t\tdev_dbg(&priv->udev->dev, \"%s: only TX\\n\", __func__);\n\t\treturn;\n\t}\n\n\treg = result[candidate][2];\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE);\n\tval32 &= ~0x3ff;\n\tval32 |= (reg & 0x3ff);\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE, val32);\n\n\treg = result[candidate][3] & 0x3F;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE);\n\tval32 &= ~0xfc00;\n\tval32 |= ((reg << 10) & 0xfc00);\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE, val32);\n\n\treg = (result[candidate][3] >> 6) & 0xF;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_RX_IQ_EXT_ANTA);\n\tval32 &= ~0xf0000000;\n\tval32 |= (reg << 28);\n\trtl8xxxu_write32(priv, REG_OFDM0_RX_IQ_EXT_ANTA, val32);\n}\n\nvoid rtl8xxxu_fill_iqk_matrix_b(struct rtl8xxxu_priv *priv, bool iqk_ok,\n\t\t\t\tint result[][8], int candidate, bool tx_only)\n{\n\tu32 oldval, x, tx1_a, reg;\n\tint y, tx1_c;\n\tu32 val32;\n\n\tif (!iqk_ok)\n\t\treturn;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE);\n\toldval = val32 >> 22;\n\n\tx = result[candidate][4];\n\tif ((x & 0x00000200) != 0)\n\t\tx = x | 0xfffffc00;\n\ttx1_a = (x * oldval) >> 8;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE);\n\tval32 &= ~0x3ff;\n\tval32 |= tx1_a;\n\trtl8xxxu_write32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\n\tval32 &= ~BIT(27);\n\tif ((x * oldval >> 7) & 0x1)\n\t\tval32 |= BIT(27);\n\trtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\n\n\ty = result[candidate][5];\n\tif ((y & 0x00000200) != 0)\n\t\ty = y | 0xfffffc00;\n\ttx1_c = (y * oldval) >> 8;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XD_TX_AFE);\n\tval32 &= ~0xf0000000;\n\tval32 |= (((tx1_c & 0x3c0) >> 6) << 28);\n\trtl8xxxu_write32(priv, REG_OFDM0_XD_TX_AFE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE);\n\tval32 &= ~0x003f0000;\n\tval32 |= ((tx1_c & 0x3f) << 16);\n\trtl8xxxu_write32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\n\tval32 &= ~BIT(25);\n\tif ((y * oldval >> 7) & 0x1)\n\t\tval32 |= BIT(25);\n\trtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\n\n\tif (tx_only) {\n\t\tdev_dbg(&priv->udev->dev, \"%s: only TX\\n\", __func__);\n\t\treturn;\n\t}\n\n\treg = result[candidate][6];\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE);\n\tval32 &= ~0x3ff;\n\tval32 |= (reg & 0x3ff);\n\trtl8xxxu_write32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE, val32);\n\n\treg = result[candidate][7] & 0x3f;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE);\n\tval32 &= ~0xfc00;\n\tval32 |= ((reg << 10) & 0xfc00);\n\trtl8xxxu_write32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE, val32);\n\n\treg = (result[candidate][7] >> 6) & 0xf;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_AGCR_SSI_TABLE);\n\tval32 &= ~0x0000f000;\n\tval32 |= (reg << 12);\n\trtl8xxxu_write32(priv, REG_OFDM0_AGCR_SSI_TABLE, val32);\n}\n\n#define MAX_TOLERANCE\t\t5\n\nstatic bool rtl8xxxu_simularity_compare(struct rtl8xxxu_priv *priv,\n\t\t\t\t\tint result[][8], int c1, int c2)\n{\n\tu32 i, j, diff, simubitmap, bound = 0;\n\tint candidate[2] = {-1, -1};\t/* for path A and path B */\n\tbool retval = true;\n\n\tif (priv->tx_paths > 1)\n\t\tbound = 8;\n\telse\n\t\tbound = 4;\n\n\tsimubitmap = 0;\n\n\tfor (i = 0; i < bound; i++) {\n\t\tdiff = (result[c1][i] > result[c2][i]) ?\n\t\t\t(result[c1][i] - result[c2][i]) :\n\t\t\t(result[c2][i] - result[c1][i]);\n\t\tif (diff > MAX_TOLERANCE) {\n\t\t\tif ((i == 2 || i == 6) && !simubitmap) {\n\t\t\t\tif (result[c1][i] + result[c1][i + 1] == 0)\n\t\t\t\t\tcandidate[(i / 4)] = c2;\n\t\t\t\telse if (result[c2][i] + result[c2][i + 1] == 0)\n\t\t\t\t\tcandidate[(i / 4)] = c1;\n\t\t\t\telse\n\t\t\t\t\tsimubitmap = simubitmap | (1 << i);\n\t\t\t} else {\n\t\t\t\tsimubitmap = simubitmap | (1 << i);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (simubitmap == 0) {\n\t\tfor (i = 0; i < (bound / 4); i++) {\n\t\t\tif (candidate[i] >= 0) {\n\t\t\t\tfor (j = i * 4; j < (i + 1) * 4 - 2; j++)\n\t\t\t\t\tresult[3][j] = result[candidate[i]][j];\n\t\t\t\tretval = false;\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t} else if (!(simubitmap & 0x0f)) {\n\t\t/* path A OK */\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tresult[3][i] = result[c1][i];\n\t} else if (!(simubitmap & 0xf0) && priv->tx_paths > 1) {\n\t\t/* path B OK */\n\t\tfor (i = 4; i < 8; i++)\n\t\t\tresult[3][i] = result[c1][i];\n\t}\n\n\treturn false;\n}\n\nbool rtl8xxxu_gen2_simularity_compare(struct rtl8xxxu_priv *priv,\n\t\t\t\t      int result[][8], int c1, int c2)\n{\n\tu32 i, j, diff, simubitmap, bound = 0;\n\tint candidate[2] = {-1, -1};\t/* for path A and path B */\n\tint tmp1, tmp2;\n\tbool retval = true;\n\n\tif (priv->tx_paths > 1)\n\t\tbound = 8;\n\telse\n\t\tbound = 4;\n\n\tsimubitmap = 0;\n\n\tfor (i = 0; i < bound; i++) {\n\t\tif (i & 1) {\n\t\t\tif ((result[c1][i] & 0x00000200))\n\t\t\t\ttmp1 = result[c1][i] | 0xfffffc00;\n\t\t\telse\n\t\t\t\ttmp1 = result[c1][i];\n\n\t\t\tif ((result[c2][i]& 0x00000200))\n\t\t\t\ttmp2 = result[c2][i] | 0xfffffc00;\n\t\t\telse\n\t\t\t\ttmp2 = result[c2][i];\n\t\t} else {\n\t\t\ttmp1 = result[c1][i];\n\t\t\ttmp2 = result[c2][i];\n\t\t}\n\n\t\tdiff = (tmp1 > tmp2) ? (tmp1 - tmp2) : (tmp2 - tmp1);\n\n\t\tif (diff > MAX_TOLERANCE) {\n\t\t\tif ((i == 2 || i == 6) && !simubitmap) {\n\t\t\t\tif (result[c1][i] + result[c1][i + 1] == 0)\n\t\t\t\t\tcandidate[(i / 4)] = c2;\n\t\t\t\telse if (result[c2][i] + result[c2][i + 1] == 0)\n\t\t\t\t\tcandidate[(i / 4)] = c1;\n\t\t\t\telse\n\t\t\t\t\tsimubitmap = simubitmap | (1 << i);\n\t\t\t} else {\n\t\t\t\tsimubitmap = simubitmap | (1 << i);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (simubitmap == 0) {\n\t\tfor (i = 0; i < (bound / 4); i++) {\n\t\t\tif (candidate[i] >= 0) {\n\t\t\t\tfor (j = i * 4; j < (i + 1) * 4 - 2; j++)\n\t\t\t\t\tresult[3][j] = result[candidate[i]][j];\n\t\t\t\tretval = false;\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t} else {\n\t\tif (!(simubitmap & 0x03)) {\n\t\t\t/* path A TX OK */\n\t\t\tfor (i = 0; i < 2; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\n\t\tif (!(simubitmap & 0x0c)) {\n\t\t\t/* path A RX OK */\n\t\t\tfor (i = 2; i < 4; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\n\t\tif (!(simubitmap & 0x30) && priv->tx_paths > 1) {\n\t\t\t/* path B RX OK */\n\t\t\tfor (i = 4; i < 6; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\n\t\tif (!(simubitmap & 0x30) && priv->tx_paths > 1) {\n\t\t\t/* path B RX OK */\n\t\t\tfor (i = 6; i < 8; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid\nrtl8xxxu_save_mac_regs(struct rtl8xxxu_priv *priv, const u32 *reg, u32 *backup)\n{\n\tint i;\n\n\tfor (i = 0; i < (RTL8XXXU_MAC_REGS - 1); i++)\n\t\tbackup[i] = rtl8xxxu_read8(priv, reg[i]);\n\n\tbackup[i] = rtl8xxxu_read32(priv, reg[i]);\n}\n\nvoid rtl8xxxu_restore_mac_regs(struct rtl8xxxu_priv *priv,\n\t\t\t       const u32 *reg, u32 *backup)\n{\n\tint i;\n\n\tfor (i = 0; i < (RTL8XXXU_MAC_REGS - 1); i++)\n\t\trtl8xxxu_write8(priv, reg[i], backup[i]);\n\n\trtl8xxxu_write32(priv, reg[i], backup[i]);\n}\n\nvoid rtl8xxxu_save_regs(struct rtl8xxxu_priv *priv, const u32 *regs,\n\t\t\tu32 *backup, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tbackup[i] = rtl8xxxu_read32(priv, regs[i]);\n}\n\nvoid rtl8xxxu_restore_regs(struct rtl8xxxu_priv *priv, const u32 *regs,\n\t\t\t   u32 *backup, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\trtl8xxxu_write32(priv, regs[i], backup[i]);\n}\n\n\nvoid rtl8xxxu_path_adda_on(struct rtl8xxxu_priv *priv, const u32 *regs,\n\t\t\t   bool path_a_on)\n{\n\tu32 path_on;\n\tint i;\n\n\tif (priv->tx_paths == 1) {\n\t\tpath_on = priv->fops->adda_1t_path_on;\n\t\trtl8xxxu_write32(priv, regs[0], priv->fops->adda_1t_init);\n\t} else {\n\t\tpath_on = path_a_on ? priv->fops->adda_2t_path_on_a :\n\t\t\tpriv->fops->adda_2t_path_on_b;\n\n\t\trtl8xxxu_write32(priv, regs[0], path_on);\n\t}\n\n\tfor (i = 1 ; i < RTL8XXXU_ADDA_REGS ; i++)\n\t\trtl8xxxu_write32(priv, regs[i], path_on);\n}\n\nvoid rtl8xxxu_mac_calibration(struct rtl8xxxu_priv *priv,\n\t\t\t      const u32 *regs, u32 *backup)\n{\n\tint i = 0;\n\n\trtl8xxxu_write8(priv, regs[i], 0x3f);\n\n\tfor (i = 1 ; i < (RTL8XXXU_MAC_REGS - 1); i++)\n\t\trtl8xxxu_write8(priv, regs[i], (u8)(backup[i] & ~BIT(3)));\n\n\trtl8xxxu_write8(priv, regs[i], (u8)(backup[i] & ~BIT(5)));\n}\n\nstatic int rtl8xxxu_iqk_path_a(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_eac, reg_e94, reg_e9c, reg_ea4, val32;\n\tint result = 0;\n\n\t/* path-A IQK setting */\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x10008c1f);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x10008c1f);\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x82140102);\n\n\tval32 = (priv->rf_paths > 1) ? 0x28160202 :\n\t\t/*IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID)?0x28160202: */\n\t\t0x28160502;\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, val32);\n\n\t/* path-B IQK setting */\n\tif (priv->rf_paths > 1) {\n\t\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x10008c22);\n\t\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x10008c22);\n\t\trtl8xxxu_write32(priv, REG_TX_IQK_PI_B, 0x82140102);\n\t\trtl8xxxu_write32(priv, REG_RX_IQK_PI_B, 0x28160202);\n\t}\n\n\t/* LO calibration setting */\n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x001028d1);\n\n\t/* One shot, path A LOK & IQK */\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf9000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(1);\n\n\t/* Check failed */\n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_e94 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\treg_e9c = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\treg_ea4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_A_2);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    ((reg_e94 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_e9c & 0x03ff0000) != 0x00420000))\n\t\tresult |= 0x01;\n\telse\t/* If TX not OK, ignore RX */\n\t\tgoto out;\n\n\t/* If TX is OK, check whether RX is OK */\n\tif (!(reg_eac & BIT(27)) &&\n\t    ((reg_ea4 & 0x03ff0000) != 0x01320000) &&\n\t    ((reg_eac & 0x03ff0000) != 0x00360000))\n\t\tresult |= 0x02;\n\telse\n\t\tdev_warn(&priv->udev->dev, \"%s: Path A RX IQK failed!\\n\",\n\t\t\t __func__);\nout:\n\treturn result;\n}\n\nstatic int rtl8xxxu_iqk_path_b(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_eac, reg_eb4, reg_ebc, reg_ec4, reg_ecc;\n\tint result = 0;\n\n\t/* One shot, path B LOK & IQK */\n\trtl8xxxu_write32(priv, REG_IQK_AGC_CONT, 0x00000002);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_CONT, 0x00000000);\n\n\tmdelay(1);\n\n\t/* Check failed */\n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_eb4 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\treg_ebc = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\treg_ec4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_B_2);\n\treg_ecc = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_B_2);\n\n\tif (!(reg_eac & BIT(31)) &&\n\t    ((reg_eb4 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_ebc & 0x03ff0000) != 0x00420000))\n\t\tresult |= 0x01;\n\telse\n\t\tgoto out;\n\n\tif (!(reg_eac & BIT(30)) &&\n\t    (((reg_ec4 & 0x03ff0000) >> 16) != 0x132) &&\n\t    (((reg_ecc & 0x03ff0000) >> 16) != 0x36))\n\t\tresult |= 0x02;\n\telse\n\t\tdev_warn(&priv->udev->dev, \"%s: Path B RX IQK failed!\\n\",\n\t\t\t __func__);\nout:\n\treturn result;\n}\n\nstatic void rtl8xxxu_phy_iqcalibrate(struct rtl8xxxu_priv *priv,\n\t\t\t\t     int result[][8], int t)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 i, val32;\n\tint path_a_ok, path_b_ok;\n\tint retry = 2;\n\tconst u32 adda_regs[RTL8XXXU_ADDA_REGS] = {\n\t\tREG_FPGA0_XCD_SWITCH_CTRL, REG_BLUETOOTH,\n\t\tREG_RX_WAIT_CCA, REG_TX_CCK_RFON,\n\t\tREG_TX_CCK_BBON, REG_TX_OFDM_RFON,\n\t\tREG_TX_OFDM_BBON, REG_TX_TO_RX,\n\t\tREG_TX_TO_TX, REG_RX_CCK,\n\t\tREG_RX_OFDM, REG_RX_WAIT_RIFS,\n\t\tREG_RX_TO_RX, REG_STANDBY,\n\t\tREG_SLEEP, REG_PMPD_ANAEN\n\t};\n\tconst u32 iqk_mac_regs[RTL8XXXU_MAC_REGS] = {\n\t\tREG_TXPAUSE, REG_BEACON_CTRL,\n\t\tREG_BEACON_CTRL_1, REG_GPIO_MUXCFG\n\t};\n\tconst u32 iqk_bb_regs[RTL8XXXU_BB_REGS] = {\n\t\tREG_OFDM0_TRX_PATH_ENABLE, REG_OFDM0_TR_MUX_PAR,\n\t\tREG_FPGA0_XCD_RF_SW_CTRL, REG_CONFIG_ANT_A, REG_CONFIG_ANT_B,\n\t\tREG_FPGA0_XAB_RF_SW_CTRL, REG_FPGA0_XA_RF_INT_OE,\n\t\tREG_FPGA0_XB_RF_INT_OE, REG_FPGA0_RF_MODE\n\t};\n\n\t/*\n\t * Note: IQ calibration must be performed after loading\n\t *       PHY_REG.txt , and radio_a, radio_b.txt\n\t */\n\n\tif (t == 0) {\n\t\t/* Save ADDA parameters, turn Path A ADDA on */\n\t\trtl8xxxu_save_regs(priv, adda_regs, priv->adda_backup,\n\t\t\t\t   RTL8XXXU_ADDA_REGS);\n\t\trtl8xxxu_save_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\t\trtl8xxxu_save_regs(priv, iqk_bb_regs,\n\t\t\t\t   priv->bb_backup, RTL8XXXU_BB_REGS);\n\t}\n\n\trtl8xxxu_path_adda_on(priv, adda_regs, true);\n\n\tif (t == 0) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XA_HSSI_PARM1);\n\t\tif (val32 & FPGA0_HSSI_PARM1_PI)\n\t\t\tpriv->pi_enabled = 1;\n\t}\n\n\tif (!priv->pi_enabled) {\n\t\t/* Switch BB to PI mode to do IQ Calibration. */\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000100);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XB_HSSI_PARM1, 0x01000100);\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\tval32 &= ~FPGA_RF_MODE_CCK;\n\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x03a05600);\n\trtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000800e4);\n\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x22204000);\n\n\tif (!priv->no_pape) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XAB_RF_SW_CTRL);\n\t\tval32 |= (FPGA0_RF_PAPE |\n\t\t\t  (FPGA0_RF_PAPE << FPGA0_RF_BD_CTRL_SHIFT));\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_SW_CTRL, val32);\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XA_RF_INT_OE);\n\tval32 &= ~BIT(10);\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_RF_INT_OE, val32);\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XB_RF_INT_OE);\n\tval32 &= ~BIT(10);\n\trtl8xxxu_write32(priv, REG_FPGA0_XB_RF_INT_OE, val32);\n\n\tif (priv->tx_paths > 1) {\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_LSSI_PARM, 0x00010000);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XB_LSSI_PARM, 0x00010000);\n\t}\n\n\t/* MAC settings */\n\trtl8xxxu_mac_calibration(priv, iqk_mac_regs, priv->mac_backup);\n\n\t/* Page B init */\n\trtl8xxxu_write32(priv, REG_CONFIG_ANT_A, 0x00080000);\n\n\tif (priv->tx_paths > 1)\n\t\trtl8xxxu_write32(priv, REG_CONFIG_ANT_B, 0x00080000);\n\n\t/* IQ calibration setting */\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\tfor (i = 0; i < retry; i++) {\n\t\tpath_a_ok = rtl8xxxu_iqk_path_a(priv);\n\t\tif (path_a_ok == 0x03) {\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_BEFORE_IQK_A);\n\t\t\tresult[t][0] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_AFTER_IQK_A);\n\t\t\tresult[t][1] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_RX_POWER_BEFORE_IQK_A_2);\n\t\t\tresult[t][2] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_RX_POWER_AFTER_IQK_A_2);\n\t\t\tresult[t][3] = (val32 >> 16) & 0x3ff;\n\t\t\tbreak;\n\t\t} else if (i == (retry - 1) && path_a_ok == 0x01) {\n\t\t\t/* TX IQK OK */\n\t\t\tdev_dbg(dev, \"%s: Path A IQK Only Tx Success!!\\n\",\n\t\t\t\t__func__);\n\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_BEFORE_IQK_A);\n\t\t\tresult[t][0] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_AFTER_IQK_A);\n\t\t\tresult[t][1] = (val32 >> 16) & 0x3ff;\n\t\t}\n\t}\n\n\tif (!path_a_ok)\n\t\tdev_dbg(dev, \"%s: Path A IQK failed!\\n\", __func__);\n\n\tif (priv->tx_paths > 1) {\n\t\t/*\n\t\t * Path A into standby\n\t\t */\n\t\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x0);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_LSSI_PARM, 0x00010000);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\n\t\t/* Turn Path B ADDA on */\n\t\trtl8xxxu_path_adda_on(priv, adda_regs, false);\n\n\t\tfor (i = 0; i < retry; i++) {\n\t\t\tpath_b_ok = rtl8xxxu_iqk_path_b(priv);\n\t\t\tif (path_b_ok == 0x03) {\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\t\t\t\tresult[t][4] = (val32 >> 16) & 0x3ff;\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\t\t\t\tresult[t][5] = (val32 >> 16) & 0x3ff;\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_B_2);\n\t\t\t\tresult[t][6] = (val32 >> 16) & 0x3ff;\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_B_2);\n\t\t\t\tresult[t][7] = (val32 >> 16) & 0x3ff;\n\t\t\t\tbreak;\n\t\t\t} else if (i == (retry - 1) && path_b_ok == 0x01) {\n\t\t\t\t/* TX IQK OK */\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\t\t\t\tresult[t][4] = (val32 >> 16) & 0x3ff;\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\t\t\t\tresult[t][5] = (val32 >> 16) & 0x3ff;\n\t\t\t}\n\t\t}\n\n\t\tif (!path_b_ok)\n\t\t\tdev_dbg(dev, \"%s: Path B IQK failed!\\n\", __func__);\n\t}\n\n\t/* Back to BB mode, load original value */\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0);\n\n\tif (t) {\n\t\tif (!priv->pi_enabled) {\n\t\t\t/*\n\t\t\t * Switch back BB to SI mode after finishing\n\t\t\t * IQ Calibration\n\t\t\t */\n\t\t\tval32 = 0x01000000;\n\t\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, val32);\n\t\t\trtl8xxxu_write32(priv, REG_FPGA0_XB_HSSI_PARM1, val32);\n\t\t}\n\n\t\t/* Reload ADDA power saving parameters */\n\t\trtl8xxxu_restore_regs(priv, adda_regs, priv->adda_backup,\n\t\t\t\t      RTL8XXXU_ADDA_REGS);\n\n\t\t/* Reload MAC parameters */\n\t\trtl8xxxu_restore_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\n\t\t/* Reload BB parameters */\n\t\trtl8xxxu_restore_regs(priv, iqk_bb_regs,\n\t\t\t\t      priv->bb_backup, RTL8XXXU_BB_REGS);\n\n\t\t/* Restore RX initial gain */\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_LSSI_PARM, 0x00032ed3);\n\n\t\tif (priv->tx_paths > 1) {\n\t\t\trtl8xxxu_write32(priv, REG_FPGA0_XB_LSSI_PARM,\n\t\t\t\t\t 0x00032ed3);\n\t\t}\n\n\t\t/* Load 0xe30 IQC default value */\n\t\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x01008c00);\n\t\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x01008c00);\n\t}\n}\n\nvoid rtl8xxxu_gen2_prepare_calibrate(struct rtl8xxxu_priv *priv, u8 start)\n{\n\tstruct h2c_cmd h2c;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\th2c.bt_wlan_calibration.cmd = H2C_8723B_BT_WLAN_CALIBRATION;\n\th2c.bt_wlan_calibration.data = start;\n\n\trtl8xxxu_gen2_h2c_cmd(priv, &h2c, sizeof(h2c.bt_wlan_calibration));\n}\n\nvoid rtl8xxxu_gen1_phy_iq_calibrate(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint result[4][8];\t/* last is final result */\n\tint i, candidate;\n\tbool path_a_ok, path_b_ok;\n\tu32 reg_e94, reg_e9c, reg_ea4, reg_eac;\n\tu32 reg_eb4, reg_ebc, reg_ec4, reg_ecc;\n\ts32 reg_tmp = 0;\n\tbool simu;\n\n\tmemset(result, 0, sizeof(result));\n\tcandidate = -1;\n\n\tpath_a_ok = false;\n\tpath_b_ok = false;\n\n\trtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\n\tfor (i = 0; i < 3; i++) {\n\t\trtl8xxxu_phy_iqcalibrate(priv, result, i);\n\n\t\tif (i == 1) {\n\t\t\tsimu = rtl8xxxu_simularity_compare(priv, result, 0, 1);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == 2) {\n\t\t\tsimu = rtl8xxxu_simularity_compare(priv, result, 0, 2);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsimu = rtl8xxxu_simularity_compare(priv, result, 1, 2);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 1;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t\treg_tmp += result[3][i];\n\n\t\t\t\tif (reg_tmp)\n\t\t\t\t\tcandidate = 3;\n\t\t\t\telse\n\t\t\t\t\tcandidate = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\treg_e94 = result[i][0];\n\t\treg_e9c = result[i][1];\n\t\treg_ea4 = result[i][2];\n\t\treg_eac = result[i][3];\n\t\treg_eb4 = result[i][4];\n\t\treg_ebc = result[i][5];\n\t\treg_ec4 = result[i][6];\n\t\treg_ecc = result[i][7];\n\t}\n\n\tif (candidate >= 0) {\n\t\treg_e94 = result[candidate][0];\n\t\tpriv->rege94 =  reg_e94;\n\t\treg_e9c = result[candidate][1];\n\t\tpriv->rege9c = reg_e9c;\n\t\treg_ea4 = result[candidate][2];\n\t\treg_eac = result[candidate][3];\n\t\treg_eb4 = result[candidate][4];\n\t\tpriv->regeb4 = reg_eb4;\n\t\treg_ebc = result[candidate][5];\n\t\tpriv->regebc = reg_ebc;\n\t\treg_ec4 = result[candidate][6];\n\t\treg_ecc = result[candidate][7];\n\t\tdev_dbg(dev, \"%s: candidate is %x\\n\", __func__, candidate);\n\t\tdev_dbg(dev,\n\t\t\t\"%s: e94 =%x e9c=%x ea4=%x eac=%x eb4=%x ebc=%x ec4=%x ecc=%x\\n\",\n\t\t\t__func__, reg_e94, reg_e9c,\n\t\t\treg_ea4, reg_eac, reg_eb4, reg_ebc, reg_ec4, reg_ecc);\n\t\tpath_a_ok = true;\n\t\tpath_b_ok = true;\n\t} else {\n\t\treg_e94 = reg_eb4 = priv->rege94 = priv->regeb4 = 0x100;\n\t\treg_e9c = reg_ebc = priv->rege9c = priv->regebc = 0x0;\n\t}\n\n\tif (reg_e94 && candidate >= 0)\n\t\trtl8xxxu_fill_iqk_matrix_a(priv, path_a_ok, result,\n\t\t\t\t\t   candidate, (reg_ea4 == 0));\n\n\tif (priv->tx_paths > 1 && reg_eb4)\n\t\trtl8xxxu_fill_iqk_matrix_b(priv, path_b_ok, result,\n\t\t\t\t\t   candidate, (reg_ec4 == 0));\n\n\trtl8xxxu_save_regs(priv, rtl8xxxu_iqk_phy_iq_bb_reg,\n\t\t\t   priv->bb_recovery_backup, RTL8XXXU_BB_REGS);\n}\n\nstatic void rtl8723a_phy_lc_calibrate(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\tu32 rf_amode, rf_bmode = 0, lstf;\n\n\t/* Check continuous TX and Packet TX */\n\tlstf = rtl8xxxu_read32(priv, REG_OFDM1_LSTF);\n\n\tif (lstf & OFDM_LSTF_MASK) {\n\t\t/* Disable all continuous TX */\n\t\tval32 = lstf & ~OFDM_LSTF_MASK;\n\t\trtl8xxxu_write32(priv, REG_OFDM1_LSTF, val32);\n\n\t\t/* Read original RF mode Path A */\n\t\trf_amode = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_AC);\n\n\t\t/* Set RF mode to standby Path A */\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC,\n\t\t\t\t     (rf_amode & 0x8ffff) | 0x10000);\n\n\t\t/* Path-B */\n\t\tif (priv->tx_paths > 1) {\n\t\t\trf_bmode = rtl8xxxu_read_rfreg(priv, RF_B,\n\t\t\t\t\t\t       RF6052_REG_AC);\n\n\t\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC,\n\t\t\t\t\t     (rf_bmode & 0x8ffff) | 0x10000);\n\t\t}\n\t} else {\n\t\t/*  Deal with Packet TX case */\n\t\t/*  block all queues */\n\t\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\t}\n\n\t/* Start LC calibration */\n\tif (priv->fops->has_s0s1)\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_S0S1, 0xdfbe0);\n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_MODE_AG);\n\tval32 |= 0x08000;\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_MODE_AG, val32);\n\n\tmsleep(100);\n\n\tif (priv->fops->has_s0s1)\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_S0S1, 0xdffe0);\n\n\t/* Restore original parameters */\n\tif (lstf & OFDM_LSTF_MASK) {\n\t\t/* Path-A */\n\t\trtl8xxxu_write32(priv, REG_OFDM1_LSTF, lstf);\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, rf_amode);\n\n\t\t/* Path-B */\n\t\tif (priv->tx_paths > 1)\n\t\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC,\n\t\t\t\t\t     rf_bmode);\n\t} else /*  Deal with Packet TX case */\n\t\trtl8xxxu_write8(priv, REG_TXPAUSE, 0x00);\n}\n\nstatic int rtl8xxxu_set_mac(struct rtl8xxxu_priv *priv)\n{\n\tint i;\n\tu16 reg;\n\n\treg = REG_MACID;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\trtl8xxxu_write8(priv, reg + i, priv->mac_addr[i]);\n\n\treturn 0;\n}\n\nstatic int rtl8xxxu_set_bssid(struct rtl8xxxu_priv *priv, const u8 *bssid)\n{\n\tint i;\n\tu16 reg;\n\n\tdev_dbg(&priv->udev->dev, \"%s: (%pM)\\n\", __func__, bssid);\n\n\treg = REG_BSSID;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\trtl8xxxu_write8(priv, reg + i, bssid[i]);\n\n\treturn 0;\n}\n\nstatic void\nrtl8xxxu_set_ampdu_factor(struct rtl8xxxu_priv *priv, u8 ampdu_factor)\n{\n\tu8 vals[4] = { 0x41, 0xa8, 0x72, 0xb9 };\n\tu8 max_agg = 0xf;\n\tint i;\n\n\tampdu_factor = 1 << (ampdu_factor + 2);\n\tif (ampdu_factor > max_agg)\n\t\tampdu_factor = max_agg;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif ((vals[i] & 0xf0) > (ampdu_factor << 4))\n\t\t\tvals[i] = (vals[i] & 0x0f) | (ampdu_factor << 4);\n\n\t\tif ((vals[i] & 0x0f) > ampdu_factor)\n\t\t\tvals[i] = (vals[i] & 0xf0) | ampdu_factor;\n\n\t\trtl8xxxu_write8(priv, REG_AGGLEN_LMT + i, vals[i]);\n\t}\n}\n\nstatic void rtl8xxxu_set_ampdu_min_space(struct rtl8xxxu_priv *priv, u8 density)\n{\n\tu8 val8;\n\n\tval8 = rtl8xxxu_read8(priv, REG_AMPDU_MIN_SPACE);\n\tval8 &= 0xf8;\n\tval8 |= density;\n\trtl8xxxu_write8(priv, REG_AMPDU_MIN_SPACE, val8);\n}\n\nstatic int rtl8xxxu_active_to_emu(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tint count, ret = 0;\n\n\t/* Start of rtl8723AU_card_enable_flow */\n\t/* Act to Cardemu sequence*/\n\t/* Turn off RF */\n\trtl8xxxu_write8(priv, REG_RF_CTRL, 0);\n\n\t/* 0x004E[7] = 0, switch DPDT_SEL_P output from register 0x0065[2] */\n\tval8 = rtl8xxxu_read8(priv, REG_LEDCFG2);\n\tval8 &= ~LEDCFG2_DPDT_SELECT;\n\trtl8xxxu_write8(priv, REG_LEDCFG2, val8);\n\n\t/* 0x0005[1] = 1 turn off MAC by HW state machine*/\n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 |= BIT(1);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\t\tif ((val8 & BIT(1)) == 0)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tif (!count) {\n\t\tdev_warn(&priv->udev->dev, \"%s: Disabling MAC timed out\\n\",\n\t\t\t __func__);\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t/* 0x0000[5] = 1 analog Ips to digital, 1:isolation */\n\tval8 = rtl8xxxu_read8(priv, REG_SYS_ISO_CTRL);\n\tval8 |= SYS_ISO_ANALOG_IPS;\n\trtl8xxxu_write8(priv, REG_SYS_ISO_CTRL, val8);\n\n\t/* 0x0020[0] = 0 disable LDOA12 MACRO block*/\n\tval8 = rtl8xxxu_read8(priv, REG_LDOA15_CTRL);\n\tval8 &= ~LDOA15_ENABLE;\n\trtl8xxxu_write8(priv, REG_LDOA15_CTRL, val8);\n\nexit:\n\treturn ret;\n}\n\nint rtl8xxxu_active_to_lps(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu8 val32;\n\tint count, ret = 0;\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\n\t/*\n\t * Poll - wait for RX packet to complete\n\t */\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, 0x5f8);\n\t\tif (!val32)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tif (!count) {\n\t\tdev_warn(&priv->udev->dev,\n\t\t\t \"%s: RX poll timed out (0x05f8)\\n\", __func__);\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t/* Disable CCK and OFDM, clock gated */\n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\n\tval8 &= ~SYS_FUNC_BBRSTB;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\n\n\tudelay(2);\n\n\t/* Reset baseband */\n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\n\tval8 &= ~SYS_FUNC_BB_GLB_RSTN;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\n\n\t/* Reset MAC TRX */\n\tval8 = rtl8xxxu_read8(priv, REG_CR);\n\tval8 = CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE;\n\trtl8xxxu_write8(priv, REG_CR, val8);\n\n\t/* Reset MAC TRX */\n\tval8 = rtl8xxxu_read8(priv, REG_CR + 1);\n\tval8 &= ~BIT(1); /* CR_SECURITY_ENABLE */\n\trtl8xxxu_write8(priv, REG_CR + 1, val8);\n\n\t/* Respond TX OK to scheduler */\n\tval8 = rtl8xxxu_read8(priv, REG_DUAL_TSF_RST);\n\tval8 |= DUAL_TSF_TX_OK;\n\trtl8xxxu_write8(priv, REG_DUAL_TSF_RST, val8);\n\nexit:\n\treturn ret;\n}\n\nvoid rtl8xxxu_disabled_to_emu(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\n\t/* Clear suspend enable and power down enable*/\n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~(BIT(3) | BIT(7));\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\t/* 0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/\n\tval8 = rtl8xxxu_read8(priv, REG_GPIO_INTM + 2);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_GPIO_INTM + 2, val8);\n\n\t/* 0x04[12:11] = 11 enable WL suspend*/\n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~(BIT(3) | BIT(4));\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n}\n\nstatic int rtl8xxxu_emu_to_disabled(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\n\t/* 0x0007[7:0] = 0x20 SOP option to disable BG/MB */\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 3, 0x20);\n\n\t/* 0x04[12:11] = 01 enable WL suspend */\n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~BIT(4);\n\tval8 |= BIT(3);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 |= BIT(7);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\t/* 0x48[16] = 1 to enable GPIO9 as EXT wakeup */\n\tval8 = rtl8xxxu_read8(priv, REG_GPIO_INTM + 2);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, REG_GPIO_INTM + 2, val8);\n\n\treturn 0;\n}\n\nint rtl8xxxu_flush_fifo(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 val32;\n\tint retry, retval;\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\n\tval32 = rtl8xxxu_read32(priv, REG_RXPKT_NUM);\n\tval32 |= RXPKT_NUM_RW_RELEASE_EN;\n\trtl8xxxu_write32(priv, REG_RXPKT_NUM, val32);\n\n\tretry = 100;\n\tretval = -EBUSY;\n\n\tdo {\n\t\tval32 = rtl8xxxu_read32(priv, REG_RXPKT_NUM);\n\t\tif (val32 & RXPKT_NUM_RXDMA_IDLE) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (retry--);\n\n\trtl8xxxu_write16(priv, REG_RQPN_NPQ, 0);\n\trtl8xxxu_write32(priv, REG_RQPN, 0x80000000);\n\tmdelay(2);\n\n\tif (!retry)\n\t\tdev_warn(dev, \"Failed to flush FIFO\\n\");\n\n\treturn retval;\n}\n\nvoid rtl8xxxu_gen1_usb_quirks(struct rtl8xxxu_priv *priv)\n{\n\t/* Fix USB interface interference issue */\n\trtl8xxxu_write8(priv, 0xfe40, 0xe0);\n\trtl8xxxu_write8(priv, 0xfe41, 0x8d);\n\trtl8xxxu_write8(priv, 0xfe42, 0x80);\n\t/*\n\t * This sets TXDMA_OFFSET_DROP_DATA_EN (bit 9) as well as bits\n\t * 8 and 5, for which I have found no documentation.\n\t */\n\trtl8xxxu_write32(priv, REG_TXDMA_OFFSET_CHK, 0xfd0320);\n\n\t/*\n\t * Solve too many protocol error on USB bus.\n\t * Can't do this for 8188/8192 UMC A cut parts\n\t */\n\tif (!(!priv->chip_cut && priv->vendor_umc)) {\n\t\trtl8xxxu_write8(priv, 0xfe40, 0xe6);\n\t\trtl8xxxu_write8(priv, 0xfe41, 0x94);\n\t\trtl8xxxu_write8(priv, 0xfe42, 0x80);\n\n\t\trtl8xxxu_write8(priv, 0xfe40, 0xe0);\n\t\trtl8xxxu_write8(priv, 0xfe41, 0x19);\n\t\trtl8xxxu_write8(priv, 0xfe42, 0x80);\n\n\t\trtl8xxxu_write8(priv, 0xfe40, 0xe5);\n\t\trtl8xxxu_write8(priv, 0xfe41, 0x91);\n\t\trtl8xxxu_write8(priv, 0xfe42, 0x80);\n\n\t\trtl8xxxu_write8(priv, 0xfe40, 0xe2);\n\t\trtl8xxxu_write8(priv, 0xfe41, 0x81);\n\t\trtl8xxxu_write8(priv, 0xfe42, 0x80);\n\t}\n}\n\nvoid rtl8xxxu_gen2_usb_quirks(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\n\tval32 = rtl8xxxu_read32(priv, REG_TXDMA_OFFSET_CHK);\n\tval32 |= TXDMA_OFFSET_DROP_DATA_EN;\n\trtl8xxxu_write32(priv, REG_TXDMA_OFFSET_CHK, val32);\n}\n\nvoid rtl8xxxu_power_off(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\n\t/*\n\t * Workaround for 8188RU LNA power leakage problem.\n\t */\n\tif (priv->rtl_chip == RTL8188R) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XCD_RF_PARM);\n\t\tval32 |= BIT(1);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_PARM, val32);\n\t}\n\n\trtl8xxxu_flush_fifo(priv);\n\n\trtl8xxxu_active_to_lps(priv);\n\n\t/* Turn off RF */\n\trtl8xxxu_write8(priv, REG_RF_CTRL, 0x00);\n\n\t/* Reset Firmware if running in RAM */\n\tif (rtl8xxxu_read8(priv, REG_MCU_FW_DL) & MCU_FW_RAM_SEL)\n\t\trtl8xxxu_firmware_self_reset(priv);\n\n\t/* Reset MCU */\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tval16 &= ~SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\n\t/* Reset MCU ready status */\n\trtl8xxxu_write8(priv, REG_MCU_FW_DL, 0x00);\n\n\trtl8xxxu_active_to_emu(priv);\n\trtl8xxxu_emu_to_disabled(priv);\n\n\t/* Reset MCU IO Wrapper */\n\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\n\n\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\n\n\t/* RSV_CTRL 0x1C[7:0] = 0x0e  lock ISO/CLK/Power control register */\n\trtl8xxxu_write8(priv, REG_RSV_CTRL, 0x0e);\n}\n\n#ifdef NEED_PS_TDMA\nstatic void rtl8723bu_set_ps_tdma(struct rtl8xxxu_priv *priv,\n\t\t\t\t  u8 arg1, u8 arg2, u8 arg3, u8 arg4, u8 arg5)\n{\n\tstruct h2c_cmd h2c;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\th2c.b_type_dma.cmd = H2C_8723B_B_TYPE_TDMA;\n\th2c.b_type_dma.data1 = arg1;\n\th2c.b_type_dma.data2 = arg2;\n\th2c.b_type_dma.data3 = arg3;\n\th2c.b_type_dma.data4 = arg4;\n\th2c.b_type_dma.data5 = arg5;\n\trtl8xxxu_gen2_h2c_cmd(priv, &h2c, sizeof(h2c.b_type_dma));\n}\n#endif\n\nvoid rtl8xxxu_gen2_disable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\n\tval32 = rtl8xxxu_read32(priv, REG_RX_WAIT_CCA);\n\tval32 &= ~(BIT(22) | BIT(23));\n\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, val32);\n}\n\nstatic void rtl8xxxu_init_queue_reserved_page(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8xxxu_fileops *fops = priv->fops;\n\tu32 hq, lq, nq, eq, pubq;\n\tu32 val32;\n\n\thq = 0;\n\tlq = 0;\n\tnq = 0;\n\teq = 0;\n\tpubq = 0;\n\n\tif (priv->ep_tx_high_queue)\n\t\thq = fops->page_num_hi;\n\tif (priv->ep_tx_low_queue)\n\t\tlq = fops->page_num_lo;\n\tif (priv->ep_tx_normal_queue)\n\t\tnq = fops->page_num_norm;\n\n\tval32 = (nq << RQPN_NPQ_SHIFT) | (eq << RQPN_EPQ_SHIFT);\n\trtl8xxxu_write32(priv, REG_RQPN_NPQ, val32);\n\n\tpubq = fops->total_page_num - hq - lq - nq - 1;\n\n\tval32 = RQPN_LOAD;\n\tval32 |= (hq << RQPN_HI_PQ_SHIFT);\n\tval32 |= (lq << RQPN_LO_PQ_SHIFT);\n\tval32 |= (pubq << RQPN_PUB_PQ_SHIFT);\n\n\trtl8xxxu_write32(priv, REG_RQPN, val32);\n}\n\nstatic int rtl8xxxu_init_device(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tstruct rtl8xxxu_fileops *fops = priv->fops;\n\tbool macpower;\n\tint ret;\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\n\t/* Check if MAC is already powered on */\n\tval8 = rtl8xxxu_read8(priv, REG_CR);\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_CLKR);\n\n\t/*\n\t * Fix 92DU-VC S3 hang with the reason is that secondary mac is not\n\t * initialized. First MAC returns 0xea, second MAC returns 0x00\n\t */\n\tif (val8 == 0xea || !(val16 & SYS_CLK_MAC_CLK_ENABLE))\n\t\tmacpower = false;\n\telse\n\t\tmacpower = true;\n\n\tret = fops->power_on(priv);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"%s: Failed power on\\n\", __func__);\n\t\tgoto exit;\n\t}\n\n\tif (!macpower)\n\t\trtl8xxxu_init_queue_reserved_page(priv);\n\n\tret = rtl8xxxu_init_queue_priority(priv);\n\tdev_dbg(dev, \"%s: init_queue_priority %i\\n\", __func__, ret);\n\tif (ret)\n\t\tgoto exit;\n\n\t/*\n\t * Set RX page boundary\n\t */\n\trtl8xxxu_write16(priv, REG_TRXFF_BNDY + 2, fops->trxff_boundary);\n\n\tret = rtl8xxxu_download_firmware(priv);\n\tdev_dbg(dev, \"%s: download_firmware %i\\n\", __func__, ret);\n\tif (ret)\n\t\tgoto exit;\n\tret = rtl8xxxu_start_firmware(priv);\n\tdev_dbg(dev, \"%s: start_firmware %i\\n\", __func__, ret);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (fops->phy_init_antenna_selection)\n\t\tfops->phy_init_antenna_selection(priv);\n\n\tret = rtl8xxxu_init_mac(priv);\n\n\tdev_dbg(dev, \"%s: init_mac %i\\n\", __func__, ret);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = rtl8xxxu_init_phy_bb(priv);\n\tdev_dbg(dev, \"%s: init_phy_bb %i\\n\", __func__, ret);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = fops->init_phy_rf(priv);\n\tif (ret)\n\t\tgoto exit;\n\n\t/* RFSW Control - clear bit 14 ?? */\n\tif (priv->rtl_chip != RTL8723B && priv->rtl_chip != RTL8192E)\n\t\trtl8xxxu_write32(priv, REG_FPGA0_TX_INFO, 0x00000003);\n\n\tval32 = FPGA0_RF_TRSW | FPGA0_RF_TRSWB | FPGA0_RF_ANTSW |\n\t\tFPGA0_RF_ANTSWB |\n\t\t((FPGA0_RF_ANTSW | FPGA0_RF_ANTSWB) << FPGA0_RF_BD_CTRL_SHIFT);\n\tif (!priv->no_pape) {\n\t\tval32 |= (FPGA0_RF_PAPE |\n\t\t\t  (FPGA0_RF_PAPE << FPGA0_RF_BD_CTRL_SHIFT));\n\t}\n\trtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_SW_CTRL, val32);\n\n\t/* 0x860[6:5]= 00 - why? - this sets antenna B */\n\tif (priv->rtl_chip != RTL8192E)\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_RF_INT_OE, 0x66f60210);\n\n\tif (!macpower) {\n\t\t/*\n\t\t * Set TX buffer boundary\n\t\t */\n\t\tval8 = fops->total_page_num + 1;\n\n\t\trtl8xxxu_write8(priv, REG_TXPKTBUF_BCNQ_BDNY, val8);\n\t\trtl8xxxu_write8(priv, REG_TXPKTBUF_MGQ_BDNY, val8);\n\t\trtl8xxxu_write8(priv, REG_TXPKTBUF_WMAC_LBK_BF_HD, val8);\n\t\trtl8xxxu_write8(priv, REG_TRXFF_BNDY, val8);\n\t\trtl8xxxu_write8(priv, REG_TDECTRL + 1, val8);\n\t}\n\n\t/*\n\t * The vendor drivers set PBP for all devices, except 8192e.\n\t * There is no explanation for this in any of the sources.\n\t */\n\tval8 = (fops->pbp_rx << PBP_PAGE_SIZE_RX_SHIFT) |\n\t\t(fops->pbp_tx << PBP_PAGE_SIZE_TX_SHIFT);\n\tif (priv->rtl_chip != RTL8192E)\n\t\trtl8xxxu_write8(priv, REG_PBP, val8);\n\n\tdev_dbg(dev, \"%s: macpower %i\\n\", __func__, macpower);\n\tif (!macpower) {\n\t\tret = fops->llt_init(priv);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"%s: LLT table init failed\\n\", __func__);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/*\n\t\t * Chip specific quirks\n\t\t */\n\t\tfops->usb_quirks(priv);\n\n\t\t/*\n\t\t * Enable TX report and TX report timer for 8723bu/8188eu/...\n\t\t */\n\t\tif (fops->has_tx_report) {\n\t\t\tval8 = rtl8xxxu_read8(priv, REG_TX_REPORT_CTRL);\n\t\t\tval8 |= TX_REPORT_CTRL_TIMER_ENABLE;\n\t\t\trtl8xxxu_write8(priv, REG_TX_REPORT_CTRL, val8);\n\t\t\t/* Set MAX RPT MACID */\n\t\t\trtl8xxxu_write8(priv, REG_TX_REPORT_CTRL + 1, 0x02);\n\t\t\t/* TX report Timer. Unit: 32us */\n\t\t\trtl8xxxu_write16(priv, REG_TX_REPORT_TIME, 0xcdf0);\n\n\t\t\t/* tmp ps ? */\n\t\t\tval8 = rtl8xxxu_read8(priv, 0xa3);\n\t\t\tval8 &= 0xf8;\n\t\t\trtl8xxxu_write8(priv, 0xa3, val8);\n\t\t}\n\t}\n\n\t/*\n\t * Unit in 8 bytes, not obvious what it is used for\n\t */\n\trtl8xxxu_write8(priv, REG_RX_DRVINFO_SZ, 4);\n\n\tif (priv->rtl_chip == RTL8192E) {\n\t\trtl8xxxu_write32(priv, REG_HIMR0, 0x00);\n\t\trtl8xxxu_write32(priv, REG_HIMR1, 0x00);\n\t} else {\n\t\t/*\n\t\t * Enable all interrupts - not obvious USB needs to do this\n\t\t */\n\t\trtl8xxxu_write32(priv, REG_HISR, 0xffffffff);\n\t\trtl8xxxu_write32(priv, REG_HIMR, 0xffffffff);\n\t}\n\n\trtl8xxxu_set_mac(priv);\n\trtl8xxxu_set_linktype(priv, NL80211_IFTYPE_STATION);\n\n\t/*\n\t * Configure initial WMAC settings\n\t */\n\tval32 = RCR_ACCEPT_PHYS_MATCH | RCR_ACCEPT_MCAST | RCR_ACCEPT_BCAST |\n\t\tRCR_ACCEPT_MGMT_FRAME | RCR_HTC_LOC_CTRL |\n\t\tRCR_APPEND_PHYSTAT | RCR_APPEND_ICV | RCR_APPEND_MIC;\n\trtl8xxxu_write32(priv, REG_RCR, val32);\n\n\t/*\n\t * Accept all multicast\n\t */\n\trtl8xxxu_write32(priv, REG_MAR, 0xffffffff);\n\trtl8xxxu_write32(priv, REG_MAR + 4, 0xffffffff);\n\n\t/*\n\t * Init adaptive controls\n\t */\n\tval32 = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\n\tval32 &= ~RESPONSE_RATE_BITMAP_ALL;\n\tval32 |= RESPONSE_RATE_RRSR_CCK_ONLY_1M;\n\trtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, val32);\n\n\t/* CCK = 0x0a, OFDM = 0x10 */\n\trtl8xxxu_set_spec_sifs(priv, 0x10, 0x10);\n\trtl8xxxu_set_retry(priv, 0x30, 0x30);\n\trtl8xxxu_set_spec_sifs(priv, 0x0a, 0x10);\n\n\t/*\n\t * Init EDCA\n\t */\n\trtl8xxxu_write16(priv, REG_MAC_SPEC_SIFS, 0x100a);\n\n\t/* Set CCK SIFS */\n\trtl8xxxu_write16(priv, REG_SIFS_CCK, 0x100a);\n\n\t/* Set OFDM SIFS */\n\trtl8xxxu_write16(priv, REG_SIFS_OFDM, 0x100a);\n\n\t/* TXOP */\n\trtl8xxxu_write32(priv, REG_EDCA_BE_PARAM, 0x005ea42b);\n\trtl8xxxu_write32(priv, REG_EDCA_BK_PARAM, 0x0000a44f);\n\trtl8xxxu_write32(priv, REG_EDCA_VI_PARAM, 0x005ea324);\n\trtl8xxxu_write32(priv, REG_EDCA_VO_PARAM, 0x002fa226);\n\n\t/* Set data auto rate fallback retry count */\n\trtl8xxxu_write32(priv, REG_DARFRC, 0x00000000);\n\trtl8xxxu_write32(priv, REG_DARFRC + 4, 0x10080404);\n\trtl8xxxu_write32(priv, REG_RARFRC, 0x04030201);\n\trtl8xxxu_write32(priv, REG_RARFRC + 4, 0x08070605);\n\n\tval8 = rtl8xxxu_read8(priv, REG_FWHW_TXQ_CTRL);\n\tval8 |= FWHW_TXQ_CTRL_AMPDU_RETRY;\n\trtl8xxxu_write8(priv, REG_FWHW_TXQ_CTRL, val8);\n\n\t/*  Set ACK timeout */\n\trtl8xxxu_write8(priv, REG_ACKTO, 0x40);\n\n\t/*\n\t * Initialize beacon parameters\n\t */\n\tval16 = BEACON_DISABLE_TSF_UPDATE | (BEACON_DISABLE_TSF_UPDATE << 8);\n\trtl8xxxu_write16(priv, REG_BEACON_CTRL, val16);\n\trtl8xxxu_write16(priv, REG_TBTT_PROHIBIT, 0x6404);\n\trtl8xxxu_write8(priv, REG_DRIVER_EARLY_INT, DRIVER_EARLY_INT_TIME);\n\trtl8xxxu_write8(priv, REG_BEACON_DMA_TIME, BEACON_DMA_ATIME_INT_TIME);\n\trtl8xxxu_write16(priv, REG_BEACON_TCFG, 0x660F);\n\n\t/*\n\t * Initialize burst parameters\n\t */\n\tif (priv->rtl_chip == RTL8723B) {\n\t\t/*\n\t\t * For USB high speed set 512B packets\n\t\t */\n\t\tval8 = rtl8xxxu_read8(priv, REG_RXDMA_PRO_8723B);\n\t\tval8 &= ~(BIT(4) | BIT(5));\n\t\tval8 |= BIT(4);\n\t\tval8 |= BIT(1) | BIT(2) | BIT(3);\n\t\trtl8xxxu_write8(priv, REG_RXDMA_PRO_8723B, val8);\n\n\t\t/*\n\t\t * For USB high speed set 512B packets\n\t\t */\n\t\tval8 = rtl8xxxu_read8(priv, REG_HT_SINGLE_AMPDU_8723B);\n\t\tval8 |= BIT(7);\n\t\trtl8xxxu_write8(priv, REG_HT_SINGLE_AMPDU_8723B, val8);\n\n\t\trtl8xxxu_write16(priv, REG_MAX_AGGR_NUM, 0x0c14);\n\t\trtl8xxxu_write8(priv, REG_AMPDU_MAX_TIME_8723B, 0x5e);\n\t\trtl8xxxu_write32(priv, REG_AGGLEN_LMT, 0xffffffff);\n\t\trtl8xxxu_write8(priv, REG_RX_PKT_LIMIT, 0x18);\n\t\trtl8xxxu_write8(priv, REG_PIFS, 0x00);\n\t\trtl8xxxu_write8(priv, REG_USTIME_TSF_8723B, 0x50);\n\t\trtl8xxxu_write8(priv, REG_USTIME_EDCA, 0x50);\n\n\t\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL);\n\t\tval8 |= BIT(5) | BIT(6);\n\t\trtl8xxxu_write8(priv, REG_RSV_CTRL, val8);\n\t}\n\n\tif (fops->init_aggregation)\n\t\tfops->init_aggregation(priv);\n\n\t/*\n\t * Enable CCK and OFDM block\n\t */\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\tval32 |= (FPGA_RF_MODE_CCK | FPGA_RF_MODE_OFDM);\n\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t/*\n\t * Invalidate all CAM entries - bit 30 is undocumented\n\t */\n\trtl8xxxu_write32(priv, REG_CAM_CMD, CAM_CMD_POLLING | BIT(30));\n\n\t/*\n\t * Start out with default power levels for channel 6, 20MHz\n\t */\n\tfops->set_tx_power(priv, 1, false);\n\n\t/* Let the 8051 take control of antenna setting */\n\tif (priv->rtl_chip != RTL8192E) {\n\t\tval8 = rtl8xxxu_read8(priv, REG_LEDCFG2);\n\t\tval8 |= LEDCFG2_DPDT_SELECT;\n\t\trtl8xxxu_write8(priv, REG_LEDCFG2, val8);\n\t}\n\n\trtl8xxxu_write8(priv, REG_HWSEQ_CTRL, 0xff);\n\n\t/* Disable BAR - not sure if this has any effect on USB */\n\trtl8xxxu_write32(priv, REG_BAR_MODE_CTRL, 0x0201ffff);\n\n\trtl8xxxu_write16(priv, REG_FAST_EDCA_CTRL, 0);\n\n\tif (fops->init_statistics)\n\t\tfops->init_statistics(priv);\n\n\tif (priv->rtl_chip == RTL8192E) {\n\t\t/*\n\t\t * 0x4c6[3] 1: RTS BW = Data BW\n\t\t * 0: RTS BW depends on CCA / secondary CCA result.\n\t\t */\n\t\tval8 = rtl8xxxu_read8(priv, REG_QUEUE_CTRL);\n\t\tval8 &= ~BIT(3);\n\t\trtl8xxxu_write8(priv, REG_QUEUE_CTRL, val8);\n\t\t/*\n\t\t * Reset USB mode switch setting\n\t\t */\n\t\trtl8xxxu_write8(priv, REG_ACLK_MON, 0x00);\n\t}\n\n\trtl8723a_phy_lc_calibrate(priv);\n\n\tfops->phy_iq_calibrate(priv);\n\n\t/*\n\t * This should enable thermal meter\n\t */\n\tif (fops->gen2_thermal_meter)\n\t\trtl8xxxu_write_rfreg(priv,\n\t\t\t\t     RF_A, RF6052_REG_T_METER_8723B, 0x37cf8);\n\telse\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_T_METER, 0x60);\n\n\t/* Set NAV_UPPER to 30000us */\n\tval8 = ((30000 + NAV_UPPER_UNIT - 1) / NAV_UPPER_UNIT);\n\trtl8xxxu_write8(priv, REG_NAV_UPPER, val8);\n\n\tif (priv->rtl_chip == RTL8723A) {\n\t\t/*\n\t\t * 2011/03/09 MH debug only, UMC-B cut pass 2500 S5 test,\n\t\t * but we need to find root cause.\n\t\t * This is 8723au only.\n\t\t */\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tif ((val32 & 0xff000000) != 0x83000000) {\n\t\t\tval32 |= FPGA_RF_MODE_CCK;\n\t\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\t\t}\n\t} else if (priv->rtl_chip == RTL8192E) {\n\t\trtl8xxxu_write8(priv, REG_USB_HRPWM, 0x00);\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_FWHW_TXQ_CTRL);\n\tval32 |= FWHW_TXQ_CTRL_XMIT_MGMT_ACK;\n\t/* ack for xmit mgmt frames. */\n\trtl8xxxu_write32(priv, REG_FWHW_TXQ_CTRL, val32);\n\n\tif (priv->rtl_chip == RTL8192E) {\n\t\t/*\n\t\t * Fix LDPC rx hang issue.\n\t\t */\n\t\tval32 = rtl8xxxu_read32(priv, REG_AFE_MISC);\n\t\trtl8xxxu_write8(priv, REG_8192E_LDOV12_CTRL, 0x75);\n\t\tval32 &= 0xfff00fff;\n\t\tval32 |= 0x0007e000;\n\t\trtl8xxxu_write32(priv, REG_AFE_MISC, val32);\n\t}\nexit:\n\treturn ret;\n}\n\nstatic void rtl8xxxu_cam_write(struct rtl8xxxu_priv *priv,\n\t\t\t       struct ieee80211_key_conf *key, const u8 *mac)\n{\n\tu32 cmd, val32, addr, ctrl;\n\tint j, i, tmp_debug;\n\n\ttmp_debug = rtl8xxxu_debug;\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_KEY)\n\t\trtl8xxxu_debug |= RTL8XXXU_DEBUG_REG_WRITE;\n\n\t/*\n\t * This is a bit of a hack - the lower bits of the cipher\n\t * suite selector happens to match the cipher index in the CAM\n\t */\n\taddr = key->keyidx << CAM_CMD_KEY_SHIFT;\n\tctrl = (key->cipher & 0x0f) << 2 | key->keyidx | CAM_WRITE_VALID;\n\n\tfor (j = 5; j >= 0; j--) {\n\t\tswitch (j) {\n\t\tcase 0:\n\t\t\tval32 = ctrl | (mac[0] << 16) | (mac[1] << 24);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tval32 = mac[2] | (mac[3] << 8) |\n\t\t\t\t(mac[4] << 16) | (mac[5] << 24);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ti = (j - 2) << 2;\n\t\t\tval32 = key->key[i] | (key->key[i + 1] << 8) |\n\t\t\t\tkey->key[i + 2] << 16 | key->key[i + 3] << 24;\n\t\t\tbreak;\n\t\t}\n\n\t\trtl8xxxu_write32(priv, REG_CAM_WRITE, val32);\n\t\tcmd = CAM_CMD_POLLING | CAM_CMD_WRITE | (addr + j);\n\t\trtl8xxxu_write32(priv, REG_CAM_CMD, cmd);\n\t\tudelay(100);\n\t}\n\n\trtl8xxxu_debug = tmp_debug;\n}\n\nstatic void rtl8xxxu_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif, const u8 *mac)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tu8 val8;\n\n\tval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\n\tval8 |= BEACON_DISABLE_TSF_UPDATE;\n\trtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\n}\n\nstatic void rtl8xxxu_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tu8 val8;\n\n\tval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\n\tval8 &= ~BEACON_DISABLE_TSF_UPDATE;\n\trtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\n}\n\nvoid rtl8xxxu_update_rate_mask(struct rtl8xxxu_priv *priv, u32 ramask, int sgi)\n{\n\tstruct h2c_cmd h2c;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\n\th2c.ramask.cmd = H2C_SET_RATE_MASK;\n\th2c.ramask.mask_lo = cpu_to_le16(ramask & 0xffff);\n\th2c.ramask.mask_hi = cpu_to_le16(ramask >> 16);\n\n\th2c.ramask.arg = 0x80;\n\tif (sgi)\n\t\th2c.ramask.arg |= 0x20;\n\n\tdev_dbg(&priv->udev->dev, \"%s: rate mask %08x, arg %02x, size %zi\\n\",\n\t\t__func__, ramask, h2c.ramask.arg, sizeof(h2c.ramask));\n\trtl8xxxu_gen1_h2c_cmd(priv, &h2c, sizeof(h2c.ramask));\n}\n\nvoid rtl8xxxu_gen2_update_rate_mask(struct rtl8xxxu_priv *priv,\n\t\t\t\t    u32 ramask, int sgi)\n{\n\tstruct h2c_cmd h2c;\n\tu8 bw = 0;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\n\th2c.b_macid_cfg.cmd = H2C_8723B_MACID_CFG_RAID;\n\th2c.b_macid_cfg.ramask0 = ramask & 0xff;\n\th2c.b_macid_cfg.ramask1 = (ramask >> 8) & 0xff;\n\th2c.b_macid_cfg.ramask2 = (ramask >> 16) & 0xff;\n\th2c.b_macid_cfg.ramask3 = (ramask >> 24) & 0xff;\n\n\th2c.ramask.arg = 0x80;\n\th2c.b_macid_cfg.data1 = 0;\n\tif (sgi)\n\t\th2c.b_macid_cfg.data1 |= BIT(7);\n\n\th2c.b_macid_cfg.data2 = bw;\n\n\tdev_dbg(&priv->udev->dev, \"%s: rate mask %08x, arg %02x, size %zi\\n\",\n\t\t__func__, ramask, h2c.ramask.arg, sizeof(h2c.b_macid_cfg));\n\trtl8xxxu_gen2_h2c_cmd(priv, &h2c, sizeof(h2c.b_macid_cfg));\n}\n\nvoid rtl8xxxu_gen1_report_connect(struct rtl8xxxu_priv *priv,\n\t\t\t\t  u8 macid, bool connect)\n{\n\tstruct h2c_cmd h2c;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\n\th2c.joinbss.cmd = H2C_JOIN_BSS_REPORT;\n\n\tif (connect)\n\t\th2c.joinbss.data = H2C_JOIN_BSS_CONNECT;\n\telse\n\t\th2c.joinbss.data = H2C_JOIN_BSS_DISCONNECT;\n\n\trtl8xxxu_gen1_h2c_cmd(priv, &h2c, sizeof(h2c.joinbss));\n}\n\nvoid rtl8xxxu_gen2_report_connect(struct rtl8xxxu_priv *priv,\n\t\t\t\t  u8 macid, bool connect)\n{\n#ifdef RTL8XXXU_GEN2_REPORT_CONNECT\n\t/*\n\t * Barry Day reports this causes issues with 8192eu and 8723bu\n\t * devices reconnecting. The reason for this is unclear, but\n\t * until it is better understood, leave the code in place but\n\t * disabled, so it is not lost.\n\t */\n\tstruct h2c_cmd h2c;\n\n\tmemset(&h2c, 0, sizeof(struct h2c_cmd));\n\n\th2c.media_status_rpt.cmd = H2C_8723B_MEDIA_STATUS_RPT;\n\tif (connect)\n\t\th2c.media_status_rpt.parm |= BIT(0);\n\telse\n\t\th2c.media_status_rpt.parm &= ~BIT(0);\n\n\trtl8xxxu_gen2_h2c_cmd(priv, &h2c, sizeof(h2c.media_status_rpt));\n#endif\n}\n\nvoid rtl8xxxu_gen1_init_aggregation(struct rtl8xxxu_priv *priv)\n{\n\tu8 agg_ctrl, usb_spec, page_thresh, timeout;\n\n\tusb_spec = rtl8xxxu_read8(priv, REG_USB_SPECIAL_OPTION);\n\tusb_spec &= ~USB_SPEC_USB_AGG_ENABLE;\n\trtl8xxxu_write8(priv, REG_USB_SPECIAL_OPTION, usb_spec);\n\n\tagg_ctrl = rtl8xxxu_read8(priv, REG_TRXDMA_CTRL);\n\tagg_ctrl &= ~TRXDMA_CTRL_RXDMA_AGG_EN;\n\n\tif (!rtl8xxxu_dma_aggregation) {\n\t\trtl8xxxu_write8(priv, REG_TRXDMA_CTRL, agg_ctrl);\n\t\treturn;\n\t}\n\n\tagg_ctrl |= TRXDMA_CTRL_RXDMA_AGG_EN;\n\trtl8xxxu_write8(priv, REG_TRXDMA_CTRL, agg_ctrl);\n\n\t/*\n\t * The number of packets we can take looks to be buffer size / 512\n\t * which matches the 512 byte rounding we have to do when de-muxing\n\t * the packets.\n\t *\n\t * Sample numbers from the vendor driver:\n\t * USB High-Speed mode values:\n\t *   RxAggBlockCount = 8 : 512 byte unit\n\t *   RxAggBlockTimeout = 6\n\t *   RxAggPageCount = 48 : 128 byte unit\n\t *   RxAggPageTimeout = 4 or 6 (absolute time 34ms/(2^6))\n\t */\n\n\tpage_thresh = (priv->fops->rx_agg_buf_size / 512);\n\tif (rtl8xxxu_dma_agg_pages >= 0) {\n\t\tif (rtl8xxxu_dma_agg_pages <= page_thresh)\n\t\t\ttimeout = page_thresh;\n\t\telse if (rtl8xxxu_dma_agg_pages <= 6)\n\t\t\tdev_err(&priv->udev->dev,\n\t\t\t\t\"%s: dma_agg_pages=%i too small, minimum is 6\\n\",\n\t\t\t\t__func__, rtl8xxxu_dma_agg_pages);\n\t\telse\n\t\t\tdev_err(&priv->udev->dev,\n\t\t\t\t\"%s: dma_agg_pages=%i larger than limit %i\\n\",\n\t\t\t\t__func__, rtl8xxxu_dma_agg_pages, page_thresh);\n\t}\n\trtl8xxxu_write8(priv, REG_RXDMA_AGG_PG_TH, page_thresh);\n\t/*\n\t * REG_RXDMA_AGG_PG_TH + 1 seems to be the timeout register on\n\t * gen2 chips and rtl8188eu. The rtl8723au seems unhappy if we\n\t * don't set it, so better set both.\n\t */\n\ttimeout = 4;\n\n\tif (rtl8xxxu_dma_agg_timeout >= 0) {\n\t\tif (rtl8xxxu_dma_agg_timeout <= 127)\n\t\t\ttimeout = rtl8xxxu_dma_agg_timeout;\n\t\telse\n\t\t\tdev_err(&priv->udev->dev,\n\t\t\t\t\"%s: Invalid dma_agg_timeout: %i\\n\",\n\t\t\t\t__func__, rtl8xxxu_dma_agg_timeout);\n\t}\n\n\trtl8xxxu_write8(priv, REG_RXDMA_AGG_PG_TH + 1, timeout);\n\trtl8xxxu_write8(priv, REG_USB_DMA_AGG_TO, timeout);\n\tpriv->rx_buf_aggregation = 1;\n}\n\nstatic void rtl8xxxu_set_basic_rates(struct rtl8xxxu_priv *priv, u32 rate_cfg)\n{\n\tu32 val32;\n\tu8 rate_idx = 0;\n\n\trate_cfg &= RESPONSE_RATE_BITMAP_ALL;\n\n\tval32 = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\n\tval32 &= ~RESPONSE_RATE_BITMAP_ALL;\n\tval32 |= rate_cfg;\n\trtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, val32);\n\n\tdev_dbg(&priv->udev->dev, \"%s: rates %08x\\n\", __func__,\trate_cfg);\n\n\twhile (rate_cfg) {\n\t\trate_cfg = (rate_cfg >> 1);\n\t\trate_idx++;\n\t}\n\trtl8xxxu_write8(priv, REG_INIRTS_RATE_SEL, rate_idx);\n}\n\nstatic void\nrtl8xxxu_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_bss_conf *bss_conf, u32 changed)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tstruct ieee80211_sta *sta;\n\tu32 val32;\n\tu8 val8;\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tdev_dbg(dev, \"Changed ASSOC: %i!\\n\", bss_conf->assoc);\n\n\t\trtl8xxxu_set_linktype(priv, vif->type);\n\n\t\tif (bss_conf->assoc) {\n\t\t\tu32 ramask;\n\t\t\tint sgi = 0;\n\n\t\t\trcu_read_lock();\n\t\t\tsta = ieee80211_find_sta(vif, bss_conf->bssid);\n\t\t\tif (!sta) {\n\t\t\t\tdev_info(dev, \"%s: ASSOC no sta found\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (sta->ht_cap.ht_supported)\n\t\t\t\tdev_info(dev, \"%s: HT supported\\n\", __func__);\n\t\t\tif (sta->vht_cap.vht_supported)\n\t\t\t\tdev_info(dev, \"%s: VHT supported\\n\", __func__);\n\n\t\t\t/* TODO: Set bits 28-31 for rate adaptive id */\n\t\t\tramask = (sta->supp_rates[0] & 0xfff) |\n\t\t\t\tsta->ht_cap.mcs.rx_mask[0] << 12 |\n\t\t\t\tsta->ht_cap.mcs.rx_mask[1] << 20;\n\t\t\tif (sta->ht_cap.cap &\n\t\t\t    (IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20))\n\t\t\t\tsgi = 1;\n\t\t\trcu_read_unlock();\n\n\t\t\tpriv->fops->update_rate_mask(priv, ramask, sgi);\n\n\t\t\trtl8xxxu_write8(priv, REG_BCN_MAX_ERR, 0xff);\n\n\t\t\trtl8xxxu_stop_tx_beacon(priv);\n\n\t\t\t/* joinbss sequence */\n\t\t\trtl8xxxu_write16(priv, REG_BCN_PSR_RPT,\n\t\t\t\t\t 0xc000 | bss_conf->aid);\n\n\t\t\tpriv->fops->report_connect(priv, 0, true);\n\t\t} else {\n\t\t\tval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\n\t\t\tval8 |= BEACON_DISABLE_TSF_UPDATE;\n\t\t\trtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\n\n\t\t\tpriv->fops->report_connect(priv, 0, false);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tdev_dbg(dev, \"Changed ERP_PREAMBLE: Use short preamble %i\\n\",\n\t\t\tbss_conf->use_short_preamble);\n\t\tval32 = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\n\t\tif (bss_conf->use_short_preamble)\n\t\t\tval32 |= RSR_ACK_SHORT_PREAMBLE;\n\t\telse\n\t\t\tval32 &= ~RSR_ACK_SHORT_PREAMBLE;\n\t\trtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, val32);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tdev_dbg(dev, \"Changed ERP_SLOT: short_slot_time %i\\n\",\n\t\t\tbss_conf->use_short_slot);\n\n\t\tif (bss_conf->use_short_slot)\n\t\t\tval8 = 9;\n\t\telse\n\t\t\tval8 = 20;\n\t\trtl8xxxu_write8(priv, REG_SLOT, val8);\n\t}\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tdev_dbg(dev, \"Changed BSSID!\\n\");\n\t\trtl8xxxu_set_bssid(priv, bss_conf->bssid);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\tdev_dbg(dev, \"Changed BASIC_RATES!\\n\");\n\t\trtl8xxxu_set_basic_rates(priv, bss_conf->basic_rates);\n\t}\nerror:\n\treturn;\n}\n\nstatic u32 rtl8xxxu_80211_to_rtl_queue(u32 queue)\n{\n\tu32 rtlqueue;\n\n\tswitch (queue) {\n\tcase IEEE80211_AC_VO:\n\t\trtlqueue = TXDESC_QUEUE_VO;\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\trtlqueue = TXDESC_QUEUE_VI;\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\trtlqueue = TXDESC_QUEUE_BE;\n\t\tbreak;\n\tcase IEEE80211_AC_BK:\n\t\trtlqueue = TXDESC_QUEUE_BK;\n\t\tbreak;\n\tdefault:\n\t\trtlqueue = TXDESC_QUEUE_BE;\n\t}\n\n\treturn rtlqueue;\n}\n\nstatic u32 rtl8xxxu_queue_select(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tu32 queue;\n\n\tif (ieee80211_is_mgmt(hdr->frame_control))\n\t\tqueue = TXDESC_QUEUE_MGNT;\n\telse\n\t\tqueue = rtl8xxxu_80211_to_rtl_queue(skb_get_queue_mapping(skb));\n\n\treturn queue;\n}\n\n/*\n * Despite newer chips 8723b/8812/8821 having a larger TX descriptor\n * format. The descriptor checksum is still only calculated over the\n * initial 32 bytes of the descriptor!\n */\nstatic void rtl8xxxu_calc_tx_desc_csum(struct rtl8xxxu_txdesc32 *tx_desc)\n{\n\t__le16 *ptr = (__le16 *)tx_desc;\n\tu16 csum = 0;\n\tint i;\n\n\t/*\n\t * Clear csum field before calculation, as the csum field is\n\t * in the middle of the struct.\n\t */\n\ttx_desc->csum = cpu_to_le16(0);\n\n\tfor (i = 0; i < (sizeof(struct rtl8xxxu_txdesc32) / sizeof(u16)); i++)\n\t\tcsum = csum ^ le16_to_cpu(ptr[i]);\n\n\ttx_desc->csum |= cpu_to_le16(csum);\n}\n\nstatic void rtl8xxxu_free_tx_resources(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8xxxu_tx_urb *tx_urb, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->tx_urb_lock, flags);\n\tlist_for_each_entry_safe(tx_urb, tmp, &priv->tx_urb_free_list, list) {\n\t\tlist_del(&tx_urb->list);\n\t\tpriv->tx_urb_free_count--;\n\t\tusb_free_urb(&tx_urb->urb);\n\t}\n\tspin_unlock_irqrestore(&priv->tx_urb_lock, flags);\n}\n\nstatic struct rtl8xxxu_tx_urb *\nrtl8xxxu_alloc_tx_urb(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8xxxu_tx_urb *tx_urb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->tx_urb_lock, flags);\n\ttx_urb = list_first_entry_or_null(&priv->tx_urb_free_list,\n\t\t\t\t\t  struct rtl8xxxu_tx_urb, list);\n\tif (tx_urb) {\n\t\tlist_del(&tx_urb->list);\n\t\tpriv->tx_urb_free_count--;\n\t\tif (priv->tx_urb_free_count < RTL8XXXU_TX_URB_LOW_WATER &&\n\t\t    !priv->tx_stopped) {\n\t\t\tpriv->tx_stopped = true;\n\t\t\tieee80211_stop_queues(priv->hw);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&priv->tx_urb_lock, flags);\n\n\treturn tx_urb;\n}\n\nstatic void rtl8xxxu_free_tx_urb(struct rtl8xxxu_priv *priv,\n\t\t\t\t struct rtl8xxxu_tx_urb *tx_urb)\n{\n\tunsigned long flags;\n\n\tINIT_LIST_HEAD(&tx_urb->list);\n\n\tspin_lock_irqsave(&priv->tx_urb_lock, flags);\n\n\tlist_add(&tx_urb->list, &priv->tx_urb_free_list);\n\tpriv->tx_urb_free_count++;\n\tif (priv->tx_urb_free_count > RTL8XXXU_TX_URB_HIGH_WATER &&\n\t    priv->tx_stopped) {\n\t\tpriv->tx_stopped = false;\n\t\tieee80211_wake_queues(priv->hw);\n\t}\n\n\tspin_unlock_irqrestore(&priv->tx_urb_lock, flags);\n}\n\nstatic void rtl8xxxu_tx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)urb->context;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ieee80211_hw *hw;\n\tstruct rtl8xxxu_priv *priv;\n\tstruct rtl8xxxu_tx_urb *tx_urb =\n\t\tcontainer_of(urb, struct rtl8xxxu_tx_urb, urb);\n\n\ttx_info = IEEE80211_SKB_CB(skb);\n\thw = tx_info->rate_driver_data[0];\n\tpriv = hw->priv;\n\n\tskb_pull(skb, priv->fops->tx_desc_size);\n\n\tieee80211_tx_info_clear_status(tx_info);\n\ttx_info->status.rates[0].idx = -1;\n\ttx_info->status.rates[0].count = 0;\n\n\tif (!urb->status)\n\t\ttx_info->flags |= IEEE80211_TX_STAT_ACK;\n\n\tieee80211_tx_status_irqsafe(hw, skb);\n\n\trtl8xxxu_free_tx_urb(priv, tx_urb);\n}\n\nstatic void rtl8xxxu_dump_action(struct device *dev,\n\t\t\t\t struct ieee80211_hdr *hdr)\n{\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)hdr;\n\tu16 cap, timeout;\n\n\tif (!(rtl8xxxu_debug & RTL8XXXU_DEBUG_ACTION))\n\t\treturn;\n\n\tswitch (mgmt->u.action.u.addba_resp.action_code) {\n\tcase WLAN_ACTION_ADDBA_RESP:\n\t\tcap = le16_to_cpu(mgmt->u.action.u.addba_resp.capab);\n\t\ttimeout = le16_to_cpu(mgmt->u.action.u.addba_resp.timeout);\n\t\tdev_info(dev, \"WLAN_ACTION_ADDBA_RESP: \"\n\t\t\t \"timeout %i, tid %02x, buf_size %02x, policy %02x, \"\n\t\t\t \"status %02x\\n\",\n\t\t\t timeout,\n\t\t\t (cap & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2,\n\t\t\t (cap & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6,\n\t\t\t (cap >> 1) & 0x1,\n\t\t\t le16_to_cpu(mgmt->u.action.u.addba_resp.status));\n\t\tbreak;\n\tcase WLAN_ACTION_ADDBA_REQ:\n\t\tcap = le16_to_cpu(mgmt->u.action.u.addba_req.capab);\n\t\ttimeout = le16_to_cpu(mgmt->u.action.u.addba_req.timeout);\n\t\tdev_info(dev, \"WLAN_ACTION_ADDBA_REQ: \"\n\t\t\t \"timeout %i, tid %02x, buf_size %02x, policy %02x\\n\",\n\t\t\t timeout,\n\t\t\t (cap & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2,\n\t\t\t (cap & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6,\n\t\t\t (cap >> 1) & 0x1);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(dev, \"action frame %02x\\n\",\n\t\t\t mgmt->u.action.u.addba_resp.action_code);\n\t\tbreak;\n\t}\n}\n\n/*\n * Fill in v1 (gen1) specific TX descriptor bits.\n * This format is used on 8188cu/8192cu/8723au\n */\nvoid\nrtl8xxxu_fill_txdesc_v1(struct ieee80211_hw *hw, struct ieee80211_hdr *hdr,\n\t\t\tstruct ieee80211_tx_info *tx_info,\n\t\t\tstruct rtl8xxxu_txdesc32 *tx_desc, bool sgi,\n\t\t\tbool short_preamble, bool ampdu_enable, u32 rts_rate)\n{\n\tstruct ieee80211_rate *tx_rate = ieee80211_get_tx_rate(hw, tx_info);\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tu32 rate;\n\tu16 rate_flags = tx_info->control.rates[0].flags;\n\tu16 seq_number;\n\n\tif (rate_flags & IEEE80211_TX_RC_MCS &&\n\t    !ieee80211_is_mgmt(hdr->frame_control))\n\t\trate = tx_info->control.rates[0].idx + DESC_RATE_MCS0;\n\telse\n\t\trate = tx_rate->hw_value;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_TX)\n\t\tdev_info(dev, \"%s: TX rate: %d, pkt size %d\\n\",\n\t\t\t __func__, rate, cpu_to_le16(tx_desc->pkt_size));\n\n\tseq_number = IEEE80211_SEQ_TO_SN(le16_to_cpu(hdr->seq_ctrl));\n\n\ttx_desc->txdw5 = cpu_to_le32(rate);\n\n\tif (ieee80211_is_data(hdr->frame_control))\n\t\ttx_desc->txdw5 |= cpu_to_le32(0x0001ff00);\n\n\ttx_desc->txdw3 = cpu_to_le32((u32)seq_number << TXDESC32_SEQ_SHIFT);\n\n\tif (ampdu_enable)\n\t\ttx_desc->txdw1 |= cpu_to_le32(TXDESC32_AGG_ENABLE);\n\telse\n\t\ttx_desc->txdw1 |= cpu_to_le32(TXDESC32_AGG_BREAK);\n\n\tif (ieee80211_is_mgmt(hdr->frame_control)) {\n\t\ttx_desc->txdw5 = cpu_to_le32(rate);\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_USE_DRIVER_RATE);\n\t\ttx_desc->txdw5 |= cpu_to_le32(6 << TXDESC32_RETRY_LIMIT_SHIFT);\n\t\ttx_desc->txdw5 |= cpu_to_le32(TXDESC32_RETRY_LIMIT_ENABLE);\n\t}\n\n\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_QOS);\n\n\tif (short_preamble)\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_SHORT_PREAMBLE);\n\n\tif (sgi)\n\t\ttx_desc->txdw5 |= cpu_to_le32(TXDESC32_SHORT_GI);\n\n\t/*\n\t * rts_rate is zero if RTS/CTS or CTS to SELF are not enabled\n\t */\n\ttx_desc->txdw4 |= cpu_to_le32(rts_rate << TXDESC32_RTS_RATE_SHIFT);\n\tif (rate_flags & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_RTS_CTS_ENABLE);\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_HW_RTS_ENABLE);\n\t} else if (rate_flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_CTS_SELF_ENABLE);\n\t\ttx_desc->txdw4 |= cpu_to_le32(TXDESC32_HW_RTS_ENABLE);\n\t}\n}\n\n/*\n * Fill in v2 (gen2) specific TX descriptor bits.\n * This format is used on 8192eu/8723bu\n */\nvoid\nrtl8xxxu_fill_txdesc_v2(struct ieee80211_hw *hw, struct ieee80211_hdr *hdr,\n\t\t\tstruct ieee80211_tx_info *tx_info,\n\t\t\tstruct rtl8xxxu_txdesc32 *tx_desc32, bool sgi,\n\t\t\tbool short_preamble, bool ampdu_enable, u32 rts_rate)\n{\n\tstruct ieee80211_rate *tx_rate = ieee80211_get_tx_rate(hw, tx_info);\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tstruct rtl8xxxu_txdesc40 *tx_desc40;\n\tu32 rate;\n\tu16 rate_flags = tx_info->control.rates[0].flags;\n\tu16 seq_number;\n\n\ttx_desc40 = (struct rtl8xxxu_txdesc40 *)tx_desc32;\n\n\tif (rate_flags & IEEE80211_TX_RC_MCS &&\n\t    !ieee80211_is_mgmt(hdr->frame_control))\n\t\trate = tx_info->control.rates[0].idx + DESC_RATE_MCS0;\n\telse\n\t\trate = tx_rate->hw_value;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_TX)\n\t\tdev_info(dev, \"%s: TX rate: %d, pkt size %d\\n\",\n\t\t\t __func__, rate, cpu_to_le16(tx_desc40->pkt_size));\n\n\tseq_number = IEEE80211_SEQ_TO_SN(le16_to_cpu(hdr->seq_ctrl));\n\n\ttx_desc40->txdw4 = cpu_to_le32(rate);\n\tif (ieee80211_is_data(hdr->frame_control)) {\n\t\ttx_desc40->txdw4 |= cpu_to_le32(0x1f <<\n\t\t\t\t\t\tTXDESC40_DATA_RATE_FB_SHIFT);\n\t}\n\n\ttx_desc40->txdw9 = cpu_to_le32((u32)seq_number << TXDESC40_SEQ_SHIFT);\n\n\tif (ampdu_enable)\n\t\ttx_desc40->txdw2 |= cpu_to_le32(TXDESC40_AGG_ENABLE);\n\telse\n\t\ttx_desc40->txdw2 |= cpu_to_le32(TXDESC40_AGG_BREAK);\n\n\tif (ieee80211_is_mgmt(hdr->frame_control)) {\n\t\ttx_desc40->txdw4 = cpu_to_le32(rate);\n\t\ttx_desc40->txdw3 |= cpu_to_le32(TXDESC40_USE_DRIVER_RATE);\n\t\ttx_desc40->txdw4 |=\n\t\t\tcpu_to_le32(6 << TXDESC40_RETRY_LIMIT_SHIFT);\n\t\ttx_desc40->txdw4 |= cpu_to_le32(TXDESC40_RETRY_LIMIT_ENABLE);\n\t}\n\n\tif (short_preamble)\n\t\ttx_desc40->txdw5 |= cpu_to_le32(TXDESC40_SHORT_PREAMBLE);\n\n\ttx_desc40->txdw4 |= cpu_to_le32(rts_rate << TXDESC40_RTS_RATE_SHIFT);\n\t/*\n\t * rts_rate is zero if RTS/CTS or CTS to SELF are not enabled\n\t */\n\tif (rate_flags & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\ttx_desc40->txdw3 |= cpu_to_le32(TXDESC40_RTS_CTS_ENABLE);\n\t\ttx_desc40->txdw3 |= cpu_to_le32(TXDESC40_HW_RTS_ENABLE);\n\t} else if (rate_flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\t/*\n\t\t * For some reason the vendor driver doesn't set\n\t\t * TXDESC40_HW_RTS_ENABLE for CTS to SELF\n\t\t */\n\t\ttx_desc40->txdw3 |= cpu_to_le32(TXDESC40_CTS_SELF_ENABLE);\n\t}\n}\n\nstatic void rtl8xxxu_tx(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_tx_control *control,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct rtl8xxxu_txdesc32 *tx_desc;\n\tstruct rtl8xxxu_tx_urb *tx_urb;\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct ieee80211_vif *vif = tx_info->control.vif;\n\tstruct device *dev = &priv->udev->dev;\n\tu32 queue, rts_rate;\n\tu16 pktlen = skb->len;\n\tu16 rate_flag = tx_info->control.rates[0].flags;\n\tint tx_desc_size = priv->fops->tx_desc_size;\n\tint ret;\n\tbool ampdu_enable, sgi = false, short_preamble = false;\n\n\tif (skb_headroom(skb) < tx_desc_size) {\n\t\tdev_warn(dev,\n\t\t\t \"%s: Not enough headroom (%i) for tx descriptor\\n\",\n\t\t\t __func__, skb_headroom(skb));\n\t\tgoto error;\n\t}\n\n\tif (unlikely(skb->len > (65535 - tx_desc_size))) {\n\t\tdev_warn(dev, \"%s: Trying to send over-sized skb (%i)\\n\",\n\t\t\t __func__, skb->len);\n\t\tgoto error;\n\t}\n\n\ttx_urb = rtl8xxxu_alloc_tx_urb(priv);\n\tif (!tx_urb) {\n\t\tdev_warn(dev, \"%s: Unable to allocate tx urb\\n\", __func__);\n\t\tgoto error;\n\t}\n\n\tif (ieee80211_is_action(hdr->frame_control))\n\t\trtl8xxxu_dump_action(dev, hdr);\n\n\ttx_info->rate_driver_data[0] = hw;\n\n\tif (control && control->sta)\n\t\tsta = control->sta;\n\n\ttx_desc = skb_push(skb, tx_desc_size);\n\n\tmemset(tx_desc, 0, tx_desc_size);\n\ttx_desc->pkt_size = cpu_to_le16(pktlen);\n\ttx_desc->pkt_offset = tx_desc_size;\n\n\ttx_desc->txdw0 =\n\t\tTXDESC_OWN | TXDESC_FIRST_SEGMENT | TXDESC_LAST_SEGMENT;\n\tif (is_multicast_ether_addr(ieee80211_get_DA(hdr)) ||\n\t    is_broadcast_ether_addr(ieee80211_get_DA(hdr)))\n\t\ttx_desc->txdw0 |= TXDESC_BROADMULTICAST;\n\n\tqueue = rtl8xxxu_queue_select(hw, skb);\n\ttx_desc->txdw1 = cpu_to_le32(queue << TXDESC_QUEUE_SHIFT);\n\n\tif (tx_info->control.hw_key) {\n\t\tswitch (tx_info->control.hw_key->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\ttx_desc->txdw1 |= cpu_to_le32(TXDESC_SEC_RC4);\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\ttx_desc->txdw1 |= cpu_to_le32(TXDESC_SEC_AES);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* (tx_info->flags & IEEE80211_TX_CTL_AMPDU) && */\n\tampdu_enable = false;\n\tif (ieee80211_is_data_qos(hdr->frame_control) && sta) {\n\t\tif (sta->ht_cap.ht_supported) {\n\t\t\tu32 ampdu, val32;\n\n\t\t\tampdu = (u32)sta->ht_cap.ampdu_density;\n\t\t\tval32 = ampdu << TXDESC_AMPDU_DENSITY_SHIFT;\n\t\t\ttx_desc->txdw2 |= cpu_to_le32(val32);\n\n\t\t\tampdu_enable = true;\n\t\t}\n\t}\n\n\tif (rate_flag & IEEE80211_TX_RC_SHORT_GI ||\n\t    (ieee80211_is_data_qos(hdr->frame_control) &&\n\t     sta && sta->ht_cap.cap &\n\t     (IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20)))\n\t\tsgi = true;\n\n\tif (rate_flag & IEEE80211_TX_RC_USE_SHORT_PREAMBLE ||\n\t    (sta && vif && vif->bss_conf.use_short_preamble))\n\t\tshort_preamble = true;\n\n\tif (rate_flag & IEEE80211_TX_RC_USE_RTS_CTS)\n\t\trts_rate = ieee80211_get_rts_cts_rate(hw, tx_info)->hw_value;\n\telse if (rate_flag & IEEE80211_TX_RC_USE_CTS_PROTECT)\n\t\trts_rate = ieee80211_get_rts_cts_rate(hw, tx_info)->hw_value;\n\telse\n\t\trts_rate = 0;\n\n\n\tpriv->fops->fill_txdesc(hw, hdr, tx_info, tx_desc, sgi, short_preamble,\n\t\t\t\tampdu_enable, rts_rate);\n\n\trtl8xxxu_calc_tx_desc_csum(tx_desc);\n\n\tusb_fill_bulk_urb(&tx_urb->urb, priv->udev, priv->pipe_out[queue],\n\t\t\t  skb->data, skb->len, rtl8xxxu_tx_complete, skb);\n\n\tusb_anchor_urb(&tx_urb->urb, &priv->tx_anchor);\n\tret = usb_submit_urb(&tx_urb->urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tusb_unanchor_urb(&tx_urb->urb);\n\t\trtl8xxxu_free_tx_urb(priv, tx_urb);\n\t\tgoto error;\n\t}\n\treturn;\nerror:\n\tdev_kfree_skb(skb);\n}\n\nstatic void rtl8xxxu_rx_parse_phystats(struct rtl8xxxu_priv *priv,\n\t\t\t\t       struct ieee80211_rx_status *rx_status,\n\t\t\t\t       struct rtl8723au_phy_stats *phy_stats,\n\t\t\t\t       u32 rxmcs)\n{\n\tif (phy_stats->sgi_en)\n\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\n\tif (rxmcs < DESC_RATE_6M) {\n\t\t/*\n\t\t * Handle PHY stats for CCK rates\n\t\t */\n\t\tu8 cck_agc_rpt = phy_stats->cck_agc_rpt_ofdm_cfosho_a;\n\n\t\tswitch (cck_agc_rpt & 0xc0) {\n\t\tcase 0xc0:\n\t\t\trx_status->signal = -46 - (cck_agc_rpt & 0x3e);\n\t\t\tbreak;\n\t\tcase 0x80:\n\t\t\trx_status->signal = -26 - (cck_agc_rpt & 0x3e);\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\t\trx_status->signal = -12 - (cck_agc_rpt & 0x3e);\n\t\t\tbreak;\n\t\tcase 0x00:\n\t\t\trx_status->signal = 16 - (cck_agc_rpt & 0x3e);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trx_status->signal =\n\t\t\t(phy_stats->cck_sig_qual_ofdm_pwdb_all >> 1) - 110;\n\t}\n}\n\nstatic void rtl8xxxu_free_rx_resources(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8xxxu_rx_urb *rx_urb, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->rx_urb_lock, flags);\n\n\tlist_for_each_entry_safe(rx_urb, tmp,\n\t\t\t\t &priv->rx_urb_pending_list, list) {\n\t\tlist_del(&rx_urb->list);\n\t\tpriv->rx_urb_pending_count--;\n\t\tusb_free_urb(&rx_urb->urb);\n\t}\n\n\tspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\n}\n\nstatic void rtl8xxxu_queue_rx_urb(struct rtl8xxxu_priv *priv,\n\t\t\t\t  struct rtl8xxxu_rx_urb *rx_urb)\n{\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tint pending = 0;\n\n\tspin_lock_irqsave(&priv->rx_urb_lock, flags);\n\n\tif (!priv->shutdown) {\n\t\tlist_add_tail(&rx_urb->list, &priv->rx_urb_pending_list);\n\t\tpriv->rx_urb_pending_count++;\n\t\tpending = priv->rx_urb_pending_count;\n\t} else {\n\t\tskb = (struct sk_buff *)rx_urb->urb.context;\n\t\tdev_kfree_skb(skb);\n\t\tusb_free_urb(&rx_urb->urb);\n\t}\n\n\tspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\n\n\tif (pending > RTL8XXXU_RX_URB_PENDING_WATER)\n\t\tschedule_work(&priv->rx_urb_wq);\n}\n\nstatic void rtl8xxxu_rx_urb_work(struct work_struct *work)\n{\n\tstruct rtl8xxxu_priv *priv;\n\tstruct rtl8xxxu_rx_urb *rx_urb, *tmp;\n\tstruct list_head local;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tint ret;\n\n\tpriv = container_of(work, struct rtl8xxxu_priv, rx_urb_wq);\n\tINIT_LIST_HEAD(&local);\n\n\tspin_lock_irqsave(&priv->rx_urb_lock, flags);\n\n\tlist_splice_init(&priv->rx_urb_pending_list, &local);\n\tpriv->rx_urb_pending_count = 0;\n\n\tspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\n\n\tlist_for_each_entry_safe(rx_urb, tmp, &local, list) {\n\t\tlist_del_init(&rx_urb->list);\n\t\tret = rtl8xxxu_submit_rx_urb(priv, rx_urb);\n\t\t/*\n\t\t * If out of memory or temporary error, put it back on the\n\t\t * queue and try again. Otherwise the device is dead/gone\n\t\t * and we should drop it.\n\t\t */\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -ENOMEM:\n\t\tcase -EAGAIN:\n\t\t\trtl8xxxu_queue_rx_urb(priv, rx_urb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"failed to requeue urb %i\\n\", ret);\n\t\t\tskb = (struct sk_buff *)rx_urb->urb.context;\n\t\t\tdev_kfree_skb(skb);\n\t\t\tusb_free_urb(&rx_urb->urb);\n\t\t}\n\t}\n}\n\nstatic void rtl8723bu_handle_c2h(struct rtl8xxxu_priv *priv,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct rtl8723bu_c2h *c2h = (struct rtl8723bu_c2h *)skb->data;\n\tstruct device *dev = &priv->udev->dev;\n\tint len;\n\n\tlen = skb->len - 2;\n\n\tdev_dbg(dev, \"C2H ID %02x seq %02x, len %02x source %02x\\n\",\n\t\tc2h->id, c2h->seq, len, c2h->bt_info.response_source);\n\n\tswitch(c2h->id) {\n\tcase C2H_8723B_BT_INFO:\n\t\tif (c2h->bt_info.response_source >\n\t\t    BT_INFO_SRC_8723B_BT_ACTIVE_SEND)\n\t\t\tdev_dbg(dev, \"C2H_BT_INFO WiFi only firmware\\n\");\n\t\telse\n\t\t\tdev_dbg(dev, \"C2H_BT_INFO BT/WiFi coexist firmware\\n\");\n\n\t\tif (c2h->bt_info.bt_has_reset)\n\t\t\tdev_dbg(dev, \"BT has been reset\\n\");\n\t\tif (c2h->bt_info.tx_rx_mask)\n\t\t\tdev_dbg(dev, \"BT TRx mask\\n\");\n\n\t\tbreak;\n\tcase C2H_8723B_BT_MP_INFO:\n\t\tdev_dbg(dev, \"C2H_MP_INFO ext ID %02x, status %02x\\n\",\n\t\t\tc2h->bt_mp_info.ext_id, c2h->bt_mp_info.status);\n\t\tbreak;\n\tcase C2H_8723B_RA_REPORT:\n\t\tdev_dbg(dev,\n\t\t\t\"C2H RA RPT: rate %02x, unk %i, macid %02x, noise %i\\n\",\n\t\t\tc2h->ra_report.rate, c2h->ra_report.dummy0_0,\n\t\t\tc2h->ra_report.macid, c2h->ra_report.noisy_state);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(dev, \"Unhandled C2H event %02x seq %02x\\n\",\n\t\t\t c2h->id, c2h->seq);\n\t\tprint_hex_dump(KERN_INFO, \"C2H content: \", DUMP_PREFIX_NONE,\n\t\t\t       16, 1, c2h->raw.payload, len, false);\n\t\tbreak;\n\t}\n}\n\nint rtl8xxxu_parse_rxdesc16(struct rtl8xxxu_priv *priv, struct sk_buff *skb)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct rtl8xxxu_rxdesc16 *rx_desc;\n\tstruct rtl8723au_phy_stats *phy_stats;\n\tstruct sk_buff *next_skb = NULL;\n\t__le32 *_rx_desc_le;\n\tu32 *_rx_desc;\n\tint drvinfo_sz, desc_shift;\n\tint i, pkt_cnt, pkt_len, urb_len, pkt_offset;\n\n\turb_len = skb->len;\n\tpkt_cnt = 0;\n\n\tdo {\n\t\trx_desc = (struct rtl8xxxu_rxdesc16 *)skb->data;\n\t\t_rx_desc_le = (__le32 *)skb->data;\n\t\t_rx_desc = (u32 *)skb->data;\n\n\t\tfor (i = 0;\n\t\t     i < (sizeof(struct rtl8xxxu_rxdesc16) / sizeof(u32)); i++)\n\t\t\t_rx_desc[i] = le32_to_cpu(_rx_desc_le[i]);\n\n\t\t/*\n\t\t * Only read pkt_cnt from the header if we're parsing the\n\t\t * first packet\n\t\t */\n\t\tif (!pkt_cnt)\n\t\t\tpkt_cnt = rx_desc->pkt_cnt;\n\t\tpkt_len = rx_desc->pktlen;\n\n\t\tdrvinfo_sz = rx_desc->drvinfo_sz * 8;\n\t\tdesc_shift = rx_desc->shift;\n\t\tpkt_offset = roundup(pkt_len + drvinfo_sz + desc_shift +\n\t\t\t\t     sizeof(struct rtl8xxxu_rxdesc16), 128);\n\n\t\t/*\n\t\t * Only clone the skb if there's enough data at the end to\n\t\t * at least cover the rx descriptor\n\t\t */\n\t\tif (pkt_cnt > 1 &&\n\t\t    urb_len > (pkt_offset + sizeof(struct rtl8xxxu_rxdesc16)))\n\t\t\tnext_skb = skb_clone(skb, GFP_ATOMIC);\n\n\t\trx_status = IEEE80211_SKB_RXCB(skb);\n\t\tmemset(rx_status, 0, sizeof(struct ieee80211_rx_status));\n\n\t\tskb_pull(skb, sizeof(struct rtl8xxxu_rxdesc16));\n\n\t\tphy_stats = (struct rtl8723au_phy_stats *)skb->data;\n\n\t\tskb_pull(skb, drvinfo_sz + desc_shift);\n\n\t\tskb_trim(skb, pkt_len);\n\n\t\tif (rx_desc->phy_stats)\n\t\t\trtl8xxxu_rx_parse_phystats(priv, rx_status, phy_stats,\n\t\t\t\t\t\t   rx_desc->rxmcs);\n\n\t\trx_status->mactime = rx_desc->tsfl;\n\t\trx_status->flag |= RX_FLAG_MACTIME_START;\n\n\t\tif (!rx_desc->swdec)\n\t\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\t\tif (rx_desc->crc32)\n\t\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\t\tif (rx_desc->bw)\n\t\t\trx_status->bw = RATE_INFO_BW_40;\n\n\t\tif (rx_desc->rxht) {\n\t\t\trx_status->encoding = RX_ENC_HT;\n\t\t\trx_status->rate_idx = rx_desc->rxmcs - DESC_RATE_MCS0;\n\t\t} else {\n\t\t\trx_status->rate_idx = rx_desc->rxmcs;\n\t\t}\n\n\t\trx_status->freq = hw->conf.chandef.chan->center_freq;\n\t\trx_status->band = hw->conf.chandef.chan->band;\n\n\t\tieee80211_rx_irqsafe(hw, skb);\n\n\t\tskb = next_skb;\n\t\tif (skb)\n\t\t\tskb_pull(next_skb, pkt_offset);\n\n\t\tpkt_cnt--;\n\t\turb_len -= pkt_offset;\n\t} while (skb && urb_len > 0 && pkt_cnt > 0);\n\n\treturn RX_TYPE_DATA_PKT;\n}\n\nint rtl8xxxu_parse_rxdesc24(struct rtl8xxxu_priv *priv, struct sk_buff *skb)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tstruct rtl8xxxu_rxdesc24 *rx_desc =\n\t\t(struct rtl8xxxu_rxdesc24 *)skb->data;\n\tstruct rtl8723au_phy_stats *phy_stats;\n\t__le32 *_rx_desc_le = (__le32 *)skb->data;\n\tu32 *_rx_desc = (u32 *)skb->data;\n\tint drvinfo_sz, desc_shift;\n\tint i;\n\n\tfor (i = 0; i < (sizeof(struct rtl8xxxu_rxdesc24) / sizeof(u32)); i++)\n\t\t_rx_desc[i] = le32_to_cpu(_rx_desc_le[i]);\n\n\tmemset(rx_status, 0, sizeof(struct ieee80211_rx_status));\n\n\tskb_pull(skb, sizeof(struct rtl8xxxu_rxdesc24));\n\n\tphy_stats = (struct rtl8723au_phy_stats *)skb->data;\n\n\tdrvinfo_sz = rx_desc->drvinfo_sz * 8;\n\tdesc_shift = rx_desc->shift;\n\tskb_pull(skb, drvinfo_sz + desc_shift);\n\n\tif (rx_desc->rpt_sel) {\n\t\tstruct device *dev = &priv->udev->dev;\n\t\tdev_dbg(dev, \"%s: C2H packet\\n\", __func__);\n\t\trtl8723bu_handle_c2h(priv, skb);\n\t\tdev_kfree_skb(skb);\n\t\treturn RX_TYPE_C2H;\n\t}\n\n\tif (rx_desc->phy_stats)\n\t\trtl8xxxu_rx_parse_phystats(priv, rx_status, phy_stats,\n\t\t\t\t\t   rx_desc->rxmcs);\n\n\trx_status->mactime = rx_desc->tsfl;\n\trx_status->flag |= RX_FLAG_MACTIME_START;\n\n\tif (!rx_desc->swdec)\n\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\tif (rx_desc->crc32)\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\tif (rx_desc->bw)\n\t\trx_status->bw = RATE_INFO_BW_40;\n\n\tif (rx_desc->rxmcs >= DESC_RATE_MCS0) {\n\t\trx_status->encoding = RX_ENC_HT;\n\t\trx_status->rate_idx = rx_desc->rxmcs - DESC_RATE_MCS0;\n\t} else {\n\t\trx_status->rate_idx = rx_desc->rxmcs;\n\t}\n\n\trx_status->freq = hw->conf.chandef.chan->center_freq;\n\trx_status->band = hw->conf.chandef.chan->band;\n\n\tieee80211_rx_irqsafe(hw, skb);\n\treturn RX_TYPE_DATA_PKT;\n}\n\nstatic void rtl8xxxu_rx_complete(struct urb *urb)\n{\n\tstruct rtl8xxxu_rx_urb *rx_urb =\n\t\tcontainer_of(urb, struct rtl8xxxu_rx_urb, urb);\n\tstruct ieee80211_hw *hw = rx_urb->hw;\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct sk_buff *skb = (struct sk_buff *)urb->context;\n\tstruct device *dev = &priv->udev->dev;\n\n\tskb_put(skb, urb->actual_length);\n\n\tif (urb->status == 0) {\n\t\tpriv->fops->parse_rx_desc(priv, skb);\n\n\t\tskb = NULL;\n\t\trx_urb->urb.context = NULL;\n\t\trtl8xxxu_queue_rx_urb(priv, rx_urb);\n\t} else {\n\t\tdev_dbg(dev, \"%s: status %i\\n\",\t__func__, urb->status);\n\t\tgoto cleanup;\n\t}\n\treturn;\n\ncleanup:\n\tusb_free_urb(urb);\n\tdev_kfree_skb(skb);\n\treturn;\n}\n\nstatic int rtl8xxxu_submit_rx_urb(struct rtl8xxxu_priv *priv,\n\t\t\t\t  struct rtl8xxxu_rx_urb *rx_urb)\n{\n\tstruct rtl8xxxu_fileops *fops = priv->fops;\n\tstruct sk_buff *skb;\n\tint skb_size;\n\tint ret, rx_desc_sz;\n\n\trx_desc_sz = fops->rx_desc_size;\n\n\tif (priv->rx_buf_aggregation && fops->rx_agg_buf_size) {\n\t\tskb_size = fops->rx_agg_buf_size;\n\t\tskb_size += (rx_desc_sz + sizeof(struct rtl8723au_phy_stats));\n\t} else {\n\t\tskb_size = IEEE80211_MAX_FRAME_LEN;\n\t}\n\n\tskb = __netdev_alloc_skb(NULL, skb_size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, rx_desc_sz);\n\tusb_fill_bulk_urb(&rx_urb->urb, priv->udev, priv->pipe_in, skb->data,\n\t\t\t  skb_size, rtl8xxxu_rx_complete, skb);\n\tusb_anchor_urb(&rx_urb->urb, &priv->rx_anchor);\n\tret = usb_submit_urb(&rx_urb->urb, GFP_ATOMIC);\n\tif (ret)\n\t\tusb_unanchor_urb(&rx_urb->urb);\n\treturn ret;\n}\n\nstatic void rtl8xxxu_int_complete(struct urb *urb)\n{\n\tstruct rtl8xxxu_priv *priv = (struct rtl8xxxu_priv *)urb->context;\n\tstruct device *dev = &priv->udev->dev;\n\tint ret;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_INTERRUPT)\n\t\tdev_dbg(dev, \"%s: status %i\\n\", __func__, urb->status);\n\tif (urb->status == 0) {\n\t\tusb_anchor_urb(urb, &priv->int_anchor);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret)\n\t\t\tusb_unanchor_urb(urb);\n\t} else {\n\t\tdev_dbg(dev, \"%s: Error %i\\n\", __func__, urb->status);\n\t}\n}\n\n\nstatic int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_urb(urb);\n\t\tgoto error;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\n\nerror:\n\treturn ret;\n}\n\nstatic int rtl8xxxu_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tint ret;\n\tu8 val8;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\trtl8xxxu_stop_tx_beacon(priv);\n\n\t\tval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\n\t\tval8 |= BEACON_ATIM | BEACON_FUNCTION_ENABLE |\n\t\t\tBEACON_DISABLE_TSF_UPDATE;\n\t\trtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\trtl8xxxu_set_linktype(priv, vif->type);\n\n\treturn ret;\n}\n\nstatic void rtl8xxxu_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\n\tdev_dbg(&priv->udev->dev, \"%s\\n\", __func__);\n}\n\nstatic int rtl8xxxu_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tu16 val16;\n\tint ret = 0, channel;\n\tbool ht40;\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_CHANNEL)\n\t\tdev_info(dev,\n\t\t\t \"%s: channel: %i (changed %08x chandef.width %02x)\\n\",\n\t\t\t __func__, hw->conf.chandef.chan->hw_value,\n\t\t\t changed, hw->conf.chandef.width);\n\n\tif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {\n\t\tval16 = ((hw->conf.long_frame_max_tx_count <<\n\t\t\t  RETRY_LIMIT_LONG_SHIFT) & RETRY_LIMIT_LONG_MASK) |\n\t\t\t((hw->conf.short_frame_max_tx_count <<\n\t\t\t  RETRY_LIMIT_SHORT_SHIFT) & RETRY_LIMIT_SHORT_MASK);\n\t\trtl8xxxu_write16(priv, REG_RETRY_LIMIT, val16);\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tswitch (hw->conf.chandef.width) {\n\t\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tcase NL80211_CHAN_WIDTH_20:\n\t\t\tht40 = false;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_40:\n\t\t\tht40 = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tchannel = hw->conf.chandef.chan->hw_value;\n\n\t\tpriv->fops->set_tx_power(priv, channel, ht40);\n\n\t\tpriv->fops->config_channel(hw);\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int rtl8xxxu_conf_tx(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif, u16 queue,\n\t\t\t    const struct ieee80211_tx_queue_params *param)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tu32 val32;\n\tu8 aifs, acm_ctrl, acm_bit;\n\n\taifs = param->aifs;\n\n\tval32 = aifs |\n\t\tfls(param->cw_min) << EDCA_PARAM_ECW_MIN_SHIFT |\n\t\tfls(param->cw_max) << EDCA_PARAM_ECW_MAX_SHIFT |\n\t\t(u32)param->txop << EDCA_PARAM_TXOP_SHIFT;\n\n\tacm_ctrl = rtl8xxxu_read8(priv, REG_ACM_HW_CTRL);\n\tdev_dbg(dev,\n\t\t\"%s: IEEE80211 queue %02x val %08x, acm %i, acm_ctrl %02x\\n\",\n\t\t__func__, queue, val32, param->acm, acm_ctrl);\n\n\tswitch (queue) {\n\tcase IEEE80211_AC_VO:\n\t\tacm_bit = ACM_HW_CTRL_VO;\n\t\trtl8xxxu_write32(priv, REG_EDCA_VO_PARAM, val32);\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\tacm_bit = ACM_HW_CTRL_VI;\n\t\trtl8xxxu_write32(priv, REG_EDCA_VI_PARAM, val32);\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\tacm_bit = ACM_HW_CTRL_BE;\n\t\trtl8xxxu_write32(priv, REG_EDCA_BE_PARAM, val32);\n\t\tbreak;\n\tcase IEEE80211_AC_BK:\n\t\tacm_bit = ACM_HW_CTRL_BK;\n\t\trtl8xxxu_write32(priv, REG_EDCA_BK_PARAM, val32);\n\t\tbreak;\n\tdefault:\n\t\tacm_bit = 0;\n\t\tbreak;\n\t}\n\n\tif (param->acm)\n\t\tacm_ctrl |= acm_bit;\n\telse\n\t\tacm_ctrl &= ~acm_bit;\n\trtl8xxxu_write8(priv, REG_ACM_HW_CTRL, acm_ctrl);\n\n\treturn 0;\n}\n\nstatic void rtl8xxxu_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t      unsigned int changed_flags,\n\t\t\t\t      unsigned int *total_flags, u64 multicast)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tu32 rcr = rtl8xxxu_read32(priv, REG_RCR);\n\n\tdev_dbg(&priv->udev->dev, \"%s: changed_flags %08x, total_flags %08x\\n\",\n\t\t__func__, changed_flags, *total_flags);\n\n\t/*\n\t * FIF_ALLMULTI ignored as all multicast frames are accepted (REG_MAR)\n\t */\n\n\tif (*total_flags & FIF_FCSFAIL)\n\t\trcr |= RCR_ACCEPT_CRC32;\n\telse\n\t\trcr &= ~RCR_ACCEPT_CRC32;\n\n\t/*\n\t * FIF_PLCPFAIL not supported?\n\t */\n\n\tif (*total_flags & FIF_BCN_PRBRESP_PROMISC)\n\t\trcr &= ~RCR_CHECK_BSSID_BEACON;\n\telse\n\t\trcr |= RCR_CHECK_BSSID_BEACON;\n\n\tif (*total_flags & FIF_CONTROL)\n\t\trcr |= RCR_ACCEPT_CTRL_FRAME;\n\telse\n\t\trcr &= ~RCR_ACCEPT_CTRL_FRAME;\n\n\tif (*total_flags & FIF_OTHER_BSS) {\n\t\trcr |= RCR_ACCEPT_AP;\n\t\trcr &= ~RCR_CHECK_BSSID_MATCH;\n\t} else {\n\t\trcr &= ~RCR_ACCEPT_AP;\n\t\trcr |= RCR_CHECK_BSSID_MATCH;\n\t}\n\n\tif (*total_flags & FIF_PSPOLL)\n\t\trcr |= RCR_ACCEPT_PM;\n\telse\n\t\trcr &= ~RCR_ACCEPT_PM;\n\n\t/*\n\t * FIF_PROBE_REQ ignored as probe requests always seem to be accepted\n\t */\n\n\trtl8xxxu_write32(priv, REG_RCR, rcr);\n\n\t*total_flags &= (FIF_ALLMULTI | FIF_FCSFAIL | FIF_BCN_PRBRESP_PROMISC |\n\t\t\t FIF_CONTROL | FIF_OTHER_BSS | FIF_PSPOLL |\n\t\t\t FIF_PROBE_REQ);\n}\n\nstatic int rtl8xxxu_set_rts_threshold(struct ieee80211_hw *hw, u32 rts)\n{\n\tif (rts > 2347)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int rtl8xxxu_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct ieee80211_key_conf *key)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tu8 mac_addr[ETH_ALEN];\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\tint retval = -EOPNOTSUPP;\n\n\tdev_dbg(dev, \"%s: cmd %02x, cipher %08x, index %i\\n\",\n\t\t__func__, cmd, key->cipher, key->keyidx);\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (key->keyidx > 3)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\n\t\tdev_dbg(dev, \"%s: pairwise key\\n\", __func__);\n\t\tether_addr_copy(mac_addr, sta->addr);\n\t} else {\n\t\tdev_dbg(dev, \"%s: group key\\n\", __func__);\n\t\teth_broadcast_addr(mac_addr);\n\t}\n\n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 |= CR_SECURITY_ENABLE;\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\n\tval8 = SEC_CFG_TX_SEC_ENABLE | SEC_CFG_TXBC_USE_DEFKEY |\n\t\tSEC_CFG_RX_SEC_ENABLE | SEC_CFG_RXBC_USE_DEFKEY;\n\tval8 |= SEC_CFG_TX_USE_DEFKEY | SEC_CFG_RX_USE_DEFKEY;\n\trtl8xxxu_write8(priv, REG_SECURITY_CFG, val8);\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tkey->hw_key_idx = key->keyidx;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\trtl8xxxu_cam_write(priv, key, mac_addr);\n\t\tretval = 0;\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\trtl8xxxu_write32(priv, REG_CAM_WRITE, 0x00000000);\n\t\tval32 = CAM_CMD_POLLING | CAM_CMD_WRITE |\n\t\t\tkey->keyidx << CAM_CMD_KEY_SHIFT;\n\t\trtl8xxxu_write32(priv, REG_CAM_CMD, val32);\n\t\tretval = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"%s: Unsupported command %02x\\n\", __func__, cmd);\n\t}\n\n\treturn retval;\n}\n\nstatic int\nrtl8xxxu_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t      struct ieee80211_ampdu_params *params)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct device *dev = &priv->udev->dev;\n\tu8 ampdu_factor, ampdu_density;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tdev_dbg(dev, \"%s: IEEE80211_AMPDU_TX_START\\n\", __func__);\n\t\tampdu_factor = sta->ht_cap.ampdu_factor;\n\t\tampdu_density = sta->ht_cap.ampdu_density;\n\t\trtl8xxxu_set_ampdu_factor(priv, ampdu_factor);\n\t\trtl8xxxu_set_ampdu_min_space(priv, ampdu_density);\n\t\tdev_dbg(dev,\n\t\t\t\"Changed HT: ampdu_factor %02x, ampdu_density %02x\\n\",\n\t\t\tampdu_factor, ampdu_density);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\t\tdev_dbg(dev, \"%s: IEEE80211_AMPDU_TX_STOP_FLUSH\\n\", __func__);\n\t\trtl8xxxu_set_ampdu_factor(priv, 0);\n\t\trtl8xxxu_set_ampdu_min_space(priv, 0);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tdev_dbg(dev, \"%s: IEEE80211_AMPDU_TX_STOP_FLUSH_CONT\\n\",\n\t\t\t __func__);\n\t\trtl8xxxu_set_ampdu_factor(priv, 0);\n\t\trtl8xxxu_set_ampdu_min_space(priv, 0);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tdev_dbg(dev, \"%s: IEEE80211_AMPDU_RX_START\\n\", __func__);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tdev_dbg(dev, \"%s: IEEE80211_AMPDU_RX_STOP\\n\", __func__);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rtl8xxxu_start(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct rtl8xxxu_rx_urb *rx_urb;\n\tstruct rtl8xxxu_tx_urb *tx_urb;\n\tunsigned long flags;\n\tint ret, i;\n\n\tret = 0;\n\n\tinit_usb_anchor(&priv->rx_anchor);\n\tinit_usb_anchor(&priv->tx_anchor);\n\tinit_usb_anchor(&priv->int_anchor);\n\n\tpriv->fops->enable_rf(priv);\n\tif (priv->usb_interrupts) {\n\t\tret = rtl8xxxu_submit_int_urb(hw);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < RTL8XXXU_TX_URBS; i++) {\n\t\ttx_urb = kmalloc(sizeof(struct rtl8xxxu_tx_urb), GFP_KERNEL);\n\t\tif (!tx_urb) {\n\t\t\tif (!i)\n\t\t\t\tret = -ENOMEM;\n\n\t\t\tgoto error_out;\n\t\t}\n\t\tusb_init_urb(&tx_urb->urb);\n\t\tINIT_LIST_HEAD(&tx_urb->list);\n\t\ttx_urb->hw = hw;\n\t\tlist_add(&tx_urb->list, &priv->tx_urb_free_list);\n\t\tpriv->tx_urb_free_count++;\n\t}\n\n\tpriv->tx_stopped = false;\n\n\tspin_lock_irqsave(&priv->rx_urb_lock, flags);\n\tpriv->shutdown = false;\n\tspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\n\n\tfor (i = 0; i < RTL8XXXU_RX_URBS; i++) {\n\t\trx_urb = kmalloc(sizeof(struct rtl8xxxu_rx_urb), GFP_KERNEL);\n\t\tif (!rx_urb) {\n\t\t\tif (!i)\n\t\t\t\tret = -ENOMEM;\n\n\t\t\tgoto error_out;\n\t\t}\n\t\tusb_init_urb(&rx_urb->urb);\n\t\tINIT_LIST_HEAD(&rx_urb->list);\n\t\trx_urb->hw = hw;\n\n\t\tret = rtl8xxxu_submit_rx_urb(priv, rx_urb);\n\t}\nexit:\n\t/*\n\t * Accept all data and mgmt frames\n\t */\n\trtl8xxxu_write16(priv, REG_RXFLTMAP2, 0xffff);\n\trtl8xxxu_write16(priv, REG_RXFLTMAP0, 0xffff);\n\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_AGC_CORE1, 0x6954341e);\n\n\treturn ret;\n\nerror_out:\n\trtl8xxxu_free_tx_resources(priv);\n\t/*\n\t * Disable all data and mgmt frames\n\t */\n\trtl8xxxu_write16(priv, REG_RXFLTMAP2, 0x0000);\n\trtl8xxxu_write16(priv, REG_RXFLTMAP0, 0x0000);\n\n\treturn ret;\n}\n\nstatic void rtl8xxxu_stop(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tunsigned long flags;\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\n\trtl8xxxu_write16(priv, REG_RXFLTMAP0, 0x0000);\n\trtl8xxxu_write16(priv, REG_RXFLTMAP2, 0x0000);\n\n\tspin_lock_irqsave(&priv->rx_urb_lock, flags);\n\tpriv->shutdown = true;\n\tspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\n\n\tusb_kill_anchored_urbs(&priv->rx_anchor);\n\tusb_kill_anchored_urbs(&priv->tx_anchor);\n\tif (priv->usb_interrupts)\n\t\tusb_kill_anchored_urbs(&priv->int_anchor);\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\n\tpriv->fops->disable_rf(priv);\n\n\t/*\n\t * Disable interrupts\n\t */\n\tif (priv->usb_interrupts)\n\t\trtl8xxxu_write32(priv, REG_USB_HIMR, 0);\n\n\trtl8xxxu_free_rx_resources(priv);\n\trtl8xxxu_free_tx_resources(priv);\n}\n\nstatic const struct ieee80211_ops rtl8xxxu_ops = {\n\t.tx = rtl8xxxu_tx,\n\t.add_interface = rtl8xxxu_add_interface,\n\t.remove_interface = rtl8xxxu_remove_interface,\n\t.config = rtl8xxxu_config,\n\t.conf_tx = rtl8xxxu_conf_tx,\n\t.bss_info_changed = rtl8xxxu_bss_info_changed,\n\t.configure_filter = rtl8xxxu_configure_filter,\n\t.set_rts_threshold = rtl8xxxu_set_rts_threshold,\n\t.start = rtl8xxxu_start,\n\t.stop = rtl8xxxu_stop,\n\t.sw_scan_start = rtl8xxxu_sw_scan_start,\n\t.sw_scan_complete = rtl8xxxu_sw_scan_complete,\n\t.set_key = rtl8xxxu_set_key,\n\t.ampdu_action = rtl8xxxu_ampdu_action,\n};\n\nstatic int rtl8xxxu_parse_usb(struct rtl8xxxu_priv *priv,\n\t\t\t      struct usb_interface *interface)\n{\n\tstruct usb_interface_descriptor *interface_desc;\n\tstruct usb_host_interface *host_interface;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct device *dev = &priv->udev->dev;\n\tint i, j = 0, endpoints;\n\tu8 dir, xtype, num;\n\tint ret = 0;\n\n\thost_interface = &interface->altsetting[0];\n\tinterface_desc = &host_interface->desc;\n\tendpoints = interface_desc->bNumEndpoints;\n\n\tfor (i = 0; i < endpoints; i++) {\n\t\tendpoint = &host_interface->endpoint[i].desc;\n\n\t\tdir = endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK;\n\t\tnum = usb_endpoint_num(endpoint);\n\t\txtype = usb_endpoint_type(endpoint);\n\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s: endpoint: dir %02x, # %02x, type %02x\\n\",\n\t\t\t\t__func__, dir, num, xtype);\n\t\tif (usb_endpoint_dir_in(endpoint) &&\n\t\t    usb_endpoint_xfer_bulk(endpoint)) {\n\t\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\n\t\t\t\tdev_dbg(dev, \"%s: in endpoint num %i\\n\",\n\t\t\t\t\t__func__, num);\n\n\t\t\tif (priv->pipe_in) {\n\t\t\t\tdev_warn(dev,\n\t\t\t\t\t \"%s: Too many IN pipes\\n\", __func__);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tpriv->pipe_in =\tusb_rcvbulkpipe(priv->udev, num);\n\t\t}\n\n\t\tif (usb_endpoint_dir_in(endpoint) &&\n\t\t    usb_endpoint_xfer_int(endpoint)) {\n\t\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\n\t\t\t\tdev_dbg(dev, \"%s: interrupt endpoint num %i\\n\",\n\t\t\t\t\t__func__, num);\n\n\t\t\tif (priv->pipe_interrupt) {\n\t\t\t\tdev_warn(dev, \"%s: Too many INTERRUPT pipes\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tpriv->pipe_interrupt = usb_rcvintpipe(priv->udev, num);\n\t\t}\n\n\t\tif (usb_endpoint_dir_out(endpoint) &&\n\t\t    usb_endpoint_xfer_bulk(endpoint)) {\n\t\t\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\n\t\t\t\tdev_dbg(dev, \"%s: out endpoint num %i\\n\",\n\t\t\t\t\t__func__, num);\n\t\t\tif (j >= RTL8XXXU_OUT_ENDPOINTS) {\n\t\t\t\tdev_warn(dev,\n\t\t\t\t\t \"%s: Too many OUT pipes\\n\", __func__);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tpriv->out_ep[j++] = num;\n\t\t}\n\t}\nexit:\n\tpriv->nr_out_eps = j;\n\treturn ret;\n}\n\nstatic int rtl8xxxu_probe(struct usb_interface *interface,\n\t\t\t  const struct usb_device_id *id)\n{\n\tstruct rtl8xxxu_priv *priv;\n\tstruct ieee80211_hw *hw;\n\tstruct usb_device *udev;\n\tstruct ieee80211_supported_band *sband;\n\tint ret;\n\tint untested = 1;\n\n\tudev = usb_get_dev(interface_to_usbdev(interface));\n\n\tswitch (id->idVendor) {\n\tcase USB_VENDOR_ID_REALTEK:\n\t\tswitch(id->idProduct) {\n\t\tcase 0x1724:\n\t\tcase 0x8176:\n\t\tcase 0x8178:\n\t\tcase 0x817f:\n\t\tcase 0x818b:\n\t\t\tuntested = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 0x7392:\n\t\tif (id->idProduct == 0x7811)\n\t\t\tuntested = 0;\n\t\tbreak;\n\tcase 0x050d:\n\t\tif (id->idProduct == 0x1004)\n\t\t\tuntested = 0;\n\t\tbreak;\n\tcase 0x20f4:\n\t\tif (id->idProduct == 0x648b)\n\t\t\tuntested = 0;\n\t\tbreak;\n\tcase 0x2001:\n\t\tif (id->idProduct == 0x3308)\n\t\t\tuntested = 0;\n\t\tbreak;\n\tcase 0x2357:\n\t\tif (id->idProduct == 0x0109)\n\t\t\tuntested = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (untested) {\n\t\trtl8xxxu_debug |= RTL8XXXU_DEBUG_EFUSE;\n\t\tdev_info(&udev->dev,\n\t\t\t \"This Realtek USB WiFi dongle (0x%04x:0x%04x) is untested!\\n\",\n\t\t\t id->idVendor, id->idProduct);\n\t\tdev_info(&udev->dev,\n\t\t\t \"Please report results to Jes.Sorensen@gmail.com\\n\");\n\t}\n\n\thw = ieee80211_alloc_hw(sizeof(struct rtl8xxxu_priv), &rtl8xxxu_ops);\n\tif (!hw) {\n\t\tret = -ENOMEM;\n\t\tpriv = NULL;\n\t\tgoto exit;\n\t}\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tpriv->udev = udev;\n\tpriv->fops = (struct rtl8xxxu_fileops *)id->driver_info;\n\tmutex_init(&priv->usb_buf_mutex);\n\tmutex_init(&priv->h2c_mutex);\n\tINIT_LIST_HEAD(&priv->tx_urb_free_list);\n\tspin_lock_init(&priv->tx_urb_lock);\n\tINIT_LIST_HEAD(&priv->rx_urb_pending_list);\n\tspin_lock_init(&priv->rx_urb_lock);\n\tINIT_WORK(&priv->rx_urb_wq, rtl8xxxu_rx_urb_work);\n\n\tusb_set_intfdata(interface, hw);\n\n\tret = rtl8xxxu_parse_usb(priv, interface);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = rtl8xxxu_identify_chip(priv);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"Fatal - failed to identify chip\\n\");\n\t\tgoto exit;\n\t}\n\n\tret = rtl8xxxu_read_efuse(priv);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"Fatal - failed to read EFuse\\n\");\n\t\tgoto exit;\n\t}\n\n\tret = priv->fops->parse_efuse(priv);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"Fatal - failed to parse EFuse\\n\");\n\t\tgoto exit;\n\t}\n\n\trtl8xxxu_print_chipinfo(priv);\n\n\tret = priv->fops->load_firmware(priv);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"Fatal - failed to load firmware\\n\");\n\t\tgoto exit;\n\t}\n\n\tret = rtl8xxxu_init_device(hw);\n\tif (ret)\n\t\tgoto exit;\n\n\thw->wiphy->max_scan_ssids = 1;\n\thw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\thw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\n\thw->queues = 4;\n\n\tsband = &rtl8xxxu_supported_band;\n\tsband->ht_cap.ht_supported = true;\n\tsband->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tsband->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;\n\tsband->ht_cap.cap = IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_SGI_40;\n\tmemset(&sband->ht_cap.mcs, 0, sizeof(sband->ht_cap.mcs));\n\tsband->ht_cap.mcs.rx_mask[0] = 0xff;\n\tsband->ht_cap.mcs.rx_mask[4] = 0x01;\n\tif (priv->rf_paths > 1) {\n\t\tsband->ht_cap.mcs.rx_mask[1] = 0xff;\n\t\tsband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\n\t}\n\tsband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\t/*\n\t * Some APs will negotiate HT20_40 in a noisy environment leading\n\t * to miserable performance. Rather than defaulting to this, only\n\t * enable it if explicitly requested at module load time.\n\t */\n\tif (rtl8xxxu_ht40_2g) {\n\t\tdev_info(&udev->dev, \"Enabling HT_20_40 on the 2.4GHz band\\n\");\n\t\tsband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\thw->wiphy->bands[NL80211_BAND_2GHZ] = sband;\n\n\thw->wiphy->rts_threshold = 2347;\n\n\tSET_IEEE80211_DEV(priv->hw, &interface->dev);\n\tSET_IEEE80211_PERM_ADDR(hw, priv->mac_addr);\n\n\thw->extra_tx_headroom = priv->fops->tx_desc_size;\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\t/*\n\t * The firmware handles rate control\n\t */\n\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tret = ieee80211_register_hw(priv->hw);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"%s: Failed to register: %i\\n\",\n\t\t\t__func__, ret);\n\t\tgoto exit;\n\t}\n\n\treturn 0;\n\nexit:\n\tusb_set_intfdata(interface, NULL);\n\n\tif (priv) {\n\t\tkfree(priv->fw_data);\n\t\tmutex_destroy(&priv->usb_buf_mutex);\n\t\tmutex_destroy(&priv->h2c_mutex);\n\t}\n\tusb_put_dev(udev);\n\n\tieee80211_free_hw(hw);\n\n\treturn ret;\n}\n\nstatic void rtl8xxxu_disconnect(struct usb_interface *interface)\n{\n\tstruct rtl8xxxu_priv *priv;\n\tstruct ieee80211_hw *hw;\n\n\thw = usb_get_intfdata(interface);\n\tpriv = hw->priv;\n\n\tieee80211_unregister_hw(hw);\n\n\tpriv->fops->power_off(priv);\n\n\tusb_set_intfdata(interface, NULL);\n\n\tdev_info(&priv->udev->dev, \"disconnecting\\n\");\n\n\tkfree(priv->fw_data);\n\tmutex_destroy(&priv->usb_buf_mutex);\n\tmutex_destroy(&priv->h2c_mutex);\n\n\tif (priv->udev->state != USB_STATE_NOTATTACHED) {\n\t\tdev_info(&priv->udev->dev,\n\t\t\t \"Device still attached, trying to reset\\n\");\n\t\tusb_reset_device(priv->udev);\n\t}\n\tusb_put_dev(priv->udev);\n\tieee80211_free_hw(hw);\n}\n\nstatic const struct usb_device_id dev_table[] = {\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8724, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8723au_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x1724, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8723au_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x0724, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8723au_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x818b, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n/* TP-Link TL-WN822N v4 */\n{USB_DEVICE_AND_INTERFACE_INFO(0x2357, 0x0108, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n/* D-Link DWA-131 rev E1, tested by David Pati\u00f1o */\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x3319, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n/* Tested by Myckel Habets */\n{USB_DEVICE_AND_INTERFACE_INFO(0x2357, 0x0109, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0xb720, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8723bu_fops},\n#ifdef CONFIG_RTL8XXXU_UNTESTED\n/* Still supported by rtlwifi */\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8176, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8178, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x817f, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Tested by Larry Finger */\n{USB_DEVICE_AND_INTERFACE_INFO(0x7392, 0x7811, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Tested by Andrea Merello */\n{USB_DEVICE_AND_INTERFACE_INFO(0x050d, 0x1004, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Tested by Jocelyn Mayer */\n{USB_DEVICE_AND_INTERFACE_INFO(0x20f4, 0x648b, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Tested by Stefano Bravi */\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x3308, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Currently untested 8188 series devices */\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x018a, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8191, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8170, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x8177, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x817a, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x817b, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x817d, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x817e, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x818a, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x317f, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x1058, 0x0631, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04bb, 0x094c, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x050d, 0x1102, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x06f8, 0xe033, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x07b8, 0x8189, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0846, 0x9041, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0b05, 0x17ba, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x1e1e, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x5088, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0df6, 0x0052, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0df6, 0x005c, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0eb0, 0x9071, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x103c, 0x1629, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x13d3, 0x3357, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x330b, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0x4902, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xab2a, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xab2e, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xed17, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x4855, 0x0090, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x4856, 0x0091, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0xcdab, 0x8010, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaff7, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaff9, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaffa, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaff8, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaffb, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x04f2, 0xaffc, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0x1201, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* Currently untested 8192 series devices */\n{USB_DEVICE_AND_INTERFACE_INFO(0x04bb, 0x0950, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x050d, 0x2102, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x050d, 0x2103, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0586, 0x341f, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x06f8, 0xe035, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0b05, 0x17ab, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0df6, 0x0061, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0df6, 0x0070, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0789, 0x016d, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x07aa, 0x0056, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x07b8, 0x8178, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0846, 0x9021, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0846, 0xf001, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x2e2e, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0e66, 0x0019, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x0e66, 0x0020, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x3307, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x3309, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x330a, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xab2b, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x20f4, 0x624d, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2357, 0x0100, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x4855, 0x0091, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x7392, 0x7822, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192cu_fops},\n/* found in rtl8192eu vendor driver */\n{USB_DEVICE_AND_INTERFACE_INFO(0x2357, 0x0107, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xab33, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x818c, 0xff, 0xff, 0xff),\n\t.driver_info = (unsigned long)&rtl8192eu_fops},\n#endif\n{ }\n};\n\nstatic struct usb_driver rtl8xxxu_driver = {\n\t.name = DRIVER_NAME,\n\t.probe = rtl8xxxu_probe,\n\t.disconnect = rtl8xxxu_disconnect,\n\t.id_table = dev_table,\n\t.no_dynamic_id = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nstatic int __init rtl8xxxu_module_init(void)\n{\n\tint res;\n\n\tres = usb_register(&rtl8xxxu_driver);\n\tif (res < 0)\n\t\tpr_err(DRIVER_NAME \": usb_register() failed (%i)\\n\", res);\n\n\treturn res;\n}\n\nstatic void __exit rtl8xxxu_module_exit(void)\n{\n\tusb_deregister(&rtl8xxxu_driver);\n}\n\n\nMODULE_DEVICE_TABLE(usb, dev_table);\n\nmodule_init(rtl8xxxu_module_init);\nmodule_exit(rtl8xxxu_module_exit);\n"], "filenames": ["drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c"], "buggy_code_start_loc": [5446], "buggy_code_end_loc": [5446], "fixing_code_start_loc": [5447], "fixing_code_end_loc": [5448], "type": "CWE-401", "message": "A memory leak in the rtl8xxxu_submit_int_urb() function in drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-a2cdd07488e6.", "other": {"cve": {"id": "CVE-2019-19068", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:12.857", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the rtl8xxxu_submit_int_urb() function in drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-a2cdd07488e6."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n rtl8xxxu_submit_int_urb() en el archivo drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c en el kernel de Linux versiones hasta la versi\u00f3n  5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n usb_submit_urb(), tambi\u00e9n se conoce como CID-a2cdd07488e6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.11", "matchCriteriaId": "EB2904AC-AD7A-498D-8619-CBB421E9165D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/a2cdd07488e666aa93a49a3fc9c9b1299e27ef3c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4286-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4286-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4300-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4301-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4302-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a2cdd07488e666aa93a49a3fc9c9b1299e27ef3c"}}