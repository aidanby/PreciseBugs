{"buggy_code": ["/* bcon.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <assert.h>\n#include \"bcon.h\"\n\n#ifndef NOT_REACHED\n#define NOT_REACHED 0\n#endif\n\n#define ARRAY_INDEX_BUFFER_SIZE 9\n\nchar *bcon_errstr[] = {\n    \"OK\",\n    \"ERROR\",\n    \"bcon document or nesting incomplete\",\n    \"bson finish error\"\n};\n\nstatic int bcon_error(bson *b, const bcon *bc, size_t i, bcon_error_t err) {\n    b->err = err;\n    b->errstr = bcon_errstr[err];\n    return BCON_ERROR;\n}\n\nbcon_error_t bson_append_bcon_array(bson *b, const bcon *bc);\n\nstatic bcon_token_t bcon_token(char *s) {\n    if (s == 0) return Token_EOD;\n    switch (s[0]) {\n    case ':': if (s[1] != '\\0' && s[2] != '\\0' && s[3] != '\\0' && s[4] == '\\0' &&\n                      s[3] == ':' && (s[1] == '_' || s[1] == 'P' || s[1] == 'R'))\n            return Token_Typespec; break;\n    case '{': if (s[1] == '\\0') return Token_OpenBrace; break;\n    case '}': if (s[1] == '\\0') return Token_CloseBrace; break;\n    case '[': if (s[1] == '\\0') return Token_OpenBracket; break;\n    case ']': if (s[1] == '\\0') return Token_CloseBracket; break;\n    case '.': if (s[1] == '\\0') return Token_End; break;\n    }\n    return Token_Default;\n}\n\nstatic bcon_error_t bson_bcon_key_value(bson *b, const char *key, const char *typespec, const bcon bci) {\n    bcon_error_t ret = BCON_OK;\n    bson_oid_t oid;\n    char ptype = typespec ? typespec[1] : '_';\n    char utype = typespec ? typespec[2] : '_';\n    switch (ptype) {\n    case '_': /* kv(b, key, utype, bci) */\n        switch (utype) {\n        case '_': /* fall through */\n        case 's': bson_append_string( b, key, bci.s ); break; /* common case */\n        case 'f': bson_append_double( b, key, bci.f ); break;\n        case 'D':\n            bson_append_start_object( b, key );\n            ret = bson_append_bcon( b, bci.D );\n            bson_append_finish_object( b );\n            break;\n        case 'A':\n            bson_append_start_array( b, key );\n            ret = bson_append_bcon_array( b, bci.A );\n            bson_append_finish_array( b );\n            break;\n        case 'o': if (*bci.o == '\\0') bson_oid_gen( &oid ); else bson_oid_from_string( &oid, bci.o ); bson_append_oid( b, key, &oid ); break;\n        case 'b': bson_append_bool( b, key, bci.b ); break;\n        case 't': bson_append_time_t( b, key, bci.t ); break;\n        case 'v': bson_append_null( b, key ); break; /* void */\n        case 'x': bson_append_symbol( b, key, bci.x ); break;\n        case 'i': bson_append_int( b, key, bci.i ); break;\n        case 'l': bson_append_long( b, key, bci.l ); break;\n        default: printf(\"\\nptype:'%c' utype:'%c'\\n\", ptype, utype); assert(NOT_REACHED); break;\n        }\n        break;\n    case 'R': /* krv(b, key, utype, bci) */\n        switch (utype) {\n        case 'f': bson_append_double( b, key, *bci.Rf ); break;\n        case 's': bson_append_string( b, key, bci.Rs ); break;\n        case 'D':\n            bson_append_start_object( b, key );\n            ret = bson_append_bcon( b, bci.RD );\n            bson_append_finish_object( b );\n            break;\n        case 'A':\n            bson_append_start_array( b, key );\n            ret = bson_append_bcon_array( b, bci.RA );\n            bson_append_finish_array( b );\n            break;\n        case 'o': if (*bci.o == '\\0') bson_oid_gen( &oid ); else bson_oid_from_string( &oid, bci.o ); bson_append_oid( b, key, &oid ); break;\n        case 'b': bson_append_bool( b, key, *bci.Rb ); break;\n        case 't': bson_append_time_t( b, key, *bci.Rt ); break;\n        case 'x': bson_append_symbol( b, key, bci.Rx ); break;\n        case 'i': bson_append_int( b, key, *bci.Ri ); break;\n        case 'l': bson_append_long( b, key, *bci.Rl ); break;\n        default: printf(\"\\nptype:'%c' utype:'%c'\\n\", ptype, utype); assert(NOT_REACHED); break;\n        }\n        break;\n    case 'P': /* kpv(b, key, utype, bci) */\n        if (*bci.Pv != 0) {\n            switch (utype) {\n            case 'f': bson_append_double( b, key, **bci.Pf ); break;\n            case 's': bson_append_string( b, key, *bci.Ps ); break;\n            case 'D':\n                bson_append_start_object( b, key );\n                ret = bson_append_bcon( b, *bci.PD );\n                bson_append_finish_object( b );\n                break;\n            case 'A':\n                bson_append_start_array( b, key );\n                ret = bson_append_bcon_array( b, *bci.PA );\n                bson_append_finish_array( b );\n                break;\n            case 'o': if (**bci.Po == '\\0') bson_oid_gen( &oid );\n                else bson_oid_from_string( &oid, *bci.Po );\n                bson_append_oid( b, key, &oid );\n                break;\n            case 'b': bson_append_bool( b, key, **bci.Pb ); break;\n            case 't': bson_append_time_t( b, key, **bci.Pt ); break;\n            case 'x': if (*bci.Px != 0) bson_append_symbol( b, key, *bci.Px ); break;\n            case 'i': bson_append_int( b, key, **bci.Pi ); break;\n            case 'l': bson_append_long( b, key, **bci.Pl ); break;\n            default: printf(\"\\nptype:'%c' utype:'%c'\\n\", ptype, utype); assert(NOT_REACHED); break;\n            }\n        }\n        break;\n    default:\n        printf(\"\\nptype:'%c' utype:'%c'\\n\", ptype, utype); assert(NOT_REACHED);\n        break;\n    }\n    return ret;\n}\n\ntypedef enum bcon_state_t {\n    State_Element, State_DocSpecValue, State_DocValue,\n    State_ArraySpecValue, State_ArrayValue\n} bcon_state_t;\n\n#define DOC_STACK_SIZE 1024\n#define ARRAY_INDEX_STACK_SIZE 1024\n\n#define DOC_PUSH_STATE(return_state) ( doc_stack[doc_stack_pointer++] = (return_state) )\n#define DOC_POP_STATE ( state = doc_stack[--doc_stack_pointer] )\n#define ARRAY_PUSH_RESET_INDEX_STATE(return_state) ( array_index_stack[array_index_stack_pointer++] = array_index, array_index = 0, DOC_PUSH_STATE(return_state) )\n#define ARRAY_POP_INDEX_STATE ( array_index = array_index_stack[--array_index_stack_pointer], DOC_POP_STATE )\n\n#define ARRAY_KEY_STRING(l) (bson_numstr(array_index_buffer, (int)(l)), array_index_buffer)\n\n/*\n * simplified FSM to parse BCON structure, uses stacks for sub-documents and sub-arrays\n */\nstatic bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) {\n    bcon_error_t ret = BCON_OK;\n    bcon_state_t state = start_state;\n    char *key = 0;\n    char *typespec = 0;\n    unsigned char doc_stack[DOC_STACK_SIZE];\n    size_t doc_stack_pointer = 0;\n    size_t array_index = 0;\n    unsigned int array_index_stack[ARRAY_INDEX_STACK_SIZE];\n    size_t array_index_stack_pointer = 0;\n    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; /* max BSON size */\n    int end_of_data;\n    const bcon *bcp;\n    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        char *s = bci.s;\n        switch (state) {\n        case State_Element:\n            switch (bcon_token(s)) {\n            case Token_CloseBrace:\n                bson_append_finish_object( b );\n                DOC_POP_STATE; /* state = ...; */\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                key = s;\n                state = State_DocSpecValue;\n                break;\n            }\n            break;\n        case State_DocSpecValue:\n            switch (bcon_token(s)) {\n            case Token_Typespec:\n                typespec = s;\n                state = State_DocValue;\n                break;\n            case Token_OpenBrace:\n                bson_append_start_object( b, key );\n                DOC_PUSH_STATE(State_Element);\n                state = State_Element;\n                break;\n            case Token_OpenBracket:\n                bson_append_start_array( b, key );\n                ARRAY_PUSH_RESET_INDEX_STATE(State_Element);\n                state = State_ArraySpecValue;\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                ret = bson_bcon_key_value(b, key, typespec, bci);\n                state = State_Element;\n                break;\n            }\n            break;\n        case State_DocValue:\n            ret = bson_bcon_key_value(b, key, typespec, bci);\n            state = State_Element;\n            typespec = 0;\n            break;\n        case State_ArraySpecValue:\n            switch (bcon_token(s)) {\n            case Token_Typespec:\n                typespec = s;\n                state = State_ArrayValue;\n                break;\n            case Token_OpenBrace:\n                key = ARRAY_KEY_STRING(array_index++);\n                bson_append_start_object( b, key );\n                DOC_PUSH_STATE(State_ArraySpecValue);\n                state = State_Element;\n                break;\n            case Token_OpenBracket:\n                key = ARRAY_KEY_STRING(array_index++);\n                bson_append_start_array( b, key );\n                ARRAY_PUSH_RESET_INDEX_STATE(State_ArraySpecValue);\n                /* state = State_ArraySpecValue; */\n                break;\n            case Token_CloseBracket:\n                bson_append_finish_array( b );\n                ARRAY_POP_INDEX_STATE; /* state = ...; */\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                key = ARRAY_KEY_STRING(array_index++);\n                ret = bson_bcon_key_value(b, key, typespec, bci);\n                /* state = State_ArraySpecValue; */\n                break;\n            }\n            break;\n        case State_ArrayValue:\n            key = ARRAY_KEY_STRING(array_index++);\n            ret = bson_bcon_key_value(b, key, typespec, bci);\n            state = State_ArraySpecValue;\n            typespec = 0;\n            break;\n        default: assert(NOT_REACHED); break;\n        }\n    }\n    return state == start_state ? BCON_OK : BCON_DOCUMENT_INCOMPLETE;\n}\n\nbcon_error_t bson_append_bcon(bson *b, const bcon *bc) {\n    return bson_append_bcon_with_state(b, bc, State_Element);\n}\n\nbcon_error_t bson_append_bcon_array(bson *b, const bcon *bc) {\n    return bson_append_bcon_with_state(b, bc, State_ArraySpecValue);\n}\n\n/**\n * Generate BSON from BCON\n * @param b a BSON object\n * @param bc a BCON object\n * match with bson_destroy\n */\nbcon_error_t bson_from_bcon(bson *b, const bcon *bc) {\n    bcon_error_t ret = BSON_OK;\n    bson_init( b );\n    ret = bson_append_bcon_with_state( b, bc, State_Element );\n    if (ret != BCON_OK) return ret;\n    ret = bson_finish( b );\n    return ( ret == BSON_OK ? BCON_OK : BCON_BSON_ERROR );\n}\n\nvoid bcon_print(const bcon *bc) { /* prints internal representation, not JSON */\n    char *typespec = 0;\n    char *delim = \"\";\n    int end_of_data;\n    bcon *bcp;\n    putchar('{');\n    for (end_of_data = 0, bcp = (bcon*)bc; !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        char *typespec_next = 0;\n        if (typespec) {\n            switch (typespec[1]) {\n            case '_':\n                switch (typespec[2]) {\n                case 'f': printf(\"%s%f\", delim, bci.f); break;\n                case 's': printf(\"%s\\\"%s\\\"\", delim, bci.s); break;\n                case 'D': printf(\"%sPD(0x%lx,..)\", delim, (unsigned long)bci.D); break;\n                case 'A': printf(\"%sPA(0x%lx,....)\", delim, (unsigned long)bci.A); break;\n                case 'o': printf(\"%s\\\"%s\\\"\", delim, bci.o); break;\n                case 'b': printf(\"%s%d\", delim, bci.b); break;\n                case 't': printf(\"%s%ld\", delim, (long)bci.t); break;\n                case 'v': printf(\"%s\\\"%s\\\"\", delim, bci.v); break;\n                case 'x': printf(\"%s\\\"%s\\\"\", delim, bci.x); break;\n                case 'i': printf(\"%s%d\", delim, bci.i); break;\n                case 'l': printf(\"%s%ld\", delim, bci.l); break;\n                default: printf(\"\\ntypespec:\\\"%s\\\"\\n\", typespec); assert(NOT_REACHED); break;\n                }\n                break;\n            case 'R':\n                switch (typespec[2]) {\n                case 'f': printf(\"%sRf(0x%lx,%f)\", delim, (unsigned long)bci.Rf, *bci.Rf); break;\n                case 's': printf(\"%sRs(0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Rs, bci.Rs); break;\n                case 'D': printf(\"%sRD(0x%lx,..)\", delim, (unsigned long)bci.RD); break;\n                case 'A': printf(\"%sRA(0x%lx,....)\", delim, (unsigned long)bci.RA); break;\n                case 'o': printf(\"%sRo(0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Ro, bci.Ro); break;\n                case 'b': printf(\"%sRb(0x%lx,%d)\", delim, (unsigned long)bci.Rb, *bci.Rb); break;\n                case 't': printf(\"%sRt(0x%lx,%ld)\", delim, (unsigned long)bci.Rt, (long)*bci.Rt); break;\n                case 'x': printf(\"%sRx(0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Rx, bci.Rx); break;\n                case 'i': printf(\"%sRi(0x%lx,%d)\", delim, (unsigned long)bci.Ri, *bci.Ri); break;\n                case 'l': printf(\"%sRl(0x%lx,%ld)\", delim, (unsigned long)bci.Rl, *bci.Rl); break;\n                default: printf(\"\\ntypespec:\\\"%s\\\"\\n\", typespec); assert(NOT_REACHED); break;\n                }\n                break;\n            case 'P':\n                switch (typespec[2]) {\n                case 'f': printf(\"%sPf(0x%lx,0x%lx,%f)\", delim, (unsigned long)bci.Pf, (unsigned long)(bci.Pf ? *bci.Pf : 0), bci.Pf && *bci.Pf ? **bci.Pf : 0.0); break;\n                case 's': printf(\"%sPs(0x%lx,0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Ps, (unsigned long)(bci.Ps ? *bci.Ps : 0), bci.Ps && *bci.Ps ? *bci.Ps : \"\"); break;\n                case 'D': printf(\"%sPD(0x%lx,0x%lx,..)\", delim, (unsigned long)bci.PD, (unsigned long)(bci.PD ? *bci.PD : 0)); break;\n                case 'A': printf(\"%sPA(0x%lx,0x%lx,....)\", delim, (unsigned long)bci.PA, (unsigned long)(bci.PA ? *bci.PA : 0)); break;\n                case 'o': printf(\"%sPo(0x%lx,0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Po, (unsigned long)(bci.Po ? *bci.Po : 0), bci.Po && *bci.Po ? *bci.Po : \"\"); break;\n                case 'b': printf(\"%sPb(0x%lx,0x%lx,%d)\", delim, (unsigned long)bci.Pb, (unsigned long)(bci.Pb ? *bci.Pb : 0), bci.Pb && *bci.Pb ? **bci.Pb : 0); break;\n                case 't': printf(\"%sPt(0x%lx,0x%lx,%ld)\", delim, (unsigned long)bci.Pt, (unsigned long)(bci.Pt ? *bci.Pt : 0), bci.Pt && *bci.Pt ? (long)**bci.Pt : 0); break;\n                case 'x': printf(\"%sPx(0x%lx,0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Px, (unsigned long)(bci.Px ? *bci.Px : 0), bci.Px && *bci.Px ? *bci.Px : \"\"); break;\n                case 'i': printf(\"%sPi(0x%lx,0x%lx,%d)\", delim, (unsigned long)bci.Pi, (unsigned long)(bci.Pi ? *bci.Pi : 0), bci.Pi && *bci.Pi ? **bci.Pi : 0); break;\n                case 'l': printf(\"%sPl(0x%lx,0x%lx,%ld)\", delim, (unsigned long)bci.Pl, (unsigned long)(bci.Pl ? *bci.Pl : 0), bci.Pl && *bci.Pl ? **bci.Pl : 0); break;\n\n                default: printf(\"\\ntypespec:\\\"%s\\\"\\n\", typespec); assert(NOT_REACHED); break;\n                }\n                break;\n            default:\n                printf(\"\\ntypespec:\\\"%s\\\"\\n\", typespec); assert(NOT_REACHED);\n                break;\n            }\n        }\n        else {\n            char *s = bci.s;\n            switch (s[0]) {\n            case '.':\n                end_of_data = (s[1] == '\\0');\n                break;\n            case ':':\n                typespec_next = bcon_token(s) == Token_Typespec ? s : 0;\n                break;\n            }\n            printf(\"%s\\\"%s\\\"\", delim, s);\n        }\n        typespec = typespec_next;\n        delim = \",\";\n    }\n    putchar('}');\n}\n\n/* TODO - incomplete */\nstatic void bcon_json_print(bcon *bc, int n) {\n    int t = 0;\n    int key_value_count = 0;\n    char *s;\n    int end_of_data;\n    bcon *bcp;\n    putchar('{');\n    for (end_of_data = 0, bcp = bc; !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        switch (t) {\n        case 'l':\n            if (key_value_count & 0x1) putchar(':');\n            printf(\"%ld\", bci.l);\n            t = 0;\n            key_value_count++;\n            break;\n        case 's': /* fall through */\n        default:\n            s = bci.s;\n            switch (*s) {\n            case ':':\n                ++s;\n                t = *++s;\n                break;\n            case '{':\n                if (key_value_count & 0x1) putchar(':');\n                putchar(*s);\n                key_value_count = 0;\n                break;\n            case '}':\n                putchar(*s);\n                key_value_count = 2;\n                break;\n            default:\n                if (key_value_count & 0x1) putchar(':');\n                else if (key_value_count > 1) putchar(',');\n                printf(\"\\\"%s\\\"\", s);\n                t = 0;\n                key_value_count++;\n                break;\n            }\n            break;\n        }\n    }\n    putchar('}');\n}\n", "/* bson.c */\n\n/*    Copyright 2009, 2010 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <time.h>\n#include <limits.h>\n\n#include \"bson.h\"\n#include \"encoding.h\"\n\nconst int initialBufferSize = 128;\n\n/* only need one of these */\nstatic const int zero = 0;\n\n/* Custom standard function pointers. */\nvoid *( *bson_malloc_func )( size_t ) = malloc;\nvoid *( *bson_realloc_func )( void *, size_t ) = realloc;\nvoid  ( *bson_free_func )( void * ) = free;\n#ifdef R_SAFETY_NET\nbson_printf_func bson_printf;\n#else\nbson_printf_func bson_printf = printf;\n#endif\nbson_fprintf_func bson_fprintf = fprintf;\nbson_sprintf_func bson_sprintf = sprintf;\n\nstatic int _bson_errprintf( const char *, ... );\nbson_printf_func bson_errprintf = _bson_errprintf;\n\n/* ObjectId fuzz functions. */\nstatic int ( *oid_fuzz_func )( void ) = NULL;\nstatic int ( *oid_inc_func )( void )  = NULL;\n\n/* ----------------------------\n   READING\n   ------------------------------ */\n\nMONGO_EXPORT bson* bson_create( void ) {\n    return (bson*)bson_malloc(sizeof(bson));\n}\n\nMONGO_EXPORT void bson_dispose(bson* b) {\n    bson_free(b);\n}\n\nMONGO_EXPORT bson *bson_empty( bson *obj ) {\n    static char *data = \"\\005\\0\\0\\0\\0\";\n    bson_init_data( obj, data );\n    obj->finished = 1;\n    obj->err = 0;\n    obj->errstr = NULL;\n    obj->stackPos = 0;\n    return obj;\n}\n\nMONGO_EXPORT int bson_copy( bson *out, const bson *in ) {\n    if ( !out || !in ) return BSON_ERROR;\n    if ( !in->finished ) return BSON_ERROR;\n    bson_init_size( out, bson_size( in ) );\n    memcpy( out->data, in->data, bson_size( in ) );\n    out->finished = 1;\n\n    return BSON_OK;\n}\n\nint bson_init_data( bson *b, char *data ) {\n    b->data = data;\n    return BSON_OK;\n}\n\nint bson_init_finished_data( bson *b, char *data ) {\n    bson_init_data( b, data );\n    b->finished = 1;\n    return BSON_OK;\n}\n\nstatic void _bson_reset( bson *b ) {\n    b->finished = 0;\n    b->stackPos = 0;\n    b->err = 0;\n    b->errstr = NULL;\n}\n\nMONGO_EXPORT int bson_size( const bson *b ) {\n    int i;\n    if ( ! b || ! b->data )\n        return 0;\n    bson_little_endian32( &i, b->data );\n    return i;\n}\n\nMONGO_EXPORT int bson_buffer_size( const bson *b ) {\n    return (b->cur - b->data + 1);\n}\n\n\nMONGO_EXPORT const char *bson_data( const bson *b ) {\n    return (const char *)b->data;\n}\n\nstatic char hexbyte( char hex ) {\n    if (hex >= '0' && hex <= '9')\n        return (hex - '0');\n    else if (hex >= 'A' && hex <= 'F')\n        return (hex - 'A' + 10);\n    else if (hex >= 'a' && hex <= 'f')\n        return (hex - 'a' + 10);\n    else\n        return 0x0;\n}\n\nMONGO_EXPORT void bson_oid_from_string( bson_oid_t *oid, const char *str ) {\n    int i;\n    for ( i=0; i<12; i++ ) {\n        oid->bytes[i] = ( hexbyte( str[2*i] ) << 4 ) | hexbyte( str[2*i + 1] );\n    }\n}\n\nMONGO_EXPORT void bson_oid_to_string( const bson_oid_t *oid, char *str ) {\n    static const char hex[16] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n    int i;\n    for ( i=0; i<12; i++ ) {\n        str[2*i]     = hex[( oid->bytes[i] & 0xf0 ) >> 4];\n        str[2*i + 1] = hex[ oid->bytes[i] & 0x0f      ];\n    }\n    str[24] = '\\0';\n}\n\nMONGO_EXPORT void bson_set_oid_fuzz( int ( *func )( void ) ) {\n    oid_fuzz_func = func;\n}\n\nMONGO_EXPORT void bson_set_oid_inc( int ( *func )( void ) ) {\n    oid_inc_func = func;\n}\n\nMONGO_EXPORT void bson_oid_gen( bson_oid_t *oid ) {\n    static int incr = 0;\n    static int fuzz = 0;\n    int i;\n    time_t t = time( NULL );\n\n    if( oid_inc_func )\n        i = oid_inc_func();\n    else\n        i = incr++;\n\n    if ( !fuzz ) {\n        if ( oid_fuzz_func )\n            fuzz = oid_fuzz_func();\n        else {\n            srand( ( int )t );\n            fuzz = rand();\n        }\n    }\n\n    bson_big_endian32( &oid->ints[0], &t );\n    oid->ints[1] = fuzz;\n    bson_big_endian32( &oid->ints[2], &i );\n}\n\nMONGO_EXPORT time_t bson_oid_generated_time( bson_oid_t *oid ) {\n    time_t out;\n    bson_big_endian32( &out, &oid->ints[0] );\n\n    return out;\n}\n\nMONGO_EXPORT void bson_print( const bson *b ) {\n    bson_print_raw( b->data , 0 );\n}\n\nMONGO_EXPORT void bson_print_raw( const char *data , int depth ) {\n    bson_iterator i;\n    const char *key;\n    int temp;\n    bson_timestamp_t ts;\n    char oidhex[25];\n    bson scope;\n    bson_iterator_from_buffer( &i, data );\n\n    while ( bson_iterator_next( &i ) ) {\n        bson_type t = bson_iterator_type( &i );\n        if ( t == 0 )\n            break;\n        key = bson_iterator_key( &i );\n\n        for ( temp=0; temp<=depth; temp++ )\n            bson_printf( \"\\t\" );\n        bson_printf( \"%s : %d \\t \" , key , t );\n        switch ( t ) {\n        case BSON_DOUBLE:\n            bson_printf( \"%f\" , bson_iterator_double( &i ) );\n            break;\n        case BSON_STRING:\n            bson_printf( \"%s\" , bson_iterator_string( &i ) );\n            break;\n        case BSON_SYMBOL:\n            bson_printf( \"SYMBOL: %s\" , bson_iterator_string( &i ) );\n            break;\n        case BSON_OID:\n            bson_oid_to_string( bson_iterator_oid( &i ), oidhex );\n            bson_printf( \"%s\" , oidhex );\n            break;\n        case BSON_BOOL:\n            bson_printf( \"%s\" , bson_iterator_bool( &i ) ? \"true\" : \"false\" );\n            break;\n        case BSON_DATE:\n            bson_printf( \"%ld\" , ( long int )bson_iterator_date( &i ) );\n            break;\n        case BSON_BINDATA:\n            bson_printf( \"BSON_BINDATA\" );\n            break;\n        case BSON_UNDEFINED:\n            bson_printf( \"BSON_UNDEFINED\" );\n            break;\n        case BSON_NULL:\n            bson_printf( \"BSON_NULL\" );\n            break;\n        case BSON_REGEX:\n            bson_printf( \"BSON_REGEX: %s\", bson_iterator_regex( &i ) );\n            break;\n        case BSON_CODE:\n            bson_printf( \"BSON_CODE: %s\", bson_iterator_code( &i ) );\n            break;\n        case BSON_CODEWSCOPE:\n            bson_printf( \"BSON_CODE_W_SCOPE: %s\", bson_iterator_code( &i ) );\n            /* bson_init( &scope ); */ /* review - stepped on by bson_iterator_code_scope? */\n            bson_iterator_code_scope( &i, &scope );\n            bson_printf( \"\\n\\t SCOPE: \" );\n            bson_print( &scope );\n            /* bson_destroy( &scope ); */ /* review - causes free error */\n            break;\n        case BSON_INT:\n            bson_printf( \"%d\" , bson_iterator_int( &i ) );\n            break;\n        case BSON_LONG:\n            bson_printf( \"%lld\" , ( uint64_t )bson_iterator_long( &i ) );\n            break;\n        case BSON_TIMESTAMP:\n            ts = bson_iterator_timestamp( &i );\n            bson_printf( \"i: %d, t: %d\", ts.i, ts.t );\n            break;\n        case BSON_OBJECT:\n        case BSON_ARRAY:\n            bson_printf( \"\\n\" );\n            bson_print_raw( bson_iterator_value( &i ) , depth + 1 );\n            break;\n        default:\n            bson_errprintf( \"can't print type : %d\\n\" , t );\n        }\n        bson_printf( \"\\n\" );\n    }\n}\n\n/* ----------------------------\n   ITERATOR\n   ------------------------------ */\n\nMONGO_EXPORT bson_iterator* bson_iterator_create( void ) {\n    return ( bson_iterator* )malloc( sizeof( bson_iterator ) );\n}\n\nMONGO_EXPORT void bson_iterator_dispose(bson_iterator* i) {\n    free(i);\n}\n\nMONGO_EXPORT void bson_iterator_init( bson_iterator *i, const bson *b ) {\n    i->cur = b->data + 4;\n    i->first = 1;\n}\n\nMONGO_EXPORT void bson_iterator_from_buffer( bson_iterator *i, const char *buffer ) {\n    i->cur = buffer + 4;\n    i->first = 1;\n}\n\nMONGO_EXPORT bson_type bson_find( bson_iterator *it, const bson *obj, const char *name ) {\n    bson_iterator_init( it, (bson *)obj );\n    while( bson_iterator_next( it ) ) {\n        if ( strcmp( name, bson_iterator_key( it ) ) == 0 )\n            break;\n    }\n    return bson_iterator_type( it );\n}\n\nMONGO_EXPORT bson_bool_t bson_iterator_more( const bson_iterator *i ) {\n    return *( i->cur );\n}\n\nMONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i ) {\n    int ds;\n\n    if ( i->first ) {\n        i->first = 0;\n        return ( bson_type )( *i->cur );\n    }\n\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_EOO:\n        return BSON_EOO; /* don't advance */\n    case BSON_UNDEFINED:\n    case BSON_NULL:\n        ds = 0;\n        break;\n    case BSON_BOOL:\n        ds = 1;\n        break;\n    case BSON_INT:\n        ds = 4;\n        break;\n    case BSON_LONG:\n    case BSON_DOUBLE:\n    case BSON_TIMESTAMP:\n    case BSON_DATE:\n        ds = 8;\n        break;\n    case BSON_OID:\n        ds = 12;\n        break;\n    case BSON_STRING:\n    case BSON_SYMBOL:\n    case BSON_CODE:\n        ds = 4 + bson_iterator_int_raw( i );\n        break;\n    case BSON_BINDATA:\n        ds = 5 + bson_iterator_int_raw( i );\n        break;\n    case BSON_OBJECT:\n    case BSON_ARRAY:\n    case BSON_CODEWSCOPE:\n        ds = bson_iterator_int_raw( i );\n        break;\n    case BSON_DBREF:\n        ds = 4+12 + bson_iterator_int_raw( i );\n        break;\n    case BSON_REGEX: {\n        const char *s = bson_iterator_value( i );\n        const char *p = s;\n        p += strlen( p )+1;\n        p += strlen( p )+1;\n        ds = p-s;\n        break;\n    }\n\n    default: {\n        char msg[] = \"unknown type: 000000000000\";\n        bson_numstr( msg+14, ( unsigned )( i->cur[0] ) );\n        bson_fatal_msg( 0, msg );\n        return 0;\n    }\n    }\n\n    i->cur += 1 + strlen( i->cur + 1 ) + 1 + ds;\n\n    return ( bson_type )( *i->cur );\n}\n\nMONGO_EXPORT bson_type bson_iterator_type( const bson_iterator *i ) {\n    return ( bson_type )i->cur[0];\n}\n\nMONGO_EXPORT const char *bson_iterator_key( const bson_iterator *i ) {\n    return i->cur + 1;\n}\n\nMONGO_EXPORT const char *bson_iterator_value( const bson_iterator *i ) {\n    const char *t = i->cur + 1;\n    t += strlen( t ) + 1;\n    return t;\n}\n\n/* types */\n\nint bson_iterator_int_raw( const bson_iterator *i ) {\n    int out;\n    bson_little_endian32( &out, bson_iterator_value( i ) );\n    return out;\n}\n\ndouble bson_iterator_double_raw( const bson_iterator *i ) {\n    double out;\n    bson_little_endian64( &out, bson_iterator_value( i ) );\n    return out;\n}\n\nint64_t bson_iterator_long_raw( const bson_iterator *i ) {\n    int64_t out;\n    bson_little_endian64( &out, bson_iterator_value( i ) );\n    return out;\n}\n\nbson_bool_t bson_iterator_bool_raw( const bson_iterator *i ) {\n    return bson_iterator_value( i )[0];\n}\n\nMONGO_EXPORT bson_oid_t *bson_iterator_oid( const bson_iterator *i ) {\n    return ( bson_oid_t * )bson_iterator_value( i );\n}\n\nMONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}\n\nMONGO_EXPORT double bson_iterator_double( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}\n\nMONGO_EXPORT int64_t bson_iterator_long( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}\n\nMONGO_EXPORT bson_timestamp_t bson_iterator_timestamp( const bson_iterator *i ) {\n    bson_timestamp_t ts;\n    bson_little_endian32( &( ts.i ), bson_iterator_value( i ) );\n    bson_little_endian32( &( ts.t ), bson_iterator_value( i ) + 4 );\n    return ts;\n}\n\n\nMONGO_EXPORT int bson_iterator_timestamp_time( const bson_iterator *i ) {\n    int time;\n    bson_little_endian32( &time, bson_iterator_value( i ) + 4 );\n    return time;\n}\n\n\nMONGO_EXPORT int bson_iterator_timestamp_increment( const bson_iterator *i ) {\n    int increment;\n    bson_little_endian32( &increment, bson_iterator_value( i ) );\n    return increment;\n}\n\n\nMONGO_EXPORT bson_bool_t bson_iterator_bool( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_BOOL:\n        return bson_iterator_bool_raw( i );\n    case BSON_INT:\n        return bson_iterator_int_raw( i ) != 0;\n    case BSON_LONG:\n        return bson_iterator_long_raw( i ) != 0;\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i ) != 0;\n    case BSON_EOO:\n    case BSON_NULL:\n        return 0;\n    default:\n        return 1;\n    }\n}\n\nMONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_STRING:\n    case BSON_SYMBOL:\n        return bson_iterator_value( i ) + 4;\n    default:\n        return \"\";\n    }\n}\n\nint bson_iterator_string_len( const bson_iterator *i ) {\n    return bson_iterator_int_raw( i );\n}\n\nMONGO_EXPORT const char *bson_iterator_code( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_STRING:\n    case BSON_CODE:\n        return bson_iterator_value( i ) + 4;\n    case BSON_CODEWSCOPE:\n        return bson_iterator_value( i ) + 8;\n    default:\n        return NULL;\n    }\n}\n\nMONGO_EXPORT void bson_iterator_code_scope( const bson_iterator *i, bson *scope ) {\n    if ( bson_iterator_type( i ) == BSON_CODEWSCOPE ) {\n        int code_len;\n        bson_little_endian32( &code_len, bson_iterator_value( i )+4 );\n        bson_init_data( scope, ( void * )( bson_iterator_value( i )+8+code_len ) );\n        _bson_reset( scope );\n        scope->finished = 1;\n    }\n    else {\n        bson_empty( scope );\n    }\n}\n\nMONGO_EXPORT bson_date_t bson_iterator_date( const bson_iterator *i ) {\n    return bson_iterator_long_raw( i );\n}\n\nMONGO_EXPORT time_t bson_iterator_time_t( const bson_iterator *i ) {\n    return bson_iterator_date( i ) / 1000;\n}\n\nMONGO_EXPORT int bson_iterator_bin_len( const bson_iterator *i ) {\n    return ( bson_iterator_bin_type( i ) == BSON_BIN_BINARY_OLD )\n           ? bson_iterator_int_raw( i ) - 4\n           : bson_iterator_int_raw( i );\n}\n\nMONGO_EXPORT char bson_iterator_bin_type( const bson_iterator *i ) {\n    return bson_iterator_value( i )[4];\n}\n\nMONGO_EXPORT const char *bson_iterator_bin_data( const bson_iterator *i ) {\n    return ( bson_iterator_bin_type( i ) == BSON_BIN_BINARY_OLD )\n           ? bson_iterator_value( i ) + 9\n           : bson_iterator_value( i ) + 5;\n}\n\nMONGO_EXPORT const char *bson_iterator_regex( const bson_iterator *i ) {\n    return bson_iterator_value( i );\n}\n\nMONGO_EXPORT const char *bson_iterator_regex_opts( const bson_iterator *i ) {\n    const char *p = bson_iterator_value( i );\n    return p + strlen( p ) + 1;\n\n}\n\nMONGO_EXPORT void bson_iterator_subobject( const bson_iterator *i, bson *sub ) {\n    bson_init_data( sub, ( char * )bson_iterator_value( i ) );\n    _bson_reset( sub );\n    sub->finished = 1;\n}\n\nMONGO_EXPORT void bson_iterator_subiterator( const bson_iterator *i, bson_iterator *sub ) {\n    bson_iterator_from_buffer( sub, bson_iterator_value( i ) );\n}\n\n/* ----------------------------\n   BUILDING\n   ------------------------------ */\n\nstatic void _bson_init_size( bson *b, int size ) {\n    if( size == 0 )\n        b->data = NULL;\n    else\n        b->data = ( char * )bson_malloc( size );\n    b->dataSize = size;\n    b->cur = b->data + 4;\n    _bson_reset( b );\n}\n\nMONGO_EXPORT void bson_init( bson *b ) {\n    _bson_init_size( b, initialBufferSize );\n}\n\nvoid bson_init_size( bson *b, int size ) {\n    _bson_init_size( b, size );\n}\n\nstatic void bson_append_byte( bson *b, char c ) {\n    b->cur[0] = c;\n    b->cur++;\n}\n\nstatic void bson_append( bson *b, const void *data, int len ) {\n    memcpy( b->cur , data , len );\n    b->cur += len;\n}\n\nstatic void bson_append32( bson *b, const void *data ) {\n    bson_little_endian32( b->cur, data );\n    b->cur += 4;\n}\n\nstatic void bson_append64( bson *b, const void *data ) {\n    bson_little_endian64( b->cur, data );\n    b->cur += 8;\n}\n\nint bson_ensure_space( bson *b, const int bytesNeeded ) {\n    int pos = b->cur - b->data;\n    char *orig = b->data;\n    int new_size;\n\n    if ( pos + bytesNeeded <= b->dataSize )\n        return BSON_OK;\n\n    new_size = 1.5 * ( b->dataSize + bytesNeeded );\n\n    if( new_size < b->dataSize ) {\n        if( ( b->dataSize + bytesNeeded ) < INT_MAX )\n            new_size = INT_MAX;\n        else {\n            b->err = BSON_SIZE_OVERFLOW;\n            return BSON_ERROR;\n        }\n    }\n\n    b->data = bson_realloc( b->data, new_size );\n    if ( !b->data )\n        bson_fatal_msg( !!b->data, \"realloc() failed\" );\n\n    b->dataSize = new_size;\n    b->cur += b->data - orig;\n\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_finish( bson *b ) {\n    int i;\n\n    if( b->err & BSON_NOT_UTF8 )\n        return BSON_ERROR;\n\n    if ( ! b->finished ) {\n        if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n        bson_append_byte( b, 0 );\n        i = b->cur - b->data;\n        bson_little_endian32( b->data, &i );\n        b->finished = 1;\n    }\n\n    return BSON_OK;\n}\n\nMONGO_EXPORT void bson_destroy( bson *b ) {\n    if (b) {\n        bson_free( b->data );\n        b->err = 0;\n        b->data = 0;\n        b->cur = 0;\n        b->finished = 1;\n    }\n}\n\nstatic int bson_append_estart( bson *b, int type, const char *name, const int dataSize ) {\n    const int len = strlen( name ) + 1;\n\n    if ( b->finished ) {\n        b->err |= BSON_ALREADY_FINISHED;\n        return BSON_ERROR;\n    }\n\n    if ( bson_ensure_space( b, 1 + len + dataSize ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n\n    if( bson_check_field_name( b, ( const char * )name, len - 1 ) == BSON_ERROR ) {\n        bson_builder_error( b );\n        return BSON_ERROR;\n    }\n\n    bson_append_byte( b, ( char )type );\n    bson_append( b, name, len );\n    return BSON_OK;\n}\n\n/* ----------------------------\n   BUILDING TYPES\n   ------------------------------ */\n\nMONGO_EXPORT int bson_append_int( bson *b, const char *name, const int i ) {\n    if ( bson_append_estart( b, BSON_INT, name, 4 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append32( b , &i );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_long( bson *b, const char *name, const int64_t i ) {\n    if ( bson_append_estart( b , BSON_LONG, name, 8 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append64( b , &i );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_double( bson *b, const char *name, const double d ) {\n    if ( bson_append_estart( b, BSON_DOUBLE, name, 8 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append64( b , &d );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_bool( bson *b, const char *name, const bson_bool_t i ) {\n    if ( bson_append_estart( b, BSON_BOOL, name, 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append_byte( b , i != 0 );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_null( bson *b, const char *name ) {\n    if ( bson_append_estart( b , BSON_NULL, name, 0 ) == BSON_ERROR )\n        return BSON_ERROR;\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_undefined( bson *b, const char *name ) {\n    if ( bson_append_estart( b, BSON_UNDEFINED, name, 0 ) == BSON_ERROR )\n        return BSON_ERROR;\n    return BSON_OK;\n}\n\nstatic int bson_append_string_base( bson *b, const char *name,\n                                    const char *value, int len, bson_type type ) {\n\n    int sl = len + 1;\n    if ( bson_check_string( b, ( const char * )value, sl - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_append_estart( b, type, name, 4 + sl ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n    bson_append32( b , &sl );\n    bson_append( b , value , sl - 1 );\n    bson_append( b , \"\\0\" , 1 );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_string( bson *b, const char *name, const char *value ) {\n    return bson_append_string_base( b, name, value, strlen ( value ), BSON_STRING );\n}\n\nMONGO_EXPORT int bson_append_symbol( bson *b, const char *name, const char *value ) {\n    return bson_append_string_base( b, name, value, strlen ( value ), BSON_SYMBOL );\n}\n\nMONGO_EXPORT int bson_append_code( bson *b, const char *name, const char *value ) {\n    return bson_append_string_base( b, name, value, strlen ( value ), BSON_CODE );\n}\n\nMONGO_EXPORT int bson_append_string_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_STRING );\n}\n\nMONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}\n\nMONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_CODE );\n}\n\nMONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,\n        const char *code, int len, const bson *scope ) {\n\n    int sl, size;\n    if ( !scope ) return BSON_ERROR;\n    sl = len + 1;\n    size = 4 + 4 + sl + bson_size( scope );\n    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append32( b, &size );\n    bson_append32( b, &sl );\n    bson_append( b, code, sl );\n    bson_append( b, scope->data, bson_size( scope ) );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_code_w_scope( bson *b, const char *name, const char *code, const bson *scope ) {\n    return bson_append_code_w_scope_n( b, name, code, strlen ( code ), scope );\n}\n\nMONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &subtwolen );\n        bson_append_byte( b, type );\n        bson_append32( b, &len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_oid( bson *b, const char *name, const bson_oid_t *oid ) {\n    if ( bson_append_estart( b, BSON_OID, name, 12 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , oid , 12 );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_new_oid( bson *b, const char *name ) {\n    bson_oid_t oid;\n    bson_oid_gen( &oid );\n    return bson_append_oid( b, name, &oid );\n}\n\nMONGO_EXPORT int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts ) {\n    const int plen = strlen( pattern )+1;\n    const int olen = strlen( opts )+1;\n    if ( bson_append_estart( b, BSON_REGEX, name, plen + olen ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_check_string( b, pattern, plen - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , pattern , plen );\n    bson_append( b , opts , olen );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_bson( bson *b, const char *name, const bson *bson ) {\n    if ( !bson ) return BSON_ERROR;\n    if ( bson_append_estart( b, BSON_OBJECT, name, bson_size( bson ) ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , bson->data , bson_size( bson ) );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem ) {\n    bson_iterator next = *elem;\n    int size;\n\n    bson_iterator_next( &next );\n    size = next.cur - elem->cur;\n\n    if ( name_or_null == NULL ) {\n        if( bson_ensure_space( b, size ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append( b, elem->cur, size );\n    }\n    else {\n        int data_size = size - 2 - strlen( bson_iterator_key( elem ) );\n        bson_append_estart( b, elem->cur[0], name_or_null, data_size );\n        bson_append( b, bson_iterator_value( elem ), data_size );\n    }\n\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_timestamp( bson *b, const char *name, bson_timestamp_t *ts ) {\n    if ( bson_append_estart( b, BSON_TIMESTAMP, name, 8 ) == BSON_ERROR ) return BSON_ERROR;\n\n    bson_append32( b , &( ts->i ) );\n    bson_append32( b , &( ts->t ) );\n\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_timestamp2( bson *b, const char *name, int time, int increment ) {\n    if ( bson_append_estart( b, BSON_TIMESTAMP, name, 8 ) == BSON_ERROR ) return BSON_ERROR;\n\n    bson_append32( b , &increment );\n    bson_append32( b , &time );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_date( bson *b, const char *name, bson_date_t millis ) {\n    if ( bson_append_estart( b, BSON_DATE, name, 8 ) == BSON_ERROR ) return BSON_ERROR;\n    bson_append64( b , &millis );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_time_t( bson *b, const char *name, time_t secs ) {\n    return bson_append_date( b, name, ( bson_date_t )secs * 1000 );\n}\n\nMONGO_EXPORT int bson_append_start_object( bson *b, const char *name ) {\n    if ( bson_append_estart( b, BSON_OBJECT, name, 5 ) == BSON_ERROR ) return BSON_ERROR;\n    b->stack[ b->stackPos++ ] = b->cur - b->data;\n    bson_append32( b , &zero );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_start_array( bson *b, const char *name ) {\n    if ( bson_append_estart( b, BSON_ARRAY, name, 5 ) == BSON_ERROR ) return BSON_ERROR;\n    b->stack[ b->stackPos++ ] = b->cur - b->data;\n    bson_append32( b , &zero );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_finish_object( bson *b ) {\n    char *start;\n    int i;\n    if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n    bson_append_byte( b , 0 );\n\n    start = b->data + b->stack[ --b->stackPos ];\n    i = b->cur - start;\n    bson_little_endian32( start, &i );\n\n    return BSON_OK;\n}\n\nMONGO_EXPORT double bson_int64_to_double( int64_t i64 ) {\n    return (double)i64;\n}\n\nMONGO_EXPORT int bson_append_finish_array( bson *b ) {\n    return bson_append_finish_object( b );\n}\n\n/* Error handling and allocators. */\n\nstatic bson_err_handler err_handler = NULL;\n\nMONGO_EXPORT bson_err_handler set_bson_err_handler( bson_err_handler func ) {\n    bson_err_handler old = err_handler;\n    err_handler = func;\n    return old;\n}\n\nMONGO_EXPORT void bson_free( void *ptr ) {\n    bson_free_func( ptr );\n}\n\nMONGO_EXPORT void *bson_malloc( int size ) {\n    void *p;\n    p = bson_malloc_func( size );\n    bson_fatal_msg( !!p, \"malloc() failed\" );\n    return p;\n}\n\nvoid *bson_realloc( void *ptr, int size ) {\n    void *p;\n    p = bson_realloc_func( ptr, size );\n    bson_fatal_msg( !!p, \"realloc() failed\" );\n    return p;\n}\n\nint _bson_errprintf( const char *format, ... ) {\n    va_list ap;\n    int ret = 0;\n    va_start( ap, format );\n#ifndef R_SAFETY_NET\n    ret = vfprintf( stderr, format, ap );\n#endif\n    va_end( ap );\n\n    return ret;\n}\n\n/**\n * This method is invoked when a non-fatal bson error is encountered.\n * Calls the error handler if available.\n *\n *  @param\n */\nvoid bson_builder_error( bson *b ) {\n    if( err_handler )\n        err_handler( \"BSON error.\" );\n}\n\nvoid bson_fatal( int ok ) {\n    bson_fatal_msg( ok, \"\" );\n}\n\nvoid bson_fatal_msg( int ok , const char *msg ) {\n    if ( ok )\n        return;\n\n    if ( err_handler ) {\n        err_handler( msg );\n    }\n#ifndef R_SAFETY_NET\n    bson_errprintf( \"error: %s\\n\" , msg );\n    exit( -5 );\n#endif\n}\n\n\n/* Efficiently copy an integer to a string. */\nextern const char bson_numstrs[1000][4];\n\nvoid bson_numstr( char *str, int i ) {\n    if( i < 1000 )\n        memcpy( str, bson_numstrs[i], 4 );\n    else\n        bson_sprintf( str,\"%d\", i );\n}\n\nMONGO_EXPORT void bson_swap_endian64( void *outp, const void *inp ) {\n    const char *in = ( const char * )inp;\n    char *out = ( char * )outp;\n\n    out[0] = in[7];\n    out[1] = in[6];\n    out[2] = in[5];\n    out[3] = in[4];\n    out[4] = in[3];\n    out[5] = in[2];\n    out[6] = in[1];\n    out[7] = in[0];\n\n}\n\nMONGO_EXPORT void bson_swap_endian32( void *outp, const void *inp ) {\n    const char *in = ( const char * )inp;\n    char *out = ( char * )outp;\n\n    out[0] = in[3];\n    out[1] = in[2];\n    out[2] = in[1];\n    out[3] = in[0];\n}\n", "/**\n * @file bson.h\n * @brief BSON Declarations\n */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#ifndef BSON_H_\n#define BSON_H_\n\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n\n#ifdef __GNUC__\n#define MONGO_INLINE static __inline__\n#define MONGO_EXPORT\n#else\n#define MONGO_INLINE static\n#ifdef MONGO_STATIC_BUILD\n#define MONGO_EXPORT\n#elif defined(MONGO_DLL_BUILD)\n#define MONGO_EXPORT __declspec(dllexport)\n#else\n#define MONGO_EXPORT __declspec(dllimport)\n#endif\n#endif\n\n#ifdef __cplusplus\n#define MONGO_EXTERN_C_START extern \"C\" {\n#define MONGO_EXTERN_C_END }\n#else\n#define MONGO_EXTERN_C_START\n#define MONGO_EXTERN_C_END\n#endif\n\n#if defined(MONGO_HAVE_STDINT) || __STDC_VERSION__ >= 199901L\n#include <stdint.h>\n#elif defined(MONGO_HAVE_UNISTD)\n#include <unistd.h>\n#elif defined(MONGO_USE__INT64)\ntypedef __int64 int64_t;\ntypedef unsigned __int64 uint64_t;\n#elif defined(MONGO_USE_LONG_LONG_INT)\ntypedef long long int int64_t;\ntypedef unsigned long long int uint64_t;\n#else\n#error Must compile with c99 or define MONGO_HAVE_STDINT, MONGO_HAVE_UNISTD, MONGO_USE__INT64, or MONGO_USE_LONG_LONG_INT.\n#endif\n\n#ifdef MONGO_BIG_ENDIAN\n#define bson_little_endian64(out, in) ( bson_swap_endian64(out, in) )\n#define bson_little_endian32(out, in) ( bson_swap_endian32(out, in) )\n#define bson_big_endian64(out, in) ( memcpy(out, in, 8) )\n#define bson_big_endian32(out, in) ( memcpy(out, in, 4) )\n#else\n#define bson_little_endian64(out, in) ( memcpy(out, in, 8) )\n#define bson_little_endian32(out, in) ( memcpy(out, in, 4) )\n#define bson_big_endian64(out, in) ( bson_swap_endian64(out, in) )\n#define bson_big_endian32(out, in) ( bson_swap_endian32(out, in) )\n#endif\n\nMONGO_EXTERN_C_START\n\n#define BSON_OK 0\n#define BSON_ERROR -1\n\nenum bson_error_t {\n    BSON_SIZE_OVERFLOW = 1 /**< Trying to create a BSON object larger than INT_MAX. */\n};\n\nenum bson_validity_t {\n    BSON_VALID = 0,                 /**< BSON is valid and UTF-8 compliant. */\n    BSON_NOT_UTF8 = ( 1<<1 ),       /**< A key or a string is not valid UTF-8. */\n    BSON_FIELD_HAS_DOT = ( 1<<2 ),  /**< Warning: key contains '.' character. */\n    BSON_FIELD_INIT_DOLLAR = ( 1<<3 ), /**< Warning: key starts with '$' character. */\n    BSON_ALREADY_FINISHED = ( 1<<4 )  /**< Trying to modify a finished BSON object. */\n};\n\nenum bson_binary_subtype_t {\n    BSON_BIN_BINARY = 0,\n    BSON_BIN_FUNC = 1,\n    BSON_BIN_BINARY_OLD = 2,\n    BSON_BIN_UUID = 3,\n    BSON_BIN_MD5 = 5,\n    BSON_BIN_USER = 128\n};\n\ntypedef enum {\n    BSON_EOO = 0,\n    BSON_DOUBLE = 1,\n    BSON_STRING = 2,\n    BSON_OBJECT = 3,\n    BSON_ARRAY = 4,\n    BSON_BINDATA = 5,\n    BSON_UNDEFINED = 6,\n    BSON_OID = 7,\n    BSON_BOOL = 8,\n    BSON_DATE = 9,\n    BSON_NULL = 10,\n    BSON_REGEX = 11,\n    BSON_DBREF = 12, /**< Deprecated. */\n    BSON_CODE = 13,\n    BSON_SYMBOL = 14,\n    BSON_CODEWSCOPE = 15,\n    BSON_INT = 16,\n    BSON_TIMESTAMP = 17,\n    BSON_LONG = 18\n} bson_type;\n\ntypedef int bson_bool_t;\n\ntypedef struct {\n    const char *cur;\n    bson_bool_t first;\n} bson_iterator;\n\ntypedef struct {\n    char *data;    /**< Pointer to a block of data in this BSON object. */\n    char *cur;     /**< Pointer to the current position. */\n    int dataSize;  /**< The number of bytes allocated to char *data. */\n    bson_bool_t finished; /**< When finished, the BSON object can no longer be modified. */\n    int stack[32];        /**< A stack used to keep track of nested BSON elements. */\n    int stackPos;         /**< Index of current stack position. */\n    int err; /**< Bitfield representing errors or warnings on this buffer */\n    char *errstr; /**< A string representation of the most recent error or warning. */\n} bson;\n\n#pragma pack(1)\ntypedef union {\n    char bytes[12];\n    int ints[3];\n} bson_oid_t;\n#pragma pack()\n\ntypedef int64_t bson_date_t; /* milliseconds since epoch UTC */\n\ntypedef struct {\n    int i; /* increment */\n    int t; /* time in seconds */\n} bson_timestamp_t;\n\n/* ----------------------------\n   READING\n   ------------------------------ */\n\nMONGO_EXPORT bson* bson_create( void );\nMONGO_EXPORT void  bson_dispose(bson* b);\n\n/**\n * Size of a BSON object.\n *\n * @param b the BSON object.\n *\n * @return the size.\n */\nMONGO_EXPORT int bson_size( const bson *b );\nMONGO_EXPORT int bson_buffer_size( const bson *b );\n\n/**\n * Print a string representation of a BSON object.\n *\n * @param b the BSON object to print.\n */\nMONGO_EXPORT void bson_print( const bson *b );\n\n/**\n * Return a pointer to the raw buffer stored by this bson object.\n *\n * @param b a BSON object\n */\nMONGO_EXPORT const char *bson_data( const bson *b );\n\n/**\n * Print a string representation of a BSON object.\n *\n * @param bson the raw data to print.\n * @param depth the depth to recurse the object.x\n */\nMONGO_EXPORT void bson_print_raw( const char *bson , int depth );\n\n/**\n * Advance a bson_iterator to the named field.\n *\n * @param it the bson_iterator to use.\n * @param obj the BSON object to use.\n * @param name the name of the field to find.\n *\n * @return the type of the found object or BSON_EOO if it is not found.\n */\nMONGO_EXPORT bson_type bson_find( bson_iterator *it, const bson *obj, const char *name );\n\n\nMONGO_EXPORT bson_iterator* bson_iterator_create( void );\nMONGO_EXPORT void bson_iterator_dispose(bson_iterator*);\n/**\n * Initialize a bson_iterator.\n *\n * @param i the bson_iterator to initialize.\n * @param bson the BSON object to associate with the iterator.\n */\nMONGO_EXPORT void bson_iterator_init( bson_iterator *i , const bson *b );\n\n/**\n * Initialize a bson iterator from a const char* buffer. Note\n * that this is mostly used internally.\n *\n * @param i the bson_iterator to initialize.\n * @param buffer the buffer to point to.\n */\nMONGO_EXPORT void bson_iterator_from_buffer( bson_iterator *i, const char *buffer );\n\n/* more returns true for eoo. best to loop with bson_iterator_next(&it) */\n/**\n * Check to see if the bson_iterator has more data.\n *\n * @param i the iterator.\n *\n * @return  returns true if there is more data.\n */\nMONGO_EXPORT bson_bool_t bson_iterator_more( const bson_iterator *i );\n\n/**\n * Point the iterator at the next BSON object.\n *\n * @param i the bson_iterator.\n *\n * @return the type of the next BSON object.\n */\nMONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i );\n\n/**\n * Get the type of the BSON object currently pointed to by the iterator.\n *\n * @param i the bson_iterator\n *\n * @return  the type of the current BSON object.\n */\nMONGO_EXPORT bson_type bson_iterator_type( const bson_iterator *i );\n\n/**\n * Get the key of the BSON object currently pointed to by the iterator.\n *\n * @param i the bson_iterator\n *\n * @return the key of the current BSON object.\n */\nMONGO_EXPORT const char *bson_iterator_key( const bson_iterator *i );\n\n/**\n * Get the value of the BSON object currently pointed to by the iterator.\n *\n * @param i the bson_iterator\n *\n * @return  the value of the current BSON object.\n */\nMONGO_EXPORT const char *bson_iterator_value( const bson_iterator *i );\n\n/* these convert to the right type (return 0 if non-numeric) */\n/**\n * Get the double value of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return  the value of the current BSON object.\n */\nMONGO_EXPORT double bson_iterator_double( const bson_iterator *i );\n\n/**\n * Get the int value of the BSON object currently pointed to by the iterator.\n *\n * @param i the bson_iterator\n *\n * @return  the value of the current BSON object.\n */\nMONGO_EXPORT int bson_iterator_int( const bson_iterator *i );\n\n/**\n * Get the long value of the BSON object currently pointed to by the iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nMONGO_EXPORT int64_t bson_iterator_long( const bson_iterator *i );\n\n/* return the bson timestamp as a whole or in parts */\n/**\n * Get the timestamp value of the BSON object currently pointed to by\n * the iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nMONGO_EXPORT bson_timestamp_t bson_iterator_timestamp( const bson_iterator *i );\nMONGO_EXPORT int bson_iterator_timestamp_time( const bson_iterator *i );\nMONGO_EXPORT int bson_iterator_timestamp_increment( const bson_iterator *i );\n\n/**\n * Get the boolean value of the BSON object currently pointed to by\n * the iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\n/* false: boolean false, 0 in any type, or null */\n/* true: anything else (even empty strings and objects) */\nMONGO_EXPORT bson_bool_t bson_iterator_bool( const bson_iterator *i );\n\n/**\n * Get the double value of the BSON object currently pointed to by the\n * iterator. Assumes the correct type is used.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\n/* these assume you are using the right type */\ndouble bson_iterator_double_raw( const bson_iterator *i );\n\n/**\n * Get the int value of the BSON object currently pointed to by the\n * iterator. Assumes the correct type is used.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nint bson_iterator_int_raw( const bson_iterator *i );\n\n/**\n * Get the long value of the BSON object currently pointed to by the\n * iterator. Assumes the correct type is used.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nint64_t bson_iterator_long_raw( const bson_iterator *i );\n\n/**\n * Get the bson_bool_t value of the BSON object currently pointed to by the\n * iterator. Assumes the correct type is used.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nbson_bool_t bson_iterator_bool_raw( const bson_iterator *i );\n\n/**\n * Get the bson_oid_t value of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nMONGO_EXPORT bson_oid_t *bson_iterator_oid( const bson_iterator *i );\n\n/**\n * Get the string value of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return  the value of the current BSON object.\n */\n/* these can also be used with bson_code and bson_symbol*/\nMONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i );\n\n/**\n * Get the string length of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the length of the current BSON object.\n */\nint bson_iterator_string_len( const bson_iterator *i );\n\n/**\n * Get the code value of the BSON object currently pointed to by the\n * iterator. Works with bson_code, bson_codewscope, and BSON_STRING\n * returns NULL for everything else.\n *\n * @param i the bson_iterator\n *\n * @return the code value of the current BSON object.\n */\n/* works with bson_code, bson_codewscope, and BSON_STRING */\n/* returns NULL for everything else */\nMONGO_EXPORT const char *bson_iterator_code( const bson_iterator *i );\n\n/**\n * Calls bson_empty on scope if not a bson_codewscope\n *\n * @param i the bson_iterator.\n * @param scope the bson scope.\n */\n/* calls bson_empty on scope if not a bson_codewscope */\nMONGO_EXPORT void bson_iterator_code_scope( const bson_iterator *i, bson *scope );\n\n/**\n * Get the date value of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the date value of the current BSON object.\n */\n/* both of these only work with bson_date */\nMONGO_EXPORT bson_date_t bson_iterator_date( const bson_iterator *i );\n\n/**\n * Get the time value of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the time value of the current BSON object.\n */\nMONGO_EXPORT time_t bson_iterator_time_t( const bson_iterator *i );\n\n/**\n * Get the length of the BSON binary object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the length of the current BSON binary object.\n */\nMONGO_EXPORT int bson_iterator_bin_len( const bson_iterator *i );\n\n/**\n * Get the type of the BSON binary object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the type of the current BSON binary object.\n */\nMONGO_EXPORT char bson_iterator_bin_type( const bson_iterator *i );\n\n/**\n * Get the value of the BSON binary object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON binary object.\n */\nMONGO_EXPORT const char *bson_iterator_bin_data( const bson_iterator *i );\n\n/**\n * Get the value of the BSON regex object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON regex object.\n */\nMONGO_EXPORT const char *bson_iterator_regex( const bson_iterator *i );\n\n/**\n * Get the options of the BSON regex object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator.\n *\n * @return the options of the current BSON regex object.\n */\nMONGO_EXPORT const char *bson_iterator_regex_opts( const bson_iterator *i );\n\n/* these work with BSON_OBJECT and BSON_ARRAY */\n/**\n * Get the BSON subobject currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator.\n * @param sub the BSON subobject destination.\n */\nMONGO_EXPORT void bson_iterator_subobject( const bson_iterator *i, bson *sub );\n\n/**\n * Get a bson_iterator that on the BSON subobject.\n *\n * @param i the bson_iterator.\n * @param sub the iterator to point at the BSON subobject.\n */\nMONGO_EXPORT void bson_iterator_subiterator( const bson_iterator *i, bson_iterator *sub );\n\n/* str must be at least 24 hex chars + null byte */\n/**\n * Create a bson_oid_t from a string.\n *\n * @param oid the bson_oid_t destination.\n * @param str a null terminated string comprised of at least 24 hex chars.\n */\nMONGO_EXPORT void bson_oid_from_string( bson_oid_t *oid, const char *str );\n\n/**\n * Create a string representation of the bson_oid_t.\n *\n * @param oid the bson_oid_t source.\n * @param str the string representation destination.\n */\nMONGO_EXPORT void bson_oid_to_string( const bson_oid_t *oid, char *str );\n\n/**\n * Create a bson_oid object.\n *\n * @param oid the destination for the newly created bson_oid_t.\n */\nMONGO_EXPORT void bson_oid_gen( bson_oid_t *oid );\n\n/**\n * Set a function to be used to generate the second four bytes\n * of an object id.\n *\n * @param func a pointer to a function that returns an int.\n */\nMONGO_EXPORT void bson_set_oid_fuzz( int ( *func )( void ) );\n\n/**\n * Set a function to be used to generate the incrementing part\n * of an object id (last four bytes). If you need thread-safety\n * in generating object ids, you should set this function.\n *\n * @param func a pointer to a function that returns an int.\n */\nMONGO_EXPORT void bson_set_oid_inc( int ( *func )( void ) );\n\n/**\n * Get the time a bson_oid_t was created.\n *\n * @param oid the bson_oid_t.\n */\nMONGO_EXPORT time_t bson_oid_generated_time( bson_oid_t *oid ); /* Gives the time the OID was created */\n\n/* ----------------------------\n   BUILDING\n   ------------------------------ */\n\n/**\n *  Initialize a new bson object. If not created\n *  with bson_new, you must initialize each new bson\n *  object using this function.\n *\n *  @note When finished, you must pass the bson object to\n *      bson_destroy( ).\n */\nMONGO_EXPORT void bson_init( bson *b );\n\n/**\n * Initialize a BSON object, and point its data\n * pointer to the provided char*.\n *\n * @param b the BSON object to initialize.\n * @param data the raw BSON data.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nint bson_init_data( bson *b , char *data );\nint bson_init_finished_data( bson *b, char *data ) ;\n\n/**\n * Initialize a BSON object, and set its\n * buffer to the given size.\n *\n * @param b the BSON object to initialize.\n * @param size the initial size of the buffer.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nvoid bson_init_size( bson *b, int size );\n\n/**\n * Grow a bson object.\n *\n * @param b the bson to grow.\n * @param bytesNeeded the additional number of bytes needed.\n *\n * @return BSON_OK or BSON_ERROR with the bson error object set.\n *   Exits if allocation fails.\n */\nint bson_ensure_space( bson *b, const int bytesNeeded );\n\n/**\n * Finalize a bson object.\n *\n * @param b the bson object to finalize.\n *\n * @return the standard error code. To deallocate memory,\n *   call bson_destroy on the bson object.\n */\nMONGO_EXPORT int bson_finish( bson *b );\n\n/**\n * Destroy a bson object.\n *\n * @param b the bson object to destroy.\n *\n */\nMONGO_EXPORT void bson_destroy( bson *b );\n\n/**\n * Returns a pointer to a static empty BSON object.\n *\n * @param obj the BSON object to initialize.\n *\n * @return the empty initialized BSON object.\n */\n/* returns pointer to static empty bson object */\nMONGO_EXPORT bson *bson_empty( bson *obj );\n\n/**\n * Make a complete copy of the a BSON object.\n * The source bson object must be in a finished\n * state; otherwise, the copy will fail.\n *\n * @param out the copy destination BSON object.\n * @param in the copy source BSON object.\n */\nMONGO_EXPORT int bson_copy( bson *out, const bson *in ); /* puts data in new buffer. NOOP if out==NULL */\n\n/**\n * Append a previously created bson_oid_t to a bson object.\n *\n * @param b the bson to append to.\n * @param name the key for the bson_oid_t.\n * @param oid the bson_oid_t to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_oid( bson *b, const char *name, const bson_oid_t *oid );\n\n/**\n * Append a bson_oid_t to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the bson_oid_t.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_new_oid( bson *b, const char *name );\n\n/**\n * Append an int to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the int.\n * @param i the int to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_int( bson *b, const char *name, const int i );\n\n/**\n * Append an long to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the long.\n * @param i the long to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_long( bson *b, const char *name, const int64_t i );\n\n/**\n * Append an double to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the double.\n * @param d the double to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_double( bson *b, const char *name, const double d );\n\n/**\n * Append a string to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the string.\n * @param str the string to append.\n *\n * @return BSON_OK or BSON_ERROR.\n*/\nMONGO_EXPORT int bson_append_string( bson *b, const char *name, const char *str );\n\n/**\n * Append len bytes of a string to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the string.\n * @param str the string to append.\n * @param len the number of bytes from str to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_string_n( bson *b, const char *name, const char *str, int len );\n\n/**\n * Append a symbol to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the symbol.\n * @param str the symbol to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_symbol( bson *b, const char *name, const char *str );\n\n/**\n * Append len bytes of a symbol to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the symbol.\n * @param str the symbol to append.\n * @param len the number of bytes from str to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *str, int len );\n\n/**\n * Append code to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the code.\n * @param str the code to append.\n * @param len the number of bytes from str to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_code( bson *b, const char *name, const char *str );\n\n/**\n * Append len bytes of code to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the code.\n * @param str the code to append.\n * @param len the number of bytes from str to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *str, int len );\n\n/**\n * Append code to a bson with scope.\n *\n * @param b the bson to append to.\n * @param name the key for the code.\n * @param str the string to append.\n * @param scope a BSON object containing the scope.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_code_w_scope( bson *b, const char *name, const char *code, const bson *scope );\n\n/**\n * Append len bytes of code to a bson with scope.\n *\n * @param b the bson to append to.\n * @param name the key for the code.\n * @param str the string to append.\n * @param len the number of bytes from str to append.\n * @param scope a BSON object containing the scope.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name, const char *code, int size, const bson *scope );\n\n/**\n * Append binary data to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the data.\n * @param type the binary data type.\n * @param str the binary data.\n * @param len the length of the data.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len );\n\n/**\n * Append a bson_bool_t to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the boolean value.\n * @param v the bson_bool_t to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_bool( bson *b, const char *name, const bson_bool_t v );\n\n/**\n * Append a null value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the null value.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_null( bson *b, const char *name );\n\n/**\n * Append an undefined value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the undefined value.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_undefined( bson *b, const char *name );\n\n/**\n * Append a regex value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the regex value.\n * @param pattern the regex pattern to append.\n * @param the regex options.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts );\n\n/**\n * Append bson data to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the bson data.\n * @param bson the bson object to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_bson( bson *b, const char *name, const bson *bson );\n\n/**\n * Append a BSON element to a bson from the current point of an iterator.\n *\n * @param b the bson to append to.\n * @param name_or_null the key for the BSON element, or NULL.\n * @param elem the bson_iterator.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem );\n\n/**\n * Append a bson_timestamp_t value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the timestampe value.\n * @param ts the bson_timestamp_t value to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_timestamp( bson *b, const char *name, bson_timestamp_t *ts );\nMONGO_EXPORT int bson_append_timestamp2( bson *b, const char *name, int time, int increment );\n\n/* these both append a bson_date */\n/**\n * Append a bson_date_t value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the date value.\n * @param millis the bson_date_t to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_date( bson *b, const char *name, bson_date_t millis );\n\n/**\n * Append a time_t value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the date value.\n * @param secs the time_t to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_time_t( bson *b, const char *name, time_t secs );\n\n/**\n * Start appending a new object to a bson.\n *\n * @param b the bson to append to.\n * @param name the name of the new object.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_start_object( bson *b, const char *name );\n\n/**\n * Start appending a new array to a bson.\n *\n * @param b the bson to append to.\n * @param name the name of the new array.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_start_array( bson *b, const char *name );\n\n/**\n * Finish appending a new object or array to a bson.\n *\n * @param b the bson to append to.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_finish_object( bson *b );\n\n/**\n * Finish appending a new object or array to a bson. This\n * is simply an alias for bson_append_finish_object.\n *\n * @param b the bson to append to.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_finish_array( bson *b );\n\nvoid bson_numstr( char *str, int i );\n\nvoid bson_incnumstr( char *str );\n\n/* Error handling and standard library function over-riding. */\n/* -------------------------------------------------------- */\n\n/* bson_err_handlers shouldn't return!!! */\ntypedef void( *bson_err_handler )( const char *errmsg );\n\ntypedef int (*bson_printf_func)( const char *, ... );\ntypedef int (*bson_fprintf_func)( FILE *, const char *, ... );\ntypedef int (*bson_sprintf_func)( char *, const char *, ... );\n\nextern void *( *bson_malloc_func )( size_t );\nextern void *( *bson_realloc_func )( void *, size_t );\nextern void ( *bson_free_func )( void * );\n\nextern bson_printf_func bson_printf;\nextern bson_fprintf_func bson_fprintf;\nextern bson_sprintf_func bson_sprintf;\nextern bson_printf_func bson_errprintf;\n\nMONGO_EXPORT void bson_free( void *ptr );\n\n/**\n * Allocates memory and checks return value, exiting fatally if malloc() fails.\n *\n * @param size bytes to allocate.\n *\n * @return a pointer to the allocated memory.\n *\n * @sa malloc(3)\n */\nMONGO_EXPORT void *bson_malloc( int size );\n\n/**\n * Changes the size of allocated memory and checks return value,\n * exiting fatally if realloc() fails.\n *\n * @param ptr pointer to the space to reallocate.\n * @param size bytes to allocate.\n *\n * @return a pointer to the allocated memory.\n *\n * @sa realloc()\n */\nvoid *bson_realloc( void *ptr, int size );\n\n/**\n * Set a function for error handling.\n *\n * @param func a bson_err_handler function.\n *\n * @return the old error handling function, or NULL.\n */\nMONGO_EXPORT bson_err_handler set_bson_err_handler( bson_err_handler func );\n\n/* does nothing if ok != 0 */\n/**\n * Exit fatally.\n *\n * @param ok exits if ok is equal to 0.\n */\nvoid bson_fatal( int ok );\n\n/**\n * Exit fatally with an error message.\n  *\n * @param ok exits if ok is equal to 0.\n * @param msg prints to stderr before exiting.\n */\nvoid bson_fatal_msg( int ok, const char *msg );\n\n/**\n * Invoke the error handler, but do not exit.\n *\n * @param b the buffer object.\n */\nvoid bson_builder_error( bson *b );\n\n/**\n * Cast an int64_t to double. This is necessary for embedding in\n * certain environments.\n *\n */\nMONGO_EXPORT double bson_int64_to_double( int64_t i64 );\n\nMONGO_EXPORT void bson_swap_endian32( void *outp, const void *inp );\nMONGO_EXPORT void bson_swap_endian64( void *outp, const void *inp );\n\nMONGO_EXTERN_C_END\n#endif\n", "/*\n * Copyright 2009-2012 10gen, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Portions Copyright 2001 Unicode, Inc.\n *\n * Disclaimer\n *\n * This source code is provided as is by Unicode, Inc. No claims are\n * made as to fitness for any particular purpose. No warranties of any\n * kind are expressed or implied. The recipient agrees to determine\n * applicability of information provided. If this file has been\n * purchased on magnetic or optical media from Unicode, Inc., the\n * sole remedy for any claim will be exchange of defective media\n * within 90 days of receipt.\n *\n * Limitations on Rights to Redistribute This Code\n *\n * Unicode, Inc. hereby grants the right to freely use the information\n * supplied in this file in the creation of products supporting the\n * Unicode Standard, and to make copies of this file in any form\n * for internal or external distribution as long as this notice\n * remains attached.\n */\n\n\n#include \"bson.h\"\n#include \"encoding.h\"\n\n/*\n * Index into the table below with the first byte of a UTF-8 sequence to\n * get the number of trailing bytes that are supposed to follow it.\n */\nstatic const char trailingBytesForUTF8[256] = {\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5\n};\n\n/* --------------------------------------------------------------------- */\n\n/*\n * Utility routine to tell whether a sequence of bytes is legal UTF-8.\n * This must be called with the length pre-determined by the first byte.\n * The length can be set by:\n *  length = trailingBytesForUTF8[*source]+1;\n * and the sequence is illegal right away if there aren't that many bytes\n * available.\n * If presented with a length > 4, this returns 0.  The Unicode\n * definition of UTF-8 goes up to 4-byte sequences.\n */\nstatic int isLegalUTF8( const unsigned char *source, int length ) {\n    unsigned char a;\n    const unsigned char *srcptr = source + length;\n    switch ( length ) {\n    default:\n        return 0;\n        /* Everything else falls through when \"true\"... */\n    case 4:\n        if ( ( a = ( *--srcptr ) ) < 0x80 || a > 0xBF ) return 0;\n    case 3:\n        if ( ( a = ( *--srcptr ) ) < 0x80 || a > 0xBF ) return 0;\n    case 2:\n        if ( ( a = ( *--srcptr ) ) > 0xBF ) return 0;\n        switch ( *source ) {\n            /* no fall-through in this inner switch */\n        case 0xE0:\n            if ( a < 0xA0 ) return 0;\n            break;\n        case 0xF0:\n            if ( a < 0x90 ) return 0;\n            break;\n        case 0xF4:\n            if ( a > 0x8F ) return 0;\n            break;\n        default:\n            if ( a < 0x80 ) return 0;\n        }\n    case 1:\n        if ( *source >= 0x80 && *source < 0xC2 ) return 0;\n        if ( *source > 0xF4 ) return 0;\n    }\n    return 1;\n}\n\n/* If the name is part of a db ref ($ref, $db, or $id), then return true. */\nstatic int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n\n    return result;\n}\n\nstatic int bson_validate_string( bson *b, const unsigned char *string,\n                                 const int length, const char check_utf8, const char check_dot,\n                                 const char check_dollar ) {\n\n    int position = 0;\n    int sequence_length = 1;\n\n    if( check_dollar && string[0] == '$' ) {\n        if( !bson_string_is_db_ref( string, length ) )\n            b->err |= BSON_FIELD_INIT_DOLLAR;\n    }\n\n    while ( position < length ) {\n        if ( check_dot && *( string + position ) == '.' ) {\n            b->err |= BSON_FIELD_HAS_DOT;\n        }\n\n        if ( check_utf8 ) {\n            sequence_length = trailingBytesForUTF8[*( string + position )] + 1;\n            if ( ( position + sequence_length ) > length ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n            if ( !isLegalUTF8( string + position, sequence_length ) ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n        }\n        position += sequence_length;\n    }\n\n    return BSON_OK;\n}\n\n\nint bson_check_string( bson *b, const char *string,\n                       const int length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );\n}\n\nint bson_check_field_name( bson *b, const char *string,\n                           const int length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}\n", "/*\n * Copyright 2009-2012 10gen, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef BSON_ENCODING_H_\n#define BSON_ENCODING_H_\n\nMONGO_EXTERN_C_START\n\n/**\n * Check that a field name is valid UTF8, does not start with a '$',\n * and contains no '.' characters. Set bson bit field appropriately.\n * Note that we don't need to check for '\\0' because we're using\n * strlen(3), which stops at '\\0'.\n *\n * @param b The bson object to which field name will be appended.\n * @param string The field name as char*.\n * @param length The length of the field name.\n *\n * @return BSON_OK if valid UTF8 and BSON_ERROR if not. All BSON strings must be\n *     valid UTF8. This function will also check whether the string\n *     contains '.' or starts with '$', since the validity of this depends on context.\n *     Set the value of b->err appropriately.\n */\nint bson_check_field_name( bson *b, const char *string,\n                           const int length );\n\n/**\n * Check that a string is valid UTF8. Sets the buffer bit field appropriately.\n *\n * @param b The bson object to which string will be appended.\n * @param string The string to check.\n * @param length The length of the string.\n *\n * @return BSON_OK if valid UTF-8; otherwise, BSON_ERROR.\n *     Sets b->err on error.\n */\nbson_bool_t bson_check_string( bson *b, const char *string,\n                               const int length );\n\nMONGO_EXTERN_C_END\n#endif\n", "#if !defined(MONGO_ENV_STANDARD) && (defined(_WIN32) || defined(_WIN64))\n\n/* env_win32.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n/* Networking and other niceties for WIN32. */\n#include \"env.h\"\n#include <string.h>\n\n#ifdef _MSC_VER\n#include <ws2tcpip.h>  /* send,recv,socklen_t etc */\n#include <wspiapi.h>   /* addrinfo */\n#else\n#include <ws2tcpip.h>  /* send,recv,socklen_t etc */\n#include <winsock2.h>\ntypedef int socklen_t;\n#endif\n\n#ifndef NI_MAXSERV\n# define NI_MAXSERV 32\n#endif\n\nint mongo_env_close_socket( int socket ) {\n    return closesocket( socket );\n}\n\nint mongo_env_write_socket( mongo *conn, const void *buf, int len ) {\n    const char *cbuf = buf;\n    int flags = 0;\n\n    while ( len ) {\n        int sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            conn->connected = 0;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_set_socket_op_timeout( mongo *conn, int millis ) {\n    if ( setsockopt( conn->sock, SOL_SOCKET, SO_RCVTIMEO, (const char *)&millis,\n                     sizeof( millis ) ) == -1 ) {\n        __mongo_set_error( conn, MONGO_IO_ERROR, \"setsockopt SO_RCVTIMEO failed.\",\n                           WSAGetLastError() );\n        return MONGO_ERROR;\n    }\n\n    if ( setsockopt( conn->sock, SOL_SOCKET, SO_SNDTIMEO, (const char *)&millis,\n                     sizeof( millis ) ) == -1 ) {\n        __mongo_set_error( conn, MONGO_IO_ERROR, \"setsockopt SO_SNDTIMEO failed.\",\n                           WSAGetLastError() );\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_socket_connect( mongo *conn, const char *host, int port ) {\n    char port_str[NI_MAXSERV];\n    char errstr[MONGO_ERR_LEN];\n    int status;\n\n    struct addrinfo ai_hints;\n    struct addrinfo *ai_list = NULL;\n    struct addrinfo *ai_ptr = NULL;\n\n    conn->sock = 0;\n    conn->connected = 0;\n\n    bson_sprintf( port_str, \"%d\", port );\n\n    memset( &ai_hints, 0, sizeof( ai_hints ) );\n    ai_hints.ai_family = AF_UNSPEC;\n    ai_hints.ai_socktype = SOCK_STREAM;\n    ai_hints.ai_protocol = IPPROTO_TCP;\n\n    status = getaddrinfo( host, port_str, &ai_hints, &ai_list );\n    if ( status != 0 ) {\n        bson_sprintf( errstr, \"getaddrinfo failed with error %d\", status );\n        __mongo_set_error( conn, MONGO_CONN_ADDR_FAIL, errstr, WSAGetLastError() );\n        return MONGO_ERROR;\n    }\n\n    for ( ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next ) {\n        conn->sock = socket( ai_ptr->ai_family, ai_ptr->ai_socktype,\n                             ai_ptr->ai_protocol );\n\n        if ( conn->sock < 0 ) {\n            __mongo_set_error( conn, MONGO_SOCKET_ERROR, \"socket() failed\",\n                               WSAGetLastError() );\n            conn->sock = 0;\n            continue;\n        }\n\n        status = connect( conn->sock, ai_ptr->ai_addr, ai_ptr->ai_addrlen );\n        if ( status != 0 ) {\n            __mongo_set_error( conn, MONGO_SOCKET_ERROR, \"connect() failed\",\n                               WSAGetLastError() );\n            mongo_env_close_socket( conn->sock );\n            conn->sock = 0;\n            continue;\n        }\n\n        if ( ai_ptr->ai_protocol == IPPROTO_TCP ) {\n            int flag = 1;\n\n            setsockopt( conn->sock, IPPROTO_TCP, TCP_NODELAY,\n                        ( void * ) &flag, sizeof( flag ) );\n\n            if ( conn->op_timeout_ms > 0 )\n                mongo_env_set_socket_op_timeout( conn, conn->op_timeout_ms );\n        }\n\n        conn->connected = 1;\n        break;\n    }\n\n    freeaddrinfo( ai_list );\n\n    if ( ! conn->connected ) {\n        conn->err = MONGO_CONN_FAIL;\n        return MONGO_ERROR;\n    }\n    else {\n        mongo_clear_errors( conn );\n        return MONGO_OK;\n    }\n}\n\nMONGO_EXPORT int mongo_env_sock_init( void ) {\n\n    WSADATA wsaData;\n    WORD wVers;\n    static int called_once;\n    static int retval;\n\n    if (called_once) return retval;\n\n    called_once = 1;\n    wVers = MAKEWORD(1, 1);\n    retval = (WSAStartup(wVers, &wsaData) == 0);\n\n    return retval;\n}\n\n\n#elif !defined(MONGO_ENV_STANDARD) && (defined(__APPLE__) || defined(__linux) || defined(__unix) || defined(__posix))\n\n/* env_posix.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n/* Networking and other niceties for POSIX systems. */\n#include \"env.h\"\n#include <string.h>\n#include <errno.h>\n#include <sys/time.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#ifndef NI_MAXSERV\n# define NI_MAXSERV 32\n#endif\n\nint mongo_env_close_socket( int socket ) {\n    return close( socket );\n}\n\nint mongo_env_sock_init( void ) {\n    return 0;\n}\n\nint mongo_env_write_socket( mongo *conn, const void *buf, int len ) {\n    const char *cbuf = buf;\n#ifdef __APPLE__\n    int flags = 0;\n#else\n    int flags = MSG_NOSIGNAL;\n#endif\n\n    while ( len ) {\n        int sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            if (errno == EPIPE)\n                conn->connected = 0;\n            __mongo_set_error( conn, MONGO_IO_ERROR, strerror( errno ), errno );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, strerror( errno ), errno );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_set_socket_op_timeout( mongo *conn, int millis ) {\n    struct timeval tv;\n    tv.tv_sec = millis / 1000;\n    tv.tv_usec = ( millis % 1000 ) * 1000;\n\n    if ( setsockopt( conn->sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof( tv ) ) == -1 ) {\n        conn->err = MONGO_IO_ERROR;\n        __mongo_set_error( conn, MONGO_IO_ERROR, \"setsockopt SO_RCVTIMEO failed.\", errno );\n        return MONGO_ERROR;\n    }\n\n    if ( setsockopt( conn->sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof( tv ) ) == -1 ) {\n        __mongo_set_error( conn, MONGO_IO_ERROR, \"setsockopt SO_SNDTIMEO failed.\", errno );\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\nstatic int mongo_env_unix_socket_connect( mongo *conn, const char *sock_path ) {\n    struct sockaddr_un addr;\n    int status, len;\n\n    conn->connected = 0;\n\n    conn->sock = socket( AF_UNIX, SOCK_STREAM, 0 );\n\n    if ( conn->sock < 0 ) {\n        conn->sock = 0;\n        return MONGO_ERROR;\n    }\n\n    addr.sun_family = AF_UNIX;\n    strncpy( addr.sun_path, sock_path, sizeof(addr.sun_path) - 1 );\n    len = sizeof( addr );\n\n    status = connect( conn->sock, (struct sockaddr *) &addr, len );\n    if( status < 0 ) {\n        mongo_env_close_socket( conn->sock );\n        conn->sock = 0;\n        conn->err = MONGO_CONN_FAIL;\n        return MONGO_ERROR;\n    }\n\n    conn->connected = 1;\n\n    return MONGO_OK;\n}\n\nint mongo_env_socket_connect( mongo *conn, const char *host, int port ) {\n    char port_str[NI_MAXSERV];\n    int status;\n\n    struct addrinfo ai_hints;\n    struct addrinfo *ai_list = NULL;\n    struct addrinfo *ai_ptr = NULL;\n\n    if ( port < 0 ) {\n        return mongo_env_unix_socket_connect( conn, host );\n    }\n\n    conn->sock = 0;\n    conn->connected = 0;\n    sprintf(port_str,\"%d\",port);\n\n    bson_sprintf( port_str, \"%d\", port );\n\n    memset( &ai_hints, 0, sizeof( ai_hints ) );\n#ifdef AI_ADDRCONFIG\n    ai_hints.ai_flags = AI_ADDRCONFIG;\n#endif\n    ai_hints.ai_family = AF_UNSPEC;\n    ai_hints.ai_socktype = SOCK_STREAM;\n\n    status = getaddrinfo( host, port_str, &ai_hints, &ai_list );\n    if ( status != 0 ) {\n        bson_errprintf( \"getaddrinfo failed: %s\", gai_strerror( status ) );\n        conn->err = MONGO_CONN_ADDR_FAIL;\n        return MONGO_ERROR;\n    }\n\n    for ( ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next ) {\n        conn->sock = socket( ai_ptr->ai_family, ai_ptr->ai_socktype, ai_ptr->ai_protocol );\n        if ( conn->sock < 0 ) {\n            conn->sock = 0;\n            continue;\n        }\n\n        status = connect( conn->sock, ai_ptr->ai_addr, ai_ptr->ai_addrlen );\n        if ( status != 0 ) {\n            mongo_env_close_socket( conn->sock );\n            conn->sock = 0;\n            continue;\n        }\n#if __APPLE__\n        {\n            int flag = 1;\n            setsockopt( conn->sock, SOL_SOCKET, SO_NOSIGPIPE,\n                       ( void * ) &flag, sizeof( flag ) );\n        }\n#endif\n\n        if ( ai_ptr->ai_protocol == IPPROTO_TCP ) {\n            int flag = 1;\n\n            setsockopt( conn->sock, IPPROTO_TCP, TCP_NODELAY,\n                        ( void * ) &flag, sizeof( flag ) );\n            if ( conn->op_timeout_ms > 0 )\n                mongo_env_set_socket_op_timeout( conn, conn->op_timeout_ms );\n        }\n\n        conn->connected = 1;\n        break;\n    }\n\n    freeaddrinfo( ai_list );\n\n    if ( ! conn->connected ) {\n        conn->err = MONGO_CONN_FAIL;\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\n#else\n/* env_standard.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n/* Vanilla networking designed to work on all systems. */\n#include \"env.h\"\n#include <errno.h>\n#include <string.h>\n\n#ifdef _WIN32\n#ifdef _MSC_VER\n#include <ws2tcpip.h>  /* send,recv,socklen_t etc */\n#include <wspiapi.h>   /* addrinfo */\n#else\n#include <windows.h>\n#include <winsock.h>\ntypedef int socklen_t;\n#endif\n#else\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <fcntl.h>\n#include <unistd.h>\n#endif\n\n#ifndef NI_MAXSERV\n# define NI_MAXSERV 32\n#endif\n\nint mongo_env_close_socket( int socket ) {\n#ifdef _WIN32\n    return closesocket( socket );\n#else\n    return close( socket );\n#endif\n}\n\nint mongo_env_write_socket( mongo *conn, const void *buf, int len ) {\n    const char *cbuf = buf;\n#ifdef _WIN32\n    int flags = 0;\n#else\n#ifdef __APPLE__\n    int flags = 0;\n#else\n    int flags = MSG_NOSIGNAL;\n#endif\n#endif\n\n    while ( len ) {\n        int sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            if (errno == EPIPE)\n                conn->connected = 0;\n            conn->err = MONGO_IO_ERROR;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            conn->err = MONGO_IO_ERROR;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\n/* This is a no-op in the generic implementation. */\nint mongo_env_set_socket_op_timeout( mongo *conn, int millis ) {\n    return MONGO_OK;\n}\n\nint mongo_env_socket_connect( mongo *conn, const char *host, int port ) {\n    struct sockaddr_in sa;\n    socklen_t addressSize;\n    int flag = 1;\n\n    if ( ( conn->sock = socket( AF_INET, SOCK_STREAM, 0 ) ) < 0 ) {\n        conn->sock = 0;\n        conn->err = MONGO_CONN_NO_SOCKET;\n        return MONGO_ERROR;\n    }\n\n    memset( sa.sin_zero , 0 , sizeof( sa.sin_zero ) );\n    sa.sin_family = AF_INET;\n    sa.sin_port = htons( port );\n    sa.sin_addr.s_addr = inet_addr( host );\n    addressSize = sizeof( sa );\n\n    if ( connect( conn->sock, ( struct sockaddr * )&sa, addressSize ) == -1 ) {\n        mongo_env_close_socket( conn->sock );\n        conn->connected = 0;\n        conn->sock = 0;\n        conn->err = MONGO_CONN_FAIL;\n        return MONGO_ERROR;\n    }\n\n    setsockopt( conn->sock, IPPROTO_TCP, TCP_NODELAY, ( char * ) &flag, sizeof( flag ) );\n\n    if( conn->op_timeout_ms > 0 )\n        mongo_env_set_socket_op_timeout( conn, conn->op_timeout_ms );\n\n    conn->connected = 1;\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_env_sock_init( void ) {\n\n#if defined(_WIN32)\n    WSADATA wsaData;\n    WORD wVers;\n#elif defined(SIGPIPE)\n    struct sigaction act;\n#endif\n\n    static int called_once;\n    static int retval;\n    if (called_once) return retval;\n    called_once = 1;\n\n#if defined(_WIN32)\n    wVers = MAKEWORD(1, 1);\n    retval = (WSAStartup(wVers, &wsaData) == 0);\n#elif defined(MACINTOSH)\n    GUSISetup(GUSIwithInternetSockets);\n    retval = 1;\n#elif defined(SIGPIPE)\n    retval = 1;\n    if (sigaction(SIGPIPE, (struct sigaction *)NULL, &act) < 0)\n        retval = 0;\n    else if (act.sa_handler == SIG_DFL) {\n        act.sa_handler = SIG_IGN;\n        if (sigaction(SIGPIPE, &act, (struct sigaction *)NULL) < 0)\n            retval = 0;\n    }\n#endif\n    return retval;\n}\n\n#endif\n", "/** @file env.h */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n/* Header for generic net.h */\n#ifndef MONGO_ENV_H_\n#define MONGO_ENV_H_\n\n#include \"mongo.h\"\n\nMONGO_EXTERN_C_START\n\n/* This is a no-op in the generic implementation. */\nint mongo_env_set_socket_op_timeout( mongo *conn, int millis );\nint mongo_env_read_socket( mongo *conn, void *buf, int len );\nint mongo_env_write_socket( mongo *conn, const void *buf, int len );\nint mongo_env_socket_connect( mongo *conn, const char *host, int port );\n\n/* Initialize socket services */\nMONGO_EXPORT int mongo_env_sock_init( void );\n\n/* Close a socket */\nMONGO_EXPORT int mongo_env_close_socket( int socket );\n\nMONGO_EXTERN_C_END\n#endif\n", "/* gridfs.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#include \"gridfs.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nMONGO_EXPORT gridfs* gridfs_create( void ) {\n    return (gridfs*)bson_malloc(sizeof(gridfs));\n}\n\nMONGO_EXPORT void gridfs_dispose(gridfs* gfs) {\n    free(gfs);\n}\n\nMONGO_EXPORT gridfile* gridfile_create( void ) {\n    return (gridfile*)bson_malloc(sizeof(gridfile));\n}\n\nMONGO_EXPORT void gridfile_dispose(gridfile* gf) {\n    free(gf);\n}\n\nMONGO_EXPORT void gridfile_get_descriptor(gridfile* gf, bson* out) {\n    *out = *gf->meta;\n}\n\n\nstatic bson *chunk_new( bson_oid_t id, int chunkNumber,\n                        const char *data, int len ) {\n    bson *b = bson_malloc( sizeof( bson ) );\n\n    bson_init( b );\n    bson_append_oid( b, \"files_id\", &id );\n    bson_append_int( b, \"n\", chunkNumber );\n    bson_append_binary( b, \"data\", BSON_BIN_BINARY, data, len );\n    bson_finish( b );\n    return  b;\n}\n\nstatic void chunk_free( bson *oChunk ) {\n    bson_destroy( oChunk );\n    bson_free( oChunk );\n}\n\nint gridfs_init( mongo *client, const char *dbname, const char *prefix,\n                 gridfs *gfs ) {\n\n    int options;\n    bson b;\n    bson_bool_t success;\n\n    gfs->client = client;\n\n    /* Allocate space to own the dbname */\n    gfs->dbname = ( const char * )bson_malloc( strlen( dbname )+1 );\n    strcpy( ( char * )gfs->dbname, dbname );\n\n    /* Allocate space to own the prefix */\n    if ( prefix == NULL ) prefix = \"fs\";\n    gfs->prefix = ( const char * )bson_malloc( strlen( prefix )+1 );\n    strcpy( ( char * )gfs->prefix, prefix );\n\n    /* Allocate space to own files_ns */\n    gfs->files_ns =\n        ( const char * ) bson_malloc ( strlen( prefix )+strlen( dbname )+strlen( \".files\" )+2 );\n    strcpy( ( char * )gfs->files_ns, dbname );\n    strcat( ( char * )gfs->files_ns, \".\" );\n    strcat( ( char * )gfs->files_ns, prefix );\n    strcat( ( char * )gfs->files_ns, \".files\" );\n\n    /* Allocate space to own chunks_ns */\n    gfs->chunks_ns = ( const char * ) bson_malloc( strlen( prefix ) + strlen( dbname )\n                     + strlen( \".chunks\" ) + 2 );\n    strcpy( ( char * )gfs->chunks_ns, dbname );\n    strcat( ( char * )gfs->chunks_ns, \".\" );\n    strcat( ( char * )gfs->chunks_ns, prefix );\n    strcat( ( char * )gfs->chunks_ns, \".chunks\" );\n\n    bson_init( &b );\n    bson_append_int( &b, \"filename\", 1 );\n    bson_finish( &b );\n    options = 0;\n    success = ( mongo_create_index( gfs->client, gfs->files_ns, &b, options, NULL ) == MONGO_OK );\n    bson_destroy( &b );\n    if ( !success ) {\n        bson_free( ( char * )gfs->dbname );\n        bson_free( ( char * )gfs->prefix );\n        bson_free( ( char * )gfs->files_ns );\n        bson_free( ( char * )gfs->chunks_ns );\n        return MONGO_ERROR;\n    }\n\n    bson_init( &b );\n    bson_append_int( &b, \"files_id\", 1 );\n    bson_append_int( &b, \"n\", 1 );\n    bson_finish( &b );\n    options = MONGO_INDEX_UNIQUE;\n    success = ( mongo_create_index( gfs->client, gfs->chunks_ns, &b, options, NULL ) == MONGO_OK );\n    bson_destroy( &b );\n    if ( !success ) {\n        bson_free( ( char * )gfs->dbname );\n        bson_free( ( char * )gfs->prefix );\n        bson_free( ( char * )gfs->files_ns );\n        bson_free( ( char * )gfs->chunks_ns );\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT void gridfs_destroy( gridfs *gfs ) {\n    if ( gfs == NULL ) return;\n    if ( gfs->dbname ) bson_free( ( char * )gfs->dbname );\n    if ( gfs->prefix ) bson_free( ( char * )gfs->prefix );\n    if ( gfs->files_ns ) bson_free( ( char * )gfs->files_ns );\n    if ( gfs->chunks_ns ) bson_free( ( char * )gfs->chunks_ns );\n}\n\nstatic int gridfs_insert_file( gridfs *gfs, const char *name,\n                               const bson_oid_t id, gridfs_offset length,\n                               const char *contenttype ) {\n    bson command;\n    bson ret;\n    bson res;\n    bson_iterator it;\n    int result;\n    int64_t d;\n\n    /* Check run md5 */\n    bson_init( &command );\n    bson_append_oid( &command, \"filemd5\", &id );\n    bson_append_string( &command, \"root\", gfs->prefix );\n    bson_finish( &command );\n    result = mongo_run_command( gfs->client, gfs->dbname, &command, &res );\n    bson_destroy( &command );\n    if (result != MONGO_OK)\n        return result;\n\n    /* Create and insert BSON for file metadata */\n    bson_init( &ret );\n    bson_append_oid( &ret, \"_id\", &id );\n    if ( name != NULL && *name != '\\0' ) {\n        bson_append_string( &ret, \"filename\", name );\n    }\n    bson_append_long( &ret, \"length\", length );\n    bson_append_int( &ret, \"chunkSize\", DEFAULT_CHUNK_SIZE );\n    d = ( bson_date_t )1000*time( NULL );\n    bson_append_date( &ret, \"uploadDate\", d);\n    bson_find( &it, &res, \"md5\" );\n    bson_append_string( &ret, \"md5\", bson_iterator_string( &it ) );\n    bson_destroy( &res );\n    if ( contenttype != NULL && *contenttype != '\\0' ) {\n        bson_append_string( &ret, \"contentType\", contenttype );\n    }\n    bson_finish( &ret );\n    result = mongo_insert( gfs->client, gfs->files_ns, &ret, NULL );\n    bson_destroy( &ret );\n\n    return result;\n}\n\nMONGO_EXPORT int gridfs_store_buffer( gridfs *gfs, const char *data,\n                                      gridfs_offset length, const char *remotename,\n                                      const char *contenttype ) {\n\n    char const *end = data + length;\n    const char *data_ptr = data;\n    bson_oid_t id;\n    int chunkNumber = 0;\n    int chunkLen;\n    bson *oChunk;\n\n    /* Large files Assertion */\n    /* assert( length <= 0xffffffff ); */\n\n    /* Generate and append an oid*/\n    bson_oid_gen( &id );\n\n    /* Insert the file's data chunk by chunk */\n    while ( data_ptr < end ) {\n        chunkLen = DEFAULT_CHUNK_SIZE < ( unsigned int )( end - data_ptr ) ?\n                   DEFAULT_CHUNK_SIZE : ( unsigned int )( end - data_ptr );\n        oChunk = chunk_new( id, chunkNumber, data_ptr, chunkLen );\n        mongo_insert( gfs->client, gfs->chunks_ns, oChunk, NULL );\n        chunk_free( oChunk );\n        chunkNumber++;\n        data_ptr += chunkLen;\n    }\n\n    /* Inserts file's metadata */\n    return gridfs_insert_file( gfs, remotename, id, length, contenttype );\n}\n\nMONGO_EXPORT void gridfile_writer_init( gridfile *gfile, gridfs *gfs,\n                                        const char *remote_name, const char *content_type ) {\n    gfile->gfs = gfs;\n\n    bson_oid_gen( &( gfile->id ) );\n    gfile->chunk_num = 0;\n    gfile->length = 0;\n    gfile->pending_len = 0;\n    gfile->pending_data = NULL;\n\n    gfile->remote_name = ( char * )bson_malloc( strlen( remote_name ) + 1 );\n    strcpy( ( char * )gfile->remote_name, remote_name );\n\n    gfile->content_type = ( char * )bson_malloc( strlen( content_type ) + 1 );\n    strcpy( ( char * )gfile->content_type, content_type );\n}\n\nMONGO_EXPORT void gridfile_write_buffer( gridfile *gfile, const char *data,\n        gridfs_offset length ) {\n\n    int bytes_left = 0;\n    int data_partial_len = 0;\n    int chunks_to_write = 0;\n    char *buffer;\n    bson *oChunk;\n    gridfs_offset to_write = length + gfile->pending_len;\n\n    if ( to_write < DEFAULT_CHUNK_SIZE ) { /* Less than one chunk to write */\n        if( gfile->pending_data ) {\n            gfile->pending_data = ( char * )bson_realloc( ( void * )gfile->pending_data, gfile->pending_len + to_write );\n            memcpy( gfile->pending_data + gfile->pending_len, data, length );\n        }\n        else if ( to_write > 0 ) {\n            gfile->pending_data = ( char * )bson_malloc( to_write );\n            memcpy( gfile->pending_data, data, length );\n        }\n        gfile->pending_len += length;\n\n    }\n    else {   /* At least one chunk of data to write */\n        chunks_to_write = to_write / DEFAULT_CHUNK_SIZE;\n        bytes_left = to_write % DEFAULT_CHUNK_SIZE;\n\n        /* If there's a pending chunk to be written, we need to combine\n         * the buffer provided up to DEFAULT_CHUNK_SIZE.\n         */\n        if ( gfile->pending_len > 0 ) {\n            data_partial_len = DEFAULT_CHUNK_SIZE - gfile->pending_len;\n            buffer = ( char * )bson_malloc( DEFAULT_CHUNK_SIZE );\n            memcpy( buffer, gfile->pending_data, gfile->pending_len );\n            memcpy( buffer + gfile->pending_len, data, data_partial_len );\n\n            oChunk = chunk_new( gfile->id, gfile->chunk_num, buffer, DEFAULT_CHUNK_SIZE );\n            mongo_insert( gfile->gfs->client, gfile->gfs->chunks_ns, oChunk, NULL );\n            chunk_free( oChunk );\n            gfile->chunk_num++;\n            gfile->length += DEFAULT_CHUNK_SIZE;\n            data += data_partial_len;\n\n            chunks_to_write--;\n\n            bson_free( buffer );\n        }\n\n        while( chunks_to_write > 0 ) {\n            oChunk = chunk_new( gfile->id, gfile->chunk_num, data, DEFAULT_CHUNK_SIZE );\n            mongo_insert( gfile->gfs->client, gfile->gfs->chunks_ns, oChunk, NULL );\n            chunk_free( oChunk );\n            gfile->chunk_num++;\n            chunks_to_write--;\n            gfile->length += DEFAULT_CHUNK_SIZE;\n            data += DEFAULT_CHUNK_SIZE;\n        }\n\n        bson_free( gfile->pending_data );\n\n        /* If there are any leftover bytes, store them as pending data. */\n        if( bytes_left == 0 )\n            gfile->pending_data = NULL;\n        else {\n            gfile->pending_data = ( char * )bson_malloc( bytes_left );\n            memcpy( gfile->pending_data, data, bytes_left );\n        }\n\n        gfile->pending_len = bytes_left;\n    }\n}\n\nMONGO_EXPORT int gridfile_writer_done( gridfile *gfile ) {\n\n    /* write any remaining pending chunk data.\n     * pending data will always take up less than one chunk */\n    bson *oChunk;\n    int response;\n    if( gfile->pending_data ) {\n        oChunk = chunk_new( gfile->id, gfile->chunk_num, gfile->pending_data, gfile->pending_len );\n        mongo_insert( gfile->gfs->client, gfile->gfs->chunks_ns, oChunk, NULL );\n        chunk_free( oChunk );\n        bson_free( gfile->pending_data );\n        gfile->length += gfile->pending_len;\n    }\n\n    /* insert into files collection */\n    response = gridfs_insert_file( gfile->gfs, gfile->remote_name, gfile->id,\n                                   gfile->length, gfile->content_type );\n\n    bson_free( gfile->remote_name );\n    bson_free( gfile->content_type );\n\n    return response;\n}\n\nint gridfs_store_file( gridfs *gfs, const char *filename,\n                       const char *remotename, const char *contenttype ) {\n\n    char buffer[DEFAULT_CHUNK_SIZE];\n    FILE *fd;\n    bson_oid_t id;\n    int chunkNumber = 0;\n    gridfs_offset length = 0;\n    gridfs_offset chunkLen = 0;\n    bson *oChunk;\n\n    /* Open the file and the correct stream */\n    if ( strcmp( filename, \"-\" ) == 0 ) fd = stdin;\n    else {\n        fd = fopen( filename, \"rb\" );\n        if (fd == NULL)\n            return MONGO_ERROR;\n    }\n\n    /* Generate and append an oid*/\n    bson_oid_gen( &id );\n\n    /* Insert the file chunk by chunk */\n    chunkLen = fread( buffer, 1, DEFAULT_CHUNK_SIZE, fd );\n    do {\n        oChunk = chunk_new( id, chunkNumber, buffer, chunkLen );\n        mongo_insert( gfs->client, gfs->chunks_ns, oChunk, NULL );\n        chunk_free( oChunk );\n        length += chunkLen;\n        chunkNumber++;\n        chunkLen = fread( buffer, 1, DEFAULT_CHUNK_SIZE, fd );\n    }\n    while ( chunkLen != 0 );\n\n    /* Close the file stream */\n    if ( fd != stdin ) fclose( fd );\n\n    /* Large files Assertion */\n    /* assert(length <= 0xffffffff); */\n\n    /* Optional Remote Name */\n    if ( remotename == NULL || *remotename == '\\0' ) {\n        remotename = filename;\n    }\n\n    /* Inserts file's metadata */\n    return gridfs_insert_file( gfs, remotename, id, length, contenttype );\n}\n\nMONGO_EXPORT void gridfs_remove_filename( gridfs *gfs, const char *filename ) {\n    bson query;\n    mongo_cursor *files;\n    bson file;\n    bson_iterator it;\n    bson_oid_t id;\n    bson b;\n\n    bson_init( &query );\n    bson_append_string( &query, \"filename\", filename );\n    bson_finish( &query );\n    files = mongo_find( gfs->client, gfs->files_ns, &query, NULL, 0, 0, 0 );\n    bson_destroy( &query );\n\n    /* Remove each file and it's chunks from files named filename */\n    while ( mongo_cursor_next( files ) == MONGO_OK ) {\n        file = files->current;\n        bson_find( &it, &file, \"_id\" );\n        id = *bson_iterator_oid( &it );\n\n        /* Remove the file with the specified id */\n        bson_init( &b );\n        bson_append_oid( &b, \"_id\", &id );\n        bson_finish( &b );\n        mongo_remove( gfs->client, gfs->files_ns, &b, NULL );\n        bson_destroy( &b );\n\n        /* Remove all chunks from the file with the specified id */\n        bson_init( &b );\n        bson_append_oid( &b, \"files_id\", &id );\n        bson_finish( &b );\n        mongo_remove( gfs->client, gfs->chunks_ns, &b, NULL );\n        bson_destroy( &b );\n    }\n\n    mongo_cursor_destroy( files );\n}\n\nint gridfs_find_query( gridfs *gfs, bson *query,\n                       gridfile *gfile ) {\n\n    bson uploadDate;\n    bson finalQuery;\n    bson out;\n    int i;\n\n    bson_init( &uploadDate );\n    bson_append_int( &uploadDate, \"uploadDate\", -1 );\n    bson_finish( &uploadDate );\n\n    bson_init( &finalQuery );\n    bson_append_bson( &finalQuery, \"query\", query );\n    bson_append_bson( &finalQuery, \"orderby\", &uploadDate );\n    bson_finish( &finalQuery );\n\n    i = ( mongo_find_one( gfs->client, gfs->files_ns,\n                          &finalQuery, NULL, &out ) == MONGO_OK );\n    bson_destroy( &uploadDate );\n    bson_destroy( &finalQuery );\n    if ( !i )\n        return MONGO_ERROR;\n    else {\n        gridfile_init( gfs, &out, gfile );\n        bson_destroy( &out );\n        return MONGO_OK;\n    }\n}\n\nint gridfs_find_filename( gridfs *gfs, const char *filename,\n                          gridfile *gfile )\n\n{\n    bson query;\n    int i;\n\n    bson_init( &query );\n    bson_append_string( &query, \"filename\", filename );\n    bson_finish( &query );\n    i = gridfs_find_query( gfs, &query, gfile );\n    bson_destroy( &query );\n    return i;\n}\n\nint gridfile_init( gridfs *gfs, bson *meta, gridfile *gfile )\n\n{\n    gfile->gfs = gfs;\n    gfile->pos = 0;\n    gfile->meta = ( bson * )bson_malloc( sizeof( bson ) );\n    if ( gfile->meta == NULL ) return MONGO_ERROR;\n    bson_copy( gfile->meta, meta );\n    return MONGO_OK;\n}\n\nMONGO_EXPORT void gridfile_destroy( gridfile *gfile )\n\n{\n    bson_destroy( gfile->meta );\n    bson_free( gfile->meta );\n}\n\nbson_bool_t gridfile_exists( gridfile *gfile ) {\n    return ( bson_bool_t )( gfile != NULL && gfile->meta != NULL );\n}\n\nMONGO_EXPORT const char *gridfile_get_filename( gridfile *gfile ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, \"filename\" );\n    return bson_iterator_string( &it );\n}\n\nMONGO_EXPORT int gridfile_get_chunksize( gridfile *gfile ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, \"chunkSize\" );\n    return bson_iterator_int( &it );\n}\n\nMONGO_EXPORT gridfs_offset gridfile_get_contentlength( gridfile *gfile ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, \"length\" );\n\n    if( bson_iterator_type( &it ) == BSON_INT )\n        return ( gridfs_offset )bson_iterator_int( &it );\n    else\n        return ( gridfs_offset )bson_iterator_long( &it );\n}\n\nMONGO_EXPORT const char *gridfile_get_contenttype( gridfile *gfile ) {\n    bson_iterator it;\n\n    if ( bson_find( &it, gfile->meta, \"contentType\" ) )\n        return bson_iterator_string( &it );\n    else return NULL;\n}\n\nMONGO_EXPORT bson_date_t gridfile_get_uploaddate( gridfile *gfile ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, \"uploadDate\" );\n    return bson_iterator_date( &it );\n}\n\nMONGO_EXPORT const char *gridfile_get_md5( gridfile *gfile ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, \"md5\" );\n    return bson_iterator_string( &it );\n}\n\nconst char *gridfile_get_field( gridfile *gfile, const char *name ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, name );\n    return bson_iterator_value( &it );\n}\n\nbson_bool_t gridfile_get_boolean( gridfile *gfile, const char *name ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, name );\n    return bson_iterator_bool( &it );\n}\n\nMONGO_EXPORT void gridfile_get_metadata( gridfile *gfile, bson* out ) {\n    bson_iterator it;\n\n    if ( bson_find( &it, gfile->meta, \"metadata\" ) )\n        bson_iterator_subobject( &it, out );\n    else\n        bson_empty( out );\n}\n\nMONGO_EXPORT int gridfile_get_numchunks( gridfile *gfile ) {\n    bson_iterator it;\n    gridfs_offset length;\n    gridfs_offset chunkSize;\n    double numchunks;\n\n    bson_find( &it, gfile->meta, \"length\" );\n\n    if( bson_iterator_type( &it ) == BSON_INT )\n        length = ( gridfs_offset )bson_iterator_int( &it );\n    else\n        length = ( gridfs_offset )bson_iterator_long( &it );\n\n    bson_find( &it, gfile->meta, \"chunkSize\" );\n    chunkSize = bson_iterator_int( &it );\n    numchunks = ( ( double )length/( double )chunkSize );\n    return ( numchunks - ( int )numchunks > 0 )\n           ? ( int )( numchunks+1 )\n           : ( int )( numchunks );\n}\n\nMONGO_EXPORT void gridfile_get_chunk( gridfile *gfile, int n, bson* out ) {\n    bson query;\n\n    bson_iterator it;\n    bson_oid_t id;\n    int result;\n\n    bson_init( &query );\n    bson_find( &it, gfile->meta, \"_id\" );\n    id = *bson_iterator_oid( &it );\n    bson_append_oid( &query, \"files_id\", &id );\n    bson_append_int( &query, \"n\", n );\n    bson_finish( &query );\n\n    result = (mongo_find_one(gfile->gfs->client,\n                             gfile->gfs->chunks_ns,\n                             &query, NULL, out ) == MONGO_OK );\n    bson_destroy( &query );\n    if (!result) {\n        bson empty;\n        bson_empty(&empty);\n        bson_copy(out, &empty);\n    }\n}\n\nMONGO_EXPORT mongo_cursor *gridfile_get_chunks( gridfile *gfile, int start, int size ) {\n    bson_iterator it;\n    bson_oid_t id;\n    bson gte;\n    bson query;\n    bson orderby;\n    bson command;\n    mongo_cursor *cursor;\n\n    bson_find( &it, gfile->meta, \"_id\" );\n    id = *bson_iterator_oid( &it );\n\n    bson_init( &query );\n    bson_append_oid( &query, \"files_id\", &id );\n    if ( size == 1 ) {\n        bson_append_int( &query, \"n\", start );\n    }\n    else {\n        bson_init( &gte );\n        bson_append_int( &gte, \"$gte\", start );\n        bson_finish( &gte );\n        bson_append_bson( &query, \"n\", &gte );\n        bson_destroy( &gte );\n    }\n    bson_finish( &query );\n\n    bson_init( &orderby );\n    bson_append_int( &orderby, \"n\", 1 );\n    bson_finish( &orderby );\n\n    bson_init( &command );\n    bson_append_bson( &command, \"query\", &query );\n    bson_append_bson( &command, \"orderby\", &orderby );\n    bson_finish( &command );\n\n    cursor = mongo_find( gfile->gfs->client, gfile->gfs->chunks_ns,\n                         &command, NULL, size, 0, 0 );\n\n    bson_destroy( &command );\n    bson_destroy( &query );\n    bson_destroy( &orderby );\n\n    return cursor;\n}\n\ngridfs_offset gridfile_write_file( gridfile *gfile, FILE *stream ) {\n    int i;\n    size_t len;\n    bson chunk;\n    bson_iterator it;\n    const char *data;\n    const int num = gridfile_get_numchunks( gfile );\n\n    for ( i=0; i<num; i++ ) {\n        gridfile_get_chunk( gfile, i, &chunk );\n        bson_find( &it, &chunk, \"data\" );\n        len = bson_iterator_bin_len( &it );\n        data = bson_iterator_bin_data( &it );\n        fwrite( data, sizeof( char ), len, stream );\n        bson_destroy( &chunk );\n    }\n\n    return gridfile_get_contentlength( gfile );\n}\n\nMONGO_EXPORT gridfs_offset gridfile_read( gridfile *gfile, gridfs_offset size, char *buf ) {\n    mongo_cursor *chunks;\n    bson chunk;\n\n    int first_chunk;\n    int last_chunk;\n    int total_chunks;\n    gridfs_offset chunksize;\n    gridfs_offset contentlength;\n    gridfs_offset bytes_left;\n    int i;\n    bson_iterator it;\n    gridfs_offset chunk_len;\n    const char *chunk_data;\n\n    contentlength = gridfile_get_contentlength( gfile );\n    chunksize = gridfile_get_chunksize( gfile );\n    size = ( contentlength - gfile->pos < size )\n           ? contentlength - gfile->pos\n           : size;\n    bytes_left = size;\n\n    first_chunk = ( gfile->pos )/chunksize;\n    last_chunk = ( gfile->pos+size-1 )/chunksize;\n    total_chunks = last_chunk - first_chunk + 1;\n    chunks = gridfile_get_chunks( gfile, first_chunk, total_chunks );\n\n    for ( i = 0; i < total_chunks; i++ ) {\n        mongo_cursor_next( chunks );\n        chunk = chunks->current;\n        bson_find( &it, &chunk, \"data\" );\n        chunk_len = bson_iterator_bin_len( &it );\n        chunk_data = bson_iterator_bin_data( &it );\n        if ( i == 0 ) {\n            chunk_data += ( gfile->pos )%chunksize;\n            chunk_len -= ( gfile->pos )%chunksize;\n        }\n        if ( bytes_left > chunk_len ) {\n            memcpy( buf, chunk_data, chunk_len );\n            bytes_left -= chunk_len;\n            buf += chunk_len;\n        }\n        else {\n            memcpy( buf, chunk_data, bytes_left );\n        }\n    }\n\n    mongo_cursor_destroy( chunks );\n    gfile->pos = gfile->pos + size;\n\n    return size;\n}\n\nMONGO_EXPORT gridfs_offset gridfile_seek( gridfile *gfile, gridfs_offset offset ) {\n    gridfs_offset length;\n\n    length = gridfile_get_contentlength( gfile );\n    gfile->pos = length < offset ? length : offset;\n    return gfile->pos;\n}\n", "/** @file gridfs.h\n *\n *  @brief GridFS declarations\n *\n * */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#include \"mongo.h\"\n\n#ifndef MONGO_GRIDFS_H_\n#define MONGO_GRIDFS_H_\n\nenum {DEFAULT_CHUNK_SIZE = 256 * 1024};\n\ntypedef uint64_t gridfs_offset;\n\n/* A GridFS represents a single collection of GridFS files in the database. */\ntypedef struct {\n    mongo *client; /**> The client to db-connection. */\n    const char *dbname; /**> The root database name */\n    const char *prefix; /**> The prefix of the GridFS's collections, default is NULL */\n    const char *files_ns; /**> The namespace where the file's metadata is stored */\n    const char *chunks_ns; /**. The namespace where the files's data is stored in chunks */\n} gridfs;\n\n/* A GridFile is a single GridFS file. */\ntypedef struct {\n    gridfs *gfs;        /**> The GridFS where the GridFile is located */\n    bson *meta;         /**> The GridFile's bson object where all its metadata is located */\n    gridfs_offset pos;  /**> The position is the offset in the file */\n    bson_oid_t id;      /**> The files_id of the gridfile */\n    char *remote_name;  /**> The name of the gridfile as a string */\n    char *content_type; /**> The gridfile's content type */\n    gridfs_offset length; /**> The length of this gridfile */\n    int chunk_num;      /**> The number of the current chunk being written to */\n    char *pending_data; /**> A buffer storing data still to be written to chunks */\n    int pending_len;    /**> Length of pending_data buffer */\n} gridfile;\n\nMONGO_EXPORT gridfs* gridfs_create( void );\nMONGO_EXPORT void gridfs_dispose(gridfs* gfs);\nMONGO_EXPORT gridfile* gridfile_create( void );\nMONGO_EXPORT void gridfile_dispose(gridfile* gf);\nMONGO_EXPORT void gridfile_get_descriptor(gridfile* gf, bson* out);\n\n/**\n *  Initializes a GridFS object\n *  @param client - db connection\n *  @param dbname - database name\n *  @param prefix - collection prefix, default is fs if NULL or empty\n *  @param gfs - the GridFS object to initialize\n *\n *  @return - MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfs_init( mongo *client, const char *dbname,\n                              const char *prefix, gridfs *gfs );\n\n/**\n * Destroys a GridFS object. Call this when finished with\n * the object..\n *\n * @param gfs a grid\n */\nMONGO_EXPORT void gridfs_destroy( gridfs *gfs );\n\n/**\n *  Initializes a gridfile for writing incrementally with gridfs_write_buffer.\n *  Once initialized, you can write any number of buffers with gridfs_write_buffer.\n *  When done, you must call gridfs_writer_done to save the file metadata.\n *\n */\nMONGO_EXPORT void gridfile_writer_init( gridfile *gfile, gridfs *gfs, const char *remote_name,\n                                        const char *content_type );\n\n/**\n *  Write to a GridFS file incrementally. You can call this function any number\n *  of times with a new buffer each time. This allows you to effectively\n *  stream to a GridFS file. When finished, be sure to call gridfs_writer_done.\n *\n */\nMONGO_EXPORT void gridfile_write_buffer( gridfile *gfile, const char *data,\n        gridfs_offset length );\n\n/**\n *  Signal that writing of this gridfile is complete by\n *  writing any buffered chunks along with the entry in the\n *  files collection.\n *\n *  @return - MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfile_writer_done( gridfile *gfile );\n\n/**\n *  Store a buffer as a GridFS file.\n *  @param gfs - the working GridFS\n *  @param data - pointer to buffer to store in GridFS\n *  @param length - length of the buffer\n *  @param remotename - filename for use in the database\n *  @param contenttype - optional MIME type for this object\n *\n *  @return - MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfs_store_buffer( gridfs *gfs, const char *data, gridfs_offset length,\n                                      const char *remotename,\n                                      const char *contenttype );\n\n/**\n *  Open the file referenced by filename and store it as a GridFS file.\n *  @param gfs - the working GridFS\n *  @param filename - local filename relative to the process\n *  @param remotename - optional filename for use in the database\n *  @param contenttype - optional MIME type for this object\n *\n *  @return - MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfs_store_file( gridfs *gfs, const char *filename,\n                                    const char *remotename, const char *contenttype );\n\n/**\n *  Removes the files referenced by filename from the db\n *  @param gfs - the working GridFS\n *  @param filename - the filename of the file/s to be removed\n */\nMONGO_EXPORT void gridfs_remove_filename( gridfs *gfs, const char *filename );\n\n/**\n *  Find the first file matching the provided query within the\n *  GridFS files collection, and return the file as a GridFile.\n *\n *  @param gfs - the working GridFS\n *  @param query - a pointer to the bson with the query data\n *  @param gfile - the output GridFile to be initialized\n *\n *  @return MONGO_OK if successful, MONGO_ERROR otherwise\n */\nMONGO_EXPORT int gridfs_find_query( gridfs *gfs, bson *query, gridfile *gfile );\n\n/**\n *  Find the first file referenced by filename within the GridFS\n *  and return it as a GridFile\n *  @param gfs - the working GridFS\n *  @param filename - filename of the file to find\n *  @param gfile - the output GridFile to be intialized\n *\n *  @return MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfs_find_filename( gridfs *gfs, const char *filename, gridfile *gfile );\n\n/**\n *  Initializes a GridFile containing the GridFS and file bson\n *  @param gfs - the GridFS where the GridFile is located\n *  @param meta - the file object\n *  @param gfile - the output GridFile that is being initialized\n *\n *  @return - MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfile_init( gridfs *gfs, bson *meta, gridfile *gfile );\n\n/**\n *  Destroys the GridFile\n *\n *  @param oGridFIle - the GridFile being destroyed\n */\nMONGO_EXPORT void gridfile_destroy( gridfile *gfile );\n\n/**\n *  Returns whether or not the GridFile exists\n *  @param gfile - the GridFile being examined\n */\nMONGO_EXPORT bson_bool_t gridfile_exists( gridfile *gfile );\n\n/**\n *  Returns the filename of GridFile\n *  @param gfile - the working GridFile\n *\n *  @return - the filename of the Gridfile\n */\nMONGO_EXPORT const char *gridfile_get_filename( gridfile *gfile );\n\n/**\n *  Returns the size of the chunks of the GridFile\n *  @param gfile - the working GridFile\n *\n *  @return - the size of the chunks of the Gridfile\n */\nMONGO_EXPORT int gridfile_get_chunksize( gridfile *gfile );\n\n/**\n *  Returns the length of GridFile's data\n *\n *  @param gfile - the working GridFile\n *\n *  @return - the length of the Gridfile's data\n */\nMONGO_EXPORT gridfs_offset gridfile_get_contentlength( gridfile *gfile );\n\n/**\n *  Returns the MIME type of the GridFile\n *\n *  @param gfile - the working GridFile\n *\n *  @return - the MIME type of the Gridfile\n *            (NULL if no type specified)\n */\nMONGO_EXPORT const char *gridfile_get_contenttype( gridfile *gfile );\n\n/**\n *  Returns the upload date of GridFile\n *\n *  @param gfile - the working GridFile\n *\n *  @return - the upload date of the Gridfile\n */\nMONGO_EXPORT bson_date_t gridfile_get_uploaddate( gridfile *gfile );\n\n/**\n *  Returns the MD5 of GridFile\n *\n *  @param gfile - the working GridFile\n *\n *  @return - the MD5 of the Gridfile\n */\nMONGO_EXPORT const char *gridfile_get_md5( gridfile *gfile );\n\n/**\n *  Returns the field in GridFile specified by name\n *\n *  @param gfile - the working GridFile\n *  @param name - the name of the field to be returned\n *\n *  @return - the data of the field specified\n *            (NULL if none exists)\n */\nconst char *gridfile_get_field( gridfile *gfile,\n                                const char *name );\n\n/**\n *  Returns a boolean field in GridFile specified by name\n *  @param gfile - the working GridFile\n *  @param name - the name of the field to be returned\n *\n *  @return - the boolean of the field specified\n *            (NULL if none exists)\n */\nbson_bool_t gridfile_get_boolean( gridfile *gfile,\n                                  const char *name );\n\n/**\n *  Returns the metadata of GridFile\n *  @param gfile - the working GridFile\n *\n *  @return - the metadata of the Gridfile in a bson object\n *            (an empty bson is returned if none exists)\n */\nMONGO_EXPORT void gridfile_get_metadata( gridfile *gfile, bson* out );\n\n/**\n *  Returns the number of chunks in the GridFile\n *  @param gfile - the working GridFile\n *\n *  @return - the number of chunks in the Gridfile\n */\nMONGO_EXPORT int gridfile_get_numchunks( gridfile *gfile );\n\n/**\n *  Returns chunk n of GridFile\n *  @param gfile - the working GridFile\n *\n *  @return - the nth chunk of the Gridfile\n */\nMONGO_EXPORT void gridfile_get_chunk( gridfile *gfile, int n, bson* out );\n\n/**\n *  Returns a mongo_cursor of *size* chunks starting with chunk *start*\n *\n *  @param gfile - the working GridFile\n *  @param start - the first chunk in the cursor\n *  @param size - the number of chunks to be returned\n *\n *  @return - mongo_cursor of the chunks (must be destroyed after use)\n */\nMONGO_EXPORT mongo_cursor *gridfile_get_chunks( gridfile *gfile, int start, int size );\n\n/**\n *  Writes the GridFile to a stream\n *\n *  @param gfile - the working GridFile\n *  @param stream - the file stream to write to\n */\nMONGO_EXPORT gridfs_offset gridfile_write_file( gridfile *gfile, FILE *stream );\n\n/**\n *  Reads length bytes from the GridFile to a buffer\n *  and updates the position in the file.\n *  (assumes the buffer is large enough)\n *  (if size is greater than EOF gridfile_read reads until EOF)\n *\n *  @param gfile - the working GridFile\n *  @param size - the amount of bytes to be read\n *  @param buf - the buffer to read to\n *\n *  @return - the number of bytes read\n */\nMONGO_EXPORT gridfs_offset gridfile_read( gridfile *gfile, gridfs_offset size, char *buf );\n\n/**\n *  Updates the position in the file\n *  (If the offset goes beyond the contentlength,\n *  the position is updated to the end of the file.)\n *\n *  @param gfile - the working GridFile\n *  @param offset - the position to update to\n *\n *  @return - resulting offset location\n */\nMONGO_EXPORT gridfs_offset gridfile_seek( gridfile *gfile, gridfs_offset offset );\n\n#endif\n", "/* mongo.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#include \"mongo.h\"\n#include \"md5.h\"\n#include \"env.h\"\n\n#include <string.h>\n\nMONGO_EXPORT mongo* mongo_create( void ) {\n    return (mongo*)bson_malloc(sizeof(mongo));\n}\n\n\nMONGO_EXPORT void mongo_dispose(mongo* conn) {\n    bson_free(conn);\n}\n\nMONGO_EXPORT int mongo_get_err(mongo* conn) {\n    return conn->err;\n}\n\n\nMONGO_EXPORT int mongo_is_connected(mongo* conn) {\n    return conn->connected != 0;\n}\n\n\nMONGO_EXPORT int mongo_get_op_timeout(mongo* conn) {\n    return conn->op_timeout_ms;\n}\n\n\nstatic const char* _get_host_port(mongo_host_port* hp) {\n    static char _hp[sizeof(hp->host)+12];\n    bson_sprintf(_hp, \"%s:%d\", hp->host, hp->port);\n    return _hp;\n}\n\n\nMONGO_EXPORT const char* mongo_get_primary(mongo* conn) {\n    mongo* conn_ = (mongo*)conn;\n    if( !(conn_->connected) || (conn_->primary->host[0] == '\\0') )\n        return NULL;\n    return _get_host_port(conn_->primary);\n}\n\n\nMONGO_EXPORT int mongo_get_socket(mongo* conn) {\n    mongo* conn_ = (mongo*)conn;\n    return conn_->sock;\n}\n\n\nMONGO_EXPORT int mongo_get_host_count(mongo* conn) {\n    mongo_replica_set* r = conn->replica_set;\n    mongo_host_port* hp;\n    int count = 0;\n    if (!r) return 0;\n    for (hp = r->hosts; hp; hp = hp->next)\n        ++count;\n    return count;\n}\n\n\nMONGO_EXPORT const char* mongo_get_host(mongo* conn, int i) {\n    mongo_replica_set* r = conn->replica_set;\n    mongo_host_port* hp;\n    int count = 0;\n    if (!r) return 0;\n    for (hp = r->hosts; hp; hp = hp->next) {\n        if (count == i)\n            return _get_host_port(hp);\n        ++count;\n    }\n    return 0;\n}\n\n\nMONGO_EXPORT mongo_cursor* mongo_cursor_create( void ) {\n    return (mongo_cursor*)bson_malloc(sizeof(mongo_cursor));\n}\n\n\nMONGO_EXPORT void mongo_cursor_dispose(mongo_cursor* cursor) {\n    bson_free(cursor);\n}\n\n\nMONGO_EXPORT int  mongo_get_server_err(mongo* conn) {\n    return conn->lasterrcode;\n}\n\n\nMONGO_EXPORT const char*  mongo_get_server_err_string(mongo* conn) {\n    return conn->lasterrstr;\n}\n\nMONGO_EXPORT void __mongo_set_error( mongo *conn, mongo_error_t err, const char *str,\n                                     int errcode ) {\n    int errstr_size, str_size;\n\n    conn->err = err;\n    conn->errcode = errcode;\n\n    if( str ) {\n        str_size = strlen( str ) + 1;\n        errstr_size = str_size > MONGO_ERR_LEN ? MONGO_ERR_LEN : str_size;\n        memcpy( conn->errstr, str, errstr_size );\n        conn->errstr[errstr_size-1] = '\\0';\n    }\n}\n\nMONGO_EXPORT void mongo_clear_errors( mongo *conn ) {\n    conn->err = 0;\n    conn->errcode = 0;\n    conn->lasterrcode = 0;\n    memset( conn->errstr, 0, MONGO_ERR_LEN );\n    memset( conn->lasterrstr, 0, MONGO_ERR_LEN );\n}\n\n/* Note: this function returns a char* which must be freed. */\nstatic char *mongo_ns_to_cmd_db( const char *ns ) {\n    char *current = NULL;\n    char *cmd_db_name = NULL;\n    int len = 0;\n\n    for( current = (char *)ns; *current != '.'; current++ ) {\n        len++;\n    }\n\n    cmd_db_name = (char *)bson_malloc( len + 6 );\n    strncpy( cmd_db_name, ns, len );\n    strncpy( cmd_db_name + len, \".$cmd\", 6 );\n\n    return cmd_db_name;\n}\n\nMONGO_EXPORT int mongo_validate_ns( mongo *conn, const char *ns ) {\n    char *last = NULL;\n    char *current = NULL;\n    const char *db_name = ns;\n    char *collection_name = NULL;\n    char errmsg[64];\n    int ns_len = 0;\n\n    /* If the first character is a '.', fail. */\n    if( *ns == '.' ) {\n        __mongo_set_error( conn, MONGO_NS_INVALID, \"ns cannot start with a '.'.\", 0 );\n        return MONGO_ERROR;\n    }\n\n    /* Find the division between database and collection names. */\n    for( current = (char *)ns; *current != '\\0'; current++ ) {\n        if( *current == '.' ) {\n            current++;\n            break;\n        }\n    }\n\n    /* Fail if the collection part starts with a dot. */\n    if( *current == '.' ) {\n        __mongo_set_error( conn, MONGO_NS_INVALID, \"ns cannot start with a '.'.\", 0 );\n        return MONGO_ERROR;\n    }\n\n    /* Fail if collection length is 0.\n     * or the ns doesn't contain a '.'. */\n    if( *current == '\\0' ) {\n        __mongo_set_error( conn, MONGO_NS_INVALID, \"Collection name missing.\", 0 );\n        return MONGO_ERROR;\n    }\n\n\n    /* Point to the beginning of the collection name. */\n    collection_name = current;\n\n    /* Ensure that the database name is greater than one char.*/\n    if( collection_name - 1 == db_name ) {\n        __mongo_set_error( conn, MONGO_NS_INVALID, \"Database name missing.\", 0 );\n        return MONGO_ERROR;\n    }\n\n    /* Go back and validate the database name. */\n    for( current = (char *)db_name; *current != '.'; current++ ) {\n        switch( *current ) {\n        case ' ':\n        case '$':\n        case '/':\n        case '\\\\':\n            __mongo_set_error( conn, MONGO_NS_INVALID,\n                               \"Database name may not contain ' ', '$', '/', or '\\\\'\", 0 );\n            return MONGO_ERROR;\n        default:\n            break;\n        }\n\n        ns_len++;\n    }\n\n    /* Add one to the length for the '.' character. */\n    ns_len++;\n\n    /* Now validate the collection name. */\n    for( current = collection_name; *current != '\\0'; current++ ) {\n\n        /* Cannot have two consecutive dots. */\n        if( last && *last == '.' && *current == '.' ) {\n            __mongo_set_error( conn, MONGO_NS_INVALID,\n                               \"Collection may not contain two consecutive '.'\", 0 );\n            return MONGO_ERROR;\n        }\n\n        /* Cannot contain a '$' */\n        if( *current == '$' ) {\n            __mongo_set_error( conn, MONGO_NS_INVALID,\n                               \"Collection may not contain '$'\", 0 );\n            return MONGO_ERROR;\n        }\n\n        last = current;\n        ns_len++;\n    }\n\n    if( ns_len > 128 ) {\n        bson_sprintf( errmsg, \"Namespace too long; has %d but must <= 128.\",\n                      ns_len );\n        __mongo_set_error( conn, MONGO_NS_INVALID, errmsg, 0 );\n        return MONGO_ERROR;\n    }\n\n    /* Cannot end with a '.' */\n    if( *(current - 1) == '.' ) {\n        __mongo_set_error( conn, MONGO_NS_INVALID,\n                           \"Collection may not end with '.'\", 0 );\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\nstatic void mongo_set_last_error( mongo *conn, bson_iterator *it, bson *obj ) {\n    int result_len = bson_iterator_string_len( it );\n    const char *result_string = bson_iterator_string( it );\n    int len = result_len < MONGO_ERR_LEN ? result_len : MONGO_ERR_LEN;\n    memcpy( conn->lasterrstr, result_string, len );\n\n    if( bson_find( it, obj, \"code\" ) != BSON_NULL )\n        conn->lasterrcode = bson_iterator_int( it );\n}\n\nstatic const int ZERO = 0;\nstatic const int ONE = 1;\nstatic mongo_message *mongo_message_create( int len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n\n    if ( !id )\n        id = rand();\n\n    /* native endian (converted on send) */\n    mm->head.len = len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n\n    return mm;\n}\n\n/* Always calls bson_free(mm) */\nstatic int mongo_message_send( mongo *conn, mongo_message *mm ) {\n    mongo_header head; /* little endian */\n    int res;\n    bson_little_endian32( &head.len, &mm->head.len );\n    bson_little_endian32( &head.id, &mm->head.id );\n    bson_little_endian32( &head.responseTo, &mm->head.responseTo );\n    bson_little_endian32( &head.op, &mm->head.op );\n\n    res = mongo_env_write_socket( conn, &head, sizeof( head ) );\n    if( res != MONGO_OK ) {\n        bson_free( mm );\n        return res;\n    }\n\n    res = mongo_env_write_socket( conn, &mm->data, mm->head.len - sizeof( head ) );\n    if( res != MONGO_OK ) {\n        bson_free( mm );\n        return res;\n    }\n\n    bson_free( mm );\n    return MONGO_OK;\n}\n\nstatic int mongo_read_response( mongo *conn, mongo_reply **reply ) {\n    mongo_header head; /* header from network */\n    mongo_reply_fields fields; /* header from network */\n    mongo_reply *out;  /* native endian */\n    unsigned int len;\n    int res;\n\n    mongo_env_read_socket( conn, &head, sizeof( head ) );\n    mongo_env_read_socket( conn, &fields, sizeof( fields ) );\n\n    bson_little_endian32( &len, &head.len );\n\n    if ( len < sizeof( head )+sizeof( fields ) || len > 64*1024*1024 )\n        return MONGO_READ_SIZE_ERROR;  /* most likely corruption */\n\n    out = ( mongo_reply * )bson_malloc( len );\n\n    out->head.len = len;\n    bson_little_endian32( &out->head.id, &head.id );\n    bson_little_endian32( &out->head.responseTo, &head.responseTo );\n    bson_little_endian32( &out->head.op, &head.op );\n\n    bson_little_endian32( &out->fields.flag, &fields.flag );\n    bson_little_endian64( &out->fields.cursorID, &fields.cursorID );\n    bson_little_endian32( &out->fields.start, &fields.start );\n    bson_little_endian32( &out->fields.num, &fields.num );\n\n    res = mongo_env_read_socket( conn, &out->objs, len-sizeof( head )-sizeof( fields ) );\n    if( res != MONGO_OK ) {\n        bson_free( out );\n        return res;\n    }\n\n    *reply = out;\n\n    return MONGO_OK;\n}\n\n\nstatic char *mongo_data_append( char *start , const void *data , int len ) {\n    memcpy( start , data , len );\n    return start + len;\n}\n\nstatic char *mongo_data_append32( char *start , const void *data ) {\n    bson_little_endian32( start , data );\n    return start + 4;\n}\n\nstatic char *mongo_data_append64( char *start , const void *data ) {\n    bson_little_endian64( start , data );\n    return start + 8;\n}\n\n/* Connection API */\n\nstatic int mongo_check_is_master( mongo *conn ) {\n    bson out;\n    bson_iterator it;\n    bson_bool_t ismaster = 0;\n    int max_bson_size = MONGO_DEFAULT_MAX_BSON_SIZE;\n\n    out.data = NULL;\n\n    if ( mongo_simple_int_command( conn, \"admin\", \"ismaster\", 1, &out ) == MONGO_OK ) {\n        if( bson_find( &it, &out, \"ismaster\" ) )\n            ismaster = bson_iterator_bool( &it );\n        if( bson_find( &it, &out, \"maxBsonObjectSize\" ) ) {\n            max_bson_size = bson_iterator_int( &it );\n        }\n        conn->max_bson_size = max_bson_size;\n    }\n    else {\n        return MONGO_ERROR;\n    }\n\n    bson_destroy( &out );\n\n    if( ismaster )\n        return MONGO_OK;\n    else {\n        conn->err = MONGO_CONN_NOT_MASTER;\n        return MONGO_ERROR;\n    }\n}\n\nMONGO_EXPORT void mongo_init_sockets( void ) {\n    mongo_env_sock_init();\n}\n\n/* WC1 is completely static */\nstatic char WC1_data[] = {23,0,0,0,16,103,101,116,108,97,115,116,101,114,114,111,114,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0};\nstatic bson WC1_cmd = {\n    WC1_data, WC1_data, 128, 1, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 0, 0, \"\"\n};\nstatic mongo_write_concern WC1 = { 1, 0, 0, 0, 0, &WC1_cmd }; /* w = 1 */\n\nMONGO_EXPORT void mongo_init( mongo *conn ) {\n    memset( conn, 0, sizeof( mongo ) );\n    conn->max_bson_size = MONGO_DEFAULT_MAX_BSON_SIZE;\n    mongo_set_write_concern( conn, &WC1 );\n}\n\nMONGO_EXPORT int mongo_client( mongo *conn , const char *host, int port ) {\n    mongo_init( conn );\n\n    conn->primary = bson_malloc( sizeof( mongo_host_port ) );\n    strncpy( conn->primary->host, host, strlen( host ) + 1 );\n    conn->primary->port = port;\n    conn->primary->next = NULL;\n\n    if( mongo_env_socket_connect( conn, host, port ) != MONGO_OK )\n        return MONGO_ERROR;\n\n    if( mongo_check_is_master( conn ) != MONGO_OK )\n        return MONGO_ERROR;\n    else\n        return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_connect( mongo *conn , const char *host, int port ) {\n    int ret;\n    bson_errprintf(\"WARNING: mongo_connect() is deprecated, please use mongo_client()\\n\");\n    ret = mongo_client( conn, host, port );\n    mongo_set_write_concern( conn, 0 );\n    return ret;\n}\n\nMONGO_EXPORT void mongo_replica_set_init( mongo *conn, const char *name ) {\n    mongo_init( conn );\n\n    conn->replica_set = bson_malloc( sizeof( mongo_replica_set ) );\n    conn->replica_set->primary_connected = 0;\n    conn->replica_set->seeds = NULL;\n    conn->replica_set->hosts = NULL;\n    conn->replica_set->name = ( char * )bson_malloc( strlen( name ) + 1 );\n    memcpy( conn->replica_set->name, name, strlen( name ) + 1  );\n\n    conn->primary = bson_malloc( sizeof( mongo_host_port ) );\n    conn->primary->host[0] = '\\0';\n    conn->primary->next = NULL;\n}\n\nMONGO_EXPORT void mongo_replset_init( mongo *conn, const char *name ) {\n    bson_errprintf(\"WARNING: mongo_replset_init() is deprecated, please use mongo_replica_set_init()\\n\");\n    mongo_replica_set_init( conn, name );\n}\n\nstatic void mongo_replica_set_add_node( mongo_host_port **list, const char *host, int port ) {\n    mongo_host_port *host_port = bson_malloc( sizeof( mongo_host_port ) );\n    host_port->port = port;\n    host_port->next = NULL;\n    strncpy( host_port->host, host, strlen( host ) + 1 );\n\n    if( *list == NULL )\n        *list = host_port;\n    else {\n        mongo_host_port *p = *list;\n        while( p->next != NULL )\n            p = p->next;\n        p->next = host_port;\n    }\n}\n\nstatic void mongo_replica_set_free_list( mongo_host_port **list ) {\n    mongo_host_port *node = *list;\n    mongo_host_port *prev;\n\n    while( node != NULL ) {\n        prev = node;\n        node = node->next;\n        bson_free( prev );\n    }\n\n    *list = NULL;\n}\n\nMONGO_EXPORT void mongo_replica_set_add_seed( mongo *conn, const char *host, int port ) {\n    mongo_replica_set_add_node( &conn->replica_set->seeds, host, port );\n}\n\nMONGO_EXPORT void mongo_replset_add_seed( mongo *conn, const char *host, int port ) {\n    bson_errprintf(\"WARNING: mongo_replset_add_seed() is deprecated, please use mongo_replica_set_add_seed()\\n\");\n    mongo_replica_set_add_node( &conn->replica_set->seeds, host, port );\n}\n\nvoid mongo_parse_host( const char *host_string, mongo_host_port *host_port ) {\n    int len, idx, split;\n    len = split = idx = 0;\n\n    /* Split the host_port string at the ':' */\n    while( 1 ) {\n        if( *( host_string + len ) == '\\0' )\n            break;\n        if( *( host_string + len ) == ':' )\n            split = len;\n\n        len++;\n    }\n\n    /* If 'split' is set, we know the that port exists;\n     * Otherwise, we set the default port. */\n    idx = split ? split : len;\n    memcpy( host_port->host, host_string, idx );\n    memcpy( host_port->host + idx, \"\\0\", 1 );\n    if( split )\n        host_port->port = atoi( host_string + idx + 1 );\n    else\n        host_port->port = MONGO_DEFAULT_PORT;\n}\n\nstatic void mongo_replica_set_check_seed( mongo *conn ) {\n    bson out;\n    bson hosts;\n    const char *data;\n    bson_iterator it;\n    bson_iterator it_sub;\n    const char *host_string;\n    mongo_host_port *host_port = NULL;\n\n    out.data = NULL;\n\n    hosts.data = NULL;\n\n    if( mongo_simple_int_command( conn, \"admin\", \"ismaster\", 1, &out ) == MONGO_OK ) {\n\n        if( bson_find( &it, &out, \"hosts\" ) ) {\n            data = bson_iterator_value( &it );\n            bson_iterator_from_buffer( &it_sub, data );\n\n            /* Iterate over host list, adding each host to the\n             * connection's host list. */\n            while( bson_iterator_next( &it_sub ) ) {\n                host_string = bson_iterator_string( &it_sub );\n\n                host_port = bson_malloc( sizeof( mongo_host_port ) );\n\n                if( host_port ) {\n                    mongo_parse_host( host_string, host_port );\n                    mongo_replica_set_add_node( &conn->replica_set->hosts,\n                                                host_port->host, host_port->port );\n\n                    bson_free( host_port );\n                    host_port = NULL;\n                }\n            }\n        }\n    }\n\n    bson_destroy( &out );\n    bson_destroy( &hosts );\n    mongo_env_close_socket( conn->sock );\n    conn->sock = 0;\n    conn->connected = 0;\n\n}\n\n/* Find out whether the current connected node is master, and\n * verify that the node's replica set name matched the provided name\n */\nstatic int mongo_replica_set_check_host( mongo *conn ) {\n\n    bson out;\n    bson_iterator it;\n    bson_bool_t ismaster = 0;\n    const char *set_name;\n    int max_bson_size = MONGO_DEFAULT_MAX_BSON_SIZE;\n\n    out.data = NULL;\n\n    if ( mongo_simple_int_command( conn, \"admin\", \"ismaster\", 1, &out ) == MONGO_OK ) {\n        if( bson_find( &it, &out, \"ismaster\" ) )\n            ismaster = bson_iterator_bool( &it );\n\n        if( bson_find( &it, &out, \"maxBsonObjectSize\" ) )\n            max_bson_size = bson_iterator_int( &it );\n        conn->max_bson_size = max_bson_size;\n\n        if( bson_find( &it, &out, \"setName\" ) ) {\n            set_name = bson_iterator_string( &it );\n            if( strcmp( set_name, conn->replica_set->name ) != 0 ) {\n                bson_destroy( &out );\n                conn->err = MONGO_CONN_BAD_SET_NAME;\n                return MONGO_ERROR;\n            }\n        }\n    }\n\n    bson_destroy( &out );\n\n    if( ismaster ) {\n        conn->replica_set->primary_connected = 1;\n    }\n    else {\n        mongo_env_close_socket( conn->sock );\n    }\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_replica_set_client( mongo *conn ) {\n\n    int res = 0;\n    mongo_host_port *node;\n\n    conn->sock = 0;\n    conn->connected = 0;\n\n    /* First iterate over the seed nodes to get the canonical list of hosts\n     * from the replica set. Break out once we have a host list.\n     */\n    node = conn->replica_set->seeds;\n    while( node != NULL ) {\n        res = mongo_env_socket_connect( conn, ( const char * )&node->host, node->port );\n        if( res == MONGO_OK ) {\n            mongo_replica_set_check_seed( conn );\n            if( conn->replica_set->hosts )\n                break;\n        }\n        node = node->next;\n    }\n\n    /* Iterate over the host list, checking for the primary node. */\n    if( !conn->replica_set->hosts ) {\n        conn->err = MONGO_CONN_NO_PRIMARY;\n        return MONGO_ERROR;\n    }\n    else {\n        node = conn->replica_set->hosts;\n\n        while( node != NULL ) {\n            res = mongo_env_socket_connect( conn, ( const char * )&node->host, node->port );\n\n            if( res == MONGO_OK ) {\n                if( mongo_replica_set_check_host( conn ) != MONGO_OK )\n                    return MONGO_ERROR;\n\n                /* Primary found, so return. */\n                else if( conn->replica_set->primary_connected ) {\n                    conn->primary = bson_malloc( sizeof( mongo_host_port ) );\n                    strncpy( conn->primary->host, node->host, strlen( node->host ) + 1 );\n                    conn->primary->port = node->port;\n                    return MONGO_OK;\n                }\n\n                /* No primary, so close the connection. */\n                else {\n                    mongo_env_close_socket( conn->sock );\n                    conn->sock = 0;\n                    conn->connected = 0;\n                }\n            }\n\n            node = node->next;\n        }\n    }\n\n\n    conn->err = MONGO_CONN_NO_PRIMARY;\n    return MONGO_ERROR;\n}\n\nMONGO_EXPORT int mongo_replset_connect( mongo *conn ) {\n    int ret;\n    bson_errprintf(\"WARNING: mongo_replset_connect() is deprecated, please use mongo_replica_set_client()\\n\");\n    ret = mongo_replica_set_client( conn );\n    mongo_set_write_concern( conn, 0 );\n    return ret;\n}\n\nMONGO_EXPORT int mongo_set_op_timeout( mongo *conn, int millis ) {\n    conn->op_timeout_ms = millis;\n    if( conn->sock && conn->connected )\n        mongo_env_set_socket_op_timeout( conn, millis );\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_reconnect( mongo *conn ) {\n    int res;\n    mongo_disconnect( conn );\n\n    if( conn->replica_set ) {\n        conn->replica_set->primary_connected = 0;\n        mongo_replica_set_free_list( &conn->replica_set->hosts );\n        conn->replica_set->hosts = NULL;\n        res = mongo_replica_set_client( conn );\n        return res;\n    }\n    else\n        return mongo_env_socket_connect( conn, conn->primary->host, conn->primary->port );\n}\n\nMONGO_EXPORT int mongo_check_connection( mongo *conn ) {\n    if( ! conn->connected )\n        return MONGO_ERROR;\n\n    if( mongo_simple_int_command( conn, \"admin\", \"ping\", 1, NULL ) == MONGO_OK )\n        return MONGO_OK;\n    else\n        return MONGO_ERROR;\n}\n\nMONGO_EXPORT void mongo_disconnect( mongo *conn ) {\n    if( ! conn->connected )\n        return;\n\n    if( conn->replica_set ) {\n        conn->replica_set->primary_connected = 0;\n        mongo_replica_set_free_list( &conn->replica_set->hosts );\n        conn->replica_set->hosts = NULL;\n    }\n\n    mongo_env_close_socket( conn->sock );\n\n    conn->sock = 0;\n    conn->connected = 0;\n}\n\nMONGO_EXPORT void mongo_destroy( mongo *conn ) {\n    mongo_disconnect( conn );\n\n    if( conn->replica_set ) {\n        mongo_replica_set_free_list( &conn->replica_set->seeds );\n        mongo_replica_set_free_list( &conn->replica_set->hosts );\n        bson_free( conn->replica_set->name );\n        bson_free( conn->replica_set );\n        conn->replica_set = NULL;\n    }\n\n    bson_free( conn->primary );\n\n    mongo_clear_errors( conn );\n}\n\n/* Determine whether this BSON object is valid for the given operation.  */\nstatic int mongo_bson_valid( mongo *conn, const bson *bson, int write ) {\n    int size;\n\n    if( ! bson->finished ) {\n        conn->err = MONGO_BSON_NOT_FINISHED;\n        return MONGO_ERROR;\n    }\n\n    size = bson_size( bson );\n    if( size > conn->max_bson_size ) {\n        conn->err = MONGO_BSON_TOO_LARGE;\n        return MONGO_ERROR;\n    }\n\n    if( bson->err & BSON_NOT_UTF8 ) {\n        conn->err = MONGO_BSON_INVALID;\n        return MONGO_ERROR;\n    }\n\n    if( write ) {\n        if( ( bson->err & BSON_FIELD_HAS_DOT ) ||\n                ( bson->err & BSON_FIELD_INIT_DOLLAR ) ) {\n\n            conn->err = MONGO_BSON_INVALID;\n            return MONGO_ERROR;\n\n        }\n    }\n\n    conn->err = 0;\n\n    return MONGO_OK;\n}\n\n/* Determine whether this BSON object is valid for the given operation.  */\nstatic int mongo_cursor_bson_valid( mongo_cursor *cursor, const bson *bson ) {\n    if( ! bson->finished ) {\n        cursor->err = MONGO_CURSOR_BSON_ERROR;\n        cursor->conn->err = MONGO_BSON_NOT_FINISHED;\n        return MONGO_ERROR;\n    }\n\n    if( bson->err & BSON_NOT_UTF8 ) {\n        cursor->err = MONGO_CURSOR_BSON_ERROR;\n        cursor->conn->err = MONGO_BSON_INVALID;\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\nstatic int mongo_check_last_error( mongo *conn, const char *ns,\n                                   mongo_write_concern *write_concern ) {\n    int ret = MONGO_OK;\n    bson response = {NULL, 0};\n    bson fields;\n    bson_iterator it;\n    int res = 0;\n    char *cmd_ns = mongo_ns_to_cmd_db( ns );\n\n    res = mongo_find_one( conn, cmd_ns, write_concern->cmd, bson_empty( &fields ), &response );\n    bson_free( cmd_ns );\n\n    if( res != MONGO_OK )\n        ret = MONGO_ERROR;\n    else {\n        if( ( bson_find( &it, &response, \"$err\" ) == BSON_STRING ) ||\n                ( bson_find( &it, &response, \"err\" ) == BSON_STRING ) ) {\n\n            __mongo_set_error( conn, MONGO_WRITE_ERROR,\n                               \"See conn->lasterrstr for details.\", 0 );\n            mongo_set_last_error( conn, &it, &response );\n            ret = MONGO_ERROR;\n        }\n        bson_destroy( &response );\n    }\n    return ret;\n}\n\nstatic int mongo_choose_write_concern( mongo *conn,\n                                       mongo_write_concern *custom_write_concern,\n                                       mongo_write_concern **write_concern ) {\n\n    if( custom_write_concern ) {\n        *write_concern = custom_write_concern;\n    }\n    else if( conn->write_concern ) {\n        *write_concern = conn->write_concern;\n    }\n    if ( *write_concern && (*write_concern)->w < 1 ) {\n        *write_concern = 0; /* do not generate getLastError request */\n    }\n    if( *write_concern && !((*write_concern)->cmd) ) {\n        __mongo_set_error( conn, MONGO_WRITE_CONCERN_INVALID,\n                           \"Must call mongo_write_concern_finish() before using *write_concern.\", 0 );\n        return MONGO_ERROR;\n    }\n    else\n        return MONGO_OK;\n}\n\n\n/*********************************************************************\nCRUD API\n**********************************************************************/\n\nMONGO_EXPORT int mongo_insert( mongo *conn, const char *ns,\n                               const bson *bson, mongo_write_concern *custom_write_concern ) {\n\n    char *data;\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n\n    if( mongo_validate_ns( conn, ns ) != MONGO_OK )\n        return MONGO_ERROR;\n\n    if( mongo_bson_valid( conn, bson, 1 ) != MONGO_OK ) {\n        return MONGO_ERROR;\n    }\n\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n\n    mm = mongo_message_create( 16 /* header */\n                               + 4 /* ZERO */\n                               + strlen( ns )\n                               + 1 + bson_size( bson )\n                               , 0, 0, MONGO_OP_INSERT );\n\n    data = &mm->data;\n    data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n    mongo_data_append( data, bson->data, bson_size( bson ) );\n\n\n    /* TODO: refactor so that we can send the insert message\n       and the getlasterror messages together. */\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}\n\nMONGO_EXPORT int mongo_insert_batch( mongo *conn, const char *ns,\n                                     const bson **bsons, int count, mongo_write_concern *custom_write_concern,\n                                     int flags ) {\n\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n    int i;\n    char *data;\n    int overhead =  16 + 4 + strlen( ns ) + 1;\n    int size = overhead;\n\n    if( mongo_validate_ns( conn, ns ) != MONGO_OK )\n        return MONGO_ERROR;\n\n    for( i=0; i<count; i++ ) {\n        size += bson_size( bsons[i] );\n        if( mongo_bson_valid( conn, bsons[i], 1 ) != MONGO_OK )\n            return MONGO_ERROR;\n    }\n\n    if( ( size - overhead ) > conn->max_bson_size ) {\n        conn->err = MONGO_BSON_TOO_LARGE;\n        return MONGO_ERROR;\n    }\n\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n\n    mm = mongo_message_create( size , 0 , 0 , MONGO_OP_INSERT );\n\n    data = &mm->data;\n    if( flags & MONGO_CONTINUE_ON_ERROR )\n        data = mongo_data_append32( data, &ONE );\n    else\n        data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n\n    for( i=0; i<count; i++ ) {\n        data = mongo_data_append( data, bsons[i]->data, bson_size( bsons[i] ) );\n    }\n\n    /* TODO: refactor so that we can send the insert message\n     * and the getlasterror messages together. */\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}\n\nMONGO_EXPORT int mongo_update( mongo *conn, const char *ns, const bson *cond,\n                               const bson *op, int flags, mongo_write_concern *custom_write_concern ) {\n\n    char *data;\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n\n    /* Make sure that the op BSON is valid UTF-8.\n     * TODO: decide whether to check cond as well.\n     * */\n    if( mongo_bson_valid( conn, ( bson * )op, 0 ) != MONGO_OK ) {\n        return MONGO_ERROR;\n    }\n\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n\n    mm = mongo_message_create( 16 /* header */\n                               + 4  /* ZERO */\n                               + strlen( ns ) + 1\n                               + 4  /* flags */\n                               + bson_size( cond )\n                               + bson_size( op )\n                               , 0 , 0 , MONGO_OP_UPDATE );\n\n    data = &mm->data;\n    data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n    data = mongo_data_append32( data, &flags );\n    data = mongo_data_append( data, cond->data, bson_size( cond ) );\n    mongo_data_append( data, op->data, bson_size( op ) );\n\n    /* TODO: refactor so that we can send the insert message\n     * and the getlasterror messages together. */\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}\n\nMONGO_EXPORT int mongo_remove( mongo *conn, const char *ns, const bson *cond,\n                               mongo_write_concern *custom_write_concern ) {\n\n    char *data;\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n\n    /* Make sure that the BSON is valid UTF-8.\n     * TODO: decide whether to check cond as well.\n     * */\n    if( mongo_bson_valid( conn, ( bson * )cond, 0 ) != MONGO_OK ) {\n        return MONGO_ERROR;\n    }\n\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n\n    mm = mongo_message_create( 16  /* header */\n                               + 4  /* ZERO */\n                               + strlen( ns ) + 1\n                               + 4  /* ZERO */\n                               + bson_size( cond )\n                               , 0 , 0 , MONGO_OP_DELETE );\n\n    data = &mm->data;\n    data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n    data = mongo_data_append32( data, &ZERO );\n    mongo_data_append( data, cond->data, bson_size( cond ) );\n\n    /* TODO: refactor so that we can send the insert message\n     * and the getlasterror messages together. */\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}\n\n\n/*********************************************************************\nWrite Concern API\n**********************************************************************/\n\nMONGO_EXPORT void mongo_write_concern_init( mongo_write_concern *write_concern ) {\n    memset( write_concern, 0, sizeof( mongo_write_concern ) );\n}\n\nMONGO_EXPORT int mongo_write_concern_finish( mongo_write_concern *write_concern ) {\n    bson *command;\n\n    /* Destory any existing serialized write concern object and reuse it. */\n    if( write_concern->cmd ) {\n        bson_destroy( write_concern->cmd );\n        command = write_concern->cmd;\n    }\n    else\n        command = (bson *)bson_malloc( sizeof( bson ) );\n\n    if( !command ) {\n        return MONGO_ERROR;\n    }\n\n    bson_init( command );\n\n    bson_append_int( command, \"getlasterror\", 1 );\n\n    if( write_concern->mode ) {\n        bson_append_string( command, \"w\", write_concern->mode );\n    }\n\n    else if( write_concern->w && write_concern->w > 1 ) {\n        bson_append_int( command, \"w\", write_concern->w );\n    }\n\n    if( write_concern->wtimeout ) {\n        bson_append_int( command, \"wtimeout\", write_concern->wtimeout );\n    }\n\n    if( write_concern->j ) {\n        bson_append_int( command, \"j\", write_concern->j );\n    }\n\n    if( write_concern->fsync ) {\n        bson_append_int( command, \"fsync\", write_concern->fsync );\n    }\n\n    bson_finish( command );\n\n    /* write_concern now owns the BSON command object.\n     * This is freed in mongo_write_concern_destroy(). */\n    write_concern->cmd = command;\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT void mongo_write_concern_destroy( mongo_write_concern *write_concern ) {\n    if( !write_concern )\n        return;\n\n    if( write_concern->cmd )\n        bson_destroy( write_concern->cmd );\n\n    bson_free( write_concern->cmd );\n}\n\nMONGO_EXPORT void mongo_set_write_concern( mongo *conn,\n        mongo_write_concern *write_concern ) {\n\n    conn->write_concern = write_concern;\n}\n\n/**\n * Free the write_concern object (specifically, the BSON object that it holds).\n */\nMONGO_EXPORT void mongo_write_concern_destroy( mongo_write_concern *write_concern );\n\n\nstatic int mongo_cursor_op_query( mongo_cursor *cursor ) {\n    int res;\n    bson empty;\n    char *data;\n    mongo_message *mm;\n    bson temp;\n    bson_iterator it;\n\n    /* Clear any errors. */\n    mongo_clear_errors( cursor->conn );\n\n    /* Set up default values for query and fields, if necessary. */\n    if( ! cursor->query )\n        cursor->query = bson_empty( &empty );\n    else if( mongo_cursor_bson_valid( cursor, cursor->query ) != MONGO_OK )\n        return MONGO_ERROR;\n\n    if( ! cursor->fields )\n        cursor->fields = bson_empty( &empty );\n    else if( mongo_cursor_bson_valid( cursor, cursor->fields ) != MONGO_OK )\n        return MONGO_ERROR;\n\n    mm = mongo_message_create( 16 + /* header */\n                               4 + /*  options */\n                               strlen( cursor->ns ) + 1 + /* ns */\n                               4 + 4 + /* skip,return */\n                               bson_size( cursor->query ) +\n                               bson_size( cursor->fields ) ,\n                               0 , 0 , MONGO_OP_QUERY );\n\n    data = &mm->data;\n    data = mongo_data_append32( data , &cursor->options );\n    data = mongo_data_append( data , cursor->ns , strlen( cursor->ns ) + 1 );\n    data = mongo_data_append32( data , &cursor->skip );\n    data = mongo_data_append32( data , &cursor->limit );\n    data = mongo_data_append( data , cursor->query->data , bson_size( cursor->query ) );\n    if ( cursor->fields )\n        data = mongo_data_append( data , cursor->fields->data , bson_size( cursor->fields ) );\n\n    bson_fatal_msg( ( data == ( ( char * )mm ) + mm->head.len ), \"query building fail!\" );\n\n    res = mongo_message_send( cursor->conn , mm );\n    if( res != MONGO_OK ) {\n        return MONGO_ERROR;\n    }\n\n    res = mongo_read_response( cursor->conn, ( mongo_reply ** )&( cursor->reply ) );\n    if( res != MONGO_OK ) {\n        return MONGO_ERROR;\n    }\n\n    if( cursor->reply->fields.num == 1 ) {\n        bson_init_data( &temp, &cursor->reply->objs );\n        if( bson_find( &it, &temp, \"$err\" ) ) {\n            mongo_set_last_error( cursor->conn, &it, &temp );\n            cursor->err = MONGO_CURSOR_QUERY_FAIL;\n            return MONGO_ERROR;\n        }\n    }\n\n    cursor->seen += cursor->reply->fields.num;\n    cursor->flags |= MONGO_CURSOR_QUERY_SENT;\n    return MONGO_OK;\n}\n\nstatic int mongo_cursor_get_more( mongo_cursor *cursor ) {\n    int res;\n\n    if( cursor->limit > 0 && cursor->seen >= cursor->limit ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply ) {\n        cursor->err = MONGO_CURSOR_INVALID;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply->fields.cursorID ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else {\n        char *data;\n        int sl = strlen( cursor->ns )+1;\n        int limit = 0;\n        mongo_message *mm;\n\n        if( cursor->limit > 0 )\n            limit = cursor->limit - cursor->seen;\n\n        mm = mongo_message_create( 16 /*header*/\n                                   +4 /*ZERO*/\n                                   +sl\n                                   +4 /*numToReturn*/\n                                   +8 /*cursorID*/\n                                   , 0, 0, MONGO_OP_GET_MORE );\n        data = &mm->data;\n        data = mongo_data_append32( data, &ZERO );\n        data = mongo_data_append( data, cursor->ns, sl );\n        data = mongo_data_append32( data, &limit );\n        mongo_data_append64( data, &cursor->reply->fields.cursorID );\n\n        bson_free( cursor->reply );\n        res = mongo_message_send( cursor->conn, mm );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n\n        res = mongo_read_response( cursor->conn, &( cursor->reply ) );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        cursor->current.data = NULL;\n        cursor->seen += cursor->reply->fields.num;\n\n        return MONGO_OK;\n    }\n}\n\nMONGO_EXPORT mongo_cursor *mongo_find( mongo *conn, const char *ns, const bson *query,\n                                       const bson *fields, int limit, int skip, int options ) {\n\n    mongo_cursor *cursor = ( mongo_cursor * )bson_malloc( sizeof( mongo_cursor ) );\n    mongo_cursor_init( cursor, conn, ns );\n    cursor->flags |= MONGO_CURSOR_MUST_FREE;\n\n    mongo_cursor_set_query( cursor, query );\n    mongo_cursor_set_fields( cursor, fields );\n    mongo_cursor_set_limit( cursor, limit );\n    mongo_cursor_set_skip( cursor, skip );\n    mongo_cursor_set_options( cursor, options );\n\n    if( mongo_cursor_op_query( cursor ) == MONGO_OK )\n        return cursor;\n    else {\n        mongo_cursor_destroy( cursor );\n        return NULL;\n    }\n}\n\nMONGO_EXPORT int mongo_find_one( mongo *conn, const char *ns, const bson *query,\n                                 const bson *fields, bson *out ) {\n\n    mongo_cursor cursor[1];\n    mongo_cursor_init( cursor, conn, ns );\n    mongo_cursor_set_query( cursor, query );\n    mongo_cursor_set_fields( cursor, fields );\n    mongo_cursor_set_limit( cursor, 1 );\n\n    if ( mongo_cursor_next( cursor ) == MONGO_OK ) {\n        if( out ) {\n            bson_init_size( out, bson_size( (bson *)&cursor->current ) );\n            memcpy( out->data, cursor->current.data,\n                    bson_size( (bson *)&cursor->current ) );\n            out->finished = 1;\n        }\n        mongo_cursor_destroy( cursor );\n        return MONGO_OK;\n    }\n    else {\n        mongo_cursor_destroy( cursor );\n        return MONGO_ERROR;\n    }\n}\n\nMONGO_EXPORT void mongo_cursor_init( mongo_cursor *cursor, mongo *conn, const char *ns ) {\n    memset( cursor, 0, sizeof( mongo_cursor ) );\n    cursor->conn = conn;\n    cursor->ns = ( const char * )bson_malloc( strlen( ns ) + 1 );\n    strncpy( ( char * )cursor->ns, ns, strlen( ns ) + 1 );\n    cursor->current.data = NULL;\n}\n\nMONGO_EXPORT void mongo_cursor_set_query( mongo_cursor *cursor, const bson *query ) {\n    cursor->query = query;\n}\n\nMONGO_EXPORT void mongo_cursor_set_fields( mongo_cursor *cursor, const bson *fields ) {\n    cursor->fields = fields;\n}\n\nMONGO_EXPORT void mongo_cursor_set_skip( mongo_cursor *cursor, int skip ) {\n    cursor->skip = skip;\n}\n\nMONGO_EXPORT void mongo_cursor_set_limit( mongo_cursor *cursor, int limit ) {\n    cursor->limit = limit;\n}\n\nMONGO_EXPORT void mongo_cursor_set_options( mongo_cursor *cursor, int options ) {\n    cursor->options = options;\n}\n\nMONGO_EXPORT const char *mongo_cursor_data( mongo_cursor *cursor ) {\n    return cursor->current.data;\n}\n\nMONGO_EXPORT const bson *mongo_cursor_bson( mongo_cursor *cursor ) {\n    return (const bson *)&(cursor->current);\n}\n\nMONGO_EXPORT int mongo_cursor_next( mongo_cursor *cursor ) {\n    char *next_object;\n    char *message_end;\n\n    if( ! ( cursor->flags & MONGO_CURSOR_QUERY_SENT ) )\n        if( mongo_cursor_op_query( cursor ) != MONGO_OK )\n            return MONGO_ERROR;\n\n    if( !cursor->reply )\n        return MONGO_ERROR;\n\n    /* no data */\n    if ( cursor->reply->fields.num == 0 ) {\n\n        /* Special case for tailable cursors. */\n        if( cursor->reply->fields.cursorID ) {\n            if( ( mongo_cursor_get_more( cursor ) != MONGO_OK ) ||\n                    cursor->reply->fields.num == 0 ) {\n                return MONGO_ERROR;\n            }\n        }\n\n        else\n            return MONGO_ERROR;\n    }\n\n    /* first */\n    if ( cursor->current.data == NULL ) {\n        bson_init_finished_data( &cursor->current, &cursor->reply->objs );\n        return MONGO_OK;\n    }\n\n    next_object = cursor->current.data + bson_size( &cursor->current );\n    message_end = ( char * )cursor->reply + cursor->reply->head.len;\n\n    if ( next_object >= message_end ) {\n        if( mongo_cursor_get_more( cursor ) != MONGO_OK )\n            return MONGO_ERROR;\n\n        if ( cursor->reply->fields.num == 0 ) {\n            /* Special case for tailable cursors. */\n            if ( cursor->reply->fields.cursorID ) {\n                cursor->err = MONGO_CURSOR_PENDING;\n                return MONGO_ERROR;\n            }\n            else\n                return MONGO_ERROR;\n        }\n\n        bson_init_finished_data( &cursor->current, &cursor->reply->objs );\n    }\n    else {\n        bson_init_finished_data( &cursor->current, next_object );\n    }\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_cursor_destroy( mongo_cursor *cursor ) {\n    int result = MONGO_OK;\n\n    if ( !cursor ) return result;\n\n    /* Kill cursor if live. */\n    if ( cursor->reply && cursor->reply->fields.cursorID ) {\n        mongo *conn = cursor->conn;\n        mongo_message *mm = mongo_message_create( 16 /*header*/\n                            +4 /*ZERO*/\n                            +4 /*numCursors*/\n                            +8 /*cursorID*/\n                            , 0, 0, MONGO_OP_KILL_CURSORS );\n        char *data = &mm->data;\n        data = mongo_data_append32( data, &ZERO );\n        data = mongo_data_append32( data, &ONE );\n        mongo_data_append64( data, &cursor->reply->fields.cursorID );\n\n        result = mongo_message_send( conn, mm );\n    }\n\n    bson_free( cursor->reply );\n    bson_free( ( void * )cursor->ns );\n\n    if( cursor->flags & MONGO_CURSOR_MUST_FREE )\n        bson_free( cursor );\n\n    return result;\n}\n\n/* MongoDB Helper Functions */\n\nMONGO_EXPORT int mongo_create_index( mongo *conn, const char *ns, const bson *key, int options, bson *out ) {\n    bson b;\n    bson_iterator it;\n    char name[255] = {'_'};\n    int i = 1;\n    char idxns[1024];\n\n    bson_iterator_init( &it, key );\n    while( i < 255 && bson_iterator_next( &it ) ) {\n        strncpy( name + i, bson_iterator_key( &it ), 255 - i );\n        i += strlen( bson_iterator_key( &it ) );\n    }\n    name[254] = '\\0';\n\n    bson_init( &b );\n    bson_append_bson( &b, \"key\", key );\n    bson_append_string( &b, \"ns\", ns );\n    bson_append_string( &b, \"name\", name );\n    if ( options & MONGO_INDEX_UNIQUE )\n        bson_append_bool( &b, \"unique\", 1 );\n    if ( options & MONGO_INDEX_DROP_DUPS )\n        bson_append_bool( &b, \"dropDups\", 1 );\n    if ( options & MONGO_INDEX_BACKGROUND )\n        bson_append_bool( &b, \"background\", 1 );\n    if ( options & MONGO_INDEX_SPARSE )\n        bson_append_bool( &b, \"sparse\", 1 );\n    bson_finish( &b );\n\n    strncpy( idxns, ns, 1024-16 );\n    strcpy( strchr( idxns, '.' ), \".system.indexes\" );\n    mongo_insert( conn, idxns, &b, NULL );\n    bson_destroy( &b );\n\n    *strchr( idxns, '.' ) = '\\0'; /* just db not ns */\n    return mongo_cmd_get_last_error( conn, idxns, out );\n}\n\nMONGO_EXPORT bson_bool_t mongo_create_simple_index( mongo *conn, const char *ns, const char *field, int options, bson *out ) {\n    bson b;\n    bson_bool_t success;\n\n    bson_init( &b );\n    bson_append_int( &b, field, 1 );\n    bson_finish( &b );\n\n    success = mongo_create_index( conn, ns, &b, options, out );\n    bson_destroy( &b );\n    return success;\n}\n\nMONGO_EXPORT int mongo_create_capped_collection( mongo *conn, const char *db,\n        const char *collection, int size, int max, bson *out ) {\n\n    bson b;\n    int result;\n\n    bson_init( &b );\n    bson_append_string( &b, \"create\", collection );\n    bson_append_bool( &b, \"capped\", 1 );\n    bson_append_int( &b, \"size\", size );\n    if( max > 0 )\n        bson_append_int( &b, \"max\", size );\n    bson_finish( &b );\n\n    result = mongo_run_command( conn, db, &b, out );\n\n    bson_destroy( &b );\n\n    return result;\n}\n\nMONGO_EXPORT double mongo_count( mongo *conn, const char *db, const char *ns, const bson *query ) {\n    bson cmd;\n    bson out = {NULL, 0};\n    double count = -1;\n\n    bson_init( &cmd );\n    bson_append_string( &cmd, \"count\", ns );\n    if ( query && bson_size( query ) > 5 ) /* not empty */\n        bson_append_bson( &cmd, \"query\", query );\n    bson_finish( &cmd );\n\n    if( mongo_run_command( conn, db, &cmd, &out ) == MONGO_OK ) {\n        bson_iterator it;\n        if( bson_find( &it, &out, \"n\" ) )\n            count = bson_iterator_double( &it );\n        bson_destroy( &cmd );\n        bson_destroy( &out );\n        return count;\n    }\n    else {\n        bson_destroy( &out );\n        bson_destroy( &cmd );\n        return MONGO_ERROR;\n    }\n}\n\nMONGO_EXPORT int mongo_run_command( mongo *conn, const char *db, const bson *command,\n                                    bson *out ) {\n    int ret = MONGO_OK;\n    bson response = {NULL, 0};\n    bson fields;\n    int sl = strlen( db );\n    char *ns = bson_malloc( sl + 5 + 1 ); /* \".$cmd\" + nul */\n    int res, success = 0;\n\n    strcpy( ns, db );\n    strcpy( ns+sl, \".$cmd\" );\n\n    res = mongo_find_one( conn, ns, command, bson_empty( &fields ), &response );\n    bson_free( ns );\n\n    if( res != MONGO_OK )\n        ret = MONGO_ERROR;\n    else {\n        bson_iterator it;\n        if( bson_find( &it, &response, \"ok\" ) )\n            success = bson_iterator_bool( &it );\n\n        if( !success ) {\n            conn->err = MONGO_COMMAND_FAILED;\n            bson_destroy( &response );\n            ret = MONGO_ERROR;\n        }\n        else {\n            if( out )\n                *out = response;\n            else\n                bson_destroy( &response );\n        }\n    }\n    return ret;\n}\n\nMONGO_EXPORT int mongo_simple_int_command( mongo *conn, const char *db,\n        const char *cmdstr, int arg, bson *realout ) {\n\n    bson out = {NULL, 0};\n    bson cmd;\n    int result;\n\n    bson_init( &cmd );\n    bson_append_int( &cmd, cmdstr, arg );\n    bson_finish( &cmd );\n\n    result = mongo_run_command( conn, db, &cmd, &out );\n\n    bson_destroy( &cmd );\n\n    if ( realout )\n        *realout = out;\n    else\n        bson_destroy( &out );\n\n    return result;\n}\n\nMONGO_EXPORT int mongo_simple_str_command( mongo *conn, const char *db,\n        const char *cmdstr, const char *arg, bson *realout ) {\n\n    bson out = {NULL, 0};\n    int result;\n\n    bson cmd;\n    bson_init( &cmd );\n    bson_append_string( &cmd, cmdstr, arg );\n    bson_finish( &cmd );\n\n    result = mongo_run_command( conn, db, &cmd, &out );\n\n    bson_destroy( &cmd );\n\n    if ( realout )\n        *realout = out;\n    else\n        bson_destroy( &out );\n\n    return result;\n}\n\nMONGO_EXPORT int mongo_cmd_drop_db( mongo *conn, const char *db ) {\n    return mongo_simple_int_command( conn, db, \"dropDatabase\", 1, NULL );\n}\n\nMONGO_EXPORT int mongo_cmd_drop_collection( mongo *conn, const char *db, const char *collection, bson *out ) {\n    return mongo_simple_str_command( conn, db, \"drop\", collection, out );\n}\n\nMONGO_EXPORT void mongo_cmd_reset_error( mongo *conn, const char *db ) {\n    mongo_simple_int_command( conn, db, \"reseterror\", 1, NULL );\n}\n\nstatic int mongo_cmd_get_error_helper( mongo *conn, const char *db,\n                                       bson *realout, const char *cmdtype ) {\n\n    bson out = {NULL,0};\n    bson_bool_t haserror = 0;\n\n    /* Reset last error codes. */\n    mongo_clear_errors( conn );\n\n    /* If there's an error, store its code and string in the connection object. */\n    if( mongo_simple_int_command( conn, db, cmdtype, 1, &out ) == MONGO_OK ) {\n        bson_iterator it;\n        haserror = ( bson_find( &it, &out, \"err\" ) != BSON_NULL );\n        if( haserror ) mongo_set_last_error( conn, &it, &out );\n    }\n\n    if( realout )\n        *realout = out; /* transfer of ownership */\n    else\n        bson_destroy( &out );\n\n    if( haserror )\n        return MONGO_ERROR;\n    else\n        return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_cmd_get_prev_error( mongo *conn, const char *db, bson *out ) {\n    return mongo_cmd_get_error_helper( conn, db, out, \"getpreverror\" );\n}\n\nMONGO_EXPORT int mongo_cmd_get_last_error( mongo *conn, const char *db, bson *out ) {\n    return mongo_cmd_get_error_helper( conn, db, out, \"getlasterror\" );\n}\n\nMONGO_EXPORT bson_bool_t mongo_cmd_ismaster( mongo *conn, bson *realout ) {\n    bson out = {NULL,0};\n    bson_bool_t ismaster = 0;\n\n    if ( mongo_simple_int_command( conn, \"admin\", \"ismaster\", 1, &out ) == MONGO_OK ) {\n        bson_iterator it;\n        bson_find( &it, &out, \"ismaster\" );\n        ismaster = bson_iterator_bool( &it );\n    }\n\n    if( realout )\n        *realout = out; /* transfer of ownership */\n    else\n        bson_destroy( &out );\n\n    return ismaster;\n}\n\nstatic void digest2hex( mongo_md5_byte_t digest[16], char hex_digest[33] ) {\n    static const char hex[16] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n    int i;\n    for ( i=0; i<16; i++ ) {\n        hex_digest[2*i]     = hex[( digest[i] & 0xf0 ) >> 4];\n        hex_digest[2*i + 1] = hex[ digest[i] & 0x0f      ];\n    }\n    hex_digest[32] = '\\0';\n}\n\nstatic void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}\n\nMONGO_EXPORT int mongo_cmd_add_user( mongo *conn, const char *db, const char *user, const char *pass ) {\n    bson user_obj;\n    bson pass_obj;\n    char hex_digest[33];\n    char *ns = bson_malloc( strlen( db ) + strlen( \".system.users\" ) + 1 );\n    int res;\n\n    strcpy( ns, db );\n    strcpy( ns+strlen( db ), \".system.users\" );\n\n    mongo_pass_digest( user, pass, hex_digest );\n\n    bson_init( &user_obj );\n    bson_append_string( &user_obj, \"user\", user );\n    bson_finish( &user_obj );\n\n    bson_init( &pass_obj );\n    bson_append_start_object( &pass_obj, \"$set\" );\n    bson_append_string( &pass_obj, \"pwd\", hex_digest );\n    bson_append_finish_object( &pass_obj );\n    bson_finish( &pass_obj );\n\n    res = mongo_update( conn, ns, &user_obj, &pass_obj, MONGO_UPDATE_UPSERT, NULL );\n\n    bson_free( ns );\n    bson_destroy( &user_obj );\n    bson_destroy( &pass_obj );\n\n    return res;\n}\n\nMONGO_EXPORT bson_bool_t mongo_cmd_authenticate( mongo *conn, const char *db, const char *user, const char *pass ) {\n    bson from_db;\n    bson cmd;\n    const char *nonce;\n    int result;\n\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n    char hex_digest[33];\n\n    if( mongo_simple_int_command( conn, db, \"getnonce\", 1, &from_db ) == MONGO_OK ) {\n        bson_iterator it;\n        bson_find( &it, &from_db, \"nonce\" );\n        nonce = bson_iterator_string( &it );\n    }\n    else {\n        return MONGO_ERROR;\n    }\n\n    mongo_pass_digest( user, pass, hex_digest );\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )nonce, strlen( nonce ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )hex_digest, 32 );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n\n    bson_init( &cmd );\n    bson_append_int( &cmd, \"authenticate\", 1 );\n    bson_append_string( &cmd, \"user\", user );\n    bson_append_string( &cmd, \"nonce\", nonce );\n    bson_append_string( &cmd, \"key\", hex_digest );\n    bson_finish( &cmd );\n\n    bson_destroy( &from_db );\n\n    result = mongo_run_command( conn, db, &cmd, NULL );\n\n    bson_destroy( &cmd );\n\n    return result;\n}\n"], "fixing_code": ["/* bcon.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <assert.h>\n#include \"bcon.h\"\n\n#ifndef NOT_REACHED\n#define NOT_REACHED 0\n#endif\n\n#define ARRAY_INDEX_BUFFER_SIZE 9\n\nchar *bcon_errstr[] = {\n    \"OK\",\n    \"ERROR\",\n    \"bcon document or nesting incomplete\",\n    \"bson finish error\"\n};\n\nstatic int bcon_error(bson *b, const bcon *bc, size_t i, bcon_error_t err) {\n    b->err = err;\n    b->errstr = bcon_errstr[err];\n    return BCON_ERROR;\n}\n\nbcon_error_t bson_append_bcon_array(bson *b, const bcon *bc);\n\nstatic bcon_token_t bcon_token(char *s) {\n    if (s == 0) return Token_EOD;\n    switch (s[0]) {\n    case ':': if (s[1] != '\\0' && s[2] != '\\0' && s[3] != '\\0' && s[4] == '\\0' &&\n                      s[3] == ':' && (s[1] == '_' || s[1] == 'P' || s[1] == 'R'))\n            return Token_Typespec; break;\n    case '{': if (s[1] == '\\0') return Token_OpenBrace; break;\n    case '}': if (s[1] == '\\0') return Token_CloseBrace; break;\n    case '[': if (s[1] == '\\0') return Token_OpenBracket; break;\n    case ']': if (s[1] == '\\0') return Token_CloseBracket; break;\n    case '.': if (s[1] == '\\0') return Token_End; break;\n    }\n    return Token_Default;\n}\n\nstatic bcon_error_t bson_bcon_key_value(bson *b, const char *key, const char *typespec, const bcon bci) {\n    bcon_error_t ret = BCON_OK;\n    bson_oid_t oid;\n    char ptype = typespec ? typespec[1] : '_';\n    char utype = typespec ? typespec[2] : '_';\n    switch (ptype) {\n    case '_': /* kv(b, key, utype, bci) */\n        switch (utype) {\n        case '_': /* fall through */\n        case 's': bson_append_string( b, key, bci.s ); break; /* common case */\n        case 'f': bson_append_double( b, key, bci.f ); break;\n        case 'D':\n            bson_append_start_object( b, key );\n            ret = bson_append_bcon( b, bci.D );\n            bson_append_finish_object( b );\n            break;\n        case 'A':\n            bson_append_start_array( b, key );\n            ret = bson_append_bcon_array( b, bci.A );\n            bson_append_finish_array( b );\n            break;\n        case 'o': if (*bci.o == '\\0') bson_oid_gen( &oid ); else bson_oid_from_string( &oid, bci.o ); bson_append_oid( b, key, &oid ); break;\n        case 'b': bson_append_bool( b, key, bci.b ); break;\n        case 't': bson_append_time_t( b, key, bci.t ); break;\n        case 'v': bson_append_null( b, key ); break; /* void */\n        case 'x': bson_append_symbol( b, key, bci.x ); break;\n        case 'i': bson_append_int( b, key, bci.i ); break;\n        case 'l': bson_append_long( b, key, bci.l ); break;\n        default: printf(\"\\nptype:'%c' utype:'%c'\\n\", ptype, utype); assert(NOT_REACHED); break;\n        }\n        break;\n    case 'R': /* krv(b, key, utype, bci) */\n        switch (utype) {\n        case 'f': bson_append_double( b, key, *bci.Rf ); break;\n        case 's': bson_append_string( b, key, bci.Rs ); break;\n        case 'D':\n            bson_append_start_object( b, key );\n            ret = bson_append_bcon( b, bci.RD );\n            bson_append_finish_object( b );\n            break;\n        case 'A':\n            bson_append_start_array( b, key );\n            ret = bson_append_bcon_array( b, bci.RA );\n            bson_append_finish_array( b );\n            break;\n        case 'o': if (*bci.o == '\\0') bson_oid_gen( &oid ); else bson_oid_from_string( &oid, bci.o ); bson_append_oid( b, key, &oid ); break;\n        case 'b': bson_append_bool( b, key, *bci.Rb ); break;\n        case 't': bson_append_time_t( b, key, *bci.Rt ); break;\n        case 'x': bson_append_symbol( b, key, bci.Rx ); break;\n        case 'i': bson_append_int( b, key, *bci.Ri ); break;\n        case 'l': bson_append_long( b, key, *bci.Rl ); break;\n        default: printf(\"\\nptype:'%c' utype:'%c'\\n\", ptype, utype); assert(NOT_REACHED); break;\n        }\n        break;\n    case 'P': /* kpv(b, key, utype, bci) */\n        if (*bci.Pv != 0) {\n            switch (utype) {\n            case 'f': bson_append_double( b, key, **bci.Pf ); break;\n            case 's': bson_append_string( b, key, *bci.Ps ); break;\n            case 'D':\n                bson_append_start_object( b, key );\n                ret = bson_append_bcon( b, *bci.PD );\n                bson_append_finish_object( b );\n                break;\n            case 'A':\n                bson_append_start_array( b, key );\n                ret = bson_append_bcon_array( b, *bci.PA );\n                bson_append_finish_array( b );\n                break;\n            case 'o': if (**bci.Po == '\\0') bson_oid_gen( &oid );\n                else bson_oid_from_string( &oid, *bci.Po );\n                bson_append_oid( b, key, &oid );\n                break;\n            case 'b': bson_append_bool( b, key, **bci.Pb ); break;\n            case 't': bson_append_time_t( b, key, **bci.Pt ); break;\n            case 'x': if (*bci.Px != 0) bson_append_symbol( b, key, *bci.Px ); break;\n            case 'i': bson_append_int( b, key, **bci.Pi ); break;\n            case 'l': bson_append_long( b, key, **bci.Pl ); break;\n            default: printf(\"\\nptype:'%c' utype:'%c'\\n\", ptype, utype); assert(NOT_REACHED); break;\n            }\n        }\n        break;\n    default:\n        printf(\"\\nptype:'%c' utype:'%c'\\n\", ptype, utype); assert(NOT_REACHED);\n        break;\n    }\n    return ret;\n}\n\ntypedef enum bcon_state_t {\n    State_Element, State_DocSpecValue, State_DocValue,\n    State_ArraySpecValue, State_ArrayValue\n} bcon_state_t;\n\n#define DOC_STACK_SIZE 1024\n#define ARRAY_INDEX_STACK_SIZE 1024\n\n#define DOC_PUSH_STATE(return_state) ( doc_stack[doc_stack_pointer++] = (return_state) )\n#define DOC_POP_STATE ( state = doc_stack[--doc_stack_pointer] )\n#define ARRAY_PUSH_RESET_INDEX_STATE(return_state) ( array_index_stack[array_index_stack_pointer++] = array_index, array_index = 0, DOC_PUSH_STATE(return_state) )\n#define ARRAY_POP_INDEX_STATE ( array_index = array_index_stack[--array_index_stack_pointer], DOC_POP_STATE )\n\n#define ARRAY_KEY_STRING(l) (bson_numstr(array_index_buffer, (int)(l)), array_index_buffer)\n\n/*\n * simplified FSM to parse BCON structure, uses stacks for sub-documents and sub-arrays\n */\nstatic bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) {\n    bcon_error_t ret = BCON_OK;\n    bcon_state_t state = start_state;\n    char *key = 0;\n    char *typespec = 0;\n    unsigned char doc_stack[DOC_STACK_SIZE];\n    size_t doc_stack_pointer = 0;\n    size_t array_index = 0;\n    size_t array_index_stack[ARRAY_INDEX_STACK_SIZE];\n    size_t array_index_stack_pointer = 0;\n    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; /* max BSON size */\n    int end_of_data;\n    const bcon *bcp;\n    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        char *s = bci.s;\n        switch (state) {\n        case State_Element:\n            switch (bcon_token(s)) {\n            case Token_CloseBrace:\n                bson_append_finish_object( b );\n                DOC_POP_STATE; /* state = ...; */\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                key = s;\n                state = State_DocSpecValue;\n                break;\n            }\n            break;\n        case State_DocSpecValue:\n            switch (bcon_token(s)) {\n            case Token_Typespec:\n                typespec = s;\n                state = State_DocValue;\n                break;\n            case Token_OpenBrace:\n                bson_append_start_object( b, key );\n                DOC_PUSH_STATE(State_Element);\n                state = State_Element;\n                break;\n            case Token_OpenBracket:\n                bson_append_start_array( b, key );\n                ARRAY_PUSH_RESET_INDEX_STATE(State_Element);\n                state = State_ArraySpecValue;\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                ret = bson_bcon_key_value(b, key, typespec, bci);\n                state = State_Element;\n                break;\n            }\n            break;\n        case State_DocValue:\n            ret = bson_bcon_key_value(b, key, typespec, bci);\n            state = State_Element;\n            typespec = 0;\n            break;\n        case State_ArraySpecValue:\n            switch (bcon_token(s)) {\n            case Token_Typespec:\n                typespec = s;\n                state = State_ArrayValue;\n                break;\n            case Token_OpenBrace:\n                key = ARRAY_KEY_STRING(array_index++);\n                bson_append_start_object( b, key );\n                DOC_PUSH_STATE(State_ArraySpecValue);\n                state = State_Element;\n                break;\n            case Token_OpenBracket:\n                key = ARRAY_KEY_STRING(array_index++);\n                bson_append_start_array( b, key );\n                ARRAY_PUSH_RESET_INDEX_STATE(State_ArraySpecValue);\n                /* state = State_ArraySpecValue; */\n                break;\n            case Token_CloseBracket:\n                bson_append_finish_array( b );\n                ARRAY_POP_INDEX_STATE; /* state = ...; */\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                key = ARRAY_KEY_STRING(array_index++);\n                ret = bson_bcon_key_value(b, key, typespec, bci);\n                /* state = State_ArraySpecValue; */\n                break;\n            }\n            break;\n        case State_ArrayValue:\n            key = ARRAY_KEY_STRING(array_index++);\n            ret = bson_bcon_key_value(b, key, typespec, bci);\n            state = State_ArraySpecValue;\n            typespec = 0;\n            break;\n        default: assert(NOT_REACHED); break;\n        }\n    }\n    return state == start_state ? BCON_OK : BCON_DOCUMENT_INCOMPLETE;\n}\n\nbcon_error_t bson_append_bcon(bson *b, const bcon *bc) {\n    return bson_append_bcon_with_state(b, bc, State_Element);\n}\n\nbcon_error_t bson_append_bcon_array(bson *b, const bcon *bc) {\n    return bson_append_bcon_with_state(b, bc, State_ArraySpecValue);\n}\n\n/**\n * Generate BSON from BCON\n * @param b a BSON object\n * @param bc a BCON object\n * match with bson_destroy\n */\nbcon_error_t bson_from_bcon(bson *b, const bcon *bc) {\n    bcon_error_t ret = BSON_OK;\n    bson_init( b );\n    ret = bson_append_bcon_with_state( b, bc, State_Element );\n    if (ret != BCON_OK) return ret;\n    ret = bson_finish( b );\n    return ( ret == BSON_OK ? BCON_OK : BCON_BSON_ERROR );\n}\n\nvoid bcon_print(const bcon *bc) { /* prints internal representation, not JSON */\n    char *typespec = 0;\n    char *delim = \"\";\n    int end_of_data;\n    bcon *bcp;\n    putchar('{');\n    for (end_of_data = 0, bcp = (bcon*)bc; !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        char *typespec_next = 0;\n        if (typespec) {\n            switch (typespec[1]) {\n            case '_':\n                switch (typespec[2]) {\n                case 'f': printf(\"%s%f\", delim, bci.f); break;\n                case 's': printf(\"%s\\\"%s\\\"\", delim, bci.s); break;\n                case 'D': printf(\"%sPD(0x%lx,..)\", delim, (unsigned long)bci.D); break;\n                case 'A': printf(\"%sPA(0x%lx,....)\", delim, (unsigned long)bci.A); break;\n                case 'o': printf(\"%s\\\"%s\\\"\", delim, bci.o); break;\n                case 'b': printf(\"%s%d\", delim, bci.b); break;\n                case 't': printf(\"%s%ld\", delim, (long)bci.t); break;\n                case 'v': printf(\"%s\\\"%s\\\"\", delim, bci.v); break;\n                case 'x': printf(\"%s\\\"%s\\\"\", delim, bci.x); break;\n                case 'i': printf(\"%s%d\", delim, bci.i); break;\n                case 'l': printf(\"%s%ld\", delim, bci.l); break;\n                default: printf(\"\\ntypespec:\\\"%s\\\"\\n\", typespec); assert(NOT_REACHED); break;\n                }\n                break;\n            case 'R':\n                switch (typespec[2]) {\n                case 'f': printf(\"%sRf(0x%lx,%f)\", delim, (unsigned long)bci.Rf, *bci.Rf); break;\n                case 's': printf(\"%sRs(0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Rs, bci.Rs); break;\n                case 'D': printf(\"%sRD(0x%lx,..)\", delim, (unsigned long)bci.RD); break;\n                case 'A': printf(\"%sRA(0x%lx,....)\", delim, (unsigned long)bci.RA); break;\n                case 'o': printf(\"%sRo(0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Ro, bci.Ro); break;\n                case 'b': printf(\"%sRb(0x%lx,%d)\", delim, (unsigned long)bci.Rb, *bci.Rb); break;\n                case 't': printf(\"%sRt(0x%lx,%ld)\", delim, (unsigned long)bci.Rt, (long)*bci.Rt); break;\n                case 'x': printf(\"%sRx(0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Rx, bci.Rx); break;\n                case 'i': printf(\"%sRi(0x%lx,%d)\", delim, (unsigned long)bci.Ri, *bci.Ri); break;\n                case 'l': printf(\"%sRl(0x%lx,%ld)\", delim, (unsigned long)bci.Rl, *bci.Rl); break;\n                default: printf(\"\\ntypespec:\\\"%s\\\"\\n\", typespec); assert(NOT_REACHED); break;\n                }\n                break;\n            case 'P':\n                switch (typespec[2]) {\n                case 'f': printf(\"%sPf(0x%lx,0x%lx,%f)\", delim, (unsigned long)bci.Pf, (unsigned long)(bci.Pf ? *bci.Pf : 0), bci.Pf && *bci.Pf ? **bci.Pf : 0.0); break;\n                case 's': printf(\"%sPs(0x%lx,0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Ps, (unsigned long)(bci.Ps ? *bci.Ps : 0), bci.Ps && *bci.Ps ? *bci.Ps : \"\"); break;\n                case 'D': printf(\"%sPD(0x%lx,0x%lx,..)\", delim, (unsigned long)bci.PD, (unsigned long)(bci.PD ? *bci.PD : 0)); break;\n                case 'A': printf(\"%sPA(0x%lx,0x%lx,....)\", delim, (unsigned long)bci.PA, (unsigned long)(bci.PA ? *bci.PA : 0)); break;\n                case 'o': printf(\"%sPo(0x%lx,0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Po, (unsigned long)(bci.Po ? *bci.Po : 0), bci.Po && *bci.Po ? *bci.Po : \"\"); break;\n                case 'b': printf(\"%sPb(0x%lx,0x%lx,%d)\", delim, (unsigned long)bci.Pb, (unsigned long)(bci.Pb ? *bci.Pb : 0), bci.Pb && *bci.Pb ? **bci.Pb : 0); break;\n                case 't': printf(\"%sPt(0x%lx,0x%lx,%ld)\", delim, (unsigned long)bci.Pt, (unsigned long)(bci.Pt ? *bci.Pt : 0), bci.Pt && *bci.Pt ? (long)**bci.Pt : 0); break;\n                case 'x': printf(\"%sPx(0x%lx,0x%lx,\\\"%s\\\")\", delim, (unsigned long)bci.Px, (unsigned long)(bci.Px ? *bci.Px : 0), bci.Px && *bci.Px ? *bci.Px : \"\"); break;\n                case 'i': printf(\"%sPi(0x%lx,0x%lx,%d)\", delim, (unsigned long)bci.Pi, (unsigned long)(bci.Pi ? *bci.Pi : 0), bci.Pi && *bci.Pi ? **bci.Pi : 0); break;\n                case 'l': printf(\"%sPl(0x%lx,0x%lx,%ld)\", delim, (unsigned long)bci.Pl, (unsigned long)(bci.Pl ? *bci.Pl : 0), bci.Pl && *bci.Pl ? **bci.Pl : 0); break;\n\n                default: printf(\"\\ntypespec:\\\"%s\\\"\\n\", typespec); assert(NOT_REACHED); break;\n                }\n                break;\n            default:\n                printf(\"\\ntypespec:\\\"%s\\\"\\n\", typespec); assert(NOT_REACHED);\n                break;\n            }\n        }\n        else {\n            char *s = bci.s;\n            switch (s[0]) {\n            case '.':\n                end_of_data = (s[1] == '\\0');\n                break;\n            case ':':\n                typespec_next = bcon_token(s) == Token_Typespec ? s : 0;\n                break;\n            }\n            printf(\"%s\\\"%s\\\"\", delim, s);\n        }\n        typespec = typespec_next;\n        delim = \",\";\n    }\n    putchar('}');\n}\n\n/* TODO - incomplete */\nstatic void bcon_json_print(bcon *bc, int n) {\n    int t = 0;\n    int key_value_count = 0;\n    char *s;\n    int end_of_data;\n    bcon *bcp;\n    putchar('{');\n    for (end_of_data = 0, bcp = bc; !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        switch (t) {\n        case 'l':\n            if (key_value_count & 0x1) putchar(':');\n            printf(\"%ld\", bci.l);\n            t = 0;\n            key_value_count++;\n            break;\n        case 's': /* fall through */\n        default:\n            s = bci.s;\n            switch (*s) {\n            case ':':\n                ++s;\n                t = *++s;\n                break;\n            case '{':\n                if (key_value_count & 0x1) putchar(':');\n                putchar(*s);\n                key_value_count = 0;\n                break;\n            case '}':\n                putchar(*s);\n                key_value_count = 2;\n                break;\n            default:\n                if (key_value_count & 0x1) putchar(':');\n                else if (key_value_count > 1) putchar(',');\n                printf(\"\\\"%s\\\"\", s);\n                t = 0;\n                key_value_count++;\n                break;\n            }\n            break;\n        }\n    }\n    putchar('}');\n}\n", "/* bson.c */\n\n/*    Copyright 2009, 2010 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <time.h>\n#include <limits.h>\n\n#include \"bson.h\"\n#include \"encoding.h\"\n\nconst int initialBufferSize = 128;\n\n/* only need one of these */\nstatic const int zero = 0;\n\n/* Custom standard function pointers. */\nvoid *( *bson_malloc_func )( size_t ) = malloc;\nvoid *( *bson_realloc_func )( void *, size_t ) = realloc;\nvoid  ( *bson_free_func )( void * ) = free;\n#ifdef R_SAFETY_NET\nbson_printf_func bson_printf;\n#else\nbson_printf_func bson_printf = printf;\n#endif\nbson_fprintf_func bson_fprintf = fprintf;\nbson_sprintf_func bson_sprintf = sprintf;\n\nstatic int _bson_errprintf( const char *, ... );\nbson_printf_func bson_errprintf = _bson_errprintf;\n\n/* ObjectId fuzz functions. */\nstatic int ( *oid_fuzz_func )( void ) = NULL;\nstatic int ( *oid_inc_func )( void )  = NULL;\n\n/* ----------------------------\n   READING\n   ------------------------------ */\n\nMONGO_EXPORT bson* bson_create( void ) {\n    return (bson*)bson_malloc(sizeof(bson));\n}\n\nMONGO_EXPORT void bson_dispose(bson* b) {\n    bson_free(b);\n}\n\nMONGO_EXPORT bson *bson_empty( bson *obj ) {\n    static char *data = \"\\005\\0\\0\\0\\0\";\n    bson_init_data( obj, data );\n    obj->finished = 1;\n    obj->err = 0;\n    obj->errstr = NULL;\n    obj->stackPos = 0;\n    return obj;\n}\n\nMONGO_EXPORT int bson_copy( bson *out, const bson *in ) {\n    if ( !out || !in ) return BSON_ERROR;\n    if ( !in->finished ) return BSON_ERROR;\n    bson_init_size( out, bson_size( in ) );\n    memcpy( out->data, in->data, bson_size( in ) );\n    out->finished = 1;\n\n    return BSON_OK;\n}\n\nint bson_init_data( bson *b, char *data ) {\n    b->data = data;\n    return BSON_OK;\n}\n\nint bson_init_finished_data( bson *b, char *data ) {\n    bson_init_data( b, data );\n    b->finished = 1;\n    return BSON_OK;\n}\n\nstatic void _bson_reset( bson *b ) {\n    b->finished = 0;\n    b->stackPos = 0;\n    b->err = 0;\n    b->errstr = NULL;\n}\n\nMONGO_EXPORT int bson_size( const bson *b ) {\n    int i;\n    if ( ! b || ! b->data )\n        return 0;\n    bson_little_endian32( &i, b->data );\n    return i;\n}\n\nMONGO_EXPORT size_t bson_buffer_size( const bson *b ) {\n    return (b->cur - b->data + 1);\n}\n\n\nMONGO_EXPORT const char *bson_data( const bson *b ) {\n    return (const char *)b->data;\n}\n\nstatic char hexbyte( char hex ) {\n    if (hex >= '0' && hex <= '9')\n        return (hex - '0');\n    else if (hex >= 'A' && hex <= 'F')\n        return (hex - 'A' + 10);\n    else if (hex >= 'a' && hex <= 'f')\n        return (hex - 'a' + 10);\n    else\n        return 0x0;\n}\n\nMONGO_EXPORT void bson_oid_from_string( bson_oid_t *oid, const char *str ) {\n    int i;\n    for ( i=0; i<12; i++ ) {\n        oid->bytes[i] = ( hexbyte( str[2*i] ) << 4 ) | hexbyte( str[2*i + 1] );\n    }\n}\n\nMONGO_EXPORT void bson_oid_to_string( const bson_oid_t *oid, char *str ) {\n    static const char hex[16] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n    int i;\n    for ( i=0; i<12; i++ ) {\n        str[2*i]     = hex[( oid->bytes[i] & 0xf0 ) >> 4];\n        str[2*i + 1] = hex[ oid->bytes[i] & 0x0f      ];\n    }\n    str[24] = '\\0';\n}\n\nMONGO_EXPORT void bson_set_oid_fuzz( int ( *func )( void ) ) {\n    oid_fuzz_func = func;\n}\n\nMONGO_EXPORT void bson_set_oid_inc( int ( *func )( void ) ) {\n    oid_inc_func = func;\n}\n\nMONGO_EXPORT void bson_oid_gen( bson_oid_t *oid ) {\n    static int incr = 0;\n    static int fuzz = 0;\n    int i;\n    time_t t = time( NULL );\n\n    if( oid_inc_func )\n        i = oid_inc_func();\n    else\n        i = incr++;\n\n    if ( !fuzz ) {\n        if ( oid_fuzz_func )\n            fuzz = oid_fuzz_func();\n        else {\n            srand( ( int )t );\n            fuzz = rand();\n        }\n    }\n\n    bson_big_endian32( &oid->ints[0], &t );\n    oid->ints[1] = fuzz;\n    bson_big_endian32( &oid->ints[2], &i );\n}\n\nMONGO_EXPORT time_t bson_oid_generated_time( bson_oid_t *oid ) {\n    time_t out;\n    bson_big_endian32( &out, &oid->ints[0] );\n\n    return out;\n}\n\nMONGO_EXPORT void bson_print( const bson *b ) {\n    bson_print_raw( b->data , 0 );\n}\n\nMONGO_EXPORT void bson_print_raw( const char *data , int depth ) {\n    bson_iterator i;\n    const char *key;\n    int temp;\n    bson_timestamp_t ts;\n    char oidhex[25];\n    bson scope;\n    bson_iterator_from_buffer( &i, data );\n\n    while ( bson_iterator_next( &i ) ) {\n        bson_type t = bson_iterator_type( &i );\n        if ( t == 0 )\n            break;\n        key = bson_iterator_key( &i );\n\n        for ( temp=0; temp<=depth; temp++ )\n            bson_printf( \"\\t\" );\n        bson_printf( \"%s : %d \\t \" , key , t );\n        switch ( t ) {\n        case BSON_DOUBLE:\n            bson_printf( \"%f\" , bson_iterator_double( &i ) );\n            break;\n        case BSON_STRING:\n            bson_printf( \"%s\" , bson_iterator_string( &i ) );\n            break;\n        case BSON_SYMBOL:\n            bson_printf( \"SYMBOL: %s\" , bson_iterator_string( &i ) );\n            break;\n        case BSON_OID:\n            bson_oid_to_string( bson_iterator_oid( &i ), oidhex );\n            bson_printf( \"%s\" , oidhex );\n            break;\n        case BSON_BOOL:\n            bson_printf( \"%s\" , bson_iterator_bool( &i ) ? \"true\" : \"false\" );\n            break;\n        case BSON_DATE:\n            bson_printf( \"%ld\" , ( long int )bson_iterator_date( &i ) );\n            break;\n        case BSON_BINDATA:\n            bson_printf( \"BSON_BINDATA\" );\n            break;\n        case BSON_UNDEFINED:\n            bson_printf( \"BSON_UNDEFINED\" );\n            break;\n        case BSON_NULL:\n            bson_printf( \"BSON_NULL\" );\n            break;\n        case BSON_REGEX:\n            bson_printf( \"BSON_REGEX: %s\", bson_iterator_regex( &i ) );\n            break;\n        case BSON_CODE:\n            bson_printf( \"BSON_CODE: %s\", bson_iterator_code( &i ) );\n            break;\n        case BSON_CODEWSCOPE:\n            bson_printf( \"BSON_CODE_W_SCOPE: %s\", bson_iterator_code( &i ) );\n            /* bson_init( &scope ); */ /* review - stepped on by bson_iterator_code_scope? */\n            bson_iterator_code_scope( &i, &scope );\n            bson_printf( \"\\n\\t SCOPE: \" );\n            bson_print( &scope );\n            /* bson_destroy( &scope ); */ /* review - causes free error */\n            break;\n        case BSON_INT:\n            bson_printf( \"%d\" , bson_iterator_int( &i ) );\n            break;\n        case BSON_LONG:\n            bson_printf( \"%lld\" , ( uint64_t )bson_iterator_long( &i ) );\n            break;\n        case BSON_TIMESTAMP:\n            ts = bson_iterator_timestamp( &i );\n            bson_printf( \"i: %d, t: %d\", ts.i, ts.t );\n            break;\n        case BSON_OBJECT:\n        case BSON_ARRAY:\n            bson_printf( \"\\n\" );\n            bson_print_raw( bson_iterator_value( &i ) , depth + 1 );\n            break;\n        default:\n            bson_errprintf( \"can't print type : %d\\n\" , t );\n        }\n        bson_printf( \"\\n\" );\n    }\n}\n\n/* ----------------------------\n   ITERATOR\n   ------------------------------ */\n\nMONGO_EXPORT bson_iterator* bson_iterator_create( void ) {\n    return ( bson_iterator* )malloc( sizeof( bson_iterator ) );\n}\n\nMONGO_EXPORT void bson_iterator_dispose(bson_iterator* i) {\n    free(i);\n}\n\nMONGO_EXPORT void bson_iterator_init( bson_iterator *i, const bson *b ) {\n    i->cur = b->data + 4;\n    i->first = 1;\n}\n\nMONGO_EXPORT void bson_iterator_from_buffer( bson_iterator *i, const char *buffer ) {\n    i->cur = buffer + 4;\n    i->first = 1;\n}\n\nMONGO_EXPORT bson_type bson_find( bson_iterator *it, const bson *obj, const char *name ) {\n    bson_iterator_init( it, (bson *)obj );\n    while( bson_iterator_next( it ) ) {\n        if ( strcmp( name, bson_iterator_key( it ) ) == 0 )\n            break;\n    }\n    return bson_iterator_type( it );\n}\n\nMONGO_EXPORT bson_bool_t bson_iterator_more( const bson_iterator *i ) {\n    return *( i->cur );\n}\n\nMONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i ) {\n    size_t ds;\n\n    if ( i->first ) {\n        i->first = 0;\n        return ( bson_type )( *i->cur );\n    }\n\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_EOO:\n        return BSON_EOO; /* don't advance */\n    case BSON_UNDEFINED:\n    case BSON_NULL:\n        ds = 0;\n        break;\n    case BSON_BOOL:\n        ds = 1;\n        break;\n    case BSON_INT:\n        ds = 4;\n        break;\n    case BSON_LONG:\n    case BSON_DOUBLE:\n    case BSON_TIMESTAMP:\n    case BSON_DATE:\n        ds = 8;\n        break;\n    case BSON_OID:\n        ds = 12;\n        break;\n    case BSON_STRING:\n    case BSON_SYMBOL:\n    case BSON_CODE:\n        ds = 4 + bson_iterator_int_raw( i );\n        break;\n    case BSON_BINDATA:\n        ds = 5 + bson_iterator_int_raw( i );\n        break;\n    case BSON_OBJECT:\n    case BSON_ARRAY:\n    case BSON_CODEWSCOPE:\n        ds = bson_iterator_int_raw( i );\n        break;\n    case BSON_DBREF:\n        ds = 4+12 + bson_iterator_int_raw( i );\n        break;\n    case BSON_REGEX: {\n        const char *s = bson_iterator_value( i );\n        const char *p = s;\n        p += strlen( p )+1;\n        p += strlen( p )+1;\n        ds = p-s;\n        break;\n    }\n\n    default: {\n        char msg[] = \"unknown type: 000000000000\";\n        bson_numstr( msg+14, ( unsigned )( i->cur[0] ) );\n        bson_fatal_msg( 0, msg );\n        return 0;\n    }\n    }\n\n    i->cur += 1 + strlen( i->cur + 1 ) + 1 + ds;\n\n    return ( bson_type )( *i->cur );\n}\n\nMONGO_EXPORT bson_type bson_iterator_type( const bson_iterator *i ) {\n    return ( bson_type )i->cur[0];\n}\n\nMONGO_EXPORT const char *bson_iterator_key( const bson_iterator *i ) {\n    return i->cur + 1;\n}\n\nMONGO_EXPORT const char *bson_iterator_value( const bson_iterator *i ) {\n    const char *t = i->cur + 1;\n    t += strlen( t ) + 1;\n    return t;\n}\n\n/* types */\n\nint bson_iterator_int_raw( const bson_iterator *i ) {\n    int out;\n    bson_little_endian32( &out, bson_iterator_value( i ) );\n    return out;\n}\n\ndouble bson_iterator_double_raw( const bson_iterator *i ) {\n    double out;\n    bson_little_endian64( &out, bson_iterator_value( i ) );\n    return out;\n}\n\nint64_t bson_iterator_long_raw( const bson_iterator *i ) {\n    int64_t out;\n    bson_little_endian64( &out, bson_iterator_value( i ) );\n    return out;\n}\n\nbson_bool_t bson_iterator_bool_raw( const bson_iterator *i ) {\n    return bson_iterator_value( i )[0];\n}\n\nMONGO_EXPORT bson_oid_t *bson_iterator_oid( const bson_iterator *i ) {\n    return ( bson_oid_t * )bson_iterator_value( i );\n}\n\nMONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return ( int )bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}\n\nMONGO_EXPORT double bson_iterator_double( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}\n\nMONGO_EXPORT int64_t bson_iterator_long( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}\n\nMONGO_EXPORT bson_timestamp_t bson_iterator_timestamp( const bson_iterator *i ) {\n    bson_timestamp_t ts;\n    bson_little_endian32( &( ts.i ), bson_iterator_value( i ) );\n    bson_little_endian32( &( ts.t ), bson_iterator_value( i ) + 4 );\n    return ts;\n}\n\n\nMONGO_EXPORT int bson_iterator_timestamp_time( const bson_iterator *i ) {\n    int time;\n    bson_little_endian32( &time, bson_iterator_value( i ) + 4 );\n    return time;\n}\n\n\nMONGO_EXPORT int bson_iterator_timestamp_increment( const bson_iterator *i ) {\n    int increment;\n    bson_little_endian32( &increment, bson_iterator_value( i ) );\n    return increment;\n}\n\n\nMONGO_EXPORT bson_bool_t bson_iterator_bool( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_BOOL:\n        return bson_iterator_bool_raw( i );\n    case BSON_INT:\n        return bson_iterator_int_raw( i ) != 0;\n    case BSON_LONG:\n        return bson_iterator_long_raw( i ) != 0;\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i ) != 0;\n    case BSON_EOO:\n    case BSON_NULL:\n        return 0;\n    default:\n        return 1;\n    }\n}\n\nMONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_STRING:\n    case BSON_SYMBOL:\n        return bson_iterator_value( i ) + 4;\n    default:\n        return \"\";\n    }\n}\n\nint bson_iterator_string_len( const bson_iterator *i ) {\n    return bson_iterator_int_raw( i );\n}\n\nMONGO_EXPORT const char *bson_iterator_code( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_STRING:\n    case BSON_CODE:\n        return bson_iterator_value( i ) + 4;\n    case BSON_CODEWSCOPE:\n        return bson_iterator_value( i ) + 8;\n    default:\n        return NULL;\n    }\n}\n\nMONGO_EXPORT void bson_iterator_code_scope( const bson_iterator *i, bson *scope ) {\n    if ( bson_iterator_type( i ) == BSON_CODEWSCOPE ) {\n        int code_len;\n        bson_little_endian32( &code_len, bson_iterator_value( i )+4 );\n        bson_init_data( scope, ( void * )( bson_iterator_value( i )+8+code_len ) );\n        _bson_reset( scope );\n        scope->finished = 1;\n    }\n    else {\n        bson_empty( scope );\n    }\n}\n\nMONGO_EXPORT bson_date_t bson_iterator_date( const bson_iterator *i ) {\n    return bson_iterator_long_raw( i );\n}\n\nMONGO_EXPORT time_t bson_iterator_time_t( const bson_iterator *i ) {\n    return bson_iterator_date( i ) / 1000;\n}\n\nMONGO_EXPORT int bson_iterator_bin_len( const bson_iterator *i ) {\n    return ( bson_iterator_bin_type( i ) == BSON_BIN_BINARY_OLD )\n           ? bson_iterator_int_raw( i ) - 4\n           : bson_iterator_int_raw( i );\n}\n\nMONGO_EXPORT char bson_iterator_bin_type( const bson_iterator *i ) {\n    return bson_iterator_value( i )[4];\n}\n\nMONGO_EXPORT const char *bson_iterator_bin_data( const bson_iterator *i ) {\n    return ( bson_iterator_bin_type( i ) == BSON_BIN_BINARY_OLD )\n           ? bson_iterator_value( i ) + 9\n           : bson_iterator_value( i ) + 5;\n}\n\nMONGO_EXPORT const char *bson_iterator_regex( const bson_iterator *i ) {\n    return bson_iterator_value( i );\n}\n\nMONGO_EXPORT const char *bson_iterator_regex_opts( const bson_iterator *i ) {\n    const char *p = bson_iterator_value( i );\n    return p + strlen( p ) + 1;\n\n}\n\nMONGO_EXPORT void bson_iterator_subobject( const bson_iterator *i, bson *sub ) {\n    bson_init_data( sub, ( char * )bson_iterator_value( i ) );\n    _bson_reset( sub );\n    sub->finished = 1;\n}\n\nMONGO_EXPORT void bson_iterator_subiterator( const bson_iterator *i, bson_iterator *sub ) {\n    bson_iterator_from_buffer( sub, bson_iterator_value( i ) );\n}\n\n/* ----------------------------\n   BUILDING\n   ------------------------------ */\n\nstatic void _bson_init_size( bson *b, int size ) {\n    if( size == 0 )\n        b->data = NULL;\n    else\n        b->data = ( char * )bson_malloc( size );\n    b->dataSize = size;\n    b->cur = b->data + 4;\n    _bson_reset( b );\n}\n\nMONGO_EXPORT void bson_init( bson *b ) {\n    _bson_init_size( b, initialBufferSize );\n}\n\nvoid bson_init_size( bson *b, int size ) {\n    _bson_init_size( b, size );\n}\n\nstatic void bson_append_byte( bson *b, char c ) {\n    b->cur[0] = c;\n    b->cur++;\n}\n\nstatic void bson_append( bson *b, const void *data, size_t len ) {\n    memcpy( b->cur , data , len );\n    b->cur += len;\n}\n\nstatic void bson_append32( bson *b, const void *data ) {\n    bson_little_endian32( b->cur, data );\n    b->cur += 4;\n}\n\nstatic void bson_append32_as_int( bson *b, int data ) {\n    bson_little_endian32( b->cur, &data );\n    b->cur += 4;\n}\n\nstatic void bson_append64( bson *b, const void *data ) {\n    bson_little_endian64( b->cur, data );\n    b->cur += 8;\n}\n\nint bson_ensure_space( bson *b, const size_t bytesNeeded ) {\n    int pos = b->cur - b->data;\n    char *orig = b->data;\n    int new_size;\n\n    if ( pos + bytesNeeded <= b->dataSize )\n        return BSON_OK;\n\n    new_size = 1.5 * ( b->dataSize + bytesNeeded );\n\n    if( new_size < b->dataSize ) {\n        if( ( b->dataSize + bytesNeeded ) < INT_MAX )\n            new_size = INT_MAX;\n        else {\n            b->err = BSON_SIZE_OVERFLOW;\n            return BSON_ERROR;\n        }\n    }\n\n    b->data = bson_realloc( b->data, new_size );\n    if ( !b->data )\n        bson_fatal_msg( !!b->data, \"realloc() failed\" );\n\n    b->dataSize = new_size;\n    b->cur += b->data - orig;\n\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_finish( bson *b ) {\n    int i;\n\n    if( b->err & BSON_NOT_UTF8 )\n        return BSON_ERROR;\n\n    if ( ! b->finished ) {\n        if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n        bson_append_byte( b, 0 );\n        i = ( int )( b->cur - b->data );\n        bson_little_endian32( b->data, &i );\n        b->finished = 1;\n    }\n\n    return BSON_OK;\n}\n\nMONGO_EXPORT void bson_destroy( bson *b ) {\n    if (b) {\n        bson_free( b->data );\n        b->err = 0;\n        b->data = 0;\n        b->cur = 0;\n        b->finished = 1;\n    }\n}\n\nstatic int bson_append_estart( bson *b, int type, const char *name, const size_t dataSize ) {\n    const int len = strlen( name ) + 1;\n\n    if ( b->finished ) {\n        b->err |= BSON_ALREADY_FINISHED;\n        return BSON_ERROR;\n    }\n\n    if ( bson_ensure_space( b, 1 + len + dataSize ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n\n    if( bson_check_field_name( b, ( const char * )name, len - 1 ) == BSON_ERROR ) {\n        bson_builder_error( b );\n        return BSON_ERROR;\n    }\n\n    bson_append_byte( b, ( char )type );\n    bson_append( b, name, len );\n    return BSON_OK;\n}\n\n/* ----------------------------\n   BUILDING TYPES\n   ------------------------------ */\n\nMONGO_EXPORT int bson_append_int( bson *b, const char *name, const int i ) {\n    if ( bson_append_estart( b, BSON_INT, name, 4 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append32( b , &i );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_long( bson *b, const char *name, const int64_t i ) {\n    if ( bson_append_estart( b , BSON_LONG, name, 8 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append64( b , &i );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_double( bson *b, const char *name, const double d ) {\n    if ( bson_append_estart( b, BSON_DOUBLE, name, 8 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append64( b , &d );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_bool( bson *b, const char *name, const bson_bool_t i ) {\n    if ( bson_append_estart( b, BSON_BOOL, name, 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append_byte( b , i != 0 );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_null( bson *b, const char *name ) {\n    if ( bson_append_estart( b , BSON_NULL, name, 0 ) == BSON_ERROR )\n        return BSON_ERROR;\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_undefined( bson *b, const char *name ) {\n    if ( bson_append_estart( b, BSON_UNDEFINED, name, 0 ) == BSON_ERROR )\n        return BSON_ERROR;\n    return BSON_OK;\n}\n\nstatic int bson_append_string_base( bson *b, const char *name,\n                                    const char *value, size_t len, bson_type type ) {\n\n    size_t sl = len + 1;\n    if ( bson_check_string( b, ( const char * )value, sl - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_append_estart( b, type, name, 4 + sl ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n    bson_append32_as_int( b , ( int )sl );\n    bson_append( b , value , sl - 1 );\n    bson_append( b , \"\\0\" , 1 );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_string( bson *b, const char *name, const char *value ) {\n    return bson_append_string_base( b, name, value, strlen ( value ), BSON_STRING );\n}\n\nMONGO_EXPORT int bson_append_symbol( bson *b, const char *name, const char *value ) {\n    return bson_append_string_base( b, name, value, strlen ( value ), BSON_SYMBOL );\n}\n\nMONGO_EXPORT int bson_append_code( bson *b, const char *name, const char *value ) {\n    return bson_append_string_base( b, name, value, strlen ( value ), BSON_CODE );\n}\n\nMONGO_EXPORT int bson_append_string_n( bson *b, const char *name, const char *value, size_t len ) {\n    return bson_append_string_base( b, name, value, len, BSON_STRING );\n}\n\nMONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, size_t len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}\n\nMONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *value, size_t len ) {\n    return bson_append_string_base( b, name, value, len, BSON_CODE );\n}\n\nMONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,\n        const char *code, size_t len, const bson *scope ) {\n\n    size_t sl, size;\n    if ( !scope ) return BSON_ERROR;\n    sl = len + 1;\n    size = 4 + 4 + sl + bson_size( scope );\n    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append32_as_int( b, ( int )size );\n    bson_append32( b, &sl );\n    bson_append( b, code, sl );\n    bson_append( b, scope->data, bson_size( scope ) );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_code_w_scope( bson *b, const char *name, const char *code, const bson *scope ) {\n    return bson_append_code_w_scope_n( b, name, code, strlen ( code ), scope );\n}\n\nMONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, size_t len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32_as_int( b, ( int )subtwolen );\n        bson_append_byte( b, type );\n        bson_append32_as_int( b, ( int )len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32_as_int( b, ( int )len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_oid( bson *b, const char *name, const bson_oid_t *oid ) {\n    if ( bson_append_estart( b, BSON_OID, name, 12 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , oid , 12 );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_new_oid( bson *b, const char *name ) {\n    bson_oid_t oid;\n    bson_oid_gen( &oid );\n    return bson_append_oid( b, name, &oid );\n}\n\nMONGO_EXPORT int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts ) {\n    const size_t plen = strlen( pattern )+1;\n    const size_t olen = strlen( opts )+1;\n    if ( bson_append_estart( b, BSON_REGEX, name, plen + olen ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_check_string( b, pattern, plen - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , pattern , plen );\n    bson_append( b , opts , olen );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_bson( bson *b, const char *name, const bson *bson ) {\n    if ( !bson ) return BSON_ERROR;\n    if ( bson_append_estart( b, BSON_OBJECT, name, bson_size( bson ) ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , bson->data , bson_size( bson ) );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem ) {\n    bson_iterator next = *elem;\n    size_t size;\n\n    bson_iterator_next( &next );\n    size = next.cur - elem->cur;\n\n    if ( name_or_null == NULL ) {\n        if( bson_ensure_space( b, size ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append( b, elem->cur, size );\n    }\n    else {\n        size_t data_size = size - 2 - strlen( bson_iterator_key( elem ) );\n        bson_append_estart( b, elem->cur[0], name_or_null, data_size );\n        bson_append( b, bson_iterator_value( elem ), data_size );\n    }\n\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_timestamp( bson *b, const char *name, bson_timestamp_t *ts ) {\n    if ( bson_append_estart( b, BSON_TIMESTAMP, name, 8 ) == BSON_ERROR ) return BSON_ERROR;\n\n    bson_append32( b , &( ts->i ) );\n    bson_append32( b , &( ts->t ) );\n\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_timestamp2( bson *b, const char *name, int time, int increment ) {\n    if ( bson_append_estart( b, BSON_TIMESTAMP, name, 8 ) == BSON_ERROR ) return BSON_ERROR;\n\n    bson_append32( b , &increment );\n    bson_append32( b , &time );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_date( bson *b, const char *name, bson_date_t millis ) {\n    if ( bson_append_estart( b, BSON_DATE, name, 8 ) == BSON_ERROR ) return BSON_ERROR;\n    bson_append64( b , &millis );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_time_t( bson *b, const char *name, time_t secs ) {\n    return bson_append_date( b, name, ( bson_date_t )secs * 1000 );\n}\n\nMONGO_EXPORT int bson_append_start_object( bson *b, const char *name ) {\n    if ( bson_append_estart( b, BSON_OBJECT, name, 5 ) == BSON_ERROR ) return BSON_ERROR;\n    b->stack[ b->stackPos++ ] = b->cur - b->data;\n    bson_append32( b , &zero );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_start_array( bson *b, const char *name ) {\n    if ( bson_append_estart( b, BSON_ARRAY, name, 5 ) == BSON_ERROR ) return BSON_ERROR;\n    b->stack[ b->stackPos++ ] = b->cur - b->data;\n    bson_append32( b , &zero );\n    return BSON_OK;\n}\n\nMONGO_EXPORT int bson_append_finish_object( bson *b ) {\n    char *start;\n    int i;\n    if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n    bson_append_byte( b , 0 );\n\n    start = b->data + b->stack[ --b->stackPos ];\n    i = ( int )( b->cur - start );\n    bson_little_endian32( start, &i );\n\n    return BSON_OK;\n}\n\nMONGO_EXPORT double bson_int64_to_double( int64_t i64 ) {\n    return (double)i64;\n}\n\nMONGO_EXPORT int bson_append_finish_array( bson *b ) {\n    return bson_append_finish_object( b );\n}\n\n/* Error handling and allocators. */\n\nstatic bson_err_handler err_handler = NULL;\n\nMONGO_EXPORT bson_err_handler set_bson_err_handler( bson_err_handler func ) {\n    bson_err_handler old = err_handler;\n    err_handler = func;\n    return old;\n}\n\nMONGO_EXPORT void bson_free( void *ptr ) {\n    bson_free_func( ptr );\n}\n\nMONGO_EXPORT void *bson_malloc( size_t size ) {\n    void *p;\n    p = bson_malloc_func( size );\n    bson_fatal_msg( !!p, \"malloc() failed\" );\n    return p;\n}\n\nvoid *bson_realloc( void *ptr, size_t size ) {\n    void *p;\n    p = bson_realloc_func( ptr, size );\n    bson_fatal_msg( !!p, \"realloc() failed\" );\n    return p;\n}\n\nint _bson_errprintf( const char *format, ... ) {\n    va_list ap;\n    int ret = 0;\n    va_start( ap, format );\n#ifndef R_SAFETY_NET\n    ret = vfprintf( stderr, format, ap );\n#endif\n    va_end( ap );\n\n    return ret;\n}\n\n/**\n * This method is invoked when a non-fatal bson error is encountered.\n * Calls the error handler if available.\n *\n *  @param\n */\nvoid bson_builder_error( bson *b ) {\n    if( err_handler )\n        err_handler( \"BSON error.\" );\n}\n\nvoid bson_fatal( int ok ) {\n    bson_fatal_msg( ok, \"\" );\n}\n\nvoid bson_fatal_msg( int ok , const char *msg ) {\n    if ( ok )\n        return;\n\n    if ( err_handler ) {\n        err_handler( msg );\n    }\n#ifndef R_SAFETY_NET\n    bson_errprintf( \"error: %s\\n\" , msg );\n    exit( -5 );\n#endif\n}\n\n\n/* Efficiently copy an integer to a string. */\nextern const char bson_numstrs[1000][4];\n\nvoid bson_numstr( char *str, int i ) {\n    if( i < 1000 )\n        memcpy( str, bson_numstrs[i], 4 );\n    else\n        bson_sprintf( str,\"%d\", i );\n}\n\nMONGO_EXPORT void bson_swap_endian64( void *outp, const void *inp ) {\n    const char *in = ( const char * )inp;\n    char *out = ( char * )outp;\n\n    out[0] = in[7];\n    out[1] = in[6];\n    out[2] = in[5];\n    out[3] = in[4];\n    out[4] = in[3];\n    out[5] = in[2];\n    out[6] = in[1];\n    out[7] = in[0];\n\n}\n\nMONGO_EXPORT void bson_swap_endian32( void *outp, const void *inp ) {\n    const char *in = ( const char * )inp;\n    char *out = ( char * )outp;\n\n    out[0] = in[3];\n    out[1] = in[2];\n    out[2] = in[1];\n    out[3] = in[0];\n}\n", "/**\n * @file bson.h\n * @brief BSON Declarations\n */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#ifndef BSON_H_\n#define BSON_H_\n\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n\n#ifdef __GNUC__\n#define MONGO_INLINE static __inline__\n#define MONGO_EXPORT\n#else\n#define MONGO_INLINE static\n#ifdef MONGO_STATIC_BUILD\n#define MONGO_EXPORT\n#elif defined(MONGO_DLL_BUILD)\n#define MONGO_EXPORT __declspec(dllexport)\n#else\n#define MONGO_EXPORT __declspec(dllimport)\n#endif\n#endif\n\n#ifdef __cplusplus\n#define MONGO_EXTERN_C_START extern \"C\" {\n#define MONGO_EXTERN_C_END }\n#else\n#define MONGO_EXTERN_C_START\n#define MONGO_EXTERN_C_END\n#endif\n\n#if defined(MONGO_HAVE_STDINT) || __STDC_VERSION__ >= 199901L\n#include <stdint.h>\n#elif defined(MONGO_HAVE_UNISTD)\n#include <unistd.h>\n#elif defined(MONGO_USE__INT64)\ntypedef __int64 int64_t;\ntypedef unsigned __int64 uint64_t;\n#elif defined(MONGO_USE_LONG_LONG_INT)\ntypedef long long int int64_t;\ntypedef unsigned long long int uint64_t;\n#else\n#error Must compile with c99 or define MONGO_HAVE_STDINT, MONGO_HAVE_UNISTD, MONGO_USE__INT64, or MONGO_USE_LONG_LONG_INT.\n#endif\n\n#ifdef MONGO_BIG_ENDIAN\n#define bson_little_endian64(out, in) ( bson_swap_endian64(out, in) )\n#define bson_little_endian32(out, in) ( bson_swap_endian32(out, in) )\n#define bson_big_endian64(out, in) ( memcpy(out, in, 8) )\n#define bson_big_endian32(out, in) ( memcpy(out, in, 4) )\n#else\n#define bson_little_endian64(out, in) ( memcpy(out, in, 8) )\n#define bson_little_endian32(out, in) ( memcpy(out, in, 4) )\n#define bson_big_endian64(out, in) ( bson_swap_endian64(out, in) )\n#define bson_big_endian32(out, in) ( bson_swap_endian32(out, in) )\n#endif\n\nMONGO_EXTERN_C_START\n\n#define BSON_OK 0\n#define BSON_ERROR -1\n\nenum bson_error_t {\n    BSON_SIZE_OVERFLOW = 1 /**< Trying to create a BSON object larger than INT_MAX. */\n};\n\nenum bson_validity_t {\n    BSON_VALID = 0,                 /**< BSON is valid and UTF-8 compliant. */\n    BSON_NOT_UTF8 = ( 1<<1 ),       /**< A key or a string is not valid UTF-8. */\n    BSON_FIELD_HAS_DOT = ( 1<<2 ),  /**< Warning: key contains '.' character. */\n    BSON_FIELD_INIT_DOLLAR = ( 1<<3 ), /**< Warning: key starts with '$' character. */\n    BSON_ALREADY_FINISHED = ( 1<<4 )  /**< Trying to modify a finished BSON object. */\n};\n\nenum bson_binary_subtype_t {\n    BSON_BIN_BINARY = 0,\n    BSON_BIN_FUNC = 1,\n    BSON_BIN_BINARY_OLD = 2,\n    BSON_BIN_UUID = 3,\n    BSON_BIN_MD5 = 5,\n    BSON_BIN_USER = 128\n};\n\ntypedef enum {\n    BSON_EOO = 0,\n    BSON_DOUBLE = 1,\n    BSON_STRING = 2,\n    BSON_OBJECT = 3,\n    BSON_ARRAY = 4,\n    BSON_BINDATA = 5,\n    BSON_UNDEFINED = 6,\n    BSON_OID = 7,\n    BSON_BOOL = 8,\n    BSON_DATE = 9,\n    BSON_NULL = 10,\n    BSON_REGEX = 11,\n    BSON_DBREF = 12, /**< Deprecated. */\n    BSON_CODE = 13,\n    BSON_SYMBOL = 14,\n    BSON_CODEWSCOPE = 15,\n    BSON_INT = 16,\n    BSON_TIMESTAMP = 17,\n    BSON_LONG = 18\n} bson_type;\n\ntypedef int bson_bool_t;\n\ntypedef struct {\n    const char *cur;\n    bson_bool_t first;\n} bson_iterator;\n\ntypedef struct {\n    char *data;    /**< Pointer to a block of data in this BSON object. */\n    char *cur;     /**< Pointer to the current position. */\n    int dataSize;  /**< The number of bytes allocated to char *data. */\n    bson_bool_t finished; /**< When finished, the BSON object can no longer be modified. */\n    size_t stack[32];        /**< A stack used to keep track of nested BSON elements. */\n    int stackPos;         /**< Index of current stack position. */\n    int err; /**< Bitfield representing errors or warnings on this buffer */\n    char *errstr; /**< A string representation of the most recent error or warning. */\n} bson;\n\n#pragma pack(1)\ntypedef union {\n    char bytes[12];\n    int ints[3];\n} bson_oid_t;\n#pragma pack()\n\ntypedef int64_t bson_date_t; /* milliseconds since epoch UTC */\n\ntypedef struct {\n    int i; /* increment */\n    int t; /* time in seconds */\n} bson_timestamp_t;\n\n/* ----------------------------\n   READING\n   ------------------------------ */\n\nMONGO_EXPORT bson* bson_create( void );\nMONGO_EXPORT void  bson_dispose(bson* b);\n\n/**\n * Size of a BSON object.\n *\n * @param b the BSON object.\n *\n * @return the size.\n */\nMONGO_EXPORT int bson_size( const bson *b );\nMONGO_EXPORT size_t bson_buffer_size( const bson *b );\n\n/**\n * Print a string representation of a BSON object.\n *\n * @param b the BSON object to print.\n */\nMONGO_EXPORT void bson_print( const bson *b );\n\n/**\n * Return a pointer to the raw buffer stored by this bson object.\n *\n * @param b a BSON object\n */\nMONGO_EXPORT const char *bson_data( const bson *b );\n\n/**\n * Print a string representation of a BSON object.\n *\n * @param bson the raw data to print.\n * @param depth the depth to recurse the object.x\n */\nMONGO_EXPORT void bson_print_raw( const char *bson , int depth );\n\n/**\n * Advance a bson_iterator to the named field.\n *\n * @param it the bson_iterator to use.\n * @param obj the BSON object to use.\n * @param name the name of the field to find.\n *\n * @return the type of the found object or BSON_EOO if it is not found.\n */\nMONGO_EXPORT bson_type bson_find( bson_iterator *it, const bson *obj, const char *name );\n\n\nMONGO_EXPORT bson_iterator* bson_iterator_create( void );\nMONGO_EXPORT void bson_iterator_dispose(bson_iterator*);\n/**\n * Initialize a bson_iterator.\n *\n * @param i the bson_iterator to initialize.\n * @param bson the BSON object to associate with the iterator.\n */\nMONGO_EXPORT void bson_iterator_init( bson_iterator *i , const bson *b );\n\n/**\n * Initialize a bson iterator from a const char* buffer. Note\n * that this is mostly used internally.\n *\n * @param i the bson_iterator to initialize.\n * @param buffer the buffer to point to.\n */\nMONGO_EXPORT void bson_iterator_from_buffer( bson_iterator *i, const char *buffer );\n\n/* more returns true for eoo. best to loop with bson_iterator_next(&it) */\n/**\n * Check to see if the bson_iterator has more data.\n *\n * @param i the iterator.\n *\n * @return  returns true if there is more data.\n */\nMONGO_EXPORT bson_bool_t bson_iterator_more( const bson_iterator *i );\n\n/**\n * Point the iterator at the next BSON object.\n *\n * @param i the bson_iterator.\n *\n * @return the type of the next BSON object.\n */\nMONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i );\n\n/**\n * Get the type of the BSON object currently pointed to by the iterator.\n *\n * @param i the bson_iterator\n *\n * @return  the type of the current BSON object.\n */\nMONGO_EXPORT bson_type bson_iterator_type( const bson_iterator *i );\n\n/**\n * Get the key of the BSON object currently pointed to by the iterator.\n *\n * @param i the bson_iterator\n *\n * @return the key of the current BSON object.\n */\nMONGO_EXPORT const char *bson_iterator_key( const bson_iterator *i );\n\n/**\n * Get the value of the BSON object currently pointed to by the iterator.\n *\n * @param i the bson_iterator\n *\n * @return  the value of the current BSON object.\n */\nMONGO_EXPORT const char *bson_iterator_value( const bson_iterator *i );\n\n/* these convert to the right type (return 0 if non-numeric) */\n/**\n * Get the double value of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return  the value of the current BSON object.\n */\nMONGO_EXPORT double bson_iterator_double( const bson_iterator *i );\n\n/**\n * Get the int value of the BSON object currently pointed to by the iterator.\n *\n * @param i the bson_iterator\n *\n * @return  the value of the current BSON object.\n */\nMONGO_EXPORT int bson_iterator_int( const bson_iterator *i );\n\n/**\n * Get the long value of the BSON object currently pointed to by the iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nMONGO_EXPORT int64_t bson_iterator_long( const bson_iterator *i );\n\n/* return the bson timestamp as a whole or in parts */\n/**\n * Get the timestamp value of the BSON object currently pointed to by\n * the iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nMONGO_EXPORT bson_timestamp_t bson_iterator_timestamp( const bson_iterator *i );\nMONGO_EXPORT int bson_iterator_timestamp_time( const bson_iterator *i );\nMONGO_EXPORT int bson_iterator_timestamp_increment( const bson_iterator *i );\n\n/**\n * Get the boolean value of the BSON object currently pointed to by\n * the iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\n/* false: boolean false, 0 in any type, or null */\n/* true: anything else (even empty strings and objects) */\nMONGO_EXPORT bson_bool_t bson_iterator_bool( const bson_iterator *i );\n\n/**\n * Get the double value of the BSON object currently pointed to by the\n * iterator. Assumes the correct type is used.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\n/* these assume you are using the right type */\ndouble bson_iterator_double_raw( const bson_iterator *i );\n\n/**\n * Get the int value of the BSON object currently pointed to by the\n * iterator. Assumes the correct type is used.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nint bson_iterator_int_raw( const bson_iterator *i );\n\n/**\n * Get the long value of the BSON object currently pointed to by the\n * iterator. Assumes the correct type is used.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nint64_t bson_iterator_long_raw( const bson_iterator *i );\n\n/**\n * Get the bson_bool_t value of the BSON object currently pointed to by the\n * iterator. Assumes the correct type is used.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nbson_bool_t bson_iterator_bool_raw( const bson_iterator *i );\n\n/**\n * Get the bson_oid_t value of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON object.\n */\nMONGO_EXPORT bson_oid_t *bson_iterator_oid( const bson_iterator *i );\n\n/**\n * Get the string value of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return  the value of the current BSON object.\n */\n/* these can also be used with bson_code and bson_symbol*/\nMONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i );\n\n/**\n * Get the string length of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the length of the current BSON object.\n */\nint bson_iterator_string_len( const bson_iterator *i );\n\n/**\n * Get the code value of the BSON object currently pointed to by the\n * iterator. Works with bson_code, bson_codewscope, and BSON_STRING\n * returns NULL for everything else.\n *\n * @param i the bson_iterator\n *\n * @return the code value of the current BSON object.\n */\n/* works with bson_code, bson_codewscope, and BSON_STRING */\n/* returns NULL for everything else */\nMONGO_EXPORT const char *bson_iterator_code( const bson_iterator *i );\n\n/**\n * Calls bson_empty on scope if not a bson_codewscope\n *\n * @param i the bson_iterator.\n * @param scope the bson scope.\n */\n/* calls bson_empty on scope if not a bson_codewscope */\nMONGO_EXPORT void bson_iterator_code_scope( const bson_iterator *i, bson *scope );\n\n/**\n * Get the date value of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the date value of the current BSON object.\n */\n/* both of these only work with bson_date */\nMONGO_EXPORT bson_date_t bson_iterator_date( const bson_iterator *i );\n\n/**\n * Get the time value of the BSON object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the time value of the current BSON object.\n */\nMONGO_EXPORT time_t bson_iterator_time_t( const bson_iterator *i );\n\n/**\n * Get the length of the BSON binary object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the length of the current BSON binary object.\n */\nMONGO_EXPORT int bson_iterator_bin_len( const bson_iterator *i );\n\n/**\n * Get the type of the BSON binary object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the type of the current BSON binary object.\n */\nMONGO_EXPORT char bson_iterator_bin_type( const bson_iterator *i );\n\n/**\n * Get the value of the BSON binary object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON binary object.\n */\nMONGO_EXPORT const char *bson_iterator_bin_data( const bson_iterator *i );\n\n/**\n * Get the value of the BSON regex object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator\n *\n * @return the value of the current BSON regex object.\n */\nMONGO_EXPORT const char *bson_iterator_regex( const bson_iterator *i );\n\n/**\n * Get the options of the BSON regex object currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator.\n *\n * @return the options of the current BSON regex object.\n */\nMONGO_EXPORT const char *bson_iterator_regex_opts( const bson_iterator *i );\n\n/* these work with BSON_OBJECT and BSON_ARRAY */\n/**\n * Get the BSON subobject currently pointed to by the\n * iterator.\n *\n * @param i the bson_iterator.\n * @param sub the BSON subobject destination.\n */\nMONGO_EXPORT void bson_iterator_subobject( const bson_iterator *i, bson *sub );\n\n/**\n * Get a bson_iterator that on the BSON subobject.\n *\n * @param i the bson_iterator.\n * @param sub the iterator to point at the BSON subobject.\n */\nMONGO_EXPORT void bson_iterator_subiterator( const bson_iterator *i, bson_iterator *sub );\n\n/* str must be at least 24 hex chars + null byte */\n/**\n * Create a bson_oid_t from a string.\n *\n * @param oid the bson_oid_t destination.\n * @param str a null terminated string comprised of at least 24 hex chars.\n */\nMONGO_EXPORT void bson_oid_from_string( bson_oid_t *oid, const char *str );\n\n/**\n * Create a string representation of the bson_oid_t.\n *\n * @param oid the bson_oid_t source.\n * @param str the string representation destination.\n */\nMONGO_EXPORT void bson_oid_to_string( const bson_oid_t *oid, char *str );\n\n/**\n * Create a bson_oid object.\n *\n * @param oid the destination for the newly created bson_oid_t.\n */\nMONGO_EXPORT void bson_oid_gen( bson_oid_t *oid );\n\n/**\n * Set a function to be used to generate the second four bytes\n * of an object id.\n *\n * @param func a pointer to a function that returns an int.\n */\nMONGO_EXPORT void bson_set_oid_fuzz( int ( *func )( void ) );\n\n/**\n * Set a function to be used to generate the incrementing part\n * of an object id (last four bytes). If you need thread-safety\n * in generating object ids, you should set this function.\n *\n * @param func a pointer to a function that returns an int.\n */\nMONGO_EXPORT void bson_set_oid_inc( int ( *func )( void ) );\n\n/**\n * Get the time a bson_oid_t was created.\n *\n * @param oid the bson_oid_t.\n */\nMONGO_EXPORT time_t bson_oid_generated_time( bson_oid_t *oid ); /* Gives the time the OID was created */\n\n/* ----------------------------\n   BUILDING\n   ------------------------------ */\n\n/**\n *  Initialize a new bson object. If not created\n *  with bson_new, you must initialize each new bson\n *  object using this function.\n *\n *  @note When finished, you must pass the bson object to\n *      bson_destroy( ).\n */\nMONGO_EXPORT void bson_init( bson *b );\n\n/**\n * Initialize a BSON object, and point its data\n * pointer to the provided char*.\n *\n * @param b the BSON object to initialize.\n * @param data the raw BSON data.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nint bson_init_data( bson *b , char *data );\nint bson_init_finished_data( bson *b, char *data ) ;\n\n/**\n * Initialize a BSON object, and set its\n * buffer to the given size.\n *\n * @param b the BSON object to initialize.\n * @param size the initial size of the buffer.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nvoid bson_init_size( bson *b, int size );\n\n/**\n * Grow a bson object.\n *\n * @param b the bson to grow.\n * @param bytesNeeded the additional number of bytes needed.\n *\n * @return BSON_OK or BSON_ERROR with the bson error object set.\n *   Exits if allocation fails.\n */\nint bson_ensure_space( bson *b, const size_t bytesNeeded );\n\n/**\n * Finalize a bson object.\n *\n * @param b the bson object to finalize.\n *\n * @return the standard error code. To deallocate memory,\n *   call bson_destroy on the bson object.\n */\nMONGO_EXPORT int bson_finish( bson *b );\n\n/**\n * Destroy a bson object.\n *\n * @param b the bson object to destroy.\n *\n */\nMONGO_EXPORT void bson_destroy( bson *b );\n\n/**\n * Returns a pointer to a static empty BSON object.\n *\n * @param obj the BSON object to initialize.\n *\n * @return the empty initialized BSON object.\n */\n/* returns pointer to static empty bson object */\nMONGO_EXPORT bson *bson_empty( bson *obj );\n\n/**\n * Make a complete copy of the a BSON object.\n * The source bson object must be in a finished\n * state; otherwise, the copy will fail.\n *\n * @param out the copy destination BSON object.\n * @param in the copy source BSON object.\n */\nMONGO_EXPORT int bson_copy( bson *out, const bson *in ); /* puts data in new buffer. NOOP if out==NULL */\n\n/**\n * Append a previously created bson_oid_t to a bson object.\n *\n * @param b the bson to append to.\n * @param name the key for the bson_oid_t.\n * @param oid the bson_oid_t to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_oid( bson *b, const char *name, const bson_oid_t *oid );\n\n/**\n * Append a bson_oid_t to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the bson_oid_t.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_new_oid( bson *b, const char *name );\n\n/**\n * Append an int to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the int.\n * @param i the int to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_int( bson *b, const char *name, const int i );\n\n/**\n * Append an long to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the long.\n * @param i the long to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_long( bson *b, const char *name, const int64_t i );\n\n/**\n * Append an double to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the double.\n * @param d the double to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_double( bson *b, const char *name, const double d );\n\n/**\n * Append a string to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the string.\n * @param str the string to append.\n *\n * @return BSON_OK or BSON_ERROR.\n*/\nMONGO_EXPORT int bson_append_string( bson *b, const char *name, const char *str );\n\n/**\n * Append len bytes of a string to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the string.\n * @param str the string to append.\n * @param len the number of bytes from str to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_string_n( bson *b, const char *name, const char *str, size_t len );\n\n/**\n * Append a symbol to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the symbol.\n * @param str the symbol to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_symbol( bson *b, const char *name, const char *str );\n\n/**\n * Append len bytes of a symbol to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the symbol.\n * @param str the symbol to append.\n * @param len the number of bytes from str to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *str, size_t len );\n\n/**\n * Append code to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the code.\n * @param str the code to append.\n * @param len the number of bytes from str to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_code( bson *b, const char *name, const char *str );\n\n/**\n * Append len bytes of code to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the code.\n * @param str the code to append.\n * @param len the number of bytes from str to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *str, size_t len );\n\n/**\n * Append code to a bson with scope.\n *\n * @param b the bson to append to.\n * @param name the key for the code.\n * @param str the string to append.\n * @param scope a BSON object containing the scope.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_code_w_scope( bson *b, const char *name, const char *code, const bson *scope );\n\n/**\n * Append len bytes of code to a bson with scope.\n *\n * @param b the bson to append to.\n * @param name the key for the code.\n * @param str the string to append.\n * @param len the number of bytes from str to append.\n * @param scope a BSON object containing the scope.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name, const char *code, size_t size, const bson *scope );\n\n/**\n * Append binary data to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the data.\n * @param type the binary data type.\n * @param str the binary data.\n * @param len the length of the data.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, size_t len );\n\n/**\n * Append a bson_bool_t to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the boolean value.\n * @param v the bson_bool_t to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_bool( bson *b, const char *name, const bson_bool_t v );\n\n/**\n * Append a null value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the null value.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_null( bson *b, const char *name );\n\n/**\n * Append an undefined value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the undefined value.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_undefined( bson *b, const char *name );\n\n/**\n * Append a regex value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the regex value.\n * @param pattern the regex pattern to append.\n * @param the regex options.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts );\n\n/**\n * Append bson data to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the bson data.\n * @param bson the bson object to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_bson( bson *b, const char *name, const bson *bson );\n\n/**\n * Append a BSON element to a bson from the current point of an iterator.\n *\n * @param b the bson to append to.\n * @param name_or_null the key for the BSON element, or NULL.\n * @param elem the bson_iterator.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem );\n\n/**\n * Append a bson_timestamp_t value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the timestampe value.\n * @param ts the bson_timestamp_t value to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_timestamp( bson *b, const char *name, bson_timestamp_t *ts );\nMONGO_EXPORT int bson_append_timestamp2( bson *b, const char *name, int time, int increment );\n\n/* these both append a bson_date */\n/**\n * Append a bson_date_t value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the date value.\n * @param millis the bson_date_t to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_date( bson *b, const char *name, bson_date_t millis );\n\n/**\n * Append a time_t value to a bson.\n *\n * @param b the bson to append to.\n * @param name the key for the date value.\n * @param secs the time_t to append.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_time_t( bson *b, const char *name, time_t secs );\n\n/**\n * Start appending a new object to a bson.\n *\n * @param b the bson to append to.\n * @param name the name of the new object.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_start_object( bson *b, const char *name );\n\n/**\n * Start appending a new array to a bson.\n *\n * @param b the bson to append to.\n * @param name the name of the new array.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_start_array( bson *b, const char *name );\n\n/**\n * Finish appending a new object or array to a bson.\n *\n * @param b the bson to append to.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_finish_object( bson *b );\n\n/**\n * Finish appending a new object or array to a bson. This\n * is simply an alias for bson_append_finish_object.\n *\n * @param b the bson to append to.\n *\n * @return BSON_OK or BSON_ERROR.\n */\nMONGO_EXPORT int bson_append_finish_array( bson *b );\n\nvoid bson_numstr( char *str, int i );\n\nvoid bson_incnumstr( char *str );\n\n/* Error handling and standard library function over-riding. */\n/* -------------------------------------------------------- */\n\n/* bson_err_handlers shouldn't return!!! */\ntypedef void( *bson_err_handler )( const char *errmsg );\n\ntypedef int (*bson_printf_func)( const char *, ... );\ntypedef int (*bson_fprintf_func)( FILE *, const char *, ... );\ntypedef int (*bson_sprintf_func)( char *, const char *, ... );\n\nextern void *( *bson_malloc_func )( size_t );\nextern void *( *bson_realloc_func )( void *, size_t );\nextern void ( *bson_free_func )( void * );\n\nextern bson_printf_func bson_printf;\nextern bson_fprintf_func bson_fprintf;\nextern bson_sprintf_func bson_sprintf;\nextern bson_printf_func bson_errprintf;\n\nMONGO_EXPORT void bson_free( void *ptr );\n\n/**\n * Allocates memory and checks return value, exiting fatally if malloc() fails.\n *\n * @param size bytes to allocate.\n *\n * @return a pointer to the allocated memory.\n *\n * @sa malloc(3)\n */\nMONGO_EXPORT void *bson_malloc( size_t size );\n\n/**\n * Changes the size of allocated memory and checks return value,\n * exiting fatally if realloc() fails.\n *\n * @param ptr pointer to the space to reallocate.\n * @param size bytes to allocate.\n *\n * @return a pointer to the allocated memory.\n *\n * @sa realloc()\n */\nvoid *bson_realloc( void *ptr, size_t size );\n\n/**\n * Set a function for error handling.\n *\n * @param func a bson_err_handler function.\n *\n * @return the old error handling function, or NULL.\n */\nMONGO_EXPORT bson_err_handler set_bson_err_handler( bson_err_handler func );\n\n/* does nothing if ok != 0 */\n/**\n * Exit fatally.\n *\n * @param ok exits if ok is equal to 0.\n */\nvoid bson_fatal( int ok );\n\n/**\n * Exit fatally with an error message.\n  *\n * @param ok exits if ok is equal to 0.\n * @param msg prints to stderr before exiting.\n */\nvoid bson_fatal_msg( int ok, const char *msg );\n\n/**\n * Invoke the error handler, but do not exit.\n *\n * @param b the buffer object.\n */\nvoid bson_builder_error( bson *b );\n\n/**\n * Cast an int64_t to double. This is necessary for embedding in\n * certain environments.\n *\n */\nMONGO_EXPORT double bson_int64_to_double( int64_t i64 );\n\nMONGO_EXPORT void bson_swap_endian32( void *outp, const void *inp );\nMONGO_EXPORT void bson_swap_endian64( void *outp, const void *inp );\n\nMONGO_EXTERN_C_END\n#endif\n", "/*\n * Copyright 2009-2012 10gen, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Portions Copyright 2001 Unicode, Inc.\n *\n * Disclaimer\n *\n * This source code is provided as is by Unicode, Inc. No claims are\n * made as to fitness for any particular purpose. No warranties of any\n * kind are expressed or implied. The recipient agrees to determine\n * applicability of information provided. If this file has been\n * purchased on magnetic or optical media from Unicode, Inc., the\n * sole remedy for any claim will be exchange of defective media\n * within 90 days of receipt.\n *\n * Limitations on Rights to Redistribute This Code\n *\n * Unicode, Inc. hereby grants the right to freely use the information\n * supplied in this file in the creation of products supporting the\n * Unicode Standard, and to make copies of this file in any form\n * for internal or external distribution as long as this notice\n * remains attached.\n */\n\n\n#include \"bson.h\"\n#include \"encoding.h\"\n\n/*\n * Index into the table below with the first byte of a UTF-8 sequence to\n * get the number of trailing bytes that are supposed to follow it.\n */\nstatic const char trailingBytesForUTF8[256] = {\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5\n};\n\n/* --------------------------------------------------------------------- */\n\n/*\n * Utility routine to tell whether a sequence of bytes is legal UTF-8.\n * This must be called with the length pre-determined by the first byte.\n * The length can be set by:\n *  length = trailingBytesForUTF8[*source]+1;\n * and the sequence is illegal right away if there aren't that many bytes\n * available.\n * If presented with a length > 4, this returns 0.  The Unicode\n * definition of UTF-8 goes up to 4-byte sequences.\n */\nstatic int isLegalUTF8( const unsigned char *source, int length ) {\n    unsigned char a;\n    const unsigned char *srcptr = source + length;\n    switch ( length ) {\n    default:\n        return 0;\n        /* Everything else falls through when \"true\"... */\n    case 4:\n        if ( ( a = ( *--srcptr ) ) < 0x80 || a > 0xBF ) return 0;\n    case 3:\n        if ( ( a = ( *--srcptr ) ) < 0x80 || a > 0xBF ) return 0;\n    case 2:\n        if ( ( a = ( *--srcptr ) ) > 0xBF ) return 0;\n        switch ( *source ) {\n            /* no fall-through in this inner switch */\n        case 0xE0:\n            if ( a < 0xA0 ) return 0;\n            break;\n        case 0xF0:\n            if ( a < 0x90 ) return 0;\n            break;\n        case 0xF4:\n            if ( a > 0x8F ) return 0;\n            break;\n        default:\n            if ( a < 0x80 ) return 0;\n        }\n    case 1:\n        if ( *source >= 0x80 && *source < 0xC2 ) return 0;\n        if ( *source > 0xF4 ) return 0;\n    }\n    return 1;\n}\n\n/* If the name is part of a db ref ($ref, $db, or $id), then return true. */\nstatic int bson_string_is_db_ref( const unsigned char *string, const size_t length ) {\n    int result = 0;\n\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n\n    return result;\n}\n\nstatic int bson_validate_string( bson *b, const unsigned char *string,\n                                 const size_t length, const char check_utf8, const char check_dot,\n                                 const char check_dollar ) {\n\n    size_t position = 0;\n    int sequence_length = 1;\n\n    if( check_dollar && string[0] == '$' ) {\n        if( !bson_string_is_db_ref( string, length ) )\n            b->err |= BSON_FIELD_INIT_DOLLAR;\n    }\n\n    while ( position < length ) {\n        if ( check_dot && *( string + position ) == '.' ) {\n            b->err |= BSON_FIELD_HAS_DOT;\n        }\n\n        if ( check_utf8 ) {\n            sequence_length = trailingBytesForUTF8[*( string + position )] + 1;\n            if ( ( position + sequence_length ) > length ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n            if ( !isLegalUTF8( string + position, sequence_length ) ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n        }\n        position += sequence_length;\n    }\n\n    return BSON_OK;\n}\n\n\nint bson_check_string( bson *b, const char *string,\n                       const size_t length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );\n}\n\nint bson_check_field_name( bson *b, const char *string,\n                           const size_t length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}\n", "/*\n * Copyright 2009-2012 10gen, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef BSON_ENCODING_H_\n#define BSON_ENCODING_H_\n\nMONGO_EXTERN_C_START\n\n/**\n * Check that a field name is valid UTF8, does not start with a '$',\n * and contains no '.' characters. Set bson bit field appropriately.\n * Note that we don't need to check for '\\0' because we're using\n * strlen(3), which stops at '\\0'.\n *\n * @param b The bson object to which field name will be appended.\n * @param string The field name as char*.\n * @param length The length of the field name.\n *\n * @return BSON_OK if valid UTF8 and BSON_ERROR if not. All BSON strings must be\n *     valid UTF8. This function will also check whether the string\n *     contains '.' or starts with '$', since the validity of this depends on context.\n *     Set the value of b->err appropriately.\n */\nint bson_check_field_name( bson *b, const char *string,\n                           const size_t length );\n\n/**\n * Check that a string is valid UTF8. Sets the buffer bit field appropriately.\n *\n * @param b The bson object to which string will be appended.\n * @param string The string to check.\n * @param length The length of the string.\n *\n * @return BSON_OK if valid UTF-8; otherwise, BSON_ERROR.\n *     Sets b->err on error.\n */\nbson_bool_t bson_check_string( bson *b, const char *string,\n                               const size_t length );\n\nMONGO_EXTERN_C_END\n#endif\n", "#if !defined(MONGO_ENV_STANDARD) && (defined(_WIN32) || defined(_WIN64))\n\n/* env_win32.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n/* Networking and other niceties for WIN32. */\n#include \"env.h\"\n#include <string.h>\n\n#ifdef _MSC_VER\n#include <ws2tcpip.h>  /* send,recv,socklen_t etc */\n#include <wspiapi.h>   /* addrinfo */\n#else\n#include <ws2tcpip.h>  /* send,recv,socklen_t etc */\n#include <winsock2.h>\ntypedef int socklen_t;\n#endif\n\n#ifndef NI_MAXSERV\n# define NI_MAXSERV 32\n#endif\n\nint mongo_env_close_socket( int socket ) {\n    return closesocket( socket );\n}\n\nint mongo_env_write_socket( mongo *conn, const void *buf, size_t len ) {\n    const char *cbuf = buf;\n    int flags = 0;\n\n    while ( len ) {\n        size_t sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            conn->connected = 0;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_read_socket( mongo *conn, void *buf, size_t len ) {\n    char *cbuf = buf;\n\n    while ( len ) {\n        size_t sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_set_socket_op_timeout( mongo *conn, int millis ) {\n    if ( setsockopt( conn->sock, SOL_SOCKET, SO_RCVTIMEO, (const char *)&millis,\n                     sizeof( millis ) ) == -1 ) {\n        __mongo_set_error( conn, MONGO_IO_ERROR, \"setsockopt SO_RCVTIMEO failed.\",\n                           WSAGetLastError() );\n        return MONGO_ERROR;\n    }\n\n    if ( setsockopt( conn->sock, SOL_SOCKET, SO_SNDTIMEO, (const char *)&millis,\n                     sizeof( millis ) ) == -1 ) {\n        __mongo_set_error( conn, MONGO_IO_ERROR, \"setsockopt SO_SNDTIMEO failed.\",\n                           WSAGetLastError() );\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_socket_connect( mongo *conn, const char *host, int port ) {\n    char port_str[NI_MAXSERV];\n    char errstr[MONGO_ERR_LEN];\n    int status;\n\n    struct addrinfo ai_hints;\n    struct addrinfo *ai_list = NULL;\n    struct addrinfo *ai_ptr = NULL;\n\n    conn->sock = 0;\n    conn->connected = 0;\n\n    bson_sprintf( port_str, \"%d\", port );\n\n    memset( &ai_hints, 0, sizeof( ai_hints ) );\n    ai_hints.ai_family = AF_UNSPEC;\n    ai_hints.ai_socktype = SOCK_STREAM;\n    ai_hints.ai_protocol = IPPROTO_TCP;\n\n    status = getaddrinfo( host, port_str, &ai_hints, &ai_list );\n    if ( status != 0 ) {\n        bson_sprintf( errstr, \"getaddrinfo failed with error %d\", status );\n        __mongo_set_error( conn, MONGO_CONN_ADDR_FAIL, errstr, WSAGetLastError() );\n        return MONGO_ERROR;\n    }\n\n    for ( ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next ) {\n        conn->sock = socket( ai_ptr->ai_family, ai_ptr->ai_socktype,\n                             ai_ptr->ai_protocol );\n\n        if ( conn->sock < 0 ) {\n            __mongo_set_error( conn, MONGO_SOCKET_ERROR, \"socket() failed\",\n                               WSAGetLastError() );\n            conn->sock = 0;\n            continue;\n        }\n\n        status = connect( conn->sock, ai_ptr->ai_addr, ai_ptr->ai_addrlen );\n        if ( status != 0 ) {\n            __mongo_set_error( conn, MONGO_SOCKET_ERROR, \"connect() failed\",\n                               WSAGetLastError() );\n            mongo_env_close_socket( conn->sock );\n            conn->sock = 0;\n            continue;\n        }\n\n        if ( ai_ptr->ai_protocol == IPPROTO_TCP ) {\n            int flag = 1;\n\n            setsockopt( conn->sock, IPPROTO_TCP, TCP_NODELAY,\n                        ( void * ) &flag, sizeof( flag ) );\n\n            if ( conn->op_timeout_ms > 0 )\n                mongo_env_set_socket_op_timeout( conn, conn->op_timeout_ms );\n        }\n\n        conn->connected = 1;\n        break;\n    }\n\n    freeaddrinfo( ai_list );\n\n    if ( ! conn->connected ) {\n        conn->err = MONGO_CONN_FAIL;\n        return MONGO_ERROR;\n    }\n    else {\n        mongo_clear_errors( conn );\n        return MONGO_OK;\n    }\n}\n\nMONGO_EXPORT int mongo_env_sock_init( void ) {\n\n    WSADATA wsaData;\n    WORD wVers;\n    static int called_once;\n    static int retval;\n\n    if (called_once) return retval;\n\n    called_once = 1;\n    wVers = MAKEWORD(1, 1);\n    retval = (WSAStartup(wVers, &wsaData) == 0);\n\n    return retval;\n}\n\n\n#elif !defined(MONGO_ENV_STANDARD) && (defined(__APPLE__) || defined(__linux) || defined(__unix) || defined(__posix))\n\n/* env_posix.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n/* Networking and other niceties for POSIX systems. */\n#include \"env.h\"\n#include <string.h>\n#include <errno.h>\n#include <sys/time.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#ifndef NI_MAXSERV\n# define NI_MAXSERV 32\n#endif\n\nint mongo_env_close_socket( int socket ) {\n    return close( socket );\n}\n\nint mongo_env_sock_init( void ) {\n    return 0;\n}\n\nint mongo_env_write_socket( mongo *conn, const void *buf, size_t len ) {\n    const char *cbuf = buf;\n#ifdef __APPLE__\n    int flags = 0;\n#else\n    int flags = MSG_NOSIGNAL;\n#endif\n\n    while ( len ) {\n        size_t sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            if (errno == EPIPE)\n                conn->connected = 0;\n            __mongo_set_error( conn, MONGO_IO_ERROR, strerror( errno ), errno );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_read_socket( mongo *conn, void *buf, size_t len ) {\n    char *cbuf = buf;\n    while ( len ) {\n        size_t sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, strerror( errno ), errno );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_set_socket_op_timeout( mongo *conn, int millis ) {\n    struct timeval tv;\n    tv.tv_sec = millis / 1000;\n    tv.tv_usec = ( millis % 1000 ) * 1000;\n\n    if ( setsockopt( conn->sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof( tv ) ) == -1 ) {\n        conn->err = MONGO_IO_ERROR;\n        __mongo_set_error( conn, MONGO_IO_ERROR, \"setsockopt SO_RCVTIMEO failed.\", errno );\n        return MONGO_ERROR;\n    }\n\n    if ( setsockopt( conn->sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof( tv ) ) == -1 ) {\n        __mongo_set_error( conn, MONGO_IO_ERROR, \"setsockopt SO_SNDTIMEO failed.\", errno );\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\nstatic int mongo_env_unix_socket_connect( mongo *conn, const char *sock_path ) {\n    struct sockaddr_un addr;\n    int status, len;\n\n    conn->connected = 0;\n\n    conn->sock = socket( AF_UNIX, SOCK_STREAM, 0 );\n\n    if ( conn->sock < 0 ) {\n        conn->sock = 0;\n        return MONGO_ERROR;\n    }\n\n    addr.sun_family = AF_UNIX;\n    strncpy( addr.sun_path, sock_path, sizeof(addr.sun_path) - 1 );\n    len = sizeof( addr );\n\n    status = connect( conn->sock, (struct sockaddr *) &addr, len );\n    if( status < 0 ) {\n        mongo_env_close_socket( conn->sock );\n        conn->sock = 0;\n        conn->err = MONGO_CONN_FAIL;\n        return MONGO_ERROR;\n    }\n\n    conn->connected = 1;\n\n    return MONGO_OK;\n}\n\nint mongo_env_socket_connect( mongo *conn, const char *host, int port ) {\n    char port_str[NI_MAXSERV];\n    int status;\n\n    struct addrinfo ai_hints;\n    struct addrinfo *ai_list = NULL;\n    struct addrinfo *ai_ptr = NULL;\n\n    if ( port < 0 ) {\n        return mongo_env_unix_socket_connect( conn, host );\n    }\n\n    conn->sock = 0;\n    conn->connected = 0;\n    sprintf(port_str,\"%d\",port);\n\n    bson_sprintf( port_str, \"%d\", port );\n\n    memset( &ai_hints, 0, sizeof( ai_hints ) );\n#ifdef AI_ADDRCONFIG\n    ai_hints.ai_flags = AI_ADDRCONFIG;\n#endif\n    ai_hints.ai_family = AF_UNSPEC;\n    ai_hints.ai_socktype = SOCK_STREAM;\n\n    status = getaddrinfo( host, port_str, &ai_hints, &ai_list );\n    if ( status != 0 ) {\n        bson_errprintf( \"getaddrinfo failed: %s\", gai_strerror( status ) );\n        conn->err = MONGO_CONN_ADDR_FAIL;\n        return MONGO_ERROR;\n    }\n\n    for ( ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next ) {\n        conn->sock = socket( ai_ptr->ai_family, ai_ptr->ai_socktype, ai_ptr->ai_protocol );\n        if ( conn->sock < 0 ) {\n            conn->sock = 0;\n            continue;\n        }\n\n        status = connect( conn->sock, ai_ptr->ai_addr, ai_ptr->ai_addrlen );\n        if ( status != 0 ) {\n            mongo_env_close_socket( conn->sock );\n            conn->sock = 0;\n            continue;\n        }\n#if __APPLE__\n        {\n            int flag = 1;\n            setsockopt( conn->sock, SOL_SOCKET, SO_NOSIGPIPE,\n                       ( void * ) &flag, sizeof( flag ) );\n        }\n#endif\n\n        if ( ai_ptr->ai_protocol == IPPROTO_TCP ) {\n            int flag = 1;\n\n            setsockopt( conn->sock, IPPROTO_TCP, TCP_NODELAY,\n                        ( void * ) &flag, sizeof( flag ) );\n            if ( conn->op_timeout_ms > 0 )\n                mongo_env_set_socket_op_timeout( conn, conn->op_timeout_ms );\n        }\n\n        conn->connected = 1;\n        break;\n    }\n\n    freeaddrinfo( ai_list );\n\n    if ( ! conn->connected ) {\n        conn->err = MONGO_CONN_FAIL;\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\n#else\n/* env_standard.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n/* Vanilla networking designed to work on all systems. */\n#include \"env.h\"\n#include <errno.h>\n#include <string.h>\n\n#ifdef _WIN32\n#ifdef _MSC_VER\n#include <ws2tcpip.h>  /* send,recv,socklen_t etc */\n#include <wspiapi.h>   /* addrinfo */\n#else\n#include <windows.h>\n#include <winsock.h>\ntypedef int socklen_t;\n#endif\n#else\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <fcntl.h>\n#include <unistd.h>\n#endif\n\n#ifndef NI_MAXSERV\n# define NI_MAXSERV 32\n#endif\n\nint mongo_env_close_socket( int socket ) {\n#ifdef _WIN32\n    return closesocket( socket );\n#else\n    return close( socket );\n#endif\n}\n\nint mongo_env_write_socket( mongo *conn, const void *buf, size_t len ) {\n    const char *cbuf = buf;\n#ifdef _WIN32\n    int flags = 0;\n#else\n#ifdef __APPLE__\n    int flags = 0;\n#else\n    int flags = MSG_NOSIGNAL;\n#endif\n#endif\n\n    while ( len ) {\n        size_t sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            if (errno == EPIPE)\n                conn->connected = 0;\n            conn->err = MONGO_IO_ERROR;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\nint mongo_env_read_socket( mongo *conn, void *buf, size_t len ) {\n    char *cbuf = buf;\n    while ( len ) {\n        size_t sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            conn->err = MONGO_IO_ERROR;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n\n/* This is a no-op in the generic implementation. */\nint mongo_env_set_socket_op_timeout( mongo *conn, int millis ) {\n    return MONGO_OK;\n}\n\nint mongo_env_socket_connect( mongo *conn, const char *host, int port ) {\n    struct sockaddr_in sa;\n    socklen_t addressSize;\n    int flag = 1;\n\n    if ( ( conn->sock = socket( AF_INET, SOCK_STREAM, 0 ) ) < 0 ) {\n        conn->sock = 0;\n        conn->err = MONGO_CONN_NO_SOCKET;\n        return MONGO_ERROR;\n    }\n\n    memset( sa.sin_zero , 0 , sizeof( sa.sin_zero ) );\n    sa.sin_family = AF_INET;\n    sa.sin_port = htons( port );\n    sa.sin_addr.s_addr = inet_addr( host );\n    addressSize = sizeof( sa );\n\n    if ( connect( conn->sock, ( struct sockaddr * )&sa, addressSize ) == -1 ) {\n        mongo_env_close_socket( conn->sock );\n        conn->connected = 0;\n        conn->sock = 0;\n        conn->err = MONGO_CONN_FAIL;\n        return MONGO_ERROR;\n    }\n\n    setsockopt( conn->sock, IPPROTO_TCP, TCP_NODELAY, ( char * ) &flag, sizeof( flag ) );\n\n    if( conn->op_timeout_ms > 0 )\n        mongo_env_set_socket_op_timeout( conn, conn->op_timeout_ms );\n\n    conn->connected = 1;\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_env_sock_init( void ) {\n\n#if defined(_WIN32)\n    WSADATA wsaData;\n    WORD wVers;\n#elif defined(SIGPIPE)\n    struct sigaction act;\n#endif\n\n    static int called_once;\n    static int retval;\n    if (called_once) return retval;\n    called_once = 1;\n\n#if defined(_WIN32)\n    wVers = MAKEWORD(1, 1);\n    retval = (WSAStartup(wVers, &wsaData) == 0);\n#elif defined(MACINTOSH)\n    GUSISetup(GUSIwithInternetSockets);\n    retval = 1;\n#elif defined(SIGPIPE)\n    retval = 1;\n    if (sigaction(SIGPIPE, (struct sigaction *)NULL, &act) < 0)\n        retval = 0;\n    else if (act.sa_handler == SIG_DFL) {\n        act.sa_handler = SIG_IGN;\n        if (sigaction(SIGPIPE, &act, (struct sigaction *)NULL) < 0)\n            retval = 0;\n    }\n#endif\n    return retval;\n}\n\n#endif\n", "/** @file env.h */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n/* Header for generic net.h */\n#ifndef MONGO_ENV_H_\n#define MONGO_ENV_H_\n\n#include \"mongo.h\"\n\nMONGO_EXTERN_C_START\n\n/* This is a no-op in the generic implementation. */\nint mongo_env_set_socket_op_timeout( mongo *conn, int millis );\nint mongo_env_read_socket( mongo *conn, void *buf, size_t len );\nint mongo_env_write_socket( mongo *conn, const void *buf, size_t len );\nint mongo_env_socket_connect( mongo *conn, const char *host, int port );\n\n/* Initialize socket services */\nMONGO_EXPORT int mongo_env_sock_init( void );\n\n/* Close a socket */\nMONGO_EXPORT int mongo_env_close_socket( int socket );\n\nMONGO_EXTERN_C_END\n#endif\n", "/* gridfs.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#include \"gridfs.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nMONGO_EXPORT gridfs* gridfs_create( void ) {\n    return (gridfs*)bson_malloc(sizeof(gridfs));\n}\n\nMONGO_EXPORT void gridfs_dispose(gridfs* gfs) {\n    free(gfs);\n}\n\nMONGO_EXPORT gridfile* gridfile_create( void ) {\n    return (gridfile*)bson_malloc(sizeof(gridfile));\n}\n\nMONGO_EXPORT void gridfile_dispose(gridfile* gf) {\n    free(gf);\n}\n\nMONGO_EXPORT void gridfile_get_descriptor(gridfile* gf, bson* out) {\n    *out = *gf->meta;\n}\n\n\nstatic bson *chunk_new( bson_oid_t id, int chunkNumber,\n                        const char *data, int len ) {\n    bson *b = bson_malloc( sizeof( bson ) );\n\n    bson_init( b );\n    bson_append_oid( b, \"files_id\", &id );\n    bson_append_int( b, \"n\", chunkNumber );\n    bson_append_binary( b, \"data\", BSON_BIN_BINARY, data, len );\n    bson_finish( b );\n    return  b;\n}\n\nstatic void chunk_free( bson *oChunk ) {\n    bson_destroy( oChunk );\n    bson_free( oChunk );\n}\n\nint gridfs_init( mongo *client, const char *dbname, const char *prefix,\n                 gridfs *gfs ) {\n\n    int options;\n    bson b;\n    bson_bool_t success;\n\n    gfs->client = client;\n\n    /* Allocate space to own the dbname */\n    gfs->dbname = ( const char * )bson_malloc( strlen( dbname )+1 );\n    strcpy( ( char * )gfs->dbname, dbname );\n\n    /* Allocate space to own the prefix */\n    if ( prefix == NULL ) prefix = \"fs\";\n    gfs->prefix = ( const char * )bson_malloc( strlen( prefix )+1 );\n    strcpy( ( char * )gfs->prefix, prefix );\n\n    /* Allocate space to own files_ns */\n    gfs->files_ns =\n        ( const char * ) bson_malloc ( strlen( prefix )+strlen( dbname )+strlen( \".files\" )+2 );\n    strcpy( ( char * )gfs->files_ns, dbname );\n    strcat( ( char * )gfs->files_ns, \".\" );\n    strcat( ( char * )gfs->files_ns, prefix );\n    strcat( ( char * )gfs->files_ns, \".files\" );\n\n    /* Allocate space to own chunks_ns */\n    gfs->chunks_ns = ( const char * ) bson_malloc( strlen( prefix ) + strlen( dbname )\n                     + strlen( \".chunks\" ) + 2 );\n    strcpy( ( char * )gfs->chunks_ns, dbname );\n    strcat( ( char * )gfs->chunks_ns, \".\" );\n    strcat( ( char * )gfs->chunks_ns, prefix );\n    strcat( ( char * )gfs->chunks_ns, \".chunks\" );\n\n    bson_init( &b );\n    bson_append_int( &b, \"filename\", 1 );\n    bson_finish( &b );\n    options = 0;\n    success = ( mongo_create_index( gfs->client, gfs->files_ns, &b, options, NULL ) == MONGO_OK );\n    bson_destroy( &b );\n    if ( !success ) {\n        bson_free( ( char * )gfs->dbname );\n        bson_free( ( char * )gfs->prefix );\n        bson_free( ( char * )gfs->files_ns );\n        bson_free( ( char * )gfs->chunks_ns );\n        return MONGO_ERROR;\n    }\n\n    bson_init( &b );\n    bson_append_int( &b, \"files_id\", 1 );\n    bson_append_int( &b, \"n\", 1 );\n    bson_finish( &b );\n    options = MONGO_INDEX_UNIQUE;\n    success = ( mongo_create_index( gfs->client, gfs->chunks_ns, &b, options, NULL ) == MONGO_OK );\n    bson_destroy( &b );\n    if ( !success ) {\n        bson_free( ( char * )gfs->dbname );\n        bson_free( ( char * )gfs->prefix );\n        bson_free( ( char * )gfs->files_ns );\n        bson_free( ( char * )gfs->chunks_ns );\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT void gridfs_destroy( gridfs *gfs ) {\n    if ( gfs == NULL ) return;\n    if ( gfs->dbname ) bson_free( ( char * )gfs->dbname );\n    if ( gfs->prefix ) bson_free( ( char * )gfs->prefix );\n    if ( gfs->files_ns ) bson_free( ( char * )gfs->files_ns );\n    if ( gfs->chunks_ns ) bson_free( ( char * )gfs->chunks_ns );\n}\n\nstatic int gridfs_insert_file( gridfs *gfs, const char *name,\n                               const bson_oid_t id, gridfs_offset length,\n                               const char *contenttype ) {\n    bson command;\n    bson ret;\n    bson res;\n    bson_iterator it;\n    int result;\n    int64_t d;\n\n    /* Check run md5 */\n    bson_init( &command );\n    bson_append_oid( &command, \"filemd5\", &id );\n    bson_append_string( &command, \"root\", gfs->prefix );\n    bson_finish( &command );\n    result = mongo_run_command( gfs->client, gfs->dbname, &command, &res );\n    bson_destroy( &command );\n    if (result != MONGO_OK)\n        return result;\n\n    /* Create and insert BSON for file metadata */\n    bson_init( &ret );\n    bson_append_oid( &ret, \"_id\", &id );\n    if ( name != NULL && *name != '\\0' ) {\n        bson_append_string( &ret, \"filename\", name );\n    }\n    bson_append_long( &ret, \"length\", length );\n    bson_append_int( &ret, \"chunkSize\", DEFAULT_CHUNK_SIZE );\n    d = ( bson_date_t )1000*time( NULL );\n    bson_append_date( &ret, \"uploadDate\", d);\n    bson_find( &it, &res, \"md5\" );\n    bson_append_string( &ret, \"md5\", bson_iterator_string( &it ) );\n    bson_destroy( &res );\n    if ( contenttype != NULL && *contenttype != '\\0' ) {\n        bson_append_string( &ret, \"contentType\", contenttype );\n    }\n    bson_finish( &ret );\n    result = mongo_insert( gfs->client, gfs->files_ns, &ret, NULL );\n    bson_destroy( &ret );\n\n    return result;\n}\n\nMONGO_EXPORT int gridfs_store_buffer( gridfs *gfs, const char *data,\n                                      gridfs_offset length, const char *remotename,\n                                      const char *contenttype ) {\n\n    char const *end = data + length;\n    const char *data_ptr = data;\n    bson_oid_t id;\n    int chunkNumber = 0;\n    int chunkLen;\n    bson *oChunk;\n\n    /* Large files Assertion */\n    /* assert( length <= 0xffffffff ); */\n\n    /* Generate and append an oid*/\n    bson_oid_gen( &id );\n\n    /* Insert the file's data chunk by chunk */\n    while ( data_ptr < end ) {\n        chunkLen = DEFAULT_CHUNK_SIZE < ( unsigned int )( end - data_ptr ) ?\n                   DEFAULT_CHUNK_SIZE : ( unsigned int )( end - data_ptr );\n        oChunk = chunk_new( id, chunkNumber, data_ptr, chunkLen );\n        mongo_insert( gfs->client, gfs->chunks_ns, oChunk, NULL );\n        chunk_free( oChunk );\n        chunkNumber++;\n        data_ptr += chunkLen;\n    }\n\n    /* Inserts file's metadata */\n    return gridfs_insert_file( gfs, remotename, id, length, contenttype );\n}\n\nMONGO_EXPORT void gridfile_writer_init( gridfile *gfile, gridfs *gfs,\n                                        const char *remote_name, const char *content_type ) {\n    gfile->gfs = gfs;\n\n    bson_oid_gen( &( gfile->id ) );\n    gfile->chunk_num = 0;\n    gfile->length = 0;\n    gfile->pending_len = 0;\n    gfile->pending_data = NULL;\n\n    gfile->remote_name = ( char * )bson_malloc( strlen( remote_name ) + 1 );\n    strcpy( ( char * )gfile->remote_name, remote_name );\n\n    gfile->content_type = ( char * )bson_malloc( strlen( content_type ) + 1 );\n    strcpy( ( char * )gfile->content_type, content_type );\n}\n\nMONGO_EXPORT void gridfile_write_buffer( gridfile *gfile, const char *data,\n        gridfs_offset length ) {\n\n    size_t bytes_left = 0;\n    size_t data_partial_len = 0;\n    size_t chunks_to_write = 0;\n    char *buffer;\n    bson *oChunk;\n    gridfs_offset to_write = length + gfile->pending_len;\n\n    if ( to_write < DEFAULT_CHUNK_SIZE ) { /* Less than one chunk to write */\n        if( gfile->pending_data ) {\n            gfile->pending_data = ( char * )bson_realloc( ( void * )gfile->pending_data, gfile->pending_len + to_write );\n            memcpy( gfile->pending_data + gfile->pending_len, data, length );\n        }\n        else if ( to_write > 0 ) {\n            gfile->pending_data = ( char * )bson_malloc( to_write );\n            memcpy( gfile->pending_data, data, length );\n        }\n        gfile->pending_len += length;\n\n    }\n    else {   /* At least one chunk of data to write */\n        chunks_to_write = to_write / DEFAULT_CHUNK_SIZE;\n        bytes_left = to_write % DEFAULT_CHUNK_SIZE;\n\n        /* If there's a pending chunk to be written, we need to combine\n         * the buffer provided up to DEFAULT_CHUNK_SIZE.\n         */\n        if ( gfile->pending_len > 0 ) {\n            data_partial_len = DEFAULT_CHUNK_SIZE - gfile->pending_len;\n            buffer = ( char * )bson_malloc( DEFAULT_CHUNK_SIZE );\n            memcpy( buffer, gfile->pending_data, gfile->pending_len );\n            memcpy( buffer + gfile->pending_len, data, data_partial_len );\n\n            oChunk = chunk_new( gfile->id, gfile->chunk_num, buffer, DEFAULT_CHUNK_SIZE );\n            mongo_insert( gfile->gfs->client, gfile->gfs->chunks_ns, oChunk, NULL );\n            chunk_free( oChunk );\n            gfile->chunk_num++;\n            gfile->length += DEFAULT_CHUNK_SIZE;\n            data += data_partial_len;\n\n            chunks_to_write--;\n\n            bson_free( buffer );\n        }\n\n        while( chunks_to_write > 0 ) {\n            oChunk = chunk_new( gfile->id, gfile->chunk_num, data, DEFAULT_CHUNK_SIZE );\n            mongo_insert( gfile->gfs->client, gfile->gfs->chunks_ns, oChunk, NULL );\n            chunk_free( oChunk );\n            gfile->chunk_num++;\n            chunks_to_write--;\n            gfile->length += DEFAULT_CHUNK_SIZE;\n            data += DEFAULT_CHUNK_SIZE;\n        }\n\n        bson_free( gfile->pending_data );\n\n        /* If there are any leftover bytes, store them as pending data. */\n        if( bytes_left == 0 )\n            gfile->pending_data = NULL;\n        else {\n            gfile->pending_data = ( char * )bson_malloc( bytes_left );\n            memcpy( gfile->pending_data, data, bytes_left );\n        }\n\n        gfile->pending_len = bytes_left;\n    }\n}\n\nMONGO_EXPORT int gridfile_writer_done( gridfile *gfile ) {\n\n    /* write any remaining pending chunk data.\n     * pending data will always take up less than one chunk */\n    bson *oChunk;\n    int response;\n    if( gfile->pending_data ) {\n        oChunk = chunk_new( gfile->id, gfile->chunk_num, gfile->pending_data, gfile->pending_len );\n        mongo_insert( gfile->gfs->client, gfile->gfs->chunks_ns, oChunk, NULL );\n        chunk_free( oChunk );\n        bson_free( gfile->pending_data );\n        gfile->length += gfile->pending_len;\n    }\n\n    /* insert into files collection */\n    response = gridfs_insert_file( gfile->gfs, gfile->remote_name, gfile->id,\n                                   gfile->length, gfile->content_type );\n\n    bson_free( gfile->remote_name );\n    bson_free( gfile->content_type );\n\n    return response;\n}\n\nint gridfs_store_file( gridfs *gfs, const char *filename,\n                       const char *remotename, const char *contenttype ) {\n\n    char buffer[DEFAULT_CHUNK_SIZE];\n    FILE *fd;\n    bson_oid_t id;\n    int chunkNumber = 0;\n    gridfs_offset length = 0;\n    gridfs_offset chunkLen = 0;\n    bson *oChunk;\n\n    /* Open the file and the correct stream */\n    if ( strcmp( filename, \"-\" ) == 0 ) fd = stdin;\n    else {\n        fd = fopen( filename, \"rb\" );\n        if (fd == NULL)\n            return MONGO_ERROR;\n    }\n\n    /* Generate and append an oid*/\n    bson_oid_gen( &id );\n\n    /* Insert the file chunk by chunk */\n    chunkLen = fread( buffer, 1, DEFAULT_CHUNK_SIZE, fd );\n    do {\n        oChunk = chunk_new( id, chunkNumber, buffer, chunkLen );\n        mongo_insert( gfs->client, gfs->chunks_ns, oChunk, NULL );\n        chunk_free( oChunk );\n        length += chunkLen;\n        chunkNumber++;\n        chunkLen = fread( buffer, 1, DEFAULT_CHUNK_SIZE, fd );\n    }\n    while ( chunkLen != 0 );\n\n    /* Close the file stream */\n    if ( fd != stdin ) fclose( fd );\n\n    /* Large files Assertion */\n    /* assert(length <= 0xffffffff); */\n\n    /* Optional Remote Name */\n    if ( remotename == NULL || *remotename == '\\0' ) {\n        remotename = filename;\n    }\n\n    /* Inserts file's metadata */\n    return gridfs_insert_file( gfs, remotename, id, length, contenttype );\n}\n\nMONGO_EXPORT void gridfs_remove_filename( gridfs *gfs, const char *filename ) {\n    bson query;\n    mongo_cursor *files;\n    bson file;\n    bson_iterator it;\n    bson_oid_t id;\n    bson b;\n\n    bson_init( &query );\n    bson_append_string( &query, \"filename\", filename );\n    bson_finish( &query );\n    files = mongo_find( gfs->client, gfs->files_ns, &query, NULL, 0, 0, 0 );\n    bson_destroy( &query );\n\n    /* Remove each file and it's chunks from files named filename */\n    while ( mongo_cursor_next( files ) == MONGO_OK ) {\n        file = files->current;\n        bson_find( &it, &file, \"_id\" );\n        id = *bson_iterator_oid( &it );\n\n        /* Remove the file with the specified id */\n        bson_init( &b );\n        bson_append_oid( &b, \"_id\", &id );\n        bson_finish( &b );\n        mongo_remove( gfs->client, gfs->files_ns, &b, NULL );\n        bson_destroy( &b );\n\n        /* Remove all chunks from the file with the specified id */\n        bson_init( &b );\n        bson_append_oid( &b, \"files_id\", &id );\n        bson_finish( &b );\n        mongo_remove( gfs->client, gfs->chunks_ns, &b, NULL );\n        bson_destroy( &b );\n    }\n\n    mongo_cursor_destroy( files );\n}\n\nint gridfs_find_query( gridfs *gfs, bson *query,\n                       gridfile *gfile ) {\n\n    bson uploadDate;\n    bson finalQuery;\n    bson out;\n    int i;\n\n    bson_init( &uploadDate );\n    bson_append_int( &uploadDate, \"uploadDate\", -1 );\n    bson_finish( &uploadDate );\n\n    bson_init( &finalQuery );\n    bson_append_bson( &finalQuery, \"query\", query );\n    bson_append_bson( &finalQuery, \"orderby\", &uploadDate );\n    bson_finish( &finalQuery );\n\n    i = ( mongo_find_one( gfs->client, gfs->files_ns,\n                          &finalQuery, NULL, &out ) == MONGO_OK );\n    bson_destroy( &uploadDate );\n    bson_destroy( &finalQuery );\n    if ( !i )\n        return MONGO_ERROR;\n    else {\n        gridfile_init( gfs, &out, gfile );\n        bson_destroy( &out );\n        return MONGO_OK;\n    }\n}\n\nint gridfs_find_filename( gridfs *gfs, const char *filename,\n                          gridfile *gfile )\n\n{\n    bson query;\n    int i;\n\n    bson_init( &query );\n    bson_append_string( &query, \"filename\", filename );\n    bson_finish( &query );\n    i = gridfs_find_query( gfs, &query, gfile );\n    bson_destroy( &query );\n    return i;\n}\n\nint gridfile_init( gridfs *gfs, bson *meta, gridfile *gfile )\n\n{\n    gfile->gfs = gfs;\n    gfile->pos = 0;\n    gfile->meta = ( bson * )bson_malloc( sizeof( bson ) );\n    if ( gfile->meta == NULL ) return MONGO_ERROR;\n    bson_copy( gfile->meta, meta );\n    return MONGO_OK;\n}\n\nMONGO_EXPORT void gridfile_destroy( gridfile *gfile )\n\n{\n    bson_destroy( gfile->meta );\n    bson_free( gfile->meta );\n}\n\nbson_bool_t gridfile_exists( gridfile *gfile ) {\n    return ( bson_bool_t )( gfile != NULL && gfile->meta != NULL );\n}\n\nMONGO_EXPORT const char *gridfile_get_filename( gridfile *gfile ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, \"filename\" );\n    return bson_iterator_string( &it );\n}\n\nMONGO_EXPORT int gridfile_get_chunksize( gridfile *gfile ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, \"chunkSize\" );\n    return bson_iterator_int( &it );\n}\n\nMONGO_EXPORT gridfs_offset gridfile_get_contentlength( gridfile *gfile ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, \"length\" );\n\n    if( bson_iterator_type( &it ) == BSON_INT )\n        return ( gridfs_offset )bson_iterator_int( &it );\n    else\n        return ( gridfs_offset )bson_iterator_long( &it );\n}\n\nMONGO_EXPORT const char *gridfile_get_contenttype( gridfile *gfile ) {\n    bson_iterator it;\n\n    if ( bson_find( &it, gfile->meta, \"contentType\" ) )\n        return bson_iterator_string( &it );\n    else return NULL;\n}\n\nMONGO_EXPORT bson_date_t gridfile_get_uploaddate( gridfile *gfile ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, \"uploadDate\" );\n    return bson_iterator_date( &it );\n}\n\nMONGO_EXPORT const char *gridfile_get_md5( gridfile *gfile ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, \"md5\" );\n    return bson_iterator_string( &it );\n}\n\nconst char *gridfile_get_field( gridfile *gfile, const char *name ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, name );\n    return bson_iterator_value( &it );\n}\n\nbson_bool_t gridfile_get_boolean( gridfile *gfile, const char *name ) {\n    bson_iterator it;\n\n    bson_find( &it, gfile->meta, name );\n    return bson_iterator_bool( &it );\n}\n\nMONGO_EXPORT void gridfile_get_metadata( gridfile *gfile, bson* out ) {\n    bson_iterator it;\n\n    if ( bson_find( &it, gfile->meta, \"metadata\" ) )\n        bson_iterator_subobject( &it, out );\n    else\n        bson_empty( out );\n}\n\nMONGO_EXPORT int gridfile_get_numchunks( gridfile *gfile ) {\n    bson_iterator it;\n    gridfs_offset length;\n    gridfs_offset chunkSize;\n    double numchunks;\n\n    bson_find( &it, gfile->meta, \"length\" );\n\n    if( bson_iterator_type( &it ) == BSON_INT )\n        length = ( gridfs_offset )bson_iterator_int( &it );\n    else\n        length = ( gridfs_offset )bson_iterator_long( &it );\n\n    bson_find( &it, gfile->meta, \"chunkSize\" );\n    chunkSize = bson_iterator_int( &it );\n    numchunks = ( ( double )length/( double )chunkSize );\n    return ( numchunks - ( int )numchunks > 0 )\n           ? ( int )( numchunks+1 )\n           : ( int )( numchunks );\n}\n\nMONGO_EXPORT void gridfile_get_chunk( gridfile *gfile, int n, bson* out ) {\n    bson query;\n\n    bson_iterator it;\n    bson_oid_t id;\n    int result;\n\n    bson_init( &query );\n    bson_find( &it, gfile->meta, \"_id\" );\n    id = *bson_iterator_oid( &it );\n    bson_append_oid( &query, \"files_id\", &id );\n    bson_append_int( &query, \"n\", n );\n    bson_finish( &query );\n\n    result = (mongo_find_one(gfile->gfs->client,\n                             gfile->gfs->chunks_ns,\n                             &query, NULL, out ) == MONGO_OK );\n    bson_destroy( &query );\n    if (!result) {\n        bson empty;\n        bson_empty(&empty);\n        bson_copy(out, &empty);\n    }\n}\n\nMONGO_EXPORT mongo_cursor *gridfile_get_chunks( gridfile *gfile, int start, size_t size ) {\n    bson_iterator it;\n    bson_oid_t id;\n    bson gte;\n    bson query;\n    bson orderby;\n    bson command;\n    mongo_cursor *cursor;\n\n    bson_find( &it, gfile->meta, \"_id\" );\n    id = *bson_iterator_oid( &it );\n\n    bson_init( &query );\n    bson_append_oid( &query, \"files_id\", &id );\n    if ( size == 1 ) {\n        bson_append_int( &query, \"n\", (int)start );\n    }\n    else {\n        bson_init( &gte );\n        bson_append_int( &gte, \"$gte\", (int)start );\n        bson_finish( &gte );\n        bson_append_bson( &query, \"n\", &gte );\n        bson_destroy( &gte );\n    }\n    bson_finish( &query );\n\n    bson_init( &orderby );\n    bson_append_int( &orderby, \"n\", 1 );\n    bson_finish( &orderby );\n\n    bson_init( &command );\n    bson_append_bson( &command, \"query\", &query );\n    bson_append_bson( &command, \"orderby\", &orderby );\n    bson_finish( &command );\n\n    cursor = mongo_find( gfile->gfs->client, gfile->gfs->chunks_ns,\n                         &command, NULL, (int)size, 0, 0 );\n\n    bson_destroy( &command );\n    bson_destroy( &query );\n    bson_destroy( &orderby );\n\n    return cursor;\n}\n\ngridfs_offset gridfile_write_file( gridfile *gfile, FILE *stream ) {\n    int i;\n    size_t len;\n    bson chunk;\n    bson_iterator it;\n    const char *data;\n    const int num = gridfile_get_numchunks( gfile );\n\n    for ( i=0; i<num; i++ ) {\n        gridfile_get_chunk( gfile, i, &chunk );\n        bson_find( &it, &chunk, \"data\" );\n        len = bson_iterator_bin_len( &it );\n        data = bson_iterator_bin_data( &it );\n        fwrite( data, sizeof( char ), len, stream );\n        bson_destroy( &chunk );\n    }\n\n    return gridfile_get_contentlength( gfile );\n}\n\nMONGO_EXPORT gridfs_offset gridfile_read( gridfile *gfile, gridfs_offset size, char *buf ) {\n    mongo_cursor *chunks;\n    bson chunk;\n\n    size_t first_chunk;\n    size_t last_chunk;\n    size_t total_chunks;\n    gridfs_offset chunksize;\n    gridfs_offset contentlength;\n    gridfs_offset bytes_left;\n    int i;\n    bson_iterator it;\n    gridfs_offset chunk_len;\n    const char *chunk_data;\n\n    contentlength = gridfile_get_contentlength( gfile );\n    chunksize = gridfile_get_chunksize( gfile );\n    size = ( contentlength - gfile->pos < size )\n           ? contentlength - gfile->pos\n           : size;\n    bytes_left = size;\n\n    first_chunk = ( gfile->pos )/chunksize;\n    last_chunk = ( gfile->pos+size-1 )/chunksize;\n    total_chunks = last_chunk - first_chunk + 1;\n    chunks = gridfile_get_chunks( gfile, first_chunk, total_chunks );\n\n    for ( i = 0; i < total_chunks; i++ ) {\n        mongo_cursor_next( chunks );\n        chunk = chunks->current;\n        bson_find( &it, &chunk, \"data\" );\n        chunk_len = bson_iterator_bin_len( &it );\n        chunk_data = bson_iterator_bin_data( &it );\n        if ( i == 0 ) {\n            chunk_data += ( gfile->pos )%chunksize;\n            chunk_len -= ( gfile->pos )%chunksize;\n        }\n        if ( bytes_left > chunk_len ) {\n            memcpy( buf, chunk_data, chunk_len );\n            bytes_left -= chunk_len;\n            buf += chunk_len;\n        }\n        else {\n            memcpy( buf, chunk_data, bytes_left );\n        }\n    }\n\n    mongo_cursor_destroy( chunks );\n    gfile->pos = gfile->pos + size;\n\n    return size;\n}\n\nMONGO_EXPORT gridfs_offset gridfile_seek( gridfile *gfile, gridfs_offset offset ) {\n    gridfs_offset length;\n\n    length = gridfile_get_contentlength( gfile );\n    gfile->pos = length < offset ? length : offset;\n    return gfile->pos;\n}\n", "/** @file gridfs.h\n *\n *  @brief GridFS declarations\n *\n * */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#include \"mongo.h\"\n\n#ifndef MONGO_GRIDFS_H_\n#define MONGO_GRIDFS_H_\n\nenum {DEFAULT_CHUNK_SIZE = 256 * 1024};\n\ntypedef uint64_t gridfs_offset;\n\n/* A GridFS represents a single collection of GridFS files in the database. */\ntypedef struct {\n    mongo *client; /**> The client to db-connection. */\n    const char *dbname; /**> The root database name */\n    const char *prefix; /**> The prefix of the GridFS's collections, default is NULL */\n    const char *files_ns; /**> The namespace where the file's metadata is stored */\n    const char *chunks_ns; /**. The namespace where the files's data is stored in chunks */\n} gridfs;\n\n/* A GridFile is a single GridFS file. */\ntypedef struct {\n    gridfs *gfs;        /**> The GridFS where the GridFile is located */\n    bson *meta;         /**> The GridFile's bson object where all its metadata is located */\n    gridfs_offset pos;  /**> The position is the offset in the file */\n    bson_oid_t id;      /**> The files_id of the gridfile */\n    char *remote_name;  /**> The name of the gridfile as a string */\n    char *content_type; /**> The gridfile's content type */\n    gridfs_offset length; /**> The length of this gridfile */\n    int chunk_num;      /**> The number of the current chunk being written to */\n    char *pending_data; /**> A buffer storing data still to be written to chunks */\n    size_t pending_len;    /**> Length of pending_data buffer */\n} gridfile;\n\nMONGO_EXPORT gridfs* gridfs_create( void );\nMONGO_EXPORT void gridfs_dispose(gridfs* gfs);\nMONGO_EXPORT gridfile* gridfile_create( void );\nMONGO_EXPORT void gridfile_dispose(gridfile* gf);\nMONGO_EXPORT void gridfile_get_descriptor(gridfile* gf, bson* out);\n\n/**\n *  Initializes a GridFS object\n *  @param client - db connection\n *  @param dbname - database name\n *  @param prefix - collection prefix, default is fs if NULL or empty\n *  @param gfs - the GridFS object to initialize\n *\n *  @return - MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfs_init( mongo *client, const char *dbname,\n                              const char *prefix, gridfs *gfs );\n\n/**\n * Destroys a GridFS object. Call this when finished with\n * the object..\n *\n * @param gfs a grid\n */\nMONGO_EXPORT void gridfs_destroy( gridfs *gfs );\n\n/**\n *  Initializes a gridfile for writing incrementally with gridfs_write_buffer.\n *  Once initialized, you can write any number of buffers with gridfs_write_buffer.\n *  When done, you must call gridfs_writer_done to save the file metadata.\n *\n */\nMONGO_EXPORT void gridfile_writer_init( gridfile *gfile, gridfs *gfs, const char *remote_name,\n                                        const char *content_type );\n\n/**\n *  Write to a GridFS file incrementally. You can call this function any number\n *  of times with a new buffer each time. This allows you to effectively\n *  stream to a GridFS file. When finished, be sure to call gridfs_writer_done.\n *\n */\nMONGO_EXPORT void gridfile_write_buffer( gridfile *gfile, const char *data,\n        gridfs_offset length );\n\n/**\n *  Signal that writing of this gridfile is complete by\n *  writing any buffered chunks along with the entry in the\n *  files collection.\n *\n *  @return - MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfile_writer_done( gridfile *gfile );\n\n/**\n *  Store a buffer as a GridFS file.\n *  @param gfs - the working GridFS\n *  @param data - pointer to buffer to store in GridFS\n *  @param length - length of the buffer\n *  @param remotename - filename for use in the database\n *  @param contenttype - optional MIME type for this object\n *\n *  @return - MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfs_store_buffer( gridfs *gfs, const char *data, gridfs_offset length,\n                                      const char *remotename,\n                                      const char *contenttype );\n\n/**\n *  Open the file referenced by filename and store it as a GridFS file.\n *  @param gfs - the working GridFS\n *  @param filename - local filename relative to the process\n *  @param remotename - optional filename for use in the database\n *  @param contenttype - optional MIME type for this object\n *\n *  @return - MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfs_store_file( gridfs *gfs, const char *filename,\n                                    const char *remotename, const char *contenttype );\n\n/**\n *  Removes the files referenced by filename from the db\n *  @param gfs - the working GridFS\n *  @param filename - the filename of the file/s to be removed\n */\nMONGO_EXPORT void gridfs_remove_filename( gridfs *gfs, const char *filename );\n\n/**\n *  Find the first file matching the provided query within the\n *  GridFS files collection, and return the file as a GridFile.\n *\n *  @param gfs - the working GridFS\n *  @param query - a pointer to the bson with the query data\n *  @param gfile - the output GridFile to be initialized\n *\n *  @return MONGO_OK if successful, MONGO_ERROR otherwise\n */\nMONGO_EXPORT int gridfs_find_query( gridfs *gfs, bson *query, gridfile *gfile );\n\n/**\n *  Find the first file referenced by filename within the GridFS\n *  and return it as a GridFile\n *  @param gfs - the working GridFS\n *  @param filename - filename of the file to find\n *  @param gfile - the output GridFile to be intialized\n *\n *  @return MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfs_find_filename( gridfs *gfs, const char *filename, gridfile *gfile );\n\n/**\n *  Initializes a GridFile containing the GridFS and file bson\n *  @param gfs - the GridFS where the GridFile is located\n *  @param meta - the file object\n *  @param gfile - the output GridFile that is being initialized\n *\n *  @return - MONGO_OK or MONGO_ERROR.\n */\nMONGO_EXPORT int gridfile_init( gridfs *gfs, bson *meta, gridfile *gfile );\n\n/**\n *  Destroys the GridFile\n *\n *  @param oGridFIle - the GridFile being destroyed\n */\nMONGO_EXPORT void gridfile_destroy( gridfile *gfile );\n\n/**\n *  Returns whether or not the GridFile exists\n *  @param gfile - the GridFile being examined\n */\nMONGO_EXPORT bson_bool_t gridfile_exists( gridfile *gfile );\n\n/**\n *  Returns the filename of GridFile\n *  @param gfile - the working GridFile\n *\n *  @return - the filename of the Gridfile\n */\nMONGO_EXPORT const char *gridfile_get_filename( gridfile *gfile );\n\n/**\n *  Returns the size of the chunks of the GridFile\n *  @param gfile - the working GridFile\n *\n *  @return - the size of the chunks of the Gridfile\n */\nMONGO_EXPORT int gridfile_get_chunksize( gridfile *gfile );\n\n/**\n *  Returns the length of GridFile's data\n *\n *  @param gfile - the working GridFile\n *\n *  @return - the length of the Gridfile's data\n */\nMONGO_EXPORT gridfs_offset gridfile_get_contentlength( gridfile *gfile );\n\n/**\n *  Returns the MIME type of the GridFile\n *\n *  @param gfile - the working GridFile\n *\n *  @return - the MIME type of the Gridfile\n *            (NULL if no type specified)\n */\nMONGO_EXPORT const char *gridfile_get_contenttype( gridfile *gfile );\n\n/**\n *  Returns the upload date of GridFile\n *\n *  @param gfile - the working GridFile\n *\n *  @return - the upload date of the Gridfile\n */\nMONGO_EXPORT bson_date_t gridfile_get_uploaddate( gridfile *gfile );\n\n/**\n *  Returns the MD5 of GridFile\n *\n *  @param gfile - the working GridFile\n *\n *  @return - the MD5 of the Gridfile\n */\nMONGO_EXPORT const char *gridfile_get_md5( gridfile *gfile );\n\n/**\n *  Returns the field in GridFile specified by name\n *\n *  @param gfile - the working GridFile\n *  @param name - the name of the field to be returned\n *\n *  @return - the data of the field specified\n *            (NULL if none exists)\n */\nconst char *gridfile_get_field( gridfile *gfile,\n                                const char *name );\n\n/**\n *  Returns a boolean field in GridFile specified by name\n *  @param gfile - the working GridFile\n *  @param name - the name of the field to be returned\n *\n *  @return - the boolean of the field specified\n *            (NULL if none exists)\n */\nbson_bool_t gridfile_get_boolean( gridfile *gfile,\n                                  const char *name );\n\n/**\n *  Returns the metadata of GridFile\n *  @param gfile - the working GridFile\n *\n *  @return - the metadata of the Gridfile in a bson object\n *            (an empty bson is returned if none exists)\n */\nMONGO_EXPORT void gridfile_get_metadata( gridfile *gfile, bson* out );\n\n/**\n *  Returns the number of chunks in the GridFile\n *  @param gfile - the working GridFile\n *\n *  @return - the number of chunks in the Gridfile\n */\nMONGO_EXPORT int gridfile_get_numchunks( gridfile *gfile );\n\n/**\n *  Returns chunk n of GridFile\n *  @param gfile - the working GridFile\n *\n *  @return - the nth chunk of the Gridfile\n */\nMONGO_EXPORT void gridfile_get_chunk( gridfile *gfile, int n, bson* out );\n\n/**\n *  Returns a mongo_cursor of *size* chunks starting with chunk *start*\n *\n *  @param gfile - the working GridFile\n *  @param start - the first chunk in the cursor\n *  @param size - the number of chunks to be returned\n *\n *  @return - mongo_cursor of the chunks (must be destroyed after use)\n */\nMONGO_EXPORT mongo_cursor *gridfile_get_chunks( gridfile *gfile, int start, size_t size );\n\n/**\n *  Writes the GridFile to a stream\n *\n *  @param gfile - the working GridFile\n *  @param stream - the file stream to write to\n */\nMONGO_EXPORT gridfs_offset gridfile_write_file( gridfile *gfile, FILE *stream );\n\n/**\n *  Reads length bytes from the GridFile to a buffer\n *  and updates the position in the file.\n *  (assumes the buffer is large enough)\n *  (if size is greater than EOF gridfile_read reads until EOF)\n *\n *  @param gfile - the working GridFile\n *  @param size - the amount of bytes to be read\n *  @param buf - the buffer to read to\n *\n *  @return - the number of bytes read\n */\nMONGO_EXPORT gridfs_offset gridfile_read( gridfile *gfile, gridfs_offset size, char *buf );\n\n/**\n *  Updates the position in the file\n *  (If the offset goes beyond the contentlength,\n *  the position is updated to the end of the file.)\n *\n *  @param gfile - the working GridFile\n *  @param offset - the position to update to\n *\n *  @return - resulting offset location\n */\nMONGO_EXPORT gridfs_offset gridfile_seek( gridfile *gfile, gridfs_offset offset );\n\n#endif\n", "/* mongo.c */\n\n/*    Copyright 2009-2012 10gen Inc.\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\n\n#include \"mongo.h\"\n#include \"md5.h\"\n#include \"env.h\"\n\n#include <string.h>\n\nMONGO_EXPORT mongo* mongo_create( void ) {\n    return (mongo*)bson_malloc(sizeof(mongo));\n}\n\n\nMONGO_EXPORT void mongo_dispose(mongo* conn) {\n    bson_free(conn);\n}\n\nMONGO_EXPORT int mongo_get_err(mongo* conn) {\n    return conn->err;\n}\n\n\nMONGO_EXPORT int mongo_is_connected(mongo* conn) {\n    return conn->connected != 0;\n}\n\n\nMONGO_EXPORT int mongo_get_op_timeout(mongo* conn) {\n    return conn->op_timeout_ms;\n}\n\n\nstatic const char* _get_host_port(mongo_host_port* hp) {\n    static char _hp[sizeof(hp->host)+12];\n    bson_sprintf(_hp, \"%s:%d\", hp->host, hp->port);\n    return _hp;\n}\n\n\nMONGO_EXPORT const char* mongo_get_primary(mongo* conn) {\n    mongo* conn_ = (mongo*)conn;\n    if( !(conn_->connected) || (conn_->primary->host[0] == '\\0') )\n        return NULL;\n    return _get_host_port(conn_->primary);\n}\n\n\nMONGO_EXPORT int mongo_get_socket(mongo* conn) {\n    mongo* conn_ = (mongo*)conn;\n    return conn_->sock;\n}\n\n\nMONGO_EXPORT int mongo_get_host_count(mongo* conn) {\n    mongo_replica_set* r = conn->replica_set;\n    mongo_host_port* hp;\n    int count = 0;\n    if (!r) return 0;\n    for (hp = r->hosts; hp; hp = hp->next)\n        ++count;\n    return count;\n}\n\n\nMONGO_EXPORT const char* mongo_get_host(mongo* conn, int i) {\n    mongo_replica_set* r = conn->replica_set;\n    mongo_host_port* hp;\n    int count = 0;\n    if (!r) return 0;\n    for (hp = r->hosts; hp; hp = hp->next) {\n        if (count == i)\n            return _get_host_port(hp);\n        ++count;\n    }\n    return 0;\n}\n\n\nMONGO_EXPORT mongo_cursor* mongo_cursor_create( void ) {\n    return (mongo_cursor*)bson_malloc(sizeof(mongo_cursor));\n}\n\n\nMONGO_EXPORT void mongo_cursor_dispose(mongo_cursor* cursor) {\n    bson_free(cursor);\n}\n\n\nMONGO_EXPORT int  mongo_get_server_err(mongo* conn) {\n    return conn->lasterrcode;\n}\n\n\nMONGO_EXPORT const char*  mongo_get_server_err_string(mongo* conn) {\n    return conn->lasterrstr;\n}\n\nMONGO_EXPORT void __mongo_set_error( mongo *conn, mongo_error_t err, const char *str,\n                                     int errcode ) {\n    size_t errstr_size, str_size;\n\n    conn->err = err;\n    conn->errcode = errcode;\n\n    if( str ) {\n        str_size = strlen( str ) + 1;\n        errstr_size = str_size > MONGO_ERR_LEN ? MONGO_ERR_LEN : str_size;\n        memcpy( conn->errstr, str, errstr_size );\n        conn->errstr[errstr_size-1] = '\\0';\n    }\n}\n\nMONGO_EXPORT void mongo_clear_errors( mongo *conn ) {\n    conn->err = 0;\n    conn->errcode = 0;\n    conn->lasterrcode = 0;\n    memset( conn->errstr, 0, MONGO_ERR_LEN );\n    memset( conn->lasterrstr, 0, MONGO_ERR_LEN );\n}\n\n/* Note: this function returns a char* which must be freed. */\nstatic char *mongo_ns_to_cmd_db( const char *ns ) {\n    char *current = NULL;\n    char *cmd_db_name = NULL;\n    int len = 0;\n\n    for( current = (char *)ns; *current != '.'; current++ ) {\n        len++;\n    }\n\n    cmd_db_name = (char *)bson_malloc( len + 6 );\n    strncpy( cmd_db_name, ns, len );\n    strncpy( cmd_db_name + len, \".$cmd\", 6 );\n\n    return cmd_db_name;\n}\n\nMONGO_EXPORT int mongo_validate_ns( mongo *conn, const char *ns ) {\n    char *last = NULL;\n    char *current = NULL;\n    const char *db_name = ns;\n    char *collection_name = NULL;\n    char errmsg[64];\n    int ns_len = 0;\n\n    /* If the first character is a '.', fail. */\n    if( *ns == '.' ) {\n        __mongo_set_error( conn, MONGO_NS_INVALID, \"ns cannot start with a '.'.\", 0 );\n        return MONGO_ERROR;\n    }\n\n    /* Find the division between database and collection names. */\n    for( current = (char *)ns; *current != '\\0'; current++ ) {\n        if( *current == '.' ) {\n            current++;\n            break;\n        }\n    }\n\n    /* Fail if the collection part starts with a dot. */\n    if( *current == '.' ) {\n        __mongo_set_error( conn, MONGO_NS_INVALID, \"ns cannot start with a '.'.\", 0 );\n        return MONGO_ERROR;\n    }\n\n    /* Fail if collection length is 0.\n     * or the ns doesn't contain a '.'. */\n    if( *current == '\\0' ) {\n        __mongo_set_error( conn, MONGO_NS_INVALID, \"Collection name missing.\", 0 );\n        return MONGO_ERROR;\n    }\n\n\n    /* Point to the beginning of the collection name. */\n    collection_name = current;\n\n    /* Ensure that the database name is greater than one char.*/\n    if( collection_name - 1 == db_name ) {\n        __mongo_set_error( conn, MONGO_NS_INVALID, \"Database name missing.\", 0 );\n        return MONGO_ERROR;\n    }\n\n    /* Go back and validate the database name. */\n    for( current = (char *)db_name; *current != '.'; current++ ) {\n        switch( *current ) {\n        case ' ':\n        case '$':\n        case '/':\n        case '\\\\':\n            __mongo_set_error( conn, MONGO_NS_INVALID,\n                               \"Database name may not contain ' ', '$', '/', or '\\\\'\", 0 );\n            return MONGO_ERROR;\n        default:\n            break;\n        }\n\n        ns_len++;\n    }\n\n    /* Add one to the length for the '.' character. */\n    ns_len++;\n\n    /* Now validate the collection name. */\n    for( current = collection_name; *current != '\\0'; current++ ) {\n\n        /* Cannot have two consecutive dots. */\n        if( last && *last == '.' && *current == '.' ) {\n            __mongo_set_error( conn, MONGO_NS_INVALID,\n                               \"Collection may not contain two consecutive '.'\", 0 );\n            return MONGO_ERROR;\n        }\n\n        /* Cannot contain a '$' */\n        if( *current == '$' ) {\n            __mongo_set_error( conn, MONGO_NS_INVALID,\n                               \"Collection may not contain '$'\", 0 );\n            return MONGO_ERROR;\n        }\n\n        last = current;\n        ns_len++;\n    }\n\n    if( ns_len > 128 ) {\n        bson_sprintf( errmsg, \"Namespace too long; has %d but must <= 128.\",\n                      ns_len );\n        __mongo_set_error( conn, MONGO_NS_INVALID, errmsg, 0 );\n        return MONGO_ERROR;\n    }\n\n    /* Cannot end with a '.' */\n    if( *(current - 1) == '.' ) {\n        __mongo_set_error( conn, MONGO_NS_INVALID,\n                           \"Collection may not end with '.'\", 0 );\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\nstatic void mongo_set_last_error( mongo *conn, bson_iterator *it, bson *obj ) {\n    int result_len = bson_iterator_string_len( it );\n    const char *result_string = bson_iterator_string( it );\n    int len = result_len < MONGO_ERR_LEN ? result_len : MONGO_ERR_LEN;\n    memcpy( conn->lasterrstr, result_string, len );\n\n    if( bson_find( it, obj, \"code\" ) != BSON_NULL )\n        conn->lasterrcode = bson_iterator_int( it );\n}\n\nstatic const int ZERO = 0;\nstatic const int ONE = 1;\nstatic mongo_message *mongo_message_create( size_t len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n\n    if ( !id )\n        id = rand();\n\n    /* native endian (converted on send) */\n    mm->head.len = ( int )len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n\n    return mm;\n}\n\n/* Always calls bson_free(mm) */\nstatic int mongo_message_send( mongo *conn, mongo_message *mm ) {\n    mongo_header head; /* little endian */\n    int res;\n    bson_little_endian32( &head.len, &mm->head.len );\n    bson_little_endian32( &head.id, &mm->head.id );\n    bson_little_endian32( &head.responseTo, &mm->head.responseTo );\n    bson_little_endian32( &head.op, &mm->head.op );\n\n    res = mongo_env_write_socket( conn, &head, sizeof( head ) );\n    if( res != MONGO_OK ) {\n        bson_free( mm );\n        return res;\n    }\n\n    res = mongo_env_write_socket( conn, &mm->data, mm->head.len - sizeof( head ) );\n    if( res != MONGO_OK ) {\n        bson_free( mm );\n        return res;\n    }\n\n    bson_free( mm );\n    return MONGO_OK;\n}\n\nstatic int mongo_read_response( mongo *conn, mongo_reply **reply ) {\n    mongo_header head; /* header from network */\n    mongo_reply_fields fields; /* header from network */\n    mongo_reply *out;  /* native endian */\n    unsigned int len;\n    int res;\n\n    mongo_env_read_socket( conn, &head, sizeof( head ) );\n    mongo_env_read_socket( conn, &fields, sizeof( fields ) );\n\n    bson_little_endian32( &len, &head.len );\n\n    if ( len < sizeof( head )+sizeof( fields ) || len > 64*1024*1024 )\n        return MONGO_READ_SIZE_ERROR;  /* most likely corruption */\n\n    out = ( mongo_reply * )bson_malloc( len );\n\n    out->head.len = len;\n    bson_little_endian32( &out->head.id, &head.id );\n    bson_little_endian32( &out->head.responseTo, &head.responseTo );\n    bson_little_endian32( &out->head.op, &head.op );\n\n    bson_little_endian32( &out->fields.flag, &fields.flag );\n    bson_little_endian64( &out->fields.cursorID, &fields.cursorID );\n    bson_little_endian32( &out->fields.start, &fields.start );\n    bson_little_endian32( &out->fields.num, &fields.num );\n\n    res = mongo_env_read_socket( conn, &out->objs, len-sizeof( head )-sizeof( fields ) );\n    if( res != MONGO_OK ) {\n        bson_free( out );\n        return res;\n    }\n\n    *reply = out;\n\n    return MONGO_OK;\n}\n\n\nstatic char *mongo_data_append( char *start , const void *data , size_t len ) {\n    memcpy( start , data , len );\n    return start + len;\n}\n\nstatic char *mongo_data_append32( char *start , const void *data ) {\n    bson_little_endian32( start , data );\n    return start + 4;\n}\n\nstatic char *mongo_data_append64( char *start , const void *data ) {\n    bson_little_endian64( start , data );\n    return start + 8;\n}\n\n/* Connection API */\n\nstatic int mongo_check_is_master( mongo *conn ) {\n    bson out;\n    bson_iterator it;\n    bson_bool_t ismaster = 0;\n    int max_bson_size = MONGO_DEFAULT_MAX_BSON_SIZE;\n\n    out.data = NULL;\n\n    if ( mongo_simple_int_command( conn, \"admin\", \"ismaster\", 1, &out ) == MONGO_OK ) {\n        if( bson_find( &it, &out, \"ismaster\" ) )\n            ismaster = bson_iterator_bool( &it );\n        if( bson_find( &it, &out, \"maxBsonObjectSize\" ) ) {\n            max_bson_size = bson_iterator_int( &it );\n        }\n        conn->max_bson_size = max_bson_size;\n    }\n    else {\n        return MONGO_ERROR;\n    }\n\n    bson_destroy( &out );\n\n    if( ismaster )\n        return MONGO_OK;\n    else {\n        conn->err = MONGO_CONN_NOT_MASTER;\n        return MONGO_ERROR;\n    }\n}\n\nMONGO_EXPORT void mongo_init_sockets( void ) {\n    mongo_env_sock_init();\n}\n\n/* WC1 is completely static */\nstatic char WC1_data[] = {23,0,0,0,16,103,101,116,108,97,115,116,101,114,114,111,114,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0};\nstatic bson WC1_cmd = {\n    WC1_data, WC1_data, 128, 1, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 0, 0, \"\"\n};\nstatic mongo_write_concern WC1 = { 1, 0, 0, 0, 0, &WC1_cmd }; /* w = 1 */\n\nMONGO_EXPORT void mongo_init( mongo *conn ) {\n    memset( conn, 0, sizeof( mongo ) );\n    conn->max_bson_size = MONGO_DEFAULT_MAX_BSON_SIZE;\n    mongo_set_write_concern( conn, &WC1 );\n}\n\nMONGO_EXPORT int mongo_client( mongo *conn , const char *host, int port ) {\n    mongo_init( conn );\n\n    conn->primary = bson_malloc( sizeof( mongo_host_port ) );\n    strncpy( conn->primary->host, host, strlen( host ) + 1 );\n    conn->primary->port = port;\n    conn->primary->next = NULL;\n\n    if( mongo_env_socket_connect( conn, host, port ) != MONGO_OK )\n        return MONGO_ERROR;\n\n    if( mongo_check_is_master( conn ) != MONGO_OK )\n        return MONGO_ERROR;\n    else\n        return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_connect( mongo *conn , const char *host, int port ) {\n    int ret;\n    bson_errprintf(\"WARNING: mongo_connect() is deprecated, please use mongo_client()\\n\");\n    ret = mongo_client( conn, host, port );\n    mongo_set_write_concern( conn, 0 );\n    return ret;\n}\n\nMONGO_EXPORT void mongo_replica_set_init( mongo *conn, const char *name ) {\n    mongo_init( conn );\n\n    conn->replica_set = bson_malloc( sizeof( mongo_replica_set ) );\n    conn->replica_set->primary_connected = 0;\n    conn->replica_set->seeds = NULL;\n    conn->replica_set->hosts = NULL;\n    conn->replica_set->name = ( char * )bson_malloc( strlen( name ) + 1 );\n    memcpy( conn->replica_set->name, name, strlen( name ) + 1  );\n\n    conn->primary = bson_malloc( sizeof( mongo_host_port ) );\n    conn->primary->host[0] = '\\0';\n    conn->primary->next = NULL;\n}\n\nMONGO_EXPORT void mongo_replset_init( mongo *conn, const char *name ) {\n    bson_errprintf(\"WARNING: mongo_replset_init() is deprecated, please use mongo_replica_set_init()\\n\");\n    mongo_replica_set_init( conn, name );\n}\n\nstatic void mongo_replica_set_add_node( mongo_host_port **list, const char *host, int port ) {\n    mongo_host_port *host_port = bson_malloc( sizeof( mongo_host_port ) );\n    host_port->port = port;\n    host_port->next = NULL;\n    strncpy( host_port->host, host, strlen( host ) + 1 );\n\n    if( *list == NULL )\n        *list = host_port;\n    else {\n        mongo_host_port *p = *list;\n        while( p->next != NULL )\n            p = p->next;\n        p->next = host_port;\n    }\n}\n\nstatic void mongo_replica_set_free_list( mongo_host_port **list ) {\n    mongo_host_port *node = *list;\n    mongo_host_port *prev;\n\n    while( node != NULL ) {\n        prev = node;\n        node = node->next;\n        bson_free( prev );\n    }\n\n    *list = NULL;\n}\n\nMONGO_EXPORT void mongo_replica_set_add_seed( mongo *conn, const char *host, int port ) {\n    mongo_replica_set_add_node( &conn->replica_set->seeds, host, port );\n}\n\nMONGO_EXPORT void mongo_replset_add_seed( mongo *conn, const char *host, int port ) {\n    bson_errprintf(\"WARNING: mongo_replset_add_seed() is deprecated, please use mongo_replica_set_add_seed()\\n\");\n    mongo_replica_set_add_node( &conn->replica_set->seeds, host, port );\n}\n\nvoid mongo_parse_host( const char *host_string, mongo_host_port *host_port ) {\n    int len, idx, split;\n    len = split = idx = 0;\n\n    /* Split the host_port string at the ':' */\n    while( 1 ) {\n        if( *( host_string + len ) == '\\0' )\n            break;\n        if( *( host_string + len ) == ':' )\n            split = len;\n\n        len++;\n    }\n\n    /* If 'split' is set, we know the that port exists;\n     * Otherwise, we set the default port. */\n    idx = split ? split : len;\n    memcpy( host_port->host, host_string, idx );\n    memcpy( host_port->host + idx, \"\\0\", 1 );\n    if( split )\n        host_port->port = atoi( host_string + idx + 1 );\n    else\n        host_port->port = MONGO_DEFAULT_PORT;\n}\n\nstatic void mongo_replica_set_check_seed( mongo *conn ) {\n    bson out;\n    bson hosts;\n    const char *data;\n    bson_iterator it;\n    bson_iterator it_sub;\n    const char *host_string;\n    mongo_host_port *host_port = NULL;\n\n    out.data = NULL;\n\n    hosts.data = NULL;\n\n    if( mongo_simple_int_command( conn, \"admin\", \"ismaster\", 1, &out ) == MONGO_OK ) {\n\n        if( bson_find( &it, &out, \"hosts\" ) ) {\n            data = bson_iterator_value( &it );\n            bson_iterator_from_buffer( &it_sub, data );\n\n            /* Iterate over host list, adding each host to the\n             * connection's host list. */\n            while( bson_iterator_next( &it_sub ) ) {\n                host_string = bson_iterator_string( &it_sub );\n\n                host_port = bson_malloc( sizeof( mongo_host_port ) );\n\n                if( host_port ) {\n                    mongo_parse_host( host_string, host_port );\n                    mongo_replica_set_add_node( &conn->replica_set->hosts,\n                                                host_port->host, host_port->port );\n\n                    bson_free( host_port );\n                    host_port = NULL;\n                }\n            }\n        }\n    }\n\n    bson_destroy( &out );\n    bson_destroy( &hosts );\n    mongo_env_close_socket( conn->sock );\n    conn->sock = 0;\n    conn->connected = 0;\n\n}\n\n/* Find out whether the current connected node is master, and\n * verify that the node's replica set name matched the provided name\n */\nstatic int mongo_replica_set_check_host( mongo *conn ) {\n\n    bson out;\n    bson_iterator it;\n    bson_bool_t ismaster = 0;\n    const char *set_name;\n    int max_bson_size = MONGO_DEFAULT_MAX_BSON_SIZE;\n\n    out.data = NULL;\n\n    if ( mongo_simple_int_command( conn, \"admin\", \"ismaster\", 1, &out ) == MONGO_OK ) {\n        if( bson_find( &it, &out, \"ismaster\" ) )\n            ismaster = bson_iterator_bool( &it );\n\n        if( bson_find( &it, &out, \"maxBsonObjectSize\" ) )\n            max_bson_size = bson_iterator_int( &it );\n        conn->max_bson_size = max_bson_size;\n\n        if( bson_find( &it, &out, \"setName\" ) ) {\n            set_name = bson_iterator_string( &it );\n            if( strcmp( set_name, conn->replica_set->name ) != 0 ) {\n                bson_destroy( &out );\n                conn->err = MONGO_CONN_BAD_SET_NAME;\n                return MONGO_ERROR;\n            }\n        }\n    }\n\n    bson_destroy( &out );\n\n    if( ismaster ) {\n        conn->replica_set->primary_connected = 1;\n    }\n    else {\n        mongo_env_close_socket( conn->sock );\n    }\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_replica_set_client( mongo *conn ) {\n\n    int res = 0;\n    mongo_host_port *node;\n\n    conn->sock = 0;\n    conn->connected = 0;\n\n    /* First iterate over the seed nodes to get the canonical list of hosts\n     * from the replica set. Break out once we have a host list.\n     */\n    node = conn->replica_set->seeds;\n    while( node != NULL ) {\n        res = mongo_env_socket_connect( conn, ( const char * )&node->host, node->port );\n        if( res == MONGO_OK ) {\n            mongo_replica_set_check_seed( conn );\n            if( conn->replica_set->hosts )\n                break;\n        }\n        node = node->next;\n    }\n\n    /* Iterate over the host list, checking for the primary node. */\n    if( !conn->replica_set->hosts ) {\n        conn->err = MONGO_CONN_NO_PRIMARY;\n        return MONGO_ERROR;\n    }\n    else {\n        node = conn->replica_set->hosts;\n\n        while( node != NULL ) {\n            res = mongo_env_socket_connect( conn, ( const char * )&node->host, node->port );\n\n            if( res == MONGO_OK ) {\n                if( mongo_replica_set_check_host( conn ) != MONGO_OK )\n                    return MONGO_ERROR;\n\n                /* Primary found, so return. */\n                else if( conn->replica_set->primary_connected ) {\n                    conn->primary = bson_malloc( sizeof( mongo_host_port ) );\n                    strncpy( conn->primary->host, node->host, strlen( node->host ) + 1 );\n                    conn->primary->port = node->port;\n                    return MONGO_OK;\n                }\n\n                /* No primary, so close the connection. */\n                else {\n                    mongo_env_close_socket( conn->sock );\n                    conn->sock = 0;\n                    conn->connected = 0;\n                }\n            }\n\n            node = node->next;\n        }\n    }\n\n\n    conn->err = MONGO_CONN_NO_PRIMARY;\n    return MONGO_ERROR;\n}\n\nMONGO_EXPORT int mongo_replset_connect( mongo *conn ) {\n    int ret;\n    bson_errprintf(\"WARNING: mongo_replset_connect() is deprecated, please use mongo_replica_set_client()\\n\");\n    ret = mongo_replica_set_client( conn );\n    mongo_set_write_concern( conn, 0 );\n    return ret;\n}\n\nMONGO_EXPORT int mongo_set_op_timeout( mongo *conn, int millis ) {\n    conn->op_timeout_ms = millis;\n    if( conn->sock && conn->connected )\n        mongo_env_set_socket_op_timeout( conn, millis );\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_reconnect( mongo *conn ) {\n    int res;\n    mongo_disconnect( conn );\n\n    if( conn->replica_set ) {\n        conn->replica_set->primary_connected = 0;\n        mongo_replica_set_free_list( &conn->replica_set->hosts );\n        conn->replica_set->hosts = NULL;\n        res = mongo_replica_set_client( conn );\n        return res;\n    }\n    else\n        return mongo_env_socket_connect( conn, conn->primary->host, conn->primary->port );\n}\n\nMONGO_EXPORT int mongo_check_connection( mongo *conn ) {\n    if( ! conn->connected )\n        return MONGO_ERROR;\n\n    if( mongo_simple_int_command( conn, \"admin\", \"ping\", 1, NULL ) == MONGO_OK )\n        return MONGO_OK;\n    else\n        return MONGO_ERROR;\n}\n\nMONGO_EXPORT void mongo_disconnect( mongo *conn ) {\n    if( ! conn->connected )\n        return;\n\n    if( conn->replica_set ) {\n        conn->replica_set->primary_connected = 0;\n        mongo_replica_set_free_list( &conn->replica_set->hosts );\n        conn->replica_set->hosts = NULL;\n    }\n\n    mongo_env_close_socket( conn->sock );\n\n    conn->sock = 0;\n    conn->connected = 0;\n}\n\nMONGO_EXPORT void mongo_destroy( mongo *conn ) {\n    mongo_disconnect( conn );\n\n    if( conn->replica_set ) {\n        mongo_replica_set_free_list( &conn->replica_set->seeds );\n        mongo_replica_set_free_list( &conn->replica_set->hosts );\n        bson_free( conn->replica_set->name );\n        bson_free( conn->replica_set );\n        conn->replica_set = NULL;\n    }\n\n    bson_free( conn->primary );\n\n    mongo_clear_errors( conn );\n}\n\n/* Determine whether this BSON object is valid for the given operation.  */\nstatic int mongo_bson_valid( mongo *conn, const bson *bson, int write ) {\n    int size;\n\n    if( ! bson->finished ) {\n        conn->err = MONGO_BSON_NOT_FINISHED;\n        return MONGO_ERROR;\n    }\n\n    size = bson_size( bson );\n    if( size > conn->max_bson_size ) {\n        conn->err = MONGO_BSON_TOO_LARGE;\n        return MONGO_ERROR;\n    }\n\n    if( bson->err & BSON_NOT_UTF8 ) {\n        conn->err = MONGO_BSON_INVALID;\n        return MONGO_ERROR;\n    }\n\n    if( write ) {\n        if( ( bson->err & BSON_FIELD_HAS_DOT ) ||\n                ( bson->err & BSON_FIELD_INIT_DOLLAR ) ) {\n\n            conn->err = MONGO_BSON_INVALID;\n            return MONGO_ERROR;\n\n        }\n    }\n\n    conn->err = 0;\n\n    return MONGO_OK;\n}\n\n/* Determine whether this BSON object is valid for the given operation.  */\nstatic int mongo_cursor_bson_valid( mongo_cursor *cursor, const bson *bson ) {\n    if( ! bson->finished ) {\n        cursor->err = MONGO_CURSOR_BSON_ERROR;\n        cursor->conn->err = MONGO_BSON_NOT_FINISHED;\n        return MONGO_ERROR;\n    }\n\n    if( bson->err & BSON_NOT_UTF8 ) {\n        cursor->err = MONGO_CURSOR_BSON_ERROR;\n        cursor->conn->err = MONGO_BSON_INVALID;\n        return MONGO_ERROR;\n    }\n\n    return MONGO_OK;\n}\n\nstatic int mongo_check_last_error( mongo *conn, const char *ns,\n                                   mongo_write_concern *write_concern ) {\n    int ret = MONGO_OK;\n    bson response = {NULL, 0};\n    bson fields;\n    bson_iterator it;\n    int res = 0;\n    char *cmd_ns = mongo_ns_to_cmd_db( ns );\n\n    res = mongo_find_one( conn, cmd_ns, write_concern->cmd, bson_empty( &fields ), &response );\n    bson_free( cmd_ns );\n\n    if( res != MONGO_OK )\n        ret = MONGO_ERROR;\n    else {\n        if( ( bson_find( &it, &response, \"$err\" ) == BSON_STRING ) ||\n                ( bson_find( &it, &response, \"err\" ) == BSON_STRING ) ) {\n\n            __mongo_set_error( conn, MONGO_WRITE_ERROR,\n                               \"See conn->lasterrstr for details.\", 0 );\n            mongo_set_last_error( conn, &it, &response );\n            ret = MONGO_ERROR;\n        }\n        bson_destroy( &response );\n    }\n    return ret;\n}\n\nstatic int mongo_choose_write_concern( mongo *conn,\n                                       mongo_write_concern *custom_write_concern,\n                                       mongo_write_concern **write_concern ) {\n\n    if( custom_write_concern ) {\n        *write_concern = custom_write_concern;\n    }\n    else if( conn->write_concern ) {\n        *write_concern = conn->write_concern;\n    }\n    if ( *write_concern && (*write_concern)->w < 1 ) {\n        *write_concern = 0; /* do not generate getLastError request */\n    }\n    if( *write_concern && !((*write_concern)->cmd) ) {\n        __mongo_set_error( conn, MONGO_WRITE_CONCERN_INVALID,\n                           \"Must call mongo_write_concern_finish() before using *write_concern.\", 0 );\n        return MONGO_ERROR;\n    }\n    else\n        return MONGO_OK;\n}\n\n\n/*********************************************************************\nCRUD API\n**********************************************************************/\n\nMONGO_EXPORT int mongo_insert( mongo *conn, const char *ns,\n                               const bson *bson, mongo_write_concern *custom_write_concern ) {\n\n    char *data;\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n\n    if( mongo_validate_ns( conn, ns ) != MONGO_OK )\n        return MONGO_ERROR;\n\n    if( mongo_bson_valid( conn, bson, 1 ) != MONGO_OK ) {\n        return MONGO_ERROR;\n    }\n\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n\n    mm = mongo_message_create( 16 /* header */\n                               + 4 /* ZERO */\n                               + strlen( ns )\n                               + 1 + bson_size( bson )\n                               , 0, 0, MONGO_OP_INSERT );\n\n    data = &mm->data;\n    data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n    mongo_data_append( data, bson->data, bson_size( bson ) );\n\n\n    /* TODO: refactor so that we can send the insert message\n       and the getlasterror messages together. */\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}\n\nMONGO_EXPORT int mongo_insert_batch( mongo *conn, const char *ns,\n                                     const bson **bsons, int count, mongo_write_concern *custom_write_concern,\n                                     int flags ) {\n\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n    int i;\n    char *data;\n    size_t overhead =  16 + 4 + strlen( ns ) + 1;\n    size_t size = overhead;\n\n    if( mongo_validate_ns( conn, ns ) != MONGO_OK )\n        return MONGO_ERROR;\n\n    for( i=0; i<count; i++ ) {\n        size += bson_size( bsons[i] );\n        if( mongo_bson_valid( conn, bsons[i], 1 ) != MONGO_OK )\n            return MONGO_ERROR;\n    }\n\n    if( ( size - overhead ) > conn->max_bson_size ) {\n        conn->err = MONGO_BSON_TOO_LARGE;\n        return MONGO_ERROR;\n    }\n\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n\n    mm = mongo_message_create( size , 0 , 0 , MONGO_OP_INSERT );\n\n    data = &mm->data;\n    if( flags & MONGO_CONTINUE_ON_ERROR )\n        data = mongo_data_append32( data, &ONE );\n    else\n        data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n\n    for( i=0; i<count; i++ ) {\n        data = mongo_data_append( data, bsons[i]->data, bson_size( bsons[i] ) );\n    }\n\n    /* TODO: refactor so that we can send the insert message\n     * and the getlasterror messages together. */\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}\n\nMONGO_EXPORT int mongo_update( mongo *conn, const char *ns, const bson *cond,\n                               const bson *op, int flags, mongo_write_concern *custom_write_concern ) {\n\n    char *data;\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n\n    /* Make sure that the op BSON is valid UTF-8.\n     * TODO: decide whether to check cond as well.\n     * */\n    if( mongo_bson_valid( conn, ( bson * )op, 0 ) != MONGO_OK ) {\n        return MONGO_ERROR;\n    }\n\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n\n    mm = mongo_message_create( 16 /* header */\n                               + 4  /* ZERO */\n                               + strlen( ns ) + 1\n                               + 4  /* flags */\n                               + bson_size( cond )\n                               + bson_size( op )\n                               , 0 , 0 , MONGO_OP_UPDATE );\n\n    data = &mm->data;\n    data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n    data = mongo_data_append32( data, &flags );\n    data = mongo_data_append( data, cond->data, bson_size( cond ) );\n    mongo_data_append( data, op->data, bson_size( op ) );\n\n    /* TODO: refactor so that we can send the insert message\n     * and the getlasterror messages together. */\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}\n\nMONGO_EXPORT int mongo_remove( mongo *conn, const char *ns, const bson *cond,\n                               mongo_write_concern *custom_write_concern ) {\n\n    char *data;\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n\n    /* Make sure that the BSON is valid UTF-8.\n     * TODO: decide whether to check cond as well.\n     * */\n    if( mongo_bson_valid( conn, ( bson * )cond, 0 ) != MONGO_OK ) {\n        return MONGO_ERROR;\n    }\n\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n\n    mm = mongo_message_create( 16  /* header */\n                               + 4  /* ZERO */\n                               + strlen( ns ) + 1\n                               + 4  /* ZERO */\n                               + bson_size( cond )\n                               , 0 , 0 , MONGO_OP_DELETE );\n\n    data = &mm->data;\n    data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n    data = mongo_data_append32( data, &ZERO );\n    mongo_data_append( data, cond->data, bson_size( cond ) );\n\n    /* TODO: refactor so that we can send the insert message\n     * and the getlasterror messages together. */\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}\n\n\n/*********************************************************************\nWrite Concern API\n**********************************************************************/\n\nMONGO_EXPORT void mongo_write_concern_init( mongo_write_concern *write_concern ) {\n    memset( write_concern, 0, sizeof( mongo_write_concern ) );\n}\n\nMONGO_EXPORT int mongo_write_concern_finish( mongo_write_concern *write_concern ) {\n    bson *command;\n\n    /* Destory any existing serialized write concern object and reuse it. */\n    if( write_concern->cmd ) {\n        bson_destroy( write_concern->cmd );\n        command = write_concern->cmd;\n    }\n    else\n        command = (bson *)bson_malloc( sizeof( bson ) );\n\n    if( !command ) {\n        return MONGO_ERROR;\n    }\n\n    bson_init( command );\n\n    bson_append_int( command, \"getlasterror\", 1 );\n\n    if( write_concern->mode ) {\n        bson_append_string( command, \"w\", write_concern->mode );\n    }\n\n    else if( write_concern->w && write_concern->w > 1 ) {\n        bson_append_int( command, \"w\", write_concern->w );\n    }\n\n    if( write_concern->wtimeout ) {\n        bson_append_int( command, \"wtimeout\", write_concern->wtimeout );\n    }\n\n    if( write_concern->j ) {\n        bson_append_int( command, \"j\", write_concern->j );\n    }\n\n    if( write_concern->fsync ) {\n        bson_append_int( command, \"fsync\", write_concern->fsync );\n    }\n\n    bson_finish( command );\n\n    /* write_concern now owns the BSON command object.\n     * This is freed in mongo_write_concern_destroy(). */\n    write_concern->cmd = command;\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT void mongo_write_concern_destroy( mongo_write_concern *write_concern ) {\n    if( !write_concern )\n        return;\n\n    if( write_concern->cmd )\n        bson_destroy( write_concern->cmd );\n\n    bson_free( write_concern->cmd );\n}\n\nMONGO_EXPORT void mongo_set_write_concern( mongo *conn,\n        mongo_write_concern *write_concern ) {\n\n    conn->write_concern = write_concern;\n}\n\n/**\n * Free the write_concern object (specifically, the BSON object that it holds).\n */\nMONGO_EXPORT void mongo_write_concern_destroy( mongo_write_concern *write_concern );\n\n\nstatic int mongo_cursor_op_query( mongo_cursor *cursor ) {\n    int res;\n    bson empty;\n    char *data;\n    mongo_message *mm;\n    bson temp;\n    bson_iterator it;\n\n    /* Clear any errors. */\n    mongo_clear_errors( cursor->conn );\n\n    /* Set up default values for query and fields, if necessary. */\n    if( ! cursor->query )\n        cursor->query = bson_empty( &empty );\n    else if( mongo_cursor_bson_valid( cursor, cursor->query ) != MONGO_OK )\n        return MONGO_ERROR;\n\n    if( ! cursor->fields )\n        cursor->fields = bson_empty( &empty );\n    else if( mongo_cursor_bson_valid( cursor, cursor->fields ) != MONGO_OK )\n        return MONGO_ERROR;\n\n    mm = mongo_message_create( 16 + /* header */\n                               4 + /*  options */\n                               strlen( cursor->ns ) + 1 + /* ns */\n                               4 + 4 + /* skip,return */\n                               bson_size( cursor->query ) +\n                               bson_size( cursor->fields ) ,\n                               0 , 0 , MONGO_OP_QUERY );\n\n    data = &mm->data;\n    data = mongo_data_append32( data , &cursor->options );\n    data = mongo_data_append( data , cursor->ns , strlen( cursor->ns ) + 1 );\n    data = mongo_data_append32( data , &cursor->skip );\n    data = mongo_data_append32( data , &cursor->limit );\n    data = mongo_data_append( data , cursor->query->data , bson_size( cursor->query ) );\n    if ( cursor->fields )\n        data = mongo_data_append( data , cursor->fields->data , bson_size( cursor->fields ) );\n\n    bson_fatal_msg( ( data == ( ( char * )mm ) + mm->head.len ), \"query building fail!\" );\n\n    res = mongo_message_send( cursor->conn , mm );\n    if( res != MONGO_OK ) {\n        return MONGO_ERROR;\n    }\n\n    res = mongo_read_response( cursor->conn, ( mongo_reply ** )&( cursor->reply ) );\n    if( res != MONGO_OK ) {\n        return MONGO_ERROR;\n    }\n\n    if( cursor->reply->fields.num == 1 ) {\n        bson_init_data( &temp, &cursor->reply->objs );\n        if( bson_find( &it, &temp, \"$err\" ) ) {\n            mongo_set_last_error( cursor->conn, &it, &temp );\n            cursor->err = MONGO_CURSOR_QUERY_FAIL;\n            return MONGO_ERROR;\n        }\n    }\n\n    cursor->seen += cursor->reply->fields.num;\n    cursor->flags |= MONGO_CURSOR_QUERY_SENT;\n    return MONGO_OK;\n}\n\nstatic int mongo_cursor_get_more( mongo_cursor *cursor ) {\n    int res;\n\n    if( cursor->limit > 0 && cursor->seen >= cursor->limit ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply ) {\n        cursor->err = MONGO_CURSOR_INVALID;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply->fields.cursorID ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else {\n        char *data;\n        size_t sl = strlen( cursor->ns )+1;\n        int limit = 0;\n        mongo_message *mm;\n\n        if( cursor->limit > 0 )\n            limit = cursor->limit - cursor->seen;\n\n        mm = mongo_message_create( 16 /*header*/\n                                   +4 /*ZERO*/\n                                   +sl\n                                   +4 /*numToReturn*/\n                                   +8 /*cursorID*/\n                                   , 0, 0, MONGO_OP_GET_MORE );\n        data = &mm->data;\n        data = mongo_data_append32( data, &ZERO );\n        data = mongo_data_append( data, cursor->ns, sl );\n        data = mongo_data_append32( data, &limit );\n        mongo_data_append64( data, &cursor->reply->fields.cursorID );\n\n        bson_free( cursor->reply );\n        res = mongo_message_send( cursor->conn, mm );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n\n        res = mongo_read_response( cursor->conn, &( cursor->reply ) );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        cursor->current.data = NULL;\n        cursor->seen += cursor->reply->fields.num;\n\n        return MONGO_OK;\n    }\n}\n\nMONGO_EXPORT mongo_cursor *mongo_find( mongo *conn, const char *ns, const bson *query,\n                                       const bson *fields, int limit, int skip, int options ) {\n\n    mongo_cursor *cursor = ( mongo_cursor * )bson_malloc( sizeof( mongo_cursor ) );\n    mongo_cursor_init( cursor, conn, ns );\n    cursor->flags |= MONGO_CURSOR_MUST_FREE;\n\n    mongo_cursor_set_query( cursor, query );\n    mongo_cursor_set_fields( cursor, fields );\n    mongo_cursor_set_limit( cursor, limit );\n    mongo_cursor_set_skip( cursor, skip );\n    mongo_cursor_set_options( cursor, options );\n\n    if( mongo_cursor_op_query( cursor ) == MONGO_OK )\n        return cursor;\n    else {\n        mongo_cursor_destroy( cursor );\n        return NULL;\n    }\n}\n\nMONGO_EXPORT int mongo_find_one( mongo *conn, const char *ns, const bson *query,\n                                 const bson *fields, bson *out ) {\n\n    mongo_cursor cursor[1];\n    mongo_cursor_init( cursor, conn, ns );\n    mongo_cursor_set_query( cursor, query );\n    mongo_cursor_set_fields( cursor, fields );\n    mongo_cursor_set_limit( cursor, 1 );\n\n    if ( mongo_cursor_next( cursor ) == MONGO_OK ) {\n        if( out ) {\n            bson_init_size( out, bson_size( (bson *)&cursor->current ) );\n            memcpy( out->data, cursor->current.data,\n                    bson_size( (bson *)&cursor->current ) );\n            out->finished = 1;\n        }\n        mongo_cursor_destroy( cursor );\n        return MONGO_OK;\n    }\n    else {\n        mongo_cursor_destroy( cursor );\n        return MONGO_ERROR;\n    }\n}\n\nMONGO_EXPORT void mongo_cursor_init( mongo_cursor *cursor, mongo *conn, const char *ns ) {\n    memset( cursor, 0, sizeof( mongo_cursor ) );\n    cursor->conn = conn;\n    cursor->ns = ( const char * )bson_malloc( strlen( ns ) + 1 );\n    strncpy( ( char * )cursor->ns, ns, strlen( ns ) + 1 );\n    cursor->current.data = NULL;\n}\n\nMONGO_EXPORT void mongo_cursor_set_query( mongo_cursor *cursor, const bson *query ) {\n    cursor->query = query;\n}\n\nMONGO_EXPORT void mongo_cursor_set_fields( mongo_cursor *cursor, const bson *fields ) {\n    cursor->fields = fields;\n}\n\nMONGO_EXPORT void mongo_cursor_set_skip( mongo_cursor *cursor, int skip ) {\n    cursor->skip = skip;\n}\n\nMONGO_EXPORT void mongo_cursor_set_limit( mongo_cursor *cursor, int limit ) {\n    cursor->limit = limit;\n}\n\nMONGO_EXPORT void mongo_cursor_set_options( mongo_cursor *cursor, int options ) {\n    cursor->options = options;\n}\n\nMONGO_EXPORT const char *mongo_cursor_data( mongo_cursor *cursor ) {\n    return cursor->current.data;\n}\n\nMONGO_EXPORT const bson *mongo_cursor_bson( mongo_cursor *cursor ) {\n    return (const bson *)&(cursor->current);\n}\n\nMONGO_EXPORT int mongo_cursor_next( mongo_cursor *cursor ) {\n    char *next_object;\n    char *message_end;\n\n    if( ! ( cursor->flags & MONGO_CURSOR_QUERY_SENT ) )\n        if( mongo_cursor_op_query( cursor ) != MONGO_OK )\n            return MONGO_ERROR;\n\n    if( !cursor->reply )\n        return MONGO_ERROR;\n\n    /* no data */\n    if ( cursor->reply->fields.num == 0 ) {\n\n        /* Special case for tailable cursors. */\n        if( cursor->reply->fields.cursorID ) {\n            if( ( mongo_cursor_get_more( cursor ) != MONGO_OK ) ||\n                    cursor->reply->fields.num == 0 ) {\n                return MONGO_ERROR;\n            }\n        }\n\n        else\n            return MONGO_ERROR;\n    }\n\n    /* first */\n    if ( cursor->current.data == NULL ) {\n        bson_init_finished_data( &cursor->current, &cursor->reply->objs );\n        return MONGO_OK;\n    }\n\n    next_object = cursor->current.data + bson_size( &cursor->current );\n    message_end = ( char * )cursor->reply + cursor->reply->head.len;\n\n    if ( next_object >= message_end ) {\n        if( mongo_cursor_get_more( cursor ) != MONGO_OK )\n            return MONGO_ERROR;\n\n        if ( cursor->reply->fields.num == 0 ) {\n            /* Special case for tailable cursors. */\n            if ( cursor->reply->fields.cursorID ) {\n                cursor->err = MONGO_CURSOR_PENDING;\n                return MONGO_ERROR;\n            }\n            else\n                return MONGO_ERROR;\n        }\n\n        bson_init_finished_data( &cursor->current, &cursor->reply->objs );\n    }\n    else {\n        bson_init_finished_data( &cursor->current, next_object );\n    }\n\n    return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_cursor_destroy( mongo_cursor *cursor ) {\n    int result = MONGO_OK;\n\n    if ( !cursor ) return result;\n\n    /* Kill cursor if live. */\n    if ( cursor->reply && cursor->reply->fields.cursorID ) {\n        mongo *conn = cursor->conn;\n        mongo_message *mm = mongo_message_create( 16 /*header*/\n                            +4 /*ZERO*/\n                            +4 /*numCursors*/\n                            +8 /*cursorID*/\n                            , 0, 0, MONGO_OP_KILL_CURSORS );\n        char *data = &mm->data;\n        data = mongo_data_append32( data, &ZERO );\n        data = mongo_data_append32( data, &ONE );\n        mongo_data_append64( data, &cursor->reply->fields.cursorID );\n\n        result = mongo_message_send( conn, mm );\n    }\n\n    bson_free( cursor->reply );\n    bson_free( ( void * )cursor->ns );\n\n    if( cursor->flags & MONGO_CURSOR_MUST_FREE )\n        bson_free( cursor );\n\n    return result;\n}\n\n/* MongoDB Helper Functions */\n\nMONGO_EXPORT int mongo_create_index( mongo *conn, const char *ns, const bson *key, int options, bson *out ) {\n    bson b;\n    bson_iterator it;\n    char name[255] = {'_'};\n    int i = 1;\n    char idxns[1024];\n\n    bson_iterator_init( &it, key );\n    while( i < 255 && bson_iterator_next( &it ) ) {\n        strncpy( name + i, bson_iterator_key( &it ), 255 - i );\n        i += strlen( bson_iterator_key( &it ) );\n    }\n    name[254] = '\\0';\n\n    bson_init( &b );\n    bson_append_bson( &b, \"key\", key );\n    bson_append_string( &b, \"ns\", ns );\n    bson_append_string( &b, \"name\", name );\n    if ( options & MONGO_INDEX_UNIQUE )\n        bson_append_bool( &b, \"unique\", 1 );\n    if ( options & MONGO_INDEX_DROP_DUPS )\n        bson_append_bool( &b, \"dropDups\", 1 );\n    if ( options & MONGO_INDEX_BACKGROUND )\n        bson_append_bool( &b, \"background\", 1 );\n    if ( options & MONGO_INDEX_SPARSE )\n        bson_append_bool( &b, \"sparse\", 1 );\n    bson_finish( &b );\n\n    strncpy( idxns, ns, 1024-16 );\n    strcpy( strchr( idxns, '.' ), \".system.indexes\" );\n    mongo_insert( conn, idxns, &b, NULL );\n    bson_destroy( &b );\n\n    *strchr( idxns, '.' ) = '\\0'; /* just db not ns */\n    return mongo_cmd_get_last_error( conn, idxns, out );\n}\n\nMONGO_EXPORT bson_bool_t mongo_create_simple_index( mongo *conn, const char *ns, const char *field, int options, bson *out ) {\n    bson b;\n    bson_bool_t success;\n\n    bson_init( &b );\n    bson_append_int( &b, field, 1 );\n    bson_finish( &b );\n\n    success = mongo_create_index( conn, ns, &b, options, out );\n    bson_destroy( &b );\n    return success;\n}\n\nMONGO_EXPORT int mongo_create_capped_collection( mongo *conn, const char *db,\n        const char *collection, int size, int max, bson *out ) {\n\n    bson b;\n    int result;\n\n    bson_init( &b );\n    bson_append_string( &b, \"create\", collection );\n    bson_append_bool( &b, \"capped\", 1 );\n    bson_append_int( &b, \"size\", size );\n    if( max > 0 )\n        bson_append_int( &b, \"max\", size );\n    bson_finish( &b );\n\n    result = mongo_run_command( conn, db, &b, out );\n\n    bson_destroy( &b );\n\n    return result;\n}\n\nMONGO_EXPORT double mongo_count( mongo *conn, const char *db, const char *ns, const bson *query ) {\n    bson cmd;\n    bson out = {NULL, 0};\n    double count = -1;\n\n    bson_init( &cmd );\n    bson_append_string( &cmd, \"count\", ns );\n    if ( query && bson_size( query ) > 5 ) /* not empty */\n        bson_append_bson( &cmd, \"query\", query );\n    bson_finish( &cmd );\n\n    if( mongo_run_command( conn, db, &cmd, &out ) == MONGO_OK ) {\n        bson_iterator it;\n        if( bson_find( &it, &out, \"n\" ) )\n            count = bson_iterator_double( &it );\n        bson_destroy( &cmd );\n        bson_destroy( &out );\n        return count;\n    }\n    else {\n        bson_destroy( &out );\n        bson_destroy( &cmd );\n        return MONGO_ERROR;\n    }\n}\n\nMONGO_EXPORT int mongo_run_command( mongo *conn, const char *db, const bson *command,\n                                    bson *out ) {\n    int ret = MONGO_OK;\n    bson response = {NULL, 0};\n    bson fields;\n    size_t sl = strlen( db );\n    char *ns = bson_malloc( sl + 5 + 1 ); /* \".$cmd\" + nul */\n    int res, success = 0;\n\n    strcpy( ns, db );\n    strcpy( ns+sl, \".$cmd\" );\n\n    res = mongo_find_one( conn, ns, command, bson_empty( &fields ), &response );\n    bson_free( ns );\n\n    if( res != MONGO_OK )\n        ret = MONGO_ERROR;\n    else {\n        bson_iterator it;\n        if( bson_find( &it, &response, \"ok\" ) )\n            success = bson_iterator_bool( &it );\n\n        if( !success ) {\n            conn->err = MONGO_COMMAND_FAILED;\n            bson_destroy( &response );\n            ret = MONGO_ERROR;\n        }\n        else {\n            if( out )\n                *out = response;\n            else\n                bson_destroy( &response );\n        }\n    }\n    return ret;\n}\n\nMONGO_EXPORT int mongo_simple_int_command( mongo *conn, const char *db,\n        const char *cmdstr, int arg, bson *realout ) {\n\n    bson out = {NULL, 0};\n    bson cmd;\n    int result;\n\n    bson_init( &cmd );\n    bson_append_int( &cmd, cmdstr, arg );\n    bson_finish( &cmd );\n\n    result = mongo_run_command( conn, db, &cmd, &out );\n\n    bson_destroy( &cmd );\n\n    if ( realout )\n        *realout = out;\n    else\n        bson_destroy( &out );\n\n    return result;\n}\n\nMONGO_EXPORT int mongo_simple_str_command( mongo *conn, const char *db,\n        const char *cmdstr, const char *arg, bson *realout ) {\n\n    bson out = {NULL, 0};\n    int result;\n\n    bson cmd;\n    bson_init( &cmd );\n    bson_append_string( &cmd, cmdstr, arg );\n    bson_finish( &cmd );\n\n    result = mongo_run_command( conn, db, &cmd, &out );\n\n    bson_destroy( &cmd );\n\n    if ( realout )\n        *realout = out;\n    else\n        bson_destroy( &out );\n\n    return result;\n}\n\nMONGO_EXPORT int mongo_cmd_drop_db( mongo *conn, const char *db ) {\n    return mongo_simple_int_command( conn, db, \"dropDatabase\", 1, NULL );\n}\n\nMONGO_EXPORT int mongo_cmd_drop_collection( mongo *conn, const char *db, const char *collection, bson *out ) {\n    return mongo_simple_str_command( conn, db, \"drop\", collection, out );\n}\n\nMONGO_EXPORT void mongo_cmd_reset_error( mongo *conn, const char *db ) {\n    mongo_simple_int_command( conn, db, \"reseterror\", 1, NULL );\n}\n\nstatic int mongo_cmd_get_error_helper( mongo *conn, const char *db,\n                                       bson *realout, const char *cmdtype ) {\n\n    bson out = {NULL,0};\n    bson_bool_t haserror = 0;\n\n    /* Reset last error codes. */\n    mongo_clear_errors( conn );\n\n    /* If there's an error, store its code and string in the connection object. */\n    if( mongo_simple_int_command( conn, db, cmdtype, 1, &out ) == MONGO_OK ) {\n        bson_iterator it;\n        haserror = ( bson_find( &it, &out, \"err\" ) != BSON_NULL );\n        if( haserror ) mongo_set_last_error( conn, &it, &out );\n    }\n\n    if( realout )\n        *realout = out; /* transfer of ownership */\n    else\n        bson_destroy( &out );\n\n    if( haserror )\n        return MONGO_ERROR;\n    else\n        return MONGO_OK;\n}\n\nMONGO_EXPORT int mongo_cmd_get_prev_error( mongo *conn, const char *db, bson *out ) {\n    return mongo_cmd_get_error_helper( conn, db, out, \"getpreverror\" );\n}\n\nMONGO_EXPORT int mongo_cmd_get_last_error( mongo *conn, const char *db, bson *out ) {\n    return mongo_cmd_get_error_helper( conn, db, out, \"getlasterror\" );\n}\n\nMONGO_EXPORT bson_bool_t mongo_cmd_ismaster( mongo *conn, bson *realout ) {\n    bson out = {NULL,0};\n    bson_bool_t ismaster = 0;\n\n    if ( mongo_simple_int_command( conn, \"admin\", \"ismaster\", 1, &out ) == MONGO_OK ) {\n        bson_iterator it;\n        bson_find( &it, &out, \"ismaster\" );\n        ismaster = bson_iterator_bool( &it );\n    }\n\n    if( realout )\n        *realout = out; /* transfer of ownership */\n    else\n        bson_destroy( &out );\n\n    return ismaster;\n}\n\nstatic void digest2hex( mongo_md5_byte_t digest[16], char hex_digest[33] ) {\n    static const char hex[16] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n    int i;\n    for ( i=0; i<16; i++ ) {\n        hex_digest[2*i]     = hex[( digest[i] & 0xf0 ) >> 4];\n        hex_digest[2*i + 1] = hex[ digest[i] & 0x0f      ];\n    }\n    hex_digest[32] = '\\0';\n}\n\nstatic void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, ( int )strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, ( int )strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}\n\nMONGO_EXPORT int mongo_cmd_add_user( mongo *conn, const char *db, const char *user, const char *pass ) {\n    bson user_obj;\n    bson pass_obj;\n    char hex_digest[33];\n    char *ns = bson_malloc( strlen( db ) + strlen( \".system.users\" ) + 1 );\n    int res;\n\n    strcpy( ns, db );\n    strcpy( ns+strlen( db ), \".system.users\" );\n\n    mongo_pass_digest( user, pass, hex_digest );\n\n    bson_init( &user_obj );\n    bson_append_string( &user_obj, \"user\", user );\n    bson_finish( &user_obj );\n\n    bson_init( &pass_obj );\n    bson_append_start_object( &pass_obj, \"$set\" );\n    bson_append_string( &pass_obj, \"pwd\", hex_digest );\n    bson_append_finish_object( &pass_obj );\n    bson_finish( &pass_obj );\n\n    res = mongo_update( conn, ns, &user_obj, &pass_obj, MONGO_UPDATE_UPSERT, NULL );\n\n    bson_free( ns );\n    bson_destroy( &user_obj );\n    bson_destroy( &pass_obj );\n\n    return res;\n}\n\nMONGO_EXPORT bson_bool_t mongo_cmd_authenticate( mongo *conn, const char *db, const char *user, const char *pass ) {\n    bson from_db;\n    bson cmd;\n    const char *nonce;\n    int result;\n\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n    char hex_digest[33];\n\n    if( mongo_simple_int_command( conn, db, \"getnonce\", 1, &from_db ) == MONGO_OK ) {\n        bson_iterator it;\n        bson_find( &it, &from_db, \"nonce\" );\n        nonce = bson_iterator_string( &it );\n    }\n    else {\n        return MONGO_ERROR;\n    }\n\n    mongo_pass_digest( user, pass, hex_digest );\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )nonce, ( int )strlen( nonce ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, ( int )strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )hex_digest, 32 );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n\n    bson_init( &cmd );\n    bson_append_int( &cmd, \"authenticate\", 1 );\n    bson_append_string( &cmd, \"user\", user );\n    bson_append_string( &cmd, \"nonce\", nonce );\n    bson_append_string( &cmd, \"key\", hex_digest );\n    bson_finish( &cmd );\n\n    bson_destroy( &from_db );\n\n    result = mongo_run_command( conn, db, &cmd, NULL );\n\n    bson_destroy( &cmd );\n\n    return result;\n}\n"], "filenames": ["src/bcon.c", "src/bson.c", "src/bson.h", "src/encoding.c", "src/encoding.h", "src/env.c", "src/env.h", "src/gridfs.c", "src/gridfs.h", "src/mongo.c"], "buggy_code_start_loc": [175, 109, 138, 105, 38, 41, 28, 231, 51, 115], "buggy_code_end_loc": [176, 961, 994, 165, 52, 477, 30, 665, 297, 1739], "fixing_code_start_loc": [175, 109, 138, 105, 38, 41, 28, 231, 51, 115], "fixing_code_end_loc": [176, 966, 994, 165, 52, 477, 30, 665, 297, 1739], "type": "CWE-190", "message": "bson before 0.8 incorrectly uses int rather than size_t for many variables, parameters, and return values. In particular, the bson_ensure_space() parameter bytesNeeded could have an integer overflow via properly constructed bson input.", "other": {"cve": {"id": "CVE-2020-12135", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-24T01:15:11.430", "lastModified": "2020-08-12T17:15:11.600", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "bson before 0.8 incorrectly uses int rather than size_t for many variables, parameters, and return values. In particular, the bson_ensure_space() parameter bytesNeeded could have an integer overflow via properly constructed bson input."}, {"lang": "es", "value": "bson en versiones anteriores a la 0.8 usa incorrectamente int en lugar de size_t para muchas variables, par\u00e1metros y valores de retorno. En particular, el par\u00e1metro bson_ensure_space () bytesNeeded podr\u00eda tener un desbordamiento de enteros a trav\u00e9s de una entrada bson construida correctamente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:whoopsie_project:whoopsie:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.2.69", "matchCriteriaId": "31886E49-F328-4FE2-B04C-0D7EBC6082B8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mongodb:c_driver:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8", "matchCriteriaId": "33B88603-D79A-4501-B0A6-DA1F586C56D9"}]}]}], "references": [{"url": "https://bugs.launchpad.net/ubuntu/+source/whoopsie/+bug/1872560", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca#diff-f7d29a680148f52d6601f59ed787f577", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://launchpadlibrarian.net/474887364/bson-fix-overflow.patch", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4450-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca#diff-f7d29a680148f52d6601f59ed787f577"}}