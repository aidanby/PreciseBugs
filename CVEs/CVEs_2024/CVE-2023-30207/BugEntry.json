{"buggy_code": ["/*\n *  Copyright (C) 2005-2018 Team Kodi\n *  This file is part of Kodi - https://kodi.tv\n *\n *  SPDX-License-Identifier: GPL-2.0-or-later\n *  See LICENSES/README.md for more information.\n */\n\n#include \"VideoPlayerCodec.h\"\n\n#include \"ServiceBroker.h\"\n#include \"URL.h\"\n#include \"cores/AudioEngine/AEResampleFactory.h\"\n#include \"cores/AudioEngine/Interfaces/AE.h\"\n#include \"cores/AudioEngine/Utils/AEUtil.h\"\n#include \"cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h\"\n#include \"cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.h\"\n#include \"cores/VideoPlayer/DVDDemuxers/DVDFactoryDemuxer.h\"\n#include \"cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.h\"\n#include \"cores/VideoPlayer/DVDStreamInfo.h\"\n#include \"music/tags/TagLoaderTagLib.h\"\n#include \"utils/StringUtils.h\"\n#include \"utils/log.h\"\n\nVideoPlayerCodec::VideoPlayerCodec()\n{\n  m_CodecName = \"VideoPlayer\";\n  m_pDemuxer = NULL;\n  m_nAudioStream = -1;\n  m_nDecodedLen = 0;\n  m_bInited = false;\n  m_pResampler = NULL;\n  m_needConvert = false;\n  m_channels = 0;\n\n  m_processInfo.reset(CProcessInfo::CreateInstance());\n}\n\nVideoPlayerCodec::~VideoPlayerCodec()\n{\n  DeInit();\n}\n\nAEAudioFormat VideoPlayerCodec::GetFormat()\n{\n  AEAudioFormat format;\n  if (m_pAudioCodec)\n  {\n    format = m_pAudioCodec->GetFormat();\n  }\n  return format;\n}\n\nvoid VideoPlayerCodec::SetContentType(const std::string &strContent)\n{\n  m_strContentType = strContent;\n  StringUtils::ToLower(m_strContentType);\n}\n\nvoid  VideoPlayerCodec::SetPassthroughStreamType(CAEStreamInfo::DataType streamType)\n{\n  m_srcFormat.m_streamInfo.m_type = streamType;\n}\n\nbool VideoPlayerCodec::Init(const CFileItem &file, unsigned int filecache)\n{\n  // take precaution if Init()ialized earlier\n  if (m_bInited)\n  {\n    // keep things as is if Init() was done with known strFile\n    if (m_strFileName == file.GetDynPath())\n      return true;\n\n    // got differing filename, so cleanup before starting over\n    DeInit();\n  }\n\n  m_nDecodedLen = 0;\n\n  CFileItem fileitem(file);\n  fileitem.SetMimeType(m_strContentType);\n  fileitem.SetMimeTypeForInternetFile();\n  m_pInputStream = CDVDFactoryInputStream::CreateInputStream(NULL, fileitem);\n  if (!m_pInputStream)\n  {\n    CLog::Log(LOGERROR, \"{}: Error creating input stream for {}\", __FUNCTION__, file.GetDynPath());\n    return false;\n  }\n\n  //! @todo\n  //! convey CFileItem::ContentLookup() into Open()\n  if (!m_pInputStream->Open())\n  {\n    CLog::Log(LOGERROR, \"{}: Error opening file {}\", __FUNCTION__, file.GetDynPath());\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  m_pDemuxer = NULL;\n\n  try\n  {\n    m_pDemuxer = CDVDFactoryDemuxer::CreateDemuxer(m_pInputStream);\n    if (!m_pDemuxer)\n    {\n      if (m_pInputStream.use_count() > 1)\n        throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n      m_pInputStream.reset();\n      CLog::Log(LOGERROR, \"{}: Error creating demuxer\", __FUNCTION__);\n      return false;\n    }\n  }\n  catch(...)\n  {\n    CLog::Log(LOGERROR, \"{}: Exception thrown when opening demuxer\", __FUNCTION__);\n    if (m_pDemuxer)\n    {\n      delete m_pDemuxer;\n      m_pDemuxer = NULL;\n    }\n    return false;\n  }\n\n  CDemuxStream* pStream = NULL;\n  m_nAudioStream = -1;\n  int64_t demuxerId = -1;\n  for (auto stream : m_pDemuxer->GetStreams())\n  {\n    if (stream && stream->type == STREAM_AUDIO)\n    {\n      m_nAudioStream = stream->uniqueId;\n      demuxerId = stream->demuxerId;\n      pStream = stream;\n      break;\n    }\n  }\n\n  if (m_nAudioStream == -1)\n  {\n    CLog::Log(LOGERROR, \"{}: Could not find audio stream\", __FUNCTION__);\n    delete m_pDemuxer;\n    m_pDemuxer = NULL;\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  CDVDStreamInfo hint(*pStream, true);\n\n  CAEStreamInfo::DataType ptStreamTye =\n      GetPassthroughStreamType(hint.codec, hint.samplerate, hint.profile);\n  m_pAudioCodec = CDVDFactoryCodec::CreateAudioCodec(hint, *m_processInfo, true, true, ptStreamTye);\n  if (!m_pAudioCodec)\n  {\n    CLog::Log(LOGERROR, \"{}: Could not create audio codec\", __FUNCTION__);\n    delete m_pDemuxer;\n    m_pDemuxer = NULL;\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  //  Extract ReplayGain info\n  // tagLoaderTagLib.Load will try to determine tag type by file extension, so set fallback by contentType\n  std::string strFallbackFileExtension = \"\";\n  if (m_strContentType == \"audio/aacp\" ||\n      m_strContentType == \"audio/aac\")\n    strFallbackFileExtension = \"m4a\";\n  else if (m_strContentType == \"audio/x-ms-wma\")\n    strFallbackFileExtension = \"wma\";\n  else if (m_strContentType == \"audio/x-ape\" ||\n           m_strContentType == \"audio/ape\")\n    strFallbackFileExtension = \"ape\";\n  CTagLoaderTagLib tagLoaderTagLib;\n  tagLoaderTagLib.Load(file.GetDynPath(), m_tag, strFallbackFileExtension);\n\n  // we have to decode initial data in order to get channels/samplerate\n  // for sanity - we read no more than 10 packets\n  int nErrors = 0;\n  for (int nPacket=0; nPacket < 10 && (m_channels == 0 || m_format.m_sampleRate == 0); nPacket++)\n  {\n    uint8_t dummy[256];\n    size_t nSize = 256;\n    if (ReadPCM(dummy, nSize, &nSize) == READ_ERROR)\n      ++nErrors;\n\n    m_srcFormat = m_pAudioCodec->GetFormat();\n    m_format = m_srcFormat;\n    m_channels = m_srcFormat.m_channelLayout.Count();\n    m_bitsPerSample = CAEUtil::DataFormatToBits(m_srcFormat.m_dataFormat);\n    m_bitsPerCodedSample = static_cast<CDemuxStreamAudio*>(pStream)->iBitsPerSample;\n  }\n  if (nErrors >= 10)\n  {\n    CLog::Log(LOGDEBUG, \"{}: Could not decode data\", __FUNCTION__);\n    return false;\n  }\n\n  // test if seeking is supported\n  m_bCanSeek = false;\n  if (m_pInputStream->Seek(0, SEEK_POSSIBLE))\n  {\n    if (Seek(1))\n    {\n      // rewind stream to beginning\n      Seek(0);\n      m_bCanSeek = true;\n    }\n    else\n    {\n      m_pInputStream->Seek(0, SEEK_SET);\n      if (!m_pDemuxer->Reset())\n        return false;\n    }\n  }\n\n  if (m_channels == 0) // no data - just guess and hope for the best\n  {\n    m_srcFormat.m_channelLayout = CAEChannelInfo(AE_CH_LAYOUT_2_0);\n    m_channels = m_srcFormat.m_channelLayout.Count();\n  }\n\n  if (m_srcFormat.m_sampleRate == 0)\n    m_srcFormat.m_sampleRate = 44100;\n\n  m_TotalTime = m_pDemuxer->GetStreamLength();\n  m_bitRate = m_pAudioCodec->GetBitRate();\n  if (!m_bitRate && m_TotalTime)\n  {\n    m_bitRate = (int)(((m_pInputStream->GetLength()*1000) / m_TotalTime) * 8);\n  }\n  m_CodecName = m_pDemuxer->GetStreamCodecName(demuxerId, m_nAudioStream);\n\n  m_needConvert = false;\n  if (NeedConvert(m_srcFormat.m_dataFormat))\n  {\n    m_needConvert = true;\n    m_pResampler = ActiveAE::CAEResampleFactory::Create();\n\n    SampleConfig dstConfig, srcConfig;\n    dstConfig.channel_layout = CAEUtil::GetAVChannelLayout(m_srcFormat.m_channelLayout);\n    dstConfig.channels = m_channels;\n    dstConfig.sample_rate = m_srcFormat.m_sampleRate;\n    dstConfig.fmt = CAEUtil::GetAVSampleFormat(AE_FMT_FLOAT);\n    dstConfig.bits_per_sample = CAEUtil::DataFormatToUsedBits(AE_FMT_FLOAT);\n    dstConfig.dither_bits = CAEUtil::DataFormatToDitherBits(AE_FMT_FLOAT);\n\n    srcConfig.channel_layout = CAEUtil::GetAVChannelLayout(m_srcFormat.m_channelLayout);\n    srcConfig.channels = m_channels;\n    srcConfig.sample_rate = m_srcFormat.m_sampleRate;\n    srcConfig.fmt = CAEUtil::GetAVSampleFormat(m_srcFormat.m_dataFormat);\n    srcConfig.bits_per_sample = CAEUtil::DataFormatToUsedBits(m_srcFormat.m_dataFormat);\n    srcConfig.dither_bits = CAEUtil::DataFormatToDitherBits(m_srcFormat.m_dataFormat);\n\n    m_pResampler->Init(dstConfig, srcConfig,\n                       false,\n                       false,\n                       M_SQRT1_2,\n                       NULL,\n                       AE_QUALITY_UNKNOWN,\n                       false);\n\n    m_planes = AE_IS_PLANAR(m_srcFormat.m_dataFormat) ? m_channels : 1;\n    m_format = m_srcFormat;\n    m_format.m_dataFormat = AE_FMT_FLOAT;\n    m_bitsPerSample = CAEUtil::DataFormatToBits(m_format.m_dataFormat);\n  }\n\n  m_strFileName = file.GetDynPath();\n  m_bInited = true;\n\n  return true;\n}\n\nvoid VideoPlayerCodec::DeInit()\n{\n  if (m_pDemuxer != NULL)\n  {\n    delete m_pDemuxer;\n    m_pDemuxer = NULL;\n  }\n\n  if (m_pInputStream.use_count() > 1)\n    throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n  m_pInputStream.reset();\n\n  m_pAudioCodec.reset();\n\n  delete m_pResampler;\n  m_pResampler = NULL;\n\n  // cleanup format information\n  m_TotalTime = 0;\n  m_bitsPerSample = 0;\n  m_bitRate = 0;\n  m_channels = 0;\n  m_format.m_dataFormat = AE_FMT_INVALID;\n\n  m_nDecodedLen = 0;\n\n  m_strFileName = \"\";\n  m_bInited = false;\n}\n\nbool VideoPlayerCodec::Seek(int64_t iSeekTime)\n{\n  // default to announce backwards seek if !m_pPacket to not make FFmpeg\n  // skip mpeg audio frames at playback start\n  bool seekback = true;\n\n  bool ret = m_pDemuxer->SeekTime((int)iSeekTime, seekback);\n  m_pAudioCodec->Reset();\n\n  m_nDecodedLen = 0;\n\n  return ret;\n}\n\nint VideoPlayerCodec::ReadPCM(uint8_t* pBuffer, size_t size, size_t* actualsize)\n{\n  if (m_nDecodedLen > 0)\n  {\n    size_t nLen = (size < m_nDecodedLen) ? size : m_nDecodedLen;\n    *actualsize = nLen;\n    if (m_needConvert)\n    {\n      int samples = *actualsize / (m_bitsPerSample>>3);\n      int frames = samples / m_channels;\n      m_pResampler->Resample(&pBuffer, frames, m_audioFrame.data, frames, 1.0);\n      for (int i=0; i<m_planes; i++)\n      {\n        m_audioFrame.data[i] += frames*m_srcFormat.m_frameSize/m_planes;\n      }\n    }\n    else\n    {\n      memcpy(pBuffer, m_audioFrame.data[0], *actualsize);\n      m_audioFrame.data[0] += (*actualsize);\n    }\n    m_nDecodedLen -= nLen;\n    return READ_SUCCESS;\n  }\n\n  m_nDecodedLen = 0;\n  m_pAudioCodec->GetData(m_audioFrame);\n  int bytes = m_audioFrame.nb_frames * m_audioFrame.framesize;\n\n  if (!bytes)\n  {\n    DemuxPacket* pPacket = nullptr;\n    do\n    {\n      if (pPacket)\n        CDVDDemuxUtils::FreeDemuxPacket(pPacket);\n      pPacket = m_pDemuxer->Read();\n    } while (pPacket && pPacket->iStreamId != m_nAudioStream);\n\n    if (!pPacket)\n    {\n      return READ_EOF;\n    }\n\n    pPacket->pts = DVD_NOPTS_VALUE;\n    pPacket->dts = DVD_NOPTS_VALUE;\n\n    int ret = m_pAudioCodec->AddData(*pPacket);\n    CDVDDemuxUtils::FreeDemuxPacket(pPacket);\n    if (ret < 0)\n    {\n      return READ_ERROR;\n    }\n\n    m_pAudioCodec->GetData(m_audioFrame);\n    bytes = m_audioFrame.nb_frames * m_audioFrame.framesize;\n  }\n\n  m_nDecodedLen = bytes;\n  // scale decoded bytes to destination format\n  if (m_needConvert)\n    m_nDecodedLen *= (m_bitsPerSample>>3) / (m_srcFormat.m_frameSize / m_channels);\n\n  *actualsize = (m_nDecodedLen <= size) ? m_nDecodedLen : size;\n  if (*actualsize > 0)\n  {\n    if (m_needConvert)\n    {\n      int samples = *actualsize / (m_bitsPerSample>>3);\n      int frames = samples / m_channels;\n      m_pResampler->Resample(&pBuffer, frames, m_audioFrame.data, frames, 1.0);\n      for (int i=0; i<m_planes; i++)\n      {\n        m_audioFrame.data[i] += frames*m_srcFormat.m_frameSize/m_planes;\n      }\n    }\n    else\n    {\n      memcpy(pBuffer, m_audioFrame.data[0], *actualsize);\n      m_audioFrame.data[0] += *actualsize;\n    }\n    m_nDecodedLen -= *actualsize;\n  }\n\n  return READ_SUCCESS;\n}\n\nint VideoPlayerCodec::ReadRaw(uint8_t **pBuffer, int *bufferSize)\n{\n  DemuxPacket* pPacket;\n\n  m_nDecodedLen = 0;\n  DVDAudioFrame audioframe;\n\n  m_pAudioCodec->GetData(audioframe);\n  if (audioframe.nb_frames)\n  {\n    return READ_SUCCESS;\n  }\n\n  do\n  {\n    pPacket = m_pDemuxer->Read();\n  } while (pPacket && pPacket->iStreamId != m_nAudioStream);\n\n  if (!pPacket)\n  {\n    return READ_EOF;\n  }\n  pPacket->pts = DVD_NOPTS_VALUE;\n  pPacket->dts = DVD_NOPTS_VALUE;\n  int ret = m_pAudioCodec->AddData(*pPacket);\n  CDVDDemuxUtils::FreeDemuxPacket(pPacket);\n  if (ret < 0)\n  {\n    return READ_ERROR;\n  }\n\n  m_pAudioCodec->GetData(audioframe);\n  if (audioframe.nb_frames)\n  {\n    *bufferSize = audioframe.nb_frames;\n    *pBuffer = audioframe.data[0];\n  }\n  else\n  {\n    *bufferSize = 0;\n  }\n\n  return READ_SUCCESS;\n}\n\nbool VideoPlayerCodec::CanInit()\n{\n  return true;\n}\n\nbool VideoPlayerCodec::CanSeek()\n{\n  return m_bCanSeek;\n}\n\nbool VideoPlayerCodec::NeedConvert(AEDataFormat fmt)\n{\n  if (fmt == AE_FMT_RAW)\n    return false;\n\n  switch(fmt)\n  {\n    case AE_FMT_U8:\n    case AE_FMT_S16NE:\n    case AE_FMT_S32NE:\n    case AE_FMT_FLOAT:\n    case AE_FMT_DOUBLE:\n      return false;\n    default:\n      return true;\n  }\n}\n\nCAEStreamInfo::DataType VideoPlayerCodec::GetPassthroughStreamType(AVCodecID codecId,\n                                                                   int samplerate,\n                                                                   int profile)\n{\n  AEAudioFormat format;\n  format.m_dataFormat = AE_FMT_RAW;\n  format.m_sampleRate = samplerate;\n  format.m_streamInfo.m_type = CAEStreamInfo::DataType::STREAM_TYPE_NULL;\n  switch (codecId)\n  {\n    case AV_CODEC_ID_AC3:\n      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_AC3;\n      format.m_streamInfo.m_sampleRate = samplerate;\n      break;\n\n    case AV_CODEC_ID_EAC3:\n      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_EAC3;\n      format.m_streamInfo.m_sampleRate = samplerate;\n      break;\n\n    case AV_CODEC_ID_DTS:\n      if (profile == FF_PROFILE_DTS_HD_HRA)\n        format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_DTSHD;\n      else if (profile == FF_PROFILE_DTS_HD_MA)\n        format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_DTSHD_MA;\n      else\n        format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_DTSHD_CORE;\n      format.m_streamInfo.m_sampleRate = samplerate;\n      break;\n\n    case AV_CODEC_ID_TRUEHD:\n      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_TRUEHD;\n      format.m_streamInfo.m_sampleRate = samplerate;\n      break;\n\n    default:\n      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_NULL;\n  }\n\n  bool supports = CServiceBroker::GetActiveAE()->SupportsRaw(format);\n\n  if (!supports && codecId == AV_CODEC_ID_DTS &&\n      format.m_streamInfo.m_type != CAEStreamInfo::STREAM_TYPE_DTSHD_CORE &&\n      CServiceBroker::GetActiveAE()->UsesDtsCoreFallback())\n  {\n    format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_DTSHD_CORE;\n    supports = CServiceBroker::GetActiveAE()->SupportsRaw(format);\n  }\n\n  if (supports)\n    return format.m_streamInfo.m_type;\n  else\n    return CAEStreamInfo::DataType::STREAM_TYPE_NULL;\n}\n"], "fixing_code": ["/*\n *  Copyright (C) 2005-2018 Team Kodi\n *  This file is part of Kodi - https://kodi.tv\n *\n *  SPDX-License-Identifier: GPL-2.0-or-later\n *  See LICENSES/README.md for more information.\n */\n\n#include \"VideoPlayerCodec.h\"\n\n#include \"ServiceBroker.h\"\n#include \"URL.h\"\n#include \"cores/AudioEngine/AEResampleFactory.h\"\n#include \"cores/AudioEngine/Interfaces/AE.h\"\n#include \"cores/AudioEngine/Utils/AEUtil.h\"\n#include \"cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h\"\n#include \"cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.h\"\n#include \"cores/VideoPlayer/DVDDemuxers/DVDFactoryDemuxer.h\"\n#include \"cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.h\"\n#include \"cores/VideoPlayer/DVDStreamInfo.h\"\n#include \"music/tags/TagLoaderTagLib.h\"\n#include \"utils/StringUtils.h\"\n#include \"utils/log.h\"\n\nVideoPlayerCodec::VideoPlayerCodec()\n{\n  m_CodecName = \"VideoPlayer\";\n  m_pDemuxer = NULL;\n  m_nAudioStream = -1;\n  m_nDecodedLen = 0;\n  m_bInited = false;\n  m_pResampler = NULL;\n  m_needConvert = false;\n  m_channels = 0;\n\n  m_processInfo.reset(CProcessInfo::CreateInstance());\n}\n\nVideoPlayerCodec::~VideoPlayerCodec()\n{\n  DeInit();\n}\n\nAEAudioFormat VideoPlayerCodec::GetFormat()\n{\n  AEAudioFormat format;\n  if (m_pAudioCodec)\n  {\n    format = m_pAudioCodec->GetFormat();\n  }\n  return format;\n}\n\nvoid VideoPlayerCodec::SetContentType(const std::string &strContent)\n{\n  m_strContentType = strContent;\n  StringUtils::ToLower(m_strContentType);\n}\n\nvoid  VideoPlayerCodec::SetPassthroughStreamType(CAEStreamInfo::DataType streamType)\n{\n  m_srcFormat.m_streamInfo.m_type = streamType;\n}\n\nbool VideoPlayerCodec::Init(const CFileItem &file, unsigned int filecache)\n{\n  // take precaution if Init()ialized earlier\n  if (m_bInited)\n  {\n    // keep things as is if Init() was done with known strFile\n    if (m_strFileName == file.GetDynPath())\n      return true;\n\n    // got differing filename, so cleanup before starting over\n    DeInit();\n  }\n\n  m_nDecodedLen = 0;\n\n  CFileItem fileitem(file);\n  fileitem.SetMimeType(m_strContentType);\n  fileitem.SetMimeTypeForInternetFile();\n  m_pInputStream = CDVDFactoryInputStream::CreateInputStream(NULL, fileitem);\n  if (!m_pInputStream)\n  {\n    CLog::Log(LOGERROR, \"{}: Error creating input stream for {}\", __FUNCTION__, file.GetDynPath());\n    return false;\n  }\n\n  //! @todo\n  //! convey CFileItem::ContentLookup() into Open()\n  if (!m_pInputStream->Open())\n  {\n    CLog::Log(LOGERROR, \"{}: Error opening file {}\", __FUNCTION__, file.GetDynPath());\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  m_pDemuxer = NULL;\n\n  try\n  {\n    m_pDemuxer = CDVDFactoryDemuxer::CreateDemuxer(m_pInputStream);\n    if (!m_pDemuxer)\n    {\n      if (m_pInputStream.use_count() > 1)\n        throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n      m_pInputStream.reset();\n      CLog::Log(LOGERROR, \"{}: Error creating demuxer\", __FUNCTION__);\n      return false;\n    }\n  }\n  catch(...)\n  {\n    CLog::Log(LOGERROR, \"{}: Exception thrown when opening demuxer\", __FUNCTION__);\n    if (m_pDemuxer)\n    {\n      delete m_pDemuxer;\n      m_pDemuxer = NULL;\n    }\n    return false;\n  }\n\n  CDemuxStream* pStream = NULL;\n  m_nAudioStream = -1;\n  int64_t demuxerId = -1;\n  for (auto stream : m_pDemuxer->GetStreams())\n  {\n    if (stream && stream->type == STREAM_AUDIO)\n    {\n      m_nAudioStream = stream->uniqueId;\n      demuxerId = stream->demuxerId;\n      pStream = stream;\n      break;\n    }\n  }\n\n  if (m_nAudioStream == -1)\n  {\n    CLog::Log(LOGERROR, \"{}: Could not find audio stream\", __FUNCTION__);\n    delete m_pDemuxer;\n    m_pDemuxer = NULL;\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  CDVDStreamInfo hint(*pStream, true);\n\n  CAEStreamInfo::DataType ptStreamTye =\n      GetPassthroughStreamType(hint.codec, hint.samplerate, hint.profile);\n  m_pAudioCodec = CDVDFactoryCodec::CreateAudioCodec(hint, *m_processInfo, true, true, ptStreamTye);\n  if (!m_pAudioCodec)\n  {\n    CLog::Log(LOGERROR, \"{}: Could not create audio codec\", __FUNCTION__);\n    delete m_pDemuxer;\n    m_pDemuxer = NULL;\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  //  Extract ReplayGain info\n  // tagLoaderTagLib.Load will try to determine tag type by file extension, so set fallback by contentType\n  std::string strFallbackFileExtension = \"\";\n  if (m_strContentType == \"audio/aacp\" ||\n      m_strContentType == \"audio/aac\")\n    strFallbackFileExtension = \"m4a\";\n  else if (m_strContentType == \"audio/x-ms-wma\")\n    strFallbackFileExtension = \"wma\";\n  else if (m_strContentType == \"audio/x-ape\" ||\n           m_strContentType == \"audio/ape\")\n    strFallbackFileExtension = \"ape\";\n  CTagLoaderTagLib tagLoaderTagLib;\n  tagLoaderTagLib.Load(file.GetDynPath(), m_tag, strFallbackFileExtension);\n\n  // we have to decode initial data in order to get channels/samplerate\n  // for sanity - we read no more than 10 packets\n  int nErrors = 0;\n  for (int nPacket = 0;\n       nPacket < 10 && (m_channels == 0 || m_format.m_sampleRate == 0 || m_format.m_frameSize == 0);\n       nPacket++)\n  {\n    uint8_t dummy[256];\n    size_t nSize = 256;\n    if (ReadPCM(dummy, nSize, &nSize) == READ_ERROR)\n      ++nErrors;\n\n    m_srcFormat = m_pAudioCodec->GetFormat();\n    m_format = m_srcFormat;\n    m_channels = m_srcFormat.m_channelLayout.Count();\n    m_bitsPerSample = CAEUtil::DataFormatToBits(m_srcFormat.m_dataFormat);\n    m_bitsPerCodedSample = static_cast<CDemuxStreamAudio*>(pStream)->iBitsPerSample;\n  }\n  if (nErrors >= 10)\n  {\n    CLog::Log(LOGDEBUG, \"{}: Could not decode data\", __FUNCTION__);\n    return false;\n  }\n\n  // test if seeking is supported\n  m_bCanSeek = false;\n  if (m_pInputStream->Seek(0, SEEK_POSSIBLE))\n  {\n    if (Seek(1))\n    {\n      // rewind stream to beginning\n      Seek(0);\n      m_bCanSeek = true;\n    }\n    else\n    {\n      m_pInputStream->Seek(0, SEEK_SET);\n      if (!m_pDemuxer->Reset())\n        return false;\n    }\n  }\n\n  if (m_channels == 0) // no data - just guess and hope for the best\n  {\n    m_srcFormat.m_channelLayout = CAEChannelInfo(AE_CH_LAYOUT_2_0);\n    m_channels = m_srcFormat.m_channelLayout.Count();\n  }\n\n  if (m_srcFormat.m_sampleRate == 0)\n    m_srcFormat.m_sampleRate = 44100;\n\n  m_TotalTime = m_pDemuxer->GetStreamLength();\n  m_bitRate = m_pAudioCodec->GetBitRate();\n  if (!m_bitRate && m_TotalTime)\n  {\n    m_bitRate = (int)(((m_pInputStream->GetLength()*1000) / m_TotalTime) * 8);\n  }\n  m_CodecName = m_pDemuxer->GetStreamCodecName(demuxerId, m_nAudioStream);\n\n  m_needConvert = false;\n  if (NeedConvert(m_srcFormat.m_dataFormat))\n  {\n    m_needConvert = true;\n    // if we don't know the framesize yet, we will fail when converting\n    if (m_srcFormat.m_frameSize == 0)\n      return false;\n\n    m_pResampler = ActiveAE::CAEResampleFactory::Create();\n\n    SampleConfig dstConfig, srcConfig;\n    dstConfig.channel_layout = CAEUtil::GetAVChannelLayout(m_srcFormat.m_channelLayout);\n    dstConfig.channels = m_channels;\n    dstConfig.sample_rate = m_srcFormat.m_sampleRate;\n    dstConfig.fmt = CAEUtil::GetAVSampleFormat(AE_FMT_FLOAT);\n    dstConfig.bits_per_sample = CAEUtil::DataFormatToUsedBits(AE_FMT_FLOAT);\n    dstConfig.dither_bits = CAEUtil::DataFormatToDitherBits(AE_FMT_FLOAT);\n\n    srcConfig.channel_layout = CAEUtil::GetAVChannelLayout(m_srcFormat.m_channelLayout);\n    srcConfig.channels = m_channels;\n    srcConfig.sample_rate = m_srcFormat.m_sampleRate;\n    srcConfig.fmt = CAEUtil::GetAVSampleFormat(m_srcFormat.m_dataFormat);\n    srcConfig.bits_per_sample = CAEUtil::DataFormatToUsedBits(m_srcFormat.m_dataFormat);\n    srcConfig.dither_bits = CAEUtil::DataFormatToDitherBits(m_srcFormat.m_dataFormat);\n\n    m_pResampler->Init(dstConfig, srcConfig,\n                       false,\n                       false,\n                       M_SQRT1_2,\n                       NULL,\n                       AE_QUALITY_UNKNOWN,\n                       false);\n\n    m_planes = AE_IS_PLANAR(m_srcFormat.m_dataFormat) ? m_channels : 1;\n    m_format = m_srcFormat;\n    m_format.m_dataFormat = AE_FMT_FLOAT;\n    m_bitsPerSample = CAEUtil::DataFormatToBits(m_format.m_dataFormat);\n  }\n\n  m_strFileName = file.GetDynPath();\n  m_bInited = true;\n\n  return true;\n}\n\nvoid VideoPlayerCodec::DeInit()\n{\n  if (m_pDemuxer != NULL)\n  {\n    delete m_pDemuxer;\n    m_pDemuxer = NULL;\n  }\n\n  if (m_pInputStream.use_count() > 1)\n    throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n  m_pInputStream.reset();\n\n  m_pAudioCodec.reset();\n\n  delete m_pResampler;\n  m_pResampler = NULL;\n\n  // cleanup format information\n  m_TotalTime = 0;\n  m_bitsPerSample = 0;\n  m_bitRate = 0;\n  m_channels = 0;\n  m_format.m_dataFormat = AE_FMT_INVALID;\n\n  m_nDecodedLen = 0;\n\n  m_strFileName = \"\";\n  m_bInited = false;\n}\n\nbool VideoPlayerCodec::Seek(int64_t iSeekTime)\n{\n  // default to announce backwards seek if !m_pPacket to not make FFmpeg\n  // skip mpeg audio frames at playback start\n  bool seekback = true;\n\n  bool ret = m_pDemuxer->SeekTime((int)iSeekTime, seekback);\n  m_pAudioCodec->Reset();\n\n  m_nDecodedLen = 0;\n\n  return ret;\n}\n\nint VideoPlayerCodec::ReadPCM(uint8_t* pBuffer, size_t size, size_t* actualsize)\n{\n  if (m_nDecodedLen > 0)\n  {\n    size_t nLen = (size < m_nDecodedLen) ? size : m_nDecodedLen;\n    *actualsize = nLen;\n    if (m_needConvert)\n    {\n      int samples = *actualsize / (m_bitsPerSample>>3);\n      int frames = samples / m_channels;\n      m_pResampler->Resample(&pBuffer, frames, m_audioFrame.data, frames, 1.0);\n      for (int i=0; i<m_planes; i++)\n      {\n        m_audioFrame.data[i] += frames*m_srcFormat.m_frameSize/m_planes;\n      }\n    }\n    else\n    {\n      memcpy(pBuffer, m_audioFrame.data[0], *actualsize);\n      m_audioFrame.data[0] += (*actualsize);\n    }\n    m_nDecodedLen -= nLen;\n    return READ_SUCCESS;\n  }\n\n  m_nDecodedLen = 0;\n  m_pAudioCodec->GetData(m_audioFrame);\n  int bytes = m_audioFrame.nb_frames * m_audioFrame.framesize;\n\n  if (!bytes)\n  {\n    DemuxPacket* pPacket = nullptr;\n    do\n    {\n      if (pPacket)\n        CDVDDemuxUtils::FreeDemuxPacket(pPacket);\n      pPacket = m_pDemuxer->Read();\n    } while (pPacket && pPacket->iStreamId != m_nAudioStream);\n\n    if (!pPacket)\n    {\n      return READ_EOF;\n    }\n\n    pPacket->pts = DVD_NOPTS_VALUE;\n    pPacket->dts = DVD_NOPTS_VALUE;\n\n    int ret = m_pAudioCodec->AddData(*pPacket);\n    CDVDDemuxUtils::FreeDemuxPacket(pPacket);\n    if (ret < 0)\n    {\n      return READ_ERROR;\n    }\n\n    m_pAudioCodec->GetData(m_audioFrame);\n    bytes = m_audioFrame.nb_frames * m_audioFrame.framesize;\n  }\n\n  m_nDecodedLen = bytes;\n  // scale decoded bytes to destination format\n  if (m_needConvert)\n    m_nDecodedLen *= (m_bitsPerSample>>3) / (m_srcFormat.m_frameSize / m_channels);\n\n  *actualsize = (m_nDecodedLen <= size) ? m_nDecodedLen : size;\n  if (*actualsize > 0)\n  {\n    if (m_needConvert)\n    {\n      int samples = *actualsize / (m_bitsPerSample>>3);\n      int frames = samples / m_channels;\n      m_pResampler->Resample(&pBuffer, frames, m_audioFrame.data, frames, 1.0);\n      for (int i=0; i<m_planes; i++)\n      {\n        m_audioFrame.data[i] += frames*m_srcFormat.m_frameSize/m_planes;\n      }\n    }\n    else\n    {\n      memcpy(pBuffer, m_audioFrame.data[0], *actualsize);\n      m_audioFrame.data[0] += *actualsize;\n    }\n    m_nDecodedLen -= *actualsize;\n  }\n\n  return READ_SUCCESS;\n}\n\nint VideoPlayerCodec::ReadRaw(uint8_t **pBuffer, int *bufferSize)\n{\n  DemuxPacket* pPacket;\n\n  m_nDecodedLen = 0;\n  DVDAudioFrame audioframe;\n\n  m_pAudioCodec->GetData(audioframe);\n  if (audioframe.nb_frames)\n  {\n    return READ_SUCCESS;\n  }\n\n  do\n  {\n    pPacket = m_pDemuxer->Read();\n  } while (pPacket && pPacket->iStreamId != m_nAudioStream);\n\n  if (!pPacket)\n  {\n    return READ_EOF;\n  }\n  pPacket->pts = DVD_NOPTS_VALUE;\n  pPacket->dts = DVD_NOPTS_VALUE;\n  int ret = m_pAudioCodec->AddData(*pPacket);\n  CDVDDemuxUtils::FreeDemuxPacket(pPacket);\n  if (ret < 0)\n  {\n    return READ_ERROR;\n  }\n\n  m_pAudioCodec->GetData(audioframe);\n  if (audioframe.nb_frames)\n  {\n    *bufferSize = audioframe.nb_frames;\n    *pBuffer = audioframe.data[0];\n  }\n  else\n  {\n    *bufferSize = 0;\n  }\n\n  return READ_SUCCESS;\n}\n\nbool VideoPlayerCodec::CanInit()\n{\n  return true;\n}\n\nbool VideoPlayerCodec::CanSeek()\n{\n  return m_bCanSeek;\n}\n\nbool VideoPlayerCodec::NeedConvert(AEDataFormat fmt)\n{\n  if (fmt == AE_FMT_RAW)\n    return false;\n\n  switch(fmt)\n  {\n    case AE_FMT_U8:\n    case AE_FMT_S16NE:\n    case AE_FMT_S32NE:\n    case AE_FMT_FLOAT:\n    case AE_FMT_DOUBLE:\n      return false;\n    default:\n      return true;\n  }\n}\n\nCAEStreamInfo::DataType VideoPlayerCodec::GetPassthroughStreamType(AVCodecID codecId,\n                                                                   int samplerate,\n                                                                   int profile)\n{\n  AEAudioFormat format;\n  format.m_dataFormat = AE_FMT_RAW;\n  format.m_sampleRate = samplerate;\n  format.m_streamInfo.m_type = CAEStreamInfo::DataType::STREAM_TYPE_NULL;\n  switch (codecId)\n  {\n    case AV_CODEC_ID_AC3:\n      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_AC3;\n      format.m_streamInfo.m_sampleRate = samplerate;\n      break;\n\n    case AV_CODEC_ID_EAC3:\n      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_EAC3;\n      format.m_streamInfo.m_sampleRate = samplerate;\n      break;\n\n    case AV_CODEC_ID_DTS:\n      if (profile == FF_PROFILE_DTS_HD_HRA)\n        format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_DTSHD;\n      else if (profile == FF_PROFILE_DTS_HD_MA)\n        format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_DTSHD_MA;\n      else\n        format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_DTSHD_CORE;\n      format.m_streamInfo.m_sampleRate = samplerate;\n      break;\n\n    case AV_CODEC_ID_TRUEHD:\n      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_TRUEHD;\n      format.m_streamInfo.m_sampleRate = samplerate;\n      break;\n\n    default:\n      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_NULL;\n  }\n\n  bool supports = CServiceBroker::GetActiveAE()->SupportsRaw(format);\n\n  if (!supports && codecId == AV_CODEC_ID_DTS &&\n      format.m_streamInfo.m_type != CAEStreamInfo::STREAM_TYPE_DTSHD_CORE &&\n      CServiceBroker::GetActiveAE()->UsesDtsCoreFallback())\n  {\n    format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_DTSHD_CORE;\n    supports = CServiceBroker::GetActiveAE()->SupportsRaw(format);\n  }\n\n  if (supports)\n    return format.m_streamInfo.m_type;\n  else\n    return CAEStreamInfo::DataType::STREAM_TYPE_NULL;\n}\n"], "filenames": ["xbmc/cores/paplayer/VideoPlayerCodec.cpp"], "buggy_code_start_loc": [184], "buggy_code_end_loc": [241], "fixing_code_start_loc": [184], "fixing_code_end_loc": [248], "type": "CWE-369", "message": "A divide by zero issue discovered in Kodi Home Theater Software 19.5 and earlier allows attackers to cause a denial of service via use of crafted mp3 file.", "other": {"cve": {"id": "CVE-2023-30207", "sourceIdentifier": "cve@mitre.org", "published": "2023-07-05T21:15:09.410", "lastModified": "2024-01-23T07:15:52.253", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A divide by zero issue discovered in Kodi Home Theater Software 19.5 and earlier allows attackers to cause a denial of service via use of crafted mp3 file."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kodi:kodi:*:*:*:*:*:*:*:*", "versionEndIncluding": "19.5", "matchCriteriaId": "AEE0AAF6-FF9A-4120-8A0A-27505D73EDB7"}]}]}], "references": [{"url": "https://github.com/xbmc/xbmc/commit/dbc00c500f4c4830049cc040a61c439c580eea73", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/xbmc/xbmc/issues/22378", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/xbmc/xbmc/pull/22391", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/01/msg00009.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/xbmc/xbmc/commit/dbc00c500f4c4830049cc040a61c439c580eea73"}}