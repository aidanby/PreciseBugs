{"buggy_code": ["import express from 'express'\nimport { MVideoCaption } from '@server/types/models'\nimport { HttpStatusCode } from '../../../../shared/models/http/http-error-codes'\nimport { moveAndProcessCaptionFile } from '../../../helpers/captions-utils'\nimport { createReqFiles } from '../../../helpers/express-utils'\nimport { logger } from '../../../helpers/logger'\nimport { getFormattedObjects } from '../../../helpers/utils'\nimport { CONFIG } from '../../../initializers/config'\nimport { MIMETYPES } from '../../../initializers/constants'\nimport { sequelizeTypescript } from '../../../initializers/database'\nimport { federateVideoIfNeeded } from '../../../lib/activitypub/videos'\nimport { asyncMiddleware, asyncRetryTransactionMiddleware, authenticate } from '../../../middlewares'\nimport { addVideoCaptionValidator, deleteVideoCaptionValidator, listVideoCaptionsValidator } from '../../../middlewares/validators'\nimport { VideoCaptionModel } from '../../../models/video/video-caption'\n\nconst reqVideoCaptionAdd = createReqFiles(\n  [ 'captionfile' ],\n  MIMETYPES.VIDEO_CAPTIONS.MIMETYPE_EXT,\n  {\n    captionfile: CONFIG.STORAGE.CAPTIONS_DIR\n  }\n)\n\nconst videoCaptionsRouter = express.Router()\n\nvideoCaptionsRouter.get('/:videoId/captions',\n  asyncMiddleware(listVideoCaptionsValidator),\n  asyncMiddleware(listVideoCaptions)\n)\nvideoCaptionsRouter.put('/:videoId/captions/:captionLanguage',\n  authenticate,\n  reqVideoCaptionAdd,\n  asyncMiddleware(addVideoCaptionValidator),\n  asyncRetryTransactionMiddleware(addVideoCaption)\n)\nvideoCaptionsRouter.delete('/:videoId/captions/:captionLanguage',\n  authenticate,\n  asyncMiddleware(deleteVideoCaptionValidator),\n  asyncRetryTransactionMiddleware(deleteVideoCaption)\n)\n\n// ---------------------------------------------------------------------------\n\nexport {\n  videoCaptionsRouter\n}\n\n// ---------------------------------------------------------------------------\n\nasync function listVideoCaptions (req: express.Request, res: express.Response) {\n  const data = await VideoCaptionModel.listVideoCaptions(res.locals.videoId.id)\n\n  return res.json(getFormattedObjects(data, data.length))\n}\n\nasync function addVideoCaption (req: express.Request, res: express.Response) {\n  const videoCaptionPhysicalFile = req.files['captionfile'][0]\n  const video = res.locals.videoAll\n\n  const captionLanguage = req.params.captionLanguage\n\n  const videoCaption = new VideoCaptionModel({\n    videoId: video.id,\n    filename: VideoCaptionModel.generateCaptionName(captionLanguage),\n    language: captionLanguage\n  }) as MVideoCaption\n\n  // Move physical file\n  await moveAndProcessCaptionFile(videoCaptionPhysicalFile, videoCaption)\n\n  await sequelizeTypescript.transaction(async t => {\n    await VideoCaptionModel.insertOrReplaceLanguage(videoCaption, t)\n\n    // Update video update\n    await federateVideoIfNeeded(video, false, t)\n  })\n\n  return res.status(HttpStatusCode.NO_CONTENT_204).end()\n}\n\nasync function deleteVideoCaption (req: express.Request, res: express.Response) {\n  const video = res.locals.videoAll\n  const videoCaption = res.locals.videoCaption\n\n  await sequelizeTypescript.transaction(async t => {\n    await videoCaption.destroy({ transaction: t })\n\n    // Send video update\n    await federateVideoIfNeeded(video, false, t)\n  })\n\n  logger.info('Video caption %s of video %s deleted.', videoCaption.language, video.uuid)\n\n  return res.type('json').status(HttpStatusCode.NO_CONTENT_204).end()\n}\n", "import express from 'express'\nimport toInt from 'validator/lib/toInt'\nimport { logger, loggerTagsFactory } from '@server/helpers/logger'\nimport { federateVideoIfNeeded } from '@server/lib/activitypub/videos'\nimport { VideoFileModel } from '@server/models/video/video-file'\nimport { HttpStatusCode, UserRight } from '@shared/models'\nimport {\n  asyncMiddleware,\n  authenticate,\n  ensureUserHasRight,\n  videoFileMetadataGetValidator,\n  videoFilesDeleteHLSValidator,\n  videoFilesDeleteWebTorrentValidator\n} from '../../../middlewares'\n\nconst lTags = loggerTagsFactory('api', 'video')\nconst filesRouter = express.Router()\n\nfilesRouter.get('/:id/metadata/:videoFileId',\n  asyncMiddleware(videoFileMetadataGetValidator),\n  asyncMiddleware(getVideoFileMetadata)\n)\n\nfilesRouter.delete('/:id/hls',\n  authenticate,\n  ensureUserHasRight(UserRight.MANAGE_VIDEO_FILES),\n  asyncMiddleware(videoFilesDeleteHLSValidator),\n  asyncMiddleware(removeHLSPlaylist)\n)\n\nfilesRouter.delete('/:id/webtorrent',\n  authenticate,\n  ensureUserHasRight(UserRight.MANAGE_VIDEO_FILES),\n  asyncMiddleware(videoFilesDeleteWebTorrentValidator),\n  asyncMiddleware(removeWebTorrentFiles)\n)\n\n// ---------------------------------------------------------------------------\n\nexport {\n  filesRouter\n}\n\n// ---------------------------------------------------------------------------\n\nasync function getVideoFileMetadata (req: express.Request, res: express.Response) {\n  const videoFile = await VideoFileModel.loadWithMetadata(toInt(req.params.videoFileId))\n\n  return res.json(videoFile.metadata)\n}\n\nasync function removeHLSPlaylist (req: express.Request, res: express.Response) {\n  const video = res.locals.videoAll\n\n  logger.info('Deleting HLS playlist of %s.', video.url, lTags(video.uuid))\n\n  const hls = video.getHLSPlaylist()\n  await video.removeStreamingPlaylistFiles(hls)\n  await hls.destroy()\n\n  video.VideoStreamingPlaylists = video.VideoStreamingPlaylists.filter(p => p.id !== hls.id)\n\n  await federateVideoIfNeeded(video, false, undefined)\n\n  return res.sendStatus(HttpStatusCode.NO_CONTENT_204)\n}\n\nasync function removeWebTorrentFiles (req: express.Request, res: express.Response) {\n  const video = res.locals.videoAll\n\n  logger.info('Deleting WebTorrent files of %s.', video.url, lTags(video.uuid))\n\n  for (const file of video.VideoFiles) {\n    await video.removeWebTorrentFileAndTorrent(file)\n    await file.destroy()\n  }\n\n  video.VideoFiles = []\n  await federateVideoIfNeeded(video, false, undefined)\n\n  return res.sendStatus(HttpStatusCode.NO_CONTENT_204)\n}\n", "import { Response } from 'express'\nimport { loadVideo, VideoLoadType } from '@server/lib/model-loaders'\nimport { VideoChannelModel } from '@server/models/video/video-channel'\nimport { VideoFileModel } from '@server/models/video/video-file'\nimport {\n  MUser,\n  MUserAccountId,\n  MVideoAccountLight,\n  MVideoFormattableDetails,\n  MVideoFullLight,\n  MVideoId,\n  MVideoImmutable,\n  MVideoThumbnail\n} from '@server/types/models'\nimport { HttpStatusCode, UserRight } from '@shared/models'\n\nasync function doesVideoExist (id: number | string, res: Response, fetchType: VideoLoadType = 'all') {\n  const userId = res.locals.oauth ? res.locals.oauth.token.User.id : undefined\n\n  const video = await loadVideo(id, fetchType, userId)\n\n  if (video === null) {\n    res.fail({\n      status: HttpStatusCode.NOT_FOUND_404,\n      message: 'Video not found'\n    })\n    return false\n  }\n\n  switch (fetchType) {\n    case 'for-api':\n      res.locals.videoAPI = video as MVideoFormattableDetails\n      break\n\n    case 'all':\n      res.locals.videoAll = video as MVideoFullLight\n      break\n\n    case 'only-immutable-attributes':\n      res.locals.onlyImmutableVideo = video as MVideoImmutable\n      break\n\n    case 'id':\n      res.locals.videoId = video as MVideoId\n      break\n\n    case 'only-video':\n      res.locals.onlyVideo = video as MVideoThumbnail\n      break\n  }\n\n  return true\n}\n\nasync function doesVideoFileOfVideoExist (id: number, videoIdOrUUID: number | string, res: Response) {\n  if (!await VideoFileModel.doesVideoExistForVideoFile(id, videoIdOrUUID)) {\n    res.fail({\n      status: HttpStatusCode.NOT_FOUND_404,\n      message: 'VideoFile matching Video not found'\n    })\n    return false\n  }\n\n  return true\n}\n\nasync function doesVideoChannelOfAccountExist (channelId: number, user: MUserAccountId, res: Response) {\n  const videoChannel = await VideoChannelModel.loadAndPopulateAccount(channelId)\n\n  if (videoChannel === null) {\n    res.fail({ message: 'Unknown video \"video channel\" for this instance.' })\n    return false\n  }\n\n  // Don't check account id if the user can update any video\n  if (user.hasRight(UserRight.UPDATE_ANY_VIDEO) === true) {\n    res.locals.videoChannel = videoChannel\n    return true\n  }\n\n  if (videoChannel.Account.id !== user.Account.id) {\n    res.fail({\n      message: 'Unknown video \"video channel\" for this account.'\n    })\n    return false\n  }\n\n  res.locals.videoChannel = videoChannel\n  return true\n}\n\nfunction checkUserCanManageVideo (user: MUser, video: MVideoAccountLight, right: UserRight, res: Response, onlyOwned = true) {\n  // Retrieve the user who did the request\n  if (onlyOwned && video.isOwned() === false) {\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: 'Cannot manage a video of another server.'\n    })\n    return false\n  }\n\n  // Check if the user can delete the video\n  // The user can delete it if he has the right\n  // Or if s/he is the video's account\n  const account = video.VideoChannel.Account\n  if (user.hasRight(right) === false && account.userId !== user.id) {\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: 'Cannot manage a video of another user.'\n    })\n    return false\n  }\n\n  return true\n}\n\n// ---------------------------------------------------------------------------\n\nexport {\n  doesVideoChannelOfAccountExist,\n  doesVideoExist,\n  doesVideoFileOfVideoExist,\n  checkUserCanManageVideo\n}\n", "import express from 'express'\nimport { body, param } from 'express-validator'\nimport { UserRight } from '../../../../shared'\nimport { isVideoCaptionFile, isVideoCaptionLanguageValid } from '../../../helpers/custom-validators/video-captions'\nimport { cleanUpReqFiles } from '../../../helpers/express-utils'\nimport { logger } from '../../../helpers/logger'\nimport { CONSTRAINTS_FIELDS, MIMETYPES } from '../../../initializers/constants'\nimport { areValidationErrors, checkUserCanManageVideo, doesVideoCaptionExist, doesVideoExist, isValidVideoIdParam } from '../shared'\n\nconst addVideoCaptionValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('captionLanguage')\n    .custom(isVideoCaptionLanguageValid).not().isEmpty().withMessage('Should have a valid caption language'),\n\n  body('captionfile')\n    .custom((_, { req }) => isVideoCaptionFile(req.files, 'captionfile'))\n    .withMessage(\n      'This caption file is not supported or too large. ' +\n      `Please, make sure it is under ${CONSTRAINTS_FIELDS.VIDEO_CAPTIONS.CAPTION_FILE.FILE_SIZE.max} bytes ` +\n      'and one of the following mimetypes: ' +\n      Object.keys(MIMETYPES.VIDEO_CAPTIONS.MIMETYPE_EXT).map(key => `${key} (${MIMETYPES.VIDEO_CAPTIONS.MIMETYPE_EXT[key]})`).join(', ')\n    ),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking addVideoCaption parameters', { parameters: req.body })\n\n    if (areValidationErrors(req, res)) return cleanUpReqFiles(req)\n    if (!await doesVideoExist(req.params.videoId, res)) return cleanUpReqFiles(req)\n\n    // Check if the user who did the request is able to update the video\n    const user = res.locals.oauth.token.User\n    if (!checkUserCanManageVideo(user, res.locals.videoAll, UserRight.UPDATE_ANY_VIDEO, res)) return cleanUpReqFiles(req)\n\n    return next()\n  }\n]\n\nconst deleteVideoCaptionValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('captionLanguage')\n    .custom(isVideoCaptionLanguageValid).not().isEmpty().withMessage('Should have a valid caption language'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking deleteVideoCaption parameters', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!await doesVideoCaptionExist(res.locals.videoAll, req.params.captionLanguage, res)) return\n\n    // Check if the user who did the request is able to update the video\n    const user = res.locals.oauth.token.User\n    if (!checkUserCanManageVideo(user, res.locals.videoAll, UserRight.UPDATE_ANY_VIDEO, res)) return\n\n    return next()\n  }\n]\n\nconst listVideoCaptionsValidator = [\n  isValidVideoIdParam('videoId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoCaptions parameters', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'id')) return\n\n    return next()\n  }\n]\n\nexport {\n  addVideoCaptionValidator,\n  listVideoCaptionsValidator,\n  deleteVideoCaptionValidator\n}\n", "import express from 'express'\nimport { body, header, param, query, ValidationChain } from 'express-validator'\nimport { isTestInstance } from '@server/helpers/core-utils'\nimport { getResumableUploadPath } from '@server/helpers/upload'\nimport { Redis } from '@server/lib/redis'\nimport { isAbleToUploadVideo } from '@server/lib/user'\nimport { getServerActor } from '@server/models/application/application'\nimport { ExpressPromiseHandler } from '@server/types/express'\nimport { MUserAccountId, MVideoFullLight } from '@server/types/models'\nimport { getAllPrivacies } from '@shared/core-utils'\nimport { VideoInclude } from '@shared/models'\nimport { ServerErrorCode, UserRight, VideoPrivacy } from '../../../../shared'\nimport { HttpStatusCode } from '../../../../shared/models/http/http-error-codes'\nimport {\n  exists,\n  isBooleanValid,\n  isDateValid,\n  isFileFieldValid,\n  isIdValid,\n  isUUIDValid,\n  toArray,\n  toBooleanOrNull,\n  toIntOrNull,\n  toValueOrNull\n} from '../../../helpers/custom-validators/misc'\nimport { isBooleanBothQueryValid, isNumberArray, isStringArray } from '../../../helpers/custom-validators/search'\nimport {\n  isScheduleVideoUpdatePrivacyValid,\n  isVideoCategoryValid,\n  isVideoDescriptionValid,\n  isVideoFileMimeTypeValid,\n  isVideoFileSizeValid,\n  isVideoFilterValid,\n  isVideoImage,\n  isVideoIncludeValid,\n  isVideoLanguageValid,\n  isVideoLicenceValid,\n  isVideoNameValid,\n  isVideoOriginallyPublishedAtValid,\n  isVideoPrivacyValid,\n  isVideoSupportValid,\n  isVideoTagsValid\n} from '../../../helpers/custom-validators/videos'\nimport { cleanUpReqFiles } from '../../../helpers/express-utils'\nimport { getDurationFromVideoFile } from '../../../helpers/ffprobe-utils'\nimport { logger } from '../../../helpers/logger'\nimport { deleteFileAndCatch } from '../../../helpers/utils'\nimport { getVideoWithAttributes } from '../../../helpers/video'\nimport { CONFIG } from '../../../initializers/config'\nimport { CONSTRAINTS_FIELDS, OVERVIEWS } from '../../../initializers/constants'\nimport { isLocalVideoAccepted } from '../../../lib/moderation'\nimport { Hooks } from '../../../lib/plugins/hooks'\nimport { VideoModel } from '../../../models/video/video'\nimport { authenticatePromiseIfNeeded } from '../../auth'\nimport {\n  areValidationErrors,\n  checkUserCanManageVideo,\n  doesVideoChannelOfAccountExist,\n  doesVideoExist,\n  doesVideoFileOfVideoExist,\n  isValidVideoIdParam\n} from '../shared'\n\nconst videosAddLegacyValidator = getCommonVideoEditAttributes().concat([\n  body('videofile')\n    .custom((value, { req }) => isFileFieldValid(req.files, 'videofile'))\n    .withMessage('Should have a file'),\n  body('name')\n    .trim()\n    .custom(isVideoNameValid).withMessage(\n      `Should have a video name between ${CONSTRAINTS_FIELDS.VIDEOS.NAME.min} and ${CONSTRAINTS_FIELDS.VIDEOS.NAME.max} characters long`\n    ),\n  body('channelId')\n    .customSanitizer(toIntOrNull)\n    .custom(isIdValid).withMessage('Should have correct video channel id'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videosAdd parameters', { parameters: req.body, files: req.files })\n\n    if (areValidationErrors(req, res)) return cleanUpReqFiles(req)\n\n    const videoFile: express.VideoUploadFile = req.files['videofile'][0]\n    const user = res.locals.oauth.token.User\n\n    if (!await commonVideoChecksPass({ req, res, user, videoFileSize: videoFile.size, files: req.files })) {\n      return cleanUpReqFiles(req)\n    }\n\n    try {\n      if (!videoFile.duration) await addDurationToVideo(videoFile)\n    } catch (err) {\n      logger.error('Invalid input file in videosAddLegacyValidator.', { err })\n\n      res.fail({\n        status: HttpStatusCode.UNPROCESSABLE_ENTITY_422,\n        message: 'Video file unreadable.'\n      })\n      return cleanUpReqFiles(req)\n    }\n\n    if (!await isVideoAccepted(req, res, videoFile)) return cleanUpReqFiles(req)\n\n    return next()\n  }\n])\n\nconst videosResumableUploadIdValidator = [\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    const user = res.locals.oauth.token.User\n    const uploadId = req.query.upload_id\n\n    if (uploadId.startsWith(user.id + '-') !== true) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'You cannot send chunks in another user upload'\n      })\n    }\n\n    return next()\n  }\n]\n\n/**\n * Gets called after the last PUT request\n */\nconst videosAddResumableValidator = [\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    const user = res.locals.oauth.token.User\n    const body: express.CustomUploadXFile<express.UploadXFileMetadata> = req.body\n    const file = { ...body, duration: undefined, path: getResumableUploadPath(body.name), filename: body.metadata.filename }\n    const cleanup = () => deleteFileAndCatch(file.path)\n\n    const uploadId = req.query.upload_id\n    const sessionExists = await Redis.Instance.doesUploadSessionExist(uploadId)\n\n    if (sessionExists) {\n      const sessionResponse = await Redis.Instance.getUploadSession(uploadId)\n\n      if (!sessionResponse) {\n        res.setHeader('Retry-After', 300) // ask to retry after 5 min, knowing the upload_id is kept for up to 15 min after completion\n\n        return res.fail({\n          status: HttpStatusCode.SERVICE_UNAVAILABLE_503,\n          message: 'The upload is already being processed'\n        })\n      }\n\n      if (isTestInstance()) {\n        res.setHeader('x-resumable-upload-cached', 'true')\n      }\n\n      return res.json(sessionResponse)\n    }\n\n    await Redis.Instance.setUploadSession(uploadId)\n\n    if (!await doesVideoChannelOfAccountExist(file.metadata.channelId, user, res)) return cleanup()\n\n    try {\n      if (!file.duration) await addDurationToVideo(file)\n    } catch (err) {\n      logger.error('Invalid input file in videosAddResumableValidator.', { err })\n\n      res.fail({\n        status: HttpStatusCode.UNPROCESSABLE_ENTITY_422,\n        message: 'Video file unreadable.'\n      })\n      return cleanup()\n    }\n\n    if (!await isVideoAccepted(req, res, file)) return cleanup()\n\n    res.locals.videoFileResumable = file\n\n    return next()\n  }\n]\n\n/**\n * File is created in POST initialisation, and its body is saved as a 'metadata' field is saved by uploadx for later use.\n * see https://github.com/kukhariev/node-uploadx/blob/dc9fb4a8ac5a6f481902588e93062f591ec6ef03/packages/core/src/handlers/uploadx.ts\n *\n * Uploadx doesn't use next() until the upload completes, so this middleware has to be placed before uploadx\n * see https://github.com/kukhariev/node-uploadx/blob/dc9fb4a8ac5a6f481902588e93062f591ec6ef03/packages/core/src/handlers/base-handler.ts\n *\n */\nconst videosAddResumableInitValidator = getCommonVideoEditAttributes().concat([\n  body('filename')\n    .isString()\n    .exists()\n    .withMessage('Should have a valid filename'),\n  body('name')\n    .trim()\n    .custom(isVideoNameValid).withMessage(\n      `Should have a video name between ${CONSTRAINTS_FIELDS.VIDEOS.NAME.min} and ${CONSTRAINTS_FIELDS.VIDEOS.NAME.max} characters long`\n    ),\n  body('channelId')\n    .customSanitizer(toIntOrNull)\n    .custom(isIdValid).withMessage('Should have correct video channel id'),\n\n  header('x-upload-content-length')\n    .isNumeric()\n    .exists()\n    .withMessage('Should specify the file length'),\n  header('x-upload-content-type')\n    .isString()\n    .exists()\n    .withMessage('Should specify the file mimetype'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    const videoFileMetadata = {\n      mimetype: req.headers['x-upload-content-type'] as string,\n      size: +req.headers['x-upload-content-length'],\n      originalname: req.body.filename\n    }\n\n    const user = res.locals.oauth.token.User\n    const cleanup = () => cleanUpReqFiles(req)\n\n    logger.debug('Checking videosAddResumableInitValidator parameters and headers', {\n      parameters: req.body,\n      headers: req.headers,\n      files: req.files\n    })\n\n    if (areValidationErrors(req, res)) return cleanup()\n\n    const files = { videofile: [ videoFileMetadata ] }\n    if (!await commonVideoChecksPass({ req, res, user, videoFileSize: videoFileMetadata.size, files })) return cleanup()\n\n    // multer required unsetting the Content-Type, now we can set it for node-uploadx\n    req.headers['content-type'] = 'application/json; charset=utf-8'\n    // place previewfile in metadata so that uploadx saves it in .META\n    if (req.files?.['previewfile']) req.body.previewfile = req.files['previewfile']\n\n    return next()\n  }\n])\n\nconst videosUpdateValidator = getCommonVideoEditAttributes().concat([\n  isValidVideoIdParam('id'),\n\n  body('name')\n    .optional()\n    .trim()\n    .custom(isVideoNameValid).withMessage(\n      `Should have a video name between ${CONSTRAINTS_FIELDS.VIDEOS.NAME.min} and ${CONSTRAINTS_FIELDS.VIDEOS.NAME.max} characters long`\n    ),\n  body('channelId')\n    .optional()\n    .customSanitizer(toIntOrNull)\n    .custom(isIdValid).withMessage('Should have correct video channel id'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videosUpdate parameters', { parameters: req.body })\n\n    if (areValidationErrors(req, res)) return cleanUpReqFiles(req)\n    if (areErrorsInScheduleUpdate(req, res)) return cleanUpReqFiles(req)\n    if (!await doesVideoExist(req.params.id, res)) return cleanUpReqFiles(req)\n\n    // Check if the user who did the request is able to update the video\n    const user = res.locals.oauth.token.User\n    if (!checkUserCanManageVideo(user, res.locals.videoAll, UserRight.UPDATE_ANY_VIDEO, res)) return cleanUpReqFiles(req)\n\n    if (req.body.channelId && !await doesVideoChannelOfAccountExist(req.body.channelId, user, res)) return cleanUpReqFiles(req)\n\n    return next()\n  }\n])\n\nasync function checkVideoFollowConstraints (req: express.Request, res: express.Response, next: express.NextFunction) {\n  const video = getVideoWithAttributes(res)\n\n  // Anybody can watch local videos\n  if (video.isOwned() === true) return next()\n\n  // Logged user\n  if (res.locals.oauth) {\n    // Users can search or watch remote videos\n    if (CONFIG.SEARCH.REMOTE_URI.USERS === true) return next()\n  }\n\n  // Anybody can search or watch remote videos\n  if (CONFIG.SEARCH.REMOTE_URI.ANONYMOUS === true) return next()\n\n  // Check our instance follows an actor that shared this video\n  const serverActor = await getServerActor()\n  if (await VideoModel.checkVideoHasInstanceFollow(video.id, serverActor.id) === true) return next()\n\n  return res.fail({\n    status: HttpStatusCode.FORBIDDEN_403,\n    message: 'Cannot get this video regarding follow constraints',\n    type: ServerErrorCode.DOES_NOT_RESPECT_FOLLOW_CONSTRAINTS,\n    data: {\n      originUrl: video.url\n    }\n  })\n}\n\nconst videosCustomGetValidator = (\n  fetchType: 'for-api' | 'all' | 'only-video' | 'only-immutable-attributes',\n  authenticateInQuery = false\n) => {\n  return [\n    isValidVideoIdParam('id'),\n\n    async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n      logger.debug('Checking videosGet parameters', { parameters: req.params })\n\n      if (areValidationErrors(req, res)) return\n      if (!await doesVideoExist(req.params.id, res, fetchType)) return\n\n      // Controllers does not need to check video rights\n      if (fetchType === 'only-immutable-attributes') return next()\n\n      const video = getVideoWithAttributes(res) as MVideoFullLight\n\n      // Video private or blacklisted\n      if (video.requiresAuth()) {\n        await authenticatePromiseIfNeeded(req, res, authenticateInQuery)\n\n        const user = res.locals.oauth ? res.locals.oauth.token.User : null\n\n        // Only the owner or a user that have blocklist rights can see the video\n        if (!user || !user.canGetVideo(video)) {\n          return res.fail({\n            status: HttpStatusCode.FORBIDDEN_403,\n            message: 'Cannot get this private/internal or blocklisted video'\n          })\n        }\n\n        return next()\n      }\n\n      // Video is public, anyone can access it\n      if (video.privacy === VideoPrivacy.PUBLIC) return next()\n\n      // Video is unlisted, check we used the uuid to fetch it\n      if (video.privacy === VideoPrivacy.UNLISTED) {\n        if (isUUIDValid(req.params.id)) return next()\n\n        // Don't leak this unlisted video\n        return res.fail({\n          status: HttpStatusCode.NOT_FOUND_404,\n          message: 'Video not found'\n        })\n      }\n    }\n  ]\n}\n\nconst videosGetValidator = videosCustomGetValidator('all')\nconst videosDownloadValidator = videosCustomGetValidator('all', true)\n\nconst videoFileMetadataGetValidator = getCommonVideoEditAttributes().concat([\n  isValidVideoIdParam('id'),\n\n  param('videoFileId')\n    .custom(isIdValid).not().isEmpty().withMessage('Should have a valid videoFileId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videoFileMetadataGet parameters', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoFileOfVideoExist(+req.params.videoFileId, req.params.id, res)) return\n\n    return next()\n  }\n])\n\nconst videosRemoveValidator = [\n  isValidVideoIdParam('id'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videosRemove parameters', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.id, res)) return\n\n    // Check if the user who did the request is able to delete the video\n    if (!checkUserCanManageVideo(res.locals.oauth.token.User, res.locals.videoAll, UserRight.REMOVE_ANY_VIDEO, res)) return\n\n    return next()\n  }\n]\n\nconst videosOverviewValidator = [\n  query('page')\n    .optional()\n    .isInt({ min: 1, max: OVERVIEWS.VIDEOS.SAMPLES_COUNT })\n    .withMessage('Should have a valid pagination'),\n\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    if (areValidationErrors(req, res)) return\n\n    return next()\n  }\n]\n\nfunction getCommonVideoEditAttributes () {\n  return [\n    body('thumbnailfile')\n      .custom((value, { req }) => isVideoImage(req.files, 'thumbnailfile')).withMessage(\n        'This thumbnail file is not supported or too large. Please, make sure it is of the following type: ' +\n        CONSTRAINTS_FIELDS.VIDEOS.IMAGE.EXTNAME.join(', ')\n      ),\n    body('previewfile')\n      .custom((value, { req }) => isVideoImage(req.files, 'previewfile')).withMessage(\n        'This preview file is not supported or too large. Please, make sure it is of the following type: ' +\n        CONSTRAINTS_FIELDS.VIDEOS.IMAGE.EXTNAME.join(', ')\n      ),\n\n    body('category')\n      .optional()\n      .customSanitizer(toIntOrNull)\n      .custom(isVideoCategoryValid).withMessage('Should have a valid category'),\n    body('licence')\n      .optional()\n      .customSanitizer(toIntOrNull)\n      .custom(isVideoLicenceValid).withMessage('Should have a valid licence'),\n    body('language')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoLanguageValid).withMessage('Should have a valid language'),\n    body('nsfw')\n      .optional()\n      .customSanitizer(toBooleanOrNull)\n      .custom(isBooleanValid).withMessage('Should have a valid NSFW attribute'),\n    body('waitTranscoding')\n      .optional()\n      .customSanitizer(toBooleanOrNull)\n      .custom(isBooleanValid).withMessage('Should have a valid wait transcoding attribute'),\n    body('privacy')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoPrivacyValid).withMessage('Should have correct video privacy'),\n    body('description')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoDescriptionValid).withMessage('Should have a valid description'),\n    body('support')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoSupportValid).withMessage('Should have a valid support text'),\n    body('tags')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoTagsValid)\n      .withMessage(\n        `Should have an array of up to ${CONSTRAINTS_FIELDS.VIDEOS.TAGS.max} tags between ` +\n        `${CONSTRAINTS_FIELDS.VIDEOS.TAG.min} and ${CONSTRAINTS_FIELDS.VIDEOS.TAG.max} characters each`\n      ),\n    body('commentsEnabled')\n      .optional()\n      .customSanitizer(toBooleanOrNull)\n      .custom(isBooleanValid).withMessage('Should have comments enabled boolean'),\n    body('downloadEnabled')\n      .optional()\n      .customSanitizer(toBooleanOrNull)\n      .custom(isBooleanValid).withMessage('Should have downloading enabled boolean'),\n    body('originallyPublishedAt')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoOriginallyPublishedAtValid).withMessage('Should have a valid original publication date'),\n    body('scheduleUpdate')\n      .optional()\n      .customSanitizer(toValueOrNull),\n    body('scheduleUpdate.updateAt')\n      .optional()\n      .custom(isDateValid).withMessage('Should have a schedule update date that conforms to ISO 8601'),\n    body('scheduleUpdate.privacy')\n      .optional()\n      .customSanitizer(toIntOrNull)\n      .custom(isScheduleVideoUpdatePrivacyValid).withMessage('Should have correct schedule update privacy')\n  ] as (ValidationChain | ExpressPromiseHandler)[]\n}\n\nconst commonVideosFiltersValidator = [\n  query('categoryOneOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isNumberArray).withMessage('Should have a valid one of category array'),\n  query('licenceOneOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isNumberArray).withMessage('Should have a valid one of licence array'),\n  query('languageOneOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isStringArray).withMessage('Should have a valid one of language array'),\n  query('privacyOneOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isNumberArray).withMessage('Should have a valid one of privacy array'),\n  query('tagsOneOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isStringArray).withMessage('Should have a valid one of tags array'),\n  query('tagsAllOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isStringArray).withMessage('Should have a valid all of tags array'),\n  query('nsfw')\n    .optional()\n    .custom(isBooleanBothQueryValid).withMessage('Should have a valid NSFW attribute'),\n  query('isLive')\n    .optional()\n    .customSanitizer(toBooleanOrNull)\n    .custom(isBooleanValid).withMessage('Should have a valid live boolean'),\n  query('filter')\n    .optional()\n    .custom(isVideoFilterValid).withMessage('Should have a valid filter attribute'),\n  query('include')\n    .optional()\n    .custom(isVideoIncludeValid).withMessage('Should have a valid include attribute'),\n  query('isLocal')\n    .optional()\n    .customSanitizer(toBooleanOrNull)\n    .custom(isBooleanValid).withMessage('Should have a valid local boolean'),\n  query('hasHLSFiles')\n    .optional()\n    .customSanitizer(toBooleanOrNull)\n    .custom(isBooleanValid).withMessage('Should have a valid has hls boolean'),\n  query('hasWebtorrentFiles')\n    .optional()\n    .customSanitizer(toBooleanOrNull)\n    .custom(isBooleanValid).withMessage('Should have a valid has webtorrent boolean'),\n  query('skipCount')\n    .optional()\n    .customSanitizer(toBooleanOrNull)\n    .custom(isBooleanValid).withMessage('Should have a valid skip count boolean'),\n  query('search')\n    .optional()\n    .custom(exists).withMessage('Should have a valid search'),\n\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking commons video filters query', { parameters: req.query })\n\n    if (areValidationErrors(req, res)) return\n\n    // FIXME: deprecated in 4.0, to remove\n    {\n      if (req.query.filter === 'all-local') {\n        req.query.include = VideoInclude.NOT_PUBLISHED_STATE\n        req.query.isLocal = true\n        req.query.privacyOneOf = getAllPrivacies()\n      } else if (req.query.filter === 'all') {\n        req.query.include = VideoInclude.NOT_PUBLISHED_STATE\n        req.query.privacyOneOf = getAllPrivacies()\n      } else if (req.query.filter === 'local') {\n        req.query.isLocal = true\n      }\n\n      req.query.filter = undefined\n    }\n\n    const user = res.locals.oauth?.token.User\n\n    if ((!user || user.hasRight(UserRight.SEE_ALL_VIDEOS) !== true)) {\n      if (req.query.include || req.query.privacyOneOf) {\n        return res.fail({\n          status: HttpStatusCode.UNAUTHORIZED_401,\n          message: 'You are not allowed to see all videos.'\n        })\n      }\n    }\n\n    return next()\n  }\n]\n\n// ---------------------------------------------------------------------------\n\nexport {\n  videosAddLegacyValidator,\n  videosAddResumableValidator,\n  videosAddResumableInitValidator,\n  videosResumableUploadIdValidator,\n\n  videosUpdateValidator,\n  videosGetValidator,\n  videoFileMetadataGetValidator,\n  videosDownloadValidator,\n  checkVideoFollowConstraints,\n  videosCustomGetValidator,\n  videosRemoveValidator,\n\n  getCommonVideoEditAttributes,\n\n  commonVideosFiltersValidator,\n\n  videosOverviewValidator\n}\n\n// ---------------------------------------------------------------------------\n\nfunction areErrorsInScheduleUpdate (req: express.Request, res: express.Response) {\n  if (req.body.scheduleUpdate) {\n    if (!req.body.scheduleUpdate.updateAt) {\n      logger.warn('Invalid parameters: scheduleUpdate.updateAt is mandatory.')\n\n      res.fail({ message: 'Schedule update at is mandatory.' })\n      return true\n    }\n  }\n\n  return false\n}\n\nasync function commonVideoChecksPass (parameters: {\n  req: express.Request\n  res: express.Response\n  user: MUserAccountId\n  videoFileSize: number\n  files: express.UploadFilesForCheck\n}): Promise<boolean> {\n  const { req, res, user, videoFileSize, files } = parameters\n\n  if (areErrorsInScheduleUpdate(req, res)) return false\n\n  if (!await doesVideoChannelOfAccountExist(req.body.channelId, user, res)) return false\n\n  if (!isVideoFileMimeTypeValid(files)) {\n    res.fail({\n      status: HttpStatusCode.UNSUPPORTED_MEDIA_TYPE_415,\n      message: 'This file is not supported. Please, make sure it is of the following type: ' +\n               CONSTRAINTS_FIELDS.VIDEOS.EXTNAME.join(', ')\n    })\n    return false\n  }\n\n  if (!isVideoFileSizeValid(videoFileSize.toString())) {\n    res.fail({\n      status: HttpStatusCode.PAYLOAD_TOO_LARGE_413,\n      message: 'This file is too large. It exceeds the maximum file size authorized.',\n      type: ServerErrorCode.MAX_FILE_SIZE_REACHED\n    })\n    return false\n  }\n\n  if (await isAbleToUploadVideo(user.id, videoFileSize) === false) {\n    res.fail({\n      status: HttpStatusCode.PAYLOAD_TOO_LARGE_413,\n      message: 'The user video quota is exceeded with this video.',\n      type: ServerErrorCode.QUOTA_REACHED\n    })\n    return false\n  }\n\n  return true\n}\n\nexport async function isVideoAccepted (\n  req: express.Request,\n  res: express.Response,\n  videoFile: express.VideoUploadFile\n) {\n  // Check we accept this video\n  const acceptParameters = {\n    videoBody: req.body,\n    videoFile,\n    user: res.locals.oauth.token.User\n  }\n  const acceptedResult = await Hooks.wrapFun(\n    isLocalVideoAccepted,\n    acceptParameters,\n    'filter:api.video.upload.accept.result'\n  )\n\n  if (!acceptedResult || acceptedResult.accepted !== true) {\n    logger.info('Refused local video.', { acceptedResult, acceptParameters })\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: acceptedResult.errorMessage || 'Refused local video'\n    })\n    return false\n  }\n\n  return true\n}\n\nasync function addDurationToVideo (videoFile: { path: string, duration?: number }) {\n  const duration: number = await getDurationFromVideoFile(videoFile.path)\n\n  if (isNaN(duration)) throw new Error(`Couldn't get video duration`)\n\n  videoFile.duration = duration\n}\n", "/* eslint-disable @typescript-eslint/no-unused-expressions,@typescript-eslint/require-await */\n\nimport 'mocha'\nimport {\n  buildAbsoluteFixturePath,\n  cleanupTests,\n  createSingleServer,\n  makeDeleteRequest,\n  makeGetRequest,\n  makeUploadRequest,\n  PeerTubeServer,\n  setAccessTokensToServers\n} from '@shared/extra-utils'\nimport { HttpStatusCode, VideoCreateResult } from '@shared/models'\n\ndescribe('Test video captions API validator', function () {\n  const path = '/api/v1/videos/'\n\n  let server: PeerTubeServer\n  let userAccessToken: string\n  let video: VideoCreateResult\n\n  // ---------------------------------------------------------------\n\n  before(async function () {\n    this.timeout(30000)\n\n    server = await createSingleServer(1)\n\n    await setAccessTokensToServers([ server ])\n\n    video = await server.videos.upload()\n\n    {\n      const user = {\n        username: 'user1',\n        password: 'my super password'\n      }\n      await server.users.create({ username: user.username, password: user.password })\n      userAccessToken = await server.login.getAccessToken(user)\n    }\n  })\n\n  describe('When adding video caption', function () {\n    const fields = { }\n    const attaches = {\n      captionfile: buildAbsoluteFixturePath('subtitle-good1.vtt')\n    }\n\n    it('Should fail without a valid uuid', async function () {\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df563d0b06/captions/fr',\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with an unknown id', async function () {\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06/captions/fr',\n        token: server.accessToken,\n        fields,\n        attaches,\n        expectedStatus: 404\n      })\n    })\n\n    it('Should fail with a missing language in path', async function () {\n      const captionPath = path + video.uuid + '/captions'\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: captionPath,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with an unknown language', async function () {\n      const captionPath = path + video.uuid + '/captions/15'\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: captionPath,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail without access token', async function () {\n      const captionPath = path + video.uuid + '/captions/fr'\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: captionPath,\n        fields,\n        attaches,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with a bad access token', async function () {\n      const captionPath = path + video.uuid + '/captions/fr'\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: captionPath,\n        token: 'blabla',\n        fields,\n        attaches,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    // We accept any file now\n    // it('Should fail with an invalid captionfile extension', async function () {\n    //   const attaches = {\n    //     'captionfile': buildAbsoluteFixturePath('subtitle-bad.txt')\n    //   }\n    //\n    //   const captionPath = path + video.uuid + '/captions/fr'\n    //   await makeUploadRequest({\n    //     method: 'PUT',\n    //     url: server.url,\n    //     path: captionPath,\n    //     token: server.accessToken,\n    //     fields,\n    //     attaches,\n    //     expectedStatus: HttpStatusCode.BAD_REQUEST_400\n    //   })\n    // })\n\n    // We don't check the extension yet\n    // it('Should fail with an invalid captionfile extension and octet-stream mime type', async function () {\n    //   await createVideoCaption({\n    //     url: server.url,\n    //     accessToken: server.accessToken,\n    //     language: 'zh',\n    //     videoId: video.uuid,\n    //     fixture: 'subtitle-bad.txt',\n    //     mimeType: 'application/octet-stream',\n    //     expectedStatus: HttpStatusCode.BAD_REQUEST_400\n    //   })\n    // })\n\n    it('Should succeed with a valid captionfile extension and octet-stream mime type', async function () {\n      await server.captions.add({\n        language: 'zh',\n        videoId: video.uuid,\n        fixture: 'subtitle-good.srt',\n        mimeType: 'application/octet-stream'\n      })\n    })\n\n    // We don't check the file validity yet\n    // it('Should fail with an invalid captionfile srt', async function () {\n    //   const attaches = {\n    //     'captionfile': buildAbsoluteFixturePath('subtitle-bad.srt')\n    //   }\n    //\n    //   const captionPath = path + video.uuid + '/captions/fr'\n    //   await makeUploadRequest({\n    //     method: 'PUT',\n    //     url: server.url,\n    //     path: captionPath,\n    //     token: server.accessToken,\n    //     fields,\n    //     attaches,\n    //     expectedStatus: HttpStatusCode.INTERNAL_SERVER_ERROR_500\n    //   })\n    // })\n\n    it('Should success with the correct parameters', async function () {\n      const captionPath = path + video.uuid + '/captions/fr'\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: captionPath,\n        token: server.accessToken,\n        fields,\n        attaches,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  describe('When listing video captions', function () {\n    it('Should fail without a valid uuid', async function () {\n      await makeGetRequest({ url: server.url, path: path + '4da6fde3-88f7-4d16-b119-108df563d0b06/captions' })\n    })\n\n    it('Should fail with an unknown id', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06/captions',\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path: path + video.shortUUID + '/captions', expectedStatus: HttpStatusCode.OK_200 })\n    })\n  })\n\n  describe('When deleting video caption', function () {\n    it('Should fail without a valid uuid', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df563d0b06/captions/fr',\n        token: server.accessToken\n      })\n    })\n\n    it('Should fail with an unknown id', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06/captions/fr',\n        token: server.accessToken,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with an invalid language', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06/captions/16',\n        token: server.accessToken\n      })\n    })\n\n    it('Should fail with a missing language', async function () {\n      const captionPath = path + video.shortUUID + '/captions'\n      await makeDeleteRequest({ url: server.url, path: captionPath, token: server.accessToken })\n    })\n\n    it('Should fail with an unknown language', async function () {\n      const captionPath = path + video.shortUUID + '/captions/15'\n      await makeDeleteRequest({ url: server.url, path: captionPath, token: server.accessToken })\n    })\n\n    it('Should fail without access token', async function () {\n      const captionPath = path + video.shortUUID + '/captions/fr'\n      await makeDeleteRequest({ url: server.url, path: captionPath, expectedStatus: HttpStatusCode.UNAUTHORIZED_401 })\n    })\n\n    it('Should fail with a bad access token', async function () {\n      const captionPath = path + video.shortUUID + '/captions/fr'\n      await makeDeleteRequest({ url: server.url, path: captionPath, token: 'coucou', expectedStatus: HttpStatusCode.UNAUTHORIZED_401 })\n    })\n\n    it('Should fail with another user', async function () {\n      const captionPath = path + video.shortUUID + '/captions/fr'\n      await makeDeleteRequest({\n        url: server.url,\n        path: captionPath,\n        token: userAccessToken,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should success with the correct parameters', async function () {\n      const captionPath = path + video.shortUUID + '/captions/fr'\n      await makeDeleteRequest({\n        url: server.url,\n        path: captionPath,\n        token: server.accessToken,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  after(async function () {\n    await cleanupTests([ server ])\n  })\n})\n"], "fixing_code": ["import express from 'express'\nimport { MVideoCaption } from '@server/types/models'\nimport { HttpStatusCode } from '../../../../shared/models/http/http-error-codes'\nimport { moveAndProcessCaptionFile } from '../../../helpers/captions-utils'\nimport { createReqFiles } from '../../../helpers/express-utils'\nimport { logger } from '../../../helpers/logger'\nimport { getFormattedObjects } from '../../../helpers/utils'\nimport { CONFIG } from '../../../initializers/config'\nimport { MIMETYPES } from '../../../initializers/constants'\nimport { sequelizeTypescript } from '../../../initializers/database'\nimport { federateVideoIfNeeded } from '../../../lib/activitypub/videos'\nimport { asyncMiddleware, asyncRetryTransactionMiddleware, authenticate } from '../../../middlewares'\nimport { addVideoCaptionValidator, deleteVideoCaptionValidator, listVideoCaptionsValidator } from '../../../middlewares/validators'\nimport { VideoCaptionModel } from '../../../models/video/video-caption'\n\nconst reqVideoCaptionAdd = createReqFiles(\n  [ 'captionfile' ],\n  MIMETYPES.VIDEO_CAPTIONS.MIMETYPE_EXT,\n  {\n    captionfile: CONFIG.STORAGE.CAPTIONS_DIR\n  }\n)\n\nconst videoCaptionsRouter = express.Router()\n\nvideoCaptionsRouter.get('/:videoId/captions',\n  asyncMiddleware(listVideoCaptionsValidator),\n  asyncMiddleware(listVideoCaptions)\n)\nvideoCaptionsRouter.put('/:videoId/captions/:captionLanguage',\n  authenticate,\n  reqVideoCaptionAdd,\n  asyncMiddleware(addVideoCaptionValidator),\n  asyncRetryTransactionMiddleware(addVideoCaption)\n)\nvideoCaptionsRouter.delete('/:videoId/captions/:captionLanguage',\n  authenticate,\n  asyncMiddleware(deleteVideoCaptionValidator),\n  asyncRetryTransactionMiddleware(deleteVideoCaption)\n)\n\n// ---------------------------------------------------------------------------\n\nexport {\n  videoCaptionsRouter\n}\n\n// ---------------------------------------------------------------------------\n\nasync function listVideoCaptions (req: express.Request, res: express.Response) {\n  const data = await VideoCaptionModel.listVideoCaptions(res.locals.onlyVideo.id)\n\n  return res.json(getFormattedObjects(data, data.length))\n}\n\nasync function addVideoCaption (req: express.Request, res: express.Response) {\n  const videoCaptionPhysicalFile = req.files['captionfile'][0]\n  const video = res.locals.videoAll\n\n  const captionLanguage = req.params.captionLanguage\n\n  const videoCaption = new VideoCaptionModel({\n    videoId: video.id,\n    filename: VideoCaptionModel.generateCaptionName(captionLanguage),\n    language: captionLanguage\n  }) as MVideoCaption\n\n  // Move physical file\n  await moveAndProcessCaptionFile(videoCaptionPhysicalFile, videoCaption)\n\n  await sequelizeTypescript.transaction(async t => {\n    await VideoCaptionModel.insertOrReplaceLanguage(videoCaption, t)\n\n    // Update video update\n    await federateVideoIfNeeded(video, false, t)\n  })\n\n  return res.status(HttpStatusCode.NO_CONTENT_204).end()\n}\n\nasync function deleteVideoCaption (req: express.Request, res: express.Response) {\n  const video = res.locals.videoAll\n  const videoCaption = res.locals.videoCaption\n\n  await sequelizeTypescript.transaction(async t => {\n    await videoCaption.destroy({ transaction: t })\n\n    // Send video update\n    await federateVideoIfNeeded(video, false, t)\n  })\n\n  logger.info('Video caption %s of video %s deleted.', videoCaption.language, video.uuid)\n\n  return res.type('json').status(HttpStatusCode.NO_CONTENT_204).end()\n}\n", "import express from 'express'\nimport toInt from 'validator/lib/toInt'\nimport { logger, loggerTagsFactory } from '@server/helpers/logger'\nimport { federateVideoIfNeeded } from '@server/lib/activitypub/videos'\nimport { VideoFileModel } from '@server/models/video/video-file'\nimport { HttpStatusCode, UserRight } from '@shared/models'\nimport {\n  asyncMiddleware,\n  authenticate,\n  ensureUserHasRight,\n  videoFileMetadataGetValidator,\n  videoFilesDeleteHLSValidator,\n  videoFilesDeleteWebTorrentValidator,\n  videosGetValidator\n} from '../../../middlewares'\n\nconst lTags = loggerTagsFactory('api', 'video')\nconst filesRouter = express.Router()\n\nfilesRouter.get('/:id/metadata/:videoFileId',\n  asyncMiddleware(videosGetValidator),\n  asyncMiddleware(videoFileMetadataGetValidator),\n  asyncMiddleware(getVideoFileMetadata)\n)\n\nfilesRouter.delete('/:id/hls',\n  authenticate,\n  ensureUserHasRight(UserRight.MANAGE_VIDEO_FILES),\n  asyncMiddleware(videoFilesDeleteHLSValidator),\n  asyncMiddleware(removeHLSPlaylist)\n)\n\nfilesRouter.delete('/:id/webtorrent',\n  authenticate,\n  ensureUserHasRight(UserRight.MANAGE_VIDEO_FILES),\n  asyncMiddleware(videoFilesDeleteWebTorrentValidator),\n  asyncMiddleware(removeWebTorrentFiles)\n)\n\n// ---------------------------------------------------------------------------\n\nexport {\n  filesRouter\n}\n\n// ---------------------------------------------------------------------------\n\nasync function getVideoFileMetadata (req: express.Request, res: express.Response) {\n  const videoFile = await VideoFileModel.loadWithMetadata(toInt(req.params.videoFileId))\n\n  return res.json(videoFile.metadata)\n}\n\nasync function removeHLSPlaylist (req: express.Request, res: express.Response) {\n  const video = res.locals.videoAll\n\n  logger.info('Deleting HLS playlist of %s.', video.url, lTags(video.uuid))\n\n  const hls = video.getHLSPlaylist()\n  await video.removeStreamingPlaylistFiles(hls)\n  await hls.destroy()\n\n  video.VideoStreamingPlaylists = video.VideoStreamingPlaylists.filter(p => p.id !== hls.id)\n\n  await federateVideoIfNeeded(video, false, undefined)\n\n  return res.sendStatus(HttpStatusCode.NO_CONTENT_204)\n}\n\nasync function removeWebTorrentFiles (req: express.Request, res: express.Response) {\n  const video = res.locals.videoAll\n\n  logger.info('Deleting WebTorrent files of %s.', video.url, lTags(video.uuid))\n\n  for (const file of video.VideoFiles) {\n    await video.removeWebTorrentFileAndTorrent(file)\n    await file.destroy()\n  }\n\n  video.VideoFiles = []\n  await federateVideoIfNeeded(video, false, undefined)\n\n  return res.sendStatus(HttpStatusCode.NO_CONTENT_204)\n}\n", "import { Request, Response } from 'express'\nimport { loadVideo, VideoLoadType } from '@server/lib/model-loaders'\nimport { authenticatePromiseIfNeeded } from '@server/middlewares/auth'\nimport { VideoModel } from '@server/models/video/video'\nimport { VideoChannelModel } from '@server/models/video/video-channel'\nimport { VideoFileModel } from '@server/models/video/video-file'\nimport {\n  MUser,\n  MUserAccountId,\n  MVideo,\n  MVideoAccountLight,\n  MVideoFormattableDetails,\n  MVideoFullLight,\n  MVideoId,\n  MVideoImmutable,\n  MVideoThumbnail,\n  MVideoWithRights\n} from '@server/types/models'\nimport { HttpStatusCode, UserRight } from '@shared/models'\n\nasync function doesVideoExist (id: number | string, res: Response, fetchType: VideoLoadType = 'all') {\n  const userId = res.locals.oauth ? res.locals.oauth.token.User.id : undefined\n\n  const video = await loadVideo(id, fetchType, userId)\n\n  if (video === null) {\n    res.fail({\n      status: HttpStatusCode.NOT_FOUND_404,\n      message: 'Video not found'\n    })\n    return false\n  }\n\n  switch (fetchType) {\n    case 'for-api':\n      res.locals.videoAPI = video as MVideoFormattableDetails\n      break\n\n    case 'all':\n      res.locals.videoAll = video as MVideoFullLight\n      break\n\n    case 'only-immutable-attributes':\n      res.locals.onlyImmutableVideo = video as MVideoImmutable\n      break\n\n    case 'id':\n      res.locals.videoId = video as MVideoId\n      break\n\n    case 'only-video':\n      res.locals.onlyVideo = video as MVideoThumbnail\n      break\n  }\n\n  return true\n}\n\nasync function doesVideoFileOfVideoExist (id: number, videoIdOrUUID: number | string, res: Response) {\n  if (!await VideoFileModel.doesVideoExistForVideoFile(id, videoIdOrUUID)) {\n    res.fail({\n      status: HttpStatusCode.NOT_FOUND_404,\n      message: 'VideoFile matching Video not found'\n    })\n    return false\n  }\n\n  return true\n}\n\nasync function doesVideoChannelOfAccountExist (channelId: number, user: MUserAccountId, res: Response) {\n  const videoChannel = await VideoChannelModel.loadAndPopulateAccount(channelId)\n\n  if (videoChannel === null) {\n    res.fail({ message: 'Unknown video \"video channel\" for this instance.' })\n    return false\n  }\n\n  // Don't check account id if the user can update any video\n  if (user.hasRight(UserRight.UPDATE_ANY_VIDEO) === true) {\n    res.locals.videoChannel = videoChannel\n    return true\n  }\n\n  if (videoChannel.Account.id !== user.Account.id) {\n    res.fail({\n      message: 'Unknown video \"video channel\" for this account.'\n    })\n    return false\n  }\n\n  res.locals.videoChannel = videoChannel\n  return true\n}\n\nasync function checkCanSeeVideoIfPrivate (req: Request, res: Response, video: MVideo, authenticateInQuery = false) {\n  if (!video.requiresAuth()) return true\n\n  const videoWithRights = await VideoModel.loadAndPopulateAccountAndServerAndTags(video.id)\n\n  return checkCanSeePrivateVideo(req, res, videoWithRights, authenticateInQuery)\n}\n\nasync function checkCanSeePrivateVideo (req: Request, res: Response, video: MVideoWithRights, authenticateInQuery = false) {\n  await authenticatePromiseIfNeeded(req, res, authenticateInQuery)\n\n  const user = res.locals.oauth ? res.locals.oauth.token.User : null\n\n  // Only the owner or a user that have blocklist rights can see the video\n  if (!user || !user.canGetVideo(video)) {\n    return false\n  }\n\n  return true\n}\n\nfunction checkUserCanManageVideo (user: MUser, video: MVideoAccountLight, right: UserRight, res: Response, onlyOwned = true) {\n  // Retrieve the user who did the request\n  if (onlyOwned && video.isOwned() === false) {\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: 'Cannot manage a video of another server.'\n    })\n    return false\n  }\n\n  // Check if the user can delete the video\n  // The user can delete it if he has the right\n  // Or if s/he is the video's account\n  const account = video.VideoChannel.Account\n  if (user.hasRight(right) === false && account.userId !== user.id) {\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: 'Cannot manage a video of another user.'\n    })\n    return false\n  }\n\n  return true\n}\n\n// ---------------------------------------------------------------------------\n\nexport {\n  doesVideoChannelOfAccountExist,\n  doesVideoExist,\n  doesVideoFileOfVideoExist,\n  checkUserCanManageVideo,\n  checkCanSeeVideoIfPrivate,\n  checkCanSeePrivateVideo\n}\n", "import express from 'express'\nimport { body, param } from 'express-validator'\nimport { HttpStatusCode, UserRight } from '../../../../shared'\nimport { isVideoCaptionFile, isVideoCaptionLanguageValid } from '../../../helpers/custom-validators/video-captions'\nimport { cleanUpReqFiles } from '../../../helpers/express-utils'\nimport { logger } from '../../../helpers/logger'\nimport { CONSTRAINTS_FIELDS, MIMETYPES } from '../../../initializers/constants'\nimport {\n  areValidationErrors,\n  checkCanSeeVideoIfPrivate,\n  checkUserCanManageVideo,\n  doesVideoCaptionExist,\n  doesVideoExist,\n  isValidVideoIdParam\n} from '../shared'\n\nconst addVideoCaptionValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('captionLanguage')\n    .custom(isVideoCaptionLanguageValid).not().isEmpty().withMessage('Should have a valid caption language'),\n\n  body('captionfile')\n    .custom((_, { req }) => isVideoCaptionFile(req.files, 'captionfile'))\n    .withMessage(\n      'This caption file is not supported or too large. ' +\n      `Please, make sure it is under ${CONSTRAINTS_FIELDS.VIDEO_CAPTIONS.CAPTION_FILE.FILE_SIZE.max} bytes ` +\n      'and one of the following mimetypes: ' +\n      Object.keys(MIMETYPES.VIDEO_CAPTIONS.MIMETYPE_EXT).map(key => `${key} (${MIMETYPES.VIDEO_CAPTIONS.MIMETYPE_EXT[key]})`).join(', ')\n    ),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking addVideoCaption parameters', { parameters: req.body })\n\n    if (areValidationErrors(req, res)) return cleanUpReqFiles(req)\n    if (!await doesVideoExist(req.params.videoId, res)) return cleanUpReqFiles(req)\n\n    // Check if the user who did the request is able to update the video\n    const user = res.locals.oauth.token.User\n    if (!checkUserCanManageVideo(user, res.locals.videoAll, UserRight.UPDATE_ANY_VIDEO, res)) return cleanUpReqFiles(req)\n\n    return next()\n  }\n]\n\nconst deleteVideoCaptionValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('captionLanguage')\n    .custom(isVideoCaptionLanguageValid).not().isEmpty().withMessage('Should have a valid caption language'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking deleteVideoCaption parameters', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!await doesVideoCaptionExist(res.locals.videoAll, req.params.captionLanguage, res)) return\n\n    // Check if the user who did the request is able to update the video\n    const user = res.locals.oauth.token.User\n    if (!checkUserCanManageVideo(user, res.locals.videoAll, UserRight.UPDATE_ANY_VIDEO, res)) return\n\n    return next()\n  }\n]\n\nconst listVideoCaptionsValidator = [\n  isValidVideoIdParam('videoId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoCaptions parameters', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'only-video')) return\n\n    const video = res.locals.onlyVideo\n\n    if (!await checkCanSeeVideoIfPrivate(req, res, video)) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'Cannot list captions of private/internal/blocklisted video'\n      })\n    }\n\n    return next()\n  }\n]\n\nexport {\n  addVideoCaptionValidator,\n  listVideoCaptionsValidator,\n  deleteVideoCaptionValidator\n}\n", "import express from 'express'\nimport { body, header, param, query, ValidationChain } from 'express-validator'\nimport { isTestInstance } from '@server/helpers/core-utils'\nimport { getResumableUploadPath } from '@server/helpers/upload'\nimport { Redis } from '@server/lib/redis'\nimport { isAbleToUploadVideo } from '@server/lib/user'\nimport { getServerActor } from '@server/models/application/application'\nimport { ExpressPromiseHandler } from '@server/types/express'\nimport { MUserAccountId, MVideoFullLight } from '@server/types/models'\nimport { getAllPrivacies } from '@shared/core-utils'\nimport { VideoInclude } from '@shared/models'\nimport { ServerErrorCode, UserRight, VideoPrivacy } from '../../../../shared'\nimport { HttpStatusCode } from '../../../../shared/models/http/http-error-codes'\nimport {\n  exists,\n  isBooleanValid,\n  isDateValid,\n  isFileFieldValid,\n  isIdValid,\n  isUUIDValid,\n  toArray,\n  toBooleanOrNull,\n  toIntOrNull,\n  toValueOrNull\n} from '../../../helpers/custom-validators/misc'\nimport { isBooleanBothQueryValid, isNumberArray, isStringArray } from '../../../helpers/custom-validators/search'\nimport {\n  isScheduleVideoUpdatePrivacyValid,\n  isVideoCategoryValid,\n  isVideoDescriptionValid,\n  isVideoFileMimeTypeValid,\n  isVideoFileSizeValid,\n  isVideoFilterValid,\n  isVideoImage,\n  isVideoIncludeValid,\n  isVideoLanguageValid,\n  isVideoLicenceValid,\n  isVideoNameValid,\n  isVideoOriginallyPublishedAtValid,\n  isVideoPrivacyValid,\n  isVideoSupportValid,\n  isVideoTagsValid\n} from '../../../helpers/custom-validators/videos'\nimport { cleanUpReqFiles } from '../../../helpers/express-utils'\nimport { getDurationFromVideoFile } from '../../../helpers/ffprobe-utils'\nimport { logger } from '../../../helpers/logger'\nimport { deleteFileAndCatch } from '../../../helpers/utils'\nimport { getVideoWithAttributes } from '../../../helpers/video'\nimport { CONFIG } from '../../../initializers/config'\nimport { CONSTRAINTS_FIELDS, OVERVIEWS } from '../../../initializers/constants'\nimport { isLocalVideoAccepted } from '../../../lib/moderation'\nimport { Hooks } from '../../../lib/plugins/hooks'\nimport { VideoModel } from '../../../models/video/video'\nimport {\n  areValidationErrors,\n  checkCanSeePrivateVideo,\n  checkUserCanManageVideo,\n  doesVideoChannelOfAccountExist,\n  doesVideoExist,\n  doesVideoFileOfVideoExist,\n  isValidVideoIdParam\n} from '../shared'\n\nconst videosAddLegacyValidator = getCommonVideoEditAttributes().concat([\n  body('videofile')\n    .custom((value, { req }) => isFileFieldValid(req.files, 'videofile'))\n    .withMessage('Should have a file'),\n  body('name')\n    .trim()\n    .custom(isVideoNameValid).withMessage(\n      `Should have a video name between ${CONSTRAINTS_FIELDS.VIDEOS.NAME.min} and ${CONSTRAINTS_FIELDS.VIDEOS.NAME.max} characters long`\n    ),\n  body('channelId')\n    .customSanitizer(toIntOrNull)\n    .custom(isIdValid).withMessage('Should have correct video channel id'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videosAdd parameters', { parameters: req.body, files: req.files })\n\n    if (areValidationErrors(req, res)) return cleanUpReqFiles(req)\n\n    const videoFile: express.VideoUploadFile = req.files['videofile'][0]\n    const user = res.locals.oauth.token.User\n\n    if (!await commonVideoChecksPass({ req, res, user, videoFileSize: videoFile.size, files: req.files })) {\n      return cleanUpReqFiles(req)\n    }\n\n    try {\n      if (!videoFile.duration) await addDurationToVideo(videoFile)\n    } catch (err) {\n      logger.error('Invalid input file in videosAddLegacyValidator.', { err })\n\n      res.fail({\n        status: HttpStatusCode.UNPROCESSABLE_ENTITY_422,\n        message: 'Video file unreadable.'\n      })\n      return cleanUpReqFiles(req)\n    }\n\n    if (!await isVideoAccepted(req, res, videoFile)) return cleanUpReqFiles(req)\n\n    return next()\n  }\n])\n\nconst videosResumableUploadIdValidator = [\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    const user = res.locals.oauth.token.User\n    const uploadId = req.query.upload_id\n\n    if (uploadId.startsWith(user.id + '-') !== true) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'You cannot send chunks in another user upload'\n      })\n    }\n\n    return next()\n  }\n]\n\n/**\n * Gets called after the last PUT request\n */\nconst videosAddResumableValidator = [\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    const user = res.locals.oauth.token.User\n    const body: express.CustomUploadXFile<express.UploadXFileMetadata> = req.body\n    const file = { ...body, duration: undefined, path: getResumableUploadPath(body.name), filename: body.metadata.filename }\n    const cleanup = () => deleteFileAndCatch(file.path)\n\n    const uploadId = req.query.upload_id\n    const sessionExists = await Redis.Instance.doesUploadSessionExist(uploadId)\n\n    if (sessionExists) {\n      const sessionResponse = await Redis.Instance.getUploadSession(uploadId)\n\n      if (!sessionResponse) {\n        res.setHeader('Retry-After', 300) // ask to retry after 5 min, knowing the upload_id is kept for up to 15 min after completion\n\n        return res.fail({\n          status: HttpStatusCode.SERVICE_UNAVAILABLE_503,\n          message: 'The upload is already being processed'\n        })\n      }\n\n      if (isTestInstance()) {\n        res.setHeader('x-resumable-upload-cached', 'true')\n      }\n\n      return res.json(sessionResponse)\n    }\n\n    await Redis.Instance.setUploadSession(uploadId)\n\n    if (!await doesVideoChannelOfAccountExist(file.metadata.channelId, user, res)) return cleanup()\n\n    try {\n      if (!file.duration) await addDurationToVideo(file)\n    } catch (err) {\n      logger.error('Invalid input file in videosAddResumableValidator.', { err })\n\n      res.fail({\n        status: HttpStatusCode.UNPROCESSABLE_ENTITY_422,\n        message: 'Video file unreadable.'\n      })\n      return cleanup()\n    }\n\n    if (!await isVideoAccepted(req, res, file)) return cleanup()\n\n    res.locals.videoFileResumable = file\n\n    return next()\n  }\n]\n\n/**\n * File is created in POST initialisation, and its body is saved as a 'metadata' field is saved by uploadx for later use.\n * see https://github.com/kukhariev/node-uploadx/blob/dc9fb4a8ac5a6f481902588e93062f591ec6ef03/packages/core/src/handlers/uploadx.ts\n *\n * Uploadx doesn't use next() until the upload completes, so this middleware has to be placed before uploadx\n * see https://github.com/kukhariev/node-uploadx/blob/dc9fb4a8ac5a6f481902588e93062f591ec6ef03/packages/core/src/handlers/base-handler.ts\n *\n */\nconst videosAddResumableInitValidator = getCommonVideoEditAttributes().concat([\n  body('filename')\n    .isString()\n    .exists()\n    .withMessage('Should have a valid filename'),\n  body('name')\n    .trim()\n    .custom(isVideoNameValid).withMessage(\n      `Should have a video name between ${CONSTRAINTS_FIELDS.VIDEOS.NAME.min} and ${CONSTRAINTS_FIELDS.VIDEOS.NAME.max} characters long`\n    ),\n  body('channelId')\n    .customSanitizer(toIntOrNull)\n    .custom(isIdValid).withMessage('Should have correct video channel id'),\n\n  header('x-upload-content-length')\n    .isNumeric()\n    .exists()\n    .withMessage('Should specify the file length'),\n  header('x-upload-content-type')\n    .isString()\n    .exists()\n    .withMessage('Should specify the file mimetype'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    const videoFileMetadata = {\n      mimetype: req.headers['x-upload-content-type'] as string,\n      size: +req.headers['x-upload-content-length'],\n      originalname: req.body.filename\n    }\n\n    const user = res.locals.oauth.token.User\n    const cleanup = () => cleanUpReqFiles(req)\n\n    logger.debug('Checking videosAddResumableInitValidator parameters and headers', {\n      parameters: req.body,\n      headers: req.headers,\n      files: req.files\n    })\n\n    if (areValidationErrors(req, res)) return cleanup()\n\n    const files = { videofile: [ videoFileMetadata ] }\n    if (!await commonVideoChecksPass({ req, res, user, videoFileSize: videoFileMetadata.size, files })) return cleanup()\n\n    // multer required unsetting the Content-Type, now we can set it for node-uploadx\n    req.headers['content-type'] = 'application/json; charset=utf-8'\n    // place previewfile in metadata so that uploadx saves it in .META\n    if (req.files?.['previewfile']) req.body.previewfile = req.files['previewfile']\n\n    return next()\n  }\n])\n\nconst videosUpdateValidator = getCommonVideoEditAttributes().concat([\n  isValidVideoIdParam('id'),\n\n  body('name')\n    .optional()\n    .trim()\n    .custom(isVideoNameValid).withMessage(\n      `Should have a video name between ${CONSTRAINTS_FIELDS.VIDEOS.NAME.min} and ${CONSTRAINTS_FIELDS.VIDEOS.NAME.max} characters long`\n    ),\n  body('channelId')\n    .optional()\n    .customSanitizer(toIntOrNull)\n    .custom(isIdValid).withMessage('Should have correct video channel id'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videosUpdate parameters', { parameters: req.body })\n\n    if (areValidationErrors(req, res)) return cleanUpReqFiles(req)\n    if (areErrorsInScheduleUpdate(req, res)) return cleanUpReqFiles(req)\n    if (!await doesVideoExist(req.params.id, res)) return cleanUpReqFiles(req)\n\n    // Check if the user who did the request is able to update the video\n    const user = res.locals.oauth.token.User\n    if (!checkUserCanManageVideo(user, res.locals.videoAll, UserRight.UPDATE_ANY_VIDEO, res)) return cleanUpReqFiles(req)\n\n    if (req.body.channelId && !await doesVideoChannelOfAccountExist(req.body.channelId, user, res)) return cleanUpReqFiles(req)\n\n    return next()\n  }\n])\n\nasync function checkVideoFollowConstraints (req: express.Request, res: express.Response, next: express.NextFunction) {\n  const video = getVideoWithAttributes(res)\n\n  // Anybody can watch local videos\n  if (video.isOwned() === true) return next()\n\n  // Logged user\n  if (res.locals.oauth) {\n    // Users can search or watch remote videos\n    if (CONFIG.SEARCH.REMOTE_URI.USERS === true) return next()\n  }\n\n  // Anybody can search or watch remote videos\n  if (CONFIG.SEARCH.REMOTE_URI.ANONYMOUS === true) return next()\n\n  // Check our instance follows an actor that shared this video\n  const serverActor = await getServerActor()\n  if (await VideoModel.checkVideoHasInstanceFollow(video.id, serverActor.id) === true) return next()\n\n  return res.fail({\n    status: HttpStatusCode.FORBIDDEN_403,\n    message: 'Cannot get this video regarding follow constraints',\n    type: ServerErrorCode.DOES_NOT_RESPECT_FOLLOW_CONSTRAINTS,\n    data: {\n      originUrl: video.url\n    }\n  })\n}\n\nconst videosCustomGetValidator = (\n  fetchType: 'for-api' | 'all' | 'only-video' | 'only-immutable-attributes',\n  authenticateInQuery = false\n) => {\n  return [\n    isValidVideoIdParam('id'),\n\n    async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n      logger.debug('Checking videosGet parameters', { parameters: req.params })\n\n      if (areValidationErrors(req, res)) return\n      if (!await doesVideoExist(req.params.id, res, fetchType)) return\n\n      // Controllers does not need to check video rights\n      if (fetchType === 'only-immutable-attributes') return next()\n\n      const video = getVideoWithAttributes(res) as MVideoFullLight\n\n      // Video private or blacklisted\n      if (video.requiresAuth()) {\n        if (await checkCanSeePrivateVideo(req, res, video, authenticateInQuery)) return next()\n\n        return res.fail({\n          status: HttpStatusCode.FORBIDDEN_403,\n          message: 'Cannot get this private/internal or blocklisted video'\n        })\n      }\n\n      // Video is public, anyone can access it\n      if (video.privacy === VideoPrivacy.PUBLIC) return next()\n\n      // Video is unlisted, check we used the uuid to fetch it\n      if (video.privacy === VideoPrivacy.UNLISTED) {\n        if (isUUIDValid(req.params.id)) return next()\n\n        // Don't leak this unlisted video\n        return res.fail({\n          status: HttpStatusCode.NOT_FOUND_404,\n          message: 'Video not found'\n        })\n      }\n    }\n  ]\n}\n\nconst videosGetValidator = videosCustomGetValidator('all')\nconst videosDownloadValidator = videosCustomGetValidator('all', true)\n\nconst videoFileMetadataGetValidator = getCommonVideoEditAttributes().concat([\n  isValidVideoIdParam('id'),\n\n  param('videoFileId')\n    .custom(isIdValid).not().isEmpty().withMessage('Should have a valid videoFileId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videoFileMetadataGet parameters', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoFileOfVideoExist(+req.params.videoFileId, req.params.id, res)) return\n\n    return next()\n  }\n])\n\nconst videosRemoveValidator = [\n  isValidVideoIdParam('id'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videosRemove parameters', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.id, res)) return\n\n    // Check if the user who did the request is able to delete the video\n    if (!checkUserCanManageVideo(res.locals.oauth.token.User, res.locals.videoAll, UserRight.REMOVE_ANY_VIDEO, res)) return\n\n    return next()\n  }\n]\n\nconst videosOverviewValidator = [\n  query('page')\n    .optional()\n    .isInt({ min: 1, max: OVERVIEWS.VIDEOS.SAMPLES_COUNT })\n    .withMessage('Should have a valid pagination'),\n\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    if (areValidationErrors(req, res)) return\n\n    return next()\n  }\n]\n\nfunction getCommonVideoEditAttributes () {\n  return [\n    body('thumbnailfile')\n      .custom((value, { req }) => isVideoImage(req.files, 'thumbnailfile')).withMessage(\n        'This thumbnail file is not supported or too large. Please, make sure it is of the following type: ' +\n        CONSTRAINTS_FIELDS.VIDEOS.IMAGE.EXTNAME.join(', ')\n      ),\n    body('previewfile')\n      .custom((value, { req }) => isVideoImage(req.files, 'previewfile')).withMessage(\n        'This preview file is not supported or too large. Please, make sure it is of the following type: ' +\n        CONSTRAINTS_FIELDS.VIDEOS.IMAGE.EXTNAME.join(', ')\n      ),\n\n    body('category')\n      .optional()\n      .customSanitizer(toIntOrNull)\n      .custom(isVideoCategoryValid).withMessage('Should have a valid category'),\n    body('licence')\n      .optional()\n      .customSanitizer(toIntOrNull)\n      .custom(isVideoLicenceValid).withMessage('Should have a valid licence'),\n    body('language')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoLanguageValid).withMessage('Should have a valid language'),\n    body('nsfw')\n      .optional()\n      .customSanitizer(toBooleanOrNull)\n      .custom(isBooleanValid).withMessage('Should have a valid NSFW attribute'),\n    body('waitTranscoding')\n      .optional()\n      .customSanitizer(toBooleanOrNull)\n      .custom(isBooleanValid).withMessage('Should have a valid wait transcoding attribute'),\n    body('privacy')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoPrivacyValid).withMessage('Should have correct video privacy'),\n    body('description')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoDescriptionValid).withMessage('Should have a valid description'),\n    body('support')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoSupportValid).withMessage('Should have a valid support text'),\n    body('tags')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoTagsValid)\n      .withMessage(\n        `Should have an array of up to ${CONSTRAINTS_FIELDS.VIDEOS.TAGS.max} tags between ` +\n        `${CONSTRAINTS_FIELDS.VIDEOS.TAG.min} and ${CONSTRAINTS_FIELDS.VIDEOS.TAG.max} characters each`\n      ),\n    body('commentsEnabled')\n      .optional()\n      .customSanitizer(toBooleanOrNull)\n      .custom(isBooleanValid).withMessage('Should have comments enabled boolean'),\n    body('downloadEnabled')\n      .optional()\n      .customSanitizer(toBooleanOrNull)\n      .custom(isBooleanValid).withMessage('Should have downloading enabled boolean'),\n    body('originallyPublishedAt')\n      .optional()\n      .customSanitizer(toValueOrNull)\n      .custom(isVideoOriginallyPublishedAtValid).withMessage('Should have a valid original publication date'),\n    body('scheduleUpdate')\n      .optional()\n      .customSanitizer(toValueOrNull),\n    body('scheduleUpdate.updateAt')\n      .optional()\n      .custom(isDateValid).withMessage('Should have a schedule update date that conforms to ISO 8601'),\n    body('scheduleUpdate.privacy')\n      .optional()\n      .customSanitizer(toIntOrNull)\n      .custom(isScheduleVideoUpdatePrivacyValid).withMessage('Should have correct schedule update privacy')\n  ] as (ValidationChain | ExpressPromiseHandler)[]\n}\n\nconst commonVideosFiltersValidator = [\n  query('categoryOneOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isNumberArray).withMessage('Should have a valid one of category array'),\n  query('licenceOneOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isNumberArray).withMessage('Should have a valid one of licence array'),\n  query('languageOneOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isStringArray).withMessage('Should have a valid one of language array'),\n  query('privacyOneOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isNumberArray).withMessage('Should have a valid one of privacy array'),\n  query('tagsOneOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isStringArray).withMessage('Should have a valid one of tags array'),\n  query('tagsAllOf')\n    .optional()\n    .customSanitizer(toArray)\n    .custom(isStringArray).withMessage('Should have a valid all of tags array'),\n  query('nsfw')\n    .optional()\n    .custom(isBooleanBothQueryValid).withMessage('Should have a valid NSFW attribute'),\n  query('isLive')\n    .optional()\n    .customSanitizer(toBooleanOrNull)\n    .custom(isBooleanValid).withMessage('Should have a valid live boolean'),\n  query('filter')\n    .optional()\n    .custom(isVideoFilterValid).withMessage('Should have a valid filter attribute'),\n  query('include')\n    .optional()\n    .custom(isVideoIncludeValid).withMessage('Should have a valid include attribute'),\n  query('isLocal')\n    .optional()\n    .customSanitizer(toBooleanOrNull)\n    .custom(isBooleanValid).withMessage('Should have a valid local boolean'),\n  query('hasHLSFiles')\n    .optional()\n    .customSanitizer(toBooleanOrNull)\n    .custom(isBooleanValid).withMessage('Should have a valid has hls boolean'),\n  query('hasWebtorrentFiles')\n    .optional()\n    .customSanitizer(toBooleanOrNull)\n    .custom(isBooleanValid).withMessage('Should have a valid has webtorrent boolean'),\n  query('skipCount')\n    .optional()\n    .customSanitizer(toBooleanOrNull)\n    .custom(isBooleanValid).withMessage('Should have a valid skip count boolean'),\n  query('search')\n    .optional()\n    .custom(exists).withMessage('Should have a valid search'),\n\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking commons video filters query', { parameters: req.query })\n\n    if (areValidationErrors(req, res)) return\n\n    // FIXME: deprecated in 4.0, to remove\n    {\n      if (req.query.filter === 'all-local') {\n        req.query.include = VideoInclude.NOT_PUBLISHED_STATE\n        req.query.isLocal = true\n        req.query.privacyOneOf = getAllPrivacies()\n      } else if (req.query.filter === 'all') {\n        req.query.include = VideoInclude.NOT_PUBLISHED_STATE\n        req.query.privacyOneOf = getAllPrivacies()\n      } else if (req.query.filter === 'local') {\n        req.query.isLocal = true\n      }\n\n      req.query.filter = undefined\n    }\n\n    const user = res.locals.oauth?.token.User\n\n    if ((!user || user.hasRight(UserRight.SEE_ALL_VIDEOS) !== true)) {\n      if (req.query.include || req.query.privacyOneOf) {\n        return res.fail({\n          status: HttpStatusCode.UNAUTHORIZED_401,\n          message: 'You are not allowed to see all videos.'\n        })\n      }\n    }\n\n    return next()\n  }\n]\n\n// ---------------------------------------------------------------------------\n\nexport {\n  videosAddLegacyValidator,\n  videosAddResumableValidator,\n  videosAddResumableInitValidator,\n  videosResumableUploadIdValidator,\n\n  videosUpdateValidator,\n  videosGetValidator,\n  videoFileMetadataGetValidator,\n  videosDownloadValidator,\n  checkVideoFollowConstraints,\n  videosCustomGetValidator,\n  videosRemoveValidator,\n\n  getCommonVideoEditAttributes,\n\n  commonVideosFiltersValidator,\n\n  videosOverviewValidator\n}\n\n// ---------------------------------------------------------------------------\n\nfunction areErrorsInScheduleUpdate (req: express.Request, res: express.Response) {\n  if (req.body.scheduleUpdate) {\n    if (!req.body.scheduleUpdate.updateAt) {\n      logger.warn('Invalid parameters: scheduleUpdate.updateAt is mandatory.')\n\n      res.fail({ message: 'Schedule update at is mandatory.' })\n      return true\n    }\n  }\n\n  return false\n}\n\nasync function commonVideoChecksPass (parameters: {\n  req: express.Request\n  res: express.Response\n  user: MUserAccountId\n  videoFileSize: number\n  files: express.UploadFilesForCheck\n}): Promise<boolean> {\n  const { req, res, user, videoFileSize, files } = parameters\n\n  if (areErrorsInScheduleUpdate(req, res)) return false\n\n  if (!await doesVideoChannelOfAccountExist(req.body.channelId, user, res)) return false\n\n  if (!isVideoFileMimeTypeValid(files)) {\n    res.fail({\n      status: HttpStatusCode.UNSUPPORTED_MEDIA_TYPE_415,\n      message: 'This file is not supported. Please, make sure it is of the following type: ' +\n               CONSTRAINTS_FIELDS.VIDEOS.EXTNAME.join(', ')\n    })\n    return false\n  }\n\n  if (!isVideoFileSizeValid(videoFileSize.toString())) {\n    res.fail({\n      status: HttpStatusCode.PAYLOAD_TOO_LARGE_413,\n      message: 'This file is too large. It exceeds the maximum file size authorized.',\n      type: ServerErrorCode.MAX_FILE_SIZE_REACHED\n    })\n    return false\n  }\n\n  if (await isAbleToUploadVideo(user.id, videoFileSize) === false) {\n    res.fail({\n      status: HttpStatusCode.PAYLOAD_TOO_LARGE_413,\n      message: 'The user video quota is exceeded with this video.',\n      type: ServerErrorCode.QUOTA_REACHED\n    })\n    return false\n  }\n\n  return true\n}\n\nexport async function isVideoAccepted (\n  req: express.Request,\n  res: express.Response,\n  videoFile: express.VideoUploadFile\n) {\n  // Check we accept this video\n  const acceptParameters = {\n    videoBody: req.body,\n    videoFile,\n    user: res.locals.oauth.token.User\n  }\n  const acceptedResult = await Hooks.wrapFun(\n    isLocalVideoAccepted,\n    acceptParameters,\n    'filter:api.video.upload.accept.result'\n  )\n\n  if (!acceptedResult || acceptedResult.accepted !== true) {\n    logger.info('Refused local video.', { acceptedResult, acceptParameters })\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: acceptedResult.errorMessage || 'Refused local video'\n    })\n    return false\n  }\n\n  return true\n}\n\nasync function addDurationToVideo (videoFile: { path: string, duration?: number }) {\n  const duration: number = await getDurationFromVideoFile(videoFile.path)\n\n  if (isNaN(duration)) throw new Error(`Couldn't get video duration`)\n\n  videoFile.duration = duration\n}\n", "/* eslint-disable @typescript-eslint/no-unused-expressions,@typescript-eslint/require-await */\n\nimport 'mocha'\nimport {\n  buildAbsoluteFixturePath,\n  cleanupTests,\n  createSingleServer,\n  makeDeleteRequest,\n  makeGetRequest,\n  makeUploadRequest,\n  PeerTubeServer,\n  setAccessTokensToServers\n} from '@shared/extra-utils'\nimport { HttpStatusCode, VideoCreateResult, VideoPrivacy } from '@shared/models'\n\ndescribe('Test video captions API validator', function () {\n  const path = '/api/v1/videos/'\n\n  let server: PeerTubeServer\n  let userAccessToken: string\n  let video: VideoCreateResult\n  let privateVideo: VideoCreateResult\n\n  // ---------------------------------------------------------------\n\n  before(async function () {\n    this.timeout(30000)\n\n    server = await createSingleServer(1)\n\n    await setAccessTokensToServers([ server ])\n\n    video = await server.videos.upload()\n    privateVideo = await server.videos.upload({ attributes: { privacy: VideoPrivacy.PRIVATE } })\n\n    {\n      const user = {\n        username: 'user1',\n        password: 'my super password'\n      }\n      await server.users.create({ username: user.username, password: user.password })\n      userAccessToken = await server.login.getAccessToken(user)\n    }\n  })\n\n  describe('When adding video caption', function () {\n    const fields = { }\n    const attaches = {\n      captionfile: buildAbsoluteFixturePath('subtitle-good1.vtt')\n    }\n\n    it('Should fail without a valid uuid', async function () {\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df563d0b06/captions/fr',\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with an unknown id', async function () {\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06/captions/fr',\n        token: server.accessToken,\n        fields,\n        attaches,\n        expectedStatus: 404\n      })\n    })\n\n    it('Should fail with a missing language in path', async function () {\n      const captionPath = path + video.uuid + '/captions'\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: captionPath,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with an unknown language', async function () {\n      const captionPath = path + video.uuid + '/captions/15'\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: captionPath,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail without access token', async function () {\n      const captionPath = path + video.uuid + '/captions/fr'\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: captionPath,\n        fields,\n        attaches,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with a bad access token', async function () {\n      const captionPath = path + video.uuid + '/captions/fr'\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: captionPath,\n        token: 'blabla',\n        fields,\n        attaches,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    // We accept any file now\n    // it('Should fail with an invalid captionfile extension', async function () {\n    //   const attaches = {\n    //     'captionfile': buildAbsoluteFixturePath('subtitle-bad.txt')\n    //   }\n    //\n    //   const captionPath = path + video.uuid + '/captions/fr'\n    //   await makeUploadRequest({\n    //     method: 'PUT',\n    //     url: server.url,\n    //     path: captionPath,\n    //     token: server.accessToken,\n    //     fields,\n    //     attaches,\n    //     expectedStatus: HttpStatusCode.BAD_REQUEST_400\n    //   })\n    // })\n\n    // We don't check the extension yet\n    // it('Should fail with an invalid captionfile extension and octet-stream mime type', async function () {\n    //   await createVideoCaption({\n    //     url: server.url,\n    //     accessToken: server.accessToken,\n    //     language: 'zh',\n    //     videoId: video.uuid,\n    //     fixture: 'subtitle-bad.txt',\n    //     mimeType: 'application/octet-stream',\n    //     expectedStatus: HttpStatusCode.BAD_REQUEST_400\n    //   })\n    // })\n\n    it('Should succeed with a valid captionfile extension and octet-stream mime type', async function () {\n      await server.captions.add({\n        language: 'zh',\n        videoId: video.uuid,\n        fixture: 'subtitle-good.srt',\n        mimeType: 'application/octet-stream'\n      })\n    })\n\n    // We don't check the file validity yet\n    // it('Should fail with an invalid captionfile srt', async function () {\n    //   const attaches = {\n    //     'captionfile': buildAbsoluteFixturePath('subtitle-bad.srt')\n    //   }\n    //\n    //   const captionPath = path + video.uuid + '/captions/fr'\n    //   await makeUploadRequest({\n    //     method: 'PUT',\n    //     url: server.url,\n    //     path: captionPath,\n    //     token: server.accessToken,\n    //     fields,\n    //     attaches,\n    //     expectedStatus: HttpStatusCode.INTERNAL_SERVER_ERROR_500\n    //   })\n    // })\n\n    it('Should success with the correct parameters', async function () {\n      const captionPath = path + video.uuid + '/captions/fr'\n      await makeUploadRequest({\n        method: 'PUT',\n        url: server.url,\n        path: captionPath,\n        token: server.accessToken,\n        fields,\n        attaches,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  describe('When listing video captions', function () {\n    it('Should fail without a valid uuid', async function () {\n      await makeGetRequest({ url: server.url, path: path + '4da6fde3-88f7-4d16-b119-108df563d0b06/captions' })\n    })\n\n    it('Should fail with an unknown id', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06/captions',\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a private video without token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: path + privateVideo.shortUUID + '/captions',\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with another user token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: userAccessToken,\n        path: path + privateVideo.shortUUID + '/captions',\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path: path + video.shortUUID + '/captions', expectedStatus: HttpStatusCode.OK_200 })\n\n      await makeGetRequest({\n        url: server.url,\n        path: path + privateVideo.shortUUID + '/captions',\n        token: server.accessToken,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When deleting video caption', function () {\n    it('Should fail without a valid uuid', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df563d0b06/captions/fr',\n        token: server.accessToken\n      })\n    })\n\n    it('Should fail with an unknown id', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06/captions/fr',\n        token: server.accessToken,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with an invalid language', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06/captions/16',\n        token: server.accessToken\n      })\n    })\n\n    it('Should fail with a missing language', async function () {\n      const captionPath = path + video.shortUUID + '/captions'\n      await makeDeleteRequest({ url: server.url, path: captionPath, token: server.accessToken })\n    })\n\n    it('Should fail with an unknown language', async function () {\n      const captionPath = path + video.shortUUID + '/captions/15'\n      await makeDeleteRequest({ url: server.url, path: captionPath, token: server.accessToken })\n    })\n\n    it('Should fail without access token', async function () {\n      const captionPath = path + video.shortUUID + '/captions/fr'\n      await makeDeleteRequest({ url: server.url, path: captionPath, expectedStatus: HttpStatusCode.UNAUTHORIZED_401 })\n    })\n\n    it('Should fail with a bad access token', async function () {\n      const captionPath = path + video.shortUUID + '/captions/fr'\n      await makeDeleteRequest({ url: server.url, path: captionPath, token: 'coucou', expectedStatus: HttpStatusCode.UNAUTHORIZED_401 })\n    })\n\n    it('Should fail with another user', async function () {\n      const captionPath = path + video.shortUUID + '/captions/fr'\n      await makeDeleteRequest({\n        url: server.url,\n        path: captionPath,\n        token: userAccessToken,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should success with the correct parameters', async function () {\n      const captionPath = path + video.shortUUID + '/captions/fr'\n      await makeDeleteRequest({\n        url: server.url,\n        path: captionPath,\n        token: server.accessToken,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  after(async function () {\n    await cleanupTests([ server ])\n  })\n})\n"], "filenames": ["server/controllers/api/videos/captions.ts", "server/controllers/api/videos/files.ts", "server/middlewares/validators/shared/videos.ts", "server/middlewares/validators/videos/video-captions.ts", "server/middlewares/validators/videos/videos.ts", "server/tests/api/check-params/video-captions.ts"], "buggy_code_start_loc": [51, 13, 1, 3, 54, 14], "buggy_code_end_loc": [52, 19, 124, 68, 333, 208], "fixing_code_start_loc": [51, 13, 1, 3, 53, 14], "fixing_code_end_loc": [52, 22, 151, 84, 326, 235], "type": "CWE-284", "message": "peertube is vulnerable to Improper Access Control", "other": {"cve": {"id": "CVE-2022-0133", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-10T14:12:27.957", "lastModified": "2022-01-14T16:52:36.573", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "peertube is vulnerable to Improper Access Control"}, {"lang": "es", "value": "peertube es vulnerable a un Control de Acceso Inapropiado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:framasoft:peertube:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-01-06", "matchCriteriaId": "E75028A0-3D2E-469D-A871-9565DE7AEEF7"}]}]}], "references": [{"url": "https://github.com/chocobozzz/peertube/commit/795212f7acc690c88c86d0fab8772f6564d59cb8", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/80aabdc1-89fe-47b8-87ca-9d68107fc0b4", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/chocobozzz/peertube/commit/795212f7acc690c88c86d0fab8772f6564d59cb8"}}