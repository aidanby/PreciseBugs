{"buggy_code": ["package org.bouncycastle.crypto.signers;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\n\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DSA;\nimport org.bouncycastle.crypto.params.DSAKeyParameters;\nimport org.bouncycastle.crypto.params.DSAParameters;\nimport org.bouncycastle.crypto.params.DSAPrivateKeyParameters;\nimport org.bouncycastle.crypto.params.DSAPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\n\n/**\n * The Digital Signature Algorithm - as described in \"Handbook of Applied\n * Cryptography\", pages 452 - 453.\n */\npublic class DSASigner\n    implements DSA\n{\n    private final DSAKCalculator kCalculator;\n\n    private DSAKeyParameters key;\n    private SecureRandom    random;\n\n    /**\n     * Default configuration, random K values.\n     */\n    public DSASigner()\n    {\n        this.kCalculator = new RandomDSAKCalculator();\n    }\n\n    /**\n     * Configuration with an alternate, possibly deterministic calculator of K.\n     *\n     * @param kCalculator a K value calculator.\n     */\n    public DSASigner(DSAKCalculator kCalculator)\n    {\n        this.kCalculator = kCalculator;\n    }\n\n    public void init(\n        boolean                 forSigning,\n        CipherParameters        param)\n    {\n        SecureRandom providedRandom = null;\n\n        if (forSigning)\n        {\n            if (param instanceof ParametersWithRandom)\n            {\n                ParametersWithRandom rParam = (ParametersWithRandom)param;\n\n                this.key = (DSAPrivateKeyParameters)rParam.getParameters();\n                providedRandom = rParam.getRandom();\n            }\n            else\n            {\n                this.key = (DSAPrivateKeyParameters)param;\n            }\n        }\n        else\n        {\n            this.key = (DSAPublicKeyParameters)param;\n        }\n\n        this.random = initSecureRandom(forSigning && !kCalculator.isDeterministic(), providedRandom);\n    }\n\n    /**\n     * generate a signature for the given message using the key we were\n     * initialised with. For conventional DSA the message should be a SHA-1\n     * hash of the message of interest.\n     *\n     * @param message the message that will be verified later.\n     */\n    public BigInteger[] generateSignature(\n        byte[] message)\n    {\n        DSAParameters   params = key.getParameters();\n        BigInteger      q = params.getQ();\n        BigInteger      m = calculateE(q, message);\n        BigInteger      x = ((DSAPrivateKeyParameters)key).getX();\n\n        if (kCalculator.isDeterministic())\n        {\n            kCalculator.init(q, x, message);\n        }\n        else\n        {\n            kCalculator.init(q, random);\n        }\n\n        BigInteger  k = kCalculator.nextK();\n\n        BigInteger  r = params.getG().modPow(k, params.getP()).mod(q);\n\n        k = k.modInverse(q).multiply(m.add(x.multiply(r)));\n\n        BigInteger  s = k.mod(q);\n\n        return new BigInteger[]{ r, s };\n    }\n\n    /**\n     * return true if the value r and s represent a DSA signature for\n     * the passed in message for standard DSA the message should be a\n     * SHA-1 hash of the real message to be verified.\n     */\n    public boolean verifySignature(\n        byte[]      message,\n        BigInteger  r,\n        BigInteger  s)\n    {\n        DSAParameters   params = key.getParameters();\n        BigInteger      q = params.getQ();\n        BigInteger      m = calculateE(q, message);\n        BigInteger      zero = BigInteger.valueOf(0);\n\n        if (zero.compareTo(r) >= 0 || q.compareTo(r) <= 0)\n        {\n            return false;\n        }\n\n        if (zero.compareTo(s) >= 0 || q.compareTo(s) <= 0)\n        {\n            return false;\n        }\n\n        BigInteger  w = s.modInverse(q);\n\n        BigInteger  u1 = m.multiply(w).mod(q);\n        BigInteger  u2 = r.multiply(w).mod(q);\n\n        BigInteger p = params.getP();\n        u1 = params.getG().modPow(u1, p);\n        u2 = ((DSAPublicKeyParameters)key).getY().modPow(u2, p);\n\n        BigInteger  v = u1.multiply(u2).mod(p).mod(q);\n\n        return v.equals(r);\n    }\n\n    private BigInteger calculateE(BigInteger n, byte[] message)\n    {\n        if (n.bitLength() >= message.length * 8)\n        {\n            return new BigInteger(1, message);\n        }\n        else\n        {\n            byte[] trunc = new byte[n.bitLength() / 8];\n\n            System.arraycopy(message, 0, trunc, 0, trunc.length);\n\n            return new BigInteger(1, trunc);\n        }\n    }\n\n    protected SecureRandom initSecureRandom(boolean needed, SecureRandom provided)\n    {\n        return !needed ? null : (provided != null) ? provided : new SecureRandom();\n    }\n}\n", "package org.bouncycastle.crypto.test;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\n\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.digests.SHA224Digest;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.digests.SHA3Digest;\nimport org.bouncycastle.crypto.generators.DSAKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.DSAParametersGenerator;\nimport org.bouncycastle.crypto.params.DSAKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.DSAParameterGenerationParameters;\nimport org.bouncycastle.crypto.params.DSAParameters;\nimport org.bouncycastle.crypto.params.DSAPrivateKeyParameters;\nimport org.bouncycastle.crypto.params.DSAPublicKeyParameters;\nimport org.bouncycastle.crypto.params.DSAValidationParameters;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\nimport org.bouncycastle.crypto.signers.DSADigestSigner;\nimport org.bouncycastle.crypto.signers.DSASigner;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.FixedSecureRandom;\nimport org.bouncycastle.util.test.SimpleTest;\nimport org.bouncycastle.util.test.TestRandomBigInteger;\nimport org.bouncycastle.util.test.TestRandomData;\n\n/**\n * Test based on FIPS 186-2, Appendix 5, an example of DSA, and FIPS 168-3 test vectors.\n */\npublic class DSATest\n    extends SimpleTest\n{\n    byte[] k1 = Hex.decode(\"d5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    byte[] k2 = Hex.decode(\"345e8d05c075c3a508df729a1685690e68fcfb8c8117847e89063bca1f85d968fd281540b6e13bd1af989a1fbf17e06462bf511f9d0b140fb48ac1b1baa5bded\");\n\n    SecureRandom    random = new FixedSecureRandom(\n        new FixedSecureRandom.Source[] { new FixedSecureRandom.Data(k1), new FixedSecureRandom.Data(k2) });\n\n    byte[] keyData = Hex.decode(\"b5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    \n    SecureRandom    keyRandom = new FixedSecureRandom(\n                      new FixedSecureRandom.Source[] { new FixedSecureRandom.Data(keyData), new FixedSecureRandom.Data(keyData) });\n\n    BigInteger  pValue = new BigInteger(\"8df2a494492276aa3d25759bb06869cbeac0d83afb8d0cf7cbb8324f0d7882e5d0762fc5b7210eafc2e9adac32ab7aac49693dfbf83724c2ec0736ee31c80291\", 16);\n    BigInteger  qValue = new BigInteger(\"c773218c737ec8ee993b4f2ded30f48edace915f\", 16);\n\n    public String getName()\n    {\n        return \"DSA\";\n    }\n\n    public void performTest()\n    {\n        BigInteger              r = new BigInteger(\"68076202252361894315274692543577577550894681403\");\n        BigInteger              s = new BigInteger(\"1089214853334067536215539335472893651470583479365\");\n        DSAParametersGenerator  pGen = new DSAParametersGenerator();\n\n        pGen.init(512, 80, random);\n\n        DSAParameters           params = pGen.generateParameters();\n        DSAValidationParameters pValid = params.getValidationParameters();\n\n        if (pValid.getCounter() != 105)\n        {\n            fail(\"Counter wrong\");\n        }\n\n        if (!pValue.equals(params.getP()) || !qValue.equals(params.getQ()))\n        {\n            fail(\"p or q wrong\");\n        }\n\n        DSAKeyPairGenerator         dsaKeyGen = new DSAKeyPairGenerator();\n        DSAKeyGenerationParameters  genParam = new DSAKeyGenerationParameters(keyRandom, params);\n\n        dsaKeyGen.init(genParam);\n\n        AsymmetricCipherKeyPair  pair = dsaKeyGen.generateKeyPair();\n\n        ParametersWithRandom param = new ParametersWithRandom(pair.getPrivate(), keyRandom);\n\n        DSASigner dsa = new DSASigner();\n\n        dsa.init(true, param);\n\n        byte[] message = BigIntegers.asUnsignedByteArray(new BigInteger(\"968236873715988614170569073515315707566766479517\"));\n        BigInteger[] sig = dsa.generateSignature(message);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\", r, sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\", s, sig[1]);\n        }\n\n        dsa.init(false, pair.getPublic());\n\n        if (!dsa.verifySignature(message, sig[0], sig[1]))\n        {\n            fail(\"verification fails\");\n        }\n\n        dsa2Test1();\n        dsa2Test2();\n        dsa2Test3();\n        dsa2Test4();\n\n        testDSAsha3(224, new BigInteger(\"613202af2a7f77e02b11b5c3a5311cf6b412192bc0032aac3ec127faebfc6bd0\", 16));\n        testDSAsha3(256, new BigInteger(\"2450755c5e15a691b121bc833b97864e34a61ee025ecec89289c949c1858091e\", 16));\n        testDSAsha3(384, new BigInteger(\"7aad97c0b71bb1e1a6483b6948a03bbe952e4780b0cee699a11731f90d84ddd1\", 16));\n        testDSAsha3(512, new BigInteger(\"725ad64d923c668e64e7c3898b5efde484cab49ce7f98c2885d2a13a9e355ad4\", 16));\n    }\n\n    private void testDSAsha3(int size, BigInteger s)\n    {\n        DSAParameters dsaParams = new DSAParameters(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        BigInteger x = new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16);\n\n        BigInteger y = new BigInteger(\n                    \"2828003D7C747199143C370FDD07A286\" +\n                    \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n                    \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n                    \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n                    \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n                    \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n                    \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n                    \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n                    \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n                    \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n                    \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16);\n\n        DSAPrivateKeyParameters priKey = new DSAPrivateKeyParameters(x, dsaParams);\n        SecureRandom k = new TestRandomBigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\");\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        DSADigestSigner dsa = new DSADigestSigner(new DSASigner(), new SHA3Digest(size));\n\n        dsa.init(true, new ParametersWithRandom(priKey, k));\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.generateSignature();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        DSAPublicKeyParameters pubKey = new DSAPublicKeyParameters(y, dsaParams);\n\n        dsa.init(false, pubKey);\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verifySignature(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void dsa2Test1()\n    {\n        byte[] seed = Hex.decode(\"ED8BEE8D1CB89229D2903CBF0E51EE7377F48698\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator();\n\n        pGen.init(new DSAParameterGenerationParameters(1024, 160, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 5)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"E950511EAB424B9A19A2AEB4E159B7844C589C4F\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"E0A67598CD1B763B\" +\n            \"C98C8ABB333E5DDA0CD3AA0E5E1FB5BA8A7B4EABC10BA338\" +\n            \"FAE06DD4B90FDA70D7CF0CB0C638BE3341BEC0AF8A7330A3\" +\n            \"307DED2299A0EE606DF035177A239C34A912C202AA5F83B9\" +\n            \"C4A7CF0235B5316BFC6EFB9A248411258B30B839AF172440\" +\n            \"F32563056CB67A861158DDD90E6A894C72A5BBEF9E286C6B\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"D29D5121B0423C27\" +\n            \"69AB21843E5A3240FF19CACC792264E3BB6BE4F78EDD1B15\" +\n            \"C4DFF7F1D905431F0AB16790E1F773B5CE01C804E509066A\" +\n            \"9919F5195F4ABC58189FD9FF987389CB5BEDF21B4DAB4F8B\" +\n            \"76A055FFE2770988FE2EC2DE11AD92219F0B351869AC24DA\" +\n            \"3D7BA87011A701CE8EE7BFE49486ED4527B7186CA4610A75\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomBigInteger(\"D0EC4E50BB290A42E9E355C73D8809345DE2E139\", 16), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"25282217F5730501\" +\n            \"DD8DBA3EDFCF349AAFFEC20921128D70FAC44110332201BB\" +\n            \"A3F10986140CBB97C726938060473C8EC97B4731DB004293\" +\n            \"B5E730363609DF9780F8D883D8C4D41DED6A2F1E1BBBDC97\" +\n            \"9E1B9D6D3C940301F4E978D65B19041FCF1E8B518F5C0576\" +\n            \"C770FE5A7A485D8329EE2914A2DE1B5DA4A6128CEAB70F79\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"D0EC4E50BB290A42E9E355C73D8809345DE2E139\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomBigInteger(\"349C55648DCF992F3F33E8026CFAC87C1D2BA075\", 16)));\n\n        byte[] msg = Hex.decode(\"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"636155AC9A4633B4665D179F9E4117DF68601F34\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"6C540B02D9D4852F89DF8CFC99963204F4347704\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n\n    }\n\n    private void dsa2Test2()\n        {\n            byte[] seed = Hex.decode(\"5AFCC1EFFC079A9CCA6ECA86D6E3CC3B18642D9BE1CC6207C84002A9\");\n\n            DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA224Digest());\n\n            pGen.init(new DSAParameterGenerationParameters(2048, 224, 80, new DSATestSecureRandom(seed)));\n\n            DSAParameters params = pGen.generateParameters();\n\n            DSAValidationParameters pv = params.getValidationParameters();\n\n            if (pv.getCounter() != 21)\n            {\n                fail(\"counter incorrect\");\n            }\n\n            if (!Arrays.areEqual(seed, pv.getSeed()))\n            {\n                fail(\"seed incorrect\");\n            }\n\n            if (!params.getQ().equals(new BigInteger(\"90EAF4D1AF0708B1B612FF35E0A2997EB9E9D263C9CE659528945C0D\", 16)))\n            {\n                fail(\"Q incorrect\");\n            }\n\n            if (!params.getP().equals(new BigInteger(\n                \"C196BA05AC29E1F9C3C72D56DFFC6154\" +\n                \"A033F1477AC88EC37F09BE6C5BB95F51C296DD20D1A28A06\" +\n                \"7CCC4D4316A4BD1DCA55ED1066D438C35AEBAABF57E7DAE4\" +\n                \"28782A95ECA1C143DB701FD48533A3C18F0FE23557EA7AE6\" +\n                \"19ECACC7E0B51652A8776D02A425567DED36EABD90CA33A1\" +\n                \"E8D988F0BBB92D02D1D20290113BB562CE1FC856EEB7CDD9\" +\n                \"2D33EEA6F410859B179E7E789A8F75F645FAE2E136D252BF\" +\n                \"FAFF89528945C1ABE705A38DBC2D364AADE99BE0D0AAD82E\" +\n                \"5320121496DC65B3930E38047294FF877831A16D5228418D\" +\n                \"E8AB275D7D75651CEFED65F78AFC3EA7FE4D79B35F62A040\" +\n                \"2A1117599ADAC7B269A59F353CF450E6982D3B1702D9CA83\", 16)))\n            {\n                fail(\"P incorrect\");\n            }\n\n            if (!params.getG().equals(new BigInteger(\n                \"A59A749A11242C58C894E9E5A91804E8\"+\n                \"FA0AC64B56288F8D47D51B1EDC4D65444FECA0111D78F35F\"+\n                \"C9FDD4CB1F1B79A3BA9CBEE83A3F811012503C8117F98E50\"+\n                \"48B089E387AF6949BF8784EBD9EF45876F2E6A5A495BE64B\"+\n                \"6E770409494B7FEE1DBB1E4B2BC2A53D4F893D418B715959\"+\n                \"2E4FFFDF6969E91D770DAEBD0B5CB14C00AD68EC7DC1E574\"+\n                \"5EA55C706C4A1C5C88964E34D09DEB753AD418C1AD0F4FDF\"+\n                \"D049A955E5D78491C0B7A2F1575A008CCD727AB376DB6E69\"+\n                \"5515B05BD412F5B8C2F4C77EE10DA48ABD53F5DD498927EE\"+\n                \"7B692BBBCDA2FB23A516C5B4533D73980B2A3B60E384ED20\"+\n                \"0AE21B40D273651AD6060C13D97FD69AA13C5611A51B9085\", 16)))\n            {\n                fail(\"G incorrect\");\n            }\n\n            DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n            kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"00D0F09ED3E2568F6CADF9224117DA2AEC5A4300E009DE1366023E17\")), params));\n\n            AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n            DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n            DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n            if (!pub.getY().equals(new BigInteger(\n                \"70035C9A3B225B258F16741F3941FBF0\" +\n                \"6F3D056CD7BD864604CBB5EE9DD85304EE8E8E4ABD5E9032\" +\n                \"11DDF25CE149075510ACE166970AFDC7DF552B7244F342FA\" +\n                \"02F7A621405B754909D757F97290E1FE5036E904CF593446\" +\n                \"0C046D95659821E1597ED9F2B1F0E20863A6BBD0CE74DACB\" +\n                \"A5D8C68A90B29C2157CDEDB82EC12B81EE3068F9BF5F7F34\" +\n                \"6ECA41ED174CCCD7D154FA4F42F80FFE1BF46AE9D8125DEB\" +\n                \"5B4BA08A72BDD86596DBEDDC9550FDD650C58F5AE5133509\" +\n                \"A702F79A31ECB490F7A3C5581631F7C5BE4FF7F9E9F27FA3\" +\n                \"90E47347AD1183509FED6FCF198BA9A71AB3335B4F38BE8D\" +\n                \"15496A00B6DC2263E20A5F6B662320A3A1EC033AA61E3B68\", 16)))\n            {\n                fail(\"Y value incorrect\");\n            }\n\n            if (!priv.getX().equals(\n                new BigInteger(\"00D0F09ED3E2568F6CADF9224117DA2AEC5A4300E009DE1366023E17\", 16)))\n            {\n                fail(\"X value incorrect\");\n            }\n\n            DSASigner signer = new DSASigner();\n\n            signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomData(Hex.decode(\"735959CC4463B8B440E407EECA8A473BF6A6D1FE657546F67D401F05\"))));\n\n            byte[] msg = Hex.decode(\"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n            BigInteger[] sig = signer.generateSignature(msg);\n\n            if (!sig[0].equals(new BigInteger(\"4400138D05F9639CAF54A583CAAF25D2B76D0C3EAD752CE17DBC85FE\", 16)))\n            {\n                fail(\"R value incorrect\");\n            }\n\n            if (!sig[1].equals(new BigInteger(\"874D4F12CB13B61732D398445698CFA9D92381D938AA57EE2C9327B3\", 16)))\n            {\n                fail(\"S value incorrect\");\n            }\n\n            signer.init(false, kp.getPublic());\n\n            if (!signer.verifySignature(msg, sig[0], sig[1]))\n            {\n                fail(\"signature not verified\");\n            }\n        }\n\n    private void dsa2Test3()\n    {\n        byte[] seed = Hex.decode(\"4783081972865EA95D43318AB2EAF9C61A2FC7BBF1B772A09017BDF5A58F4FF0\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA256Digest());\n\n        pGen.init(new DSAParameterGenerationParameters(2048, 256, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 12)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n            \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n            \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n            \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n            \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n            \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n            \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n            \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n            \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n            \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n            \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n            \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n            \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n            \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n            \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n            \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n            \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n            \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n            \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n            \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n            \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"2828003D7C747199143C370FDD07A286\" +\n            \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n            \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n            \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n            \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n            \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n            \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n            \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n            \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n            \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n            \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomData(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\"))));\n\n        byte[] msg = Hex.decode(\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"315C875DCD4850E948B8AC42824E9483A32D5BA5ABE0681B9B9448D444F2BE3C\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"89718D12E54A8D9ED066E4A55F7ED5A2229CD23B9A3CEE78F83ED6AA61F6BCB9\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n    }\n\n    private void dsa2Test4()\n    {\n        byte[] seed = Hex.decode(\"193AFCA7C1E77B3C1ECC618C81322E47B8B8B997C9C83515C59CC446C2D9BD47\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA256Digest());\n\n        pGen.init(new DSAParameterGenerationParameters(3072, 256, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 20)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"CFA0478A54717B08CE64805B76E5B14249A77A4838469DF7F7DC987EFCCFB11D\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"90066455B5CFC38F9CAA4A48B4281F292C260FEEF01FD610\" +\n            \"37E56258A7795A1C7AD46076982CE6BB956936C6AB4DCFE0\" +\n            \"5E6784586940CA544B9B2140E1EB523F009D20A7E7880E4E\" +\n            \"5BFA690F1B9004A27811CD9904AF70420EEFD6EA11EF7DA1\" +\n            \"29F58835FF56B89FAA637BC9AC2EFAAB903402229F491D8D\" +\n            \"3485261CD068699B6BA58A1DDBBEF6DB51E8FE34E8A78E54\" +\n            \"2D7BA351C21EA8D8F1D29F5D5D15939487E27F4416B0CA63\" +\n            \"2C59EFD1B1EB66511A5A0FBF615B766C5862D0BD8A3FE7A0\" +\n            \"E0DA0FB2FE1FCB19E8F9996A8EA0FCCDE538175238FC8B0E\" +\n            \"E6F29AF7F642773EBE8CD5402415A01451A840476B2FCEB0\" +\n            \"E388D30D4B376C37FE401C2A2C2F941DAD179C540C1C8CE0\" +\n            \"30D460C4D983BE9AB0B20F69144C1AE13F9383EA1C08504F\" +\n            \"B0BF321503EFE43488310DD8DC77EC5B8349B8BFE97C2C56\" +\n            \"0EA878DE87C11E3D597F1FEA742D73EEC7F37BE43949EF1A\" +\n            \"0D15C3F3E3FC0A8335617055AC91328EC22B50FC15B941D3\" +\n            \"D1624CD88BC25F3E941FDDC6200689581BFEC416B4B2CB73\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"5E5CBA992E0A680D885EB903AEA78E4A45A469103D448EDE\" +\n            \"3B7ACCC54D521E37F84A4BDD5B06B0970CC2D2BBB715F7B8\" +\n            \"2846F9A0C393914C792E6A923E2117AB805276A975AADB52\" +\n            \"61D91673EA9AAFFEECBFA6183DFCB5D3B7332AA19275AFA1\" +\n            \"F8EC0B60FB6F66CC23AE4870791D5982AAD1AA9485FD8F4A\" +\n            \"60126FEB2CF05DB8A7F0F09B3397F3937F2E90B9E5B9C9B6\" +\n            \"EFEF642BC48351C46FB171B9BFA9EF17A961CE96C7E7A7CC\" +\n            \"3D3D03DFAD1078BA21DA425198F07D2481622BCE45969D9C\" +\n            \"4D6063D72AB7A0F08B2F49A7CC6AF335E08C4720E31476B6\" +\n            \"7299E231F8BD90B39AC3AE3BE0C6B6CACEF8289A2E2873D5\" +\n            \"8E51E029CAFBD55E6841489AB66B5B4B9BA6E2F784660896\" +\n            \"AFF387D92844CCB8B69475496DE19DA2E58259B090489AC8\" +\n            \"E62363CDF82CFD8EF2A427ABCD65750B506F56DDE3B98856\" +\n            \"7A88126B914D7828E2B63A6D7ED0747EC59E0E0A23CE7D8A\" +\n            \"74C1D2C2A7AFB6A29799620F00E11C33787F7DED3B30E1A2\" +\n            \"2D09F1FBDA1ABBBFBF25CAE05A13F812E34563F99410E73B\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"3ABC1587297CE7B9EA1AD6651CF2BC4D7F92ED25CABC8553F567D1B40EBB8764\")), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"8B891C8692D3DE875879390F2698B26FBECCA6B075535DCE\" +\n            \"6B0C862577F9FA0DEF6074E7A7624121224A595896ABD4CD\" +\n            \"A56B2CEFB942E025D2A4282FFAA98A48CDB47E1A6FCB5CFB\" +\n            \"393EF35AF9DF913102BB303C2B5C36C3F8FC04ED7B8B69FE\" +\n            \"FE0CF3E1FC05CFA713B3435B2656E913BA8874AEA9F93600\" +\n            \"6AEB448BCD005D18EC3562A33D04CF25C8D3D69844343442\" +\n            \"FA3DB7DE618C5E2DA064573E61E6D5581BFB694A23AC87FD\" +\n            \"5B52D62E954E1376DB8DDB524FFC0D469DF978792EE44173\" +\n            \"8E5DB05A7DC43E94C11A2E7A4FBE383071FA36D2A7EC8A93\" +\n            \"88FE1C4F79888A99D3B6105697C2556B79BB4D7E781CEBB3\" +\n            \"D4866AD825A5E830846072289FDBC941FA679CA82F5F78B7\" +\n            \"461B2404DB883D215F4E0676CF5493950AC5591697BFEA8D\" +\n            \"1EE6EC016B89BA51CAFB5F9C84C989FA117375E94578F28B\" +\n            \"E0B34CE0545DA46266FD77F62D8F2CEE92AB77012AFEBC11\" +\n            \"008985A821CD2D978C7E6FE7499D1AAF8DE632C21BB48CA5\" +\n            \"CBF9F31098FD3FD3854C49A65D9201744AACE540354974F9\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"3ABC1587297CE7B9EA1AD6651CF2BC4D7F92ED25CABC8553F567D1B40EBB8764\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomData(Hex.decode(\"A6902C1E6E3943C5628061588A8B007BCCEA91DBF12915483F04B24AB0678BEE\"))));\n\n        byte[] msg = Hex.decode(\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"5F184E645A38BE8FB4A6871B6503A9D12924C7ABE04B71410066C2ECA6E3BE3E\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"91EB0C7BA3D4B9B60B825C3D9F2CADA8A2C9D7723267B033CBCDCF8803DB9C18\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        runTest(new DSATest());\n    }\n\n    private class DSATestSecureRandom\n        extends TestRandomData\n    {\n        private boolean first = true;\n\n        public DSATestSecureRandom(byte[] value)\n        {\n            super(value);\n        }\n\n       public void nextBytes(byte[] bytes)\n       {\n           if (first)\n           {\n               super.nextBytes(bytes);\n               first = false;\n           }\n           else\n           {\n               bytes[bytes.length - 1] = 2;\n           }\n       }\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameterGenerator;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.spec.DSAParameterSpec;\nimport java.security.spec.DSAPrivateKeySpec;\nimport java.security.spec.DSAPublicKeySpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.eac.EACObjectIdentifiers;\nimport org.bouncycastle.asn1.nist.NISTNamedCurves;\nimport org.bouncycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.X9ECParameters;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.crypto.params.DSAParameters;\nimport org.bouncycastle.crypto.params.DSAPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ECDomainParameters;\nimport org.bouncycastle.crypto.signers.DSASigner;\nimport org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.ECNamedCurveGenParameterSpec;\nimport org.bouncycastle.jce.spec.ECParameterSpec;\nimport org.bouncycastle.jce.spec.ECPrivateKeySpec;\nimport org.bouncycastle.jce.spec.ECPublicKeySpec;\nimport org.bouncycastle.math.ec.ECCurve;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.FixedSecureRandom;\nimport org.bouncycastle.util.test.SimpleTest;\nimport org.bouncycastle.util.test.TestRandomBigInteger;\nimport org.bouncycastle.util.test.TestRandomData;\n\npublic class DSATest\n    extends SimpleTest\n{\n    byte[] k1 = Hex.decode(\"d5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    byte[] k2 = Hex.decode(\"345e8d05c075c3a508df729a1685690e68fcfb8c8117847e89063bca1f85d968fd281540b6e13bd1af989a1fbf17e06462bf511f9d0b140fb48ac1b1baa5bded\");\n\n    SecureRandom    random = new FixedSecureRandom(new byte[][] { k1, k2 });\n\n    // DSA modified signatures, courtesy of the Google security team\n    static final DSAPrivateKeySpec PRIVATE_KEY = new DSAPrivateKeySpec(\n        // x\n        new BigInteger(\n            \"15382583218386677486843706921635237927801862255437148328980464126979\"),\n        // p\n        new BigInteger(\n            \"181118486631420055711787706248812146965913392568235070235446058914\"\n            + \"1170708161715231951918020125044061516370042605439640379530343556\"\n            + \"4101919053459832890139496933938670005799610981765220283775567361\"\n            + \"4836626483403394052203488713085936276470766894079318754834062443\"\n            + \"1033792580942743268186462355159813630244169054658542719322425431\"\n            + \"4088256212718983105131138772434658820375111735710449331518776858\"\n            + \"7867938758654181244292694091187568128410190746310049564097068770\"\n            + \"8161261634790060655580211122402292101772553741704724263582994973\"\n            + \"9109274666495826205002104010355456981211025738812433088757102520\"\n            + \"562459649777989718122219159982614304359\"),\n        // q\n        new BigInteger(\n            \"19689526866605154788513693571065914024068069442724893395618704484701\"),\n        // g\n        new BigInteger(\n            \"2859278237642201956931085611015389087970918161297522023542900348\"\n            + \"0877180630984239764282523693409675060100542360520959501692726128\"\n            + \"3149190229583566074777557293475747419473934711587072321756053067\"\n            + \"2532404847508798651915566434553729839971841903983916294692452760\"\n            + \"2490198571084091890169933809199002313226100830607842692992570749\"\n            + \"0504363602970812128803790973955960534785317485341020833424202774\"\n            + \"0275688698461842637641566056165699733710043802697192696426360843\"\n            + \"1736206792141319514001488556117408586108219135730880594044593648\"\n            + \"9237302749293603778933701187571075920849848690861126195402696457\"\n            + \"4111219599568903257472567764789616958430\"));\n\n    static final DSAPublicKeySpec PUBLIC_KEY = new DSAPublicKeySpec(\n        new BigInteger(\n            \"3846308446317351758462473207111709291533523711306097971550086650\"\n            + \"2577333637930103311673872185522385807498738696446063139653693222\"\n            + \"3528823234976869516765207838304932337200968476150071617737755913\"\n            + \"3181601169463467065599372409821150709457431511200322947508290005\"\n            + \"1780020974429072640276810306302799924668893998032630777409440831\"\n            + \"4314588994475223696460940116068336991199969153649625334724122468\"\n            + \"7497038281983541563359385775312520539189474547346202842754393945\"\n            + \"8755803223951078082197762886933401284142487322057236814878262166\"\n            + \"5072306622943221607031324846468109901964841479558565694763440972\"\n            + \"5447389416166053148132419345627682740529\"),\n         PRIVATE_KEY.getP(),\n         PRIVATE_KEY.getQ(),\n         PRIVATE_KEY.getG());\n\n    // The following test vectors check for signature malleability and bugs. That means the test\n    // vectors are derived from a valid signature by modifying the ASN encoding. A correct\n    // implementation of DSA should only accept correct DER encoding and properly handle the others.\n    // Allowing alternative BER encodings is in many cases benign. An example where this kind of\n    // signature malleability was a problem: https://en.bitcoin.it/wiki/Transaction_Malleability\n    static final String[] MODIFIED_SIGNATURES  = {\n        \"303e02811c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303f0282001c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021d001e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd02811d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303f021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd0282001d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021e0000ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"30813d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"3082003d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9ef4\"\n        + \"1dd424a4e1c8f16967cf3365813fe87862360000\",\n        \"3040021c57b10411b54ab248af03d8f2456676ebc6d3db5f1081492ac87e9ca8021d00942b117051d7d9d107fc42cac9c5a36a1fd7f0f8916ccca86cec4ed3040100\",\n        \"303e021c57b10411b54ab248af03d8f2456676ebc6d3db5f1081492ac87e9ca802811d00942b117051d7d9d107fc42cac9c5a36a1fd7f0f8916ccca86cec4ed3\"\n    };\n\n    private void testModified()\n        throws Exception\n    {\n        KeyFactory kFact = KeyFactory.getInstance(\"DSA\", \"BC\");\n        PublicKey pubKey = kFact.generatePublic(PUBLIC_KEY);\n        Signature sig = Signature.getInstance(\"DSA\", \"BC\");\n\n        for (int i = 0; i != MODIFIED_SIGNATURES.length; i++)\n        {\n            sig.initVerify(pubKey);\n\n            sig.update(Strings.toByteArray(\"Hello\"));\n\n            boolean failed;\n\n            try\n            {\n                failed = !sig.verify(Hex.decode(MODIFIED_SIGNATURES[i]));\n            }\n            catch (SignatureException e)\n            {\n                failed = true;\n            }\n\n            isTrue(\"sig verified when shouldn't\", failed);\n        }\n    }\n\n    private void testCompat()\n        throws Exception\n    {\n        if (Security.getProvider(\"SUN\") == null)\n        {\n            return;\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"SUN\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"SUN\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        g.initialize(512, new SecureRandom());\n        \n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        //\n        // sign SUN - verify with BC \n        //\n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"SUN -> BC verification failed\");\n        }\n        \n        //\n        // sign BC - verify with SUN\n        //\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"SUN\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"BC -> SUN verification failed\");\n        }\n\n        //\n        // key encoding test - BC decoding Sun keys\n        //\n        KeyFactory          f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec  x509s = new X509EncodedKeySpec(vKey.getEncoded());\n\n        DSAPublicKey        k1 = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        PKCS8EncodedKeySpec  pkcs8 = new PKCS8EncodedKeySpec(sKey.getEncoded());\n\n        DSAPrivateKey        k2 = (DSAPrivateKey)f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n        \n        //\n        // key decoding test - SUN decoding BC keys\n        // \n        f = KeyFactory.getInstance(\"DSA\", \"SUN\");\n        x509s = new X509EncodedKeySpec(k1.getEncoded());\n        \n        vKey = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        pkcs8 = new PKCS8EncodedKeySpec(k2.getEncoded());\n        sKey = f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n    }\n\n    private void testNullParameters()\n        throws Exception\n    {\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec x509s = new X509EncodedKeySpec(new SubjectPublicKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_dsa), new ASN1Integer(10001)).getEncoded());\n\n        DSAPublicKey key1 = (DSAPublicKey)f.generatePublic(x509s);\n        DSAPublicKey key2 = (DSAPublicKey)f.generatePublic(x509s);\n\n        isTrue(\"parameters not absent\", key1.getParams() == null && key2.getParams() == null);\n        isTrue(\"hashCode mismatch\", key1.hashCode() == key2.hashCode());\n        isTrue(\"not equal\", key1.equals(key2));\n        isTrue(\"encoding mismatch\", Arrays.areEqual(x509s.getEncoded(), key1.getEncoded()));\n    }\n\n    private void testValidate()\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        try\n        {\n            f.generatePublic(new DSAPublicKeySpec(BigInteger.valueOf(1), dsaParams.getP(), dsaParams.getG(), dsaParams.getQ()));\n\n            fail(\"no exception\");\n        }\n        catch (Exception e)\n        {\n            isTrue(\"mismatch\", \"invalid KeySpec: y value does not appear to be in correct group\".equals(e.getMessage()));\n        }\n    }\n\n    private void testNONEwithDSA()\n        throws Exception\n    {\n        byte[] dummySha1 = Hex.decode(\"01020304050607080910111213141516\");\n\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n\n        kpGen.initialize(512);\n\n        KeyPair          kp = kpGen.generateKeyPair();\n\n        Signature        sig = Signature.getInstance(\"NONEwithDSA\", \"BC\");\n\n        sig.initSign(kp.getPrivate());\n\n        sig.update(dummySha1);\n\n        byte[] sigBytes = sig.sign();\n\n        sig.initVerify(kp.getPublic());\n\n        sig.update(dummySha1);\n\n        sig.verify(sigBytes);\n\n        // reset test\n\n        sig.update(dummySha1);\n\n        if (!sig.verify(sigBytes))\n        {\n            fail(\"NONEwithDSA failed to reset\");\n        }\n\n        // lightweight test\n        DSAPublicKey  key = (DSAPublicKey)kp.getPublic();\n        DSAParameters params = new DSAParameters(key.getParams().getP(), key.getParams().getQ(), key.getParams().getG());\n        DSAPublicKeyParameters keyParams = new DSAPublicKeyParameters(key.getY(), params);\n        DSASigner signer = new DSASigner();\n        ASN1Sequence derSig = ASN1Sequence.getInstance(ASN1Primitive.fromByteArray(sigBytes));\n\n        signer.init(false, keyParams);\n\n        if (!signer.verifySignature(dummySha1, ASN1Integer.getInstance(derSig.getObjectAt(0)).getValue(), ASN1Integer.getInstance(derSig.getObjectAt(1)).getValue()))\n        {\n            fail(\"NONEwithDSA not really NONE!\");\n        }\n    }\n\n    private void checkPublic(DSAPublicKey k1, PublicKey vKey)\n    {\n        if (!k1.getY().equals(((DSAPublicKey)vKey).getY()))\n        {\n            fail(\"public number not decoded properly\");\n        }\n\n        if (!k1.getParams().getG().equals(((DSAPublicKey)vKey).getParams().getG()))\n        {\n            fail(\"public generator not decoded properly\");\n        }\n\n        if (!k1.getParams().getP().equals(((DSAPublicKey)vKey).getParams().getP()))\n        {\n            fail(\"public p value not decoded properly\");\n        }\n\n        if (!k1.getParams().getQ().equals(((DSAPublicKey)vKey).getParams().getQ()))\n        {\n            fail(\"public q value not decoded properly\");\n        }\n    }\n\n    private void checkPrivateKey(DSAPrivateKey k2, PrivateKey sKey)\n    {\n        if (!k2.getX().equals(((DSAPrivateKey)sKey).getX()))\n        {\n            fail(\"private number not decoded properly\");\n        }\n\n        if (!k2.getParams().getG().equals(((DSAPrivateKey)sKey).getParams().getG()))\n        {\n            fail(\"private generator not decoded properly\");\n        }\n\n        if (!k2.getParams().getP().equals(((DSAPrivateKey)sKey).getParams().getP()))\n        {\n            fail(\"private p value not decoded properly\");\n        }\n\n        if (!k2.getParams().getQ().equals(((DSAPrivateKey)sKey).getParams().getQ()))\n        {\n            fail(\"private q value not decoded properly\");\n        }\n    }\n\n    private Object serializeDeserialize(Object o)\n        throws Exception\n    {\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ObjectOutputStream oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(o);\n        oOut.close();\n\n        ObjectInputStream oIn = new ObjectInputStream(new ByteArrayInputStream(bOut.toByteArray()));\n\n        return oIn.readObject();\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.3.2, Page 155, ECDSA over the field Fp<br>\n     * an example with 239 bit prime\n     */\n    private void testECDSA239bitPrime()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"308636143175167811492622547300668018854959378758531778147462058306432176\");\n        BigInteger s = new BigInteger(\"323813553209797357708078776831250505931891051755007842781978505179448783\");\n\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n        \n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n        \n        \n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n        \n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n        \n        Signature           sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n        \n        sgr.initSign(sKey, k);\n        \n        byte[] message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n        \n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n        \n        sgr.initVerify(vKey);\n        \n        sgr.update(message);\n        \n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n        \n        BigInteger[]  sig = derDecode(sigBytes);\n        \n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + r + Strings.lineSeparator()\n                    + \" got      : \" + sig[0]);\n        }\n        \n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + s + Strings.lineSeparator()\n                    + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testNONEwithECDSA239bitPrime()\n        throws Exception\n    {\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n\n        Signature           sgr = Signature.getInstance(\"NONEwithECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n\n        byte[] message = \"abc\".getBytes();\n        byte[] sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e64cb19604be06c57e761b3de5518f71de0f6e0cd2df677cec8a6ffcb690d\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"abcdefghijklmnopqrstuvwxyz\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e43fd65b3363d76aabef8630572257dbb67c82818ad9fad31256539b1b02c\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"a very very long message gauranteed to cause an overflow\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e7d5be84b22937a1691859a3c6fe45ed30b108574431d01b34025825ec17a\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n    }\n\n    private void testECDSAP256sha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        X9ECParameters p = NISTNamedCurves.getByName(\"P-256\");\n        KeyFactory ecKeyFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        ECDomainParameters params = new ECDomainParameters(p.getCurve(), p.getG(), p.getN(), p.getH());\n\n        ECCurve curve = p.getCurve();\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                p.getG(), // G\n                p.getN()); // n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"20186677036482506117540275567393538695075300175221296989956723148347484984008\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n            params.getCurve().decodePoint(Hex.decode(\"03596375E6CE57E0F20294FC46BDFCFD19A39F8161B58695B3EC5B3D16427C274D\")), // Q\n            spec);\n\n        doEcDsaTest(\"SHA3-\" + size + \"withECDSA\", s, ecKeyFact, pubKey, priKey);\n        doEcDsaTest(sigOid.getId(), s, ecKeyFact, pubKey, priKey);\n    }\n\n    private void doEcDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, ECPublicKeySpec pubKey, ECPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"97354732615802252173078420023658453040116611318111190383344590814578738210384\");\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void testDSAsha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        BigInteger x = new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16);\n\n        BigInteger y = new BigInteger(\n                    \"2828003D7C747199143C370FDD07A286\" +\n                    \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n                    \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n                    \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n                    \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n                    \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n                    \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n                    \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n                    \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n                    \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n                    \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16);\n\n        DSAPrivateKeySpec priKey = new DSAPrivateKeySpec(\n                x, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        DSAPublicKeySpec pubKey = new DSAPublicKeySpec(\n            y, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        KeyFactory dsaKeyFact = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        doDsaTest(\"SHA3-\" + size + \"withDSA\", s, dsaKeyFact, pubKey, priKey);\n        doDsaTest(sigOid.getId(), s, dsaKeyFact, pubKey, priKey);\n    }\n\n    private void doDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, DSAPublicKeySpec pubKey, DSAPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void checkMessage(Signature sgr, PrivateKey sKey, PublicKey vKey, byte[] message, byte[] sig)\n        throws InvalidKeyException, SignatureException\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        if (!Arrays.areEqual(sigBytes, sig))\n        {\n            fail(new String(message) + \" signature incorrect\");\n        }\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(new String(message) + \" verification failed\");\n        }\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.2.1, Page 100, ECDSA over the field F2m<br>\n     * an example with 191 bit binary field\n     */\n    private void testECDSA239bitBinary()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"21596333210419611985018340039034612628818151486841789642455876922391552\");\n        BigInteger s = new BigInteger(\"197030374000731686738334997654997227052849804072198819102649413465737174\");\n    \n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n    \n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n    \n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n        \n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n    \n        Signature   sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n       \n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n\n        BigInteger[]  sig = derDecode(sigBytes);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r + Strings.lineSeparator()\n                + \" got      : \" + sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s + Strings.lineSeparator()\n                + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testECDSA239bitBinary(String algorithm, ASN1ObjectIdentifier oid)\n        throws Exception\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n\n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n\n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n\n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n\n        Signature   sgr = Signature.getInstance(algorithm, \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        sgr = Signature.getInstance(oid.getId(), \"BC\");\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC RIPEMD160 verification failed\");\n        }\n    }\n\n    private void testGeneration()\n        throws Exception\n    {\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n\n        // test exception\n        //\n        try\n        {\n            g.initialize(513, new SecureRandom());\n\n            fail(\"illegal parameter 513 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(510, new SecureRandom());\n\n            fail(\"illegal parameter 510 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(1025, new SecureRandom());\n\n            fail(\"illegal parameter 1025 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        g.initialize(512, new SecureRandom());\n\n        KeyPair p = g.generateKeyPair();\n\n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        DSAPublicKey k1 = (DSAPublicKey)serializeDeserialize(vKey);\n\n        checkPublic(k1, vKey);\n\n        checkEquals(k1, vKey);\n\n        DSAPrivateKey k2 = (DSAPrivateKey)serializeDeserialize(sKey);\n\n        checkPrivateKey(k2, sKey);\n\n        checkEquals(k2, sKey);\n\n        if (!(k2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n\n        //\n        // ECDSA Fp generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        ECCurve curve = new ECCurve.Fp(\n            new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n            new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n            new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n            new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        PublicKey eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        PrivateKey eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        // Named curve parameter\n        g.initialize(new ECNamedCurveGenParameterSpec(\"P-256\"), new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        //\n        // ECDSA F2m generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        curve = new ECCurve.F2m(\n                239, // m\n                36, // k\n                new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n                new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n        \n        ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n        \n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        if (!(eck2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n    }\n\n    private void checkEquals(Object o1, Object o2)\n    {\n        if (!o1.equals(o2))\n        {\n            fail(\"comparison test failed\");\n        }\n\n        if (o1.hashCode() != o2.hashCode())\n        {\n            fail(\"hashCode test failed\");\n        }\n    }\n    \n    private void testParameters()\n        throws Exception\n    {\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(512, random);\n        AlgorithmParameters params = a.generateParameters();\n        \n        byte[] encodeParams = params.getEncoded();\n        \n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n        \n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n        \n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n        \n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n        \n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new SecureRandom());\n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    private void testDSA2Parameters()\n        throws Exception\n    {\n        byte[] seed = Hex.decode(\"4783081972865EA95D43318AB2EAF9C61A2FC7BBF1B772A09017BDF5A58F4FF0\");\n\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(2048, new DSATestSecureRandom(seed));\n        AlgorithmParameters params = a.generateParameters();\n\n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n\n        if (!dsaP.getQ().equals(new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!dsaP.getP().equals(new BigInteger(\n            \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n            \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n            \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n            \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n            \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n            \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n            \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n            \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n            \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n            \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n            \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!dsaP.getG().equals(new BigInteger(\n            \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n            \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n            \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n            \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n            \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n            \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n            \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n            \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n            \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n            \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n            \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new TestRandomBigInteger(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")));\n        KeyPair p = g.generateKeyPair();\n\n        DSAPrivateKey  sKey = (DSAPrivateKey)p.getPrivate();\n        DSAPublicKey   vKey = (DSAPublicKey)p.getPublic();\n\n        if (!vKey.getY().equals(new BigInteger(\n            \"2828003D7C747199143C370FDD07A286\" +\n            \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n            \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n            \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n            \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n            \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n            \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n            \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n            \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n            \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n            \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!sKey.getX().equals(\n            new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        byte[] encodeParams = params.getEncoded();\n\n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n\n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n\n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        testCompat();\n        testNONEwithDSA();\n\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_224, 224, new BigInteger(\"613202af2a7f77e02b11b5c3a5311cf6b412192bc0032aac3ec127faebfc6bd0\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_256, 256, new BigInteger(\"2450755c5e15a691b121bc833b97864e34a61ee025ecec89289c949c1858091e\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_384, 384, new BigInteger(\"7aad97c0b71bb1e1a6483b6948a03bbe952e4780b0cee699a11731f90d84ddd1\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_512, 512, new BigInteger(\"725ad64d923c668e64e7c3898b5efde484cab49ce7f98c2885d2a13a9e355ad4\", 16));\n\n        testECDSA239bitPrime();\n        testNONEwithECDSA239bitPrime();\n        testECDSA239bitBinary();\n        testECDSA239bitBinary(\"RIPEMD160withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithRipemd160);\n        testECDSA239bitBinary(\"SHA1withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithSha1);\n        testECDSA239bitBinary(\"SHA224withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA224);\n        testECDSA239bitBinary(\"SHA256withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA256);\n        testECDSA239bitBinary(\"SHA384withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA384);\n        testECDSA239bitBinary(\"SHA512withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA512);\n        testECDSA239bitBinary(\"SHA1withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_1);\n        testECDSA239bitBinary(\"SHA224withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_224);\n        testECDSA239bitBinary(\"SHA256withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_256);\n        testECDSA239bitBinary(\"SHA384withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_384);\n        testECDSA239bitBinary(\"SHA512withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_512);\n\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_224, 224, new BigInteger(\"84d7d8e68e405064109cd9fc3e3026d74d278aada14ce6b7a9dd0380c154dc94\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_256, 256, new BigInteger(\"99a43bdab4af989aaf2899079375642f2bae2dce05bcd8b72ec8c4a8d9a143f\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_384, 384, new BigInteger(\"aa27726509c37aaf601de6f7e01e11c19add99530c9848381c23365dc505b11a\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_512, 512, new BigInteger(\"f8306b57a1f5068bf12e53aabaae39e2658db39bc56747eaefb479995130ad16\", 16));\n\n        testGeneration();\n        testParameters();\n        testDSA2Parameters();\n        testNullParameters();\n        testValidate();\n        testModified();\n    }\n\n    protected BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ByteArrayInputStream    bIn = new ByteArrayInputStream(encoding);\n        ASN1InputStream         aIn = new ASN1InputStream(bIn);\n        ASN1Sequence            s = (ASN1Sequence)aIn.readObject();\n\n        BigInteger[]            sig = new BigInteger[2];\n\n        sig[0] = ((ASN1Integer)s.getObjectAt(0)).getValue();\n        sig[1] = ((ASN1Integer)s.getObjectAt(1)).getValue();\n\n        return sig;\n    }\n\n    public String getName()\n    {\n        return \"DSA/ECDSA\";\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new DSATest());\n    }\n\n    private class DSATestSecureRandom\n        extends TestRandomData\n    {\n        private boolean first = true;\n\n        public DSATestSecureRandom(byte[] value)\n        {\n            super(value);\n        }\n\n       public void nextBytes(byte[] bytes)\n       {\n           if (first)\n           {\n               super.nextBytes(bytes);\n               first = false;\n           }\n           else\n           {\n               bytes[bytes.length - 1] = 2;\n           }\n       }\n    }\n}\n"], "fixing_code": ["package org.bouncycastle.crypto.signers;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\n\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DSA;\nimport org.bouncycastle.crypto.params.DSAKeyParameters;\nimport org.bouncycastle.crypto.params.DSAParameters;\nimport org.bouncycastle.crypto.params.DSAPrivateKeyParameters;\nimport org.bouncycastle.crypto.params.DSAPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\n\n/**\n * The Digital Signature Algorithm - as described in \"Handbook of Applied\n * Cryptography\", pages 452 - 453.\n */\npublic class DSASigner\n    implements DSA\n{\n    private final DSAKCalculator kCalculator;\n\n    private DSAKeyParameters key;\n    private SecureRandom    random;\n\n    /**\n     * Default configuration, random K values.\n     */\n    public DSASigner()\n    {\n        this.kCalculator = new RandomDSAKCalculator();\n    }\n\n    /**\n     * Configuration with an alternate, possibly deterministic calculator of K.\n     *\n     * @param kCalculator a K value calculator.\n     */\n    public DSASigner(DSAKCalculator kCalculator)\n    {\n        this.kCalculator = kCalculator;\n    }\n\n    public void init(\n        boolean                 forSigning,\n        CipherParameters        param)\n    {\n        SecureRandom providedRandom = null;\n\n        if (forSigning)\n        {\n            if (param instanceof ParametersWithRandom)\n            {\n                ParametersWithRandom rParam = (ParametersWithRandom)param;\n\n                this.key = (DSAPrivateKeyParameters)rParam.getParameters();\n                providedRandom = rParam.getRandom();\n            }\n            else\n            {\n                this.key = (DSAPrivateKeyParameters)param;\n            }\n        }\n        else\n        {\n            this.key = (DSAPublicKeyParameters)param;\n        }\n\n        this.random = initSecureRandom(forSigning && !kCalculator.isDeterministic(), providedRandom);\n    }\n\n    /**\n     * generate a signature for the given message using the key we were\n     * initialised with. For conventional DSA the message should be a SHA-1\n     * hash of the message of interest.\n     *\n     * @param message the message that will be verified later.\n     */\n    public BigInteger[] generateSignature(\n        byte[] message)\n    {\n        DSAParameters   params = key.getParameters();\n        BigInteger      q = params.getQ();\n        BigInteger      m = calculateE(q, message);\n        BigInteger      x = ((DSAPrivateKeyParameters)key).getX();\n\n        if (kCalculator.isDeterministic())\n        {\n            kCalculator.init(q, x, message);\n        }\n        else\n        {\n            kCalculator.init(q, random);\n        }\n\n        BigInteger  k = kCalculator.nextK();\n\n        // the randomizer is to conceal timing information related to k and x.\n        BigInteger  r = params.getG().modPow(k.add(getRandomizer(q, random)), params.getP()).mod(q);\n\n        k = k.modInverse(q).multiply(m.add(x.multiply(r)));\n\n        BigInteger  s = k.mod(q);\n\n        return new BigInteger[]{ r, s };\n    }\n\n    /**\n     * return true if the value r and s represent a DSA signature for\n     * the passed in message for standard DSA the message should be a\n     * SHA-1 hash of the real message to be verified.\n     */\n    public boolean verifySignature(\n        byte[]      message,\n        BigInteger  r,\n        BigInteger  s)\n    {\n        DSAParameters   params = key.getParameters();\n        BigInteger      q = params.getQ();\n        BigInteger      m = calculateE(q, message);\n        BigInteger      zero = BigInteger.valueOf(0);\n\n        if (zero.compareTo(r) >= 0 || q.compareTo(r) <= 0)\n        {\n            return false;\n        }\n\n        if (zero.compareTo(s) >= 0 || q.compareTo(s) <= 0)\n        {\n            return false;\n        }\n\n        BigInteger  w = s.modInverse(q);\n\n        BigInteger  u1 = m.multiply(w).mod(q);\n        BigInteger  u2 = r.multiply(w).mod(q);\n\n        BigInteger p = params.getP();\n        u1 = params.getG().modPow(u1, p);\n        u2 = ((DSAPublicKeyParameters)key).getY().modPow(u2, p);\n\n        BigInteger  v = u1.multiply(u2).mod(p).mod(q);\n\n        return v.equals(r);\n    }\n\n    private BigInteger calculateE(BigInteger n, byte[] message)\n    {\n        if (n.bitLength() >= message.length * 8)\n        {\n            return new BigInteger(1, message);\n        }\n        else\n        {\n            byte[] trunc = new byte[n.bitLength() / 8];\n\n            System.arraycopy(message, 0, trunc, 0, trunc.length);\n\n            return new BigInteger(1, trunc);\n        }\n    }\n\n    protected SecureRandom initSecureRandom(boolean needed, SecureRandom provided)\n    {\n        return !needed ? null : (provided != null) ? provided : new SecureRandom();\n    }\n\n    private BigInteger getRandomizer(BigInteger q, SecureRandom provided)\n    {\n        // Calculate a random multiple of q to add to k. Note that g^q = 1 (mod p), so adding multiple of q to k does not change r.\n        int randomBits = 7;\n\n        return new BigInteger(randomBits, provided != null ? provided : new SecureRandom()).add(BigInteger.valueOf(128)).multiply(q);\n    }\n}\n", "package org.bouncycastle.crypto.test;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\n\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.digests.SHA224Digest;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.digests.SHA3Digest;\nimport org.bouncycastle.crypto.generators.DSAKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.DSAParametersGenerator;\nimport org.bouncycastle.crypto.params.DSAKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.DSAParameterGenerationParameters;\nimport org.bouncycastle.crypto.params.DSAParameters;\nimport org.bouncycastle.crypto.params.DSAPrivateKeyParameters;\nimport org.bouncycastle.crypto.params.DSAPublicKeyParameters;\nimport org.bouncycastle.crypto.params.DSAValidationParameters;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\nimport org.bouncycastle.crypto.signers.DSADigestSigner;\nimport org.bouncycastle.crypto.signers.DSASigner;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.FixedSecureRandom;\nimport org.bouncycastle.util.test.SimpleTest;\nimport org.bouncycastle.util.test.TestRandomBigInteger;\nimport org.bouncycastle.util.test.TestRandomData;\n\n/**\n * Test based on FIPS 186-2, Appendix 5, an example of DSA, and FIPS 168-3 test vectors.\n */\npublic class DSATest\n    extends SimpleTest\n{\n    byte[] k1 = Hex.decode(\"d5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    byte[] k2 = Hex.decode(\"345e8d05c075c3a508df729a1685690e68fcfb8c8117847e89063bca1f85d968fd281540b6e13bd1af989a1fbf17e06462bf511f9d0b140fb48ac1b1baa5bded\");\n\n    SecureRandom    random = new FixedSecureRandom(\n        new FixedSecureRandom.Source[] { new FixedSecureRandom.Data(k1), new FixedSecureRandom.Data(k2) });\n\n    byte[] keyData = Hex.decode(\"b5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    \n    SecureRandom    keyRandom = new FixedSecureRandom(\n                      new FixedSecureRandom.Source[] { new FixedSecureRandom.Data(keyData), new FixedSecureRandom.Data(keyData), new FixedSecureRandom.Data(Hex.decode(\"01020304\"))});\n\n    BigInteger  pValue = new BigInteger(\"8df2a494492276aa3d25759bb06869cbeac0d83afb8d0cf7cbb8324f0d7882e5d0762fc5b7210eafc2e9adac32ab7aac49693dfbf83724c2ec0736ee31c80291\", 16);\n    BigInteger  qValue = new BigInteger(\"c773218c737ec8ee993b4f2ded30f48edace915f\", 16);\n\n    public String getName()\n    {\n        return \"DSA\";\n    }\n\n    public void performTest()\n    {\n        BigInteger              r = new BigInteger(\"68076202252361894315274692543577577550894681403\");\n        BigInteger              s = new BigInteger(\"1089214853334067536215539335472893651470583479365\");\n        DSAParametersGenerator  pGen = new DSAParametersGenerator();\n\n        pGen.init(512, 80, random);\n\n        DSAParameters           params = pGen.generateParameters();\n        DSAValidationParameters pValid = params.getValidationParameters();\n\n        if (pValid.getCounter() != 105)\n        {\n            fail(\"Counter wrong\");\n        }\n\n        if (!pValue.equals(params.getP()) || !qValue.equals(params.getQ()))\n        {\n            fail(\"p or q wrong\");\n        }\n\n        DSAKeyPairGenerator         dsaKeyGen = new DSAKeyPairGenerator();\n        DSAKeyGenerationParameters  genParam = new DSAKeyGenerationParameters(keyRandom, params);\n\n        dsaKeyGen.init(genParam);\n\n        AsymmetricCipherKeyPair  pair = dsaKeyGen.generateKeyPair();\n\n        ParametersWithRandom param = new ParametersWithRandom(pair.getPrivate(), keyRandom);\n\n        DSASigner dsa = new DSASigner();\n\n        dsa.init(true, param);\n\n        byte[] message = BigIntegers.asUnsignedByteArray(new BigInteger(\"968236873715988614170569073515315707566766479517\"));\n        BigInteger[] sig = dsa.generateSignature(message);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\", r, sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\", s, sig[1]);\n        }\n\n        dsa.init(false, pair.getPublic());\n\n        if (!dsa.verifySignature(message, sig[0], sig[1]))\n        {\n            fail(\"verification fails\");\n        }\n\n        dsa2Test1();\n        dsa2Test2();\n        dsa2Test3();\n        dsa2Test4();\n\n        testDSAsha3(224, new BigInteger(\"613202af2a7f77e02b11b5c3a5311cf6b412192bc0032aac3ec127faebfc6bd0\", 16));\n        testDSAsha3(256, new BigInteger(\"2450755c5e15a691b121bc833b97864e34a61ee025ecec89289c949c1858091e\", 16));\n        testDSAsha3(384, new BigInteger(\"7aad97c0b71bb1e1a6483b6948a03bbe952e4780b0cee699a11731f90d84ddd1\", 16));\n        testDSAsha3(512, new BigInteger(\"725ad64d923c668e64e7c3898b5efde484cab49ce7f98c2885d2a13a9e355ad4\", 16));\n    }\n\n    private void testDSAsha3(int size, BigInteger s)\n    {\n        DSAParameters dsaParams = new DSAParameters(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        BigInteger x = new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16);\n\n        BigInteger y = new BigInteger(\n                    \"2828003D7C747199143C370FDD07A286\" +\n                    \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n                    \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n                    \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n                    \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n                    \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n                    \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n                    \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n                    \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n                    \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n                    \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16);\n\n        DSAPrivateKeyParameters priKey = new DSAPrivateKeyParameters(x, dsaParams);\n        SecureRandom k = new FixedSecureRandom(\n            new FixedSecureRandom.Source[] {\n                new FixedSecureRandom.BigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\"))),\n                new FixedSecureRandom.Data(Hex.decode(\"01020304\"))\n            });\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        DSADigestSigner dsa = new DSADigestSigner(new DSASigner(), new SHA3Digest(size));\n\n        dsa.init(true, new ParametersWithRandom(priKey, k));\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.generateSignature();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        DSAPublicKeyParameters pubKey = new DSAPublicKeyParameters(y, dsaParams);\n\n        dsa.init(false, pubKey);\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verifySignature(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void dsa2Test1()\n    {\n        byte[] seed = Hex.decode(\"ED8BEE8D1CB89229D2903CBF0E51EE7377F48698\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator();\n\n        pGen.init(new DSAParameterGenerationParameters(1024, 160, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 5)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"E950511EAB424B9A19A2AEB4E159B7844C589C4F\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"E0A67598CD1B763B\" +\n            \"C98C8ABB333E5DDA0CD3AA0E5E1FB5BA8A7B4EABC10BA338\" +\n            \"FAE06DD4B90FDA70D7CF0CB0C638BE3341BEC0AF8A7330A3\" +\n            \"307DED2299A0EE606DF035177A239C34A912C202AA5F83B9\" +\n            \"C4A7CF0235B5316BFC6EFB9A248411258B30B839AF172440\" +\n            \"F32563056CB67A861158DDD90E6A894C72A5BBEF9E286C6B\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"D29D5121B0423C27\" +\n            \"69AB21843E5A3240FF19CACC792264E3BB6BE4F78EDD1B15\" +\n            \"C4DFF7F1D905431F0AB16790E1F773B5CE01C804E509066A\" +\n            \"9919F5195F4ABC58189FD9FF987389CB5BEDF21B4DAB4F8B\" +\n            \"76A055FFE2770988FE2EC2DE11AD92219F0B351869AC24DA\" +\n            \"3D7BA87011A701CE8EE7BFE49486ED4527B7186CA4610A75\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomBigInteger(\"D0EC4E50BB290A42E9E355C73D8809345DE2E139\", 16), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"25282217F5730501\" +\n            \"DD8DBA3EDFCF349AAFFEC20921128D70FAC44110332201BB\" +\n            \"A3F10986140CBB97C726938060473C8EC97B4731DB004293\" +\n            \"B5E730363609DF9780F8D883D8C4D41DED6A2F1E1BBBDC97\" +\n            \"9E1B9D6D3C940301F4E978D65B19041FCF1E8B518F5C0576\" +\n            \"C770FE5A7A485D8329EE2914A2DE1B5DA4A6128CEAB70F79\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"D0EC4E50BB290A42E9E355C73D8809345DE2E139\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new FixedSecureRandom(\n            new FixedSecureRandom.Source[] {\n                new FixedSecureRandom.BigInteger(\"349C55648DCF992F3F33E8026CFAC87C1D2BA075\"),\n                new FixedSecureRandom.Data(Hex.decode(\"01020304\")) })));\n\n        byte[] msg = Hex.decode(\"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"636155AC9A4633B4665D179F9E4117DF68601F34\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"6C540B02D9D4852F89DF8CFC99963204F4347704\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n\n    }\n\n    private void dsa2Test2()\n        {\n            byte[] seed = Hex.decode(\"5AFCC1EFFC079A9CCA6ECA86D6E3CC3B18642D9BE1CC6207C84002A9\");\n\n            DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA224Digest());\n\n            pGen.init(new DSAParameterGenerationParameters(2048, 224, 80, new DSATestSecureRandom(seed)));\n\n            DSAParameters params = pGen.generateParameters();\n\n            DSAValidationParameters pv = params.getValidationParameters();\n\n            if (pv.getCounter() != 21)\n            {\n                fail(\"counter incorrect\");\n            }\n\n            if (!Arrays.areEqual(seed, pv.getSeed()))\n            {\n                fail(\"seed incorrect\");\n            }\n\n            if (!params.getQ().equals(new BigInteger(\"90EAF4D1AF0708B1B612FF35E0A2997EB9E9D263C9CE659528945C0D\", 16)))\n            {\n                fail(\"Q incorrect\");\n            }\n\n            if (!params.getP().equals(new BigInteger(\n                \"C196BA05AC29E1F9C3C72D56DFFC6154\" +\n                \"A033F1477AC88EC37F09BE6C5BB95F51C296DD20D1A28A06\" +\n                \"7CCC4D4316A4BD1DCA55ED1066D438C35AEBAABF57E7DAE4\" +\n                \"28782A95ECA1C143DB701FD48533A3C18F0FE23557EA7AE6\" +\n                \"19ECACC7E0B51652A8776D02A425567DED36EABD90CA33A1\" +\n                \"E8D988F0BBB92D02D1D20290113BB562CE1FC856EEB7CDD9\" +\n                \"2D33EEA6F410859B179E7E789A8F75F645FAE2E136D252BF\" +\n                \"FAFF89528945C1ABE705A38DBC2D364AADE99BE0D0AAD82E\" +\n                \"5320121496DC65B3930E38047294FF877831A16D5228418D\" +\n                \"E8AB275D7D75651CEFED65F78AFC3EA7FE4D79B35F62A040\" +\n                \"2A1117599ADAC7B269A59F353CF450E6982D3B1702D9CA83\", 16)))\n            {\n                fail(\"P incorrect\");\n            }\n\n            if (!params.getG().equals(new BigInteger(\n                \"A59A749A11242C58C894E9E5A91804E8\"+\n                \"FA0AC64B56288F8D47D51B1EDC4D65444FECA0111D78F35F\"+\n                \"C9FDD4CB1F1B79A3BA9CBEE83A3F811012503C8117F98E50\"+\n                \"48B089E387AF6949BF8784EBD9EF45876F2E6A5A495BE64B\"+\n                \"6E770409494B7FEE1DBB1E4B2BC2A53D4F893D418B715959\"+\n                \"2E4FFFDF6969E91D770DAEBD0B5CB14C00AD68EC7DC1E574\"+\n                \"5EA55C706C4A1C5C88964E34D09DEB753AD418C1AD0F4FDF\"+\n                \"D049A955E5D78491C0B7A2F1575A008CCD727AB376DB6E69\"+\n                \"5515B05BD412F5B8C2F4C77EE10DA48ABD53F5DD498927EE\"+\n                \"7B692BBBCDA2FB23A516C5B4533D73980B2A3B60E384ED20\"+\n                \"0AE21B40D273651AD6060C13D97FD69AA13C5611A51B9085\", 16)))\n            {\n                fail(\"G incorrect\");\n            }\n\n            DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n            kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"00D0F09ED3E2568F6CADF9224117DA2AEC5A4300E009DE1366023E17\")), params));\n\n            AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n            DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n            DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n            if (!pub.getY().equals(new BigInteger(\n                \"70035C9A3B225B258F16741F3941FBF0\" +\n                \"6F3D056CD7BD864604CBB5EE9DD85304EE8E8E4ABD5E9032\" +\n                \"11DDF25CE149075510ACE166970AFDC7DF552B7244F342FA\" +\n                \"02F7A621405B754909D757F97290E1FE5036E904CF593446\" +\n                \"0C046D95659821E1597ED9F2B1F0E20863A6BBD0CE74DACB\" +\n                \"A5D8C68A90B29C2157CDEDB82EC12B81EE3068F9BF5F7F34\" +\n                \"6ECA41ED174CCCD7D154FA4F42F80FFE1BF46AE9D8125DEB\" +\n                \"5B4BA08A72BDD86596DBEDDC9550FDD650C58F5AE5133509\" +\n                \"A702F79A31ECB490F7A3C5581631F7C5BE4FF7F9E9F27FA3\" +\n                \"90E47347AD1183509FED6FCF198BA9A71AB3335B4F38BE8D\" +\n                \"15496A00B6DC2263E20A5F6B662320A3A1EC033AA61E3B68\", 16)))\n            {\n                fail(\"Y value incorrect\");\n            }\n\n            if (!priv.getX().equals(\n                new BigInteger(\"00D0F09ED3E2568F6CADF9224117DA2AEC5A4300E009DE1366023E17\", 16)))\n            {\n                fail(\"X value incorrect\");\n            }\n\n            DSASigner signer = new DSASigner();\n\n            signer.init(true, new ParametersWithRandom(kp.getPrivate(), new FixedSecureRandom(\n                new FixedSecureRandom.Source[] {\n                    new FixedSecureRandom.BigInteger(Hex.decode(\"735959CC4463B8B440E407EECA8A473BF6A6D1FE657546F67D401F05\")),\n                    new FixedSecureRandom.Data(Hex.decode(\"01020304\"))\n                })));\n\n            byte[] msg = Hex.decode(\"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n            BigInteger[] sig = signer.generateSignature(msg);\n\n            if (!sig[0].equals(new BigInteger(\"4400138D05F9639CAF54A583CAAF25D2B76D0C3EAD752CE17DBC85FE\", 16)))\n            {\n                fail(\"R value incorrect\");\n            }\n\n            if (!sig[1].equals(new BigInteger(\"874D4F12CB13B61732D398445698CFA9D92381D938AA57EE2C9327B3\", 16)))\n            {\n                fail(\"S value incorrect\");\n            }\n\n            signer.init(false, kp.getPublic());\n\n            if (!signer.verifySignature(msg, sig[0], sig[1]))\n            {\n                fail(\"signature not verified\");\n            }\n        }\n\n    private void dsa2Test3()\n    {\n        byte[] seed = Hex.decode(\"4783081972865EA95D43318AB2EAF9C61A2FC7BBF1B772A09017BDF5A58F4FF0\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA256Digest());\n\n        pGen.init(new DSAParameterGenerationParameters(2048, 256, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 12)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n            \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n            \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n            \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n            \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n            \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n            \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n            \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n            \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n            \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n            \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n            \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n            \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n            \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n            \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n            \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n            \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n            \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n            \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n            \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n            \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"2828003D7C747199143C370FDD07A286\" +\n            \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n            \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n            \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n            \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n            \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n            \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n            \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n            \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n            \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n            \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new FixedSecureRandom(\n            new FixedSecureRandom.Source[] {\n                new FixedSecureRandom.BigInteger(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")),\n                new FixedSecureRandom.Data(Hex.decode(\"01020304\"))\n            })));\n\n        byte[] msg = Hex.decode(\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"315C875DCD4850E948B8AC42824E9483A32D5BA5ABE0681B9B9448D444F2BE3C\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"89718D12E54A8D9ED066E4A55F7ED5A2229CD23B9A3CEE78F83ED6AA61F6BCB9\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n    }\n\n    private void dsa2Test4()\n    {\n        byte[] seed = Hex.decode(\"193AFCA7C1E77B3C1ECC618C81322E47B8B8B997C9C83515C59CC446C2D9BD47\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA256Digest());\n\n        pGen.init(new DSAParameterGenerationParameters(3072, 256, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 20)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"CFA0478A54717B08CE64805B76E5B14249A77A4838469DF7F7DC987EFCCFB11D\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"90066455B5CFC38F9CAA4A48B4281F292C260FEEF01FD610\" +\n            \"37E56258A7795A1C7AD46076982CE6BB956936C6AB4DCFE0\" +\n            \"5E6784586940CA544B9B2140E1EB523F009D20A7E7880E4E\" +\n            \"5BFA690F1B9004A27811CD9904AF70420EEFD6EA11EF7DA1\" +\n            \"29F58835FF56B89FAA637BC9AC2EFAAB903402229F491D8D\" +\n            \"3485261CD068699B6BA58A1DDBBEF6DB51E8FE34E8A78E54\" +\n            \"2D7BA351C21EA8D8F1D29F5D5D15939487E27F4416B0CA63\" +\n            \"2C59EFD1B1EB66511A5A0FBF615B766C5862D0BD8A3FE7A0\" +\n            \"E0DA0FB2FE1FCB19E8F9996A8EA0FCCDE538175238FC8B0E\" +\n            \"E6F29AF7F642773EBE8CD5402415A01451A840476B2FCEB0\" +\n            \"E388D30D4B376C37FE401C2A2C2F941DAD179C540C1C8CE0\" +\n            \"30D460C4D983BE9AB0B20F69144C1AE13F9383EA1C08504F\" +\n            \"B0BF321503EFE43488310DD8DC77EC5B8349B8BFE97C2C56\" +\n            \"0EA878DE87C11E3D597F1FEA742D73EEC7F37BE43949EF1A\" +\n            \"0D15C3F3E3FC0A8335617055AC91328EC22B50FC15B941D3\" +\n            \"D1624CD88BC25F3E941FDDC6200689581BFEC416B4B2CB73\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"5E5CBA992E0A680D885EB903AEA78E4A45A469103D448EDE\" +\n            \"3B7ACCC54D521E37F84A4BDD5B06B0970CC2D2BBB715F7B8\" +\n            \"2846F9A0C393914C792E6A923E2117AB805276A975AADB52\" +\n            \"61D91673EA9AAFFEECBFA6183DFCB5D3B7332AA19275AFA1\" +\n            \"F8EC0B60FB6F66CC23AE4870791D5982AAD1AA9485FD8F4A\" +\n            \"60126FEB2CF05DB8A7F0F09B3397F3937F2E90B9E5B9C9B6\" +\n            \"EFEF642BC48351C46FB171B9BFA9EF17A961CE96C7E7A7CC\" +\n            \"3D3D03DFAD1078BA21DA425198F07D2481622BCE45969D9C\" +\n            \"4D6063D72AB7A0F08B2F49A7CC6AF335E08C4720E31476B6\" +\n            \"7299E231F8BD90B39AC3AE3BE0C6B6CACEF8289A2E2873D5\" +\n            \"8E51E029CAFBD55E6841489AB66B5B4B9BA6E2F784660896\" +\n            \"AFF387D92844CCB8B69475496DE19DA2E58259B090489AC8\" +\n            \"E62363CDF82CFD8EF2A427ABCD65750B506F56DDE3B98856\" +\n            \"7A88126B914D7828E2B63A6D7ED0747EC59E0E0A23CE7D8A\" +\n            \"74C1D2C2A7AFB6A29799620F00E11C33787F7DED3B30E1A2\" +\n            \"2D09F1FBDA1ABBBFBF25CAE05A13F812E34563F99410E73B\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"3ABC1587297CE7B9EA1AD6651CF2BC4D7F92ED25CABC8553F567D1B40EBB8764\")), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"8B891C8692D3DE875879390F2698B26FBECCA6B075535DCE\" +\n            \"6B0C862577F9FA0DEF6074E7A7624121224A595896ABD4CD\" +\n            \"A56B2CEFB942E025D2A4282FFAA98A48CDB47E1A6FCB5CFB\" +\n            \"393EF35AF9DF913102BB303C2B5C36C3F8FC04ED7B8B69FE\" +\n            \"FE0CF3E1FC05CFA713B3435B2656E913BA8874AEA9F93600\" +\n            \"6AEB448BCD005D18EC3562A33D04CF25C8D3D69844343442\" +\n            \"FA3DB7DE618C5E2DA064573E61E6D5581BFB694A23AC87FD\" +\n            \"5B52D62E954E1376DB8DDB524FFC0D469DF978792EE44173\" +\n            \"8E5DB05A7DC43E94C11A2E7A4FBE383071FA36D2A7EC8A93\" +\n            \"88FE1C4F79888A99D3B6105697C2556B79BB4D7E781CEBB3\" +\n            \"D4866AD825A5E830846072289FDBC941FA679CA82F5F78B7\" +\n            \"461B2404DB883D215F4E0676CF5493950AC5591697BFEA8D\" +\n            \"1EE6EC016B89BA51CAFB5F9C84C989FA117375E94578F28B\" +\n            \"E0B34CE0545DA46266FD77F62D8F2CEE92AB77012AFEBC11\" +\n            \"008985A821CD2D978C7E6FE7499D1AAF8DE632C21BB48CA5\" +\n            \"CBF9F31098FD3FD3854C49A65D9201744AACE540354974F9\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"3ABC1587297CE7B9EA1AD6651CF2BC4D7F92ED25CABC8553F567D1B40EBB8764\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new FixedSecureRandom(\n            new FixedSecureRandom.Source[]\n                { new FixedSecureRandom.BigInteger(\"A6902C1E6E3943C5628061588A8B007BCCEA91DBF12915483F04B24AB0678BEE\"),\n                  new FixedSecureRandom.Data(Hex.decode(\"01020304\")) })));\n\n        byte[] msg = Hex.decode(\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"5F184E645A38BE8FB4A6871B6503A9D12924C7ABE04B71410066C2ECA6E3BE3E\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"91EB0C7BA3D4B9B60B825C3D9F2CADA8A2C9D7723267B033CBCDCF8803DB9C18\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        runTest(new DSATest());\n    }\n\n    private class DSATestSecureRandom\n        extends TestRandomData\n    {\n        private boolean first = true;\n\n        public DSATestSecureRandom(byte[] value)\n        {\n            super(value);\n        }\n\n       public void nextBytes(byte[] bytes)\n       {\n           if (first)\n           {\n               super.nextBytes(bytes);\n               first = false;\n           }\n           else\n           {\n               bytes[bytes.length - 1] = 2;\n           }\n       }\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameterGenerator;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.spec.DSAParameterSpec;\nimport java.security.spec.DSAPrivateKeySpec;\nimport java.security.spec.DSAPublicKeySpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.eac.EACObjectIdentifiers;\nimport org.bouncycastle.asn1.nist.NISTNamedCurves;\nimport org.bouncycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.X9ECParameters;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.crypto.params.DSAParameters;\nimport org.bouncycastle.crypto.params.DSAPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ECDomainParameters;\nimport org.bouncycastle.crypto.signers.DSASigner;\nimport org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.ECNamedCurveGenParameterSpec;\nimport org.bouncycastle.jce.spec.ECParameterSpec;\nimport org.bouncycastle.jce.spec.ECPrivateKeySpec;\nimport org.bouncycastle.jce.spec.ECPublicKeySpec;\nimport org.bouncycastle.math.ec.ECCurve;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.FixedSecureRandom;\nimport org.bouncycastle.util.test.SimpleTest;\nimport org.bouncycastle.util.test.TestRandomBigInteger;\nimport org.bouncycastle.util.test.TestRandomData;\n\npublic class DSATest\n    extends SimpleTest\n{\n    byte[] k1 = Hex.decode(\"d5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    byte[] k2 = Hex.decode(\"345e8d05c075c3a508df729a1685690e68fcfb8c8117847e89063bca1f85d968fd281540b6e13bd1af989a1fbf17e06462bf511f9d0b140fb48ac1b1baa5bded\");\n\n    SecureRandom    random = new FixedSecureRandom(new byte[][] { k1, k2 });\n\n    // DSA modified signatures, courtesy of the Google security team\n    static final DSAPrivateKeySpec PRIVATE_KEY = new DSAPrivateKeySpec(\n        // x\n        new BigInteger(\n            \"15382583218386677486843706921635237927801862255437148328980464126979\"),\n        // p\n        new BigInteger(\n            \"181118486631420055711787706248812146965913392568235070235446058914\"\n            + \"1170708161715231951918020125044061516370042605439640379530343556\"\n            + \"4101919053459832890139496933938670005799610981765220283775567361\"\n            + \"4836626483403394052203488713085936276470766894079318754834062443\"\n            + \"1033792580942743268186462355159813630244169054658542719322425431\"\n            + \"4088256212718983105131138772434658820375111735710449331518776858\"\n            + \"7867938758654181244292694091187568128410190746310049564097068770\"\n            + \"8161261634790060655580211122402292101772553741704724263582994973\"\n            + \"9109274666495826205002104010355456981211025738812433088757102520\"\n            + \"562459649777989718122219159982614304359\"),\n        // q\n        new BigInteger(\n            \"19689526866605154788513693571065914024068069442724893395618704484701\"),\n        // g\n        new BigInteger(\n            \"2859278237642201956931085611015389087970918161297522023542900348\"\n            + \"0877180630984239764282523693409675060100542360520959501692726128\"\n            + \"3149190229583566074777557293475747419473934711587072321756053067\"\n            + \"2532404847508798651915566434553729839971841903983916294692452760\"\n            + \"2490198571084091890169933809199002313226100830607842692992570749\"\n            + \"0504363602970812128803790973955960534785317485341020833424202774\"\n            + \"0275688698461842637641566056165699733710043802697192696426360843\"\n            + \"1736206792141319514001488556117408586108219135730880594044593648\"\n            + \"9237302749293603778933701187571075920849848690861126195402696457\"\n            + \"4111219599568903257472567764789616958430\"));\n\n    static final DSAPublicKeySpec PUBLIC_KEY = new DSAPublicKeySpec(\n        new BigInteger(\n            \"3846308446317351758462473207111709291533523711306097971550086650\"\n            + \"2577333637930103311673872185522385807498738696446063139653693222\"\n            + \"3528823234976869516765207838304932337200968476150071617737755913\"\n            + \"3181601169463467065599372409821150709457431511200322947508290005\"\n            + \"1780020974429072640276810306302799924668893998032630777409440831\"\n            + \"4314588994475223696460940116068336991199969153649625334724122468\"\n            + \"7497038281983541563359385775312520539189474547346202842754393945\"\n            + \"8755803223951078082197762886933401284142487322057236814878262166\"\n            + \"5072306622943221607031324846468109901964841479558565694763440972\"\n            + \"5447389416166053148132419345627682740529\"),\n         PRIVATE_KEY.getP(),\n         PRIVATE_KEY.getQ(),\n         PRIVATE_KEY.getG());\n\n    // The following test vectors check for signature malleability and bugs. That means the test\n    // vectors are derived from a valid signature by modifying the ASN encoding. A correct\n    // implementation of DSA should only accept correct DER encoding and properly handle the others.\n    // Allowing alternative BER encodings is in many cases benign. An example where this kind of\n    // signature malleability was a problem: https://en.bitcoin.it/wiki/Transaction_Malleability\n    static final String[] MODIFIED_SIGNATURES  = {\n        \"303e02811c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303f0282001c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021d001e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd02811d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303f021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd0282001d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021e0000ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"30813d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"3082003d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9ef4\"\n        + \"1dd424a4e1c8f16967cf3365813fe87862360000\",\n        \"3040021c57b10411b54ab248af03d8f2456676ebc6d3db5f1081492ac87e9ca8021d00942b117051d7d9d107fc42cac9c5a36a1fd7f0f8916ccca86cec4ed3040100\",\n        \"303e021c57b10411b54ab248af03d8f2456676ebc6d3db5f1081492ac87e9ca802811d00942b117051d7d9d107fc42cac9c5a36a1fd7f0f8916ccca86cec4ed3\"\n    };\n\n    private void testModified()\n        throws Exception\n    {\n        KeyFactory kFact = KeyFactory.getInstance(\"DSA\", \"BC\");\n        PublicKey pubKey = kFact.generatePublic(PUBLIC_KEY);\n        Signature sig = Signature.getInstance(\"DSA\", \"BC\");\n\n        for (int i = 0; i != MODIFIED_SIGNATURES.length; i++)\n        {\n            sig.initVerify(pubKey);\n\n            sig.update(Strings.toByteArray(\"Hello\"));\n\n            boolean failed;\n\n            try\n            {\n                failed = !sig.verify(Hex.decode(MODIFIED_SIGNATURES[i]));\n            }\n            catch (SignatureException e)\n            {\n                failed = true;\n            }\n\n            isTrue(\"sig verified when shouldn't\", failed);\n        }\n    }\n\n    private void testCompat()\n        throws Exception\n    {\n        if (Security.getProvider(\"SUN\") == null)\n        {\n            return;\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"SUN\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"SUN\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        g.initialize(512, new SecureRandom());\n        \n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        //\n        // sign SUN - verify with BC \n        //\n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"SUN -> BC verification failed\");\n        }\n        \n        //\n        // sign BC - verify with SUN\n        //\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"SUN\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"BC -> SUN verification failed\");\n        }\n\n        //\n        // key encoding test - BC decoding Sun keys\n        //\n        KeyFactory          f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec  x509s = new X509EncodedKeySpec(vKey.getEncoded());\n\n        DSAPublicKey        k1 = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        PKCS8EncodedKeySpec  pkcs8 = new PKCS8EncodedKeySpec(sKey.getEncoded());\n\n        DSAPrivateKey        k2 = (DSAPrivateKey)f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n        \n        //\n        // key decoding test - SUN decoding BC keys\n        // \n        f = KeyFactory.getInstance(\"DSA\", \"SUN\");\n        x509s = new X509EncodedKeySpec(k1.getEncoded());\n        \n        vKey = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        pkcs8 = new PKCS8EncodedKeySpec(k2.getEncoded());\n        sKey = f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n    }\n\n    private void testNullParameters()\n        throws Exception\n    {\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec x509s = new X509EncodedKeySpec(new SubjectPublicKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_dsa), new ASN1Integer(10001)).getEncoded());\n\n        DSAPublicKey key1 = (DSAPublicKey)f.generatePublic(x509s);\n        DSAPublicKey key2 = (DSAPublicKey)f.generatePublic(x509s);\n\n        isTrue(\"parameters not absent\", key1.getParams() == null && key2.getParams() == null);\n        isTrue(\"hashCode mismatch\", key1.hashCode() == key2.hashCode());\n        isTrue(\"not equal\", key1.equals(key2));\n        isTrue(\"encoding mismatch\", Arrays.areEqual(x509s.getEncoded(), key1.getEncoded()));\n    }\n\n    private void testValidate()\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        try\n        {\n            f.generatePublic(new DSAPublicKeySpec(BigInteger.valueOf(1), dsaParams.getP(), dsaParams.getG(), dsaParams.getQ()));\n\n            fail(\"no exception\");\n        }\n        catch (Exception e)\n        {\n            isTrue(\"mismatch\", \"invalid KeySpec: y value does not appear to be in correct group\".equals(e.getMessage()));\n        }\n    }\n\n    private void testNONEwithDSA()\n        throws Exception\n    {\n        byte[] dummySha1 = Hex.decode(\"01020304050607080910111213141516\");\n\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n\n        kpGen.initialize(512);\n\n        KeyPair          kp = kpGen.generateKeyPair();\n\n        Signature        sig = Signature.getInstance(\"NONEwithDSA\", \"BC\");\n\n        sig.initSign(kp.getPrivate());\n\n        sig.update(dummySha1);\n\n        byte[] sigBytes = sig.sign();\n\n        sig.initVerify(kp.getPublic());\n\n        sig.update(dummySha1);\n\n        sig.verify(sigBytes);\n\n        // reset test\n\n        sig.update(dummySha1);\n\n        if (!sig.verify(sigBytes))\n        {\n            fail(\"NONEwithDSA failed to reset\");\n        }\n\n        // lightweight test\n        DSAPublicKey  key = (DSAPublicKey)kp.getPublic();\n        DSAParameters params = new DSAParameters(key.getParams().getP(), key.getParams().getQ(), key.getParams().getG());\n        DSAPublicKeyParameters keyParams = new DSAPublicKeyParameters(key.getY(), params);\n        DSASigner signer = new DSASigner();\n        ASN1Sequence derSig = ASN1Sequence.getInstance(ASN1Primitive.fromByteArray(sigBytes));\n\n        signer.init(false, keyParams);\n\n        if (!signer.verifySignature(dummySha1, ASN1Integer.getInstance(derSig.getObjectAt(0)).getValue(), ASN1Integer.getInstance(derSig.getObjectAt(1)).getValue()))\n        {\n            fail(\"NONEwithDSA not really NONE!\");\n        }\n    }\n\n    private void checkPublic(DSAPublicKey k1, PublicKey vKey)\n    {\n        if (!k1.getY().equals(((DSAPublicKey)vKey).getY()))\n        {\n            fail(\"public number not decoded properly\");\n        }\n\n        if (!k1.getParams().getG().equals(((DSAPublicKey)vKey).getParams().getG()))\n        {\n            fail(\"public generator not decoded properly\");\n        }\n\n        if (!k1.getParams().getP().equals(((DSAPublicKey)vKey).getParams().getP()))\n        {\n            fail(\"public p value not decoded properly\");\n        }\n\n        if (!k1.getParams().getQ().equals(((DSAPublicKey)vKey).getParams().getQ()))\n        {\n            fail(\"public q value not decoded properly\");\n        }\n    }\n\n    private void checkPrivateKey(DSAPrivateKey k2, PrivateKey sKey)\n    {\n        if (!k2.getX().equals(((DSAPrivateKey)sKey).getX()))\n        {\n            fail(\"private number not decoded properly\");\n        }\n\n        if (!k2.getParams().getG().equals(((DSAPrivateKey)sKey).getParams().getG()))\n        {\n            fail(\"private generator not decoded properly\");\n        }\n\n        if (!k2.getParams().getP().equals(((DSAPrivateKey)sKey).getParams().getP()))\n        {\n            fail(\"private p value not decoded properly\");\n        }\n\n        if (!k2.getParams().getQ().equals(((DSAPrivateKey)sKey).getParams().getQ()))\n        {\n            fail(\"private q value not decoded properly\");\n        }\n    }\n\n    private Object serializeDeserialize(Object o)\n        throws Exception\n    {\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ObjectOutputStream oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(o);\n        oOut.close();\n\n        ObjectInputStream oIn = new ObjectInputStream(new ByteArrayInputStream(bOut.toByteArray()));\n\n        return oIn.readObject();\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.3.2, Page 155, ECDSA over the field Fp<br>\n     * an example with 239 bit prime\n     */\n    private void testECDSA239bitPrime()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"308636143175167811492622547300668018854959378758531778147462058306432176\");\n        BigInteger s = new BigInteger(\"323813553209797357708078776831250505931891051755007842781978505179448783\");\n\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n        \n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n        \n        \n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n        \n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n        \n        Signature           sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n        \n        sgr.initSign(sKey, k);\n        \n        byte[] message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n        \n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n        \n        sgr.initVerify(vKey);\n        \n        sgr.update(message);\n        \n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n        \n        BigInteger[]  sig = derDecode(sigBytes);\n        \n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + r + Strings.lineSeparator()\n                    + \" got      : \" + sig[0]);\n        }\n        \n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + s + Strings.lineSeparator()\n                    + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testNONEwithECDSA239bitPrime()\n        throws Exception\n    {\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n\n        Signature           sgr = Signature.getInstance(\"NONEwithECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n\n        byte[] message = \"abc\".getBytes();\n        byte[] sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e64cb19604be06c57e761b3de5518f71de0f6e0cd2df677cec8a6ffcb690d\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"abcdefghijklmnopqrstuvwxyz\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e43fd65b3363d76aabef8630572257dbb67c82818ad9fad31256539b1b02c\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"a very very long message gauranteed to cause an overflow\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e7d5be84b22937a1691859a3c6fe45ed30b108574431d01b34025825ec17a\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n    }\n\n    private void testECDSAP256sha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        X9ECParameters p = NISTNamedCurves.getByName(\"P-256\");\n        KeyFactory ecKeyFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        ECDomainParameters params = new ECDomainParameters(p.getCurve(), p.getG(), p.getN(), p.getH());\n\n        ECCurve curve = p.getCurve();\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                p.getG(), // G\n                p.getN()); // n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"20186677036482506117540275567393538695075300175221296989956723148347484984008\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n            params.getCurve().decodePoint(Hex.decode(\"03596375E6CE57E0F20294FC46BDFCFD19A39F8161B58695B3EC5B3D16427C274D\")), // Q\n            spec);\n\n        doEcDsaTest(\"SHA3-\" + size + \"withECDSA\", s, ecKeyFact, pubKey, priKey);\n        doEcDsaTest(sigOid.getId(), s, ecKeyFact, pubKey, priKey);\n    }\n\n    private void doEcDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, ECPublicKeySpec pubKey, ECPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"97354732615802252173078420023658453040116611318111190383344590814578738210384\");\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void testDSAsha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        BigInteger x = new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16);\n\n        BigInteger y = new BigInteger(\n                    \"2828003D7C747199143C370FDD07A286\" +\n                    \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n                    \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n                    \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n                    \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n                    \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n                    \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n                    \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n                    \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n                    \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n                    \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16);\n\n        DSAPrivateKeySpec priKey = new DSAPrivateKeySpec(\n                x, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        DSAPublicKeySpec pubKey = new DSAPublicKeySpec(\n            y, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        KeyFactory dsaKeyFact = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        doDsaTest(\"SHA3-\" + size + \"withDSA\", s, dsaKeyFact, pubKey, priKey);\n        doDsaTest(sigOid.getId(), s, dsaKeyFact, pubKey, priKey);\n    }\n\n    private void doDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, DSAPublicKeySpec pubKey, DSAPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new FixedSecureRandom(\n            new FixedSecureRandom.Source[] { new FixedSecureRandom.BigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\"))),\n                new FixedSecureRandom.Data(Hex.decode(\"01020304\")) });\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void checkMessage(Signature sgr, PrivateKey sKey, PublicKey vKey, byte[] message, byte[] sig)\n        throws InvalidKeyException, SignatureException\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        if (!Arrays.areEqual(sigBytes, sig))\n        {\n            fail(new String(message) + \" signature incorrect\");\n        }\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(new String(message) + \" verification failed\");\n        }\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.2.1, Page 100, ECDSA over the field F2m<br>\n     * an example with 191 bit binary field\n     */\n    private void testECDSA239bitBinary()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"21596333210419611985018340039034612628818151486841789642455876922391552\");\n        BigInteger s = new BigInteger(\"197030374000731686738334997654997227052849804072198819102649413465737174\");\n    \n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n    \n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n    \n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n        \n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n    \n        Signature   sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n       \n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n\n        BigInteger[]  sig = derDecode(sigBytes);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r + Strings.lineSeparator()\n                + \" got      : \" + sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s + Strings.lineSeparator()\n                + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testECDSA239bitBinary(String algorithm, ASN1ObjectIdentifier oid)\n        throws Exception\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n\n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n\n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n\n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n\n        Signature   sgr = Signature.getInstance(algorithm, \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        sgr = Signature.getInstance(oid.getId(), \"BC\");\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC RIPEMD160 verification failed\");\n        }\n    }\n\n    private void testGeneration()\n        throws Exception\n    {\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n\n        // test exception\n        //\n        try\n        {\n            g.initialize(513, new SecureRandom());\n\n            fail(\"illegal parameter 513 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(510, new SecureRandom());\n\n            fail(\"illegal parameter 510 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(1025, new SecureRandom());\n\n            fail(\"illegal parameter 1025 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        g.initialize(512, new SecureRandom());\n\n        KeyPair p = g.generateKeyPair();\n\n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        DSAPublicKey k1 = (DSAPublicKey)serializeDeserialize(vKey);\n\n        checkPublic(k1, vKey);\n\n        checkEquals(k1, vKey);\n\n        DSAPrivateKey k2 = (DSAPrivateKey)serializeDeserialize(sKey);\n\n        checkPrivateKey(k2, sKey);\n\n        checkEquals(k2, sKey);\n\n        if (!(k2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n\n        //\n        // ECDSA Fp generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        ECCurve curve = new ECCurve.Fp(\n            new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n            new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n            new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n            new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        PublicKey eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        PrivateKey eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        // Named curve parameter\n        g.initialize(new ECNamedCurveGenParameterSpec(\"P-256\"), new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        //\n        // ECDSA F2m generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        curve = new ECCurve.F2m(\n                239, // m\n                36, // k\n                new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n                new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n        \n        ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n        \n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        if (!(eck2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n    }\n\n    private void checkEquals(Object o1, Object o2)\n    {\n        if (!o1.equals(o2))\n        {\n            fail(\"comparison test failed\");\n        }\n\n        if (o1.hashCode() != o2.hashCode())\n        {\n            fail(\"hashCode test failed\");\n        }\n    }\n    \n    private void testParameters()\n        throws Exception\n    {\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(512, random);\n        AlgorithmParameters params = a.generateParameters();\n        \n        byte[] encodeParams = params.getEncoded();\n        \n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n        \n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n        \n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n        \n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n        \n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new SecureRandom());\n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    private void testDSA2Parameters()\n        throws Exception\n    {\n        byte[] seed = Hex.decode(\"4783081972865EA95D43318AB2EAF9C61A2FC7BBF1B772A09017BDF5A58F4FF0\");\n\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(2048, new DSATestSecureRandom(seed));\n        AlgorithmParameters params = a.generateParameters();\n\n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n\n        if (!dsaP.getQ().equals(new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!dsaP.getP().equals(new BigInteger(\n            \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n            \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n            \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n            \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n            \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n            \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n            \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n            \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n            \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n            \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n            \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!dsaP.getG().equals(new BigInteger(\n            \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n            \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n            \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n            \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n            \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n            \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n            \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n            \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n            \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n            \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n            \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new TestRandomBigInteger(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")));\n        KeyPair p = g.generateKeyPair();\n\n        DSAPrivateKey  sKey = (DSAPrivateKey)p.getPrivate();\n        DSAPublicKey   vKey = (DSAPublicKey)p.getPublic();\n\n        if (!vKey.getY().equals(new BigInteger(\n            \"2828003D7C747199143C370FDD07A286\" +\n            \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n            \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n            \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n            \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n            \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n            \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n            \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n            \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n            \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n            \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!sKey.getX().equals(\n            new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        byte[] encodeParams = params.getEncoded();\n\n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n\n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n\n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        testCompat();\n        testNONEwithDSA();\n\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_224, 224, new BigInteger(\"613202af2a7f77e02b11b5c3a5311cf6b412192bc0032aac3ec127faebfc6bd0\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_256, 256, new BigInteger(\"2450755c5e15a691b121bc833b97864e34a61ee025ecec89289c949c1858091e\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_384, 384, new BigInteger(\"7aad97c0b71bb1e1a6483b6948a03bbe952e4780b0cee699a11731f90d84ddd1\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_512, 512, new BigInteger(\"725ad64d923c668e64e7c3898b5efde484cab49ce7f98c2885d2a13a9e355ad4\", 16));\n\n        testECDSA239bitPrime();\n        testNONEwithECDSA239bitPrime();\n        testECDSA239bitBinary();\n        testECDSA239bitBinary(\"RIPEMD160withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithRipemd160);\n        testECDSA239bitBinary(\"SHA1withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithSha1);\n        testECDSA239bitBinary(\"SHA224withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA224);\n        testECDSA239bitBinary(\"SHA256withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA256);\n        testECDSA239bitBinary(\"SHA384withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA384);\n        testECDSA239bitBinary(\"SHA512withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA512);\n        testECDSA239bitBinary(\"SHA1withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_1);\n        testECDSA239bitBinary(\"SHA224withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_224);\n        testECDSA239bitBinary(\"SHA256withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_256);\n        testECDSA239bitBinary(\"SHA384withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_384);\n        testECDSA239bitBinary(\"SHA512withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_512);\n\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_224, 224, new BigInteger(\"84d7d8e68e405064109cd9fc3e3026d74d278aada14ce6b7a9dd0380c154dc94\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_256, 256, new BigInteger(\"99a43bdab4af989aaf2899079375642f2bae2dce05bcd8b72ec8c4a8d9a143f\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_384, 384, new BigInteger(\"aa27726509c37aaf601de6f7e01e11c19add99530c9848381c23365dc505b11a\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_512, 512, new BigInteger(\"f8306b57a1f5068bf12e53aabaae39e2658db39bc56747eaefb479995130ad16\", 16));\n\n        testGeneration();\n        testParameters();\n        testDSA2Parameters();\n        testNullParameters();\n        testValidate();\n        testModified();\n    }\n\n    protected BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ByteArrayInputStream    bIn = new ByteArrayInputStream(encoding);\n        ASN1InputStream         aIn = new ASN1InputStream(bIn);\n        ASN1Sequence            s = (ASN1Sequence)aIn.readObject();\n\n        BigInteger[]            sig = new BigInteger[2];\n\n        sig[0] = ((ASN1Integer)s.getObjectAt(0)).getValue();\n        sig[1] = ((ASN1Integer)s.getObjectAt(1)).getValue();\n\n        return sig;\n    }\n\n    public String getName()\n    {\n        return \"DSA/ECDSA\";\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new DSATest());\n    }\n\n    private class DSATestSecureRandom\n        extends TestRandomData\n    {\n        private boolean first = true;\n\n        public DSATestSecureRandom(byte[] value)\n        {\n            super(value);\n        }\n\n       public void nextBytes(byte[] bytes)\n       {\n           if (first)\n           {\n               super.nextBytes(bytes);\n               first = false;\n           }\n           else\n           {\n               bytes[bytes.length - 1] = 2;\n           }\n       }\n    }\n}\n"], "filenames": ["core/src/main/java/org/bouncycastle/crypto/signers/DSASigner.java", "core/src/test/java/org/bouncycastle/crypto/test/DSATest.java", "prov/src/test/java/org/bouncycastle/jce/provider/test/DSATest.java"], "buggy_code_start_loc": [98, 47, 689], "buggy_code_end_loc": [165, 655, 690], "fixing_code_start_loc": [98, 47, 689], "fixing_code_end_loc": [175, 673, 692], "type": "CWE-361", "message": "In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well.", "other": {"cve": {"id": "CVE-2016-1000341", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-04T13:29:00.340", "lastModified": "2020-10-20T22:15:17.247", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well."}, {"lang": "es", "value": "En Bouncy Castle JCE Provider, en versiones 1.55 y anteriores, la generaci\u00f3n de firmas DSA es vulnerable a ataques de sincronizaci\u00f3n. En los casos en los que se puede observar detenidamente la sincronizaci\u00f3n para la generaci\u00f3n de firmas, la falta de blindaje en las versiones 1.55 o anteriores puede permitir que un atacante obtenga informaci\u00f3n sobre el valor k de la firma y, en \u00faltima instancia, tambi\u00e9n del valor privado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-361"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bouncycastle:legion-of-the-bouncy-castle-java-crytography-api:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.55", "matchCriteriaId": "946393A6-EEE2-4502-9309-81514DB5755B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:2669", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:2927", "source": "cve@mitre.org"}, {"url": "https://github.com/bcgit/bc-java/commit/acaac81f96fec91ab45bd0412beaf9c3acd8defa#diff-e75226a9ca49217a7276b29242ec59ce", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00009.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20181127-0004/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3727-1/", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/bcgit/bc-java/commit/acaac81f96fec91ab45bd0412beaf9c3acd8defa#diff-e75226a9ca49217a7276b29242ec59ce"}}