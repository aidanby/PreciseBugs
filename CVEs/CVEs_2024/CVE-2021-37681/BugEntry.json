{"buggy_code": ["/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n\n#include <algorithm>\n#include <complex>\n#include <limits>\n#include <memory>\n#ifndef TF_LITE_STATIC_MEMORY\n#include <string>\n#endif  // TF_LITE_STATIC_MEMORY\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/cppmath.h\"\n#include \"tensorflow/lite/kernels/internal/quantization_util.h\"\n\n#if defined(__APPLE__)\n#include \"TargetConditionals.h\"\n#endif\n\nnamespace tflite {\n\nnamespace {\n\n// Assumes tensor_index is a valid index (in bounds)\ninline TfLiteTensor* GetTensorAtIndex(const TfLiteContext* context,\n                                      int tensor_index) {\n  if (context->tensors != nullptr) {\n    return &context->tensors[tensor_index];\n  } else {\n    return context->GetTensor(context, tensor_index);\n  }\n}\n\n// Validate in a single place to reduce binary size\ninline TfLiteStatus ValidateTensorIndexingSafe(const TfLiteContext* context,\n                                               int index, int max_size,\n                                               const int* tensor_indices,\n                                               int* tensor_index) {\n  if (index < 0 || index >= max_size) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Invalid tensor index %d (not in [0, %d))\\n\", index,\n                       max_size);\n    return kTfLiteError;\n  }\n  if (tensor_indices[index] == kTfLiteOptionalTensor) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Tensor at index %d was optional but was expected\\n\",\n                       index);\n    return kTfLiteError;\n  }\n\n  *tensor_index = tensor_indices[index];\n  return kTfLiteOk;\n}\n\n// Same as above but returns -1 for invalid inputs instead of status + logging\n// error.\ninline int ValidateTensorIndexing(const TfLiteContext* context, int index,\n                                  int max_size, const int* tensor_indices) {\n  if (index >= 0 && index < max_size) {\n    const int tensor_index = tensor_indices[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      return tensor_index;\n    }\n  }\n  return -1;\n}\n\ninline TfLiteTensor* GetMutableInput(const TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->inputs->size, node->inputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\ninline TfLiteStatus GetMutableInputSafe(const TfLiteContext* context,\n                                        const TfLiteNode* node, int index,\n                                        const TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->inputs->size,\n                                          node->inputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n\n}  // anonymous namespace.\n\nconst TfLiteTensor* GetInput(const TfLiteContext* context,\n                             const TfLiteNode* node, int index) {\n  return GetMutableInput(context, node, index);\n}\n\nTfLiteStatus GetInputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                          int index, const TfLiteTensor** tensor) {\n  return GetMutableInputSafe(context, node, index, tensor);\n}\n\nTfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                               int index) {\n  TfLiteTensor* tensor = GetMutableInput(context, node, index);\n  return tensor->is_variable ? tensor : nullptr;\n}\n\nTfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->outputs->size, node->outputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\nTfLiteStatus GetOutputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                           int index, TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->outputs->size,\n                                          node->outputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n\nconst TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  return GetInput(context, node, index);\n}\n\n#ifndef TF_LITE_STATIC_MEMORY\nTfLiteTensor* GetTemporary(TfLiteContext* context, const TfLiteNode* node,\n                           int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->temporaries->size, node->temporaries->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\nTfLiteStatus GetTemporarySafe(const TfLiteContext* context,\n                              const TfLiteNode* node, int index,\n                              TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->temporaries->size,\n                                 node->temporaries->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n\nconst TfLiteTensor* GetIntermediates(TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->intermediates->size, node->intermediates->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\nTfLiteStatus GetIntermediatesSafe(const TfLiteContext* context,\n                                  const TfLiteNode* node, int index,\n                                  TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->intermediates->size,\n                                 node->intermediates->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n#endif  // TF_LITE_STATIC_MEMORY\n\n// Per-axis\nTfLiteStatus PopulateConvolutionQuantizationParams(\n    TfLiteContext* context, const TfLiteTensor* input,\n    const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* output,\n    const TfLiteFusedActivation& activation, int32_t* multiplier, int* shift,\n    int32_t* output_activation_min, int32_t* output_activation_max,\n    int32_t* per_channel_multiplier, int32_t* per_channel_shift) {\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n  return PopulateConvolutionQuantizationParams(\n      context, input, filter, bias, output, activation, multiplier, shift,\n      output_activation_min, output_activation_max, per_channel_multiplier,\n      per_channel_shift, affine_quantization->scale->size);\n}\n\n// Per-axis & per-tensor\nTfLiteStatus PopulateConvolutionQuantizationParams(\n    TfLiteContext* context, const TfLiteTensor* input,\n    const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* output,\n    const TfLiteFusedActivation& activation, int32_t* multiplier, int* shift,\n    int32_t* output_activation_min, int32_t* output_activation_max,\n    int32_t* per_channel_multiplier, int32_t* per_channel_shift,\n    int num_channels) {\n  TF_LITE_ENSURE_EQ(context, input->quantization.type,\n                    kTfLiteAffineQuantization);\n  TF_LITE_ENSURE_EQ(context, filter->quantization.type,\n                    kTfLiteAffineQuantization);\n  // TODO(jianlijianli): Enable bias type check and bias scale == input scale\n  // * filter scale for each channel in affine quantization once bias\n  // quantization is properly populated.\n  // TF_LITE_ENSURE_EQ(context, bias->quantization.type,\n  // kTfLiteAffineQuantization);\n\n  // Check data type.\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n  TF_LITE_ENSURE(context, affine_quantization);\n  TF_LITE_ENSURE(context, affine_quantization->scale);\n  const bool is_per_channel = affine_quantization->scale->size > 1;\n  if (is_per_channel) {\n    //  Currently only Int8/Int16 is supported for per channel quantization.\n    TF_LITE_ENSURE(context,\n                   input->type == kTfLiteInt8 || input->type == kTfLiteInt16);\n    TF_LITE_ENSURE_EQ(context, filter->type, kTfLiteInt8);\n    TF_LITE_ENSURE_EQ(context, affine_quantization->scale->size, num_channels);\n    TF_LITE_ENSURE_EQ(\n        context, num_channels,\n        filter->dims->data[affine_quantization->quantized_dimension]);\n  }\n\n  // Populate multiplier and shift using affine quantization.\n  const float input_scale = input->params.scale;\n  const float output_scale = output->params.scale;\n  const float* filter_scales = affine_quantization->scale->data;\n  for (int i = 0; i < num_channels; ++i) {\n    // If per-tensor quantization parameter is specified, broadcast it along the\n    // quantization dimension (channels_out).\n    const float scale = is_per_channel ? filter_scales[i] : filter_scales[0];\n    const double filter_scale = static_cast<double>(scale);\n    const double effective_output_scale = static_cast<double>(input_scale) *\n                                          filter_scale /\n                                          static_cast<double>(output_scale);\n    int32_t significand;\n    int channel_shift;\n    QuantizeMultiplier(effective_output_scale, &significand, &channel_shift);\n    per_channel_multiplier[i] = significand;\n    per_channel_shift[i] = channel_shift;\n  }\n\n  // Populate scalar quantization parameters.\n  // This check on legacy quantization parameters is kept only for backward\n  // compatibility.\n  if (input->type == kTfLiteUInt8) {\n    // Check bias scale == input scale * filter scale.\n    double real_multiplier = 0.0;\n    TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(\n        context, input, filter, bias, output, &real_multiplier));\n    int exponent;\n\n    // Populate quantization parameters with multiplier and shift.\n    QuantizeMultiplier(real_multiplier, multiplier, &exponent);\n    *shift = -exponent;\n  }\n  if (input->type == kTfLiteInt8 || input->type == kTfLiteUInt8 ||\n      input->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, activation, output, output_activation_min,\n        output_activation_max));\n  }\n  return kTfLiteOk;\n}\n\nTfLiteStatus GetQuantizedConvolutionMultipler(TfLiteContext* context,\n                                              const TfLiteTensor* input,\n                                              const TfLiteTensor* filter,\n                                              const TfLiteTensor* bias,\n                                              TfLiteTensor* output,\n                                              double* multiplier) {\n  const double input_product_scale = static_cast<double>(input->params.scale) *\n                                     static_cast<double>(filter->params.scale);\n  // The following conditions must be guaranteed by the training pipeline.\n  if (bias) {\n    const double bias_scale = static_cast<double>(bias->params.scale);\n    // Here we're making sure the input_product_scale & bias_scale are about the\n    // same. Since we have:\n    // (output - output_zp) * output_scale =\n    // input_product_scale * input_product + bias * bias_scale ---- (0)\n    //\n    // (0) equals:\n    // (input_product + bias) * input_product_scale ----- (1)\n    //           +\n    // bias * (bias_scale - input_product_scale)   ------ (2)\n    //\n    // For the real kernel computation, we're doing (1), so we really need to\n    // make sure (2) has minimum impact on the output, so:\n    // bias * (bias_scale - input_product_scale) / output_scale should be\n    // a small number for an integer.\n    // Since normally bias should be within a small range.\n    // We should expect (bias_scale - input_product_scale) / output_scale to\n    // be a small number like 0.02.\n    const double scale_diff = std::abs(input_product_scale - bias_scale);\n    const double output_scale = static_cast<double>(output->params.scale);\n\n    TF_LITE_ENSURE(context, scale_diff / output_scale <= 0.02);\n  }\n  return GetQuantizedConvolutionMultipler(context, input, filter, output,\n                                          multiplier);\n}\n\nTfLiteStatus GetQuantizedConvolutionMultipler(TfLiteContext* context,\n                                              const TfLiteTensor* input,\n                                              const TfLiteTensor* filter,\n                                              TfLiteTensor* output,\n                                              double* multiplier) {\n  const double input_product_scale =\n      static_cast<double>(input->params.scale * filter->params.scale);\n  TF_LITE_ENSURE(context, input_product_scale >= 0);\n  *multiplier = input_product_scale / static_cast<double>(output->params.scale);\n\n  return kTfLiteOk;\n}\n\nnamespace {\n\ninline TfLiteStatus Quantize(TfLiteContext* context, float scale,\n                             int32_t zero_point, float f, int32_t& q) {\n  const float tmp = TfLiteRound(f / scale);\n  const bool no_integer_overflow_from_quantization =\n      (tmp >= static_cast<float>(std::numeric_limits<int32_t>::min()) &&\n       tmp <= static_cast<float>(std::numeric_limits<int32_t>::max()));\n  TF_LITE_ENSURE(context, no_integer_overflow_from_quantization);\n  q = zero_point + static_cast<int32_t>(tmp);\n  return kTfLiteOk;\n}\n\nTfLiteStatus CalculateActivationRangeQuantizedImpl(\n    TfLiteContext* context, TfLiteFusedActivation activation, int32_t qmin,\n    int32_t qmax, TfLiteTensor* output, int32_t* act_min, int32_t* act_max) {\n  const auto scale = output->params.scale;\n  const auto zero_point = output->params.zero_point;\n\n  int32_t tmp_q;\n  if (activation == kTfLiteActRelu) {\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 0.0, tmp_q));\n    *act_min = std::max(qmin, tmp_q);\n    *act_max = qmax;\n  } else if (activation == kTfLiteActRelu6) {\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 0.0, tmp_q));\n    *act_min = std::max(qmin, tmp_q);\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 6.0, tmp_q));\n    *act_max = std::min(qmax, tmp_q);\n  } else if (activation == kTfLiteActReluN1To1) {\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, -1.0, tmp_q));\n    *act_min = std::max(qmin, tmp_q);\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 1.0, tmp_q));\n    *act_max = std::min(qmax, tmp_q);\n  } else {\n    *act_min = qmin;\n    *act_max = qmax;\n  }\n  return kTfLiteOk;\n}\n}  // namespace\n\nTfLiteStatus CalculateActivationRangeQuantized(TfLiteContext* context,\n                                               TfLiteFusedActivation activation,\n                                               TfLiteTensor* output,\n                                               int32_t* act_min,\n                                               int32_t* act_max) {\n  int32_t qmin = 0;\n  int32_t qmax = 0;\n  if (output->type == kTfLiteUInt8) {\n    qmin = std::numeric_limits<uint8_t>::min();\n    qmax = std::numeric_limits<uint8_t>::max();\n  } else if (output->type == kTfLiteInt8) {\n    qmin = std::numeric_limits<int8_t>::min();\n    qmax = std::numeric_limits<int8_t>::max();\n  } else if (output->type == kTfLiteInt16) {\n    qmin = std::numeric_limits<int16_t>::min();\n    qmax = std::numeric_limits<int16_t>::max();\n  } else {\n    TF_LITE_ENSURE(context, false);\n  }\n\n  return CalculateActivationRangeQuantizedImpl(context, activation, qmin, qmax,\n                                               output, act_min, act_max);\n}\n\nbool HaveSameShapes(const TfLiteTensor* input1, const TfLiteTensor* input2) {\n  return TfLiteIntArrayEqual(input1->dims, input2->dims);\n}\n\n#ifndef TF_LITE_STATIC_MEMORY\n\n// TODO(b/172067338): Having this function be part of TF_LITE_STATIC_MEMORY\n// build results in a 6KB size increase, even though the function is unsused for\n// that build. What appears to be happening is that while the linker drops the\n// unsused function, the string library that gets pulled in is not dropped,\n// resulting in the increased binary size.\nstd::string GetShapeDebugString(const TfLiteIntArray* shape) {\n  std::string str;\n  for (int d = 0; d < shape->size; ++d) {\n    if (str.empty())\n      str = \"[\" + std::to_string(shape->data[d]);\n    else\n      str += \", \" + std::to_string(shape->data[d]);\n  }\n  str += \"]\";\n  return str;\n}\n\nTfLiteStatus CalculateShapeForBroadcast(TfLiteContext* context,\n                                        const TfLiteTensor* input1,\n                                        const TfLiteTensor* input2,\n                                        TfLiteIntArray** output_shape) {\n  const int dims1 = NumDimensions(input1);\n  const int dims2 = NumDimensions(input2);\n  const int out_dims = std::max(dims1, dims2);\n\n  std::unique_ptr<TfLiteIntArray, void (*)(TfLiteIntArray*)> shape(\n      TfLiteIntArrayCreate(out_dims), TfLiteIntArrayFree);\n  for (int i = 0; i < out_dims; ++i) {\n    const int d1 = i >= dims1 ? 1 : SizeOfDimension(input1, dims1 - i - 1);\n    const int d2 = i >= dims2 ? 1 : SizeOfDimension(input2, dims2 - i - 1);\n    if (!(d1 == d2 || d1 == 1 || d2 == 1)) {\n      context->ReportError(context,\n                           \"Given shapes, %s and %s, are not broadcastable.\",\n                           GetShapeDebugString(input1->dims).c_str(),\n                           GetShapeDebugString(input2->dims).c_str());\n      return kTfLiteError;\n    }\n\n    if (d1 == 0 || d2 == 0) {\n      shape->data[out_dims - i - 1] = 0;\n    } else {\n      shape->data[out_dims - i - 1] = std::max(d1, d2);\n    }\n  }\n  *output_shape = shape.release();\n  return kTfLiteOk;\n}\n\nTfLiteStatus CalculateShapeForBroadcast(TfLiteContext* context,\n                                        const TfLiteTensor* input1,\n                                        const TfLiteTensor* input2,\n                                        const TfLiteTensor* input3,\n                                        TfLiteIntArray** output_shape) {\n  const int dims1 = NumDimensions(input1);\n  const int dims2 = NumDimensions(input2);\n  const int dims3 = NumDimensions(input3);\n  const int out_dims = std::max(std::max(dims1, dims2), dims3);\n  std::unique_ptr<TfLiteIntArray, void (*)(TfLiteIntArray*)> shape(\n      TfLiteIntArrayCreate(out_dims), TfLiteIntArrayFree);\n  for (int i = 0; i < out_dims; ++i) {\n    const int d1 = i >= dims1 ? 1 : SizeOfDimension(input1, dims1 - i - 1);\n    const int d2 = i >= dims2 ? 1 : SizeOfDimension(input2, dims2 - i - 1);\n    const int d3 = i >= dims3 ? 1 : SizeOfDimension(input3, dims3 - i - 1);\n    const int min_value = std::min(std::min(d1, d2), d3);\n    int max_value = std::max(std::max(d1, d2), d3);\n    // If one dimention is 0, others must be 0 or 1.\n    if (min_value == 0) max_value = 0;\n    if (!(d1 == 1 || d1 == max_value) || !(d2 == 1 || d2 == max_value) ||\n        !(d3 == 1 || d3 == max_value)) {\n      context->ReportError(\n          context, \"Given shapes, %s, %s and %s, are not broadcastable.\",\n          GetShapeDebugString(input1->dims).c_str(),\n          GetShapeDebugString(input2->dims).c_str(),\n          GetShapeDebugString(input3->dims).c_str());\n      return kTfLiteError;\n    }\n    shape->data[out_dims - i - 1] = max_value;\n  }\n  *output_shape = shape.release();\n  return kTfLiteOk;\n}\n#endif  // TF_LITE_STATIC_MEMORY\n\n// Size of string is not constant, return 0 in such case.\nint TfLiteTypeGetSize(TfLiteType type) {\n  switch (type) {\n    case kTfLiteUInt8:\n      static_assert(sizeof(uint8_t) == 1, \"\");\n      return 1;\n    case kTfLiteInt8:\n      static_assert(sizeof(int8_t) == 1, \"\");\n      return 1;\n    case kTfLiteBool:\n      return sizeof(bool);\n    case kTfLiteInt16:\n      static_assert(sizeof(int16_t) == 2, \"\");\n      return 2;\n    case kTfLiteFloat16:\n      static_assert(sizeof(int16_t) == 2, \"\");\n      return 2;\n    case kTfLiteFloat32:\n      static_assert(sizeof(float) == 4, \"\");\n      return 4;\n    case kTfLiteInt32:\n      static_assert(sizeof(int32_t) == 4, \"\");\n      return 4;\n    case kTfLiteUInt32:\n      static_assert(sizeof(uint32_t) == 4, \"\");\n      return 4;\n    case kTfLiteInt64:\n      static_assert(sizeof(int64_t) == 8, \"\");\n      return 8;\n    case kTfLiteUInt64:\n      static_assert(sizeof(uint64_t) == 8, \"\");\n      return 8;\n    case kTfLiteFloat64:\n      static_assert(sizeof(double) == 8, \"\");\n      return 8;\n    case kTfLiteComplex64:\n      static_assert(sizeof(std::complex<float>) == 8, \"\");\n      return 8;\n    case kTfLiteComplex128:\n      static_assert(sizeof(std::complex<double>) == 16, \"\");\n      return 16;\n    default:\n      return 0;\n  }\n}\n\nbool IsMobilePlatform() {\n#if defined(ANDROID) || defined(__ANDROID__)\n  return true;\n#elif defined(__APPLE__)\n#if TARGET_IPHONE_SIMULATOR || TARGET_OS_IPHONE\n  return true;\n#endif\n#endif\n  return false;\n}\n\n}  // namespace tflite\n", "/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// SVDF op that compresses a fully connected op via low-rank matrix\n// factorization. See https://research.google.com/pubs/archive/43813.pdf for\n// details.\n\n#include \"tensorflow/lite/kernels/internal/reference/svdf.h\"\n\n#include <cstddef>\n#include <cstdint>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/compatibility.h\"\n#include \"tensorflow/lite/kernels/internal/quantization_util.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_utils.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace svdf {\n\nnamespace {\n\nstruct OpData {\n  int scratch_tensor_index;\n  bool float_weights_time_initialized;\n  int32 effective_scale_1_a;\n  int effective_scale_1_b;\n  int32 effective_scale_2_a;\n  int effective_scale_2_b;\n  bool compute_row_sums = false;\n};\n\n}  // namespace\n\n// Input tensors.\nconstexpr int kInputTensor = 0;\nconstexpr int kWeightsFeatureTensor = 1;\nconstexpr int kWeightsTimeTensor = 2;\nconstexpr int kBiasTensor = 3;\n// This is a variable tensor, and will be modified by this op.\nconstexpr int kStateTensor = 4;\n\n// Output tensor.\nconstexpr int kOutputTensor = 0;\n\nvoid* Init(TfLiteContext* context, const char* buffer, size_t length) {\n  auto* op_data = new OpData();\n  op_data->float_weights_time_initialized = false;\n  // Note: only needs 6 scratch tensors when is_hybrid_op, only 1 otherwise.\n  context->AddTensors(context, /*tensors_to_add=*/6,\n                      &op_data->scratch_tensor_index);\n  return op_data;\n}\n\nvoid Free(TfLiteContext* context, void* buffer) {\n  delete reinterpret_cast<OpData*>(buffer);\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int scratch_tensor_index = op_data->scratch_tensor_index;\n\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* weights_feature;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,\n                                          &weights_feature));\n  const TfLiteTensor* weights_time;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));\n\n  TF_LITE_ENSURE(context,\n                 input->type == kTfLiteFloat32 || input->type == kTfLiteInt8);\n\n  // Check all the parameters of tensor match within themselves and match the\n  // input configuration.\n  const int rank = params->rank;\n  const int batch_size = input->dims->data[0];\n  const int num_filters = weights_feature->dims->data[0];\n  TF_LITE_ENSURE(context, rank != 0);\n  TF_LITE_ENSURE_EQ(context, num_filters % rank, 0);\n  const int num_units = num_filters / rank;\n  const int memory_size = weights_time->dims->data[1];\n  TF_LITE_ENSURE_EQ(context, input->dims->data[1],\n                    weights_feature->dims->data[1]);\n  TF_LITE_ENSURE_EQ(context, weights_time->dims->data[0], num_filters);\n\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n  if (bias) {\n    TF_LITE_ENSURE_EQ(context, bias->dims->data[0], num_units);\n  }\n\n  const TfLiteTensor* state;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kStateTensor, &state));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  // Check the shape of input state tensors.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(state), 2);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 0), batch_size);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 1),\n                    memory_size * num_filters);\n\n  // Resize output.\n  TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(2);\n  output_size_array->data[0] = batch_size;\n  output_size_array->data[1] = num_units;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_size_array));\n\n  // The weights are of consistent type, so it suffices to check one.\n  const bool is_hybrid_op = IsHybridOp(input, weights_feature);\n  const bool is_full_integer = input->type == kTfLiteInt8;\n\n  // Resize scratch.\n  TfLiteIntArrayFree(node->temporaries);\n  if (is_hybrid_op) {\n    node->temporaries = TfLiteIntArrayCreate(6);\n  } else if (is_full_integer) {\n    node->temporaries = TfLiteIntArrayCreate(2);\n  } else {\n    node->temporaries = TfLiteIntArrayCreate(1);\n  }\n  node->temporaries->data[0] = scratch_tensor_index;\n\n  TfLiteIntArray* scratch_size_array = TfLiteIntArrayCreate(2);\n  scratch_size_array->data[0] = batch_size;\n  scratch_size_array->data[1] = num_filters;\n\n  TfLiteTensor* scratch_tensor;\n  TF_LITE_ENSURE_OK(\n      context, GetTemporarySafe(context, node, /*index=*/0, &scratch_tensor));\n\n  // The scratch buffer is of type int32 for full integer svdf and it's of type\n  // float32 for hybrid and float case.\n  if (is_full_integer) {\n    scratch_tensor->type = kTfLiteInt32;\n  } else {\n    scratch_tensor->type = kTfLiteFloat32;\n  }\n  scratch_tensor->allocation_type = kTfLiteArenaRw;\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_tensor,\n                                                   scratch_size_array));\n\n  if (is_hybrid_op) {\n    op_data->compute_row_sums = true;\n    // Tell interpreter to allocate temporary tensors to store quantized values\n    // of input tensors.\n    node->temporaries->data[1] = scratch_tensor_index + 1;\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,\n                                                &input_quantized));\n    input_quantized->type = weights_feature->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    // Tell interpreter to allocate temporary tensors to store scaling factors.\n    node->temporaries->data[2] = scratch_tensor_index + 2;\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,\n                                                &scaling_factors));\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n\n    // Used to store dequantized weights_time matrix for hybrid computation of\n    // matmul(state, weights_time), which occurs in floating point.\n    node->temporaries->data[3] = scratch_tensor_index + 3;\n    TfLiteTensor* float_weights_time;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,\n                                                &float_weights_time));\n    float_weights_time->type = kTfLiteFloat32;\n    // Persistent so that we can compute the dequantized weights only once.\n    float_weights_time->allocation_type = kTfLiteArenaRwPersistent;\n    if (!TfLiteIntArrayEqual(float_weights_time->dims, weights_time->dims)) {\n      TfLiteIntArray* float_weights_time_size =\n          TfLiteIntArrayCopy(weights_time->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, float_weights_time,\n                                              float_weights_time_size));\n    }\n\n    node->temporaries->data[4] = scratch_tensor_index + 4;\n    TfLiteTensor* zero_points;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/4, &zero_points));\n    zero_points->type = kTfLiteFloat32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = zero_points_dims[0];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n\n    node->temporaries->data[5] = scratch_tensor_index + 5;\n    TfLiteTensor* row_sums;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, /*index=*/5, &row_sums));\n    row_sums->type = kTfLiteFloat32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_dims[1] = {num_filters};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);\n      row_sums_size->data[0] = row_sums_dims[0];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n  if (is_full_integer) {\n    // Allocated one extra tensor.\n    TfLiteIntArray* output_temp_size_array = TfLiteIntArrayCreate(2);\n    output_temp_size_array->data[0] = num_units;\n    output_temp_size_array->data[1] = batch_size;\n    node->temporaries->data[1] = scratch_tensor_index + 1;\n    TfLiteTensor* output_temp;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));\n    output_temp->type = kTfLiteInt32;\n    output_temp->allocation_type = kTfLiteArenaRw;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_temp,\n                                                     output_temp_size_array));\n\n    // Calculate effective scales.\n    auto* input_params =\n        reinterpret_cast<TfLiteAffineQuantization*>(input->quantization.params);\n    auto* weights_feature_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        weights_feature->quantization.params);\n    auto* state_params =\n        reinterpret_cast<TfLiteAffineQuantization*>(state->quantization.params);\n    auto* weight_time_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        weights_time->quantization.params);\n    auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        output->quantization.params);\n    const double effective_scale_1 = input_params->scale->data[0] *\n                                     weights_feature_params->scale->data[0] /\n                                     state_params->scale->data[0];\n    const double effective_scale_2 = state_params->scale->data[0] *\n                                     weight_time_params->scale->data[0] /\n                                     output_params->scale->data[0];\n    QuantizeMultiplier(effective_scale_1, &op_data->effective_scale_1_a,\n                       &op_data->effective_scale_1_b);\n    QuantizeMultiplier(effective_scale_2, &op_data->effective_scale_2_a,\n                       &op_data->effective_scale_2_b);\n  }\n  return kTfLiteOk;\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* weights_feature;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,\n                                          &weights_feature));\n  const TfLiteTensor* weights_time;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n\n  TfLiteTensor* scratch;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, /*index=*/0, &scratch));\n\n  TfLiteTensor* state = GetVariableInput(context, node, kStateTensor);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  switch (weights_feature->type) {\n    case kTfLiteFloat32: {\n      reference_ops::EvalFloatSVDF(\n          params, GetTensorShape(input), GetTensorData<float>(input),\n          GetTensorShape(weights_feature),\n          GetTensorData<float>(weights_feature), GetTensorShape(weights_time),\n          GetTensorData<float>(weights_time), GetTensorShape(bias),\n          GetTensorData<float>(bias), GetTensorData<float>(scratch),\n          GetTensorData<float>(state), GetTensorShape(output),\n          GetTensorData<float>(output));\n      return kTfLiteOk;\n    }\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      if (input->type == kTfLiteFloat32) {\n        TfLiteTensor* input_quantized;\n        TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,\n                                                    &input_quantized));\n        TfLiteTensor* scaling_factors;\n        TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,\n                                                    &scaling_factors));\n        TfLiteTensor* float_weights_time;\n        TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,\n                                                    &float_weights_time));\n        TfLiteTensor* zero_points;\n        TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/4,\n                                                    &zero_points));\n        TfLiteTensor* row_sums;\n        TF_LITE_ENSURE_OK(\n            context, GetTemporarySafe(context, node, /*index=*/5, &row_sums));\n        // Dequantize weights time.\n        // TODO(alanchiao): this dequantization initialization only needs to\n        // happen once per model and should theoretically be placed in either\n        // Init or Prepare. However, TFLite doesn't allocate float_weights_time\n        // until the Eval function.\n        // TODO(alanchiao): refactor logic out into dequantize function.\n        if (!op_data->float_weights_time_initialized) {\n          const float dequantization_scale = weights_time->params.scale;\n          const int8_t* weights_time_ptr = GetTensorData<int8_t>(weights_time);\n          float* float_weights_time_ptr =\n              GetTensorData<float>(float_weights_time);\n          for (int i = 0; i < NumElements(float_weights_time); ++i) {\n            float_weights_time_ptr[i] =\n                weights_time_ptr[i] * dequantization_scale;\n          }\n          op_data->float_weights_time_initialized = true;\n        }\n\n        int32_t* zero_points_ptr = nullptr;\n        int32_t* row_sums_ptr = nullptr;\n        if (params->asymmetric_quantize_inputs && row_sums != nullptr) {\n          zero_points_ptr = GetTensorData<int32_t>(zero_points);\n          row_sums_ptr = GetTensorData<int32_t>(row_sums);\n        }\n\n        reference_ops::EvalHybridSVDF(\n            params, GetTensorShape(input), GetTensorData<float>(input),\n            GetTensorShape(weights_feature),\n            GetTensorData<int8_t>(weights_feature),\n            weights_feature->params.scale, GetTensorShape(float_weights_time),\n            GetTensorData<float>(float_weights_time), GetTensorShape(bias),\n            GetTensorData<float>(bias), GetTensorData<float>(scratch),\n            GetTensorData<float>(scaling_factors),\n            GetTensorData<int8_t>(input_quantized), GetTensorData<float>(state),\n            GetTensorShape(output), GetTensorData<float>(output),\n            zero_points_ptr, row_sums_ptr, &op_data->compute_row_sums);\n        return kTfLiteOk;\n      }\n      auto* input_params = reinterpret_cast<TfLiteAffineQuantization*>(\n          input->quantization.params);\n      auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(\n          output->quantization.params);\n      TfLiteTensor* output_temp;\n      TF_LITE_ENSURE_OK(\n          context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));\n\n      // Currently supports only ReLU.\n      // TODO(jianlijianli): support other activations.\n      TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActRelu);\n\n      reference_ops::EvalIntegerSVDF(\n          params, GetTensorShape(input), GetTensorData<int8_t>(input),\n          GetTensorShape(weights_feature),\n          GetTensorData<int8_t>(weights_feature), GetTensorShape(weights_time),\n          GetTensorData<int16_t>(weights_time), GetTensorShape(bias),\n          GetTensorData<int32_t>(bias), GetTensorData<int16_t>(state),\n          GetTensorShape(output), GetTensorData<int8_t>(output),\n          GetTensorData<int32_t>(scratch), GetTensorData<int32_t>(output_temp),\n          op_data->effective_scale_1_a, op_data->effective_scale_1_b,\n          op_data->effective_scale_2_a, op_data->effective_scale_2_b,\n          input_params->zero_point->data[0],\n          output_params->zero_point->data[0]);\n      return kTfLiteOk;\n    }\n    default:\n      context->ReportError(context, \"Type %s not currently supported.\",\n                           TfLiteTypeGetName(weights_feature->type));\n      return kTfLiteError;\n  }\n}\n\n}  // namespace svdf\n\nTfLiteRegistration* Register_SVDF() {\n  static TfLiteRegistration r = {svdf::Init, svdf::Free, svdf::Prepare,\n                                 svdf::Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite\n"], "fixing_code": ["/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n\n#include <algorithm>\n#include <complex>\n#include <limits>\n#include <memory>\n#ifndef TF_LITE_STATIC_MEMORY\n#include <string>\n#endif  // TF_LITE_STATIC_MEMORY\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/cppmath.h\"\n#include \"tensorflow/lite/kernels/internal/quantization_util.h\"\n\n#if defined(__APPLE__)\n#include \"TargetConditionals.h\"\n#endif\n\nnamespace tflite {\n\nnamespace {\n\n// Assumes tensor_index is a valid index (in bounds)\ninline TfLiteTensor* GetTensorAtIndex(const TfLiteContext* context,\n                                      int tensor_index) {\n  if (context->tensors != nullptr) {\n    return &context->tensors[tensor_index];\n  } else {\n    return context->GetTensor(context, tensor_index);\n  }\n}\n\n// Validate in a single place to reduce binary size\ninline TfLiteStatus ValidateTensorIndexingSafe(const TfLiteContext* context,\n                                               int index, int max_size,\n                                               const int* tensor_indices,\n                                               int* tensor_index) {\n  if (index < 0 || index >= max_size) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Invalid tensor index %d (not in [0, %d))\\n\", index,\n                       max_size);\n    return kTfLiteError;\n  }\n  if (tensor_indices[index] == kTfLiteOptionalTensor) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Tensor at index %d was optional but was expected\\n\",\n                       index);\n    return kTfLiteError;\n  }\n\n  *tensor_index = tensor_indices[index];\n  return kTfLiteOk;\n}\n\n// Same as above but returns -1 for invalid inputs instead of status + logging\n// error.\ninline int ValidateTensorIndexing(const TfLiteContext* context, int index,\n                                  int max_size, const int* tensor_indices) {\n  if (index >= 0 && index < max_size) {\n    const int tensor_index = tensor_indices[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      return tensor_index;\n    }\n  }\n  return -1;\n}\n\ninline TfLiteTensor* GetMutableInput(const TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->inputs->size, node->inputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\ninline TfLiteStatus GetMutableInputSafe(const TfLiteContext* context,\n                                        const TfLiteNode* node, int index,\n                                        const TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->inputs->size,\n                                          node->inputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n\n}  // anonymous namespace.\n\nconst TfLiteTensor* GetInput(const TfLiteContext* context,\n                             const TfLiteNode* node, int index) {\n  return GetMutableInput(context, node, index);\n}\n\nTfLiteStatus GetInputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                          int index, const TfLiteTensor** tensor) {\n  return GetMutableInputSafe(context, node, index, tensor);\n}\n\nTfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                               int index) {\n  TfLiteTensor* tensor = GetMutableInput(context, node, index);\n  if (tensor == nullptr) return nullptr;\n  return tensor->is_variable ? tensor : nullptr;\n}\n\nTfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->outputs->size, node->outputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\nTfLiteStatus GetOutputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                           int index, TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->outputs->size,\n                                          node->outputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n\nconst TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  return GetInput(context, node, index);\n}\n\n#ifndef TF_LITE_STATIC_MEMORY\nTfLiteTensor* GetTemporary(TfLiteContext* context, const TfLiteNode* node,\n                           int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->temporaries->size, node->temporaries->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\nTfLiteStatus GetTemporarySafe(const TfLiteContext* context,\n                              const TfLiteNode* node, int index,\n                              TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->temporaries->size,\n                                 node->temporaries->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n\nconst TfLiteTensor* GetIntermediates(TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->intermediates->size, node->intermediates->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\nTfLiteStatus GetIntermediatesSafe(const TfLiteContext* context,\n                                  const TfLiteNode* node, int index,\n                                  TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->intermediates->size,\n                                 node->intermediates->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n#endif  // TF_LITE_STATIC_MEMORY\n\n// Per-axis\nTfLiteStatus PopulateConvolutionQuantizationParams(\n    TfLiteContext* context, const TfLiteTensor* input,\n    const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* output,\n    const TfLiteFusedActivation& activation, int32_t* multiplier, int* shift,\n    int32_t* output_activation_min, int32_t* output_activation_max,\n    int32_t* per_channel_multiplier, int32_t* per_channel_shift) {\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n  return PopulateConvolutionQuantizationParams(\n      context, input, filter, bias, output, activation, multiplier, shift,\n      output_activation_min, output_activation_max, per_channel_multiplier,\n      per_channel_shift, affine_quantization->scale->size);\n}\n\n// Per-axis & per-tensor\nTfLiteStatus PopulateConvolutionQuantizationParams(\n    TfLiteContext* context, const TfLiteTensor* input,\n    const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* output,\n    const TfLiteFusedActivation& activation, int32_t* multiplier, int* shift,\n    int32_t* output_activation_min, int32_t* output_activation_max,\n    int32_t* per_channel_multiplier, int32_t* per_channel_shift,\n    int num_channels) {\n  TF_LITE_ENSURE_EQ(context, input->quantization.type,\n                    kTfLiteAffineQuantization);\n  TF_LITE_ENSURE_EQ(context, filter->quantization.type,\n                    kTfLiteAffineQuantization);\n  // TODO(jianlijianli): Enable bias type check and bias scale == input scale\n  // * filter scale for each channel in affine quantization once bias\n  // quantization is properly populated.\n  // TF_LITE_ENSURE_EQ(context, bias->quantization.type,\n  // kTfLiteAffineQuantization);\n\n  // Check data type.\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n  TF_LITE_ENSURE(context, affine_quantization);\n  TF_LITE_ENSURE(context, affine_quantization->scale);\n  const bool is_per_channel = affine_quantization->scale->size > 1;\n  if (is_per_channel) {\n    //  Currently only Int8/Int16 is supported for per channel quantization.\n    TF_LITE_ENSURE(context,\n                   input->type == kTfLiteInt8 || input->type == kTfLiteInt16);\n    TF_LITE_ENSURE_EQ(context, filter->type, kTfLiteInt8);\n    TF_LITE_ENSURE_EQ(context, affine_quantization->scale->size, num_channels);\n    TF_LITE_ENSURE_EQ(\n        context, num_channels,\n        filter->dims->data[affine_quantization->quantized_dimension]);\n  }\n\n  // Populate multiplier and shift using affine quantization.\n  const float input_scale = input->params.scale;\n  const float output_scale = output->params.scale;\n  const float* filter_scales = affine_quantization->scale->data;\n  for (int i = 0; i < num_channels; ++i) {\n    // If per-tensor quantization parameter is specified, broadcast it along the\n    // quantization dimension (channels_out).\n    const float scale = is_per_channel ? filter_scales[i] : filter_scales[0];\n    const double filter_scale = static_cast<double>(scale);\n    const double effective_output_scale = static_cast<double>(input_scale) *\n                                          filter_scale /\n                                          static_cast<double>(output_scale);\n    int32_t significand;\n    int channel_shift;\n    QuantizeMultiplier(effective_output_scale, &significand, &channel_shift);\n    per_channel_multiplier[i] = significand;\n    per_channel_shift[i] = channel_shift;\n  }\n\n  // Populate scalar quantization parameters.\n  // This check on legacy quantization parameters is kept only for backward\n  // compatibility.\n  if (input->type == kTfLiteUInt8) {\n    // Check bias scale == input scale * filter scale.\n    double real_multiplier = 0.0;\n    TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(\n        context, input, filter, bias, output, &real_multiplier));\n    int exponent;\n\n    // Populate quantization parameters with multiplier and shift.\n    QuantizeMultiplier(real_multiplier, multiplier, &exponent);\n    *shift = -exponent;\n  }\n  if (input->type == kTfLiteInt8 || input->type == kTfLiteUInt8 ||\n      input->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, activation, output, output_activation_min,\n        output_activation_max));\n  }\n  return kTfLiteOk;\n}\n\nTfLiteStatus GetQuantizedConvolutionMultipler(TfLiteContext* context,\n                                              const TfLiteTensor* input,\n                                              const TfLiteTensor* filter,\n                                              const TfLiteTensor* bias,\n                                              TfLiteTensor* output,\n                                              double* multiplier) {\n  const double input_product_scale = static_cast<double>(input->params.scale) *\n                                     static_cast<double>(filter->params.scale);\n  // The following conditions must be guaranteed by the training pipeline.\n  if (bias) {\n    const double bias_scale = static_cast<double>(bias->params.scale);\n    // Here we're making sure the input_product_scale & bias_scale are about the\n    // same. Since we have:\n    // (output - output_zp) * output_scale =\n    // input_product_scale * input_product + bias * bias_scale ---- (0)\n    //\n    // (0) equals:\n    // (input_product + bias) * input_product_scale ----- (1)\n    //           +\n    // bias * (bias_scale - input_product_scale)   ------ (2)\n    //\n    // For the real kernel computation, we're doing (1), so we really need to\n    // make sure (2) has minimum impact on the output, so:\n    // bias * (bias_scale - input_product_scale) / output_scale should be\n    // a small number for an integer.\n    // Since normally bias should be within a small range.\n    // We should expect (bias_scale - input_product_scale) / output_scale to\n    // be a small number like 0.02.\n    const double scale_diff = std::abs(input_product_scale - bias_scale);\n    const double output_scale = static_cast<double>(output->params.scale);\n\n    TF_LITE_ENSURE(context, scale_diff / output_scale <= 0.02);\n  }\n  return GetQuantizedConvolutionMultipler(context, input, filter, output,\n                                          multiplier);\n}\n\nTfLiteStatus GetQuantizedConvolutionMultipler(TfLiteContext* context,\n                                              const TfLiteTensor* input,\n                                              const TfLiteTensor* filter,\n                                              TfLiteTensor* output,\n                                              double* multiplier) {\n  const double input_product_scale =\n      static_cast<double>(input->params.scale * filter->params.scale);\n  TF_LITE_ENSURE(context, input_product_scale >= 0);\n  *multiplier = input_product_scale / static_cast<double>(output->params.scale);\n\n  return kTfLiteOk;\n}\n\nnamespace {\n\ninline TfLiteStatus Quantize(TfLiteContext* context, float scale,\n                             int32_t zero_point, float f, int32_t& q) {\n  const float tmp = TfLiteRound(f / scale);\n  const bool no_integer_overflow_from_quantization =\n      (tmp >= static_cast<float>(std::numeric_limits<int32_t>::min()) &&\n       tmp <= static_cast<float>(std::numeric_limits<int32_t>::max()));\n  TF_LITE_ENSURE(context, no_integer_overflow_from_quantization);\n  q = zero_point + static_cast<int32_t>(tmp);\n  return kTfLiteOk;\n}\n\nTfLiteStatus CalculateActivationRangeQuantizedImpl(\n    TfLiteContext* context, TfLiteFusedActivation activation, int32_t qmin,\n    int32_t qmax, TfLiteTensor* output, int32_t* act_min, int32_t* act_max) {\n  const auto scale = output->params.scale;\n  const auto zero_point = output->params.zero_point;\n\n  int32_t tmp_q;\n  if (activation == kTfLiteActRelu) {\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 0.0, tmp_q));\n    *act_min = std::max(qmin, tmp_q);\n    *act_max = qmax;\n  } else if (activation == kTfLiteActRelu6) {\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 0.0, tmp_q));\n    *act_min = std::max(qmin, tmp_q);\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 6.0, tmp_q));\n    *act_max = std::min(qmax, tmp_q);\n  } else if (activation == kTfLiteActReluN1To1) {\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, -1.0, tmp_q));\n    *act_min = std::max(qmin, tmp_q);\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 1.0, tmp_q));\n    *act_max = std::min(qmax, tmp_q);\n  } else {\n    *act_min = qmin;\n    *act_max = qmax;\n  }\n  return kTfLiteOk;\n}\n}  // namespace\n\nTfLiteStatus CalculateActivationRangeQuantized(TfLiteContext* context,\n                                               TfLiteFusedActivation activation,\n                                               TfLiteTensor* output,\n                                               int32_t* act_min,\n                                               int32_t* act_max) {\n  int32_t qmin = 0;\n  int32_t qmax = 0;\n  if (output->type == kTfLiteUInt8) {\n    qmin = std::numeric_limits<uint8_t>::min();\n    qmax = std::numeric_limits<uint8_t>::max();\n  } else if (output->type == kTfLiteInt8) {\n    qmin = std::numeric_limits<int8_t>::min();\n    qmax = std::numeric_limits<int8_t>::max();\n  } else if (output->type == kTfLiteInt16) {\n    qmin = std::numeric_limits<int16_t>::min();\n    qmax = std::numeric_limits<int16_t>::max();\n  } else {\n    TF_LITE_ENSURE(context, false);\n  }\n\n  return CalculateActivationRangeQuantizedImpl(context, activation, qmin, qmax,\n                                               output, act_min, act_max);\n}\n\nbool HaveSameShapes(const TfLiteTensor* input1, const TfLiteTensor* input2) {\n  return TfLiteIntArrayEqual(input1->dims, input2->dims);\n}\n\n#ifndef TF_LITE_STATIC_MEMORY\n\n// TODO(b/172067338): Having this function be part of TF_LITE_STATIC_MEMORY\n// build results in a 6KB size increase, even though the function is unsused for\n// that build. What appears to be happening is that while the linker drops the\n// unsused function, the string library that gets pulled in is not dropped,\n// resulting in the increased binary size.\nstd::string GetShapeDebugString(const TfLiteIntArray* shape) {\n  std::string str;\n  for (int d = 0; d < shape->size; ++d) {\n    if (str.empty())\n      str = \"[\" + std::to_string(shape->data[d]);\n    else\n      str += \", \" + std::to_string(shape->data[d]);\n  }\n  str += \"]\";\n  return str;\n}\n\nTfLiteStatus CalculateShapeForBroadcast(TfLiteContext* context,\n                                        const TfLiteTensor* input1,\n                                        const TfLiteTensor* input2,\n                                        TfLiteIntArray** output_shape) {\n  const int dims1 = NumDimensions(input1);\n  const int dims2 = NumDimensions(input2);\n  const int out_dims = std::max(dims1, dims2);\n\n  std::unique_ptr<TfLiteIntArray, void (*)(TfLiteIntArray*)> shape(\n      TfLiteIntArrayCreate(out_dims), TfLiteIntArrayFree);\n  for (int i = 0; i < out_dims; ++i) {\n    const int d1 = i >= dims1 ? 1 : SizeOfDimension(input1, dims1 - i - 1);\n    const int d2 = i >= dims2 ? 1 : SizeOfDimension(input2, dims2 - i - 1);\n    if (!(d1 == d2 || d1 == 1 || d2 == 1)) {\n      context->ReportError(context,\n                           \"Given shapes, %s and %s, are not broadcastable.\",\n                           GetShapeDebugString(input1->dims).c_str(),\n                           GetShapeDebugString(input2->dims).c_str());\n      return kTfLiteError;\n    }\n\n    if (d1 == 0 || d2 == 0) {\n      shape->data[out_dims - i - 1] = 0;\n    } else {\n      shape->data[out_dims - i - 1] = std::max(d1, d2);\n    }\n  }\n  *output_shape = shape.release();\n  return kTfLiteOk;\n}\n\nTfLiteStatus CalculateShapeForBroadcast(TfLiteContext* context,\n                                        const TfLiteTensor* input1,\n                                        const TfLiteTensor* input2,\n                                        const TfLiteTensor* input3,\n                                        TfLiteIntArray** output_shape) {\n  const int dims1 = NumDimensions(input1);\n  const int dims2 = NumDimensions(input2);\n  const int dims3 = NumDimensions(input3);\n  const int out_dims = std::max(std::max(dims1, dims2), dims3);\n  std::unique_ptr<TfLiteIntArray, void (*)(TfLiteIntArray*)> shape(\n      TfLiteIntArrayCreate(out_dims), TfLiteIntArrayFree);\n  for (int i = 0; i < out_dims; ++i) {\n    const int d1 = i >= dims1 ? 1 : SizeOfDimension(input1, dims1 - i - 1);\n    const int d2 = i >= dims2 ? 1 : SizeOfDimension(input2, dims2 - i - 1);\n    const int d3 = i >= dims3 ? 1 : SizeOfDimension(input3, dims3 - i - 1);\n    const int min_value = std::min(std::min(d1, d2), d3);\n    int max_value = std::max(std::max(d1, d2), d3);\n    // If one dimention is 0, others must be 0 or 1.\n    if (min_value == 0) max_value = 0;\n    if (!(d1 == 1 || d1 == max_value) || !(d2 == 1 || d2 == max_value) ||\n        !(d3 == 1 || d3 == max_value)) {\n      context->ReportError(\n          context, \"Given shapes, %s, %s and %s, are not broadcastable.\",\n          GetShapeDebugString(input1->dims).c_str(),\n          GetShapeDebugString(input2->dims).c_str(),\n          GetShapeDebugString(input3->dims).c_str());\n      return kTfLiteError;\n    }\n    shape->data[out_dims - i - 1] = max_value;\n  }\n  *output_shape = shape.release();\n  return kTfLiteOk;\n}\n#endif  // TF_LITE_STATIC_MEMORY\n\n// Size of string is not constant, return 0 in such case.\nint TfLiteTypeGetSize(TfLiteType type) {\n  switch (type) {\n    case kTfLiteUInt8:\n      static_assert(sizeof(uint8_t) == 1, \"\");\n      return 1;\n    case kTfLiteInt8:\n      static_assert(sizeof(int8_t) == 1, \"\");\n      return 1;\n    case kTfLiteBool:\n      return sizeof(bool);\n    case kTfLiteInt16:\n      static_assert(sizeof(int16_t) == 2, \"\");\n      return 2;\n    case kTfLiteFloat16:\n      static_assert(sizeof(int16_t) == 2, \"\");\n      return 2;\n    case kTfLiteFloat32:\n      static_assert(sizeof(float) == 4, \"\");\n      return 4;\n    case kTfLiteInt32:\n      static_assert(sizeof(int32_t) == 4, \"\");\n      return 4;\n    case kTfLiteUInt32:\n      static_assert(sizeof(uint32_t) == 4, \"\");\n      return 4;\n    case kTfLiteInt64:\n      static_assert(sizeof(int64_t) == 8, \"\");\n      return 8;\n    case kTfLiteUInt64:\n      static_assert(sizeof(uint64_t) == 8, \"\");\n      return 8;\n    case kTfLiteFloat64:\n      static_assert(sizeof(double) == 8, \"\");\n      return 8;\n    case kTfLiteComplex64:\n      static_assert(sizeof(std::complex<float>) == 8, \"\");\n      return 8;\n    case kTfLiteComplex128:\n      static_assert(sizeof(std::complex<double>) == 16, \"\");\n      return 16;\n    default:\n      return 0;\n  }\n}\n\nbool IsMobilePlatform() {\n#if defined(ANDROID) || defined(__ANDROID__)\n  return true;\n#elif defined(__APPLE__)\n#if TARGET_IPHONE_SIMULATOR || TARGET_OS_IPHONE\n  return true;\n#endif\n#endif\n  return false;\n}\n\n}  // namespace tflite\n", "/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// SVDF op that compresses a fully connected op via low-rank matrix\n// factorization. See https://research.google.com/pubs/archive/43813.pdf for\n// details.\n\n#include \"tensorflow/lite/kernels/internal/reference/svdf.h\"\n\n#include <cstddef>\n#include <cstdint>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/compatibility.h\"\n#include \"tensorflow/lite/kernels/internal/quantization_util.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_utils.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace svdf {\n\nnamespace {\n\nstruct OpData {\n  int scratch_tensor_index;\n  bool float_weights_time_initialized;\n  int32 effective_scale_1_a;\n  int effective_scale_1_b;\n  int32 effective_scale_2_a;\n  int effective_scale_2_b;\n  bool compute_row_sums = false;\n};\n\n}  // namespace\n\n// Input tensors.\nconstexpr int kInputTensor = 0;\nconstexpr int kWeightsFeatureTensor = 1;\nconstexpr int kWeightsTimeTensor = 2;\nconstexpr int kBiasTensor = 3;\n// This is a variable tensor, and will be modified by this op.\nconstexpr int kStateTensor = 4;\n\n// Output tensor.\nconstexpr int kOutputTensor = 0;\n\nvoid* Init(TfLiteContext* context, const char* buffer, size_t length) {\n  auto* op_data = new OpData();\n  op_data->float_weights_time_initialized = false;\n  // Note: only needs 6 scratch tensors when is_hybrid_op, only 1 otherwise.\n  context->AddTensors(context, /*tensors_to_add=*/6,\n                      &op_data->scratch_tensor_index);\n  return op_data;\n}\n\nvoid Free(TfLiteContext* context, void* buffer) {\n  delete reinterpret_cast<OpData*>(buffer);\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int scratch_tensor_index = op_data->scratch_tensor_index;\n\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* weights_feature;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,\n                                          &weights_feature));\n  const TfLiteTensor* weights_time;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));\n\n  TF_LITE_ENSURE(context,\n                 input->type == kTfLiteFloat32 || input->type == kTfLiteInt8);\n\n  // Check all the parameters of tensor match within themselves and match the\n  // input configuration.\n  const int rank = params->rank;\n  const int batch_size = input->dims->data[0];\n  const int num_filters = weights_feature->dims->data[0];\n  TF_LITE_ENSURE(context, rank != 0);\n  TF_LITE_ENSURE_EQ(context, num_filters % rank, 0);\n  const int num_units = num_filters / rank;\n  const int memory_size = weights_time->dims->data[1];\n  TF_LITE_ENSURE_EQ(context, input->dims->data[1],\n                    weights_feature->dims->data[1]);\n  TF_LITE_ENSURE_EQ(context, weights_time->dims->data[0], num_filters);\n\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n  if (bias) {\n    TF_LITE_ENSURE_EQ(context, bias->dims->data[0], num_units);\n  }\n\n  const TfLiteTensor* state;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kStateTensor, &state));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  // Check the shape of input state tensors.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(state), 2);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 0), batch_size);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 1),\n                    memory_size * num_filters);\n\n  // Resize output.\n  TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(2);\n  output_size_array->data[0] = batch_size;\n  output_size_array->data[1] = num_units;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_size_array));\n\n  // The weights are of consistent type, so it suffices to check one.\n  const bool is_hybrid_op = IsHybridOp(input, weights_feature);\n  const bool is_full_integer = input->type == kTfLiteInt8;\n\n  // Resize scratch.\n  TfLiteIntArrayFree(node->temporaries);\n  if (is_hybrid_op) {\n    node->temporaries = TfLiteIntArrayCreate(6);\n  } else if (is_full_integer) {\n    node->temporaries = TfLiteIntArrayCreate(2);\n  } else {\n    node->temporaries = TfLiteIntArrayCreate(1);\n  }\n  node->temporaries->data[0] = scratch_tensor_index;\n\n  TfLiteIntArray* scratch_size_array = TfLiteIntArrayCreate(2);\n  scratch_size_array->data[0] = batch_size;\n  scratch_size_array->data[1] = num_filters;\n\n  TfLiteTensor* scratch_tensor;\n  TF_LITE_ENSURE_OK(\n      context, GetTemporarySafe(context, node, /*index=*/0, &scratch_tensor));\n\n  // The scratch buffer is of type int32 for full integer svdf and it's of type\n  // float32 for hybrid and float case.\n  if (is_full_integer) {\n    scratch_tensor->type = kTfLiteInt32;\n  } else {\n    scratch_tensor->type = kTfLiteFloat32;\n  }\n  scratch_tensor->allocation_type = kTfLiteArenaRw;\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_tensor,\n                                                   scratch_size_array));\n\n  if (is_hybrid_op) {\n    op_data->compute_row_sums = true;\n    // Tell interpreter to allocate temporary tensors to store quantized values\n    // of input tensors.\n    node->temporaries->data[1] = scratch_tensor_index + 1;\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,\n                                                &input_quantized));\n    input_quantized->type = weights_feature->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    // Tell interpreter to allocate temporary tensors to store scaling factors.\n    node->temporaries->data[2] = scratch_tensor_index + 2;\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,\n                                                &scaling_factors));\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n\n    // Used to store dequantized weights_time matrix for hybrid computation of\n    // matmul(state, weights_time), which occurs in floating point.\n    node->temporaries->data[3] = scratch_tensor_index + 3;\n    TfLiteTensor* float_weights_time;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,\n                                                &float_weights_time));\n    float_weights_time->type = kTfLiteFloat32;\n    // Persistent so that we can compute the dequantized weights only once.\n    float_weights_time->allocation_type = kTfLiteArenaRwPersistent;\n    if (!TfLiteIntArrayEqual(float_weights_time->dims, weights_time->dims)) {\n      TfLiteIntArray* float_weights_time_size =\n          TfLiteIntArrayCopy(weights_time->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, float_weights_time,\n                                              float_weights_time_size));\n    }\n\n    node->temporaries->data[4] = scratch_tensor_index + 4;\n    TfLiteTensor* zero_points;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/4, &zero_points));\n    zero_points->type = kTfLiteFloat32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = zero_points_dims[0];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n\n    node->temporaries->data[5] = scratch_tensor_index + 5;\n    TfLiteTensor* row_sums;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, /*index=*/5, &row_sums));\n    row_sums->type = kTfLiteFloat32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_dims[1] = {num_filters};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);\n      row_sums_size->data[0] = row_sums_dims[0];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n  if (is_full_integer) {\n    // Allocated one extra tensor.\n    TfLiteIntArray* output_temp_size_array = TfLiteIntArrayCreate(2);\n    output_temp_size_array->data[0] = num_units;\n    output_temp_size_array->data[1] = batch_size;\n    node->temporaries->data[1] = scratch_tensor_index + 1;\n    TfLiteTensor* output_temp;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));\n    output_temp->type = kTfLiteInt32;\n    output_temp->allocation_type = kTfLiteArenaRw;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_temp,\n                                                     output_temp_size_array));\n\n    // Calculate effective scales.\n    auto* input_params =\n        reinterpret_cast<TfLiteAffineQuantization*>(input->quantization.params);\n    auto* weights_feature_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        weights_feature->quantization.params);\n    auto* state_params =\n        reinterpret_cast<TfLiteAffineQuantization*>(state->quantization.params);\n    auto* weight_time_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        weights_time->quantization.params);\n    auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        output->quantization.params);\n    const double effective_scale_1 = input_params->scale->data[0] *\n                                     weights_feature_params->scale->data[0] /\n                                     state_params->scale->data[0];\n    const double effective_scale_2 = state_params->scale->data[0] *\n                                     weight_time_params->scale->data[0] /\n                                     output_params->scale->data[0];\n    QuantizeMultiplier(effective_scale_1, &op_data->effective_scale_1_a,\n                       &op_data->effective_scale_1_b);\n    QuantizeMultiplier(effective_scale_2, &op_data->effective_scale_2_a,\n                       &op_data->effective_scale_2_b);\n  }\n  return kTfLiteOk;\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* weights_feature;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,\n                                          &weights_feature));\n  const TfLiteTensor* weights_time;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n\n  TfLiteTensor* scratch;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, /*index=*/0, &scratch));\n\n  TfLiteTensor* state = GetVariableInput(context, node, kStateTensor);\n  TF_LITE_ENSURE(context, state != nullptr);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  switch (weights_feature->type) {\n    case kTfLiteFloat32: {\n      reference_ops::EvalFloatSVDF(\n          params, GetTensorShape(input), GetTensorData<float>(input),\n          GetTensorShape(weights_feature),\n          GetTensorData<float>(weights_feature), GetTensorShape(weights_time),\n          GetTensorData<float>(weights_time), GetTensorShape(bias),\n          GetTensorData<float>(bias), GetTensorData<float>(scratch),\n          GetTensorData<float>(state), GetTensorShape(output),\n          GetTensorData<float>(output));\n      return kTfLiteOk;\n    }\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      if (input->type == kTfLiteFloat32) {\n        TfLiteTensor* input_quantized;\n        TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,\n                                                    &input_quantized));\n        TfLiteTensor* scaling_factors;\n        TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,\n                                                    &scaling_factors));\n        TfLiteTensor* float_weights_time;\n        TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,\n                                                    &float_weights_time));\n        TfLiteTensor* zero_points;\n        TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/4,\n                                                    &zero_points));\n        TfLiteTensor* row_sums;\n        TF_LITE_ENSURE_OK(\n            context, GetTemporarySafe(context, node, /*index=*/5, &row_sums));\n        // Dequantize weights time.\n        // TODO(alanchiao): this dequantization initialization only needs to\n        // happen once per model and should theoretically be placed in either\n        // Init or Prepare. However, TFLite doesn't allocate float_weights_time\n        // until the Eval function.\n        // TODO(alanchiao): refactor logic out into dequantize function.\n        if (!op_data->float_weights_time_initialized) {\n          const float dequantization_scale = weights_time->params.scale;\n          const int8_t* weights_time_ptr = GetTensorData<int8_t>(weights_time);\n          float* float_weights_time_ptr =\n              GetTensorData<float>(float_weights_time);\n          for (int i = 0; i < NumElements(float_weights_time); ++i) {\n            float_weights_time_ptr[i] =\n                weights_time_ptr[i] * dequantization_scale;\n          }\n          op_data->float_weights_time_initialized = true;\n        }\n\n        int32_t* zero_points_ptr = nullptr;\n        int32_t* row_sums_ptr = nullptr;\n        if (params->asymmetric_quantize_inputs && row_sums != nullptr) {\n          zero_points_ptr = GetTensorData<int32_t>(zero_points);\n          row_sums_ptr = GetTensorData<int32_t>(row_sums);\n        }\n\n        reference_ops::EvalHybridSVDF(\n            params, GetTensorShape(input), GetTensorData<float>(input),\n            GetTensorShape(weights_feature),\n            GetTensorData<int8_t>(weights_feature),\n            weights_feature->params.scale, GetTensorShape(float_weights_time),\n            GetTensorData<float>(float_weights_time), GetTensorShape(bias),\n            GetTensorData<float>(bias), GetTensorData<float>(scratch),\n            GetTensorData<float>(scaling_factors),\n            GetTensorData<int8_t>(input_quantized), GetTensorData<float>(state),\n            GetTensorShape(output), GetTensorData<float>(output),\n            zero_points_ptr, row_sums_ptr, &op_data->compute_row_sums);\n        return kTfLiteOk;\n      }\n      auto* input_params = reinterpret_cast<TfLiteAffineQuantization*>(\n          input->quantization.params);\n      auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(\n          output->quantization.params);\n      TfLiteTensor* output_temp;\n      TF_LITE_ENSURE_OK(\n          context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));\n\n      // Currently supports only ReLU.\n      // TODO(jianlijianli): support other activations.\n      TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActRelu);\n\n      reference_ops::EvalIntegerSVDF(\n          params, GetTensorShape(input), GetTensorData<int8_t>(input),\n          GetTensorShape(weights_feature),\n          GetTensorData<int8_t>(weights_feature), GetTensorShape(weights_time),\n          GetTensorData<int16_t>(weights_time), GetTensorShape(bias),\n          GetTensorData<int32_t>(bias), GetTensorData<int16_t>(state),\n          GetTensorShape(output), GetTensorData<int8_t>(output),\n          GetTensorData<int32_t>(scratch), GetTensorData<int32_t>(output_temp),\n          op_data->effective_scale_1_a, op_data->effective_scale_1_b,\n          op_data->effective_scale_2_a, op_data->effective_scale_2_b,\n          input_params->zero_point->data[0],\n          output_params->zero_point->data[0]);\n      return kTfLiteOk;\n    }\n    default:\n      context->ReportError(context, \"Type %s not currently supported.\",\n                           TfLiteTypeGetName(weights_feature->type));\n      return kTfLiteError;\n  }\n}\n\n}  // namespace svdf\n\nTfLiteRegistration* Register_SVDF() {\n  static TfLiteRegistration r = {svdf::Init, svdf::Free, svdf::Prepare,\n                                 svdf::Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite\n"], "filenames": ["tensorflow/lite/kernels/kernel_util.cc", "tensorflow/lite/kernels/svdf.cc"], "buggy_code_start_loc": [121, 301], "buggy_code_end_loc": [121, 301], "fixing_code_start_loc": [122, 302], "fixing_code_end_loc": [123, 303], "type": "CWE-476", "message": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of SVDF in TFLite is [vulnerable to a null pointer error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/svdf.cc#L300-L313). The [`GetVariableInput` function](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L115-L119) can return a null pointer but `GetTensorData` assumes that the argument is always a valid tensor. Furthermore, because `GetVariableInput` calls [`GetMutableInput`](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L82-L90) which might return `nullptr`, the `tensor->is_variable` expression can also trigger a null pointer exception. We have patched the issue in GitHub commit 5b048e87e4e55990dae6b547add4dae59f4e1c76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-37681", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-12T22:15:08.867", "lastModified": "2021-08-18T20:38:55.347", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of SVDF in TFLite is [vulnerable to a null pointer error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/svdf.cc#L300-L313). The [`GetVariableInput` function](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L115-L119) can return a null pointer but `GetTensorData` assumes that the argument is always a valid tensor. Furthermore, because `GetVariableInput` calls [`GetMutableInput`](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L82-L90) which might return `nullptr`, the `tensor->is_variable` expression can also trigger a null pointer exception. We have patched the issue in GitHub commit 5b048e87e4e55990dae6b547add4dae59f4e1c76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico. En las versiones afectadas la implementaci\u00f3n SVDF en TFLite es [vulnerable a un error de puntero null](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/svdf.cc#L300-L313). La funci\u00f3n [\"GetVariableInput\"](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L115-L119) puede devolver un puntero null pero \"GetTensorData\" asume que el argumento es siempre un tensor v\u00e1lido. Adem\u00e1s, como \"GetVariableInput\" llama a [\"GetMutableInput\"](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L82-L90) que puede devolver \"nullptr\", la expresi\u00f3n \"tensor-)is_variable\" tambi\u00e9n puede desencadenar una excepci\u00f3n de puntero null. Hemos parcheado el problema en el commit 5b048e87e4e55990dae6b547add4dae59f4e1c76 de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.6.0. Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.5.1, TensorFlow versi\u00f3n 2.4.3 y TensorFlow versi\u00f3n 2.3.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango de soporte."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.4", "matchCriteriaId": "0F83C081-51CC-415F-A8C0-0A44C75E2CD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.3", "matchCriteriaId": "BD3F2BF8-EBA9-42BF-8F9B-D918B880B15A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D03E99A7-4E3D-427D-A156-C0713E9FB02A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "70FA6E48-6C57-40CA-809F-4E3D07CBF348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "42187561-E491-434D-828C-F36701446634"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C66B61C8-450A-4C5E-9174-F970D6DEE778"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/5b048e87e4e55990dae6b547add4dae59f4e1c76", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-7xwj-5r4v-429p", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/5b048e87e4e55990dae6b547add4dae59f4e1c76"}}