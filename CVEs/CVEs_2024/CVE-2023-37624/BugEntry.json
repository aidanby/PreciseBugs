{"buggy_code": ["package App::Netdisco::Web::AuthN;\n\nuse Dancer ':syntax';\nuse Dancer::Plugin::DBIC;\nuse Dancer::Plugin::Auth::Extensible;\nuse Dancer::Plugin::Swagger;\n\nuse App::Netdisco; # a safe noop but needed for standalone testing\nuse App::Netdisco::Util::Web 'request_is_api';\nuse MIME::Base64;\n\n# ensure that regardless of where the user is redirected, we have a link\n# back to the page they requested.\nhook 'before' => sub {\n    params->{return_url} ||= ((request->path ne uri_for('/')->path)\n      ? request->uri : uri_for(setting('web_home'))->path);\n};\n\n#\u00a0try to find a valid username according to headers\n# or configuration settings\nsub _get_delegated_authn_user {\n  my $username = undef;\n\n  if (setting('trust_x_remote_user')\n    and scalar request->header('X-REMOTE_USER')\n    and length scalar request->header('X-REMOTE_USER')) {\n\n      ($username = scalar request->header('X-REMOTE_USER')) =~ s/@[^@]*$//;\n  }\n  elsif (setting('trust_remote_user')\n    and defined $ENV{REMOTE_USER}\n    and length  $ENV{REMOTE_USER}) {\n\n      ($username = $ENV{REMOTE_USER}) =~ s/@[^@]*$//;\n  }\n  #\u00a0this works for API calls, too\n  elsif (setting('no_auth')) {\n      $username = 'guest';\n  }\n\n  return unless $username;\n\n  # from the internals of Dancer::Plugin::Auth::Extensible\n  my $provider = Dancer::Plugin::Auth::Extensible::auth_provider('users');\n\n  #\u00a0may synthesize a user if validate_remote_user=false\n  return $provider->get_user_details($username);\n}\n\n# Dancer will create a session if it sees its own cookie. For the API and also\n# various auto login options we need to bootstrap the session instead. If no\n# auth data passed, then the hook simply returns, no session is set, and the\n# user is redirected to login page.\nhook 'before' => sub {\n    # return if request is for endpoints not requiring a session\n    return if (\n      request->path eq uri_for('/login')->path\n      or request->path eq uri_for('/logout')->path\n      or request->path eq uri_for('/swagger.json')->path\n      or index(request->path, uri_for('/swagger-ui')->path) == 0\n    );\n\n    # Dancer will issue a cookie to the client which could be returned and\n    # cause API calls to succeed without passing token. Kill the session.\n    session->destroy if request_is_api;\n\n    # ...otherwise, we can short circuit if Dancer reads its cookie OK\n    return if session('logged_in_user');\n\n    my $delegated = _get_delegated_authn_user();\n\n    # this ordering allows override of delegated authN if given creds\n\n    #\u00a0protect against delegated authN config but no valid user\n    if ((not $delegated) and\n      (setting('trust_x_remote_user') or setting('trust_remote_user'))) {\n        session->destroy;\n        request->path_info('/');\n    }\n    # API calls must conform strictly to path and header requirements\n    elsif (request_is_api and request->header('Authorization')) {\n        # from the internals of Dancer::Plugin::Auth::Extensible\n        my $provider = Dancer::Plugin::Auth::Extensible::auth_provider('users');\n\n        my $token = request->header('Authorization');\n        my $user = $provider->validate_api_token($token)\n          or return;\n\n        session(logged_in_user => $user->username);\n        session(logged_in_user_realm => 'users');\n    }\n    elsif ($delegated) {\n        session(logged_in_user => $delegated->username);\n        session(logged_in_user_realm => 'users');\n    }\n    else {\n        # user has no AuthN - force to handler for '/'\n        request->path_info('/');\n    }\n};\n\n# override default login_handler so we can log access in the database\nswagger_path {\n  description => 'Obtain an API Key',\n  tags => ['General'],\n  path => (setting('url_base') ? setting('url_base')->with('/login')->path : '/login'),\n  parameters => [],\n  responses => { default => { examples => {\n    'application/json' => { api_key => 'cc9d5c02d8898e5728b7d7a0339c0785' } } },\n  },\n},\npost '/login' => sub {\n    my $api = ((request->accept and request->accept =~ m/(?:json|javascript)/) ? true : false);\n\n    # from the internals of Dancer::Plugin::Auth::Extensible\n    my $provider = Dancer::Plugin::Auth::Extensible::auth_provider('users');\n\n    # get authN data from BasicAuth header used by API, put into params\n    my $authheader = request->header('Authorization');\n    if (defined $authheader and $authheader =~ /^Basic (.*)$/i) {\n        my ($u, $p) = split(m/:/, (MIME::Base64::decode($1) || \":\"));\n        params->{username} = $u;\n        params->{password} = $p;\n    }\n\n    # validate authN\n    my ($success, $realm) = authenticate_user(param('username'),param('password'));\n\n    #\u00a0or try to get user from somewhere else\n    my $delegated = _get_delegated_authn_user();\n\n    if (($success and not\n          #\u00a0protect against delegated authN config but no valid user (then must ignore params)\n          (not $delegated and (setting('trust_x_remote_user') or setting('trust_remote_user'))))\n        or $delegated) {\n\n        # this ordering allows override of delegated user if given creds\n        my $user = ($success ? $provider->get_user_details(param('username'))\n                             : $delegated);\n\n        session logged_in_user => $user->username;\n        session logged_in_fullname => ($user->fullname || '');\n        session logged_in_user_realm => ($realm || 'users');\n\n        schema('netdisco')->resultset('UserLog')->create({\n          username => session('logged_in_user'),\n          userip => request->remote_address,\n          event => (sprintf 'Login (%s)', ($api ? 'API' : 'WebUI')),\n          details => param('return_url'),\n        });\n        $user->update({ last_on => \\'LOCALTIMESTAMP' });\n\n        if ($api) {\n            header('Content-Type' => 'application/json');\n\n            #\u00a0if there's a current valid token then reissue it and reset timer\n            $user->update({\n              token_from => time,\n              ($provider->validate_api_token($user->token)\n                ? () : (token => \\'md5(random()::text)')),\n            })->discard_changes();\n            return to_json { api_key => $user->token };\n        }\n\n        redirect param('return_url');\n    }\n    else {\n        # invalidate session cookie\n        session->destroy;\n\n        schema('netdisco')->resultset('UserLog')->create({\n          username => param('username'),\n          userip => request->remote_address,\n          event => (sprintf 'Login Failure (%s)', ($api ? 'API' : 'WebUI')),\n          details => param('return_url'),\n        });\n\n        if ($api) {\n            header('Content-Type' => 'application/json');\n            status('unauthorized');\n            return to_json { error => 'authentication failed' };\n        }\n\n        vars->{login_failed}++;\n        forward uri_for('/login'),\n          { login_failed => 1, return_url => param('return_url') },\n          { method => 'GET' };\n    }\n};\n\n# ugh, *puke*, but D::P::Swagger has no way to set this with swagger_path\n# must be after the path is declared, above.\nDancer::Plugin::Swagger->instance->doc\n  ->{paths}->{ (setting('url_base') ? setting('url_base')->with('/login')->path : '/login') }\n  ->{post}->{security}->[0]->{BasicAuth} = [];\n\n# we override the default login_handler, so logout has to be handled as well\nswagger_path {\n  description => 'Destroy user API Key and session cookie',\n  tags => ['General'],\n  path => (setting('url_base') ? setting('url_base')->with('/logout')->path : '/logout'),\n  parameters => [],\n  responses => { default => { examples => { 'application/json' => {} } } },\n},\nget '/logout' => sub {\n    my $api = ((request->accept and request->accept =~ m/(?:json|javascript)/) ? true : false);\n\n    # clear out API token\n    my $user = schema('netdisco')->resultset('User')\n      ->find({ username => session('logged_in_user')});\n    $user->update({token => undef, token_from => undef})->discard_changes()\n      if $user and $user->in_storage;\n\n    # invalidate session cookie\n    session->destroy;\n\n    schema('netdisco')->resultset('UserLog')->create({\n      username => session('logged_in_user'),\n      userip => request->remote_address,\n      event => (sprintf 'Logout (%s)', ($api ? 'API' : 'WebUI')),\n      details => '',\n    });\n\n    if ($api) {\n        header('Content-Type' => 'application/json');\n        return to_json {};\n    }\n\n    redirect uri_for(setting('web_home'))->path;\n};\n\n# user redirected here when require_role does not succeed\nany qr{^/(?:login(?:/denied)?)?} => sub {\n    my $api = ((request->accept and request->accept =~ m/(?:json|javascript)/) ? true : false);\n\n    if ($api) {\n      header('Content-Type' => 'application/json');\n      status('unauthorized');\n      return to_json {\n        error => 'not authorized',\n        return_url => param('return_url'),\n      };\n    }\n    elsif (defined request->header('X-Requested-With')\n           and request->header('X-Requested-With') eq 'XMLHttpRequest') {\n      status('unauthorized');\n      return '<div class=\"span2 alert alert-error\"><i class=\"icon-ban-circle\"></i> Error: unauthorized.</div>';\n    }\n    else {\n      template 'index', {\n        return_url => param('return_url')\n      }, { layout => 'main' };\n    }\n};\n\ntrue;\n"], "fixing_code": ["package App::Netdisco::Web::AuthN;\n\nuse Dancer ':syntax';\nuse Dancer::Plugin::DBIC;\nuse Dancer::Plugin::Auth::Extensible;\nuse Dancer::Plugin::Swagger;\n\nuse App::Netdisco; # a safe noop but needed for standalone testing\nuse App::Netdisco::Util::Web 'request_is_api';\nuse MIME::Base64;\nuse URI::Based;\n\n# ensure that regardless of where the user is redirected, we have a link\n# back to the page they requested.\nhook 'before' => sub {\n    params->{return_url} ||= ((request->path ne uri_for('/')->path)\n      ? request->uri : uri_for(setting('web_home'))->path);\n};\n\n#\u00a0try to find a valid username according to headers\n# or configuration settings\nsub _get_delegated_authn_user {\n  my $username = undef;\n\n  if (setting('trust_x_remote_user')\n    and scalar request->header('X-REMOTE_USER')\n    and length scalar request->header('X-REMOTE_USER')) {\n\n      ($username = scalar request->header('X-REMOTE_USER')) =~ s/@[^@]*$//;\n  }\n  elsif (setting('trust_remote_user')\n    and defined $ENV{REMOTE_USER}\n    and length  $ENV{REMOTE_USER}) {\n\n      ($username = $ENV{REMOTE_USER}) =~ s/@[^@]*$//;\n  }\n  #\u00a0this works for API calls, too\n  elsif (setting('no_auth')) {\n      $username = 'guest';\n  }\n\n  return unless $username;\n\n  # from the internals of Dancer::Plugin::Auth::Extensible\n  my $provider = Dancer::Plugin::Auth::Extensible::auth_provider('users');\n\n  #\u00a0may synthesize a user if validate_remote_user=false\n  return $provider->get_user_details($username);\n}\n\n# Dancer will create a session if it sees its own cookie. For the API and also\n# various auto login options we need to bootstrap the session instead. If no\n# auth data passed, then the hook simply returns, no session is set, and the\n# user is redirected to login page.\nhook 'before' => sub {\n    # return if request is for endpoints not requiring a session\n    return if (\n      request->path eq uri_for('/login')->path\n      or request->path eq uri_for('/logout')->path\n      or request->path eq uri_for('/swagger.json')->path\n      or index(request->path, uri_for('/swagger-ui')->path) == 0\n    );\n\n    # Dancer will issue a cookie to the client which could be returned and\n    # cause API calls to succeed without passing token. Kill the session.\n    session->destroy if request_is_api;\n\n    # ...otherwise, we can short circuit if Dancer reads its cookie OK\n    return if session('logged_in_user');\n\n    my $delegated = _get_delegated_authn_user();\n\n    # this ordering allows override of delegated authN if given creds\n\n    #\u00a0protect against delegated authN config but no valid user\n    if ((not $delegated) and\n      (setting('trust_x_remote_user') or setting('trust_remote_user'))) {\n        session->destroy;\n        request->path_info('/');\n    }\n    # API calls must conform strictly to path and header requirements\n    elsif (request_is_api and request->header('Authorization')) {\n        # from the internals of Dancer::Plugin::Auth::Extensible\n        my $provider = Dancer::Plugin::Auth::Extensible::auth_provider('users');\n\n        my $token = request->header('Authorization');\n        my $user = $provider->validate_api_token($token)\n          or return;\n\n        session(logged_in_user => $user->username);\n        session(logged_in_user_realm => 'users');\n    }\n    elsif ($delegated) {\n        session(logged_in_user => $delegated->username);\n        session(logged_in_user_realm => 'users');\n    }\n    else {\n        # user has no AuthN - force to handler for '/'\n        request->path_info('/');\n    }\n};\n\n# override default login_handler so we can log access in the database\nswagger_path {\n  description => 'Obtain an API Key',\n  tags => ['General'],\n  path => (setting('url_base') ? setting('url_base')->with('/login')->path : '/login'),\n  parameters => [],\n  responses => { default => { examples => {\n    'application/json' => { api_key => 'cc9d5c02d8898e5728b7d7a0339c0785' } } },\n  },\n},\npost '/login' => sub {\n    my $api = ((request->accept and request->accept =~ m/(?:json|javascript)/) ? true : false);\n\n    # from the internals of Dancer::Plugin::Auth::Extensible\n    my $provider = Dancer::Plugin::Auth::Extensible::auth_provider('users');\n\n    # get authN data from BasicAuth header used by API, put into params\n    my $authheader = request->header('Authorization');\n    if (defined $authheader and $authheader =~ /^Basic (.*)$/i) {\n        my ($u, $p) = split(m/:/, (MIME::Base64::decode($1) || \":\"));\n        params->{username} = $u;\n        params->{password} = $p;\n    }\n\n    # validate authN\n    my ($success, $realm) = authenticate_user(param('username'),param('password'));\n\n    #\u00a0or try to get user from somewhere else\n    my $delegated = _get_delegated_authn_user();\n\n    if (($success and not\n          #\u00a0protect against delegated authN config but no valid user (then must ignore params)\n          (not $delegated and (setting('trust_x_remote_user') or setting('trust_remote_user'))))\n        or $delegated) {\n\n        # this ordering allows override of delegated user if given creds\n        my $user = ($success ? $provider->get_user_details(param('username'))\n                             : $delegated);\n\n        session logged_in_user => $user->username;\n        session logged_in_fullname => ($user->fullname || '');\n        session logged_in_user_realm => ($realm || 'users');\n\n        schema('netdisco')->resultset('UserLog')->create({\n          username => session('logged_in_user'),\n          userip => request->remote_address,\n          event => (sprintf 'Login (%s)', ($api ? 'API' : 'WebUI')),\n          details => param('return_url'),\n        });\n        $user->update({ last_on => \\'LOCALTIMESTAMP' });\n\n        if ($api) {\n            header('Content-Type' => 'application/json');\n\n            #\u00a0if there's a current valid token then reissue it and reset timer\n            $user->update({\n              token_from => time,\n              ($provider->validate_api_token($user->token)\n                ? () : (token => \\'md5(random()::text)')),\n            })->discard_changes();\n            return to_json { api_key => $user->token };\n        }\n\n        redirect ((scalar URI::Based->new(param('return_url'))->path_query) || '/');\n    }\n    else {\n        # invalidate session cookie\n        session->destroy;\n\n        schema('netdisco')->resultset('UserLog')->create({\n          username => param('username'),\n          userip => request->remote_address,\n          event => (sprintf 'Login Failure (%s)', ($api ? 'API' : 'WebUI')),\n          details => param('return_url'),\n        });\n\n        if ($api) {\n            header('Content-Type' => 'application/json');\n            status('unauthorized');\n            return to_json { error => 'authentication failed' };\n        }\n\n        vars->{login_failed}++;\n        forward uri_for('/login'),\n          { login_failed => 1, return_url => param('return_url') },\n          { method => 'GET' };\n    }\n};\n\n# ugh, *puke*, but D::P::Swagger has no way to set this with swagger_path\n# must be after the path is declared, above.\nDancer::Plugin::Swagger->instance->doc\n  ->{paths}->{ (setting('url_base') ? setting('url_base')->with('/login')->path : '/login') }\n  ->{post}->{security}->[0]->{BasicAuth} = [];\n\n# we override the default login_handler, so logout has to be handled as well\nswagger_path {\n  description => 'Destroy user API Key and session cookie',\n  tags => ['General'],\n  path => (setting('url_base') ? setting('url_base')->with('/logout')->path : '/logout'),\n  parameters => [],\n  responses => { default => { examples => { 'application/json' => {} } } },\n},\nget '/logout' => sub {\n    my $api = ((request->accept and request->accept =~ m/(?:json|javascript)/) ? true : false);\n\n    # clear out API token\n    my $user = schema('netdisco')->resultset('User')\n      ->find({ username => session('logged_in_user')});\n    $user->update({token => undef, token_from => undef})->discard_changes()\n      if $user and $user->in_storage;\n\n    # invalidate session cookie\n    session->destroy;\n\n    schema('netdisco')->resultset('UserLog')->create({\n      username => session('logged_in_user'),\n      userip => request->remote_address,\n      event => (sprintf 'Logout (%s)', ($api ? 'API' : 'WebUI')),\n      details => '',\n    });\n\n    if ($api) {\n        header('Content-Type' => 'application/json');\n        return to_json {};\n    }\n\n    redirect uri_for(setting('web_home'))->path;\n};\n\n# user redirected here when require_role does not succeed\nany qr{^/(?:login(?:/denied)?)?} => sub {\n    my $api = ((request->accept and request->accept =~ m/(?:json|javascript)/) ? true : false);\n\n    if ($api) {\n      header('Content-Type' => 'application/json');\n      status('unauthorized');\n      return to_json {\n        error => 'not authorized',\n        return_url => param('return_url'),\n      };\n    }\n    elsif (defined request->header('X-Requested-With')\n           and request->header('X-Requested-With') eq 'XMLHttpRequest') {\n      status('unauthorized');\n      return '<div class=\"span2 alert alert-error\"><i class=\"icon-ban-circle\"></i> Error: unauthorized.</div>';\n    }\n    else {\n      template 'index', {\n        return_url => param('return_url')\n      }, { layout => 'main' };\n    }\n};\n\ntrue;\n"], "filenames": ["lib/App/Netdisco/Web/AuthN.pm"], "buggy_code_start_loc": [10], "buggy_code_end_loc": [166], "fixing_code_start_loc": [11], "fixing_code_end_loc": [167], "type": "CWE-601", "message": "Netdisco before v2.063000 was discovered to contain an open redirect vulnerability. An attacker may exploit this vulnerability to redirect users to arbitrary web URLs by tricking the victim users to click on crafted links.", "other": {"cve": {"id": "CVE-2023-37624", "sourceIdentifier": "cve@mitre.org", "published": "2023-07-26T20:15:12.727", "lastModified": "2023-08-02T00:35:41.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Netdisco before v2.063000 was discovered to contain an open redirect vulnerability. An attacker may exploit this vulnerability to redirect users to arbitrary web URLs by tricking the victim users to click on crafted links."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netdisco:netdisco:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.063000", "matchCriteriaId": "49A130E0-9B38-4DA0-82CD-4B2B3376A38F"}]}]}], "references": [{"url": "https://github.com/benjaminpsinclair/Netdisco-2023-Advisory", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/benjaminpsinclair/Netdisco-CVE", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/netdisco/netdisco/commit/a2da6a7a046c1c0fd41072dd6991eec7614293f8", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/netdisco/netdisco/commit/a2da6a7a046c1c0fd41072dd6991eec7614293f8"}}