{"buggy_code": ["/*\n * Copyright 2018 Jonathan Dieter <jdieter@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  1. Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *  2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <math.h>\n#include <zck.h>\n\n#include \"zck_private.h\"\n#include \"comp/nocomp/nocomp.h\"\n#ifdef ZCHUNK_ZSTD\n#include \"comp/zstd/zstd.h\"\n#endif\n\n#define BLK_SIZE 32768\n\nstatic char unknown[] = \"Unknown(\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\nconst static char *COMP_NAME[] = {\n    \"no\",\n    \"Unknown (1)\",\n    \"zstd\"\n};\n\nstatic void update_buzhash_bits(zckCtx *zck) {\n    int s=1;\n    for(int i=0; i<zck->buzhash_match_bits; i++)\n        s *= 2;\n    s -= 1;\n    zck->buzhash_bitmask = s;\n}\n\nstatic bool set_comp_type(zckCtx *zck, ssize_t type) {\n    VALIDATE_BOOL(zck);\n\n    zckComp *comp = &(zck->comp);\n\n    /* Cannot change compression type after compression has started */\n    if(comp->started) {\n        set_error(zck, \"Unable to set compression type after initialization\");\n        return false;\n    }\n\n    /* Set all values to 0 before setting compression type */\n    char *dc_data = comp->dc_data;\n    size_t dc_data_loc = comp->dc_data_loc;\n    size_t dc_data_size = comp->dc_data_size;\n    memset(comp, 0, sizeof(zckComp));\n    comp->dc_data = dc_data;\n    comp->dc_data_loc = dc_data_loc;\n    comp->dc_data_size = dc_data_size;\n\n    zck_log(ZCK_LOG_DEBUG, \"Setting compression to %s\",\n            zck_comp_name_from_type(type));\n    if(type == ZCK_COMP_NONE) {\n        return nocomp_setup(zck, comp);\n#ifdef ZCHUNK_ZSTD\n    } else if(type == ZCK_COMP_ZSTD) {\n        return zstd_setup(zck, comp);\n#endif\n    } else {\n        set_error(zck, \"Unsupported compression type: %s\",\n                  zck_comp_name_from_type(type));\n        return false;\n    }\n    return true;\n}\n\nstatic size_t comp_read_from_dc(zckCtx *zck, zckComp *comp, char *dst,\n                                size_t dst_size) {\n    VALIDATE_INT(zck);\n    ALLOCD_INT(zck, comp);\n    ALLOCD_INT(zck, dst);\n\n    size_t dl_size = dst_size;\n    if(dl_size > comp->dc_data_size - comp->dc_data_loc)\n        dl_size = comp->dc_data_size - comp->dc_data_loc;\n    memcpy(dst, comp->dc_data+comp->dc_data_loc, dl_size);\n    comp->dc_data_loc += dl_size;\n    if(dl_size > 0)\n        zck_log(ZCK_LOG_DEBUG, \"Reading %llu bytes from decompressed buffer\",\n                (long long unsigned) dl_size);\n    return dl_size;\n}\n\nstatic bool comp_add_to_data(zckCtx *zck, zckComp *comp, const char *src,\n                             size_t src_size) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n    ALLOCD_BOOL(zck, src);\n\n    comp->data = zrealloc(comp->data, comp->data_size + src_size);\n    if (!comp->data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Adding %llu bytes to compressed buffer\",\n        (long long unsigned) src_size);\n    memcpy(comp->data + comp->data_size, src, src_size);\n    comp->data_size += src_size;\n    comp->data_loc += src_size;\n    return true;\n}\n\nstatic ssize_t comp_end_dchunk(zckCtx *zck, bool use_dict, size_t fd_size) {\n    VALIDATE_READ_INT(zck);\n\n    ssize_t rb = zck->comp.end_dchunk(zck, &(zck->comp), use_dict, fd_size);\n    if(validate_current_chunk(zck) < 1)\n        return -1;\n    zck->comp.data_loc = 0;\n    zck->comp.data_idx = zck->comp.data_idx->next;\n    if(!hash_init(zck, &(zck->check_chunk_hash), &(zck->chunk_hash_type)))\n        return -1;\n    return rb;\n}\n\nstatic ssize_t comp_write(zckCtx *zck, const char *src, const size_t src_size) {\n    VALIDATE_WRITE_INT(zck);\n\n    if(src_size == 0)\n        return 0;\n\n    char *dst = NULL;\n    size_t dst_size = 0;\n    if(zck->comp.compress(zck, &(zck->comp), src, src_size, &dst,\n                          &dst_size, 1) < 0)\n        return -1;\n    zck->comp.dc_data_size += src_size;\n\n    if(zck->no_write == 0 && dst_size > 0 && !write_data(zck, zck->temp_fd, dst, dst_size)) {\n        free(dst);\n        return -1;\n    }\n    if(!index_add_to_chunk(zck, dst, dst_size, src_size)) {\n        free(dst);\n        return -1;\n    }\n    if(zck->has_uncompressed_source && !hash_update(zck, &(zck->work_index_hash_uncomp), src, src_size))\n        return -1;\n    free(dst);\n    return src_size;\n}\n\nbool comp_init(zckCtx *zck) {\n    VALIDATE_BOOL(zck);\n\n    zckComp *comp = &(zck->comp);\n\n    if(zck->comp.started) {\n        set_error(zck, \"Compression already initialized\");\n        return false;\n    }\n    if((zck->comp.dict && zck->comp.dict_size == 0) ||\n       (zck->comp.dict == NULL && zck->comp.dict_size > 0)) {\n        set_error(zck, \"Invalid dictionary configuration\");\n        return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Initializing %s compression\",\n            zck_comp_name_from_type(comp->type));\n    if(!zck->comp.init(zck, &(zck->comp)))\n        return false;\n    if(zck->mode == ZCK_MODE_WRITE) {\n        if(zck->chunk_min_size == 0) {\n            zck->chunk_min_size = CHUNK_DEFAULT_MIN;\n            zck_log(ZCK_LOG_DEBUG, \"Using default minimum chunk size of %llu\",\n                    (long long unsigned) zck->chunk_min_size);\n        }\n        if(zck->chunk_max_size == 0) {\n            zck->chunk_max_size = CHUNK_DEFAULT_MAX;\n            zck_log(ZCK_LOG_DEBUG, \"Using default maximum chunk size of %llu\",\n                    (long long unsigned) zck->chunk_max_size);\n        }\n        if(zck->manual_chunk == 0) {\n            zck_log(ZCK_LOG_DEBUG, \"Using buzhash algorithm for chunking\");\n            zck->buzhash_width = DEFAULT_BUZHASH_WIDTH;\n            zck->buzhash_match_bits = DEFAULT_BUZHASH_BITS;\n            update_buzhash_bits(zck);\n            zck_log(ZCK_LOG_DEBUG, \"Setting average chunk size to %llu\",\n                    (long long unsigned) zck->buzhash_bitmask + 1);\n            zck->chunk_auto_min = (zck->buzhash_bitmask + 1) / 4;\n            if(zck->chunk_auto_min < zck->chunk_min_size)\n                zck->chunk_auto_min = zck->chunk_min_size;\n            zck_log(ZCK_LOG_DEBUG, \"Setting automatic minimum chunk size to %llu\",\n                    (long long unsigned) zck->chunk_auto_min);\n            zck->chunk_auto_max = (zck->buzhash_bitmask + 1) * 4;\n            if(zck->chunk_auto_max > zck->chunk_max_size)\n                zck->chunk_auto_max = zck->chunk_max_size;\n            zck_log(ZCK_LOG_DEBUG, \"Setting automatic maximum chunk size to %llu\",\n                    (long long unsigned) zck->chunk_auto_max);\n        }\n    }\n\n    if(zck->temp_fd || zck->no_write) {\n        if(zck->comp.dict) {\n            char *dst = NULL;\n            size_t dst_size = 0;\n\n            if(zck->comp.compress(zck, comp, zck->comp.dict,\n                                  zck->comp.dict_size, &dst, &dst_size, 0) < 0)\n                return false;\n            zck->comp.dc_data_size = zck->comp.dict_size;\n            if(zck->no_write == 0 && !write_data(zck, zck->temp_fd, dst, dst_size)) {\n                free(dst);\n                return false;\n            }\n            if(!index_add_to_chunk(zck, dst, dst_size,\n                                       zck->comp.dict_size)) {\n                free(dst);\n                return false;\n            }\n            free(dst);\n            dst = NULL;\n            dst_size = 0;\n\n            if(!zck->comp.end_cchunk(zck, comp, &dst, &dst_size, 0))\n                return false;\n            zck->comp.dc_data_size = 0;\n            if(zck->no_write == 0 && !write_data(zck, zck->temp_fd, dst, dst_size)) {\n                free(dst);\n                return false;\n            }\n            if(!index_add_to_chunk(zck, dst, dst_size, 0) ||\n               !index_finish_chunk(zck)) {\n                free(dst);\n                return false;\n            }\n            free(dst);\n        } else {\n            if(!index_finish_chunk(zck))\n                return false;\n        }\n    }\n    zck->comp.started = true;\n    return true;\n}\n\nbool comp_reset(zckCtx *zck) {\n    ALLOCD_BOOL(zck, zck);\n\n    zck->comp.started = 0;\n    if(zck->comp.dc_data) {\n        free(zck->comp.dc_data);\n        zck->comp.dc_data = NULL;\n        zck->comp.dc_data_loc = 0;\n        zck->comp.dc_data_size = 0;\n    }\n    if(zck->comp.close == NULL)\n        return true;\n    return zck->comp.close(zck, &(zck->comp));\n}\n\nbool comp_reset_comp_data(zckCtx *zck) {\n    ALLOCD_BOOL(zck, zck);\n\n    if(zck->comp.data) {\n        free(zck->comp.data);\n        zck->comp.data = NULL;\n        zck->comp.data_size = 0;\n        zck->comp.data_loc = 0;\n        zck->comp.data_idx = NULL;\n    }\n    return true;\n}\n\nbool comp_close(zckCtx *zck) {\n    ALLOCD_BOOL(zck, zck);\n\n    zck_log(ZCK_LOG_DEBUG, \"Closing compression\");\n    comp_reset_comp_data(zck);\n    if(zck->comp.dict)\n        free(zck->comp.dict);\n    zck->comp.dict = NULL;\n    zck->comp.dict_size = 0;\n\n    return comp_reset(zck);\n}\n\nbool comp_ioption(zckCtx *zck, zck_ioption option, ssize_t value) {\n    VALIDATE_BOOL(zck);\n\n    /* Cannot change compression parameters after compression has started */\n    if(zck && zck->comp.started) {\n        set_error(zck,\n                  \"Unable to set compression parameters after initialization\");\n        return false;\n    }\n    if(option == ZCK_COMP_TYPE) {\n        return set_comp_type(zck, value);\n\n    /* Manual chunking */\n    } else if(option == ZCK_MANUAL_CHUNK) {\n        VALIDATE_WRITE_BOOL(zck);\n        if(value != 0) {\n            zck_log(ZCK_LOG_DEBUG, \"Disabling automatic chunking\");\n            zck->manual_chunk = 1;\n        } else {\n            zck_log(ZCK_LOG_DEBUG, \"Enabling automatic chunking\");\n            zck->manual_chunk = 0;\n        }\n        return true;\n\n    /* Minimum chunk size */\n    } else if(option == ZCK_CHUNK_MIN) {\n        VALIDATE_WRITE_BOOL(zck);\n        if(value < 1) {\n            set_error(zck, \"Minimum chunk size must be > 0\");\n            return false;\n        }\n        if(value > zck->chunk_max_size) {\n            set_error(zck, \"Minimum chunk size must be <= maximum chunk size\");\n            return false;\n        }\n        zck->chunk_min_size = value;\n        zck_log(ZCK_LOG_DEBUG, \"Setting minimum chunk size to %lli\", (long long) value);\n        return true;\n\n    /* Maximum chunk size */\n    } else if(option == ZCK_CHUNK_MAX) {\n        VALIDATE_WRITE_BOOL(zck);\n        if(value < 1) {\n            set_error(zck, \"Maximum chunk size must be > 0\");\n            return false;\n        }\n        if(value < zck->chunk_min_size) {\n            set_error(zck, \"Maximum chunk size must be >= minimum chunk size\");\n            return false;\n        }\n        zck->chunk_max_size = value;\n        zck_log(ZCK_LOG_DEBUG, \"Setting maximum chunk size to %lli\", (long long) value);\n        return true;\n\n    } else {\n        if(zck && zck->comp.set_parameter)\n            return zck->comp.set_parameter(zck, &(zck->comp), option, &value);\n\n        set_error(zck, \"Unsupported compression parameter: %i\",\n                  option);\n        return false;\n    }\n    return true;\n}\n\nbool comp_soption(zckCtx *zck, zck_soption option, const void *value,\n                  size_t length) {\n    VALIDATE_BOOL(zck);\n\n    /* Cannot change compression parameters after compression has started */\n    if(zck && zck->comp.started) {\n        set_error(zck,\n                  \"Unable to set compression parameters after initialization\");\n        return false;\n    }\n    if(option == ZCK_COMP_DICT) {\n        zck_log(ZCK_LOG_DEBUG, \"Adding dictionary of size %lli\", (long long) length);\n        zck->comp.dict = (char *)value;\n        zck->comp.dict_size = length;\n    } else {\n        if(zck && zck->comp.set_parameter)\n            return zck->comp.set_parameter(zck, &(zck->comp), option, value);\n\n        set_error(zck, \"Unsupported compression parameter: %i\", option);\n        return false;\n    }\n    return true;\n}\n\nbool comp_add_to_dc(zckCtx *zck, zckComp *comp, const char *src,\n                    size_t src_size) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n    ALLOCD_BOOL(zck, src);\n\n    /* Get rid of any already read data and allocate space for new data */\n    char *temp = zmalloc(comp->dc_data_size - comp->dc_data_loc + src_size);\n    if (!temp) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    if(comp->dc_data_loc != 0)\n        zck_log(ZCK_LOG_DEBUG, \"Freeing %llu bytes from decompressed buffer\",\n                (long long unsigned) comp->dc_data_loc);\n    zck_log(ZCK_LOG_DEBUG, \"Adding %llu bytes to decompressed buffer\",\n            (long long unsigned) src_size);\n    memcpy(temp, comp->dc_data + comp->dc_data_loc,\n           comp->dc_data_size - comp->dc_data_loc);\n    free(comp->dc_data);\n    comp->dc_data_size -= comp->dc_data_loc;\n    comp->dc_data_loc = 0;\n    comp->dc_data = temp;\n\n    /* Copy new uncompressed data into comp */\n    memcpy(comp->dc_data + comp->dc_data_size, src, src_size);\n    comp->dc_data_size += src_size;\n    return true;\n}\n\nssize_t comp_read(zckCtx *zck, char *dst, size_t dst_size, bool use_dict) {\n    VALIDATE_READ_INT(zck);\n\n    if(!zck->comp.started) {\n        set_error(zck, \"Compression hasn't been initialized yet\");\n        return -1;\n    }\n\n    if(dst_size == 0)\n        return 0;\n\n    /* Read dictionary if it exists and hasn't been read yet */\n    if(use_dict && zck->index.first->length > 0 && zck->comp.dict == NULL &&\n       !import_dict(zck))\n        return -1;\n\n    size_t dc = 0;\n    char *src = zmalloc(dst_size - dc);\n    if (!src) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    bool finished_rd = false;\n    bool finished_dc = false;\n    zck_log(ZCK_LOG_DEBUG, \"Trying to read %llu bytes\", (long long unsigned) dst_size);\n    while(dc < dst_size) {\n        /* Get bytes from decompressed buffer */\n        ssize_t rb = comp_read_from_dc(zck, &(zck->comp), dst+dc, dst_size-dc);\n        if(rb < 0)\n            goto read_error;\n        dc += rb;\n        if(dc == dst_size)\n            break;\n        if(rb > 0)\n            continue;\n        if(finished_dc || zck->comp.data_eof)\n            break;\n\n        /* Decompress compressed buffer into decompressed buffer */\n        size_t dc_data_size = zck->comp.dc_data_size;\n        size_t dc_data_loc = zck->comp.dc_data_loc;\n        if(zck->comp.data_size > 0 &&\n           !zck->comp.decompress(zck, &(zck->comp), use_dict))\n            goto read_error;\n\n        /* Check whether we decompressed more data */\n        if(zck->comp.dc_data_size != dc_data_size ||\n           zck->comp.dc_data_loc != dc_data_loc)\n            continue;\n\n        /* End decompression chunk if we're on a chunk boundary */\n        if(zck->comp.data_idx == NULL) {\n            zck->comp.data_idx = zck->index.first;\n            /* Skip first chunk if it's an empty dict */\n            if(zck->comp.data_idx->comp_length == 0)\n                zck->comp.data_idx = zck->comp.data_idx->next;\n            if(!hash_init(zck, &(zck->check_chunk_hash),\n                          &(zck->chunk_hash_type)))\n                goto hash_error;\n            if(zck->comp.data_loc > 0) {\n                if(!zck->has_uncompressed_source) {\n                    if(!hash_update(zck, &(zck->check_full_hash), zck->comp.data,\n                                    zck->comp.data_loc))\n                        goto hash_error;\n                }\n                if(!hash_update(zck, &(zck->check_chunk_hash), zck->comp.data,\n                                zck->comp.data_loc))\n                    goto hash_error;\n            }\n            if(zck->comp.data_idx == NULL) {\n                free(src);\n                return 0;\n            }\n        }\n        if(zck->comp.data_loc == zck->comp.data_idx->comp_length) {\n            if(!comp_end_dchunk(zck, use_dict, zck->comp.data_idx->length)) {\n                free(src);\n                return -1;\n            }\n            if(zck->comp.data_idx == NULL)\n                zck->comp.data_eof = true;\n            continue;\n        }\n\n        /* If we finished reading and we've reached here, we're done\n         * decompressing */\n        if(finished_rd) {\n            finished_dc = true;\n            continue;\n        }\n\n        /* Make sure we don't read beyond current chunk length */\n        size_t rs = dst_size;\n        if(zck->comp.data_loc + rs > zck->comp.data_idx->comp_length)\n            rs = zck->comp.data_idx->comp_length - zck->comp.data_loc;\n\n        /* Decompressed buffer is empty, so read data from file and fill\n         * compressed buffer */\n        rb = read_data(zck, src, rs);\n        if(rb < 0)\n            goto read_error;\n        if(rb < rs) {\n            zck_log(ZCK_LOG_DDEBUG, \"EOF\");\n            finished_rd = true;\n        }\n        if(zck->check_chunk_hash.ctx == NULL)\n            if(!hash_init(zck, &(zck->check_chunk_hash),\n                          &(zck->chunk_hash_type)))\n                goto hash_error;\n        if(!zck->has_uncompressed_source) {\n            if(!hash_update(zck, &(zck->check_full_hash), src, rb))\n                goto read_error;\n        }\n        if(!hash_update(zck, &(zck->check_chunk_hash), src, rb) ||\n           !comp_add_to_data(zck, &(zck->comp), src, rb))\n            goto read_error;\n    }\n    free(src);\n    return dc;\nread_error:\n    free(src);\n    return -1;\nhash_error:\n    free(src);\n    return -2;\n}\n\nconst char ZCK_PUBLIC_API *zck_comp_name_from_type(int comp_type) {\n    if(comp_type > 2) {\n        snprintf(unknown+8, 21, \"%i)\", comp_type);\n        return unknown;\n    }\n    return COMP_NAME[comp_type];\n}\n\nssize_t ZCK_PUBLIC_API zck_write(zckCtx *zck, const char *src, const size_t src_size) {\n    VALIDATE_WRITE_INT(zck);\n\n    if(src_size == 0)\n        return 0;\n\n    if(!zck->comp.started && !comp_init(zck))\n        return -1;\n\n    const char *loc = src;\n    size_t loc_size = src_size;\n    size_t loc_written = 0;\n    uint32_t buzhash_res;\n\n    if(zck->manual_chunk) {\n        while(zck->comp.dc_data_size + loc_size > zck->chunk_max_size) {\n            loc_written = zck->chunk_max_size - zck->comp.dc_data_size;\n            if(comp_write(zck, loc, loc_written) != loc_written)\n                return -1;\n            loc_size -= loc_written;\n            loc += loc_written;\n            zck_log(ZCK_LOG_DDEBUG,\n                    \"Chunk has reached maximum size, forcing a new chunk\");\n            if(zck_end_chunk(zck) < 0)\n                return -1;\n        }\n        if(comp_write(zck, loc, loc_size) != loc_size)\n            return -1;\n        else\n            return src_size;\n    } else {\n        for(size_t i=0; i<loc_size; ) {\n            if (!buzhash_update(&(zck->buzhash), loc+i, zck->buzhash_width, &buzhash_res)) {\n                zck_log(ZCK_LOG_ERROR, \"OOM in buzhash_update\");\n                return -1;\n            }\n\n            if((buzhash_res & zck->buzhash_bitmask) == 0 ||\n               zck->comp.dc_data_size + i >= zck->chunk_auto_max) {\n                if(comp_write(zck, loc, i) != i)\n                    return -1;\n                loc += i;\n                loc_size -= i;\n                i = 0;\n                if(zck->comp.dc_data_size >= zck->chunk_max_size)\n                    zck_log(ZCK_LOG_DDEBUG,\n                            \"Chunk has reached maximum size, forcing a new \"\n                            \"chunk\");\n                else\n                    zck_log(ZCK_LOG_DDEBUG, \"Automatically ending chunk\");\n                if(zck->comp.dc_data_size < zck->chunk_auto_min) {\n                    zck_log(ZCK_LOG_DDEBUG,\n                            \"Chunk too small, refusing to end chunk\");\n                    continue;\n                }\n                if(zck_end_chunk(zck) < 0)\n                    return -1;\n            } else {\n                i++;\n            }\n        }\n        if(loc_size > 0 && comp_write(zck, loc, loc_size) != loc_size)\n            return -1;\n        return src_size;\n    }\n}\n\nssize_t ZCK_PUBLIC_API zck_end_chunk(zckCtx *zck) {\n    VALIDATE_WRITE_INT(zck);\n\n    if(!zck->comp.started && !comp_init(zck))\n        return -1;\n\n    if(zck->comp.dc_data_size < zck->chunk_min_size) {\n        zck_log(ZCK_LOG_DDEBUG, \"Chunk too small, refusing to end chunk\");\n        return zck->comp.dc_data_size;\n    }\n\n    buzhash_reset(&(zck->buzhash));\n    /* No point in compressing empty data */\n    if(zck->comp.dc_data_size == 0)\n        return 0;\n\n    size_t data_size = zck->comp.dc_data_size;\n    char *dst = NULL;\n    size_t dst_size = 0;\n    if(!zck->comp.end_cchunk(zck, &(zck->comp), &dst, &dst_size, 1))\n        return -1;\n    zck->comp.dc_data_size = 0;\n    if(zck->no_write == 0 && dst_size > 0 && !write_data(zck, zck->temp_fd, dst, dst_size)) {\n        free(dst);\n        return -1;\n    }\n    if(!index_add_to_chunk(zck, dst, dst_size, 0)) {\n        free(dst);\n        return -1;\n    }\n    if(!index_finish_chunk(zck)) {\n        free(dst);\n        return -1;\n    }\n    zck_log(ZCK_LOG_DDEBUG, \"Finished chunk size: %llu\", (long long unsigned) data_size);\n    free(dst);\n    return data_size;\n}\n\nssize_t ZCK_PUBLIC_API zck_read(zckCtx *zck, char *dst, size_t dst_size) {\n    VALIDATE_READ_INT(zck);\n    ALLOCD_INT(zck, dst);\n\n    return comp_read(zck, dst, dst_size, 1);\n}\n\nssize_t ZCK_PUBLIC_API zck_get_chunk_comp_data(zckChunk *idx, char *dst,\n                                       size_t dst_size) {\n    zckCtx *zck = NULL;\n    if(idx && idx->zck) {\n        VALIDATE_INT(idx->zck);\n        zck = idx->zck;\n    }\n    ALLOCD_INT(zck, idx);\n    ALLOCD_INT(zck, dst);\n\n    /* Make sure chunk size is valid */\n    if(zck_get_chunk_size(idx) < 0)\n        return -1;\n\n    /* If the chunk is empty, we're done */\n    if(zck_get_chunk_size(idx) == 0)\n        return 0;\n\n    /* Make sure requested chunk has a beginning */\n    if(zck_get_chunk_start(idx) < 0)\n        return -1;\n\n    /* Seek to beginning of requested chunk */\n    if(!seek_data(zck, zck_get_chunk_start(idx), SEEK_SET))\n        return -1;\n\n    /* Return read chunk */\n    return read_data(zck, dst, dst_size);\n}\n\nssize_t ZCK_PUBLIC_API zck_get_chunk_data(zckChunk *idx, char *dst,\n                                  size_t dst_size) {\n    zckCtx *zck = NULL;\n    if(idx && idx->zck) {\n        VALIDATE_INT(idx->zck);\n        zck = idx->zck;\n    }\n    ALLOCD_INT(zck, idx);\n    ALLOCD_INT(zck, dst);\n\n    /* Make sure chunk size is valid */\n    if(zck_get_chunk_size(idx) < 0)\n        return -1;\n    /* If the chunk is empty, we're done */\n    if(zck_get_chunk_size(idx) == 0)\n        return 0;\n    /* Make sure requested chunk has a beginning */\n    if(zck_get_chunk_start(idx) < 0)\n        return -1;\n\n    /* Read dictionary if needed */\n    zckChunk *dict = zck_get_first_chunk(zck);\n    if(dict == NULL)\n        return -1;\n    if(zck_get_chunk_size(dict) > 0 && zck->comp.dict == NULL) {\n        if(zck_get_chunk_start(dict) < 0)\n            return -1;\n        if(!seek_data(zck, zck_get_chunk_start(dict), SEEK_SET))\n            return -1;\n        if(!comp_reset(zck))\n            return -1;\n        if(!comp_init(zck))\n            return -1;\n        if(!import_dict(zck))\n            return -1;\n    }\n\n    /* Seek to beginning of requested chunk */\n    if(!comp_reset_comp_data(zck))\n        return -1;\n    if(!comp_reset(zck))\n        return -1;\n    if(!comp_init(zck))\n        return -1;\n    if(!seek_data(zck, zck_get_chunk_start(idx), SEEK_SET))\n        return -1;\n    zck->comp.data_idx = idx;\n    return comp_read(zck, dst, dst_size, 1);\n}\n", "/*\n * Copyright 2018, 2021 Jonathan Dieter <jdieter@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  1. Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *  2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <zstd.h>\n#include <zck.h>\n\n#include \"zck_private.h\"\n\nstatic bool init(zckCtx *zck, zckComp *comp) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n\n#ifndef OLD_ZSTD\n    size_t retval = 0;\n#endif\n\n    comp->cctx = ZSTD_createCCtx();\n#ifndef OLD_ZSTD\n    retval = ZSTD_CCtx_setParameter(comp->cctx, ZSTD_c_compressionLevel, comp->level);\n    if(ZSTD_isError(retval)) {\n        set_fatal_error(zck, \"Unable to set compression level to %i\", comp->level);\n        return false;\n    }\n    // This seems to be the only way to make the compression deterministic across\n    // architectures with zstd 1.5.0\n    retval = ZSTD_CCtx_setParameter(comp->cctx, ZSTD_c_strategy, ZSTD_btopt);\n    if(ZSTD_isError(retval)) {\n        set_fatal_error(zck, \"Unable to set compression strategy\");\n        return false;\n    }\n#endif //OLD_ZSTD\n    comp->dctx = ZSTD_createDCtx();\n    if(comp->dict && comp->dict_size > 0) {\n#ifdef OLD_ZSTD\n        comp->cdict_ctx = ZSTD_createCDict(comp->dict, comp->dict_size,\n                                           comp->level);\n        if(comp->cdict_ctx == NULL) {\n            set_fatal_error(zck, \"Unable to create zstd compression dict context\");\n            return false;\n        }\n#else\n        retval = ZSTD_CCtx_loadDictionary(comp->cctx, comp->dict, comp->dict_size);\n        if(ZSTD_isError(retval)) {\n            set_fatal_error(zck, \"Unable to add zdict to compression context\");\n            return false;\n        }\n#endif //OLD_ZSTD\n        comp->ddict_ctx = ZSTD_createDDict(comp->dict, comp->dict_size);\n        if(comp->ddict_ctx == NULL) {\n            set_fatal_error(zck,\n                            \"Unable to create zstd decompression dict context\");\n            return false;\n        }\n    }\n    return true;\n}\n\nstatic bool close(zckCtx *zck, zckComp *comp) {\n    ALLOCD_BOOL(zck, zck);\n    ALLOCD_BOOL(zck, comp);\n\n    if(comp->cdict_ctx) {\n        ZSTD_freeCDict(comp->cdict_ctx);\n        comp->cdict_ctx = NULL;\n    }\n    if(comp->ddict_ctx) {\n        ZSTD_freeDDict(comp->ddict_ctx);\n        comp->ddict_ctx = NULL;\n    }\n    if(comp->cctx) {\n        ZSTD_freeCCtx(comp->cctx);\n        comp->cctx = NULL;\n    }\n    if(comp->dctx) {\n        ZSTD_freeDCtx(comp->dctx);\n        comp->dctx = NULL;\n    }\n    return true;\n}\n\n/* The zstd compression format doesn't allow streaming compression with a dict\n * unless you statically link to it.  If we have a dict, we do pseudo-streaming\n * compression where we buffer the data until the chunk ends. */\nstatic ssize_t compress(zckCtx *zck, zckComp *comp, const char *src,\n                        const size_t src_size, char **dst, size_t *dst_size,\n                        bool use_dict) {\n    VALIDATE_INT(zck);\n    ALLOCD_INT(zck, dst);\n    ALLOCD_INT(zck, src);\n    ALLOCD_INT(zck, dst_size);\n    ALLOCD_INT(zck, comp);\n\n    comp->dc_data = zrealloc(comp->dc_data, comp->dc_data_size + src_size);\n    if (!comp->dc_data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return -1;\n    }\n\n    memcpy(comp->dc_data + comp->dc_data_size, src, src_size);\n    *dst = NULL;\n    *dst_size = 0;\n    return 0;\n}\n\nstatic bool end_cchunk(zckCtx *zck, zckComp *comp, char **dst, size_t *dst_size,\n                       bool use_dict) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, dst);\n    ALLOCD_BOOL(zck, dst_size);\n    ALLOCD_BOOL(zck, comp);\n\n    size_t max_size = ZSTD_compressBound(comp->dc_data_size);\n    if(ZSTD_isError(max_size)) {\n        set_fatal_error(zck, \"zstd compression error: %s\",\n                        ZSTD_getErrorName(max_size));\n        return false;\n    }\n\n    *dst = zmalloc(max_size);\n    if (!dst) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n#ifdef OLD_ZSTD\n    /* Currently, compression isn't deterministic when using contexts in\n     * zstd 1.3.5, so this works around it */\n    if(use_dict && comp->cdict_ctx) {\n        if(comp->cctx)\n            ZSTD_freeCCtx(comp->cctx);\n        comp->cctx = ZSTD_createCCtx();\n\n        *dst_size = ZSTD_compress_usingDict(comp->cctx, *dst, max_size,\n                                            comp->dc_data, comp->dc_data_size,\n                                            comp->dict, comp->dict_size,\n                                            comp->level);\n    } else {\n        *dst_size = ZSTD_compress(*dst, max_size, comp->dc_data,\n                                  comp->dc_data_size, comp->level);\n    }\n#else\n    if(!use_dict && comp->dict_size > 0) {\n        size_t retval = ZSTD_CCtx_loadDictionary(comp->cctx, NULL, 0);\n        if(ZSTD_isError(retval)) {\n            set_fatal_error(zck, \"Unable to add zdict to compression context\");\n            return false;\n        }\n        *dst_size = ZSTD_compress2(comp->cctx, *dst, max_size, comp->dc_data,\n                                   comp->dc_data_size);\n        retval = ZSTD_CCtx_loadDictionary(comp->cctx, comp->dict, comp->dict_size);\n        if(ZSTD_isError(retval)) {\n            set_fatal_error(zck, \"Unable to add zdict to compression context\");\n            return false;\n        }\n    } else {\n        *dst_size = ZSTD_compress2(comp->cctx, *dst, max_size, comp->dc_data,\n                                   comp->dc_data_size);\n    }\n#endif //OLD_ZSTD\n\n    free(comp->dc_data);\n    comp->dc_data = NULL;\n    comp->dc_data_loc = 0;\n    if(ZSTD_isError(*dst_size)) {\n        set_fatal_error(zck, \"zstd compression error: %s\",\n                        ZSTD_getErrorName(*dst_size));\n        return false;\n    }\n    return true;\n}\n\nstatic bool decompress(zckCtx *zck, zckComp *comp, const bool use_dict) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n\n    return true;\n}\n\nstatic bool end_dchunk(zckCtx *zck, zckComp *comp, const bool use_dict,\n                       const size_t fd_size) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n\n    char *src = comp->data;\n    size_t src_size = comp->data_size;\n    comp->data = NULL;\n    comp->data_size = 0;\n\n    char *dst = zmalloc(fd_size);\n    if (!dst) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    size_t retval = 0;\n    zck_log(ZCK_LOG_DEBUG, \"Decompressing %llu bytes to %llu bytes\",\n            (long long unsigned) src_size,\n            (long long unsigned) fd_size\n    );\n    if(use_dict && comp->ddict_ctx) {\n        zck_log(ZCK_LOG_DEBUG, \"Running decompression using dict\");\n        retval = ZSTD_decompress_usingDDict(comp->dctx, dst, fd_size, src,\n                                            src_size, comp->ddict_ctx);\n    } else {\n        zck_log(ZCK_LOG_DEBUG, \"Running decompression\");\n        retval = ZSTD_decompressDCtx(comp->dctx, dst, fd_size, src, src_size);\n    }\n\n    if(ZSTD_isError(retval)) {\n        set_fatal_error(zck, \"zstd decompression error: %s\",\n                        ZSTD_getErrorName(retval));\n        goto decomp_error_2;\n    }\n    if(!comp_add_to_dc(zck, comp, dst, fd_size))\n        goto decomp_error_2;\n    free(dst);\n    free(src);\n    return true;\ndecomp_error_2:\n    free(dst);\n    free(src);\n    return false;\n}\n\nstatic bool set_parameter(zckCtx *zck, zckComp *comp, int option,\n                          const void *value) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n\n    if(option == ZCK_ZSTD_COMP_LEVEL) {\n        if(*(int*)value >= 0 && *(int*)value <= ZSTD_maxCLevel()) {\n            comp->level = *(int*)value;\n            return true;\n        }\n    }\n    set_error(zck, \"Invalid compression parameter for ZCK_COMP_ZSTD\");\n    return false;\n}\n\nstatic bool set_default_parameters(zckCtx *zck, zckComp *comp) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n\n    /* Set default compression level to 9 */\n    int level=9;\n    return set_parameter(zck, comp, ZCK_ZSTD_COMP_LEVEL, &level);\n}\n\nbool zstd_setup(zckCtx *zck, zckComp *comp) {\n    comp->init = init;\n    comp->set_parameter = set_parameter;\n    comp->compress = compress;\n    comp->end_cchunk = end_cchunk;\n    comp->decompress = decompress;\n    comp->end_dchunk = end_dchunk;\n    comp->close = close;\n    comp->type = ZCK_COMP_ZSTD;\n    return set_default_parameters(zck, comp);\n}\n", "/*\n * Copyright 2018 Jonathan Dieter <jdieter@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  1. Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *  2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdio.h>\n#include <regex.h>\n#include <zck.h>\n\n#include \"zck_private.h\"\n\nstatic char *add_boundary_to_regex(zckCtx *zck, const char *regex,\n                                   const char *boundary) {\n    VALIDATE_PTR(zck);\n\n    if(regex == NULL || boundary == NULL)\n        return NULL;\n    char *regex_b = zmalloc(strlen(regex) + strlen(boundary) + 1);\n    if(!regex_b || snprintf(regex_b, strlen(regex) + strlen(boundary), regex,\n                boundary) != strlen(regex) + strlen(boundary) - 2) {\n        free(regex_b);\n        set_error(zck, \"Unable to build regular expression\");\n        return NULL;\n    }\n    return regex_b;\n}\n\nstatic bool create_regex(zckCtx *zck, regex_t *reg, const char *regex) {\n    VALIDATE_BOOL(zck);\n\n    if(reg == NULL || regex == NULL) {\n        set_error(zck, \"Regular expression not initialized\");\n        return false;\n    }\n    int cflags = REG_ICASE | REG_EXTENDED;\n#if __APPLE__\n    cflags |= REG_ENHANCED;\n#endif\n    if(regcomp(reg, regex, cflags) != 0) {\n        set_error(zck, \"Unable to compile regular expression\");\n        return false;\n    }\n    return true;\n}\n\nstatic bool gen_regex(zckDL *dl) {\n    ALLOCD_BOOL(NULL, dl);\n    VALIDATE_BOOL(dl->zck);\n\n    /* Response should include content-type, but we only need the range, so\n     * wildcard out the content-type */\n    char *next = \"\\r?\\n?--%s\\r\\n.*\" \\\n                 \"content-range: *bytes *([0-9]+) *- *([0-9]+) */[0-9]+\";\n    char *end =  \"\\r\\n--%s--\";\n    char *regex_n = add_boundary_to_regex(dl->zck, next, dl->boundary);\n    if(regex_n == NULL)\n        return false;\n    dl->dl_regex = zmalloc(sizeof(regex_t));\n    if(!dl->dl_regex || !create_regex(dl->zck, dl->dl_regex, regex_n)) {\n        free(regex_n);\n        return false;\n    }\n    free(regex_n);\n    char *regex_e = add_boundary_to_regex(dl->zck, end, dl->boundary);\n    if(regex_e == NULL)\n        return false;\n    dl->end_regex = zmalloc(sizeof(regex_t));\n    if(!dl->end_regex || !create_regex(dl->zck, dl->end_regex, regex_e)) {\n        free(regex_e);\n        return false;\n    }\n    free(regex_e);\n    return true;\n}\n\nvoid reset_mp(zckMP *mp) {\n    if(mp == NULL)\n        return;\n    if(mp->buffer)\n        free(mp->buffer);\n    memset(mp, 0, sizeof(zckMP));\n}\n\nsize_t multipart_extract(zckDL *dl, char *b, size_t l) {\n    ALLOCD_BOOL(NULL, dl);\n    VALIDATE_BOOL(dl->zck);\n\n    if(dl->mp == NULL)\n        return 0;\n\n    zckMP *mp = dl->mp;\n    char *buf = b;\n    bool alloc_buf = false;\n\n    /* Add new data to stored buffer */\n    if(mp->buffer) {\n        buf = zrealloc(mp->buffer, mp->buffer_len + l);\n        if (!buf) {\n            zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n            return 0;\n        }\n        memcpy(buf + mp->buffer_len, b, l);\n        l = mp->buffer_len + l;\n        mp->buffer = NULL;  // No need to free, buf holds realloc'd buffer\n        mp->buffer_len = 0;\n        alloc_buf = true;\n    }\n\n    /* If regex hasn't been created, create it */\n    if(dl->dl_regex == NULL && !gen_regex(dl)) {\n        if(alloc_buf)\n            free(buf);\n        return 0;\n    }\n\n    char *header_start = buf;\n    char *i = buf;\n    while(i) {\n        char *end = buf + l;\n        /* If we're in data writing state, then write data until end of buffer\n         * or end of range, whichever comes first */\n        if(mp->state != 0) {\n            if(i >= end)\n                break;\n            size_t size = end - i;\n            if(mp->length <= size) {\n                size = mp->length;\n                mp->length = 0;\n                mp->state = 0;\n                header_start = i + size;\n            } else {\n                mp->length -= size;\n            }\n            if(dl_write_range(dl, i, size) != size)\n                return 0;\n            i += size;\n            continue;\n        }\n\n        /* If we've reached the end of the buffer without finishing, save it\n         * and leave loop */\n        if(i >= end) {\n            size_t size = buf + l - header_start;\n            if(size > 0) {\n                mp->buffer = zmalloc(size);\n                if (!mp->buffer) {\n                    free(buf);\n                    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n                    return 0;\n                }\n                memcpy(mp->buffer, header_start, size);\n                mp->buffer_len = size;\n            }\n            break;\n        }\n\n        /* Find double newline and replace final \\n with \\0, so it's a zero-\n         * terminated string.  This is the part header.  After finding the end\n         * of the part header (and beginning of the actual data), set j to that\n         * so we can set i to it when we finish getting the part header info */\n        char *j = i;\n        for(; j<end; j++) {\n            if(j + 4 >= end) {\n                i = j+4;\n                break;\n            }\n            if(memcmp(j, \"\\r\\n\\r\\n\", 4) == 0) {\n                j[3] = '\\0';\n                j += 4;\n                break;\n            }\n        }\n        if(i >= end)\n            continue;\n\n        /* Run regex against download range string */\n        regmatch_t match[4] = {{0}};\n        if(regexec(dl->dl_regex, i, 3, match, 0) != 0) {\n            if(regexec(dl->end_regex, i, 3, match, 0) != 0)\n                set_error(dl->zck, \"Unable to find multipart download range\");\n            goto end;\n        }\n\n        /* Get range start from regex */\n        size_t rstart = 0;\n        for(char *c=i + match[1].rm_so; c < i + match[1].rm_eo; c++)\n            rstart = rstart*10 + (size_t)(c[0] - 48);\n\n        /* Get range end from regex */\n        size_t rend = 0;\n        for(char *c=i + match[2].rm_so; c < i + match[2].rm_eo; c++)\n            rend = rend*10 + (size_t)(c[0] - 48);\n\n        i = j;\n        zck_log(ZCK_LOG_DEBUG, \"Download range: %llu-%llu\",\n                (long long unsigned) rstart,\n                (long long unsigned) rend\n        );\n        mp->length = rend-rstart+1;\n        mp->state = 1;\n    }\nend:\n    if(alloc_buf)\n        free(buf);\n    return l;\n}\n\nsize_t multipart_get_boundary(zckDL *dl, char *b, size_t size) {\n    ALLOCD_BOOL(NULL, dl);\n    VALIDATE_BOOL(dl->zck);\n\n    /* Create regex to find boundary */\n    if(dl->hdr_regex == NULL) {\n        char *regex = \"boundary *= *(.*?) *\\r\";\n        dl->hdr_regex = zmalloc(sizeof(regex_t));\n        if(!dl->hdr_regex || !create_regex(dl->zck, dl->hdr_regex, regex))\n            return 0;\n    }\n\n    /* Copy buffer to null-terminated string because POSIX regex requires null-\n     * terminated string */\n    char *buf = zmalloc(size+1);\n    if (!buf) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return 0;\n    }\n    buf[size] = '\\0';\n    memcpy(buf, b, size);\n\n    /* Check whether this header contains the boundary and set it if it does */\n    regmatch_t match[2] = {{0}};\n    if(regexec(dl->hdr_regex, buf, 2, match, 0) == 0) {\n        reset_mp(dl->mp);\n        size_t boundary_length = match[1].rm_eo - match[1].rm_so;\n        char *boundary_start = buf + match[1].rm_so;\n        if (boundary_start[0] == '\\\"' && boundary_length > 2\n            && boundary_start[boundary_length-1] == '\\\"') {\n            /* Remove optional quotes */\n            boundary_start  += 1;\n            boundary_length -= 2;\n        }\n        char *boundary = zmalloc(boundary_length + 1);\n        if (!boundary) {\n            zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n            free(buf);\n            return 0;\n        }\n        memcpy(boundary, boundary_start, boundary_length);\n        zck_log(ZCK_LOG_DEBUG, \"Multipart boundary: %s\", boundary);\n        dl->boundary = boundary;\n    }\n    free(buf);\n    return size;\n}\n", "/*\n * Copyright 2018 Jonathan Dieter <jdieter@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  1. Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *  2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include <zck.h>\n\n#include \"zck_private.h\"\n\nstatic bool check_flags(zckCtx *zck, size_t flags) {\n    zck->has_streams = flags & 1;\n    if(zck->has_streams) {\n        flags -= 1;\n        set_fatal_error(zck,\n                        \"This version of zchunk doesn't support streams\");\n        return false;\n    }\n    zck->has_optional_elems = flags & 2;\n    if(zck->has_optional_elems)\n        flags -= 2;\n    zck->has_uncompressed_source = flags & 4;\n    if(zck->has_uncompressed_source)\n        flags -= 4;\n\n    flags = flags & (SIZE_MAX - 1);\n    if(flags != 0) {\n        set_fatal_error(zck, \"Unknown flags(s) set: %lu\", flags);\n        return false;\n    }\n    return true;\n}\n\nstatic ssize_t get_flags(zckCtx *zck) {\n    size_t flags = 0;\n    if(zck->has_streams)\n        flags |= 1;\n    if(zck->has_optional_elems)\n        flags |= 2;\n    if(zck->has_uncompressed_source)\n        flags |= 4;\n    return flags;\n}\n\nstatic bool read_optional_element(zckCtx *zck, size_t id, size_t data_size,\n                                  char *data) {\n    zck_log(ZCK_LOG_WARNING, \"Unknown optional element id %i set\", id);\n    return true;\n}\n\nstatic bool read_header_from_file(zckCtx *zck) {\n    /* Verify that lead_size and header_length have been set */\n    if(zck->lead_size == 0 || zck->header_length == 0) {\n        set_error(zck, \"Lead and header sizes are both 0.  Have you run zck_read_lead() yet?\");\n        return false;\n    }\n\n    /* Allocate header and store any extra bytes at beginning of header */\n    zck->header = zrealloc(zck->header, zck->lead_size + zck->header_length);\n    if (!zck->header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck->lead_string = zck->header;\n    char *header = zck->header + zck->lead_size;\n    size_t loaded = 0;\n\n    if(zck->header_length < zck->header_size - zck->lead_size) {\n        set_fatal_error(zck, \"Header size is too small for actual data\");\n        return false;\n    }\n    if(zck->lead_size < zck->header_size)\n        loaded = zck->header_size - zck->lead_size;\n\n    /* Read header from file */\n    zck_log(ZCK_LOG_DEBUG, \"Reading the rest of the header: %llu bytes\",\n            (long long unsigned) zck->header_length);\n    if(loaded < zck->header_length) {\n        if(read_data(zck, header + loaded, zck->header_length - loaded) < zck->header_length - loaded) {\n            set_fatal_error(zck, \"Unable to read %llu bytes from the file\", zck->header_length - loaded);\n            return false;\n        }\n        zck->header_size = zck->lead_size + zck->header_length;\n    }\n\n    if(!hash_init(zck, &(zck->check_full_hash), &(zck->hash_type)))\n        return false;\n    /* If we're reading a detached zchunk header, first five bytes will be\n     * different, breaking the header digest, so let's make things simple\n     * by forcing the first five bytes to be static */\n    if(!hash_update(zck, &(zck->check_full_hash), \"\\0ZCK1\", 5))\n        return false;\n    /* Now hash the remaining lead */\n    if(!hash_update(zck, &(zck->check_full_hash), zck->header+5,\n                    zck->hdr_digest_loc-5))\n        return false;\n    /* And the remaining header */\n    if(!hash_update(zck, &(zck->check_full_hash), header, zck->header_length))\n        return false;\n    int ret = validate_header(zck);\n    if(ret < 1) {\n        if(ret == -1)\n            set_fatal_error(zck, \"Header checksum failed verification\");\n        return false;\n    }\n    return true;\n}\n\nstatic bool read_preface(zckCtx *zck) {\n    VALIDATE_READ_BOOL(zck);\n\n    if(zck->header_digest == NULL) {\n        set_error(zck, \"Reading preface before lead is read\");\n        return false;\n    }\n\n    char *header = zck->header + zck->lead_size;\n    size_t length = 0;\n    size_t max_length = zck->header_length;\n\n    /* Read data digest */\n    zck_log(ZCK_LOG_DEBUG, \"Reading data digest\");\n    if(length + zck->hash_type.digest_size > max_length) {\n        set_fatal_error(zck, \"Read past end of header\");\n        return false;\n    }\n    zck->full_hash_digest = zmalloc(zck->hash_type.digest_size);\n    if (!zck->full_hash_digest) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    memcpy(zck->full_hash_digest, header+length, zck->hash_type.digest_size);\n    length += zck->hash_type.digest_size;\n\n    /* Read flags */\n    size_t flags = 0;\n    if(!compint_to_size(zck, &flags, header+length, &length, max_length))\n        return false;\n    if(!check_flags(zck, flags))\n        return false;\n\n    /* Setup for reading compression type */\n    zck_log(ZCK_LOG_DEBUG, \"Reading compression type and index size\");\n    int tmp = 0;\n\n    /* Read and initialize compression type */\n    if(!compint_to_int(zck, &tmp, header+length, &length, max_length))\n        return false;\n    if(!comp_ioption(zck, ZCK_COMP_TYPE, tmp))\n        return false;\n    if(!comp_init(zck))\n        return false;\n\n    /* Read optional flags */\n    if(zck->has_optional_elems) {\n        size_t opt_count = 0;\n        if(!compint_to_size(zck, &opt_count, header+length, &length,\n                            max_length))\n            return false;\n        for(size_t i=0; i<opt_count; i++) {\n            size_t id = 0;\n            size_t data_size = 0;\n            if(!compint_to_size(zck, &id, header+length, &length, max_length))\n                return false;\n            if(!compint_to_size(zck, &data_size, header+length, &length,\n                                max_length))\n                return false;\n            if(!read_optional_element(zck, id, data_size, header+length))\n                return false;\n            length += data_size;\n        }\n    }\n\n    /* Read and initialize index size */\n    if(!compint_to_int(zck, &tmp, header+length, &length, max_length))\n        return false;\n    zck->index_size = tmp;\n\n    zck->preface_string = header;\n    zck->preface_size = length;\n    return true;\n}\n\nstatic bool read_index(zckCtx *zck) {\n    VALIDATE_READ_BOOL(zck);\n\n    if(zck->preface_string == NULL) {\n        set_error(zck, \"Reading index before preface is read\");\n        return false;\n    }\n\n    char *header = NULL;\n    if(zck->lead_size + zck->preface_size + zck->index_size >\n       zck->header_size) {\n        set_fatal_error(zck, \"Read past end of header\");\n        return false;\n    }\n    header = zck->header + zck->lead_size + zck->preface_size;\n    zck_log(ZCK_LOG_DEBUG, \"Reading index at 0x%x\", (unsigned long)(zck->lead_size + zck->preface_size));\n    int max_length = zck->header_size - (zck->lead_size + zck->preface_size);\n    if(!index_read(zck, header, zck->index_size, max_length))\n        return false;\n\n    zck->index_string = header;\n    return true;\n}\n\nstatic bool read_sig(zckCtx *zck) {\n    VALIDATE_READ_BOOL(zck);\n\n    if(zck->index_string == NULL) {\n        set_error(zck, \"Reading signatures before index is read\");\n        return false;\n    }\n\n    char *header = zck->header + zck->lead_size + zck->preface_size +\n                   zck->index_size;\n    size_t max_length = zck->header_size - (zck->lead_size + zck->preface_size +\n                                            zck->index_size);\n    size_t length = 0;\n\n    if(!compint_to_int(zck, &(zck->sigs.count), header, &length, max_length))\n        return false;\n\n    /* We don't actually support signatures yet, so bail if there is one */\n    zck_log(ZCK_LOG_DEBUG, \"Signature count: %i\", zck->sigs.count);\n    if(zck->sigs.count > 0) {\n        set_fatal_error(zck, \"Signatures aren't supported yet\");\n        return false;\n    }\n\n    /* Set data_offset */\n    zck->data_offset = zck->lead_size + zck->header_length;\n\n    if(zck->header_size >\n       zck->lead_size + zck->preface_size + zck->index_size + length)\n        zck_log(ZCK_LOG_WARNING, \"There are unused bytes in the header\");\n\n    zck->sig_size = length;\n    zck->sig_string = header;\n    return true;\n}\n\nstatic bool preface_create(zckCtx *zck) {\n    VALIDATE_WRITE_BOOL(zck);\n\n    int header_malloc = zck->hash_type.digest_size + 4 + 2*MAX_COMP_SIZE;\n\n    char *header = zmalloc(header_malloc);\n    if (!header) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    size_t length = 0;\n\n    /* Write out the full data digest */\n    memcpy(header + length, zck->full_hash_digest, zck->hash_type.digest_size);\n    length += zck->hash_type.digest_size;\n\n    /* Write out flags */\n    compint_from_size(header+length, get_flags(zck), &length);\n\n    /* Write out compression type and index size */\n    if(!compint_from_int(zck, header+length, zck->comp.type, &length)) {\n        free(header);\n        return false;\n    }\n    compint_from_size(header+length, zck->index_size, &length);\n\n    /* Shrink header to actual size */\n    header = zrealloc(header, length);\n    if (!header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n\n    zck->preface_string = header;\n    zck->preface_size = length;\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Generated preface: %llu bytes\",\n        (long long unsigned) zck->preface_size\n    );\n    return true;\n}\n\nstatic bool sig_create(zckCtx *zck) {\n    char *header = zmalloc(MAX_COMP_SIZE);\n    size_t length = 0;\n\n    if (!header) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Calculating %i signatures\", zck->sigs.count);\n\n    /* Write out signature count and signatures */\n    if(!compint_from_int(zck, header+length, zck->sigs.count, &length)) {\n        free(header);\n        return false;\n    }\n    for(int i=0; i<zck->sigs.count; i++) {\n        // TODO: Add signatures\n    }\n    zck->sig_string = header;\n    zck->sig_size = length;\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Generated signatures: %llu bytes\",\n        (long long unsigned) zck->sig_size\n    );\n    return true;\n}\n\nstatic bool lead_create(zckCtx *zck) {\n    int phs = 5 + 2*MAX_COMP_SIZE + zck->hash_type.digest_size;\n    char *header = zmalloc(phs);\n    size_t length = 0;\n    memcpy(header, \"\\0ZCK1\", 5);\n    length += 5;\n\n    if (!header) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    /* Write out full data and header hash type */\n    compint_from_size(header + length, zck->hash_type.type, &length);\n    /* Write out header length */\n    zck->header_length = zck->preface_size + zck->index_size + zck->sig_size;\n    compint_from_size(header + length, zck->header_length, &length);\n    /* Skip header digest; we'll fill it in later */\n    zck->hdr_digest_loc = length;\n    length += zck->hash_type.digest_size;\n\n    header = zrealloc(header, length);\n    if (!header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n\n    zck->lead_string = header;\n    zck->lead_size = length;\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Generated lead: %llu bytes\",\n        (long long unsigned) zck->lead_size\n    );\n    return true;\n}\n\nbool header_create(zckCtx *zck) {\n    VALIDATE_WRITE_BOOL(zck);\n\n    /* Rebuild header without header hash */\n    if(zck->header_digest) {\n        free(zck->header_digest);\n        zck->header_digest = NULL;\n    }\n\n    /* Generate index */\n    if(!index_create(zck))\n        return false;\n\n    /* Generate preface */\n    if(!preface_create(zck))\n        return false;\n\n    /* Rebuild signatures */\n    if(!sig_create(zck))\n        return false;\n\n    /* Rebuild pre-header */\n    if(!lead_create(zck))\n        return false;\n\n    /* Calculate data offset */\n    zck->data_offset = zck->lead_size + zck->preface_size +\n                       zck->index_size + zck->sig_size;\n\n    /* Merge everything into one large string */\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Merging into header: %llu bytes\",\n        (long long unsigned) zck->data_offset\n    );\n    zck->header = zmalloc(zck->data_offset);\n    if (!zck->header) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    size_t offs = 0;\n    memcpy(zck->header + offs, zck->lead_string, zck->lead_size);\n    free(zck->lead_string);\n    zck->lead_string = zck->header + offs;\n    offs += zck->lead_size;\n    memcpy(zck->header + offs, zck->preface_string, zck->preface_size);\n    free(zck->preface_string);\n    zck->preface_string = zck->header + offs;\n    offs += zck->preface_size;\n    memcpy(zck->header + offs, zck->index_string, zck->index_size);\n    free(zck->index_string);\n    zck->index_string = zck->header + offs;\n    offs += zck->index_size;\n    memcpy(zck->header + offs, zck->sig_string, zck->sig_size);\n    free(zck->sig_string);\n    zck->sig_string = zck->header + offs;\n    zck->header_size = zck->data_offset;\n\n    zckHash header_hash = {0};\n\n    /* Calculate hash of header */\n    if(!hash_init(zck, &header_hash, &(zck->hash_type)))\n        return false;\n    zck_log(ZCK_LOG_DEBUG, \"Hashing lead\");\n    /* Hash lead up to header digest */\n    if(!hash_update(zck, &header_hash, zck->lead_string,\n                    zck->hdr_digest_loc))\n        return false;\n    zck_log(ZCK_LOG_DEBUG, \"Hashing the rest\");\n    /* Hash rest of header */\n    if(!hash_update(zck, &header_hash, zck->preface_string, zck->header_length))\n        return false;\n    zck->header_digest = hash_finalize(zck, &header_hash);\n    if(zck->header_digest == NULL)\n        return false;\n\n    /* Write digest to header */\n    memcpy(zck->lead_string+zck->hdr_digest_loc, zck->header_digest,\n           zck->hash_type.digest_size);\n\n    return true;\n}\n\nbool write_header(zckCtx *zck) {\n    VALIDATE_WRITE_BOOL(zck);\n\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Writing header: %llu bytes\",\n        (long long unsigned) zck->lead_size\n    );\n    if(zck->no_write == 0 && !write_data(zck, zck->fd, zck->header, zck->header_size))\n        return false;\n    return true;\n}\n\nstatic bool read_lead(zckCtx *zck) {\n    VALIDATE_READ_BOOL(zck);\n\n    int lead = 5 + 2*MAX_COMP_SIZE;\n\n    char *header = zmalloc(lead);\n    if (!header) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    size_t length = 0;\n\n    if(read_data(zck, header, lead) < lead) {\n        free(header);\n        set_error(zck, \"Short read\");\n        return false;\n    }\n\n    if(memcmp(header, \"\\0ZHR1\", 5) == 0) {\n        zck->header_only = true;\n    } else if(memcmp(header, \"\\0ZCK1\", 5) != 0) {\n        free(header);\n        set_error(zck, \"Invalid lead, perhaps this is not a zck file?\");\n        return false;\n    }\n    length += 5;\n\n    /* Read hash type for header and full digest and initialize check hash */\n    int hash_type = 0;\n    if(!compint_to_int(zck, &hash_type, header+length, &length, lead)) {\n        free(header);\n        return false;\n    }\n    if(zck->prep_hash_type > -1 && zck->prep_hash_type != hash_type) {\n        free(header);\n        set_error(zck, \"Hash type (%i) doesn't match requested hash type \"\n                  \"(%i)\", hash_type, zck->prep_hash_type);\n        return false;\n    }\n    if(!hash_setup(zck, &(zck->hash_type), hash_type)) {\n        free(header);\n        return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Setting header and full digest hash type to %s\",\n            zck_hash_name_from_type(hash_type));\n\n    /* Read header size */\n    size_t header_length = 0;\n    if(!compint_to_size(zck, &header_length, header+length, &length, lead)) {\n        free(header);\n        hash_reset(&(zck->hash_type));\n        return false;\n    }\n    if(header_length > SIZE_MAX) {\n        free(header);\n        set_error(zck, \"Header length of %li invalid\", header_length);\n        hash_reset(&(zck->hash_type));\n        return false;\n    }\n    zck->header_length = header_length;\n\n    /* Set header digest location */\n    zck->hdr_digest_loc = length;\n\n    /* Read header digest */\n    zck_log(ZCK_LOG_DEBUG, \"Reading header digest\");\n    header = zrealloc(header, length + zck->hash_type.digest_size);\n    if (!header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    size_t to_read = 0;\n    if(lead < length + zck->hash_type.digest_size)\n        to_read = length + zck->hash_type.digest_size - lead;\n    if(read_data(zck, header + lead, to_read) < to_read) {\n        free(header);\n        zck->header_length = 0;\n        zck->hdr_digest_loc = 0;\n        hash_reset(&(zck->hash_type));\n        return false;\n    }\n    lead += to_read;\n\n    if(zck->prep_digest &&\n       memcmp(zck->prep_digest, header + length, zck->hash_type.digest_size) != 0) {\n        zck->header_length = 0;\n        zck->hdr_digest_loc = 0;\n        hash_reset(&(zck->hash_type));\n        set_error(zck,\n                  \"Header digest doesn't match requested header digest\"\n                  \"Expected: %sActual: %s\",\n                  get_digest_string(zck->prep_digest,\n                                    zck->hash_type.digest_size),\n                  get_digest_string(header + length,\n                                    zck->hash_type.digest_size));\n        free(header);\n        return false;\n    }\n    zck->header_digest = zmalloc(zck->hash_type.digest_size);\n    if (!zck->header_digest) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    free(header);\n\t    return false;\n    }\n    memcpy(zck->header_digest, header + length, zck->hash_type.digest_size);\n    length += zck->hash_type.digest_size;\n\n    /* Check whether full header length matches specified header length */\n    if(zck->prep_hdr_size > -1 &&\n       (size_t)zck->prep_hdr_size != zck->header_length + length) {\n        free(header);\n        zck->header_length = 0;\n        zck->hdr_digest_loc = 0;\n        hash_reset(&(zck->hash_type));\n        free(zck->header_digest);\n        zck->header_digest = NULL;\n        set_error(\n            zck,\n            \"Header length (%llu) doesn't match requested header length (%llu)\",\n            (long long unsigned) zck->header_length + length,\n            (long long unsigned) zck->prep_hdr_size\n        );\n        return false;\n    }\n    /* Store pre-header */\n    zck->header = header;\n    zck->header_size = lead;\n    zck->lead_string = header;\n    zck->lead_size = length;\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Parsed lead: %llu bytes\",\n        (long long unsigned) length\n    );\n    return true;\n}\n\nbool ZCK_PUBLIC_API zck_read_lead(zckCtx *zck) {\n    VALIDATE_BOOL(zck);\n\n    return read_lead(zck);\n}\n\nbool ZCK_PUBLIC_API zck_validate_lead(zckCtx *zck) {\n    VALIDATE_BOOL(zck);\n\n    int retval = read_lead(zck);\n    if(!zck_clear_error(zck))\n        return false;\n    free(zck->header);\n    free(zck->header_digest);\n    zck->header = NULL;\n    zck->header_size = 0;\n    zck->header_length = 0;\n    zck->hdr_digest_loc = 0;\n    zck->lead_string = NULL;\n    zck->lead_size = 0;\n    zck->header_digest = NULL;\n    zck->hdr_digest_loc = 0;\n    hash_reset(&(zck->hash_type));\n    if(!seek_data(zck, 0, SEEK_SET))\n        return false;\n    return retval;\n}\n\nbool ZCK_PUBLIC_API zck_read_header(zckCtx *zck) {\n    VALIDATE_READ_BOOL(zck);\n\n    if(!read_header_from_file(zck))\n        return false;\n    if(!read_preface(zck))\n        return false;\n    if(!read_index(zck))\n        return false;\n    if(!read_sig(zck))\n        return false;\n    return true;\n}\n\nssize_t ZCK_PUBLIC_API zck_get_header_length(zckCtx *zck) {\n    VALIDATE_INT(zck);\n    return zck->lead_size + zck->header_length;\n}\n\nssize_t ZCK_PUBLIC_API zck_get_lead_length(zckCtx *zck) {\n    VALIDATE_INT(zck);\n    return zck->lead_size;\n}\n\nssize_t ZCK_PUBLIC_API zck_get_data_length(zckCtx *zck) {\n    VALIDATE_INT(zck);\n    zckChunk *idx = zck->index.first;\n    while(idx->next != NULL)\n        idx = idx->next;\n    return idx->start + idx->comp_length;\n}\n\nssize_t ZCK_PUBLIC_API zck_get_length(zckCtx *zck) {\n    VALIDATE_INT(zck);\n    return zck_get_header_length(zck) + zck_get_data_length(zck);\n}\n\nssize_t ZCK_PUBLIC_API zck_get_flags(zckCtx *zck) {\n    VALIDATE_INT(zck);\n    return get_flags(zck);\n}\n\nbool ZCK_PUBLIC_API zck_is_detached_header(zckCtx *zck) {\n    VALIDATE_BOOL(zck);\n    return zck->header_only;\n}\n"], "fixing_code": ["/*\n * Copyright 2018 Jonathan Dieter <jdieter@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  1. Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *  2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <math.h>\n#include <zck.h>\n\n#include \"zck_private.h\"\n#include \"comp/nocomp/nocomp.h\"\n#ifdef ZCHUNK_ZSTD\n#include \"comp/zstd/zstd.h\"\n#endif\n\n#define BLK_SIZE 32768\n\nstatic char unknown[] = \"Unknown(\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\nconst static char *COMP_NAME[] = {\n    \"no\",\n    \"Unknown (1)\",\n    \"zstd\"\n};\n\nstatic void update_buzhash_bits(zckCtx *zck) {\n    int s=1;\n    for(int i=0; i<zck->buzhash_match_bits; i++)\n        s *= 2;\n    s -= 1;\n    zck->buzhash_bitmask = s;\n}\n\nstatic bool set_comp_type(zckCtx *zck, ssize_t type) {\n    VALIDATE_BOOL(zck);\n\n    zckComp *comp = &(zck->comp);\n\n    /* Cannot change compression type after compression has started */\n    if(comp->started) {\n        set_error(zck, \"Unable to set compression type after initialization\");\n        return false;\n    }\n\n    /* Set all values to 0 before setting compression type */\n    char *dc_data = comp->dc_data;\n    size_t dc_data_loc = comp->dc_data_loc;\n    size_t dc_data_size = comp->dc_data_size;\n    memset(comp, 0, sizeof(zckComp));\n    comp->dc_data = dc_data;\n    comp->dc_data_loc = dc_data_loc;\n    comp->dc_data_size = dc_data_size;\n\n    zck_log(ZCK_LOG_DEBUG, \"Setting compression to %s\",\n            zck_comp_name_from_type(type));\n    if(type == ZCK_COMP_NONE) {\n        return nocomp_setup(zck, comp);\n#ifdef ZCHUNK_ZSTD\n    } else if(type == ZCK_COMP_ZSTD) {\n        return zstd_setup(zck, comp);\n#endif\n    } else {\n        set_error(zck, \"Unsupported compression type: %s\",\n                  zck_comp_name_from_type(type));\n        return false;\n    }\n    return true;\n}\n\nstatic size_t comp_read_from_dc(zckCtx *zck, zckComp *comp, char *dst,\n                                size_t dst_size) {\n    VALIDATE_INT(zck);\n    ALLOCD_INT(zck, comp);\n    ALLOCD_INT(zck, dst);\n\n    size_t dl_size = dst_size;\n    if(dl_size > comp->dc_data_size - comp->dc_data_loc)\n        dl_size = comp->dc_data_size - comp->dc_data_loc;\n    memcpy(dst, comp->dc_data+comp->dc_data_loc, dl_size);\n    comp->dc_data_loc += dl_size;\n    if(dl_size > 0)\n        zck_log(ZCK_LOG_DEBUG, \"Reading %llu bytes from decompressed buffer\",\n                (long long unsigned) dl_size);\n    return dl_size;\n}\n\nstatic bool comp_add_to_data(zckCtx *zck, zckComp *comp, const char *src,\n                             size_t src_size) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n    ALLOCD_BOOL(zck, src);\n\n    if((comp->data_size > comp->data_size + src_size) ||\n       (src_size > comp->data_size + src_size)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading data\");\n        return false;\n    }\n\n    comp->data = zrealloc(comp->data, comp->data_size + src_size);\n    if (!comp->data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Adding %llu bytes to compressed buffer\",\n        (long long unsigned) src_size);\n    memcpy(comp->data + comp->data_size, src, src_size);\n    comp->data_size += src_size;\n    comp->data_loc += src_size;\n    return true;\n}\n\nstatic ssize_t comp_end_dchunk(zckCtx *zck, bool use_dict, size_t fd_size) {\n    VALIDATE_READ_INT(zck);\n\n    ssize_t rb = zck->comp.end_dchunk(zck, &(zck->comp), use_dict, fd_size);\n    if(validate_current_chunk(zck) < 1)\n        return -1;\n    zck->comp.data_loc = 0;\n    zck->comp.data_idx = zck->comp.data_idx->next;\n    if(!hash_init(zck, &(zck->check_chunk_hash), &(zck->chunk_hash_type)))\n        return -1;\n    return rb;\n}\n\nstatic ssize_t comp_write(zckCtx *zck, const char *src, const size_t src_size) {\n    VALIDATE_WRITE_INT(zck);\n\n    if(src_size == 0)\n        return 0;\n\n    char *dst = NULL;\n    size_t dst_size = 0;\n    if(zck->comp.compress(zck, &(zck->comp), src, src_size, &dst,\n                          &dst_size, 1) < 0)\n        return -1;\n    zck->comp.dc_data_size += src_size;\n\n    if(zck->no_write == 0 && dst_size > 0 && !write_data(zck, zck->temp_fd, dst, dst_size)) {\n        free(dst);\n        return -1;\n    }\n    if(!index_add_to_chunk(zck, dst, dst_size, src_size)) {\n        free(dst);\n        return -1;\n    }\n    if(zck->has_uncompressed_source && !hash_update(zck, &(zck->work_index_hash_uncomp), src, src_size))\n        return -1;\n    free(dst);\n    return src_size;\n}\n\nbool comp_init(zckCtx *zck) {\n    VALIDATE_BOOL(zck);\n\n    zckComp *comp = &(zck->comp);\n\n    if(zck->comp.started) {\n        set_error(zck, \"Compression already initialized\");\n        return false;\n    }\n    if((zck->comp.dict && zck->comp.dict_size == 0) ||\n       (zck->comp.dict == NULL && zck->comp.dict_size > 0)) {\n        set_error(zck, \"Invalid dictionary configuration\");\n        return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Initializing %s compression\",\n            zck_comp_name_from_type(comp->type));\n    if(!zck->comp.init(zck, &(zck->comp)))\n        return false;\n    if(zck->mode == ZCK_MODE_WRITE) {\n        if(zck->chunk_min_size == 0) {\n            zck->chunk_min_size = CHUNK_DEFAULT_MIN;\n            zck_log(ZCK_LOG_DEBUG, \"Using default minimum chunk size of %llu\",\n                    (long long unsigned) zck->chunk_min_size);\n        }\n        if(zck->chunk_max_size == 0) {\n            zck->chunk_max_size = CHUNK_DEFAULT_MAX;\n            zck_log(ZCK_LOG_DEBUG, \"Using default maximum chunk size of %llu\",\n                    (long long unsigned) zck->chunk_max_size);\n        }\n        if(zck->manual_chunk == 0) {\n            zck_log(ZCK_LOG_DEBUG, \"Using buzhash algorithm for chunking\");\n            zck->buzhash_width = DEFAULT_BUZHASH_WIDTH;\n            zck->buzhash_match_bits = DEFAULT_BUZHASH_BITS;\n            update_buzhash_bits(zck);\n            zck_log(ZCK_LOG_DEBUG, \"Setting average chunk size to %llu\",\n                    (long long unsigned) zck->buzhash_bitmask + 1);\n            zck->chunk_auto_min = (zck->buzhash_bitmask + 1) / 4;\n            if(zck->chunk_auto_min < zck->chunk_min_size)\n                zck->chunk_auto_min = zck->chunk_min_size;\n            zck_log(ZCK_LOG_DEBUG, \"Setting automatic minimum chunk size to %llu\",\n                    (long long unsigned) zck->chunk_auto_min);\n            zck->chunk_auto_max = (zck->buzhash_bitmask + 1) * 4;\n            if(zck->chunk_auto_max > zck->chunk_max_size)\n                zck->chunk_auto_max = zck->chunk_max_size;\n            zck_log(ZCK_LOG_DEBUG, \"Setting automatic maximum chunk size to %llu\",\n                    (long long unsigned) zck->chunk_auto_max);\n        }\n    }\n\n    if(zck->temp_fd || zck->no_write) {\n        if(zck->comp.dict) {\n            char *dst = NULL;\n            size_t dst_size = 0;\n\n            if(zck->comp.compress(zck, comp, zck->comp.dict,\n                                  zck->comp.dict_size, &dst, &dst_size, 0) < 0)\n                return false;\n            zck->comp.dc_data_size = zck->comp.dict_size;\n            if(zck->no_write == 0 && !write_data(zck, zck->temp_fd, dst, dst_size)) {\n                free(dst);\n                return false;\n            }\n            if(!index_add_to_chunk(zck, dst, dst_size,\n                                       zck->comp.dict_size)) {\n                free(dst);\n                return false;\n            }\n            free(dst);\n            dst = NULL;\n            dst_size = 0;\n\n            if(!zck->comp.end_cchunk(zck, comp, &dst, &dst_size, 0))\n                return false;\n            zck->comp.dc_data_size = 0;\n            if(zck->no_write == 0 && !write_data(zck, zck->temp_fd, dst, dst_size)) {\n                free(dst);\n                return false;\n            }\n            if(!index_add_to_chunk(zck, dst, dst_size, 0) ||\n               !index_finish_chunk(zck)) {\n                free(dst);\n                return false;\n            }\n            free(dst);\n        } else {\n            if(!index_finish_chunk(zck))\n                return false;\n        }\n    }\n    zck->comp.started = true;\n    return true;\n}\n\nbool comp_reset(zckCtx *zck) {\n    ALLOCD_BOOL(zck, zck);\n\n    zck->comp.started = 0;\n    if(zck->comp.dc_data) {\n        free(zck->comp.dc_data);\n        zck->comp.dc_data = NULL;\n        zck->comp.dc_data_loc = 0;\n        zck->comp.dc_data_size = 0;\n    }\n    if(zck->comp.close == NULL)\n        return true;\n    return zck->comp.close(zck, &(zck->comp));\n}\n\nbool comp_reset_comp_data(zckCtx *zck) {\n    ALLOCD_BOOL(zck, zck);\n\n    if(zck->comp.data) {\n        free(zck->comp.data);\n        zck->comp.data = NULL;\n        zck->comp.data_size = 0;\n        zck->comp.data_loc = 0;\n        zck->comp.data_idx = NULL;\n    }\n    return true;\n}\n\nbool comp_close(zckCtx *zck) {\n    ALLOCD_BOOL(zck, zck);\n\n    zck_log(ZCK_LOG_DEBUG, \"Closing compression\");\n    comp_reset_comp_data(zck);\n    if(zck->comp.dict)\n        free(zck->comp.dict);\n    zck->comp.dict = NULL;\n    zck->comp.dict_size = 0;\n\n    return comp_reset(zck);\n}\n\nbool comp_ioption(zckCtx *zck, zck_ioption option, ssize_t value) {\n    VALIDATE_BOOL(zck);\n\n    /* Cannot change compression parameters after compression has started */\n    if(zck && zck->comp.started) {\n        set_error(zck,\n                  \"Unable to set compression parameters after initialization\");\n        return false;\n    }\n    if(option == ZCK_COMP_TYPE) {\n        return set_comp_type(zck, value);\n\n    /* Manual chunking */\n    } else if(option == ZCK_MANUAL_CHUNK) {\n        VALIDATE_WRITE_BOOL(zck);\n        if(value != 0) {\n            zck_log(ZCK_LOG_DEBUG, \"Disabling automatic chunking\");\n            zck->manual_chunk = 1;\n        } else {\n            zck_log(ZCK_LOG_DEBUG, \"Enabling automatic chunking\");\n            zck->manual_chunk = 0;\n        }\n        return true;\n\n    /* Minimum chunk size */\n    } else if(option == ZCK_CHUNK_MIN) {\n        VALIDATE_WRITE_BOOL(zck);\n        if(value < 1) {\n            set_error(zck, \"Minimum chunk size must be > 0\");\n            return false;\n        }\n        if(value > zck->chunk_max_size) {\n            set_error(zck, \"Minimum chunk size must be <= maximum chunk size\");\n            return false;\n        }\n        zck->chunk_min_size = value;\n        zck_log(ZCK_LOG_DEBUG, \"Setting minimum chunk size to %lli\", (long long) value);\n        return true;\n\n    /* Maximum chunk size */\n    } else if(option == ZCK_CHUNK_MAX) {\n        VALIDATE_WRITE_BOOL(zck);\n        if(value < 1) {\n            set_error(zck, \"Maximum chunk size must be > 0\");\n            return false;\n        }\n        if(value < zck->chunk_min_size) {\n            set_error(zck, \"Maximum chunk size must be >= minimum chunk size\");\n            return false;\n        }\n        zck->chunk_max_size = value;\n        zck_log(ZCK_LOG_DEBUG, \"Setting maximum chunk size to %lli\", (long long) value);\n        return true;\n\n    } else {\n        if(zck && zck->comp.set_parameter)\n            return zck->comp.set_parameter(zck, &(zck->comp), option, &value);\n\n        set_error(zck, \"Unsupported compression parameter: %i\",\n                  option);\n        return false;\n    }\n    return true;\n}\n\nbool comp_soption(zckCtx *zck, zck_soption option, const void *value,\n                  size_t length) {\n    VALIDATE_BOOL(zck);\n\n    /* Cannot change compression parameters after compression has started */\n    if(zck && zck->comp.started) {\n        set_error(zck,\n                  \"Unable to set compression parameters after initialization\");\n        return false;\n    }\n    if(option == ZCK_COMP_DICT) {\n        zck_log(ZCK_LOG_DEBUG, \"Adding dictionary of size %lli\", (long long) length);\n        zck->comp.dict = (char *)value;\n        zck->comp.dict_size = length;\n    } else {\n        if(zck && zck->comp.set_parameter)\n            return zck->comp.set_parameter(zck, &(zck->comp), option, value);\n\n        set_error(zck, \"Unsupported compression parameter: %i\", option);\n        return false;\n    }\n    return true;\n}\n\nbool comp_add_to_dc(zckCtx *zck, zckComp *comp, const char *src,\n                    size_t src_size) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n    ALLOCD_BOOL(zck, src);\n\n    /* Get rid of any already read data and allocate space for new data */\n    char *temp = zmalloc(comp->dc_data_size - comp->dc_data_loc + src_size);\n    if (!temp) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    if(comp->dc_data_loc != 0)\n        zck_log(ZCK_LOG_DEBUG, \"Freeing %llu bytes from decompressed buffer\",\n                (long long unsigned) comp->dc_data_loc);\n    zck_log(ZCK_LOG_DEBUG, \"Adding %llu bytes to decompressed buffer\",\n            (long long unsigned) src_size);\n    memcpy(temp, comp->dc_data + comp->dc_data_loc,\n           comp->dc_data_size - comp->dc_data_loc);\n    free(comp->dc_data);\n    comp->dc_data_size -= comp->dc_data_loc;\n    comp->dc_data_loc = 0;\n    comp->dc_data = temp;\n\n    /* Copy new uncompressed data into comp */\n    memcpy(comp->dc_data + comp->dc_data_size, src, src_size);\n    comp->dc_data_size += src_size;\n    return true;\n}\n\nssize_t comp_read(zckCtx *zck, char *dst, size_t dst_size, bool use_dict) {\n    VALIDATE_READ_INT(zck);\n\n    if(!zck->comp.started) {\n        set_error(zck, \"Compression hasn't been initialized yet\");\n        return -1;\n    }\n\n    if(dst_size == 0)\n        return 0;\n\n    /* Read dictionary if it exists and hasn't been read yet */\n    if(use_dict && zck->index.first->length > 0 && zck->comp.dict == NULL &&\n       !import_dict(zck))\n        return -1;\n\n    size_t dc = 0;\n    char *src = zmalloc(dst_size - dc);\n    if (!src) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    bool finished_rd = false;\n    bool finished_dc = false;\n    zck_log(ZCK_LOG_DEBUG, \"Trying to read %llu bytes\", (long long unsigned) dst_size);\n    while(dc < dst_size) {\n        /* Get bytes from decompressed buffer */\n        ssize_t rb = comp_read_from_dc(zck, &(zck->comp), dst+dc, dst_size-dc);\n        if(rb < 0)\n            goto read_error;\n        dc += rb;\n        if(dc == dst_size)\n            break;\n        if(rb > 0)\n            continue;\n        if(finished_dc || zck->comp.data_eof)\n            break;\n\n        /* Decompress compressed buffer into decompressed buffer */\n        size_t dc_data_size = zck->comp.dc_data_size;\n        size_t dc_data_loc = zck->comp.dc_data_loc;\n        if(zck->comp.data_size > 0 &&\n           !zck->comp.decompress(zck, &(zck->comp), use_dict))\n            goto read_error;\n\n        /* Check whether we decompressed more data */\n        if(zck->comp.dc_data_size != dc_data_size ||\n           zck->comp.dc_data_loc != dc_data_loc)\n            continue;\n\n        /* End decompression chunk if we're on a chunk boundary */\n        if(zck->comp.data_idx == NULL) {\n            zck->comp.data_idx = zck->index.first;\n            /* Skip first chunk if it's an empty dict */\n            if(zck->comp.data_idx->comp_length == 0)\n                zck->comp.data_idx = zck->comp.data_idx->next;\n            if(!hash_init(zck, &(zck->check_chunk_hash),\n                          &(zck->chunk_hash_type)))\n                goto hash_error;\n            if(zck->comp.data_loc > 0) {\n                if(!zck->has_uncompressed_source) {\n                    if(!hash_update(zck, &(zck->check_full_hash), zck->comp.data,\n                                    zck->comp.data_loc))\n                        goto hash_error;\n                }\n                if(!hash_update(zck, &(zck->check_chunk_hash), zck->comp.data,\n                                zck->comp.data_loc))\n                    goto hash_error;\n            }\n            if(zck->comp.data_idx == NULL) {\n                free(src);\n                return 0;\n            }\n        }\n        if(zck->comp.data_loc == zck->comp.data_idx->comp_length) {\n            if(!comp_end_dchunk(zck, use_dict, zck->comp.data_idx->length)) {\n                free(src);\n                return -1;\n            }\n            if(zck->comp.data_idx == NULL)\n                zck->comp.data_eof = true;\n            continue;\n        }\n\n        /* If we finished reading and we've reached here, we're done\n         * decompressing */\n        if(finished_rd) {\n            finished_dc = true;\n            continue;\n        }\n\n        /* Make sure we don't read beyond current chunk length */\n        size_t rs = dst_size;\n        if(zck->comp.data_loc + rs > zck->comp.data_idx->comp_length)\n            rs = zck->comp.data_idx->comp_length - zck->comp.data_loc;\n\n        /* Decompressed buffer is empty, so read data from file and fill\n         * compressed buffer */\n        rb = read_data(zck, src, rs);\n        if(rb < 0)\n            goto read_error;\n        if(rb < rs) {\n            zck_log(ZCK_LOG_DDEBUG, \"EOF\");\n            finished_rd = true;\n        }\n        if(zck->check_chunk_hash.ctx == NULL)\n            if(!hash_init(zck, &(zck->check_chunk_hash),\n                          &(zck->chunk_hash_type)))\n                goto hash_error;\n        if(!zck->has_uncompressed_source) {\n            if(!hash_update(zck, &(zck->check_full_hash), src, rb))\n                goto read_error;\n        }\n        if(!hash_update(zck, &(zck->check_chunk_hash), src, rb) ||\n           !comp_add_to_data(zck, &(zck->comp), src, rb))\n            goto read_error;\n    }\n    free(src);\n    return dc;\nread_error:\n    free(src);\n    return -1;\nhash_error:\n    free(src);\n    return -2;\n}\n\nconst char ZCK_PUBLIC_API *zck_comp_name_from_type(int comp_type) {\n    if(comp_type > 2) {\n        snprintf(unknown+8, 21, \"%i)\", comp_type);\n        return unknown;\n    }\n    return COMP_NAME[comp_type];\n}\n\nssize_t ZCK_PUBLIC_API zck_write(zckCtx *zck, const char *src, const size_t src_size) {\n    VALIDATE_WRITE_INT(zck);\n\n    if(src_size == 0)\n        return 0;\n\n    if(!zck->comp.started && !comp_init(zck))\n        return -1;\n\n    const char *loc = src;\n    size_t loc_size = src_size;\n    size_t loc_written = 0;\n    uint32_t buzhash_res;\n\n    if(zck->manual_chunk) {\n        while(zck->comp.dc_data_size + loc_size > zck->chunk_max_size) {\n            loc_written = zck->chunk_max_size - zck->comp.dc_data_size;\n            if(comp_write(zck, loc, loc_written) != loc_written)\n                return -1;\n            loc_size -= loc_written;\n            loc += loc_written;\n            zck_log(ZCK_LOG_DDEBUG,\n                    \"Chunk has reached maximum size, forcing a new chunk\");\n            if(zck_end_chunk(zck) < 0)\n                return -1;\n        }\n        if(comp_write(zck, loc, loc_size) != loc_size)\n            return -1;\n        else\n            return src_size;\n    } else {\n        for(size_t i=0; i<loc_size; ) {\n            if (!buzhash_update(&(zck->buzhash), loc+i, zck->buzhash_width, &buzhash_res)) {\n                zck_log(ZCK_LOG_ERROR, \"OOM in buzhash_update\");\n                return -1;\n            }\n\n            if((buzhash_res & zck->buzhash_bitmask) == 0 ||\n               zck->comp.dc_data_size + i >= zck->chunk_auto_max) {\n                if(comp_write(zck, loc, i) != i)\n                    return -1;\n                loc += i;\n                loc_size -= i;\n                i = 0;\n                if(zck->comp.dc_data_size >= zck->chunk_max_size)\n                    zck_log(ZCK_LOG_DDEBUG,\n                            \"Chunk has reached maximum size, forcing a new \"\n                            \"chunk\");\n                else\n                    zck_log(ZCK_LOG_DDEBUG, \"Automatically ending chunk\");\n                if(zck->comp.dc_data_size < zck->chunk_auto_min) {\n                    zck_log(ZCK_LOG_DDEBUG,\n                            \"Chunk too small, refusing to end chunk\");\n                    continue;\n                }\n                if(zck_end_chunk(zck) < 0)\n                    return -1;\n            } else {\n                i++;\n            }\n        }\n        if(loc_size > 0 && comp_write(zck, loc, loc_size) != loc_size)\n            return -1;\n        return src_size;\n    }\n}\n\nssize_t ZCK_PUBLIC_API zck_end_chunk(zckCtx *zck) {\n    VALIDATE_WRITE_INT(zck);\n\n    if(!zck->comp.started && !comp_init(zck))\n        return -1;\n\n    if(zck->comp.dc_data_size < zck->chunk_min_size) {\n        zck_log(ZCK_LOG_DDEBUG, \"Chunk too small, refusing to end chunk\");\n        return zck->comp.dc_data_size;\n    }\n\n    buzhash_reset(&(zck->buzhash));\n    /* No point in compressing empty data */\n    if(zck->comp.dc_data_size == 0)\n        return 0;\n\n    size_t data_size = zck->comp.dc_data_size;\n    char *dst = NULL;\n    size_t dst_size = 0;\n    if(!zck->comp.end_cchunk(zck, &(zck->comp), &dst, &dst_size, 1))\n        return -1;\n    zck->comp.dc_data_size = 0;\n    if(zck->no_write == 0 && dst_size > 0 && !write_data(zck, zck->temp_fd, dst, dst_size)) {\n        free(dst);\n        return -1;\n    }\n    if(!index_add_to_chunk(zck, dst, dst_size, 0)) {\n        free(dst);\n        return -1;\n    }\n    if(!index_finish_chunk(zck)) {\n        free(dst);\n        return -1;\n    }\n    zck_log(ZCK_LOG_DDEBUG, \"Finished chunk size: %llu\", (long long unsigned) data_size);\n    free(dst);\n    return data_size;\n}\n\nssize_t ZCK_PUBLIC_API zck_read(zckCtx *zck, char *dst, size_t dst_size) {\n    VALIDATE_READ_INT(zck);\n    ALLOCD_INT(zck, dst);\n\n    return comp_read(zck, dst, dst_size, 1);\n}\n\nssize_t ZCK_PUBLIC_API zck_get_chunk_comp_data(zckChunk *idx, char *dst,\n                                       size_t dst_size) {\n    zckCtx *zck = NULL;\n    if(idx && idx->zck) {\n        VALIDATE_INT(idx->zck);\n        zck = idx->zck;\n    }\n    ALLOCD_INT(zck, idx);\n    ALLOCD_INT(zck, dst);\n\n    /* Make sure chunk size is valid */\n    if(zck_get_chunk_size(idx) < 0)\n        return -1;\n\n    /* If the chunk is empty, we're done */\n    if(zck_get_chunk_size(idx) == 0)\n        return 0;\n\n    /* Make sure requested chunk has a beginning */\n    if(zck_get_chunk_start(idx) < 0)\n        return -1;\n\n    /* Seek to beginning of requested chunk */\n    if(!seek_data(zck, zck_get_chunk_start(idx), SEEK_SET))\n        return -1;\n\n    /* Return read chunk */\n    return read_data(zck, dst, dst_size);\n}\n\nssize_t ZCK_PUBLIC_API zck_get_chunk_data(zckChunk *idx, char *dst,\n                                  size_t dst_size) {\n    zckCtx *zck = NULL;\n    if(idx && idx->zck) {\n        VALIDATE_INT(idx->zck);\n        zck = idx->zck;\n    }\n    ALLOCD_INT(zck, idx);\n    ALLOCD_INT(zck, dst);\n\n    /* Make sure chunk size is valid */\n    if(zck_get_chunk_size(idx) < 0)\n        return -1;\n    /* If the chunk is empty, we're done */\n    if(zck_get_chunk_size(idx) == 0)\n        return 0;\n    /* Make sure requested chunk has a beginning */\n    if(zck_get_chunk_start(idx) < 0)\n        return -1;\n\n    /* Read dictionary if needed */\n    zckChunk *dict = zck_get_first_chunk(zck);\n    if(dict == NULL)\n        return -1;\n    if(zck_get_chunk_size(dict) > 0 && zck->comp.dict == NULL) {\n        if(zck_get_chunk_start(dict) < 0)\n            return -1;\n        if(!seek_data(zck, zck_get_chunk_start(dict), SEEK_SET))\n            return -1;\n        if(!comp_reset(zck))\n            return -1;\n        if(!comp_init(zck))\n            return -1;\n        if(!import_dict(zck))\n            return -1;\n    }\n\n    /* Seek to beginning of requested chunk */\n    if(!comp_reset_comp_data(zck))\n        return -1;\n    if(!comp_reset(zck))\n        return -1;\n    if(!comp_init(zck))\n        return -1;\n    if(!seek_data(zck, zck_get_chunk_start(idx), SEEK_SET))\n        return -1;\n    zck->comp.data_idx = idx;\n    return comp_read(zck, dst, dst_size, 1);\n}\n", "/*\n * Copyright 2018, 2021 Jonathan Dieter <jdieter@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  1. Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *  2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <zstd.h>\n#include <zck.h>\n\n#include \"zck_private.h\"\n\nstatic bool init(zckCtx *zck, zckComp *comp) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n\n#ifndef OLD_ZSTD\n    size_t retval = 0;\n#endif\n\n    comp->cctx = ZSTD_createCCtx();\n#ifndef OLD_ZSTD\n    retval = ZSTD_CCtx_setParameter(comp->cctx, ZSTD_c_compressionLevel, comp->level);\n    if(ZSTD_isError(retval)) {\n        set_fatal_error(zck, \"Unable to set compression level to %i\", comp->level);\n        return false;\n    }\n    // This seems to be the only way to make the compression deterministic across\n    // architectures with zstd 1.5.0\n    retval = ZSTD_CCtx_setParameter(comp->cctx, ZSTD_c_strategy, ZSTD_btopt);\n    if(ZSTD_isError(retval)) {\n        set_fatal_error(zck, \"Unable to set compression strategy\");\n        return false;\n    }\n#endif //OLD_ZSTD\n    comp->dctx = ZSTD_createDCtx();\n    if(comp->dict && comp->dict_size > 0) {\n#ifdef OLD_ZSTD\n        comp->cdict_ctx = ZSTD_createCDict(comp->dict, comp->dict_size,\n                                           comp->level);\n        if(comp->cdict_ctx == NULL) {\n            set_fatal_error(zck, \"Unable to create zstd compression dict context\");\n            return false;\n        }\n#else\n        retval = ZSTD_CCtx_loadDictionary(comp->cctx, comp->dict, comp->dict_size);\n        if(ZSTD_isError(retval)) {\n            set_fatal_error(zck, \"Unable to add zdict to compression context\");\n            return false;\n        }\n#endif //OLD_ZSTD\n        comp->ddict_ctx = ZSTD_createDDict(comp->dict, comp->dict_size);\n        if(comp->ddict_ctx == NULL) {\n            set_fatal_error(zck,\n                            \"Unable to create zstd decompression dict context\");\n            return false;\n        }\n    }\n    return true;\n}\n\nstatic bool close(zckCtx *zck, zckComp *comp) {\n    ALLOCD_BOOL(zck, zck);\n    ALLOCD_BOOL(zck, comp);\n\n    if(comp->cdict_ctx) {\n        ZSTD_freeCDict(comp->cdict_ctx);\n        comp->cdict_ctx = NULL;\n    }\n    if(comp->ddict_ctx) {\n        ZSTD_freeDDict(comp->ddict_ctx);\n        comp->ddict_ctx = NULL;\n    }\n    if(comp->cctx) {\n        ZSTD_freeCCtx(comp->cctx);\n        comp->cctx = NULL;\n    }\n    if(comp->dctx) {\n        ZSTD_freeDCtx(comp->dctx);\n        comp->dctx = NULL;\n    }\n    return true;\n}\n\n/* The zstd compression format doesn't allow streaming compression with a dict\n * unless you statically link to it.  If we have a dict, we do pseudo-streaming\n * compression where we buffer the data until the chunk ends. */\nstatic ssize_t compress(zckCtx *zck, zckComp *comp, const char *src,\n                        const size_t src_size, char **dst, size_t *dst_size,\n                        bool use_dict) {\n    VALIDATE_INT(zck);\n    ALLOCD_INT(zck, dst);\n    ALLOCD_INT(zck, src);\n    ALLOCD_INT(zck, dst_size);\n    ALLOCD_INT(zck, comp);\n\n    if((comp->dc_data_size > comp->dc_data_size + src_size) ||\n       (src_size > comp->dc_data_size + src_size)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading decompressed data\");\n        return false;\n    }\n\n    comp->dc_data = zrealloc(comp->dc_data, comp->dc_data_size + src_size);\n    if (!comp->dc_data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return -1;\n    }\n\n    memcpy(comp->dc_data + comp->dc_data_size, src, src_size);\n    *dst = NULL;\n    *dst_size = 0;\n    return 0;\n}\n\nstatic bool end_cchunk(zckCtx *zck, zckComp *comp, char **dst, size_t *dst_size,\n                       bool use_dict) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, dst);\n    ALLOCD_BOOL(zck, dst_size);\n    ALLOCD_BOOL(zck, comp);\n\n    size_t max_size = ZSTD_compressBound(comp->dc_data_size);\n    if(ZSTD_isError(max_size)) {\n        set_fatal_error(zck, \"zstd compression error: %s\",\n                        ZSTD_getErrorName(max_size));\n        return false;\n    }\n\n    *dst = zmalloc(max_size);\n    if (!dst) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n#ifdef OLD_ZSTD\n    /* Currently, compression isn't deterministic when using contexts in\n     * zstd 1.3.5, so this works around it */\n    if(use_dict && comp->cdict_ctx) {\n        if(comp->cctx)\n            ZSTD_freeCCtx(comp->cctx);\n        comp->cctx = ZSTD_createCCtx();\n\n        *dst_size = ZSTD_compress_usingDict(comp->cctx, *dst, max_size,\n                                            comp->dc_data, comp->dc_data_size,\n                                            comp->dict, comp->dict_size,\n                                            comp->level);\n    } else {\n        *dst_size = ZSTD_compress(*dst, max_size, comp->dc_data,\n                                  comp->dc_data_size, comp->level);\n    }\n#else\n    if(!use_dict && comp->dict_size > 0) {\n        size_t retval = ZSTD_CCtx_loadDictionary(comp->cctx, NULL, 0);\n        if(ZSTD_isError(retval)) {\n            set_fatal_error(zck, \"Unable to add zdict to compression context\");\n            return false;\n        }\n        *dst_size = ZSTD_compress2(comp->cctx, *dst, max_size, comp->dc_data,\n                                   comp->dc_data_size);\n        retval = ZSTD_CCtx_loadDictionary(comp->cctx, comp->dict, comp->dict_size);\n        if(ZSTD_isError(retval)) {\n            set_fatal_error(zck, \"Unable to add zdict to compression context\");\n            return false;\n        }\n    } else {\n        *dst_size = ZSTD_compress2(comp->cctx, *dst, max_size, comp->dc_data,\n                                   comp->dc_data_size);\n    }\n#endif //OLD_ZSTD\n\n    free(comp->dc_data);\n    comp->dc_data = NULL;\n    comp->dc_data_loc = 0;\n    if(ZSTD_isError(*dst_size)) {\n        set_fatal_error(zck, \"zstd compression error: %s\",\n                        ZSTD_getErrorName(*dst_size));\n        return false;\n    }\n    return true;\n}\n\nstatic bool decompress(zckCtx *zck, zckComp *comp, const bool use_dict) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n\n    return true;\n}\n\nstatic bool end_dchunk(zckCtx *zck, zckComp *comp, const bool use_dict,\n                       const size_t fd_size) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n\n    char *src = comp->data;\n    size_t src_size = comp->data_size;\n    comp->data = NULL;\n    comp->data_size = 0;\n\n    char *dst = zmalloc(fd_size);\n    if (!dst) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    size_t retval = 0;\n    zck_log(ZCK_LOG_DEBUG, \"Decompressing %llu bytes to %llu bytes\",\n            (long long unsigned) src_size,\n            (long long unsigned) fd_size\n    );\n    if(use_dict && comp->ddict_ctx) {\n        zck_log(ZCK_LOG_DEBUG, \"Running decompression using dict\");\n        retval = ZSTD_decompress_usingDDict(comp->dctx, dst, fd_size, src,\n                                            src_size, comp->ddict_ctx);\n    } else {\n        zck_log(ZCK_LOG_DEBUG, \"Running decompression\");\n        retval = ZSTD_decompressDCtx(comp->dctx, dst, fd_size, src, src_size);\n    }\n\n    if(ZSTD_isError(retval)) {\n        set_fatal_error(zck, \"zstd decompression error: %s\",\n                        ZSTD_getErrorName(retval));\n        goto decomp_error_2;\n    }\n    if(!comp_add_to_dc(zck, comp, dst, fd_size))\n        goto decomp_error_2;\n    free(dst);\n    free(src);\n    return true;\ndecomp_error_2:\n    free(dst);\n    free(src);\n    return false;\n}\n\nstatic bool set_parameter(zckCtx *zck, zckComp *comp, int option,\n                          const void *value) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n\n    if(option == ZCK_ZSTD_COMP_LEVEL) {\n        if(*(int*)value >= 0 && *(int*)value <= ZSTD_maxCLevel()) {\n            comp->level = *(int*)value;\n            return true;\n        }\n    }\n    set_error(zck, \"Invalid compression parameter for ZCK_COMP_ZSTD\");\n    return false;\n}\n\nstatic bool set_default_parameters(zckCtx *zck, zckComp *comp) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n\n    /* Set default compression level to 9 */\n    int level=9;\n    return set_parameter(zck, comp, ZCK_ZSTD_COMP_LEVEL, &level);\n}\n\nbool zstd_setup(zckCtx *zck, zckComp *comp) {\n    comp->init = init;\n    comp->set_parameter = set_parameter;\n    comp->compress = compress;\n    comp->end_cchunk = end_cchunk;\n    comp->decompress = decompress;\n    comp->end_dchunk = end_dchunk;\n    comp->close = close;\n    comp->type = ZCK_COMP_ZSTD;\n    return set_default_parameters(zck, comp);\n}\n", "/*\n * Copyright 2018 Jonathan Dieter <jdieter@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  1. Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *  2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdio.h>\n#include <regex.h>\n#include <zck.h>\n\n#include \"zck_private.h\"\n\nstatic char *add_boundary_to_regex(zckCtx *zck, const char *regex,\n                                   const char *boundary) {\n    VALIDATE_PTR(zck);\n\n    if(regex == NULL || boundary == NULL)\n        return NULL;\n    char *regex_b = zmalloc(strlen(regex) + strlen(boundary) + 1);\n    if(!regex_b || snprintf(regex_b, strlen(regex) + strlen(boundary), regex,\n                boundary) != strlen(regex) + strlen(boundary) - 2) {\n        free(regex_b);\n        set_error(zck, \"Unable to build regular expression\");\n        return NULL;\n    }\n    return regex_b;\n}\n\nstatic bool create_regex(zckCtx *zck, regex_t *reg, const char *regex) {\n    VALIDATE_BOOL(zck);\n\n    if(reg == NULL || regex == NULL) {\n        set_error(zck, \"Regular expression not initialized\");\n        return false;\n    }\n    int cflags = REG_ICASE | REG_EXTENDED;\n#if __APPLE__\n    cflags |= REG_ENHANCED;\n#endif\n    if(regcomp(reg, regex, cflags) != 0) {\n        set_error(zck, \"Unable to compile regular expression\");\n        return false;\n    }\n    return true;\n}\n\nstatic bool gen_regex(zckDL *dl) {\n    ALLOCD_BOOL(NULL, dl);\n    VALIDATE_BOOL(dl->zck);\n\n    /* Response should include content-type, but we only need the range, so\n     * wildcard out the content-type */\n    char *next = \"\\r?\\n?--%s\\r\\n.*\" \\\n                 \"content-range: *bytes *([0-9]+) *- *([0-9]+) */[0-9]+\";\n    char *end =  \"\\r\\n--%s--\";\n    char *regex_n = add_boundary_to_regex(dl->zck, next, dl->boundary);\n    if(regex_n == NULL)\n        return false;\n    dl->dl_regex = zmalloc(sizeof(regex_t));\n    if(!dl->dl_regex || !create_regex(dl->zck, dl->dl_regex, regex_n)) {\n        free(regex_n);\n        return false;\n    }\n    free(regex_n);\n    char *regex_e = add_boundary_to_regex(dl->zck, end, dl->boundary);\n    if(regex_e == NULL)\n        return false;\n    dl->end_regex = zmalloc(sizeof(regex_t));\n    if(!dl->end_regex || !create_regex(dl->zck, dl->end_regex, regex_e)) {\n        free(regex_e);\n        return false;\n    }\n    free(regex_e);\n    return true;\n}\n\nvoid reset_mp(zckMP *mp) {\n    if(mp == NULL)\n        return;\n    if(mp->buffer)\n        free(mp->buffer);\n    memset(mp, 0, sizeof(zckMP));\n}\n\nsize_t multipart_extract(zckDL *dl, char *b, size_t l) {\n    ALLOCD_BOOL(NULL, dl);\n    VALIDATE_BOOL(dl->zck);\n\n    if(dl->mp == NULL)\n        return 0;\n\n    zckMP *mp = dl->mp;\n    char *buf = b;\n    bool alloc_buf = false;\n\n    /* Add new data to stored buffer */\n    if(mp->buffer) {\n        if((mp->buffer_len > mp->buffer_len + l) ||\n           (l > mp->buffer_len + l)) {\n            zck_log(ZCK_LOG_ERROR, \"Integer overflow when extracting multipart data\");\n            return 0;\n        }\n\n        buf = zrealloc(mp->buffer, mp->buffer_len + l);\n        if (!buf) {\n            zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n            return 0;\n        }\n        memcpy(buf + mp->buffer_len, b, l);\n        l = mp->buffer_len + l;\n        mp->buffer = NULL;  // No need to free, buf holds realloc'd buffer\n        mp->buffer_len = 0;\n        alloc_buf = true;\n    }\n\n    /* If regex hasn't been created, create it */\n    if(dl->dl_regex == NULL && !gen_regex(dl)) {\n        if(alloc_buf)\n            free(buf);\n        return 0;\n    }\n\n    char *header_start = buf;\n    char *i = buf;\n    while(i) {\n        char *end = buf + l;\n        /* If we're in data writing state, then write data until end of buffer\n         * or end of range, whichever comes first */\n        if(mp->state != 0) {\n            if(i >= end)\n                break;\n            size_t size = end - i;\n            if(mp->length <= size) {\n                size = mp->length;\n                mp->length = 0;\n                mp->state = 0;\n                header_start = i + size;\n            } else {\n                mp->length -= size;\n            }\n            if(dl_write_range(dl, i, size) != size)\n                return 0;\n            i += size;\n            continue;\n        }\n\n        /* If we've reached the end of the buffer without finishing, save it\n         * and leave loop */\n        if(i >= end) {\n            size_t size = buf + l - header_start;\n            if(size > 0) {\n                mp->buffer = zmalloc(size);\n                if (!mp->buffer) {\n                    free(buf);\n                    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n                    return 0;\n                }\n                memcpy(mp->buffer, header_start, size);\n                mp->buffer_len = size;\n            }\n            break;\n        }\n\n        /* Find double newline and replace final \\n with \\0, so it's a zero-\n         * terminated string.  This is the part header.  After finding the end\n         * of the part header (and beginning of the actual data), set j to that\n         * so we can set i to it when we finish getting the part header info */\n        char *j = i;\n        for(; j<end; j++) {\n            if(j + 4 >= end) {\n                i = j+4;\n                break;\n            }\n            if(memcmp(j, \"\\r\\n\\r\\n\", 4) == 0) {\n                j[3] = '\\0';\n                j += 4;\n                break;\n            }\n        }\n        if(i >= end)\n            continue;\n\n        /* Run regex against download range string */\n        regmatch_t match[4] = {{0}};\n        if(regexec(dl->dl_regex, i, 3, match, 0) != 0) {\n            if(regexec(dl->end_regex, i, 3, match, 0) != 0)\n                set_error(dl->zck, \"Unable to find multipart download range\");\n            goto end;\n        }\n\n        /* Get range start from regex */\n        size_t rstart = 0;\n        for(char *c=i + match[1].rm_so; c < i + match[1].rm_eo; c++)\n            rstart = rstart*10 + (size_t)(c[0] - 48);\n\n        /* Get range end from regex */\n        size_t rend = 0;\n        for(char *c=i + match[2].rm_so; c < i + match[2].rm_eo; c++)\n            rend = rend*10 + (size_t)(c[0] - 48);\n\n        i = j;\n        zck_log(ZCK_LOG_DEBUG, \"Download range: %llu-%llu\",\n                (long long unsigned) rstart,\n                (long long unsigned) rend\n        );\n        mp->length = rend-rstart+1;\n        mp->state = 1;\n    }\nend:\n    if(alloc_buf)\n        free(buf);\n    return l;\n}\n\nsize_t multipart_get_boundary(zckDL *dl, char *b, size_t size) {\n    ALLOCD_BOOL(NULL, dl);\n    VALIDATE_BOOL(dl->zck);\n\n    /* Create regex to find boundary */\n    if(dl->hdr_regex == NULL) {\n        char *regex = \"boundary *= *(.*?) *\\r\";\n        dl->hdr_regex = zmalloc(sizeof(regex_t));\n        if(!dl->hdr_regex || !create_regex(dl->zck, dl->hdr_regex, regex))\n            return 0;\n    }\n\n    /* Copy buffer to null-terminated string because POSIX regex requires null-\n     * terminated string */\n    char *buf = zmalloc(size+1);\n    if (!buf) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return 0;\n    }\n    buf[size] = '\\0';\n    memcpy(buf, b, size);\n\n    /* Check whether this header contains the boundary and set it if it does */\n    regmatch_t match[2] = {{0}};\n    if(regexec(dl->hdr_regex, buf, 2, match, 0) == 0) {\n        reset_mp(dl->mp);\n        size_t boundary_length = match[1].rm_eo - match[1].rm_so;\n        char *boundary_start = buf + match[1].rm_so;\n        if (boundary_start[0] == '\\\"' && boundary_length > 2\n            && boundary_start[boundary_length-1] == '\\\"') {\n            /* Remove optional quotes */\n            boundary_start  += 1;\n            boundary_length -= 2;\n        }\n        char *boundary = zmalloc(boundary_length + 1);\n        if (!boundary) {\n            zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n            free(buf);\n            return 0;\n        }\n        memcpy(boundary, boundary_start, boundary_length);\n        zck_log(ZCK_LOG_DEBUG, \"Multipart boundary: %s\", boundary);\n        dl->boundary = boundary;\n    }\n    free(buf);\n    return size;\n}\n", "/*\n * Copyright 2018 Jonathan Dieter <jdieter@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  1. Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *  2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include <zck.h>\n\n#include \"zck_private.h\"\n\nstatic bool check_flags(zckCtx *zck, size_t flags) {\n    zck->has_streams = flags & 1;\n    if(zck->has_streams) {\n        flags -= 1;\n        set_fatal_error(zck,\n                        \"This version of zchunk doesn't support streams\");\n        return false;\n    }\n    zck->has_optional_elems = flags & 2;\n    if(zck->has_optional_elems)\n        flags -= 2;\n    zck->has_uncompressed_source = flags & 4;\n    if(zck->has_uncompressed_source)\n        flags -= 4;\n\n    flags = flags & (SIZE_MAX - 1);\n    if(flags != 0) {\n        set_fatal_error(zck, \"Unknown flags(s) set: %lu\", flags);\n        return false;\n    }\n    return true;\n}\n\nstatic ssize_t get_flags(zckCtx *zck) {\n    size_t flags = 0;\n    if(zck->has_streams)\n        flags |= 1;\n    if(zck->has_optional_elems)\n        flags |= 2;\n    if(zck->has_uncompressed_source)\n        flags |= 4;\n    return flags;\n}\n\nstatic bool read_optional_element(zckCtx *zck, size_t id, size_t data_size,\n                                  char *data) {\n    zck_log(ZCK_LOG_WARNING, \"Unknown optional element id %i set\", id);\n    return true;\n}\n\nstatic bool read_header_from_file(zckCtx *zck) {\n    /* Verify that lead_size and header_length have been set and are legit */\n    if(zck->lead_size == 0 || zck->header_length == 0) {\n        set_error(zck, \"Lead and header sizes are both 0.  Have you run zck_read_lead() yet?\");\n        return false;\n    }\n    if((zck->lead_size > zck->lead_size + zck->header_length) ||\n       (zck->header_length > zck->lead_size + zck->header_length)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading header\");\n        return false;\n    }\n\n    /* Allocate header and store any extra bytes at beginning of header */\n    zck->header = zrealloc(zck->header, zck->lead_size + zck->header_length);\n    if (!zck->header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck->lead_string = zck->header;\n    char *header = zck->header + zck->lead_size;\n    size_t loaded = 0;\n\n    if(zck->header_length < zck->header_size - zck->lead_size) {\n        set_fatal_error(zck, \"Header size is too small for actual data\");\n        return false;\n    }\n    if(zck->lead_size < zck->header_size)\n        loaded = zck->header_size - zck->lead_size;\n\n    /* Read header from file */\n    zck_log(ZCK_LOG_DEBUG, \"Reading the rest of the header: %llu bytes\",\n            (long long unsigned) zck->header_length);\n    if(loaded < zck->header_length) {\n        if(read_data(zck, header + loaded, zck->header_length - loaded) < zck->header_length - loaded) {\n            set_fatal_error(zck, \"Unable to read %llu bytes from the file\", zck->header_length - loaded);\n            return false;\n        }\n        zck->header_size = zck->lead_size + zck->header_length;\n    }\n\n    if(!hash_init(zck, &(zck->check_full_hash), &(zck->hash_type)))\n        return false;\n    /* If we're reading a detached zchunk header, first five bytes will be\n     * different, breaking the header digest, so let's make things simple\n     * by forcing the first five bytes to be static */\n    if(!hash_update(zck, &(zck->check_full_hash), \"\\0ZCK1\", 5))\n        return false;\n    /* Now hash the remaining lead */\n    if(!hash_update(zck, &(zck->check_full_hash), zck->header+5,\n                    zck->hdr_digest_loc-5))\n        return false;\n    /* And the remaining header */\n    if(!hash_update(zck, &(zck->check_full_hash), header, zck->header_length))\n        return false;\n    int ret = validate_header(zck);\n    if(ret < 1) {\n        if(ret == -1)\n            set_fatal_error(zck, \"Header checksum failed verification\");\n        return false;\n    }\n    return true;\n}\n\nstatic bool read_preface(zckCtx *zck) {\n    VALIDATE_READ_BOOL(zck);\n\n    if(zck->header_digest == NULL) {\n        set_error(zck, \"Reading preface before lead is read\");\n        return false;\n    }\n\n    char *header = zck->header + zck->lead_size;\n    size_t length = 0;\n    size_t max_length = zck->header_length;\n\n    /* Read data digest */\n    zck_log(ZCK_LOG_DEBUG, \"Reading data digest\");\n    if(length + zck->hash_type.digest_size > max_length) {\n        set_fatal_error(zck, \"Read past end of header\");\n        return false;\n    }\n    zck->full_hash_digest = zmalloc(zck->hash_type.digest_size);\n    if (!zck->full_hash_digest) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    memcpy(zck->full_hash_digest, header+length, zck->hash_type.digest_size);\n    length += zck->hash_type.digest_size;\n\n    /* Read flags */\n    size_t flags = 0;\n    if(!compint_to_size(zck, &flags, header+length, &length, max_length))\n        return false;\n    if(!check_flags(zck, flags))\n        return false;\n\n    /* Setup for reading compression type */\n    zck_log(ZCK_LOG_DEBUG, \"Reading compression type and index size\");\n    int tmp = 0;\n\n    /* Read and initialize compression type */\n    if(!compint_to_int(zck, &tmp, header+length, &length, max_length))\n        return false;\n    if(!comp_ioption(zck, ZCK_COMP_TYPE, tmp))\n        return false;\n    if(!comp_init(zck))\n        return false;\n\n    /* Read optional flags */\n    if(zck->has_optional_elems) {\n        size_t opt_count = 0;\n        if(!compint_to_size(zck, &opt_count, header+length, &length,\n                            max_length))\n            return false;\n        for(size_t i=0; i<opt_count; i++) {\n            size_t id = 0;\n            size_t data_size = 0;\n            if(!compint_to_size(zck, &id, header+length, &length, max_length))\n                return false;\n            if(!compint_to_size(zck, &data_size, header+length, &length,\n                                max_length))\n                return false;\n            if(!read_optional_element(zck, id, data_size, header+length))\n                return false;\n            length += data_size;\n        }\n    }\n\n    /* Read and initialize index size */\n    if(!compint_to_int(zck, &tmp, header+length, &length, max_length))\n        return false;\n    zck->index_size = tmp;\n\n    zck->preface_string = header;\n    zck->preface_size = length;\n    return true;\n}\n\nstatic bool read_index(zckCtx *zck) {\n    VALIDATE_READ_BOOL(zck);\n\n    if(zck->preface_string == NULL) {\n        set_error(zck, \"Reading index before preface is read\");\n        return false;\n    }\n\n    char *header = NULL;\n    if(zck->lead_size + zck->preface_size + zck->index_size >\n       zck->header_size) {\n        set_fatal_error(zck, \"Read past end of header\");\n        return false;\n    }\n    header = zck->header + zck->lead_size + zck->preface_size;\n    zck_log(ZCK_LOG_DEBUG, \"Reading index at 0x%x\", (unsigned long)(zck->lead_size + zck->preface_size));\n    int max_length = zck->header_size - (zck->lead_size + zck->preface_size);\n    if(!index_read(zck, header, zck->index_size, max_length))\n        return false;\n\n    zck->index_string = header;\n    return true;\n}\n\nstatic bool read_sig(zckCtx *zck) {\n    VALIDATE_READ_BOOL(zck);\n\n    if(zck->index_string == NULL) {\n        set_error(zck, \"Reading signatures before index is read\");\n        return false;\n    }\n\n    char *header = zck->header + zck->lead_size + zck->preface_size +\n                   zck->index_size;\n    size_t max_length = zck->header_size - (zck->lead_size + zck->preface_size +\n                                            zck->index_size);\n    size_t length = 0;\n\n    if(!compint_to_int(zck, &(zck->sigs.count), header, &length, max_length))\n        return false;\n\n    /* We don't actually support signatures yet, so bail if there is one */\n    zck_log(ZCK_LOG_DEBUG, \"Signature count: %i\", zck->sigs.count);\n    if(zck->sigs.count > 0) {\n        set_fatal_error(zck, \"Signatures aren't supported yet\");\n        return false;\n    }\n\n    /* Set data_offset */\n    zck->data_offset = zck->lead_size + zck->header_length;\n\n    if(zck->header_size >\n       zck->lead_size + zck->preface_size + zck->index_size + length)\n        zck_log(ZCK_LOG_WARNING, \"There are unused bytes in the header\");\n\n    zck->sig_size = length;\n    zck->sig_string = header;\n    return true;\n}\n\nstatic bool preface_create(zckCtx *zck) {\n    VALIDATE_WRITE_BOOL(zck);\n\n    int header_malloc = zck->hash_type.digest_size + 4 + 2*MAX_COMP_SIZE;\n\n    char *header = zmalloc(header_malloc);\n    if (!header) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    size_t length = 0;\n\n    /* Write out the full data digest */\n    memcpy(header + length, zck->full_hash_digest, zck->hash_type.digest_size);\n    length += zck->hash_type.digest_size;\n\n    /* Write out flags */\n    compint_from_size(header+length, get_flags(zck), &length);\n\n    /* Write out compression type and index size */\n    if(!compint_from_int(zck, header+length, zck->comp.type, &length)) {\n        free(header);\n        return false;\n    }\n    compint_from_size(header+length, zck->index_size, &length);\n\n    /* Shrink header to actual size */\n    header = zrealloc(header, length);\n    if (!header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n\n    zck->preface_string = header;\n    zck->preface_size = length;\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Generated preface: %llu bytes\",\n        (long long unsigned) zck->preface_size\n    );\n    return true;\n}\n\nstatic bool sig_create(zckCtx *zck) {\n    char *header = zmalloc(MAX_COMP_SIZE);\n    size_t length = 0;\n\n    if (!header) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Calculating %i signatures\", zck->sigs.count);\n\n    /* Write out signature count and signatures */\n    if(!compint_from_int(zck, header+length, zck->sigs.count, &length)) {\n        free(header);\n        return false;\n    }\n    for(int i=0; i<zck->sigs.count; i++) {\n        // TODO: Add signatures\n    }\n    zck->sig_string = header;\n    zck->sig_size = length;\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Generated signatures: %llu bytes\",\n        (long long unsigned) zck->sig_size\n    );\n    return true;\n}\n\nstatic bool lead_create(zckCtx *zck) {\n    int phs = 5 + 2*MAX_COMP_SIZE + zck->hash_type.digest_size;\n    char *header = zmalloc(phs);\n    size_t length = 0;\n    memcpy(header, \"\\0ZCK1\", 5);\n    length += 5;\n\n    if (!header) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    /* Write out full data and header hash type */\n    compint_from_size(header + length, zck->hash_type.type, &length);\n    /* Write out header length */\n    zck->header_length = zck->preface_size + zck->index_size + zck->sig_size;\n    compint_from_size(header + length, zck->header_length, &length);\n    /* Skip header digest; we'll fill it in later */\n    zck->hdr_digest_loc = length;\n    length += zck->hash_type.digest_size;\n\n    header = zrealloc(header, length);\n    if (!header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n\n    zck->lead_string = header;\n    zck->lead_size = length;\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Generated lead: %llu bytes\",\n        (long long unsigned) zck->lead_size\n    );\n    return true;\n}\n\nbool header_create(zckCtx *zck) {\n    VALIDATE_WRITE_BOOL(zck);\n\n    /* Rebuild header without header hash */\n    if(zck->header_digest) {\n        free(zck->header_digest);\n        zck->header_digest = NULL;\n    }\n\n    /* Generate index */\n    if(!index_create(zck))\n        return false;\n\n    /* Generate preface */\n    if(!preface_create(zck))\n        return false;\n\n    /* Rebuild signatures */\n    if(!sig_create(zck))\n        return false;\n\n    /* Rebuild pre-header */\n    if(!lead_create(zck))\n        return false;\n\n    /* Calculate data offset */\n    zck->data_offset = zck->lead_size + zck->preface_size +\n                       zck->index_size + zck->sig_size;\n\n    /* Merge everything into one large string */\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Merging into header: %llu bytes\",\n        (long long unsigned) zck->data_offset\n    );\n    zck->header = zmalloc(zck->data_offset);\n    if (!zck->header) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    size_t offs = 0;\n    memcpy(zck->header + offs, zck->lead_string, zck->lead_size);\n    free(zck->lead_string);\n    zck->lead_string = zck->header + offs;\n    offs += zck->lead_size;\n    memcpy(zck->header + offs, zck->preface_string, zck->preface_size);\n    free(zck->preface_string);\n    zck->preface_string = zck->header + offs;\n    offs += zck->preface_size;\n    memcpy(zck->header + offs, zck->index_string, zck->index_size);\n    free(zck->index_string);\n    zck->index_string = zck->header + offs;\n    offs += zck->index_size;\n    memcpy(zck->header + offs, zck->sig_string, zck->sig_size);\n    free(zck->sig_string);\n    zck->sig_string = zck->header + offs;\n    zck->header_size = zck->data_offset;\n\n    zckHash header_hash = {0};\n\n    /* Calculate hash of header */\n    if(!hash_init(zck, &header_hash, &(zck->hash_type)))\n        return false;\n    zck_log(ZCK_LOG_DEBUG, \"Hashing lead\");\n    /* Hash lead up to header digest */\n    if(!hash_update(zck, &header_hash, zck->lead_string,\n                    zck->hdr_digest_loc))\n        return false;\n    zck_log(ZCK_LOG_DEBUG, \"Hashing the rest\");\n    /* Hash rest of header */\n    if(!hash_update(zck, &header_hash, zck->preface_string, zck->header_length))\n        return false;\n    zck->header_digest = hash_finalize(zck, &header_hash);\n    if(zck->header_digest == NULL)\n        return false;\n\n    /* Write digest to header */\n    memcpy(zck->lead_string+zck->hdr_digest_loc, zck->header_digest,\n           zck->hash_type.digest_size);\n\n    return true;\n}\n\nbool write_header(zckCtx *zck) {\n    VALIDATE_WRITE_BOOL(zck);\n\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Writing header: %llu bytes\",\n        (long long unsigned) zck->lead_size\n    );\n    if(zck->no_write == 0 && !write_data(zck, zck->fd, zck->header, zck->header_size))\n        return false;\n    return true;\n}\n\nstatic bool read_lead(zckCtx *zck) {\n    VALIDATE_READ_BOOL(zck);\n\n    int lead = 5 + 2*MAX_COMP_SIZE;\n\n    char *header = zmalloc(lead);\n    if (!header) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    size_t length = 0;\n\n    if(read_data(zck, header, lead) < lead) {\n        free(header);\n        set_error(zck, \"Short read\");\n        return false;\n    }\n\n    if(memcmp(header, \"\\0ZHR1\", 5) == 0) {\n        zck->header_only = true;\n    } else if(memcmp(header, \"\\0ZCK1\", 5) != 0) {\n        free(header);\n        set_error(zck, \"Invalid lead, perhaps this is not a zck file?\");\n        return false;\n    }\n    length += 5;\n\n    /* Read hash type for header and full digest and initialize check hash */\n    int hash_type = 0;\n    if(!compint_to_int(zck, &hash_type, header+length, &length, lead)) {\n        free(header);\n        return false;\n    }\n    if(zck->prep_hash_type > -1 && zck->prep_hash_type != hash_type) {\n        free(header);\n        set_error(zck, \"Hash type (%i) doesn't match requested hash type \"\n                  \"(%i)\", hash_type, zck->prep_hash_type);\n        return false;\n    }\n    if(!hash_setup(zck, &(zck->hash_type), hash_type)) {\n        free(header);\n        return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Setting header and full digest hash type to %s\",\n            zck_hash_name_from_type(hash_type));\n\n    /* Read header size */\n    size_t header_length = 0;\n    if(!compint_to_size(zck, &header_length, header+length, &length, lead)) {\n        free(header);\n        hash_reset(&(zck->hash_type));\n        return false;\n    }\n    if(header_length > SIZE_MAX) {\n        free(header);\n        set_error(zck, \"Header length of %li invalid\", header_length);\n        hash_reset(&(zck->hash_type));\n        return false;\n    }\n    zck->header_length = header_length;\n\n    /* Set header digest location */\n    zck->hdr_digest_loc = length;\n\n    /* Verify that we're not going to overflow */\n    if(length > length + zck->hash_type.digest_size) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading lead\");\n        return false;\n    }\n\n    /* Read header digest */\n    zck_log(ZCK_LOG_DEBUG, \"Reading header digest\");\n    header = zrealloc(header, length + zck->hash_type.digest_size);\n    if (!header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    size_t to_read = 0;\n    if(lead < length + zck->hash_type.digest_size)\n        to_read = length + zck->hash_type.digest_size - lead;\n    if(read_data(zck, header + lead, to_read) < to_read) {\n        free(header);\n        zck->header_length = 0;\n        zck->hdr_digest_loc = 0;\n        hash_reset(&(zck->hash_type));\n        return false;\n    }\n    lead += to_read;\n\n    if(zck->prep_digest &&\n       memcmp(zck->prep_digest, header + length, zck->hash_type.digest_size) != 0) {\n        zck->header_length = 0;\n        zck->hdr_digest_loc = 0;\n        hash_reset(&(zck->hash_type));\n        set_error(zck,\n                  \"Header digest doesn't match requested header digest\"\n                  \"Expected: %sActual: %s\",\n                  get_digest_string(zck->prep_digest,\n                                    zck->hash_type.digest_size),\n                  get_digest_string(header + length,\n                                    zck->hash_type.digest_size));\n        free(header);\n        return false;\n    }\n    zck->header_digest = zmalloc(zck->hash_type.digest_size);\n    if (!zck->header_digest) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    free(header);\n\t    return false;\n    }\n    memcpy(zck->header_digest, header + length, zck->hash_type.digest_size);\n    length += zck->hash_type.digest_size;\n\n    /* Check whether full header length matches specified header length */\n    if(zck->prep_hdr_size > -1 &&\n       (size_t)zck->prep_hdr_size != zck->header_length + length) {\n        free(header);\n        zck->header_length = 0;\n        zck->hdr_digest_loc = 0;\n        hash_reset(&(zck->hash_type));\n        free(zck->header_digest);\n        zck->header_digest = NULL;\n        set_error(\n            zck,\n            \"Header length (%llu) doesn't match requested header length (%llu)\",\n            (long long unsigned) zck->header_length + length,\n            (long long unsigned) zck->prep_hdr_size\n        );\n        return false;\n    }\n    /* Store pre-header */\n    zck->header = header;\n    zck->header_size = lead;\n    zck->lead_string = header;\n    zck->lead_size = length;\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Parsed lead: %llu bytes\",\n        (long long unsigned) length\n    );\n    return true;\n}\n\nbool ZCK_PUBLIC_API zck_read_lead(zckCtx *zck) {\n    VALIDATE_BOOL(zck);\n\n    return read_lead(zck);\n}\n\nbool ZCK_PUBLIC_API zck_validate_lead(zckCtx *zck) {\n    VALIDATE_BOOL(zck);\n\n    int retval = read_lead(zck);\n    if(!zck_clear_error(zck))\n        return false;\n    free(zck->header);\n    free(zck->header_digest);\n    zck->header = NULL;\n    zck->header_size = 0;\n    zck->header_length = 0;\n    zck->hdr_digest_loc = 0;\n    zck->lead_string = NULL;\n    zck->lead_size = 0;\n    zck->header_digest = NULL;\n    zck->hdr_digest_loc = 0;\n    hash_reset(&(zck->hash_type));\n    if(!seek_data(zck, 0, SEEK_SET))\n        return false;\n    return retval;\n}\n\nbool ZCK_PUBLIC_API zck_read_header(zckCtx *zck) {\n    VALIDATE_READ_BOOL(zck);\n\n    if(!read_header_from_file(zck))\n        return false;\n    if(!read_preface(zck))\n        return false;\n    if(!read_index(zck))\n        return false;\n    if(!read_sig(zck))\n        return false;\n    return true;\n}\n\nssize_t ZCK_PUBLIC_API zck_get_header_length(zckCtx *zck) {\n    VALIDATE_INT(zck);\n    return zck->lead_size + zck->header_length;\n}\n\nssize_t ZCK_PUBLIC_API zck_get_lead_length(zckCtx *zck) {\n    VALIDATE_INT(zck);\n    return zck->lead_size;\n}\n\nssize_t ZCK_PUBLIC_API zck_get_data_length(zckCtx *zck) {\n    VALIDATE_INT(zck);\n    zckChunk *idx = zck->index.first;\n    while(idx->next != NULL)\n        idx = idx->next;\n    return idx->start + idx->comp_length;\n}\n\nssize_t ZCK_PUBLIC_API zck_get_length(zckCtx *zck) {\n    VALIDATE_INT(zck);\n    return zck_get_header_length(zck) + zck_get_data_length(zck);\n}\n\nssize_t ZCK_PUBLIC_API zck_get_flags(zckCtx *zck) {\n    VALIDATE_INT(zck);\n    return get_flags(zck);\n}\n\nbool ZCK_PUBLIC_API zck_is_detached_header(zckCtx *zck) {\n    VALIDATE_BOOL(zck);\n    return zck->header_only;\n}\n"], "filenames": ["src/lib/comp/comp.c", "src/lib/comp/zstd/zstd.c", "src/lib/dl/multipart.c", "src/lib/header.c"], "buggy_code_start_loc": [117, 119, 121, 77], "buggy_code_end_loc": [117, 119, 121, 535], "fixing_code_start_loc": [118, 120, 122, 77], "fixing_code_end_loc": [124, 126, 128, 547], "type": "CWE-190", "message": "zchunk before 1.3.2 has multiple integer overflows via malformed zchunk files to lib/comp/comp.c, lib/comp/zstd/zstd.c, lib/dl/multipart.c, or lib/header.c.", "other": {"cve": {"id": "CVE-2023-46228", "sourceIdentifier": "cve@mitre.org", "published": "2023-10-19T05:15:58.663", "lastModified": "2023-10-25T14:51:06.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "zchunk before 1.3.2 has multiple integer overflows via malformed zchunk files to lib/comp/comp.c, lib/comp/zstd/zstd.c, lib/dl/multipart.c, or lib/header.c."}, {"lang": "es", "value": "zchunk anterior a 1.3.2 tiene m\u00faltiples desbordamientos de enteros a trav\u00e9s de archivos zchunk con formato incorrecto a lib/comp/comp.c, lib/comp/zstd/zstd.c, lib/dl/multipart.c o lib/header.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zchunk:zchunk:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.2", "matchCriteriaId": "98C5913A-9F71-4F81-97DA-6093D1CBBBAA"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=1216268", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/zchunk/zchunk/commit/08aec2b4dfd7f709b6e3d511411ffcc83ed4efbe", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/zchunk/zchunk/compare/1.3.1...1.3.2", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/zchunk/zchunk/commit/08aec2b4dfd7f709b6e3d511411ffcc83ed4efbe"}}