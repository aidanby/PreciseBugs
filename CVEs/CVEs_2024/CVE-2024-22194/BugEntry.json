{"buggy_code": ["#!/usr/bin/env python3\n\n# Portions of this file contributed by NIST are governed by the\n# following statement:\n#\n# This software was developed at the National Institute of Standards\n# and Technology by employees of the Federal Government in the course\n# of their official duties. Pursuant to Title 17 Section 105 of the\n# United States Code, this software is not subject to copyright\n# protection within the United States. NIST assumes no responsibility\n# whatsoever for its use by other parties, and makes no guarantees,\n# expressed or implied, about its quality, reliability, or any other\n# characteristic.\n#\n# We would appreciate acknowledgement if the software is used.\n\n\"\"\"\nThis library is a wrapper for uuid, provided to generate repeatable UUIDs if requested.\n\nThe function local_uuid() should be used in code where a user could be expected to opt in to non-random UUIDs.\n\"\"\"\n\n__version__ = \"0.4.0\"\n\n__all__ = [\"configure\", \"local_uuid\"]\n\nimport logging\nimport os\nimport pathlib\nimport sys\nimport typing\nimport uuid\nimport warnings\n\nDEMO_UUID_BASE: typing.Optional[str] = None\n\nDEMO_UUID_COUNTER: int = 0\n\n_logger = logging.getLogger(pathlib.Path(__file__).name)\n\n\ndef configure() -> None:\n    \"\"\"\n    This function is part of setting up _demo_uuid() to generate non-random UUIDs.  See _demo_uuid() documentation for further setup notes.\n    \"\"\"\n    global DEMO_UUID_BASE\n\n    if os.getenv(\"DEMO_UUID_REQUESTING_NONRANDOM\") == \"NONRANDOM_REQUESTED\":\n        warnings.warn(\n            \"Environment variable DEMO_UUID_REQUESTING_NONRANDOM is deprecated.  See cdo_local_uuid._demo_uuid for usage notes on its replacement, CDO_DEMO_NONRANDOM_UUID_BASE.  Proceeding with random UUIDs.\",\n            FutureWarning,\n        )\n        return\n\n    if os.getenv(\"CASE_DEMO_NONRANDOM_UUID_BASE\") is not None:\n        warnings.warn(\n            \"Environment variable CASE_DEMO_NONRANDOM_UUID_BASE is deprecated.  Its replacement variable is CDO_DEMO_NONRANDOM_UUID_BASE.  Proceeding with random UUIDs.\",\n            FutureWarning,\n        )\n        return\n\n    env_base_dir_name = os.getenv(\"CDO_DEMO_NONRANDOM_UUID_BASE\")\n    if env_base_dir_name is None:\n        return\n\n    base_dir_original_path = pathlib.Path(env_base_dir_name)\n    if not base_dir_original_path.exists():\n        warnings.warn(\n            \"Environment variable CDO_DEMO_NONRANDOM_UUID_BASE is expected to refer to an existing directory.  Proceeding with random UUIDs.\",\n            RuntimeWarning,\n        )\n        return\n    if not base_dir_original_path.is_dir():\n        warnings.warn(\n            \"Environment variable CDO_DEMO_NONRANDOM_UUID_BASE is expected to refer to a directory.  Proceeding with random UUIDs.\",\n            RuntimeWarning,\n        )\n        return\n\n    # Component: An emphasis this is an example.\n    demo_uuid_base_parts = [\"example.org\"]\n\n    # Component: Present working directory, relative to CDO_DEMO_NONRANDOM_UUID_BASE if that environment variable is an ancestor of pwd.\n    base_dir_resolved_path = base_dir_original_path.resolve()\n    srcdir_original_path = pathlib.Path(os.getcwd())\n    srcdir_resolved_path = srcdir_original_path.resolve()\n    # _logger.debug(\"base_dir_resolved_path = %r.\", base_dir_resolved_path)\n    # _logger.debug(\"srcdir_resolved_path = %r.\", srcdir_resolved_path)\n    try:\n        srcdir_relative_path = srcdir_resolved_path.relative_to(base_dir_resolved_path)\n        # _logger.debug(\"srcdir_relative_path = %r.\", srcdir_relative_path)\n        demo_uuid_base_parts.append(str(srcdir_relative_path))\n    except ValueError:\n        # If base_dir is not an ancestor directory of srcdir, default to srcdir.\n        # _logger.debug(\"PWD is not relative to base path.\")\n        demo_uuid_base_parts.append(str(srcdir_resolved_path))\n\n    # Component: Command of argument vector.\n    env_venv_name = os.getenv(\"VIRTUAL_ENV\")\n    if env_venv_name is None:\n        demo_uuid_base_parts.append(sys.argv[0])\n    else:\n        command_original_path = pathlib.Path(sys.argv[0])\n        command_resolved_path = command_original_path.resolve()\n        venv_original_path = pathlib.Path(env_venv_name)\n        venv_resolved_path = venv_original_path.resolve()\n        try:\n            command_relative_path = command_resolved_path.relative_to(\n                venv_resolved_path\n            )\n            # _logger.debug(\"command_relative_path = %r.\", command_relative_path)\n            demo_uuid_base_parts.append(str(command_relative_path))\n        except ValueError:\n            # _logger.debug(\"Command path is not relative to virtual environment path.\")\n            demo_uuid_base_parts.append(str(command_resolved_path))\n\n    if len(sys.argv) > 1:\n        # Component: Arguments of argument vector.\n        demo_uuid_base_parts.extend(sys.argv[1:])\n\n    # _logger.debug(\"demo_uuid_base_parts = %r.\", demo_uuid_base_parts)\n\n    DEMO_UUID_BASE = \"/\".join(demo_uuid_base_parts)\n\n\ndef _demo_uuid() -> str:\n    \"\"\"\n    This function generates a repeatable UUID, drawing on non-varying elements of the environment and process call for entropy.\n\n    This function is not intended to be called outside of this module.  Instead, local_uuid() should be called.\n\n    WARNING: This function was developed for use ONLY for reducing (but not eliminating) version-control edits to identifiers when generating sample data.  It creates UUIDs that are decidedly NOT random, and should remain consistent on repeated calls to the importing script.\n\n    To prevent accidental non-random UUID usage, two setup steps need to be done before calling this function:\n\n    * An environment variable, CDO_DEMO_NONRANDOM_UUID_BASE, must be set to a string provided by the caller.  The variable's required value is the path to some directory.  The variable's recommended value is the equivalent of the Make variable \"top_srcdir\" - that is, the root directory of the containing Git repository, some parent of the current process's current working directory.\n    * The configure() function in this module must be called.\n    \"\"\"\n    global DEMO_UUID_BASE\n    global DEMO_UUID_COUNTER\n\n    if os.getenv(\"CDO_DEMO_NONRANDOM_UUID_BASE\") is None:\n        raise ValueError(\n            \"demo_uuid() called without CDO_DEMO_NONRANDOM_UUID_BASE in environment.\"\n        )\n\n    if DEMO_UUID_BASE is None:\n        raise ValueError(\"demo_uuid() called with DEMO_UUID_BASE unset.\")\n\n    parts = [DEMO_UUID_BASE]\n\n    # Component: Incrementing counter.\n    DEMO_UUID_COUNTER += 1\n    parts.append(str(DEMO_UUID_COUNTER))\n\n    return str(uuid.uuid5(uuid.NAMESPACE_URL, \"/\".join(parts)))\n\n\ndef local_uuid() -> str:\n    \"\"\"\n    Generate either a UUID4, or if requested via environment configuration, a non-random demo UUID.\n\n    >>> from cdo_local_uuid import local_uuid\n    >>> from uuid import UUID\n    >>> lu: str = local_uuid()\n    >>> # To get a UUID object, e.g. to verify syntax, feed local_uuid's string output into the UUID constructor.\n    >>> u = UUID(lu)\n    \"\"\"\n    global DEMO_UUID_BASE\n    if DEMO_UUID_BASE is None:\n        return str(uuid.uuid4())\n    else:\n        return _demo_uuid()\n"], "fixing_code": ["#!/usr/bin/env python3\n\n# Portions of this file contributed by NIST are governed by the\n# following statement:\n#\n# This software was developed at the National Institute of Standards\n# and Technology by employees of the Federal Government in the course\n# of their official duties. Pursuant to Title 17 Section 105 of the\n# United States Code, this software is not subject to copyright\n# protection within the United States. NIST assumes no responsibility\n# whatsoever for its use by other parties, and makes no guarantees,\n# expressed or implied, about its quality, reliability, or any other\n# characteristic.\n#\n# We would appreciate acknowledgement if the software is used.\n\n\"\"\"\nThis library is a wrapper for uuid, provided to generate repeatable UUIDs if requested.\n\nThe function local_uuid() should be used in code where a user could be expected to opt in to non-random UUIDs.\n\"\"\"\n\n__version__ = \"0.4.0\"\n\n__all__ = [\"configure\", \"local_uuid\"]\n\nimport logging\nimport os\nimport pathlib\nimport sys\nimport typing\nimport uuid\nimport warnings\n\nDEMO_UUID_BASE: typing.Optional[str] = None\n\nDEMO_UUID_COUNTER: int = 0\n\n_logger = logging.getLogger(pathlib.Path(__file__).name)\n\n\ndef _is_relative_to(p1: pathlib.Path, p2: pathlib.Path) -> bool:\n    \"\"\"\n    This function provides pathlib.is_relative_to to Pythons before 3.9.  After the End of Life of Python 3.8, this function can be removed.\n    \"\"\"\n    if sys.version_info < (3, 9):\n        try:\n            _ = p1.relative_to(p2)\n            return True\n        except ValueError:\n            return False\n    else:\n        return p1.is_relative_to(p2)\n\n\ndef configure() -> None:\n    \"\"\"\n    This function is part of setting up _demo_uuid() to generate non-random UUIDs.  See _demo_uuid() documentation for further setup notes.\n    \"\"\"\n    global DEMO_UUID_BASE\n\n    # _logger.debug(\"sys.argv = %r.\", sys.argv)\n\n    if os.getenv(\"DEMO_UUID_REQUESTING_NONRANDOM\") == \"NONRANDOM_REQUESTED\":\n        warnings.warn(\n            \"Environment variable DEMO_UUID_REQUESTING_NONRANDOM is deprecated.  See cdo_local_uuid._demo_uuid for usage notes on its replacement, CDO_DEMO_NONRANDOM_UUID_BASE.  Proceeding with random UUIDs.\",\n            FutureWarning,\n        )\n        return\n\n    if os.getenv(\"CASE_DEMO_NONRANDOM_UUID_BASE\") is not None:\n        warnings.warn(\n            \"Environment variable CASE_DEMO_NONRANDOM_UUID_BASE is deprecated.  Its replacement variable is CDO_DEMO_NONRANDOM_UUID_BASE.  Proceeding with random UUIDs.\",\n            FutureWarning,\n        )\n        return\n\n    env_base_dir_name = os.getenv(\"CDO_DEMO_NONRANDOM_UUID_BASE\")\n    if env_base_dir_name is None:\n        return\n\n    base_dir_original_path = pathlib.Path(env_base_dir_name)\n    if not base_dir_original_path.exists():\n        warnings.warn(\n            \"Environment variable CDO_DEMO_NONRANDOM_UUID_BASE is expected to refer to an existing directory.  Proceeding with random UUIDs.\",\n            RuntimeWarning,\n        )\n        return\n    if not base_dir_original_path.is_dir():\n        warnings.warn(\n            \"Environment variable CDO_DEMO_NONRANDOM_UUID_BASE is expected to refer to a directory.  Proceeding with random UUIDs.\",\n            RuntimeWarning,\n        )\n        return\n\n    # Component: An emphasis this is an example.\n    demo_uuid_base_parts = [\"example.org\"]\n\n    # Component: Present working directory, relative to CDO_DEMO_NONRANDOM_UUID_BASE if that environment variable is an ancestor of pwd.\n    base_dir_resolved_path = base_dir_original_path.resolve()\n    srcdir_original_path = pathlib.Path(os.getcwd())\n    srcdir_resolved_path = srcdir_original_path.resolve()\n    # _logger.debug(\"base_dir_resolved_path = %r.\", base_dir_resolved_path)\n    # _logger.debug(\"srcdir_resolved_path = %r.\", srcdir_resolved_path)\n    try:\n        srcdir_relative_path = srcdir_resolved_path.relative_to(base_dir_resolved_path)\n        # _logger.debug(\"srcdir_relative_path = %r.\", srcdir_relative_path)\n        demo_uuid_base_parts.append(str(srcdir_relative_path))\n    except ValueError:\n        # If base_dir is not an ancestor directory of srcdir, default to srcdir.\n        # _logger.debug(\"PWD is not relative to base path.\")\n        demo_uuid_base_parts.append(str(srcdir_resolved_path))\n\n    # Component: Command of argument vector.\n    env_venv_name = os.getenv(\"VIRTUAL_ENV\")\n    if env_venv_name is None:\n        demo_uuid_base_parts.append(sys.argv[0])\n    else:\n        command_original_path = pathlib.Path(sys.argv[0])\n        # _logger.debug(\"command_original_path = %r.\", command_original_path)\n        command_resolved_path = command_original_path.resolve()\n        # _logger.debug(\"command_resolved_path = %r.\", command_resolved_path)\n\n        # The command could be a command embedded in a virtual\n        # environment, or it could be a script external to any virtual\n        # environment.\n        venv_original_path = pathlib.Path(env_venv_name)\n        venv_resolved_path = venv_original_path.resolve()\n        if _is_relative_to(command_resolved_path, venv_resolved_path):\n            command_relative_path = command_resolved_path.relative_to(\n                venv_resolved_path\n            )\n            # _logger.debug(\"command_relative_path = %r.\", command_relative_path)\n            demo_uuid_base_parts.append(str(command_relative_path))\n        else:\n            demo_uuid_base_parts.append(str(command_original_path))\n\n    if len(sys.argv) > 1:\n        # Component: Arguments of argument vector.\n        demo_uuid_base_parts.extend(sys.argv[1:])\n\n    # _logger.debug(\"demo_uuid_base_parts = %r.\", demo_uuid_base_parts)\n\n    DEMO_UUID_BASE = \"/\".join(demo_uuid_base_parts)\n\n\ndef _demo_uuid() -> str:\n    \"\"\"\n    This function generates a repeatable UUID, drawing on non-varying elements of the environment and process call for entropy.\n\n    This function is not intended to be called outside of this module.  Instead, local_uuid() should be called.\n\n    WARNING: This function was developed for use ONLY for reducing (but not eliminating) version-control edits to identifiers when generating sample data.  It creates UUIDs that are decidedly NOT random, and should remain consistent on repeated calls to the importing script.\n\n    To prevent accidental non-random UUID usage, two setup steps need to be done before calling this function:\n\n    * An environment variable, CDO_DEMO_NONRANDOM_UUID_BASE, must be set to a string provided by the caller.  The variable's required value is the path to some directory.  The variable's recommended value is the equivalent of the Make variable \"top_srcdir\" - that is, the root directory of the containing Git repository, some parent of the current process's current working directory.\n    * The configure() function in this module must be called.\n    \"\"\"\n    global DEMO_UUID_BASE\n    global DEMO_UUID_COUNTER\n\n    if os.getenv(\"CDO_DEMO_NONRANDOM_UUID_BASE\") is None:\n        raise ValueError(\n            \"demo_uuid() called without CDO_DEMO_NONRANDOM_UUID_BASE in environment.\"\n        )\n\n    if DEMO_UUID_BASE is None:\n        raise ValueError(\"demo_uuid() called with DEMO_UUID_BASE unset.\")\n\n    parts = [DEMO_UUID_BASE]\n\n    # Component: Incrementing counter.\n    DEMO_UUID_COUNTER += 1\n    parts.append(str(DEMO_UUID_COUNTER))\n\n    return str(uuid.uuid5(uuid.NAMESPACE_URL, \"/\".join(parts)))\n\n\ndef local_uuid() -> str:\n    \"\"\"\n    Generate either a UUID4, or if requested via environment configuration, a non-random demo UUID.\n\n    >>> from cdo_local_uuid import local_uuid\n    >>> from uuid import UUID\n    >>> lu: str = local_uuid()\n    >>> # To get a UUID object, e.g. to verify syntax, feed local_uuid's string output into the UUID constructor.\n    >>> u = UUID(lu)\n    \"\"\"\n    global DEMO_UUID_BASE\n    if DEMO_UUID_BASE is None:\n        return str(uuid.uuid4())\n    else:\n        return _demo_uuid()\n"], "filenames": ["cdo_local_uuid/__init__.py"], "buggy_code_start_loc": [41], "buggy_code_end_loc": [116], "fixing_code_start_loc": [42], "fixing_code_end_loc": [137], "type": "CWE-215", "message": "cdo-local-uuid project provides a specialized UUID-generating function that can, on user request, cause a program to generate deterministic UUIDs. An information leakage vulnerability is present in `cdo-local-uuid` at version `0.4.0`, and in `case-utils` in unpatched versions (matching the pattern `0.x.0`) at and since `0.5.0`, before `0.15.0`. The vulnerability stems from a Python function, `cdo_local_uuid.local_uuid()`, and its original implementation `case_utils.local_uuid()`. ", "other": {"cve": {"id": "CVE-2024-22194", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-11T03:15:10.933", "lastModified": "2024-01-19T19:03:31.737", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cdo-local-uuid project provides a specialized UUID-generating function that can, on user request, cause a program to generate deterministic UUIDs. An information leakage vulnerability is present in `cdo-local-uuid` at version `0.4.0`, and in `case-utils` in unpatched versions (matching the pattern `0.x.0`) at and since `0.5.0`, before `0.15.0`. The vulnerability stems from a Python function, `cdo_local_uuid.local_uuid()`, and its original implementation `case_utils.local_uuid()`. "}, {"lang": "es", "value": "El proyecto cdo-local-uuid proporciona una funci\u00f3n especializada de generaci\u00f3n de UUID que puede, a petici\u00f3n del usuario, hacer que un programa genere UUID deterministas. Una vulnerabilidad de fuga de informaci\u00f3n est\u00e1 presente en `cdo-local-uuid` en la versi\u00f3n `0.4.0`, y en `case-utils` en versiones sin parches (que coinciden con el patr\u00f3n `0.x.0`) en y desde `0.5. 0`, antes de `0.15.0`. La vulnerabilidad surge de una funci\u00f3n de Python, `cdo_local_uuid.local_uuid()`, y su implementaci\u00f3n original `case_utils.local_uuid()`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.8, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.2, "baseSeverity": "LOW"}, "exploitabilityScore": 0.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-215"}, {"lang": "en", "value": "CWE-337"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:case_python_utilities:0.5.0:*:*:*:*:python:*:*", "matchCriteriaId": "4E51AD2E-CCCC-49CB-884C-AE7E5520AE03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:case_python_utilities:0.6.0:*:*:*:*:python:*:*", "matchCriteriaId": "824DCDCC-5ED0-4B22-9B1C-BED8AB8C829D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:case_python_utilities:0.7.0:*:*:*:*:python:*:*", "matchCriteriaId": "29159383-18CE-4726-A720-5A3E51F4FA3E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:case_python_utilities:0.8.0:*:*:*:*:python:*:*", "matchCriteriaId": "7782FE6A-5CF4-4C6F-A090-AD35DCEC83D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:case_python_utilities:0.9.0:*:*:*:*:python:*:*", "matchCriteriaId": "B717C054-3F5E-4C4A-A0F9-BB25BB3257F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:case_python_utilities:0.10.0:*:*:*:*:python:*:*", "matchCriteriaId": "17A5F451-9403-426D-8CED-F2D3071572A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:case_python_utilities:0.11.0:*:*:*:*:python:*:*", "matchCriteriaId": "4CCA01E2-7F94-4036-BC86-86A76C5B6261"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:case_python_utilities:0.12.0:*:*:*:*:python:*:*", "matchCriteriaId": "38A4A141-2D71-4A8E-80A4-9C3B3D25D3C5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:case_python_utilities:0.13.0:*:*:*:*:python:*:*", "matchCriteriaId": "971C2825-0C3F-4A19-8E3F-8254D3246B56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:case_python_utilities:0.14.0:*:*:*:*:python:*:*", "matchCriteriaId": "7AE69ADE-F5F2-420C-BB31-1DD0FA92CCA2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:cdo_local_uuid_utility:0.4.0:*:*:*:*:python:*:*", "matchCriteriaId": "1395DAD2-0463-4F6B-8053-4DCFDE5AD075"}]}]}], "references": [{"url": "https://github.com/Cyber-Domain-Ontology/CDO-Utility-Local-UUID/commit/9e78f7cb1075728d0aafc918514f32a1392cd235", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Cyber-Domain-Ontology/CDO-Utility-Local-UUID/pull/3", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Cyber-Domain-Ontology/CDO-Utility-Local-UUID/pull/4", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Cyber-Domain-Ontology/CDO-Utility-Local-UUID/security/advisories/GHSA-rgrf-6mf5-m882", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}, {"url": "https://github.com/casework/CASE-Utilities-Python/commit/00864cd12de7c50d882dd1a74915d32e939c25f9", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/casework/CASE-Utilities-Python/commit/1cccae8eb3cf94b3a28f6490efa0fbf5c82ebd6b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/casework/CASE-Utilities-Python/commit/5acb929dfb599709d1c8c90d1824dd79e0fd9e10", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/casework/CASE-Utilities-Python/commit/7e02d18383eabbeb9fb4ec97d81438c9980a4790", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/casework/CASE-Utilities-Python/commit/80551f49241c874c7c50e14abe05c5017630dad2", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/casework/CASE-Utilities-Python/commit/939775f956796d0432ecabbf62782ed7ad1007b5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/casework/CASE-Utilities-Python/commit/db428a0745dac4fdd888ced9c52f617695519f9d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/casework/CASE-Utilities-Python/commit/e4ffadc3d56fd303b8f465d727c4a58213d311a1", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/casework/CASE-Utilities-Python/commit/fca7388f09feccd3b9ea88e6df9c7a43a5349452", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/casework/CASE-Utilities-Python/commit/fdc32414eccfcbde6be0fd91b7f491cc0779b02d#diff-e60b9cb8fb480ed27283a030a0898be3475992d78228f4045b12ce5cbb2f0509", "source": "security-advisories@github.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/Cyber-Domain-Ontology/CDO-Utility-Local-UUID/commit/9e78f7cb1075728d0aafc918514f32a1392cd235"}}