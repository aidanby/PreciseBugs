{"buggy_code": ["= BinData Changelog\n\n== Version 2.4.9 (2021-04-22)\n\n* Change example from Fixnum to Integer.  Thanks to Tim Chambers.\n* Now works with frozen string literals.  Requested by Jeremy Evans.\n\n== Version 2.4.8 (2020-07-21)\n\n* Bug fix array self assignment.  Thanks to Spencer McIntyre.\n* Bug fix Stringz max_length.  Thanks to cdelafuente-r7.\n\n== Version 2.4.7 (2020-03-31)\n\n* Fix choice assignment inside arrays.  Reported by Spencer McIntyre.\n\n== Version 2.4.6 (2020-02-27)\n\n* More encoding fixes.  Thanks to Aaron Patterson.\n\n== Version 2.4.5 (2020-02-21)\n\n* Small typo fixes to examples.\n* Fix encoding issue for ruby 2.7.  Thanks to Aaron Patterson.\n* Quieter test output.\n\n== Version 2.4.4 (2018-10-03)\n\n* Display a hint when endian is omitted.  Requested by Tails.\n* Add thread safety to Integer/BitField creation.  Requested by jbpeirce.\n* Ensure windows sockets are unseekable.  Thanks to Brent Cook.\n\n== Version 2.4.3 (2018-03-10)\n\n* Add Uint8Arrays.  Requested by masarakki.\n\n== Version 2.4.2 (2018-01-31)\n\n* Allow boolean values as parameters.  Requested by Patrik Wenger.\n\n== Version 2.4.1 (2017-08-30)\n\n* Fix crash with String :length invoking :rel_offset.  Reported by Claudius\n  Coenen.\n\n== Version 2.4.0 (2017-04-09)\n\n* Reworked internal sanitizing API.\n* Fix bit-based integers inside buffers.  Reported by Claudius Coenen.\n\n== Version 2.3.5 (2017-01-19)\n\n* Enforce Integer#nbits > 0.  Reported by Keenan Tims.\n* Fix auto_call_delayed_io crash.  Reported by Michael Petter.\n\n== Version 2.3.4 (2016-10-17)\n\n* Memoize dynamic methods for primitives.  Thanks to hiroeorz.\n\n== Version 2.3.3 (2016-09-07)\n\n* Fix bug #80.  Thanks to Michael Petter.\n* Add Buffer#raw_num_bytes.\n\n== Version 2.3.2 (2016-09-02)\n\n* IO#num_bytes_remaining now works inside Buffers.\n* Added ability to skip to arbitrary byte patterns.  Requested by Stefan Kolb.\n\n== Version 2.3.1 (2016-06-17)\n\n* Improve list of reserved words.  Thanks to Claudius Coenen.\n* Fix virtual fields to be bit aligned.  Thanks to hopesea.\n\n== Version 2.3.0 (2016-03-25)\n\n* Add :to_abs_offset to Skip.\n* Added backwards seeking via multi pass I/O.  See DelayedIO.\n* Removed #offset, which was deprecated in 2.1.0.\n* Removed :adjust_offset.  See NEWS.rdoc for details.\n\n== Version 2.2.0 (2016-01-30)\n\n* Warn if String has :value but no :read_length.  Requested by Michael\n  Genereux.\n* Prevent running under Ruby 2.1.0p0 due to ruby bug 44525.\n* Added #to_hex convenience method.  Thanks to Gregory Rom\u00e9.\n* Added namespacing via search_prefix. Requested by sumofparts.\n\n== Version 2.1.0 (2014-04-16)\n\n* Performance improvements.\n* Removed deprecated parameters.\n* Code refactored to use Ruby 1.9 features.\n* #eval_parameters can now call private methods.  Requested by Ole Rasmussen.\n* Can now determine state of :onlyif fields.  Requested by Ole Rasmussen.\n* Renamed #offset to #abs_offset for clarity.  #offset is now deprecated.\n* Support :byte_align for fields in structs.  Requested by Igor Yamolov.\n* Added bit fields with dynamic length.  Requested by Jacob Dam.\n* Added \"endian :big_and_little\" option which creates :big and :little\n  versions of the class.  Thanks to Jacob Lukas for the prototype.\n\n== Version 2.0.0 (2014-02-02)\n\n* Ruby 1.8 now has its own separate branch.\n* Struct now uses symbols for field names instead of strings.\n* Added signed bitfields.  Requested by redood.\n* Virtual fields can now have names.\n* Bug fixes.\n\n== Version 1.8.0 (2014-01-06)\n\n* Allow custom types to have endian, not just numerics.\n* Added missing field to TCP example.  Thanks to Bertrand Paquet.\n* Made tests compatible with JRuby.  Thanks to Charles Oliver Nutter.\n* Support travis ci for those that use it.  Thanks to Charles Oliver Nutter.\n* Added Buffer for easier handling of nested streams.\n* Added Virtual field.\n\n== Version 1.6.0 (2013-09-02)\n\n* Added license to .gemspec\n* Moved test suite from RSpec to Minitest.\n* Added :assert and :asserted_value.\n* :check_value has been deprecated. Use :assert instead.\n\n== Version 1.5.1 (2013-08-16)\n\n* Rework build system and include .gemspec.  Requested by Simon Shortman.\n* Fixed bug when Choice#clear didn't clear everything.  Thanks to Simon\n  Shortman for the bug report.\n* Moved BinData::VERSION into its own file.  Thanks to John Van Enk.\n\n== Version 1.5.0 (2013-05-21)\n\n* Moved to github.\n* Updated to Ruby 2.0\n* Arrays now accept BinData object factories for :type (feature request by\n  Matt Dainty).\n* Dynamically generated BinData objects can use the :name parameter to\n  register themselves.\n* Remove functionality that has been deprecated for two years.\n\n== Version 1.4.5 (2012-07-24)\n\n* Added the :pad_front option for padding to occur at the front of a String.\n  (suggested by Eduardo Mour\u00e3o).\n\n== Version 1.4.4 (2012-06-21)\n\n* Fixed bug where user defined boolean primitive wouldn't set its\n  value to false (reported by Frank Roland).\n* Fixed infinite looping bug caused by nested Choices.\n* Renamed String parameter :pad_char to :pad_byte.\n* Updated manual.\n\n== Version 1.4.3 (2011-10-01)\n\n* Exceptions no longer ignored inside lambdas when reading until eof \n  in an array (thanks John Labovitz).\n* Fixed interaction bug between choices and records (reported by\n  Refrigerator Johnny).\n\n== Version 1.4.2 (2011-08-06)\n\n* \\=~ now works for strings.\n\n== Version 1.4.1 (2011-06-20)\n\n* Added :default option for Choices.\n* Added count_bytes_remaining keyword.\n* Increased speed of lazy evaluation.\n\n== Version 1.4.0 (2011-06-14)\n\n* Record#snapshot now returns fields in order.\n* Removed the need to call #register_self in subclasses.\n* Wrapper is now deprecated.  Use subclassing instead.\n* Updated license to mimic changes to the Ruby License.\n* Refactoring to reduce memory usage.\n\n== Version 1.3.1 (2011-01-25)\n\n* Fixed file permissions problem.\n\n== Version 1.3.0 (2011-01-25)\n\n* BinData objects can now assign values when instantiating.\n* Improved support for bit-based alignment.\n* Updated reference manual.\n* Added examples for declaring recursive structures.\n* Objects deriving from BinData::Base should no longer override #initialize.\n* Added BinData::Base(#new, #initialize_instance) to speed up\n  instantiation of multiple objects.\n* Updated specs to rspec-1.3.0\n* BinData::Struct.hide now expects symbols instead of strings.\n\n== Version 1.2.2 (2010-12-14)\n\n* Added Base.bindata_name method.\n* Removed Base#done_read to reduce memory usage and cpu usage.\n* Derived classes should now use do_read et al, instead of _do_read.\n* Added predefinition of record fields to improve speed.\n* Made compatible with ruby 1.9.2.  Thanks to Andrew Watts.\n\n== Version 1.2.1 (2010-07-20)\n\n* Updated specs to be compatible with ruby 1.9.1\n\n== Version 1.2.0 (2010-07-09)\n\n* Deprecated Base#register. Use #register_self or #register_subclasses instead.\n* Syntax improvement.  Array, Structs and Choices can now use blocks to\n  specify fields.\n* Reduced startup time (suggestion courtesy of Mike Ryan).\n\n== Version 1.1.0 (2009-11-24)\n\n* Allow anonymous fields in Records and Primitives.\n* Add the ability to skip over unused data.\n* Allow Records, Primitives and Wrappers to be derived from.\n* Classes for integers are now defined on demand.\n\n== Version 1.0.0 (2009-09-13)\n\n* Is now compatible with Ruby 1.9\n* Added reference manual.\n* Added #rel_offset to Base.\n* Removed support for deprecated functionality.\n\n== Version 0.11.1 (2009-08-28)\n\n* Allow wrapped types to work with struct's :onlyif parameter\n* Use Array#index instead of #find_index for compatibility with Ruby 1.8.6\n  (patch courtesy of Joe Rozner).\n\n== Version 0.11.0 (2009-06-28)\n\n* Sanitizing code was refactored for speed.\n* Arbitrary sized integers and bit fields are now automatically instantiated.\n* Add ability to wrap existing types and override their parameters.\n\n== Version 0.10.0 (2009-04-17)\n\n* Arbitrary byte sized integers are now supported (e.g. 24bit, 808bit).\n* Renamed String :trim_value parameter to :trim_padding.\n* BinData::Array now behaves more like Ruby's Array.\n* Added debug_name\n* Added ability to trace reading\n* Primitives now behave as their value.  Calling #value is no longer needed.\n* Renamed #to_s -> #to_binary_s to avoid confusion with Ruby's #to_s.\n* Added #assign as the generic way to assign values to objects.\n* Added :copy_on_change parameter to Choice.\n* Implement #offset for all objects.\n* Renamed Single -> BasePrimitive.\n* Renamed SingleValue -> Primitive.\n* Renamed MultiValue -> Record.\n* The :onlyif parameter now only applies to fields inside Structs.\n* LazyEvaluator can now supply arguments when invoking methods\n\n== Version 0.9.3 (2008-12-03)\n\n* Arrays can now :read_until => :eof\n* TCPSocket and UDPSocket can now be used as input streams (patch courtesy\n  of Peter Suschlik).\n* Added 128 bit integers.\n* Significant memory usage reduction.\n* Added custom mandatory and default parameters for user defined MultiValues.\n\n== Version 0.9.2 (2008-07-18)\n\n* Added lazy instantiation to allow recursive definitions.\n* Array elements can be appended at any position.\n* Deprecated the :readwrite parameter.\n* Removed feature where Struct fields names could be nil.\n* Reworked sanitizing system.\n\n== Version 0.9.1 (2008-06-15)\n\n* Implemented bit fields.\n* Added :onlyif parameter to Base for specifying optional fields.\n* Fixed IO offset bug with SingleValues.\n\n== Version 0.9.0 (2008-06-02)\n\n* Added :adjust_offset option to automatically seek to a given offset.\n* Modified #read to accept strings as well as IO streams.\n* Choice now accepts sparse arrays and hashes as :choice.\n* Added BinData::Rest to help with debugging.\n* Major internal restructuring - memory usage is much better.\n* Improved documentation.\n\n== Version 0.8.1 (2008-01-14)\n\n* Reduced memory consumption.\n* Increased execution speed.\n* Deprecated BinData::Base.parameters.\n* Fixed spec syntax (thanks to David Goodlad).\n\n== Version 0.8.0 (2007-10-14)\n\n* Add reserved field names to Struct.\n* Prevent warnings about method redefinition.\n* Allow Struct to masquerade as one of its fields.\n* Renamed String param :initial_length to :read_length.\n* BinData::Array now behaves more like the internal Ruby array.\n\n== Version 0.7.0 (2007-08-26)\n\n* Arrays now support terminating conditions as well as fixed length reads.\n* Updated specs to new rspec syntax (0.9).\n* Added scoped resolution of variables in lambdas.\n* Added ability to append elements to arrays.\n\n== Version 0.6.0 (2007-03-28)\n\n* Added 64 bit integers.\n* Added floating point numbers.\n* Added endian keyword to Struct to reduce the amount of typing needed.\n\n== Version 0.5.1 (2007-03-21)\n\n* Updated documentation.\n* Struct now raises an error if a field name shadows an existing method.\n\n== Version 0.5.0 (2007-03-14)\n\n* Initial public release.\n", "require 'thread'\nrequire 'bindata/base_primitive'\n\nmodule BinData\n  # Defines a number of classes that contain a bit based integer.\n  # The integer is defined by endian and number of bits.\n\n  module BitField #:nodoc: all\n    @@mutex = Mutex.new\n\n    class << self\n      def define_class(name, nbits, endian, signed = :unsigned)\n        @@mutex.synchronize do\n          unless BinData.const_defined?(name)\n            new_class = Class.new(BinData::BasePrimitive)\n            BitField.define_methods(new_class, nbits, endian.to_sym, signed.to_sym)\n            RegisteredClasses.register(name, new_class)\n\n            BinData.const_set(name, new_class)\n          end\n        end\n\n        BinData.const_get(name)\n      end\n\n      def define_methods(bit_class, nbits, endian, signed)\n        bit_class.module_eval <<-END\n          #{create_params_code(nbits)}\n\n          def assign(val)\n            #{create_nbits_code(nbits)}\n            #{create_clamp_code(nbits, signed)}\n            super(val)\n          end\n\n          def do_write(io)\n            #{create_nbits_code(nbits)}\n            val = _value\n            #{create_int2uint_code(nbits, signed)}\n            io.writebits(val, #{nbits}, :#{endian})\n          end\n\n          def do_num_bytes\n            #{create_nbits_code(nbits)}\n            #{create_do_num_bytes_code(nbits)}\n          end\n\n          def bit_aligned?\n            true\n          end\n\n          #---------------\n          private\n\n          def read_and_return_value(io)\n            #{create_nbits_code(nbits)}\n            val = io.readbits(#{nbits}, :#{endian})\n            #{create_uint2int_code(nbits, signed)}\n            val\n          end\n\n          def sensible_default\n            0\n          end\n        END\n      end\n\n      def create_params_code(nbits)\n        if nbits == :nbits\n          \"mandatory_parameter :nbits\"\n        else\n          \"\"\n        end\n      end\n\n      def create_nbits_code(nbits)\n        if nbits == :nbits\n          \"nbits = eval_parameter(:nbits)\"\n        else\n          \"\"\n        end\n      end\n\n      def create_do_num_bytes_code(nbits)\n        if nbits == :nbits\n          \"nbits / 8.0\"\n        else\n          nbits / 8.0\n        end\n      end\n\n      def create_clamp_code(nbits, signed)\n        if nbits == :nbits\n          create_dynamic_clamp_code(signed)\n        else\n          create_fixed_clamp_code(nbits, signed)\n        end\n      end\n\n      def create_dynamic_clamp_code(signed)\n        if signed == :signed\n          max = \"max = (1 << (nbits - 1)) - 1\"\n          min = \"min = -(max + 1)\"\n        else\n          max = \"max = (1 << nbits) - 1\"\n          min = \"min = 0\"\n        end\n\n        \"#{max}; #{min}; val = (val < min) ? min : (val > max) ? max : val\"\n      end\n\n      def create_fixed_clamp_code(nbits, signed)\n        if nbits == 1 && signed == :signed\n          raise \"signed bitfield must have more than one bit\"\n        end\n\n        if signed == :signed\n          max = (1 << (nbits - 1)) - 1\n          min = -(max + 1)\n        else\n          min = 0\n          max = (1 << nbits) - 1\n        end\n\n        clamp = \"(val < #{min}) ? #{min} : (val > #{max}) ? #{max} : val\"\n\n        if nbits == 1\n          # allow single bits to be used as booleans\n          clamp = \"(val == true) ? 1 : (not val) ? 0 : #{clamp}\"\n        end\n\n        \"val = #{clamp}\"\n      end\n\n      def create_int2uint_code(nbits, signed)\n        if signed != :signed\n          \"\"\n        elsif nbits == :nbits\n          \"val &= (1 << nbits) - 1\"\n        else\n          \"val &= #{(1 << nbits) - 1}\"\n        end\n      end\n\n      def create_uint2int_code(nbits, signed)\n        if signed != :signed\n          \"\"\n        elsif nbits == :nbits\n          \"val -= (1 << nbits) if (val >= (1 << (nbits - 1)))\"\n        else\n          \"val -= #{1 << nbits} if (val >= #{1 << (nbits - 1)})\"\n        end\n      end\n    end\n  end\n\n  # Create classes for dynamic bitfields\n  {\n    \"Bit\"    => :big,\n    \"BitLe\"  => :little,\n    \"Sbit\"   => [:big, :signed],\n    \"SbitLe\" => [:little, :signed],\n  }.each_pair { |name, args| BitField.define_class(name, :nbits, *args) }\n\n  # Create classes on demand\n  module BitFieldFactory\n    def const_missing(name)\n      mappings = {\n        /^Bit(\\d+)$/    => :big,\n        /^Bit(\\d+)le$/  => :little,\n        /^Sbit(\\d+)$/   => [:big, :signed],\n        /^Sbit(\\d+)le$/ => [:little, :signed]\n      }\n\n      mappings.each_pair do |regex, args|\n        if regex =~ name.to_s\n          nbits = $1.to_i\n          return BitField.define_class(name, nbits, *args)\n        end\n      end\n\n      super(name)\n    end\n  end\n  BinData.extend BitFieldFactory\nend\n", "require 'thread'\nrequire 'bindata/base_primitive'\n\nmodule BinData\n  # Defines a number of classes that contain an integer.  The integer\n  # is defined by endian, signedness and number of bytes.\n\n  module Int #:nodoc: all\n    @@mutex = Mutex.new\n\n    class << self\n      def define_class(name, nbits, endian, signed)\n        @@mutex.synchronize do\n          unless BinData.const_defined?(name)\n            new_class = Class.new(BinData::BasePrimitive)\n            Int.define_methods(new_class, nbits, endian.to_sym, signed.to_sym)\n            RegisteredClasses.register(name, new_class)\n\n            BinData.const_set(name, new_class)\n          end\n        end\n\n        BinData.const_get(name)\n      end\n\n      def define_methods(int_class, nbits, endian, signed)\n        raise \"nbits must be divisible by 8\" unless (nbits % 8).zero?\n\n        int_class.module_eval <<-END\n          def assign(val)\n            #{create_clamp_code(nbits, signed)}\n            super(val)\n          end\n\n          def do_num_bytes\n            #{nbits / 8}\n          end\n\n          #---------------\n          private\n\n          def sensible_default\n            0\n          end\n\n          def value_to_binary_string(val)\n            #{create_clamp_code(nbits, signed)}\n            #{create_to_binary_s_code(nbits, endian, signed)}\n          end\n\n          def read_and_return_value(io)\n            #{create_read_code(nbits, endian, signed)}\n          end\n        END\n      end\n\n      #-------------\n      private\n\n      def create_clamp_code(nbits, signed)\n        if signed == :signed\n          max = (1 << (nbits - 1)) - 1\n          min = -(max + 1)\n        else\n          max = (1 << nbits) - 1\n          min = 0\n        end\n\n        \"val = (val < #{min}) ? #{min} : (val > #{max}) ? #{max} : val\"\n      end\n\n      def create_read_code(nbits, endian, signed)\n        read_str = create_raw_read_code(nbits, endian, signed)\n\n        if need_signed_conversion_code?(nbits, signed)\n          \"val = #{read_str} ; #{create_uint2int_code(nbits)}\"\n        else\n          read_str\n        end\n      end\n\n      def create_raw_read_code(nbits, endian, signed)\n        # special case 8bit integers for speed\n        if nbits == 8\n          \"io.readbytes(1).ord\"\n        else\n          unpack_str   = create_read_unpack_code(nbits, endian, signed)\n          assemble_str = create_read_assemble_code(nbits, endian, signed)\n\n          \"(#{unpack_str} ; #{assemble_str})\"\n        end\n      end\n\n      def create_read_unpack_code(nbits, endian, signed)\n        nbytes         = nbits / 8\n        pack_directive = pack_directive(nbits, endian, signed)\n\n        \"ints = io.readbytes(#{nbytes}).unpack('#{pack_directive}')\"\n      end\n\n      def create_read_assemble_code(nbits, endian, signed)\n        nwords = nbits / bits_per_word(nbits)\n\n        idx = (0...nwords).to_a\n        idx.reverse! if endian == :big\n\n        parts = (0...nwords).collect do |i|\n                  \"(ints.at(#{idx[i]}) << #{bits_per_word(nbits) * i})\"\n                end\n        parts[0] = parts[0].sub(/ << 0\\b/, \"\")  # Remove \" << 0\" for optimisation\n\n        parts.join(\" + \")\n      end\n\n      def create_to_binary_s_code(nbits, endian, signed)\n        # special case 8bit integers for speed\n        return \"(val & 0xff).chr\" if nbits == 8\n\n        pack_directive = pack_directive(nbits, endian, signed)\n        words          = val_as_packed_words(nbits, endian, signed)\n        pack_str       = \"[#{words}].pack('#{pack_directive}')\"\n\n        if need_signed_conversion_code?(nbits, signed)\n          \"#{create_int2uint_code(nbits)} ; #{pack_str}\"\n        else\n          pack_str\n        end\n      end\n\n      def val_as_packed_words(nbits, endian, signed)\n        nwords = nbits / bits_per_word(nbits)\n        mask   = (1 << bits_per_word(nbits)) - 1\n\n        vals = (0...nwords).collect { |i| \"val >> #{bits_per_word(nbits) * i}\" }\n        vals[0] = vals[0].sub(/ >> 0\\b/, \"\")  # Remove \" >> 0\" for optimisation\n        vals.reverse! if (endian == :big)\n\n        vals = vals.collect { |val| \"#{val} & #{mask}\" }  # TODO: \"& mask\" is needed to work around jruby bug. Remove this line when fixed.\n        vals.join(\",\")\n      end\n\n      def create_int2uint_code(nbits)\n        \"val &= #{(1 << nbits) - 1}\"\n      end\n\n      def create_uint2int_code(nbits)\n        \"(val >= #{1 << (nbits - 1)}) ? val - #{1 << nbits} : val\"\n      end\n\n      def bits_per_word(nbits)\n        (nbits % 64).zero? ? 64 :\n        (nbits % 32).zero? ? 32 :\n        (nbits % 16).zero? ? 16 :\n                              8\n      end\n\n      def pack_directive(nbits, endian, signed)\n        nwords = nbits / bits_per_word(nbits)\n\n        directives = { 8 => \"C\", 16 => \"S\", 32 => \"L\", 64 => \"Q\" }\n\n        d = directives[bits_per_word(nbits)]\n        d += ((endian == :big) ? \">\" : \"<\") unless d == \"C\"\n\n        if signed == :signed && directives.key?(nbits)\n          (d * nwords).downcase\n        else\n          d * nwords\n        end\n      end\n\n      def need_signed_conversion_code?(nbits, signed)\n        signed == :signed && ![64, 32, 16].include?(nbits)\n      end\n    end\n  end\n\n\n  # Unsigned 1 byte integer.\n  class Uint8 < BinData::BasePrimitive\n    Int.define_methods(self, 8, :little, :unsigned)\n  end\n\n  # Signed 1 byte integer.\n  class Int8 < BinData::BasePrimitive\n    Int.define_methods(self, 8, :little, :signed)\n  end\n\n  # Create classes on demand\n  module IntFactory\n    def const_missing(name)\n      mappings = {\n        /^Uint(\\d+)be$/ => [:big,    :unsigned],\n        /^Uint(\\d+)le$/ => [:little, :unsigned],\n        /^Int(\\d+)be$/  => [:big,    :signed],\n        /^Int(\\d+)le$/  => [:little, :signed],\n      }\n\n      mappings.each_pair do |regex, args|\n        if regex =~ name.to_s\n          nbits = $1.to_i\n          if nbits > 0 && (nbits % 8).zero?\n            return Int.define_class(name, nbits, *args)\n          end\n        end\n      end\n\n      super\n    end\n  end\n  BinData.extend IntFactory\nend\n"], "fixing_code": ["= BinData Changelog\n\n== Version 2.4.10 (2021-05-18)\n\n* Improve speed of dynamic object creation.  Reported by Charlie Ablett.\n\n== Version 2.4.9 (2021-04-22)\n\n* Change example from Fixnum to Integer.  Thanks to Tim Chambers.\n* Now works with frozen string literals.  Requested by Jeremy Evans.\n\n== Version 2.4.8 (2020-07-21)\n\n* Bug fix array self assignment.  Thanks to Spencer McIntyre.\n* Bug fix Stringz max_length.  Thanks to cdelafuente-r7.\n\n== Version 2.4.7 (2020-03-31)\n\n* Fix choice assignment inside arrays.  Reported by Spencer McIntyre.\n\n== Version 2.4.6 (2020-02-27)\n\n* More encoding fixes.  Thanks to Aaron Patterson.\n\n== Version 2.4.5 (2020-02-21)\n\n* Small typo fixes to examples.\n* Fix encoding issue for ruby 2.7.  Thanks to Aaron Patterson.\n* Quieter test output.\n\n== Version 2.4.4 (2018-10-03)\n\n* Display a hint when endian is omitted.  Requested by Tails.\n* Add thread safety to Integer/BitField creation.  Requested by jbpeirce.\n* Ensure windows sockets are unseekable.  Thanks to Brent Cook.\n\n== Version 2.4.3 (2018-03-10)\n\n* Add Uint8Arrays.  Requested by masarakki.\n\n== Version 2.4.2 (2018-01-31)\n\n* Allow boolean values as parameters.  Requested by Patrik Wenger.\n\n== Version 2.4.1 (2017-08-30)\n\n* Fix crash with String :length invoking :rel_offset.  Reported by Claudius\n  Coenen.\n\n== Version 2.4.0 (2017-04-09)\n\n* Reworked internal sanitizing API.\n* Fix bit-based integers inside buffers.  Reported by Claudius Coenen.\n\n== Version 2.3.5 (2017-01-19)\n\n* Enforce Integer#nbits > 0.  Reported by Keenan Tims.\n* Fix auto_call_delayed_io crash.  Reported by Michael Petter.\n\n== Version 2.3.4 (2016-10-17)\n\n* Memoize dynamic methods for primitives.  Thanks to hiroeorz.\n\n== Version 2.3.3 (2016-09-07)\n\n* Fix bug #80.  Thanks to Michael Petter.\n* Add Buffer#raw_num_bytes.\n\n== Version 2.3.2 (2016-09-02)\n\n* IO#num_bytes_remaining now works inside Buffers.\n* Added ability to skip to arbitrary byte patterns.  Requested by Stefan Kolb.\n\n== Version 2.3.1 (2016-06-17)\n\n* Improve list of reserved words.  Thanks to Claudius Coenen.\n* Fix virtual fields to be bit aligned.  Thanks to hopesea.\n\n== Version 2.3.0 (2016-03-25)\n\n* Add :to_abs_offset to Skip.\n* Added backwards seeking via multi pass I/O.  See DelayedIO.\n* Removed #offset, which was deprecated in 2.1.0.\n* Removed :adjust_offset.  See NEWS.rdoc for details.\n\n== Version 2.2.0 (2016-01-30)\n\n* Warn if String has :value but no :read_length.  Requested by Michael\n  Genereux.\n* Prevent running under Ruby 2.1.0p0 due to ruby bug 44525.\n* Added #to_hex convenience method.  Thanks to Gregory Rom\u00e9.\n* Added namespacing via search_prefix. Requested by sumofparts.\n\n== Version 2.1.0 (2014-04-16)\n\n* Performance improvements.\n* Removed deprecated parameters.\n* Code refactored to use Ruby 1.9 features.\n* #eval_parameters can now call private methods.  Requested by Ole Rasmussen.\n* Can now determine state of :onlyif fields.  Requested by Ole Rasmussen.\n* Renamed #offset to #abs_offset for clarity.  #offset is now deprecated.\n* Support :byte_align for fields in structs.  Requested by Igor Yamolov.\n* Added bit fields with dynamic length.  Requested by Jacob Dam.\n* Added \"endian :big_and_little\" option which creates :big and :little\n  versions of the class.  Thanks to Jacob Lukas for the prototype.\n\n== Version 2.0.0 (2014-02-02)\n\n* Ruby 1.8 now has its own separate branch.\n* Struct now uses symbols for field names instead of strings.\n* Added signed bitfields.  Requested by redood.\n* Virtual fields can now have names.\n* Bug fixes.\n\n== Version 1.8.0 (2014-01-06)\n\n* Allow custom types to have endian, not just numerics.\n* Added missing field to TCP example.  Thanks to Bertrand Paquet.\n* Made tests compatible with JRuby.  Thanks to Charles Oliver Nutter.\n* Support travis ci for those that use it.  Thanks to Charles Oliver Nutter.\n* Added Buffer for easier handling of nested streams.\n* Added Virtual field.\n\n== Version 1.6.0 (2013-09-02)\n\n* Added license to .gemspec\n* Moved test suite from RSpec to Minitest.\n* Added :assert and :asserted_value.\n* :check_value has been deprecated. Use :assert instead.\n\n== Version 1.5.1 (2013-08-16)\n\n* Rework build system and include .gemspec.  Requested by Simon Shortman.\n* Fixed bug when Choice#clear didn't clear everything.  Thanks to Simon\n  Shortman for the bug report.\n* Moved BinData::VERSION into its own file.  Thanks to John Van Enk.\n\n== Version 1.5.0 (2013-05-21)\n\n* Moved to github.\n* Updated to Ruby 2.0\n* Arrays now accept BinData object factories for :type (feature request by\n  Matt Dainty).\n* Dynamically generated BinData objects can use the :name parameter to\n  register themselves.\n* Remove functionality that has been deprecated for two years.\n\n== Version 1.4.5 (2012-07-24)\n\n* Added the :pad_front option for padding to occur at the front of a String.\n  (suggested by Eduardo Mour\u00e3o).\n\n== Version 1.4.4 (2012-06-21)\n\n* Fixed bug where user defined boolean primitive wouldn't set its\n  value to false (reported by Frank Roland).\n* Fixed infinite looping bug caused by nested Choices.\n* Renamed String parameter :pad_char to :pad_byte.\n* Updated manual.\n\n== Version 1.4.3 (2011-10-01)\n\n* Exceptions no longer ignored inside lambdas when reading until eof \n  in an array (thanks John Labovitz).\n* Fixed interaction bug between choices and records (reported by\n  Refrigerator Johnny).\n\n== Version 1.4.2 (2011-08-06)\n\n* \\=~ now works for strings.\n\n== Version 1.4.1 (2011-06-20)\n\n* Added :default option for Choices.\n* Added count_bytes_remaining keyword.\n* Increased speed of lazy evaluation.\n\n== Version 1.4.0 (2011-06-14)\n\n* Record#snapshot now returns fields in order.\n* Removed the need to call #register_self in subclasses.\n* Wrapper is now deprecated.  Use subclassing instead.\n* Updated license to mimic changes to the Ruby License.\n* Refactoring to reduce memory usage.\n\n== Version 1.3.1 (2011-01-25)\n\n* Fixed file permissions problem.\n\n== Version 1.3.0 (2011-01-25)\n\n* BinData objects can now assign values when instantiating.\n* Improved support for bit-based alignment.\n* Updated reference manual.\n* Added examples for declaring recursive structures.\n* Objects deriving from BinData::Base should no longer override #initialize.\n* Added BinData::Base(#new, #initialize_instance) to speed up\n  instantiation of multiple objects.\n* Updated specs to rspec-1.3.0\n* BinData::Struct.hide now expects symbols instead of strings.\n\n== Version 1.2.2 (2010-12-14)\n\n* Added Base.bindata_name method.\n* Removed Base#done_read to reduce memory usage and cpu usage.\n* Derived classes should now use do_read et al, instead of _do_read.\n* Added predefinition of record fields to improve speed.\n* Made compatible with ruby 1.9.2.  Thanks to Andrew Watts.\n\n== Version 1.2.1 (2010-07-20)\n\n* Updated specs to be compatible with ruby 1.9.1\n\n== Version 1.2.0 (2010-07-09)\n\n* Deprecated Base#register. Use #register_self or #register_subclasses instead.\n* Syntax improvement.  Array, Structs and Choices can now use blocks to\n  specify fields.\n* Reduced startup time (suggestion courtesy of Mike Ryan).\n\n== Version 1.1.0 (2009-11-24)\n\n* Allow anonymous fields in Records and Primitives.\n* Add the ability to skip over unused data.\n* Allow Records, Primitives and Wrappers to be derived from.\n* Classes for integers are now defined on demand.\n\n== Version 1.0.0 (2009-09-13)\n\n* Is now compatible with Ruby 1.9\n* Added reference manual.\n* Added #rel_offset to Base.\n* Removed support for deprecated functionality.\n\n== Version 0.11.1 (2009-08-28)\n\n* Allow wrapped types to work with struct's :onlyif parameter\n* Use Array#index instead of #find_index for compatibility with Ruby 1.8.6\n  (patch courtesy of Joe Rozner).\n\n== Version 0.11.0 (2009-06-28)\n\n* Sanitizing code was refactored for speed.\n* Arbitrary sized integers and bit fields are now automatically instantiated.\n* Add ability to wrap existing types and override their parameters.\n\n== Version 0.10.0 (2009-04-17)\n\n* Arbitrary byte sized integers are now supported (e.g. 24bit, 808bit).\n* Renamed String :trim_value parameter to :trim_padding.\n* BinData::Array now behaves more like Ruby's Array.\n* Added debug_name\n* Added ability to trace reading\n* Primitives now behave as their value.  Calling #value is no longer needed.\n* Renamed #to_s -> #to_binary_s to avoid confusion with Ruby's #to_s.\n* Added #assign as the generic way to assign values to objects.\n* Added :copy_on_change parameter to Choice.\n* Implement #offset for all objects.\n* Renamed Single -> BasePrimitive.\n* Renamed SingleValue -> Primitive.\n* Renamed MultiValue -> Record.\n* The :onlyif parameter now only applies to fields inside Structs.\n* LazyEvaluator can now supply arguments when invoking methods\n\n== Version 0.9.3 (2008-12-03)\n\n* Arrays can now :read_until => :eof\n* TCPSocket and UDPSocket can now be used as input streams (patch courtesy\n  of Peter Suschlik).\n* Added 128 bit integers.\n* Significant memory usage reduction.\n* Added custom mandatory and default parameters for user defined MultiValues.\n\n== Version 0.9.2 (2008-07-18)\n\n* Added lazy instantiation to allow recursive definitions.\n* Array elements can be appended at any position.\n* Deprecated the :readwrite parameter.\n* Removed feature where Struct fields names could be nil.\n* Reworked sanitizing system.\n\n== Version 0.9.1 (2008-06-15)\n\n* Implemented bit fields.\n* Added :onlyif parameter to Base for specifying optional fields.\n* Fixed IO offset bug with SingleValues.\n\n== Version 0.9.0 (2008-06-02)\n\n* Added :adjust_offset option to automatically seek to a given offset.\n* Modified #read to accept strings as well as IO streams.\n* Choice now accepts sparse arrays and hashes as :choice.\n* Added BinData::Rest to help with debugging.\n* Major internal restructuring - memory usage is much better.\n* Improved documentation.\n\n== Version 0.8.1 (2008-01-14)\n\n* Reduced memory consumption.\n* Increased execution speed.\n* Deprecated BinData::Base.parameters.\n* Fixed spec syntax (thanks to David Goodlad).\n\n== Version 0.8.0 (2007-10-14)\n\n* Add reserved field names to Struct.\n* Prevent warnings about method redefinition.\n* Allow Struct to masquerade as one of its fields.\n* Renamed String param :initial_length to :read_length.\n* BinData::Array now behaves more like the internal Ruby array.\n\n== Version 0.7.0 (2007-08-26)\n\n* Arrays now support terminating conditions as well as fixed length reads.\n* Updated specs to new rspec syntax (0.9).\n* Added scoped resolution of variables in lambdas.\n* Added ability to append elements to arrays.\n\n== Version 0.6.0 (2007-03-28)\n\n* Added 64 bit integers.\n* Added floating point numbers.\n* Added endian keyword to Struct to reduce the amount of typing needed.\n\n== Version 0.5.1 (2007-03-21)\n\n* Updated documentation.\n* Struct now raises an error if a field name shadows an existing method.\n\n== Version 0.5.0 (2007-03-14)\n\n* Initial public release.\n", "require 'thread'\nrequire 'bindata/base_primitive'\n\nmodule BinData\n  # Defines a number of classes that contain a bit based integer.\n  # The integer is defined by endian and number of bits.\n\n  module BitField #:nodoc: all\n    @@mutex = Mutex.new\n\n    class << self\n      def define_class(name, nbits, endian, signed = :unsigned)\n        @@mutex.synchronize do\n          unless BinData.const_defined?(name)\n            new_class = Class.new(BinData::BasePrimitive)\n            BitField.define_methods(new_class, nbits, endian.to_sym, signed.to_sym)\n            RegisteredClasses.register(name, new_class)\n\n            BinData.const_set(name, new_class)\n          end\n        end\n\n        BinData.const_get(name)\n      end\n\n      def define_methods(bit_class, nbits, endian, signed)\n        bit_class.module_eval <<-END\n          #{create_params_code(nbits)}\n\n          def assign(val)\n            #{create_nbits_code(nbits)}\n            #{create_clamp_code(nbits, signed)}\n            super(val)\n          end\n\n          def do_write(io)\n            #{create_nbits_code(nbits)}\n            val = _value\n            #{create_int2uint_code(nbits, signed)}\n            io.writebits(val, #{nbits}, :#{endian})\n          end\n\n          def do_num_bytes\n            #{create_nbits_code(nbits)}\n            #{create_do_num_bytes_code(nbits)}\n          end\n\n          def bit_aligned?\n            true\n          end\n\n          #---------------\n          private\n\n          def read_and_return_value(io)\n            #{create_nbits_code(nbits)}\n            val = io.readbits(#{nbits}, :#{endian})\n            #{create_uint2int_code(nbits, signed)}\n            val\n          end\n\n          def sensible_default\n            0\n          end\n        END\n      end\n\n      def create_params_code(nbits)\n        if nbits == :nbits\n          \"mandatory_parameter :nbits\"\n        else\n          \"\"\n        end\n      end\n\n      def create_nbits_code(nbits)\n        if nbits == :nbits\n          \"nbits = eval_parameter(:nbits)\"\n        else\n          \"\"\n        end\n      end\n\n      def create_do_num_bytes_code(nbits)\n        if nbits == :nbits\n          \"nbits / 8.0\"\n        else\n          nbits / 8.0\n        end\n      end\n\n      def create_clamp_code(nbits, signed)\n        if nbits == :nbits\n          create_dynamic_clamp_code(signed)\n        else\n          create_fixed_clamp_code(nbits, signed)\n        end\n      end\n\n      def create_dynamic_clamp_code(signed)\n        if signed == :signed\n          max = \"max = (1 << (nbits - 1)) - 1\"\n          min = \"min = -(max + 1)\"\n        else\n          max = \"max = (1 << nbits) - 1\"\n          min = \"min = 0\"\n        end\n\n        \"#{max}; #{min}; val = (val < min) ? min : (val > max) ? max : val\"\n      end\n\n      def create_fixed_clamp_code(nbits, signed)\n        if nbits == 1 && signed == :signed\n          raise \"signed bitfield must have more than one bit\"\n        end\n\n        if signed == :signed\n          max = \"max = (1 << (#{nbits} - 1)) - 1\"\n          min = \"min = -(max + 1)\"\n        else\n          min = \"min = 0\"\n          max = \"max = (1 << #{nbits}) - 1\"\n        end\n\n        clamp = \"(#{max}; #{min}; val = (val < min) ? min : (val > max) ? max : val)\"\n\n        if nbits == 1\n          # allow single bits to be used as booleans\n          clamp = \"(val == true) ? 1 : (not val) ? 0 : #{clamp}\"\n        end\n\n        \"val = #{clamp}\"\n      end\n\n      def create_int2uint_code(nbits, signed)\n        if signed != :signed\n          \"\"\n        elsif nbits == :nbits\n          \"val &= (1 << nbits) - 1\"\n        else\n          \"val &= #{(1 << nbits) - 1}\"\n        end\n      end\n\n      def create_uint2int_code(nbits, signed)\n        if signed != :signed\n          \"\"\n        elsif nbits == :nbits\n          \"val -= (1 << nbits) if (val >= (1 << (nbits - 1)))\"\n        else\n          \"val -= #{1 << nbits} if (val >= #{1 << (nbits - 1)})\"\n        end\n      end\n    end\n  end\n\n  # Create classes for dynamic bitfields\n  {\n    \"Bit\"    => :big,\n    \"BitLe\"  => :little,\n    \"Sbit\"   => [:big, :signed],\n    \"SbitLe\" => [:little, :signed],\n  }.each_pair { |name, args| BitField.define_class(name, :nbits, *args) }\n\n  # Create classes on demand\n  module BitFieldFactory\n    def const_missing(name)\n      mappings = {\n        /^Bit(\\d+)$/    => :big,\n        /^Bit(\\d+)le$/  => :little,\n        /^Sbit(\\d+)$/   => [:big, :signed],\n        /^Sbit(\\d+)le$/ => [:little, :signed]\n      }\n\n      mappings.each_pair do |regex, args|\n        if regex =~ name.to_s\n          nbits = $1.to_i\n          return BitField.define_class(name, nbits, *args)\n        end\n      end\n\n      super(name)\n    end\n  end\n  BinData.extend BitFieldFactory\nend\n", "require 'thread'\nrequire 'bindata/base_primitive'\n\nmodule BinData\n  # Defines a number of classes that contain an integer.  The integer\n  # is defined by endian, signedness and number of bytes.\n\n  module Int #:nodoc: all\n    @@mutex = Mutex.new\n\n    class << self\n      def define_class(name, nbits, endian, signed)\n        @@mutex.synchronize do\n          unless BinData.const_defined?(name)\n            new_class = Class.new(BinData::BasePrimitive)\n            Int.define_methods(new_class, nbits, endian.to_sym, signed.to_sym)\n            RegisteredClasses.register(name, new_class)\n\n            BinData.const_set(name, new_class)\n          end\n        end\n\n        BinData.const_get(name)\n      end\n\n      def define_methods(int_class, nbits, endian, signed)\n        raise \"nbits must be divisible by 8\" unless (nbits % 8).zero?\n\n        int_class.module_eval <<-END\n          def assign(val)\n            #{create_clamp_code(nbits, signed)}\n            super(val)\n          end\n\n          def do_num_bytes\n            #{nbits / 8}\n          end\n\n          #---------------\n          private\n\n          def sensible_default\n            0\n          end\n\n          def value_to_binary_string(val)\n            #{create_clamp_code(nbits, signed)}\n            #{create_to_binary_s_code(nbits, endian, signed)}\n          end\n\n          def read_and_return_value(io)\n            #{create_read_code(nbits, endian, signed)}\n          end\n        END\n      end\n\n      #-------------\n      private\n\n      def create_clamp_code(nbits, signed)\n        if signed == :signed\n          max = \"max = (1 << (#{nbits} - 1)) - 1\"\n          min = \"min = -(max + 1)\"\n        else\n          max = \"max = (1 << #{nbits}) - 1\"\n          min = \"min = 0\"\n        end\n\n        clamp = \"(#{max}; #{min}; val = (val < min) ? min : (val > max) ? max : val)\"\n\n        \"val = #{clamp}\"\n      end\n\n      def create_read_code(nbits, endian, signed)\n        read_str = create_raw_read_code(nbits, endian, signed)\n\n        if need_signed_conversion_code?(nbits, signed)\n          \"val = #{read_str} ; #{create_uint2int_code(nbits)}\"\n        else\n          read_str\n        end\n      end\n\n      def create_raw_read_code(nbits, endian, signed)\n        # special case 8bit integers for speed\n        if nbits == 8\n          \"io.readbytes(1).ord\"\n        else\n          unpack_str   = create_read_unpack_code(nbits, endian, signed)\n          assemble_str = create_read_assemble_code(nbits, endian, signed)\n\n          \"(#{unpack_str} ; #{assemble_str})\"\n        end\n      end\n\n      def create_read_unpack_code(nbits, endian, signed)\n        nbytes         = nbits / 8\n        pack_directive = pack_directive(nbits, endian, signed)\n\n        \"ints = io.readbytes(#{nbytes}).unpack('#{pack_directive}')\"\n      end\n\n      def create_read_assemble_code(nbits, endian, signed)\n        nwords = nbits / bits_per_word(nbits)\n\n        idx = (0...nwords).to_a\n        idx.reverse! if endian == :big\n\n        parts = (0...nwords).collect do |i|\n                  \"(ints.at(#{idx[i]}) << #{bits_per_word(nbits) * i})\"\n                end\n        parts[0] = parts[0].sub(/ << 0\\b/, \"\")  # Remove \" << 0\" for optimisation\n\n        parts.join(\" + \")\n      end\n\n      def create_to_binary_s_code(nbits, endian, signed)\n        # special case 8bit integers for speed\n        return \"(val & 0xff).chr\" if nbits == 8\n\n        pack_directive = pack_directive(nbits, endian, signed)\n        words          = val_as_packed_words(nbits, endian, signed)\n        pack_str       = \"[#{words}].pack('#{pack_directive}')\"\n\n        if need_signed_conversion_code?(nbits, signed)\n          \"#{create_int2uint_code(nbits)} ; #{pack_str}\"\n        else\n          pack_str\n        end\n      end\n\n      def val_as_packed_words(nbits, endian, signed)\n        nwords = nbits / bits_per_word(nbits)\n        mask   = (1 << bits_per_word(nbits)) - 1\n\n        vals = (0...nwords).collect { |i| \"val >> #{bits_per_word(nbits) * i}\" }\n        vals[0] = vals[0].sub(/ >> 0\\b/, \"\")  # Remove \" >> 0\" for optimisation\n        vals.reverse! if (endian == :big)\n\n        vals = vals.collect { |val| \"#{val} & #{mask}\" }  # TODO: \"& mask\" is needed to work around jruby bug. Remove this line when fixed.\n        vals.join(\",\")\n      end\n\n      def create_int2uint_code(nbits)\n        \"val &= #{(1 << nbits) - 1}\"\n      end\n\n      def create_uint2int_code(nbits)\n        \"(val >= #{1 << (nbits - 1)}) ? val - #{1 << nbits} : val\"\n      end\n\n      def bits_per_word(nbits)\n        (nbits % 64).zero? ? 64 :\n        (nbits % 32).zero? ? 32 :\n        (nbits % 16).zero? ? 16 :\n                              8\n      end\n\n      def pack_directive(nbits, endian, signed)\n        nwords = nbits / bits_per_word(nbits)\n\n        directives = { 8 => \"C\", 16 => \"S\", 32 => \"L\", 64 => \"Q\" }\n\n        d = directives[bits_per_word(nbits)]\n        d += ((endian == :big) ? \">\" : \"<\") unless d == \"C\"\n\n        if signed == :signed && directives.key?(nbits)\n          (d * nwords).downcase\n        else\n          d * nwords\n        end\n      end\n\n      def need_signed_conversion_code?(nbits, signed)\n        signed == :signed && ![64, 32, 16].include?(nbits)\n      end\n    end\n  end\n\n\n  # Unsigned 1 byte integer.\n  class Uint8 < BinData::BasePrimitive\n    Int.define_methods(self, 8, :little, :unsigned)\n  end\n\n  # Signed 1 byte integer.\n  class Int8 < BinData::BasePrimitive\n    Int.define_methods(self, 8, :little, :signed)\n  end\n\n  # Create classes on demand\n  module IntFactory\n    def const_missing(name)\n      mappings = {\n        /^Uint(\\d+)be$/ => [:big,    :unsigned],\n        /^Uint(\\d+)le$/ => [:little, :unsigned],\n        /^Int(\\d+)be$/  => [:big,    :signed],\n        /^Int(\\d+)le$/  => [:little, :signed],\n      }\n\n      mappings.each_pair do |regex, args|\n        if regex =~ name.to_s\n          nbits = $1.to_i\n          if nbits > 0 && (nbits % 8).zero?\n            return Int.define_class(name, nbits, *args)\n          end\n        end\n      end\n\n      super\n    end\n  end\n  BinData.extend IntFactory\nend\n"], "filenames": ["ChangeLog.rdoc", "lib/bindata/bits.rb", "lib/bindata/int.rb"], "buggy_code_start_loc": [1, 118, 62], "buggy_code_end_loc": [1, 126, 70], "fixing_code_start_loc": [2, 118, 62], "fixing_code_end_loc": [6, 126, 72], "type": "NVD-CWE-Other", "message": "In the bindata RubyGem before version 2.4.10 there is a potential denial-of-service vulnerability. In affected versions it is very slow for certain classes in BinData to be created. For example BinData::Bit100000, BinData::Bit100001, BinData::Bit100002, BinData::Bit<N>. In combination with <user_input>.constantize there is a potential for a CPU-based DoS. In version 2.4.10 bindata improved the creation time of Bits and Integers.", "other": {"cve": {"id": "CVE-2021-32823", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-24T00:15:08.103", "lastModified": "2022-10-25T14:20:46.857", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the bindata RubyGem before version 2.4.10 there is a potential denial-of-service vulnerability. In affected versions it is very slow for certain classes in BinData to be created. For example BinData::Bit100000, BinData::Bit100001, BinData::Bit100002, BinData::Bit<N>. In combination with <user_input>.constantize there is a potential for a CPU-based DoS. In version 2.4.10 bindata improved the creation time of Bits and Integers."}, {"lang": "es", "value": "En bindata RubyGem versiones anteriores a 2.4.10, presenta una vulnerabilidad potencial de denegaci\u00f3n de servicio.&#xa0;En las versiones afectadas, es muy lento crear determinadas clases en BinData.&#xa0;Por ejemplo,BinData::Bit100000, BinData::Bit100001, BinData::Bit100002, BinData::Bit(N).&#xa0;En combinaci\u00f3n con (user_input) .constantize, se presenta la posibilidad de un DoS basado en CPU.&#xa0;En la versi\u00f3n 2.4.10 bindata mejor\u00f3 el tiempo de creaci\u00f3n de Bits e Integers"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bindata_project:bindata:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "2.4.10", "matchCriteriaId": "F3FDB12D-A7D5-4E28-9515-94054E69934D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gitlab:gitlab:*:*:*:*:community:*:*:*", "versionStartIncluding": "12.0", "matchCriteriaId": "3F06CCC0-70A9-4F4B-B2A8-4A6824B2848F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitlab:gitlab:*:*:*:*:enterprise:*:*:*", "versionStartIncluding": "12.0", "matchCriteriaId": "156A2D48-6FFE-407D-9536-035358C33813"}]}]}], "references": [{"url": "https://about.gitlab.com/releases/2021/06/01/security-release-gitlab-13-12-2-released/#update-bindata-dependency", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/dmendel/bindata/blob/v2.4.10/ChangeLog.rdoc#version-2410-2021-05-18-", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/dmendel/bindata/commit/d99f050b88337559be2cb35906c1f8da49531323", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rubysec/ruby-advisory-db/issues/476", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://rubygems.org/gems/bindata", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dmendel/bindata/commit/d99f050b88337559be2cb35906c1f8da49531323"}}