{"buggy_code": ["#include <config.h>\n\n#define DEFINE_GLOBALS\n#include \"messages.h\"\n#include \"ftpd_p.h\"\n#include \"dynamic.h\"\n#include \"ftpwho-update.h\"\n#include \"ftpwho-read.h\"\n#include \"globals.h\"\n#include \"caps.h\"\n#include \"alt_arc4random.h\"\n#if defined(WITH_UPLOAD_SCRIPT)\n# include \"upload-pipe.h\"\n#endif\n#ifdef WITH_ALTLOG\n# include \"altlog.h\"\n#endif\n#ifdef QUOTAS\n# include \"quotas.h\"\n#endif\n#ifdef WITH_DIRALIASES\n# include \"diraliases.h\"\n#endif\n#include \"ftpd.h\"\n#include \"bsd-glob.h\"\n#include \"getloadavg.h\"\n#include \"safe_rw.h\"\n#include \"utils.h\"\n#ifndef MINIMAL\n# include \"simpleconf.h\"\n# include \"simpleconf_ftpd.h\"\n#endif\n#ifndef WITHOUT_PRIVSEP\n# include \"privsep.h\"\n#endif\n#ifdef WITH_TLS\n# include \"tls.h\"\n# include \"tls_extcert.h\"\n#endif\n#ifdef WITH_BONJOUR\n# include \"bonjour.h\"\n#endif\n#ifdef HAVE_LIBSODIUM\n# include <sodium.h>\n#endif\n#ifdef WITH_DMALLOC\n# include <dmalloc.h>\n#endif\n\nvoid disablesignals(void)\n{\n    sigset_t sigs;\n\n    sigfillset(&sigs);\n    if (sigprocmask(SIG_BLOCK, &sigs, &old_sigmask) < 0) {\n        _EXIT(EXIT_FAILURE);\n    }\n}\n\nstatic void enablesignals(void)\n{\n    if (sigprocmask(SIG_SETMASK, &old_sigmask, NULL) < 0) {\n        _EXIT(EXIT_FAILURE);\n    }\n}\n\nvoid usleep2(const unsigned long microsec)\n{\n    disablesignals();\n    usleep(microsec);\n    enablesignals();\n}\n\n#ifdef WITH_TLS\nssize_t secure_safe_write(void * const tls_fd, const void *buf_, size_t count)\n{\n    ssize_t written;\n    const char *buf = (const char *) buf_;\n\n    while (count > (size_t) 0U) {\n        for (;;) {\n            if ((written = SSL_write(tls_fd, buf, count)) <= (ssize_t) 0) {\n                if (SSL_get_error(tls_fd, written) != SSL_ERROR_NONE) {\n                    return (ssize_t) -1;\n                }\n                continue;\n            }\n            break;\n        }\n        buf += written;\n        count -= written;\n    }\n    return (ssize_t) (buf - (const char *) buf_);\n}\n#endif\n\nstatic ssize_t safe_nonblock_write(const int fd, void * const tls_fd,\n                                   const void *buf_, size_t count)\n{\n    ssize_t written;\n    const char *buf = (const char *) buf_;\n    struct pollfd pfd;\n\n    while (count > (size_t) 0U) {\n        for (;;) {\n            if (tls_fd == NULL) {\n                written = write(fd, buf, count);\n            } else {\n#ifdef WITH_TLS\n                written = SSL_write(tls_fd, buf, count);\n                if (SSL_get_error(tls_fd, written) == SSL_ERROR_WANT_WRITE) {\n                    errno = EAGAIN;\n                }\n#else\n                abort();\n#endif\n            }\n            if (written > (ssize_t) 0) {\n                break;\n            }\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                pfd.fd = fd;\n                pfd.events = POLLOUT | POLLERR | POLLHUP;\n                pfd.revents = 0;\n                if (poll(&pfd, 1U, idletime * 1000UL) <= 0 ||\n                    (pfd.revents & (POLLERR | POLLHUP)) != 0 ||\n                    (pfd.revents & POLLOUT) == 0) {\n                    errno = EPIPE;\n                    return -1;\n                }\n            } else if (errno != EINTR) {\n                return -1;\n            }\n        }\n        buf += written;\n        count -= written;\n    }\n    return 0;\n}\n\nstatic void overlapcpy(char *d, const char *s)\n{\n    while (*s != 0) {\n        *d++ = *s++;\n    }\n    *d = 0;\n}\n\nstatic void safe_fd_set(const int fd, fd_set * const fds)\n{\n    if (fd == -1) {\n        return;\n    }\n    FD_SET(fd, fds);\n}\n\nstatic int safe_fd_isset(const int fd, const fd_set * const fds)\n{\n    if (fd == -1) {\n        return 0;\n    }\n    return FD_ISSET(fd, fds);\n}\n\nstatic int init_tz(void)\n{\n    char stbuf[10];\n    struct tm *tm;\n    time_t now = time(NULL);\n\n#ifdef HAVE_TZSET\n    tzset();\n#endif\n#ifdef HAVE_PUTENV\n    if ((tm = localtime(&now)) != NULL &&\n        strftime(stbuf, sizeof stbuf, \"%z\", tm) == (size_t) 5U) {\n        snprintf(default_tz_for_putenv, sizeof default_tz_for_putenv,\n                 \"TZ=UTC%c%c%c:%c%c\", (*stbuf == '-' ? '+' : '-'),\n                 stbuf[1], stbuf[2], stbuf[3], stbuf[4]);\n    }\n    putenv(default_tz_for_putenv);\n#endif\n    (void) localtime(&now);\n    (void) gmtime(&now);\n\n    return 0;\n}\n\nvoid simplify(char *subdir)\n{\n    char *a;\n\n    if (subdir == NULL || *subdir == 0) {\n        return;\n    }\n    while ((a = strstr(subdir, \"//\")) != NULL) {\n        overlapcpy(a, a + 1);\n    }\n    while ((a = strstr(subdir, \"/./\")) != NULL) {\n        overlapcpy(a, a + 2);\n    }\n    while (strncmp(subdir, \"../\", 3) == 0) {\n        subdir += 3;\n    }\n    a = strstr(subdir, \"/../\");\n    if (a != NULL) {\n        if (a == subdir) {\n            while (strncmp(subdir, \"/../\", 4) == 0) {\n                overlapcpy(subdir, subdir + 3);\n            }\n            a = strstr(subdir, \"/../\");\n        }\n        while (a != NULL) {\n            char *nextcomponent = a + 4;\n            if (a != subdir && *a == '/') {\n                a--;\n            }\n            while (a != subdir && *a != '/') {\n                a--;\n            }\n            if (*a == '/') {\n                a++;\n            }\n            overlapcpy(a, nextcomponent);\n            a = strstr(subdir, \"/../\");\n        }\n    }\n    a = subdir;\n    if (*a == '.') {\n        a++;\n        if (*a == 0) {\n            return;\n        }\n        if (*a == '/') {\n            while (*a == '/') {\n                a++;\n            }\n            overlapcpy(subdir, a);\n        }\n    }\n    if (*a == 0) {\n        return;\n    }\n    a = subdir + strlen(subdir) - (size_t) 1U;\n    if (*a != '.' || a == subdir) {\n        return;\n    }\n    a--;\n    if (*a == '/') {\n        a[1] = 0;\n        return;\n    }\n    if (*a != '.' || a == subdir) {\n        return;\n    }\n    a--;\n    if (*a != '/') {\n        return;\n    }\n    *a = 0;\n    if ((a = strrchr(subdir, '/')) == NULL) {\n        *subdir = '/';\n        subdir[1] = 0;\n        return;\n    }\n    a[1] = 0;\n}\n\nint checkprintable(const char *s)\n{\n    int ret = 0;\n    unsigned char c;\n\n    while ((c = (unsigned char) *s) != 0U) {\n        if (ISCTRLCODE(c)) {\n            ret--;\n            break;\n        }\n        s++;\n    }\n\n    return ret;\n}\n\nchar *skip_telnet_controls(const char *str)\n{\n    if (str == NULL) {\n        return NULL;\n    }\n    while (*str != 0 && (unsigned char) *str >= 240U) {\n        str++;\n    }\n    return (char *) str;\n}\n\nvoid _EXIT(const int status)\n{\n    delete_atomic_file();\n#ifdef FTPWHO\n    ftpwho_exit();\n#endif\n    _exit(status);\n}\n\nstatic char replybuf[MAX_SERVER_REPLY_LEN * 4U];\nstatic char *replybuf_pos = replybuf;\nstatic size_t replybuf_left;\n\nstatic void client_init_reply_buf(void)\n{\n    replybuf_pos = replybuf;\n    replybuf_left = sizeof replybuf - 1U;\n}\n\nvoid client_fflush(void)\n{\n    if (replybuf_pos == replybuf) {\n        return;\n    }\n    safe_write(clientfd, replybuf, (size_t) (replybuf_pos - replybuf), -1);\n    client_init_reply_buf();\n}\n\nvoid client_printf(const char * const format, ...)\n{\n    va_list va;\n    char buf[MAX_SERVER_REPLY_LEN];\n    size_t len;\n    int vlen;\n\n    va_start(va, format);\n    vlen = vsnprintf(buf, sizeof buf, format, va);\n    if (vlen < 0 || (size_t) vlen >= sizeof buf) {\n        buf[MAX_SERVER_REPLY_LEN - 1] = 0;\n        len = strlen(buf);\n    } else {\n        len = (size_t) vlen;\n    }\n    if (len >= replybuf_left) {\n        client_fflush();\n    }\n    if (len > replybuf_left) {\n        va_end(va);\n        abort();\n    }\n    memcpy(replybuf_pos, buf, len);\n    replybuf_pos += len;\n    replybuf_left -= len;\n\n    va_end(va);\n}\n\nvoid die(const int err, const int priority, const char * const format, ...)\n{\n    va_list va;\n    char line[MAX_SYSLOG_LINE];\n\n    disablesignals();\n    logging = 0;\n    va_start(va, format);\n    vsnprintf(line, sizeof line, format, va);\n    addreply(err, \"%s\", line);\n    va_end(va);\n    doreply();\n    logfile(priority, \"%s\", line);\n    _EXIT(-priority - 1);\n}\n\nvoid die_mem(void)\n{\n    die(421, LOG_ERR, MSG_OUT_OF_MEMORY);\n}\n\nstatic void sigalarm(int sig)\n{\n    (void) sig;\n    disablesignals();\n    die(421, LOG_INFO, MSG_TIMEOUT);\n}\n\n#ifndef NO_STANDALONE\nstatic void sigchild(int sig)\n{\n    const int olderrno = errno;\n    pid_t pid;\n\n    (void) sig;\n# ifdef HAVE_WAITPID\n    while ((pid = waitpid((pid_t) -1, NULL, WNOHANG)) > (pid_t) 0) {\n        if (nb_children > 0U) {\n            nb_children--;\n        }\n#  ifdef FTPWHO\n        ftpwho_unlinksbfile(pid);\n#  endif\n        iptrack_delete_pid(pid);\n    }\n# endif\n    errno = olderrno;\n}\n#endif\n\nstatic void sigterm_client(int sig)\n{\n    (void) sig;\n\n    disablesignals();\n    _EXIT(EXIT_SUCCESS);\n}\n\n#ifndef NO_STANDALONE\nstatic void sigterm(int sig)\n{\n    const int olderrno = errno;\n    (void) sig;\n\n    stop_server = 1;\n    if (listenfd != -1) {\n        shutdown(listenfd, 2);\n        (void) close(listenfd);\n    }\n    if (listenfd6 != -1) {\n        shutdown(listenfd6, 2);\n        (void) close(listenfd6);\n    }\n    errno = olderrno;\n}\n\nstatic void set_cloexec_flag(const int fd)\n{\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n}\n#endif\n\nstatic void clearargs(int argc, char **argv)\n{\n#ifndef NO_PROCNAME_CHANGE\n# if defined(__linux__) && !defined(HAVE_SETPROCTITLE)\n    int i;\n    char *first = NULL;\n    char *next = NULL;\n\n    for (i = 0; i < argc; i++) {\n        if (first == NULL) {\n            first = argv[i];\n        }\n        if (next == NULL || argv[i] == next + 1) {\n            next = argv[i] + strlen(argv[i]);\n        }\n    }\n    for (i = 0; environ[i] != NULL; i++) {\n        if (first == NULL) {\n            first = argv[i];\n        }\n        if (next == NULL) {\n            next = argv[i] + strlen(argv[i]);\n        }\n    }\n    if (first == NULL || next == NULL) {\n        return;\n    }\n    argv_lth = next - first;\n    argv0 = argv;\n    if (environ != NULL) {\n        char **new_environ;\n        unsigned int env_nb = 0U;\n\n        while (environ[env_nb] != NULL) {\n            env_nb++;\n        }\n        if ((new_environ = malloc((1U + env_nb) * sizeof (char *))) == NULL) {\n            abort();\n        }\n        new_environ[env_nb] = NULL;\n        while (env_nb > 0U) {\n            env_nb--;\n            new_environ[env_nb] = strdup(environ[env_nb]);\n        }\n        environ = new_environ;\n    }\n# else\n    (void) argc;\n    (void) argv;\n# endif\n#endif\n}\n\nvoid setprocessname(const char * const title)\n{\n#ifndef NO_PROCNAME_CHANGE\n# ifdef HAVE_SETPROCTITLE\n    setproctitle(\"-%s\", title);\n# elif defined(__linux__)\n    if (argv0 != NULL && argv_lth > strlen(title) - 2) {\n        memset(argv0[0], 0, argv_lth);\n        strncpy(argv0[0], title, argv_lth - 2);\n        argv0[1] = NULL;\n    }\n# elif defined(__hpux__)\n    union pstun pst;\n\n    pst.pst_command = title;\n    pstat(PSTAT_SETCMD, pst, strlen(title), 0, 0);\n# endif\n#endif\n    (void) title;\n}\n\n/* Check whether an address is valid, return 1 if ok, 0 otherwise.\n * Unfortunately, multicasting with the FTP protocol is impossible,\n * you have to use things like MTP instead. So prohibit multicast.\n */\n\nstatic int checkvalidaddr(const struct sockaddr_storage * const addr)\n{\n    if (addr == NULL) {\n        return 0;\n    }\n    /* Some versions of MacOS X have broken IN* macros */\n#ifdef __APPLE_CC__\n    return 1;\n#endif\n    if (STORAGE_FAMILY(*addr) == AF_INET6) {\n        if (IN6_IS_ADDR_MULTICAST(&STORAGE_SIN_ADDR6_NF_CONST(*addr)) ||\n            IN6_IS_ADDR_UNSPECIFIED(&STORAGE_SIN_ADDR6_NF_CONST(*addr))) {\n            return 0;\n        }\n        return 1;\n    } else if (STORAGE_FAMILY(*addr) == AF_INET) {\n        if (ntohl(STORAGE_SIN_ADDR_CONST(*addr)) == INADDR_ANY ||\n            ntohl(STORAGE_SIN_ADDR_CONST(*addr)) == INADDR_NONE ||\n            ntohl(STORAGE_SIN_ADDR_CONST(*addr)) == INADDR_BROADCAST ||\n            IN_MULTICAST(ntohl(STORAGE_SIN_ADDR_CONST(*addr)))) {\n            return 0;\n        }\n        return 1;\n    }\n    return 0;\n}\n\n/* Convert a 4-in-6 address to pure IPv4 */\n\nstatic void fourinsix(struct sockaddr_storage *v6)\n{\n    struct sockaddr_storage v4;\n\n    if (v6ready == 0 || STORAGE_FAMILY(*v6) != AF_INET6 ||\n        IN6_IS_ADDR_V4MAPPED(&STORAGE_SIN_ADDR6_NF_CONST(*v6)) == 0) {\n        return;\n    }\n    memset(&v4, 0, sizeof v4);\n    STORAGE_FAMILY(v4) = AF_INET;\n    memcpy(&STORAGE_SIN_ADDR(v4),\n           (unsigned char *) &STORAGE_SIN_ADDR6_CONST(*v6) + 12,\n           sizeof STORAGE_SIN_ADDR(v4));\n    STORAGE_PORT(v4) = STORAGE_PORT6_CONST(*v6);\n    SET_STORAGE_LEN(v4, sizeof(struct sockaddr_in));\n    *v6 = v4;\n}\n\n/* Return 0 if s1 == s2 , 1 if s1 != s2 , -1 if error */\n\nstatic int addrcmp(const struct sockaddr_storage * const s1,\n                   const struct sockaddr_storage * const s2)\n{\n    if (STORAGE_FAMILY(*s1) == AF_INET6) {\n        if (STORAGE_FAMILY(*s2) != AF_INET6) {\n            return 1;\n        }\n        if (IN6_ARE_ADDR_EQUAL(&STORAGE_SIN_ADDR6_NF_CONST(*s1), &STORAGE_SIN_ADDR6_NF_CONST(*s2))) {\n            return 0;\n        } else {\n            return 1;\n        }\n    } else if (STORAGE_FAMILY(*s1) == AF_INET) {\n        if (STORAGE_FAMILY(*s2) != AF_INET) {\n            return 1;\n        }\n        if (STORAGE_SIN_ADDR_CONST(*s1) == STORAGE_SIN_ADDR_CONST(*s2)) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n    return -1;\n}\n\nstatic int generic_aton(const char *src, struct sockaddr_storage *a)\n{\n    if (inet_pton(AF_INET6, src, &STORAGE_SIN_ADDR6(*a)) > 0) {\n        STORAGE_FAMILY(*a) = AF_INET6;\n        return 0;\n    }\n    if (inet_pton(AF_INET, src, &STORAGE_SIN_ADDR(*a)) > 0) {\n        STORAGE_FAMILY(*a) = AF_INET;\n        return 0;\n    }\n    memset(a, 0, sizeof *a);\n\n    return -1;\n}\n\nvoid logfile(const int crit, const char *format, ...)\n{\n#if defined(NON_ROOT_FTP)\n    (void) crit;\n    (void) format;\n#else\n    const char *urgency;\n    va_list va;\n    char line[MAX_SYSLOG_LINE];\n\n    if (no_syslog != 0) {\n        va_end(va);\n        return;\n    }\n    va_start(va, format);\n    vsnprintf(line, sizeof line, format, va);\n    va_end(va);\n    switch (crit) {\n    case LOG_INFO:\n        urgency = \"[INFO] \";\n        break;\n    case LOG_WARNING:\n        urgency = \"[WARNING] \";\n        break;\n    case LOG_ERR:\n        urgency = \"[ERROR] \";\n        break;\n    case LOG_NOTICE:\n        urgency = \"[NOTICE] \";\n        break;\n    case LOG_DEBUG:\n        urgency = \"[DEBUG] \";\n        break;\n    default:\n        urgency = \"\";\n    }\n# ifdef SAVE_DESCRIPTORS\n    openlog(\"pure-ftpd\", log_pid, syslog_facility);\n# endif\n    syslog(crit, \"(%s@%s) %s%s\",\n           ((loggedin != 0 && *account != 0) ? account : \"?\"),\n           (*host != 0 ? host : \"?\"),\n           urgency, line);\n# ifdef SAVE_DESCRIPTORS\n    closelog();\n# endif\n#endif\n}\n\n#ifndef NO_STANDALONE\n\n/* this is taken from the code examples for Stevens' \"Advanced\n * Programming in the Unix Environment. The code is publicly available\n * at ftp://ftp.uu.net/published/books/stevens.advprog.tar.Z */\n\nstatic unsigned int open_max(void)\n{\n    long z;\n\n    if ((z = (long) sysconf(_SC_OPEN_MAX)) < 0L) {\n        perror(\"_SC_OPEN_MAX\");\n        _EXIT(EXIT_FAILURE);\n    }\n    return (unsigned int) z;\n}\n\n#endif\n\nstatic void addreply_newline(const char * const str, const size_t size)\n{\n    struct reply *newline;\n\n    if ((newline = (struct reply *) malloc(offsetof(struct reply, line) +\n                                           size)) == NULL) {\n        die_mem();\n    }\n    if (firstreply == NULL) {\n        firstreply = newline;\n    } else {\n        lastreply->next = newline;\n    }\n    newline->next = NULL;\n    lastreply = newline;\n    memcpy(newline->line, str, size);\n}\n\nvoid addreply_noformat(const int code, const char * const line)\n{\n    if (code != 0) {\n        replycode = code;\n    }\n    addreply_newline(line, strlen(line) + (size_t) 1U);\n}\n\nvoid addreply(const int code, const char * const line, ...)\n{\n    char *a;\n    char *b;\n    va_list ap;\n    int last;\n    char buf[MAX_SERVER_REPLY_LEN];\n\n    if (code != 0) {\n        replycode = code;\n    }\n    va_start(ap, line);\n    vsnprintf(buf, sizeof buf, line, ap);\n    va_end(ap);\n    last = 0;\n    a = buf;\n    for (;;) {\n        b = strchr(a, '\\n');\n        if (b != NULL) {\n            *b = 0;\n        } else {\n            b = a;\n            while (*b != 0) {\n                b++;\n            }\n            last++;\n        }\n        addreply_newline(a, (size_t) (b - a) + (size_t) 1U);\n        if (last != 0) {\n            break;\n        }\n        a = b + 1;\n    }\n}\n\nvoid doreply(void)\n{\n    struct reply *scannedentry;\n    struct reply *nextentry;\n\n    if ((scannedentry = firstreply) == NULL) {\n        return;\n    }\n    do {\n        nextentry = scannedentry->next;\n#ifdef WITH_TLS\n        if (tls_cnx != NULL) {\n            char buf[MAX_SERVER_REPLY_LEN];\n\n            snprintf(buf, sizeof buf, \"%3d%c%s\\r\\n\", replycode,\n                     nextentry == NULL ? ' ' : '-', scannedentry->line);\n            SSL_write(tls_cnx, buf, strlen(buf));\n        } else\n#endif\n        {\n            client_printf(\"%3d%c%s\\r\\n\", replycode,\n                          nextentry == NULL ? ' ' : '-',\n                          scannedentry->line);\n        }\n        if (logging > 1) {\n            logfile(LOG_DEBUG, \"%3d%c%s\", replycode,\n                    nextentry == NULL ? ' ' : '-', scannedentry->line);\n        }\n    } while ((scannedentry = nextentry) != NULL);\n    client_fflush();\n    scannedentry = firstreply;\n    do {\n        nextentry = scannedentry->next;\n        free(scannedentry);\n    } while ((scannedentry = nextentry) != NULL);\n    firstreply = lastreply = NULL;\n}\n\n/* Check whether a file name is valid. Files names starting\n * with a dot are only allowed to root and to users\n * chroot()ed in their home directories -Jedi. */\n\nstatic int checknamesanity(const char *name, int dot_ok)\n{\n    const char *namepnt;\n\n#ifdef PARANOID_FILE_NAMES\n    const char *validchars =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        \"abcdefgihjklmnopqrstuvwxyz\"\n        \"0123456789./-_\";\n#endif\n\n    if (name == NULL || *name == 0) {\n        return -1;\n    }\n    /* optimize . and .. */\n    if (name[0] == '.' && (name[1] == 0 || (name[1] == '.' && name[2] == 0))) {\n        return 0;\n    }\n    namepnt = name;\n#ifdef PARANOID_FILE_NAMES\n    /* we want to make sure we don't get any non-alphanumeric file name */\n    if (strlen(namepnt) != strspn(namepnt, validchars)) {\n        return -1;\n    }\n#endif\n#ifdef QUOTAS\n    if (hasquota() == 0) {\n        if (strstr(namepnt, QUOTA_FILE) != NULL) {\n            return -1;                     /* .ftpquota => *NO* */\n        }\n# ifndef ALLOW_DELETION_OF_TEMPORARY_FILES\n        if (strstr(namepnt, PUREFTPD_TMPFILE_PREFIX) == namepnt) {\n            return -1;\n        }\n# endif\n    }\n#endif\n    while (*namepnt != 0) {\n#ifndef ALLOW_EVERYTHING_IN_FILE_NAMES\n        if (ISCTRLCODE(*namepnt) || *namepnt == '\\\\') {\n            return -1;\n        }\n#endif\n        if (dot_ok == 0) {\n            if (*namepnt == '/') {\n                namepnt++;\n            } else if (namepnt != name) {\n                namepnt++;\n                continue;\n            }\n            if (namepnt[0] == 0) {     /* /$ */\n                return 0;\n            }\n            if (namepnt[0] == '.') {   /* /. */\n                if (namepnt[1] == 0) { /* /.$ => ok */\n                    return 0;\n                }\n                if (namepnt[1] == '.') {   /* /.. */\n                    if (namepnt[2] == 0) {   /* /..$ => ok */\n                        return 0;\n                    }\n                    if (namepnt[2] != '/') {   /* /..[^/] => *NO* */\n                        return -1;\n                    }\n                } else if (namepnt[1] != '/') {   /* /.[^/]/ => *NO* */\n                    return -1;\n                }\n            }\n            if (namepnt != name) {\n                continue;\n            }\n        }\n        namepnt++;\n    }\n    return 0;\n}\n\nstatic void do_ipv6_port(char *p, char delim)\n{\n    char *deb;\n    struct sockaddr_storage a;\n\n    deb = p;\n    while (*p && strchr(\"0123456789abcdefABCDEF:\", *p) != NULL) {\n        p++;\n    }\n    if (*p != delim || atoi(p + 1) == 0) {\n        nope:\n        (void) close(datafd);\n        datafd = -1;\n        addreply_noformat(501, MSG_SYNTAX_ERROR_IP);\n        return;\n    }\n    *p++ = 0;\n    if (generic_aton(deb, &a) != 0) {\n        goto nope;\n    }\n    doport2(a, (unsigned int) atoi(p));\n}\n\n#ifndef MINIMAL\nvoid doesta(void)\n{\n    struct sockaddr_storage dataconn;\n    socklen_t socksize;\n    char hbuf[NI_MAXHOST];\n    char pbuf[NI_MAXSERV];\n\n    if (passive != 0 || datafd == -1) {\n        addreply_noformat(520, MSG_ACTIVE_DISABLED);\n        return;\n    }\n    if (xferfd == -1) {\n        opendata();\n        if (xferfd == -1) {\n            addreply_noformat(425, MSG_CANT_CREATE_DATA_SOCKET);\n            return;\n        }\n    }\n    socksize = (socklen_t) sizeof dataconn;\n    if (getsockname(xferfd, (struct sockaddr *) &dataconn, &socksize) < 0 ||\n        getnameinfo((struct sockaddr *) &dataconn, STORAGE_LEN(dataconn),\n                    hbuf, sizeof hbuf, pbuf, sizeof pbuf,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n        addreply_noformat(425, MSG_GETSOCKNAME_DATA);\n        closedata();\n        return;\n    }\n    addreply(225, \"Connected from (|%c|%s|%s|)\",\n             STORAGE_FAMILY(dataconn) == AF_INET6 ? '2' : '1', hbuf, pbuf);\n}\n\nvoid doestp(void)\n{\n    struct sockaddr_storage dataconn;\n    socklen_t socksize;\n    char hbuf[NI_MAXHOST];\n    char pbuf[NI_MAXSERV];\n\n    if (passive == 0 || datafd == -1) {\n        addreply_noformat(520, MSG_CANT_PASSIVE);\n        return;\n    }\n    if (xferfd == -1) {\n        opendata();\n        if (xferfd == -1) {\n            addreply_noformat(425, MSG_CANT_CREATE_DATA_SOCKET);\n            return;\n        }\n    }\n    socksize = (socklen_t) sizeof dataconn;\n    if (getpeername(xferfd, (struct sockaddr *) &dataconn, &socksize) < 0 ||\n        getnameinfo((struct sockaddr *) &dataconn, STORAGE_LEN(dataconn),\n                    hbuf, sizeof hbuf, pbuf, sizeof pbuf,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n        addreply_noformat(425, MSG_GETSOCKNAME_DATA);\n        closedata();\n        return;\n    }\n    addreply(225, \"Connected to (|%c|%s|%s|)\",\n             STORAGE_FAMILY(dataconn) == AF_INET6 ? '2' : '1', hbuf, pbuf);\n}\n#endif\n\nvoid doeprt(char *p)\n{\n    char delim;\n    int family;\n\n    delim = *p++;\n    family = atoi(p);\n    while (isdigit((unsigned char) *p)) {\n        p++;\n    }\n    if (*p == delim) {\n        p++;\n    } else {\n        addreply_noformat(501, MSG_SYNTAX_ERROR_IP);\n        return;\n    }\n    if (family == 2 && v6ready) {\n        do_ipv6_port(p, delim);\n        return;\n    }\n    if (family != 1) {\n        if (v6ready) {\n            addreply_noformat(522, MSG_ONLY_IPV4V6);\n        } else {\n            addreply_noformat(522, MSG_ONLY_IPV4);\n        }\n        return;\n    }\n\n    {\n        unsigned int a1, a2, a3, a4, port = 0U;\n        /* there should be dot-decimal ip as rfc2428 states,\n         * but troll used for some reason \"comma-decimal\" notation\n         * so I decided to leave it */\n        if ((sscanf(p, \"%u,%u,%u,%u\", &a1, &a2, &a3, &a4) != 4 &&\n             sscanf(p, \"%u.%u.%u.%u\", &a1, &a2, &a3, &a4) != 4) ||\n            a1 > 255U || a2 > 255U || a3 > 255U || a4 > 255U ||\n            (a1 | a2 | a3 | a4) == 0U) {\n            addreply_noformat(501, MSG_SYNTAX_ERROR_IP);\n            return;\n        }\n        while (*p && strchr(\"0123456789.,\", *p)) {\n            p++;\n        }\n        if (*p == delim) {\n            port = (unsigned int) atoi(++p);\n            while (*p && isdigit((unsigned char) *p)) {\n                p++;\n            }\n        }\n        if (*p != delim || port > 65535U || port <= 0U) {\n            addreply_noformat(501, MSG_SYNTAX_ERROR_IP);\n            return;\n        } else {\n            struct sockaddr_storage a;\n\n            memset(&a, 0, sizeof a);\n            STORAGE_FAMILY(a) = AF_INET;\n            STORAGE_SIN_ADDR(a) =\n                htonl(((uint32_t) a1 << 24) |\n                      ((uint32_t) a2 << 16) | (a3 << 8) | a4);\n            SET_STORAGE_LEN(a, sizeof(struct sockaddr_in));\n            doport2(a, port);\n        }\n    }\n}\n\nvoid stripctrl(char * const buf, size_t len)\n{\n    if (len <= (size_t) 0U) {\n        return;\n    }\n    do {\n        len--;\n        if (ISCTRLCODE(buf[len]) &&\n            buf[len] != 0 && buf[len] != '\\n') {\n            buf[len] = '_';\n        }\n    } while (len != (size_t) 0U);\n}\n\n#ifndef MINIMAL\n\n/*\n * small help routine to display a banner\n * type = 0 reads .banner/welcome.msg\n * type = 1 reads .message (after cd'ing into a directory)\n */\nvoid dobanner(const int type)\n{\n    char buffer[512];\n    FILE *msg;\n    size_t buflen;\n    unsigned int nblines = BANNER_MAXLINES;\n\n    switch (type) {\n    case 0:\n        if ((msg = fopen(\".banner\", \"r\")) == NULL\n# ifdef WITH_WELCOME_MSG\n            && (msg = fopen(\"welcome.msg\", \"r\")) == NULL\n# endif\n            ) {\n            return;\n        }\n        break;\n    case 1:\n        if ((msg = fopen(\".message\", \"r\")) == NULL) {\n            return;\n        }\n        break;\n    default:\n        return;\n    }\n\n    while (fgets(buffer, sizeof buffer, msg) != NULL && nblines > 0U) {\n        nblines--;\n        if ((buflen = strlen(buffer)) > (size_t) 0U) {\n            buflen--;\n            while (buffer[buflen] == '\\n' || buffer[buflen] == '\\r') {\n                buffer[buflen] = 0;\n                if (buflen == (size_t) 0U) {\n                    break;\n                }\n                buflen--;\n            }\n            stripctrl(buffer, buflen);\n        }\n        addreply_noformat(0, buffer);\n    }\n    (void) fclose(msg);\n}\n\n#endif\n\n#ifndef MINIMAL\n\nint modernformat(const char *file, char *target, size_t target_size,\n                 const char * const prefix)\n{\n    char link_target[PATH_MAX + 1U];\n    const char *ft;\n    const char *ftx = \"\";\n    struct tm *t;\n    struct stat st;\n    int ret = 0;\n\n    if (lstat(file, &st) != 0 || !(t = gmtime((time_t *) &st.st_mtime))) {\n        return -1;\n    }\n#if !defined(MINIMAL) && !defined(ALWAYS_SHOW_SYMLINKS_AS_SYMLINKS)\n    if (\n# ifndef ALWAYS_SHOW_RESOLVED_SYMLINKS\n        broken_client_compat != 0 &&\n# endif\n        S_ISLNK(st.st_mode)) {\n        struct stat sts;\n\n        if (stat(file, &sts) == 0 && !S_ISLNK(sts.st_mode)) {\n            st = sts;\n        }\n    } /* Show non-dangling symlinks as files/directories */\n#endif\n    if (S_ISREG(st.st_mode)) {\n        ft = \"file\";\n    } else if (S_ISDIR(st.st_mode)) {\n        ret = 1;\n        ft = \"dir\";\n        if (*file == '.') {\n            if (file[1] == '.' && file[2] == 0) {\n                ft = \"pdir\";\n            } else if (file[1] == 0) {\n                ft = \"cdir\";\n            }\n        } else if (*file == '/' && file[1] == 0) {\n            ft = \"pdir\";\n        }\n    } else if (S_ISLNK(st.st_mode)) {\n        ssize_t sx;\n\n        ft = \"OS.unix=symlink\";\n        if ((sx = readlink(file, link_target, sizeof link_target - 1U)) > 0) {\n            link_target[sx] = 0;\n            if (strpbrk(link_target, \"\\r\\n;\") == NULL) {\n                ftx = link_target;\n                ft = \"OS.unix=slink:\";\n            }\n        }\n    } else {\n        ft = \"unknown\";\n    }\n    if (guest != 0) {\n        if (SNCHECK(snprintf(target, target_size,\n                             \"%stype=%s%s;siz%c=%llu;modify=%04d%02d%02d%02d%02d%02d;UNIX.mode=0%o;unique=%xg%llx; %s\",\n                             prefix,\n                             ft, ftx,\n                             ret ? 'd' : 'e',\n                             (unsigned long long) st.st_size,\n                             t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                             t->tm_hour, t->tm_min, t->tm_sec,\n                             (unsigned int) st.st_mode & 07777,\n                             (unsigned int) st.st_dev,\n                             (unsigned long long) st.st_ino,\n                             file), target_size)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    } else {\n        if (SNCHECK(snprintf(target, target_size,\n                             \"%stype=%s;siz%c=%llu;modify=%04d%02d%02d%02d%02d%02d;UNIX.mode=0%o;UNIX.uid=%lld;UNIX.gid=%lld;unique=%xg%llx; %s\",\n                             prefix,\n                             ft,\n                             ret ? 'd' : 'e',\n                             (unsigned long long) st.st_size,\n                             t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                             t->tm_hour, t->tm_min, t->tm_sec,\n                             (unsigned int) st.st_mode & 07777,\n                             (unsigned long long) st.st_uid,\n                             (unsigned long long) st.st_gid,\n                             (unsigned int) st.st_dev,\n                             (unsigned long long) st.st_ino,\n                             file), target_size)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    }\n    return ret;\n}\n\n#define MLST_BEGIN \"Begin\" CRLF\n\nvoid domlst(const char * const file)\n{\n    char line[PATH_MAX + 256U] = MLST_BEGIN;\n\n    if (modernformat(file, line + (sizeof MLST_BEGIN - 1U),\n                     sizeof line - (sizeof MLST_BEGIN - 1U), \" \") < 0) {\n        addreply_noformat(550, MSG_STAT_FAILURE2);\n        return;\n    }\n    addreply_noformat(0, line);\n    addreply_noformat(250, \"End.\");\n}\n\nvoid donoop(void)\n{\n#ifdef BORING_MODE\n    addreply_noformat(200, \"dc.w $4E71\");\n#else\n    addreply_noformat(200, MSG_SLEEPING);\n#endif\n}\n\nvoid doallo(const off_t size)\n{\n    int ret = -1;\n#ifdef QUOTAS\n    Quota quota;\n#endif\n\n    if (size <= 0) {\n        ret = 0;\n    } else if (ul_check_free_space(wd, (double) size) != 0) {\n        ret = 0;\n    }\n#ifdef QUOTAS\n    if (quota_update(&quota, 0LL, 0LL, NULL) == 0) {\n        if (quota.files >= user_quota_files ||\n            quota.size >= user_quota_size ||\n            (unsigned long long) size > user_quota_size - quota.size) {\n            ret = -1;\n        }\n    }\n#endif\n    if (ret == 0) {\n#ifdef DISABLE_HUMOR\n        addreply_noformat(200, \"OK\");\n#else\n        addreply_noformat(200, \"A L'HUILE\");\n#endif\n    } else {\n        addreply_noformat(552, MSG_NO_DISK_SPACE);\n    }\n}\n\n#endif\n\nvoid dositetime(void)\n{\n    char tmp[64];\n    const struct tm *tm;\n    time_t now;\n\n    if ((now = time(NULL)) == (time_t) -1 || (tm = localtime(&now)) == NULL) {\n        addreply_noformat(451, \"time()\");\n        return;\n    }\n    strftime(tmp, sizeof tmp, \"%Y-%m-%d %H:%M:%S\", tm);\n    addreply_noformat(211, tmp);\n}\n\nstatic int doinitsupgroups(const char *user, const uid_t uid, const gid_t gid)\n{\n#ifndef NON_ROOT_FTP\n# ifdef HAVE_SETGROUPS\n    if (setgroups(1U, &gid) != 0) {\n        return -1;\n    }\n# else\n    (void) gid;\n# endif\n# ifdef HAVE_INITGROUPS\n    if (user == NULL) {\n        const struct passwd * const lpwd = getpwuid(uid);\n\n        if (lpwd != NULL && lpwd->pw_name != NULL) {\n            user = lpwd->pw_name;\n        } else {\n            return 0;\n        }\n    }\n    initgroups(user, gid);\n# else\n    (void) user;\n    (void) uid;\n# endif\n#else\n    (void) user;\n    (void) uid;\n    (void) gid;\n#endif\n    return 0;\n}\n\nvoid douser(const char *username)\n{\n    struct passwd *pw = NULL;\n\n    if (loggedin) {\n        if (username) {\n            if (!guest) {\n                addreply_noformat(530, MSG_ALREADY_LOGGED);\n            } else if (broken_client_compat != 0) {\n                addreply_noformat(331, MSG_ANY_PASSWORD);\n            } else {\n                addreply_noformat(230, MSG_ANONYMOUS_LOGGED);\n                dot_read_ok = dot_read_anon_ok;\n                dot_write_ok = 0;\n            }\n        }\n        return;\n    }\n    if (anon_only <= 0 && username != NULL && *username != 0 &&\n        (anon_only < 0 || (strcasecmp(username, \"ftp\") &&\n                           strcasecmp(username, \"anonymous\")))) {\n        strncpy(account, username, sizeof(account) - 1);\n        account[sizeof(account) - (size_t) 1U] = 0;\n        addreply(331, MSG_USER_OK, account);\n        loggedin = 0;\n    } else if (anon_only < 0) {\n        if (broken_client_compat != 0) {\n            addreply(331, MSG_USER_OK, username);\n            return;\n        } else {\n            die(530, LOG_DEBUG, MSG_NO_ANONYMOUS_LOGIN);\n        }\n    } else {\n#ifdef WITH_VIRTUAL_HOSTS\n        char name[PATH_MAX];\n        char hbuf[NI_MAXHOST];\n#endif\n        if (chrooted != 0) {\n            die(421, LOG_DEBUG, MSG_CANT_DO_TWICE);\n        }\n\n#ifdef PER_USER_LIMITS\n        if (per_anon_max > 0U && ftpwho_read_count(\"ftp\") >= per_anon_max) {\n            addreply(421, MSG_PERUSER_MAX, (unsigned long) per_anon_max);\n            doreply();\n            _EXIT(1);\n        }\n#endif\n\n#ifdef NON_ROOT_FTP\n        {\n            static struct passwd pw_;\n            char s[PATH_MAX + 1U];\n\n            if (getcwd(s, sizeof s - (size_t) 1U) == NULL) {\n                cantsec:\n                die(421, LOG_ERR, MSG_UNABLE_SECURE_ANON);\n            }\n            pw_.pw_uid = geteuid();\n            pw_.pw_gid = getegid();\n            pw_.pw_dir = (char *) NON_ROOT_ANON_DIR;\n            if (home_directory != NULL) {\n                pw_.pw_dir = (char *) home_directory;\n            }\n            if (getenv(\"FTP_ANON_DIR\") != NULL) {\n                pw_.pw_dir = getenv(\"FTP_ANON_DIR\");\n            }\n            if (pw_.pw_dir == NULL) {\n                pw_.pw_dir = strdup(s);    /* checked for == NULL later */\n            }\n            pw = &pw_;\n        }\n#else\n        if (((pw = getpwnam(\"ftp\")) == NULL &&\n             (pw = getpwnam(\"_ftp\")) == NULL) ||\n            pw->pw_uid == 0 || pw->pw_gid == 0 ||\n            (doinitsupgroups(\"ftp\", (uid_t) -1, pw->pw_gid) != 0 &&\n             doinitsupgroups(\"_ftp\", (uid_t) -1, pw->pw_gid) != 0) ||\n            setgid(pw->pw_gid) || setegid(pw->pw_gid)) {\n            cantsec:\n            die(421, LOG_ERR, MSG_UNABLE_SECURE_ANON);\n        }\n# ifdef ANON_DIR\n        if ((pw->pw_dir = strdup(ANON_DIR)) == NULL) {\n            die_mem();\n        }\n# endif\n#endif\n#ifdef WITH_VIRTUAL_HOSTS\n        if (getnameinfo((struct sockaddr *) &ctrlconn, STORAGE_LEN(ctrlconn),\n                        hbuf, sizeof hbuf, NULL,\n                        (size_t) 0U, NI_NUMERICHOST) != 0\n            || SNCHECK(snprintf(name, sizeof name, VHOST_PATH \"/%s\", hbuf),\n                       sizeof name)) {\n            _EXIT(EXIT_FAILURE);\n        }\n        if (chdir(name) != 0)         /* non-virtual */\n#endif\n        {\n            char *hd;\n            size_t rd_len;\n\n            if (pw->pw_dir == NULL || *pw->pw_dir != '/') {\n                goto cantsec;\n            }\n            if ((hd = strstr(pw->pw_dir, \"/./\")) != NULL) {\n                rd_len = (size_t) (hd - pw->pw_dir) + sizeof \"/\";\n                if ((root_directory = malloc(rd_len)) == NULL) {\n                    goto cantsec;\n                }\n                memcpy(root_directory, pw->pw_dir, rd_len);\n                root_directory[rd_len - (size_t) 1U] = 0;\n                hd += 2;\n            } else {\n                rd_len = strlen(pw->pw_dir) + sizeof \"/\";\n                if ((root_directory = malloc(rd_len)) == NULL) {\n                    goto cantsec;\n                }\n                snprintf(root_directory, rd_len, \"%s/\", pw->pw_dir);\n                hd = (char *) \"/\";\n            }\n            if (chdir(root_directory) || chroot(root_directory) || chdir(hd)) {\n                die(421, LOG_ERR, MSG_CANT_CHANGE_DIR \" [%s]\", root_directory, hd);\n            }\n            logfile(LOG_INFO, MSG_ANONYMOUS_LOGGED);\n        }\n#ifdef WITH_VIRTUAL_HOSTS\n        else {                       /* virtual host */\n            const size_t rd_len = strlen(hbuf) + sizeof \":/\";\n\n            if ((root_directory = malloc(rd_len)) == NULL ||\n                chdir(name) || chroot(name) || chdir(\"/\") ||\n                SNCHECK(snprintf(root_directory, rd_len, \"%s:/\", hbuf),\n                        rd_len)) {\n                goto cantsec;\n            }\n            logfile(LOG_INFO, MSG_ANONYMOUS_LOGGED_VIRTUAL \": %s\", hbuf);\n        }\n#endif\n        if (pw == NULL) {\n            goto cantsec;\n        }\n        chrooted = 1;\n        authresult.uid = pw->pw_uid;\n        authresult.gid = pw->pw_gid;\n        if ((authresult.dir = strdup(pw->pw_dir)) == NULL) {\n            die_mem();\n        }\n\n#ifdef THROTTLING\n        if (throttling != 0) {\n            addreply_noformat(0, MSG_BANDWIDTH_RESTRICTED);\n            (void) nice(NICE_VALUE);\n        } else {\n            throttling_delay = throttling_bandwidth_ul =\n                throttling_bandwidth_dl = 0UL;\n        }\n#endif\n\n#ifndef NON_ROOT_FTP\n        if (authresult.uid > (uid_t) 0) {\n# ifndef WITHOUT_PRIVSEP\n            if (setuid(authresult.uid) != 0 || seteuid(authresult.uid) != 0) {\n                goto cantsec;\n            }\n# else\n            if (seteuid(authresult.uid) != 0) {\n                goto cantsec;\n            }\n#  ifdef USE_CAPABILITIES\n            drop_login_caps();\n#  endif\n# endif\n        }\n#endif\n\n#ifndef MINIMAL\n        dobanner(0);\n#endif\n\n        if (broken_client_compat != 0) {\n            addreply_noformat(331, MSG_ANONYMOUS_ANY_PASSWORD);\n        } else {\n            addreply_noformat(230, MSG_ANONYMOUS_LOGGED);\n        }\n        dot_write_ok = 0;\n        dot_read_ok = dot_read_anon_ok;\n        strncpy(account, \"ftp\", sizeof account - (size_t) 1U);\n        account[(sizeof account) - 1U] = 0;\n#ifdef FTPWHO\n        if (shm_data_cur != NULL) {\n            ftpwho_lock();\n            strncpy(shm_data_cur->account, account,\n                    sizeof shm_data_cur->account - (size_t) 1U);\n            shm_data_cur->account[sizeof shm_data_cur->account - 1U] = 0;\n            ftpwho_unlock();\n            state_needs_update = 1;\n        }\n#endif\n        loggedin = guest = 1;\n#ifdef QUOTAS\n        user_quota_size = user_quota_files = ULONG_LONG_MAX;\n#endif\n    }\n    if (getcwd(wd, sizeof wd - (size_t) 1U) == NULL) {\n        wd[0] = '/';\n        wd[1] = 0;\n    }\n#ifdef WITH_BONJOUR\n    refreshManager();\n#endif\n}\n\nstatic AuthResult pw_check(const char *account, const char *password,\n                           const struct sockaddr_storage * const sa,\n                           const struct sockaddr_storage * const peer)\n{\n    Authentications *auth_scan = first_authentications;\n    AuthResult result;\n\n    result.auth_ok = -1;\n    while (auth_scan != NULL) {\n#ifdef THROTTLING\n        result.throttling_bandwidth_ul = throttling_bandwidth_ul;\n        result.throttling_bandwidth_dl = throttling_bandwidth_dl;\n        result.throttling_ul_changed = result.throttling_dl_changed = 0;\n#endif\n#ifdef QUOTAS\n        result.user_quota_size = user_quota_size;\n        result.user_quota_files = user_quota_files;\n        result.quota_size_changed = result.quota_files_changed = 0;\n#endif\n#ifdef RATIOS\n        result.ratio_upload = ratio_upload;\n        result.ratio_download = ratio_download;\n        result.ratio_ul_changed = result.ratio_dl_changed = 0;\n#endif\n#ifdef PER_USER_LIMITS\n        result.per_user_max = per_user_max;\n#endif\n        result.backend_data = NULL;\n        auth_scan->auth->check(&result, account, password, sa, peer);\n        if (result.auth_ok < 0) {\n            break;\n        } else if (result.auth_ok > 0) {\n#ifdef THROTTLING\n            if ((result.throttling_ul_changed |\n                 result.throttling_dl_changed) != 0) {\n                if (result.throttling_ul_changed != 0 &&\n                    result.throttling_bandwidth_ul > 0UL) {\n                    throttling_bandwidth_ul = result.throttling_bandwidth_ul;\n                }\n                if (result.throttling_dl_changed != 0 &&\n                    result.throttling_bandwidth_dl > 0UL) {\n                    throttling_bandwidth_dl = result.throttling_bandwidth_dl;\n                }\n                throttling_delay = 1000000 /\n                    (throttling_bandwidth_dl | throttling_bandwidth_ul);\n                throttling = 2;\n            }\n#endif\n#ifdef QUOTAS\n            if (result.quota_size_changed != 0) {\n                user_quota_size = result.user_quota_size;\n            }\n            if (result.quota_files_changed != 0) {\n                user_quota_files = result.user_quota_files;\n            }\n#endif\n#ifdef RATIOS\n            if (result.ratio_ul_changed != 0) {\n                ratio_upload = result.ratio_upload;\n                ratio_for_non_anon = 1;\n            }\n            if (result.ratio_dl_changed != 0) {\n                ratio_download = result.ratio_download;\n            }\n#endif\n#ifdef PER_USER_LIMITS\n            per_user_max = result.per_user_max;\n#endif\n\n#ifdef NON_ROOT_FTP\n            result.uid = geteuid();\n            result.gid = getegid();\n#endif\n\n            return result;\n        }\n        auth_scan = auth_scan->next;\n    }\n\n    return result;\n}\n\n/*\n * Check if an user belongs to the trusted group, either in his\n * primary group, or his supplementary groups. Root is always trusted.\n */\n\nstatic int check_trustedgroup(const uid_t uid, const gid_t gid)\n{\n    GETGROUPS_T *alloca_suppgroups;\n    int n;\n    int n2;\n    int result = 0;\n\n    if (uid == (uid_t) 0) {\n        return 1;\n    }\n    if (userchroot == 2) {\n        return 0;\n    }\n    if (gid == chroot_trustedgid) {\n        return 1;\n    }\n#ifdef HAVE_GETGROUPS\n    if ((n = getgroups(0, NULL)) <= 0) {\n        return 0;\n    }\n    if ((alloca_suppgroups =\n         ALLOCA(n * (sizeof *alloca_suppgroups))) == NULL) {\n        die_mem();\n    }\n    n2 = getgroups(n, alloca_suppgroups);\n    /* Jedi's paranoia */\n    if (n2 < n) {\n        n = n2;\n    }\n    result = 0;\n    while (n != 0) {\n        n--;\n        if (alloca_suppgroups[n] == (GETGROUPS_T) chroot_trustedgid) {\n            result = 1;\n            break;\n        }\n    };\n    ALLOCA_FREE(alloca_suppgroups);\n#endif\n\n    return result;\n}\n\n/*\n * Create a home directory on demand.\n */\n\nstatic int create_home_and_chdir(const char * const home)\n{\n    char *pathcomp;\n    char *z;\n    size_t len;\n    const char delim = '/';\n\n    if (home == NULL || *home != '/') {\n        return -1;\n    }\n    if (chdir(home) == 0) {\n        return 0;\n    }\n    if (create_home == 0) {\n        return -1;\n    }\n    len = strlen(home) + (size_t) 1U;\n    if (len < (size_t) 2U || *home != delim) {\n        return -1;\n    }\n    if ((pathcomp = ALLOCA(len)) == NULL) {\n        return -1;\n    }\n    memcpy(pathcomp, home, len);       /* safe, no possible overflow */\n    z = pathcomp;\n    for (;;) {\n        z++;\n        if (*z == 0) {\n            break;\n        }\n        if (*z == delim) {\n            *z = 0;\n            if (z[1] == 0) {\n                break;\n            }\n            (void) mkdir(pathcomp, (mode_t) 0755);\n            *z = delim;\n        }\n    }\n    ALLOCA_FREE(pathcomp);\n    (void) mkdir(home, (mode_t) 0700);\n    if (chdir(home) != 0) {\n        return -1;\n    }\n    if (chmod(home, (mode_t) 0777 & ~u_mask_d) < 0 ||\n        chown(home, authresult.uid, authresult.gid) < 0) {\n        return -1;\n    }\n\n    return chdir(home);\n}\n\nstatic void randomsleep(unsigned int t) {\n    usleep2((unsigned long) (zrand() % PASSWD_FAILURE_DELAY));\n    usleep2(t * PASSWD_FAILURE_DELAY);\n}\n\nvoid dopass(char *password)\n{\n    static unsigned int tapping;\n    char *hd;\n#if !defined(MINIMAL) && defined(HAVE_GETGROUPS) && defined(DISPLAY_GROUPS)\n    gid_t *groups = NULL;\n    int ngroups;\n# if defined(NGROUPS_MAX) && NGROUPS_MAX > 0\n    int ngroups_max = NGROUPS_MAX; /* Use the compile time value */\n# else\n    int ngroups_max = 1; /* use a sane default */\n# endif\n#endif\n\n    if (loggedin != 0) {\n        if (guest != 0) {\n            addreply_noformat(230, MSG_NO_PASSWORD_NEEDED);\n#ifdef LOG_ANON_EMAIL\n            snprintf(account, sizeof account, \"ftp: <%s> \", password);\n#endif\n        } else {\n            addreply_noformat(530, MSG_CANT_DO_TWICE);\n        }\n        return;\n    }\n    if (*account == 0) {\n        addreply_noformat(530, MSG_WHOAREYOU);\n        return;\n    }\n    if (strlen(password) >= MAX_PASSWORD_LEN) {\n        addreply_noformat(530, MSG_LINE_TOO_LONG);\n        return;\n    }\n    authresult = pw_check(account, password, &ctrlconn, &peer);\n    pure_memzero(password, strlen(password));\n    if (authresult.auth_ok != 1) {\n        tapping++;\n        randomsleep(tapping);\n        addreply_noformat(530, MSG_AUTH_FAILED);\n        doreply();\n        if (tapping > MAX_PASSWD_TRIES) {\n            logfile(LOG_ERR, MSG_AUTH_TOOMANY);\n            _EXIT(EXIT_FAILURE);\n        }\n        logfile(LOG_WARNING, MSG_AUTH_FAILED_LOG, account);\n        return;\n    }\n    if (authresult.uid < useruid) {\n        logfile(LOG_WARNING, MSG_ACCOUNT_DISABLED \" (uid < %lu)\",\n                account, (unsigned long) useruid);\n        randomsleep(tapping);\n        if (tapping >= MAX_PASSWD_TRIES) {\n            addreply_noformat(530, MSG_AUTH_FAILED);\n            doreply();\n            _EXIT(EXIT_FAILURE);\n        }\n        addreply_noformat(530, MSG_NOTRUST);\n        doreply();\n        return;\n    }\n\n#ifdef PER_USER_LIMITS\n    if (per_user_max > 0U && ftpwho_read_count(account) >= per_user_max) {\n        addreply(421, MSG_PERUSER_MAX, (unsigned long) per_user_max);\n        doreply();\n        _EXIT(1);\n    }\n#endif\n\n    /* Add username and primary group to the uid/gid cache */\n    (void) getname(authresult.uid);\n    (void) getgroup(authresult.gid);\n\n    if (\n#if defined(WITH_LDAP) || defined(WITH_MYSQL) || defined(WITH_PGSQL) || defined(WITH_PUREDB) || defined(WITH_EXTAUTH)\n        doinitsupgroups(NULL, authresult.uid, authresult.gid) != 0\n#else\n        doinitsupgroups(account, (uid_t) -1, authresult.gid) != 0\n#endif\n        ) {\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)\n        (void) 0;\n#else\n        die(421, LOG_WARNING, MSG_NOTRUST);\n#endif\n    }\n\n    /* handle /home/user/./public_html form */\n    if ((root_directory = strdup(authresult.dir)) == NULL) {\n        die_mem();\n    }\n    hd = strstr(root_directory, \"/./\");\n    if (hd != NULL) {\n        if (chrooted != 0) {\n            die(421, LOG_DEBUG, MSG_CANT_DO_TWICE);\n        }\n        if (create_home_and_chdir(root_directory)) {\n            die(421, LOG_ERR, MSG_NO_HOMEDIR);\n        }\n        *++hd = 0;\n        hd++;\n        if (chroot(root_directory) || chdir(hd)) {\n            die(421, LOG_ERR, MSG_NO_HOMEDIR);\n        }\n        chrooted = 1;\n#ifdef RATIOS\n        if (ratio_for_non_anon == 0) {\n            ratio_upload = ratio_download = 0U;\n        }\n        if (check_trustedgroup(authresult.uid, authresult.gid) != 0) {\n            dot_write_ok = dot_read_ok = 1;\n            ratio_upload = ratio_download = 0U;\n            keepallfiles = 0;\n        }\n#endif\n    } else {\n        (void) free(root_directory);\n        root_directory = (char *) \"/\";\n        if (create_home_and_chdir(authresult.dir)) {\n            die(421, LOG_ERR, MSG_NO_HOMEDIR);\n        }\n    }\n    if (getcwd(wd, sizeof wd - (size_t) 1U) == NULL) {\n        wd[0] = '/';\n        wd[1] = 0;\n    }\n#ifndef NON_ROOT_FTP\n    if (setgid(authresult.gid) || setegid(authresult.gid)) {\n        _EXIT(EXIT_FAILURE);\n    }\n#endif\n    if (check_trustedgroup(authresult.uid, authresult.gid) != 0) {\n        userchroot = 0;\n        dot_write_ok = dot_read_ok = 1;\n        keepallfiles = 0;\n#ifdef RATIOS\n        ratio_upload = ratio_download = 0U;\n#endif\n#ifdef QUOTAS\n        user_quota_files = user_quota_size = ULONG_LONG_MAX;\n#endif\n    }\n#ifdef QUOTAS\n    if (hasquota() == 0) {\n        userchroot = 1;\n    }\n#endif\n    if (loggedin == 0) {\n        candownload = 1;        /* real users can always download */\n    }\n#ifdef THROTTLING\n    if ((throttling == 2) || (guest != 0 && throttling == 1)) {\n        addreply_noformat(0, MSG_BANDWIDTH_RESTRICTED);\n        (void) nice(NICE_VALUE);\n    } else {\n        throttling_delay = throttling_bandwidth_dl =\n            throttling_bandwidth_ul = 0UL;\n    }\n#endif\n#if !defined(MINIMAL) && defined(HAVE_GETGROUPS) && defined(DISPLAY_GROUPS)\n# ifdef SAFE_GETGROUPS_0\n    ngroups = getgroups(0, NULL);\n    if (ngroups > ngroups_max) {\n        ngroups_max = ngroups;\n    }\n# elif defined(_SC_NGROUPS_MAX)\n    /* get the run time value */\n    ngroups = (int) sysconf(_SC_NGROUPS_MAX);\n    if (ngroups > ngroups_max) {\n        ngroups_max = ngroups;\n    }\n# endif\n    if ((groups = malloc(sizeof(GETGROUPS_T) * ngroups_max)) == NULL) {\n        die_mem();\n    }\n    ngroups = getgroups(ngroups_max, groups);\n    if (guest == 0 && ngroups > 0) {\n        char reply[80 + MAX_USER_LENGTH];\n        const char *q;\n        size_t p;\n\n        if (SNCHECK(snprintf(reply, sizeof reply,\n                             MSG_USER_GROUP_ACCESS \": \", account),\n                    sizeof reply)) {\n            _EXIT(EXIT_FAILURE);\n        }\n        p = strlen(reply);\n        do {\n            ngroups--;\n            if ((ngroups != 0 && groups[ngroups] == groups[0]) ||\n                (q = getgroup(groups[ngroups])) == NULL) {\n                continue;\n            }\n            if (p + strlen(q) > 75) {\n                reply[p] = 0;\n                addreply(0, \"%s\", reply);\n                *reply = 0;\n                p = (size_t) 0U;\n            }\n            reply[p++] = ' ';\n            while (*q != 0 && p < sizeof reply - (size_t) 1U) {\n                reply[p++] = *q++;\n            }\n        } while (ngroups > 0);\n        reply[p] = 0;\n        addreply(0, \"%s\", reply);\n    }\n    free(groups);\n#endif\n    if (guest == 0 && allowfxp == 1) {\n        addreply_noformat(0, MSG_FXP_SUPPORT);\n    }\n#ifdef RATIOS\n    if (ratio_for_non_anon != 0 && ratio_upload > 0) {\n        addreply(0, MSG_RATIO, ratio_upload, ratio_download);\n    }\n#endif\n    if (userchroot != 0 && chrooted == 0) {\n        if (chdir(wd) || chroot(wd)) {    /* should never fail */\n            die(421, LOG_ERR, MSG_CHROOT_FAILED);\n        }\n        chrooted = 1;\n#ifdef RATIOS\n        if (ratio_for_non_anon == 0) {\n            ratio_upload = ratio_download = 0U;\n        }\n#endif\n        {\n            const size_t rd_len = strlen(wd) + sizeof \"/\";\n\n            if ((root_directory = malloc(rd_len)) == NULL) {\n                die_mem();\n            }\n            snprintf(root_directory, rd_len, \"%s/\", wd);\n        }\n        wd[0] = '/';\n        wd[1] = 0;\n        if (chdir(wd)) {\n            _EXIT(EXIT_FAILURE);\n        }\n        addreply(230, MSG_CURRENT_RESTRICTED_DIR_IS, wd);\n    } else {\n        addreply(230, MSG_CURRENT_DIR_IS, wd);\n    }\n\n#ifndef NON_ROOT_FTP\n    disablesignals();\n# ifndef WITHOUT_PRIVSEP\n    if (setuid(authresult.uid) != 0 || seteuid(authresult.uid) != 0) {\n        _EXIT(EXIT_FAILURE);\n    }\n# else\n    if (seteuid(authresult.uid) != 0) {\n        _EXIT(EXIT_FAILURE);\n    }\n#  ifdef USE_CAPABILITIES\n    drop_login_caps();\n#  endif\n# endif\n    enablesignals();\n#endif\n    logfile(LOG_INFO, MSG_IS_NOW_LOGGED_IN, account);\n#ifdef FTPWHO\n    if (shm_data_cur != NULL) {\n        ftpwho_lock();\n        strncpy(shm_data_cur->account, account,\n                sizeof shm_data_cur->account - (size_t) 1U);\n        shm_data_cur->account[sizeof shm_data_cur->account - 1U] = 0;\n        ftpwho_unlock();\n        state_needs_update = 1;\n    }\n#endif\n    loggedin = 1;\n    if (getcwd(wd, sizeof wd - (size_t) 1U) == NULL) {\n        wd[0] = '/';\n        wd[1] = 0;\n    }\n#ifndef MINIMAL\n    dobanner(0);\n#endif\n#ifdef QUOTAS\n    displayquota(NULL);\n#endif\n#ifdef WITH_BONJOUR\n    refreshManager();\n#endif\n}\n\nvoid docwd(const char *dir)\n{\n    const char *where;\n    char buffer[PATH_MAX + 256U];\n\n    if (loggedin == 0) {\n        goto kaboom;\n    }\n    /*\n     * secure and conformant tilde expansion routine. Need to be packaged in\n     * a function so that it can be called in other commands and avoid\n     * duplicate code in ls.c             -frank.\n     */\n    where = dir;\n    if (dir == NULL || *dir == 0) {\n        dir = \"~\";\n    }\n    if (*dir == '~') {\n        const struct passwd *pw;\n\n        if (dir[1] == 0) {         /* cd ~ */\n            strncpy(buffer, chrooted != 0 ? \"/\" : authresult.dir,\n                    sizeof buffer);\n            buffer[sizeof buffer - (size_t) 1U] = 0;\n            where = buffer;\n        } else {                   /* cd ~user or cd ~user/ */\n            char *bufpnt = buffer;\n            size_t s = sizeof buffer;\n            const char *dirscan = dir + 1;\n\n            while (*dirscan != 0 && *dirscan != '/') {\n                if (--s <= 0) {\n                    goto kaboom;   /* script kiddy's playing */\n                }\n                *bufpnt++ = *dirscan++;\n            }\n            *bufpnt = 0;\n            if (*buffer == 0) {        /* ~/... */\n                snprintf(buffer, sizeof buffer, \"%s%s\",\n                         chrooted != 0 ? \"/\" : authresult.dir, dirscan);\n                where = buffer;\n            } else if (authresult.slow_tilde_expansion == 0) {\n                if (chrooted != 0 || guest != 0 ||\n                    (pw = getpwnam(buffer)) == NULL || pw->pw_dir == NULL) {\n                    /* try with old where = dir */\n                } else {\n                    snprintf(buffer, sizeof buffer, \"%s%s\", pw->pw_dir, dirscan);\n                    where = buffer;\n                }\n            }\n        }\n    }\n    if (checknamesanity(where, dot_read_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, where);\n        return;\n    }\n    if (chdir(where) != 0) {\n\n#ifdef WITH_DIRALIASES\n        const int real_errno = errno;\n        const char *where_alias;\n\n        if ((where_alias = lookup_alias(where)) == NULL ||\n            chdir(where_alias) != 0) {\n            errno = real_errno;\n        } else {\n            goto chdir_success;\n        }\n#endif\n\n        if (SNCHECK(snprintf(buffer, sizeof buffer,\n                             MSG_CANT_CHANGE_DIR \": %s\",\n                             dir, strerror(errno)), sizeof buffer)) {\n            _EXIT(EXIT_FAILURE);\n        }\n        logfile(LOG_INFO, \"%s\", buffer);\n        addreply(550, \"%s\", buffer);\n\n#ifndef MINIMAL\n# ifndef NO_DIRSCAN_DELAY\n        if (cwd_failures >= MAX_DIRSCAN_TRIES) {\n            _EXIT(EXIT_FAILURE);\n        }\n        usleep2(cwd_failures * DIRSCAN_FAILURE_DELAY);\n        cwd_failures++;\n# endif\n#endif\n\n        return;\n    }\n\n#ifdef WITH_DIRALIASES\n    chdir_success:\n#endif\n\n#ifndef MINIMAL\n    cwd_failures = 0UL;\n    dobanner(1);\n#endif\n    if (getcwd(wd, sizeof wd - (size_t) 1U) == NULL) {\n        if (*dir == '/') {\n            if (SNCHECK(snprintf(wd, sizeof wd, \"%s\", dir), sizeof wd)) { /* already checked */\n                _EXIT(EXIT_FAILURE);\n            }\n        } else {\n            const size_t dir_len = strlen(dir);\n            const size_t wd_len = strlen(wd);\n            if (sizeof wd < dir_len + sizeof \"/\" - 1U + wd_len + 1U) {\n                kaboom:\n                die(421, LOG_ERR, MSG_PATH_TOO_LONG);\n            }\n            strcat(strcat(wd, \"/\"), dir); /* safe, see above */\n        }\n    }\n    addreply(250, MSG_CURRENT_DIR_IS, wd);\n}\n\nunsigned int zrand(void)\n{\n    return (unsigned int) alt_arc4random();\n}\n\nstatic void keepalive(const int fd, int keep)\n{\n#ifdef SO_KEEPALIVE\n    {\n        setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &keep, sizeof keep);\n    }\n#endif\n}\n\n/* psvtype = 0: PASV */\n/* psvtype = 1: EPSV */\n\nvoid dopasv(int psvtype)\n{\n    struct sockaddr_storage dataconn;    /* my data connection endpoint */\n    unsigned long a = 0U;\n    unsigned int p;\n    int on;\n    unsigned int firstporttried;\n\n    if (loggedin == 0) {\n        addreply_noformat(530, MSG_NOT_LOGGED_IN);\n        return;\n    }\n    if (datafd != -1) {                /* for buggy clients */\n        (void) close(datafd);\n        datafd = -1;\n    }\n    fourinsix(&ctrlconn);\n    if (STORAGE_FAMILY(ctrlconn) == AF_INET6 && psvtype == 0) {\n        addreply_noformat(425, MSG_CANT_PASV);\n        return;\n    }\n    firstporttried = firstport + zrand() % (lastport - firstport + 1);\n    p = firstporttried;\n    datafd = socket(STORAGE_FAMILY(ctrlconn), SOCK_STREAM, IPPROTO_TCP);\n    if (datafd == -1) {\n        error(425, MSG_CANT_PASSIVE);\n        return;\n    }\n    on = 1;\n    if (setsockopt(datafd, SOL_SOCKET, SO_REUSEADDR,\n                   (char *) &on, sizeof on) < 0) {\n        error(421, \"setsockopt\");\n        return;\n    }\n    dataconn = ctrlconn;\n    for (;;) {\n        if (STORAGE_FAMILY(dataconn) == AF_INET6) {\n            STORAGE_PORT6(dataconn) = htons(p);\n        } else {\n            STORAGE_PORT(dataconn) = htons(p);\n        }\n        if (bind(datafd, (struct sockaddr *) &dataconn,\n                 STORAGE_LEN(dataconn)) == 0) {\n            break;\n        }\n        p--;\n        if (p < firstport) {\n            p = lastport;\n        }\n        if (p == firstporttried) {\n            (void) close(datafd);\n            datafd = -1;\n            addreply_noformat(425, MSG_PORTS_BUSY);\n            return;\n        }\n    }\n    alarm(idletime);\n    if (listen(datafd, DEFAULT_BACKLOG_DATA) < 0) {\n        (void) close(datafd);\n        datafd = -1;\n        error(425, MSG_GETSOCKNAME_DATA);\n        return;\n    }\n    switch (psvtype) {\n    case 0:\n        if (STORAGE_FAMILY(force_passive_ip) == 0) {\n            a = ntohl(STORAGE_SIN_ADDR_CONST(dataconn));\n        } else if (STORAGE_FAMILY(force_passive_ip) == AF_INET6) {\n            (void) close(datafd);\n            datafd = -1;\n            addreply_noformat(425, MSG_NO_EPSV);\n            return;\n        } else if (STORAGE_FAMILY(force_passive_ip) == AF_INET) {\n            a = ntohl(STORAGE_SIN_ADDR_CONST(force_passive_ip));\n        } else {\n            _EXIT(EXIT_FAILURE);\n        }\n\n        /* According to RFC, any message can follow 227. But broken NAT gateways\n         * and connection tracking code rely on this. So don't translate the following\n         * messages */\n\n        addreply(227, \"Entering Passive Mode (%lu,%lu,%lu,%lu,%u,%u)\",\n                 (a >> 24) & 255UL, (a >> 16) & 255UL, (a >> 8) & 255UL, a & 255UL,\n                 (p >> 8) & 255, p & 255);\n        break;\n    case 1:\n        addreply(229, \"Extended Passive mode OK (|||%u|)\", p);\n        break;\n    default:\n        _EXIT(EXIT_FAILURE);\n    }\n    passive = 1;\n}\n\nvoid doport(const char *arg)\n{\n    unsigned int a1, a2, a3, a4, p1, p2;\n    struct sockaddr_storage a;\n\n    if (sscanf(arg, \"%u,%u,%u,%u,%u,%u\",\n               &a1, &a2, &a3, &a4, &p1, &p2) != 6 ||\n        a1 > 255 || a2 > 255 || a3 > 255 || a4 > 255 ||\n        p1 > 255 || p2 > 255 || (a1|a2|a3|a4) == 0 ||\n        (p1 | p2) == 0) {\n        addreply_noformat(501, MSG_SYNTAX_ERROR_IP);\n        return;\n    }\n    memset(&a, 0, sizeof a);\n    STORAGE_FAMILY(a) = AF_INET;\n    STORAGE_SIN_ADDR(a) =\n        htonl(((uint32_t) a1 << 24) | ((uint32_t) a2 << 16) |\n              (a3 << 8) | a4);\n    SET_STORAGE_LEN(a, sizeof(struct sockaddr_in));\n    doport2(a, (p1 << 8) | p2);\n}\n\n#ifdef WITHOUT_PRIVSEP\n\nstatic int doport3(const int protocol)\n{\n    struct sockaddr_storage dataconn;  /* his endpoint */\n\n# ifndef NON_ROOT_FTP\n    static const in_port_t portlist[] = FTP_ACTIVE_SOURCE_PORTS;\n    const in_port_t *portlistpnt = portlist;\n# else\n    static const in_port_t portlist[] = { 0U };\n    const in_port_t *portlistpnt = portlist;\n# endif\n    int on;\n\n# ifndef NON_ROOT_FTP\n    disablesignals();\n    seteuid((uid_t) 0);\n# endif\n    if ((datafd = socket(protocol, SOCK_STREAM, IPPROTO_TCP)) == -1) {\n        data_socket_error:\n# ifndef NON_ROOT_FTP\n        if (seteuid(authresult.uid) != 0) {\n            _EXIT(EXIT_FAILURE);\n        }\n        enablesignals();\n# endif\n        (void) close(datafd);\n        datafd = -1;\n        error(425, MSG_CANT_CREATE_DATA_SOCKET);\n\n        return -1;\n    }\n    on = 1;\n# ifdef SO_REUSEPORT\n    (void) setsockopt(datafd, SOL_SOCKET, SO_REUSEPORT,\n                      (char *) &on, sizeof on);\n# else\n    (void) setsockopt(datafd, SOL_SOCKET, SO_REUSEADDR,\n                      (char *) &on, sizeof on);\n# endif\n    memcpy(&dataconn, &ctrlconn, sizeof dataconn);\n    for (;;) {\n        if (STORAGE_FAMILY(dataconn) == AF_INET6) {\n            STORAGE_PORT6(dataconn) = htons(*portlistpnt);\n        } else {\n            STORAGE_PORT(dataconn) = htons(*portlistpnt);\n        }\n        if (bind(datafd, (struct sockaddr *) &dataconn,\n                 STORAGE_LEN(dataconn)) == 0) {\n            break;\n        }\n# ifdef USE_ONLY_FIXED_DATA_PORT\n        (void) sleep(1U);\n# else\n        if (*portlistpnt == (in_port_t) 0U) {\n            goto data_socket_error;\n        }\n        portlistpnt++;\n# endif\n    }\n# ifndef NON_ROOT_FTP\n    if (seteuid(authresult.uid) != 0) {\n        _EXIT(EXIT_FAILURE);\n    }\n    enablesignals();\n# endif\n\n    return 0;\n}\n\n#else\n\n/* Privilege-separated version of doport3() */\n\nstatic int doport3(const int protocol)\n{\n    if ((datafd = privsep_bindresport(protocol, ctrlconn)) == -1) {\n        error(425, MSG_CANT_CREATE_DATA_SOCKET);\n\n        return -1;\n    }\n    return 0;\n}\n\n#endif\n\nvoid doport2(struct sockaddr_storage a, unsigned int p)\n{\n    if (loggedin == 0) {\n        addreply_noformat(530, MSG_NOT_LOGGED_IN);\n        return;\n    }\n    if (epsv_all != 0) {\n        addreply_noformat(501, MSG_ACTIVE_DISABLED);\n        return;\n    }\n    if (datafd != -1) {    /* for buggy clients saying PORT over and over */\n        (void) close(datafd);\n        datafd = -1;\n    }\n    if (p < 1024U) {\n        addreply_noformat(501, MSG_BAD_PORT);\n        return;\n    }\n    if (doport3(STORAGE_FAMILY(a) == AF_INET6 ? PF_INET6 : PF_INET) != 0) {\n        return;\n    }\n    peerdataport = (in_port_t) p;\n    if (addrcmp(&a, &peer) != 0) {\n        char hbuf[NI_MAXHOST];\n        char peerbuf[NI_MAXHOST];\n\n        if (getnameinfo((struct sockaddr *) &a, STORAGE_LEN(a),\n                        hbuf, sizeof hbuf, NULL,\n                        (size_t) 0U, NI_NUMERICHOST) != 0 ||\n            getnameinfo((struct sockaddr *) &peer, STORAGE_LEN(peer),\n                        peerbuf, sizeof peerbuf, NULL,\n                        (size_t) 0U, NI_NUMERICHOST) != 0) {\n            goto hu;\n        }\n        if (allowfxp == 0 || (allowfxp == 1 && guest != 0)) {\n            hu:\n            (void) close(datafd);\n            datafd = -1;\n            addreply(500, MSG_NO_FXP, hbuf, peerbuf);\n            return;\n        } else {\n            addreply(0, MSG_FXP, peerbuf, hbuf);\n            memcpy(&peer, &a, sizeof a);\n        }\n    }\n    passive = 0;\n\n    addreply_noformat(200, MSG_PORT_SUCCESSFUL);\n    return;\n}\n\nvoid closedata(void)\n{\n    volatile int tmp_xferfd = xferfd;   /* do not simplify this... */\n\n#ifdef WITH_TLS\n    tls_close_session(&tls_data_cnx);\n    tls_data_cnx = NULL;\n#endif\n    xferfd = -1;           /* ...it avoids a race */\n    (void) close(tmp_xferfd);\n}\n\nvoid opendata(void)\n{\n    struct sockaddr_storage dataconn;    /* his data connection endpoint */\n    int fd;\n    socklen_t socksize;\n\n    if (xferfd != -1) {\n        closedata();\n    }\n    if (datafd == -1) {\n        addreply_noformat(425, MSG_NO_DATA_CONN);\n        return;\n    }\n    if (passive != 0) {\n        struct pollfd pfds[2];\n        struct pollfd *pfd;\n        int pollret;\n\n        pfd = &pfds[0];\n        pfd->fd = clientfd;\n        pfd->events = POLLERR | POLLHUP;\n        pfd->revents = 0;\n\n        pfd = &pfds[1];\n        pfd->fd = datafd;\n        pfd->events = POLLIN | POLLERR | POLLHUP;\n        pfd->revents = 0;\n\n        alarm(idletime);\n        for (;;) {\n            pfds[0].revents = pfds[1].revents = 0;\n            pollret = poll(pfds, sizeof pfds / sizeof pfds[0], idletime * 1000UL);\n            if (pollret <= 0) {\n                die(421, LOG_INFO, MSG_TIMEOUT_DATA, (unsigned long) idletime);\n            }\n            if ((pfds[0].revents & (POLLERR | POLLHUP | POLLNVAL)) != 0 ||\n                (pfds[1].revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n                die(221, LOG_INFO, MSG_LOGOUT);\n            }\n            if ((pfds[1].revents & POLLIN) == 0) {\n                continue;\n            }\n            socksize = (socklen_t) sizeof(dataconn);\n            memset(&dataconn, 0, sizeof dataconn);\n            if ((fd = accept(datafd, (struct sockaddr *) &dataconn,\n                             &socksize)) == -1) {\n                nope:\n                (void) close(datafd);\n                datafd = -1;\n                error(421, MSG_ACCEPT_FAILED);\n                return;\n            }\n            if (STORAGE_FAMILY(dataconn) != AF_INET\n                && STORAGE_FAMILY(dataconn) != AF_INET6) {\n                (void) close(fd);\n                goto nope;\n            }\n            fourinsix(&dataconn);\n            if (addrcmp(&peer, &dataconn) == 0) {\n                break;\n            }\n            if (allowfxp == 0 || (allowfxp == 1 && guest != 0)) {\n                shutdown(fd, 2);\n                (void) close(fd);\n            } else {\n                break;\n            }\n        }\n        addreply_noformat(150, MSG_ACCEPT_SUCCESS);\n    } else {\n        struct sockaddr_storage peer2;\n        unsigned long tries = 1UL + idletime / 2UL;\n\n        peer2 = peer;\n        if (STORAGE_FAMILY(peer) == AF_INET6) {\n            STORAGE_PORT6(peer2) = htons(peerdataport);\n        } else {\n            STORAGE_PORT(peer2) = htons(peerdataport);\n        }\n        again:\n        if (connect(datafd, (struct sockaddr *) &peer2,\n                    STORAGE_LEN(peer2)) != 0) {\n            if ((errno == EAGAIN || errno == EINTR\n#ifdef EADDRINUSE\n                 || errno == EADDRINUSE\n#endif\n                 ) && tries > 0UL) {\n                tries--;\n                usleep2(1000000UL);\n                goto again;\n            }\n            addreply(425, MSG_CNX_PORT_FAILED \": %s\",\n                     peerdataport, strerror(errno));\n            (void) close(datafd);\n            datafd = -1;\n            return;\n        }\n        fd = datafd;\n        datafd = -1;\n        addreply(150, MSG_CNX_PORT, peerdataport);\n    }\n\n    {\n        int fodder;\n#ifdef IPTOS_THROUGHPUT\n        fodder = IPTOS_THROUGHPUT;\n        setsockopt(fd, SOL_IP, IP_TOS, (char *) &fodder, sizeof fodder);\n#endif\n#ifndef NO_KEEPALIVE\n        keepalive(fd, 1);\n#endif\n    }\n    xferfd = fd;\n    alarm(MAX_SESSION_XFER_IDLE);\n}\n\n#ifndef MINIMAL\nvoid dochmod(char *name, mode_t mode)\n{\n    static dev_t root_st_dev;\n    static ino_t root_st_ino;\n    struct stat st2;\n    int fd = -1;\n\n    if (nochmod != 0 && authresult.uid != (uid_t) 0) {\n        addreply(550, MSG_CHMOD_FAILED, name);\n        return;\n    }\n# ifndef ANON_CAN_CHANGE_PERMS\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_CHANGE_PERMS);\n        return;\n    }\n# endif\n    if (name == NULL || *name == 0) {\n        addreply_noformat(501, MSG_NO_FILE_NAME);\n        return;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        return;\n    }\n    fd = open(name, O_RDONLY);\n    if (fd == -1) {\n        goto failure;\n    }\n    if ((root_st_dev | root_st_ino) == 0) {\n        struct stat st;\n\n        if (stat(\"/\", &st) != 0) {\n            goto failure;\n        }\n        root_st_dev = st.st_dev;\n        root_st_ino = st.st_ino;\n    }\n    if (fstat(fd, &st2) != 0) {\n        goto failure;\n    }\n# ifdef QUOTAS\n    if (hasquota() == 0 && S_ISDIR(st2.st_mode)) {\n        mode |= 0500;\n    }\n# endif\n    if (st2.st_ino == root_st_ino && st2.st_dev == root_st_dev) {\n        mode |= 0700;\n    } else if (be_customer_proof != 0) {\n        mode |= (S_ISDIR(st2.st_mode) ? 0700 : 0600);\n    }\n    if (fchmod(fd, mode) < 0 && chmod(name, mode) < 0) {\n        failure:\n        if (fd != -1) {\n            (void) close(fd);\n        }\n        addreply(550, MSG_CHMOD_FAILED \": %s\", name, strerror(errno));\n        return;\n    }\n    (void) close(fd);\n    addreply(200, MSG_CHMOD_SUCCESS, name);\n}\n\nvoid doutime(char *name, const char * const wanted_time)\n{\n    struct tm tm;\n    time_t ts;\n    struct utimbuf tb;\n\n# ifndef ANON_CAN_CHANGE_UTIME\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_CHANGE_PERMS);\n        return;\n    }\n# endif\n    if (name == NULL || *name == 0) {\n        addreply_noformat(501, MSG_NO_FILE_NAME);\n        return;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        return;\n    }\n    memset(&tm, 0, sizeof tm);\n    sscanf(wanted_time, \"%4d%2d%2d%2d%2d%2d\", &tm.tm_year, &tm.tm_mon,\n           &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec);\n    tm.tm_mon--;\n    tm.tm_year -= 1900;\n# ifdef USE_LOCAL_TIME_FOR_SITE_UTIME\n    ts = mktime(&tm);\n# else\n#  ifdef HAVE_TIMEGM\n    ts = timegm(&tm);\n#  elif defined(HAVE_PUTENV)\n    {\n        putenv(\"TZ=UTC+00:00\");\n#   ifdef HAVE_TZSET\n        tzset();\n#   endif\n        ts = mktime(&tm);\n        putenv(default_tz_for_putenv);\n        tzset();\n    }\n#  else\n    ts = mktime(&tm);\n#  endif\n# endif\n    if (tm.tm_mon < 0 || tm.tm_year <= 0 || ts == (time_t) -1) {\n        addreply_noformat(501, MSG_TIMESTAMP_FAILURE);\n        return;\n    }\n    tb.actime = tb.modtime = ts;\n    if (utime(name, &tb) < 0) {\n        addreply(550, \"utime(%s): %s\", name, strerror(errno));\n    } else {\n        addreply_noformat(213, \"UTIME OK\");\n    }\n}\n#endif\n\nvoid dodele(char *name)\n{\n#ifndef ANON_CAN_DELETE\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_DELETE);\n        return;\n    }\n#endif\n    if (name == NULL || *name == 0) {\n        addreply_noformat(501, MSG_NO_FILE_NAME);\n        return;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        return;\n    }\n    if (keepallfiles != 0) {\n#ifdef EPERM\n        errno = EPERM;\n#else\n        errno = 1;\n#endif\n        goto denied;\n    }\n\n    /*\n     * What we do here may look a bit strange. It's to defend against\n     * change-after-stat attacks. If we simply do lstat(name), then unlink(name)\n     * there's a race. An attacker can rename the file between these two\n     * system calls, so that a big file is lstat()ed, but a dummy tiny file is\n     * unlinked. That way, an attacker could easily get extra quota.\n     * To defend against this attack, we rename the file to an unique dot-file\n     * (an atomic operation) . People subject to quotas can't access dot-files.\n     * So we can securely stat it and unlink it. Having the pid in the file\n     * name should be enough to avoid that two concurrent sessions create the\n     * same temporary file. But to be paranoid to the extreme, we add some\n     * random number to that.\n     */\n\n#ifdef QUOTAS\n    {\n        char *p;\n        struct stat st;\n        struct stat st2;\n        size_t dirlen = (size_t) 0U;\n        char qtfile[PATH_MAX + 1];\n\n        if ((p = strrchr(name, '/')) != NULL) {\n            if ((dirlen = p - name + (size_t) 1U) >= sizeof qtfile) {\n                goto denied;       /* should never happen */\n            }\n            memcpy(qtfile, name, dirlen);   /* safe, dirlen < sizeof qtfile */\n        }\n        if (SNCHECK(snprintf(qtfile + dirlen, sizeof qtfile - dirlen,\n                             PUREFTPD_TMPFILE_PREFIX \"rename.%lu.%x\",\n                             (unsigned long) getpid(), zrand()),\n                    sizeof qtfile)) {\n            goto denied;\n        }\n        if (lstat(name, &st) != 0) {\n            goto denied;\n        }\n        if (!S_ISREG(st.st_mode)\n# ifndef NEVER_DELETE_SYMLINKS\n            && !S_ISLNK(st.st_mode)\n# endif\n            ) {\n# ifdef EINVAL\n            errno = EINVAL;\n# endif\n            goto denied;\n        }\n        if (rename(name, qtfile) != 0) {\n            goto denied;\n        }\n        if (lstat(qtfile, &st2) != 0 ||\n            st.st_dev != st2.st_dev ||\n            st.st_ino != st2.st_ino ||\n            st.st_size != st2.st_size) {\n# ifdef EINVAL\n            errno = EINVAL;\n# endif\n            goto denied;\n        }\n        if (unlink(qtfile) < 0) {\n            /*\n             * Race if rename() goes to an existing file.\n             * seems very difficult to exploit, though.\n             * Does a perfect userland answer exist, after all?\n             */\n            (void) rename(qtfile, name);\n            goto denied;\n        }\n        {\n            Quota quota;\n\n            if (quota_update(&quota, -1LL,\n                             -((long long) st.st_size), NULL) == 0) {\n                displayquota(&quota);\n            }\n        }\n    }\n#else\n    if (unlink(name) < 0) {\n        goto denied;\n    }\n#endif\n    addreply(250, MSG_DELE_SUCCESS, \"\", \"\", \"\", name);\n    logfile(LOG_NOTICE, MSG_DELE_SUCCESS, root_directory,\n            *name == '/' ? \"\" : wd,\n            (*name != '/' && (!*wd || wd[strlen(wd) - 1] != '/'))\n            ? \"/\" : \"\", name);\n    return;\n\n    denied:\n    addreply(550, MSG_DELE_FAILED \": %s\", name, strerror(errno));\n}\n\nstatic double get_usec_time(void)\n{\n    struct timeval tv;\n    struct timezone tz;\n\n    if (gettimeofday(&tv, &tz) < 0) {\n        return 0.0;\n    }\n    return (double) tv.tv_sec + ((double) tv.tv_usec) / 1000000.0;\n}\n\nstatic void displayrate(const char *word, off_t size,\n                        const double started,\n                        const char * const name, int up)\n{\n    double ended;\n    double t;\n    double speed;\n    char speedstring[64];\n\n    ended = get_usec_time();\n\n    t = ended - started;\n    if (t > 0.0 && size > (off_t) 0) {\n        speed = size / t;\n    } else {\n        speed = 0.0;\n    }\n    if (speed > 524288.0) {\n        addreply(0, MSG_TRANSFER_RATE_M, t, speed / 1048576.0);\n    } else if (speed > 512.0) {\n        addreply(0, MSG_TRANSFER_RATE_K, t, speed / 1024.0);\n    } else if (speed > 0.1) {\n        addreply(0, MSG_TRANSFER_RATE_B, t, speed);\n    }\n    if (!SNCHECK(snprintf(speedstring, sizeof speedstring,\n                          \" (%llu bytes, %.2fKB/sec)\",\n                          (unsigned long long) size, speed / 1024.0),\n                 sizeof speedstring)) {\n        logfile(LOG_NOTICE, \"%s%s%s%s %s %s\", root_directory,\n                *name == '/' ? \"\" : wd,\n                (*name != '/' && (!*wd || wd[strlen(wd) - 1] != '/'))\n                ? \"/\" : \"\", name, word, speedstring);\n    }\n    /* Tons of #ifdef here, but it avoids a pointless call to realpath() */\n#if defined(WITH_UPLOAD_SCRIPT) || defined(WITH_ALTLOG)\n    if (\n# ifdef WITH_ALTLOG\n        altlog_format != ALTLOG_NONE\n# endif\n# if defined(WITH_UPLOAD_SCRIPT) && defined(WITH_ALTLOG)\n        ||\n# endif\n# if (defined(WITH_UPLOAD_SCRIPT))\n        (do_upload_script != 0 && up != 0)\n# endif\n        )\n    {\n        char *alloca_filename_real;\n        const size_t sizeof_filename_real = PATH_MAX + VHOST_PREFIX_MAX_LEN;\n        char *resolved_path;\n        const size_t sizeof_resolved_path = PATH_MAX + 1U;\n\n        if ((resolved_path = malloc(sizeof_resolved_path)) == NULL) {\n            return;\n        }\n        resolved_path[sizeof_resolved_path - 1U] = 0;\n        if (realpath(name, resolved_path) == NULL) {\n            if (up != 0) {\n                (void) unlink(name);\n            }\n            free(resolved_path);\n            logfile(LOG_ERR, \"realpath() failure : [%s] => [%s]\",\n                    name, strerror(errno));\n            return;\n        }\n        if (resolved_path[sizeof_resolved_path - 1U] != 0) {\n            for (;;) {\n                *resolved_path++ = 0;\n            }\n        }\n        if ((alloca_filename_real = ALLOCA(sizeof_filename_real)) == NULL) {\n            free(resolved_path);\n            return;\n        }\n# ifdef WITH_VIRTUAL_CHROOT\n        if (SNCHECK(snprintf(alloca_filename_real, sizeof_filename_real,\n                             \"\\001%s\", resolved_path), sizeof_filename_real)) {\n            goto rp_failure;\n        }\n# else\n        if (SNCHECK(snprintf(alloca_filename_real, sizeof_filename_real,\n                             \"\\001%s%s\", root_directory,\n                             (*resolved_path == '/' ? resolved_path + 1 :\n                              resolved_path)), sizeof_filename_real)) {\n            goto rp_failure;\n        }\n# endif\n# ifdef WITH_ALTLOG\n        (void) altlog_writexfer(up, alloca_filename_real + 1, size, t);\n# endif\n# if defined(WITH_UPLOAD_SCRIPT)\n        if (do_upload_script != 0 && up != 0) {\n            upload_pipe_push(account, alloca_filename_real);\n        }\n# endif\n        rp_failure:\n        free(resolved_path);\n        ALLOCA_FREE(alloca_filename_real);\n    }\n#else\n    (void) up;\n#endif\n}\n\nstatic void displayopenfailure(const char * const name)\n{\n    char buffer[PATH_MAX + 42U];\n    const int e = errno;\n\n    if (SNCHECK(snprintf(buffer, sizeof buffer, MSG_OPEN_FAILURE, name),\n                sizeof buffer)) {\n        _EXIT(EXIT_FAILURE);\n    }\n    errno = e;\n    error(550, buffer);\n}\n\nstatic int dlhandler_throttle(DLHandler * const dlhandler,\n                              const off_t downloaded, const double ts_start,\n                              double *required_sleep)\n{\n    double ts_now;\n    double elapsed;\n    off_t would_be_downloaded;\n    double wanted_ts;\n    off_t previous_chunk_size;\n\n    if (dlhandler->bandwidth <= 0UL || downloaded <= (off_t) 0) {\n        *required_sleep = 0.0;\n        return 0;\n    }\n    if ((ts_now = get_usec_time()) <= 0.0) {\n        ts_now = ts_start;\n    }\n    if (ts_start > ts_now) {\n        ts_now = ts_start;\n    }\n    elapsed = ts_now - ts_start;\n    would_be_downloaded = dlhandler->total_downloaded + dlhandler->chunk_size;\n    if (dlhandler->bandwidth > 0UL) {\n        wanted_ts = (double) would_be_downloaded /\n            (double) dlhandler->bandwidth;\n    } else {\n        wanted_ts = elapsed;\n    }\n    *required_sleep = wanted_ts - elapsed;\n    previous_chunk_size = dlhandler->chunk_size;\n    if (dlhandler->total_downloaded <= dlhandler->chunk_size) {\n        return 0;\n    }\n    if (*required_sleep < dlhandler->min_sleep) {\n        dlhandler->chunk_size =\n            (dlhandler->max_chunk_size + dlhandler->chunk_size) / 2;\n    } else if (*required_sleep > dlhandler->max_sleep) {\n        dlhandler->chunk_size =\n            (dlhandler->min_chunk_size + dlhandler->chunk_size) / 2;\n    } else {\n        dlhandler->chunk_size = dlhandler->default_chunk_size;\n    }\n    if (dlhandler->chunk_size <= 0 || dlhandler->chunk_size > INT_MAX) {\n        dlhandler->chunk_size = dlhandler->default_chunk_size;\n    }\n    if (previous_chunk_size != dlhandler->default_chunk_size) {\n        would_be_downloaded =\n            dlhandler->total_downloaded + dlhandler->chunk_size;\n        if (dlhandler->bandwidth > 0UL) {\n            wanted_ts = (double) would_be_downloaded /\n                (double) dlhandler->bandwidth;\n        } else {\n            wanted_ts = elapsed;\n        }\n        *required_sleep = wanted_ts - elapsed;\n    }\n    return 0;\n}\n\nstatic int dlhandler_init(DLHandler * const dlhandler,\n                          const int clientfd, void * const tls_clientfd,\n                          const int xferfd,\n                          const char * const name,\n                          const int f, void * const tls_fd,\n                          const off_t restartat,\n                          const int ascii_mode,\n                          const unsigned long bandwidth)\n{\n    struct stat st;\n    struct pollfd *pfd;\n\n    if (fstat(f, &st) < 0 || (S_ISLNK(st.st_mode) && stat(name, &st) < 0)) {\n        error(451, MSG_STAT_FAILURE);\n        return -1;\n    }\n    if (!S_ISREG(st.st_mode)) {\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n        return -1;\n    }\n    dlhandler->clientfd = clientfd;\n    dlhandler->tls_clientfd = tls_clientfd;\n    dlhandler->xferfd = xferfd;\n    dlhandler->f = f;\n    dlhandler->tls_fd = tls_fd;\n    dlhandler->file_size = st.st_size;\n    dlhandler->ascii_mode = ascii_mode;\n    dlhandler->cur_pos = restartat;\n    dlhandler->total_downloaded = (off_t) 0;\n    dlhandler->min_sleep = 0.1;\n    dlhandler->max_sleep = 5.0;\n    dlhandler->bandwidth = bandwidth;\n    pfd = &dlhandler->pfds_f_in;\n    pfd->fd = clientfd;\n#ifdef __APPLE_CC__\n    pfd->events = POLLRDBAND | POLLPRI | POLLERR | POLLHUP;\n#else\n    pfd->events = POLLIN | POLLPRI | POLLERR | POLLHUP;\n#endif\n    pfd->revents = 0;\n\n    if (restartat > (off_t) 0) {\n        if (restartat == st.st_size) {\n            addreply_noformat(226, MSG_NO_MORE_TO_DOWNLOAD);\n            return -2;\n        } else if (restartat > st.st_size) {\n            addreply(554, MSG_REST_TOO_LARGE_FOR_FILE \"\\n\" MSG_REST_RESET,\n                     (long long) restartat, (long long) st.st_size);\n            return -1;\n        }\n    }\n    if (fcntl(xferfd, F_SETFL, fcntl(xferfd, F_GETFL) | O_NONBLOCK) == -1) {\n        error(451, \"fcntl(F_SETFL, O_NONBLOCK)\");\n        return -1;\n    }\n    return 0;\n}\n\nstatic int dlmap_init(DLHandler * const dlhandler, const int clientfd,\n                      void * const tls_clientfd, const int xferfd,\n                      const char * const name, const int f,\n                      void * const tls_fd, const off_t restartat,\n                      const int ascii_mode, const unsigned long bandwidth)\n{\n    if (ascii_mode > 0) {\n#ifdef WITHOUT_ASCII\n        addreply_noformat(450, MSG_ASCII_MODE_UNSUPPORTED);\n        return -1;\n#else\n        addreply_noformat(0, MSG_ASCII_MODE_WARNING);\n#endif\n    }\n    if (dlhandler_init(dlhandler, clientfd, tls_clientfd, xferfd, name, f,\n                       tls_fd, restartat, ascii_mode, bandwidth) != 0) {\n        return -1;\n    }\n    dlhandler->min_chunk_size = DL_MIN_CHUNK_SIZE;\n    if (ascii_mode > 0) {\n        dlhandler->default_chunk_size = dlhandler->max_chunk_size =\n            DL_DEFAULT_CHUNK_SIZE_ASCII;\n    } else {\n        dlhandler->max_chunk_size = DL_MAX_CHUNK_SIZE;\n        if (bandwidth <= 0UL) {\n            dlhandler->default_chunk_size = dlhandler->max_chunk_size;\n        } else {\n            dlhandler->default_chunk_size = DL_DEFAULT_CHUNK_SIZE;\n        }\n    }\n    dlhandler->chunk_size = dlhandler->default_chunk_size;\n    dlhandler->dlmap_size =\n        (DL_DLMAP_SIZE + page_size - (size_t) 1U) & ~(page_size - (size_t) 1U);\n    dlhandler->cur_pos = restartat;\n    dlhandler->dlmap_pos = (off_t) 0;\n    dlhandler->dlmap_fdpos = (off_t) -1;\n    dlhandler->sizeof_map = (size_t) 0U;\n    dlhandler->map_data = NULL;\n    dlhandler->sizeof_map = dlhandler->dlmap_size;\n    dlhandler->map = malloc(dlhandler->sizeof_map);\n    if (dlhandler->map == NULL) {\n        die_mem();\n    }\n    return 0;\n}\n\nstatic int _dlmap_read(DLHandler * const dlhandler)\n{\n    ssize_t readnb;\n\n    if (dlhandler->dlmap_size > dlhandler->sizeof_map) {\n        abort();\n    }\n    if (dlhandler->dlmap_size <= (size_t) 0U) {\n        return 0;\n    }\n    if (dlhandler->dlmap_pos != dlhandler->dlmap_fdpos) {\n        do {\n            if (lseek(dlhandler->f, dlhandler->dlmap_pos,\n                      SEEK_SET) == (off_t) -1) {\n                dlhandler->dlmap_fdpos = (off_t) -1;\n                return -1;\n            }\n            dlhandler->dlmap_fdpos = dlhandler->dlmap_pos;\n            readnb = read(dlhandler->f, dlhandler->map, dlhandler->dlmap_size);\n        } while (readnb == (ssize_t) -1 && errno == EINTR);\n    } else {\n        do {\n            readnb = read(dlhandler->f, dlhandler->map, dlhandler->dlmap_size);\n        } while (readnb == (ssize_t) -1 && errno == EINTR);\n    }\n    if (readnb <= (ssize_t) 0) {\n        dlhandler->dlmap_fdpos = (off_t) -1;\n        return -1;\n    }\n    if (readnb != (ssize_t) dlhandler->dlmap_size) {\n        dlhandler->dlmap_fdpos = (off_t) -1;\n    } else {\n        dlhandler->dlmap_fdpos += (off_t) readnb;\n    }\n    return 0;\n}\n\nstatic int _dlmap_remap(DLHandler * const dlhandler)\n{\n    size_t min_dlmap_size;\n    off_t remaining;\n\n    if (dlhandler->map_data != NULL) {\n        if (dlhandler->cur_pos >= dlhandler->dlmap_pos &&\n            dlhandler->cur_pos + dlhandler->chunk_size <=\n            dlhandler->dlmap_pos + (off_t) dlhandler->dlmap_size) {\n            if (dlhandler->cur_pos < dlhandler->dlmap_pos ||\n                dlhandler->cur_pos - dlhandler->dlmap_pos >\n                (off_t) dlhandler->dlmap_size) {\n                addreply_noformat(451, \"remap\");\n                return -1;\n            }\n            dlhandler->map_data =\n                dlhandler->map + dlhandler->cur_pos - dlhandler->dlmap_pos;\n            return 0;\n        }\n    }\n    if (dlhandler->file_size - dlhandler->cur_pos < dlhandler->chunk_size) {\n        dlhandler->chunk_size = dlhandler->file_size - dlhandler->cur_pos;\n    }\n    if (dlhandler->chunk_size <= 0) {\n        return 1;\n    }\n    dlhandler->dlmap_pos = dlhandler->cur_pos;\n    min_dlmap_size = dlhandler->chunk_size;\n    if (dlhandler->dlmap_size < min_dlmap_size) {\n        dlhandler->dlmap_size = min_dlmap_size;\n    }\n    dlhandler->dlmap_size = (dlhandler->dlmap_size + page_size - (size_t) 1U) &\n        ~(page_size - (size_t) 1U);\n    if (dlhandler->dlmap_size < page_size) {\n        dlhandler->dlmap_size = page_size;\n    }\n    remaining = dlhandler->file_size - dlhandler->dlmap_pos;\n    if ((off_t) dlhandler->dlmap_size > remaining) {\n        dlhandler->dlmap_size = (off_t) remaining;\n    }\n    if (_dlmap_read(dlhandler) != 0) {\n        error(451, MSG_DATA_READ_FAILED);\n        return -1;\n    }\n    dlhandler->map_data = dlhandler->map;\n\n    return 0;\n}\n\nstatic int dl_dowrite(DLHandler * const dlhandler, const unsigned char *buf_,\n                      const size_t size_, off_t * const downloaded)\n{\n    size_t size = size_;\n    const unsigned char *buf = buf_;\n    unsigned char *asciibuf = NULL;\n    int ret = 0;\n\n    if (size_ <= (size_t) 0U) {\n        *downloaded = 0;\n        return -1;\n    }\n#ifndef WITHOUT_ASCII\n    if (dlhandler->ascii_mode > 0) {\n        unsigned char *asciibufpnt;\n        size_t z = (size_t) 0U;\n\n        if (size > (size_t) dlhandler->chunk_size ||\n            (asciibuf = ALLOCA((size_t) dlhandler->chunk_size * 2U)) == NULL) {\n            return -1;\n        }\n        asciibufpnt = asciibuf;\n        do {\n            if (buf_[z] == (unsigned char) '\\n') {\n                *asciibufpnt++ = (unsigned char) '\\r';\n            }\n            *asciibufpnt++ = buf_[z];\n            z++;\n        } while (z < size);\n        buf = asciibuf;\n        size = (size_t) (asciibufpnt - asciibuf);\n    }\n#endif\n    ret = safe_nonblock_write(dlhandler->xferfd, dlhandler->tls_fd, buf, size);\n    if (asciibuf != NULL) {\n        ALLOCA_FREE(asciibuf);\n    }\n    if (ret < 0) {\n        *downloaded = 0;\n    } else {\n        *downloaded = size;\n    }\n    return ret;\n}\n\nstatic int dlhandler_handle_commands(DLHandler * const dlhandler,\n                                     const double required_sleep)\n{\n    int pollret;\n    char buf[100];\n    char *bufpnt;\n    ssize_t readnb;\n\n    repoll:\n    dlhandler->pfds_f_in.revents = 0;\n    pollret = poll(&dlhandler->pfds_f_in, 1U,\n                   required_sleep <= 0.0 ?\n                   0 : (int) (required_sleep * 1000.0));\n    if (pollret <= 0) {\n        return pollret;\n    }\n    if ((dlhandler->pfds_f_in.revents & (POLLIN | POLLPRI)) != 0) {\n        if (dlhandler->tls_clientfd != NULL) {\n#ifdef WITH_TLS\n            readnb = SSL_read(dlhandler->tls_clientfd, buf,\n                              sizeof buf - (size_t) 1U);\n#else\n            abort();\n#endif\n        } else {\n            readnb = read(dlhandler->clientfd, buf, sizeof buf - (size_t) 1U);\n        }\n        if (readnb == (ssize_t) 0) {\n            return -2;\n        }\n        if (readnb < (ssize_t) 0) {\n            if (errno == EAGAIN || errno == EINTR) {\n                return 0;\n            }\n            return -1;\n        }\n        buf[readnb] = 0;\n        bufpnt = skip_telnet_controls(buf);\n        if (strchr(bufpnt, '\\n') != NULL) {\n            if (strncasecmp(bufpnt, \"ABOR\", sizeof \"ABOR\" - 1U) != 0 &&\n                strncasecmp(bufpnt, \"QUIT\", sizeof \"QUIT\" - 1U) != 0) {\n                addreply_noformat(500, MSG_UNKNOWN_COMMAND);\n                doreply();\n            } else {\n                addreply_noformat(426, \"ABORT\");\n                doreply();\n                addreply_noformat(226, MSG_ABORTED);\n                return 1;\n            }\n        }\n        if (required_sleep > 0.0) {\n            goto repoll;\n        }\n    } else if ((dlhandler->pfds_f_in.revents &\n                (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n        addreply_noformat(451, MSG_DATA_READ_FAILED);\n        return 1;\n    }\n    return 0;\n}\n\nstatic int dlmap_send(DLHandler * const dlhandler)\n{\n    int ret;\n    double ts_start = 0.0;\n    double required_sleep;\n    off_t downloaded;\n\n    if (dlhandler->bandwidth > 0UL && (ts_start = get_usec_time()) <= 0.0) {\n        error(451, \"gettimeofday()\");\n        return -1;\n    }\n    required_sleep = 0.0;\n    for (;;) {\n        ret = _dlmap_remap(dlhandler);\n        if (ret < 0) {\n            return -1;\n        }\n        if (ret == 1) {\n            break;\n        }\n        if (dl_dowrite(dlhandler, dlhandler->map_data, dlhandler->chunk_size,\n                       &downloaded) != 0) {\n            return -1;\n        }\n        dlhandler->cur_pos += dlhandler->chunk_size;\n#ifdef FTPWHO\n        if (shm_data_cur != NULL) {\n            shm_data_cur->download_current_size = dlhandler->cur_pos;\n        }\n#endif\n        dlhandler->total_downloaded += downloaded;\n        required_sleep = 0.0;\n        if (dlhandler->bandwidth > 0UL) {\n            dlhandler_throttle(dlhandler, downloaded, ts_start,\n                               &required_sleep);\n        }\n        ret = dlhandler_handle_commands(dlhandler, required_sleep);\n        if (ret != 0) {\n            return ret;\n        }\n    }\n    return 0;\n}\n\nstatic int dlmap_exit(DLHandler * const dlhandler)\n{\n    if (dlhandler->map != NULL) {\n        free(dlhandler->map);\n        dlhandler->map = NULL;\n        dlhandler->sizeof_map = (size_t) 0U;\n        dlhandler->dlmap_size = (size_t) 0U;\n    }\n    return 0;\n}\n\nvoid doretr(char *name)\n{\n    DLHandler dlhandler;\n    int f;\n    struct stat st;\n    double started = 0.0;\n    int ret;\n\n    dlhandler.total_downloaded = 0;\n    if (!candownload) {\n        addreply(550, MSG_LOAD_TOO_HIGH, load);\n        goto end;\n    }\n    if (type < 1 || (type == 1 && restartat > (off_t) 1)) {\n        addreply_noformat(503, MSG_NO_ASCII_RESUME);\n        goto end;\n    }\n    if (checknamesanity(name, dot_read_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        goto end;\n    }\n    if ((f = open(name, O_RDONLY)) == -1) {\n        displayopenfailure(name);\n        goto end;\n    }\n    if (fstat(f, &st) < 0) {\n        stat_failure:\n        (void) close(f);\n        error(451, MSG_STAT_FAILURE);\n        goto end;\n    }\n    if (S_ISLNK(st.st_mode)) {\n        if (stat(name, &st) < 0) {\n            goto stat_failure;\n        }\n    }\n    if (restartat > st.st_size) {\n        (void) close(f);\n        addreply(554, MSG_REST_TOO_LARGE_FOR_FILE \"\\n\" MSG_REST_RESET,\n                 (long long) restartat, (long long) st.st_size);\n        goto end;\n    }\n    if (!S_ISREG(st.st_mode) || ((off_t) st.st_size != st.st_size)) {\n        (void) close(f);\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n        goto end;\n    }\n    if (warez != 0 && st.st_uid == warez && guest != 0) {\n        (void) close(f);\n        addreply(550, MSG_NOT_MODERATED);\n        goto end;\n    }\n#ifdef RATIOS\n    if (ratio_upload > 0U && ratio_download > 0U) {\n        if ((downloaded + st.st_size - restartat) / ratio_download >\n            (uploaded / ratio_upload)) {\n            (void) close(f);\n            addreply(550, MSG_RATIO_DENIAL, ratio_upload, ratio_download,\n                     (unsigned long long) uploaded / 1024ULL,\n                     (unsigned long long) downloaded / 1024ULL);\n            goto end;\n        }\n    }\n#endif\n    opendata();\n    if (xferfd == -1) {\n        (void) close(f);\n        goto end;\n    }\n#ifndef DISABLE_HUMOR\n    if ((time(NULL) % 100) == 0) {\n        addreply_noformat(0, MSG_WINNER);\n    }\n#endif\n    if (st.st_size - restartat > 4096) {\n        addreply(0, MSG_KBYTES_LEFT, (double) ((st.st_size - restartat) / 1024.0));\n    }\n    doreply();\n# ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n    }\n# endif\n    state_needs_update = 1;\n    setprocessname(\"pure-ftpd (DOWNLOAD)\");\n\n#ifdef FTPWHO\n    if (shm_data_cur != NULL) {\n        const size_t sl = strlen(name);\n\n        ftpwho_lock();\n        shm_data_cur->state = FTPWHO_STATE_DOWNLOAD;\n        shm_data_cur->download_total_size = st.st_size;\n        shm_data_cur->download_current_size = restartat;\n        shm_data_cur->restartat = restartat;\n        (void) time(&shm_data_cur->xfer_date);\n        if (sl < sizeof shm_data_cur->filename) {\n            memcpy(shm_data_cur->filename, name, sl);\n            shm_data_cur->filename[sl] = 0;\n        } else {\n            memcpy(shm_data_cur->filename,\n                   &name[sl - sizeof shm_data_cur->filename - 1U],\n                   sizeof shm_data_cur->filename);\n        }\n        ftpwho_unlock();\n    }\n#endif\n#ifdef HAVE_POSIX_FADVISE\n    (void) posix_fadvise(f, (off_t) 0, st.st_size, POSIX_FADV_SEQUENTIAL);\n#endif\n\n    started = get_usec_time();\n\n    if (dlmap_init(&dlhandler, clientfd, tls_cnx, xferfd, name, f,\n                   tls_data_cnx, restartat, type == 1,\n                   throttling_bandwidth_dl) == 0) {\n        ret = dlmap_send(&dlhandler);\n        dlmap_exit(&dlhandler);\n    } else {\n        ret = -1;\n    }\n\n    (void) close(f);\n    closedata();\n    if (ret == 0) {\n        addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);\n    }\n    downloaded += dlhandler.total_downloaded;\n    displayrate(MSG_DOWNLOADED, dlhandler.total_downloaded, started, name, 0);\n\n    end:\n    restartat = (off_t) 0;\n}\n\nvoid dorest(const char *name)\n{\n    char *endptr;\n\n    restartat = (off_t) strtoull(name, &endptr, 10);\n    if (*endptr != 0 || restartat < (off_t) 0) {\n        restartat = 0;\n        addreply(554, MSG_REST_NOT_NUMERIC \"\\n\" MSG_REST_RESET);\n    } else {\n        if (type == 1 && restartat != 0) {\n#ifdef STRICT_REST\n            addreply_noformat(504, MSG_REST_ASCII_STRICT);\n#else\n            addreply(350, MSG_REST_ASCII_WORKAROUND,\n                     (long long) restartat);\n#endif\n        } else {\n            if (restartat != 0) {\n                logfile(LOG_NOTICE, MSG_REST_SUCCESS, (long long) restartat);\n            }\n            addreply(350, MSG_REST_SUCCESS, (long long) restartat);\n        }\n    }\n}\n\nvoid domkd(char *name)\n{\n#ifdef QUOTAS\n    Quota quota;\n    int overflow;\n#endif\n\n    if (guest != 0 && allow_anon_mkdir == 0) {\n        addreply_noformat(550, MSG_ANON_CANT_MKD);\n        return;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply_noformat(553, MSG_SANITY_DIRECTORY_FAILURE);\n        return;\n    }\n#ifdef QUOTAS\n    if (quota_update(&quota, 1LL, 0LL, &overflow) == 0 && overflow != 0) {\n        (void) quota_update(&quota, -1LL, 0LL, NULL);\n        addreply(552, MSG_QUOTA_EXCEEDED, name);\n        goto end;\n    }\n#endif\n    if ((mkdir(name, (mode_t) (0777 & ~u_mask_d))) < 0) {\n#ifdef QUOTAS\n        (void) quota_update(&quota, -1LL, 0LL, NULL);\n#endif\n        error(550, MSG_MKD_FAILURE);\n    } else {\n        addreply(257, \"\\\"%s\\\" : \" MSG_MKD_SUCCESS, name);\n#ifndef MINIMAL\n        cwd_failures = 0UL;\n#endif\n    }\n#ifdef QUOTAS\n    end:\n    displayquota(&quota);\n#endif\n}\n\nvoid dormd(char *name)\n{\n#ifdef QUOTAS\n    Quota quota;\n#endif\n\n#ifndef ANON_CAN_DELETE\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_RMD);\n        return;\n    }\n#endif\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply_noformat(553, MSG_SANITY_DIRECTORY_FAILURE);\n        return;\n    }\n    if ((rmdir(name)) < 0) {\n        error(550, MSG_RMD_FAILURE);\n    } else {\n#ifdef QUOTAS\n        if (quota_update(&quota, -1LL, 0LL, NULL) == 0) {\n            displayquota(&quota);\n        }\n#endif\n        addreply_noformat(250, MSG_RMD_SUCCESS);\n    }\n}\n\n#ifndef MINIMAL\nvoid dofeat(void)\n{\n# define FEAT  \"Extensions supported:\" CRLF \\\n    \" UTF8\" CRLF \\\n    \" EPRT\" CRLF \" IDLE\" CRLF \" MDTM\" CRLF \" SIZE\" CRLF \" MFMT\" CRLF \\\n    \" REST STREAM\" CRLF \\\n    \" MLST type*;size*;sizd*;modify*;UNIX.mode*;UNIX.uid*;UNIX.gid*;unique*;\" CRLF \\\n    \" MLSD\" CRLF \\\n    \" PRET\"\n\n# ifdef WITH_TLS\n#  define FEAT_TLS CRLF \" AUTH TLS\" CRLF \" PBSZ\" CRLF \" PROT\"\n# else\n#  define FEAT_TLS \"\"\n# endif\n# ifdef DEBUG\n#  define FEAT_DEBUG CRLF \" XDBG\"\n# else\n#  define FEAT_DEBUG \"\"\n# endif\n# ifdef WITH_VIRTUAL_CHROOT\n#  define FEAT_TVFS \"\"\n# else\n#  define FEAT_TVFS CRLF \" TVFS\"\n# endif\n# define FEAT_PASV CRLF \" PASV\" CRLF \" EPSV\"\n\n# ifdef MINIMAL\n#  define FEAT_ESTA \"\"\n#  define FEAT_ESTP \"\"\n# else\n#  define FEAT_ESTA CRLF \" ESTA\"\n#  define FEAT_ESTP CRLF \" ESTP\"\n# endif\n\n    char feat[] = FEAT FEAT_DEBUG FEAT_TLS FEAT_TVFS FEAT_ESTA FEAT_PASV FEAT_ESTP;\n\n    if (disallow_passive != 0) {\n        feat[sizeof FEAT FEAT_DEBUG FEAT_TLS FEAT_TVFS FEAT_ESTA - 1U] = 0;\n    }\n# ifndef MINIMAL\n    else if (STORAGE_FAMILY(force_passive_ip) != 0) {\n        feat[sizeof FEAT FEAT_DEBUG FEAT_TLS FEAT_TVFS FEAT_ESTA FEAT_PASV - 1U] = 0;\n    }\n# endif\n    addreply_noformat(0, feat);\n    addreply_noformat(211, \"End.\");\n}\n#endif\n\n#ifndef MINIMAL\nvoid dostou(void)\n{\n    char file[64];\n    static unsigned int seq = 0U;\n    struct timeval tv;\n    struct timezone tz;\n\n    if (gettimeofday(&tv, &tz) != 0) {\n        error(553, MSG_TIMESTAMP_FAILURE);\n        return;\n    }\n    if (SNCHECK(snprintf(file, sizeof file, \"pureftpd.%08lx.%02lx.%04x\",\n                         (unsigned long) tv.tv_sec,\n                         (unsigned long) tv.tv_usec & 0xff,\n                         seq), sizeof file)) {\n        _EXIT(EXIT_FAILURE);\n    }\n    seq++;\n    seq &= 0xffff;\n    addreply(150, \"FILE: %s\", file);\n    dostor(file, 0, 1);\n}\n#endif\n\nstatic int tryautorename(const char * const atomic_file, char * const name,\n                         const char ** const name2_)\n{\n    static char name2[PATH_MAX];\n    unsigned int gc = 0U;\n\n    if (link(atomic_file, name) == 0) {\n        *name2_ = NULL;\n        (void) unlink(atomic_file);\n        return 0;\n    }\n    *name2_ = name2;\n    for (;;) {\n        gc++;\n        if (gc == 0U ||\n#ifdef AUTORENAME_REVERSE_ORDER\n            SNCHECK(snprintf(name2, sizeof name2, \"%u.%s\", gc, name),\n                    sizeof name2)\n#else\n            SNCHECK(snprintf(name2, sizeof name2, \"%s.%u\", name, gc),\n                    sizeof name2)\n#endif\n            ) {\n            break;\n        }\n        if (link(atomic_file, name2) == 0) {\n            (void) unlink(atomic_file);\n            return 0;\n        }\n        switch (errno) {\n#ifdef EEXIST\n        case EEXIST:\n#endif\n#ifdef EISDIR\n        case EISDIR:\n#endif\n#ifdef ETXTBSY\n        case ETXTBSY:\n#endif\n            continue;\n        }\n        break;\n    }\n    *name2_ = NULL;\n\n    return -1;\n}\n\nstatic char *get_atomic_file(const char * const file)\n{\n    static char res[PATH_MAX];\n    char *z;\n    size_t orig_len;\n    size_t slash;\n    size_t sizeof_atomic_prefix;\n\n    if (file == NULL) {\n        return res;\n    }\n    if ((z = strrchr(file, '/')) == NULL) {\n        *res = 0;\n        orig_len = (size_t) 0U;\n    } else {\n        slash = (size_t) (z - file);\n        if (slash >= (sizeof res - (size_t) 1U)) {\n            return NULL;\n        }\n        slash++;\n        if (file[slash] == 0) {\n            return NULL;\n        }\n        strncpy(res, file, slash);\n        res[slash] = 0;\n        orig_len = strlen(res);\n    }\n    sizeof_atomic_prefix = strlen(atomic_prefix) + (size_t) 1U;\n    if (sizeof res - orig_len < sizeof_atomic_prefix) {\n        return NULL;\n    }\n    memcpy(res + orig_len, atomic_prefix, sizeof_atomic_prefix);\n\n    return res;\n}\n\nvoid delete_atomic_file(void)\n{\n    const char *atomic_file;\n\n    if ((atomic_file = get_atomic_file(NULL)) == NULL || *atomic_file == 0) {\n        return;\n    }\n    (void) unlink(atomic_file);\n    atomic_file = NULL;\n}\n\nstatic off_t get_file_size(const char * const file)\n{\n    struct stat st;\n\n    if (stat(file, &st) != 0) {\n        return (off_t) -1;\n    }\n    return st.st_size;\n}\n\n#ifdef QUOTAS\nstatic int ul_quota_update(const char * const file_name,\n                           const int files_count, const off_t bytes)\n{\n    Quota quota;\n    off_t file_size = (off_t) -1;\n    int overflow;\n    int ret = 0;\n\n    if (files_count == 0 && bytes == (off_t) 0) {\n        return 0;\n    }\n    if (quota_update(&quota, files_count, (long long) bytes, &overflow) != 0) {\n        return 0;\n    }\n    if (overflow != 0) {\n        ret = 1;\n        if (file_name != NULL) {\n            file_size = get_file_size(file_name);\n        }\n        if (file_size >= (off_t) 0 && unlink(file_name) == 0) {\n            (void) quota_update(&quota, -1, (long long) -file_size, NULL);\n        }\n    }\n    displayquota(&quota);\n\n    return ret;\n}\n#endif\n\nstatic int ulhandler_throttle(ULHandler * const ulhandler,\n                              const off_t uploaded, const double ts_start,\n                              double *required_sleep)\n{\n    double ts_now;\n    double elapsed;\n    off_t would_be_uploaded;\n    double wanted_ts;\n    off_t previous_chunk_size;\n\n    (void) uploaded;\n    if (ulhandler->bandwidth <= 0UL) {\n        *required_sleep = 0.0;\n        return 0;\n    }\n    if ((ts_now = get_usec_time()) <= 0.0) {\n        ts_now = ts_start;\n    }\n    if (ts_start > ts_now) {\n        ts_now = ts_start;\n    }\n    elapsed = ts_now - ts_start;\n    would_be_uploaded = ulhandler->total_uploaded + ulhandler->chunk_size;\n    if (ulhandler->bandwidth > 0UL) {\n        wanted_ts = (double) would_be_uploaded / (double) ulhandler->bandwidth;\n    } else {\n        wanted_ts = elapsed;\n    }\n    *required_sleep = wanted_ts - elapsed;\n    previous_chunk_size = ulhandler->chunk_size;\n    if (ulhandler->total_uploaded > ulhandler->chunk_size) {\n        if (*required_sleep < ulhandler->min_sleep) {\n            ulhandler->chunk_size =\n                (ulhandler->max_chunk_size + ulhandler->chunk_size) / 2;\n        } else if (*required_sleep > ulhandler->max_sleep) {\n            ulhandler->chunk_size =\n                (ulhandler->min_chunk_size + ulhandler->chunk_size) / 2;\n        } else {\n            ulhandler->chunk_size = ulhandler->default_chunk_size;\n        }\n        if (ulhandler->chunk_size <= 0 ||\n            ulhandler->chunk_size > (off_t) ulhandler->sizeof_buf) {\n            ulhandler->chunk_size = ulhandler->default_chunk_size;\n        }\n        if (previous_chunk_size != ulhandler->default_chunk_size) {\n            would_be_uploaded =\n                ulhandler->total_uploaded + ulhandler->chunk_size;\n            if (ulhandler->bandwidth > 0UL) {\n                wanted_ts = (double) would_be_uploaded /\n                    (double) ulhandler->bandwidth;\n            } else {\n                wanted_ts = elapsed;\n            }\n            *required_sleep = wanted_ts - elapsed;\n        }\n    }\n    return 0;\n}\n\nstatic int ul_init(ULHandler * const ulhandler, const int clientfd,\n                   void * const tls_clientfd, const int xferfd,\n                   const char * const name, const int f, void * const tls_fd,\n                   const off_t restartat, const int ascii_mode,\n                   const unsigned long bandwidth, const off_t max_filesize)\n{\n    struct pollfd *pfd;\n\n    (void) name;\n    if (ascii_mode > 0) {\n#ifdef WITHOUT_ASCII\n        addreply_noformat(450, MSG_ASCII_MODE_UNSUPPORTED);\n        return -1;\n#else\n        addreply_noformat(0, MSG_ASCII_MODE_WARNING);\n#endif\n    }\n    if (fcntl(xferfd, F_SETFL, fcntl(xferfd, F_GETFL) | O_NONBLOCK) == -1) {\n        error(451, \"fcntl(F_SETFL, O_NONBLOCK)\");\n        return -1;\n    }\n    ulhandler->buf = NULL;\n    ulhandler->sizeof_buf = (size_t) 0UL;\n    ulhandler->clientfd = clientfd;\n    ulhandler->tls_clientfd = tls_clientfd;\n    ulhandler->xferfd = xferfd;\n    ulhandler->f = f;\n    ulhandler->tls_fd = tls_fd;\n    ulhandler->ascii_mode = ascii_mode;\n    ulhandler->cur_pos = restartat;\n    ulhandler->total_uploaded = (off_t) 0;\n    ulhandler->min_sleep = 0.1;\n    ulhandler->max_sleep = 5.0;\n    ulhandler->bandwidth = bandwidth;\n    ulhandler->max_filesize = max_filesize;\n    ulhandler->idletime = idletime;\n    pfd = &ulhandler->pfds[PFD_DATA];\n    pfd->fd = xferfd;\n    pfd->events = POLLIN | POLLERR | POLLHUP;\n    pfd->revents = 0;\n    pfd = &ulhandler->pfds[PFD_COMMANDS];\n    pfd->fd = clientfd;\n#ifdef __APPLE_CC__\n    pfd->events = POLLRDBAND | POLLPRI | POLLERR | POLLHUP;\n#else\n    pfd->events = POLLIN | POLLPRI | POLLERR | POLLHUP;\n#endif\n    pfd->revents = 0;\n    pfd = &ulhandler->pfds_command;\n    pfd->fd = clientfd;\n#ifdef __APPLE_CC__\n    pfd->events = POLLRDBAND | POLLPRI | POLLERR | POLLHUP;\n#else\n    pfd->events = POLLIN | POLLPRI | POLLERR | POLLHUP;\n#endif\n    pfd->revents = 0;\n    ulhandler->min_chunk_size = UL_MIN_CHUNK_SIZE;\n    if (ascii_mode > 0) {\n        ulhandler->default_chunk_size = ulhandler->max_chunk_size =\n            UL_DEFAULT_CHUNK_SIZE_ASCII;\n    } else {\n        ulhandler->max_chunk_size = UL_MAX_CHUNK_SIZE;\n        if (bandwidth <= 0UL) {\n            ulhandler->default_chunk_size = ulhandler->max_chunk_size;\n        } else {\n            ulhandler->default_chunk_size = UL_DEFAULT_CHUNK_SIZE;\n        }\n    }\n    ulhandler->chunk_size = ulhandler->default_chunk_size;\n    ulhandler->cur_pos = restartat;\n    ulhandler->sizeof_buf = ulhandler->max_chunk_size;\n    if ((ulhandler->buf = malloc(ulhandler->sizeof_buf)) == NULL) {\n        ulhandler->buf = NULL;\n        ulhandler->sizeof_buf = (size_t) 0U;\n        return -1;\n    }\n    return 0;\n}\n\nstatic int ul_dowrite(ULHandler * const ulhandler, const unsigned char *buf_,\n                      const size_t size_, off_t * const uploaded)\n{\n    size_t size = size_;\n    ssize_t written;\n    const unsigned char *buf = buf_;\n    unsigned char *unasciibuf = NULL;\n    int ret = 0;\n\n    if (size_ <= (size_t) 0U) {\n        *uploaded = 0;\n        return -1;\n    }\n#ifndef WITHOUT_ASCII\n    if (ulhandler->ascii_mode > 0) {\n        unsigned char *unasciibufpnt;\n        size_t z = (size_t) 0U;\n\n        if (size > (size_t) ulhandler->chunk_size ||\n            (unasciibuf = ALLOCA((size_t) ulhandler->chunk_size)) == NULL) {\n            return -1;\n        }\n        unasciibufpnt = unasciibuf;\n        do {\n            if (buf_[z] != (unsigned char) '\\r') {\n                *unasciibufpnt++ = buf_[z];\n            }\n            z++;\n        } while (z < size);\n        buf = unasciibuf;\n        size = (size_t) (unasciibufpnt - unasciibuf);\n    }\n#endif\n    written = safe_write(ulhandler->f, buf, size, -1);\n    ret = - (written != (ssize_t) size);\n    if (unasciibuf != NULL) {\n        ALLOCA_FREE(unasciibuf);\n    }\n    if (ret < 0) {\n        *uploaded = 0;\n    } else {\n        *uploaded = size;\n    }\n    return ret;\n}\n\nstatic int ulhandler_handle_commands(ULHandler * const ulhandler)\n{\n    char buf[100];\n    char *bufpnt;\n    ssize_t readnb;\n\n    if (ulhandler->tls_clientfd != NULL) {\n#ifdef WITH_TLS\n        readnb = SSL_read(ulhandler->tls_clientfd, buf,\n                          sizeof buf - (size_t) 1U);\n#else\n        abort();\n#endif\n    } else {\n        readnb = read(ulhandler->clientfd, buf, sizeof buf - (size_t) 1U);\n    }\n    if (readnb == (ssize_t) 0) {\n        return -2;\n    }\n    if (readnb < (ssize_t) 0) {\n        if (errno == EAGAIN || errno == EINTR) {\n            return 0;\n        }\n        return -1;\n    }\n    buf[readnb] = 0;\n    bufpnt = skip_telnet_controls(buf);\n    if (strchr(buf, '\\n') != NULL) {\n        if (strncasecmp(bufpnt, \"ABOR\", sizeof \"ABOR\" - 1U) != 0 &&\n            strncasecmp(bufpnt, \"QUIT\", sizeof \"QUIT\" - 1U) != 0) {\n            addreply_noformat(500, MSG_UNKNOWN_COMMAND);\n            doreply();\n        } else {\n            addreply_noformat(426, MSG_ABORTED);\n            doreply();\n            return 1;\n        }\n    }\n    return 0;\n}\n\nstatic int ul_handle_data(ULHandler * const ulhandler, off_t * const uploaded,\n                          const double ts_start)\n{\n    ssize_t readnb;\n    double required_sleep = 0.0;\n    int pollret;\n    int ret;\n\n    if (ulhandler->max_filesize >= (off_t) 0 &&\n        ulhandler->total_uploaded > ulhandler->max_filesize) {\n        addreply(552, MSG_ABORTED \" (quota)\");\n        return -2;\n    }\n    if (ulhandler->chunk_size > (off_t) ulhandler->sizeof_buf) {\n        ulhandler->chunk_size = ulhandler->max_chunk_size =\n            ulhandler->sizeof_buf;\n    }\n    if (ulhandler->tls_fd != NULL) {\n#ifdef WITH_TLS\n        readnb = SSL_read(ulhandler->tls_fd, ulhandler->buf,\n                          ulhandler->chunk_size);\n#else\n        abort();\n#endif\n    } else {\n        readnb = read(ulhandler->xferfd, ulhandler->buf,\n                      ulhandler->chunk_size);\n    }\n    if (readnb == (ssize_t) 0) {\n        return 2;\n    }\n    if (readnb < (ssize_t) 0) {\n        if (errno == EAGAIN || errno == EINTR) {\n            return 0;\n        }\n        addreply_noformat(451, MSG_DATA_READ_FAILED);\n        return -1;\n    }\n    if (ul_dowrite(ulhandler, ulhandler->buf, readnb, uploaded) != 0) {\n        addreply_noformat(452, MSG_WRITE_FAILED);\n        return -1;\n    }\n    ulhandler->cur_pos += *uploaded;\n#ifdef FTPWHO\n        if (shm_data_cur != NULL) {\n            shm_data_cur->download_current_size =\n                shm_data_cur->download_total_size = ulhandler->cur_pos;\n        }\n#endif\n    ulhandler->total_uploaded += *uploaded;\n    if (ulhandler->bandwidth > 0UL) {\n        ulhandler_throttle(ulhandler, *uploaded, ts_start, &required_sleep);\n        if (required_sleep > 0.0) {\n            repoll:\n            ulhandler->pfds_command.revents = 0;\n            pollret = poll(&ulhandler->pfds_command, 1, required_sleep * 1000.0);\n            if (pollret == 0) {\n                return 0;\n            }\n            if (pollret < 0) {\n                if (errno == EINTR) {\n                    goto repoll;\n                }\n                return -1;\n            }\n            if ((ulhandler->pfds_command.revents &\n                 (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n                return -1;\n            }\n            if ((ulhandler->pfds_command.revents & (POLLIN | POLLPRI)) != 0) {\n                ret = ulhandler_handle_commands(ulhandler);\n                if (ret != 0) {\n                    return ret;\n                }\n                goto repoll;\n            }\n        }\n    }\n    return 0;\n}\n\nstatic int ul_send(ULHandler * const ulhandler)\n{\n    double ts_start = 0.0;\n    off_t uploaded = (off_t) 0;\n    int pollret;\n    int timeout;\n    int ret;\n\n    if (ulhandler->bandwidth > 0UL && (ts_start = get_usec_time()) <= 0.0) {\n        error(451, \"gettimeofday()\");\n        return -1;\n    }\n    for (;;) {\n        if (ulhandler->idletime >= INT_MAX / 1000) {\n            timeout = INT_MAX;\n        } else {\n            timeout = (int) ulhandler->idletime * 1000;\n        }\n        ulhandler->pfds[PFD_DATA].revents =\n            ulhandler->pfds[PFD_COMMANDS].revents = 0;\n        pollret = poll(ulhandler->pfds,\n                       sizeof ulhandler->pfds / sizeof ulhandler->pfds[0],\n                       timeout);\n        if (pollret < 0) {\n            addreply_noformat(451, MSG_DATA_READ_FAILED);\n            return -1;\n        }\n        if (pollret == 0) {\n            addreply_noformat(421, MSG_TIMEOUT);\n            return -1;\n        }\n        if ((ulhandler->pfds[PFD_DATA].revents & POLLIN) != 0) {\n            ret = ul_handle_data(ulhandler, &uploaded, ts_start);\n            switch (ret) {\n            case 1:\n                return 1;\n            case 2:\n                return 0;\n            case 0:\n                break;\n            default:\n                if (ret > 2) {\n                    abort();\n                }\n                return ret;\n            }\n        }\n        if ((ulhandler->pfds[PFD_COMMANDS].revents & (POLLIN | POLLPRI)) != 0) {\n            ret = ulhandler_handle_commands(ulhandler);\n            if (ret != 0) {\n                return ret;\n            }\n        }\n        if ((ulhandler->pfds[PFD_DATA].revents & (POLLERR | POLLNVAL)) != 0 ||\n            ((ulhandler->pfds[PFD_DATA].revents & POLLHUP) != 0 &&\n             (ulhandler->pfds[PFD_DATA].revents & POLLIN) == 0)) {\n            return -1;\n        }\n        if ((ulhandler->pfds[PFD_COMMANDS].revents &\n             (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n            addreply_noformat(221, MSG_LOGOUT);\n            return -1;\n        }\n    }\n    /* NOTREACHED */\n    return 0;\n}\n\nstatic int ul_exit(ULHandler * const ulhandler)\n{\n    free(ulhandler->buf);\n    ulhandler->buf = NULL;\n\n    return 0;\n}\n\nint ul_check_free_space(const char *name, const double min_space)\n{\n    STATFS_STRUCT statfsbuf;\n    char *z;\n    char *alloca_namedir;\n    size_t name_len;\n    double jam;\n    double space;\n\n    if (maxdiskusagepct <= 0.0 && min_space <= 0.0) {\n        return 1;\n    }\n#ifdef CHECK_SYMLINKS_DISK_SPACE\n    if (STATFS(name, &statfsbuf) == 0) {\n        goto okcheckspace;\n    }\n#endif\n    name_len = strlen(name) + (size_t) 1U;\n    if (name_len < (size_t) 2U ||\n        (alloca_namedir = ALLOCA(name_len)) == NULL) {\n        return -1;\n    }\n    memcpy(alloca_namedir, name, name_len);\n    if ((z = strrchr(alloca_namedir, '/')) != NULL) {\n        if (z == alloca_namedir) {\n            *z++ = '.';\n        }\n        *z = 0;\n    } else {\n        alloca_namedir[0] = '.';\n        alloca_namedir[1] = 0;\n    }\n    if (STATFS(alloca_namedir, &statfsbuf) != 0) {\n        ALLOCA_FREE(alloca_namedir);\n        return -1;\n    }\n    ALLOCA_FREE(alloca_namedir);\n\n#ifdef CHECK_SYMLINKS_DISK_SPACE\n    okcheckspace:\n#endif\n    if ((double) STATFS_BLOCKS(statfsbuf) <= 0.0) {\n        return 1;\n    }\n    if (min_space >= 0.0) {\n        space = (double) STATFS_BAVAIL(statfsbuf) *\n            (double) STATFS_FRSIZE(statfsbuf);\n        if (space < min_space) {\n            return 0;\n        }\n    }\n    jam = (double) STATFS_BAVAIL(statfsbuf) /\n        (double) STATFS_BLOCKS(statfsbuf);\n    if (jam >= maxdiskusagepct) {\n        return 1;\n    }\n    return 0;\n}\n\nvoid dostor(char *name, const int append, const int autorename)\n{\n    ULHandler ulhandler;\n    int f;\n    const char *ul_name = NULL;\n    const char *atomic_file = NULL;\n    off_t filesize = (off_t) 0U;\n    struct stat st;\n    double started = 0.0;\n    signed char overwrite = 0;\n    int overflow = 0;\n    int ret = -1;\n    off_t max_filesize = (off_t) -1;\n#ifdef QUOTAS\n    Quota quota;\n#endif\n    const char *name2 = NULL;\n\n    if (type < 1 || (type == 1 && restartat > (off_t) 1)) {\n        addreply_noformat(503, MSG_NO_ASCII_RESUME);\n        goto end;\n    }\n#ifndef ANON_CAN_RESUME\n    if (guest != 0 && anon_noupload != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n        goto end;\n    }\n#endif\n    if (ul_check_free_space(name, -1.0) == 0) {\n        addreply_noformat(552, MSG_NO_DISK_SPACE);\n        goto end;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        goto end;\n    }\n    if (autorename != 0) {\n        no_truncate = 1;\n    }\n    if (restartat > (off_t) 0 || no_truncate != 0) {\n        if ((atomic_file = get_atomic_file(name)) == NULL) {\n            addreply(553, MSG_SANITY_FILE_FAILURE, name);\n            goto end;\n        }\n        if (restartat > (off_t) 0 &&\n            rename(name, atomic_file) != 0 && errno != ENOENT) {\n            error(553, MSG_RENAME_FAILURE);\n            atomic_file = NULL;\n            goto end;\n        }\n    }\n    if (atomic_file != NULL) {\n        ul_name = atomic_file;\n    } else {\n        ul_name = name;\n    }\n    if (atomic_file == NULL &&\n        (f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) {\n        overwrite++;\n    } else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW,\n                         (mode_t) 0777 & ~u_mask)) == -1) {\n        error(553, MSG_OPEN_FAILURE2);\n        goto end;\n    }\n    if (fstat(f, &st) < 0) {\n        (void) close(f);\n        error(553, MSG_STAT_FAILURE2);\n        goto end;\n    }\n    if (!S_ISREG(st.st_mode)) {\n        (void) close(f);\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n        goto end;\n    }\n    alarm(MAX_SESSION_XFER_IDLE);\n\n    /* Anonymous users *CAN* overwrite 0-bytes files - This is the right behavior */\n    if (st.st_size > (off_t) 0) {\n#ifndef ANON_CAN_RESUME\n        if (guest != 0) {\n            addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n            (void) close(f);\n            goto end;\n        }\n#endif\n        if (append != 0) {\n            restartat = st.st_size;\n        }\n    } else {\n        restartat = (off_t) 0;\n    }\n    if (restartat > st.st_size) {\n        restartat = st.st_size;\n    }\n    if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) {\n        (void) close(f);\n        error(451, \"seek\");\n        goto end;\n    }\n    if (restartat < st.st_size) {\n        if (ftruncate(f, restartat) < 0) {\n            (void) close(f);\n            error(451, \"ftruncate\");\n            goto end;\n        }\n#ifdef QUOTAS\n        if (restartat != st.st_size) {\n            (void) quota_update(NULL, 0LL,\n                                (long long) (restartat - st.st_size),\n                                &overflow);\n        }\n#endif\n    }\n#ifdef QUOTAS\n    if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 &&\n        (overflow > 0 || quota.files >= user_quota_files ||\n         quota.size > user_quota_size ||\n         (max_filesize >= (off_t) 0 &&\n          (max_filesize = user_quota_size - quota.size) < (off_t) 0))) {\n        overflow = 1;\n        (void) close(f);\n        goto afterquota;\n    }\n#endif\n    opendata();\n    if (xferfd == -1) {\n        (void) close(f);\n        goto end;\n    }\n    doreply();\n# ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n    }\n# endif\n    state_needs_update = 1;\n    setprocessname(\"pure-ftpd (UPLOAD)\");\n    filesize = restartat;\n\n#ifdef FTPWHO\n    if (shm_data_cur != NULL) {\n        const size_t sl = strlen(name);\n\n        ftpwho_lock();\n        shm_data_cur->state = FTPWHO_STATE_UPLOAD;\n        shm_data_cur->download_total_size = (off_t) 0U;\n        shm_data_cur->download_current_size = (off_t) filesize;\n        shm_data_cur->restartat = restartat;\n        (void) time(&shm_data_cur->xfer_date);\n        if (sl < sizeof shm_data_cur->filename) {\n            memcpy(shm_data_cur->filename, name, sl);\n            shm_data_cur->filename[sl] = 0;\n        } else {\n            memcpy(shm_data_cur->filename,\n                   &name[sl - sizeof shm_data_cur->filename - 1U],\n                   sizeof shm_data_cur->filename);\n        }\n        ftpwho_unlock();\n    }\n#endif\n\n    /* Here starts the real upload code */\n\n    started = get_usec_time();\n\n    if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx,\n                restartat, type == 1, throttling_bandwidth_ul,\n                max_filesize) == 0) {\n        ret = ul_send(&ulhandler);\n        ul_exit(&ulhandler);\n    } else {\n        ret = -1;\n    }\n    (void) close(f);\n    closedata();\n\n    /* Here ends the real upload code */\n\n#ifdef SHOW_REAL_DISK_SPACE\n    if (FSTATFS(f, &statfsbuf) == 0) {\n        double space;\n\n        space = (double) STATFS_BAVAIL(statfsbuf) *\n            (double) STATFS_FRSIZE(statfsbuf);\n        if (space > 524288.0) {\n            addreply(0, MSG_SPACE_FREE_M, space / 1048576.0);\n        } else {\n            addreply(0, MSG_SPACE_FREE_K, space / 1024.0);\n        }\n    }\n#endif\n\n    uploaded += (unsigned long long) ulhandler.total_uploaded;\n    {\n        off_t atomic_file_size;\n        off_t original_file_size;\n        int files_count;\n\n        if (overwrite == 0) {\n            files_count = 1;\n        } else {\n            files_count = 0;\n        }\n        if (autorename != 0 && restartat == (off_t) 0) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if (tryautorename(atomic_file, name, &name2) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                ul_quota_update(name2 ? name2 : name, 1, atomic_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else if (atomic_file != NULL) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if ((original_file_size = get_file_size(name)) < (off_t) 0 ||\n                restartat > original_file_size) {\n                original_file_size = restartat;\n            }\n            if (rename(atomic_file, name) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                overflow = ul_quota_update\n                    (name, files_count, atomic_file_size - original_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else {\n#ifdef QUOTAS\n            overflow = ul_quota_update\n                (name, files_count, ulhandler.total_uploaded);\n#endif\n        }\n    }\n    afterquota:\n    if (overflow > 0) {\n        addreply(552, MSG_QUOTA_EXCEEDED, name);\n    } else {\n        if (ret == 0) {\n            addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);\n        } else {\n            addreply_noformat(451, MSG_ABORTED);\n        }\n        displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started,\n                    name2 ? name2 : name, 1);\n    }\n    end:\n    restartat = (off_t) 0;\n    if (atomic_file != NULL) {\n        unlink(atomic_file);\n        atomic_file = NULL;\n    }\n}\n\nvoid domdtm(const char *name)\n{\n    struct stat st;\n    struct tm *t;\n\n    if (!name || !*name) {\n        addreply_noformat(501, MSG_MISSING_ARG);\n    } else if (stat(name, &st)) {\n#ifdef DEBUG\n        if (debug != 0) {\n            addreply(0, \"arg: %s, wd: %s\", name, wd);\n        }\n#endif\n        addreply_noformat(550, MSG_STAT_FAILURE2);\n    } else if (!S_ISREG(st.st_mode)) {\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n    } else {\n        t = gmtime((time_t *) &(st.st_mtime));\n        if (!t) {\n            addreply_noformat(451, MSG_GMTIME_FAILURE);\n        } else {\n            addreply(213, \"%04d%02d%02d%02d%02d%02d\",\n                     t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                     t->tm_hour, t->tm_min, t->tm_sec);\n        }\n    }\n}\n\nvoid dosize(const char *name)\n{\n    struct stat st;\n\n    if (!name || !*name) {\n        addreply_noformat(501, MSG_MISSING_ARG);\n    } else if (stat(name, &st)) {\n#ifdef DEBUG\n        if (debug != 0) {\n            addreply(0, \"arg: %s, wd: %s\", name, wd);\n        }\n#endif\n        addreply_noformat(550, MSG_STAT_FAILURE2);\n    } else if (!S_ISREG(st.st_mode)) {\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n    } else {\n        addreply(213, \"%llu\", (unsigned long long) st.st_size);\n    }\n}\n\nvoid dotype(const char *arg)\n{\n    replycode = 200;            /* bloody awful hack */\n\n    if (!arg || !*arg) {\n        addreply(501, MSG_MISSING_ARG \"\\n\" \"A(scii) I(mage) L(ocal)\");\n    } else if (tolower((unsigned char) *arg) == 'a')\n        type = 1;\n    else if (tolower((unsigned char) *arg) == 'i')\n        type = 2;\n    else if (tolower((unsigned char) *arg) == 'l') {\n        if (arg[1] == '8') {\n            type = 2;\n        } else if (isdigit((unsigned char) arg[1])) {\n            addreply_noformat(504, MSG_TYPE_8BIT_FAILURE);\n        } else {\n            addreply_noformat(0, MSG_MISSING_ARG);\n            type = 2;\n        }\n    } else {\n        addreply(504, MSG_TYPE_UNKNOWN \": %s\", arg);\n    }\n\n    addreply(0, MSG_TYPE_SUCCESS \" %s\", (type > 1) ? \"8-bit binary\" : \"ASCII\");\n}\n\nvoid dostru(const char *arg)\n{\n    if (arg == NULL || !*arg) {\n        addreply_noformat(501, MSG_MISSING_ARG);\n    } else if (strcasecmp(arg, \"F\")) {\n        addreply_noformat(504, MSG_STRU_FAILURE);\n    } else {\n        addreply_noformat(200, \"F OK\");\n    }\n}\n\nvoid domode(const char *arg)\n{\n    if (arg == NULL || !*arg) {\n        addreply_noformat(501, MSG_MISSING_ARG);\n    } else if (strcasecmp(arg, \"S\")) {\n        addreply_noformat(504, MSG_MODE_FAILURE);\n    } else {\n        addreply_noformat(200, \"S OK\");\n    }\n}\n\nvoid dornfr(char *name)\n{\n    struct stat st;\n\n#ifndef ANON_CAN_RENAME\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_RENAME);\n        return;\n    }\n#endif\n    if (disallow_rename != 0) {\n        addreply_noformat(550, MSG_RENAME_FAILURE);\n        return;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        return;\n    }\n    if ((lstat(name, &st)) == 0) {\n        if (renamefrom != NULL) {\n            addreply_noformat(0, MSG_RENAME_ABORT);\n            (void) free(renamefrom);\n        }\n        if ((renamefrom = strdup(name)) == NULL) {\n            die_mem();\n        }\n        addreply_noformat(350, MSG_RENAME_RNFR_SUCCESS);\n    } else {\n        addreply_noformat(550, MSG_FILE_DOESNT_EXIST);\n    }\n}\n\nvoid dornto(char *name)\n{\n#ifdef QUOTAS\n    off_t target_file_size = (off_t) -1;\n    int files_count = 0;\n    long long bytes = 0LL;\n#endif\n\n#ifndef ANON_CAN_RENAME\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_RENAME);\n        goto bye;\n    }\n#endif\n    if (renamefrom == NULL) {\n        addreply_noformat(503, MSG_RENAME_NORNFR);\n        goto bye;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        return;                        /* don't clear rnfrom buffer */\n    }\n#ifdef QUOTAS\n    if (hasquota() == 0) {\n        struct stat st_source, st_target;\n\n        if (stat(renamefrom, &st_source) != 0) {\n            addreply_noformat(550, MSG_RENAME_FAILURE);\n            goto bye;\n        }\n        if (stat(name, &st_target) != 0) {\n            if (errno == ENOENT) {\n                target_file_size = (off_t) -1;\n            } else {\n                addreply_noformat(550, MSG_RENAME_FAILURE);\n                goto bye;\n            }\n        } else if (st_source.st_ino == st_target.st_ino &&\n                   st_source.st_dev == st_target.st_dev) {\n            addreply_noformat(250, MSG_RENAME_SUCCESS);\n            goto bye;\n        } else {\n            target_file_size = st_target.st_size;\n        }\n        if (target_file_size >= (off_t) 0) {\n            bytes = - (long long) target_file_size;\n            files_count = -1;\n            (void) quota_update(NULL, files_count, bytes, NULL);\n        } else {\n            bytes = (off_t) 0;\n        }\n    }\n#endif\n    if (rename(renamefrom, name) < 0) {\n        error(451, MSG_RENAME_FAILURE);\n#ifdef QUOTAS\n        (void) quota_update(NULL, -files_count, -bytes, NULL);\n#endif\n    } else {\n        addreply_noformat(250, MSG_RENAME_SUCCESS);\n        logfile(LOG_NOTICE, MSG_RENAME_SUCCESS \": [%s]->[%s]\",\n                renamefrom, name);\n    }\n    bye:\n    (void) free(renamefrom);\n    renamefrom = NULL;\n}\n\n#ifndef MINIMAL\nvoid doopts(char *args)\n{\n    char *cmdopts;\n\n    if ((cmdopts = strchr(args, ' ')) != NULL) {\n        cmdopts++;\n        (void) cmdopts;\n    }\n    if (strncasecmp(\"mlst \", args, 5) == 0) {\n        addreply_noformat(200, \" MLST OPTS \"\n                          \"type;size;sizd;modify;UNIX.mode;UNIX.uid;\"\n                          \"UNIX.gid;unique;\");\n        return;\n    }\n    addreply_noformat(504, MSG_UNKNOWN_COMMAND);\n}\n#endif\n\nvoid error(int n, const char *msg)\n{\n    const char *e = strerror(errno);\n\n    logfile(LOG_ERR, \"%s: %s\", msg, e);\n    addreply(n, \"%s: %s\", msg, e);\n}\n\nstatic void fixlimits(void)\n{\n#ifdef HAVE_SETRLIMIT\n    static struct rlimit lim;\n\n    lim.rlim_max = lim.rlim_cur = MAX_CPU_TIME;\n    setrlimit(RLIMIT_CPU, &lim);\n    lim.rlim_max = lim.rlim_cur = MAX_DATA_SIZE;\n    setrlimit(RLIMIT_DATA, &lim);\n# ifndef DEBUG\n    lim.rlim_max = lim.rlim_cur = 0;\n    setrlimit(RLIMIT_CORE, &lim);\n# endif\n#endif\n}\n\n#ifdef COOKIE\nstatic int fortune(void)\n{\n    int fd;\n    char *buf;\n    char *bufpnt;\n    char *bufend;\n    struct stat st;\n    off_t gl;\n    char *fortunepnt;\n    char fortune[2048];\n\n    if (fortunes_file == NULL || *fortunes_file == 0) {\n        return 0;\n    }\n    if ((fd = open(fortunes_file, O_RDONLY)) == -1) {\n        logfile(LOG_ERR, MSG_OPEN_FAILURE, fortunes_file);\n        return -1;\n    }\n    if (fstat(fd, &st) < 0 ||\n        (((S_IRUSR | S_IRGRP | S_IROTH) & st.st_mode) !=\n         (S_IRUSR | S_IRGRP | S_IROTH)) ||\n        !(S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) || st.st_size < 2 ||\n        (buf = mmap(NULL, (size_t) st.st_size,\n                PROT_READ, MAP_FILE | MAP_SHARED, fd,\n                (off_t) 0)) == (void *) MAP_FAILED) {\n        (void) close(fd);\n        logfile(LOG_ERR, MSG_OPEN_FAILURE, fortunes_file);\n        return -1;\n    }\n# ifdef HAVE_RANDOM\n    gl = (off_t) (random() % (st.st_size - 1U));\n# else\n    gl = (off_t) (rand() % (st.st_size - 1U));\n# endif\n    bufpnt = buf + gl;\n    bufend = buf + st.st_size;\n    while (bufpnt != buf) {\n        if (bufpnt[0] == '\\n') {\n            if (&bufpnt[-1] != buf && bufpnt[-1] == '%') {\n                if (&bufpnt[-2] != buf && bufpnt[-2] == '\\n') {\n                    break;\n                }\n            }\n        }\n        bufpnt--;\n    }\n    if (bufpnt != buf) {\n        while (bufpnt != bufend && *bufpnt == '\\n') {\n            bufpnt++;\n        }\n    }\n    fortunepnt = fortune;\n    while (*bufpnt != 0 && bufpnt != bufend &&\n           fortunepnt != &fortune[sizeof fortune - 1U]) {\n        if (bufpnt[0] == '\\n') {\n            if (&bufpnt[1] != bufend && bufpnt[1] == '%') {\n                if (&bufpnt[2] != bufend && bufpnt[2] == '\\n') {\n                    break;\n                }\n            }\n        }\n        *fortunepnt++ = *bufpnt++;\n    }\n    if (fortunepnt == fortune) {\n        goto bye;\n    }\n    do {\n        fortunepnt--;\n    } while (fortunepnt != fortune && (*fortunepnt == '\\n' ||\n                                       isspace((unsigned char) *fortunepnt)));\n    fortunepnt[1] = 0;\n    fortunepnt = fortune;\n    while (*fortunepnt == '\\n') {\n        fortunepnt++;\n    }\n    if (*fortunepnt == 0) {\n        goto bye;\n    }\n    addreply(220, \"%s\", fortunepnt);\n    bye:\n    (void) munmap(buf, st.st_size);\n    (void) close(fd);\n\n    return 1;\n}\n#endif\n\n#if !defined(NO_STANDALONE) && !defined(NO_INETD)\nstatic int check_standalone(void)\n{\n    socklen_t socksize = (socklen_t) sizeof ctrlconn;\n    if (getsockname(0, (struct sockaddr *) &ctrlconn, &socksize) != 0) {\n        clientfd = -1;\n        return 1;\n    }\n    if (dup2(0, 1) == -1) {\n        _EXIT(EXIT_FAILURE);\n    }\n    clientfd = 0;\n\n    return 0;\n}\n#endif\n\nstatic void set_signals_client(void)\n{\n    sigset_t sigs;\n    struct sigaction sa;\n\n    sigfillset(&sigs);\n    sigemptyset(&sa.sa_mask);\n\n    sa.sa_flags = SA_RESTART;\n\n    sa.sa_handler = SIG_IGN;\n    (void) sigaction(SIGPIPE, &sa, NULL);\n    (void) sigaction(SIGURG, &sa, NULL);\n#ifdef SIGIO\n    (void) sigaction(SIGIO, &sa, NULL);\n#endif\n\n    sa.sa_handler = SIG_DFL;\n    sigdelset(&sigs, SIGCHLD);\n    (void) sigaction(SIGCHLD, &sa, NULL);\n#ifdef SIGFPE\n    (void) sigaction(SIGFPE, &sa, NULL);\n    sigdelset(&sigs, SIGFPE);\n#endif\n    sa.sa_flags = 0;\n\n    sa.sa_handler = sigalarm;\n    sigdelset(&sigs, SIGALRM);\n    (void) sigaction(SIGALRM, &sa, NULL);\n\n    sa.sa_handler = sigterm_client;\n    sigdelset(&sigs, SIGTERM);\n    (void) sigaction(SIGTERM, &sa, NULL);\n    sigdelset(&sigs, SIGHUP);\n    (void) sigaction(SIGHUP, &sa, NULL);\n    sigdelset(&sigs, SIGQUIT);\n    (void) sigaction(SIGQUIT, &sa, NULL);\n    sigdelset(&sigs, SIGINT);\n    (void) sigaction(SIGINT, &sa, NULL);\n#ifdef SIGXCPU\n    sigdelset(&sigs, SIGXCPU);\n    (void) sigaction(SIGXCPU, &sa, NULL);\n#endif\n    (void) sigprocmask(SIG_SETMASK, &sigs, NULL);\n}\n\nstatic void set_signals(void)\n{\n#ifndef NO_STANDALONE\n    sigset_t sigs;\n    struct sigaction sa;\n\n    sigfillset(&sigs);\n    sigemptyset(&sa.sa_mask);\n\n    sa.sa_flags = SA_RESTART;\n    sa.sa_handler = sigchild;\n    sigdelset(&sigs, SIGCHLD);\n    (void) sigaction(SIGCHLD, &sa, NULL);\n\n    sa.sa_handler = SIG_IGN;\n    (void) sigaction(SIGPIPE, &sa, NULL);\n    (void) sigaction(SIGALRM, &sa, NULL);\n    (void) sigaction(SIGURG, &sa, NULL);\n#ifdef SIGIO\n    (void) sigaction(SIGIO, &sa, NULL);\n#endif\n\n    sa.sa_flags = 0;\n    sa.sa_handler = sigterm;\n    sigdelset(&sigs, SIGTERM);\n    (void) sigaction(SIGTERM, &sa, NULL);\n    sigdelset(&sigs, SIGHUP);\n    (void) sigaction(SIGHUP, &sa, NULL);\n    sigdelset(&sigs, SIGQUIT);\n    (void) sigaction(SIGQUIT, &sa, NULL);\n    sigdelset(&sigs, SIGINT);\n    (void) sigaction(SIGINT, &sa, NULL);\n# ifdef SIGXCPU\n    sigdelset(&sigs, SIGXCPU);\n    (void) sigaction(SIGXCPU, &sa, NULL);\n# endif\n    (void) sigprocmask(SIG_SETMASK, &sigs, NULL);\n#endif\n}\n\nstatic void dns_sanitize(char *z)\n{\n    while (*z != 0) {\n        if ((*z >= 'a' && *z <= 'z') ||\n            (*z >= '0' && *z <= '9') ||\n            *z == '.' || *z == '-' || *z == ':' ||\n            (*z >= 'A' && *z <= 'Z')) {\n            /* unless */\n        } else {\n            *z = '_';\n        }\n        z++;\n    }\n}\n\nstatic void fill_atomic_prefix(void)\n{\n    char tmp_atomic_prefix[PATH_MAX];\n\n    snprintf(tmp_atomic_prefix, sizeof tmp_atomic_prefix,\n             \"%s%lx.%x.%lx.%x\",\n             ATOMIC_PREFIX_PREFIX,\n             (unsigned long) session_start_time,\n             (unsigned int) serverport,\n             (unsigned long) getpid(),\n             zrand());\n    if ((atomic_prefix = strdup(tmp_atomic_prefix)) == NULL) {\n        die_mem();\n    }\n}\n\nstatic void doit(void)\n{\n    socklen_t socksize;\n    unsigned int users = 0U;\n    int display_banner = 1;\n\n    client_init_reply_buf();\n    session_start_time = time(NULL);\n    fixlimits();\n#ifdef F_SETOWN\n    fcntl(clientfd, F_SETOWN, getpid());\n#endif\n    set_signals_client();\n    alt_arc4random_stir();\n    (void) umask((mode_t) 0);\n    socksize = (socklen_t) sizeof ctrlconn;\n    if (getsockname(clientfd, (struct sockaddr *) &ctrlconn, &socksize) != 0) {\n        die(421, LOG_ERR, MSG_NO_SUPERSERVER);\n    }\n    fourinsix(&ctrlconn);\n    if (checkvalidaddr(&ctrlconn) == 0) {\n        die(425, LOG_ERR, MSG_INVALID_IP);\n    }\n    if (STORAGE_FAMILY(ctrlconn) == AF_INET6) {\n        serverport = ntohs((in_port_t) STORAGE_PORT6_CONST(ctrlconn));\n    } else {\n        serverport = ntohs((in_port_t) STORAGE_PORT_CONST(ctrlconn));\n    }\n    if (trustedip != NULL && addrcmp(&ctrlconn, trustedip) != 0) {\n       anon_only = 1;\n    }\n    socksize = (socklen_t) sizeof peer;\n    if (getpeername(clientfd, (struct sockaddr *) &peer, &socksize)) {\n        die(421, LOG_ERR, MSG_GETPEERNAME \": %s\" , strerror(errno));\n    }\n    fourinsix(&peer);\n    if (checkvalidaddr(&peer) == 0) {\n        die(425, LOG_ERR, MSG_INVALID_IP);\n    }\n#ifndef DONT_LOG_IP\n    for (;;) {\n        int eai;\n\n        if ((eai = getnameinfo\n             ((struct sockaddr *) &peer, STORAGE_LEN(peer), host,\n              sizeof host, NULL, (size_t) 0U,\n              resolve_hostnames != 0 ? 0 : NI_NUMERICHOST)) == 0) {\n            break;\n        }\n        if (resolve_hostnames != 0 &&\n            getnameinfo\n            ((struct sockaddr *) &peer, STORAGE_LEN(peer), host,\n             sizeof host, NULL, (size_t) 0U, NI_NUMERICHOST) == 0) {\n            break;\n        }\n        die(425, LOG_ERR, MSG_INVALID_IP);\n    }\n#endif\n#ifndef DONT_LOG_IP\n    dns_sanitize(host);\n#else\n    *host = '?';\n    host[1] = 0;\n#endif\n    logfile(LOG_INFO, MSG_NEW_CONNECTION, host);\n\n    replycode = 220;\n\n    fill_atomic_prefix();\n\n    if (maxusers > 0U) {\n#ifdef NO_STANDALONE\n        users = daemons(serverport);\n#else\n# ifdef NO_INETD\n        users = nb_children;\n# else\n        if (standalone) {\n            users = nb_children;\n        } else {\n            users = daemons(serverport);\n        }\n# endif\n#endif\n        if (users > maxusers) {\n            addreply(421, MSG_MAX_USERS, (unsigned long) maxusers);\n            doreply();\n            _EXIT(1);\n        }\n    }\n    /* It's time to add a new entry to the ftpwho list */\n#ifdef FTPWHO\n    {\n        ftpwho_initwho();\n        if (shm_data_cur != NULL) {\n            ftpwho_lock();\n            shm_data_cur->pid = getpid();\n            shm_data_cur->state = FTPWHO_STATE_IDLE;\n            shm_data_cur->addr = peer;\n            shm_data_cur->local_addr = ctrlconn;\n            shm_data_cur->date = session_start_time;\n            shm_data_cur->xfer_date = shm_data_cur->date;\n            (shm_data_cur->account)[0] = '?';\n            (shm_data_cur->account)[1] = 0;\n            shm_data_cur->download_total_size = (off_t) 0;\n            shm_data_cur->download_current_size = (off_t) 0;\n            ftpwho_unlock();\n        }\n    }\n#endif\n\n#ifdef WITH_ALTLOG\n    if (altlog_format != ALTLOG_NONE) {\n        if (altlog_format == ALTLOG_W3C) {\n            if ((altlog_fd = open(altlog_filename,\n                                  O_CREAT | O_WRONLY | O_NOFOLLOW | O_EXCL,\n                                  (mode_t) 0600)) != -1) {\n                altlog_write_w3c_header();\n            } else if (errno == EEXIST) {\n                altlog_fd = open(altlog_filename, O_WRONLY | O_NOFOLLOW);\n            }\n        } else {\n            altlog_fd = open(altlog_filename,\n                             O_CREAT | O_WRONLY | O_NOFOLLOW, (mode_t) 0600);\n        }\n        if (altlog_fd == -1) {\n            logfile(LOG_ERR, \"altlog %s: %s\", altlog_filename, strerror(errno));\n        }\n    }\n#endif\n    /* Back to the client - Get the 5 min load average */\n    {\n        double load_[2];\n\n        if (getloadavg(load_, sizeof load_ / sizeof load_[0]) < 0) {\n            load = 0.0;\n        } else {\n            load = load_[1];\n        }\n    }\n#ifndef NON_ROOT_FTP\n    wd[0] = '/';\n    wd[1] = 0;\n    if (chdir(wd)) {\n        _EXIT(EXIT_FAILURE);\n    }\n#endif\n    {\n        int fodder;\n#ifdef IPTOS_LOWDELAY\n        fodder = IPTOS_LOWDELAY;\n        setsockopt(clientfd, SOL_IP, IP_TOS, (char *) &fodder, sizeof fodder);\n#endif\n#ifdef SO_OOBINLINE\n        fodder = 1;\n        setsockopt(clientfd, SOL_SOCKET, SO_OOBINLINE,\n                   (char *) &fodder, sizeof fodder);\n#endif\n#ifdef TCP_NODELAY\n        fodder = 1;\n        setsockopt(clientfd, IPPROTO_TCP, TCP_NODELAY,\n                   (char *) &fodder, sizeof fodder);\n#endif\n        keepalive(clientfd, 0);\n    }\n#ifdef HAVE_SRANDOMDEV\n    srandomdev();\n#elif defined (HAVE_RANDOM)\n    srandom((unsigned int) session_start_time ^ (unsigned int) zrand());\n#else\n    srand((unsigned int) session_start_time ^ (unsigned int) zrand());\n#endif\n#ifdef COOKIE\n    if (fortune() > 0) {\n        display_banner = 0;\n    }\n#endif\n    if (display_banner) {\n#ifdef BORING_MODE\n        addreply_noformat(0, MSG_WELCOME_TO \" Pure-FTPd.\");\n#else\n# ifdef DEBUG\n        addreply_noformat(0, \"--------- \" MSG_WELCOME_TO\n                          \" Pure-FTPd \" PACKAGE_VERSION VERSION_PRIVSEP VERSION_TLS \" ----------\");\n# else\n        addreply_noformat(0, \"--------- \" MSG_WELCOME_TO\n                          \" Pure-FTPd\" VERSION_PRIVSEP VERSION_TLS \" ----------\");\n# endif\n#endif\n        if (users > 0U) {\n            addreply(0, MSG_NB_USERS, users, maxusers);\n        }\n        {\n            struct tm *t;\n\n            if ((t = localtime(&session_start_time)) != NULL) {\n                addreply(220, MSG_WELCOME_TIME,\n                         t->tm_hour, t->tm_min, (unsigned int) serverport);\n            }\n        }\n    }\n    if (anon_only > 0) {\n        addreply_noformat(220, MSG_ANONYMOUS_FTP_ONLY);\n    } else if (anon_only < 0) {\n        addreply_noformat(220, MSG_NO_ANONYMOUS_LOGIN);\n    }\n    if (allowfxp == 2) {\n        addreply_noformat(220, MSG_FXP_SUPPORT);\n    }\n#ifdef RATIOS\n    if (ratio_upload > 0) {\n        if (ratio_for_non_anon != 0) {\n            addreply_noformat(0, MSG_RATIOS_EVERYONE);\n        } else {\n            addreply_noformat(0, MSG_RATIOS_ANONYMOUS);\n        }\n        addreply(0, MSG_RATIOS_RULE, ratio_download, ratio_upload);\n    }\n#endif\n    if (display_banner) {\n        if (v6ready != 0 && STORAGE_FAMILY(peer) != AF_INET6) {\n            addreply(0, MSG_IPV6_OK);\n        }\n        if (idletime >= 120UL) {\n            addreply(220, MSG_INFO_IDLE_M, idletime / 60UL);\n        } else {\n            addreply(220, MSG_INFO_IDLE_S, (unsigned long) idletime);\n        }\n    }\n    candownload = (signed char) ((maxload <= 0.0) || (load < maxload));\n\n    if (force_passive_ip_s != NULL) {\n        struct addrinfo hints, *res;\n\n        memset(&hints, 0, sizeof hints);\n        hints.ai_family = AF_INET;\n        hints.ai_addr = NULL;\n        if (getaddrinfo(force_passive_ip_s, NULL, &hints, &res) != 0 ||\n            res->ai_family != AF_INET ||\n            res->ai_addrlen > sizeof force_passive_ip) {\n            die(421, LOG_ERR, MSG_ILLEGAL_FORCE_PASSIVE);\n        }\n        memcpy(&force_passive_ip, res->ai_addr, res->ai_addrlen);\n        freeaddrinfo(res);\n    }\n\n#ifndef WITHOUT_PRIVSEP\n    if (privsep_init() != 0) {\n        die(421, LOG_ERR, \"privsep_init\");\n    }\n#endif\n\n    parser();\n\n    addreply(0, MSG_LOGOUT);\n    logfile(LOG_INFO, MSG_LOGOUT);\n    doreply();\n#ifdef WITH_BONJOUR\n    refreshManager();\n#endif\n}\n\nstatic void check_ipv6_support(void)     /* check for ipv6 support in kernel */\n{\n#ifndef OLD_IP_STACK\n    int p;\n\n    if ((p = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP)) != -1) {\n        (void) close(p);\n        v6ready++;\n    }\n#endif\n}\n\n#ifndef NO_STANDALONE\nstatic void updatepidfile(void)\n{\n    int fd;\n    char buf[42];\n    size_t buf_len;\n\n    if (SNCHECK(snprintf(buf, sizeof buf, \"%lu\\n\",\n                         (unsigned long) getpid()), sizeof buf)) {\n        return;\n    }\n    if (unlink(pid_file) != 0 && errno != ENOENT) {\n        return;\n    }\n    if ((fd = open(pid_file, O_CREAT | O_WRONLY | O_TRUNC |\n                   O_NOFOLLOW, (mode_t) 0644)) == -1) {\n        return;\n    }\n    buf_len = strlen(buf);\n    if (safe_write(fd, buf, buf_len, -1) != (ssize_t) buf_len) {\n        (void) ftruncate(fd, (off_t) 0);\n    }\n    (void) close(fd);\n}\n\n#ifndef NO_STANDALONE\nstatic int closedesc_all(const int closestdin)\n{\n    int fodder;\n\n    if (closestdin != 0) {\n        (void) close(0);\n        if ((fodder = open(\"/dev/null\", O_RDONLY)) == -1) {\n            return -1;\n        }\n        (void) dup2(fodder, 0);\n        if (fodder > 0) {\n            (void) close(fodder);\n        }\n    }\n    if ((fodder = open(\"/dev/null\", O_WRONLY)) == -1) {\n        return -1;\n    }\n    (void) dup2(fodder, 1);\n    (void) dup2(1, 2);\n    if (fodder > 2) {\n        (void) close(fodder);\n    }\n\n    return 0;\n}\n\nstatic void dodaemonize(void)\n{\n    pid_t child;\n    unsigned int i;\n\n    /* Contributed by Jason Lunz - also based on APUI code, see open_max() */\n    if (daemonize != 0) {\n        if ((child = fork()) == (pid_t) -1) {\n            perror(MSG_STANDALONE_FAILED \" - fork\");\n            logfile(LOG_ERR, MSG_STANDALONE_FAILED \": [fork: %s]\", strerror(errno));\n            return;\n        } else if (child != (pid_t) 0) {\n            _EXIT(EXIT_SUCCESS);       /* parent exits */\n        }\n        if (setsid() == (pid_t) -1) {\n            perror(MSG_STANDALONE_FAILED \" - setsid\");   /* continue anyway */\n        }\n# ifndef NON_ROOT_FTP\n        if (chdir(\"/\") != 0) {\n            perror(\"chdir\");\n            _EXIT(EXIT_FAILURE);\n        }\n# endif\n        i = open_max();\n        do {\n            if (isatty((int) i)) {\n                (void) close((int) i);\n            }\n            i--;\n        } while (i > 2U);\n        if (closedesc_all(1) != 0) {\n            perror(MSG_STANDALONE_FAILED \" - /dev/null duplication\");\n            _EXIT(EXIT_FAILURE);\n        }\n    }\n}\n#endif\n\nstatic void accept_client(const int active_listen_fd) {\n    sigset_t set;\n    struct sockaddr_storage sa;\n    socklen_t dummy;\n    pid_t child;\n\n    memset(&sa, 0, sizeof sa);\n    dummy = (socklen_t) sizeof sa;\n    if ((clientfd = accept\n         (active_listen_fd, (struct sockaddr *) &sa, &dummy)) == -1) {\n        return;\n    }\n    if (STORAGE_FAMILY(sa) != AF_INET && STORAGE_FAMILY(sa) != AF_INET6) {\n        (void) close(clientfd);\n        clientfd = -1;\n        return;\n    }\n    if (maxusers > 0U && nb_children >= maxusers) {\n        char line[1024];\n\n        snprintf(line, sizeof line, \"421 \" MSG_MAX_USERS \"\\r\\n\",\n                 (unsigned long) maxusers);\n        /* No need to check a return value to say 'f*ck' */\n        (void) fcntl(clientfd, F_SETFL, fcntl(clientfd, F_GETFL) | O_NONBLOCK);\n        (void) write(clientfd, line, strlen(line));\n        (void) close(clientfd);\n        clientfd = -1;\n        return;\n    }\n    if (maxip > 0U) {\n        fourinsix(&sa);\n        if (iptrack_get(&sa) >= maxip) {\n            char line[1024];\n            char hbuf[NI_MAXHOST];\n            static struct sockaddr_storage old_sa;\n\n            (void) fcntl(clientfd, F_SETFL, fcntl(clientfd, F_GETFL) | O_NONBLOCK);\n            if (!SNCHECK(snprintf(line, sizeof line,\n                                  \"421 \" MSG_MAX_USERS_IP \"\\r\\n\",\n                                  (unsigned long) maxip), sizeof line)) {\n                (void) write(clientfd, line, strlen(line));\n            }\n            if (addrcmp(&old_sa, &sa) != 0) {\n                old_sa = sa;\n                if (getnameinfo((struct sockaddr *) &sa,\n                                STORAGE_LEN(sa), hbuf,\n                                sizeof hbuf, NULL, (size_t) 0U,\n                                NI_NUMERICHOST) == 0) {\n                    logfile(LOG_WARNING, MSG_MAX_USERS_IP \": [%s]\",\n                            (unsigned long) maxip, hbuf);\n                }\n            }\n            (void) close(clientfd);\n            clientfd = -1;\n            return;\n        }\n    }\n    sigemptyset(&set);\n    sigaddset(&set, SIGCHLD);\n    sigprocmask(SIG_BLOCK, &set, NULL);\n    nb_children++;\n    child = fork();\n    if (child == (pid_t) 0) {\n        if (isatty(2)) {\n            (void) close(2);\n        }\n#ifndef SAVE_DESCRIPTORS\n        if (no_syslog == 0) {\n            closelog();\n            openlog(\"pure-ftpd\", LOG_NDELAY | log_pid, syslog_facility);\n        }\n#endif\n        doit();\n        _EXIT(EXIT_SUCCESS);\n    } else if (child == (pid_t) -1) {\n        if (nb_children > 0U) {\n            nb_children--;\n        }\n    } else {\n        if (maxip > 0U) {\n            iptrack_add(&sa, child);\n        }\n    }\n    (void) close(clientfd);\n    clientfd = -1;\n    sigprocmask(SIG_UNBLOCK, &set, NULL);\n}\n\nstatic void standalone_server(void)\n{\n    int on;\n    struct addrinfo hints, *res, *res6;\n    fd_set rs;\n    int max_fd;\n\n# ifndef NO_INETD\n    standalone = 1;\n# endif\n    memset(&hints, 0, sizeof hints);\n    hints.ai_flags = AI_PASSIVE;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_addr = NULL;\n    on = 1;\n    if (listenfd == -1 && no_ipv4 == 0 &&\n        getaddrinfo(standalone_ip, standalone_port, &hints, &res) == 0) {\n        if ((listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1 ||\n            setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,\n                       (char *) &on, sizeof on) != 0) {\n            int old_errno;\n\n            freeaddrinfo(res);\n            cant_bind:\n            old_errno = errno;\n            perror(MSG_STANDALONE_FAILED);\n            logfile(LOG_ERR, MSG_STANDALONE_FAILED \": [%s]\",\n                    strerror(old_errno));\n            return;\n        }\n# ifdef TCP_FASTOPEN\n        {\n#  ifdef __APPLE__\n            int tfo = 1;\n#  else\n            int tfo = 5;\n#  endif\n            setsockopt(listenfd, IPPROTO_TCP, TCP_FASTOPEN,\n                       (void *) &tfo, sizeof tfo);\n        }\n# endif\n        if (bind(listenfd, res->ai_addr, (socklen_t) res->ai_addrlen) != 0 ||\n            listen(listenfd, maxusers > 0U ?\n                   3U + maxusers / 8U : DEFAULT_BACKLOG) != 0) {\n            freeaddrinfo(res);\n            goto cant_bind;\n        }\n        freeaddrinfo(res);\n        set_cloexec_flag(listenfd);\n    }\n    if (listenfd6 == -1 && v6ready != 0) {\n        hints.ai_family = AF_INET6;\n        if (getaddrinfo(standalone_ip, standalone_port, &hints, &res6) == 0) {\n            if ((listenfd6 = socket(AF_INET6,\n                                    SOCK_STREAM, IPPROTO_TCP)) == -1 ||\n                setsockopt(listenfd6, SOL_SOCKET, SO_REUSEADDR,\n                           (char *) &on, sizeof on) != 0) {\n                freeaddrinfo(res6);\n                goto cant_bind;\n            }\n# if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n            (void) setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n                              (char *) &on, sizeof on);\n# endif\n# ifdef TCP_FASTOPEN\n            {\n                int tfo = maxusers > 0U ? 3U + maxusers / 8U : DEFAULT_BACKLOG;\n                setsockopt(listenfd6, IPPROTO_TCP, TCP_FASTOPEN,\n                           (void *) &tfo, sizeof tfo);\n            }\n# endif\n            if (bind(listenfd6, res6->ai_addr,\n                     (socklen_t) res6->ai_addrlen) != 0 ||\n                listen(listenfd6, maxusers > 0U ?\n                       3U + maxusers / 8U : DEFAULT_BACKLOG) != 0) {\n                freeaddrinfo(res6);\n                goto cant_bind;\n            }\n            freeaddrinfo(res6);\n            set_cloexec_flag(listenfd6);\n        }\n    }\n    if (listenfd == -1 && listenfd6 == -1) {\n# ifdef EADDRNOTAVAIL\n        errno = EADDRNOTAVAIL;\n# endif\n        goto cant_bind;\n    }\n    updatepidfile();\n    setprocessname(\"pure-ftpd (SERVER)\");\n    FD_ZERO(&rs);\n    if (listenfd > listenfd6) {\n        max_fd = listenfd;\n    } else {\n        max_fd = listenfd6;\n    }\n    max_fd++;\n    while (stop_server == 0) {\n        safe_fd_set(listenfd, &rs);\n        safe_fd_set(listenfd6, &rs);\n        if (select(max_fd, &rs, NULL, NULL, NULL) <= 0) {\n            if (errno != EINTR) {\n                (void) sleep(1);\n            }\n            continue;\n        }\n        if (safe_fd_isset(listenfd, &rs)) {\n            accept_client(listenfd);\n        }\n        if (safe_fd_isset(listenfd6, &rs)) {\n            accept_client(listenfd6);\n        }\n    }\n}\n#endif\n\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)\nstatic struct passwd *fakegetpwnam(const char * const name)\n{\n    static struct passwd pwd;\n\n    (void) name;\n    pwd.pw_name = pwd.pw_gecos = pwd.pw_shell = \"ftp\";\n    pwd.pw_passwd = \"*\";\n    pwd.pw_uid = (uid_t) 42U;\n    pwd.pw_gid = (gid_t) 42U;\n    pwd.pw_dir = WIN32_ANON_DIR;\n\n    return &pwd;\n}\n#endif\n\nint pureftpd_start(int argc, char *argv[], const char *home_directory_)\n{\n#ifndef NO_GETOPT_LONG\n    int option_index = 0;\n#endif\n    int fodder;\n    int bypass_ipv6 = 0;\n    struct passwd *pw;\n\n    (void) home_directory_;\n#ifdef NON_ROOT_FTP\n    home_directory = home_directory_;\n#endif\n    client_init_reply_buf();\n\n#ifdef HAVE_GETPAGESIZE\n    page_size = (size_t) getpagesize();\n#elif defined(_SC_PAGESIZE)\n    page_size = (size_t) sysconf(_SC_PAGESIZE);\n#elif defined(_SC_PAGE_SIZE)\n    page_size = (size_t) sysconf(_SC_PAGE_SIZE);\n#else\n    page_size = (size_t) 4096U;\n#endif\n\n#ifdef HAVE_SETLOCALE\n# ifdef LC_MESSAGES\n    (void) setlocale(LC_MESSAGES, MESSAGES_LOCALE);\n# endif\n# ifdef LC_CTYPE\n    (void) setlocale(LC_CTYPE, \"C\");\n# endif\n# ifdef LC_COLLATE\n    (void) setlocale(LC_COLLATE, \"C\");\n# endif\n#endif\n\n    init_tz();\n    (void) strerror(ENOENT);\n\n#ifndef SAVE_DESCRIPTORS\n    openlog(\"pure-ftpd\", LOG_NDELAY | log_pid, DEFAULT_FACILITY);\n#endif\n\n#ifdef USE_CAPABILITIES\n    set_initial_caps();\n#endif\n    set_signals();\n\n    loggedin = 0;\n\n#ifdef BANNER_ENVIRON\n# ifdef COOKIE\n    {\n        const char *a;\n\n        if ((a = getenv(\"BANNER\")) != NULL && *a != 0) {\n            fortunes_file = strdup(a);\n        }\n    }\n# endif\n#endif\n\n#ifndef MINIMAL\n    if (argc == 2 && *argv[1] != '-' &&\n        sc_build_command_line_from_file(argv[1], NULL, simpleconf_options,\n                                        (sizeof simpleconf_options) /\n                                        (sizeof simpleconf_options[0]),\n                                        argv[0], &argc, &argv) != 0) {\n        die(421, LOG_ERR, MSG_CONF_ERR);\n    }\n#endif\n\n    while ((fodder =\n#ifndef NO_GETOPT_LONG\n            getopt_long(argc, argv, GETOPT_OPTIONS, long_options, &option_index)\n#else\n            getopt(argc, argv, GETOPT_OPTIONS)\n#endif\n            ) != -1) {\n        switch (fodder) {\n        case 's': {\n            if ((pw = getpwnam(\"ftp\")) != NULL ||\n                (pw = getpwnam(\"_ftp\")) != NULL) {\n                warez = pw->pw_uid;\n            } else {\n                logfile(LOG_ERR, MSG_NO_FTP_ACCOUNT);\n            }\n            break;\n        }\n        case '0': {\n            no_truncate = 1;\n            break;\n        }\n        case '4': {\n            bypass_ipv6 = 1;\n            break;\n        }\n        case '6': {\n            no_ipv4 = 1;\n            break;\n        }\n        case '1': {\n            log_pid = LOG_PID;\n            break;\n        }\n#ifndef NO_STANDALONE\n        case 'S': {\n            char *struck;\n\n            if ((struck = strchr(optarg, ',')) != NULL) {\n                *struck = 0;\n                if (*optarg != 0) {\n                    if (standalone_ip == NULL &&\n                        (standalone_ip = strdup(optarg)) == NULL) {\n                        die_mem();\n                    }\n                }\n                *struck = ',';\n                if (struck[1] != 0) {\n                    if ((standalone_port = strdup(struck + 1)) == NULL) {\n                        die_mem();\n                    }\n                }\n            } else {\n                if ((standalone_port = strdup(optarg)) == NULL) {\n                    die_mem();\n                }\n            }\n            break;\n        }\n#endif\n        case 'D': {\n            force_ls_a = 1;\n            break;\n        }\n#ifdef THROTTLING\n        case 't':\n        case 'T': {\n            char *struck;\n            const char *tr_bw_ul = NULL;\n            const char *tr_bw_dl = NULL;\n\n            if ((struck = strchr(optarg, ':')) != NULL) {\n                *struck = 0;\n                if (*optarg != 0) {\n                    tr_bw_ul = optarg;\n                }\n                if (struck[1] != 0) {\n                    tr_bw_dl = &struck[1];\n                }\n            } else {\n                tr_bw_ul = tr_bw_dl = optarg;\n            }\n            if ((tr_bw_ul == NULL || *tr_bw_ul == 0) &&\n                (tr_bw_dl == NULL || *tr_bw_dl == 0)) {\n                bad_bw:\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_THROTTLING \": %s\" , optarg);\n            }\n            if (tr_bw_dl != NULL) {\n                if ((throttling_bandwidth_dl =\n                     strtoul(tr_bw_dl, NULL, 0) * 1024UL) == 0UL) {\n                    goto bad_bw;\n                }\n            }\n            if (tr_bw_ul != NULL) {\n                if ((throttling_bandwidth_ul =\n                     strtoul(tr_bw_ul, NULL, 0) * 1024UL) == 0UL) {\n                    goto bad_bw;\n                }\n            }\n            throttling_delay = 1000000 /\n                (throttling_bandwidth_dl | throttling_bandwidth_ul);\n            if (fodder == 't') {\n                throttling = 1;\n            } else {\n                throttling = 2;\n            }\n            break;\n        }\n#endif\n        case 'a': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            chroot_trustedgid = strtoul(nptr, &endptr, 0);\n            if (!nptr || !*nptr || !endptr || *endptr) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_TRUSTED_GID \": %s\" , optarg);\n            }\n            userchroot = 1;\n            break;\n        }\n        case 'x': {\n            dot_write_ok = 0;\n            break;\n        }\n        case 'X': {\n            dot_write_ok = dot_read_ok = 0;\n            break;\n        }\n        case 'z': {\n            dot_read_anon_ok = 1;\n            break;\n        }\n        case 'Z': {\n            be_customer_proof = 1;\n            break;\n        }\n        case 'A': {\n            userchroot = 2;\n            break;\n        }\n        case 'w': {\n            allowfxp = 1;\n            break;\n        }\n        case 'W': {\n            allowfxp = 2;\n            break;\n        }\n        case 'd': {\n            if (logging < 2) {\n                logging++;\n            }\n            break;\n        }\n        case 'b': {\n            broken_client_compat = 1;\n            break;\n        }\n        case 'c': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            maxusers = (unsigned int) strtoul(nptr, &endptr, 0);\n            if (!nptr || !*nptr || !endptr || *endptr || !maxusers) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_USER_LIMIT \": %s\" , optarg);\n            }\n            break;\n        }\n#ifndef NO_STANDALONE\n        case 'B': {\n            daemonize = 1;\n            break;\n        }\n        case 'C': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            maxip = (unsigned int) strtoul(nptr, &endptr, 0);\n            if (!nptr || !*nptr || !endptr || *endptr || !maxip) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_USER_LIMIT \": %s\" , optarg);\n            }\n            break;\n        }\n#endif\n#ifdef PER_USER_LIMITS\n        case 'y': {\n            int ret;\n\n            ret = sscanf(optarg, \"%u:%u\", &per_user_max, &per_anon_max);\n            if (ret != 2) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_USER_LIMIT \": %s\" , optarg);\n            }\n            break;\n        }\n#endif\n#ifdef WITH_TLS\n        case '2': {\n            char *struck;\n            char *key_file_;\n\n            if ((struck = strchr(optarg, ',')) != NULL) {\n                *struck = 0;\n                key_file_ = struck + 1;\n            } else {\n                key_file_ = optarg;\n            }\n            if (*optarg == 0 || *key_file_ == 0) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": TLS\");\n            }\n            if ((cert_file = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            if ((key_file = strdup(key_file_)) == NULL) {\n                die_mem();\n            }\n            break;\n        }\n        case '3':\n            tls_extcert_parse(optarg);\n            use_extcert++;\n            break;\n        case 'Y': {\n            if ((enforce_tls_auth = atoi(optarg)) < 0 || enforce_tls_auth > 3) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": TLS\");\n            }\n            break;\n        }\n        case 'J': {\n            while (*optarg == '-') {\n                if (strncmp(optarg, \"-S:\", sizeof \"-S:\" - (size_t) 1U) == 0) {\n                    optarg += sizeof \"-S:\" - (size_t) 1U;\n                } else if (strncmp(optarg, \"-C:\", sizeof \"-C:\" - (size_t) 1U) == 0) {\n                    optarg += sizeof \"-C:\" - (size_t) 1U;\n                    ssl_verify_client_cert = 1;\n                }\n            }\n            if ((tlsciphersuite = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            break;\n        }\n#endif\n        case 'e': {\n            anon_only = 1;\n            break;\n        }\n        case 'E': {\n            anon_only = -1;\n            break;\n        }\n#ifdef COOKIE\n        case 'F': {\n# ifdef BANNER_ENVIRON\n            free(fortunes_file);\n# endif\n            fortunes_file = strdup(optarg);\n            break;\n        }\n#endif\n        case 'f': {\n            int n = 0;\n\n            if (strcasecmp(optarg, \"none\") == 0) {\n                no_syslog = 1;\n                break;\n            }\n            while (facilitynames[n].c_name &&\n                   strcasecmp(facilitynames[n].c_name, optarg) != 0) {\n                n++;\n            }\n            if (facilitynames[n].c_name) {\n                syslog_facility = facilitynames[n].c_val;\n            } else {\n                logfile(LOG_ERR,\n                        MSG_CONF_ERR \": \" MSG_ILLEGAL_FACILITY \": %s\", optarg);\n            }\n            break;\n        }\n        case 'l': {\n            const Authentication *auth_list_pnt = auth_list;\n            const char *opt = optarg;\n            Authentications *new_auth;\n            size_t auth_name_len;\n\n            for (;;) {\n                auth_name_len = strlen(auth_list_pnt->name);\n                if (strncasecmp(opt, auth_list_pnt->name,\n                                auth_name_len) == 0) {\n                    char *file = NULL;\n\n                    opt += auth_name_len;\n                    if (*opt == ':') {\n                        opt++;\n                        if (*opt != 0) {\n                            if ((file = strdup(opt)) == NULL) {\n                                die_mem();\n                            }\n                        }\n                    }\n                    if (auth_list_pnt->parse != NULL) {\n                        auth_list_pnt->parse(file);\n                    }\n                    if ((new_auth = malloc(sizeof *new_auth)) == NULL) {\n                        die_mem();\n                    }\n                    new_auth->auth = auth_list_pnt;\n                    new_auth->conf_file = file;\n                    new_auth->next = NULL;\n                    if (last_authentications == NULL) {\n                        first_authentications = new_auth;\n                    } else {\n                        last_authentications->next = new_auth;\n                    }\n                    last_authentications = new_auth;\n\n                    break;\n                }\n                auth_list_pnt++;\n                if (auth_list_pnt->name == NULL) {\n                    die(421, LOG_ERR, MSG_AUTH_UNKNOWN \": %s\", opt);\n                }\n            }\n\n            break;\n        }\n        case 'm': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            maxload = strtod(nptr, &endptr);\n            if (!nptr || !*nptr || !endptr || *endptr || maxload <= 0.0) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \"\n                    MSG_ILLEGAL_LOAD_LIMIT \": %s\" , optarg);\n            }\n            break;\n        }\n        case 'M': {\n            allow_anon_mkdir = 1;\n            break;\n        }\n        case 'N': {\n            disallow_passive = 1;\n            break;\n        }\n#if defined(WITH_UPLOAD_SCRIPT)\n        case 'o': {\n            do_upload_script = 1;\n            break;\n        }\n#endif\n#ifdef WITH_ALTLOG\n        case 'O': {\n            char *optarg_copy;\n            char *delpoint;\n\n            if ((optarg_copy = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            if ((delpoint = strchr(optarg_copy, ALTLOG_DELIMITER)) == NULL) {\n                altlog_format = ALTLOG_DEFAULT;\n                delpoint = optarg_copy;\n            } else {\n                const AltLogPrefixes *altlogprefixes_pnt = altlogprefixes;\n\n                *delpoint++ = 0;\n                do {\n                    if (strcasecmp(optarg_copy,\n                                   altlogprefixes_pnt->prefix) == 0) {\n                        altlog_format = altlogprefixes_pnt->format;\n                        break;\n                    }\n                    altlogprefixes_pnt++;\n                } while (altlogprefixes_pnt->prefix != NULL);\n                if (altlog_format == ALTLOG_NONE) {\n                    die(421, LOG_ERR,\n                        MSG_CONF_ERR \": \" MSG_UNKNOWN_ALTLOG \": %s\",\n                        optarg_copy);\n                }\n            }\n            if (*delpoint != '/') {\n                die(421, LOG_ERR,\n                    MSG_CONF_ERR \": \" MSG_SANITY_FILE_FAILURE,\n                    delpoint);\n            }\n            if (altlog_filename == NULL &&\n                (altlog_filename = strdup(delpoint)) == NULL) {\n                die_mem();\n            }\n            (void) free(optarg_copy);\n            break;\n        }\n#endif\n        case 'p': {\n            int ret;\n\n            ret = sscanf(optarg, \"%u:%u\", &firstport, &lastport);\n            if (ret != 2 ||\n                firstport < 1024U || lastport > 65535U\n                || lastport < firstport) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_PORTS_RANGE \": %s\" , optarg);\n            }\n            break;\n        }\n        case 'L': {\n            int ret;\n\n            ret = sscanf(optarg, \"%u:%u\", &max_ls_files, &max_ls_depth);\n            if (ret != 2 ||\n                max_ls_files < 1U || max_ls_depth < 1U) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_LS_LIMITS \": %s\" , optarg);\n            }\n            break;\n        }\n#ifdef QUOTAS\n        case 'n': {\n            int ret;\n\n            ret = sscanf(optarg, \"%llu:%llu\",\n                         &user_quota_files, &user_quota_size);\n            if (ret != 2) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_QUOTA \": %s\" , optarg);\n            }\n            user_quota_size *= (1024ULL * 1024ULL);\n            break;\n        }\n#endif\n        case 'P': {\n            if (force_passive_ip_s == NULL &&\n                (force_passive_ip_s = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            break;\n        }\n#ifdef RATIOS\n        case 'q':\n        case 'Q': {\n            int ret;\n\n            ret = sscanf(optarg, \"%u:%u\", &ratio_upload, &ratio_download);\n            if (ret != 2 ||\n                ratio_upload < 1U || ratio_download < 1U) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_RATIO \": %s\" , optarg);\n            }\n            if (fodder == 'Q') {\n                ratio_for_non_anon = 1;\n            }\n            break;\n        }\n#endif\n        case 'r': {\n            autorename = 1;\n            break;\n        }\n        case 'R': {\n            nochmod = 1;\n            break;\n        }\n        case 'K': {\n            keepallfiles = 1;\n            break;\n        }\n#ifndef NO_STANDALONE\n        case 'g': {\n            if ((pid_file = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            break;\n        }\n#endif\n        case 'G': {\n            disallow_rename = 1;\n            break;\n        }\n        case 'H': {\n            resolve_hostnames = 0;\n            break;\n        }\n        case 'I': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            idletime = strtoul(nptr, &endptr, 0) * 60UL;\n            if (idletime <= 0) {\n                idletime = DEFAULT_IDLE;\n            }\n            break;\n        }\n        case 'i': {\n            anon_noupload = 1;\n            break;\n        }\n        case 'j': {\n            create_home = 1;\n            break;\n        }\n        case 'k': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            maxdiskusagepct = 1.0 - (strtod(nptr, &endptr) / 100.0);\n            if (maxdiskusagepct >= 1.0 || maxdiskusagepct < 0.0) {\n                maxdiskusagepct = 0.0;\n            }\n            break;\n        }\n        case 'u': {\n            const char *nptr;\n            char *endptr;\n            long tmp;\n\n            nptr = optarg;\n            endptr = NULL;\n            tmp = strtol(nptr, &endptr, 10);\n            if (!nptr || !*nptr || !endptr || *endptr || tmp < 0) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_UID_LIMIT \": %s\" , optarg);\n            }\n            useruid = (uid_t) tmp;\n            break;\n        }\n        case 'U': {\n            char *optarg_copy;\n            char *struck;\n            const char *tr_umask = NULL;\n            const char *tr_umask_d = NULL;\n\n            if ((optarg_copy = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            if ((struck = strchr(optarg_copy, ':')) != NULL) {\n                *struck = 0;\n                if (*optarg_copy != 0) {\n                    tr_umask = optarg_copy;\n                }\n                if (struck[1] != 0) {\n                    tr_umask_d = &struck[1];\n                }\n            } else {\n                tr_umask = tr_umask_d = optarg_copy;\n            }\n            if ((tr_umask == NULL || *tr_umask == 0) &&\n                (tr_umask_d == NULL || *tr_umask_d == 0)) {\n                bad_umask:\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_UMASK \": %s\",\n                    optarg_copy);\n            }\n            if (tr_umask != NULL) {\n                if ((u_mask =\n                     strtoul(tr_umask, NULL, 8)) > 0777) {\n                    goto bad_umask;\n                }\n            }\n            if (tr_umask_d != NULL) {\n                if ((u_mask_d =\n                     strtoul(tr_umask_d, NULL, 8)) > 0777) {\n                    goto bad_umask;\n                }\n            }\n            (void) free(optarg_copy);\n            break;\n        }\n#ifdef WITH_VIRTUAL_HOSTS\n        case 'V': {\n            if (trustedip == NULL &&\n                (trustedip = malloc(sizeof *trustedip)) == NULL) {\n                die_mem();\n            }\n            if (generic_aton(optarg, trustedip) != 0) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_TRUSTED_IP);\n            }\n            break;\n        }\n#endif\n#ifdef WITH_BONJOUR\n        case 'v': {\n            char *rdvname;\n            char *end;\n\n            if ((rdvname = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            doregistration(rdvname, strtoul(standalone_port, &end, 10));\n            break;\n        }\n#endif\n        case 'h': {\n#ifndef NON_ROOT_FTP\n            if (geteuid() == (uid_t) 0)\n#endif\n            {\n                puts(PACKAGE \" v\" VERSION VERSION_PRIVSEP \"\\n\");\n            }\n#ifndef NO_GETOPT_LONG\n            {\n                const struct option *options = long_options;\n\n                do {\n                    printf(\"-%c\\t--%s\\t%s\\n\", options->val, options->name,\n                           options->has_arg ? \"<opt>\" : \"\");\n                    options++;\n                } while (options->name != NULL);\n            }\n#endif\n            exit(EXIT_SUCCESS);\n        }\n        default:\n            die(421, LOG_ERR, MSG_ILLEGAL_OPTION);\n        }\n    }\n    if (optind < argc) {\n        die(421, LOG_ERR, MSG_INVALID_ARGUMENT, argv[optind]);\n    }\n    if (first_authentications == NULL) {\n        if ((first_authentications =\n             malloc(sizeof *first_authentications)) == NULL) {\n            die_mem();\n        }\n        first_authentications->auth = DEFAULT_AUTHENTICATION;\n        first_authentications->conf_file = NULL;\n        first_authentications->next = NULL;\n    }\n#ifndef NO_STANDALONE\n    dodaemonize();\n#endif\n#ifndef SAVE_DESCRIPTORS\n    if (no_syslog == 0 && (log_pid || syslog_facility != DEFAULT_FACILITY)) {\n        closelog();\n        openlog(\"pure-ftpd\", LOG_NDELAY | log_pid, syslog_facility);\n    }\n#endif\n    (void) umask((mode_t) 0);\n    clearargs(argc, argv);\n    idletime_noop = (double) idletime * 2.0;\n    if (firstport) {\n        unsigned int portmax;\n\n        portmax = (lastport - firstport + 1) / 2;\n        if (!maxusers || maxusers > portmax) {\n            maxusers = portmax;    /* ... so we don't run out of ports */\n        }\n    }\n    if (bypass_ipv6 == 0) {\n        check_ipv6_support();\n    }\n#if defined(WITH_UPLOAD_SCRIPT)\n    if (do_upload_script != 0) {\n        upload_pipe_open();\n    }\n#endif\n#ifdef WITH_DIRALIASES\n    if (init_aliases() != 0) {\n        logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE);\n    }\n#endif\n#ifdef WITH_TLS\n    if (enforce_tls_auth > 0) {\n        (void) tls_init_library();\n    }\n#endif\n#if !defined(NO_STANDALONE) && !defined(NO_INETD)\n    if (check_standalone() != 0) {\n        standalone_server();\n    } else {\n        doit();\n    }\n#elif !defined(NO_STANDALONE) && defined(NO_INETD)\n    standalone_server();\n#elif defined(NO_STANDALONE) && !defined(NO_INETD)\n    doit();\n#else\n# error Configuration error\n#endif\n\n#ifdef WITH_UPLOAD_SCRIPT\n    upload_pipe_close();\n#endif\n    {\n        Authentications *auth_scan = first_authentications;\n        Authentications *previous;\n\n        while (auth_scan != NULL) {\n            if (auth_scan->auth->exit != NULL) {\n                auth_scan->auth->exit();\n            }\n            free(auth_scan->conf_file);\n            previous = auth_scan;\n            auth_scan = auth_scan->next;\n            free(previous);\n        }\n    }\n    first_authentications = last_authentications = NULL;\n    free(trustedip);\n#ifndef NO_STANDALONE\n    iptrack_free();\n    unlink(pid_file);\n#endif\n    closelog();\n#ifdef WITH_TLS\n    tls_free_library();\n    tls_extcert_exit();\n    free((void *) client_sni_name);\n#endif\n    alt_arc4random_close();\n\n    _EXIT(EXIT_SUCCESS);\n\n    return 0;\n}\n"], "fixing_code": ["#include <config.h>\n\n#define DEFINE_GLOBALS\n#include \"messages.h\"\n#include \"ftpd_p.h\"\n#include \"dynamic.h\"\n#include \"ftpwho-update.h\"\n#include \"ftpwho-read.h\"\n#include \"globals.h\"\n#include \"caps.h\"\n#include \"alt_arc4random.h\"\n#if defined(WITH_UPLOAD_SCRIPT)\n# include \"upload-pipe.h\"\n#endif\n#ifdef WITH_ALTLOG\n# include \"altlog.h\"\n#endif\n#ifdef QUOTAS\n# include \"quotas.h\"\n#endif\n#ifdef WITH_DIRALIASES\n# include \"diraliases.h\"\n#endif\n#include \"ftpd.h\"\n#include \"bsd-glob.h\"\n#include \"getloadavg.h\"\n#include \"safe_rw.h\"\n#include \"utils.h\"\n#ifndef MINIMAL\n# include \"simpleconf.h\"\n# include \"simpleconf_ftpd.h\"\n#endif\n#ifndef WITHOUT_PRIVSEP\n# include \"privsep.h\"\n#endif\n#ifdef WITH_TLS\n# include \"tls.h\"\n# include \"tls_extcert.h\"\n#endif\n#ifdef WITH_BONJOUR\n# include \"bonjour.h\"\n#endif\n#ifdef HAVE_LIBSODIUM\n# include <sodium.h>\n#endif\n#ifdef WITH_DMALLOC\n# include <dmalloc.h>\n#endif\n\nvoid disablesignals(void)\n{\n    sigset_t sigs;\n\n    sigfillset(&sigs);\n    if (sigprocmask(SIG_BLOCK, &sigs, &old_sigmask) < 0) {\n        _EXIT(EXIT_FAILURE);\n    }\n}\n\nstatic void enablesignals(void)\n{\n    if (sigprocmask(SIG_SETMASK, &old_sigmask, NULL) < 0) {\n        _EXIT(EXIT_FAILURE);\n    }\n}\n\nvoid usleep2(const unsigned long microsec)\n{\n    disablesignals();\n    usleep(microsec);\n    enablesignals();\n}\n\n#ifdef WITH_TLS\nssize_t secure_safe_write(void * const tls_fd, const void *buf_, size_t count)\n{\n    ssize_t written;\n    const char *buf = (const char *) buf_;\n\n    while (count > (size_t) 0U) {\n        for (;;) {\n            if ((written = SSL_write(tls_fd, buf, count)) <= (ssize_t) 0) {\n                if (SSL_get_error(tls_fd, written) != SSL_ERROR_NONE) {\n                    return (ssize_t) -1;\n                }\n                continue;\n            }\n            break;\n        }\n        buf += written;\n        count -= written;\n    }\n    return (ssize_t) (buf - (const char *) buf_);\n}\n#endif\n\nstatic ssize_t safe_nonblock_write(const int fd, void * const tls_fd,\n                                   const void *buf_, size_t count)\n{\n    ssize_t written;\n    const char *buf = (const char *) buf_;\n    struct pollfd pfd;\n\n    while (count > (size_t) 0U) {\n        for (;;) {\n            if (tls_fd == NULL) {\n                written = write(fd, buf, count);\n            } else {\n#ifdef WITH_TLS\n                written = SSL_write(tls_fd, buf, count);\n                if (SSL_get_error(tls_fd, written) == SSL_ERROR_WANT_WRITE) {\n                    errno = EAGAIN;\n                }\n#else\n                abort();\n#endif\n            }\n            if (written > (ssize_t) 0) {\n                break;\n            }\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                pfd.fd = fd;\n                pfd.events = POLLOUT | POLLERR | POLLHUP;\n                pfd.revents = 0;\n                if (poll(&pfd, 1U, idletime * 1000UL) <= 0 ||\n                    (pfd.revents & (POLLERR | POLLHUP)) != 0 ||\n                    (pfd.revents & POLLOUT) == 0) {\n                    errno = EPIPE;\n                    return -1;\n                }\n            } else if (errno != EINTR) {\n                return -1;\n            }\n        }\n        buf += written;\n        count -= written;\n    }\n    return 0;\n}\n\nstatic void overlapcpy(char *d, const char *s)\n{\n    while (*s != 0) {\n        *d++ = *s++;\n    }\n    *d = 0;\n}\n\nstatic void safe_fd_set(const int fd, fd_set * const fds)\n{\n    if (fd == -1) {\n        return;\n    }\n    FD_SET(fd, fds);\n}\n\nstatic int safe_fd_isset(const int fd, const fd_set * const fds)\n{\n    if (fd == -1) {\n        return 0;\n    }\n    return FD_ISSET(fd, fds);\n}\n\nstatic int init_tz(void)\n{\n    char stbuf[10];\n    struct tm *tm;\n    time_t now = time(NULL);\n\n#ifdef HAVE_TZSET\n    tzset();\n#endif\n#ifdef HAVE_PUTENV\n    if ((tm = localtime(&now)) != NULL &&\n        strftime(stbuf, sizeof stbuf, \"%z\", tm) == (size_t) 5U) {\n        snprintf(default_tz_for_putenv, sizeof default_tz_for_putenv,\n                 \"TZ=UTC%c%c%c:%c%c\", (*stbuf == '-' ? '+' : '-'),\n                 stbuf[1], stbuf[2], stbuf[3], stbuf[4]);\n    }\n    putenv(default_tz_for_putenv);\n#endif\n    (void) localtime(&now);\n    (void) gmtime(&now);\n\n    return 0;\n}\n\nvoid simplify(char *subdir)\n{\n    char *a;\n\n    if (subdir == NULL || *subdir == 0) {\n        return;\n    }\n    while ((a = strstr(subdir, \"//\")) != NULL) {\n        overlapcpy(a, a + 1);\n    }\n    while ((a = strstr(subdir, \"/./\")) != NULL) {\n        overlapcpy(a, a + 2);\n    }\n    while (strncmp(subdir, \"../\", 3) == 0) {\n        subdir += 3;\n    }\n    a = strstr(subdir, \"/../\");\n    if (a != NULL) {\n        if (a == subdir) {\n            while (strncmp(subdir, \"/../\", 4) == 0) {\n                overlapcpy(subdir, subdir + 3);\n            }\n            a = strstr(subdir, \"/../\");\n        }\n        while (a != NULL) {\n            char *nextcomponent = a + 4;\n            if (a != subdir && *a == '/') {\n                a--;\n            }\n            while (a != subdir && *a != '/') {\n                a--;\n            }\n            if (*a == '/') {\n                a++;\n            }\n            overlapcpy(a, nextcomponent);\n            a = strstr(subdir, \"/../\");\n        }\n    }\n    a = subdir;\n    if (*a == '.') {\n        a++;\n        if (*a == 0) {\n            return;\n        }\n        if (*a == '/') {\n            while (*a == '/') {\n                a++;\n            }\n            overlapcpy(subdir, a);\n        }\n    }\n    if (*a == 0) {\n        return;\n    }\n    a = subdir + strlen(subdir) - (size_t) 1U;\n    if (*a != '.' || a == subdir) {\n        return;\n    }\n    a--;\n    if (*a == '/') {\n        a[1] = 0;\n        return;\n    }\n    if (*a != '.' || a == subdir) {\n        return;\n    }\n    a--;\n    if (*a != '/') {\n        return;\n    }\n    *a = 0;\n    if ((a = strrchr(subdir, '/')) == NULL) {\n        *subdir = '/';\n        subdir[1] = 0;\n        return;\n    }\n    a[1] = 0;\n}\n\nint checkprintable(const char *s)\n{\n    int ret = 0;\n    unsigned char c;\n\n    while ((c = (unsigned char) *s) != 0U) {\n        if (ISCTRLCODE(c)) {\n            ret--;\n            break;\n        }\n        s++;\n    }\n\n    return ret;\n}\n\nchar *skip_telnet_controls(const char *str)\n{\n    if (str == NULL) {\n        return NULL;\n    }\n    while (*str != 0 && (unsigned char) *str >= 240U) {\n        str++;\n    }\n    return (char *) str;\n}\n\nvoid _EXIT(const int status)\n{\n    delete_atomic_file();\n#ifdef FTPWHO\n    ftpwho_exit();\n#endif\n    _exit(status);\n}\n\nstatic char replybuf[MAX_SERVER_REPLY_LEN * 4U];\nstatic char *replybuf_pos = replybuf;\nstatic size_t replybuf_left;\n\nstatic void client_init_reply_buf(void)\n{\n    replybuf_pos = replybuf;\n    replybuf_left = sizeof replybuf - 1U;\n}\n\nvoid client_fflush(void)\n{\n    if (replybuf_pos == replybuf) {\n        return;\n    }\n    safe_write(clientfd, replybuf, (size_t) (replybuf_pos - replybuf), -1);\n    client_init_reply_buf();\n}\n\nvoid client_printf(const char * const format, ...)\n{\n    va_list va;\n    char buf[MAX_SERVER_REPLY_LEN];\n    size_t len;\n    int vlen;\n\n    va_start(va, format);\n    vlen = vsnprintf(buf, sizeof buf, format, va);\n    if (vlen < 0 || (size_t) vlen >= sizeof buf) {\n        buf[MAX_SERVER_REPLY_LEN - 1] = 0;\n        len = strlen(buf);\n    } else {\n        len = (size_t) vlen;\n    }\n    if (len >= replybuf_left) {\n        client_fflush();\n    }\n    if (len > replybuf_left) {\n        va_end(va);\n        abort();\n    }\n    memcpy(replybuf_pos, buf, len);\n    replybuf_pos += len;\n    replybuf_left -= len;\n\n    va_end(va);\n}\n\nvoid die(const int err, const int priority, const char * const format, ...)\n{\n    va_list va;\n    char line[MAX_SYSLOG_LINE];\n\n    disablesignals();\n    logging = 0;\n    va_start(va, format);\n    vsnprintf(line, sizeof line, format, va);\n    addreply(err, \"%s\", line);\n    va_end(va);\n    doreply();\n    logfile(priority, \"%s\", line);\n    _EXIT(-priority - 1);\n}\n\nvoid die_mem(void)\n{\n    die(421, LOG_ERR, MSG_OUT_OF_MEMORY);\n}\n\nstatic void sigalarm(int sig)\n{\n    (void) sig;\n    disablesignals();\n    die(421, LOG_INFO, MSG_TIMEOUT);\n}\n\n#ifndef NO_STANDALONE\nstatic void sigchild(int sig)\n{\n    const int olderrno = errno;\n    pid_t pid;\n\n    (void) sig;\n# ifdef HAVE_WAITPID\n    while ((pid = waitpid((pid_t) -1, NULL, WNOHANG)) > (pid_t) 0) {\n        if (nb_children > 0U) {\n            nb_children--;\n        }\n#  ifdef FTPWHO\n        ftpwho_unlinksbfile(pid);\n#  endif\n        iptrack_delete_pid(pid);\n    }\n# endif\n    errno = olderrno;\n}\n#endif\n\nstatic void sigterm_client(int sig)\n{\n    (void) sig;\n\n    disablesignals();\n    _EXIT(EXIT_SUCCESS);\n}\n\n#ifndef NO_STANDALONE\nstatic void sigterm(int sig)\n{\n    const int olderrno = errno;\n    (void) sig;\n\n    stop_server = 1;\n    if (listenfd != -1) {\n        shutdown(listenfd, 2);\n        (void) close(listenfd);\n    }\n    if (listenfd6 != -1) {\n        shutdown(listenfd6, 2);\n        (void) close(listenfd6);\n    }\n    errno = olderrno;\n}\n\nstatic void set_cloexec_flag(const int fd)\n{\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n}\n#endif\n\nstatic void clearargs(int argc, char **argv)\n{\n#ifndef NO_PROCNAME_CHANGE\n# if defined(__linux__) && !defined(HAVE_SETPROCTITLE)\n    int i;\n    char *first = NULL;\n    char *next = NULL;\n\n    for (i = 0; i < argc; i++) {\n        if (first == NULL) {\n            first = argv[i];\n        }\n        if (next == NULL || argv[i] == next + 1) {\n            next = argv[i] + strlen(argv[i]);\n        }\n    }\n    for (i = 0; environ[i] != NULL; i++) {\n        if (first == NULL) {\n            first = argv[i];\n        }\n        if (next == NULL) {\n            next = argv[i] + strlen(argv[i]);\n        }\n    }\n    if (first == NULL || next == NULL) {\n        return;\n    }\n    argv_lth = next - first;\n    argv0 = argv;\n    if (environ != NULL) {\n        char **new_environ;\n        unsigned int env_nb = 0U;\n\n        while (environ[env_nb] != NULL) {\n            env_nb++;\n        }\n        if ((new_environ = malloc((1U + env_nb) * sizeof (char *))) == NULL) {\n            abort();\n        }\n        new_environ[env_nb] = NULL;\n        while (env_nb > 0U) {\n            env_nb--;\n            new_environ[env_nb] = strdup(environ[env_nb]);\n        }\n        environ = new_environ;\n    }\n# else\n    (void) argc;\n    (void) argv;\n# endif\n#endif\n}\n\nvoid setprocessname(const char * const title)\n{\n#ifndef NO_PROCNAME_CHANGE\n# ifdef HAVE_SETPROCTITLE\n    setproctitle(\"-%s\", title);\n# elif defined(__linux__)\n    if (argv0 != NULL && argv_lth > strlen(title) - 2) {\n        memset(argv0[0], 0, argv_lth);\n        strncpy(argv0[0], title, argv_lth - 2);\n        argv0[1] = NULL;\n    }\n# elif defined(__hpux__)\n    union pstun pst;\n\n    pst.pst_command = title;\n    pstat(PSTAT_SETCMD, pst, strlen(title), 0, 0);\n# endif\n#endif\n    (void) title;\n}\n\n/* Check whether an address is valid, return 1 if ok, 0 otherwise.\n * Unfortunately, multicasting with the FTP protocol is impossible,\n * you have to use things like MTP instead. So prohibit multicast.\n */\n\nstatic int checkvalidaddr(const struct sockaddr_storage * const addr)\n{\n    if (addr == NULL) {\n        return 0;\n    }\n    /* Some versions of MacOS X have broken IN* macros */\n#ifdef __APPLE_CC__\n    return 1;\n#endif\n    if (STORAGE_FAMILY(*addr) == AF_INET6) {\n        if (IN6_IS_ADDR_MULTICAST(&STORAGE_SIN_ADDR6_NF_CONST(*addr)) ||\n            IN6_IS_ADDR_UNSPECIFIED(&STORAGE_SIN_ADDR6_NF_CONST(*addr))) {\n            return 0;\n        }\n        return 1;\n    } else if (STORAGE_FAMILY(*addr) == AF_INET) {\n        if (ntohl(STORAGE_SIN_ADDR_CONST(*addr)) == INADDR_ANY ||\n            ntohl(STORAGE_SIN_ADDR_CONST(*addr)) == INADDR_NONE ||\n            ntohl(STORAGE_SIN_ADDR_CONST(*addr)) == INADDR_BROADCAST ||\n            IN_MULTICAST(ntohl(STORAGE_SIN_ADDR_CONST(*addr)))) {\n            return 0;\n        }\n        return 1;\n    }\n    return 0;\n}\n\n/* Convert a 4-in-6 address to pure IPv4 */\n\nstatic void fourinsix(struct sockaddr_storage *v6)\n{\n    struct sockaddr_storage v4;\n\n    if (v6ready == 0 || STORAGE_FAMILY(*v6) != AF_INET6 ||\n        IN6_IS_ADDR_V4MAPPED(&STORAGE_SIN_ADDR6_NF_CONST(*v6)) == 0) {\n        return;\n    }\n    memset(&v4, 0, sizeof v4);\n    STORAGE_FAMILY(v4) = AF_INET;\n    memcpy(&STORAGE_SIN_ADDR(v4),\n           (unsigned char *) &STORAGE_SIN_ADDR6_CONST(*v6) + 12,\n           sizeof STORAGE_SIN_ADDR(v4));\n    STORAGE_PORT(v4) = STORAGE_PORT6_CONST(*v6);\n    SET_STORAGE_LEN(v4, sizeof(struct sockaddr_in));\n    *v6 = v4;\n}\n\n/* Return 0 if s1 == s2 , 1 if s1 != s2 , -1 if error */\n\nstatic int addrcmp(const struct sockaddr_storage * const s1,\n                   const struct sockaddr_storage * const s2)\n{\n    if (STORAGE_FAMILY(*s1) == AF_INET6) {\n        if (STORAGE_FAMILY(*s2) != AF_INET6) {\n            return 1;\n        }\n        if (IN6_ARE_ADDR_EQUAL(&STORAGE_SIN_ADDR6_NF_CONST(*s1), &STORAGE_SIN_ADDR6_NF_CONST(*s2))) {\n            return 0;\n        } else {\n            return 1;\n        }\n    } else if (STORAGE_FAMILY(*s1) == AF_INET) {\n        if (STORAGE_FAMILY(*s2) != AF_INET) {\n            return 1;\n        }\n        if (STORAGE_SIN_ADDR_CONST(*s1) == STORAGE_SIN_ADDR_CONST(*s2)) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n    return -1;\n}\n\nstatic int generic_aton(const char *src, struct sockaddr_storage *a)\n{\n    if (inet_pton(AF_INET6, src, &STORAGE_SIN_ADDR6(*a)) > 0) {\n        STORAGE_FAMILY(*a) = AF_INET6;\n        return 0;\n    }\n    if (inet_pton(AF_INET, src, &STORAGE_SIN_ADDR(*a)) > 0) {\n        STORAGE_FAMILY(*a) = AF_INET;\n        return 0;\n    }\n    memset(a, 0, sizeof *a);\n\n    return -1;\n}\n\nvoid logfile(const int crit, const char *format, ...)\n{\n#if defined(NON_ROOT_FTP)\n    (void) crit;\n    (void) format;\n#else\n    const char *urgency;\n    va_list va;\n    char line[MAX_SYSLOG_LINE];\n\n    if (no_syslog != 0) {\n        va_end(va);\n        return;\n    }\n    va_start(va, format);\n    vsnprintf(line, sizeof line, format, va);\n    va_end(va);\n    switch (crit) {\n    case LOG_INFO:\n        urgency = \"[INFO] \";\n        break;\n    case LOG_WARNING:\n        urgency = \"[WARNING] \";\n        break;\n    case LOG_ERR:\n        urgency = \"[ERROR] \";\n        break;\n    case LOG_NOTICE:\n        urgency = \"[NOTICE] \";\n        break;\n    case LOG_DEBUG:\n        urgency = \"[DEBUG] \";\n        break;\n    default:\n        urgency = \"\";\n    }\n# ifdef SAVE_DESCRIPTORS\n    openlog(\"pure-ftpd\", log_pid, syslog_facility);\n# endif\n    syslog(crit, \"(%s@%s) %s%s\",\n           ((loggedin != 0 && *account != 0) ? account : \"?\"),\n           (*host != 0 ? host : \"?\"),\n           urgency, line);\n# ifdef SAVE_DESCRIPTORS\n    closelog();\n# endif\n#endif\n}\n\n#ifndef NO_STANDALONE\n\n/* this is taken from the code examples for Stevens' \"Advanced\n * Programming in the Unix Environment. The code is publicly available\n * at ftp://ftp.uu.net/published/books/stevens.advprog.tar.Z */\n\nstatic unsigned int open_max(void)\n{\n    long z;\n\n    if ((z = (long) sysconf(_SC_OPEN_MAX)) < 0L) {\n        perror(\"_SC_OPEN_MAX\");\n        _EXIT(EXIT_FAILURE);\n    }\n    return (unsigned int) z;\n}\n\n#endif\n\nstatic void addreply_newline(const char * const str, const size_t size)\n{\n    struct reply *newline;\n\n    if ((newline = (struct reply *) malloc(offsetof(struct reply, line) +\n                                           size)) == NULL) {\n        die_mem();\n    }\n    if (firstreply == NULL) {\n        firstreply = newline;\n    } else {\n        lastreply->next = newline;\n    }\n    newline->next = NULL;\n    lastreply = newline;\n    memcpy(newline->line, str, size);\n}\n\nvoid addreply_noformat(const int code, const char * const line)\n{\n    if (code != 0) {\n        replycode = code;\n    }\n    addreply_newline(line, strlen(line) + (size_t) 1U);\n}\n\nvoid addreply(const int code, const char * const line, ...)\n{\n    char *a;\n    char *b;\n    va_list ap;\n    int last;\n    char buf[MAX_SERVER_REPLY_LEN];\n\n    if (code != 0) {\n        replycode = code;\n    }\n    va_start(ap, line);\n    vsnprintf(buf, sizeof buf, line, ap);\n    va_end(ap);\n    last = 0;\n    a = buf;\n    for (;;) {\n        b = strchr(a, '\\n');\n        if (b != NULL) {\n            *b = 0;\n        } else {\n            b = a;\n            while (*b != 0) {\n                b++;\n            }\n            last++;\n        }\n        addreply_newline(a, (size_t) (b - a) + (size_t) 1U);\n        if (last != 0) {\n            break;\n        }\n        a = b + 1;\n    }\n}\n\nvoid doreply(void)\n{\n    struct reply *scannedentry;\n    struct reply *nextentry;\n\n    if ((scannedentry = firstreply) == NULL) {\n        return;\n    }\n    do {\n        nextentry = scannedentry->next;\n#ifdef WITH_TLS\n        if (tls_cnx != NULL) {\n            char buf[MAX_SERVER_REPLY_LEN];\n\n            snprintf(buf, sizeof buf, \"%3d%c%s\\r\\n\", replycode,\n                     nextentry == NULL ? ' ' : '-', scannedentry->line);\n            SSL_write(tls_cnx, buf, strlen(buf));\n        } else\n#endif\n        {\n            client_printf(\"%3d%c%s\\r\\n\", replycode,\n                          nextentry == NULL ? ' ' : '-',\n                          scannedentry->line);\n        }\n        if (logging > 1) {\n            logfile(LOG_DEBUG, \"%3d%c%s\", replycode,\n                    nextentry == NULL ? ' ' : '-', scannedentry->line);\n        }\n    } while ((scannedentry = nextentry) != NULL);\n    client_fflush();\n    scannedentry = firstreply;\n    do {\n        nextentry = scannedentry->next;\n        free(scannedentry);\n    } while ((scannedentry = nextentry) != NULL);\n    firstreply = lastreply = NULL;\n}\n\n/* Check whether a file name is valid. Files names starting\n * with a dot are only allowed to root and to users\n * chroot()ed in their home directories -Jedi. */\n\nstatic int checknamesanity(const char *name, int dot_ok)\n{\n    const char *namepnt;\n\n#ifdef PARANOID_FILE_NAMES\n    const char *validchars =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        \"abcdefgihjklmnopqrstuvwxyz\"\n        \"0123456789./-_\";\n#endif\n\n    if (name == NULL || *name == 0) {\n        return -1;\n    }\n    /* optimize . and .. */\n    if (name[0] == '.' && (name[1] == 0 || (name[1] == '.' && name[2] == 0))) {\n        return 0;\n    }\n    namepnt = name;\n#ifdef PARANOID_FILE_NAMES\n    /* we want to make sure we don't get any non-alphanumeric file name */\n    if (strlen(namepnt) != strspn(namepnt, validchars)) {\n        return -1;\n    }\n#endif\n#ifdef QUOTAS\n    if (hasquota() == 0) {\n        if (strstr(namepnt, QUOTA_FILE) != NULL) {\n            return -1;                     /* .ftpquota => *NO* */\n        }\n# ifndef ALLOW_DELETION_OF_TEMPORARY_FILES\n        if (strstr(namepnt, PUREFTPD_TMPFILE_PREFIX) == namepnt) {\n            return -1;\n        }\n# endif\n    }\n#endif\n    while (*namepnt != 0) {\n#ifndef ALLOW_EVERYTHING_IN_FILE_NAMES\n        if (ISCTRLCODE(*namepnt) || *namepnt == '\\\\') {\n            return -1;\n        }\n#endif\n        if (dot_ok == 0) {\n            if (*namepnt == '/') {\n                namepnt++;\n            } else if (namepnt != name) {\n                namepnt++;\n                continue;\n            }\n            if (namepnt[0] == 0) {     /* /$ */\n                return 0;\n            }\n            if (namepnt[0] == '.') {   /* /. */\n                if (namepnt[1] == 0) { /* /.$ => ok */\n                    return 0;\n                }\n                if (namepnt[1] == '.') {   /* /.. */\n                    if (namepnt[2] == 0) {   /* /..$ => ok */\n                        return 0;\n                    }\n                    if (namepnt[2] != '/') {   /* /..[^/] => *NO* */\n                        return -1;\n                    }\n                } else if (namepnt[1] != '/') {   /* /.[^/]/ => *NO* */\n                    return -1;\n                }\n            }\n            if (namepnt != name) {\n                continue;\n            }\n        }\n        namepnt++;\n    }\n    return 0;\n}\n\nstatic void do_ipv6_port(char *p, char delim)\n{\n    char *deb;\n    struct sockaddr_storage a;\n\n    deb = p;\n    while (*p && strchr(\"0123456789abcdefABCDEF:\", *p) != NULL) {\n        p++;\n    }\n    if (*p != delim || atoi(p + 1) == 0) {\n        nope:\n        (void) close(datafd);\n        datafd = -1;\n        addreply_noformat(501, MSG_SYNTAX_ERROR_IP);\n        return;\n    }\n    *p++ = 0;\n    if (generic_aton(deb, &a) != 0) {\n        goto nope;\n    }\n    doport2(a, (unsigned int) atoi(p));\n}\n\n#ifndef MINIMAL\nvoid doesta(void)\n{\n    struct sockaddr_storage dataconn;\n    socklen_t socksize;\n    char hbuf[NI_MAXHOST];\n    char pbuf[NI_MAXSERV];\n\n    if (passive != 0 || datafd == -1) {\n        addreply_noformat(520, MSG_ACTIVE_DISABLED);\n        return;\n    }\n    if (xferfd == -1) {\n        opendata();\n        if (xferfd == -1) {\n            addreply_noformat(425, MSG_CANT_CREATE_DATA_SOCKET);\n            return;\n        }\n    }\n    socksize = (socklen_t) sizeof dataconn;\n    if (getsockname(xferfd, (struct sockaddr *) &dataconn, &socksize) < 0 ||\n        getnameinfo((struct sockaddr *) &dataconn, STORAGE_LEN(dataconn),\n                    hbuf, sizeof hbuf, pbuf, sizeof pbuf,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n        addreply_noformat(425, MSG_GETSOCKNAME_DATA);\n        closedata();\n        return;\n    }\n    addreply(225, \"Connected from (|%c|%s|%s|)\",\n             STORAGE_FAMILY(dataconn) == AF_INET6 ? '2' : '1', hbuf, pbuf);\n}\n\nvoid doestp(void)\n{\n    struct sockaddr_storage dataconn;\n    socklen_t socksize;\n    char hbuf[NI_MAXHOST];\n    char pbuf[NI_MAXSERV];\n\n    if (passive == 0 || datafd == -1) {\n        addreply_noformat(520, MSG_CANT_PASSIVE);\n        return;\n    }\n    if (xferfd == -1) {\n        opendata();\n        if (xferfd == -1) {\n            addreply_noformat(425, MSG_CANT_CREATE_DATA_SOCKET);\n            return;\n        }\n    }\n    socksize = (socklen_t) sizeof dataconn;\n    if (getpeername(xferfd, (struct sockaddr *) &dataconn, &socksize) < 0 ||\n        getnameinfo((struct sockaddr *) &dataconn, STORAGE_LEN(dataconn),\n                    hbuf, sizeof hbuf, pbuf, sizeof pbuf,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n        addreply_noformat(425, MSG_GETSOCKNAME_DATA);\n        closedata();\n        return;\n    }\n    addreply(225, \"Connected to (|%c|%s|%s|)\",\n             STORAGE_FAMILY(dataconn) == AF_INET6 ? '2' : '1', hbuf, pbuf);\n}\n#endif\n\nvoid doeprt(char *p)\n{\n    char delim;\n    int family;\n\n    delim = *p++;\n    family = atoi(p);\n    while (isdigit((unsigned char) *p)) {\n        p++;\n    }\n    if (*p == delim) {\n        p++;\n    } else {\n        addreply_noformat(501, MSG_SYNTAX_ERROR_IP);\n        return;\n    }\n    if (family == 2 && v6ready) {\n        do_ipv6_port(p, delim);\n        return;\n    }\n    if (family != 1) {\n        if (v6ready) {\n            addreply_noformat(522, MSG_ONLY_IPV4V6);\n        } else {\n            addreply_noformat(522, MSG_ONLY_IPV4);\n        }\n        return;\n    }\n\n    {\n        unsigned int a1, a2, a3, a4, port = 0U;\n        /* there should be dot-decimal ip as rfc2428 states,\n         * but troll used for some reason \"comma-decimal\" notation\n         * so I decided to leave it */\n        if ((sscanf(p, \"%u,%u,%u,%u\", &a1, &a2, &a3, &a4) != 4 &&\n             sscanf(p, \"%u.%u.%u.%u\", &a1, &a2, &a3, &a4) != 4) ||\n            a1 > 255U || a2 > 255U || a3 > 255U || a4 > 255U ||\n            (a1 | a2 | a3 | a4) == 0U) {\n            addreply_noformat(501, MSG_SYNTAX_ERROR_IP);\n            return;\n        }\n        while (*p && strchr(\"0123456789.,\", *p)) {\n            p++;\n        }\n        if (*p == delim) {\n            port = (unsigned int) atoi(++p);\n            while (*p && isdigit((unsigned char) *p)) {\n                p++;\n            }\n        }\n        if (*p != delim || port > 65535U || port <= 0U) {\n            addreply_noformat(501, MSG_SYNTAX_ERROR_IP);\n            return;\n        } else {\n            struct sockaddr_storage a;\n\n            memset(&a, 0, sizeof a);\n            STORAGE_FAMILY(a) = AF_INET;\n            STORAGE_SIN_ADDR(a) =\n                htonl(((uint32_t) a1 << 24) |\n                      ((uint32_t) a2 << 16) | (a3 << 8) | a4);\n            SET_STORAGE_LEN(a, sizeof(struct sockaddr_in));\n            doport2(a, port);\n        }\n    }\n}\n\nvoid stripctrl(char * const buf, size_t len)\n{\n    if (len <= (size_t) 0U) {\n        return;\n    }\n    do {\n        len--;\n        if (ISCTRLCODE(buf[len]) &&\n            buf[len] != 0 && buf[len] != '\\n') {\n            buf[len] = '_';\n        }\n    } while (len != (size_t) 0U);\n}\n\n#ifndef MINIMAL\n\n/*\n * small help routine to display a banner\n * type = 0 reads .banner/welcome.msg\n * type = 1 reads .message (after cd'ing into a directory)\n */\nvoid dobanner(const int type)\n{\n    char buffer[512];\n    FILE *msg;\n    size_t buflen;\n    unsigned int nblines = BANNER_MAXLINES;\n\n    switch (type) {\n    case 0:\n        if ((msg = fopen(\".banner\", \"r\")) == NULL\n# ifdef WITH_WELCOME_MSG\n            && (msg = fopen(\"welcome.msg\", \"r\")) == NULL\n# endif\n            ) {\n            return;\n        }\n        break;\n    case 1:\n        if ((msg = fopen(\".message\", \"r\")) == NULL) {\n            return;\n        }\n        break;\n    default:\n        return;\n    }\n\n    while (fgets(buffer, sizeof buffer, msg) != NULL && nblines > 0U) {\n        nblines--;\n        if ((buflen = strlen(buffer)) > (size_t) 0U) {\n            buflen--;\n            while (buffer[buflen] == '\\n' || buffer[buflen] == '\\r') {\n                buffer[buflen] = 0;\n                if (buflen == (size_t) 0U) {\n                    break;\n                }\n                buflen--;\n            }\n            stripctrl(buffer, buflen);\n        }\n        addreply_noformat(0, buffer);\n    }\n    (void) fclose(msg);\n}\n\n#endif\n\n#ifndef MINIMAL\n\nint modernformat(const char *file, char *target, size_t target_size,\n                 const char * const prefix)\n{\n    char link_target[PATH_MAX + 1U];\n    const char *ft;\n    const char *ftx = \"\";\n    struct tm *t;\n    struct stat st;\n    int ret = 0;\n\n    if (lstat(file, &st) != 0 || !(t = gmtime((time_t *) &st.st_mtime))) {\n        return -1;\n    }\n#if !defined(MINIMAL) && !defined(ALWAYS_SHOW_SYMLINKS_AS_SYMLINKS)\n    if (\n# ifndef ALWAYS_SHOW_RESOLVED_SYMLINKS\n        broken_client_compat != 0 &&\n# endif\n        S_ISLNK(st.st_mode)) {\n        struct stat sts;\n\n        if (stat(file, &sts) == 0 && !S_ISLNK(sts.st_mode)) {\n            st = sts;\n        }\n    } /* Show non-dangling symlinks as files/directories */\n#endif\n    if (S_ISREG(st.st_mode)) {\n        ft = \"file\";\n    } else if (S_ISDIR(st.st_mode)) {\n        ret = 1;\n        ft = \"dir\";\n        if (*file == '.') {\n            if (file[1] == '.' && file[2] == 0) {\n                ft = \"pdir\";\n            } else if (file[1] == 0) {\n                ft = \"cdir\";\n            }\n        } else if (*file == '/' && file[1] == 0) {\n            ft = \"pdir\";\n        }\n    } else if (S_ISLNK(st.st_mode)) {\n        ssize_t sx;\n\n        ft = \"OS.unix=symlink\";\n        if ((sx = readlink(file, link_target, sizeof link_target - 1U)) > 0) {\n            link_target[sx] = 0;\n            if (strpbrk(link_target, \"\\r\\n;\") == NULL) {\n                ftx = link_target;\n                ft = \"OS.unix=slink:\";\n            }\n        }\n    } else {\n        ft = \"unknown\";\n    }\n    if (guest != 0) {\n        if (SNCHECK(snprintf(target, target_size,\n                             \"%stype=%s%s;siz%c=%llu;modify=%04d%02d%02d%02d%02d%02d;UNIX.mode=0%o;unique=%xg%llx; %s\",\n                             prefix,\n                             ft, ftx,\n                             ret ? 'd' : 'e',\n                             (unsigned long long) st.st_size,\n                             t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                             t->tm_hour, t->tm_min, t->tm_sec,\n                             (unsigned int) st.st_mode & 07777,\n                             (unsigned int) st.st_dev,\n                             (unsigned long long) st.st_ino,\n                             file), target_size)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    } else {\n        if (SNCHECK(snprintf(target, target_size,\n                             \"%stype=%s;siz%c=%llu;modify=%04d%02d%02d%02d%02d%02d;UNIX.mode=0%o;UNIX.uid=%lld;UNIX.gid=%lld;unique=%xg%llx; %s\",\n                             prefix,\n                             ft,\n                             ret ? 'd' : 'e',\n                             (unsigned long long) st.st_size,\n                             t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                             t->tm_hour, t->tm_min, t->tm_sec,\n                             (unsigned int) st.st_mode & 07777,\n                             (unsigned long long) st.st_uid,\n                             (unsigned long long) st.st_gid,\n                             (unsigned int) st.st_dev,\n                             (unsigned long long) st.st_ino,\n                             file), target_size)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    }\n    return ret;\n}\n\n#define MLST_BEGIN \"Begin\" CRLF\n\nvoid domlst(const char * const file)\n{\n    char line[PATH_MAX + 256U] = MLST_BEGIN;\n\n    if (modernformat(file, line + (sizeof MLST_BEGIN - 1U),\n                     sizeof line - (sizeof MLST_BEGIN - 1U), \" \") < 0) {\n        addreply_noformat(550, MSG_STAT_FAILURE2);\n        return;\n    }\n    addreply_noformat(0, line);\n    addreply_noformat(250, \"End.\");\n}\n\nvoid donoop(void)\n{\n#ifdef BORING_MODE\n    addreply_noformat(200, \"dc.w $4E71\");\n#else\n    addreply_noformat(200, MSG_SLEEPING);\n#endif\n}\n\nvoid doallo(const off_t size)\n{\n    int ret = -1;\n#ifdef QUOTAS\n    Quota quota;\n#endif\n\n    if (size <= 0) {\n        ret = 0;\n    } else if (ul_check_free_space(wd, (double) size) != 0) {\n        ret = 0;\n    }\n#ifdef QUOTAS\n    if (quota_update(&quota, 0LL, 0LL, NULL) == 0) {\n        if (quota.files >= user_quota_files ||\n            quota.size >= user_quota_size ||\n            (unsigned long long) size > user_quota_size - quota.size) {\n            ret = -1;\n        }\n    }\n#endif\n    if (ret == 0) {\n#ifdef DISABLE_HUMOR\n        addreply_noformat(200, \"OK\");\n#else\n        addreply_noformat(200, \"A L'HUILE\");\n#endif\n    } else {\n        addreply_noformat(552, MSG_NO_DISK_SPACE);\n    }\n}\n\n#endif\n\nvoid dositetime(void)\n{\n    char tmp[64];\n    const struct tm *tm;\n    time_t now;\n\n    if ((now = time(NULL)) == (time_t) -1 || (tm = localtime(&now)) == NULL) {\n        addreply_noformat(451, \"time()\");\n        return;\n    }\n    strftime(tmp, sizeof tmp, \"%Y-%m-%d %H:%M:%S\", tm);\n    addreply_noformat(211, tmp);\n}\n\nstatic int doinitsupgroups(const char *user, const uid_t uid, const gid_t gid)\n{\n#ifndef NON_ROOT_FTP\n# ifdef HAVE_SETGROUPS\n    if (setgroups(1U, &gid) != 0) {\n        return -1;\n    }\n# else\n    (void) gid;\n# endif\n# ifdef HAVE_INITGROUPS\n    if (user == NULL) {\n        const struct passwd * const lpwd = getpwuid(uid);\n\n        if (lpwd != NULL && lpwd->pw_name != NULL) {\n            user = lpwd->pw_name;\n        } else {\n            return 0;\n        }\n    }\n    initgroups(user, gid);\n# else\n    (void) user;\n    (void) uid;\n# endif\n#else\n    (void) user;\n    (void) uid;\n    (void) gid;\n#endif\n    return 0;\n}\n\nvoid douser(const char *username)\n{\n    struct passwd *pw = NULL;\n\n    if (loggedin) {\n        if (username) {\n            if (!guest) {\n                addreply_noformat(530, MSG_ALREADY_LOGGED);\n            } else if (broken_client_compat != 0) {\n                addreply_noformat(331, MSG_ANY_PASSWORD);\n            } else {\n                addreply_noformat(230, MSG_ANONYMOUS_LOGGED);\n                dot_read_ok = dot_read_anon_ok;\n                dot_write_ok = 0;\n            }\n        }\n        return;\n    }\n    if (anon_only <= 0 && username != NULL && *username != 0 &&\n        (anon_only < 0 || (strcasecmp(username, \"ftp\") &&\n                           strcasecmp(username, \"anonymous\")))) {\n        strncpy(account, username, sizeof(account) - 1);\n        account[sizeof(account) - (size_t) 1U] = 0;\n        addreply(331, MSG_USER_OK, account);\n        loggedin = 0;\n    } else if (anon_only < 0) {\n        if (broken_client_compat != 0) {\n            addreply(331, MSG_USER_OK, username);\n            return;\n        } else {\n            die(530, LOG_DEBUG, MSG_NO_ANONYMOUS_LOGIN);\n        }\n    } else {\n#ifdef WITH_VIRTUAL_HOSTS\n        char name[PATH_MAX];\n        char hbuf[NI_MAXHOST];\n#endif\n        if (chrooted != 0) {\n            die(421, LOG_DEBUG, MSG_CANT_DO_TWICE);\n        }\n\n#ifdef PER_USER_LIMITS\n        if (per_anon_max > 0U && ftpwho_read_count(\"ftp\") >= per_anon_max) {\n            addreply(421, MSG_PERUSER_MAX, (unsigned long) per_anon_max);\n            doreply();\n            _EXIT(1);\n        }\n#endif\n\n#ifdef NON_ROOT_FTP\n        {\n            static struct passwd pw_;\n            char s[PATH_MAX + 1U];\n\n            if (getcwd(s, sizeof s - (size_t) 1U) == NULL) {\n                cantsec:\n                die(421, LOG_ERR, MSG_UNABLE_SECURE_ANON);\n            }\n            pw_.pw_uid = geteuid();\n            pw_.pw_gid = getegid();\n            pw_.pw_dir = (char *) NON_ROOT_ANON_DIR;\n            if (home_directory != NULL) {\n                pw_.pw_dir = (char *) home_directory;\n            }\n            if (getenv(\"FTP_ANON_DIR\") != NULL) {\n                pw_.pw_dir = getenv(\"FTP_ANON_DIR\");\n            }\n            if (pw_.pw_dir == NULL) {\n                pw_.pw_dir = strdup(s);    /* checked for == NULL later */\n            }\n            pw = &pw_;\n        }\n#else\n        if (((pw = getpwnam(\"ftp\")) == NULL &&\n             (pw = getpwnam(\"_ftp\")) == NULL) ||\n            pw->pw_uid == 0 || pw->pw_gid == 0 ||\n            (doinitsupgroups(\"ftp\", (uid_t) -1, pw->pw_gid) != 0 &&\n             doinitsupgroups(\"_ftp\", (uid_t) -1, pw->pw_gid) != 0) ||\n            setgid(pw->pw_gid) || setegid(pw->pw_gid)) {\n            cantsec:\n            die(421, LOG_ERR, MSG_UNABLE_SECURE_ANON);\n        }\n# ifdef ANON_DIR\n        if ((pw->pw_dir = strdup(ANON_DIR)) == NULL) {\n            die_mem();\n        }\n# endif\n#endif\n#ifdef WITH_VIRTUAL_HOSTS\n        if (getnameinfo((struct sockaddr *) &ctrlconn, STORAGE_LEN(ctrlconn),\n                        hbuf, sizeof hbuf, NULL,\n                        (size_t) 0U, NI_NUMERICHOST) != 0\n            || SNCHECK(snprintf(name, sizeof name, VHOST_PATH \"/%s\", hbuf),\n                       sizeof name)) {\n            _EXIT(EXIT_FAILURE);\n        }\n        if (chdir(name) != 0)         /* non-virtual */\n#endif\n        {\n            char *hd;\n            size_t rd_len;\n\n            if (pw->pw_dir == NULL || *pw->pw_dir != '/') {\n                goto cantsec;\n            }\n            if ((hd = strstr(pw->pw_dir, \"/./\")) != NULL) {\n                rd_len = (size_t) (hd - pw->pw_dir) + sizeof \"/\";\n                if ((root_directory = malloc(rd_len)) == NULL) {\n                    goto cantsec;\n                }\n                memcpy(root_directory, pw->pw_dir, rd_len);\n                root_directory[rd_len - (size_t) 1U] = 0;\n                hd += 2;\n            } else {\n                rd_len = strlen(pw->pw_dir) + sizeof \"/\";\n                if ((root_directory = malloc(rd_len)) == NULL) {\n                    goto cantsec;\n                }\n                snprintf(root_directory, rd_len, \"%s/\", pw->pw_dir);\n                hd = (char *) \"/\";\n            }\n            if (chdir(root_directory) || chroot(root_directory) || chdir(hd)) {\n                die(421, LOG_ERR, MSG_CANT_CHANGE_DIR \" [%s]\", root_directory, hd);\n            }\n            logfile(LOG_INFO, MSG_ANONYMOUS_LOGGED);\n        }\n#ifdef WITH_VIRTUAL_HOSTS\n        else {                       /* virtual host */\n            const size_t rd_len = strlen(hbuf) + sizeof \":/\";\n\n            if ((root_directory = malloc(rd_len)) == NULL ||\n                chdir(name) || chroot(name) || chdir(\"/\") ||\n                SNCHECK(snprintf(root_directory, rd_len, \"%s:/\", hbuf),\n                        rd_len)) {\n                goto cantsec;\n            }\n            logfile(LOG_INFO, MSG_ANONYMOUS_LOGGED_VIRTUAL \": %s\", hbuf);\n        }\n#endif\n        if (pw == NULL) {\n            goto cantsec;\n        }\n        chrooted = 1;\n        authresult.uid = pw->pw_uid;\n        authresult.gid = pw->pw_gid;\n        if ((authresult.dir = strdup(pw->pw_dir)) == NULL) {\n            die_mem();\n        }\n\n#ifdef THROTTLING\n        if (throttling != 0) {\n            addreply_noformat(0, MSG_BANDWIDTH_RESTRICTED);\n            (void) nice(NICE_VALUE);\n        } else {\n            throttling_delay = throttling_bandwidth_ul =\n                throttling_bandwidth_dl = 0UL;\n        }\n#endif\n\n#ifndef NON_ROOT_FTP\n        if (authresult.uid > (uid_t) 0) {\n# ifndef WITHOUT_PRIVSEP\n            if (setuid(authresult.uid) != 0 || seteuid(authresult.uid) != 0) {\n                goto cantsec;\n            }\n# else\n            if (seteuid(authresult.uid) != 0) {\n                goto cantsec;\n            }\n#  ifdef USE_CAPABILITIES\n            drop_login_caps();\n#  endif\n# endif\n        }\n#endif\n\n#ifndef MINIMAL\n        dobanner(0);\n#endif\n\n        if (broken_client_compat != 0) {\n            addreply_noformat(331, MSG_ANONYMOUS_ANY_PASSWORD);\n        } else {\n            addreply_noformat(230, MSG_ANONYMOUS_LOGGED);\n        }\n        dot_write_ok = 0;\n        dot_read_ok = dot_read_anon_ok;\n        strncpy(account, \"ftp\", sizeof account - (size_t) 1U);\n        account[(sizeof account) - 1U] = 0;\n#ifdef FTPWHO\n        if (shm_data_cur != NULL) {\n            ftpwho_lock();\n            strncpy(shm_data_cur->account, account,\n                    sizeof shm_data_cur->account - (size_t) 1U);\n            shm_data_cur->account[sizeof shm_data_cur->account - 1U] = 0;\n            ftpwho_unlock();\n            state_needs_update = 1;\n        }\n#endif\n        loggedin = guest = 1;\n#ifdef QUOTAS\n        user_quota_size = user_quota_files = ULONG_LONG_MAX;\n#endif\n    }\n    if (getcwd(wd, sizeof wd - (size_t) 1U) == NULL) {\n        wd[0] = '/';\n        wd[1] = 0;\n    }\n#ifdef WITH_BONJOUR\n    refreshManager();\n#endif\n}\n\nstatic AuthResult pw_check(const char *account, const char *password,\n                           const struct sockaddr_storage * const sa,\n                           const struct sockaddr_storage * const peer)\n{\n    Authentications *auth_scan = first_authentications;\n    AuthResult result;\n\n    result.auth_ok = -1;\n    while (auth_scan != NULL) {\n#ifdef THROTTLING\n        result.throttling_bandwidth_ul = throttling_bandwidth_ul;\n        result.throttling_bandwidth_dl = throttling_bandwidth_dl;\n        result.throttling_ul_changed = result.throttling_dl_changed = 0;\n#endif\n#ifdef QUOTAS\n        result.user_quota_size = user_quota_size;\n        result.user_quota_files = user_quota_files;\n        result.quota_size_changed = result.quota_files_changed = 0;\n#endif\n#ifdef RATIOS\n        result.ratio_upload = ratio_upload;\n        result.ratio_download = ratio_download;\n        result.ratio_ul_changed = result.ratio_dl_changed = 0;\n#endif\n#ifdef PER_USER_LIMITS\n        result.per_user_max = per_user_max;\n#endif\n        result.backend_data = NULL;\n        auth_scan->auth->check(&result, account, password, sa, peer);\n        if (result.auth_ok < 0) {\n            break;\n        } else if (result.auth_ok > 0) {\n#ifdef THROTTLING\n            if ((result.throttling_ul_changed |\n                 result.throttling_dl_changed) != 0) {\n                if (result.throttling_ul_changed != 0 &&\n                    result.throttling_bandwidth_ul > 0UL) {\n                    throttling_bandwidth_ul = result.throttling_bandwidth_ul;\n                }\n                if (result.throttling_dl_changed != 0 &&\n                    result.throttling_bandwidth_dl > 0UL) {\n                    throttling_bandwidth_dl = result.throttling_bandwidth_dl;\n                }\n                throttling_delay = 1000000 /\n                    (throttling_bandwidth_dl | throttling_bandwidth_ul);\n                throttling = 2;\n            }\n#endif\n#ifdef QUOTAS\n            if (result.quota_size_changed != 0) {\n                user_quota_size = result.user_quota_size;\n            }\n            if (result.quota_files_changed != 0) {\n                user_quota_files = result.user_quota_files;\n            }\n#endif\n#ifdef RATIOS\n            if (result.ratio_ul_changed != 0) {\n                ratio_upload = result.ratio_upload;\n                ratio_for_non_anon = 1;\n            }\n            if (result.ratio_dl_changed != 0) {\n                ratio_download = result.ratio_download;\n            }\n#endif\n#ifdef PER_USER_LIMITS\n            per_user_max = result.per_user_max;\n#endif\n\n#ifdef NON_ROOT_FTP\n            result.uid = geteuid();\n            result.gid = getegid();\n#endif\n\n            return result;\n        }\n        auth_scan = auth_scan->next;\n    }\n\n    return result;\n}\n\n/*\n * Check if an user belongs to the trusted group, either in his\n * primary group, or his supplementary groups. Root is always trusted.\n */\n\nstatic int check_trustedgroup(const uid_t uid, const gid_t gid)\n{\n    GETGROUPS_T *alloca_suppgroups;\n    int n;\n    int n2;\n    int result = 0;\n\n    if (uid == (uid_t) 0) {\n        return 1;\n    }\n    if (userchroot == 2) {\n        return 0;\n    }\n    if (gid == chroot_trustedgid) {\n        return 1;\n    }\n#ifdef HAVE_GETGROUPS\n    if ((n = getgroups(0, NULL)) <= 0) {\n        return 0;\n    }\n    if ((alloca_suppgroups =\n         ALLOCA(n * (sizeof *alloca_suppgroups))) == NULL) {\n        die_mem();\n    }\n    n2 = getgroups(n, alloca_suppgroups);\n    /* Jedi's paranoia */\n    if (n2 < n) {\n        n = n2;\n    }\n    result = 0;\n    while (n != 0) {\n        n--;\n        if (alloca_suppgroups[n] == (GETGROUPS_T) chroot_trustedgid) {\n            result = 1;\n            break;\n        }\n    };\n    ALLOCA_FREE(alloca_suppgroups);\n#endif\n\n    return result;\n}\n\n/*\n * Create a home directory on demand.\n */\n\nstatic int create_home_and_chdir(const char * const home)\n{\n    char *pathcomp;\n    char *z;\n    size_t len;\n    const char delim = '/';\n\n    if (home == NULL || *home != '/') {\n        return -1;\n    }\n    if (chdir(home) == 0) {\n        return 0;\n    }\n    if (create_home == 0) {\n        return -1;\n    }\n    len = strlen(home) + (size_t) 1U;\n    if (len < (size_t) 2U || *home != delim) {\n        return -1;\n    }\n    if ((pathcomp = ALLOCA(len)) == NULL) {\n        return -1;\n    }\n    memcpy(pathcomp, home, len);       /* safe, no possible overflow */\n    z = pathcomp;\n    for (;;) {\n        z++;\n        if (*z == 0) {\n            break;\n        }\n        if (*z == delim) {\n            *z = 0;\n            if (z[1] == 0) {\n                break;\n            }\n            (void) mkdir(pathcomp, (mode_t) 0755);\n            *z = delim;\n        }\n    }\n    ALLOCA_FREE(pathcomp);\n    (void) mkdir(home, (mode_t) 0700);\n    if (chdir(home) != 0) {\n        return -1;\n    }\n    if (chmod(home, (mode_t) 0777 & ~u_mask_d) < 0 ||\n        chown(home, authresult.uid, authresult.gid) < 0) {\n        return -1;\n    }\n\n    return chdir(home);\n}\n\nstatic void randomsleep(unsigned int t) {\n    usleep2((unsigned long) (zrand() % PASSWD_FAILURE_DELAY));\n    usleep2(t * PASSWD_FAILURE_DELAY);\n}\n\nvoid dopass(char *password)\n{\n    static unsigned int tapping;\n    char *hd;\n#if !defined(MINIMAL) && defined(HAVE_GETGROUPS) && defined(DISPLAY_GROUPS)\n    gid_t *groups = NULL;\n    int ngroups;\n# if defined(NGROUPS_MAX) && NGROUPS_MAX > 0\n    int ngroups_max = NGROUPS_MAX; /* Use the compile time value */\n# else\n    int ngroups_max = 1; /* use a sane default */\n# endif\n#endif\n\n    if (loggedin != 0) {\n        if (guest != 0) {\n            addreply_noformat(230, MSG_NO_PASSWORD_NEEDED);\n#ifdef LOG_ANON_EMAIL\n            snprintf(account, sizeof account, \"ftp: <%s> \", password);\n#endif\n        } else {\n            addreply_noformat(530, MSG_CANT_DO_TWICE);\n        }\n        return;\n    }\n    if (*account == 0) {\n        addreply_noformat(530, MSG_WHOAREYOU);\n        return;\n    }\n    if (strlen(password) >= MAX_PASSWORD_LEN) {\n        addreply_noformat(530, MSG_LINE_TOO_LONG);\n        return;\n    }\n    authresult = pw_check(account, password, &ctrlconn, &peer);\n    pure_memzero(password, strlen(password));\n    if (authresult.auth_ok != 1) {\n        tapping++;\n        randomsleep(tapping);\n        addreply_noformat(530, MSG_AUTH_FAILED);\n        doreply();\n        if (tapping > MAX_PASSWD_TRIES) {\n            logfile(LOG_ERR, MSG_AUTH_TOOMANY);\n            _EXIT(EXIT_FAILURE);\n        }\n        logfile(LOG_WARNING, MSG_AUTH_FAILED_LOG, account);\n        return;\n    }\n    if (authresult.uid < useruid) {\n        logfile(LOG_WARNING, MSG_ACCOUNT_DISABLED \" (uid < %lu)\",\n                account, (unsigned long) useruid);\n        randomsleep(tapping);\n        if (tapping >= MAX_PASSWD_TRIES) {\n            addreply_noformat(530, MSG_AUTH_FAILED);\n            doreply();\n            _EXIT(EXIT_FAILURE);\n        }\n        addreply_noformat(530, MSG_NOTRUST);\n        doreply();\n        return;\n    }\n\n#ifdef PER_USER_LIMITS\n    if (per_user_max > 0U && ftpwho_read_count(account) >= per_user_max) {\n        addreply(421, MSG_PERUSER_MAX, (unsigned long) per_user_max);\n        doreply();\n        _EXIT(1);\n    }\n#endif\n\n    /* Add username and primary group to the uid/gid cache */\n    (void) getname(authresult.uid);\n    (void) getgroup(authresult.gid);\n\n    if (\n#if defined(WITH_LDAP) || defined(WITH_MYSQL) || defined(WITH_PGSQL) || defined(WITH_PUREDB) || defined(WITH_EXTAUTH)\n        doinitsupgroups(NULL, authresult.uid, authresult.gid) != 0\n#else\n        doinitsupgroups(account, (uid_t) -1, authresult.gid) != 0\n#endif\n        ) {\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)\n        (void) 0;\n#else\n        die(421, LOG_WARNING, MSG_NOTRUST);\n#endif\n    }\n\n    /* handle /home/user/./public_html form */\n    if ((root_directory = strdup(authresult.dir)) == NULL) {\n        die_mem();\n    }\n    hd = strstr(root_directory, \"/./\");\n    if (hd != NULL) {\n        if (chrooted != 0) {\n            die(421, LOG_DEBUG, MSG_CANT_DO_TWICE);\n        }\n        if (create_home_and_chdir(root_directory)) {\n            die(421, LOG_ERR, MSG_NO_HOMEDIR);\n        }\n        *++hd = 0;\n        hd++;\n        if (chroot(root_directory) || chdir(hd)) {\n            die(421, LOG_ERR, MSG_NO_HOMEDIR);\n        }\n        chrooted = 1;\n#ifdef RATIOS\n        if (ratio_for_non_anon == 0) {\n            ratio_upload = ratio_download = 0U;\n        }\n        if (check_trustedgroup(authresult.uid, authresult.gid) != 0) {\n            dot_write_ok = dot_read_ok = 1;\n            ratio_upload = ratio_download = 0U;\n            keepallfiles = 0;\n        }\n#endif\n    } else {\n        (void) free(root_directory);\n        root_directory = (char *) \"/\";\n        if (create_home_and_chdir(authresult.dir)) {\n            die(421, LOG_ERR, MSG_NO_HOMEDIR);\n        }\n    }\n    if (getcwd(wd, sizeof wd - (size_t) 1U) == NULL) {\n        wd[0] = '/';\n        wd[1] = 0;\n    }\n#ifndef NON_ROOT_FTP\n    if (setgid(authresult.gid) || setegid(authresult.gid)) {\n        _EXIT(EXIT_FAILURE);\n    }\n#endif\n    if (check_trustedgroup(authresult.uid, authresult.gid) != 0) {\n        userchroot = 0;\n        dot_write_ok = dot_read_ok = 1;\n        keepallfiles = 0;\n#ifdef RATIOS\n        ratio_upload = ratio_download = 0U;\n#endif\n#ifdef QUOTAS\n        user_quota_files = user_quota_size = ULONG_LONG_MAX;\n#endif\n    }\n#ifdef QUOTAS\n    if (hasquota() == 0) {\n        userchroot = 1;\n    }\n#endif\n    if (loggedin == 0) {\n        candownload = 1;        /* real users can always download */\n    }\n#ifdef THROTTLING\n    if ((throttling == 2) || (guest != 0 && throttling == 1)) {\n        addreply_noformat(0, MSG_BANDWIDTH_RESTRICTED);\n        (void) nice(NICE_VALUE);\n    } else {\n        throttling_delay = throttling_bandwidth_dl =\n            throttling_bandwidth_ul = 0UL;\n    }\n#endif\n#if !defined(MINIMAL) && defined(HAVE_GETGROUPS) && defined(DISPLAY_GROUPS)\n# ifdef SAFE_GETGROUPS_0\n    ngroups = getgroups(0, NULL);\n    if (ngroups > ngroups_max) {\n        ngroups_max = ngroups;\n    }\n# elif defined(_SC_NGROUPS_MAX)\n    /* get the run time value */\n    ngroups = (int) sysconf(_SC_NGROUPS_MAX);\n    if (ngroups > ngroups_max) {\n        ngroups_max = ngroups;\n    }\n# endif\n    if ((groups = malloc(sizeof(GETGROUPS_T) * ngroups_max)) == NULL) {\n        die_mem();\n    }\n    ngroups = getgroups(ngroups_max, groups);\n    if (guest == 0 && ngroups > 0) {\n        char reply[80 + MAX_USER_LENGTH];\n        const char *q;\n        size_t p;\n\n        if (SNCHECK(snprintf(reply, sizeof reply,\n                             MSG_USER_GROUP_ACCESS \": \", account),\n                    sizeof reply)) {\n            _EXIT(EXIT_FAILURE);\n        }\n        p = strlen(reply);\n        do {\n            ngroups--;\n            if ((ngroups != 0 && groups[ngroups] == groups[0]) ||\n                (q = getgroup(groups[ngroups])) == NULL) {\n                continue;\n            }\n            if (p + strlen(q) > 75) {\n                reply[p] = 0;\n                addreply(0, \"%s\", reply);\n                *reply = 0;\n                p = (size_t) 0U;\n            }\n            reply[p++] = ' ';\n            while (*q != 0 && p < sizeof reply - (size_t) 1U) {\n                reply[p++] = *q++;\n            }\n        } while (ngroups > 0);\n        reply[p] = 0;\n        addreply(0, \"%s\", reply);\n    }\n    free(groups);\n#endif\n    if (guest == 0 && allowfxp == 1) {\n        addreply_noformat(0, MSG_FXP_SUPPORT);\n    }\n#ifdef RATIOS\n    if (ratio_for_non_anon != 0 && ratio_upload > 0) {\n        addreply(0, MSG_RATIO, ratio_upload, ratio_download);\n    }\n#endif\n    if (userchroot != 0 && chrooted == 0) {\n        if (chdir(wd) || chroot(wd)) {    /* should never fail */\n            die(421, LOG_ERR, MSG_CHROOT_FAILED);\n        }\n        chrooted = 1;\n#ifdef RATIOS\n        if (ratio_for_non_anon == 0) {\n            ratio_upload = ratio_download = 0U;\n        }\n#endif\n        {\n            const size_t rd_len = strlen(wd) + sizeof \"/\";\n\n            if ((root_directory = malloc(rd_len)) == NULL) {\n                die_mem();\n            }\n            snprintf(root_directory, rd_len, \"%s/\", wd);\n        }\n        wd[0] = '/';\n        wd[1] = 0;\n        if (chdir(wd)) {\n            _EXIT(EXIT_FAILURE);\n        }\n        addreply(230, MSG_CURRENT_RESTRICTED_DIR_IS, wd);\n    } else {\n        addreply(230, MSG_CURRENT_DIR_IS, wd);\n    }\n\n#ifndef NON_ROOT_FTP\n    disablesignals();\n# ifndef WITHOUT_PRIVSEP\n    if (setuid(authresult.uid) != 0 || seteuid(authresult.uid) != 0) {\n        _EXIT(EXIT_FAILURE);\n    }\n# else\n    if (seteuid(authresult.uid) != 0) {\n        _EXIT(EXIT_FAILURE);\n    }\n#  ifdef USE_CAPABILITIES\n    drop_login_caps();\n#  endif\n# endif\n    enablesignals();\n#endif\n    logfile(LOG_INFO, MSG_IS_NOW_LOGGED_IN, account);\n#ifdef FTPWHO\n    if (shm_data_cur != NULL) {\n        ftpwho_lock();\n        strncpy(shm_data_cur->account, account,\n                sizeof shm_data_cur->account - (size_t) 1U);\n        shm_data_cur->account[sizeof shm_data_cur->account - 1U] = 0;\n        ftpwho_unlock();\n        state_needs_update = 1;\n    }\n#endif\n    loggedin = 1;\n    if (getcwd(wd, sizeof wd - (size_t) 1U) == NULL) {\n        wd[0] = '/';\n        wd[1] = 0;\n    }\n#ifndef MINIMAL\n    dobanner(0);\n#endif\n#ifdef QUOTAS\n    displayquota(NULL);\n#endif\n#ifdef WITH_BONJOUR\n    refreshManager();\n#endif\n}\n\nvoid docwd(const char *dir)\n{\n    const char *where;\n    char buffer[PATH_MAX + 256U];\n\n    if (loggedin == 0) {\n        goto kaboom;\n    }\n    /*\n     * secure and conformant tilde expansion routine. Need to be packaged in\n     * a function so that it can be called in other commands and avoid\n     * duplicate code in ls.c             -frank.\n     */\n    where = dir;\n    if (dir == NULL || *dir == 0) {\n        dir = \"~\";\n    }\n    if (*dir == '~') {\n        const struct passwd *pw;\n\n        if (dir[1] == 0) {         /* cd ~ */\n            strncpy(buffer, chrooted != 0 ? \"/\" : authresult.dir,\n                    sizeof buffer);\n            buffer[sizeof buffer - (size_t) 1U] = 0;\n            where = buffer;\n        } else {                   /* cd ~user or cd ~user/ */\n            char *bufpnt = buffer;\n            size_t s = sizeof buffer;\n            const char *dirscan = dir + 1;\n\n            while (*dirscan != 0 && *dirscan != '/') {\n                if (--s <= 0) {\n                    goto kaboom;   /* script kiddy's playing */\n                }\n                *bufpnt++ = *dirscan++;\n            }\n            *bufpnt = 0;\n            if (*buffer == 0) {        /* ~/... */\n                snprintf(buffer, sizeof buffer, \"%s%s\",\n                         chrooted != 0 ? \"/\" : authresult.dir, dirscan);\n                where = buffer;\n            } else if (authresult.slow_tilde_expansion == 0) {\n                if (chrooted != 0 || guest != 0 ||\n                    (pw = getpwnam(buffer)) == NULL || pw->pw_dir == NULL) {\n                    /* try with old where = dir */\n                } else {\n                    snprintf(buffer, sizeof buffer, \"%s%s\", pw->pw_dir, dirscan);\n                    where = buffer;\n                }\n            }\n        }\n    }\n    if (checknamesanity(where, dot_read_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, where);\n        return;\n    }\n    if (chdir(where) != 0) {\n\n#ifdef WITH_DIRALIASES\n        const int real_errno = errno;\n        const char *where_alias;\n\n        if ((where_alias = lookup_alias(where)) == NULL ||\n            chdir(where_alias) != 0) {\n            errno = real_errno;\n        } else {\n            goto chdir_success;\n        }\n#endif\n\n        if (SNCHECK(snprintf(buffer, sizeof buffer,\n                             MSG_CANT_CHANGE_DIR \": %s\",\n                             dir, strerror(errno)), sizeof buffer)) {\n            _EXIT(EXIT_FAILURE);\n        }\n        logfile(LOG_INFO, \"%s\", buffer);\n        addreply(550, \"%s\", buffer);\n\n#ifndef MINIMAL\n# ifndef NO_DIRSCAN_DELAY\n        if (cwd_failures >= MAX_DIRSCAN_TRIES) {\n            _EXIT(EXIT_FAILURE);\n        }\n        usleep2(cwd_failures * DIRSCAN_FAILURE_DELAY);\n        cwd_failures++;\n# endif\n#endif\n\n        return;\n    }\n\n#ifdef WITH_DIRALIASES\n    chdir_success:\n#endif\n\n#ifndef MINIMAL\n    cwd_failures = 0UL;\n    dobanner(1);\n#endif\n    if (getcwd(wd, sizeof wd - (size_t) 1U) == NULL) {\n        if (*dir == '/') {\n            if (SNCHECK(snprintf(wd, sizeof wd, \"%s\", dir), sizeof wd)) { /* already checked */\n                _EXIT(EXIT_FAILURE);\n            }\n        } else {\n            const size_t dir_len = strlen(dir);\n            const size_t wd_len = strlen(wd);\n            if (sizeof wd < dir_len + sizeof \"/\" - 1U + wd_len + 1U) {\n                kaboom:\n                die(421, LOG_ERR, MSG_PATH_TOO_LONG);\n            }\n            strcat(strcat(wd, \"/\"), dir); /* safe, see above */\n        }\n    }\n    addreply(250, MSG_CURRENT_DIR_IS, wd);\n}\n\nunsigned int zrand(void)\n{\n    return (unsigned int) alt_arc4random();\n}\n\nstatic void keepalive(const int fd, int keep)\n{\n#ifdef SO_KEEPALIVE\n    {\n        setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &keep, sizeof keep);\n    }\n#endif\n}\n\n/* psvtype = 0: PASV */\n/* psvtype = 1: EPSV */\n\nvoid dopasv(int psvtype)\n{\n    struct sockaddr_storage dataconn;    /* my data connection endpoint */\n    unsigned long a = 0U;\n    unsigned int p;\n    int on;\n    unsigned int firstporttried;\n\n    if (loggedin == 0) {\n        addreply_noformat(530, MSG_NOT_LOGGED_IN);\n        return;\n    }\n    if (datafd != -1) {                /* for buggy clients */\n        (void) close(datafd);\n        datafd = -1;\n    }\n    fourinsix(&ctrlconn);\n    if (STORAGE_FAMILY(ctrlconn) == AF_INET6 && psvtype == 0) {\n        addreply_noformat(425, MSG_CANT_PASV);\n        return;\n    }\n    firstporttried = firstport + zrand() % (lastport - firstport + 1);\n    p = firstporttried;\n    datafd = socket(STORAGE_FAMILY(ctrlconn), SOCK_STREAM, IPPROTO_TCP);\n    if (datafd == -1) {\n        error(425, MSG_CANT_PASSIVE);\n        return;\n    }\n    on = 1;\n    if (setsockopt(datafd, SOL_SOCKET, SO_REUSEADDR,\n                   (char *) &on, sizeof on) < 0) {\n        error(421, \"setsockopt\");\n        return;\n    }\n    dataconn = ctrlconn;\n    for (;;) {\n        if (STORAGE_FAMILY(dataconn) == AF_INET6) {\n            STORAGE_PORT6(dataconn) = htons(p);\n        } else {\n            STORAGE_PORT(dataconn) = htons(p);\n        }\n        if (bind(datafd, (struct sockaddr *) &dataconn,\n                 STORAGE_LEN(dataconn)) == 0) {\n            break;\n        }\n        p--;\n        if (p < firstport) {\n            p = lastport;\n        }\n        if (p == firstporttried) {\n            (void) close(datafd);\n            datafd = -1;\n            addreply_noformat(425, MSG_PORTS_BUSY);\n            return;\n        }\n    }\n    alarm(idletime);\n    if (listen(datafd, DEFAULT_BACKLOG_DATA) < 0) {\n        (void) close(datafd);\n        datafd = -1;\n        error(425, MSG_GETSOCKNAME_DATA);\n        return;\n    }\n    switch (psvtype) {\n    case 0:\n        if (STORAGE_FAMILY(force_passive_ip) == 0) {\n            a = ntohl(STORAGE_SIN_ADDR_CONST(dataconn));\n        } else if (STORAGE_FAMILY(force_passive_ip) == AF_INET6) {\n            (void) close(datafd);\n            datafd = -1;\n            addreply_noformat(425, MSG_NO_EPSV);\n            return;\n        } else if (STORAGE_FAMILY(force_passive_ip) == AF_INET) {\n            a = ntohl(STORAGE_SIN_ADDR_CONST(force_passive_ip));\n        } else {\n            _EXIT(EXIT_FAILURE);\n        }\n\n        /* According to RFC, any message can follow 227. But broken NAT gateways\n         * and connection tracking code rely on this. So don't translate the following\n         * messages */\n\n        addreply(227, \"Entering Passive Mode (%lu,%lu,%lu,%lu,%u,%u)\",\n                 (a >> 24) & 255UL, (a >> 16) & 255UL, (a >> 8) & 255UL, a & 255UL,\n                 (p >> 8) & 255, p & 255);\n        break;\n    case 1:\n        addreply(229, \"Extended Passive mode OK (|||%u|)\", p);\n        break;\n    default:\n        _EXIT(EXIT_FAILURE);\n    }\n    passive = 1;\n}\n\nvoid doport(const char *arg)\n{\n    unsigned int a1, a2, a3, a4, p1, p2;\n    struct sockaddr_storage a;\n\n    if (sscanf(arg, \"%u,%u,%u,%u,%u,%u\",\n               &a1, &a2, &a3, &a4, &p1, &p2) != 6 ||\n        a1 > 255 || a2 > 255 || a3 > 255 || a4 > 255 ||\n        p1 > 255 || p2 > 255 || (a1|a2|a3|a4) == 0 ||\n        (p1 | p2) == 0) {\n        addreply_noformat(501, MSG_SYNTAX_ERROR_IP);\n        return;\n    }\n    memset(&a, 0, sizeof a);\n    STORAGE_FAMILY(a) = AF_INET;\n    STORAGE_SIN_ADDR(a) =\n        htonl(((uint32_t) a1 << 24) | ((uint32_t) a2 << 16) |\n              (a3 << 8) | a4);\n    SET_STORAGE_LEN(a, sizeof(struct sockaddr_in));\n    doport2(a, (p1 << 8) | p2);\n}\n\n#ifdef WITHOUT_PRIVSEP\n\nstatic int doport3(const int protocol)\n{\n    struct sockaddr_storage dataconn;  /* his endpoint */\n\n# ifndef NON_ROOT_FTP\n    static const in_port_t portlist[] = FTP_ACTIVE_SOURCE_PORTS;\n    const in_port_t *portlistpnt = portlist;\n# else\n    static const in_port_t portlist[] = { 0U };\n    const in_port_t *portlistpnt = portlist;\n# endif\n    int on;\n\n# ifndef NON_ROOT_FTP\n    disablesignals();\n    seteuid((uid_t) 0);\n# endif\n    if ((datafd = socket(protocol, SOCK_STREAM, IPPROTO_TCP)) == -1) {\n        data_socket_error:\n# ifndef NON_ROOT_FTP\n        if (seteuid(authresult.uid) != 0) {\n            _EXIT(EXIT_FAILURE);\n        }\n        enablesignals();\n# endif\n        (void) close(datafd);\n        datafd = -1;\n        error(425, MSG_CANT_CREATE_DATA_SOCKET);\n\n        return -1;\n    }\n    on = 1;\n# ifdef SO_REUSEPORT\n    (void) setsockopt(datafd, SOL_SOCKET, SO_REUSEPORT,\n                      (char *) &on, sizeof on);\n# else\n    (void) setsockopt(datafd, SOL_SOCKET, SO_REUSEADDR,\n                      (char *) &on, sizeof on);\n# endif\n    memcpy(&dataconn, &ctrlconn, sizeof dataconn);\n    for (;;) {\n        if (STORAGE_FAMILY(dataconn) == AF_INET6) {\n            STORAGE_PORT6(dataconn) = htons(*portlistpnt);\n        } else {\n            STORAGE_PORT(dataconn) = htons(*portlistpnt);\n        }\n        if (bind(datafd, (struct sockaddr *) &dataconn,\n                 STORAGE_LEN(dataconn)) == 0) {\n            break;\n        }\n# ifdef USE_ONLY_FIXED_DATA_PORT\n        (void) sleep(1U);\n# else\n        if (*portlistpnt == (in_port_t) 0U) {\n            goto data_socket_error;\n        }\n        portlistpnt++;\n# endif\n    }\n# ifndef NON_ROOT_FTP\n    if (seteuid(authresult.uid) != 0) {\n        _EXIT(EXIT_FAILURE);\n    }\n    enablesignals();\n# endif\n\n    return 0;\n}\n\n#else\n\n/* Privilege-separated version of doport3() */\n\nstatic int doport3(const int protocol)\n{\n    if ((datafd = privsep_bindresport(protocol, ctrlconn)) == -1) {\n        error(425, MSG_CANT_CREATE_DATA_SOCKET);\n\n        return -1;\n    }\n    return 0;\n}\n\n#endif\n\nvoid doport2(struct sockaddr_storage a, unsigned int p)\n{\n    if (loggedin == 0) {\n        addreply_noformat(530, MSG_NOT_LOGGED_IN);\n        return;\n    }\n    if (epsv_all != 0) {\n        addreply_noformat(501, MSG_ACTIVE_DISABLED);\n        return;\n    }\n    if (datafd != -1) {    /* for buggy clients saying PORT over and over */\n        (void) close(datafd);\n        datafd = -1;\n    }\n    if (p < 1024U) {\n        addreply_noformat(501, MSG_BAD_PORT);\n        return;\n    }\n    if (doport3(STORAGE_FAMILY(a) == AF_INET6 ? PF_INET6 : PF_INET) != 0) {\n        return;\n    }\n    peerdataport = (in_port_t) p;\n    if (addrcmp(&a, &peer) != 0) {\n        char hbuf[NI_MAXHOST];\n        char peerbuf[NI_MAXHOST];\n\n        if (getnameinfo((struct sockaddr *) &a, STORAGE_LEN(a),\n                        hbuf, sizeof hbuf, NULL,\n                        (size_t) 0U, NI_NUMERICHOST) != 0 ||\n            getnameinfo((struct sockaddr *) &peer, STORAGE_LEN(peer),\n                        peerbuf, sizeof peerbuf, NULL,\n                        (size_t) 0U, NI_NUMERICHOST) != 0) {\n            goto hu;\n        }\n        if (allowfxp == 0 || (allowfxp == 1 && guest != 0)) {\n            hu:\n            (void) close(datafd);\n            datafd = -1;\n            addreply(500, MSG_NO_FXP, hbuf, peerbuf);\n            return;\n        } else {\n            addreply(0, MSG_FXP, peerbuf, hbuf);\n            memcpy(&peer, &a, sizeof a);\n        }\n    }\n    passive = 0;\n\n    addreply_noformat(200, MSG_PORT_SUCCESSFUL);\n    return;\n}\n\nvoid closedata(void)\n{\n    volatile int tmp_xferfd = xferfd;   /* do not simplify this... */\n\n#ifdef WITH_TLS\n    tls_close_session(&tls_data_cnx);\n    tls_data_cnx = NULL;\n#endif\n    xferfd = -1;           /* ...it avoids a race */\n    (void) close(tmp_xferfd);\n}\n\nvoid opendata(void)\n{\n    struct sockaddr_storage dataconn;    /* his data connection endpoint */\n    int fd;\n    socklen_t socksize;\n\n    if (xferfd != -1) {\n        closedata();\n    }\n    if (datafd == -1) {\n        addreply_noformat(425, MSG_NO_DATA_CONN);\n        return;\n    }\n    if (passive != 0) {\n        struct pollfd pfds[2];\n        struct pollfd *pfd;\n        int pollret;\n\n        pfd = &pfds[0];\n        pfd->fd = clientfd;\n        pfd->events = POLLERR | POLLHUP;\n        pfd->revents = 0;\n\n        pfd = &pfds[1];\n        pfd->fd = datafd;\n        pfd->events = POLLIN | POLLERR | POLLHUP;\n        pfd->revents = 0;\n\n        alarm(idletime);\n        for (;;) {\n            pfds[0].revents = pfds[1].revents = 0;\n            pollret = poll(pfds, sizeof pfds / sizeof pfds[0], idletime * 1000UL);\n            if (pollret <= 0) {\n                die(421, LOG_INFO, MSG_TIMEOUT_DATA, (unsigned long) idletime);\n            }\n            if ((pfds[0].revents & (POLLERR | POLLHUP | POLLNVAL)) != 0 ||\n                (pfds[1].revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n                die(221, LOG_INFO, MSG_LOGOUT);\n            }\n            if ((pfds[1].revents & POLLIN) == 0) {\n                continue;\n            }\n            socksize = (socklen_t) sizeof(dataconn);\n            memset(&dataconn, 0, sizeof dataconn);\n            if ((fd = accept(datafd, (struct sockaddr *) &dataconn,\n                             &socksize)) == -1) {\n                nope:\n                (void) close(datafd);\n                datafd = -1;\n                error(421, MSG_ACCEPT_FAILED);\n                return;\n            }\n            if (STORAGE_FAMILY(dataconn) != AF_INET\n                && STORAGE_FAMILY(dataconn) != AF_INET6) {\n                (void) close(fd);\n                goto nope;\n            }\n            fourinsix(&dataconn);\n            if (addrcmp(&peer, &dataconn) == 0) {\n                break;\n            }\n            if (allowfxp == 0 || (allowfxp == 1 && guest != 0)) {\n                shutdown(fd, 2);\n                (void) close(fd);\n            } else {\n                break;\n            }\n        }\n        addreply_noformat(150, MSG_ACCEPT_SUCCESS);\n    } else {\n        struct sockaddr_storage peer2;\n        unsigned long tries = 1UL + idletime / 2UL;\n\n        peer2 = peer;\n        if (STORAGE_FAMILY(peer) == AF_INET6) {\n            STORAGE_PORT6(peer2) = htons(peerdataport);\n        } else {\n            STORAGE_PORT(peer2) = htons(peerdataport);\n        }\n        again:\n        if (connect(datafd, (struct sockaddr *) &peer2,\n                    STORAGE_LEN(peer2)) != 0) {\n            if ((errno == EAGAIN || errno == EINTR\n#ifdef EADDRINUSE\n                 || errno == EADDRINUSE\n#endif\n                 ) && tries > 0UL) {\n                tries--;\n                usleep2(1000000UL);\n                goto again;\n            }\n            addreply(425, MSG_CNX_PORT_FAILED \": %s\",\n                     peerdataport, strerror(errno));\n            (void) close(datafd);\n            datafd = -1;\n            return;\n        }\n        fd = datafd;\n        datafd = -1;\n        addreply(150, MSG_CNX_PORT, peerdataport);\n    }\n\n    {\n        int fodder;\n#ifdef IPTOS_THROUGHPUT\n        fodder = IPTOS_THROUGHPUT;\n        setsockopt(fd, SOL_IP, IP_TOS, (char *) &fodder, sizeof fodder);\n#endif\n#ifndef NO_KEEPALIVE\n        keepalive(fd, 1);\n#endif\n    }\n    xferfd = fd;\n    alarm(MAX_SESSION_XFER_IDLE);\n}\n\n#ifndef MINIMAL\nvoid dochmod(char *name, mode_t mode)\n{\n    static dev_t root_st_dev;\n    static ino_t root_st_ino;\n    struct stat st2;\n    int fd = -1;\n\n    if (nochmod != 0 && authresult.uid != (uid_t) 0) {\n        addreply(550, MSG_CHMOD_FAILED, name);\n        return;\n    }\n# ifndef ANON_CAN_CHANGE_PERMS\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_CHANGE_PERMS);\n        return;\n    }\n# endif\n    if (name == NULL || *name == 0) {\n        addreply_noformat(501, MSG_NO_FILE_NAME);\n        return;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        return;\n    }\n    fd = open(name, O_RDONLY);\n    if (fd == -1) {\n        goto failure;\n    }\n    if ((root_st_dev | root_st_ino) == 0) {\n        struct stat st;\n\n        if (stat(\"/\", &st) != 0) {\n            goto failure;\n        }\n        root_st_dev = st.st_dev;\n        root_st_ino = st.st_ino;\n    }\n    if (fstat(fd, &st2) != 0) {\n        goto failure;\n    }\n# ifdef QUOTAS\n    if (hasquota() == 0 && S_ISDIR(st2.st_mode)) {\n        mode |= 0500;\n    }\n# endif\n    if (st2.st_ino == root_st_ino && st2.st_dev == root_st_dev) {\n        mode |= 0700;\n    } else if (be_customer_proof != 0) {\n        mode |= (S_ISDIR(st2.st_mode) ? 0700 : 0600);\n    }\n    if (fchmod(fd, mode) < 0 && chmod(name, mode) < 0) {\n        failure:\n        if (fd != -1) {\n            (void) close(fd);\n        }\n        addreply(550, MSG_CHMOD_FAILED \": %s\", name, strerror(errno));\n        return;\n    }\n    (void) close(fd);\n    addreply(200, MSG_CHMOD_SUCCESS, name);\n}\n\nvoid doutime(char *name, const char * const wanted_time)\n{\n    struct tm tm;\n    time_t ts;\n    struct utimbuf tb;\n\n# ifndef ANON_CAN_CHANGE_UTIME\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_CHANGE_PERMS);\n        return;\n    }\n# endif\n    if (name == NULL || *name == 0) {\n        addreply_noformat(501, MSG_NO_FILE_NAME);\n        return;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        return;\n    }\n    memset(&tm, 0, sizeof tm);\n    sscanf(wanted_time, \"%4d%2d%2d%2d%2d%2d\", &tm.tm_year, &tm.tm_mon,\n           &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec);\n    tm.tm_mon--;\n    tm.tm_year -= 1900;\n# ifdef USE_LOCAL_TIME_FOR_SITE_UTIME\n    ts = mktime(&tm);\n# else\n#  ifdef HAVE_TIMEGM\n    ts = timegm(&tm);\n#  elif defined(HAVE_PUTENV)\n    {\n        putenv(\"TZ=UTC+00:00\");\n#   ifdef HAVE_TZSET\n        tzset();\n#   endif\n        ts = mktime(&tm);\n        putenv(default_tz_for_putenv);\n        tzset();\n    }\n#  else\n    ts = mktime(&tm);\n#  endif\n# endif\n    if (tm.tm_mon < 0 || tm.tm_year <= 0 || ts == (time_t) -1) {\n        addreply_noformat(501, MSG_TIMESTAMP_FAILURE);\n        return;\n    }\n    tb.actime = tb.modtime = ts;\n    if (utime(name, &tb) < 0) {\n        addreply(550, \"utime(%s): %s\", name, strerror(errno));\n    } else {\n        addreply_noformat(213, \"UTIME OK\");\n    }\n}\n#endif\n\nvoid dodele(char *name)\n{\n#ifndef ANON_CAN_DELETE\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_DELETE);\n        return;\n    }\n#endif\n    if (name == NULL || *name == 0) {\n        addreply_noformat(501, MSG_NO_FILE_NAME);\n        return;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        return;\n    }\n    if (keepallfiles != 0) {\n#ifdef EPERM\n        errno = EPERM;\n#else\n        errno = 1;\n#endif\n        goto denied;\n    }\n\n    /*\n     * What we do here may look a bit strange. It's to defend against\n     * change-after-stat attacks. If we simply do lstat(name), then unlink(name)\n     * there's a race. An attacker can rename the file between these two\n     * system calls, so that a big file is lstat()ed, but a dummy tiny file is\n     * unlinked. That way, an attacker could easily get extra quota.\n     * To defend against this attack, we rename the file to an unique dot-file\n     * (an atomic operation) . People subject to quotas can't access dot-files.\n     * So we can securely stat it and unlink it. Having the pid in the file\n     * name should be enough to avoid that two concurrent sessions create the\n     * same temporary file. But to be paranoid to the extreme, we add some\n     * random number to that.\n     */\n\n#ifdef QUOTAS\n    {\n        char *p;\n        struct stat st;\n        struct stat st2;\n        size_t dirlen = (size_t) 0U;\n        char qtfile[PATH_MAX + 1];\n\n        if ((p = strrchr(name, '/')) != NULL) {\n            if ((dirlen = p - name + (size_t) 1U) >= sizeof qtfile) {\n                goto denied;       /* should never happen */\n            }\n            memcpy(qtfile, name, dirlen);   /* safe, dirlen < sizeof qtfile */\n        }\n        if (SNCHECK(snprintf(qtfile + dirlen, sizeof qtfile - dirlen,\n                             PUREFTPD_TMPFILE_PREFIX \"rename.%lu.%x\",\n                             (unsigned long) getpid(), zrand()),\n                    sizeof qtfile)) {\n            goto denied;\n        }\n        if (lstat(name, &st) != 0) {\n            goto denied;\n        }\n        if (!S_ISREG(st.st_mode)\n# ifndef NEVER_DELETE_SYMLINKS\n            && !S_ISLNK(st.st_mode)\n# endif\n            ) {\n# ifdef EINVAL\n            errno = EINVAL;\n# endif\n            goto denied;\n        }\n        if (rename(name, qtfile) != 0) {\n            goto denied;\n        }\n        if (lstat(qtfile, &st2) != 0 ||\n            st.st_dev != st2.st_dev ||\n            st.st_ino != st2.st_ino ||\n            st.st_size != st2.st_size) {\n# ifdef EINVAL\n            errno = EINVAL;\n# endif\n            goto denied;\n        }\n        if (unlink(qtfile) < 0) {\n            /*\n             * Race if rename() goes to an existing file.\n             * seems very difficult to exploit, though.\n             * Does a perfect userland answer exist, after all?\n             */\n            (void) rename(qtfile, name);\n            goto denied;\n        }\n        {\n            Quota quota;\n\n            if (quota_update(&quota, -1LL,\n                             -((long long) st.st_size), NULL) == 0) {\n                displayquota(&quota);\n            }\n        }\n    }\n#else\n    if (unlink(name) < 0) {\n        goto denied;\n    }\n#endif\n    addreply(250, MSG_DELE_SUCCESS, \"\", \"\", \"\", name);\n    logfile(LOG_NOTICE, MSG_DELE_SUCCESS, root_directory,\n            *name == '/' ? \"\" : wd,\n            (*name != '/' && (!*wd || wd[strlen(wd) - 1] != '/'))\n            ? \"/\" : \"\", name);\n    return;\n\n    denied:\n    addreply(550, MSG_DELE_FAILED \": %s\", name, strerror(errno));\n}\n\nstatic double get_usec_time(void)\n{\n    struct timeval tv;\n    struct timezone tz;\n\n    if (gettimeofday(&tv, &tz) < 0) {\n        return 0.0;\n    }\n    return (double) tv.tv_sec + ((double) tv.tv_usec) / 1000000.0;\n}\n\nstatic void displayrate(const char *word, off_t size,\n                        const double started,\n                        const char * const name, int up)\n{\n    double ended;\n    double t;\n    double speed;\n    char speedstring[64];\n\n    ended = get_usec_time();\n\n    t = ended - started;\n    if (t > 0.0 && size > (off_t) 0) {\n        speed = size / t;\n    } else {\n        speed = 0.0;\n    }\n    if (speed > 524288.0) {\n        addreply(0, MSG_TRANSFER_RATE_M, t, speed / 1048576.0);\n    } else if (speed > 512.0) {\n        addreply(0, MSG_TRANSFER_RATE_K, t, speed / 1024.0);\n    } else if (speed > 0.1) {\n        addreply(0, MSG_TRANSFER_RATE_B, t, speed);\n    }\n    if (!SNCHECK(snprintf(speedstring, sizeof speedstring,\n                          \" (%llu bytes, %.2fKB/sec)\",\n                          (unsigned long long) size, speed / 1024.0),\n                 sizeof speedstring)) {\n        logfile(LOG_NOTICE, \"%s%s%s%s %s %s\", root_directory,\n                *name == '/' ? \"\" : wd,\n                (*name != '/' && (!*wd || wd[strlen(wd) - 1] != '/'))\n                ? \"/\" : \"\", name, word, speedstring);\n    }\n    /* Tons of #ifdef here, but it avoids a pointless call to realpath() */\n#if defined(WITH_UPLOAD_SCRIPT) || defined(WITH_ALTLOG)\n    if (\n# ifdef WITH_ALTLOG\n        altlog_format != ALTLOG_NONE\n# endif\n# if defined(WITH_UPLOAD_SCRIPT) && defined(WITH_ALTLOG)\n        ||\n# endif\n# if (defined(WITH_UPLOAD_SCRIPT))\n        (do_upload_script != 0 && up != 0)\n# endif\n        )\n    {\n        char *alloca_filename_real;\n        const size_t sizeof_filename_real = PATH_MAX + VHOST_PREFIX_MAX_LEN;\n        char *resolved_path;\n        const size_t sizeof_resolved_path = PATH_MAX + 1U;\n\n        if ((resolved_path = malloc(sizeof_resolved_path)) == NULL) {\n            return;\n        }\n        resolved_path[sizeof_resolved_path - 1U] = 0;\n        if (realpath(name, resolved_path) == NULL) {\n            if (up != 0) {\n                (void) unlink(name);\n            }\n            free(resolved_path);\n            logfile(LOG_ERR, \"realpath() failure : [%s] => [%s]\",\n                    name, strerror(errno));\n            return;\n        }\n        if (resolved_path[sizeof_resolved_path - 1U] != 0) {\n            for (;;) {\n                *resolved_path++ = 0;\n            }\n        }\n        if ((alloca_filename_real = ALLOCA(sizeof_filename_real)) == NULL) {\n            free(resolved_path);\n            return;\n        }\n# ifdef WITH_VIRTUAL_CHROOT\n        if (SNCHECK(snprintf(alloca_filename_real, sizeof_filename_real,\n                             \"\\001%s\", resolved_path), sizeof_filename_real)) {\n            goto rp_failure;\n        }\n# else\n        if (SNCHECK(snprintf(alloca_filename_real, sizeof_filename_real,\n                             \"\\001%s%s\", root_directory,\n                             (*resolved_path == '/' ? resolved_path + 1 :\n                              resolved_path)), sizeof_filename_real)) {\n            goto rp_failure;\n        }\n# endif\n# ifdef WITH_ALTLOG\n        (void) altlog_writexfer(up, alloca_filename_real + 1, size, t);\n# endif\n# if defined(WITH_UPLOAD_SCRIPT)\n        if (do_upload_script != 0 && up != 0) {\n            upload_pipe_push(account, alloca_filename_real);\n        }\n# endif\n        rp_failure:\n        free(resolved_path);\n        ALLOCA_FREE(alloca_filename_real);\n    }\n#else\n    (void) up;\n#endif\n}\n\nstatic void displayopenfailure(const char * const name)\n{\n    char buffer[PATH_MAX + 42U];\n    const int e = errno;\n\n    if (SNCHECK(snprintf(buffer, sizeof buffer, MSG_OPEN_FAILURE, name),\n                sizeof buffer)) {\n        _EXIT(EXIT_FAILURE);\n    }\n    errno = e;\n    error(550, buffer);\n}\n\nstatic int dlhandler_throttle(DLHandler * const dlhandler,\n                              const off_t downloaded, const double ts_start,\n                              double *required_sleep)\n{\n    double ts_now;\n    double elapsed;\n    off_t would_be_downloaded;\n    double wanted_ts;\n    off_t previous_chunk_size;\n\n    if (dlhandler->bandwidth <= 0UL || downloaded <= (off_t) 0) {\n        *required_sleep = 0.0;\n        return 0;\n    }\n    if ((ts_now = get_usec_time()) <= 0.0) {\n        ts_now = ts_start;\n    }\n    if (ts_start > ts_now) {\n        ts_now = ts_start;\n    }\n    elapsed = ts_now - ts_start;\n    would_be_downloaded = dlhandler->total_downloaded + dlhandler->chunk_size;\n    if (dlhandler->bandwidth > 0UL) {\n        wanted_ts = (double) would_be_downloaded /\n            (double) dlhandler->bandwidth;\n    } else {\n        wanted_ts = elapsed;\n    }\n    *required_sleep = wanted_ts - elapsed;\n    previous_chunk_size = dlhandler->chunk_size;\n    if (dlhandler->total_downloaded <= dlhandler->chunk_size) {\n        return 0;\n    }\n    if (*required_sleep < dlhandler->min_sleep) {\n        dlhandler->chunk_size =\n            (dlhandler->max_chunk_size + dlhandler->chunk_size) / 2;\n    } else if (*required_sleep > dlhandler->max_sleep) {\n        dlhandler->chunk_size =\n            (dlhandler->min_chunk_size + dlhandler->chunk_size) / 2;\n    } else {\n        dlhandler->chunk_size = dlhandler->default_chunk_size;\n    }\n    if (dlhandler->chunk_size <= 0 || dlhandler->chunk_size > INT_MAX) {\n        dlhandler->chunk_size = dlhandler->default_chunk_size;\n    }\n    if (previous_chunk_size != dlhandler->default_chunk_size) {\n        would_be_downloaded =\n            dlhandler->total_downloaded + dlhandler->chunk_size;\n        if (dlhandler->bandwidth > 0UL) {\n            wanted_ts = (double) would_be_downloaded /\n                (double) dlhandler->bandwidth;\n        } else {\n            wanted_ts = elapsed;\n        }\n        *required_sleep = wanted_ts - elapsed;\n    }\n    return 0;\n}\n\nstatic int dlhandler_init(DLHandler * const dlhandler,\n                          const int clientfd, void * const tls_clientfd,\n                          const int xferfd,\n                          const char * const name,\n                          const int f, void * const tls_fd,\n                          const off_t restartat,\n                          const int ascii_mode,\n                          const unsigned long bandwidth)\n{\n    struct stat st;\n    struct pollfd *pfd;\n\n    if (fstat(f, &st) < 0 || (S_ISLNK(st.st_mode) && stat(name, &st) < 0)) {\n        error(451, MSG_STAT_FAILURE);\n        return -1;\n    }\n    if (!S_ISREG(st.st_mode)) {\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n        return -1;\n    }\n    dlhandler->clientfd = clientfd;\n    dlhandler->tls_clientfd = tls_clientfd;\n    dlhandler->xferfd = xferfd;\n    dlhandler->f = f;\n    dlhandler->tls_fd = tls_fd;\n    dlhandler->file_size = st.st_size;\n    dlhandler->ascii_mode = ascii_mode;\n    dlhandler->cur_pos = restartat;\n    dlhandler->total_downloaded = (off_t) 0;\n    dlhandler->min_sleep = 0.1;\n    dlhandler->max_sleep = 5.0;\n    dlhandler->bandwidth = bandwidth;\n    pfd = &dlhandler->pfds_f_in;\n    pfd->fd = clientfd;\n#ifdef __APPLE_CC__\n    pfd->events = POLLRDBAND | POLLPRI | POLLERR | POLLHUP;\n#else\n    pfd->events = POLLIN | POLLPRI | POLLERR | POLLHUP;\n#endif\n    pfd->revents = 0;\n\n    if (restartat > (off_t) 0) {\n        if (restartat == st.st_size) {\n            addreply_noformat(226, MSG_NO_MORE_TO_DOWNLOAD);\n            return -2;\n        } else if (restartat > st.st_size) {\n            addreply(554, MSG_REST_TOO_LARGE_FOR_FILE \"\\n\" MSG_REST_RESET,\n                     (long long) restartat, (long long) st.st_size);\n            return -1;\n        }\n    }\n    if (fcntl(xferfd, F_SETFL, fcntl(xferfd, F_GETFL) | O_NONBLOCK) == -1) {\n        error(451, \"fcntl(F_SETFL, O_NONBLOCK)\");\n        return -1;\n    }\n    return 0;\n}\n\nstatic int dlmap_init(DLHandler * const dlhandler, const int clientfd,\n                      void * const tls_clientfd, const int xferfd,\n                      const char * const name, const int f,\n                      void * const tls_fd, const off_t restartat,\n                      const int ascii_mode, const unsigned long bandwidth)\n{\n    if (ascii_mode > 0) {\n#ifdef WITHOUT_ASCII\n        addreply_noformat(450, MSG_ASCII_MODE_UNSUPPORTED);\n        return -1;\n#else\n        addreply_noformat(0, MSG_ASCII_MODE_WARNING);\n#endif\n    }\n    if (dlhandler_init(dlhandler, clientfd, tls_clientfd, xferfd, name, f,\n                       tls_fd, restartat, ascii_mode, bandwidth) != 0) {\n        return -1;\n    }\n    dlhandler->min_chunk_size = DL_MIN_CHUNK_SIZE;\n    if (ascii_mode > 0) {\n        dlhandler->default_chunk_size = dlhandler->max_chunk_size =\n            DL_DEFAULT_CHUNK_SIZE_ASCII;\n    } else {\n        dlhandler->max_chunk_size = DL_MAX_CHUNK_SIZE;\n        if (bandwidth <= 0UL) {\n            dlhandler->default_chunk_size = dlhandler->max_chunk_size;\n        } else {\n            dlhandler->default_chunk_size = DL_DEFAULT_CHUNK_SIZE;\n        }\n    }\n    dlhandler->chunk_size = dlhandler->default_chunk_size;\n    dlhandler->dlmap_size =\n        (DL_DLMAP_SIZE + page_size - (size_t) 1U) & ~(page_size - (size_t) 1U);\n    dlhandler->cur_pos = restartat;\n    dlhandler->dlmap_pos = (off_t) 0;\n    dlhandler->dlmap_fdpos = (off_t) -1;\n    dlhandler->sizeof_map = (size_t) 0U;\n    dlhandler->map_data = NULL;\n    dlhandler->sizeof_map = dlhandler->dlmap_size;\n    dlhandler->map = malloc(dlhandler->sizeof_map);\n    if (dlhandler->map == NULL) {\n        die_mem();\n    }\n    return 0;\n}\n\nstatic int _dlmap_read(DLHandler * const dlhandler)\n{\n    ssize_t readnb;\n\n    if (dlhandler->dlmap_size > dlhandler->sizeof_map) {\n        abort();\n    }\n    if (dlhandler->dlmap_size <= (size_t) 0U) {\n        return 0;\n    }\n    if (dlhandler->dlmap_pos != dlhandler->dlmap_fdpos) {\n        do {\n            if (lseek(dlhandler->f, dlhandler->dlmap_pos,\n                      SEEK_SET) == (off_t) -1) {\n                dlhandler->dlmap_fdpos = (off_t) -1;\n                return -1;\n            }\n            dlhandler->dlmap_fdpos = dlhandler->dlmap_pos;\n            readnb = read(dlhandler->f, dlhandler->map, dlhandler->dlmap_size);\n        } while (readnb == (ssize_t) -1 && errno == EINTR);\n    } else {\n        do {\n            readnb = read(dlhandler->f, dlhandler->map, dlhandler->dlmap_size);\n        } while (readnb == (ssize_t) -1 && errno == EINTR);\n    }\n    if (readnb <= (ssize_t) 0) {\n        dlhandler->dlmap_fdpos = (off_t) -1;\n        return -1;\n    }\n    if (readnb != (ssize_t) dlhandler->dlmap_size) {\n        dlhandler->dlmap_fdpos = (off_t) -1;\n    } else {\n        dlhandler->dlmap_fdpos += (off_t) readnb;\n    }\n    return 0;\n}\n\nstatic int _dlmap_remap(DLHandler * const dlhandler)\n{\n    size_t min_dlmap_size;\n    off_t remaining;\n\n    if (dlhandler->map_data != NULL) {\n        if (dlhandler->cur_pos >= dlhandler->dlmap_pos &&\n            dlhandler->cur_pos + dlhandler->chunk_size <=\n            dlhandler->dlmap_pos + (off_t) dlhandler->dlmap_size) {\n            if (dlhandler->cur_pos < dlhandler->dlmap_pos ||\n                dlhandler->cur_pos - dlhandler->dlmap_pos >\n                (off_t) dlhandler->dlmap_size) {\n                addreply_noformat(451, \"remap\");\n                return -1;\n            }\n            dlhandler->map_data =\n                dlhandler->map + dlhandler->cur_pos - dlhandler->dlmap_pos;\n            return 0;\n        }\n    }\n    if (dlhandler->file_size - dlhandler->cur_pos < dlhandler->chunk_size) {\n        dlhandler->chunk_size = dlhandler->file_size - dlhandler->cur_pos;\n    }\n    if (dlhandler->chunk_size <= 0) {\n        return 1;\n    }\n    dlhandler->dlmap_pos = dlhandler->cur_pos;\n    min_dlmap_size = dlhandler->chunk_size;\n    if (dlhandler->dlmap_size < min_dlmap_size) {\n        dlhandler->dlmap_size = min_dlmap_size;\n    }\n    dlhandler->dlmap_size = (dlhandler->dlmap_size + page_size - (size_t) 1U) &\n        ~(page_size - (size_t) 1U);\n    if (dlhandler->dlmap_size < page_size) {\n        dlhandler->dlmap_size = page_size;\n    }\n    remaining = dlhandler->file_size - dlhandler->dlmap_pos;\n    if ((off_t) dlhandler->dlmap_size > remaining) {\n        dlhandler->dlmap_size = (off_t) remaining;\n    }\n    if (_dlmap_read(dlhandler) != 0) {\n        error(451, MSG_DATA_READ_FAILED);\n        return -1;\n    }\n    dlhandler->map_data = dlhandler->map;\n\n    return 0;\n}\n\nstatic int dl_dowrite(DLHandler * const dlhandler, const unsigned char *buf_,\n                      const size_t size_, off_t * const downloaded)\n{\n    size_t size = size_;\n    const unsigned char *buf = buf_;\n    unsigned char *asciibuf = NULL;\n    int ret = 0;\n\n    if (size_ <= (size_t) 0U) {\n        *downloaded = 0;\n        return -1;\n    }\n#ifndef WITHOUT_ASCII\n    if (dlhandler->ascii_mode > 0) {\n        unsigned char *asciibufpnt;\n        size_t z = (size_t) 0U;\n\n        if (size > (size_t) dlhandler->chunk_size ||\n            (asciibuf = ALLOCA((size_t) dlhandler->chunk_size * 2U)) == NULL) {\n            return -1;\n        }\n        asciibufpnt = asciibuf;\n        do {\n            if (buf_[z] == (unsigned char) '\\n') {\n                *asciibufpnt++ = (unsigned char) '\\r';\n            }\n            *asciibufpnt++ = buf_[z];\n            z++;\n        } while (z < size);\n        buf = asciibuf;\n        size = (size_t) (asciibufpnt - asciibuf);\n    }\n#endif\n    ret = safe_nonblock_write(dlhandler->xferfd, dlhandler->tls_fd, buf, size);\n    if (asciibuf != NULL) {\n        ALLOCA_FREE(asciibuf);\n    }\n    if (ret < 0) {\n        *downloaded = 0;\n    } else {\n        *downloaded = size;\n    }\n    return ret;\n}\n\nstatic int dlhandler_handle_commands(DLHandler * const dlhandler,\n                                     const double required_sleep)\n{\n    int pollret;\n    char buf[100];\n    char *bufpnt;\n    ssize_t readnb;\n\n    repoll:\n    dlhandler->pfds_f_in.revents = 0;\n    pollret = poll(&dlhandler->pfds_f_in, 1U,\n                   required_sleep <= 0.0 ?\n                   0 : (int) (required_sleep * 1000.0));\n    if (pollret <= 0) {\n        return pollret;\n    }\n    if ((dlhandler->pfds_f_in.revents & (POLLIN | POLLPRI)) != 0) {\n        if (dlhandler->tls_clientfd != NULL) {\n#ifdef WITH_TLS\n            readnb = SSL_read(dlhandler->tls_clientfd, buf,\n                              sizeof buf - (size_t) 1U);\n#else\n            abort();\n#endif\n        } else {\n            readnb = read(dlhandler->clientfd, buf, sizeof buf - (size_t) 1U);\n        }\n        if (readnb == (ssize_t) 0) {\n            return -2;\n        }\n        if (readnb < (ssize_t) 0) {\n            if (errno == EAGAIN || errno == EINTR) {\n                return 0;\n            }\n            return -1;\n        }\n        buf[readnb] = 0;\n        bufpnt = skip_telnet_controls(buf);\n        if (strchr(bufpnt, '\\n') != NULL) {\n            if (strncasecmp(bufpnt, \"ABOR\", sizeof \"ABOR\" - 1U) != 0 &&\n                strncasecmp(bufpnt, \"QUIT\", sizeof \"QUIT\" - 1U) != 0) {\n                addreply_noformat(500, MSG_UNKNOWN_COMMAND);\n                doreply();\n            } else {\n                addreply_noformat(426, \"ABORT\");\n                doreply();\n                addreply_noformat(226, MSG_ABORTED);\n                return 1;\n            }\n        }\n        if (required_sleep > 0.0) {\n            goto repoll;\n        }\n    } else if ((dlhandler->pfds_f_in.revents &\n                (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n        addreply_noformat(451, MSG_DATA_READ_FAILED);\n        return 1;\n    }\n    return 0;\n}\n\nstatic int dlmap_send(DLHandler * const dlhandler)\n{\n    int ret;\n    double ts_start = 0.0;\n    double required_sleep;\n    off_t downloaded;\n\n    if (dlhandler->bandwidth > 0UL && (ts_start = get_usec_time()) <= 0.0) {\n        error(451, \"gettimeofday()\");\n        return -1;\n    }\n    required_sleep = 0.0;\n    for (;;) {\n        ret = _dlmap_remap(dlhandler);\n        if (ret < 0) {\n            return -1;\n        }\n        if (ret == 1) {\n            break;\n        }\n        if (dl_dowrite(dlhandler, dlhandler->map_data, dlhandler->chunk_size,\n                       &downloaded) != 0) {\n            return -1;\n        }\n        dlhandler->cur_pos += dlhandler->chunk_size;\n#ifdef FTPWHO\n        if (shm_data_cur != NULL) {\n            shm_data_cur->download_current_size = dlhandler->cur_pos;\n        }\n#endif\n        dlhandler->total_downloaded += downloaded;\n        required_sleep = 0.0;\n        if (dlhandler->bandwidth > 0UL) {\n            dlhandler_throttle(dlhandler, downloaded, ts_start,\n                               &required_sleep);\n        }\n        ret = dlhandler_handle_commands(dlhandler, required_sleep);\n        if (ret != 0) {\n            return ret;\n        }\n    }\n    return 0;\n}\n\nstatic int dlmap_exit(DLHandler * const dlhandler)\n{\n    if (dlhandler->map != NULL) {\n        free(dlhandler->map);\n        dlhandler->map = NULL;\n        dlhandler->sizeof_map = (size_t) 0U;\n        dlhandler->dlmap_size = (size_t) 0U;\n    }\n    return 0;\n}\n\nvoid doretr(char *name)\n{\n    DLHandler dlhandler;\n    int f;\n    struct stat st;\n    double started = 0.0;\n    int ret;\n\n    dlhandler.total_downloaded = 0;\n    if (!candownload) {\n        addreply(550, MSG_LOAD_TOO_HIGH, load);\n        goto end;\n    }\n    if (type < 1 || (type == 1 && restartat > (off_t) 1)) {\n        addreply_noformat(503, MSG_NO_ASCII_RESUME);\n        goto end;\n    }\n    if (checknamesanity(name, dot_read_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        goto end;\n    }\n    if ((f = open(name, O_RDONLY)) == -1) {\n        displayopenfailure(name);\n        goto end;\n    }\n    if (fstat(f, &st) < 0) {\n        stat_failure:\n        (void) close(f);\n        error(451, MSG_STAT_FAILURE);\n        goto end;\n    }\n    if (S_ISLNK(st.st_mode)) {\n        if (stat(name, &st) < 0) {\n            goto stat_failure;\n        }\n    }\n    if (restartat > st.st_size) {\n        (void) close(f);\n        addreply(554, MSG_REST_TOO_LARGE_FOR_FILE \"\\n\" MSG_REST_RESET,\n                 (long long) restartat, (long long) st.st_size);\n        goto end;\n    }\n    if (!S_ISREG(st.st_mode) || ((off_t) st.st_size != st.st_size)) {\n        (void) close(f);\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n        goto end;\n    }\n    if (warez != 0 && st.st_uid == warez && guest != 0) {\n        (void) close(f);\n        addreply(550, MSG_NOT_MODERATED);\n        goto end;\n    }\n#ifdef RATIOS\n    if (ratio_upload > 0U && ratio_download > 0U) {\n        if ((downloaded + st.st_size - restartat) / ratio_download >\n            (uploaded / ratio_upload)) {\n            (void) close(f);\n            addreply(550, MSG_RATIO_DENIAL, ratio_upload, ratio_download,\n                     (unsigned long long) uploaded / 1024ULL,\n                     (unsigned long long) downloaded / 1024ULL);\n            goto end;\n        }\n    }\n#endif\n    opendata();\n    if (xferfd == -1) {\n        (void) close(f);\n        goto end;\n    }\n#ifndef DISABLE_HUMOR\n    if ((time(NULL) % 100) == 0) {\n        addreply_noformat(0, MSG_WINNER);\n    }\n#endif\n    if (st.st_size - restartat > 4096) {\n        addreply(0, MSG_KBYTES_LEFT, (double) ((st.st_size - restartat) / 1024.0));\n    }\n    doreply();\n# ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n    }\n# endif\n    state_needs_update = 1;\n    setprocessname(\"pure-ftpd (DOWNLOAD)\");\n\n#ifdef FTPWHO\n    if (shm_data_cur != NULL) {\n        const size_t sl = strlen(name);\n\n        ftpwho_lock();\n        shm_data_cur->state = FTPWHO_STATE_DOWNLOAD;\n        shm_data_cur->download_total_size = st.st_size;\n        shm_data_cur->download_current_size = restartat;\n        shm_data_cur->restartat = restartat;\n        (void) time(&shm_data_cur->xfer_date);\n        if (sl < sizeof shm_data_cur->filename) {\n            memcpy(shm_data_cur->filename, name, sl);\n            shm_data_cur->filename[sl] = 0;\n        } else {\n            memcpy(shm_data_cur->filename,\n                   &name[sl - sizeof shm_data_cur->filename - 1U],\n                   sizeof shm_data_cur->filename);\n        }\n        ftpwho_unlock();\n    }\n#endif\n#ifdef HAVE_POSIX_FADVISE\n    (void) posix_fadvise(f, (off_t) 0, st.st_size, POSIX_FADV_SEQUENTIAL);\n#endif\n\n    started = get_usec_time();\n\n    if (dlmap_init(&dlhandler, clientfd, tls_cnx, xferfd, name, f,\n                   tls_data_cnx, restartat, type == 1,\n                   throttling_bandwidth_dl) == 0) {\n        ret = dlmap_send(&dlhandler);\n        dlmap_exit(&dlhandler);\n    } else {\n        ret = -1;\n    }\n\n    (void) close(f);\n    closedata();\n    if (ret == 0) {\n        addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);\n    }\n    downloaded += dlhandler.total_downloaded;\n    displayrate(MSG_DOWNLOADED, dlhandler.total_downloaded, started, name, 0);\n\n    end:\n    restartat = (off_t) 0;\n}\n\nvoid dorest(const char *name)\n{\n    char *endptr;\n\n    restartat = (off_t) strtoull(name, &endptr, 10);\n    if (*endptr != 0 || restartat < (off_t) 0) {\n        restartat = 0;\n        addreply(554, MSG_REST_NOT_NUMERIC \"\\n\" MSG_REST_RESET);\n    } else {\n        if (type == 1 && restartat != 0) {\n#ifdef STRICT_REST\n            addreply_noformat(504, MSG_REST_ASCII_STRICT);\n#else\n            addreply(350, MSG_REST_ASCII_WORKAROUND,\n                     (long long) restartat);\n#endif\n        } else {\n            if (restartat != 0) {\n                logfile(LOG_NOTICE, MSG_REST_SUCCESS, (long long) restartat);\n            }\n            addreply(350, MSG_REST_SUCCESS, (long long) restartat);\n        }\n    }\n}\n\nvoid domkd(char *name)\n{\n#ifdef QUOTAS\n    Quota quota;\n    int overflow;\n#endif\n\n    if (guest != 0 && allow_anon_mkdir == 0) {\n        addreply_noformat(550, MSG_ANON_CANT_MKD);\n        return;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply_noformat(553, MSG_SANITY_DIRECTORY_FAILURE);\n        return;\n    }\n#ifdef QUOTAS\n    if (quota_update(&quota, 1LL, 0LL, &overflow) == 0 && overflow != 0) {\n        (void) quota_update(&quota, -1LL, 0LL, NULL);\n        addreply(552, MSG_QUOTA_EXCEEDED, name);\n        goto end;\n    }\n#endif\n    if ((mkdir(name, (mode_t) (0777 & ~u_mask_d))) < 0) {\n#ifdef QUOTAS\n        (void) quota_update(&quota, -1LL, 0LL, NULL);\n#endif\n        error(550, MSG_MKD_FAILURE);\n    } else {\n        addreply(257, \"\\\"%s\\\" : \" MSG_MKD_SUCCESS, name);\n#ifndef MINIMAL\n        cwd_failures = 0UL;\n#endif\n    }\n#ifdef QUOTAS\n    end:\n    displayquota(&quota);\n#endif\n}\n\nvoid dormd(char *name)\n{\n#ifdef QUOTAS\n    Quota quota;\n#endif\n\n#ifndef ANON_CAN_DELETE\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_RMD);\n        return;\n    }\n#endif\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply_noformat(553, MSG_SANITY_DIRECTORY_FAILURE);\n        return;\n    }\n    if ((rmdir(name)) < 0) {\n        error(550, MSG_RMD_FAILURE);\n    } else {\n#ifdef QUOTAS\n        if (quota_update(&quota, -1LL, 0LL, NULL) == 0) {\n            displayquota(&quota);\n        }\n#endif\n        addreply_noformat(250, MSG_RMD_SUCCESS);\n    }\n}\n\n#ifndef MINIMAL\nvoid dofeat(void)\n{\n# define FEAT  \"Extensions supported:\" CRLF \\\n    \" UTF8\" CRLF \\\n    \" EPRT\" CRLF \" IDLE\" CRLF \" MDTM\" CRLF \" SIZE\" CRLF \" MFMT\" CRLF \\\n    \" REST STREAM\" CRLF \\\n    \" MLST type*;size*;sizd*;modify*;UNIX.mode*;UNIX.uid*;UNIX.gid*;unique*;\" CRLF \\\n    \" MLSD\" CRLF \\\n    \" PRET\"\n\n# ifdef WITH_TLS\n#  define FEAT_TLS CRLF \" AUTH TLS\" CRLF \" PBSZ\" CRLF \" PROT\"\n# else\n#  define FEAT_TLS \"\"\n# endif\n# ifdef DEBUG\n#  define FEAT_DEBUG CRLF \" XDBG\"\n# else\n#  define FEAT_DEBUG \"\"\n# endif\n# ifdef WITH_VIRTUAL_CHROOT\n#  define FEAT_TVFS \"\"\n# else\n#  define FEAT_TVFS CRLF \" TVFS\"\n# endif\n# define FEAT_PASV CRLF \" PASV\" CRLF \" EPSV\"\n\n# ifdef MINIMAL\n#  define FEAT_ESTA \"\"\n#  define FEAT_ESTP \"\"\n# else\n#  define FEAT_ESTA CRLF \" ESTA\"\n#  define FEAT_ESTP CRLF \" ESTP\"\n# endif\n\n    char feat[] = FEAT FEAT_DEBUG FEAT_TLS FEAT_TVFS FEAT_ESTA FEAT_PASV FEAT_ESTP;\n\n    if (disallow_passive != 0) {\n        feat[sizeof FEAT FEAT_DEBUG FEAT_TLS FEAT_TVFS FEAT_ESTA - 1U] = 0;\n    }\n# ifndef MINIMAL\n    else if (STORAGE_FAMILY(force_passive_ip) != 0) {\n        feat[sizeof FEAT FEAT_DEBUG FEAT_TLS FEAT_TVFS FEAT_ESTA FEAT_PASV - 1U] = 0;\n    }\n# endif\n    addreply_noformat(0, feat);\n    addreply_noformat(211, \"End.\");\n}\n#endif\n\n#ifndef MINIMAL\nvoid dostou(void)\n{\n    char file[64];\n    static unsigned int seq = 0U;\n    struct timeval tv;\n    struct timezone tz;\n\n    if (gettimeofday(&tv, &tz) != 0) {\n        error(553, MSG_TIMESTAMP_FAILURE);\n        return;\n    }\n    if (SNCHECK(snprintf(file, sizeof file, \"pureftpd.%08lx.%02lx.%04x\",\n                         (unsigned long) tv.tv_sec,\n                         (unsigned long) tv.tv_usec & 0xff,\n                         seq), sizeof file)) {\n        _EXIT(EXIT_FAILURE);\n    }\n    seq++;\n    seq &= 0xffff;\n    addreply(150, \"FILE: %s\", file);\n    dostor(file, 0, 1);\n}\n#endif\n\nstatic int tryautorename(const char * const atomic_file, char * const name,\n                         const char ** const name2_)\n{\n    static char name2[PATH_MAX];\n    unsigned int gc = 0U;\n\n    if (link(atomic_file, name) == 0) {\n        *name2_ = NULL;\n        (void) unlink(atomic_file);\n        return 0;\n    }\n    *name2_ = name2;\n    for (;;) {\n        gc++;\n        if (gc == 0U ||\n#ifdef AUTORENAME_REVERSE_ORDER\n            SNCHECK(snprintf(name2, sizeof name2, \"%u.%s\", gc, name),\n                    sizeof name2)\n#else\n            SNCHECK(snprintf(name2, sizeof name2, \"%s.%u\", name, gc),\n                    sizeof name2)\n#endif\n            ) {\n            break;\n        }\n        if (link(atomic_file, name2) == 0) {\n            (void) unlink(atomic_file);\n            return 0;\n        }\n        switch (errno) {\n#ifdef EEXIST\n        case EEXIST:\n#endif\n#ifdef EISDIR\n        case EISDIR:\n#endif\n#ifdef ETXTBSY\n        case ETXTBSY:\n#endif\n            continue;\n        }\n        break;\n    }\n    *name2_ = NULL;\n\n    return -1;\n}\n\nstatic char *get_atomic_file(const char * const file)\n{\n    static char res[PATH_MAX];\n    char *z;\n    size_t orig_len;\n    size_t slash;\n    size_t sizeof_atomic_prefix;\n\n    if (file == NULL) {\n        return res;\n    }\n    if ((z = strrchr(file, '/')) == NULL) {\n        *res = 0;\n        orig_len = (size_t) 0U;\n    } else {\n        slash = (size_t) (z - file);\n        if (slash >= (sizeof res - (size_t) 1U)) {\n            return NULL;\n        }\n        slash++;\n        if (file[slash] == 0) {\n            return NULL;\n        }\n        strncpy(res, file, slash);\n        res[slash] = 0;\n        orig_len = strlen(res);\n    }\n    sizeof_atomic_prefix = strlen(atomic_prefix) + (size_t) 1U;\n    if (sizeof res - orig_len < sizeof_atomic_prefix) {\n        return NULL;\n    }\n    memcpy(res + orig_len, atomic_prefix, sizeof_atomic_prefix);\n\n    return res;\n}\n\nvoid delete_atomic_file(void)\n{\n    const char *atomic_file;\n\n    if ((atomic_file = get_atomic_file(NULL)) == NULL || *atomic_file == 0) {\n        return;\n    }\n    (void) unlink(atomic_file);\n    atomic_file = NULL;\n}\n\nstatic off_t get_file_size(const char * const file)\n{\n    struct stat st;\n\n    if (stat(file, &st) != 0) {\n        return (off_t) -1;\n    }\n    return st.st_size;\n}\n\n#ifdef QUOTAS\nstatic int ul_quota_update(const char * const file_name,\n                           const int files_count, const off_t bytes)\n{\n    Quota quota;\n    off_t file_size = (off_t) -1;\n    int overflow;\n    int ret = 0;\n\n    if (files_count == 0 && bytes == (off_t) 0) {\n        return 0;\n    }\n    if (quota_update(&quota, files_count, (long long) bytes, &overflow) != 0) {\n        return 0;\n    }\n    if (overflow != 0) {\n        ret = 1;\n        if (file_name != NULL) {\n            file_size = get_file_size(file_name);\n        }\n        if (file_size >= (off_t) 0 && unlink(file_name) == 0) {\n            (void) quota_update(&quota, -1, (long long) -file_size, NULL);\n        }\n    }\n    displayquota(&quota);\n\n    return ret;\n}\n#endif\n\nstatic int ulhandler_throttle(ULHandler * const ulhandler,\n                              const off_t uploaded, const double ts_start,\n                              double *required_sleep)\n{\n    double ts_now;\n    double elapsed;\n    off_t would_be_uploaded;\n    double wanted_ts;\n    off_t previous_chunk_size;\n\n    (void) uploaded;\n    if (ulhandler->bandwidth <= 0UL) {\n        *required_sleep = 0.0;\n        return 0;\n    }\n    if ((ts_now = get_usec_time()) <= 0.0) {\n        ts_now = ts_start;\n    }\n    if (ts_start > ts_now) {\n        ts_now = ts_start;\n    }\n    elapsed = ts_now - ts_start;\n    would_be_uploaded = ulhandler->total_uploaded + ulhandler->chunk_size;\n    if (ulhandler->bandwidth > 0UL) {\n        wanted_ts = (double) would_be_uploaded / (double) ulhandler->bandwidth;\n    } else {\n        wanted_ts = elapsed;\n    }\n    *required_sleep = wanted_ts - elapsed;\n    previous_chunk_size = ulhandler->chunk_size;\n    if (ulhandler->total_uploaded > ulhandler->chunk_size) {\n        if (*required_sleep < ulhandler->min_sleep) {\n            ulhandler->chunk_size =\n                (ulhandler->max_chunk_size + ulhandler->chunk_size) / 2;\n        } else if (*required_sleep > ulhandler->max_sleep) {\n            ulhandler->chunk_size =\n                (ulhandler->min_chunk_size + ulhandler->chunk_size) / 2;\n        } else {\n            ulhandler->chunk_size = ulhandler->default_chunk_size;\n        }\n        if (ulhandler->chunk_size <= 0 ||\n            ulhandler->chunk_size > (off_t) ulhandler->sizeof_buf) {\n            ulhandler->chunk_size = ulhandler->default_chunk_size;\n        }\n        if (previous_chunk_size != ulhandler->default_chunk_size) {\n            would_be_uploaded =\n                ulhandler->total_uploaded + ulhandler->chunk_size;\n            if (ulhandler->bandwidth > 0UL) {\n                wanted_ts = (double) would_be_uploaded /\n                    (double) ulhandler->bandwidth;\n            } else {\n                wanted_ts = elapsed;\n            }\n            *required_sleep = wanted_ts - elapsed;\n        }\n    }\n    return 0;\n}\n\nstatic int ul_init(ULHandler * const ulhandler, const int clientfd,\n                   void * const tls_clientfd, const int xferfd,\n                   const char * const name, const int f, void * const tls_fd,\n                   const off_t restartat, const int ascii_mode,\n                   const unsigned long bandwidth, const off_t max_filesize)\n{\n    struct pollfd *pfd;\n\n    (void) name;\n    if (ascii_mode > 0) {\n#ifdef WITHOUT_ASCII\n        addreply_noformat(450, MSG_ASCII_MODE_UNSUPPORTED);\n        return -1;\n#else\n        addreply_noformat(0, MSG_ASCII_MODE_WARNING);\n#endif\n    }\n    if (fcntl(xferfd, F_SETFL, fcntl(xferfd, F_GETFL) | O_NONBLOCK) == -1) {\n        error(451, \"fcntl(F_SETFL, O_NONBLOCK)\");\n        return -1;\n    }\n    ulhandler->buf = NULL;\n    ulhandler->sizeof_buf = (size_t) 0UL;\n    ulhandler->clientfd = clientfd;\n    ulhandler->tls_clientfd = tls_clientfd;\n    ulhandler->xferfd = xferfd;\n    ulhandler->f = f;\n    ulhandler->tls_fd = tls_fd;\n    ulhandler->ascii_mode = ascii_mode;\n    ulhandler->cur_pos = restartat;\n    ulhandler->total_uploaded = (off_t) 0;\n    ulhandler->min_sleep = 0.1;\n    ulhandler->max_sleep = 5.0;\n    ulhandler->bandwidth = bandwidth;\n    ulhandler->max_filesize = max_filesize;\n    ulhandler->idletime = idletime;\n    pfd = &ulhandler->pfds[PFD_DATA];\n    pfd->fd = xferfd;\n    pfd->events = POLLIN | POLLERR | POLLHUP;\n    pfd->revents = 0;\n    pfd = &ulhandler->pfds[PFD_COMMANDS];\n    pfd->fd = clientfd;\n#ifdef __APPLE_CC__\n    pfd->events = POLLRDBAND | POLLPRI | POLLERR | POLLHUP;\n#else\n    pfd->events = POLLIN | POLLPRI | POLLERR | POLLHUP;\n#endif\n    pfd->revents = 0;\n    pfd = &ulhandler->pfds_command;\n    pfd->fd = clientfd;\n#ifdef __APPLE_CC__\n    pfd->events = POLLRDBAND | POLLPRI | POLLERR | POLLHUP;\n#else\n    pfd->events = POLLIN | POLLPRI | POLLERR | POLLHUP;\n#endif\n    pfd->revents = 0;\n    ulhandler->min_chunk_size = UL_MIN_CHUNK_SIZE;\n    if (ascii_mode > 0) {\n        ulhandler->default_chunk_size = ulhandler->max_chunk_size =\n            UL_DEFAULT_CHUNK_SIZE_ASCII;\n    } else {\n        ulhandler->max_chunk_size = UL_MAX_CHUNK_SIZE;\n        if (bandwidth <= 0UL) {\n            ulhandler->default_chunk_size = ulhandler->max_chunk_size;\n        } else {\n            ulhandler->default_chunk_size = UL_DEFAULT_CHUNK_SIZE;\n        }\n    }\n    ulhandler->chunk_size = ulhandler->default_chunk_size;\n    ulhandler->cur_pos = restartat;\n    ulhandler->sizeof_buf = ulhandler->max_chunk_size;\n    if ((ulhandler->buf = malloc(ulhandler->sizeof_buf)) == NULL) {\n        ulhandler->buf = NULL;\n        ulhandler->sizeof_buf = (size_t) 0U;\n        return -1;\n    }\n    return 0;\n}\n\nstatic int ul_dowrite(ULHandler * const ulhandler, const unsigned char *buf_,\n                      const size_t size_, off_t * const uploaded)\n{\n    size_t size = size_;\n    ssize_t written;\n    const unsigned char *buf = buf_;\n    unsigned char *unasciibuf = NULL;\n    int ret = 0;\n\n    if (size_ <= (size_t) 0U) {\n        *uploaded = 0;\n        return -1;\n    }\n#ifndef WITHOUT_ASCII\n    if (ulhandler->ascii_mode > 0) {\n        unsigned char *unasciibufpnt;\n        size_t z = (size_t) 0U;\n\n        if (size > (size_t) ulhandler->chunk_size ||\n            (unasciibuf = ALLOCA((size_t) ulhandler->chunk_size)) == NULL) {\n            return -1;\n        }\n        unasciibufpnt = unasciibuf;\n        do {\n            if (buf_[z] != (unsigned char) '\\r') {\n                *unasciibufpnt++ = buf_[z];\n            }\n            z++;\n        } while (z < size);\n        buf = unasciibuf;\n        size = (size_t) (unasciibufpnt - unasciibuf);\n    }\n#endif\n    written = safe_write(ulhandler->f, buf, size, -1);\n    ret = - (written != (ssize_t) size);\n    if (unasciibuf != NULL) {\n        ALLOCA_FREE(unasciibuf);\n    }\n    if (ret < 0) {\n        *uploaded = 0;\n    } else {\n        *uploaded = size;\n    }\n    return ret;\n}\n\nstatic int ulhandler_handle_commands(ULHandler * const ulhandler)\n{\n    char buf[100];\n    char *bufpnt;\n    ssize_t readnb;\n\n    if (ulhandler->tls_clientfd != NULL) {\n#ifdef WITH_TLS\n        readnb = SSL_read(ulhandler->tls_clientfd, buf,\n                          sizeof buf - (size_t) 1U);\n#else\n        abort();\n#endif\n    } else {\n        readnb = read(ulhandler->clientfd, buf, sizeof buf - (size_t) 1U);\n    }\n    if (readnb == (ssize_t) 0) {\n        return -2;\n    }\n    if (readnb < (ssize_t) 0) {\n        if (errno == EAGAIN || errno == EINTR) {\n            return 0;\n        }\n        return -1;\n    }\n    buf[readnb] = 0;\n    bufpnt = skip_telnet_controls(buf);\n    if (strchr(buf, '\\n') != NULL) {\n        if (strncasecmp(bufpnt, \"ABOR\", sizeof \"ABOR\" - 1U) != 0 &&\n            strncasecmp(bufpnt, \"QUIT\", sizeof \"QUIT\" - 1U) != 0) {\n            addreply_noformat(500, MSG_UNKNOWN_COMMAND);\n            doreply();\n        } else {\n            addreply_noformat(426, MSG_ABORTED);\n            doreply();\n            return 1;\n        }\n    }\n    return 0;\n}\n\nstatic int ul_handle_data(ULHandler * const ulhandler, off_t * const uploaded,\n                          const double ts_start)\n{\n    ssize_t readnb;\n    double required_sleep = 0.0;\n    int pollret;\n    int ret;\n\n    if (ulhandler->max_filesize >= (off_t) 0 &&\n        ulhandler->total_uploaded > ulhandler->max_filesize) {\n        addreply(552, MSG_ABORTED \" (quota)\");\n        return -2;\n    }\n    if (ulhandler->chunk_size > (off_t) ulhandler->sizeof_buf) {\n        ulhandler->chunk_size = ulhandler->max_chunk_size =\n            ulhandler->sizeof_buf;\n    }\n    if (ulhandler->tls_fd != NULL) {\n#ifdef WITH_TLS\n        readnb = SSL_read(ulhandler->tls_fd, ulhandler->buf,\n                          ulhandler->chunk_size);\n#else\n        abort();\n#endif\n    } else {\n        readnb = read(ulhandler->xferfd, ulhandler->buf,\n                      ulhandler->chunk_size);\n    }\n    if (readnb == (ssize_t) 0) {\n        return 2;\n    }\n    if (readnb < (ssize_t) 0) {\n        if (errno == EAGAIN || errno == EINTR) {\n            return 0;\n        }\n        addreply_noformat(451, MSG_DATA_READ_FAILED);\n        return -1;\n    }\n    if (ul_dowrite(ulhandler, ulhandler->buf, readnb, uploaded) != 0) {\n        addreply_noformat(452, MSG_WRITE_FAILED);\n        return -1;\n    }\n    ulhandler->cur_pos += *uploaded;\n#ifdef FTPWHO\n        if (shm_data_cur != NULL) {\n            shm_data_cur->download_current_size =\n                shm_data_cur->download_total_size = ulhandler->cur_pos;\n        }\n#endif\n    ulhandler->total_uploaded += *uploaded;\n    if (ulhandler->bandwidth > 0UL) {\n        ulhandler_throttle(ulhandler, *uploaded, ts_start, &required_sleep);\n        if (required_sleep > 0.0) {\n            repoll:\n            ulhandler->pfds_command.revents = 0;\n            pollret = poll(&ulhandler->pfds_command, 1, required_sleep * 1000.0);\n            if (pollret == 0) {\n                return 0;\n            }\n            if (pollret < 0) {\n                if (errno == EINTR) {\n                    goto repoll;\n                }\n                return -1;\n            }\n            if ((ulhandler->pfds_command.revents &\n                 (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n                return -1;\n            }\n            if ((ulhandler->pfds_command.revents & (POLLIN | POLLPRI)) != 0) {\n                ret = ulhandler_handle_commands(ulhandler);\n                if (ret != 0) {\n                    return ret;\n                }\n                goto repoll;\n            }\n        }\n    }\n    return 0;\n}\n\nstatic int ul_send(ULHandler * const ulhandler)\n{\n    double ts_start = 0.0;\n    off_t uploaded = (off_t) 0;\n    int pollret;\n    int timeout;\n    int ret;\n\n    if (ulhandler->bandwidth > 0UL && (ts_start = get_usec_time()) <= 0.0) {\n        error(451, \"gettimeofday()\");\n        return -1;\n    }\n    for (;;) {\n        if (ulhandler->idletime >= INT_MAX / 1000) {\n            timeout = INT_MAX;\n        } else {\n            timeout = (int) ulhandler->idletime * 1000;\n        }\n        ulhandler->pfds[PFD_DATA].revents =\n            ulhandler->pfds[PFD_COMMANDS].revents = 0;\n        pollret = poll(ulhandler->pfds,\n                       sizeof ulhandler->pfds / sizeof ulhandler->pfds[0],\n                       timeout);\n        if (pollret < 0) {\n            addreply_noformat(451, MSG_DATA_READ_FAILED);\n            return -1;\n        }\n        if (pollret == 0) {\n            addreply_noformat(421, MSG_TIMEOUT);\n            return -1;\n        }\n        if ((ulhandler->pfds[PFD_DATA].revents & POLLIN) != 0) {\n            ret = ul_handle_data(ulhandler, &uploaded, ts_start);\n            switch (ret) {\n            case 1:\n                return 1;\n            case 2:\n                return 0;\n            case 0:\n                break;\n            default:\n                if (ret > 2) {\n                    abort();\n                }\n                return ret;\n            }\n        }\n        if ((ulhandler->pfds[PFD_COMMANDS].revents & (POLLIN | POLLPRI)) != 0) {\n            ret = ulhandler_handle_commands(ulhandler);\n            if (ret != 0) {\n                return ret;\n            }\n        }\n        if ((ulhandler->pfds[PFD_DATA].revents & (POLLERR | POLLNVAL)) != 0 ||\n            ((ulhandler->pfds[PFD_DATA].revents & POLLHUP) != 0 &&\n             (ulhandler->pfds[PFD_DATA].revents & POLLIN) == 0)) {\n            return -1;\n        }\n        if ((ulhandler->pfds[PFD_COMMANDS].revents &\n             (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n            addreply_noformat(221, MSG_LOGOUT);\n            return -1;\n        }\n    }\n    /* NOTREACHED */\n    return 0;\n}\n\nstatic int ul_exit(ULHandler * const ulhandler)\n{\n    free(ulhandler->buf);\n    ulhandler->buf = NULL;\n\n    return 0;\n}\n\nint ul_check_free_space(const char *name, const double min_space)\n{\n    STATFS_STRUCT statfsbuf;\n    char *z;\n    char *alloca_namedir;\n    size_t name_len;\n    double jam;\n    double space;\n\n    if (maxdiskusagepct <= 0.0 && min_space <= 0.0) {\n        return 1;\n    }\n#ifdef CHECK_SYMLINKS_DISK_SPACE\n    if (STATFS(name, &statfsbuf) == 0) {\n        goto okcheckspace;\n    }\n#endif\n    name_len = strlen(name) + (size_t) 1U;\n    if (name_len < (size_t) 2U ||\n        (alloca_namedir = ALLOCA(name_len)) == NULL) {\n        return -1;\n    }\n    memcpy(alloca_namedir, name, name_len);\n    if ((z = strrchr(alloca_namedir, '/')) != NULL) {\n        if (z == alloca_namedir) {\n            *z++ = '.';\n        }\n        *z = 0;\n    } else {\n        alloca_namedir[0] = '.';\n        alloca_namedir[1] = 0;\n    }\n    if (STATFS(alloca_namedir, &statfsbuf) != 0) {\n        ALLOCA_FREE(alloca_namedir);\n        return -1;\n    }\n    ALLOCA_FREE(alloca_namedir);\n\n#ifdef CHECK_SYMLINKS_DISK_SPACE\n    okcheckspace:\n#endif\n    if ((double) STATFS_BLOCKS(statfsbuf) <= 0.0) {\n        return 1;\n    }\n    if (min_space >= 0.0) {\n        space = (double) STATFS_BAVAIL(statfsbuf) *\n            (double) STATFS_FRSIZE(statfsbuf);\n        if (space < min_space) {\n            return 0;\n        }\n    }\n    jam = (double) STATFS_BAVAIL(statfsbuf) /\n        (double) STATFS_BLOCKS(statfsbuf);\n    if (jam >= maxdiskusagepct) {\n        return 1;\n    }\n    return 0;\n}\n\nvoid dostor(char *name, const int append, const int autorename)\n{\n    ULHandler ulhandler;\n    int f;\n    const char *ul_name = NULL;\n    const char *atomic_file = NULL;\n    off_t filesize = (off_t) 0U;\n    struct stat st;\n    double started = 0.0;\n    signed char overwrite = 0;\n    int overflow = 0;\n    int ret = -1;\n    off_t max_filesize = (off_t) -1;\n#ifdef QUOTAS\n    Quota quota;\n#endif\n    const char *name2 = NULL;\n\n    if (type < 1 || (type == 1 && restartat > (off_t) 1)) {\n        addreply_noformat(503, MSG_NO_ASCII_RESUME);\n        goto end;\n    }\n#ifndef ANON_CAN_RESUME\n    if (guest != 0 && anon_noupload != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n        goto end;\n    }\n#endif\n    if (ul_check_free_space(name, -1.0) == 0) {\n        addreply_noformat(552, MSG_NO_DISK_SPACE);\n        goto end;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        goto end;\n    }\n    if (autorename != 0) {\n        no_truncate = 1;\n    }\n    if (restartat > (off_t) 0 || no_truncate != 0) {\n        if ((atomic_file = get_atomic_file(name)) == NULL) {\n            addreply(553, MSG_SANITY_FILE_FAILURE, name);\n            goto end;\n        }\n        if (restartat > (off_t) 0 &&\n            rename(name, atomic_file) != 0 && errno != ENOENT) {\n            error(553, MSG_RENAME_FAILURE);\n            atomic_file = NULL;\n            goto end;\n        }\n    }\n    if (atomic_file != NULL) {\n        ul_name = atomic_file;\n    } else {\n        ul_name = name;\n    }\n    if (atomic_file == NULL &&\n        (f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) {\n        overwrite++;\n    } else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW,\n                         (mode_t) 0777 & ~u_mask)) == -1) {\n        error(553, MSG_OPEN_FAILURE2);\n        goto end;\n    }\n    if (fstat(f, &st) < 0) {\n        (void) close(f);\n        error(553, MSG_STAT_FAILURE2);\n        goto end;\n    }\n    if (!S_ISREG(st.st_mode)) {\n        (void) close(f);\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n        goto end;\n    }\n    alarm(MAX_SESSION_XFER_IDLE);\n\n    /* Anonymous users *CAN* overwrite 0-bytes files - This is the right behavior */\n    if (st.st_size > (off_t) 0) {\n#ifndef ANON_CAN_RESUME\n        if (guest != 0) {\n            addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n            (void) close(f);\n            goto end;\n        }\n#endif\n        if (append != 0) {\n            restartat = st.st_size;\n        }\n    } else {\n        restartat = (off_t) 0;\n    }\n    if (restartat > st.st_size) {\n        restartat = st.st_size;\n    }\n    if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) {\n        (void) close(f);\n        error(451, \"seek\");\n        goto end;\n    }\n    if (restartat < st.st_size) {\n        if (ftruncate(f, restartat) < 0) {\n            (void) close(f);\n            error(451, \"ftruncate\");\n            goto end;\n        }\n#ifdef QUOTAS\n        if (restartat != st.st_size) {\n            (void) quota_update(NULL, 0LL,\n                                (long long) (restartat - st.st_size),\n                                &overflow);\n        }\n#endif\n    }\n#ifdef QUOTAS\n    if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 &&\n        (overflow > 0 || quota.files >= user_quota_files ||\n         quota.size > user_quota_size ||\n         (max_filesize = user_quota_size - quota.size) < (off_t) 0)) {\n        overflow = 1;\n        (void) close(f);\n        goto afterquota;\n    }\n#endif\n    opendata();\n    if (xferfd == -1) {\n        (void) close(f);\n        goto end;\n    }\n    doreply();\n# ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n    }\n# endif\n    state_needs_update = 1;\n    setprocessname(\"pure-ftpd (UPLOAD)\");\n    filesize = restartat;\n\n#ifdef FTPWHO\n    if (shm_data_cur != NULL) {\n        const size_t sl = strlen(name);\n\n        ftpwho_lock();\n        shm_data_cur->state = FTPWHO_STATE_UPLOAD;\n        shm_data_cur->download_total_size = (off_t) 0U;\n        shm_data_cur->download_current_size = (off_t) filesize;\n        shm_data_cur->restartat = restartat;\n        (void) time(&shm_data_cur->xfer_date);\n        if (sl < sizeof shm_data_cur->filename) {\n            memcpy(shm_data_cur->filename, name, sl);\n            shm_data_cur->filename[sl] = 0;\n        } else {\n            memcpy(shm_data_cur->filename,\n                   &name[sl - sizeof shm_data_cur->filename - 1U],\n                   sizeof shm_data_cur->filename);\n        }\n        ftpwho_unlock();\n    }\n#endif\n\n    /* Here starts the real upload code */\n\n    started = get_usec_time();\n\n    if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx,\n                restartat, type == 1, throttling_bandwidth_ul,\n                max_filesize) == 0) {\n        ret = ul_send(&ulhandler);\n        ul_exit(&ulhandler);\n    } else {\n        ret = -1;\n    }\n    (void) close(f);\n    closedata();\n\n    /* Here ends the real upload code */\n\n#ifdef SHOW_REAL_DISK_SPACE\n    if (FSTATFS(f, &statfsbuf) == 0) {\n        double space;\n\n        space = (double) STATFS_BAVAIL(statfsbuf) *\n            (double) STATFS_FRSIZE(statfsbuf);\n        if (space > 524288.0) {\n            addreply(0, MSG_SPACE_FREE_M, space / 1048576.0);\n        } else {\n            addreply(0, MSG_SPACE_FREE_K, space / 1024.0);\n        }\n    }\n#endif\n\n    uploaded += (unsigned long long) ulhandler.total_uploaded;\n    {\n        off_t atomic_file_size;\n        off_t original_file_size;\n        int files_count;\n\n        if (overwrite == 0) {\n            files_count = 1;\n        } else {\n            files_count = 0;\n        }\n        if (autorename != 0 && restartat == (off_t) 0) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if (tryautorename(atomic_file, name, &name2) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                ul_quota_update(name2 ? name2 : name, 1, atomic_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else if (atomic_file != NULL) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if ((original_file_size = get_file_size(name)) < (off_t) 0 ||\n                restartat > original_file_size) {\n                original_file_size = restartat;\n            }\n            if (rename(atomic_file, name) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                overflow = ul_quota_update\n                    (name, files_count, atomic_file_size - original_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else {\n#ifdef QUOTAS\n            overflow = ul_quota_update\n                (name, files_count, ulhandler.total_uploaded);\n#endif\n        }\n    }\n    afterquota:\n    if (overflow > 0) {\n        addreply(552, MSG_QUOTA_EXCEEDED, name);\n    } else {\n        if (ret == 0) {\n            addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);\n        } else {\n            addreply_noformat(451, MSG_ABORTED);\n        }\n        displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started,\n                    name2 ? name2 : name, 1);\n    }\n    end:\n    restartat = (off_t) 0;\n    if (atomic_file != NULL) {\n        unlink(atomic_file);\n        atomic_file = NULL;\n    }\n}\n\nvoid domdtm(const char *name)\n{\n    struct stat st;\n    struct tm *t;\n\n    if (!name || !*name) {\n        addreply_noformat(501, MSG_MISSING_ARG);\n    } else if (stat(name, &st)) {\n#ifdef DEBUG\n        if (debug != 0) {\n            addreply(0, \"arg: %s, wd: %s\", name, wd);\n        }\n#endif\n        addreply_noformat(550, MSG_STAT_FAILURE2);\n    } else if (!S_ISREG(st.st_mode)) {\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n    } else {\n        t = gmtime((time_t *) &(st.st_mtime));\n        if (!t) {\n            addreply_noformat(451, MSG_GMTIME_FAILURE);\n        } else {\n            addreply(213, \"%04d%02d%02d%02d%02d%02d\",\n                     t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                     t->tm_hour, t->tm_min, t->tm_sec);\n        }\n    }\n}\n\nvoid dosize(const char *name)\n{\n    struct stat st;\n\n    if (!name || !*name) {\n        addreply_noformat(501, MSG_MISSING_ARG);\n    } else if (stat(name, &st)) {\n#ifdef DEBUG\n        if (debug != 0) {\n            addreply(0, \"arg: %s, wd: %s\", name, wd);\n        }\n#endif\n        addreply_noformat(550, MSG_STAT_FAILURE2);\n    } else if (!S_ISREG(st.st_mode)) {\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n    } else {\n        addreply(213, \"%llu\", (unsigned long long) st.st_size);\n    }\n}\n\nvoid dotype(const char *arg)\n{\n    replycode = 200;            /* bloody awful hack */\n\n    if (!arg || !*arg) {\n        addreply(501, MSG_MISSING_ARG \"\\n\" \"A(scii) I(mage) L(ocal)\");\n    } else if (tolower((unsigned char) *arg) == 'a')\n        type = 1;\n    else if (tolower((unsigned char) *arg) == 'i')\n        type = 2;\n    else if (tolower((unsigned char) *arg) == 'l') {\n        if (arg[1] == '8') {\n            type = 2;\n        } else if (isdigit((unsigned char) arg[1])) {\n            addreply_noformat(504, MSG_TYPE_8BIT_FAILURE);\n        } else {\n            addreply_noformat(0, MSG_MISSING_ARG);\n            type = 2;\n        }\n    } else {\n        addreply(504, MSG_TYPE_UNKNOWN \": %s\", arg);\n    }\n\n    addreply(0, MSG_TYPE_SUCCESS \" %s\", (type > 1) ? \"8-bit binary\" : \"ASCII\");\n}\n\nvoid dostru(const char *arg)\n{\n    if (arg == NULL || !*arg) {\n        addreply_noformat(501, MSG_MISSING_ARG);\n    } else if (strcasecmp(arg, \"F\")) {\n        addreply_noformat(504, MSG_STRU_FAILURE);\n    } else {\n        addreply_noformat(200, \"F OK\");\n    }\n}\n\nvoid domode(const char *arg)\n{\n    if (arg == NULL || !*arg) {\n        addreply_noformat(501, MSG_MISSING_ARG);\n    } else if (strcasecmp(arg, \"S\")) {\n        addreply_noformat(504, MSG_MODE_FAILURE);\n    } else {\n        addreply_noformat(200, \"S OK\");\n    }\n}\n\nvoid dornfr(char *name)\n{\n    struct stat st;\n\n#ifndef ANON_CAN_RENAME\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_RENAME);\n        return;\n    }\n#endif\n    if (disallow_rename != 0) {\n        addreply_noformat(550, MSG_RENAME_FAILURE);\n        return;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        return;\n    }\n    if ((lstat(name, &st)) == 0) {\n        if (renamefrom != NULL) {\n            addreply_noformat(0, MSG_RENAME_ABORT);\n            (void) free(renamefrom);\n        }\n        if ((renamefrom = strdup(name)) == NULL) {\n            die_mem();\n        }\n        addreply_noformat(350, MSG_RENAME_RNFR_SUCCESS);\n    } else {\n        addreply_noformat(550, MSG_FILE_DOESNT_EXIST);\n    }\n}\n\nvoid dornto(char *name)\n{\n#ifdef QUOTAS\n    off_t target_file_size = (off_t) -1;\n    int files_count = 0;\n    long long bytes = 0LL;\n#endif\n\n#ifndef ANON_CAN_RENAME\n    if (guest != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_RENAME);\n        goto bye;\n    }\n#endif\n    if (renamefrom == NULL) {\n        addreply_noformat(503, MSG_RENAME_NORNFR);\n        goto bye;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        return;                        /* don't clear rnfrom buffer */\n    }\n#ifdef QUOTAS\n    if (hasquota() == 0) {\n        struct stat st_source, st_target;\n\n        if (stat(renamefrom, &st_source) != 0) {\n            addreply_noformat(550, MSG_RENAME_FAILURE);\n            goto bye;\n        }\n        if (stat(name, &st_target) != 0) {\n            if (errno == ENOENT) {\n                target_file_size = (off_t) -1;\n            } else {\n                addreply_noformat(550, MSG_RENAME_FAILURE);\n                goto bye;\n            }\n        } else if (st_source.st_ino == st_target.st_ino &&\n                   st_source.st_dev == st_target.st_dev) {\n            addreply_noformat(250, MSG_RENAME_SUCCESS);\n            goto bye;\n        } else {\n            target_file_size = st_target.st_size;\n        }\n        if (target_file_size >= (off_t) 0) {\n            bytes = - (long long) target_file_size;\n            files_count = -1;\n            (void) quota_update(NULL, files_count, bytes, NULL);\n        } else {\n            bytes = (off_t) 0;\n        }\n    }\n#endif\n    if (rename(renamefrom, name) < 0) {\n        error(451, MSG_RENAME_FAILURE);\n#ifdef QUOTAS\n        (void) quota_update(NULL, -files_count, -bytes, NULL);\n#endif\n    } else {\n        addreply_noformat(250, MSG_RENAME_SUCCESS);\n        logfile(LOG_NOTICE, MSG_RENAME_SUCCESS \": [%s]->[%s]\",\n                renamefrom, name);\n    }\n    bye:\n    (void) free(renamefrom);\n    renamefrom = NULL;\n}\n\n#ifndef MINIMAL\nvoid doopts(char *args)\n{\n    char *cmdopts;\n\n    if ((cmdopts = strchr(args, ' ')) != NULL) {\n        cmdopts++;\n        (void) cmdopts;\n    }\n    if (strncasecmp(\"mlst \", args, 5) == 0) {\n        addreply_noformat(200, \" MLST OPTS \"\n                          \"type;size;sizd;modify;UNIX.mode;UNIX.uid;\"\n                          \"UNIX.gid;unique;\");\n        return;\n    }\n    addreply_noformat(504, MSG_UNKNOWN_COMMAND);\n}\n#endif\n\nvoid error(int n, const char *msg)\n{\n    const char *e = strerror(errno);\n\n    logfile(LOG_ERR, \"%s: %s\", msg, e);\n    addreply(n, \"%s: %s\", msg, e);\n}\n\nstatic void fixlimits(void)\n{\n#ifdef HAVE_SETRLIMIT\n    static struct rlimit lim;\n\n    lim.rlim_max = lim.rlim_cur = MAX_CPU_TIME;\n    setrlimit(RLIMIT_CPU, &lim);\n    lim.rlim_max = lim.rlim_cur = MAX_DATA_SIZE;\n    setrlimit(RLIMIT_DATA, &lim);\n# ifndef DEBUG\n    lim.rlim_max = lim.rlim_cur = 0;\n    setrlimit(RLIMIT_CORE, &lim);\n# endif\n#endif\n}\n\n#ifdef COOKIE\nstatic int fortune(void)\n{\n    int fd;\n    char *buf;\n    char *bufpnt;\n    char *bufend;\n    struct stat st;\n    off_t gl;\n    char *fortunepnt;\n    char fortune[2048];\n\n    if (fortunes_file == NULL || *fortunes_file == 0) {\n        return 0;\n    }\n    if ((fd = open(fortunes_file, O_RDONLY)) == -1) {\n        logfile(LOG_ERR, MSG_OPEN_FAILURE, fortunes_file);\n        return -1;\n    }\n    if (fstat(fd, &st) < 0 ||\n        (((S_IRUSR | S_IRGRP | S_IROTH) & st.st_mode) !=\n         (S_IRUSR | S_IRGRP | S_IROTH)) ||\n        !(S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) || st.st_size < 2 ||\n        (buf = mmap(NULL, (size_t) st.st_size,\n                PROT_READ, MAP_FILE | MAP_SHARED, fd,\n                (off_t) 0)) == (void *) MAP_FAILED) {\n        (void) close(fd);\n        logfile(LOG_ERR, MSG_OPEN_FAILURE, fortunes_file);\n        return -1;\n    }\n# ifdef HAVE_RANDOM\n    gl = (off_t) (random() % (st.st_size - 1U));\n# else\n    gl = (off_t) (rand() % (st.st_size - 1U));\n# endif\n    bufpnt = buf + gl;\n    bufend = buf + st.st_size;\n    while (bufpnt != buf) {\n        if (bufpnt[0] == '\\n') {\n            if (&bufpnt[-1] != buf && bufpnt[-1] == '%') {\n                if (&bufpnt[-2] != buf && bufpnt[-2] == '\\n') {\n                    break;\n                }\n            }\n        }\n        bufpnt--;\n    }\n    if (bufpnt != buf) {\n        while (bufpnt != bufend && *bufpnt == '\\n') {\n            bufpnt++;\n        }\n    }\n    fortunepnt = fortune;\n    while (*bufpnt != 0 && bufpnt != bufend &&\n           fortunepnt != &fortune[sizeof fortune - 1U]) {\n        if (bufpnt[0] == '\\n') {\n            if (&bufpnt[1] != bufend && bufpnt[1] == '%') {\n                if (&bufpnt[2] != bufend && bufpnt[2] == '\\n') {\n                    break;\n                }\n            }\n        }\n        *fortunepnt++ = *bufpnt++;\n    }\n    if (fortunepnt == fortune) {\n        goto bye;\n    }\n    do {\n        fortunepnt--;\n    } while (fortunepnt != fortune && (*fortunepnt == '\\n' ||\n                                       isspace((unsigned char) *fortunepnt)));\n    fortunepnt[1] = 0;\n    fortunepnt = fortune;\n    while (*fortunepnt == '\\n') {\n        fortunepnt++;\n    }\n    if (*fortunepnt == 0) {\n        goto bye;\n    }\n    addreply(220, \"%s\", fortunepnt);\n    bye:\n    (void) munmap(buf, st.st_size);\n    (void) close(fd);\n\n    return 1;\n}\n#endif\n\n#if !defined(NO_STANDALONE) && !defined(NO_INETD)\nstatic int check_standalone(void)\n{\n    socklen_t socksize = (socklen_t) sizeof ctrlconn;\n    if (getsockname(0, (struct sockaddr *) &ctrlconn, &socksize) != 0) {\n        clientfd = -1;\n        return 1;\n    }\n    if (dup2(0, 1) == -1) {\n        _EXIT(EXIT_FAILURE);\n    }\n    clientfd = 0;\n\n    return 0;\n}\n#endif\n\nstatic void set_signals_client(void)\n{\n    sigset_t sigs;\n    struct sigaction sa;\n\n    sigfillset(&sigs);\n    sigemptyset(&sa.sa_mask);\n\n    sa.sa_flags = SA_RESTART;\n\n    sa.sa_handler = SIG_IGN;\n    (void) sigaction(SIGPIPE, &sa, NULL);\n    (void) sigaction(SIGURG, &sa, NULL);\n#ifdef SIGIO\n    (void) sigaction(SIGIO, &sa, NULL);\n#endif\n\n    sa.sa_handler = SIG_DFL;\n    sigdelset(&sigs, SIGCHLD);\n    (void) sigaction(SIGCHLD, &sa, NULL);\n#ifdef SIGFPE\n    (void) sigaction(SIGFPE, &sa, NULL);\n    sigdelset(&sigs, SIGFPE);\n#endif\n    sa.sa_flags = 0;\n\n    sa.sa_handler = sigalarm;\n    sigdelset(&sigs, SIGALRM);\n    (void) sigaction(SIGALRM, &sa, NULL);\n\n    sa.sa_handler = sigterm_client;\n    sigdelset(&sigs, SIGTERM);\n    (void) sigaction(SIGTERM, &sa, NULL);\n    sigdelset(&sigs, SIGHUP);\n    (void) sigaction(SIGHUP, &sa, NULL);\n    sigdelset(&sigs, SIGQUIT);\n    (void) sigaction(SIGQUIT, &sa, NULL);\n    sigdelset(&sigs, SIGINT);\n    (void) sigaction(SIGINT, &sa, NULL);\n#ifdef SIGXCPU\n    sigdelset(&sigs, SIGXCPU);\n    (void) sigaction(SIGXCPU, &sa, NULL);\n#endif\n    (void) sigprocmask(SIG_SETMASK, &sigs, NULL);\n}\n\nstatic void set_signals(void)\n{\n#ifndef NO_STANDALONE\n    sigset_t sigs;\n    struct sigaction sa;\n\n    sigfillset(&sigs);\n    sigemptyset(&sa.sa_mask);\n\n    sa.sa_flags = SA_RESTART;\n    sa.sa_handler = sigchild;\n    sigdelset(&sigs, SIGCHLD);\n    (void) sigaction(SIGCHLD, &sa, NULL);\n\n    sa.sa_handler = SIG_IGN;\n    (void) sigaction(SIGPIPE, &sa, NULL);\n    (void) sigaction(SIGALRM, &sa, NULL);\n    (void) sigaction(SIGURG, &sa, NULL);\n#ifdef SIGIO\n    (void) sigaction(SIGIO, &sa, NULL);\n#endif\n\n    sa.sa_flags = 0;\n    sa.sa_handler = sigterm;\n    sigdelset(&sigs, SIGTERM);\n    (void) sigaction(SIGTERM, &sa, NULL);\n    sigdelset(&sigs, SIGHUP);\n    (void) sigaction(SIGHUP, &sa, NULL);\n    sigdelset(&sigs, SIGQUIT);\n    (void) sigaction(SIGQUIT, &sa, NULL);\n    sigdelset(&sigs, SIGINT);\n    (void) sigaction(SIGINT, &sa, NULL);\n# ifdef SIGXCPU\n    sigdelset(&sigs, SIGXCPU);\n    (void) sigaction(SIGXCPU, &sa, NULL);\n# endif\n    (void) sigprocmask(SIG_SETMASK, &sigs, NULL);\n#endif\n}\n\nstatic void dns_sanitize(char *z)\n{\n    while (*z != 0) {\n        if ((*z >= 'a' && *z <= 'z') ||\n            (*z >= '0' && *z <= '9') ||\n            *z == '.' || *z == '-' || *z == ':' ||\n            (*z >= 'A' && *z <= 'Z')) {\n            /* unless */\n        } else {\n            *z = '_';\n        }\n        z++;\n    }\n}\n\nstatic void fill_atomic_prefix(void)\n{\n    char tmp_atomic_prefix[PATH_MAX];\n\n    snprintf(tmp_atomic_prefix, sizeof tmp_atomic_prefix,\n             \"%s%lx.%x.%lx.%x\",\n             ATOMIC_PREFIX_PREFIX,\n             (unsigned long) session_start_time,\n             (unsigned int) serverport,\n             (unsigned long) getpid(),\n             zrand());\n    if ((atomic_prefix = strdup(tmp_atomic_prefix)) == NULL) {\n        die_mem();\n    }\n}\n\nstatic void doit(void)\n{\n    socklen_t socksize;\n    unsigned int users = 0U;\n    int display_banner = 1;\n\n    client_init_reply_buf();\n    session_start_time = time(NULL);\n    fixlimits();\n#ifdef F_SETOWN\n    fcntl(clientfd, F_SETOWN, getpid());\n#endif\n    set_signals_client();\n    alt_arc4random_stir();\n    (void) umask((mode_t) 0);\n    socksize = (socklen_t) sizeof ctrlconn;\n    if (getsockname(clientfd, (struct sockaddr *) &ctrlconn, &socksize) != 0) {\n        die(421, LOG_ERR, MSG_NO_SUPERSERVER);\n    }\n    fourinsix(&ctrlconn);\n    if (checkvalidaddr(&ctrlconn) == 0) {\n        die(425, LOG_ERR, MSG_INVALID_IP);\n    }\n    if (STORAGE_FAMILY(ctrlconn) == AF_INET6) {\n        serverport = ntohs((in_port_t) STORAGE_PORT6_CONST(ctrlconn));\n    } else {\n        serverport = ntohs((in_port_t) STORAGE_PORT_CONST(ctrlconn));\n    }\n    if (trustedip != NULL && addrcmp(&ctrlconn, trustedip) != 0) {\n       anon_only = 1;\n    }\n    socksize = (socklen_t) sizeof peer;\n    if (getpeername(clientfd, (struct sockaddr *) &peer, &socksize)) {\n        die(421, LOG_ERR, MSG_GETPEERNAME \": %s\" , strerror(errno));\n    }\n    fourinsix(&peer);\n    if (checkvalidaddr(&peer) == 0) {\n        die(425, LOG_ERR, MSG_INVALID_IP);\n    }\n#ifndef DONT_LOG_IP\n    for (;;) {\n        int eai;\n\n        if ((eai = getnameinfo\n             ((struct sockaddr *) &peer, STORAGE_LEN(peer), host,\n              sizeof host, NULL, (size_t) 0U,\n              resolve_hostnames != 0 ? 0 : NI_NUMERICHOST)) == 0) {\n            break;\n        }\n        if (resolve_hostnames != 0 &&\n            getnameinfo\n            ((struct sockaddr *) &peer, STORAGE_LEN(peer), host,\n             sizeof host, NULL, (size_t) 0U, NI_NUMERICHOST) == 0) {\n            break;\n        }\n        die(425, LOG_ERR, MSG_INVALID_IP);\n    }\n#endif\n#ifndef DONT_LOG_IP\n    dns_sanitize(host);\n#else\n    *host = '?';\n    host[1] = 0;\n#endif\n    logfile(LOG_INFO, MSG_NEW_CONNECTION, host);\n\n    replycode = 220;\n\n    fill_atomic_prefix();\n\n    if (maxusers > 0U) {\n#ifdef NO_STANDALONE\n        users = daemons(serverport);\n#else\n# ifdef NO_INETD\n        users = nb_children;\n# else\n        if (standalone) {\n            users = nb_children;\n        } else {\n            users = daemons(serverport);\n        }\n# endif\n#endif\n        if (users > maxusers) {\n            addreply(421, MSG_MAX_USERS, (unsigned long) maxusers);\n            doreply();\n            _EXIT(1);\n        }\n    }\n    /* It's time to add a new entry to the ftpwho list */\n#ifdef FTPWHO\n    {\n        ftpwho_initwho();\n        if (shm_data_cur != NULL) {\n            ftpwho_lock();\n            shm_data_cur->pid = getpid();\n            shm_data_cur->state = FTPWHO_STATE_IDLE;\n            shm_data_cur->addr = peer;\n            shm_data_cur->local_addr = ctrlconn;\n            shm_data_cur->date = session_start_time;\n            shm_data_cur->xfer_date = shm_data_cur->date;\n            (shm_data_cur->account)[0] = '?';\n            (shm_data_cur->account)[1] = 0;\n            shm_data_cur->download_total_size = (off_t) 0;\n            shm_data_cur->download_current_size = (off_t) 0;\n            ftpwho_unlock();\n        }\n    }\n#endif\n\n#ifdef WITH_ALTLOG\n    if (altlog_format != ALTLOG_NONE) {\n        if (altlog_format == ALTLOG_W3C) {\n            if ((altlog_fd = open(altlog_filename,\n                                  O_CREAT | O_WRONLY | O_NOFOLLOW | O_EXCL,\n                                  (mode_t) 0600)) != -1) {\n                altlog_write_w3c_header();\n            } else if (errno == EEXIST) {\n                altlog_fd = open(altlog_filename, O_WRONLY | O_NOFOLLOW);\n            }\n        } else {\n            altlog_fd = open(altlog_filename,\n                             O_CREAT | O_WRONLY | O_NOFOLLOW, (mode_t) 0600);\n        }\n        if (altlog_fd == -1) {\n            logfile(LOG_ERR, \"altlog %s: %s\", altlog_filename, strerror(errno));\n        }\n    }\n#endif\n    /* Back to the client - Get the 5 min load average */\n    {\n        double load_[2];\n\n        if (getloadavg(load_, sizeof load_ / sizeof load_[0]) < 0) {\n            load = 0.0;\n        } else {\n            load = load_[1];\n        }\n    }\n#ifndef NON_ROOT_FTP\n    wd[0] = '/';\n    wd[1] = 0;\n    if (chdir(wd)) {\n        _EXIT(EXIT_FAILURE);\n    }\n#endif\n    {\n        int fodder;\n#ifdef IPTOS_LOWDELAY\n        fodder = IPTOS_LOWDELAY;\n        setsockopt(clientfd, SOL_IP, IP_TOS, (char *) &fodder, sizeof fodder);\n#endif\n#ifdef SO_OOBINLINE\n        fodder = 1;\n        setsockopt(clientfd, SOL_SOCKET, SO_OOBINLINE,\n                   (char *) &fodder, sizeof fodder);\n#endif\n#ifdef TCP_NODELAY\n        fodder = 1;\n        setsockopt(clientfd, IPPROTO_TCP, TCP_NODELAY,\n                   (char *) &fodder, sizeof fodder);\n#endif\n        keepalive(clientfd, 0);\n    }\n#ifdef HAVE_SRANDOMDEV\n    srandomdev();\n#elif defined (HAVE_RANDOM)\n    srandom((unsigned int) session_start_time ^ (unsigned int) zrand());\n#else\n    srand((unsigned int) session_start_time ^ (unsigned int) zrand());\n#endif\n#ifdef COOKIE\n    if (fortune() > 0) {\n        display_banner = 0;\n    }\n#endif\n    if (display_banner) {\n#ifdef BORING_MODE\n        addreply_noformat(0, MSG_WELCOME_TO \" Pure-FTPd.\");\n#else\n# ifdef DEBUG\n        addreply_noformat(0, \"--------- \" MSG_WELCOME_TO\n                          \" Pure-FTPd \" PACKAGE_VERSION VERSION_PRIVSEP VERSION_TLS \" ----------\");\n# else\n        addreply_noformat(0, \"--------- \" MSG_WELCOME_TO\n                          \" Pure-FTPd\" VERSION_PRIVSEP VERSION_TLS \" ----------\");\n# endif\n#endif\n        if (users > 0U) {\n            addreply(0, MSG_NB_USERS, users, maxusers);\n        }\n        {\n            struct tm *t;\n\n            if ((t = localtime(&session_start_time)) != NULL) {\n                addreply(220, MSG_WELCOME_TIME,\n                         t->tm_hour, t->tm_min, (unsigned int) serverport);\n            }\n        }\n    }\n    if (anon_only > 0) {\n        addreply_noformat(220, MSG_ANONYMOUS_FTP_ONLY);\n    } else if (anon_only < 0) {\n        addreply_noformat(220, MSG_NO_ANONYMOUS_LOGIN);\n    }\n    if (allowfxp == 2) {\n        addreply_noformat(220, MSG_FXP_SUPPORT);\n    }\n#ifdef RATIOS\n    if (ratio_upload > 0) {\n        if (ratio_for_non_anon != 0) {\n            addreply_noformat(0, MSG_RATIOS_EVERYONE);\n        } else {\n            addreply_noformat(0, MSG_RATIOS_ANONYMOUS);\n        }\n        addreply(0, MSG_RATIOS_RULE, ratio_download, ratio_upload);\n    }\n#endif\n    if (display_banner) {\n        if (v6ready != 0 && STORAGE_FAMILY(peer) != AF_INET6) {\n            addreply(0, MSG_IPV6_OK);\n        }\n        if (idletime >= 120UL) {\n            addreply(220, MSG_INFO_IDLE_M, idletime / 60UL);\n        } else {\n            addreply(220, MSG_INFO_IDLE_S, (unsigned long) idletime);\n        }\n    }\n    candownload = (signed char) ((maxload <= 0.0) || (load < maxload));\n\n    if (force_passive_ip_s != NULL) {\n        struct addrinfo hints, *res;\n\n        memset(&hints, 0, sizeof hints);\n        hints.ai_family = AF_INET;\n        hints.ai_addr = NULL;\n        if (getaddrinfo(force_passive_ip_s, NULL, &hints, &res) != 0 ||\n            res->ai_family != AF_INET ||\n            res->ai_addrlen > sizeof force_passive_ip) {\n            die(421, LOG_ERR, MSG_ILLEGAL_FORCE_PASSIVE);\n        }\n        memcpy(&force_passive_ip, res->ai_addr, res->ai_addrlen);\n        freeaddrinfo(res);\n    }\n\n#ifndef WITHOUT_PRIVSEP\n    if (privsep_init() != 0) {\n        die(421, LOG_ERR, \"privsep_init\");\n    }\n#endif\n\n    parser();\n\n    addreply(0, MSG_LOGOUT);\n    logfile(LOG_INFO, MSG_LOGOUT);\n    doreply();\n#ifdef WITH_BONJOUR\n    refreshManager();\n#endif\n}\n\nstatic void check_ipv6_support(void)     /* check for ipv6 support in kernel */\n{\n#ifndef OLD_IP_STACK\n    int p;\n\n    if ((p = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP)) != -1) {\n        (void) close(p);\n        v6ready++;\n    }\n#endif\n}\n\n#ifndef NO_STANDALONE\nstatic void updatepidfile(void)\n{\n    int fd;\n    char buf[42];\n    size_t buf_len;\n\n    if (SNCHECK(snprintf(buf, sizeof buf, \"%lu\\n\",\n                         (unsigned long) getpid()), sizeof buf)) {\n        return;\n    }\n    if (unlink(pid_file) != 0 && errno != ENOENT) {\n        return;\n    }\n    if ((fd = open(pid_file, O_CREAT | O_WRONLY | O_TRUNC |\n                   O_NOFOLLOW, (mode_t) 0644)) == -1) {\n        return;\n    }\n    buf_len = strlen(buf);\n    if (safe_write(fd, buf, buf_len, -1) != (ssize_t) buf_len) {\n        (void) ftruncate(fd, (off_t) 0);\n    }\n    (void) close(fd);\n}\n\n#ifndef NO_STANDALONE\nstatic int closedesc_all(const int closestdin)\n{\n    int fodder;\n\n    if (closestdin != 0) {\n        (void) close(0);\n        if ((fodder = open(\"/dev/null\", O_RDONLY)) == -1) {\n            return -1;\n        }\n        (void) dup2(fodder, 0);\n        if (fodder > 0) {\n            (void) close(fodder);\n        }\n    }\n    if ((fodder = open(\"/dev/null\", O_WRONLY)) == -1) {\n        return -1;\n    }\n    (void) dup2(fodder, 1);\n    (void) dup2(1, 2);\n    if (fodder > 2) {\n        (void) close(fodder);\n    }\n\n    return 0;\n}\n\nstatic void dodaemonize(void)\n{\n    pid_t child;\n    unsigned int i;\n\n    /* Contributed by Jason Lunz - also based on APUI code, see open_max() */\n    if (daemonize != 0) {\n        if ((child = fork()) == (pid_t) -1) {\n            perror(MSG_STANDALONE_FAILED \" - fork\");\n            logfile(LOG_ERR, MSG_STANDALONE_FAILED \": [fork: %s]\", strerror(errno));\n            return;\n        } else if (child != (pid_t) 0) {\n            _EXIT(EXIT_SUCCESS);       /* parent exits */\n        }\n        if (setsid() == (pid_t) -1) {\n            perror(MSG_STANDALONE_FAILED \" - setsid\");   /* continue anyway */\n        }\n# ifndef NON_ROOT_FTP\n        if (chdir(\"/\") != 0) {\n            perror(\"chdir\");\n            _EXIT(EXIT_FAILURE);\n        }\n# endif\n        i = open_max();\n        do {\n            if (isatty((int) i)) {\n                (void) close((int) i);\n            }\n            i--;\n        } while (i > 2U);\n        if (closedesc_all(1) != 0) {\n            perror(MSG_STANDALONE_FAILED \" - /dev/null duplication\");\n            _EXIT(EXIT_FAILURE);\n        }\n    }\n}\n#endif\n\nstatic void accept_client(const int active_listen_fd) {\n    sigset_t set;\n    struct sockaddr_storage sa;\n    socklen_t dummy;\n    pid_t child;\n\n    memset(&sa, 0, sizeof sa);\n    dummy = (socklen_t) sizeof sa;\n    if ((clientfd = accept\n         (active_listen_fd, (struct sockaddr *) &sa, &dummy)) == -1) {\n        return;\n    }\n    if (STORAGE_FAMILY(sa) != AF_INET && STORAGE_FAMILY(sa) != AF_INET6) {\n        (void) close(clientfd);\n        clientfd = -1;\n        return;\n    }\n    if (maxusers > 0U && nb_children >= maxusers) {\n        char line[1024];\n\n        snprintf(line, sizeof line, \"421 \" MSG_MAX_USERS \"\\r\\n\",\n                 (unsigned long) maxusers);\n        /* No need to check a return value to say 'f*ck' */\n        (void) fcntl(clientfd, F_SETFL, fcntl(clientfd, F_GETFL) | O_NONBLOCK);\n        (void) write(clientfd, line, strlen(line));\n        (void) close(clientfd);\n        clientfd = -1;\n        return;\n    }\n    if (maxip > 0U) {\n        fourinsix(&sa);\n        if (iptrack_get(&sa) >= maxip) {\n            char line[1024];\n            char hbuf[NI_MAXHOST];\n            static struct sockaddr_storage old_sa;\n\n            (void) fcntl(clientfd, F_SETFL, fcntl(clientfd, F_GETFL) | O_NONBLOCK);\n            if (!SNCHECK(snprintf(line, sizeof line,\n                                  \"421 \" MSG_MAX_USERS_IP \"\\r\\n\",\n                                  (unsigned long) maxip), sizeof line)) {\n                (void) write(clientfd, line, strlen(line));\n            }\n            if (addrcmp(&old_sa, &sa) != 0) {\n                old_sa = sa;\n                if (getnameinfo((struct sockaddr *) &sa,\n                                STORAGE_LEN(sa), hbuf,\n                                sizeof hbuf, NULL, (size_t) 0U,\n                                NI_NUMERICHOST) == 0) {\n                    logfile(LOG_WARNING, MSG_MAX_USERS_IP \": [%s]\",\n                            (unsigned long) maxip, hbuf);\n                }\n            }\n            (void) close(clientfd);\n            clientfd = -1;\n            return;\n        }\n    }\n    sigemptyset(&set);\n    sigaddset(&set, SIGCHLD);\n    sigprocmask(SIG_BLOCK, &set, NULL);\n    nb_children++;\n    child = fork();\n    if (child == (pid_t) 0) {\n        if (isatty(2)) {\n            (void) close(2);\n        }\n#ifndef SAVE_DESCRIPTORS\n        if (no_syslog == 0) {\n            closelog();\n            openlog(\"pure-ftpd\", LOG_NDELAY | log_pid, syslog_facility);\n        }\n#endif\n        doit();\n        _EXIT(EXIT_SUCCESS);\n    } else if (child == (pid_t) -1) {\n        if (nb_children > 0U) {\n            nb_children--;\n        }\n    } else {\n        if (maxip > 0U) {\n            iptrack_add(&sa, child);\n        }\n    }\n    (void) close(clientfd);\n    clientfd = -1;\n    sigprocmask(SIG_UNBLOCK, &set, NULL);\n}\n\nstatic void standalone_server(void)\n{\n    int on;\n    struct addrinfo hints, *res, *res6;\n    fd_set rs;\n    int max_fd;\n\n# ifndef NO_INETD\n    standalone = 1;\n# endif\n    memset(&hints, 0, sizeof hints);\n    hints.ai_flags = AI_PASSIVE;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_addr = NULL;\n    on = 1;\n    if (listenfd == -1 && no_ipv4 == 0 &&\n        getaddrinfo(standalone_ip, standalone_port, &hints, &res) == 0) {\n        if ((listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1 ||\n            setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,\n                       (char *) &on, sizeof on) != 0) {\n            int old_errno;\n\n            freeaddrinfo(res);\n            cant_bind:\n            old_errno = errno;\n            perror(MSG_STANDALONE_FAILED);\n            logfile(LOG_ERR, MSG_STANDALONE_FAILED \": [%s]\",\n                    strerror(old_errno));\n            return;\n        }\n# ifdef TCP_FASTOPEN\n        {\n#  ifdef __APPLE__\n            int tfo = 1;\n#  else\n            int tfo = 5;\n#  endif\n            setsockopt(listenfd, IPPROTO_TCP, TCP_FASTOPEN,\n                       (void *) &tfo, sizeof tfo);\n        }\n# endif\n        if (bind(listenfd, res->ai_addr, (socklen_t) res->ai_addrlen) != 0 ||\n            listen(listenfd, maxusers > 0U ?\n                   3U + maxusers / 8U : DEFAULT_BACKLOG) != 0) {\n            freeaddrinfo(res);\n            goto cant_bind;\n        }\n        freeaddrinfo(res);\n        set_cloexec_flag(listenfd);\n    }\n    if (listenfd6 == -1 && v6ready != 0) {\n        hints.ai_family = AF_INET6;\n        if (getaddrinfo(standalone_ip, standalone_port, &hints, &res6) == 0) {\n            if ((listenfd6 = socket(AF_INET6,\n                                    SOCK_STREAM, IPPROTO_TCP)) == -1 ||\n                setsockopt(listenfd6, SOL_SOCKET, SO_REUSEADDR,\n                           (char *) &on, sizeof on) != 0) {\n                freeaddrinfo(res6);\n                goto cant_bind;\n            }\n# if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n            (void) setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n                              (char *) &on, sizeof on);\n# endif\n# ifdef TCP_FASTOPEN\n            {\n                int tfo = maxusers > 0U ? 3U + maxusers / 8U : DEFAULT_BACKLOG;\n                setsockopt(listenfd6, IPPROTO_TCP, TCP_FASTOPEN,\n                           (void *) &tfo, sizeof tfo);\n            }\n# endif\n            if (bind(listenfd6, res6->ai_addr,\n                     (socklen_t) res6->ai_addrlen) != 0 ||\n                listen(listenfd6, maxusers > 0U ?\n                       3U + maxusers / 8U : DEFAULT_BACKLOG) != 0) {\n                freeaddrinfo(res6);\n                goto cant_bind;\n            }\n            freeaddrinfo(res6);\n            set_cloexec_flag(listenfd6);\n        }\n    }\n    if (listenfd == -1 && listenfd6 == -1) {\n# ifdef EADDRNOTAVAIL\n        errno = EADDRNOTAVAIL;\n# endif\n        goto cant_bind;\n    }\n    updatepidfile();\n    setprocessname(\"pure-ftpd (SERVER)\");\n    FD_ZERO(&rs);\n    if (listenfd > listenfd6) {\n        max_fd = listenfd;\n    } else {\n        max_fd = listenfd6;\n    }\n    max_fd++;\n    while (stop_server == 0) {\n        safe_fd_set(listenfd, &rs);\n        safe_fd_set(listenfd6, &rs);\n        if (select(max_fd, &rs, NULL, NULL, NULL) <= 0) {\n            if (errno != EINTR) {\n                (void) sleep(1);\n            }\n            continue;\n        }\n        if (safe_fd_isset(listenfd, &rs)) {\n            accept_client(listenfd);\n        }\n        if (safe_fd_isset(listenfd6, &rs)) {\n            accept_client(listenfd6);\n        }\n    }\n}\n#endif\n\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)\nstatic struct passwd *fakegetpwnam(const char * const name)\n{\n    static struct passwd pwd;\n\n    (void) name;\n    pwd.pw_name = pwd.pw_gecos = pwd.pw_shell = \"ftp\";\n    pwd.pw_passwd = \"*\";\n    pwd.pw_uid = (uid_t) 42U;\n    pwd.pw_gid = (gid_t) 42U;\n    pwd.pw_dir = WIN32_ANON_DIR;\n\n    return &pwd;\n}\n#endif\n\nint pureftpd_start(int argc, char *argv[], const char *home_directory_)\n{\n#ifndef NO_GETOPT_LONG\n    int option_index = 0;\n#endif\n    int fodder;\n    int bypass_ipv6 = 0;\n    struct passwd *pw;\n\n    (void) home_directory_;\n#ifdef NON_ROOT_FTP\n    home_directory = home_directory_;\n#endif\n    client_init_reply_buf();\n\n#ifdef HAVE_GETPAGESIZE\n    page_size = (size_t) getpagesize();\n#elif defined(_SC_PAGESIZE)\n    page_size = (size_t) sysconf(_SC_PAGESIZE);\n#elif defined(_SC_PAGE_SIZE)\n    page_size = (size_t) sysconf(_SC_PAGE_SIZE);\n#else\n    page_size = (size_t) 4096U;\n#endif\n\n#ifdef HAVE_SETLOCALE\n# ifdef LC_MESSAGES\n    (void) setlocale(LC_MESSAGES, MESSAGES_LOCALE);\n# endif\n# ifdef LC_CTYPE\n    (void) setlocale(LC_CTYPE, \"C\");\n# endif\n# ifdef LC_COLLATE\n    (void) setlocale(LC_COLLATE, \"C\");\n# endif\n#endif\n\n    init_tz();\n    (void) strerror(ENOENT);\n\n#ifndef SAVE_DESCRIPTORS\n    openlog(\"pure-ftpd\", LOG_NDELAY | log_pid, DEFAULT_FACILITY);\n#endif\n\n#ifdef USE_CAPABILITIES\n    set_initial_caps();\n#endif\n    set_signals();\n\n    loggedin = 0;\n\n#ifdef BANNER_ENVIRON\n# ifdef COOKIE\n    {\n        const char *a;\n\n        if ((a = getenv(\"BANNER\")) != NULL && *a != 0) {\n            fortunes_file = strdup(a);\n        }\n    }\n# endif\n#endif\n\n#ifndef MINIMAL\n    if (argc == 2 && *argv[1] != '-' &&\n        sc_build_command_line_from_file(argv[1], NULL, simpleconf_options,\n                                        (sizeof simpleconf_options) /\n                                        (sizeof simpleconf_options[0]),\n                                        argv[0], &argc, &argv) != 0) {\n        die(421, LOG_ERR, MSG_CONF_ERR);\n    }\n#endif\n\n    while ((fodder =\n#ifndef NO_GETOPT_LONG\n            getopt_long(argc, argv, GETOPT_OPTIONS, long_options, &option_index)\n#else\n            getopt(argc, argv, GETOPT_OPTIONS)\n#endif\n            ) != -1) {\n        switch (fodder) {\n        case 's': {\n            if ((pw = getpwnam(\"ftp\")) != NULL ||\n                (pw = getpwnam(\"_ftp\")) != NULL) {\n                warez = pw->pw_uid;\n            } else {\n                logfile(LOG_ERR, MSG_NO_FTP_ACCOUNT);\n            }\n            break;\n        }\n        case '0': {\n            no_truncate = 1;\n            break;\n        }\n        case '4': {\n            bypass_ipv6 = 1;\n            break;\n        }\n        case '6': {\n            no_ipv4 = 1;\n            break;\n        }\n        case '1': {\n            log_pid = LOG_PID;\n            break;\n        }\n#ifndef NO_STANDALONE\n        case 'S': {\n            char *struck;\n\n            if ((struck = strchr(optarg, ',')) != NULL) {\n                *struck = 0;\n                if (*optarg != 0) {\n                    if (standalone_ip == NULL &&\n                        (standalone_ip = strdup(optarg)) == NULL) {\n                        die_mem();\n                    }\n                }\n                *struck = ',';\n                if (struck[1] != 0) {\n                    if ((standalone_port = strdup(struck + 1)) == NULL) {\n                        die_mem();\n                    }\n                }\n            } else {\n                if ((standalone_port = strdup(optarg)) == NULL) {\n                    die_mem();\n                }\n            }\n            break;\n        }\n#endif\n        case 'D': {\n            force_ls_a = 1;\n            break;\n        }\n#ifdef THROTTLING\n        case 't':\n        case 'T': {\n            char *struck;\n            const char *tr_bw_ul = NULL;\n            const char *tr_bw_dl = NULL;\n\n            if ((struck = strchr(optarg, ':')) != NULL) {\n                *struck = 0;\n                if (*optarg != 0) {\n                    tr_bw_ul = optarg;\n                }\n                if (struck[1] != 0) {\n                    tr_bw_dl = &struck[1];\n                }\n            } else {\n                tr_bw_ul = tr_bw_dl = optarg;\n            }\n            if ((tr_bw_ul == NULL || *tr_bw_ul == 0) &&\n                (tr_bw_dl == NULL || *tr_bw_dl == 0)) {\n                bad_bw:\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_THROTTLING \": %s\" , optarg);\n            }\n            if (tr_bw_dl != NULL) {\n                if ((throttling_bandwidth_dl =\n                     strtoul(tr_bw_dl, NULL, 0) * 1024UL) == 0UL) {\n                    goto bad_bw;\n                }\n            }\n            if (tr_bw_ul != NULL) {\n                if ((throttling_bandwidth_ul =\n                     strtoul(tr_bw_ul, NULL, 0) * 1024UL) == 0UL) {\n                    goto bad_bw;\n                }\n            }\n            throttling_delay = 1000000 /\n                (throttling_bandwidth_dl | throttling_bandwidth_ul);\n            if (fodder == 't') {\n                throttling = 1;\n            } else {\n                throttling = 2;\n            }\n            break;\n        }\n#endif\n        case 'a': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            chroot_trustedgid = strtoul(nptr, &endptr, 0);\n            if (!nptr || !*nptr || !endptr || *endptr) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_TRUSTED_GID \": %s\" , optarg);\n            }\n            userchroot = 1;\n            break;\n        }\n        case 'x': {\n            dot_write_ok = 0;\n            break;\n        }\n        case 'X': {\n            dot_write_ok = dot_read_ok = 0;\n            break;\n        }\n        case 'z': {\n            dot_read_anon_ok = 1;\n            break;\n        }\n        case 'Z': {\n            be_customer_proof = 1;\n            break;\n        }\n        case 'A': {\n            userchroot = 2;\n            break;\n        }\n        case 'w': {\n            allowfxp = 1;\n            break;\n        }\n        case 'W': {\n            allowfxp = 2;\n            break;\n        }\n        case 'd': {\n            if (logging < 2) {\n                logging++;\n            }\n            break;\n        }\n        case 'b': {\n            broken_client_compat = 1;\n            break;\n        }\n        case 'c': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            maxusers = (unsigned int) strtoul(nptr, &endptr, 0);\n            if (!nptr || !*nptr || !endptr || *endptr || !maxusers) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_USER_LIMIT \": %s\" , optarg);\n            }\n            break;\n        }\n#ifndef NO_STANDALONE\n        case 'B': {\n            daemonize = 1;\n            break;\n        }\n        case 'C': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            maxip = (unsigned int) strtoul(nptr, &endptr, 0);\n            if (!nptr || !*nptr || !endptr || *endptr || !maxip) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_USER_LIMIT \": %s\" , optarg);\n            }\n            break;\n        }\n#endif\n#ifdef PER_USER_LIMITS\n        case 'y': {\n            int ret;\n\n            ret = sscanf(optarg, \"%u:%u\", &per_user_max, &per_anon_max);\n            if (ret != 2) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_USER_LIMIT \": %s\" , optarg);\n            }\n            break;\n        }\n#endif\n#ifdef WITH_TLS\n        case '2': {\n            char *struck;\n            char *key_file_;\n\n            if ((struck = strchr(optarg, ',')) != NULL) {\n                *struck = 0;\n                key_file_ = struck + 1;\n            } else {\n                key_file_ = optarg;\n            }\n            if (*optarg == 0 || *key_file_ == 0) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": TLS\");\n            }\n            if ((cert_file = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            if ((key_file = strdup(key_file_)) == NULL) {\n                die_mem();\n            }\n            break;\n        }\n        case '3':\n            tls_extcert_parse(optarg);\n            use_extcert++;\n            break;\n        case 'Y': {\n            if ((enforce_tls_auth = atoi(optarg)) < 0 || enforce_tls_auth > 3) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": TLS\");\n            }\n            break;\n        }\n        case 'J': {\n            while (*optarg == '-') {\n                if (strncmp(optarg, \"-S:\", sizeof \"-S:\" - (size_t) 1U) == 0) {\n                    optarg += sizeof \"-S:\" - (size_t) 1U;\n                } else if (strncmp(optarg, \"-C:\", sizeof \"-C:\" - (size_t) 1U) == 0) {\n                    optarg += sizeof \"-C:\" - (size_t) 1U;\n                    ssl_verify_client_cert = 1;\n                }\n            }\n            if ((tlsciphersuite = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            break;\n        }\n#endif\n        case 'e': {\n            anon_only = 1;\n            break;\n        }\n        case 'E': {\n            anon_only = -1;\n            break;\n        }\n#ifdef COOKIE\n        case 'F': {\n# ifdef BANNER_ENVIRON\n            free(fortunes_file);\n# endif\n            fortunes_file = strdup(optarg);\n            break;\n        }\n#endif\n        case 'f': {\n            int n = 0;\n\n            if (strcasecmp(optarg, \"none\") == 0) {\n                no_syslog = 1;\n                break;\n            }\n            while (facilitynames[n].c_name &&\n                   strcasecmp(facilitynames[n].c_name, optarg) != 0) {\n                n++;\n            }\n            if (facilitynames[n].c_name) {\n                syslog_facility = facilitynames[n].c_val;\n            } else {\n                logfile(LOG_ERR,\n                        MSG_CONF_ERR \": \" MSG_ILLEGAL_FACILITY \": %s\", optarg);\n            }\n            break;\n        }\n        case 'l': {\n            const Authentication *auth_list_pnt = auth_list;\n            const char *opt = optarg;\n            Authentications *new_auth;\n            size_t auth_name_len;\n\n            for (;;) {\n                auth_name_len = strlen(auth_list_pnt->name);\n                if (strncasecmp(opt, auth_list_pnt->name,\n                                auth_name_len) == 0) {\n                    char *file = NULL;\n\n                    opt += auth_name_len;\n                    if (*opt == ':') {\n                        opt++;\n                        if (*opt != 0) {\n                            if ((file = strdup(opt)) == NULL) {\n                                die_mem();\n                            }\n                        }\n                    }\n                    if (auth_list_pnt->parse != NULL) {\n                        auth_list_pnt->parse(file);\n                    }\n                    if ((new_auth = malloc(sizeof *new_auth)) == NULL) {\n                        die_mem();\n                    }\n                    new_auth->auth = auth_list_pnt;\n                    new_auth->conf_file = file;\n                    new_auth->next = NULL;\n                    if (last_authentications == NULL) {\n                        first_authentications = new_auth;\n                    } else {\n                        last_authentications->next = new_auth;\n                    }\n                    last_authentications = new_auth;\n\n                    break;\n                }\n                auth_list_pnt++;\n                if (auth_list_pnt->name == NULL) {\n                    die(421, LOG_ERR, MSG_AUTH_UNKNOWN \": %s\", opt);\n                }\n            }\n\n            break;\n        }\n        case 'm': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            maxload = strtod(nptr, &endptr);\n            if (!nptr || !*nptr || !endptr || *endptr || maxload <= 0.0) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \"\n                    MSG_ILLEGAL_LOAD_LIMIT \": %s\" , optarg);\n            }\n            break;\n        }\n        case 'M': {\n            allow_anon_mkdir = 1;\n            break;\n        }\n        case 'N': {\n            disallow_passive = 1;\n            break;\n        }\n#if defined(WITH_UPLOAD_SCRIPT)\n        case 'o': {\n            do_upload_script = 1;\n            break;\n        }\n#endif\n#ifdef WITH_ALTLOG\n        case 'O': {\n            char *optarg_copy;\n            char *delpoint;\n\n            if ((optarg_copy = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            if ((delpoint = strchr(optarg_copy, ALTLOG_DELIMITER)) == NULL) {\n                altlog_format = ALTLOG_DEFAULT;\n                delpoint = optarg_copy;\n            } else {\n                const AltLogPrefixes *altlogprefixes_pnt = altlogprefixes;\n\n                *delpoint++ = 0;\n                do {\n                    if (strcasecmp(optarg_copy,\n                                   altlogprefixes_pnt->prefix) == 0) {\n                        altlog_format = altlogprefixes_pnt->format;\n                        break;\n                    }\n                    altlogprefixes_pnt++;\n                } while (altlogprefixes_pnt->prefix != NULL);\n                if (altlog_format == ALTLOG_NONE) {\n                    die(421, LOG_ERR,\n                        MSG_CONF_ERR \": \" MSG_UNKNOWN_ALTLOG \": %s\",\n                        optarg_copy);\n                }\n            }\n            if (*delpoint != '/') {\n                die(421, LOG_ERR,\n                    MSG_CONF_ERR \": \" MSG_SANITY_FILE_FAILURE,\n                    delpoint);\n            }\n            if (altlog_filename == NULL &&\n                (altlog_filename = strdup(delpoint)) == NULL) {\n                die_mem();\n            }\n            (void) free(optarg_copy);\n            break;\n        }\n#endif\n        case 'p': {\n            int ret;\n\n            ret = sscanf(optarg, \"%u:%u\", &firstport, &lastport);\n            if (ret != 2 ||\n                firstport < 1024U || lastport > 65535U\n                || lastport < firstport) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_PORTS_RANGE \": %s\" , optarg);\n            }\n            break;\n        }\n        case 'L': {\n            int ret;\n\n            ret = sscanf(optarg, \"%u:%u\", &max_ls_files, &max_ls_depth);\n            if (ret != 2 ||\n                max_ls_files < 1U || max_ls_depth < 1U) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_LS_LIMITS \": %s\" , optarg);\n            }\n            break;\n        }\n#ifdef QUOTAS\n        case 'n': {\n            int ret;\n\n            ret = sscanf(optarg, \"%llu:%llu\",\n                         &user_quota_files, &user_quota_size);\n            if (ret != 2) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_QUOTA \": %s\" , optarg);\n            }\n            user_quota_size *= (1024ULL * 1024ULL);\n            break;\n        }\n#endif\n        case 'P': {\n            if (force_passive_ip_s == NULL &&\n                (force_passive_ip_s = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            break;\n        }\n#ifdef RATIOS\n        case 'q':\n        case 'Q': {\n            int ret;\n\n            ret = sscanf(optarg, \"%u:%u\", &ratio_upload, &ratio_download);\n            if (ret != 2 ||\n                ratio_upload < 1U || ratio_download < 1U) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_RATIO \": %s\" , optarg);\n            }\n            if (fodder == 'Q') {\n                ratio_for_non_anon = 1;\n            }\n            break;\n        }\n#endif\n        case 'r': {\n            autorename = 1;\n            break;\n        }\n        case 'R': {\n            nochmod = 1;\n            break;\n        }\n        case 'K': {\n            keepallfiles = 1;\n            break;\n        }\n#ifndef NO_STANDALONE\n        case 'g': {\n            if ((pid_file = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            break;\n        }\n#endif\n        case 'G': {\n            disallow_rename = 1;\n            break;\n        }\n        case 'H': {\n            resolve_hostnames = 0;\n            break;\n        }\n        case 'I': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            idletime = strtoul(nptr, &endptr, 0) * 60UL;\n            if (idletime <= 0) {\n                idletime = DEFAULT_IDLE;\n            }\n            break;\n        }\n        case 'i': {\n            anon_noupload = 1;\n            break;\n        }\n        case 'j': {\n            create_home = 1;\n            break;\n        }\n        case 'k': {\n            const char *nptr;\n            char *endptr;\n\n            nptr = optarg;\n            endptr = NULL;\n            maxdiskusagepct = 1.0 - (strtod(nptr, &endptr) / 100.0);\n            if (maxdiskusagepct >= 1.0 || maxdiskusagepct < 0.0) {\n                maxdiskusagepct = 0.0;\n            }\n            break;\n        }\n        case 'u': {\n            const char *nptr;\n            char *endptr;\n            long tmp;\n\n            nptr = optarg;\n            endptr = NULL;\n            tmp = strtol(nptr, &endptr, 10);\n            if (!nptr || !*nptr || !endptr || *endptr || tmp < 0) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_UID_LIMIT \": %s\" , optarg);\n            }\n            useruid = (uid_t) tmp;\n            break;\n        }\n        case 'U': {\n            char *optarg_copy;\n            char *struck;\n            const char *tr_umask = NULL;\n            const char *tr_umask_d = NULL;\n\n            if ((optarg_copy = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            if ((struck = strchr(optarg_copy, ':')) != NULL) {\n                *struck = 0;\n                if (*optarg_copy != 0) {\n                    tr_umask = optarg_copy;\n                }\n                if (struck[1] != 0) {\n                    tr_umask_d = &struck[1];\n                }\n            } else {\n                tr_umask = tr_umask_d = optarg_copy;\n            }\n            if ((tr_umask == NULL || *tr_umask == 0) &&\n                (tr_umask_d == NULL || *tr_umask_d == 0)) {\n                bad_umask:\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_UMASK \": %s\",\n                    optarg_copy);\n            }\n            if (tr_umask != NULL) {\n                if ((u_mask =\n                     strtoul(tr_umask, NULL, 8)) > 0777) {\n                    goto bad_umask;\n                }\n            }\n            if (tr_umask_d != NULL) {\n                if ((u_mask_d =\n                     strtoul(tr_umask_d, NULL, 8)) > 0777) {\n                    goto bad_umask;\n                }\n            }\n            (void) free(optarg_copy);\n            break;\n        }\n#ifdef WITH_VIRTUAL_HOSTS\n        case 'V': {\n            if (trustedip == NULL &&\n                (trustedip = malloc(sizeof *trustedip)) == NULL) {\n                die_mem();\n            }\n            if (generic_aton(optarg, trustedip) != 0) {\n                die(421, LOG_ERR, MSG_CONF_ERR \": \" MSG_ILLEGAL_TRUSTED_IP);\n            }\n            break;\n        }\n#endif\n#ifdef WITH_BONJOUR\n        case 'v': {\n            char *rdvname;\n            char *end;\n\n            if ((rdvname = strdup(optarg)) == NULL) {\n                die_mem();\n            }\n            doregistration(rdvname, strtoul(standalone_port, &end, 10));\n            break;\n        }\n#endif\n        case 'h': {\n#ifndef NON_ROOT_FTP\n            if (geteuid() == (uid_t) 0)\n#endif\n            {\n                puts(PACKAGE \" v\" VERSION VERSION_PRIVSEP \"\\n\");\n            }\n#ifndef NO_GETOPT_LONG\n            {\n                const struct option *options = long_options;\n\n                do {\n                    printf(\"-%c\\t--%s\\t%s\\n\", options->val, options->name,\n                           options->has_arg ? \"<opt>\" : \"\");\n                    options++;\n                } while (options->name != NULL);\n            }\n#endif\n            exit(EXIT_SUCCESS);\n        }\n        default:\n            die(421, LOG_ERR, MSG_ILLEGAL_OPTION);\n        }\n    }\n    if (optind < argc) {\n        die(421, LOG_ERR, MSG_INVALID_ARGUMENT, argv[optind]);\n    }\n    if (first_authentications == NULL) {\n        if ((first_authentications =\n             malloc(sizeof *first_authentications)) == NULL) {\n            die_mem();\n        }\n        first_authentications->auth = DEFAULT_AUTHENTICATION;\n        first_authentications->conf_file = NULL;\n        first_authentications->next = NULL;\n    }\n#ifndef NO_STANDALONE\n    dodaemonize();\n#endif\n#ifndef SAVE_DESCRIPTORS\n    if (no_syslog == 0 && (log_pid || syslog_facility != DEFAULT_FACILITY)) {\n        closelog();\n        openlog(\"pure-ftpd\", LOG_NDELAY | log_pid, syslog_facility);\n    }\n#endif\n    (void) umask((mode_t) 0);\n    clearargs(argc, argv);\n    idletime_noop = (double) idletime * 2.0;\n    if (firstport) {\n        unsigned int portmax;\n\n        portmax = (lastport - firstport + 1) / 2;\n        if (!maxusers || maxusers > portmax) {\n            maxusers = portmax;    /* ... so we don't run out of ports */\n        }\n    }\n    if (bypass_ipv6 == 0) {\n        check_ipv6_support();\n    }\n#if defined(WITH_UPLOAD_SCRIPT)\n    if (do_upload_script != 0) {\n        upload_pipe_open();\n    }\n#endif\n#ifdef WITH_DIRALIASES\n    if (init_aliases() != 0) {\n        logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE);\n    }\n#endif\n#ifdef WITH_TLS\n    if (enforce_tls_auth > 0) {\n        (void) tls_init_library();\n    }\n#endif\n#if !defined(NO_STANDALONE) && !defined(NO_INETD)\n    if (check_standalone() != 0) {\n        standalone_server();\n    } else {\n        doit();\n    }\n#elif !defined(NO_STANDALONE) && defined(NO_INETD)\n    standalone_server();\n#elif defined(NO_STANDALONE) && !defined(NO_INETD)\n    doit();\n#else\n# error Configuration error\n#endif\n\n#ifdef WITH_UPLOAD_SCRIPT\n    upload_pipe_close();\n#endif\n    {\n        Authentications *auth_scan = first_authentications;\n        Authentications *previous;\n\n        while (auth_scan != NULL) {\n            if (auth_scan->auth->exit != NULL) {\n                auth_scan->auth->exit();\n            }\n            free(auth_scan->conf_file);\n            previous = auth_scan;\n            auth_scan = auth_scan->next;\n            free(previous);\n        }\n    }\n    first_authentications = last_authentications = NULL;\n    free(trustedip);\n#ifndef NO_STANDALONE\n    iptrack_free();\n    unlink(pid_file);\n#endif\n    closelog();\n#ifdef WITH_TLS\n    tls_free_library();\n    tls_extcert_exit();\n    free((void *) client_sni_name);\n#endif\n    alt_arc4random_close();\n\n    _EXIT(EXIT_SUCCESS);\n\n    return 0;\n}\n"], "filenames": ["src/ftpd.c"], "buggy_code_start_loc": [4250], "buggy_code_end_loc": [4252], "fixing_code_start_loc": [4250], "fixing_code_end_loc": [4251], "type": "CWE-434", "message": "In Pure-FTPd before 1.0.50, an incorrect max_filesize quota mechanism in the server allows attackers to upload files of unbounded size, which may lead to denial of service or a server hang. This occurs because a certain greater-than-zero test does not anticipate an initial -1 value. (Versions 1.0.23 through 1.0.49 are affected.)", "other": {"cve": {"id": "CVE-2021-40524", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-05T19:15:15.080", "lastModified": "2021-11-26T19:49:28.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Pure-FTPd before 1.0.50, an incorrect max_filesize quota mechanism in the server allows attackers to upload files of unbounded size, which may lead to denial of service or a server hang. This occurs because a certain greater-than-zero test does not anticipate an initial -1 value. (Versions 1.0.23 through 1.0.49 are affected.)"}, {"lang": "es", "value": "En Pure-FTPd antes de la versi\u00f3n 1.0.50, un mecanismo incorrecto de cuota max_filesize en el servidor permite a los atacantes subir archivos de tama\u00f1o no limitado, lo que puede llevar a la denegaci\u00f3n de servicio o a la ca\u00edda del servidor. Esto ocurre porque una determinada prueba mayor que cero no anticipa un valor inicial de -1. (Est\u00e1n afectadas las versiones 1.0.23 a 1.0.49)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.23", "versionEndExcluding": "1.0.50", "matchCriteriaId": "1BB7E569-40DC-47B8-AD6A-4F3EF8C0D092"}]}]}], "references": [{"url": "https://github.com/jedisct1/pure-ftpd/commit/37ad222868e52271905b94afea4fc780d83294b4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jedisct1/pure-ftpd/compare/1.0.49...1.0.50", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jedisct1/pure-ftpd/pull/158", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jedisct1/pure-ftpd/commit/37ad222868e52271905b94afea4fc780d83294b4"}}