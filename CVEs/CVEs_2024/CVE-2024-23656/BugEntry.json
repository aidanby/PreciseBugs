{"buggy_code": ["package main\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/bcrypt\"\n\n\t\"github.com/dexidp/dex/pkg/featureflags\"\n\t\"github.com/dexidp/dex/pkg/log\"\n\t\"github.com/dexidp/dex/server\"\n\t\"github.com/dexidp/dex/storage\"\n\t\"github.com/dexidp/dex/storage/ent\"\n\t\"github.com/dexidp/dex/storage/etcd\"\n\t\"github.com/dexidp/dex/storage/kubernetes\"\n\t\"github.com/dexidp/dex/storage/memory\"\n\t\"github.com/dexidp/dex/storage/sql\"\n)\n\n// Config is the config format for the main application.\ntype Config struct {\n\tIssuer    string    `json:\"issuer\"`\n\tStorage   Storage   `json:\"storage\"`\n\tWeb       Web       `json:\"web\"`\n\tTelemetry Telemetry `json:\"telemetry\"`\n\tOAuth2    OAuth2    `json:\"oauth2\"`\n\tGRPC      GRPC      `json:\"grpc\"`\n\tExpiry    Expiry    `json:\"expiry\"`\n\tLogger    Logger    `json:\"logger\"`\n\n\tFrontend server.WebConfig `json:\"frontend\"`\n\n\t// StaticConnectors are user defined connectors specified in the ConfigMap\n\t// Write operations, like updating a connector, will fail.\n\tStaticConnectors []Connector `json:\"connectors\"`\n\n\t// StaticClients cause the server to use this list of clients rather than\n\t// querying the storage. Write operations, like creating a client, will fail.\n\tStaticClients []storage.Client `json:\"staticClients\"`\n\n\t// If enabled, the server will maintain a list of passwords which can be used\n\t// to identify a user.\n\tEnablePasswordDB bool `json:\"enablePasswordDB\"`\n\n\t// StaticPasswords cause the server use this list of passwords rather than\n\t// querying the storage. Cannot be specified without enabling a passwords\n\t// database.\n\tStaticPasswords []password `json:\"staticPasswords\"`\n}\n\n// Validate the configuration\nfunc (c Config) Validate() error {\n\t// Fast checks. Perform these first for a more responsive CLI.\n\tchecks := []struct {\n\t\tbad    bool\n\t\terrMsg string\n\t}{\n\t\t{c.Issuer == \"\", \"no issuer specified in config file\"},\n\t\t{!c.EnablePasswordDB && len(c.StaticPasswords) != 0, \"cannot specify static passwords without enabling password db\"},\n\t\t{c.Storage.Config == nil, \"no storage supplied in config file\"},\n\t\t{c.Web.HTTP == \"\" && c.Web.HTTPS == \"\", \"must supply a HTTP/HTTPS  address to listen on\"},\n\t\t{c.Web.HTTPS != \"\" && c.Web.TLSCert == \"\", \"no cert specified for HTTPS\"},\n\t\t{c.Web.HTTPS != \"\" && c.Web.TLSKey == \"\", \"no private key specified for HTTPS\"},\n\t\t{c.GRPC.TLSCert != \"\" && c.GRPC.Addr == \"\", \"no address specified for gRPC\"},\n\t\t{c.GRPC.TLSKey != \"\" && c.GRPC.Addr == \"\", \"no address specified for gRPC\"},\n\t\t{(c.GRPC.TLSCert == \"\") != (c.GRPC.TLSKey == \"\"), \"must specific both a gRPC TLS cert and key\"},\n\t\t{c.GRPC.TLSCert == \"\" && c.GRPC.TLSClientCA != \"\", \"cannot specify gRPC TLS client CA without a gRPC TLS cert\"},\n\t}\n\n\tvar checkErrors []string\n\n\tfor _, check := range checks {\n\t\tif check.bad {\n\t\t\tcheckErrors = append(checkErrors, check.errMsg)\n\t\t}\n\t}\n\tif len(checkErrors) != 0 {\n\t\treturn fmt.Errorf(\"invalid Config:\\n\\t-\\t%s\", strings.Join(checkErrors, \"\\n\\t-\\t\"))\n\t}\n\treturn nil\n}\n\ntype password storage.Password\n\nfunc (p *password) UnmarshalJSON(b []byte) error {\n\tvar data struct {\n\t\tEmail       string `json:\"email\"`\n\t\tUsername    string `json:\"username\"`\n\t\tUserID      string `json:\"userID\"`\n\t\tHash        string `json:\"hash\"`\n\t\tHashFromEnv string `json:\"hashFromEnv\"`\n\t}\n\tif err := json.Unmarshal(b, &data); err != nil {\n\t\treturn err\n\t}\n\t*p = password(storage.Password{\n\t\tEmail:    data.Email,\n\t\tUsername: data.Username,\n\t\tUserID:   data.UserID,\n\t})\n\tif len(data.Hash) == 0 && len(data.HashFromEnv) > 0 {\n\t\tdata.Hash = os.Getenv(data.HashFromEnv)\n\t}\n\tif len(data.Hash) == 0 {\n\t\treturn fmt.Errorf(\"no password hash provided\")\n\t}\n\n\t// If this value is a valid bcrypt, use it.\n\t_, bcryptErr := bcrypt.Cost([]byte(data.Hash))\n\tif bcryptErr == nil {\n\t\tp.Hash = []byte(data.Hash)\n\t\treturn nil\n\t}\n\n\t// For backwards compatibility try to base64 decode this value.\n\thashBytes, err := base64.StdEncoding.DecodeString(data.Hash)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"malformed bcrypt hash: %v\", bcryptErr)\n\t}\n\tif _, err := bcrypt.Cost(hashBytes); err != nil {\n\t\treturn fmt.Errorf(\"malformed bcrypt hash: %v\", err)\n\t}\n\tp.Hash = hashBytes\n\treturn nil\n}\n\n// OAuth2 describes enabled OAuth2 extensions.\ntype OAuth2 struct {\n\t// list of allowed grant types,\n\t// defaults to all supported types\n\tGrantTypes []string `json:\"grantTypes\"`\n\n\tResponseTypes []string `json:\"responseTypes\"`\n\t// If specified, do not prompt the user to approve client authorization. The\n\t// act of logging in implies authorization.\n\tSkipApprovalScreen bool `json:\"skipApprovalScreen\"`\n\t// If specified, show the connector selection screen even if there's only one\n\tAlwaysShowLoginScreen bool `json:\"alwaysShowLoginScreen\"`\n\t// This is the connector that can be used for password grant\n\tPasswordConnector string `json:\"passwordConnector\"`\n}\n\n// Web is the config format for the HTTP server.\ntype Web struct {\n\tHTTP           string   `json:\"http\"`\n\tHTTPS          string   `json:\"https\"`\n\tTLSCert        string   `json:\"tlsCert\"`\n\tTLSKey         string   `json:\"tlsKey\"`\n\tAllowedOrigins []string `json:\"allowedOrigins\"`\n\tAllowedHeaders []string `json:\"allowedHeaders\"`\n}\n\n// Telemetry is the config format for telemetry including the HTTP server config.\ntype Telemetry struct {\n\tHTTP string `json:\"http\"`\n\t// EnableProfiling makes profiling endpoints available via web interface host:port/debug/pprof/\n\tEnableProfiling bool `json:\"enableProfiling\"`\n}\n\n// GRPC is the config for the gRPC API.\ntype GRPC struct {\n\t// The port to listen on.\n\tAddr        string `json:\"addr\"`\n\tTLSCert     string `json:\"tlsCert\"`\n\tTLSKey      string `json:\"tlsKey\"`\n\tTLSClientCA string `json:\"tlsClientCA\"`\n\tReflection  bool   `json:\"reflection\"`\n}\n\n// Storage holds app's storage configuration.\ntype Storage struct {\n\tType   string        `json:\"type\"`\n\tConfig StorageConfig `json:\"config\"`\n}\n\n// StorageConfig is a configuration that can create a storage.\ntype StorageConfig interface {\n\tOpen(logger log.Logger) (storage.Storage, error)\n}\n\nvar (\n\t_ StorageConfig = (*etcd.Etcd)(nil)\n\t_ StorageConfig = (*kubernetes.Config)(nil)\n\t_ StorageConfig = (*memory.Config)(nil)\n\t_ StorageConfig = (*sql.SQLite3)(nil)\n\t_ StorageConfig = (*sql.Postgres)(nil)\n\t_ StorageConfig = (*sql.MySQL)(nil)\n\t_ StorageConfig = (*ent.SQLite3)(nil)\n\t_ StorageConfig = (*ent.Postgres)(nil)\n\t_ StorageConfig = (*ent.MySQL)(nil)\n)\n\nfunc getORMBasedSQLStorage(normal, entBased StorageConfig) func() StorageConfig {\n\treturn func() StorageConfig {\n\t\tif featureflags.EntEnabled.Enabled() {\n\t\t\treturn entBased\n\t\t}\n\t\treturn normal\n\t}\n}\n\nvar storages = map[string]func() StorageConfig{\n\t\"etcd\":       func() StorageConfig { return new(etcd.Etcd) },\n\t\"kubernetes\": func() StorageConfig { return new(kubernetes.Config) },\n\t\"memory\":     func() StorageConfig { return new(memory.Config) },\n\t\"sqlite3\":    getORMBasedSQLStorage(&sql.SQLite3{}, &ent.SQLite3{}),\n\t\"postgres\":   getORMBasedSQLStorage(&sql.Postgres{}, &ent.Postgres{}),\n\t\"mysql\":      getORMBasedSQLStorage(&sql.MySQL{}, &ent.MySQL{}),\n}\n\n// UnmarshalJSON allows Storage to implement the unmarshaler interface to\n// dynamically determine the type of the storage config.\nfunc (s *Storage) UnmarshalJSON(b []byte) error {\n\tvar store struct {\n\t\tType   string          `json:\"type\"`\n\t\tConfig json.RawMessage `json:\"config\"`\n\t}\n\tif err := json.Unmarshal(b, &store); err != nil {\n\t\treturn fmt.Errorf(\"parse storage: %v\", err)\n\t}\n\tf, ok := storages[store.Type]\n\tif !ok {\n\t\treturn fmt.Errorf(\"unknown storage type %q\", store.Type)\n\t}\n\n\tstorageConfig := f()\n\tif len(store.Config) != 0 {\n\t\tdata := []byte(store.Config)\n\t\tif featureflags.ExpandEnv.Enabled() {\n\t\t\t// Caution, we're expanding in the raw JSON/YAML source. This may not be what the admin expects.\n\t\t\tdata = []byte(os.ExpandEnv(string(store.Config)))\n\t\t}\n\t\tif err := json.Unmarshal(data, storageConfig); err != nil {\n\t\t\treturn fmt.Errorf(\"parse storage config: %v\", err)\n\t\t}\n\t}\n\t*s = Storage{\n\t\tType:   store.Type,\n\t\tConfig: storageConfig,\n\t}\n\treturn nil\n}\n\n// Connector is a magical type that can unmarshal YAML dynamically. The\n// Type field determines the connector type, which is then customized for Config.\ntype Connector struct {\n\tType string `json:\"type\"`\n\tName string `json:\"name\"`\n\tID   string `json:\"id\"`\n\n\tConfig server.ConnectorConfig `json:\"config\"`\n}\n\n// UnmarshalJSON allows Connector to implement the unmarshaler interface to\n// dynamically determine the type of the connector config.\nfunc (c *Connector) UnmarshalJSON(b []byte) error {\n\tvar conn struct {\n\t\tType string `json:\"type\"`\n\t\tName string `json:\"name\"`\n\t\tID   string `json:\"id\"`\n\n\t\tConfig json.RawMessage `json:\"config\"`\n\t}\n\tif err := json.Unmarshal(b, &conn); err != nil {\n\t\treturn fmt.Errorf(\"parse connector: %v\", err)\n\t}\n\tf, ok := server.ConnectorsConfig[conn.Type]\n\tif !ok {\n\t\treturn fmt.Errorf(\"unknown connector type %q\", conn.Type)\n\t}\n\n\tconnConfig := f()\n\tif len(conn.Config) != 0 {\n\t\tdata := []byte(conn.Config)\n\t\tif featureflags.ExpandEnv.Enabled() {\n\t\t\t// Caution, we're expanding in the raw JSON/YAML source. This may not be what the admin expects.\n\t\t\tdata = []byte(os.ExpandEnv(string(conn.Config)))\n\t\t}\n\t\tif err := json.Unmarshal(data, connConfig); err != nil {\n\t\t\treturn fmt.Errorf(\"parse connector config: %v\", err)\n\t\t}\n\t}\n\t*c = Connector{\n\t\tType:   conn.Type,\n\t\tName:   conn.Name,\n\t\tID:     conn.ID,\n\t\tConfig: connConfig,\n\t}\n\treturn nil\n}\n\n// ToStorageConnector converts an object to storage connector type.\nfunc ToStorageConnector(c Connector) (storage.Connector, error) {\n\tdata, err := json.Marshal(c.Config)\n\tif err != nil {\n\t\treturn storage.Connector{}, fmt.Errorf(\"failed to marshal connector config: %v\", err)\n\t}\n\n\treturn storage.Connector{\n\t\tID:     c.ID,\n\t\tType:   c.Type,\n\t\tName:   c.Name,\n\t\tConfig: data,\n\t}, nil\n}\n\n// Expiry holds configuration for the validity period of components.\ntype Expiry struct {\n\t// SigningKeys defines the duration of time after which the SigningKeys will be rotated.\n\tSigningKeys string `json:\"signingKeys\"`\n\n\t// IdTokens defines the duration of time for which the IdTokens will be valid.\n\tIDTokens string `json:\"idTokens\"`\n\n\t// AuthRequests defines the duration of time for which the AuthRequests will be valid.\n\tAuthRequests string `json:\"authRequests\"`\n\n\t// DeviceRequests defines the duration of time for which the DeviceRequests will be valid.\n\tDeviceRequests string `json:\"deviceRequests\"`\n\n\t// RefreshTokens defines refresh tokens expiry policy\n\tRefreshTokens RefreshToken `json:\"refreshTokens\"`\n}\n\n// Logger holds configuration required to customize logging for dex.\ntype Logger struct {\n\t// Level sets logging level severity.\n\tLevel string `json:\"level\"`\n\n\t// Format specifies the format to be used for logging.\n\tFormat string `json:\"format\"`\n}\n\ntype RefreshToken struct {\n\tDisableRotation   bool   `json:\"disableRotation\"`\n\tReuseInterval     string `json:\"reuseInterval\"`\n\tAbsoluteLifetime  string `json:\"absoluteLifetime\"`\n\tValidIfNotUsedFor string `json:\"validIfNotUsedFor\"`\n}\n", "package main\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/ghodss/yaml\"\n\t\"github.com/kylelemons/godebug/pretty\"\n\n\t\"github.com/dexidp/dex/connector/mock\"\n\t\"github.com/dexidp/dex/connector/oidc\"\n\t\"github.com/dexidp/dex/server\"\n\t\"github.com/dexidp/dex/storage\"\n\t\"github.com/dexidp/dex/storage/sql\"\n)\n\nvar _ = yaml.YAMLToJSON\n\nfunc TestValidConfiguration(t *testing.T) {\n\tconfiguration := Config{\n\t\tIssuer: \"http://127.0.0.1:5556/dex\",\n\t\tStorage: Storage{\n\t\t\tType: \"sqlite3\",\n\t\t\tConfig: &sql.SQLite3{\n\t\t\t\tFile: \"examples/dex.db\",\n\t\t\t},\n\t\t},\n\t\tWeb: Web{\n\t\t\tHTTP: \"127.0.0.1:5556\",\n\t\t},\n\t\tStaticConnectors: []Connector{\n\t\t\t{\n\t\t\t\tType:   \"mockCallback\",\n\t\t\t\tID:     \"mock\",\n\t\t\t\tName:   \"Example\",\n\t\t\t\tConfig: &mock.CallbackConfig{},\n\t\t\t},\n\t\t},\n\t}\n\tif err := configuration.Validate(); err != nil {\n\t\tt.Fatalf(\"this configuration should have been valid: %v\", err)\n\t}\n}\n\nfunc TestInvalidConfiguration(t *testing.T) {\n\tconfiguration := Config{}\n\terr := configuration.Validate()\n\tif err == nil {\n\t\tt.Fatal(\"this configuration should be invalid\")\n\t}\n\tgot := err.Error()\n\twanted := `invalid Config:\n\t-\tno issuer specified in config file\n\t-\tno storage supplied in config file\n\t-\tmust supply a HTTP/HTTPS  address to listen on`\n\tif got != wanted {\n\t\tt.Fatalf(\"Expected error message to be %q, got %q\", wanted, got)\n\t}\n}\n\nfunc TestUnmarshalConfig(t *testing.T) {\n\trawConfig := []byte(`\nissuer: http://127.0.0.1:5556/dex\nstorage:\n  type: postgres\n  config:\n    host: 10.0.0.1\n    port: 65432\n    maxOpenConns: 5\n    maxIdleConns: 3\n    connMaxLifetime: 30\n    connectionTimeout: 3\nweb:\n  http: 127.0.0.1:5556\n\nfrontend:\n  dir: ./web\n  extra:\n    foo: bar\n\nstaticClients:\n- id: example-app\n  redirectURIs:\n  - 'http://127.0.0.1:5555/callback'\n  name: 'Example App'\n  secret: ZXhhbXBsZS1hcHAtc2VjcmV0\n\noauth2:\n  alwaysShowLoginScreen: true\n  grantTypes:\n  - refresh_token\n  - \"urn:ietf:params:oauth:grant-type:token-exchange\"\n\nconnectors:\n- type: mockCallback\n  id: mock\n  name: Example\n- type: oidc\n  id: google\n  name: Google\n  config:\n    issuer: https://accounts.google.com\n    clientID: foo\n    clientSecret: bar\n    redirectURI: http://127.0.0.1:5556/dex/callback/google\n\nenablePasswordDB: true\nstaticPasswords:\n- email: \"admin@example.com\"\n  # bcrypt hash of the string \"password\"\n  hash: \"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"\n  username: \"admin\"\n  userID: \"08a8684b-db88-4b73-90a9-3cd1661f5466\"\n- email: \"foo@example.com\"\n  # base64'd value of the same bcrypt hash above. We want to be able to parse both of these\n  hash: \"JDJhJDEwJDMzRU1UMGNWWVZsUHk2V0FNQ0xzY2VMWWpXaHVIcGJ6NXl1Wnh1L0dBRmowM0o5THl0anV5\"\n  username: \"foo\"\n  userID: \"41331323-6f44-45e6-b3b9-2c4b60c02be5\"\n\nexpiry:\n  signingKeys: \"7h\"\n  idTokens: \"25h\"\n  authRequests: \"25h\"\n  deviceRequests: \"10m\"\n\nlogger:\n  level: \"debug\"\n  format: \"json\"\n`)\n\n\twant := Config{\n\t\tIssuer: \"http://127.0.0.1:5556/dex\",\n\t\tStorage: Storage{\n\t\t\tType: \"postgres\",\n\t\t\tConfig: &sql.Postgres{\n\t\t\t\tNetworkDB: sql.NetworkDB{\n\t\t\t\t\tHost:              \"10.0.0.1\",\n\t\t\t\t\tPort:              65432,\n\t\t\t\t\tMaxOpenConns:      5,\n\t\t\t\t\tMaxIdleConns:      3,\n\t\t\t\t\tConnMaxLifetime:   30,\n\t\t\t\t\tConnectionTimeout: 3,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tWeb: Web{\n\t\t\tHTTP: \"127.0.0.1:5556\",\n\t\t},\n\t\tFrontend: server.WebConfig{\n\t\t\tDir: \"./web\",\n\t\t\tExtra: map[string]string{\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t\tStaticClients: []storage.Client{\n\t\t\t{\n\t\t\t\tID:     \"example-app\",\n\t\t\t\tSecret: \"ZXhhbXBsZS1hcHAtc2VjcmV0\",\n\t\t\t\tName:   \"Example App\",\n\t\t\t\tRedirectURIs: []string{\n\t\t\t\t\t\"http://127.0.0.1:5555/callback\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tOAuth2: OAuth2{\n\t\t\tAlwaysShowLoginScreen: true,\n\t\t\tGrantTypes: []string{\n\t\t\t\t\"refresh_token\",\n\t\t\t\t\"urn:ietf:params:oauth:grant-type:token-exchange\",\n\t\t\t},\n\t\t},\n\t\tStaticConnectors: []Connector{\n\t\t\t{\n\t\t\t\tType:   \"mockCallback\",\n\t\t\t\tID:     \"mock\",\n\t\t\t\tName:   \"Example\",\n\t\t\t\tConfig: &mock.CallbackConfig{},\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"oidc\",\n\t\t\t\tID:   \"google\",\n\t\t\t\tName: \"Google\",\n\t\t\t\tConfig: &oidc.Config{\n\t\t\t\t\tIssuer:       \"https://accounts.google.com\",\n\t\t\t\t\tClientID:     \"foo\",\n\t\t\t\t\tClientSecret: \"bar\",\n\t\t\t\t\tRedirectURI:  \"http://127.0.0.1:5556/dex/callback/google\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tEnablePasswordDB: true,\n\t\tStaticPasswords: []password{\n\t\t\t{\n\t\t\t\tEmail:    \"admin@example.com\",\n\t\t\t\tHash:     []byte(\"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"),\n\t\t\t\tUsername: \"admin\",\n\t\t\t\tUserID:   \"08a8684b-db88-4b73-90a9-3cd1661f5466\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tEmail:    \"foo@example.com\",\n\t\t\t\tHash:     []byte(\"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"),\n\t\t\t\tUsername: \"foo\",\n\t\t\t\tUserID:   \"41331323-6f44-45e6-b3b9-2c4b60c02be5\",\n\t\t\t},\n\t\t},\n\t\tExpiry: Expiry{\n\t\t\tSigningKeys:    \"7h\",\n\t\t\tIDTokens:       \"25h\",\n\t\t\tAuthRequests:   \"25h\",\n\t\t\tDeviceRequests: \"10m\",\n\t\t},\n\t\tLogger: Logger{\n\t\t\tLevel:  \"debug\",\n\t\t\tFormat: \"json\",\n\t\t},\n\t}\n\n\tvar c Config\n\tif err := yaml.Unmarshal(rawConfig, &c); err != nil {\n\t\tt.Fatalf(\"failed to decode config: %v\", err)\n\t}\n\tif diff := pretty.Compare(c, want); diff != \"\" {\n\t\tt.Errorf(\"got!=want: %s\", diff)\n\t}\n}\n\nfunc TestUnmarshalConfigWithEnvNoExpand(t *testing.T) {\n\t// If the env variable DEX_EXPAND_ENV is set and has a \"falsy\" value, os.ExpandEnv is disabled.\n\t// ParseBool: \"It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\"\n\tcheckUnmarshalConfigWithEnv(t, \"0\", false)\n\tcheckUnmarshalConfigWithEnv(t, \"f\", false)\n\tcheckUnmarshalConfigWithEnv(t, \"F\", false)\n\tcheckUnmarshalConfigWithEnv(t, \"FALSE\", false)\n\tcheckUnmarshalConfigWithEnv(t, \"false\", false)\n\tcheckUnmarshalConfigWithEnv(t, \"False\", false)\n\tos.Unsetenv(\"DEX_EXPAND_ENV\")\n}\n\nfunc TestUnmarshalConfigWithEnvExpand(t *testing.T) {\n\t// If the env variable DEX_EXPAND_ENV is unset or has a \"truthy\" or unknown value, os.ExpandEnv is enabled.\n\t// ParseBool: \"It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\"\n\tcheckUnmarshalConfigWithEnv(t, \"1\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"t\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"T\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"TRUE\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"true\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"True\", true)\n\t// Values that can't be parsed as bool:\n\tcheckUnmarshalConfigWithEnv(t, \"UNSET\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"whatever - true is default\", true)\n\tos.Unsetenv(\"DEX_EXPAND_ENV\")\n}\n\nfunc checkUnmarshalConfigWithEnv(t *testing.T, dexExpandEnv string, wantExpandEnv bool) {\n\t// For hashFromEnv:\n\tos.Setenv(\"DEX_FOO_USER_PASSWORD\", \"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\")\n\t// For os.ExpandEnv ($VAR -> value_of_VAR):\n\tos.Setenv(\"DEX_FOO_POSTGRES_HOST\", \"10.0.0.1\")\n\tos.Setenv(\"DEX_FOO_OIDC_CLIENT_SECRET\", \"bar\")\n\tif dexExpandEnv != \"UNSET\" {\n\t\tos.Setenv(\"DEX_EXPAND_ENV\", dexExpandEnv)\n\t} else {\n\t\tos.Unsetenv(\"DEX_EXPAND_ENV\")\n\t}\n\n\trawConfig := []byte(`\nissuer: http://127.0.0.1:5556/dex\nstorage:\n  type: postgres\n  config:\n    # Env variables are expanded in raw YAML source.\n    # Single quotes work fine, as long as the env variable doesn't contain any.\n    host: '$DEX_FOO_POSTGRES_HOST'\n    port: 65432\n    maxOpenConns: 5\n    maxIdleConns: 3\n    connMaxLifetime: 30\n    connectionTimeout: 3\nweb:\n  http: 127.0.0.1:5556\n\nfrontend:\n  dir: ./web\n  extra:\n    foo: bar\n\nstaticClients:\n- id: example-app\n  redirectURIs:\n  - 'http://127.0.0.1:5555/callback'\n  name: 'Example App'\n  secret: ZXhhbXBsZS1hcHAtc2VjcmV0\n\noauth2:\n  alwaysShowLoginScreen: true\n\nconnectors:\n- type: mockCallback\n  id: mock\n  name: Example\n- type: oidc\n  id: google\n  name: Google\n  config:\n    issuer: https://accounts.google.com\n    clientID: foo\n    # Env variables are expanded in raw YAML source.\n    # Single quotes work fine, as long as the env variable doesn't contain any.\n    clientSecret: '$DEX_FOO_OIDC_CLIENT_SECRET'\n    redirectURI: http://127.0.0.1:5556/dex/callback/google\n\nenablePasswordDB: true\nstaticPasswords:\n- email: \"admin@example.com\"\n  # bcrypt hash of the string \"password\"\n  hash: \"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"\n  username: \"admin\"\n  userID: \"08a8684b-db88-4b73-90a9-3cd1661f5466\"\n- email: \"foo@example.com\"\n  hashFromEnv: \"DEX_FOO_USER_PASSWORD\"\n  username: \"foo\"\n  userID: \"41331323-6f44-45e6-b3b9-2c4b60c02be5\"\n\nexpiry:\n  signingKeys: \"7h\"\n  idTokens: \"25h\"\n  authRequests: \"25h\"\n\nlogger:\n  level: \"debug\"\n  format: \"json\"\n`)\n\n\t// This is not a valid hostname. It's only used to check whether os.ExpandEnv was applied or not.\n\twantPostgresHost := \"$DEX_FOO_POSTGRES_HOST\"\n\twantOidcClientSecret := \"$DEX_FOO_OIDC_CLIENT_SECRET\"\n\tif wantExpandEnv {\n\t\twantPostgresHost = \"10.0.0.1\"\n\t\twantOidcClientSecret = \"bar\"\n\t}\n\n\twant := Config{\n\t\tIssuer: \"http://127.0.0.1:5556/dex\",\n\t\tStorage: Storage{\n\t\t\tType: \"postgres\",\n\t\t\tConfig: &sql.Postgres{\n\t\t\t\tNetworkDB: sql.NetworkDB{\n\t\t\t\t\tHost:              wantPostgresHost,\n\t\t\t\t\tPort:              65432,\n\t\t\t\t\tMaxOpenConns:      5,\n\t\t\t\t\tMaxIdleConns:      3,\n\t\t\t\t\tConnMaxLifetime:   30,\n\t\t\t\t\tConnectionTimeout: 3,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tWeb: Web{\n\t\t\tHTTP: \"127.0.0.1:5556\",\n\t\t},\n\t\tFrontend: server.WebConfig{\n\t\t\tDir: \"./web\",\n\t\t\tExtra: map[string]string{\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t\tStaticClients: []storage.Client{\n\t\t\t{\n\t\t\t\tID:     \"example-app\",\n\t\t\t\tSecret: \"ZXhhbXBsZS1hcHAtc2VjcmV0\",\n\t\t\t\tName:   \"Example App\",\n\t\t\t\tRedirectURIs: []string{\n\t\t\t\t\t\"http://127.0.0.1:5555/callback\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tOAuth2: OAuth2{\n\t\t\tAlwaysShowLoginScreen: true,\n\t\t},\n\t\tStaticConnectors: []Connector{\n\t\t\t{\n\t\t\t\tType:   \"mockCallback\",\n\t\t\t\tID:     \"mock\",\n\t\t\t\tName:   \"Example\",\n\t\t\t\tConfig: &mock.CallbackConfig{},\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"oidc\",\n\t\t\t\tID:   \"google\",\n\t\t\t\tName: \"Google\",\n\t\t\t\tConfig: &oidc.Config{\n\t\t\t\t\tIssuer:       \"https://accounts.google.com\",\n\t\t\t\t\tClientID:     \"foo\",\n\t\t\t\t\tClientSecret: wantOidcClientSecret,\n\t\t\t\t\tRedirectURI:  \"http://127.0.0.1:5556/dex/callback/google\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tEnablePasswordDB: true,\n\t\tStaticPasswords: []password{\n\t\t\t{\n\t\t\t\tEmail:    \"admin@example.com\",\n\t\t\t\tHash:     []byte(\"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"),\n\t\t\t\tUsername: \"admin\",\n\t\t\t\tUserID:   \"08a8684b-db88-4b73-90a9-3cd1661f5466\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tEmail:    \"foo@example.com\",\n\t\t\t\tHash:     []byte(\"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"),\n\t\t\t\tUsername: \"foo\",\n\t\t\t\tUserID:   \"41331323-6f44-45e6-b3b9-2c4b60c02be5\",\n\t\t\t},\n\t\t},\n\t\tExpiry: Expiry{\n\t\t\tSigningKeys:  \"7h\",\n\t\t\tIDTokens:     \"25h\",\n\t\t\tAuthRequests: \"25h\",\n\t\t},\n\t\tLogger: Logger{\n\t\t\tLevel:  \"debug\",\n\t\t\tFormat: \"json\",\n\t\t},\n\t}\n\n\tvar c Config\n\tif err := yaml.Unmarshal(rawConfig, &c); err != nil {\n\t\tt.Fatalf(\"failed to decode config: %v\", err)\n\t}\n\tif diff := pretty.Compare(c, want); diff != \"\" {\n\t\tt.Errorf(\"got!=want: %s\", diff)\n\t}\n}\n", "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\n\tgosundheit \"github.com/AppsFlyer/go-sundheit\"\n\t\"github.com/AppsFlyer/go-sundheit/checks\"\n\tgosundheithttp \"github.com/AppsFlyer/go-sundheit/http\"\n\t\"github.com/fsnotify/fsnotify\"\n\t\"github.com/ghodss/yaml\"\n\tgrpcprometheus \"github.com/grpc-ecosystem/go-grpc-prometheus\"\n\t\"github.com/oklog/run\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/collectors\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/spf13/cobra\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/reflection\"\n\n\t\"github.com/dexidp/dex/api/v2\"\n\t\"github.com/dexidp/dex/pkg/log\"\n\t\"github.com/dexidp/dex/server\"\n\t\"github.com/dexidp/dex/storage\"\n)\n\ntype serveOptions struct {\n\t// Config file path\n\tconfig string\n\n\t// Flags\n\twebHTTPAddr   string\n\twebHTTPSAddr  string\n\ttelemetryAddr string\n\tgrpcAddr      string\n}\n\nfunc commandServe() *cobra.Command {\n\toptions := serveOptions{}\n\n\tcmd := &cobra.Command{\n\t\tUse:     \"serve [flags] [config file]\",\n\t\tShort:   \"Launch Dex\",\n\t\tExample: \"dex serve config.yaml\",\n\t\tArgs:    cobra.ExactArgs(1),\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tcmd.SilenceUsage = true\n\t\t\tcmd.SilenceErrors = true\n\n\t\t\toptions.config = args[0]\n\n\t\t\treturn runServe(options)\n\t\t},\n\t}\n\n\tflags := cmd.Flags()\n\n\tflags.StringVar(&options.webHTTPAddr, \"web-http-addr\", \"\", \"Web HTTP address\")\n\tflags.StringVar(&options.webHTTPSAddr, \"web-https-addr\", \"\", \"Web HTTPS address\")\n\tflags.StringVar(&options.telemetryAddr, \"telemetry-addr\", \"\", \"Telemetry address\")\n\tflags.StringVar(&options.grpcAddr, \"grpc-addr\", \"\", \"gRPC API address\")\n\n\treturn cmd\n}\n\nfunc runServe(options serveOptions) error {\n\tconfigFile := options.config\n\tconfigData, err := os.ReadFile(configFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read config file %s: %v\", configFile, err)\n\t}\n\n\tvar c Config\n\tif err := yaml.Unmarshal(configData, &c); err != nil {\n\t\treturn fmt.Errorf(\"error parse config file %s: %v\", configFile, err)\n\t}\n\n\tapplyConfigOverrides(options, &c)\n\n\tlogger, err := newLogger(c.Logger.Level, c.Logger.Format)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid config: %v\", err)\n\t}\n\n\tlogger.Infof(\n\t\t\"Dex Version: %s, Go Version: %s, Go OS/ARCH: %s %s\",\n\t\tversion,\n\t\truntime.Version(),\n\t\truntime.GOOS,\n\t\truntime.GOARCH,\n\t)\n\n\tif c.Logger.Level != \"\" {\n\t\tlogger.Infof(\"config using log level: %s\", c.Logger.Level)\n\t}\n\tif err := c.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tlogger.Infof(\"config issuer: %s\", c.Issuer)\n\n\tprometheusRegistry := prometheus.NewRegistry()\n\terr = prometheusRegistry.Register(collectors.NewGoCollector())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to register Go runtime metrics: %v\", err)\n\t}\n\n\terr = prometheusRegistry.Register(collectors.NewProcessCollector(collectors.ProcessCollectorOpts{}))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to register process metrics: %v\", err)\n\t}\n\n\tgrpcMetrics := grpcprometheus.NewServerMetrics()\n\terr = prometheusRegistry.Register(grpcMetrics)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to register gRPC server metrics: %v\", err)\n\t}\n\n\tvar grpcOptions []grpc.ServerOption\n\n\tallowedTLSCiphers := []uint16{\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n\t\ttls.TLS_RSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t}\n\n\tif c.GRPC.TLSCert != \"\" {\n\t\tbaseTLSConfig := &tls.Config{\n\t\t\tMinVersion:               tls.VersionTLS12,\n\t\t\tCipherSuites:             allowedTLSCiphers,\n\t\t\tPreferServerCipherSuites: true,\n\t\t}\n\n\t\ttlsConfig, err := newTLSReloader(logger, c.GRPC.TLSCert, c.GRPC.TLSKey, c.GRPC.TLSClientCA, baseTLSConfig)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config: get gRPC TLS: %v\", err)\n\t\t}\n\n\t\tif c.GRPC.TLSClientCA != \"\" {\n\t\t\t// Only add metrics if client auth is enabled\n\t\t\tgrpcOptions = append(grpcOptions,\n\t\t\t\tgrpc.StreamInterceptor(grpcMetrics.StreamServerInterceptor()),\n\t\t\t\tgrpc.UnaryInterceptor(grpcMetrics.UnaryServerInterceptor()),\n\t\t\t)\n\t\t}\n\n\t\tgrpcOptions = append(grpcOptions, grpc.Creds(credentials.NewTLS(tlsConfig)))\n\t}\n\n\ts, err := c.Storage.Config.Open(logger)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to initialize storage: %v\", err)\n\t}\n\tdefer s.Close()\n\n\tlogger.Infof(\"config storage: %s\", c.Storage.Type)\n\n\tif len(c.StaticClients) > 0 {\n\t\tfor i, client := range c.StaticClients {\n\t\t\tif client.Name == \"\" {\n\t\t\t\treturn fmt.Errorf(\"invalid config: Name field is required for a client\")\n\t\t\t}\n\t\t\tif client.ID == \"\" && client.IDEnv == \"\" {\n\t\t\t\treturn fmt.Errorf(\"invalid config: ID or IDEnv field is required for a client\")\n\t\t\t}\n\t\t\tif client.IDEnv != \"\" {\n\t\t\t\tif client.ID != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\"invalid config: ID and IDEnv fields are exclusive for client %q\", client.ID)\n\t\t\t\t}\n\t\t\t\tc.StaticClients[i].ID = os.Getenv(client.IDEnv)\n\t\t\t}\n\t\t\tif client.Secret == \"\" && client.SecretEnv == \"\" && !client.Public {\n\t\t\t\treturn fmt.Errorf(\"invalid config: Secret or SecretEnv field is required for client %q\", client.ID)\n\t\t\t}\n\t\t\tif client.SecretEnv != \"\" {\n\t\t\t\tif client.Secret != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\"invalid config: Secret and SecretEnv fields are exclusive for client %q\", client.ID)\n\t\t\t\t}\n\t\t\t\tc.StaticClients[i].Secret = os.Getenv(client.SecretEnv)\n\t\t\t}\n\t\t\tlogger.Infof(\"config static client: %s\", client.Name)\n\t\t}\n\t\ts = storage.WithStaticClients(s, c.StaticClients)\n\t}\n\tif len(c.StaticPasswords) > 0 {\n\t\tpasswords := make([]storage.Password, len(c.StaticPasswords))\n\t\tfor i, p := range c.StaticPasswords {\n\t\t\tpasswords[i] = storage.Password(p)\n\t\t}\n\t\ts = storage.WithStaticPasswords(s, passwords, logger)\n\t}\n\n\tstorageConnectors := make([]storage.Connector, len(c.StaticConnectors))\n\tfor i, c := range c.StaticConnectors {\n\t\tif c.ID == \"\" || c.Name == \"\" || c.Type == \"\" {\n\t\t\treturn fmt.Errorf(\"invalid config: ID, Type and Name fields are required for a connector\")\n\t\t}\n\t\tif c.Config == nil {\n\t\t\treturn fmt.Errorf(\"invalid config: no config field for connector %q\", c.ID)\n\t\t}\n\t\tlogger.Infof(\"config connector: %s\", c.ID)\n\n\t\t// convert to a storage connector object\n\t\tconn, err := ToStorageConnector(c)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to initialize storage connectors: %v\", err)\n\t\t}\n\t\tstorageConnectors[i] = conn\n\t}\n\n\tif c.EnablePasswordDB {\n\t\tstorageConnectors = append(storageConnectors, storage.Connector{\n\t\t\tID:   server.LocalConnector,\n\t\t\tName: \"Email\",\n\t\t\tType: server.LocalConnector,\n\t\t})\n\t\tlogger.Infof(\"config connector: local passwords enabled\")\n\t}\n\n\ts = storage.WithStaticConnectors(s, storageConnectors)\n\n\tif len(c.OAuth2.ResponseTypes) > 0 {\n\t\tlogger.Infof(\"config response types accepted: %s\", c.OAuth2.ResponseTypes)\n\t}\n\tif c.OAuth2.SkipApprovalScreen {\n\t\tlogger.Infof(\"config skipping approval screen\")\n\t}\n\tif c.OAuth2.PasswordConnector != \"\" {\n\t\tlogger.Infof(\"config using password grant connector: %s\", c.OAuth2.PasswordConnector)\n\t}\n\tif len(c.Web.AllowedOrigins) > 0 {\n\t\tlogger.Infof(\"config allowed origins: %s\", c.Web.AllowedOrigins)\n\t}\n\n\t// explicitly convert to UTC.\n\tnow := func() time.Time { return time.Now().UTC() }\n\n\thealthChecker := gosundheit.New()\n\n\tserverConfig := server.Config{\n\t\tAllowedGrantTypes:      c.OAuth2.GrantTypes,\n\t\tSupportedResponseTypes: c.OAuth2.ResponseTypes,\n\t\tSkipApprovalScreen:     c.OAuth2.SkipApprovalScreen,\n\t\tAlwaysShowLoginScreen:  c.OAuth2.AlwaysShowLoginScreen,\n\t\tPasswordConnector:      c.OAuth2.PasswordConnector,\n\t\tAllowedOrigins:         c.Web.AllowedOrigins,\n\t\tAllowedHeaders:         c.Web.AllowedHeaders,\n\t\tIssuer:                 c.Issuer,\n\t\tStorage:                s,\n\t\tWeb:                    c.Frontend,\n\t\tLogger:                 logger,\n\t\tNow:                    now,\n\t\tPrometheusRegistry:     prometheusRegistry,\n\t\tHealthChecker:          healthChecker,\n\t}\n\tif c.Expiry.SigningKeys != \"\" {\n\t\tsigningKeys, err := time.ParseDuration(c.Expiry.SigningKeys)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config value %q for signing keys expiry: %v\", c.Expiry.SigningKeys, err)\n\t\t}\n\t\tlogger.Infof(\"config signing keys expire after: %v\", signingKeys)\n\t\tserverConfig.RotateKeysAfter = signingKeys\n\t}\n\tif c.Expiry.IDTokens != \"\" {\n\t\tidTokens, err := time.ParseDuration(c.Expiry.IDTokens)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config value %q for id token expiry: %v\", c.Expiry.IDTokens, err)\n\t\t}\n\t\tlogger.Infof(\"config id tokens valid for: %v\", idTokens)\n\t\tserverConfig.IDTokensValidFor = idTokens\n\t}\n\tif c.Expiry.AuthRequests != \"\" {\n\t\tauthRequests, err := time.ParseDuration(c.Expiry.AuthRequests)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config value %q for auth request expiry: %v\", c.Expiry.AuthRequests, err)\n\t\t}\n\t\tlogger.Infof(\"config auth requests valid for: %v\", authRequests)\n\t\tserverConfig.AuthRequestsValidFor = authRequests\n\t}\n\tif c.Expiry.DeviceRequests != \"\" {\n\t\tdeviceRequests, err := time.ParseDuration(c.Expiry.DeviceRequests)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config value %q for device request expiry: %v\", c.Expiry.AuthRequests, err)\n\t\t}\n\t\tlogger.Infof(\"config device requests valid for: %v\", deviceRequests)\n\t\tserverConfig.DeviceRequestsValidFor = deviceRequests\n\t}\n\trefreshTokenPolicy, err := server.NewRefreshTokenPolicy(\n\t\tlogger,\n\t\tc.Expiry.RefreshTokens.DisableRotation,\n\t\tc.Expiry.RefreshTokens.ValidIfNotUsedFor,\n\t\tc.Expiry.RefreshTokens.AbsoluteLifetime,\n\t\tc.Expiry.RefreshTokens.ReuseInterval,\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid refresh token expiration policy config: %v\", err)\n\t}\n\n\tserverConfig.RefreshTokenPolicy = refreshTokenPolicy\n\tserv, err := server.NewServer(context.Background(), serverConfig)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to initialize server: %v\", err)\n\t}\n\n\ttelemetryRouter := http.NewServeMux()\n\ttelemetryRouter.Handle(\"/metrics\", promhttp.HandlerFor(prometheusRegistry, promhttp.HandlerOpts{}))\n\n\t// Configure health checker\n\t{\n\t\thandler := gosundheithttp.HandleHealthJSON(healthChecker)\n\t\ttelemetryRouter.Handle(\"/healthz\", handler)\n\n\t\t// Kubernetes style health checks\n\t\ttelemetryRouter.HandleFunc(\"/healthz/live\", func(w http.ResponseWriter, _ *http.Request) {\n\t\t\t_, _ = w.Write([]byte(\"ok\"))\n\t\t})\n\t\ttelemetryRouter.Handle(\"/healthz/ready\", handler)\n\t}\n\n\thealthChecker.RegisterCheck(\n\t\t&checks.CustomCheck{\n\t\t\tCheckName: \"storage\",\n\t\t\tCheckFunc: storage.NewCustomHealthCheckFunc(serverConfig.Storage, serverConfig.Now),\n\t\t},\n\t\tgosundheit.ExecutionPeriod(15*time.Second),\n\t\tgosundheit.InitiallyPassing(true),\n\t)\n\n\tvar group run.Group\n\n\t// Set up telemetry server\n\tif c.Telemetry.HTTP != \"\" {\n\t\tconst name = \"telemetry\"\n\n\t\tlogger.Infof(\"listening (%s) on %s\", name, c.Telemetry.HTTP)\n\n\t\tl, err := net.Listen(\"tcp\", c.Telemetry.HTTP)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"listening (%s) on %s: %v\", name, c.Telemetry.HTTP, err)\n\t\t}\n\n\t\tif c.Telemetry.EnableProfiling {\n\t\t\tpprofHandler(telemetryRouter)\n\t\t}\n\n\t\tserver := &http.Server{\n\t\t\tHandler: telemetryRouter,\n\t\t}\n\t\tdefer server.Close()\n\n\t\tgroup.Add(func() error {\n\t\t\treturn server.Serve(l)\n\t\t}, func(err error) {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\t\t\tdefer cancel()\n\n\t\t\tlogger.Debugf(\"starting graceful shutdown (%s)\", name)\n\t\t\tif err := server.Shutdown(ctx); err != nil {\n\t\t\t\tlogger.Errorf(\"graceful shutdown (%s): %v\", name, err)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Set up http server\n\tif c.Web.HTTP != \"\" {\n\t\tconst name = \"http\"\n\n\t\tlogger.Infof(\"listening (%s) on %s\", name, c.Web.HTTP)\n\n\t\tl, err := net.Listen(\"tcp\", c.Web.HTTP)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"listening (%s) on %s: %v\", name, c.Web.HTTP, err)\n\t\t}\n\n\t\tserver := &http.Server{\n\t\t\tHandler: serv,\n\t\t}\n\t\tdefer server.Close()\n\n\t\tgroup.Add(func() error {\n\t\t\treturn server.Serve(l)\n\t\t}, func(err error) {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\t\t\tdefer cancel()\n\n\t\t\tlogger.Debugf(\"starting graceful shutdown (%s)\", name)\n\t\t\tif err := server.Shutdown(ctx); err != nil {\n\t\t\t\tlogger.Errorf(\"graceful shutdown (%s): %v\", name, err)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Set up https server\n\tif c.Web.HTTPS != \"\" {\n\t\tconst name = \"https\"\n\n\t\tlogger.Infof(\"listening (%s) on %s\", name, c.Web.HTTPS)\n\n\t\tl, err := net.Listen(\"tcp\", c.Web.HTTPS)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"listening (%s) on %s: %v\", name, c.Web.HTTPS, err)\n\t\t}\n\n\t\tbaseTLSConfig := &tls.Config{\n\t\t\tMinVersion:               tls.VersionTLS12,\n\t\t\tCipherSuites:             allowedTLSCiphers,\n\t\t\tPreferServerCipherSuites: true,\n\t\t}\n\n\t\ttlsConfig, err := newTLSReloader(logger, c.Web.TLSCert, c.Web.TLSKey, \"\", baseTLSConfig)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config: get HTTP TLS: %v\", err)\n\t\t}\n\n\t\tserver := &http.Server{\n\t\t\tHandler:   serv,\n\t\t\tTLSConfig: tlsConfig,\n\t\t}\n\t\tdefer server.Close()\n\n\t\tgroup.Add(func() error {\n\t\t\treturn server.ServeTLS(l, \"\", \"\")\n\t\t}, func(err error) {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\t\t\tdefer cancel()\n\n\t\t\tlogger.Debugf(\"starting graceful shutdown (%s)\", name)\n\t\t\tif err := server.Shutdown(ctx); err != nil {\n\t\t\t\tlogger.Errorf(\"graceful shutdown (%s): %v\", name, err)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Set up grpc server\n\tif c.GRPC.Addr != \"\" {\n\t\tlogger.Infof(\"listening (grpc) on %s\", c.GRPC.Addr)\n\n\t\tgrpcListener, err := net.Listen(\"tcp\", c.GRPC.Addr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"listening (grcp) on %s: %w\", c.GRPC.Addr, err)\n\t\t}\n\n\t\tgrpcSrv := grpc.NewServer(grpcOptions...)\n\t\tapi.RegisterDexServer(grpcSrv, server.NewAPI(serverConfig.Storage, logger, version))\n\n\t\tgrpcMetrics.InitializeMetrics(grpcSrv)\n\t\tif c.GRPC.Reflection {\n\t\t\tlogger.Info(\"enabling reflection in grpc service\")\n\t\t\treflection.Register(grpcSrv)\n\t\t}\n\n\t\tgroup.Add(func() error {\n\t\t\treturn grpcSrv.Serve(grpcListener)\n\t\t}, func(err error) {\n\t\t\tlogger.Debugf(\"starting graceful shutdown (grpc)\")\n\t\t\tgrpcSrv.GracefulStop()\n\t\t})\n\t}\n\n\tgroup.Add(run.SignalHandler(context.Background(), os.Interrupt, syscall.SIGTERM))\n\tif err := group.Run(); err != nil {\n\t\tif _, ok := err.(run.SignalError); !ok {\n\t\t\treturn fmt.Errorf(\"run groups: %w\", err)\n\t\t}\n\t\tlogger.Infof(\"%v, shutdown now\", err)\n\t}\n\treturn nil\n}\n\nvar (\n\tlogLevels  = []string{\"debug\", \"info\", \"error\"}\n\tlogFormats = []string{\"json\", \"text\"}\n)\n\ntype utcFormatter struct {\n\tf logrus.Formatter\n}\n\nfunc (f *utcFormatter) Format(e *logrus.Entry) ([]byte, error) {\n\te.Time = e.Time.UTC()\n\treturn f.f.Format(e)\n}\n\nfunc newLogger(level string, format string) (log.Logger, error) {\n\tvar logLevel logrus.Level\n\tswitch strings.ToLower(level) {\n\tcase \"debug\":\n\t\tlogLevel = logrus.DebugLevel\n\tcase \"\", \"info\":\n\t\tlogLevel = logrus.InfoLevel\n\tcase \"error\":\n\t\tlogLevel = logrus.ErrorLevel\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"log level is not one of the supported values (%s): %s\", strings.Join(logLevels, \", \"), level)\n\t}\n\n\tvar formatter utcFormatter\n\tswitch strings.ToLower(format) {\n\tcase \"\", \"text\":\n\t\tformatter.f = &logrus.TextFormatter{DisableColors: true}\n\tcase \"json\":\n\t\tformatter.f = &logrus.JSONFormatter{}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"log format is not one of the supported values (%s): %s\", strings.Join(logFormats, \", \"), format)\n\t}\n\n\treturn &logrus.Logger{\n\t\tOut:       os.Stderr,\n\t\tFormatter: &formatter,\n\t\tLevel:     logLevel,\n\t}, nil\n}\n\nfunc applyConfigOverrides(options serveOptions, config *Config) {\n\tif options.webHTTPAddr != \"\" {\n\t\tconfig.Web.HTTP = options.webHTTPAddr\n\t}\n\n\tif options.webHTTPSAddr != \"\" {\n\t\tconfig.Web.HTTPS = options.webHTTPSAddr\n\t}\n\n\tif options.telemetryAddr != \"\" {\n\t\tconfig.Telemetry.HTTP = options.telemetryAddr\n\t}\n\n\tif options.grpcAddr != \"\" {\n\t\tconfig.GRPC.Addr = options.grpcAddr\n\t}\n\n\tif config.Frontend.Dir == \"\" {\n\t\tconfig.Frontend.Dir = os.Getenv(\"DEX_FRONTEND_DIR\")\n\t}\n\n\tif len(config.OAuth2.GrantTypes) == 0 {\n\t\tconfig.OAuth2.GrantTypes = []string{\n\t\t\t\"authorization_code\",\n\t\t\t\"implicit\",\n\t\t\t\"password\",\n\t\t\t\"refresh_token\",\n\t\t\t\"urn:ietf:params:oauth:grant-type:device_code\",\n\t\t\t\"urn:ietf:params:oauth:grant-type:token-exchange\",\n\t\t}\n\t}\n}\n\nfunc pprofHandler(router *http.ServeMux) {\n\trouter.HandleFunc(\"/debug/pprof/\", pprof.Index)\n\trouter.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline)\n\trouter.HandleFunc(\"/debug/pprof/profile\", pprof.Profile)\n\trouter.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol)\n\trouter.HandleFunc(\"/debug/pprof/trace\", pprof.Trace)\n}\n\n// newTLSReloader returns a [tls.Config] with GetCertificate or GetConfigForClient set\n// to reload certificates from the given paths on SIGHUP or on file creates (atomic update via rename).\nfunc newTLSReloader(logger log.Logger, certFile, keyFile, caFile string, baseConfig *tls.Config) (*tls.Config, error) {\n\t// trigger reload on channel\n\tsigc := make(chan os.Signal, 1)\n\tsignal.Notify(sigc, syscall.SIGHUP)\n\n\t// files to watch\n\twatchFiles := map[string]struct{}{\n\t\tcertFile: {},\n\t\tkeyFile:  {},\n\t}\n\tif caFile != \"\" {\n\t\twatchFiles[caFile] = struct{}{}\n\t}\n\twatchDirs := make(map[string]struct{}) // dedupe dirs\n\tfor f := range watchFiles {\n\t\tdir := filepath.Dir(f)\n\t\tif !strings.HasPrefix(f, dir) {\n\t\t\t// normalize name to have ./ prefix if only a local path was provided\n\t\t\t// can't pass \"\" to watcher.Add\n\t\t\twatchFiles[dir+string(filepath.Separator)+f] = struct{}{}\n\t\t}\n\t\twatchDirs[dir] = struct{}{}\n\t}\n\t// trigger reload on file change\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create watcher for TLS reloader: %v\", err)\n\t}\n\t// recommended by fsnotify: watch the dir to handle renames\n\t// https://pkg.go.dev/github.com/fsnotify/fsnotify#hdr-Watching_files\n\tfor dir := range watchDirs {\n\t\tlogger.Debugf(\"watching dir: %v\", dir)\n\t\terr := watcher.Add(dir)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"watch dir for TLS reloader: %v\", err)\n\t\t}\n\t}\n\n\t// load once outside the goroutine so we can return an error on misconfig\n\tinitialConfig, err := loadTLSConfig(certFile, keyFile, caFile, baseConfig)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"load TLS config: %v\", err)\n\t}\n\n\t// stored version of current tls config\n\tptr := &atomic.Pointer[tls.Config]{}\n\tptr.Store(initialConfig)\n\n\t// start background worker to reload certs\n\tgo func() {\n\tloop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase sig := <-sigc:\n\t\t\t\tlogger.Debug(\"reloading cert from signal: %v\", sig)\n\t\t\tcase evt := <-watcher.Events:\n\t\t\t\tif _, ok := watchFiles[evt.Name]; !ok || !evt.Has(fsnotify.Create) {\n\t\t\t\t\tcontinue loop\n\t\t\t\t}\n\t\t\t\tlogger.Debug(\"reloading cert from fsnotify: %v %v\", evt.Name, evt.Op.String())\n\t\t\tcase err := <-watcher.Errors:\n\t\t\t\tlogger.Errorf(\"TLS reloader watch: %v\", err)\n\t\t\t}\n\n\t\t\tloaded, err := loadTLSConfig(certFile, keyFile, caFile, baseConfig)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Errorf(\"reload TLS config: %v\", err)\n\t\t\t}\n\t\t\tptr.Store(loaded)\n\t\t}\n\t}()\n\n\t// https://pkg.go.dev/crypto/tls#baseConfig\n\t// Server configurations must set one of Certificates, GetCertificate or GetConfigForClient.\n\tif caFile != \"\" {\n\t\t// grpc will use this via tls.Server for mTLS\n\t\tinitialConfig.GetConfigForClient = func(chi *tls.ClientHelloInfo) (*tls.Config, error) { return ptr.Load(), nil }\n\t} else {\n\t\t// net/http only uses Certificates or GetCertificate\n\t\tinitialConfig.GetCertificate = func(chi *tls.ClientHelloInfo) (*tls.Certificate, error) { return &ptr.Load().Certificates[0], nil }\n\t}\n\treturn initialConfig, nil\n}\n\n// loadTLSConfig loads the given file paths into a [tls.Config]\nfunc loadTLSConfig(certFile, keyFile, caFile string, baseConfig *tls.Config) (*tls.Config, error) {\n\tcert, err := tls.LoadX509KeyPair(certFile, keyFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"loading TLS keypair: %v\", err)\n\t}\n\tloadedConfig := baseConfig.Clone() // copy\n\tloadedConfig.Certificates = []tls.Certificate{cert}\n\tif caFile != \"\" {\n\t\tcPool := x509.NewCertPool()\n\t\tclientCert, err := os.ReadFile(caFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"reading from client CA file: %v\", err)\n\t\t}\n\t\tif !cPool.AppendCertsFromPEM(clientCert) {\n\t\t\treturn nil, errors.New(\"failed to parse client CA\")\n\t\t}\n\n\t\tloadedConfig.ClientAuth = tls.RequireAndVerifyClientCert\n\t\tloadedConfig.ClientCAs = cPool\n\t}\n\treturn loadedConfig, nil\n}\n", "# The base path of Dex and the external name of the OpenID Connect service.\n# This is the canonical URL that all clients MUST use to refer to Dex. If a\n# path is provided, Dex's HTTP service will listen at a non-root URL.\nissuer: http://127.0.0.1:5556/dex\n\n# The storage configuration determines where Dex stores its state.\n# Supported options include:\n#   - SQL flavors\n#   - key-value stores (eg. etcd)\n#   - Kubernetes Custom Resources\n#\n# See the documentation (https://dexidp.io/docs/storage/) for further information.\nstorage:\n  type: memory\n\n  # type: sqlite3\n  # config:\n  #   file: /var/dex/dex.db\n\n  # type: mysql\n  # config:\n  #   host: 127.0.0.1\n  #   port: 3306\n  #   database: dex\n  #   user: mysql\n  #   password: mysql\n  #   ssl:\n  #     mode: \"false\"\n\n  # type: postgres\n  # config:\n  #   host: 127.0.0.1\n  #   port: 5432\n  #   database: dex\n  #   user: postgres\n  #   password: postgres\n  #   ssl:\n  #     mode: disable\n\n  # type: etcd\n  # config:\n  #   endpoints:\n  #     - http://127.0.0.1:2379\n  #   namespace: dex/\n\n  # type: kubernetes\n  # config:\n  #   kubeConfigFile: $HOME/.kube/config\n\n# HTTP service configuration\nweb:\n  http: 127.0.0.1:5556\n\n  # Uncomment to enable HTTPS endpoint.\n  # https: 127.0.0.1:5554\n  # tlsCert: /etc/dex/tls.crt\n  # tlsKey: /etc/dex/tls.key\n\n# Dex UI configuration\n# frontend:\n#   issuer: dex\n#   logoURL: theme/logo.png\n#   dir: \"\"\n#   theme: light\n\n# Telemetry configuration\n# telemetry:\n#   http: 127.0.0.1:5558\n\n# logger:\n#   level: \"debug\"\n#   format: \"text\" # can also be \"json\"\n\n# gRPC API configuration\n# Uncomment this block to enable the gRPC API.\n# See the documentation (https://dexidp.io/docs/api/) for further information.\n# grpc:\n#   addr: 127.0.0.1:5557\n#   tlsCert: examples/grpc-client/server.crt\n#   tlsKey: examples/grpc-client/server.key\n#   tlsClientCA: examples/grpc-client/ca.crt\n\n# Expiration configuration for tokens, signing keys, etc.\n# expiry:\n#   deviceRequests: \"5m\"\n#   signingKeys: \"6h\"\n#   idTokens: \"24h\"\n#   refreshTokens:\n#     disableRotation: false\n#     reuseInterval: \"3s\"\n#     validIfNotUsedFor: \"2160h\" # 90 days\n#     absoluteLifetime: \"3960h\" # 165 days\n\n# OAuth2 configuration\n# oauth2:\n#   # use [\"code\", \"token\", \"id_token\"] to enable implicit flow for web-only clients\n#   responseTypes: [ \"code\" ] # also allowed are \"token\" and \"id_token\"\n#\n#   # By default, Dex will ask for approval to share data with application\n#   # (approval for sharing data from connected IdP to Dex is separate process on IdP)\n#   skipApprovalScreen: false\n#\n#   # If only one authentication method is enabled, the default behavior is to\n#   # go directly to it. For connected IdPs, this redirects the browser away\n#   # from application to upstream provider such as the Google login page\n#   alwaysShowLoginScreen: false\n#\n#   # Uncomment to use a specific connector for password grants\n#   passwordConnector: local\n\n# Static clients registered in Dex by default.\n#\n# Alternatively, clients may be added through the gRPC API.\n# staticClients:\n#   - id: example-app\n#     redirectURIs:\n#       - 'http://127.0.0.1:5555/callback'\n#     name: 'Example App'\n#     secret: ZXhhbXBsZS1hcHAtc2VjcmV0\n\n# Connectors are used to authenticate users against upstream identity providers.\n#\n# See the documentation (https://dexidp.io/docs/connectors/) for further information.\n# connectors: []\n\n# Enable the password database.\n#\n# It's a \"virtual\" connector (identity provider) that stores\n# login credentials in Dex's store.\nenablePasswordDB: true\n\n# If this option isn't chosen users may be added through the gRPC API.\n# A static list of passwords for the password connector.\n#\n# Alternatively, passwords my be added/updated through the gRPC API.\n# staticPasswords: []\n"], "fixing_code": ["package main\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/bcrypt\"\n\n\t\"github.com/dexidp/dex/pkg/featureflags\"\n\t\"github.com/dexidp/dex/pkg/log\"\n\t\"github.com/dexidp/dex/server\"\n\t\"github.com/dexidp/dex/storage\"\n\t\"github.com/dexidp/dex/storage/ent\"\n\t\"github.com/dexidp/dex/storage/etcd\"\n\t\"github.com/dexidp/dex/storage/kubernetes\"\n\t\"github.com/dexidp/dex/storage/memory\"\n\t\"github.com/dexidp/dex/storage/sql\"\n)\n\n// Config is the config format for the main application.\ntype Config struct {\n\tIssuer    string    `json:\"issuer\"`\n\tStorage   Storage   `json:\"storage\"`\n\tWeb       Web       `json:\"web\"`\n\tTelemetry Telemetry `json:\"telemetry\"`\n\tOAuth2    OAuth2    `json:\"oauth2\"`\n\tGRPC      GRPC      `json:\"grpc\"`\n\tExpiry    Expiry    `json:\"expiry\"`\n\tLogger    Logger    `json:\"logger\"`\n\n\tFrontend server.WebConfig `json:\"frontend\"`\n\n\t// StaticConnectors are user defined connectors specified in the ConfigMap\n\t// Write operations, like updating a connector, will fail.\n\tStaticConnectors []Connector `json:\"connectors\"`\n\n\t// StaticClients cause the server to use this list of clients rather than\n\t// querying the storage. Write operations, like creating a client, will fail.\n\tStaticClients []storage.Client `json:\"staticClients\"`\n\n\t// If enabled, the server will maintain a list of passwords which can be used\n\t// to identify a user.\n\tEnablePasswordDB bool `json:\"enablePasswordDB\"`\n\n\t// StaticPasswords cause the server use this list of passwords rather than\n\t// querying the storage. Cannot be specified without enabling a passwords\n\t// database.\n\tStaticPasswords []password `json:\"staticPasswords\"`\n}\n\n// Validate the configuration\nfunc (c Config) Validate() error {\n\t// Fast checks. Perform these first for a more responsive CLI.\n\tchecks := []struct {\n\t\tbad    bool\n\t\terrMsg string\n\t}{\n\t\t{c.Issuer == \"\", \"no issuer specified in config file\"},\n\t\t{!c.EnablePasswordDB && len(c.StaticPasswords) != 0, \"cannot specify static passwords without enabling password db\"},\n\t\t{c.Storage.Config == nil, \"no storage supplied in config file\"},\n\t\t{c.Web.HTTP == \"\" && c.Web.HTTPS == \"\", \"must supply a HTTP/HTTPS  address to listen on\"},\n\t\t{c.Web.HTTPS != \"\" && c.Web.TLSCert == \"\", \"no cert specified for HTTPS\"},\n\t\t{c.Web.HTTPS != \"\" && c.Web.TLSKey == \"\", \"no private key specified for HTTPS\"},\n\t\t{c.Web.TLSMinVersion != \"\" && c.Web.TLSMinVersion != \"1.2\" && c.Web.TLSMinVersion != \"1.3\", \"supported TLS versions are: 1.2, 1.3\"},\n\t\t{c.Web.TLSMaxVersion != \"\" && c.Web.TLSMaxVersion != \"1.2\" && c.Web.TLSMaxVersion != \"1.3\", \"supported TLS versions are: 1.2, 1.3\"},\n\t\t{c.Web.TLSMaxVersion != \"\" && c.Web.TLSMinVersion != \"\" && c.Web.TLSMinVersion > c.Web.TLSMaxVersion, \"TLSMinVersion greater than TLSMaxVersion\"},\n\t\t{c.GRPC.TLSCert != \"\" && c.GRPC.Addr == \"\", \"no address specified for gRPC\"},\n\t\t{c.GRPC.TLSKey != \"\" && c.GRPC.Addr == \"\", \"no address specified for gRPC\"},\n\t\t{(c.GRPC.TLSCert == \"\") != (c.GRPC.TLSKey == \"\"), \"must specific both a gRPC TLS cert and key\"},\n\t\t{c.GRPC.TLSCert == \"\" && c.GRPC.TLSClientCA != \"\", \"cannot specify gRPC TLS client CA without a gRPC TLS cert\"},\n\t\t{c.GRPC.TLSMinVersion != \"\" && c.GRPC.TLSMinVersion != \"1.2\" && c.GRPC.TLSMinVersion != \"1.3\", \"supported TLS versions are: 1.2, 1.3\"},\n\t\t{c.GRPC.TLSMaxVersion != \"\" && c.GRPC.TLSMaxVersion != \"1.2\" && c.GRPC.TLSMaxVersion != \"1.3\", \"supported TLS versions are: 1.2, 1.3\"},\n\t\t{c.GRPC.TLSMaxVersion != \"\" && c.GRPC.TLSMinVersion != \"\" && c.GRPC.TLSMinVersion > c.GRPC.TLSMaxVersion, \"TLSMinVersion greater than TLSMaxVersion\"},\n\t}\n\n\tvar checkErrors []string\n\n\tfor _, check := range checks {\n\t\tif check.bad {\n\t\t\tcheckErrors = append(checkErrors, check.errMsg)\n\t\t}\n\t}\n\tif len(checkErrors) != 0 {\n\t\treturn fmt.Errorf(\"invalid Config:\\n\\t-\\t%s\", strings.Join(checkErrors, \"\\n\\t-\\t\"))\n\t}\n\treturn nil\n}\n\ntype password storage.Password\n\nfunc (p *password) UnmarshalJSON(b []byte) error {\n\tvar data struct {\n\t\tEmail       string `json:\"email\"`\n\t\tUsername    string `json:\"username\"`\n\t\tUserID      string `json:\"userID\"`\n\t\tHash        string `json:\"hash\"`\n\t\tHashFromEnv string `json:\"hashFromEnv\"`\n\t}\n\tif err := json.Unmarshal(b, &data); err != nil {\n\t\treturn err\n\t}\n\t*p = password(storage.Password{\n\t\tEmail:    data.Email,\n\t\tUsername: data.Username,\n\t\tUserID:   data.UserID,\n\t})\n\tif len(data.Hash) == 0 && len(data.HashFromEnv) > 0 {\n\t\tdata.Hash = os.Getenv(data.HashFromEnv)\n\t}\n\tif len(data.Hash) == 0 {\n\t\treturn fmt.Errorf(\"no password hash provided\")\n\t}\n\n\t// If this value is a valid bcrypt, use it.\n\t_, bcryptErr := bcrypt.Cost([]byte(data.Hash))\n\tif bcryptErr == nil {\n\t\tp.Hash = []byte(data.Hash)\n\t\treturn nil\n\t}\n\n\t// For backwards compatibility try to base64 decode this value.\n\thashBytes, err := base64.StdEncoding.DecodeString(data.Hash)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"malformed bcrypt hash: %v\", bcryptErr)\n\t}\n\tif _, err := bcrypt.Cost(hashBytes); err != nil {\n\t\treturn fmt.Errorf(\"malformed bcrypt hash: %v\", err)\n\t}\n\tp.Hash = hashBytes\n\treturn nil\n}\n\n// OAuth2 describes enabled OAuth2 extensions.\ntype OAuth2 struct {\n\t// list of allowed grant types,\n\t// defaults to all supported types\n\tGrantTypes []string `json:\"grantTypes\"`\n\n\tResponseTypes []string `json:\"responseTypes\"`\n\t// If specified, do not prompt the user to approve client authorization. The\n\t// act of logging in implies authorization.\n\tSkipApprovalScreen bool `json:\"skipApprovalScreen\"`\n\t// If specified, show the connector selection screen even if there's only one\n\tAlwaysShowLoginScreen bool `json:\"alwaysShowLoginScreen\"`\n\t// This is the connector that can be used for password grant\n\tPasswordConnector string `json:\"passwordConnector\"`\n}\n\n// Web is the config format for the HTTP server.\ntype Web struct {\n\tHTTP           string   `json:\"http\"`\n\tHTTPS          string   `json:\"https\"`\n\tTLSCert        string   `json:\"tlsCert\"`\n\tTLSKey         string   `json:\"tlsKey\"`\n\tTLSMinVersion  string   `json:\"tlsMinVersion\"`\n\tTLSMaxVersion  string   `json:\"tlsMaxVersion\"`\n\tAllowedOrigins []string `json:\"allowedOrigins\"`\n\tAllowedHeaders []string `json:\"allowedHeaders\"`\n}\n\n// Telemetry is the config format for telemetry including the HTTP server config.\ntype Telemetry struct {\n\tHTTP string `json:\"http\"`\n\t// EnableProfiling makes profiling endpoints available via web interface host:port/debug/pprof/\n\tEnableProfiling bool `json:\"enableProfiling\"`\n}\n\n// GRPC is the config for the gRPC API.\ntype GRPC struct {\n\t// The port to listen on.\n\tAddr          string `json:\"addr\"`\n\tTLSCert       string `json:\"tlsCert\"`\n\tTLSKey        string `json:\"tlsKey\"`\n\tTLSClientCA   string `json:\"tlsClientCA\"`\n\tTLSMinVersion string `json:\"tlsMinVersion\"`\n\tTLSMaxVersion string `json:\"tlsMaxVersion\"`\n\tReflection    bool   `json:\"reflection\"`\n}\n\n// Storage holds app's storage configuration.\ntype Storage struct {\n\tType   string        `json:\"type\"`\n\tConfig StorageConfig `json:\"config\"`\n}\n\n// StorageConfig is a configuration that can create a storage.\ntype StorageConfig interface {\n\tOpen(logger log.Logger) (storage.Storage, error)\n}\n\nvar (\n\t_ StorageConfig = (*etcd.Etcd)(nil)\n\t_ StorageConfig = (*kubernetes.Config)(nil)\n\t_ StorageConfig = (*memory.Config)(nil)\n\t_ StorageConfig = (*sql.SQLite3)(nil)\n\t_ StorageConfig = (*sql.Postgres)(nil)\n\t_ StorageConfig = (*sql.MySQL)(nil)\n\t_ StorageConfig = (*ent.SQLite3)(nil)\n\t_ StorageConfig = (*ent.Postgres)(nil)\n\t_ StorageConfig = (*ent.MySQL)(nil)\n)\n\nfunc getORMBasedSQLStorage(normal, entBased StorageConfig) func() StorageConfig {\n\treturn func() StorageConfig {\n\t\tif featureflags.EntEnabled.Enabled() {\n\t\t\treturn entBased\n\t\t}\n\t\treturn normal\n\t}\n}\n\nvar storages = map[string]func() StorageConfig{\n\t\"etcd\":       func() StorageConfig { return new(etcd.Etcd) },\n\t\"kubernetes\": func() StorageConfig { return new(kubernetes.Config) },\n\t\"memory\":     func() StorageConfig { return new(memory.Config) },\n\t\"sqlite3\":    getORMBasedSQLStorage(&sql.SQLite3{}, &ent.SQLite3{}),\n\t\"postgres\":   getORMBasedSQLStorage(&sql.Postgres{}, &ent.Postgres{}),\n\t\"mysql\":      getORMBasedSQLStorage(&sql.MySQL{}, &ent.MySQL{}),\n}\n\n// UnmarshalJSON allows Storage to implement the unmarshaler interface to\n// dynamically determine the type of the storage config.\nfunc (s *Storage) UnmarshalJSON(b []byte) error {\n\tvar store struct {\n\t\tType   string          `json:\"type\"`\n\t\tConfig json.RawMessage `json:\"config\"`\n\t}\n\tif err := json.Unmarshal(b, &store); err != nil {\n\t\treturn fmt.Errorf(\"parse storage: %v\", err)\n\t}\n\tf, ok := storages[store.Type]\n\tif !ok {\n\t\treturn fmt.Errorf(\"unknown storage type %q\", store.Type)\n\t}\n\n\tstorageConfig := f()\n\tif len(store.Config) != 0 {\n\t\tdata := []byte(store.Config)\n\t\tif featureflags.ExpandEnv.Enabled() {\n\t\t\t// Caution, we're expanding in the raw JSON/YAML source. This may not be what the admin expects.\n\t\t\tdata = []byte(os.ExpandEnv(string(store.Config)))\n\t\t}\n\t\tif err := json.Unmarshal(data, storageConfig); err != nil {\n\t\t\treturn fmt.Errorf(\"parse storage config: %v\", err)\n\t\t}\n\t}\n\t*s = Storage{\n\t\tType:   store.Type,\n\t\tConfig: storageConfig,\n\t}\n\treturn nil\n}\n\n// Connector is a magical type that can unmarshal YAML dynamically. The\n// Type field determines the connector type, which is then customized for Config.\ntype Connector struct {\n\tType string `json:\"type\"`\n\tName string `json:\"name\"`\n\tID   string `json:\"id\"`\n\n\tConfig server.ConnectorConfig `json:\"config\"`\n}\n\n// UnmarshalJSON allows Connector to implement the unmarshaler interface to\n// dynamically determine the type of the connector config.\nfunc (c *Connector) UnmarshalJSON(b []byte) error {\n\tvar conn struct {\n\t\tType string `json:\"type\"`\n\t\tName string `json:\"name\"`\n\t\tID   string `json:\"id\"`\n\n\t\tConfig json.RawMessage `json:\"config\"`\n\t}\n\tif err := json.Unmarshal(b, &conn); err != nil {\n\t\treturn fmt.Errorf(\"parse connector: %v\", err)\n\t}\n\tf, ok := server.ConnectorsConfig[conn.Type]\n\tif !ok {\n\t\treturn fmt.Errorf(\"unknown connector type %q\", conn.Type)\n\t}\n\n\tconnConfig := f()\n\tif len(conn.Config) != 0 {\n\t\tdata := []byte(conn.Config)\n\t\tif featureflags.ExpandEnv.Enabled() {\n\t\t\t// Caution, we're expanding in the raw JSON/YAML source. This may not be what the admin expects.\n\t\t\tdata = []byte(os.ExpandEnv(string(conn.Config)))\n\t\t}\n\t\tif err := json.Unmarshal(data, connConfig); err != nil {\n\t\t\treturn fmt.Errorf(\"parse connector config: %v\", err)\n\t\t}\n\t}\n\t*c = Connector{\n\t\tType:   conn.Type,\n\t\tName:   conn.Name,\n\t\tID:     conn.ID,\n\t\tConfig: connConfig,\n\t}\n\treturn nil\n}\n\n// ToStorageConnector converts an object to storage connector type.\nfunc ToStorageConnector(c Connector) (storage.Connector, error) {\n\tdata, err := json.Marshal(c.Config)\n\tif err != nil {\n\t\treturn storage.Connector{}, fmt.Errorf(\"failed to marshal connector config: %v\", err)\n\t}\n\n\treturn storage.Connector{\n\t\tID:     c.ID,\n\t\tType:   c.Type,\n\t\tName:   c.Name,\n\t\tConfig: data,\n\t}, nil\n}\n\n// Expiry holds configuration for the validity period of components.\ntype Expiry struct {\n\t// SigningKeys defines the duration of time after which the SigningKeys will be rotated.\n\tSigningKeys string `json:\"signingKeys\"`\n\n\t// IdTokens defines the duration of time for which the IdTokens will be valid.\n\tIDTokens string `json:\"idTokens\"`\n\n\t// AuthRequests defines the duration of time for which the AuthRequests will be valid.\n\tAuthRequests string `json:\"authRequests\"`\n\n\t// DeviceRequests defines the duration of time for which the DeviceRequests will be valid.\n\tDeviceRequests string `json:\"deviceRequests\"`\n\n\t// RefreshTokens defines refresh tokens expiry policy\n\tRefreshTokens RefreshToken `json:\"refreshTokens\"`\n}\n\n// Logger holds configuration required to customize logging for dex.\ntype Logger struct {\n\t// Level sets logging level severity.\n\tLevel string `json:\"level\"`\n\n\t// Format specifies the format to be used for logging.\n\tFormat string `json:\"format\"`\n}\n\ntype RefreshToken struct {\n\tDisableRotation   bool   `json:\"disableRotation\"`\n\tReuseInterval     string `json:\"reuseInterval\"`\n\tAbsoluteLifetime  string `json:\"absoluteLifetime\"`\n\tValidIfNotUsedFor string `json:\"validIfNotUsedFor\"`\n}\n", "package main\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/ghodss/yaml\"\n\t\"github.com/kylelemons/godebug/pretty\"\n\n\t\"github.com/dexidp/dex/connector/mock\"\n\t\"github.com/dexidp/dex/connector/oidc\"\n\t\"github.com/dexidp/dex/server\"\n\t\"github.com/dexidp/dex/storage\"\n\t\"github.com/dexidp/dex/storage/sql\"\n)\n\nvar _ = yaml.YAMLToJSON\n\nfunc TestValidConfiguration(t *testing.T) {\n\tconfiguration := Config{\n\t\tIssuer: \"http://127.0.0.1:5556/dex\",\n\t\tStorage: Storage{\n\t\t\tType: \"sqlite3\",\n\t\t\tConfig: &sql.SQLite3{\n\t\t\t\tFile: \"examples/dex.db\",\n\t\t\t},\n\t\t},\n\t\tWeb: Web{\n\t\t\tHTTP: \"127.0.0.1:5556\",\n\t\t},\n\t\tStaticConnectors: []Connector{\n\t\t\t{\n\t\t\t\tType:   \"mockCallback\",\n\t\t\t\tID:     \"mock\",\n\t\t\t\tName:   \"Example\",\n\t\t\t\tConfig: &mock.CallbackConfig{},\n\t\t\t},\n\t\t},\n\t}\n\tif err := configuration.Validate(); err != nil {\n\t\tt.Fatalf(\"this configuration should have been valid: %v\", err)\n\t}\n}\n\nfunc TestInvalidConfiguration(t *testing.T) {\n\tconfiguration := Config{}\n\terr := configuration.Validate()\n\tif err == nil {\n\t\tt.Fatal(\"this configuration should be invalid\")\n\t}\n\tgot := err.Error()\n\twanted := `invalid Config:\n\t-\tno issuer specified in config file\n\t-\tno storage supplied in config file\n\t-\tmust supply a HTTP/HTTPS  address to listen on`\n\tif got != wanted {\n\t\tt.Fatalf(\"Expected error message to be %q, got %q\", wanted, got)\n\t}\n}\n\nfunc TestUnmarshalConfig(t *testing.T) {\n\trawConfig := []byte(`\nissuer: http://127.0.0.1:5556/dex\nstorage:\n  type: postgres\n  config:\n    host: 10.0.0.1\n    port: 65432\n    maxOpenConns: 5\n    maxIdleConns: 3\n    connMaxLifetime: 30\n    connectionTimeout: 3\nweb:\n  https: 127.0.0.1:5556\n  tlsMinVersion: 1.3\n  tlsMaxVersion: 1.2\n\nfrontend:\n  dir: ./web\n  extra:\n    foo: bar\n\nstaticClients:\n- id: example-app\n  redirectURIs:\n  - 'http://127.0.0.1:5555/callback'\n  name: 'Example App'\n  secret: ZXhhbXBsZS1hcHAtc2VjcmV0\n\noauth2:\n  alwaysShowLoginScreen: true\n  grantTypes:\n  - refresh_token\n  - \"urn:ietf:params:oauth:grant-type:token-exchange\"\n\nconnectors:\n- type: mockCallback\n  id: mock\n  name: Example\n- type: oidc\n  id: google\n  name: Google\n  config:\n    issuer: https://accounts.google.com\n    clientID: foo\n    clientSecret: bar\n    redirectURI: http://127.0.0.1:5556/dex/callback/google\n\nenablePasswordDB: true\nstaticPasswords:\n- email: \"admin@example.com\"\n  # bcrypt hash of the string \"password\"\n  hash: \"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"\n  username: \"admin\"\n  userID: \"08a8684b-db88-4b73-90a9-3cd1661f5466\"\n- email: \"foo@example.com\"\n  # base64'd value of the same bcrypt hash above. We want to be able to parse both of these\n  hash: \"JDJhJDEwJDMzRU1UMGNWWVZsUHk2V0FNQ0xzY2VMWWpXaHVIcGJ6NXl1Wnh1L0dBRmowM0o5THl0anV5\"\n  username: \"foo\"\n  userID: \"41331323-6f44-45e6-b3b9-2c4b60c02be5\"\n\nexpiry:\n  signingKeys: \"7h\"\n  idTokens: \"25h\"\n  authRequests: \"25h\"\n  deviceRequests: \"10m\"\n\nlogger:\n  level: \"debug\"\n  format: \"json\"\n`)\n\n\twant := Config{\n\t\tIssuer: \"http://127.0.0.1:5556/dex\",\n\t\tStorage: Storage{\n\t\t\tType: \"postgres\",\n\t\t\tConfig: &sql.Postgres{\n\t\t\t\tNetworkDB: sql.NetworkDB{\n\t\t\t\t\tHost:              \"10.0.0.1\",\n\t\t\t\t\tPort:              65432,\n\t\t\t\t\tMaxOpenConns:      5,\n\t\t\t\t\tMaxIdleConns:      3,\n\t\t\t\t\tConnMaxLifetime:   30,\n\t\t\t\t\tConnectionTimeout: 3,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tWeb: Web{\n\t\t\tHTTPS:         \"127.0.0.1:5556\",\n\t\t\tTLSMinVersion: \"1.3\",\n\t\t\tTLSMaxVersion: \"1.2\",\n\t\t},\n\t\tFrontend: server.WebConfig{\n\t\t\tDir: \"./web\",\n\t\t\tExtra: map[string]string{\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t\tStaticClients: []storage.Client{\n\t\t\t{\n\t\t\t\tID:     \"example-app\",\n\t\t\t\tSecret: \"ZXhhbXBsZS1hcHAtc2VjcmV0\",\n\t\t\t\tName:   \"Example App\",\n\t\t\t\tRedirectURIs: []string{\n\t\t\t\t\t\"http://127.0.0.1:5555/callback\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tOAuth2: OAuth2{\n\t\t\tAlwaysShowLoginScreen: true,\n\t\t\tGrantTypes: []string{\n\t\t\t\t\"refresh_token\",\n\t\t\t\t\"urn:ietf:params:oauth:grant-type:token-exchange\",\n\t\t\t},\n\t\t},\n\t\tStaticConnectors: []Connector{\n\t\t\t{\n\t\t\t\tType:   \"mockCallback\",\n\t\t\t\tID:     \"mock\",\n\t\t\t\tName:   \"Example\",\n\t\t\t\tConfig: &mock.CallbackConfig{},\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"oidc\",\n\t\t\t\tID:   \"google\",\n\t\t\t\tName: \"Google\",\n\t\t\t\tConfig: &oidc.Config{\n\t\t\t\t\tIssuer:       \"https://accounts.google.com\",\n\t\t\t\t\tClientID:     \"foo\",\n\t\t\t\t\tClientSecret: \"bar\",\n\t\t\t\t\tRedirectURI:  \"http://127.0.0.1:5556/dex/callback/google\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tEnablePasswordDB: true,\n\t\tStaticPasswords: []password{\n\t\t\t{\n\t\t\t\tEmail:    \"admin@example.com\",\n\t\t\t\tHash:     []byte(\"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"),\n\t\t\t\tUsername: \"admin\",\n\t\t\t\tUserID:   \"08a8684b-db88-4b73-90a9-3cd1661f5466\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tEmail:    \"foo@example.com\",\n\t\t\t\tHash:     []byte(\"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"),\n\t\t\t\tUsername: \"foo\",\n\t\t\t\tUserID:   \"41331323-6f44-45e6-b3b9-2c4b60c02be5\",\n\t\t\t},\n\t\t},\n\t\tExpiry: Expiry{\n\t\t\tSigningKeys:    \"7h\",\n\t\t\tIDTokens:       \"25h\",\n\t\t\tAuthRequests:   \"25h\",\n\t\t\tDeviceRequests: \"10m\",\n\t\t},\n\t\tLogger: Logger{\n\t\t\tLevel:  \"debug\",\n\t\t\tFormat: \"json\",\n\t\t},\n\t}\n\n\tvar c Config\n\tif err := yaml.Unmarshal(rawConfig, &c); err != nil {\n\t\tt.Fatalf(\"failed to decode config: %v\", err)\n\t}\n\tif diff := pretty.Compare(c, want); diff != \"\" {\n\t\tt.Errorf(\"got!=want: %s\", diff)\n\t}\n}\n\nfunc TestUnmarshalConfigWithEnvNoExpand(t *testing.T) {\n\t// If the env variable DEX_EXPAND_ENV is set and has a \"falsy\" value, os.ExpandEnv is disabled.\n\t// ParseBool: \"It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\"\n\tcheckUnmarshalConfigWithEnv(t, \"0\", false)\n\tcheckUnmarshalConfigWithEnv(t, \"f\", false)\n\tcheckUnmarshalConfigWithEnv(t, \"F\", false)\n\tcheckUnmarshalConfigWithEnv(t, \"FALSE\", false)\n\tcheckUnmarshalConfigWithEnv(t, \"false\", false)\n\tcheckUnmarshalConfigWithEnv(t, \"False\", false)\n\tos.Unsetenv(\"DEX_EXPAND_ENV\")\n}\n\nfunc TestUnmarshalConfigWithEnvExpand(t *testing.T) {\n\t// If the env variable DEX_EXPAND_ENV is unset or has a \"truthy\" or unknown value, os.ExpandEnv is enabled.\n\t// ParseBool: \"It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\"\n\tcheckUnmarshalConfigWithEnv(t, \"1\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"t\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"T\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"TRUE\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"true\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"True\", true)\n\t// Values that can't be parsed as bool:\n\tcheckUnmarshalConfigWithEnv(t, \"UNSET\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"\", true)\n\tcheckUnmarshalConfigWithEnv(t, \"whatever - true is default\", true)\n\tos.Unsetenv(\"DEX_EXPAND_ENV\")\n}\n\nfunc checkUnmarshalConfigWithEnv(t *testing.T, dexExpandEnv string, wantExpandEnv bool) {\n\t// For hashFromEnv:\n\tos.Setenv(\"DEX_FOO_USER_PASSWORD\", \"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\")\n\t// For os.ExpandEnv ($VAR -> value_of_VAR):\n\tos.Setenv(\"DEX_FOO_POSTGRES_HOST\", \"10.0.0.1\")\n\tos.Setenv(\"DEX_FOO_OIDC_CLIENT_SECRET\", \"bar\")\n\tif dexExpandEnv != \"UNSET\" {\n\t\tos.Setenv(\"DEX_EXPAND_ENV\", dexExpandEnv)\n\t} else {\n\t\tos.Unsetenv(\"DEX_EXPAND_ENV\")\n\t}\n\n\trawConfig := []byte(`\nissuer: http://127.0.0.1:5556/dex\nstorage:\n  type: postgres\n  config:\n    # Env variables are expanded in raw YAML source.\n    # Single quotes work fine, as long as the env variable doesn't contain any.\n    host: '$DEX_FOO_POSTGRES_HOST'\n    port: 65432\n    maxOpenConns: 5\n    maxIdleConns: 3\n    connMaxLifetime: 30\n    connectionTimeout: 3\nweb:\n  http: 127.0.0.1:5556\n\nfrontend:\n  dir: ./web\n  extra:\n    foo: bar\n\nstaticClients:\n- id: example-app\n  redirectURIs:\n  - 'http://127.0.0.1:5555/callback'\n  name: 'Example App'\n  secret: ZXhhbXBsZS1hcHAtc2VjcmV0\n\noauth2:\n  alwaysShowLoginScreen: true\n\nconnectors:\n- type: mockCallback\n  id: mock\n  name: Example\n- type: oidc\n  id: google\n  name: Google\n  config:\n    issuer: https://accounts.google.com\n    clientID: foo\n    # Env variables are expanded in raw YAML source.\n    # Single quotes work fine, as long as the env variable doesn't contain any.\n    clientSecret: '$DEX_FOO_OIDC_CLIENT_SECRET'\n    redirectURI: http://127.0.0.1:5556/dex/callback/google\n\nenablePasswordDB: true\nstaticPasswords:\n- email: \"admin@example.com\"\n  # bcrypt hash of the string \"password\"\n  hash: \"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"\n  username: \"admin\"\n  userID: \"08a8684b-db88-4b73-90a9-3cd1661f5466\"\n- email: \"foo@example.com\"\n  hashFromEnv: \"DEX_FOO_USER_PASSWORD\"\n  username: \"foo\"\n  userID: \"41331323-6f44-45e6-b3b9-2c4b60c02be5\"\n\nexpiry:\n  signingKeys: \"7h\"\n  idTokens: \"25h\"\n  authRequests: \"25h\"\n\nlogger:\n  level: \"debug\"\n  format: \"json\"\n`)\n\n\t// This is not a valid hostname. It's only used to check whether os.ExpandEnv was applied or not.\n\twantPostgresHost := \"$DEX_FOO_POSTGRES_HOST\"\n\twantOidcClientSecret := \"$DEX_FOO_OIDC_CLIENT_SECRET\"\n\tif wantExpandEnv {\n\t\twantPostgresHost = \"10.0.0.1\"\n\t\twantOidcClientSecret = \"bar\"\n\t}\n\n\twant := Config{\n\t\tIssuer: \"http://127.0.0.1:5556/dex\",\n\t\tStorage: Storage{\n\t\t\tType: \"postgres\",\n\t\t\tConfig: &sql.Postgres{\n\t\t\t\tNetworkDB: sql.NetworkDB{\n\t\t\t\t\tHost:              wantPostgresHost,\n\t\t\t\t\tPort:              65432,\n\t\t\t\t\tMaxOpenConns:      5,\n\t\t\t\t\tMaxIdleConns:      3,\n\t\t\t\t\tConnMaxLifetime:   30,\n\t\t\t\t\tConnectionTimeout: 3,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tWeb: Web{\n\t\t\tHTTP: \"127.0.0.1:5556\",\n\t\t},\n\t\tFrontend: server.WebConfig{\n\t\t\tDir: \"./web\",\n\t\t\tExtra: map[string]string{\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t\tStaticClients: []storage.Client{\n\t\t\t{\n\t\t\t\tID:     \"example-app\",\n\t\t\t\tSecret: \"ZXhhbXBsZS1hcHAtc2VjcmV0\",\n\t\t\t\tName:   \"Example App\",\n\t\t\t\tRedirectURIs: []string{\n\t\t\t\t\t\"http://127.0.0.1:5555/callback\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tOAuth2: OAuth2{\n\t\t\tAlwaysShowLoginScreen: true,\n\t\t},\n\t\tStaticConnectors: []Connector{\n\t\t\t{\n\t\t\t\tType:   \"mockCallback\",\n\t\t\t\tID:     \"mock\",\n\t\t\t\tName:   \"Example\",\n\t\t\t\tConfig: &mock.CallbackConfig{},\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"oidc\",\n\t\t\t\tID:   \"google\",\n\t\t\t\tName: \"Google\",\n\t\t\t\tConfig: &oidc.Config{\n\t\t\t\t\tIssuer:       \"https://accounts.google.com\",\n\t\t\t\t\tClientID:     \"foo\",\n\t\t\t\t\tClientSecret: wantOidcClientSecret,\n\t\t\t\t\tRedirectURI:  \"http://127.0.0.1:5556/dex/callback/google\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tEnablePasswordDB: true,\n\t\tStaticPasswords: []password{\n\t\t\t{\n\t\t\t\tEmail:    \"admin@example.com\",\n\t\t\t\tHash:     []byte(\"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"),\n\t\t\t\tUsername: \"admin\",\n\t\t\t\tUserID:   \"08a8684b-db88-4b73-90a9-3cd1661f5466\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tEmail:    \"foo@example.com\",\n\t\t\t\tHash:     []byte(\"$2a$10$33EMT0cVYVlPy6WAMCLsceLYjWhuHpbz5yuZxu/GAFj03J9Lytjuy\"),\n\t\t\t\tUsername: \"foo\",\n\t\t\t\tUserID:   \"41331323-6f44-45e6-b3b9-2c4b60c02be5\",\n\t\t\t},\n\t\t},\n\t\tExpiry: Expiry{\n\t\t\tSigningKeys:  \"7h\",\n\t\t\tIDTokens:     \"25h\",\n\t\t\tAuthRequests: \"25h\",\n\t\t},\n\t\tLogger: Logger{\n\t\t\tLevel:  \"debug\",\n\t\t\tFormat: \"json\",\n\t\t},\n\t}\n\n\tvar c Config\n\tif err := yaml.Unmarshal(rawConfig, &c); err != nil {\n\t\tt.Fatalf(\"failed to decode config: %v\", err)\n\t}\n\tif diff := pretty.Compare(c, want); diff != \"\" {\n\t\tt.Errorf(\"got!=want: %s\", diff)\n\t}\n}\n", "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\n\tgosundheit \"github.com/AppsFlyer/go-sundheit\"\n\t\"github.com/AppsFlyer/go-sundheit/checks\"\n\tgosundheithttp \"github.com/AppsFlyer/go-sundheit/http\"\n\t\"github.com/fsnotify/fsnotify\"\n\t\"github.com/ghodss/yaml\"\n\tgrpcprometheus \"github.com/grpc-ecosystem/go-grpc-prometheus\"\n\t\"github.com/oklog/run\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/collectors\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/spf13/cobra\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/reflection\"\n\n\t\"github.com/dexidp/dex/api/v2\"\n\t\"github.com/dexidp/dex/pkg/log\"\n\t\"github.com/dexidp/dex/server\"\n\t\"github.com/dexidp/dex/storage\"\n)\n\ntype serveOptions struct {\n\t// Config file path\n\tconfig string\n\n\t// Flags\n\twebHTTPAddr   string\n\twebHTTPSAddr  string\n\ttelemetryAddr string\n\tgrpcAddr      string\n}\n\nfunc commandServe() *cobra.Command {\n\toptions := serveOptions{}\n\n\tcmd := &cobra.Command{\n\t\tUse:     \"serve [flags] [config file]\",\n\t\tShort:   \"Launch Dex\",\n\t\tExample: \"dex serve config.yaml\",\n\t\tArgs:    cobra.ExactArgs(1),\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tcmd.SilenceUsage = true\n\t\t\tcmd.SilenceErrors = true\n\n\t\t\toptions.config = args[0]\n\n\t\t\treturn runServe(options)\n\t\t},\n\t}\n\n\tflags := cmd.Flags()\n\n\tflags.StringVar(&options.webHTTPAddr, \"web-http-addr\", \"\", \"Web HTTP address\")\n\tflags.StringVar(&options.webHTTPSAddr, \"web-https-addr\", \"\", \"Web HTTPS address\")\n\tflags.StringVar(&options.telemetryAddr, \"telemetry-addr\", \"\", \"Telemetry address\")\n\tflags.StringVar(&options.grpcAddr, \"grpc-addr\", \"\", \"gRPC API address\")\n\n\treturn cmd\n}\n\nfunc runServe(options serveOptions) error {\n\tconfigFile := options.config\n\tconfigData, err := os.ReadFile(configFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read config file %s: %v\", configFile, err)\n\t}\n\n\tvar c Config\n\tif err := yaml.Unmarshal(configData, &c); err != nil {\n\t\treturn fmt.Errorf(\"error parse config file %s: %v\", configFile, err)\n\t}\n\n\tapplyConfigOverrides(options, &c)\n\n\tlogger, err := newLogger(c.Logger.Level, c.Logger.Format)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid config: %v\", err)\n\t}\n\n\tlogger.Infof(\n\t\t\"Dex Version: %s, Go Version: %s, Go OS/ARCH: %s %s\",\n\t\tversion,\n\t\truntime.Version(),\n\t\truntime.GOOS,\n\t\truntime.GOARCH,\n\t)\n\n\tif c.Logger.Level != \"\" {\n\t\tlogger.Infof(\"config using log level: %s\", c.Logger.Level)\n\t}\n\tif err := c.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tlogger.Infof(\"config issuer: %s\", c.Issuer)\n\n\tprometheusRegistry := prometheus.NewRegistry()\n\terr = prometheusRegistry.Register(collectors.NewGoCollector())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to register Go runtime metrics: %v\", err)\n\t}\n\n\terr = prometheusRegistry.Register(collectors.NewProcessCollector(collectors.ProcessCollectorOpts{}))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to register process metrics: %v\", err)\n\t}\n\n\tgrpcMetrics := grpcprometheus.NewServerMetrics()\n\terr = prometheusRegistry.Register(grpcMetrics)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to register gRPC server metrics: %v\", err)\n\t}\n\n\tvar grpcOptions []grpc.ServerOption\n\n\tallowedTLSCiphers := []uint16{\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n\t\ttls.TLS_RSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t}\n\n\tallowedTLSVersions := map[string]int{\n\t\t\"1.2\": tls.VersionTLS12,\n\t\t\"1.3\": tls.VersionTLS13,\n\t}\n\n\tif c.GRPC.TLSCert != \"\" {\n\t\ttlsMinVersion := tls.VersionTLS12\n\t\tif c.GRPC.TLSMinVersion != \"\" {\n\t\t\ttlsMinVersion = allowedTLSVersions[c.GRPC.TLSMinVersion]\n\t\t}\n\t\ttlsMaxVersion := 0 // default for max is whatever Go defaults to\n\t\tif c.GRPC.TLSMaxVersion != \"\" {\n\t\t\ttlsMaxVersion = allowedTLSVersions[c.GRPC.TLSMaxVersion]\n\t\t}\n\t\tbaseTLSConfig := &tls.Config{\n\t\t\tMinVersion:               uint16(tlsMinVersion),\n\t\t\tMaxVersion:               uint16(tlsMaxVersion),\n\t\t\tCipherSuites:             allowedTLSCiphers,\n\t\t\tPreferServerCipherSuites: true,\n\t\t}\n\n\t\ttlsConfig, err := newTLSReloader(logger, c.GRPC.TLSCert, c.GRPC.TLSKey, c.GRPC.TLSClientCA, baseTLSConfig)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config: get gRPC TLS: %v\", err)\n\t\t}\n\n\t\tif c.GRPC.TLSClientCA != \"\" {\n\t\t\t// Only add metrics if client auth is enabled\n\t\t\tgrpcOptions = append(grpcOptions,\n\t\t\t\tgrpc.StreamInterceptor(grpcMetrics.StreamServerInterceptor()),\n\t\t\t\tgrpc.UnaryInterceptor(grpcMetrics.UnaryServerInterceptor()),\n\t\t\t)\n\t\t}\n\n\t\tgrpcOptions = append(grpcOptions, grpc.Creds(credentials.NewTLS(tlsConfig)))\n\t}\n\n\ts, err := c.Storage.Config.Open(logger)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to initialize storage: %v\", err)\n\t}\n\tdefer s.Close()\n\n\tlogger.Infof(\"config storage: %s\", c.Storage.Type)\n\n\tif len(c.StaticClients) > 0 {\n\t\tfor i, client := range c.StaticClients {\n\t\t\tif client.Name == \"\" {\n\t\t\t\treturn fmt.Errorf(\"invalid config: Name field is required for a client\")\n\t\t\t}\n\t\t\tif client.ID == \"\" && client.IDEnv == \"\" {\n\t\t\t\treturn fmt.Errorf(\"invalid config: ID or IDEnv field is required for a client\")\n\t\t\t}\n\t\t\tif client.IDEnv != \"\" {\n\t\t\t\tif client.ID != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\"invalid config: ID and IDEnv fields are exclusive for client %q\", client.ID)\n\t\t\t\t}\n\t\t\t\tc.StaticClients[i].ID = os.Getenv(client.IDEnv)\n\t\t\t}\n\t\t\tif client.Secret == \"\" && client.SecretEnv == \"\" && !client.Public {\n\t\t\t\treturn fmt.Errorf(\"invalid config: Secret or SecretEnv field is required for client %q\", client.ID)\n\t\t\t}\n\t\t\tif client.SecretEnv != \"\" {\n\t\t\t\tif client.Secret != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\"invalid config: Secret and SecretEnv fields are exclusive for client %q\", client.ID)\n\t\t\t\t}\n\t\t\t\tc.StaticClients[i].Secret = os.Getenv(client.SecretEnv)\n\t\t\t}\n\t\t\tlogger.Infof(\"config static client: %s\", client.Name)\n\t\t}\n\t\ts = storage.WithStaticClients(s, c.StaticClients)\n\t}\n\tif len(c.StaticPasswords) > 0 {\n\t\tpasswords := make([]storage.Password, len(c.StaticPasswords))\n\t\tfor i, p := range c.StaticPasswords {\n\t\t\tpasswords[i] = storage.Password(p)\n\t\t}\n\t\ts = storage.WithStaticPasswords(s, passwords, logger)\n\t}\n\n\tstorageConnectors := make([]storage.Connector, len(c.StaticConnectors))\n\tfor i, c := range c.StaticConnectors {\n\t\tif c.ID == \"\" || c.Name == \"\" || c.Type == \"\" {\n\t\t\treturn fmt.Errorf(\"invalid config: ID, Type and Name fields are required for a connector\")\n\t\t}\n\t\tif c.Config == nil {\n\t\t\treturn fmt.Errorf(\"invalid config: no config field for connector %q\", c.ID)\n\t\t}\n\t\tlogger.Infof(\"config connector: %s\", c.ID)\n\n\t\t// convert to a storage connector object\n\t\tconn, err := ToStorageConnector(c)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to initialize storage connectors: %v\", err)\n\t\t}\n\t\tstorageConnectors[i] = conn\n\t}\n\n\tif c.EnablePasswordDB {\n\t\tstorageConnectors = append(storageConnectors, storage.Connector{\n\t\t\tID:   server.LocalConnector,\n\t\t\tName: \"Email\",\n\t\t\tType: server.LocalConnector,\n\t\t})\n\t\tlogger.Infof(\"config connector: local passwords enabled\")\n\t}\n\n\ts = storage.WithStaticConnectors(s, storageConnectors)\n\n\tif len(c.OAuth2.ResponseTypes) > 0 {\n\t\tlogger.Infof(\"config response types accepted: %s\", c.OAuth2.ResponseTypes)\n\t}\n\tif c.OAuth2.SkipApprovalScreen {\n\t\tlogger.Infof(\"config skipping approval screen\")\n\t}\n\tif c.OAuth2.PasswordConnector != \"\" {\n\t\tlogger.Infof(\"config using password grant connector: %s\", c.OAuth2.PasswordConnector)\n\t}\n\tif len(c.Web.AllowedOrigins) > 0 {\n\t\tlogger.Infof(\"config allowed origins: %s\", c.Web.AllowedOrigins)\n\t}\n\n\t// explicitly convert to UTC.\n\tnow := func() time.Time { return time.Now().UTC() }\n\n\thealthChecker := gosundheit.New()\n\n\tserverConfig := server.Config{\n\t\tAllowedGrantTypes:      c.OAuth2.GrantTypes,\n\t\tSupportedResponseTypes: c.OAuth2.ResponseTypes,\n\t\tSkipApprovalScreen:     c.OAuth2.SkipApprovalScreen,\n\t\tAlwaysShowLoginScreen:  c.OAuth2.AlwaysShowLoginScreen,\n\t\tPasswordConnector:      c.OAuth2.PasswordConnector,\n\t\tAllowedOrigins:         c.Web.AllowedOrigins,\n\t\tAllowedHeaders:         c.Web.AllowedHeaders,\n\t\tIssuer:                 c.Issuer,\n\t\tStorage:                s,\n\t\tWeb:                    c.Frontend,\n\t\tLogger:                 logger,\n\t\tNow:                    now,\n\t\tPrometheusRegistry:     prometheusRegistry,\n\t\tHealthChecker:          healthChecker,\n\t}\n\tif c.Expiry.SigningKeys != \"\" {\n\t\tsigningKeys, err := time.ParseDuration(c.Expiry.SigningKeys)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config value %q for signing keys expiry: %v\", c.Expiry.SigningKeys, err)\n\t\t}\n\t\tlogger.Infof(\"config signing keys expire after: %v\", signingKeys)\n\t\tserverConfig.RotateKeysAfter = signingKeys\n\t}\n\tif c.Expiry.IDTokens != \"\" {\n\t\tidTokens, err := time.ParseDuration(c.Expiry.IDTokens)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config value %q for id token expiry: %v\", c.Expiry.IDTokens, err)\n\t\t}\n\t\tlogger.Infof(\"config id tokens valid for: %v\", idTokens)\n\t\tserverConfig.IDTokensValidFor = idTokens\n\t}\n\tif c.Expiry.AuthRequests != \"\" {\n\t\tauthRequests, err := time.ParseDuration(c.Expiry.AuthRequests)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config value %q for auth request expiry: %v\", c.Expiry.AuthRequests, err)\n\t\t}\n\t\tlogger.Infof(\"config auth requests valid for: %v\", authRequests)\n\t\tserverConfig.AuthRequestsValidFor = authRequests\n\t}\n\tif c.Expiry.DeviceRequests != \"\" {\n\t\tdeviceRequests, err := time.ParseDuration(c.Expiry.DeviceRequests)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config value %q for device request expiry: %v\", c.Expiry.AuthRequests, err)\n\t\t}\n\t\tlogger.Infof(\"config device requests valid for: %v\", deviceRequests)\n\t\tserverConfig.DeviceRequestsValidFor = deviceRequests\n\t}\n\trefreshTokenPolicy, err := server.NewRefreshTokenPolicy(\n\t\tlogger,\n\t\tc.Expiry.RefreshTokens.DisableRotation,\n\t\tc.Expiry.RefreshTokens.ValidIfNotUsedFor,\n\t\tc.Expiry.RefreshTokens.AbsoluteLifetime,\n\t\tc.Expiry.RefreshTokens.ReuseInterval,\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid refresh token expiration policy config: %v\", err)\n\t}\n\n\tserverConfig.RefreshTokenPolicy = refreshTokenPolicy\n\tserv, err := server.NewServer(context.Background(), serverConfig)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to initialize server: %v\", err)\n\t}\n\n\ttelemetryRouter := http.NewServeMux()\n\ttelemetryRouter.Handle(\"/metrics\", promhttp.HandlerFor(prometheusRegistry, promhttp.HandlerOpts{}))\n\n\t// Configure health checker\n\t{\n\t\thandler := gosundheithttp.HandleHealthJSON(healthChecker)\n\t\ttelemetryRouter.Handle(\"/healthz\", handler)\n\n\t\t// Kubernetes style health checks\n\t\ttelemetryRouter.HandleFunc(\"/healthz/live\", func(w http.ResponseWriter, _ *http.Request) {\n\t\t\t_, _ = w.Write([]byte(\"ok\"))\n\t\t})\n\t\ttelemetryRouter.Handle(\"/healthz/ready\", handler)\n\t}\n\n\thealthChecker.RegisterCheck(\n\t\t&checks.CustomCheck{\n\t\t\tCheckName: \"storage\",\n\t\t\tCheckFunc: storage.NewCustomHealthCheckFunc(serverConfig.Storage, serverConfig.Now),\n\t\t},\n\t\tgosundheit.ExecutionPeriod(15*time.Second),\n\t\tgosundheit.InitiallyPassing(true),\n\t)\n\n\tvar group run.Group\n\n\t// Set up telemetry server\n\tif c.Telemetry.HTTP != \"\" {\n\t\tconst name = \"telemetry\"\n\n\t\tlogger.Infof(\"listening (%s) on %s\", name, c.Telemetry.HTTP)\n\n\t\tl, err := net.Listen(\"tcp\", c.Telemetry.HTTP)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"listening (%s) on %s: %v\", name, c.Telemetry.HTTP, err)\n\t\t}\n\n\t\tif c.Telemetry.EnableProfiling {\n\t\t\tpprofHandler(telemetryRouter)\n\t\t}\n\n\t\tserver := &http.Server{\n\t\t\tHandler: telemetryRouter,\n\t\t}\n\t\tdefer server.Close()\n\n\t\tgroup.Add(func() error {\n\t\t\treturn server.Serve(l)\n\t\t}, func(err error) {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\t\t\tdefer cancel()\n\n\t\t\tlogger.Debugf(\"starting graceful shutdown (%s)\", name)\n\t\t\tif err := server.Shutdown(ctx); err != nil {\n\t\t\t\tlogger.Errorf(\"graceful shutdown (%s): %v\", name, err)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Set up http server\n\tif c.Web.HTTP != \"\" {\n\t\tconst name = \"http\"\n\n\t\tlogger.Infof(\"listening (%s) on %s\", name, c.Web.HTTP)\n\n\t\tl, err := net.Listen(\"tcp\", c.Web.HTTP)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"listening (%s) on %s: %v\", name, c.Web.HTTP, err)\n\t\t}\n\n\t\tserver := &http.Server{\n\t\t\tHandler: serv,\n\t\t}\n\t\tdefer server.Close()\n\n\t\tgroup.Add(func() error {\n\t\t\treturn server.Serve(l)\n\t\t}, func(err error) {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\t\t\tdefer cancel()\n\n\t\t\tlogger.Debugf(\"starting graceful shutdown (%s)\", name)\n\t\t\tif err := server.Shutdown(ctx); err != nil {\n\t\t\t\tlogger.Errorf(\"graceful shutdown (%s): %v\", name, err)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Set up https server\n\tif c.Web.HTTPS != \"\" {\n\t\tconst name = \"https\"\n\n\t\tlogger.Infof(\"listening (%s) on %s\", name, c.Web.HTTPS)\n\n\t\tl, err := net.Listen(\"tcp\", c.Web.HTTPS)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"listening (%s) on %s: %v\", name, c.Web.HTTPS, err)\n\t\t}\n\n\t\ttlsMinVersion := tls.VersionTLS12\n\t\tif c.Web.TLSMinVersion != \"\" {\n\t\t\ttlsMinVersion = allowedTLSVersions[c.Web.TLSMinVersion]\n\t\t}\n\t\ttlsMaxVersion := 0 // default for max is whatever Go defaults to\n\t\tif c.Web.TLSMaxVersion != \"\" {\n\t\t\ttlsMaxVersion = allowedTLSVersions[c.Web.TLSMaxVersion]\n\t\t}\n\n\t\tbaseTLSConfig := &tls.Config{\n\t\t\tMinVersion:               uint16(tlsMinVersion),\n\t\t\tMaxVersion:               uint16(tlsMaxVersion),\n\t\t\tCipherSuites:             allowedTLSCiphers,\n\t\t\tPreferServerCipherSuites: true,\n\t\t}\n\n\t\ttlsConfig, err := newTLSReloader(logger, c.Web.TLSCert, c.Web.TLSKey, \"\", baseTLSConfig)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid config: get HTTP TLS: %v\", err)\n\t\t}\n\n\t\tserver := &http.Server{\n\t\t\tHandler:   serv,\n\t\t\tTLSConfig: tlsConfig,\n\t\t}\n\t\tdefer server.Close()\n\n\t\tgroup.Add(func() error {\n\t\t\treturn server.ServeTLS(l, \"\", \"\")\n\t\t}, func(err error) {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\t\t\tdefer cancel()\n\n\t\t\tlogger.Debugf(\"starting graceful shutdown (%s)\", name)\n\t\t\tif err := server.Shutdown(ctx); err != nil {\n\t\t\t\tlogger.Errorf(\"graceful shutdown (%s): %v\", name, err)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Set up grpc server\n\tif c.GRPC.Addr != \"\" {\n\t\tlogger.Infof(\"listening (grpc) on %s\", c.GRPC.Addr)\n\n\t\tgrpcListener, err := net.Listen(\"tcp\", c.GRPC.Addr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"listening (grcp) on %s: %w\", c.GRPC.Addr, err)\n\t\t}\n\n\t\tgrpcSrv := grpc.NewServer(grpcOptions...)\n\t\tapi.RegisterDexServer(grpcSrv, server.NewAPI(serverConfig.Storage, logger, version))\n\n\t\tgrpcMetrics.InitializeMetrics(grpcSrv)\n\t\tif c.GRPC.Reflection {\n\t\t\tlogger.Info(\"enabling reflection in grpc service\")\n\t\t\treflection.Register(grpcSrv)\n\t\t}\n\n\t\tgroup.Add(func() error {\n\t\t\treturn grpcSrv.Serve(grpcListener)\n\t\t}, func(err error) {\n\t\t\tlogger.Debugf(\"starting graceful shutdown (grpc)\")\n\t\t\tgrpcSrv.GracefulStop()\n\t\t})\n\t}\n\n\tgroup.Add(run.SignalHandler(context.Background(), os.Interrupt, syscall.SIGTERM))\n\tif err := group.Run(); err != nil {\n\t\tif _, ok := err.(run.SignalError); !ok {\n\t\t\treturn fmt.Errorf(\"run groups: %w\", err)\n\t\t}\n\t\tlogger.Infof(\"%v, shutdown now\", err)\n\t}\n\treturn nil\n}\n\nvar (\n\tlogLevels  = []string{\"debug\", \"info\", \"error\"}\n\tlogFormats = []string{\"json\", \"text\"}\n)\n\ntype utcFormatter struct {\n\tf logrus.Formatter\n}\n\nfunc (f *utcFormatter) Format(e *logrus.Entry) ([]byte, error) {\n\te.Time = e.Time.UTC()\n\treturn f.f.Format(e)\n}\n\nfunc newLogger(level string, format string) (log.Logger, error) {\n\tvar logLevel logrus.Level\n\tswitch strings.ToLower(level) {\n\tcase \"debug\":\n\t\tlogLevel = logrus.DebugLevel\n\tcase \"\", \"info\":\n\t\tlogLevel = logrus.InfoLevel\n\tcase \"error\":\n\t\tlogLevel = logrus.ErrorLevel\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"log level is not one of the supported values (%s): %s\", strings.Join(logLevels, \", \"), level)\n\t}\n\n\tvar formatter utcFormatter\n\tswitch strings.ToLower(format) {\n\tcase \"\", \"text\":\n\t\tformatter.f = &logrus.TextFormatter{DisableColors: true}\n\tcase \"json\":\n\t\tformatter.f = &logrus.JSONFormatter{}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"log format is not one of the supported values (%s): %s\", strings.Join(logFormats, \", \"), format)\n\t}\n\n\treturn &logrus.Logger{\n\t\tOut:       os.Stderr,\n\t\tFormatter: &formatter,\n\t\tLevel:     logLevel,\n\t}, nil\n}\n\nfunc applyConfigOverrides(options serveOptions, config *Config) {\n\tif options.webHTTPAddr != \"\" {\n\t\tconfig.Web.HTTP = options.webHTTPAddr\n\t}\n\n\tif options.webHTTPSAddr != \"\" {\n\t\tconfig.Web.HTTPS = options.webHTTPSAddr\n\t}\n\n\tif options.telemetryAddr != \"\" {\n\t\tconfig.Telemetry.HTTP = options.telemetryAddr\n\t}\n\n\tif options.grpcAddr != \"\" {\n\t\tconfig.GRPC.Addr = options.grpcAddr\n\t}\n\n\tif config.Frontend.Dir == \"\" {\n\t\tconfig.Frontend.Dir = os.Getenv(\"DEX_FRONTEND_DIR\")\n\t}\n\n\tif len(config.OAuth2.GrantTypes) == 0 {\n\t\tconfig.OAuth2.GrantTypes = []string{\n\t\t\t\"authorization_code\",\n\t\t\t\"implicit\",\n\t\t\t\"password\",\n\t\t\t\"refresh_token\",\n\t\t\t\"urn:ietf:params:oauth:grant-type:device_code\",\n\t\t\t\"urn:ietf:params:oauth:grant-type:token-exchange\",\n\t\t}\n\t}\n}\n\nfunc pprofHandler(router *http.ServeMux) {\n\trouter.HandleFunc(\"/debug/pprof/\", pprof.Index)\n\trouter.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline)\n\trouter.HandleFunc(\"/debug/pprof/profile\", pprof.Profile)\n\trouter.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol)\n\trouter.HandleFunc(\"/debug/pprof/trace\", pprof.Trace)\n}\n\n// newTLSReloader returns a [tls.Config] with GetCertificate or GetConfigForClient set\n// to reload certificates from the given paths on SIGHUP or on file creates (atomic update via rename).\nfunc newTLSReloader(logger log.Logger, certFile, keyFile, caFile string, baseConfig *tls.Config) (*tls.Config, error) {\n\t// trigger reload on channel\n\tsigc := make(chan os.Signal, 1)\n\tsignal.Notify(sigc, syscall.SIGHUP)\n\n\t// files to watch\n\twatchFiles := map[string]struct{}{\n\t\tcertFile: {},\n\t\tkeyFile:  {},\n\t}\n\tif caFile != \"\" {\n\t\twatchFiles[caFile] = struct{}{}\n\t}\n\twatchDirs := make(map[string]struct{}) // dedupe dirs\n\tfor f := range watchFiles {\n\t\tdir := filepath.Dir(f)\n\t\tif !strings.HasPrefix(f, dir) {\n\t\t\t// normalize name to have ./ prefix if only a local path was provided\n\t\t\t// can't pass \"\" to watcher.Add\n\t\t\twatchFiles[dir+string(filepath.Separator)+f] = struct{}{}\n\t\t}\n\t\twatchDirs[dir] = struct{}{}\n\t}\n\t// trigger reload on file change\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create watcher for TLS reloader: %v\", err)\n\t}\n\t// recommended by fsnotify: watch the dir to handle renames\n\t// https://pkg.go.dev/github.com/fsnotify/fsnotify#hdr-Watching_files\n\tfor dir := range watchDirs {\n\t\tlogger.Debugf(\"watching dir: %v\", dir)\n\t\terr := watcher.Add(dir)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"watch dir for TLS reloader: %v\", err)\n\t\t}\n\t}\n\n\t// load once outside the goroutine so we can return an error on misconfig\n\tinitialConfig, err := loadTLSConfig(certFile, keyFile, caFile, baseConfig)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"load TLS config: %v\", err)\n\t}\n\n\t// stored version of current tls config\n\tptr := &atomic.Pointer[tls.Config]{}\n\tptr.Store(initialConfig)\n\n\t// start background worker to reload certs\n\tgo func() {\n\tloop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase sig := <-sigc:\n\t\t\t\tlogger.Debug(\"reloading cert from signal: %v\", sig)\n\t\t\tcase evt := <-watcher.Events:\n\t\t\t\tif _, ok := watchFiles[evt.Name]; !ok || !evt.Has(fsnotify.Create) {\n\t\t\t\t\tcontinue loop\n\t\t\t\t}\n\t\t\t\tlogger.Debug(\"reloading cert from fsnotify: %v %v\", evt.Name, evt.Op.String())\n\t\t\tcase err := <-watcher.Errors:\n\t\t\t\tlogger.Errorf(\"TLS reloader watch: %v\", err)\n\t\t\t}\n\n\t\t\tloaded, err := loadTLSConfig(certFile, keyFile, caFile, baseConfig)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Errorf(\"reload TLS config: %v\", err)\n\t\t\t}\n\t\t\tptr.Store(loaded)\n\t\t}\n\t}()\n\n\t// https://pkg.go.dev/crypto/tls#baseConfig\n\t// Server configurations must set one of Certificates, GetCertificate or GetConfigForClient.\n\tif caFile != \"\" {\n\t\t// grpc will use this via tls.Server for mTLS\n\t\tinitialConfig.GetConfigForClient = func(chi *tls.ClientHelloInfo) (*tls.Config, error) { return ptr.Load(), nil }\n\t} else {\n\t\t// net/http only uses Certificates or GetCertificate\n\t\tinitialConfig.GetCertificate = func(chi *tls.ClientHelloInfo) (*tls.Certificate, error) { return &ptr.Load().Certificates[0], nil }\n\t}\n\treturn initialConfig, nil\n}\n\n// loadTLSConfig loads the given file paths into a [tls.Config]\nfunc loadTLSConfig(certFile, keyFile, caFile string, baseConfig *tls.Config) (*tls.Config, error) {\n\tcert, err := tls.LoadX509KeyPair(certFile, keyFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"loading TLS keypair: %v\", err)\n\t}\n\tloadedConfig := baseConfig.Clone() // copy\n\tloadedConfig.Certificates = []tls.Certificate{cert}\n\tif caFile != \"\" {\n\t\tcPool := x509.NewCertPool()\n\t\tclientCert, err := os.ReadFile(caFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"reading from client CA file: %v\", err)\n\t\t}\n\t\tif !cPool.AppendCertsFromPEM(clientCert) {\n\t\t\treturn nil, errors.New(\"failed to parse client CA\")\n\t\t}\n\n\t\tloadedConfig.ClientAuth = tls.RequireAndVerifyClientCert\n\t\tloadedConfig.ClientCAs = cPool\n\t}\n\treturn loadedConfig, nil\n}\n", "# The base path of Dex and the external name of the OpenID Connect service.\n# This is the canonical URL that all clients MUST use to refer to Dex. If a\n# path is provided, Dex's HTTP service will listen at a non-root URL.\nissuer: http://127.0.0.1:5556/dex\n\n# The storage configuration determines where Dex stores its state.\n# Supported options include:\n#   - SQL flavors\n#   - key-value stores (eg. etcd)\n#   - Kubernetes Custom Resources\n#\n# See the documentation (https://dexidp.io/docs/storage/) for further information.\nstorage:\n  type: memory\n\n  # type: sqlite3\n  # config:\n  #   file: /var/dex/dex.db\n\n  # type: mysql\n  # config:\n  #   host: 127.0.0.1\n  #   port: 3306\n  #   database: dex\n  #   user: mysql\n  #   password: mysql\n  #   ssl:\n  #     mode: \"false\"\n\n  # type: postgres\n  # config:\n  #   host: 127.0.0.1\n  #   port: 5432\n  #   database: dex\n  #   user: postgres\n  #   password: postgres\n  #   ssl:\n  #     mode: disable\n\n  # type: etcd\n  # config:\n  #   endpoints:\n  #     - http://127.0.0.1:2379\n  #   namespace: dex/\n\n  # type: kubernetes\n  # config:\n  #   kubeConfigFile: $HOME/.kube/config\n\n# HTTP service configuration\nweb:\n  http: 127.0.0.1:5556\n\n  # Uncomment to enable HTTPS endpoint.\n  # https: 127.0.0.1:5554\n  # tlsCert: /etc/dex/tls.crt\n  # tlsKey: /etc/dex/tls.key\n  # tlsMinVersion: 1.2\n  # tlsMaxVersion: 1.3\n\n# Dex UI configuration\n# frontend:\n#   issuer: dex\n#   logoURL: theme/logo.png\n#   dir: \"\"\n#   theme: light\n\n# Telemetry configuration\n# telemetry:\n#   http: 127.0.0.1:5558\n\n# logger:\n#   level: \"debug\"\n#   format: \"text\" # can also be \"json\"\n\n# gRPC API configuration\n# Uncomment this block to enable the gRPC API.\n# See the documentation (https://dexidp.io/docs/api/) for further information.\n# grpc:\n#   addr: 127.0.0.1:5557\n#   tlsCert: examples/grpc-client/server.crt\n#   tlsKey: examples/grpc-client/server.key\n#   tlsClientCA: examples/grpc-client/ca.crt\n\n# Expiration configuration for tokens, signing keys, etc.\n# expiry:\n#   deviceRequests: \"5m\"\n#   signingKeys: \"6h\"\n#   idTokens: \"24h\"\n#   refreshTokens:\n#     disableRotation: false\n#     reuseInterval: \"3s\"\n#     validIfNotUsedFor: \"2160h\" # 90 days\n#     absoluteLifetime: \"3960h\" # 165 days\n\n# OAuth2 configuration\n# oauth2:\n#   # use [\"code\", \"token\", \"id_token\"] to enable implicit flow for web-only clients\n#   responseTypes: [ \"code\" ] # also allowed are \"token\" and \"id_token\"\n#\n#   # By default, Dex will ask for approval to share data with application\n#   # (approval for sharing data from connected IdP to Dex is separate process on IdP)\n#   skipApprovalScreen: false\n#\n#   # If only one authentication method is enabled, the default behavior is to\n#   # go directly to it. For connected IdPs, this redirects the browser away\n#   # from application to upstream provider such as the Google login page\n#   alwaysShowLoginScreen: false\n#\n#   # Uncomment to use a specific connector for password grants\n#   passwordConnector: local\n\n# Static clients registered in Dex by default.\n#\n# Alternatively, clients may be added through the gRPC API.\n# staticClients:\n#   - id: example-app\n#     redirectURIs:\n#       - 'http://127.0.0.1:5555/callback'\n#     name: 'Example App'\n#     secret: ZXhhbXBsZS1hcHAtc2VjcmV0\n\n# Connectors are used to authenticate users against upstream identity providers.\n#\n# See the documentation (https://dexidp.io/docs/connectors/) for further information.\n# connectors: []\n\n# Enable the password database.\n#\n# It's a \"virtual\" connector (identity provider) that stores\n# login credentials in Dex's store.\nenablePasswordDB: true\n\n# If this option isn't chosen users may be added through the gRPC API.\n# A static list of passwords for the password connector.\n#\n# Alternatively, passwords my be added/updated through the gRPC API.\n# staticPasswords: []\n"], "filenames": ["cmd/dex/config.go", "cmd/dex/config_test.go", "cmd/dex/serve.go", "config.yaml.dist"], "buggy_code_start_loc": [66, 74, 147, 57], "buggy_code_end_loc": [171, 148, 427, 57], "fixing_code_start_loc": [67, 74, 148, 58], "fixing_code_end_loc": [181, 152, 451, 60], "type": "CWE-326", "message": "Dex is an identity service that uses OpenID Connect to drive authentication for other apps. Dex 2.37.0 serves HTTPS with insecure TLS 1.0 and TLS 1.1. `cmd/dex/serve.go` line 425 seemingly sets TLS 1.2 as minimum version, but the whole `tlsConfig` is ignored after `TLS cert reloader` was introduced in v2.37.0. Configured cipher suites are not respected either. This issue is fixed in Dex 2.38.0.", "other": {"cve": {"id": "CVE-2024-23656", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-25T20:15:41.107", "lastModified": "2024-01-31T23:26:14.650", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dex is an identity service that uses OpenID Connect to drive authentication for other apps. Dex 2.37.0 serves HTTPS with insecure TLS 1.0 and TLS 1.1. `cmd/dex/serve.go` line 425 seemingly sets TLS 1.2 as minimum version, but the whole `tlsConfig` is ignored after `TLS cert reloader` was introduced in v2.37.0. Configured cipher suites are not respected either. This issue is fixed in Dex 2.38.0."}, {"lang": "es", "value": "Dex es un servicio de identidad que utiliza OpenID Connect para impulsar la autenticaci\u00f3n de otras aplicaciones. Dex 2.37.0 sirve HTTPS con TLS 1.0 y TLS 1.1 inseguros. La l\u00ednea 425 de `cmd/dex/serve.go` aparentemente establece TLS 1.2 como versi\u00f3n m\u00ednima, pero el `tlsConfig` completo se ignora despu\u00e9s de que se introdujo el `TLS cert reloader` en v2.37.0. Tampoco se respetan los conjuntos de cifrado configurados. Este problema se solucion\u00f3 en Dex 2.38.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-326"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-326"}, {"lang": "en", "value": "CWE-757"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:dex:2.37.0:*:*:*:*:*:*:*", "matchCriteriaId": "CFFADC7B-A8BE-437B-B1A8-868ECD4ED5E9"}]}]}], "references": [{"url": "https://github.com/dexidp/dex/blob/70d7a2c7c1bb2646b1a540e49616cbc39622fb83/cmd/dex/serve.go#L425", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/dexidp/dex/commit/5bbdb4420254ba73b9c4df4775fe7bdacf233b17", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/dexidp/dex/issues/2848", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/dexidp/dex/pull/2964", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/dexidp/dex/security/advisories/GHSA-gr79-9v6v-gc9r", "source": "security-advisories@github.com", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/dexidp/dex/commit/5bbdb4420254ba73b9c4df4775fe7bdacf233b17"}}