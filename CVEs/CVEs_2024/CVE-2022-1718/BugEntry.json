{"buggy_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst _ = require('lodash')\nconst xss = require('xss')\nconst fs = require('fs')\nconst piexifjs = require('piexifjs')\n\nmodule.exports.sanitizeFieldPlainText = function (text) {\n  return xss(text, {\n    whileList: {},\n    stripIgnoreTag: true,\n    stripIgnoreTagBody: ['script']\n  })\n}\n\nmodule.exports.stripExifData = function (path) {\n  const imgData = fs.readFileSync(path).toString('binary')\n  const newImgData = piexifjs.remove(imgData)\n  fs.writeFileSync(path, newImgData, 'binary')\n}\n\nmodule.exports.sendToSelf = function (socket, method, data) {\n  socket.emit(method, data)\n}\n\nmodule.exports._sendToSelf = function (io, socketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id === socketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.sendToAllConnectedClients = function (io, method, data) {\n  io.sockets.emit(method, data)\n}\n\nmodule.exports.sendToAllClientsInRoom = function (io, room, method, data) {\n  io.sockets.in(room).emit(method, data)\n}\n\nmodule.exports.sendToUser = function (socketList, userList, username, method, data) {\n  let userOnline = null\n  _.forEach(userList, function (v, k) {\n    if (k.toLowerCase() === username.toLowerCase()) {\n      userOnline = v\n      return true\n    }\n  })\n\n  if (_.isNull(userOnline)) return true\n\n  _.forEach(userOnline.sockets, function (socket) {\n    const o = _.findKey(socketList, { id: socket })\n    const i = socketList[o]\n    if (_.isUndefined(i)) return true\n    i.emit(method, data)\n  })\n}\n\nmodule.exports.sendToAllExcept = function (io, exceptSocketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id !== exceptSocketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.disconnectAllClients = function (io) {\n  Object.keys(io.sockets.sockets).forEach(function (sock) {\n    io.sockets.sockets[sock].disconnect(true)\n  })\n}\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar async = require('async')\nvar mongoose = require('mongoose')\nvar winston = require('winston')\nvar bcrypt = require('bcrypt')\nvar _ = require('lodash')\nvar Chance = require('chance')\nconst utils = require('../helpers/utils')\n\n// Required for linkage\nrequire('./role')\n\nvar SALT_FACTOR = 10\nvar COLLECTION = 'accounts'\n\n/**\n * User Schema\n * @module models/user\n * @class User\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {String} username ```Required``` ```unique``` Username of user\n * @property {String} password ```Required``` Bcrypt password\n * @property {String} fullname ```Required``` Full name of user\n * @property {String} email ```Required``` ```unique``` Email Address of user\n * @property {String} role ```Required``` Permission role of the given user. See {@link Permissions}\n * @property {Date} lastOnline Last timestamp given user was online.\n * @property {String} title Job Title of user\n * @property {String} image Filename of user image\n * @property {String} resetPassHash Password reset has for recovery password link.\n * @property {Date} resetPassExpire Date when the password recovery link will expire\n * @property {String} tOTPKey One Time Password Secret Key\n * @property {Number} tOTPPeriod One Time Password Key Length (Time) - Default 30 Seconds\n * @property {String} accessToken API Access Token\n * @property {Array} iOSDeviceTokens Array of String based device Ids for Apple iOS devices. *push notifications*\n * @property {Object} preferences Object to hold user preferences\n * @property {Boolean} preferences.autoRefreshTicketGrid Enable the auto refresh of the ticket grid.\n * @property {Boolean} deleted Account Deleted\n */\nvar userSchema = mongoose.Schema({\n  username: { type: String, required: true, unique: true, lowercase: true },\n  password: { type: String, required: true, select: false },\n  fullname: { type: String, required: true, index: true },\n  email: { type: String, required: true, unique: true, lowercase: true },\n  role: { type: mongoose.Schema.Types.ObjectId, ref: 'roles', required: true },\n  lastOnline: Date,\n  title: String,\n  image: String,\n\n  resetPassHash: { type: String, select: false },\n  resetPassExpire: { type: Date, select: false },\n  tOTPKey: { type: String, select: false },\n  tOTPPeriod: { type: Number, select: false },\n  resetL2AuthHash: { type: String, select: false },\n  resetL2AuthExpire: { type: Date, select: false },\n  hasL2Auth: { type: Boolean, required: true, default: false },\n  accessToken: { type: String, sparse: true, select: false },\n\n  preferences: {\n    tourCompleted: { type: Boolean, default: false },\n    autoRefreshTicketGrid: { type: Boolean, default: true },\n    openChatWindows: [{ type: String, default: [] }]\n  },\n\n  deleted: { type: Boolean, default: false }\n})\n\nuserSchema.set('toObject', { getters: true })\n\nvar autoPopulateRole = function (next) {\n  this.populate('role', 'name description normalized _id')\n  next()\n}\n\nuserSchema.pre('findOne', autoPopulateRole).pre('find', autoPopulateRole)\n\nuserSchema.pre('save', function (next) {\n  var user = this\n\n  user.username = utils.sanitizeFieldPlainText(user.username.toLowerCase().trim())\n  user.email = utils.sanitizeFieldPlainText(user.email.trim())\n\n  if (user.fullname) user.fullname = utils.sanitizeFieldPlainText(user.fullname.trim())\n  if (user.title) user.title = utils.sanitizeFieldPlainText(user.title.trim())\n\n  if (!user.isModified('password')) {\n    return next()\n  }\n\n  bcrypt.genSalt(SALT_FACTOR, function (err, salt) {\n    if (err) return next(err)\n\n    bcrypt.hash(user.password, salt, function (err, hash) {\n      if (err) return next(err)\n\n      user.password = hash\n      return next()\n    })\n  })\n})\n\nuserSchema.methods.addAccessToken = function (callback) {\n  var user = this\n  var date = new Date()\n  var salt = user.username.toString() + date.toISOString()\n  var chance = new Chance(salt)\n  user.accessToken = chance.hash()\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback(null, user.accessToken)\n  })\n}\n\nuserSchema.methods.removeAccessToken = function (callback) {\n  var user = this\n  if (!user.accessToken) return callback()\n\n  user.accessToken = undefined\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback()\n  })\n}\n\nuserSchema.methods.generateL2Auth = function (callback) {\n  var user = this\n  if (_.isUndefined(user.tOTPKey) || _.isNull(user.tOTPKey)) {\n    var chance = new Chance()\n    var base32 = require('thirty-two')\n\n    var genOTPKey = chance.string({\n      length: 7,\n      pool: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ23456789'\n    })\n    var base32GenOTPKey = base32\n      .encode(genOTPKey)\n      .toString()\n      .replace(/=/g, '')\n\n    user.tOTPKey = base32GenOTPKey\n    user.hasL2Auth = true\n    user.save(function (err) {\n      if (err) return callback(err)\n\n      return callback(null, base32GenOTPKey)\n    })\n  } else {\n    return callback()\n  }\n}\n\nuserSchema.methods.removeL2Auth = function (callback) {\n  var user = this\n\n  user.tOTPKey = undefined\n  user.hasL2Auth = false\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback()\n  })\n}\n\nuserSchema.methods.addDeviceToken = function (token, type, callback) {\n  if (_.isUndefined(token)) return callback('Invalid token')\n  var user = this\n  // type 1 = iOS\n  // type 2 = Android\n  if (type === 1) {\n    if (hasDeviceToken(user, token, type)) return callback(null, token)\n\n    user.iOSDeviceTokens.push(token)\n    user.save(function (err) {\n      if (err) return callback(err, null)\n\n      callback(null, token)\n    })\n  }\n}\n\nuserSchema.methods.removeDeviceToken = function (token, type, callback) {\n  var user = this\n  if (type === 1) {\n    if (!hasDeviceToken(user, token, type)) return callback()\n\n    winston.debug('Removing Device: ' + token)\n    user.iOSDeviceTokens.splice(_.indexOf(this.iOSDeviceTokens, token), 1)\n    user.save(function (err, u) {\n      if (err) return callback(err, null)\n\n      return callback(null, u.iOSDeviceTokens)\n    })\n  }\n}\n\nuserSchema.methods.addOpenChatWindow = function (convoId, callback) {\n  if (convoId === undefined) {\n    if (!_.isFunction(callback)) return false\n    return callback('Invalid convoId')\n  }\n  var user = this\n  var hasChatWindow =\n    _.filter(user.preferences.openChatWindows, function (value) {\n      return value.toString() === convoId.toString()\n    }).length > 0\n\n  if (hasChatWindow) {\n    if (!_.isFunction(callback)) return false\n    return callback()\n  }\n  user.preferences.openChatWindows.push(convoId.toString())\n  user.save(function (err, u) {\n    if (err) {\n      if (!_.isFunction(callback)) return false\n      return callback(err)\n    }\n\n    if (!_.isFunction(callback)) return false\n    return callback(null, u.preferences.openChatWindows)\n  })\n}\n\nuserSchema.methods.removeOpenChatWindow = function (convoId, callback) {\n  if (convoId === undefined) {\n    if (!_.isFunction(callback)) return false\n    return callback('Invalid convoId')\n  }\n  var user = this\n  var hasChatWindow =\n    _.filter(user.preferences.openChatWindows, function (value) {\n      return value.toString() === convoId.toString()\n    }).length > 0\n\n  if (!hasChatWindow) {\n    if (!_.isFunction(callback)) return false\n    return callback()\n  }\n  user.preferences.openChatWindows.splice(\n    _.findIndex(user.preferences.openChatWindows, function (item) {\n      return item.toString() === convoId.toString()\n    }),\n    1\n  )\n\n  user.save(function (err, u) {\n    if (err) {\n      if (!_.isFunction(callback)) return false\n      return callback(err)\n    }\n\n    if (!_.isFunction(callback)) return false\n    return callback(null, u.preferences.openChatWindows)\n  })\n}\n\nuserSchema.methods.softDelete = function (callback) {\n  var user = this\n\n  user.deleted = true\n\n  user.save(function (err) {\n    if (err) return callback(err, false)\n\n    callback(null, true)\n  })\n}\n\nuserSchema.statics.validate = function (password, dbPass) {\n  return bcrypt.compareSync(password, dbPass)\n}\n\n/**\n * Gets all users\n *\n * @memberof User\n * @static\n * @method findAll\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.findAll = function (callback) {\n  return this.model(COLLECTION).find({}, callback)\n}\n\n/**\n * Gets user via object _id\n *\n * @memberof User\n * @static\n * @method getUser\n *\n * @param {Object} oId Object _id to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUser = function (oId, callback) {\n  if (_.isUndefined(oId)) {\n    return callback('Invalid ObjectId - UserSchema.GetUser()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ _id: oId }, callback)\n}\n\n/**\n * Gets user via username\n *\n * @memberof User\n * @static\n * @method getUserByUsername\n *\n * @param {String} user Username to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByUsername = function (user, callback) {\n  if (_.isUndefined(user)) {\n    return callback('Invalid Username - UserSchema.GetUserByUsername()', null)\n  }\n\n  return this.model(COLLECTION)\n    .findOne({ username: new RegExp('^' + user + '$', 'i') })\n    .select('+password +accessToken')\n    .exec(callback)\n}\n\nuserSchema.statics.getByUsername = userSchema.statics.getUserByUsername\n\n/**\n * Gets user via email\n *\n * @memberof User\n * @static\n * @method getUserByEmail\n *\n * @param {String} email Email to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByEmail = function (email, callback) {\n  if (_.isUndefined(email)) {\n    return callback('Invalid Email - UserSchema.GetUserByEmail()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ email: email.toLowerCase() }, callback)\n}\n\n/**\n * Gets user via reset password hash\n *\n * @memberof User\n * @static\n * @method getUserByResetHash\n *\n * @param {String} hash Hash to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByResetHash = function (hash, callback) {\n  if (_.isUndefined(hash)) {\n    return callback('Invalid Hash - UserSchema.GetUserByResetHash()', null)\n  }\n\n  return this.model(COLLECTION).findOne(\n    { resetPassHash: hash, deleted: false },\n    '+resetPassHash +resetPassExpire',\n    callback\n  )\n}\n\nuserSchema.statics.getUserByL2ResetHash = function (hash, callback) {\n  if (_.isUndefined(hash)) {\n    return callback('Invalid Hash - UserSchema.GetUserByL2ResetHash()', null)\n  }\n\n  return this.model(COLLECTION).findOne(\n    { resetL2AuthHash: hash, deleted: false },\n    '+resetL2AuthHash +resetL2AuthExpire',\n    callback\n  )\n}\n\n/**\n * Gets user via API Access Token\n *\n * @memberof User\n * @static\n * @method getUserByAccessToken\n *\n * @param {String} token Access Token to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByAccessToken = function (token, callback) {\n  if (_.isUndefined(token)) {\n    return callback('Invalid Token - UserSchema.GetUserByAccessToken()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ accessToken: token, deleted: false }, '+password', callback)\n}\n\nuserSchema.statics.getUserWithObject = function (object, callback) {\n  if (!_.isObject(object)) {\n    return callback('Invalid Object (Must be of type Object) - UserSchema.GetUserWithObject()', null)\n  }\n\n  var self = this\n\n  var limit = object.limit === null ? 10 : object.limit\n  var page = object.page === null ? 0 : object.page\n  var search = object.search === null ? '' : object.search\n\n  var q = self\n    .model(COLLECTION)\n    .find({}, '-password -resetPassHash -resetPassExpire')\n    .sort({ fullname: 1 })\n    .skip(page * limit)\n  if (limit !== -1) {\n    q.limit(limit)\n  }\n\n  if (!object.showDeleted) q.where({ deleted: false })\n\n  if (!_.isEmpty(search)) {\n    q.where({ fullname: new RegExp('^' + search.toLowerCase(), 'i') })\n  }\n\n  return q.exec(callback)\n}\n\n/**\n * Gets users based on permissions > mod\n *\n * @memberof User\n * @static\n * @method getAssigneeUsers\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getAssigneeUsers = function (callback) {\n  var roles = global.roles\n  if (_.isUndefined(roles)) return callback(null, [])\n\n  var assigneeRoles = []\n  async.each(roles, function (role) {\n    if (role.isAgent) assigneeRoles.push(role._id)\n  })\n\n  assigneeRoles = _.uniq(assigneeRoles)\n  this.model(COLLECTION).find({ role: { $in: assigneeRoles }, deleted: false }, function (err, users) {\n    if (err) {\n      winston.warn(err)\n      return callback(err, null)\n    }\n\n    return callback(null, _.sortBy(users, 'fullname'))\n  })\n}\n\n/**\n * Gets users based on roles\n *\n * @memberof User\n * @static\n * @method getUsersByRoles\n *\n * @param {Array} roles Array of role ids\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUsersByRoles = function (roles, callback) {\n  if (_.isUndefined(roles)) return callback('Invalid roles array', null)\n  if (!_.isArray(roles)) {\n    roles = [roles]\n  }\n\n  var q = this.model(COLLECTION).find({ role: { $in: roles }, deleted: false })\n\n  return q.exec(callback)\n}\n\n/**\n * Creates a user with the given data object\n *\n * @memberof User\n * @static\n * @method createUser\n *\n * @param {User} data JSON data object of new User\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.createUser = function (data, callback) {\n  if (_.isUndefined(data) || _.isUndefined(data.username)) {\n    return callback('Invalid User Data - UserSchema.CreateUser()', null)\n  }\n\n  var self = this\n\n  self.model(COLLECTION).find({ username: data.username }, function (err, items) {\n    if (err) {\n      return callback(err, null)\n    }\n\n    if (_.size(items) > 0) {\n      return callback('Username Already Exists', null)\n    }\n\n    return self.collection.insert(data, callback)\n  })\n}\n\n/**\n * Creates a user with only Email address. Emails user password.\n *\n * @param email\n * @param callback\n */\nuserSchema.statics.createUserFromEmail = function (email, callback) {\n  if (_.isUndefined(email)) {\n    return callback('Invalid User Data - UserSchema.CreatePublicUser()', null)\n  }\n\n  var self = this\n\n  var settingSchema = require('./setting')\n  settingSchema.getSetting('role:user:default', function (err, userRoleDefault) {\n    if (err || !userRoleDefault) return callback('Invalid Setting - UserRoleDefault')\n\n    var Chance = require('chance')\n\n    var chance = new Chance()\n\n    var plainTextPass = chance.string({\n      length: 6,\n      pool: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'\n    })\n\n    var user = new self({\n      username: email,\n      email: email,\n      password: plainTextPass,\n      fullname: email,\n      role: userRoleDefault.value\n    })\n\n    self.model(COLLECTION).find({ username: user.username }, function (err, items) {\n      if (err) return callback(err)\n      if (_.size(items) > 0) return callback('Username already exists')\n\n      user.save(function (err, savedUser) {\n        if (err) return callback(err)\n\n        // Create a group for this user\n        var GroupSchema = require('./group')\n        var group = new GroupSchema({\n          name: savedUser.email,\n          members: [savedUser._id],\n          sendMailTo: [savedUser._id],\n          public: true\n        })\n\n        group.save(function (err, group) {\n          if (err) return callback(err)\n\n          // Send welcome email\n          var path = require('path')\n          var mailer = require('../mailer')\n          var Email = require('email-templates')\n          var templateDir = path.resolve(__dirname, '..', 'mailer', 'templates')\n\n          var email = new Email({\n            views: {\n              root: templateDir,\n              options: {\n                extension: 'handlebars'\n              }\n            }\n          })\n\n          var settingSchema = require('./setting')\n          settingSchema.getSetting('gen:siteurl', function (err, setting) {\n            if (err) return callback(err)\n\n            if (!setting) {\n              setting = { value: '' }\n            }\n\n            var dataObject = {\n              user: savedUser,\n              plainTextPassword: plainTextPass,\n              baseUrl: setting.value\n            }\n\n            email\n              .render('public-account-created', dataObject)\n              .then(function (html) {\n                var mailOptions = {\n                  to: savedUser.email,\n                  subject: 'Welcome to trudesk! - Here are your account details.',\n                  html: html,\n                  generateTextFromHTML: true\n                }\n\n                mailer.sendMail(mailOptions, function (err) {\n                  if (err) {\n                    winston.warn(err)\n                    return callback(err)\n                  }\n\n                  return callback(null, { user: savedUser, group: group })\n                })\n              })\n              .catch(function (err) {\n                winston.warn(err)\n                return callback(err)\n              })\n          })\n        })\n      })\n    })\n  })\n}\n\nuserSchema.statics.getCustomers = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n  return self\n    .model(COLLECTION)\n    .find({}, '-password -resetPassHash -resetPassExpire')\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var customerRoleIds = _.filter(accounts, function (a) {\n        return !a.role.isAdmin && !a.role.isAgent\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .find({ role: { $in: customerRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\nuserSchema.statics.getAgents = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n\n  return self\n    .model(COLLECTION)\n    .find({})\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var agentRoleIds = _.filter(accounts, function (a) {\n        return a.role.isAgent\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .model(COLLECTION)\n        .find({ role: { $in: agentRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\nuserSchema.statics.getAdmins = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n\n  return self\n    .model(COLLECTION)\n    .find({})\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var adminRoleIds = _.filter(accounts, function (a) {\n        return a.role.isAdmin\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .model(COLLECTION)\n        .find({ role: { $in: adminRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\n/**\n * Checks if a user has device token already\n *\n * @memberof User\n * @instance\n * @method hasDeviceToken\n *\n * @param {User} user User to check against\n * @param {String} token token to check for in given user\n * @param {Number} type Type of Device token to check.\n * @return {Boolean}\n * @example\n * type:\n *   1: iOS\n *   2: Android\n *   3: Windows\n */\nfunction hasDeviceToken (user, token, type) {\n  if (type === 1) {\n    var matches = _.filter(user.iOSDeviceTokens, function (value) {\n      if (value === token) {\n        return value\n      }\n    })\n\n    return matches.length > 0\n  }\n\n  return false\n}\n\nmodule.exports = mongoose.model(COLLECTION, userSchema)\n"], "fixing_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst _ = require('lodash')\nconst xss = require('xss')\nconst fs = require('fs')\nconst piexifjs = require('piexifjs')\n\nconst MAX_FIELD_TEXT_LENGTH = 255\nconst MAX_SHORT_FIELD_TEXT_LENGTH = 25\n\nmodule.exports.applyMaxShortTextLength = function (text) {\n  return text.toString().substring(0, MAX_SHORT_FIELD_TEXT_LENGTH)\n}\n\nmodule.exports.sanitizeFieldPlainText = function (text) {\n  return xss(text, {\n    whileList: {},\n    stripIgnoreTag: true,\n    stripIgnoreTagBody: ['script']\n  })\n}\n\nmodule.exports.stripExifData = function (path) {\n  const imgData = fs.readFileSync(path).toString('binary')\n  const newImgData = piexifjs.remove(imgData)\n  fs.writeFileSync(path, newImgData, 'binary')\n}\n\nmodule.exports.sendToSelf = function (socket, method, data) {\n  socket.emit(method, data)\n}\n\nmodule.exports._sendToSelf = function (io, socketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id === socketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.sendToAllConnectedClients = function (io, method, data) {\n  io.sockets.emit(method, data)\n}\n\nmodule.exports.sendToAllClientsInRoom = function (io, room, method, data) {\n  io.sockets.in(room).emit(method, data)\n}\n\nmodule.exports.sendToUser = function (socketList, userList, username, method, data) {\n  let userOnline = null\n  _.forEach(userList, function (v, k) {\n    if (k.toLowerCase() === username.toLowerCase()) {\n      userOnline = v\n      return true\n    }\n  })\n\n  if (_.isNull(userOnline)) return true\n\n  _.forEach(userOnline.sockets, function (socket) {\n    const o = _.findKey(socketList, { id: socket })\n    const i = socketList[o]\n    if (_.isUndefined(i)) return true\n    i.emit(method, data)\n  })\n}\n\nmodule.exports.sendToAllExcept = function (io, exceptSocketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id !== exceptSocketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.disconnectAllClients = function (io) {\n  Object.keys(io.sockets.sockets).forEach(function (sock) {\n    io.sockets.sockets[sock].disconnect(true)\n  })\n}\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar async = require('async')\nvar mongoose = require('mongoose')\nvar winston = require('winston')\nvar bcrypt = require('bcrypt')\nvar _ = require('lodash')\nvar Chance = require('chance')\nconst utils = require('../helpers/utils')\n\n// Required for linkage\nrequire('./role')\n\nvar SALT_FACTOR = 10\nvar COLLECTION = 'accounts'\n\n/**\n * User Schema\n * @module models/user\n * @class User\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {String} username ```Required``` ```unique``` Username of user\n * @property {String} password ```Required``` Bcrypt password\n * @property {String} fullname ```Required``` Full name of user\n * @property {String} email ```Required``` ```unique``` Email Address of user\n * @property {String} role ```Required``` Permission role of the given user. See {@link Permissions}\n * @property {Date} lastOnline Last timestamp given user was online.\n * @property {String} title Job Title of user\n * @property {String} image Filename of user image\n * @property {String} resetPassHash Password reset has for recovery password link.\n * @property {Date} resetPassExpire Date when the password recovery link will expire\n * @property {String} tOTPKey One Time Password Secret Key\n * @property {Number} tOTPPeriod One Time Password Key Length (Time) - Default 30 Seconds\n * @property {String} accessToken API Access Token\n * @property {Array} iOSDeviceTokens Array of String based device Ids for Apple iOS devices. *push notifications*\n * @property {Object} preferences Object to hold user preferences\n * @property {Boolean} preferences.autoRefreshTicketGrid Enable the auto refresh of the ticket grid.\n * @property {Boolean} deleted Account Deleted\n */\nvar userSchema = mongoose.Schema({\n  username: { type: String, required: true, unique: true, lowercase: true },\n  password: { type: String, required: true, select: false },\n  fullname: { type: String, required: true, index: true },\n  email: { type: String, required: true, unique: true, lowercase: true },\n  role: { type: mongoose.Schema.Types.ObjectId, ref: 'roles', required: true },\n  lastOnline: Date,\n  title: String,\n  image: String,\n\n  resetPassHash: { type: String, select: false },\n  resetPassExpire: { type: Date, select: false },\n  tOTPKey: { type: String, select: false },\n  tOTPPeriod: { type: Number, select: false },\n  resetL2AuthHash: { type: String, select: false },\n  resetL2AuthExpire: { type: Date, select: false },\n  hasL2Auth: { type: Boolean, required: true, default: false },\n  accessToken: { type: String, sparse: true, select: false },\n\n  preferences: {\n    tourCompleted: { type: Boolean, default: false },\n    autoRefreshTicketGrid: { type: Boolean, default: true },\n    openChatWindows: [{ type: String, default: [] }]\n  },\n\n  deleted: { type: Boolean, default: false }\n})\n\nuserSchema.set('toObject', { getters: true })\n\nvar autoPopulateRole = function (next) {\n  this.populate('role', 'name description normalized _id')\n  next()\n}\n\nuserSchema.pre('findOne', autoPopulateRole).pre('find', autoPopulateRole)\n\nuserSchema.pre('save', function (next) {\n  var user = this\n\n  user.username = utils.applyMaxShortTextLength(utils.sanitizeFieldPlainText(user.username.toLowerCase().trim()))\n  user.email = utils.sanitizeFieldPlainText(user.email.trim())\n\n  if (user.fullname) user.fullname = utils.applyMaxShortTextLength(utils.sanitizeFieldPlainText(user.fullname.trim()))\n  if (user.title) user.title = utils.applyMaxShortTextLength(utils.sanitizeFieldPlainText(user.title.trim()))\n\n  if (!user.isModified('password')) {\n    return next()\n  }\n\n  bcrypt.genSalt(SALT_FACTOR, function (err, salt) {\n    if (err) return next(err)\n\n    bcrypt.hash(user.password, salt, function (err, hash) {\n      if (err) return next(err)\n\n      user.password = hash\n      return next()\n    })\n  })\n})\n\nuserSchema.methods.addAccessToken = function (callback) {\n  var user = this\n  var date = new Date()\n  var salt = user.username.toString() + date.toISOString()\n  var chance = new Chance(salt)\n  user.accessToken = chance.hash()\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback(null, user.accessToken)\n  })\n}\n\nuserSchema.methods.removeAccessToken = function (callback) {\n  var user = this\n  if (!user.accessToken) return callback()\n\n  user.accessToken = undefined\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback()\n  })\n}\n\nuserSchema.methods.generateL2Auth = function (callback) {\n  var user = this\n  if (_.isUndefined(user.tOTPKey) || _.isNull(user.tOTPKey)) {\n    var chance = new Chance()\n    var base32 = require('thirty-two')\n\n    var genOTPKey = chance.string({\n      length: 7,\n      pool: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ23456789'\n    })\n    var base32GenOTPKey = base32\n      .encode(genOTPKey)\n      .toString()\n      .replace(/=/g, '')\n\n    user.tOTPKey = base32GenOTPKey\n    user.hasL2Auth = true\n    user.save(function (err) {\n      if (err) return callback(err)\n\n      return callback(null, base32GenOTPKey)\n    })\n  } else {\n    return callback()\n  }\n}\n\nuserSchema.methods.removeL2Auth = function (callback) {\n  var user = this\n\n  user.tOTPKey = undefined\n  user.hasL2Auth = false\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback()\n  })\n}\n\nuserSchema.methods.addDeviceToken = function (token, type, callback) {\n  if (_.isUndefined(token)) return callback('Invalid token')\n  var user = this\n  // type 1 = iOS\n  // type 2 = Android\n  if (type === 1) {\n    if (hasDeviceToken(user, token, type)) return callback(null, token)\n\n    user.iOSDeviceTokens.push(token)\n    user.save(function (err) {\n      if (err) return callback(err, null)\n\n      callback(null, token)\n    })\n  }\n}\n\nuserSchema.methods.removeDeviceToken = function (token, type, callback) {\n  var user = this\n  if (type === 1) {\n    if (!hasDeviceToken(user, token, type)) return callback()\n\n    winston.debug('Removing Device: ' + token)\n    user.iOSDeviceTokens.splice(_.indexOf(this.iOSDeviceTokens, token), 1)\n    user.save(function (err, u) {\n      if (err) return callback(err, null)\n\n      return callback(null, u.iOSDeviceTokens)\n    })\n  }\n}\n\nuserSchema.methods.addOpenChatWindow = function (convoId, callback) {\n  if (convoId === undefined) {\n    if (!_.isFunction(callback)) return false\n    return callback('Invalid convoId')\n  }\n  var user = this\n  var hasChatWindow =\n    _.filter(user.preferences.openChatWindows, function (value) {\n      return value.toString() === convoId.toString()\n    }).length > 0\n\n  if (hasChatWindow) {\n    if (!_.isFunction(callback)) return false\n    return callback()\n  }\n  user.preferences.openChatWindows.push(convoId.toString())\n  user.save(function (err, u) {\n    if (err) {\n      if (!_.isFunction(callback)) return false\n      return callback(err)\n    }\n\n    if (!_.isFunction(callback)) return false\n    return callback(null, u.preferences.openChatWindows)\n  })\n}\n\nuserSchema.methods.removeOpenChatWindow = function (convoId, callback) {\n  if (convoId === undefined) {\n    if (!_.isFunction(callback)) return false\n    return callback('Invalid convoId')\n  }\n  var user = this\n  var hasChatWindow =\n    _.filter(user.preferences.openChatWindows, function (value) {\n      return value.toString() === convoId.toString()\n    }).length > 0\n\n  if (!hasChatWindow) {\n    if (!_.isFunction(callback)) return false\n    return callback()\n  }\n  user.preferences.openChatWindows.splice(\n    _.findIndex(user.preferences.openChatWindows, function (item) {\n      return item.toString() === convoId.toString()\n    }),\n    1\n  )\n\n  user.save(function (err, u) {\n    if (err) {\n      if (!_.isFunction(callback)) return false\n      return callback(err)\n    }\n\n    if (!_.isFunction(callback)) return false\n    return callback(null, u.preferences.openChatWindows)\n  })\n}\n\nuserSchema.methods.softDelete = function (callback) {\n  var user = this\n\n  user.deleted = true\n\n  user.save(function (err) {\n    if (err) return callback(err, false)\n\n    callback(null, true)\n  })\n}\n\nuserSchema.statics.validate = function (password, dbPass) {\n  return bcrypt.compareSync(password, dbPass)\n}\n\n/**\n * Gets all users\n *\n * @memberof User\n * @static\n * @method findAll\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.findAll = function (callback) {\n  return this.model(COLLECTION).find({}, callback)\n}\n\n/**\n * Gets user via object _id\n *\n * @memberof User\n * @static\n * @method getUser\n *\n * @param {Object} oId Object _id to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUser = function (oId, callback) {\n  if (_.isUndefined(oId)) {\n    return callback('Invalid ObjectId - UserSchema.GetUser()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ _id: oId }, callback)\n}\n\n/**\n * Gets user via username\n *\n * @memberof User\n * @static\n * @method getUserByUsername\n *\n * @param {String} user Username to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByUsername = function (user, callback) {\n  if (_.isUndefined(user)) {\n    return callback('Invalid Username - UserSchema.GetUserByUsername()', null)\n  }\n\n  return this.model(COLLECTION)\n    .findOne({ username: new RegExp('^' + user + '$', 'i') })\n    .select('+password +accessToken')\n    .exec(callback)\n}\n\nuserSchema.statics.getByUsername = userSchema.statics.getUserByUsername\n\n/**\n * Gets user via email\n *\n * @memberof User\n * @static\n * @method getUserByEmail\n *\n * @param {String} email Email to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByEmail = function (email, callback) {\n  if (_.isUndefined(email)) {\n    return callback('Invalid Email - UserSchema.GetUserByEmail()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ email: email.toLowerCase() }, callback)\n}\n\n/**\n * Gets user via reset password hash\n *\n * @memberof User\n * @static\n * @method getUserByResetHash\n *\n * @param {String} hash Hash to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByResetHash = function (hash, callback) {\n  if (_.isUndefined(hash)) {\n    return callback('Invalid Hash - UserSchema.GetUserByResetHash()', null)\n  }\n\n  return this.model(COLLECTION).findOne(\n    { resetPassHash: hash, deleted: false },\n    '+resetPassHash +resetPassExpire',\n    callback\n  )\n}\n\nuserSchema.statics.getUserByL2ResetHash = function (hash, callback) {\n  if (_.isUndefined(hash)) {\n    return callback('Invalid Hash - UserSchema.GetUserByL2ResetHash()', null)\n  }\n\n  return this.model(COLLECTION).findOne(\n    { resetL2AuthHash: hash, deleted: false },\n    '+resetL2AuthHash +resetL2AuthExpire',\n    callback\n  )\n}\n\n/**\n * Gets user via API Access Token\n *\n * @memberof User\n * @static\n * @method getUserByAccessToken\n *\n * @param {String} token Access Token to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByAccessToken = function (token, callback) {\n  if (_.isUndefined(token)) {\n    return callback('Invalid Token - UserSchema.GetUserByAccessToken()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ accessToken: token, deleted: false }, '+password', callback)\n}\n\nuserSchema.statics.getUserWithObject = function (object, callback) {\n  if (!_.isObject(object)) {\n    return callback('Invalid Object (Must be of type Object) - UserSchema.GetUserWithObject()', null)\n  }\n\n  var self = this\n\n  var limit = object.limit === null ? 10 : object.limit\n  var page = object.page === null ? 0 : object.page\n  var search = object.search === null ? '' : object.search\n\n  var q = self\n    .model(COLLECTION)\n    .find({}, '-password -resetPassHash -resetPassExpire')\n    .sort({ fullname: 1 })\n    .skip(page * limit)\n  if (limit !== -1) {\n    q.limit(limit)\n  }\n\n  if (!object.showDeleted) q.where({ deleted: false })\n\n  if (!_.isEmpty(search)) {\n    q.where({ fullname: new RegExp('^' + search.toLowerCase(), 'i') })\n  }\n\n  return q.exec(callback)\n}\n\n/**\n * Gets users based on permissions > mod\n *\n * @memberof User\n * @static\n * @method getAssigneeUsers\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getAssigneeUsers = function (callback) {\n  var roles = global.roles\n  if (_.isUndefined(roles)) return callback(null, [])\n\n  var assigneeRoles = []\n  async.each(roles, function (role) {\n    if (role.isAgent) assigneeRoles.push(role._id)\n  })\n\n  assigneeRoles = _.uniq(assigneeRoles)\n  this.model(COLLECTION).find({ role: { $in: assigneeRoles }, deleted: false }, function (err, users) {\n    if (err) {\n      winston.warn(err)\n      return callback(err, null)\n    }\n\n    return callback(null, _.sortBy(users, 'fullname'))\n  })\n}\n\n/**\n * Gets users based on roles\n *\n * @memberof User\n * @static\n * @method getUsersByRoles\n *\n * @param {Array} roles Array of role ids\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUsersByRoles = function (roles, callback) {\n  if (_.isUndefined(roles)) return callback('Invalid roles array', null)\n  if (!_.isArray(roles)) {\n    roles = [roles]\n  }\n\n  var q = this.model(COLLECTION).find({ role: { $in: roles }, deleted: false })\n\n  return q.exec(callback)\n}\n\n/**\n * Creates a user with the given data object\n *\n * @memberof User\n * @static\n * @method createUser\n *\n * @param {User} data JSON data object of new User\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.createUser = function (data, callback) {\n  if (_.isUndefined(data) || _.isUndefined(data.username)) {\n    return callback('Invalid User Data - UserSchema.CreateUser()', null)\n  }\n\n  var self = this\n\n  self.model(COLLECTION).find({ username: data.username }, function (err, items) {\n    if (err) {\n      return callback(err, null)\n    }\n\n    if (_.size(items) > 0) {\n      return callback('Username Already Exists', null)\n    }\n\n    return self.collection.insert(data, callback)\n  })\n}\n\n/**\n * Creates a user with only Email address. Emails user password.\n *\n * @param email\n * @param callback\n */\nuserSchema.statics.createUserFromEmail = function (email, callback) {\n  if (_.isUndefined(email)) {\n    return callback('Invalid User Data - UserSchema.CreatePublicUser()', null)\n  }\n\n  var self = this\n\n  var settingSchema = require('./setting')\n  settingSchema.getSetting('role:user:default', function (err, userRoleDefault) {\n    if (err || !userRoleDefault) return callback('Invalid Setting - UserRoleDefault')\n\n    var Chance = require('chance')\n\n    var chance = new Chance()\n\n    var plainTextPass = chance.string({\n      length: 6,\n      pool: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'\n    })\n\n    var user = new self({\n      username: email,\n      email: email,\n      password: plainTextPass,\n      fullname: email,\n      role: userRoleDefault.value\n    })\n\n    self.model(COLLECTION).find({ username: user.username }, function (err, items) {\n      if (err) return callback(err)\n      if (_.size(items) > 0) return callback('Username already exists')\n\n      user.save(function (err, savedUser) {\n        if (err) return callback(err)\n\n        // Create a group for this user\n        var GroupSchema = require('./group')\n        var group = new GroupSchema({\n          name: savedUser.email,\n          members: [savedUser._id],\n          sendMailTo: [savedUser._id],\n          public: true\n        })\n\n        group.save(function (err, group) {\n          if (err) return callback(err)\n\n          // Send welcome email\n          var path = require('path')\n          var mailer = require('../mailer')\n          var Email = require('email-templates')\n          var templateDir = path.resolve(__dirname, '..', 'mailer', 'templates')\n\n          var email = new Email({\n            views: {\n              root: templateDir,\n              options: {\n                extension: 'handlebars'\n              }\n            }\n          })\n\n          var settingSchema = require('./setting')\n          settingSchema.getSetting('gen:siteurl', function (err, setting) {\n            if (err) return callback(err)\n\n            if (!setting) {\n              setting = { value: '' }\n            }\n\n            var dataObject = {\n              user: savedUser,\n              plainTextPassword: plainTextPass,\n              baseUrl: setting.value\n            }\n\n            email\n              .render('public-account-created', dataObject)\n              .then(function (html) {\n                var mailOptions = {\n                  to: savedUser.email,\n                  subject: 'Welcome to trudesk! - Here are your account details.',\n                  html: html,\n                  generateTextFromHTML: true\n                }\n\n                mailer.sendMail(mailOptions, function (err) {\n                  if (err) {\n                    winston.warn(err)\n                    return callback(err)\n                  }\n\n                  return callback(null, { user: savedUser, group: group })\n                })\n              })\n              .catch(function (err) {\n                winston.warn(err)\n                return callback(err)\n              })\n          })\n        })\n      })\n    })\n  })\n}\n\nuserSchema.statics.getCustomers = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n  return self\n    .model(COLLECTION)\n    .find({}, '-password -resetPassHash -resetPassExpire')\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var customerRoleIds = _.filter(accounts, function (a) {\n        return !a.role.isAdmin && !a.role.isAgent\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .find({ role: { $in: customerRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\nuserSchema.statics.getAgents = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n\n  return self\n    .model(COLLECTION)\n    .find({})\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var agentRoleIds = _.filter(accounts, function (a) {\n        return a.role.isAgent\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .model(COLLECTION)\n        .find({ role: { $in: agentRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\nuserSchema.statics.getAdmins = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n\n  return self\n    .model(COLLECTION)\n    .find({})\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var adminRoleIds = _.filter(accounts, function (a) {\n        return a.role.isAdmin\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .model(COLLECTION)\n        .find({ role: { $in: adminRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\n/**\n * Checks if a user has device token already\n *\n * @memberof User\n * @instance\n * @method hasDeviceToken\n *\n * @param {User} user User to check against\n * @param {String} token token to check for in given user\n * @param {Number} type Type of Device token to check.\n * @return {Boolean}\n * @example\n * type:\n *   1: iOS\n *   2: Android\n *   3: Windows\n */\nfunction hasDeviceToken (user, token, type) {\n  if (type === 1) {\n    var matches = _.filter(user.iOSDeviceTokens, function (value) {\n      if (value === token) {\n        return value\n      }\n    })\n\n    return matches.length > 0\n  }\n\n  return false\n}\n\nmodule.exports = mongoose.model(COLLECTION, userSchema)\n"], "filenames": ["src/helpers/utils/index.js", "src/models/user.js"], "buggy_code_start_loc": [18, 93], "buggy_code_end_loc": [18, 98], "fixing_code_start_loc": [19, 93], "fixing_code_end_loc": [26, 98], "type": "CWE-190", "message": "The trudesk application allows large characters to insert in the input field \"Full Name\" on the signup field which can allow attackers to cause a Denial of Service (DoS) via a crafted HTTP request in GitHub repository polonel/trudesk prior to 1.2.2. This can lead to Denial of service.", "other": {"cve": {"id": "CVE-2022-1718", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-29T03:15:15.083", "lastModified": "2022-09-30T19:32:08.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The trudesk application allows large characters to insert in the input field \"Full Name\" on the signup field which can allow attackers to cause a Denial of Service (DoS) via a crafted HTTP request in GitHub repository polonel/trudesk prior to 1.2.2. This can lead to Denial of service."}, {"lang": "es", "value": "La aplicaci\u00f3n trudesk permite insertar caracteres grandes en el campo de entrada \"Full Name\" en el campo de registro, lo que puede permitir a atacantes causar una Denegaci\u00f3n de Servicio (DoS) por medio de una petici\u00f3n HTTP dise\u00f1ada en el repositorio de GitHub polonel/trudesk versiones anteriores a 1.2.2. Esto puede conllevar a una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:H/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 0.6, "impactScore": 6.0}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trudesk_project:trudesk:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.2", "matchCriteriaId": "129D9FED-E43F-47B1-8FB3-012D00E93181"}]}]}], "references": [{"url": "https://github.com/polonel/trudesk/commit/87e231e04495fb705fe1e03cb56fc4136bafe895", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/1ff8afe4-6ff7-45aa-a652-d8aac7e5be7e", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/polonel/trudesk/commit/87e231e04495fb705fe1e03cb56fc4136bafe895"}}