{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Xen event channels\n *\n * Xen models interrupts with abstract event channels.  Because each\n * domain gets 1024 event channels, but NR_IRQ is not that large, we\n * must dynamically map irqs<->event channels.  The event channels\n * interface with the rest of the kernel by defining a xen interrupt\n * chip.  When an event is received, it is mapped to an irq and sent\n * through the normal interrupt processing path.\n *\n * There are four kinds of events which can be mapped to an event\n * channel:\n *\n * 1. Inter-domain notifications.  This includes all the virtual\n *    device events, since they're driven by front-ends in another domain\n *    (typically dom0).\n * 2. VIRQs, typically used for timers.  These are per-cpu events.\n * 3. IPIs.\n * 4. PIRQs - Hardware interrupts.\n *\n * Jeremy Fitzhardinge <jeremy@xensource.com>, XenSource Inc, 2007\n */\n\n#define pr_fmt(fmt) \"xen:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/linkage.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/memblock.h>\n#include <linux/slab.h>\n#include <linux/irqnr.h>\n#include <linux/pci.h>\n\n#ifdef CONFIG_X86\n#include <asm/desc.h>\n#include <asm/ptrace.h>\n#include <asm/idtentry.h>\n#include <asm/irq.h>\n#include <asm/io_apic.h>\n#include <asm/i8259.h>\n#include <asm/xen/pci.h>\n#endif\n#include <asm/sync_bitops.h>\n#include <asm/xen/hypercall.h>\n#include <asm/xen/hypervisor.h>\n#include <xen/page.h>\n\n#include <xen/xen.h>\n#include <xen/hvm.h>\n#include <xen/xen-ops.h>\n#include <xen/events.h>\n#include <xen/interface/xen.h>\n#include <xen/interface/event_channel.h>\n#include <xen/interface/hvm/hvm_op.h>\n#include <xen/interface/hvm/params.h>\n#include <xen/interface/physdev.h>\n#include <xen/interface/sched.h>\n#include <xen/interface/vcpu.h>\n#include <asm/hw_irq.h>\n\n#include \"events_internal.h\"\n\nconst struct evtchn_ops *evtchn_ops;\n\n/*\n * This lock protects updates to the following mapping and reference-count\n * arrays. The lock does not need to be acquired to read the mapping tables.\n */\nstatic DEFINE_MUTEX(irq_mapping_update_lock);\n\nstatic LIST_HEAD(xen_irq_list_head);\n\n/* IRQ <-> VIRQ mapping. */\nstatic DEFINE_PER_CPU(int [NR_VIRQS], virq_to_irq) = {[0 ... NR_VIRQS-1] = -1};\n\n/* IRQ <-> IPI mapping */\nstatic DEFINE_PER_CPU(int [XEN_NR_IPIS], ipi_to_irq) = {[0 ... XEN_NR_IPIS-1] = -1};\n\nint **evtchn_to_irq;\n#ifdef CONFIG_X86\nstatic unsigned long *pirq_eoi_map;\n#endif\nstatic bool (*pirq_needs_eoi)(unsigned irq);\n\n#define EVTCHN_ROW(e)  (e / (PAGE_SIZE/sizeof(**evtchn_to_irq)))\n#define EVTCHN_COL(e)  (e % (PAGE_SIZE/sizeof(**evtchn_to_irq)))\n#define EVTCHN_PER_ROW (PAGE_SIZE / sizeof(**evtchn_to_irq))\n\n/* Xen will never allocate port zero for any purpose. */\n#define VALID_EVTCHN(chn)\t((chn) != 0)\n\nstatic struct irq_info *legacy_info_ptrs[NR_IRQS_LEGACY];\n\nstatic struct irq_chip xen_dynamic_chip;\nstatic struct irq_chip xen_percpu_chip;\nstatic struct irq_chip xen_pirq_chip;\nstatic void enable_dynirq(struct irq_data *data);\nstatic void disable_dynirq(struct irq_data *data);\n\nstatic void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}\n\nstatic void clear_evtchn_to_irq_all(void)\n{\n\tunsigned row;\n\n\tfor (row = 0; row < EVTCHN_ROW(xen_evtchn_max_channels()); row++) {\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\tcontinue;\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n}\n\nstatic int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\n\tif (evtchn_to_irq[row] == NULL) {\n\t\t/* Unallocated irq entries return -1 anyway */\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\n\tevtchn_to_irq[row][col] = irq;\n\treturn 0;\n}\n\nint get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}\n\n/* Get info for IRQ */\nstruct irq_info *info_for_irq(unsigned irq)\n{\n\tif (irq < nr_legacy_irqs())\n\t\treturn legacy_info_ptrs[irq];\n\telse\n\t\treturn irq_get_chip_data(irq);\n}\n\nstatic void set_info_for_irq(unsigned int irq, struct irq_info *info)\n{\n\tif (irq < nr_legacy_irqs())\n\t\tlegacy_info_ptrs[irq] = info;\n\telse\n\t\tirq_set_chip_data(irq, info);\n}\n\n/* Constructors for packed IRQ information. */\nstatic int xen_irq_info_common_setup(struct irq_info *info,\n\t\t\t\t     unsigned irq,\n\t\t\t\t     enum xen_irq_type type,\n\t\t\t\t     evtchn_port_t evtchn,\n\t\t\t\t     unsigned short cpu)\n{\n\tint ret;\n\n\tBUG_ON(info->type != IRQT_UNBOUND && info->type != type);\n\n\tinfo->type = type;\n\tinfo->irq = irq;\n\tinfo->evtchn = evtchn;\n\tinfo->cpu = cpu;\n\n\tret = set_evtchn_to_irq(evtchn, irq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tirq_clear_status_flags(irq, IRQ_NOREQUEST|IRQ_NOAUTOEN);\n\n\treturn xen_evtchn_port_setup(info);\n}\n\nstatic int xen_irq_info_evtchn_setup(unsigned irq,\n\t\t\t\t     evtchn_port_t evtchn)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\treturn xen_irq_info_common_setup(info, irq, IRQT_EVTCHN, evtchn, 0);\n}\n\nstatic int xen_irq_info_ipi_setup(unsigned cpu,\n\t\t\t\t  unsigned irq,\n\t\t\t\t  evtchn_port_t evtchn,\n\t\t\t\t  enum ipi_vector ipi)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tinfo->u.ipi = ipi;\n\n\tper_cpu(ipi_to_irq, cpu)[ipi] = irq;\n\n\treturn xen_irq_info_common_setup(info, irq, IRQT_IPI, evtchn, 0);\n}\n\nstatic int xen_irq_info_virq_setup(unsigned cpu,\n\t\t\t\t   unsigned irq,\n\t\t\t\t   evtchn_port_t evtchn,\n\t\t\t\t   unsigned virq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tinfo->u.virq = virq;\n\n\tper_cpu(virq_to_irq, cpu)[virq] = irq;\n\n\treturn xen_irq_info_common_setup(info, irq, IRQT_VIRQ, evtchn, 0);\n}\n\nstatic int xen_irq_info_pirq_setup(unsigned irq,\n\t\t\t\t   evtchn_port_t evtchn,\n\t\t\t\t   unsigned pirq,\n\t\t\t\t   unsigned gsi,\n\t\t\t\t   uint16_t domid,\n\t\t\t\t   unsigned char flags)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tinfo->u.pirq.pirq = pirq;\n\tinfo->u.pirq.gsi = gsi;\n\tinfo->u.pirq.domid = domid;\n\tinfo->u.pirq.flags = flags;\n\n\treturn xen_irq_info_common_setup(info, irq, IRQT_PIRQ, evtchn, 0);\n}\n\nstatic void xen_irq_info_cleanup(struct irq_info *info)\n{\n\tset_evtchn_to_irq(info->evtchn, -1);\n\tinfo->evtchn = 0;\n}\n\n/*\n * Accessors for packed IRQ information.\n */\nevtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n\t\treturn 0;\n\n\treturn info_for_irq(irq)->evtchn;\n}\n\nunsigned int irq_from_evtchn(evtchn_port_t evtchn)\n{\n\treturn get_evtchn_to_irq(evtchn);\n}\nEXPORT_SYMBOL_GPL(irq_from_evtchn);\n\nint irq_from_virq(unsigned int cpu, unsigned int virq)\n{\n\treturn per_cpu(virq_to_irq, cpu)[virq];\n}\n\nstatic enum ipi_vector ipi_from_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tBUG_ON(info == NULL);\n\tBUG_ON(info->type != IRQT_IPI);\n\n\treturn info->u.ipi;\n}\n\nstatic unsigned virq_from_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tBUG_ON(info == NULL);\n\tBUG_ON(info->type != IRQT_VIRQ);\n\n\treturn info->u.virq;\n}\n\nstatic unsigned pirq_from_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tBUG_ON(info == NULL);\n\tBUG_ON(info->type != IRQT_PIRQ);\n\n\treturn info->u.pirq.pirq;\n}\n\nstatic enum xen_irq_type type_from_irq(unsigned irq)\n{\n\treturn info_for_irq(irq)->type;\n}\n\nunsigned cpu_from_irq(unsigned irq)\n{\n\treturn info_for_irq(irq)->cpu;\n}\n\nunsigned int cpu_from_evtchn(evtchn_port_t evtchn)\n{\n\tint irq = get_evtchn_to_irq(evtchn);\n\tunsigned ret = 0;\n\n\tif (irq != -1)\n\t\tret = cpu_from_irq(irq);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_X86\nstatic bool pirq_check_eoi_map(unsigned irq)\n{\n\treturn test_bit(pirq_from_irq(irq), pirq_eoi_map);\n}\n#endif\n\nstatic bool pirq_needs_eoi_flag(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tBUG_ON(info->type != IRQT_PIRQ);\n\n\treturn info->u.pirq.flags & PIRQ_NEEDS_EOI;\n}\n\nstatic void bind_evtchn_to_cpu(evtchn_port_t evtchn, unsigned int cpu)\n{\n\tint irq = get_evtchn_to_irq(evtchn);\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tBUG_ON(irq == -1);\n#ifdef CONFIG_SMP\n\tcpumask_copy(irq_get_affinity_mask(irq), cpumask_of(cpu));\n#endif\n\txen_evtchn_port_bind_to_cpu(info, cpu);\n\n\tinfo->cpu = cpu;\n}\n\n/**\n * notify_remote_via_irq - send event to remote end of event channel via irq\n * @irq: irq of event channel to send event to\n *\n * Unlike notify_remote_via_evtchn(), this is safe to use across\n * save/restore. Notifications on a broken connection are silently\n * dropped.\n */\nvoid notify_remote_via_irq(int irq)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tnotify_remote_via_evtchn(evtchn);\n}\nEXPORT_SYMBOL_GPL(notify_remote_via_irq);\n\nstatic void xen_irq_init(unsigned irq)\n{\n\tstruct irq_info *info;\n#ifdef CONFIG_SMP\n\t/* By default all event channels notify CPU#0. */\n\tcpumask_copy(irq_get_affinity_mask(irq), cpumask_of(0));\n#endif\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (info == NULL)\n\t\tpanic(\"Unable to allocate metadata for IRQ%d\\n\", irq);\n\n\tinfo->type = IRQT_UNBOUND;\n\tinfo->refcnt = -1;\n\n\tset_info_for_irq(irq, info);\n\n\tlist_add_tail(&info->list, &xen_irq_list_head);\n}\n\nstatic int __must_check xen_allocate_irqs_dynamic(int nvec)\n{\n\tint i, irq = irq_alloc_descs(-1, 0, nvec, -1);\n\n\tif (irq >= 0) {\n\t\tfor (i = 0; i < nvec; i++)\n\t\t\txen_irq_init(irq + i);\n\t}\n\n\treturn irq;\n}\n\nstatic inline int __must_check xen_allocate_irq_dynamic(void)\n{\n\n\treturn xen_allocate_irqs_dynamic(1);\n}\n\nstatic int __must_check xen_allocate_irq_gsi(unsigned gsi)\n{\n\tint irq;\n\n\t/*\n\t * A PV guest has no concept of a GSI (since it has no ACPI\n\t * nor access to/knowledge of the physical APICs). Therefore\n\t * all IRQs are dynamically allocated from the entire IRQ\n\t * space.\n\t */\n\tif (xen_pv_domain() && !xen_initial_domain())\n\t\treturn xen_allocate_irq_dynamic();\n\n\t/* Legacy IRQ descriptors are already allocated by the arch. */\n\tif (gsi < nr_legacy_irqs())\n\t\tirq = gsi;\n\telse\n\t\tirq = irq_alloc_desc_at(gsi, -1);\n\n\txen_irq_init(irq);\n\n\treturn irq;\n}\n\nstatic void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\tlist_del(&info->list);\n\n\tset_info_for_irq(irq, NULL);\n\n\tWARN_ON(info->refcnt > 0);\n\n\tkfree(info);\n\n\t/* Legacy IRQ descriptors are managed by the arch. */\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\n\tirq_free_desc(irq);\n}\n\nstatic void xen_evtchn_close(evtchn_port_t port)\n{\n\tstruct evtchn_close close;\n\n\tclose.port = port;\n\tif (HYPERVISOR_event_channel_op(EVTCHNOP_close, &close) != 0)\n\t\tBUG();\n}\n\nstatic void pirq_query_unmask(int irq)\n{\n\tstruct physdev_irq_status_query irq_status;\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tBUG_ON(info->type != IRQT_PIRQ);\n\n\tirq_status.irq = pirq_from_irq(irq);\n\tif (HYPERVISOR_physdev_op(PHYSDEVOP_irq_status_query, &irq_status))\n\t\tirq_status.flags = 0;\n\n\tinfo->u.pirq.flags &= ~PIRQ_NEEDS_EOI;\n\tif (irq_status.flags & XENIRQSTAT_needs_eoi)\n\t\tinfo->u.pirq.flags |= PIRQ_NEEDS_EOI;\n}\n\nstatic void eoi_pirq(struct irq_data *data)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(data->irq);\n\tstruct physdev_eoi eoi = { .irq = pirq_from_irq(data->irq) };\n\tint rc = 0;\n\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\n\tif (unlikely(irqd_is_setaffinity_pending(data)) &&\n\t    likely(!irqd_irq_disabled(data))) {\n\t\tint masked = test_and_set_mask(evtchn);\n\n\t\tclear_evtchn(evtchn);\n\n\t\tirq_move_masked_irq(data);\n\n\t\tif (!masked)\n\t\t\tunmask_evtchn(evtchn);\n\t} else\n\t\tclear_evtchn(evtchn);\n\n\tif (pirq_needs_eoi(data->irq)) {\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_eoi, &eoi);\n\t\tWARN_ON(rc);\n\t}\n}\n\nstatic void mask_ack_pirq(struct irq_data *data)\n{\n\tdisable_dynirq(data);\n\teoi_pirq(data);\n}\n\nstatic unsigned int __startup_pirq(unsigned int irq)\n{\n\tstruct evtchn_bind_pirq bind_pirq;\n\tstruct irq_info *info = info_for_irq(irq);\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\tint rc;\n\n\tBUG_ON(info->type != IRQT_PIRQ);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tgoto out;\n\n\tbind_pirq.pirq = pirq_from_irq(irq);\n\t/* NB. We are happy to share unless we are probing. */\n\tbind_pirq.flags = info->u.pirq.flags & PIRQ_SHAREABLE ?\n\t\t\t\t\tBIND_PIRQ__WILL_SHARE : 0;\n\trc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_pirq, &bind_pirq);\n\tif (rc != 0) {\n\t\tpr_warn(\"Failed to obtain physical IRQ %d\\n\", irq);\n\t\treturn 0;\n\t}\n\tevtchn = bind_pirq.port;\n\n\tpirq_query_unmask(irq);\n\n\trc = set_evtchn_to_irq(evtchn, irq);\n\tif (rc)\n\t\tgoto err;\n\n\tinfo->evtchn = evtchn;\n\tbind_evtchn_to_cpu(evtchn, 0);\n\n\trc = xen_evtchn_port_setup(info);\n\tif (rc)\n\t\tgoto err;\n\nout:\n\tunmask_evtchn(evtchn);\n\teoi_pirq(irq_get_irq_data(irq));\n\n\treturn 0;\n\nerr:\n\tpr_err(\"irq%d: Failed to set port to irq mapping (%d)\\n\", irq, rc);\n\txen_evtchn_close(evtchn);\n\treturn 0;\n}\n\nstatic unsigned int startup_pirq(struct irq_data *data)\n{\n\treturn __startup_pirq(data->irq);\n}\n\nstatic void shutdown_pirq(struct irq_data *data)\n{\n\tunsigned int irq = data->irq;\n\tstruct irq_info *info = info_for_irq(irq);\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\n\tBUG_ON(info->type != IRQT_PIRQ);\n\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\n\tmask_evtchn(evtchn);\n\txen_evtchn_close(evtchn);\n\txen_irq_info_cleanup(info);\n}\n\nstatic void enable_pirq(struct irq_data *data)\n{\n\tenable_dynirq(data);\n}\n\nstatic void disable_pirq(struct irq_data *data)\n{\n\tdisable_dynirq(data);\n}\n\nint xen_irq_from_gsi(unsigned gsi)\n{\n\tstruct irq_info *info;\n\n\tlist_for_each_entry(info, &xen_irq_list_head, list) {\n\t\tif (info->type != IRQT_PIRQ)\n\t\t\tcontinue;\n\n\t\tif (info->u.pirq.gsi == gsi)\n\t\t\treturn info->irq;\n\t}\n\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(xen_irq_from_gsi);\n\nstatic void __unbind_from_irq(unsigned int irq)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tif (info->refcnt > 0) {\n\t\tinfo->refcnt--;\n\t\tif (info->refcnt != 0)\n\t\t\treturn;\n\t}\n\n\tif (VALID_EVTCHN(evtchn)) {\n\t\tunsigned int cpu = cpu_from_irq(irq);\n\n\t\txen_evtchn_close(evtchn);\n\n\t\tswitch (type_from_irq(irq)) {\n\t\tcase IRQT_VIRQ:\n\t\t\tper_cpu(virq_to_irq, cpu)[virq_from_irq(irq)] = -1;\n\t\t\tbreak;\n\t\tcase IRQT_IPI:\n\t\t\tper_cpu(ipi_to_irq, cpu)[ipi_from_irq(irq)] = -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\txen_irq_info_cleanup(info);\n\t}\n\n\txen_free_irq(irq);\n}\n\n/*\n * Do not make any assumptions regarding the relationship between the\n * IRQ number returned here and the Xen pirq argument.\n *\n * Note: We don't assign an event channel until the irq actually started\n * up.  Return an existing irq if we've already got one for the gsi.\n *\n * Shareable implies level triggered, not shareable implies edge\n * triggered here.\n */\nint xen_bind_pirq_gsi_to_irq(unsigned gsi,\n\t\t\t     unsigned pirq, int shareable, char *name)\n{\n\tint irq = -1;\n\tstruct physdev_irq irq_op;\n\tint ret;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = xen_irq_from_gsi(gsi);\n\tif (irq != -1) {\n\t\tpr_info(\"%s: returning irq %d for gsi %u\\n\",\n\t\t\t__func__, irq, gsi);\n\t\tgoto out;\n\t}\n\n\tirq = xen_allocate_irq_gsi(gsi);\n\tif (irq < 0)\n\t\tgoto out;\n\n\tirq_op.irq = irq;\n\tirq_op.vector = 0;\n\n\t/* Only the privileged domain can do this. For non-priv, the pcifront\n\t * driver provides a PCI bus that does the call to do exactly\n\t * this in the priv domain. */\n\tif (xen_initial_domain() &&\n\t    HYPERVISOR_physdev_op(PHYSDEVOP_alloc_irq_vector, &irq_op)) {\n\t\txen_free_irq(irq);\n\t\tirq = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tret = xen_irq_info_pirq_setup(irq, 0, pirq, gsi, DOMID_SELF,\n\t\t\t       shareable ? PIRQ_SHAREABLE : 0);\n\tif (ret < 0) {\n\t\t__unbind_from_irq(irq);\n\t\tirq = ret;\n\t\tgoto out;\n\t}\n\n\tpirq_query_unmask(irq);\n\t/* We try to use the handler with the appropriate semantic for the\n\t * type of interrupt: if the interrupt is an edge triggered\n\t * interrupt we use handle_edge_irq.\n\t *\n\t * On the other hand if the interrupt is level triggered we use\n\t * handle_fasteoi_irq like the native code does for this kind of\n\t * interrupts.\n\t *\n\t * Depending on the Xen version, pirq_needs_eoi might return true\n\t * not only for level triggered interrupts but for edge triggered\n\t * interrupts too. In any case Xen always honors the eoi mechanism,\n\t * not injecting any more pirqs of the same kind if the first one\n\t * hasn't received an eoi yet. Therefore using the fasteoi handler\n\t * is the right choice either way.\n\t */\n\tif (shareable)\n\t\tirq_set_chip_and_handler_name(irq, &xen_pirq_chip,\n\t\t\t\thandle_fasteoi_irq, name);\n\telse\n\t\tirq_set_chip_and_handler_name(irq, &xen_pirq_chip,\n\t\t\t\thandle_edge_irq, name);\n\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\n\treturn irq;\n}\n\n#ifdef CONFIG_PCI_MSI\nint xen_allocate_pirq_msi(struct pci_dev *dev, struct msi_desc *msidesc)\n{\n\tint rc;\n\tstruct physdev_get_free_pirq op_get_free_pirq;\n\n\top_get_free_pirq.type = MAP_PIRQ_TYPE_MSI;\n\trc = HYPERVISOR_physdev_op(PHYSDEVOP_get_free_pirq, &op_get_free_pirq);\n\n\tWARN_ONCE(rc == -ENOSYS,\n\t\t  \"hypervisor does not support the PHYSDEVOP_get_free_pirq interface\\n\");\n\n\treturn rc ? -1 : op_get_free_pirq.pirq;\n}\n\nint xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,\n\t\t\t     int pirq, int nvec, const char *name, domid_t domid)\n{\n\tint i, irq, ret;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = xen_allocate_irqs_dynamic(nvec);\n\tif (irq < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < nvec; i++) {\n\t\tirq_set_chip_and_handler_name(irq + i, &xen_pirq_chip, handle_edge_irq, name);\n\n\t\tret = xen_irq_info_pirq_setup(irq + i, 0, pirq + i, 0, domid,\n\t\t\t\t\t      i == 0 ? 0 : PIRQ_MSI_GROUP);\n\t\tif (ret < 0)\n\t\t\tgoto error_irq;\n\t}\n\n\tret = irq_set_msi_desc(irq, msidesc);\n\tif (ret < 0)\n\t\tgoto error_irq;\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\treturn irq;\nerror_irq:\n\twhile (nvec--)\n\t\t__unbind_from_irq(irq + nvec);\n\tmutex_unlock(&irq_mapping_update_lock);\n\treturn ret;\n}\n#endif\n\nint xen_destroy_irq(int irq)\n{\n\tstruct physdev_unmap_pirq unmap_irq;\n\tstruct irq_info *info = info_for_irq(irq);\n\tint rc = -ENOENT;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\t/*\n\t * If trying to remove a vector in a MSI group different\n\t * than the first one skip the PIRQ unmap unless this vector\n\t * is the first one in the group.\n\t */\n\tif (xen_initial_domain() && !(info->u.pirq.flags & PIRQ_MSI_GROUP)) {\n\t\tunmap_irq.pirq = info->u.pirq.pirq;\n\t\tunmap_irq.domid = info->u.pirq.domid;\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_unmap_pirq, &unmap_irq);\n\t\t/* If another domain quits without making the pci_disable_msix\n\t\t * call, the Xen hypervisor takes care of freeing the PIRQs\n\t\t * (free_domain_pirqs).\n\t\t */\n\t\tif ((rc == -ESRCH && info->u.pirq.domid != DOMID_SELF))\n\t\t\tpr_info(\"domain %d does not have %d anymore\\n\",\n\t\t\t\tinfo->u.pirq.domid, info->u.pirq.pirq);\n\t\telse if (rc) {\n\t\t\tpr_warn(\"unmap irq failed %d\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\txen_free_irq(irq);\n\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\treturn rc;\n}\n\nint xen_irq_from_pirq(unsigned pirq)\n{\n\tint irq;\n\n\tstruct irq_info *info;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tlist_for_each_entry(info, &xen_irq_list_head, list) {\n\t\tif (info->type != IRQT_PIRQ)\n\t\t\tcontinue;\n\t\tirq = info->irq;\n\t\tif (info->u.pirq.pirq == pirq)\n\t\t\tgoto out;\n\t}\n\tirq = -1;\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\n\treturn irq;\n}\n\n\nint xen_pirq_from_irq(unsigned irq)\n{\n\treturn pirq_from_irq(irq);\n}\nEXPORT_SYMBOL_GPL(xen_pirq_from_irq);\n\nint bind_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tint irq;\n\tint ret;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = get_evtchn_to_irq(evtchn);\n\n\tif (irq == -1) {\n\t\tirq = xen_allocate_irq_dynamic();\n\t\tif (irq < 0)\n\t\t\tgoto out;\n\n\t\tirq_set_chip_and_handler_name(irq, &xen_dynamic_chip,\n\t\t\t\t\t      handle_edge_irq, \"event\");\n\n\t\tret = xen_irq_info_evtchn_setup(irq, evtchn);\n\t\tif (ret < 0) {\n\t\t\t__unbind_from_irq(irq);\n\t\t\tirq = ret;\n\t\t\tgoto out;\n\t\t}\n\t\t/* New interdomain events are bound to VCPU 0. */\n\t\tbind_evtchn_to_cpu(evtchn, 0);\n\t} else {\n\t\tstruct irq_info *info = info_for_irq(irq);\n\t\tWARN_ON(info == NULL || info->type != IRQT_EVTCHN);\n\t}\n\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(bind_evtchn_to_irq);\n\nstatic int bind_ipi_to_irq(unsigned int ipi, unsigned int cpu)\n{\n\tstruct evtchn_bind_ipi bind_ipi;\n\tevtchn_port_t evtchn;\n\tint ret, irq;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = per_cpu(ipi_to_irq, cpu)[ipi];\n\n\tif (irq == -1) {\n\t\tirq = xen_allocate_irq_dynamic();\n\t\tif (irq < 0)\n\t\t\tgoto out;\n\n\t\tirq_set_chip_and_handler_name(irq, &xen_percpu_chip,\n\t\t\t\t\t      handle_percpu_irq, \"ipi\");\n\n\t\tbind_ipi.vcpu = xen_vcpu_nr(cpu);\n\t\tif (HYPERVISOR_event_channel_op(EVTCHNOP_bind_ipi,\n\t\t\t\t\t\t&bind_ipi) != 0)\n\t\t\tBUG();\n\t\tevtchn = bind_ipi.port;\n\n\t\tret = xen_irq_info_ipi_setup(cpu, irq, evtchn, ipi);\n\t\tif (ret < 0) {\n\t\t\t__unbind_from_irq(irq);\n\t\t\tirq = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tbind_evtchn_to_cpu(evtchn, cpu);\n\t} else {\n\t\tstruct irq_info *info = info_for_irq(irq);\n\t\tWARN_ON(info == NULL || info->type != IRQT_IPI);\n\t}\n\n out:\n\tmutex_unlock(&irq_mapping_update_lock);\n\treturn irq;\n}\n\nint bind_interdomain_evtchn_to_irq(unsigned int remote_domain,\n\t\t\t\t   evtchn_port_t remote_port)\n{\n\tstruct evtchn_bind_interdomain bind_interdomain;\n\tint err;\n\n\tbind_interdomain.remote_dom  = remote_domain;\n\tbind_interdomain.remote_port = remote_port;\n\n\terr = HYPERVISOR_event_channel_op(EVTCHNOP_bind_interdomain,\n\t\t\t\t\t  &bind_interdomain);\n\n\treturn err ? : bind_evtchn_to_irq(bind_interdomain.local_port);\n}\nEXPORT_SYMBOL_GPL(bind_interdomain_evtchn_to_irq);\n\nstatic int find_virq(unsigned int virq, unsigned int cpu, evtchn_port_t *evtchn)\n{\n\tstruct evtchn_status status;\n\tevtchn_port_t port;\n\tint rc = -ENOENT;\n\n\tmemset(&status, 0, sizeof(status));\n\tfor (port = 0; port < xen_evtchn_max_channels(); port++) {\n\t\tstatus.dom = DOMID_SELF;\n\t\tstatus.port = port;\n\t\trc = HYPERVISOR_event_channel_op(EVTCHNOP_status, &status);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tif (status.status != EVTCHNSTAT_virq)\n\t\t\tcontinue;\n\t\tif (status.u.virq == virq && status.vcpu == xen_vcpu_nr(cpu)) {\n\t\t\t*evtchn = port;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\n/**\n * xen_evtchn_nr_channels - number of usable event channel ports\n *\n * This may be less than the maximum supported by the current\n * hypervisor ABI. Use xen_evtchn_max_channels() for the maximum\n * supported.\n */\nunsigned xen_evtchn_nr_channels(void)\n{\n        return evtchn_ops->nr_channels();\n}\nEXPORT_SYMBOL_GPL(xen_evtchn_nr_channels);\n\nint bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu)\n{\n\tstruct evtchn_bind_virq bind_virq;\n\tevtchn_port_t evtchn = 0;\n\tint irq, ret;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = per_cpu(virq_to_irq, cpu)[virq];\n\n\tif (irq == -1) {\n\t\tirq = xen_allocate_irq_dynamic();\n\t\tif (irq < 0)\n\t\t\tgoto out;\n\n\t\tif (percpu)\n\t\t\tirq_set_chip_and_handler_name(irq, &xen_percpu_chip,\n\t\t\t\t\t\t      handle_percpu_irq, \"virq\");\n\t\telse\n\t\t\tirq_set_chip_and_handler_name(irq, &xen_dynamic_chip,\n\t\t\t\t\t\t      handle_edge_irq, \"virq\");\n\n\t\tbind_virq.virq = virq;\n\t\tbind_virq.vcpu = xen_vcpu_nr(cpu);\n\t\tret = HYPERVISOR_event_channel_op(EVTCHNOP_bind_virq,\n\t\t\t\t\t\t&bind_virq);\n\t\tif (ret == 0)\n\t\t\tevtchn = bind_virq.port;\n\t\telse {\n\t\t\tif (ret == -EEXIST)\n\t\t\t\tret = find_virq(virq, cpu, &evtchn);\n\t\t\tBUG_ON(ret < 0);\n\t\t}\n\n\t\tret = xen_irq_info_virq_setup(cpu, irq, evtchn, virq);\n\t\tif (ret < 0) {\n\t\t\t__unbind_from_irq(irq);\n\t\t\tirq = ret;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbind_evtchn_to_cpu(evtchn, cpu);\n\t} else {\n\t\tstruct irq_info *info = info_for_irq(irq);\n\t\tWARN_ON(info == NULL || info->type != IRQT_VIRQ);\n\t}\n\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\n\treturn irq;\n}\n\nstatic void unbind_from_irq(unsigned int irq)\n{\n\tmutex_lock(&irq_mapping_update_lock);\n\t__unbind_from_irq(irq);\n\tmutex_unlock(&irq_mapping_update_lock);\n}\n\nint bind_evtchn_to_irqhandler(evtchn_port_t evtchn,\n\t\t\t      irq_handler_t handler,\n\t\t\t      unsigned long irqflags,\n\t\t\t      const char *devname, void *dev_id)\n{\n\tint irq, retval;\n\n\tirq = bind_evtchn_to_irq(evtchn);\n\tif (irq < 0)\n\t\treturn irq;\n\tretval = request_irq(irq, handler, irqflags, devname, dev_id);\n\tif (retval != 0) {\n\t\tunbind_from_irq(irq);\n\t\treturn retval;\n\t}\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(bind_evtchn_to_irqhandler);\n\nint bind_interdomain_evtchn_to_irqhandler(unsigned int remote_domain,\n\t\t\t\t\t  evtchn_port_t remote_port,\n\t\t\t\t\t  irq_handler_t handler,\n\t\t\t\t\t  unsigned long irqflags,\n\t\t\t\t\t  const char *devname,\n\t\t\t\t\t  void *dev_id)\n{\n\tint irq, retval;\n\n\tirq = bind_interdomain_evtchn_to_irq(remote_domain, remote_port);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tretval = request_irq(irq, handler, irqflags, devname, dev_id);\n\tif (retval != 0) {\n\t\tunbind_from_irq(irq);\n\t\treturn retval;\n\t}\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(bind_interdomain_evtchn_to_irqhandler);\n\nint bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,\n\t\t\t    irq_handler_t handler,\n\t\t\t    unsigned long irqflags, const char *devname, void *dev_id)\n{\n\tint irq, retval;\n\n\tirq = bind_virq_to_irq(virq, cpu, irqflags & IRQF_PERCPU);\n\tif (irq < 0)\n\t\treturn irq;\n\tretval = request_irq(irq, handler, irqflags, devname, dev_id);\n\tif (retval != 0) {\n\t\tunbind_from_irq(irq);\n\t\treturn retval;\n\t}\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(bind_virq_to_irqhandler);\n\nint bind_ipi_to_irqhandler(enum ipi_vector ipi,\n\t\t\t   unsigned int cpu,\n\t\t\t   irq_handler_t handler,\n\t\t\t   unsigned long irqflags,\n\t\t\t   const char *devname,\n\t\t\t   void *dev_id)\n{\n\tint irq, retval;\n\n\tirq = bind_ipi_to_irq(ipi, cpu);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirqflags |= IRQF_NO_SUSPEND | IRQF_FORCE_RESUME | IRQF_EARLY_RESUME;\n\tretval = request_irq(irq, handler, irqflags, devname, dev_id);\n\tif (retval != 0) {\n\t\tunbind_from_irq(irq);\n\t\treturn retval;\n\t}\n\n\treturn irq;\n}\n\nvoid unbind_from_irqhandler(unsigned int irq, void *dev_id)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\tfree_irq(irq, dev_id);\n\tunbind_from_irq(irq);\n}\nEXPORT_SYMBOL_GPL(unbind_from_irqhandler);\n\n/**\n * xen_set_irq_priority() - set an event channel priority.\n * @irq:irq bound to an event channel.\n * @priority: priority between XEN_IRQ_PRIORITY_MAX and XEN_IRQ_PRIORITY_MIN.\n */\nint xen_set_irq_priority(unsigned irq, unsigned priority)\n{\n\tstruct evtchn_set_priority set_priority;\n\n\tset_priority.port = evtchn_from_irq(irq);\n\tset_priority.priority = priority;\n\n\treturn HYPERVISOR_event_channel_op(EVTCHNOP_set_priority,\n\t\t\t\t\t   &set_priority);\n}\nEXPORT_SYMBOL_GPL(xen_set_irq_priority);\n\nint evtchn_make_refcounted(evtchn_port_t evtchn)\n{\n\tint irq = get_evtchn_to_irq(evtchn);\n\tstruct irq_info *info;\n\n\tif (irq == -1)\n\t\treturn -ENOENT;\n\n\tinfo = info_for_irq(irq);\n\n\tif (!info)\n\t\treturn -ENOENT;\n\n\tWARN_ON(info->refcnt != -1);\n\n\tinfo->refcnt = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(evtchn_make_refcounted);\n\nint evtchn_get(evtchn_port_t evtchn)\n{\n\tint irq;\n\tstruct irq_info *info;\n\tint err = -ENOENT;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = get_evtchn_to_irq(evtchn);\n\tif (irq == -1)\n\t\tgoto done;\n\n\tinfo = info_for_irq(irq);\n\n\tif (!info)\n\t\tgoto done;\n\n\terr = -EINVAL;\n\tif (info->refcnt <= 0)\n\t\tgoto done;\n\n\tinfo->refcnt++;\n\terr = 0;\n done:\n\tmutex_unlock(&irq_mapping_update_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(evtchn_get);\n\nvoid evtchn_put(evtchn_port_t evtchn)\n{\n\tint irq = get_evtchn_to_irq(evtchn);\n\tif (WARN_ON(irq == -1))\n\t\treturn;\n\tunbind_from_irq(irq);\n}\nEXPORT_SYMBOL_GPL(evtchn_put);\n\nvoid xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector)\n{\n\tint irq;\n\n#ifdef CONFIG_X86\n\tif (unlikely(vector == XEN_NMI_VECTOR)) {\n\t\tint rc =  HYPERVISOR_vcpu_op(VCPUOP_send_nmi, xen_vcpu_nr(cpu),\n\t\t\t\t\t     NULL);\n\t\tif (rc < 0)\n\t\t\tprintk(KERN_WARNING \"Sending nmi to CPU%d failed (rc:%d)\\n\", cpu, rc);\n\t\treturn;\n\t}\n#endif\n\tirq = per_cpu(ipi_to_irq, cpu)[vector];\n\tBUG_ON(irq < 0);\n\tnotify_remote_via_irq(irq);\n}\n\nstatic void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\n\t\txen_evtchn_handle_events(cpu);\n\n\t\tBUG_ON(!irqs_disabled());\n\n\t\tvirt_rmb(); /* Hypervisor can set upcall pending. */\n\n\t} while (vcpu_info->evtchn_upcall_pending);\n}\n\nvoid xen_evtchn_do_upcall(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\n\tirq_enter();\n\n\t__xen_evtchn_do_upcall();\n\n\tirq_exit();\n\tset_irq_regs(old_regs);\n}\n\nvoid xen_hvm_evtchn_do_upcall(void)\n{\n\t__xen_evtchn_do_upcall();\n}\nEXPORT_SYMBOL_GPL(xen_hvm_evtchn_do_upcall);\n\n/* Rebind a new event channel to an existing irq. */\nvoid rebind_evtchn_irq(evtchn_port_t evtchn, int irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\t/* Make sure the irq is masked, since the new event channel\n\t   will also be masked. */\n\tdisable_irq(irq);\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\t/* After resume the irq<->evtchn mappings are all cleared out */\n\tBUG_ON(get_evtchn_to_irq(evtchn) != -1);\n\t/* Expect irq to have been bound before,\n\t   so there should be a proper type */\n\tBUG_ON(info->type == IRQT_UNBOUND);\n\n\t(void)xen_irq_info_evtchn_setup(irq, evtchn);\n\n\tmutex_unlock(&irq_mapping_update_lock);\n\n        bind_evtchn_to_cpu(evtchn, info->cpu);\n\t/* This will be deferred until interrupt is processed */\n\tirq_set_affinity(irq, cpumask_of(info->cpu));\n\n\t/* Unmask the event channel. */\n\tenable_irq(irq);\n}\n\n/* Rebind an evtchn so that it gets delivered to a specific cpu */\nstatic int xen_rebind_evtchn_to_cpu(evtchn_port_t evtchn, unsigned int tcpu)\n{\n\tstruct evtchn_bind_vcpu bind_vcpu;\n\tint masked;\n\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn -1;\n\n\tif (!xen_support_evtchn_rebind())\n\t\treturn -1;\n\n\t/* Send future instances of this interrupt to other vcpu. */\n\tbind_vcpu.port = evtchn;\n\tbind_vcpu.vcpu = xen_vcpu_nr(tcpu);\n\n\t/*\n\t * Mask the event while changing the VCPU binding to prevent\n\t * it being delivered on an unexpected VCPU.\n\t */\n\tmasked = test_and_set_mask(evtchn);\n\n\t/*\n\t * If this fails, it usually just indicates that we're dealing with a\n\t * virq or IPI channel, which don't actually need to be rebound. Ignore\n\t * it, but don't do the xenlinux-level rebind in that case.\n\t */\n\tif (HYPERVISOR_event_channel_op(EVTCHNOP_bind_vcpu, &bind_vcpu) >= 0)\n\t\tbind_evtchn_to_cpu(evtchn, tcpu);\n\n\tif (!masked)\n\t\tunmask_evtchn(evtchn);\n\n\treturn 0;\n}\n\nstatic int set_affinity_irq(struct irq_data *data, const struct cpumask *dest,\n\t\t\t    bool force)\n{\n\tunsigned tcpu = cpumask_first_and(dest, cpu_online_mask);\n\tint ret = xen_rebind_evtchn_to_cpu(evtchn_from_irq(data->irq), tcpu);\n\n\tif (!ret)\n\t\tirq_data_update_effective_affinity(data, cpumask_of(tcpu));\n\n\treturn ret;\n}\n\n/* To be called with desc->lock held. */\nint xen_set_affinity_evtchn(struct irq_desc *desc, unsigned int tcpu)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\treturn set_affinity_irq(d, cpumask_of(tcpu), false);\n}\nEXPORT_SYMBOL_GPL(xen_set_affinity_evtchn);\n\nstatic void enable_dynirq(struct irq_data *data)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(data->irq);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tunmask_evtchn(evtchn);\n}\n\nstatic void disable_dynirq(struct irq_data *data)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(data->irq);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tmask_evtchn(evtchn);\n}\n\nstatic void ack_dynirq(struct irq_data *data)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(data->irq);\n\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\n\tif (unlikely(irqd_is_setaffinity_pending(data)) &&\n\t    likely(!irqd_irq_disabled(data))) {\n\t\tint masked = test_and_set_mask(evtchn);\n\n\t\tclear_evtchn(evtchn);\n\n\t\tirq_move_masked_irq(data);\n\n\t\tif (!masked)\n\t\t\tunmask_evtchn(evtchn);\n\t} else\n\t\tclear_evtchn(evtchn);\n}\n\nstatic void mask_ack_dynirq(struct irq_data *data)\n{\n\tdisable_dynirq(data);\n\tack_dynirq(data);\n}\n\nstatic int retrigger_dynirq(struct irq_data *data)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(data->irq);\n\tint masked;\n\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn 0;\n\n\tmasked = test_and_set_mask(evtchn);\n\tset_evtchn(evtchn);\n\tif (!masked)\n\t\tunmask_evtchn(evtchn);\n\n\treturn 1;\n}\n\nstatic void restore_pirqs(void)\n{\n\tint pirq, rc, irq, gsi;\n\tstruct physdev_map_pirq map_irq;\n\tstruct irq_info *info;\n\n\tlist_for_each_entry(info, &xen_irq_list_head, list) {\n\t\tif (info->type != IRQT_PIRQ)\n\t\t\tcontinue;\n\n\t\tpirq = info->u.pirq.pirq;\n\t\tgsi = info->u.pirq.gsi;\n\t\tirq = info->irq;\n\n\t\t/* save/restore of PT devices doesn't work, so at this point the\n\t\t * only devices present are GSI based emulated devices */\n\t\tif (!gsi)\n\t\t\tcontinue;\n\n\t\tmap_irq.domid = DOMID_SELF;\n\t\tmap_irq.type = MAP_PIRQ_TYPE_GSI;\n\t\tmap_irq.index = gsi;\n\t\tmap_irq.pirq = pirq;\n\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_map_pirq, &map_irq);\n\t\tif (rc) {\n\t\t\tpr_warn(\"xen map irq failed gsi=%d irq=%d pirq=%d rc=%d\\n\",\n\t\t\t\tgsi, irq, pirq, rc);\n\t\t\txen_free_irq(irq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(KERN_DEBUG \"xen: --> irq=%d, pirq=%d\\n\", irq, map_irq.pirq);\n\n\t\t__startup_pirq(irq);\n\t}\n}\n\nstatic void restore_cpu_virqs(unsigned int cpu)\n{\n\tstruct evtchn_bind_virq bind_virq;\n\tevtchn_port_t evtchn;\n\tint virq, irq;\n\n\tfor (virq = 0; virq < NR_VIRQS; virq++) {\n\t\tif ((irq = per_cpu(virq_to_irq, cpu)[virq]) == -1)\n\t\t\tcontinue;\n\n\t\tBUG_ON(virq_from_irq(irq) != virq);\n\n\t\t/* Get a new binding from Xen. */\n\t\tbind_virq.virq = virq;\n\t\tbind_virq.vcpu = xen_vcpu_nr(cpu);\n\t\tif (HYPERVISOR_event_channel_op(EVTCHNOP_bind_virq,\n\t\t\t\t\t\t&bind_virq) != 0)\n\t\t\tBUG();\n\t\tevtchn = bind_virq.port;\n\n\t\t/* Record the new mapping. */\n\t\t(void)xen_irq_info_virq_setup(cpu, irq, evtchn, virq);\n\t\tbind_evtchn_to_cpu(evtchn, cpu);\n\t}\n}\n\nstatic void restore_cpu_ipis(unsigned int cpu)\n{\n\tstruct evtchn_bind_ipi bind_ipi;\n\tevtchn_port_t evtchn;\n\tint ipi, irq;\n\n\tfor (ipi = 0; ipi < XEN_NR_IPIS; ipi++) {\n\t\tif ((irq = per_cpu(ipi_to_irq, cpu)[ipi]) == -1)\n\t\t\tcontinue;\n\n\t\tBUG_ON(ipi_from_irq(irq) != ipi);\n\n\t\t/* Get a new binding from Xen. */\n\t\tbind_ipi.vcpu = xen_vcpu_nr(cpu);\n\t\tif (HYPERVISOR_event_channel_op(EVTCHNOP_bind_ipi,\n\t\t\t\t\t\t&bind_ipi) != 0)\n\t\t\tBUG();\n\t\tevtchn = bind_ipi.port;\n\n\t\t/* Record the new mapping. */\n\t\t(void)xen_irq_info_ipi_setup(cpu, irq, evtchn, ipi);\n\t\tbind_evtchn_to_cpu(evtchn, cpu);\n\t}\n}\n\n/* Clear an irq's pending state, in preparation for polling on it */\nvoid xen_clear_irq_pending(int irq)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tclear_evtchn(evtchn);\n}\nEXPORT_SYMBOL(xen_clear_irq_pending);\nvoid xen_set_irq_pending(int irq)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tset_evtchn(evtchn);\n}\n\nbool xen_test_irq_pending(int irq)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\tbool ret = false;\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tret = test_evtchn(evtchn);\n\n\treturn ret;\n}\n\n/* Poll waiting for an irq to become pending with timeout.  In the usual case,\n * the irq will be disabled so it won't deliver an interrupt. */\nvoid xen_poll_irq_timeout(int irq, u64 timeout)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\n\tif (VALID_EVTCHN(evtchn)) {\n\t\tstruct sched_poll poll;\n\n\t\tpoll.nr_ports = 1;\n\t\tpoll.timeout = timeout;\n\t\tset_xen_guest_handle(poll.ports, &evtchn);\n\n\t\tif (HYPERVISOR_sched_op(SCHEDOP_poll, &poll) != 0)\n\t\t\tBUG();\n\t}\n}\nEXPORT_SYMBOL(xen_poll_irq_timeout);\n/* Poll waiting for an irq to become pending.  In the usual case, the\n * irq will be disabled so it won't deliver an interrupt. */\nvoid xen_poll_irq(int irq)\n{\n\txen_poll_irq_timeout(irq, 0 /* no timeout */);\n}\n\n/* Check whether the IRQ line is shared with other guests. */\nint xen_test_irq_shared(int irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tstruct physdev_irq_status_query irq_status;\n\n\tif (WARN_ON(!info))\n\t\treturn -ENOENT;\n\n\tirq_status.irq = info->u.pirq.pirq;\n\n\tif (HYPERVISOR_physdev_op(PHYSDEVOP_irq_status_query, &irq_status))\n\t\treturn 0;\n\treturn !(irq_status.flags & XENIRQSTAT_shared);\n}\nEXPORT_SYMBOL_GPL(xen_test_irq_shared);\n\nvoid xen_irq_resume(void)\n{\n\tunsigned int cpu;\n\tstruct irq_info *info;\n\n\t/* New event-channel space is not 'live' yet. */\n\txen_evtchn_resume();\n\n\t/* No IRQ <-> event-channel mappings. */\n\tlist_for_each_entry(info, &xen_irq_list_head, list)\n\t\tinfo->evtchn = 0; /* zap event-channel binding */\n\n\tclear_evtchn_to_irq_all();\n\n\tfor_each_possible_cpu(cpu) {\n\t\trestore_cpu_virqs(cpu);\n\t\trestore_cpu_ipis(cpu);\n\t}\n\n\trestore_pirqs();\n}\n\nstatic struct irq_chip xen_dynamic_chip __read_mostly = {\n\t.name\t\t\t= \"xen-dyn\",\n\n\t.irq_disable\t\t= disable_dynirq,\n\t.irq_mask\t\t= disable_dynirq,\n\t.irq_unmask\t\t= enable_dynirq,\n\n\t.irq_ack\t\t= ack_dynirq,\n\t.irq_mask_ack\t\t= mask_ack_dynirq,\n\n\t.irq_set_affinity\t= set_affinity_irq,\n\t.irq_retrigger\t\t= retrigger_dynirq,\n};\n\nstatic struct irq_chip xen_pirq_chip __read_mostly = {\n\t.name\t\t\t= \"xen-pirq\",\n\n\t.irq_startup\t\t= startup_pirq,\n\t.irq_shutdown\t\t= shutdown_pirq,\n\t.irq_enable\t\t= enable_pirq,\n\t.irq_disable\t\t= disable_pirq,\n\n\t.irq_mask\t\t= disable_dynirq,\n\t.irq_unmask\t\t= enable_dynirq,\n\n\t.irq_ack\t\t= eoi_pirq,\n\t.irq_eoi\t\t= eoi_pirq,\n\t.irq_mask_ack\t\t= mask_ack_pirq,\n\n\t.irq_set_affinity\t= set_affinity_irq,\n\n\t.irq_retrigger\t\t= retrigger_dynirq,\n};\n\nstatic struct irq_chip xen_percpu_chip __read_mostly = {\n\t.name\t\t\t= \"xen-percpu\",\n\n\t.irq_disable\t\t= disable_dynirq,\n\t.irq_mask\t\t= disable_dynirq,\n\t.irq_unmask\t\t= enable_dynirq,\n\n\t.irq_ack\t\t= ack_dynirq,\n};\n\nint xen_set_callback_via(uint64_t via)\n{\n\tstruct xen_hvm_param a;\n\ta.domid = DOMID_SELF;\n\ta.index = HVM_PARAM_CALLBACK_IRQ;\n\ta.value = via;\n\treturn HYPERVISOR_hvm_op(HVMOP_set_param, &a);\n}\nEXPORT_SYMBOL_GPL(xen_set_callback_via);\n\n#ifdef CONFIG_XEN_PVHVM\n/* Vector callbacks are better than PCI interrupts to receive event\n * channel notifications because we can receive vector callbacks on any\n * vcpu and we don't need PCI support or APIC interactions. */\nvoid xen_setup_callback_vector(void)\n{\n\tuint64_t callback_via;\n\n\tif (xen_have_vector_callback) {\n\t\tcallback_via = HVM_CALLBACK_VECTOR(HYPERVISOR_CALLBACK_VECTOR);\n\t\tif (xen_set_callback_via(callback_via)) {\n\t\t\tpr_err(\"Request for Xen HVM callback vector failed\\n\");\n\t\t\txen_have_vector_callback = 0;\n\t\t}\n\t}\n}\n\nstatic __init void xen_alloc_callback_vector(void)\n{\n\tif (!xen_have_vector_callback)\n\t\treturn;\n\n\tpr_info(\"Xen HVM callback vector for event delivery is enabled\\n\");\n\talloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR, asm_sysvec_xen_hvm_callback);\n}\n#else\nvoid xen_setup_callback_vector(void) {}\nstatic inline void xen_alloc_callback_vector(void) {}\n#endif\n\n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX \"xen.\"\n\nstatic bool fifo_events = true;\nmodule_param(fifo_events, bool, 0);\n\nvoid __init xen_init_IRQ(void)\n{\n\tint ret = -EINVAL;\n\tevtchn_port_t evtchn;\n\n\tif (fifo_events)\n\t\tret = xen_evtchn_fifo_init();\n\tif (ret < 0)\n\t\txen_evtchn_2l_init();\n\n\tevtchn_to_irq = kcalloc(EVTCHN_ROW(xen_evtchn_max_channels()),\n\t\t\t\tsizeof(*evtchn_to_irq), GFP_KERNEL);\n\tBUG_ON(!evtchn_to_irq);\n\n\t/* No event channels are 'live' right now. */\n\tfor (evtchn = 0; evtchn < xen_evtchn_nr_channels(); evtchn++)\n\t\tmask_evtchn(evtchn);\n\n\tpirq_needs_eoi = pirq_needs_eoi_flag;\n\n#ifdef CONFIG_X86\n\tif (xen_pv_domain()) {\n\t\tif (xen_initial_domain())\n\t\t\tpci_xen_initial_domain();\n\t}\n\tif (xen_feature(XENFEAT_hvm_callback_vector)) {\n\t\txen_setup_callback_vector();\n\t\txen_alloc_callback_vector();\n\t}\n\n\tif (xen_hvm_domain()) {\n\t\tnative_init_IRQ();\n\t\t/* pci_xen_hvm_init must be called after native_init_IRQ so that\n\t\t * __acpi_register_gsi can point at the right function */\n\t\tpci_xen_hvm_init();\n\t} else {\n\t\tint rc;\n\t\tstruct physdev_pirq_eoi_gmfn eoi_gmfn;\n\n\t\tpirq_eoi_map = (void *)__get_free_page(GFP_KERNEL|__GFP_ZERO);\n\t\teoi_gmfn.gmfn = virt_to_gfn(pirq_eoi_map);\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_pirq_eoi_gmfn_v2, &eoi_gmfn);\n\t\tif (rc != 0) {\n\t\t\tfree_page((unsigned long) pirq_eoi_map);\n\t\t\tpirq_eoi_map = NULL;\n\t\t} else\n\t\t\tpirq_needs_eoi = pirq_check_eoi_map;\n\t}\n#endif\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Xen event channels\n *\n * Xen models interrupts with abstract event channels.  Because each\n * domain gets 1024 event channels, but NR_IRQ is not that large, we\n * must dynamically map irqs<->event channels.  The event channels\n * interface with the rest of the kernel by defining a xen interrupt\n * chip.  When an event is received, it is mapped to an irq and sent\n * through the normal interrupt processing path.\n *\n * There are four kinds of events which can be mapped to an event\n * channel:\n *\n * 1. Inter-domain notifications.  This includes all the virtual\n *    device events, since they're driven by front-ends in another domain\n *    (typically dom0).\n * 2. VIRQs, typically used for timers.  These are per-cpu events.\n * 3. IPIs.\n * 4. PIRQs - Hardware interrupts.\n *\n * Jeremy Fitzhardinge <jeremy@xensource.com>, XenSource Inc, 2007\n */\n\n#define pr_fmt(fmt) \"xen:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/linkage.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/memblock.h>\n#include <linux/slab.h>\n#include <linux/irqnr.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n\n#ifdef CONFIG_X86\n#include <asm/desc.h>\n#include <asm/ptrace.h>\n#include <asm/idtentry.h>\n#include <asm/irq.h>\n#include <asm/io_apic.h>\n#include <asm/i8259.h>\n#include <asm/xen/pci.h>\n#endif\n#include <asm/sync_bitops.h>\n#include <asm/xen/hypercall.h>\n#include <asm/xen/hypervisor.h>\n#include <xen/page.h>\n\n#include <xen/xen.h>\n#include <xen/hvm.h>\n#include <xen/xen-ops.h>\n#include <xen/events.h>\n#include <xen/interface/xen.h>\n#include <xen/interface/event_channel.h>\n#include <xen/interface/hvm/hvm_op.h>\n#include <xen/interface/hvm/params.h>\n#include <xen/interface/physdev.h>\n#include <xen/interface/sched.h>\n#include <xen/interface/vcpu.h>\n#include <asm/hw_irq.h>\n\n#include \"events_internal.h\"\n\nconst struct evtchn_ops *evtchn_ops;\n\n/*\n * This lock protects updates to the following mapping and reference-count\n * arrays. The lock does not need to be acquired to read the mapping tables.\n */\nstatic DEFINE_MUTEX(irq_mapping_update_lock);\n\n/*\n * Lock protecting event handling loop against removing event channels.\n * Adding of event channels is no issue as the associated IRQ becomes active\n * only after everything is setup (before request_[threaded_]irq() the handler\n * can't be entered for an event, as the event channel will be unmasked only\n * then).\n */\nstatic DEFINE_RWLOCK(evtchn_rwlock);\n\n/*\n * Lock hierarchy:\n *\n * irq_mapping_update_lock\n *   evtchn_rwlock\n *     IRQ-desc lock\n */\n\nstatic LIST_HEAD(xen_irq_list_head);\n\n/* IRQ <-> VIRQ mapping. */\nstatic DEFINE_PER_CPU(int [NR_VIRQS], virq_to_irq) = {[0 ... NR_VIRQS-1] = -1};\n\n/* IRQ <-> IPI mapping */\nstatic DEFINE_PER_CPU(int [XEN_NR_IPIS], ipi_to_irq) = {[0 ... XEN_NR_IPIS-1] = -1};\n\nint **evtchn_to_irq;\n#ifdef CONFIG_X86\nstatic unsigned long *pirq_eoi_map;\n#endif\nstatic bool (*pirq_needs_eoi)(unsigned irq);\n\n#define EVTCHN_ROW(e)  (e / (PAGE_SIZE/sizeof(**evtchn_to_irq)))\n#define EVTCHN_COL(e)  (e % (PAGE_SIZE/sizeof(**evtchn_to_irq)))\n#define EVTCHN_PER_ROW (PAGE_SIZE / sizeof(**evtchn_to_irq))\n\n/* Xen will never allocate port zero for any purpose. */\n#define VALID_EVTCHN(chn)\t((chn) != 0)\n\nstatic struct irq_info *legacy_info_ptrs[NR_IRQS_LEGACY];\n\nstatic struct irq_chip xen_dynamic_chip;\nstatic struct irq_chip xen_percpu_chip;\nstatic struct irq_chip xen_pirq_chip;\nstatic void enable_dynirq(struct irq_data *data);\nstatic void disable_dynirq(struct irq_data *data);\n\nstatic void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tWRITE_ONCE(evtchn_to_irq[row][col], -1);\n}\n\nstatic void clear_evtchn_to_irq_all(void)\n{\n\tunsigned row;\n\n\tfor (row = 0; row < EVTCHN_ROW(xen_evtchn_max_channels()); row++) {\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\tcontinue;\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n}\n\nstatic int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\n\tif (evtchn_to_irq[row] == NULL) {\n\t\t/* Unallocated irq entries return -1 anyway */\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\n\tWRITE_ONCE(evtchn_to_irq[row][col], irq);\n\treturn 0;\n}\n\nint get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn READ_ONCE(evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)]);\n}\n\n/* Get info for IRQ */\nstruct irq_info *info_for_irq(unsigned irq)\n{\n\tif (irq < nr_legacy_irqs())\n\t\treturn legacy_info_ptrs[irq];\n\telse\n\t\treturn irq_get_chip_data(irq);\n}\n\nstatic void set_info_for_irq(unsigned int irq, struct irq_info *info)\n{\n\tif (irq < nr_legacy_irqs())\n\t\tlegacy_info_ptrs[irq] = info;\n\telse\n\t\tirq_set_chip_data(irq, info);\n}\n\n/* Constructors for packed IRQ information. */\nstatic int xen_irq_info_common_setup(struct irq_info *info,\n\t\t\t\t     unsigned irq,\n\t\t\t\t     enum xen_irq_type type,\n\t\t\t\t     evtchn_port_t evtchn,\n\t\t\t\t     unsigned short cpu)\n{\n\tint ret;\n\n\tBUG_ON(info->type != IRQT_UNBOUND && info->type != type);\n\n\tinfo->type = type;\n\tinfo->irq = irq;\n\tinfo->evtchn = evtchn;\n\tinfo->cpu = cpu;\n\n\tret = set_evtchn_to_irq(evtchn, irq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tirq_clear_status_flags(irq, IRQ_NOREQUEST|IRQ_NOAUTOEN);\n\n\treturn xen_evtchn_port_setup(info);\n}\n\nstatic int xen_irq_info_evtchn_setup(unsigned irq,\n\t\t\t\t     evtchn_port_t evtchn)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\treturn xen_irq_info_common_setup(info, irq, IRQT_EVTCHN, evtchn, 0);\n}\n\nstatic int xen_irq_info_ipi_setup(unsigned cpu,\n\t\t\t\t  unsigned irq,\n\t\t\t\t  evtchn_port_t evtchn,\n\t\t\t\t  enum ipi_vector ipi)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tinfo->u.ipi = ipi;\n\n\tper_cpu(ipi_to_irq, cpu)[ipi] = irq;\n\n\treturn xen_irq_info_common_setup(info, irq, IRQT_IPI, evtchn, 0);\n}\n\nstatic int xen_irq_info_virq_setup(unsigned cpu,\n\t\t\t\t   unsigned irq,\n\t\t\t\t   evtchn_port_t evtchn,\n\t\t\t\t   unsigned virq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tinfo->u.virq = virq;\n\n\tper_cpu(virq_to_irq, cpu)[virq] = irq;\n\n\treturn xen_irq_info_common_setup(info, irq, IRQT_VIRQ, evtchn, 0);\n}\n\nstatic int xen_irq_info_pirq_setup(unsigned irq,\n\t\t\t\t   evtchn_port_t evtchn,\n\t\t\t\t   unsigned pirq,\n\t\t\t\t   unsigned gsi,\n\t\t\t\t   uint16_t domid,\n\t\t\t\t   unsigned char flags)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tinfo->u.pirq.pirq = pirq;\n\tinfo->u.pirq.gsi = gsi;\n\tinfo->u.pirq.domid = domid;\n\tinfo->u.pirq.flags = flags;\n\n\treturn xen_irq_info_common_setup(info, irq, IRQT_PIRQ, evtchn, 0);\n}\n\nstatic void xen_irq_info_cleanup(struct irq_info *info)\n{\n\tset_evtchn_to_irq(info->evtchn, -1);\n\tinfo->evtchn = 0;\n}\n\n/*\n * Accessors for packed IRQ information.\n */\nevtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tconst struct irq_info *info = NULL;\n\n\tif (likely(irq < nr_irqs))\n\t\tinfo = info_for_irq(irq);\n\tif (!info)\n\t\treturn 0;\n\n\treturn info->evtchn;\n}\n\nunsigned int irq_from_evtchn(evtchn_port_t evtchn)\n{\n\treturn get_evtchn_to_irq(evtchn);\n}\nEXPORT_SYMBOL_GPL(irq_from_evtchn);\n\nint irq_from_virq(unsigned int cpu, unsigned int virq)\n{\n\treturn per_cpu(virq_to_irq, cpu)[virq];\n}\n\nstatic enum ipi_vector ipi_from_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tBUG_ON(info == NULL);\n\tBUG_ON(info->type != IRQT_IPI);\n\n\treturn info->u.ipi;\n}\n\nstatic unsigned virq_from_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tBUG_ON(info == NULL);\n\tBUG_ON(info->type != IRQT_VIRQ);\n\n\treturn info->u.virq;\n}\n\nstatic unsigned pirq_from_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tBUG_ON(info == NULL);\n\tBUG_ON(info->type != IRQT_PIRQ);\n\n\treturn info->u.pirq.pirq;\n}\n\nstatic enum xen_irq_type type_from_irq(unsigned irq)\n{\n\treturn info_for_irq(irq)->type;\n}\n\nunsigned cpu_from_irq(unsigned irq)\n{\n\treturn info_for_irq(irq)->cpu;\n}\n\nunsigned int cpu_from_evtchn(evtchn_port_t evtchn)\n{\n\tint irq = get_evtchn_to_irq(evtchn);\n\tunsigned ret = 0;\n\n\tif (irq != -1)\n\t\tret = cpu_from_irq(irq);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_X86\nstatic bool pirq_check_eoi_map(unsigned irq)\n{\n\treturn test_bit(pirq_from_irq(irq), pirq_eoi_map);\n}\n#endif\n\nstatic bool pirq_needs_eoi_flag(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tBUG_ON(info->type != IRQT_PIRQ);\n\n\treturn info->u.pirq.flags & PIRQ_NEEDS_EOI;\n}\n\nstatic void bind_evtchn_to_cpu(evtchn_port_t evtchn, unsigned int cpu)\n{\n\tint irq = get_evtchn_to_irq(evtchn);\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tBUG_ON(irq == -1);\n#ifdef CONFIG_SMP\n\tcpumask_copy(irq_get_affinity_mask(irq), cpumask_of(cpu));\n#endif\n\txen_evtchn_port_bind_to_cpu(info, cpu);\n\n\tinfo->cpu = cpu;\n}\n\n/**\n * notify_remote_via_irq - send event to remote end of event channel via irq\n * @irq: irq of event channel to send event to\n *\n * Unlike notify_remote_via_evtchn(), this is safe to use across\n * save/restore. Notifications on a broken connection are silently\n * dropped.\n */\nvoid notify_remote_via_irq(int irq)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tnotify_remote_via_evtchn(evtchn);\n}\nEXPORT_SYMBOL_GPL(notify_remote_via_irq);\n\nstatic void xen_irq_init(unsigned irq)\n{\n\tstruct irq_info *info;\n#ifdef CONFIG_SMP\n\t/* By default all event channels notify CPU#0. */\n\tcpumask_copy(irq_get_affinity_mask(irq), cpumask_of(0));\n#endif\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (info == NULL)\n\t\tpanic(\"Unable to allocate metadata for IRQ%d\\n\", irq);\n\n\tinfo->type = IRQT_UNBOUND;\n\tinfo->refcnt = -1;\n\n\tset_info_for_irq(irq, info);\n\n\tlist_add_tail(&info->list, &xen_irq_list_head);\n}\n\nstatic int __must_check xen_allocate_irqs_dynamic(int nvec)\n{\n\tint i, irq = irq_alloc_descs(-1, 0, nvec, -1);\n\n\tif (irq >= 0) {\n\t\tfor (i = 0; i < nvec; i++)\n\t\t\txen_irq_init(irq + i);\n\t}\n\n\treturn irq;\n}\n\nstatic inline int __must_check xen_allocate_irq_dynamic(void)\n{\n\n\treturn xen_allocate_irqs_dynamic(1);\n}\n\nstatic int __must_check xen_allocate_irq_gsi(unsigned gsi)\n{\n\tint irq;\n\n\t/*\n\t * A PV guest has no concept of a GSI (since it has no ACPI\n\t * nor access to/knowledge of the physical APICs). Therefore\n\t * all IRQs are dynamically allocated from the entire IRQ\n\t * space.\n\t */\n\tif (xen_pv_domain() && !xen_initial_domain())\n\t\treturn xen_allocate_irq_dynamic();\n\n\t/* Legacy IRQ descriptors are already allocated by the arch. */\n\tif (gsi < nr_legacy_irqs())\n\t\tirq = gsi;\n\telse\n\t\tirq = irq_alloc_desc_at(gsi, -1);\n\n\txen_irq_init(irq);\n\n\treturn irq;\n}\n\nstatic void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\n\tlist_del(&info->list);\n\n\tset_info_for_irq(irq, NULL);\n\n\tWARN_ON(info->refcnt > 0);\n\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\n\tkfree(info);\n\n\t/* Legacy IRQ descriptors are managed by the arch. */\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\n\tirq_free_desc(irq);\n}\n\nstatic void xen_evtchn_close(evtchn_port_t port)\n{\n\tstruct evtchn_close close;\n\n\tclose.port = port;\n\tif (HYPERVISOR_event_channel_op(EVTCHNOP_close, &close) != 0)\n\t\tBUG();\n}\n\nstatic void pirq_query_unmask(int irq)\n{\n\tstruct physdev_irq_status_query irq_status;\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tBUG_ON(info->type != IRQT_PIRQ);\n\n\tirq_status.irq = pirq_from_irq(irq);\n\tif (HYPERVISOR_physdev_op(PHYSDEVOP_irq_status_query, &irq_status))\n\t\tirq_status.flags = 0;\n\n\tinfo->u.pirq.flags &= ~PIRQ_NEEDS_EOI;\n\tif (irq_status.flags & XENIRQSTAT_needs_eoi)\n\t\tinfo->u.pirq.flags |= PIRQ_NEEDS_EOI;\n}\n\nstatic void eoi_pirq(struct irq_data *data)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(data->irq);\n\tstruct physdev_eoi eoi = { .irq = pirq_from_irq(data->irq) };\n\tint rc = 0;\n\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\n\tif (unlikely(irqd_is_setaffinity_pending(data)) &&\n\t    likely(!irqd_irq_disabled(data))) {\n\t\tint masked = test_and_set_mask(evtchn);\n\n\t\tclear_evtchn(evtchn);\n\n\t\tirq_move_masked_irq(data);\n\n\t\tif (!masked)\n\t\t\tunmask_evtchn(evtchn);\n\t} else\n\t\tclear_evtchn(evtchn);\n\n\tif (pirq_needs_eoi(data->irq)) {\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_eoi, &eoi);\n\t\tWARN_ON(rc);\n\t}\n}\n\nstatic void mask_ack_pirq(struct irq_data *data)\n{\n\tdisable_dynirq(data);\n\teoi_pirq(data);\n}\n\nstatic unsigned int __startup_pirq(unsigned int irq)\n{\n\tstruct evtchn_bind_pirq bind_pirq;\n\tstruct irq_info *info = info_for_irq(irq);\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\tint rc;\n\n\tBUG_ON(info->type != IRQT_PIRQ);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tgoto out;\n\n\tbind_pirq.pirq = pirq_from_irq(irq);\n\t/* NB. We are happy to share unless we are probing. */\n\tbind_pirq.flags = info->u.pirq.flags & PIRQ_SHAREABLE ?\n\t\t\t\t\tBIND_PIRQ__WILL_SHARE : 0;\n\trc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_pirq, &bind_pirq);\n\tif (rc != 0) {\n\t\tpr_warn(\"Failed to obtain physical IRQ %d\\n\", irq);\n\t\treturn 0;\n\t}\n\tevtchn = bind_pirq.port;\n\n\tpirq_query_unmask(irq);\n\n\trc = set_evtchn_to_irq(evtchn, irq);\n\tif (rc)\n\t\tgoto err;\n\n\tinfo->evtchn = evtchn;\n\tbind_evtchn_to_cpu(evtchn, 0);\n\n\trc = xen_evtchn_port_setup(info);\n\tif (rc)\n\t\tgoto err;\n\nout:\n\tunmask_evtchn(evtchn);\n\teoi_pirq(irq_get_irq_data(irq));\n\n\treturn 0;\n\nerr:\n\tpr_err(\"irq%d: Failed to set port to irq mapping (%d)\\n\", irq, rc);\n\txen_evtchn_close(evtchn);\n\treturn 0;\n}\n\nstatic unsigned int startup_pirq(struct irq_data *data)\n{\n\treturn __startup_pirq(data->irq);\n}\n\nstatic void shutdown_pirq(struct irq_data *data)\n{\n\tunsigned int irq = data->irq;\n\tstruct irq_info *info = info_for_irq(irq);\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\n\tBUG_ON(info->type != IRQT_PIRQ);\n\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\n\tmask_evtchn(evtchn);\n\txen_evtchn_close(evtchn);\n\txen_irq_info_cleanup(info);\n}\n\nstatic void enable_pirq(struct irq_data *data)\n{\n\tenable_dynirq(data);\n}\n\nstatic void disable_pirq(struct irq_data *data)\n{\n\tdisable_dynirq(data);\n}\n\nint xen_irq_from_gsi(unsigned gsi)\n{\n\tstruct irq_info *info;\n\n\tlist_for_each_entry(info, &xen_irq_list_head, list) {\n\t\tif (info->type != IRQT_PIRQ)\n\t\t\tcontinue;\n\n\t\tif (info->u.pirq.gsi == gsi)\n\t\t\treturn info->irq;\n\t}\n\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(xen_irq_from_gsi);\n\nstatic void __unbind_from_irq(unsigned int irq)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tif (info->refcnt > 0) {\n\t\tinfo->refcnt--;\n\t\tif (info->refcnt != 0)\n\t\t\treturn;\n\t}\n\n\tif (VALID_EVTCHN(evtchn)) {\n\t\tunsigned int cpu = cpu_from_irq(irq);\n\n\t\txen_evtchn_close(evtchn);\n\n\t\tswitch (type_from_irq(irq)) {\n\t\tcase IRQT_VIRQ:\n\t\t\tper_cpu(virq_to_irq, cpu)[virq_from_irq(irq)] = -1;\n\t\t\tbreak;\n\t\tcase IRQT_IPI:\n\t\t\tper_cpu(ipi_to_irq, cpu)[ipi_from_irq(irq)] = -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\txen_irq_info_cleanup(info);\n\t}\n\n\txen_free_irq(irq);\n}\n\n/*\n * Do not make any assumptions regarding the relationship between the\n * IRQ number returned here and the Xen pirq argument.\n *\n * Note: We don't assign an event channel until the irq actually started\n * up.  Return an existing irq if we've already got one for the gsi.\n *\n * Shareable implies level triggered, not shareable implies edge\n * triggered here.\n */\nint xen_bind_pirq_gsi_to_irq(unsigned gsi,\n\t\t\t     unsigned pirq, int shareable, char *name)\n{\n\tint irq = -1;\n\tstruct physdev_irq irq_op;\n\tint ret;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = xen_irq_from_gsi(gsi);\n\tif (irq != -1) {\n\t\tpr_info(\"%s: returning irq %d for gsi %u\\n\",\n\t\t\t__func__, irq, gsi);\n\t\tgoto out;\n\t}\n\n\tirq = xen_allocate_irq_gsi(gsi);\n\tif (irq < 0)\n\t\tgoto out;\n\n\tirq_op.irq = irq;\n\tirq_op.vector = 0;\n\n\t/* Only the privileged domain can do this. For non-priv, the pcifront\n\t * driver provides a PCI bus that does the call to do exactly\n\t * this in the priv domain. */\n\tif (xen_initial_domain() &&\n\t    HYPERVISOR_physdev_op(PHYSDEVOP_alloc_irq_vector, &irq_op)) {\n\t\txen_free_irq(irq);\n\t\tirq = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tret = xen_irq_info_pirq_setup(irq, 0, pirq, gsi, DOMID_SELF,\n\t\t\t       shareable ? PIRQ_SHAREABLE : 0);\n\tif (ret < 0) {\n\t\t__unbind_from_irq(irq);\n\t\tirq = ret;\n\t\tgoto out;\n\t}\n\n\tpirq_query_unmask(irq);\n\t/* We try to use the handler with the appropriate semantic for the\n\t * type of interrupt: if the interrupt is an edge triggered\n\t * interrupt we use handle_edge_irq.\n\t *\n\t * On the other hand if the interrupt is level triggered we use\n\t * handle_fasteoi_irq like the native code does for this kind of\n\t * interrupts.\n\t *\n\t * Depending on the Xen version, pirq_needs_eoi might return true\n\t * not only for level triggered interrupts but for edge triggered\n\t * interrupts too. In any case Xen always honors the eoi mechanism,\n\t * not injecting any more pirqs of the same kind if the first one\n\t * hasn't received an eoi yet. Therefore using the fasteoi handler\n\t * is the right choice either way.\n\t */\n\tif (shareable)\n\t\tirq_set_chip_and_handler_name(irq, &xen_pirq_chip,\n\t\t\t\thandle_fasteoi_irq, name);\n\telse\n\t\tirq_set_chip_and_handler_name(irq, &xen_pirq_chip,\n\t\t\t\thandle_edge_irq, name);\n\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\n\treturn irq;\n}\n\n#ifdef CONFIG_PCI_MSI\nint xen_allocate_pirq_msi(struct pci_dev *dev, struct msi_desc *msidesc)\n{\n\tint rc;\n\tstruct physdev_get_free_pirq op_get_free_pirq;\n\n\top_get_free_pirq.type = MAP_PIRQ_TYPE_MSI;\n\trc = HYPERVISOR_physdev_op(PHYSDEVOP_get_free_pirq, &op_get_free_pirq);\n\n\tWARN_ONCE(rc == -ENOSYS,\n\t\t  \"hypervisor does not support the PHYSDEVOP_get_free_pirq interface\\n\");\n\n\treturn rc ? -1 : op_get_free_pirq.pirq;\n}\n\nint xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,\n\t\t\t     int pirq, int nvec, const char *name, domid_t domid)\n{\n\tint i, irq, ret;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = xen_allocate_irqs_dynamic(nvec);\n\tif (irq < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < nvec; i++) {\n\t\tirq_set_chip_and_handler_name(irq + i, &xen_pirq_chip, handle_edge_irq, name);\n\n\t\tret = xen_irq_info_pirq_setup(irq + i, 0, pirq + i, 0, domid,\n\t\t\t\t\t      i == 0 ? 0 : PIRQ_MSI_GROUP);\n\t\tif (ret < 0)\n\t\t\tgoto error_irq;\n\t}\n\n\tret = irq_set_msi_desc(irq, msidesc);\n\tif (ret < 0)\n\t\tgoto error_irq;\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\treturn irq;\nerror_irq:\n\twhile (nvec--)\n\t\t__unbind_from_irq(irq + nvec);\n\tmutex_unlock(&irq_mapping_update_lock);\n\treturn ret;\n}\n#endif\n\nint xen_destroy_irq(int irq)\n{\n\tstruct physdev_unmap_pirq unmap_irq;\n\tstruct irq_info *info = info_for_irq(irq);\n\tint rc = -ENOENT;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\t/*\n\t * If trying to remove a vector in a MSI group different\n\t * than the first one skip the PIRQ unmap unless this vector\n\t * is the first one in the group.\n\t */\n\tif (xen_initial_domain() && !(info->u.pirq.flags & PIRQ_MSI_GROUP)) {\n\t\tunmap_irq.pirq = info->u.pirq.pirq;\n\t\tunmap_irq.domid = info->u.pirq.domid;\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_unmap_pirq, &unmap_irq);\n\t\t/* If another domain quits without making the pci_disable_msix\n\t\t * call, the Xen hypervisor takes care of freeing the PIRQs\n\t\t * (free_domain_pirqs).\n\t\t */\n\t\tif ((rc == -ESRCH && info->u.pirq.domid != DOMID_SELF))\n\t\t\tpr_info(\"domain %d does not have %d anymore\\n\",\n\t\t\t\tinfo->u.pirq.domid, info->u.pirq.pirq);\n\t\telse if (rc) {\n\t\t\tpr_warn(\"unmap irq failed %d\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\txen_free_irq(irq);\n\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\treturn rc;\n}\n\nint xen_irq_from_pirq(unsigned pirq)\n{\n\tint irq;\n\n\tstruct irq_info *info;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tlist_for_each_entry(info, &xen_irq_list_head, list) {\n\t\tif (info->type != IRQT_PIRQ)\n\t\t\tcontinue;\n\t\tirq = info->irq;\n\t\tif (info->u.pirq.pirq == pirq)\n\t\t\tgoto out;\n\t}\n\tirq = -1;\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\n\treturn irq;\n}\n\n\nint xen_pirq_from_irq(unsigned irq)\n{\n\treturn pirq_from_irq(irq);\n}\nEXPORT_SYMBOL_GPL(xen_pirq_from_irq);\n\nint bind_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tint irq;\n\tint ret;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = get_evtchn_to_irq(evtchn);\n\n\tif (irq == -1) {\n\t\tirq = xen_allocate_irq_dynamic();\n\t\tif (irq < 0)\n\t\t\tgoto out;\n\n\t\tirq_set_chip_and_handler_name(irq, &xen_dynamic_chip,\n\t\t\t\t\t      handle_edge_irq, \"event\");\n\n\t\tret = xen_irq_info_evtchn_setup(irq, evtchn);\n\t\tif (ret < 0) {\n\t\t\t__unbind_from_irq(irq);\n\t\t\tirq = ret;\n\t\t\tgoto out;\n\t\t}\n\t\t/* New interdomain events are bound to VCPU 0. */\n\t\tbind_evtchn_to_cpu(evtchn, 0);\n\t} else {\n\t\tstruct irq_info *info = info_for_irq(irq);\n\t\tWARN_ON(info == NULL || info->type != IRQT_EVTCHN);\n\t}\n\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(bind_evtchn_to_irq);\n\nstatic int bind_ipi_to_irq(unsigned int ipi, unsigned int cpu)\n{\n\tstruct evtchn_bind_ipi bind_ipi;\n\tevtchn_port_t evtchn;\n\tint ret, irq;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = per_cpu(ipi_to_irq, cpu)[ipi];\n\n\tif (irq == -1) {\n\t\tirq = xen_allocate_irq_dynamic();\n\t\tif (irq < 0)\n\t\t\tgoto out;\n\n\t\tirq_set_chip_and_handler_name(irq, &xen_percpu_chip,\n\t\t\t\t\t      handle_percpu_irq, \"ipi\");\n\n\t\tbind_ipi.vcpu = xen_vcpu_nr(cpu);\n\t\tif (HYPERVISOR_event_channel_op(EVTCHNOP_bind_ipi,\n\t\t\t\t\t\t&bind_ipi) != 0)\n\t\t\tBUG();\n\t\tevtchn = bind_ipi.port;\n\n\t\tret = xen_irq_info_ipi_setup(cpu, irq, evtchn, ipi);\n\t\tif (ret < 0) {\n\t\t\t__unbind_from_irq(irq);\n\t\t\tirq = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tbind_evtchn_to_cpu(evtchn, cpu);\n\t} else {\n\t\tstruct irq_info *info = info_for_irq(irq);\n\t\tWARN_ON(info == NULL || info->type != IRQT_IPI);\n\t}\n\n out:\n\tmutex_unlock(&irq_mapping_update_lock);\n\treturn irq;\n}\n\nint bind_interdomain_evtchn_to_irq(unsigned int remote_domain,\n\t\t\t\t   evtchn_port_t remote_port)\n{\n\tstruct evtchn_bind_interdomain bind_interdomain;\n\tint err;\n\n\tbind_interdomain.remote_dom  = remote_domain;\n\tbind_interdomain.remote_port = remote_port;\n\n\terr = HYPERVISOR_event_channel_op(EVTCHNOP_bind_interdomain,\n\t\t\t\t\t  &bind_interdomain);\n\n\treturn err ? : bind_evtchn_to_irq(bind_interdomain.local_port);\n}\nEXPORT_SYMBOL_GPL(bind_interdomain_evtchn_to_irq);\n\nstatic int find_virq(unsigned int virq, unsigned int cpu, evtchn_port_t *evtchn)\n{\n\tstruct evtchn_status status;\n\tevtchn_port_t port;\n\tint rc = -ENOENT;\n\n\tmemset(&status, 0, sizeof(status));\n\tfor (port = 0; port < xen_evtchn_max_channels(); port++) {\n\t\tstatus.dom = DOMID_SELF;\n\t\tstatus.port = port;\n\t\trc = HYPERVISOR_event_channel_op(EVTCHNOP_status, &status);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tif (status.status != EVTCHNSTAT_virq)\n\t\t\tcontinue;\n\t\tif (status.u.virq == virq && status.vcpu == xen_vcpu_nr(cpu)) {\n\t\t\t*evtchn = port;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\n/**\n * xen_evtchn_nr_channels - number of usable event channel ports\n *\n * This may be less than the maximum supported by the current\n * hypervisor ABI. Use xen_evtchn_max_channels() for the maximum\n * supported.\n */\nunsigned xen_evtchn_nr_channels(void)\n{\n        return evtchn_ops->nr_channels();\n}\nEXPORT_SYMBOL_GPL(xen_evtchn_nr_channels);\n\nint bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu)\n{\n\tstruct evtchn_bind_virq bind_virq;\n\tevtchn_port_t evtchn = 0;\n\tint irq, ret;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = per_cpu(virq_to_irq, cpu)[virq];\n\n\tif (irq == -1) {\n\t\tirq = xen_allocate_irq_dynamic();\n\t\tif (irq < 0)\n\t\t\tgoto out;\n\n\t\tif (percpu)\n\t\t\tirq_set_chip_and_handler_name(irq, &xen_percpu_chip,\n\t\t\t\t\t\t      handle_percpu_irq, \"virq\");\n\t\telse\n\t\t\tirq_set_chip_and_handler_name(irq, &xen_dynamic_chip,\n\t\t\t\t\t\t      handle_edge_irq, \"virq\");\n\n\t\tbind_virq.virq = virq;\n\t\tbind_virq.vcpu = xen_vcpu_nr(cpu);\n\t\tret = HYPERVISOR_event_channel_op(EVTCHNOP_bind_virq,\n\t\t\t\t\t\t&bind_virq);\n\t\tif (ret == 0)\n\t\t\tevtchn = bind_virq.port;\n\t\telse {\n\t\t\tif (ret == -EEXIST)\n\t\t\t\tret = find_virq(virq, cpu, &evtchn);\n\t\t\tBUG_ON(ret < 0);\n\t\t}\n\n\t\tret = xen_irq_info_virq_setup(cpu, irq, evtchn, virq);\n\t\tif (ret < 0) {\n\t\t\t__unbind_from_irq(irq);\n\t\t\tirq = ret;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbind_evtchn_to_cpu(evtchn, cpu);\n\t} else {\n\t\tstruct irq_info *info = info_for_irq(irq);\n\t\tWARN_ON(info == NULL || info->type != IRQT_VIRQ);\n\t}\n\nout:\n\tmutex_unlock(&irq_mapping_update_lock);\n\n\treturn irq;\n}\n\nstatic void unbind_from_irq(unsigned int irq)\n{\n\tmutex_lock(&irq_mapping_update_lock);\n\t__unbind_from_irq(irq);\n\tmutex_unlock(&irq_mapping_update_lock);\n}\n\nint bind_evtchn_to_irqhandler(evtchn_port_t evtchn,\n\t\t\t      irq_handler_t handler,\n\t\t\t      unsigned long irqflags,\n\t\t\t      const char *devname, void *dev_id)\n{\n\tint irq, retval;\n\n\tirq = bind_evtchn_to_irq(evtchn);\n\tif (irq < 0)\n\t\treturn irq;\n\tretval = request_irq(irq, handler, irqflags, devname, dev_id);\n\tif (retval != 0) {\n\t\tunbind_from_irq(irq);\n\t\treturn retval;\n\t}\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(bind_evtchn_to_irqhandler);\n\nint bind_interdomain_evtchn_to_irqhandler(unsigned int remote_domain,\n\t\t\t\t\t  evtchn_port_t remote_port,\n\t\t\t\t\t  irq_handler_t handler,\n\t\t\t\t\t  unsigned long irqflags,\n\t\t\t\t\t  const char *devname,\n\t\t\t\t\t  void *dev_id)\n{\n\tint irq, retval;\n\n\tirq = bind_interdomain_evtchn_to_irq(remote_domain, remote_port);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tretval = request_irq(irq, handler, irqflags, devname, dev_id);\n\tif (retval != 0) {\n\t\tunbind_from_irq(irq);\n\t\treturn retval;\n\t}\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(bind_interdomain_evtchn_to_irqhandler);\n\nint bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,\n\t\t\t    irq_handler_t handler,\n\t\t\t    unsigned long irqflags, const char *devname, void *dev_id)\n{\n\tint irq, retval;\n\n\tirq = bind_virq_to_irq(virq, cpu, irqflags & IRQF_PERCPU);\n\tif (irq < 0)\n\t\treturn irq;\n\tretval = request_irq(irq, handler, irqflags, devname, dev_id);\n\tif (retval != 0) {\n\t\tunbind_from_irq(irq);\n\t\treturn retval;\n\t}\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(bind_virq_to_irqhandler);\n\nint bind_ipi_to_irqhandler(enum ipi_vector ipi,\n\t\t\t   unsigned int cpu,\n\t\t\t   irq_handler_t handler,\n\t\t\t   unsigned long irqflags,\n\t\t\t   const char *devname,\n\t\t\t   void *dev_id)\n{\n\tint irq, retval;\n\n\tirq = bind_ipi_to_irq(ipi, cpu);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirqflags |= IRQF_NO_SUSPEND | IRQF_FORCE_RESUME | IRQF_EARLY_RESUME;\n\tretval = request_irq(irq, handler, irqflags, devname, dev_id);\n\tif (retval != 0) {\n\t\tunbind_from_irq(irq);\n\t\treturn retval;\n\t}\n\n\treturn irq;\n}\n\nvoid unbind_from_irqhandler(unsigned int irq, void *dev_id)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\tfree_irq(irq, dev_id);\n\tunbind_from_irq(irq);\n}\nEXPORT_SYMBOL_GPL(unbind_from_irqhandler);\n\n/**\n * xen_set_irq_priority() - set an event channel priority.\n * @irq:irq bound to an event channel.\n * @priority: priority between XEN_IRQ_PRIORITY_MAX and XEN_IRQ_PRIORITY_MIN.\n */\nint xen_set_irq_priority(unsigned irq, unsigned priority)\n{\n\tstruct evtchn_set_priority set_priority;\n\n\tset_priority.port = evtchn_from_irq(irq);\n\tset_priority.priority = priority;\n\n\treturn HYPERVISOR_event_channel_op(EVTCHNOP_set_priority,\n\t\t\t\t\t   &set_priority);\n}\nEXPORT_SYMBOL_GPL(xen_set_irq_priority);\n\nint evtchn_make_refcounted(evtchn_port_t evtchn)\n{\n\tint irq = get_evtchn_to_irq(evtchn);\n\tstruct irq_info *info;\n\n\tif (irq == -1)\n\t\treturn -ENOENT;\n\n\tinfo = info_for_irq(irq);\n\n\tif (!info)\n\t\treturn -ENOENT;\n\n\tWARN_ON(info->refcnt != -1);\n\n\tinfo->refcnt = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(evtchn_make_refcounted);\n\nint evtchn_get(evtchn_port_t evtchn)\n{\n\tint irq;\n\tstruct irq_info *info;\n\tint err = -ENOENT;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\tirq = get_evtchn_to_irq(evtchn);\n\tif (irq == -1)\n\t\tgoto done;\n\n\tinfo = info_for_irq(irq);\n\n\tif (!info)\n\t\tgoto done;\n\n\terr = -EINVAL;\n\tif (info->refcnt <= 0)\n\t\tgoto done;\n\n\tinfo->refcnt++;\n\terr = 0;\n done:\n\tmutex_unlock(&irq_mapping_update_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(evtchn_get);\n\nvoid evtchn_put(evtchn_port_t evtchn)\n{\n\tint irq = get_evtchn_to_irq(evtchn);\n\tif (WARN_ON(irq == -1))\n\t\treturn;\n\tunbind_from_irq(irq);\n}\nEXPORT_SYMBOL_GPL(evtchn_put);\n\nvoid xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector)\n{\n\tint irq;\n\n#ifdef CONFIG_X86\n\tif (unlikely(vector == XEN_NMI_VECTOR)) {\n\t\tint rc =  HYPERVISOR_vcpu_op(VCPUOP_send_nmi, xen_vcpu_nr(cpu),\n\t\t\t\t\t     NULL);\n\t\tif (rc < 0)\n\t\t\tprintk(KERN_WARNING \"Sending nmi to CPU%d failed (rc:%d)\\n\", cpu, rc);\n\t\treturn;\n\t}\n#endif\n\tirq = per_cpu(ipi_to_irq, cpu)[vector];\n\tBUG_ON(irq < 0);\n\tnotify_remote_via_irq(irq);\n}\n\nstatic void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\n\tread_lock(&evtchn_rwlock);\n\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\n\t\txen_evtchn_handle_events(cpu);\n\n\t\tBUG_ON(!irqs_disabled());\n\n\t\tvirt_rmb(); /* Hypervisor can set upcall pending. */\n\n\t} while (vcpu_info->evtchn_upcall_pending);\n\n\tread_unlock(&evtchn_rwlock);\n}\n\nvoid xen_evtchn_do_upcall(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\n\tirq_enter();\n\n\t__xen_evtchn_do_upcall();\n\n\tirq_exit();\n\tset_irq_regs(old_regs);\n}\n\nvoid xen_hvm_evtchn_do_upcall(void)\n{\n\t__xen_evtchn_do_upcall();\n}\nEXPORT_SYMBOL_GPL(xen_hvm_evtchn_do_upcall);\n\n/* Rebind a new event channel to an existing irq. */\nvoid rebind_evtchn_irq(evtchn_port_t evtchn, int irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\t/* Make sure the irq is masked, since the new event channel\n\t   will also be masked. */\n\tdisable_irq(irq);\n\n\tmutex_lock(&irq_mapping_update_lock);\n\n\t/* After resume the irq<->evtchn mappings are all cleared out */\n\tBUG_ON(get_evtchn_to_irq(evtchn) != -1);\n\t/* Expect irq to have been bound before,\n\t   so there should be a proper type */\n\tBUG_ON(info->type == IRQT_UNBOUND);\n\n\t(void)xen_irq_info_evtchn_setup(irq, evtchn);\n\n\tmutex_unlock(&irq_mapping_update_lock);\n\n        bind_evtchn_to_cpu(evtchn, info->cpu);\n\t/* This will be deferred until interrupt is processed */\n\tirq_set_affinity(irq, cpumask_of(info->cpu));\n\n\t/* Unmask the event channel. */\n\tenable_irq(irq);\n}\n\n/* Rebind an evtchn so that it gets delivered to a specific cpu */\nstatic int xen_rebind_evtchn_to_cpu(evtchn_port_t evtchn, unsigned int tcpu)\n{\n\tstruct evtchn_bind_vcpu bind_vcpu;\n\tint masked;\n\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn -1;\n\n\tif (!xen_support_evtchn_rebind())\n\t\treturn -1;\n\n\t/* Send future instances of this interrupt to other vcpu. */\n\tbind_vcpu.port = evtchn;\n\tbind_vcpu.vcpu = xen_vcpu_nr(tcpu);\n\n\t/*\n\t * Mask the event while changing the VCPU binding to prevent\n\t * it being delivered on an unexpected VCPU.\n\t */\n\tmasked = test_and_set_mask(evtchn);\n\n\t/*\n\t * If this fails, it usually just indicates that we're dealing with a\n\t * virq or IPI channel, which don't actually need to be rebound. Ignore\n\t * it, but don't do the xenlinux-level rebind in that case.\n\t */\n\tif (HYPERVISOR_event_channel_op(EVTCHNOP_bind_vcpu, &bind_vcpu) >= 0)\n\t\tbind_evtchn_to_cpu(evtchn, tcpu);\n\n\tif (!masked)\n\t\tunmask_evtchn(evtchn);\n\n\treturn 0;\n}\n\nstatic int set_affinity_irq(struct irq_data *data, const struct cpumask *dest,\n\t\t\t    bool force)\n{\n\tunsigned tcpu = cpumask_first_and(dest, cpu_online_mask);\n\tint ret = xen_rebind_evtchn_to_cpu(evtchn_from_irq(data->irq), tcpu);\n\n\tif (!ret)\n\t\tirq_data_update_effective_affinity(data, cpumask_of(tcpu));\n\n\treturn ret;\n}\n\n/* To be called with desc->lock held. */\nint xen_set_affinity_evtchn(struct irq_desc *desc, unsigned int tcpu)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\treturn set_affinity_irq(d, cpumask_of(tcpu), false);\n}\nEXPORT_SYMBOL_GPL(xen_set_affinity_evtchn);\n\nstatic void enable_dynirq(struct irq_data *data)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(data->irq);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tunmask_evtchn(evtchn);\n}\n\nstatic void disable_dynirq(struct irq_data *data)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(data->irq);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tmask_evtchn(evtchn);\n}\n\nstatic void ack_dynirq(struct irq_data *data)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(data->irq);\n\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\n\tif (unlikely(irqd_is_setaffinity_pending(data)) &&\n\t    likely(!irqd_irq_disabled(data))) {\n\t\tint masked = test_and_set_mask(evtchn);\n\n\t\tclear_evtchn(evtchn);\n\n\t\tirq_move_masked_irq(data);\n\n\t\tif (!masked)\n\t\t\tunmask_evtchn(evtchn);\n\t} else\n\t\tclear_evtchn(evtchn);\n}\n\nstatic void mask_ack_dynirq(struct irq_data *data)\n{\n\tdisable_dynirq(data);\n\tack_dynirq(data);\n}\n\nstatic int retrigger_dynirq(struct irq_data *data)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(data->irq);\n\tint masked;\n\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn 0;\n\n\tmasked = test_and_set_mask(evtchn);\n\tset_evtchn(evtchn);\n\tif (!masked)\n\t\tunmask_evtchn(evtchn);\n\n\treturn 1;\n}\n\nstatic void restore_pirqs(void)\n{\n\tint pirq, rc, irq, gsi;\n\tstruct physdev_map_pirq map_irq;\n\tstruct irq_info *info;\n\n\tlist_for_each_entry(info, &xen_irq_list_head, list) {\n\t\tif (info->type != IRQT_PIRQ)\n\t\t\tcontinue;\n\n\t\tpirq = info->u.pirq.pirq;\n\t\tgsi = info->u.pirq.gsi;\n\t\tirq = info->irq;\n\n\t\t/* save/restore of PT devices doesn't work, so at this point the\n\t\t * only devices present are GSI based emulated devices */\n\t\tif (!gsi)\n\t\t\tcontinue;\n\n\t\tmap_irq.domid = DOMID_SELF;\n\t\tmap_irq.type = MAP_PIRQ_TYPE_GSI;\n\t\tmap_irq.index = gsi;\n\t\tmap_irq.pirq = pirq;\n\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_map_pirq, &map_irq);\n\t\tif (rc) {\n\t\t\tpr_warn(\"xen map irq failed gsi=%d irq=%d pirq=%d rc=%d\\n\",\n\t\t\t\tgsi, irq, pirq, rc);\n\t\t\txen_free_irq(irq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(KERN_DEBUG \"xen: --> irq=%d, pirq=%d\\n\", irq, map_irq.pirq);\n\n\t\t__startup_pirq(irq);\n\t}\n}\n\nstatic void restore_cpu_virqs(unsigned int cpu)\n{\n\tstruct evtchn_bind_virq bind_virq;\n\tevtchn_port_t evtchn;\n\tint virq, irq;\n\n\tfor (virq = 0; virq < NR_VIRQS; virq++) {\n\t\tif ((irq = per_cpu(virq_to_irq, cpu)[virq]) == -1)\n\t\t\tcontinue;\n\n\t\tBUG_ON(virq_from_irq(irq) != virq);\n\n\t\t/* Get a new binding from Xen. */\n\t\tbind_virq.virq = virq;\n\t\tbind_virq.vcpu = xen_vcpu_nr(cpu);\n\t\tif (HYPERVISOR_event_channel_op(EVTCHNOP_bind_virq,\n\t\t\t\t\t\t&bind_virq) != 0)\n\t\t\tBUG();\n\t\tevtchn = bind_virq.port;\n\n\t\t/* Record the new mapping. */\n\t\t(void)xen_irq_info_virq_setup(cpu, irq, evtchn, virq);\n\t\tbind_evtchn_to_cpu(evtchn, cpu);\n\t}\n}\n\nstatic void restore_cpu_ipis(unsigned int cpu)\n{\n\tstruct evtchn_bind_ipi bind_ipi;\n\tevtchn_port_t evtchn;\n\tint ipi, irq;\n\n\tfor (ipi = 0; ipi < XEN_NR_IPIS; ipi++) {\n\t\tif ((irq = per_cpu(ipi_to_irq, cpu)[ipi]) == -1)\n\t\t\tcontinue;\n\n\t\tBUG_ON(ipi_from_irq(irq) != ipi);\n\n\t\t/* Get a new binding from Xen. */\n\t\tbind_ipi.vcpu = xen_vcpu_nr(cpu);\n\t\tif (HYPERVISOR_event_channel_op(EVTCHNOP_bind_ipi,\n\t\t\t\t\t\t&bind_ipi) != 0)\n\t\t\tBUG();\n\t\tevtchn = bind_ipi.port;\n\n\t\t/* Record the new mapping. */\n\t\t(void)xen_irq_info_ipi_setup(cpu, irq, evtchn, ipi);\n\t\tbind_evtchn_to_cpu(evtchn, cpu);\n\t}\n}\n\n/* Clear an irq's pending state, in preparation for polling on it */\nvoid xen_clear_irq_pending(int irq)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tclear_evtchn(evtchn);\n}\nEXPORT_SYMBOL(xen_clear_irq_pending);\nvoid xen_set_irq_pending(int irq)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tset_evtchn(evtchn);\n}\n\nbool xen_test_irq_pending(int irq)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\tbool ret = false;\n\n\tif (VALID_EVTCHN(evtchn))\n\t\tret = test_evtchn(evtchn);\n\n\treturn ret;\n}\n\n/* Poll waiting for an irq to become pending with timeout.  In the usual case,\n * the irq will be disabled so it won't deliver an interrupt. */\nvoid xen_poll_irq_timeout(int irq, u64 timeout)\n{\n\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\n\tif (VALID_EVTCHN(evtchn)) {\n\t\tstruct sched_poll poll;\n\n\t\tpoll.nr_ports = 1;\n\t\tpoll.timeout = timeout;\n\t\tset_xen_guest_handle(poll.ports, &evtchn);\n\n\t\tif (HYPERVISOR_sched_op(SCHEDOP_poll, &poll) != 0)\n\t\t\tBUG();\n\t}\n}\nEXPORT_SYMBOL(xen_poll_irq_timeout);\n/* Poll waiting for an irq to become pending.  In the usual case, the\n * irq will be disabled so it won't deliver an interrupt. */\nvoid xen_poll_irq(int irq)\n{\n\txen_poll_irq_timeout(irq, 0 /* no timeout */);\n}\n\n/* Check whether the IRQ line is shared with other guests. */\nint xen_test_irq_shared(int irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tstruct physdev_irq_status_query irq_status;\n\n\tif (WARN_ON(!info))\n\t\treturn -ENOENT;\n\n\tirq_status.irq = info->u.pirq.pirq;\n\n\tif (HYPERVISOR_physdev_op(PHYSDEVOP_irq_status_query, &irq_status))\n\t\treturn 0;\n\treturn !(irq_status.flags & XENIRQSTAT_shared);\n}\nEXPORT_SYMBOL_GPL(xen_test_irq_shared);\n\nvoid xen_irq_resume(void)\n{\n\tunsigned int cpu;\n\tstruct irq_info *info;\n\n\t/* New event-channel space is not 'live' yet. */\n\txen_evtchn_resume();\n\n\t/* No IRQ <-> event-channel mappings. */\n\tlist_for_each_entry(info, &xen_irq_list_head, list)\n\t\tinfo->evtchn = 0; /* zap event-channel binding */\n\n\tclear_evtchn_to_irq_all();\n\n\tfor_each_possible_cpu(cpu) {\n\t\trestore_cpu_virqs(cpu);\n\t\trestore_cpu_ipis(cpu);\n\t}\n\n\trestore_pirqs();\n}\n\nstatic struct irq_chip xen_dynamic_chip __read_mostly = {\n\t.name\t\t\t= \"xen-dyn\",\n\n\t.irq_disable\t\t= disable_dynirq,\n\t.irq_mask\t\t= disable_dynirq,\n\t.irq_unmask\t\t= enable_dynirq,\n\n\t.irq_ack\t\t= ack_dynirq,\n\t.irq_mask_ack\t\t= mask_ack_dynirq,\n\n\t.irq_set_affinity\t= set_affinity_irq,\n\t.irq_retrigger\t\t= retrigger_dynirq,\n};\n\nstatic struct irq_chip xen_pirq_chip __read_mostly = {\n\t.name\t\t\t= \"xen-pirq\",\n\n\t.irq_startup\t\t= startup_pirq,\n\t.irq_shutdown\t\t= shutdown_pirq,\n\t.irq_enable\t\t= enable_pirq,\n\t.irq_disable\t\t= disable_pirq,\n\n\t.irq_mask\t\t= disable_dynirq,\n\t.irq_unmask\t\t= enable_dynirq,\n\n\t.irq_ack\t\t= eoi_pirq,\n\t.irq_eoi\t\t= eoi_pirq,\n\t.irq_mask_ack\t\t= mask_ack_pirq,\n\n\t.irq_set_affinity\t= set_affinity_irq,\n\n\t.irq_retrigger\t\t= retrigger_dynirq,\n};\n\nstatic struct irq_chip xen_percpu_chip __read_mostly = {\n\t.name\t\t\t= \"xen-percpu\",\n\n\t.irq_disable\t\t= disable_dynirq,\n\t.irq_mask\t\t= disable_dynirq,\n\t.irq_unmask\t\t= enable_dynirq,\n\n\t.irq_ack\t\t= ack_dynirq,\n};\n\nint xen_set_callback_via(uint64_t via)\n{\n\tstruct xen_hvm_param a;\n\ta.domid = DOMID_SELF;\n\ta.index = HVM_PARAM_CALLBACK_IRQ;\n\ta.value = via;\n\treturn HYPERVISOR_hvm_op(HVMOP_set_param, &a);\n}\nEXPORT_SYMBOL_GPL(xen_set_callback_via);\n\n#ifdef CONFIG_XEN_PVHVM\n/* Vector callbacks are better than PCI interrupts to receive event\n * channel notifications because we can receive vector callbacks on any\n * vcpu and we don't need PCI support or APIC interactions. */\nvoid xen_setup_callback_vector(void)\n{\n\tuint64_t callback_via;\n\n\tif (xen_have_vector_callback) {\n\t\tcallback_via = HVM_CALLBACK_VECTOR(HYPERVISOR_CALLBACK_VECTOR);\n\t\tif (xen_set_callback_via(callback_via)) {\n\t\t\tpr_err(\"Request for Xen HVM callback vector failed\\n\");\n\t\t\txen_have_vector_callback = 0;\n\t\t}\n\t}\n}\n\nstatic __init void xen_alloc_callback_vector(void)\n{\n\tif (!xen_have_vector_callback)\n\t\treturn;\n\n\tpr_info(\"Xen HVM callback vector for event delivery is enabled\\n\");\n\talloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR, asm_sysvec_xen_hvm_callback);\n}\n#else\nvoid xen_setup_callback_vector(void) {}\nstatic inline void xen_alloc_callback_vector(void) {}\n#endif\n\n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX \"xen.\"\n\nstatic bool fifo_events = true;\nmodule_param(fifo_events, bool, 0);\n\nvoid __init xen_init_IRQ(void)\n{\n\tint ret = -EINVAL;\n\tevtchn_port_t evtchn;\n\n\tif (fifo_events)\n\t\tret = xen_evtchn_fifo_init();\n\tif (ret < 0)\n\t\txen_evtchn_2l_init();\n\n\tevtchn_to_irq = kcalloc(EVTCHN_ROW(xen_evtchn_max_channels()),\n\t\t\t\tsizeof(*evtchn_to_irq), GFP_KERNEL);\n\tBUG_ON(!evtchn_to_irq);\n\n\t/* No event channels are 'live' right now. */\n\tfor (evtchn = 0; evtchn < xen_evtchn_nr_channels(); evtchn++)\n\t\tmask_evtchn(evtchn);\n\n\tpirq_needs_eoi = pirq_needs_eoi_flag;\n\n#ifdef CONFIG_X86\n\tif (xen_pv_domain()) {\n\t\tif (xen_initial_domain())\n\t\t\tpci_xen_initial_domain();\n\t}\n\tif (xen_feature(XENFEAT_hvm_callback_vector)) {\n\t\txen_setup_callback_vector();\n\t\txen_alloc_callback_vector();\n\t}\n\n\tif (xen_hvm_domain()) {\n\t\tnative_init_IRQ();\n\t\t/* pci_xen_hvm_init must be called after native_init_IRQ so that\n\t\t * __acpi_register_gsi can point at the right function */\n\t\tpci_xen_hvm_init();\n\t} else {\n\t\tint rc;\n\t\tstruct physdev_pirq_eoi_gmfn eoi_gmfn;\n\n\t\tpirq_eoi_map = (void *)__get_free_page(GFP_KERNEL|__GFP_ZERO);\n\t\teoi_gmfn.gmfn = virt_to_gfn(pirq_eoi_map);\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_pirq_eoi_gmfn_v2, &eoi_gmfn);\n\t\tif (rc != 0) {\n\t\t\tfree_page((unsigned long) pirq_eoi_map);\n\t\t\tpirq_eoi_map = NULL;\n\t\t} else\n\t\t\tpirq_needs_eoi = pirq_check_eoi_map;\n\t}\n#endif\n}\n"], "filenames": ["drivers/xen/events/events_base.c"], "buggy_code_start_loc": [35], "buggy_code_end_loc": [1245], "fixing_code_start_loc": [36], "fixing_code_end_loc": [1277], "type": "CWE-362", "message": "An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5.", "other": {"cve": {"id": "CVE-2020-27675", "sourceIdentifier": "cve@mitre.org", "published": "2020-10-22T21:15:14.153", "lastModified": "2022-04-26T16:29:52.957", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux versiones hasta 5.9.1, como es usado con Xen versiones hasta 4.14.x.&#xa0;El archivo drivers/xen/events/events_base.c permite la eliminaci\u00f3n del canal de eventos durante el ciclo de manejo de eventos (una condici\u00f3n de carrera).&#xa0;Esto puede causar una desreferencia del puntero NULL y un uso de la memoria previamente liberada como es demostrado por un bloqueo dom0 por medio de eventos para un dispositivo paravirtualizado en reconfiguraci\u00f3n, tambi\u00e9n se conoce como CID-073d0552ead5"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-416"}, {"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.9.1", "matchCriteriaId": "C7E1EBA7-1B6D-4A6D-ADFF-2B556573F073"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/01/19/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=073d0552ead5bfc7a3a9c01de590e924f11b5dd2", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00027.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3ZG6TZLD23QO3PV2AN2HB625ZX47ALTT/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6USZ4APZSBQDHGJLJMHW5JBN4QZV6SKZ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GNF2R7FUT4IOJ2RIRGQ7X5R4F4FVVLSR/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202011-06", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://xenbits.xen.org/xsa/advisory-331.html", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2"}}