{"buggy_code": ["##############################################################################\n#\n# Copyright (c) 2001, 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"HTTP Request Parser\n\nThis server uses asyncore to accept connections and do initial\nprocessing but threads to do work.\n\"\"\"\nimport re\nfrom io import BytesIO\n\nfrom waitress.compat import (\n    tostr,\n    urlparse,\n    unquote_bytes_to_wsgi,\n)\n\nfrom waitress.buffers import OverflowableBuffer\n\nfrom waitress.receiver import (\n    FixedStreamReceiver,\n    ChunkedReceiver,\n)\n\nfrom waitress.utilities import (\n    find_double_newline,\n    RequestEntityTooLarge,\n    RequestHeaderFieldsTooLarge,\n    BadRequest,\n)\n\n\nclass ParsingError(Exception):\n    pass\n\n\nclass HTTPRequestParser(object):\n    \"\"\"A structure that collects the HTTP request.\n\n    Once the stream is completed, the instance is passed to\n    a server task constructor.\n    \"\"\"\n\n    completed = False  # Set once request is completed.\n    empty = False  # Set if no request was made.\n    expect_continue = False  # client sent \"Expect: 100-continue\" header\n    headers_finished = False  # True when headers have been read\n    header_plus = b\"\"\n    chunked = False\n    content_length = 0\n    header_bytes_received = 0\n    body_bytes_received = 0\n    body_rcv = None\n    version = \"1.0\"\n    error = None\n    connection_close = False\n\n    # Other attributes: first_line, header, headers, command, uri, version,\n    # path, query, fragment\n\n    def __init__(self, adj):\n        \"\"\"\n        adj is an Adjustments object.\n        \"\"\"\n        # headers is a mapping containing keys translated to uppercase\n        # with dashes turned into underscores.\n        self.headers = {}\n        self.adj = adj\n\n    def received(self, data):\n        \"\"\"\n        Receives the HTTP stream for one request.  Returns the number of\n        bytes consumed.  Sets the completed flag once both the header and the\n        body have been received.\n        \"\"\"\n        if self.completed:\n            return 0  # Can't consume any more.\n        datalen = len(data)\n        br = self.body_rcv\n        if br is None:\n            # In header.\n            s = self.header_plus + data\n            index = find_double_newline(s)\n            if index >= 0:\n                # Header finished.\n                header_plus = s[:index]\n                consumed = len(data) - (len(s) - index)\n                # Remove preceeding blank lines.\n                header_plus = header_plus.lstrip()\n                if not header_plus:\n                    self.empty = True\n                    self.completed = True\n                else:\n                    try:\n                        self.parse_header(header_plus)\n                    except ParsingError as e:\n                        self.error = BadRequest(e.args[0])\n                        self.completed = True\n                    else:\n                        if self.body_rcv is None:\n                            # no content-length header and not a t-e: chunked\n                            # request\n                            self.completed = True\n                        if self.content_length > 0:\n                            max_body = self.adj.max_request_body_size\n                            # we won't accept this request if the content-length\n                            # is too large\n                            if self.content_length >= max_body:\n                                self.error = RequestEntityTooLarge(\n                                    \"exceeds max_body of %s\" % max_body\n                                )\n                                self.completed = True\n                self.headers_finished = True\n                return consumed\n            else:\n                # Header not finished yet.\n                self.header_bytes_received += datalen\n                max_header = self.adj.max_request_header_size\n                if self.header_bytes_received >= max_header:\n                    # malformed header, we need to construct some request\n                    # on our own. we disregard the incoming(?) requests HTTP\n                    # version and just use 1.0. IOW someone just sent garbage\n                    # over the wire\n                    self.parse_header(b\"GET / HTTP/1.0\\n\")\n                    self.error = RequestHeaderFieldsTooLarge(\n                        \"exceeds max_header of %s\" % max_header\n                    )\n                    self.completed = True\n                self.header_plus = s\n                return datalen\n        else:\n            # In body.\n            consumed = br.received(data)\n            self.body_bytes_received += consumed\n            max_body = self.adj.max_request_body_size\n            if self.body_bytes_received >= max_body:\n                # this will only be raised during t-e: chunked requests\n                self.error = RequestEntityTooLarge(\"exceeds max_body of %s\" % max_body)\n                self.completed = True\n            elif br.error:\n                # garbage in chunked encoding input probably\n                self.error = br.error\n                self.completed = True\n            elif br.completed:\n                # The request (with the body) is ready to use.\n                self.completed = True\n                if self.chunked:\n                    # We've converted the chunked transfer encoding request\n                    # body into a normal request body, so we know its content\n                    # length; set the header here.  We already popped the\n                    # TRANSFER_ENCODING header in parse_header, so this will\n                    # appear to the client to be an entirely non-chunked HTTP\n                    # request with a valid content-length.\n                    self.headers[\"CONTENT_LENGTH\"] = str(br.__len__())\n            return consumed\n\n    def parse_header(self, header_plus):\n        \"\"\"\n        Parses the header_plus block of text (the headers plus the\n        first line of the request).\n        \"\"\"\n        index = header_plus.find(b\"\\n\")\n        if index >= 0:\n            first_line = header_plus[:index].rstrip()\n            header = header_plus[index + 1 :]\n        else:\n            first_line = header_plus.rstrip()\n            header = b\"\"\n\n        self.first_line = first_line  # for testing\n\n        lines = get_header_lines(header)\n\n        headers = self.headers\n        for line in lines:\n            index = line.find(b\":\")\n            if index > 0:\n                key = line[:index]\n                if b\"_\" in key:\n                    continue\n                value = line[index + 1 :].strip()\n                key1 = tostr(key.upper().replace(b\"-\", b\"_\"))\n                # If a header already exists, we append subsequent values\n                # seperated by a comma. Applications already need to handle\n                # the comma seperated values, as HTTP front ends might do\n                # the concatenation for you (behavior specified in RFC2616).\n                try:\n                    headers[key1] += tostr(b\", \" + value)\n                except KeyError:\n                    headers[key1] = tostr(value)\n            # else there's garbage in the headers?\n\n        # command, uri, version will be bytes\n        command, uri, version = crack_first_line(first_line)\n        version = tostr(version)\n        command = tostr(command)\n        self.command = command\n        self.version = version\n        (\n            self.proxy_scheme,\n            self.proxy_netloc,\n            self.path,\n            self.query,\n            self.fragment,\n        ) = split_uri(uri)\n        self.url_scheme = self.adj.url_scheme\n        connection = headers.get(\"CONNECTION\", \"\")\n\n        if version == \"1.0\":\n            if connection.lower() != \"keep-alive\":\n                self.connection_close = True\n\n        if version == \"1.1\":\n            # since the server buffers data from chunked transfers and clients\n            # never need to deal with chunked requests, downstream clients\n            # should not see the HTTP_TRANSFER_ENCODING header; we pop it\n            # here\n            te = headers.pop(\"TRANSFER_ENCODING\", \"\")\n            if te.lower() == \"chunked\":\n                self.chunked = True\n                buf = OverflowableBuffer(self.adj.inbuf_overflow)\n                self.body_rcv = ChunkedReceiver(buf)\n            expect = headers.get(\"EXPECT\", \"\").lower()\n            self.expect_continue = expect == \"100-continue\"\n            if connection.lower() == \"close\":\n                self.connection_close = True\n\n        if not self.chunked:\n            try:\n                cl = int(headers.get(\"CONTENT_LENGTH\", 0))\n            except ValueError:\n                cl = 0\n            self.content_length = cl\n            if cl > 0:\n                buf = OverflowableBuffer(self.adj.inbuf_overflow)\n                self.body_rcv = FixedStreamReceiver(cl, buf)\n\n    def get_body_stream(self):\n        body_rcv = self.body_rcv\n        if body_rcv is not None:\n            return body_rcv.getfile()\n        else:\n            return BytesIO()\n\n    def close(self):\n        body_rcv = self.body_rcv\n        if body_rcv is not None:\n            body_rcv.getbuf().close()\n\n\ndef split_uri(uri):\n    # urlsplit handles byte input by returning bytes on py3, so\n    # scheme, netloc, path, query, and fragment are bytes\n\n    scheme = netloc = path = query = fragment = b\"\"\n\n    # urlsplit below will treat this as a scheme-less netloc, thereby losing\n    # the original intent of the request. Here we shamelessly stole 4 lines of\n    # code from the CPython stdlib to parse out the fragment and query but\n    # leave the path alone. See\n    # https://github.com/python/cpython/blob/8c9e9b0cd5b24dfbf1424d1f253d02de80e8f5ef/Lib/urllib/parse.py#L465-L468\n    # and https://github.com/Pylons/waitress/issues/260\n\n    if uri[:2] == b\"//\":\n        path = uri\n\n        if b\"#\" in path:\n            path, fragment = path.split(b\"#\", 1)\n\n        if b\"?\" in path:\n            path, query = path.split(b\"?\", 1)\n    else:\n        try:\n            scheme, netloc, path, query, fragment = urlparse.urlsplit(uri)\n        except UnicodeError:\n            raise ParsingError(\"Bad URI\")\n\n    return (\n        tostr(scheme),\n        tostr(netloc),\n        unquote_bytes_to_wsgi(path),\n        tostr(query),\n        tostr(fragment),\n    )\n\n\ndef get_header_lines(header):\n    \"\"\"\n    Splits the header into lines, putting multi-line headers together.\n    \"\"\"\n    r = []\n    lines = header.split(b\"\\n\")\n    for line in lines:\n        if line.startswith((b\" \", b\"\\t\")):\n            if not r:\n                # https://corte.si/posts/code/pathod/pythonservers/index.html\n                raise ParsingError('Malformed header line \"%s\"' % tostr(line))\n            r[-1] += line\n        else:\n            r.append(line)\n    return r\n\n\nfirst_line_re = re.compile(\n    b\"([^ ]+) \"\n    b\"((?:[^ :?#]+://[^ ?#/]*(?:[0-9]{1,5})?)?[^ ]+)\"\n    b\"(( HTTP/([0-9.]+))$|$)\"\n)\n\n\ndef crack_first_line(line):\n    m = first_line_re.match(line)\n    if m is not None and m.end() == len(line):\n        if m.group(3):\n            version = m.group(5)\n        else:\n            version = b\"\"\n        method = m.group(1)\n\n        # the request methods that are currently defined are all uppercase:\n        # https://www.iana.org/assignments/http-methods/http-methods.xhtml and\n        # the request method is case sensitive according to\n        # https://tools.ietf.org/html/rfc7231#section-4.1\n\n        # By disallowing anything but uppercase methods we save poor\n        # unsuspecting souls from sending lowercase HTTP methods to waitress\n        # and having the request complete, while servers like nginx drop the\n        # request onto the floor.\n        if method != method.upper():\n            raise ParsingError('Malformed HTTP method \"%s\"' % tostr(method))\n        uri = m.group(2)\n        return method, uri, version\n    else:\n        return b\"\", b\"\", b\"\"\n", "##############################################################################\n#\n# Copyright (c) 2001, 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Data Chunk Receiver\n\"\"\"\n\nfrom waitress.utilities import find_double_newline\n\nfrom waitress.utilities import BadRequest\n\n\nclass FixedStreamReceiver(object):\n\n    # See IStreamConsumer\n    completed = False\n    error = None\n\n    def __init__(self, cl, buf):\n        self.remain = cl\n        self.buf = buf\n\n    def __len__(self):\n        return self.buf.__len__()\n\n    def received(self, data):\n        \"See IStreamConsumer\"\n        rm = self.remain\n        if rm < 1:\n            self.completed = True  # Avoid any chance of spinning\n            return 0\n        datalen = len(data)\n        if rm <= datalen:\n            self.buf.append(data[:rm])\n            self.remain = 0\n            self.completed = True\n            return rm\n        else:\n            self.buf.append(data)\n            self.remain -= datalen\n            return datalen\n\n    def getfile(self):\n        return self.buf.getfile()\n\n    def getbuf(self):\n        return self.buf\n\n\nclass ChunkedReceiver(object):\n\n    chunk_remainder = 0\n    control_line = b\"\"\n    all_chunks_received = False\n    trailer = b\"\"\n    completed = False\n    error = None\n\n    # max_control_line = 1024\n    # max_trailer = 65536\n\n    def __init__(self, buf):\n        self.buf = buf\n\n    def __len__(self):\n        return self.buf.__len__()\n\n    def received(self, s):\n        # Returns the number of bytes consumed.\n        if self.completed:\n            return 0\n        orig_size = len(s)\n        while s:\n            rm = self.chunk_remainder\n            if rm > 0:\n                # Receive the remainder of a chunk.\n                to_write = s[:rm]\n                self.buf.append(to_write)\n                written = len(to_write)\n                s = s[written:]\n                self.chunk_remainder -= written\n            elif not self.all_chunks_received:\n                # Receive a control line.\n                s = self.control_line + s\n                pos = s.find(b\"\\n\")\n                if pos < 0:\n                    # Control line not finished.\n                    self.control_line = s\n                    s = \"\"\n                else:\n                    # Control line finished.\n                    line = s[:pos]\n                    s = s[pos + 1 :]\n                    self.control_line = b\"\"\n                    line = line.strip()\n                    if line:\n                        # Begin a new chunk.\n                        semi = line.find(b\";\")\n                        if semi >= 0:\n                            # discard extension info.\n                            line = line[:semi]\n                        try:\n                            sz = int(line.strip(), 16)  # hexadecimal\n                        except ValueError:  # garbage in input\n                            self.error = BadRequest(\"garbage in chunked encoding input\")\n                            sz = 0\n                        if sz > 0:\n                            # Start a new chunk.\n                            self.chunk_remainder = sz\n                        else:\n                            # Finished chunks.\n                            self.all_chunks_received = True\n                    # else expect a control line.\n            else:\n                # Receive the trailer.\n                trailer = self.trailer + s\n                if trailer.startswith(b\"\\r\\n\"):\n                    # No trailer.\n                    self.completed = True\n                    return orig_size - (len(trailer) - 2)\n                elif trailer.startswith(b\"\\n\"):\n                    # No trailer.\n                    self.completed = True\n                    return orig_size - (len(trailer) - 1)\n                pos = find_double_newline(trailer)\n                if pos < 0:\n                    # Trailer not finished.\n                    self.trailer = trailer\n                    s = b\"\"\n                else:\n                    # Finished the trailer.\n                    self.completed = True\n                    self.trailer = trailer[:pos]\n                    return orig_size - (len(trailer) - pos)\n        return orig_size\n\n    def getfile(self):\n        return self.buf.getfile()\n\n    def getbuf(self):\n        return self.buf\n", "import unittest\nimport io\n\n\nclass TestHTTPChannel(unittest.TestCase):\n    def _makeOne(self, sock, addr, adj, map=None):\n        from waitress.channel import HTTPChannel\n\n        server = DummyServer()\n        return HTTPChannel(server, sock, addr, adj=adj, map=map)\n\n    def _makeOneWithMap(self, adj=None):\n        if adj is None:\n            adj = DummyAdjustments()\n        sock = DummySock()\n        map = {}\n        inst = self._makeOne(sock, \"127.0.0.1\", adj, map=map)\n        inst.outbuf_lock = DummyLock()\n        return inst, sock, map\n\n    def test_ctor(self):\n        inst, _, map = self._makeOneWithMap()\n        self.assertEqual(inst.addr, \"127.0.0.1\")\n        self.assertEqual(inst.sendbuf_len, 2048)\n        self.assertEqual(map[100], inst)\n\n    def test_total_outbufs_len_an_outbuf_size_gt_sys_maxint(self):\n        from waitress.compat import MAXINT\n\n        inst, _, map = self._makeOneWithMap()\n\n        class DummyBuffer(object):\n            chunks = []\n\n            def append(self, data):\n                self.chunks.append(data)\n\n        class DummyData(object):\n            def __len__(self):\n                return MAXINT\n\n        inst.total_outbufs_len = 1\n        inst.outbufs = [DummyBuffer()]\n        inst.write_soon(DummyData())\n        # we are testing that this method does not raise an OverflowError\n        # (see https://github.com/Pylons/waitress/issues/47)\n        self.assertEqual(inst.total_outbufs_len, MAXINT + 1)\n\n    def test_writable_something_in_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.total_outbufs_len = 3\n        self.assertTrue(inst.writable())\n\n    def test_writable_nothing_in_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        self.assertFalse(inst.writable())\n\n    def test_writable_nothing_in_outbuf_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = True\n        self.assertTrue(inst.writable())\n\n    def test_handle_write_not_connected(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.connected = False\n        self.assertFalse(inst.handle_write())\n\n    def test_handle_write_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n\n    def test_handle_write_no_request_with_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertNotEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_outbuf_raises_socketerror(self):\n        import socket\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"abc\", socket.error)\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_outbuf_raises_othererror(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"abc\", IOError)\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_no_requests_no_outbuf_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"\")\n        inst.outbufs = [outbuf]\n        inst.will_close = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_no_requests_outbuf_gt_send_bytes(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 2\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_close_when_flushed(self):\n        inst, sock, map = self._makeOneWithMap()\n        outbuf = DummyBuffer(b\"abc\")\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.will_close = False\n        inst.close_when_flushed = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, True)\n        self.assertEqual(inst.close_when_flushed, False)\n        self.assertEqual(sock.sent, b\"abc\")\n        self.assertTrue(outbuf.closed)\n\n    def test_readable_no_requests_not_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.will_close = False\n        self.assertEqual(inst.readable(), True)\n\n    def test_readable_no_requests_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.will_close = True\n        self.assertEqual(inst.readable(), False)\n\n    def test_readable_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = True\n        self.assertEqual(inst.readable(), False)\n\n    def test_handle_read_no_error(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = False\n        inst.recv = lambda *arg: b\"abc\"\n        inst.last_activity = 0\n        L = []\n        inst.received = lambda x: L.append(x)\n        result = inst.handle_read()\n        self.assertEqual(result, None)\n        self.assertNotEqual(inst.last_activity, 0)\n        self.assertEqual(L, [b\"abc\"])\n\n    def test_handle_read_error(self):\n        import socket\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = False\n\n        def recv(b):\n            raise socket.error\n\n        inst.recv = recv\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_read()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test_write_soon_empty_byte(self):\n        inst, sock, map = self._makeOneWithMap()\n        wrote = inst.write_soon(b\"\")\n        self.assertEqual(wrote, 0)\n        self.assertEqual(len(inst.outbufs[0]), 0)\n\n    def test_write_soon_nonempty_byte(self):\n        inst, sock, map = self._makeOneWithMap()\n        wrote = inst.write_soon(b\"a\")\n        self.assertEqual(wrote, 1)\n        self.assertEqual(len(inst.outbufs[0]), 1)\n\n    def test_write_soon_filewrapper(self):\n        from waitress.buffers import ReadOnlyFileBasedBuffer\n\n        f = io.BytesIO(b\"abc\")\n        wrapper = ReadOnlyFileBasedBuffer(f, 8192)\n        wrapper.prepare()\n        inst, sock, map = self._makeOneWithMap()\n        outbufs = inst.outbufs\n        orig_outbuf = outbufs[0]\n        wrote = inst.write_soon(wrapper)\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(outbufs), 3)\n        self.assertEqual(outbufs[0], orig_outbuf)\n        self.assertEqual(outbufs[1], wrapper)\n        self.assertEqual(outbufs[2].__class__.__name__, \"OverflowableBuffer\")\n\n    def test_write_soon_disconnected(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.connected = False\n        self.assertRaises(ClientDisconnected, lambda: inst.write_soon(b\"stuff\"))\n\n    def test_write_soon_disconnected_while_over_watermark(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n\n        def dummy_flush():\n            inst.connected = False\n\n        inst._flush_outbufs_below_high_watermark = dummy_flush\n        self.assertRaises(ClientDisconnected, lambda: inst.write_soon(b\"stuff\"))\n\n    def test_write_soon_rotates_outbuf_on_overflow(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.outbuf_high_watermark = 3\n        inst.current_outbuf_count = 4\n        wrote = inst.write_soon(b\"xyz\")\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(inst.outbufs), 2)\n        self.assertEqual(inst.outbufs[0].get(), b\"\")\n        self.assertEqual(inst.outbufs[1].get(), b\"xyz\")\n\n    def test_write_soon_waits_on_backpressure(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.outbuf_high_watermark = 3\n        inst.total_outbufs_len = 4\n        inst.current_outbuf_count = 4\n\n        class Lock(DummyLock):\n            def wait(self):\n                inst.total_outbufs_len = 0\n                super(Lock, self).wait()\n\n        inst.outbuf_lock = Lock()\n        wrote = inst.write_soon(b\"xyz\")\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(inst.outbufs), 2)\n        self.assertEqual(inst.outbufs[0].get(), b\"\")\n        self.assertEqual(inst.outbufs[1].get(), b\"xyz\")\n        self.assertTrue(inst.outbuf_lock.waited)\n\n    def test_handle_write_notify_after_flush(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 1\n        inst.adj.outbuf_high_watermark = 5\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertTrue(inst.outbuf_lock.notified)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_no_notify_after_flush(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 1\n        inst.adj.outbuf_high_watermark = 2\n        sock.send = lambda x: False\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertFalse(inst.outbuf_lock.notified)\n        self.assertEqual(sock.sent, b\"\")\n\n    def test__flush_some_empty_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        result = inst._flush_some()\n        self.assertEqual(result, False)\n\n    def test__flush_some_full_outbuf_socket_returns_nonzero(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.outbufs[0].append(b\"abc\")\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n\n    def test__flush_some_full_outbuf_socket_returns_zero(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: False\n        inst.outbufs[0].append(b\"abc\")\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, False)\n\n    def test_flush_some_multiple_buffers_first_empty(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: len(x)\n        buffer = DummyBuffer(b\"abc\")\n        inst.outbufs.append(buffer)\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n        self.assertEqual(buffer.skipped, 3)\n        self.assertEqual(inst.outbufs, [buffer])\n\n    def test_flush_some_multiple_buffers_close_raises(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: len(x)\n        buffer = DummyBuffer(b\"abc\")\n        inst.outbufs.append(buffer)\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        inst.logger = DummyLogger()\n\n        def doraise():\n            raise NotImplementedError\n\n        inst.outbufs[0].close = doraise\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n        self.assertEqual(buffer.skipped, 3)\n        self.assertEqual(inst.outbufs, [buffer])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test__flush_some_outbuf_len_gt_sys_maxint(self):\n        from waitress.compat import MAXINT\n\n        inst, sock, map = self._makeOneWithMap()\n\n        class DummyHugeOutbuffer(object):\n            def __init__(self):\n                self.length = MAXINT + 1\n\n            def __len__(self):\n                return self.length\n\n            def get(self, numbytes):\n                self.length = 0\n                return b\"123\"\n\n        buf = DummyHugeOutbuffer()\n        inst.outbufs = [buf]\n        inst.send = lambda *arg: 0\n        result = inst._flush_some()\n        # we are testing that _flush_some doesn't raise an OverflowError\n        # when one of its outbufs has a __len__ that returns gt sys.maxint\n        self.assertEqual(result, False)\n\n    def test_handle_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.handle_close()\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n\n    def test_handle_close_outbuf_raises_on_close(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        def doraise():\n            raise NotImplementedError\n\n        inst.outbufs[0].close = doraise\n        inst.logger = DummyLogger()\n        inst.handle_close()\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test_add_channel(self):\n        inst, sock, map = self._makeOneWithMap()\n        fileno = inst._fileno\n        inst.add_channel(map)\n        self.assertEqual(map[fileno], inst)\n        self.assertEqual(inst.server.active_channels[fileno], inst)\n\n    def test_del_channel(self):\n        inst, sock, map = self._makeOneWithMap()\n        fileno = inst._fileno\n        inst.server.active_channels[fileno] = True\n        inst.del_channel(map)\n        self.assertEqual(map.get(fileno), None)\n        self.assertEqual(inst.server.active_channels.get(fileno), None)\n\n    def test_received(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n        self.assertEqual(inst.server.tasks, [inst])\n        self.assertTrue(inst.requests)\n\n    def test_received_no_chunk(self):\n        inst, sock, map = self._makeOneWithMap()\n        self.assertEqual(inst.received(b\"\"), False)\n\n    def test_received_preq_not_completed(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = False\n        preq.empty = True\n        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n        self.assertEqual(inst.requests, ())\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_preq_completed_empty(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.empty = True\n        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n        self.assertEqual(inst.request, None)\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_preq_error(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.error = True\n        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n        self.assertEqual(inst.request, None)\n        self.assertEqual(len(inst.server.tasks), 1)\n        self.assertTrue(inst.requests)\n\n    def test_received_preq_completed_connection_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.empty = True\n        preq.connection_close = True\n        inst.received(b\"GET / HTTP/1.1\\n\\n\" + b\"a\" * 50000)\n        self.assertEqual(inst.request, None)\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_preq_completed_n_lt_data(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.empty = False\n        line = b\"GET / HTTP/1.1\\n\\n\"\n        preq.retval = len(line)\n        inst.received(line + line)\n        self.assertEqual(inst.request, None)\n        self.assertEqual(len(inst.requests), 2)\n        self.assertEqual(len(inst.server.tasks), 1)\n\n    def test_received_headers_finished_expect_continue_false(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = False\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        preq.retval = 1\n        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(inst.outbufs[0].get(100), b\"\")\n\n    def test_received_headers_finished_expect_continue_true(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = True\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(sock.sent, b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n        self.assertEqual(inst.sent_continue, True)\n        self.assertEqual(preq.completed, False)\n\n    def test_received_headers_finished_expect_continue_true_sent_true(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = True\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        inst.sent_continue = True\n        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(inst.sent_continue, True)\n        self.assertEqual(preq.completed, False)\n\n    def test_service_no_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n\n    def test_service_with_one_request(self):\n        inst, sock, map = self._makeOneWithMap()\n        request = DummyRequest()\n        inst.task_class = DummyTaskClass()\n        inst.requests = [request]\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request.serviced)\n        self.assertTrue(request.closed)\n\n    def test_service_with_one_error_request(self):\n        inst, sock, map = self._makeOneWithMap()\n        request = DummyRequest()\n        request.error = DummyError()\n        inst.error_task_class = DummyTaskClass()\n        inst.requests = [request]\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request.serviced)\n        self.assertTrue(request.closed)\n\n    def test_service_with_multiple_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        request1 = DummyRequest()\n        request2 = DummyRequest()\n        inst.task_class = DummyTaskClass()\n        inst.requests = [request1, request2]\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request1.serviced)\n        self.assertTrue(request2.serviced)\n        self.assertTrue(request1.closed)\n        self.assertTrue(request2.closed)\n\n    def test_service_with_request_raises(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_already_wrote_header(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertTrue(inst.close_when_flushed)\n        self.assertEqual(inst.error_task_class.serviced, False)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_didnt_write_header_expose_tbs(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = True\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_didnt_write_header(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertTrue(inst.close_when_flushed)\n        self.assertTrue(request.closed)\n\n    def test_service_with_request_raises_disconnect(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ClientDisconnected)\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.infos), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.error_task_class.serviced, False)\n        self.assertTrue(request.closed)\n\n    def test_service_with_request_error_raises_disconnect(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        err_request = DummyRequest()\n        inst.requests = [request]\n        inst.parser_class = lambda x: err_request\n        inst.task_class = DummyTaskClass(RuntimeError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass(ClientDisconnected)\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertTrue(err_request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertEqual(len(inst.logger.infos), 0)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.task_class.serviced, True)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_cancel_no_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = ()\n        inst.cancel()\n        self.assertEqual(inst.requests, [])\n\n    def test_cancel_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [None]\n        inst.cancel()\n        self.assertEqual(inst.requests, [])\n\n\nclass DummySock(object):\n    blocking = False\n    closed = False\n\n    def __init__(self):\n        self.sent = b\"\"\n\n    def setblocking(self, *arg):\n        self.blocking = True\n\n    def fileno(self):\n        return 100\n\n    def getpeername(self):\n        return \"127.0.0.1\"\n\n    def getsockopt(self, level, option):\n        return 2048\n\n    def close(self):\n        self.closed = True\n\n    def send(self, data):\n        self.sent += data\n        return len(data)\n\n\nclass DummyLock(object):\n    notified = False\n\n    def __init__(self, acquirable=True):\n        self.acquirable = acquirable\n\n    def acquire(self, val):\n        self.val = val\n        self.acquired = True\n        return self.acquirable\n\n    def release(self):\n        self.released = True\n\n    def notify(self):\n        self.notified = True\n\n    def wait(self):\n        self.waited = True\n\n    def __exit__(self, type, val, traceback):\n        self.acquire(True)\n\n    def __enter__(self):\n        pass\n\n\nclass DummyBuffer(object):\n    closed = False\n\n    def __init__(self, data, toraise=None):\n        self.data = data\n        self.toraise = toraise\n\n    def get(self, *arg):\n        if self.toraise:\n            raise self.toraise\n        data = self.data\n        self.data = b\"\"\n        return data\n\n    def skip(self, num, x):\n        self.skipped = num\n\n    def __len__(self):\n        return len(self.data)\n\n    def close(self):\n        self.closed = True\n\n\nclass DummyAdjustments(object):\n    outbuf_overflow = 1048576\n    outbuf_high_watermark = 1048576\n    inbuf_overflow = 512000\n    cleanup_interval = 900\n    url_scheme = \"http\"\n    channel_timeout = 300\n    log_socket_errors = True\n    recv_bytes = 8192\n    send_bytes = 1\n    expose_tracebacks = True\n    ident = \"waitress\"\n    max_request_header_size = 10000\n\n\nclass DummyServer(object):\n    trigger_pulled = False\n    adj = DummyAdjustments()\n\n    def __init__(self):\n        self.tasks = []\n        self.active_channels = {}\n\n    def add_task(self, task):\n        self.tasks.append(task)\n\n    def pull_trigger(self):\n        self.trigger_pulled = True\n\n\nclass DummyParser(object):\n    version = 1\n    data = None\n    completed = True\n    empty = False\n    headers_finished = False\n    expect_continue = False\n    retval = None\n    error = None\n    connection_close = False\n\n    def received(self, data):\n        self.data = data\n        if self.retval is not None:\n            return self.retval\n        return len(data)\n\n\nclass DummyRequest(object):\n    error = None\n    path = \"/\"\n    version = \"1.0\"\n    closed = False\n\n    def __init__(self):\n        self.headers = {}\n\n    def close(self):\n        self.closed = True\n\n\nclass DummyLogger(object):\n    def __init__(self):\n        self.exceptions = []\n        self.infos = []\n        self.warnings = []\n\n    def info(self, msg):\n        self.infos.append(msg)\n\n    def exception(self, msg):\n        self.exceptions.append(msg)\n\n\nclass DummyError(object):\n    code = \"431\"\n    reason = \"Bleh\"\n    body = \"My body\"\n\n\nclass DummyTaskClass(object):\n    wrote_header = True\n    close_on_finish = False\n    serviced = False\n\n    def __init__(self, toraise=None):\n        self.toraise = toraise\n\n    def __call__(self, channel, request):\n        self.request = request\n        return self\n\n    def service(self):\n        self.serviced = True\n        self.request.serviced = True\n        if self.toraise:\n            raise self.toraise\n", "import errno\nimport logging\nimport multiprocessing\nimport os\nimport signal\nimport socket\nimport string\nimport subprocess\nimport sys\nimport time\nimport unittest\nfrom waitress import server\nfrom waitress.compat import httplib, tobytes\nfrom waitress.utilities import cleanup_unix_socket\n\ndn = os.path.dirname\nhere = dn(__file__)\n\n\nclass NullHandler(logging.Handler):  # pragma: no cover\n    \"\"\"A logging handler that swallows all emitted messages.\n    \"\"\"\n\n    def emit(self, record):\n        pass\n\n\ndef start_server(app, svr, queue, **kwargs):  # pragma: no cover\n    \"\"\"Run a fixture application.\n    \"\"\"\n    logging.getLogger(\"waitress\").addHandler(NullHandler())\n    try_register_coverage()\n    svr(app, queue, **kwargs).run()\n\n\ndef try_register_coverage():  # pragma: no cover\n    # Hack around multiprocessing exiting early and not triggering coverage's\n    # atexit handler by always registering a signal handler\n\n    if \"COVERAGE_PROCESS_START\" in os.environ:\n        def sigterm(*args):\n            sys.exit(0)\n\n        signal.signal(signal.SIGTERM, sigterm)\n\n\nclass FixtureTcpWSGIServer(server.TcpWSGIServer):\n    \"\"\"A version of TcpWSGIServer that relays back what it's bound to.\n    \"\"\"\n\n    family = socket.AF_INET  # Testing\n\n    def __init__(self, application, queue, **kw):  # pragma: no cover\n        # Coverage doesn't see this as it's ran in a separate process.\n        kw[\"port\"] = 0  # Bind to any available port.\n        super(FixtureTcpWSGIServer, self).__init__(application, **kw)\n        host, port = self.socket.getsockname()\n        if os.name == \"nt\":\n            host = \"127.0.0.1\"\n        queue.put((host, port))\n\n\nclass SubprocessTests(object):\n\n    # For nose: all tests may be ran in separate processes.\n    _multiprocess_can_split_ = True\n\n    exe = sys.executable\n\n    server = None\n\n    def start_subprocess(self, target, **kw):\n        # Spawn a server process.\n        self.queue = multiprocessing.Queue()\n\n        if \"COVERAGE_RCFILE\" in os.environ:\n            os.environ[\"COVERAGE_PROCESS_START\"] = os.environ[\"COVERAGE_RCFILE\"]\n\n        self.proc = multiprocessing.Process(\n            target=start_server, args=(target, self.server, self.queue), kwargs=kw,\n        )\n        self.proc.start()\n\n        if self.proc.exitcode is not None:  # pragma: no cover\n            raise RuntimeError(\"%s didn't start\" % str(target))\n        # Get the socket the server is listening on.\n        self.bound_to = self.queue.get(timeout=5)\n        self.sock = self.create_socket()\n\n    def stop_subprocess(self):\n        if self.proc.exitcode is None:\n            self.proc.terminate()\n        self.sock.close()\n        # This give us one FD back ...\n        self.queue.close()\n        self.proc.join()\n\n    def assertline(self, line, status, reason, version):\n        v, s, r = (x.strip() for x in line.split(None, 2))\n        self.assertEqual(s, tobytes(status))\n        self.assertEqual(r, tobytes(reason))\n        self.assertEqual(v, tobytes(version))\n\n    def create_socket(self):\n        return socket.socket(self.server.family, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.sock.connect(self.bound_to)\n\n    def make_http_connection(self):\n        raise NotImplementedError  # pragma: no cover\n\n    def send_check_error(self, to_send):\n        self.sock.send(to_send)\n\n\nclass TcpTests(SubprocessTests):\n\n    server = FixtureTcpWSGIServer\n\n    def make_http_connection(self):\n        return httplib.HTTPConnection(*self.bound_to)\n\n\nclass SleepyThreadTests(TcpTests, unittest.TestCase):\n    # test that sleepy thread doesnt block other requests\n\n    def setUp(self):\n        from waitress.tests.fixtureapps import sleepy\n\n        self.start_subprocess(sleepy.app)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_it(self):\n        getline = os.path.join(here, \"fixtureapps\", \"getline.py\")\n        cmds = (\n            [self.exe, getline, \"http://%s:%d/sleepy\" % self.bound_to],\n            [self.exe, getline, \"http://%s:%d/\" % self.bound_to],\n        )\n        r, w = os.pipe()\n        procs = []\n        for cmd in cmds:\n            procs.append(subprocess.Popen(cmd, stdout=w))\n        time.sleep(3)\n        for proc in procs:\n            if proc.returncode is not None:  # pragma: no cover\n                proc.terminate()\n            proc.wait()\n        # the notsleepy response should always be first returned (it sleeps\n        # for 2 seconds, then returns; the notsleepy response should be\n        # processed in the meantime)\n        result = os.read(r, 10000)\n        os.close(r)\n        os.close(w)\n        self.assertEqual(result, b\"notsleepy returnedsleepy returned\")\n\n\nclass EchoTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import echo\n\n        self.start_subprocess(\n            echo.app,\n            trusted_proxy=\"*\",\n            trusted_proxy_count=1,\n            trusted_proxy_headers={\"x-forwarded-for\", \"x-forwarded-proto\"},\n            clear_untrusted_proxy_headers=True,\n        )\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def _read_echo(self, fp):\n        from waitress.tests.fixtureapps import echo\n\n        line, headers, body = read_http(fp)\n        return line, headers, echo.parse_response(body)\n\n    def test_date_and_server(self):\n        to_send = \"GET / HTTP/1.0\\n\" \"Content-Length: 0\\n\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(headers.get(\"server\"), \"waitress\")\n        self.assertTrue(headers.get(\"date\"))\n\n    def test_bad_host_header(self):\n        # https://corte.si/posts/code/pathod/pythonservers/index.html\n        to_send = \"GET / HTTP/1.0\\n\" \" Host: 0\\n\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"400\", \"Bad Request\", \"HTTP/1.0\")\n        self.assertEqual(headers.get(\"server\"), \"waitress\")\n        self.assertTrue(headers.get(\"date\"))\n\n    def test_send_with_body(self):\n        to_send = \"GET / HTTP/1.0\\n\" \"Content-Length: 5\\n\\n\"\n        to_send += \"hello\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(echo.content_length, \"5\")\n        self.assertEqual(echo.body, b\"hello\")\n\n    def test_send_empty_body(self):\n        to_send = \"GET / HTTP/1.0\\n\" \"Content-Length: 0\\n\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(echo.content_length, \"0\")\n        self.assertEqual(echo.body, b\"\")\n\n    def test_multiple_requests_with_body(self):\n        orig_sock = self.sock\n        for x in range(3):\n            self.sock = self.create_socket()\n            self.test_send_with_body()\n            self.sock.close()\n        self.sock = orig_sock\n\n    def test_multiple_requests_without_body(self):\n        orig_sock = self.sock\n        for x in range(3):\n            self.sock = self.create_socket()\n            self.test_send_empty_body()\n            self.sock.close()\n        self.sock = orig_sock\n\n    def test_without_crlf(self):\n        data = \"Echo\\nthis\\r\\nplease\"\n        s = tobytes(\n            \"GET / HTTP/1.0\\n\"\n            \"Connection: close\\n\"\n            \"Content-Length: %d\\n\"\n            \"\\n\"\n            \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(int(echo.content_length), len(data))\n        self.assertEqual(len(echo.body), len(data))\n        self.assertEqual(echo.body, tobytes(data))\n\n    def test_large_body(self):\n        # 1024 characters.\n        body = \"This string has 32 characters.\\r\\n\" * 32\n        s = tobytes(\n            \"GET / HTTP/1.0\\n\" \"Content-Length: %d\\n\" \"\\n\" \"%s\" % (len(body), body)\n        )\n        self.connect()\n        self.sock.send(s)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(echo.content_length, \"1024\")\n        self.assertEqual(echo.body, tobytes(body))\n\n    def test_many_clients(self):\n        conns = []\n        for n in range(50):\n            h = self.make_http_connection()\n            h.request(\"GET\", \"/\", headers={\"Accept\": \"text/plain\"})\n            conns.append(h)\n        responses = []\n        for h in conns:\n            response = h.getresponse()\n            self.assertEqual(response.status, 200)\n            responses.append(response)\n        for response in responses:\n            response.read()\n        for h in conns:\n            h.close()\n\n    def test_chunking_request_without_content(self):\n        header = tobytes(\"GET / HTTP/1.1\\n\" \"Transfer-Encoding: chunked\\n\\n\")\n        self.connect()\n        self.sock.send(header)\n        self.sock.send(b\"0\\r\\n\\r\\n\")\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        self.assertEqual(echo.body, b\"\")\n        self.assertEqual(echo.content_length, \"0\")\n        self.assertFalse(\"transfer-encoding\" in headers)\n\n    def test_chunking_request_with_content(self):\n        control_line = b\"20;\\r\\n\"  # 20 hex = 32 dec\n        s = b\"This string has 32 characters.\\r\\n\"\n        expected = s * 12\n        header = tobytes(\"GET / HTTP/1.1\\n\" \"Transfer-Encoding: chunked\\n\\n\")\n        self.connect()\n        self.sock.send(header)\n        fp = self.sock.makefile(\"rb\", 0)\n        for n in range(12):\n            self.sock.send(control_line)\n            self.sock.send(s)\n        self.sock.send(b\"0\\r\\n\\r\\n\")\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        self.assertEqual(echo.body, expected)\n        self.assertEqual(echo.content_length, str(len(expected)))\n        self.assertFalse(\"transfer-encoding\" in headers)\n\n    def test_broken_chunked_encoding(self):\n        control_line = \"20;\\r\\n\"  # 20 hex = 32 dec\n        s = \"This string has 32 characters.\\r\\n\"\n        to_send = \"GET / HTTP/1.1\\nTransfer-Encoding: chunked\\n\\n\"\n        to_send += control_line + s\n        # garbage in input\n        to_send += \"GET / HTTP/1.1\\nTransfer-Encoding: chunked\\n\\n\"\n        to_send += control_line + s\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # receiver caught garbage and turned it into a 400\n        self.assertline(line, \"400\", \"Bad Request\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertEqual(\n            sorted(headers.keys()), [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"]\n        )\n        self.assertEqual(headers[\"content-type\"], \"text/plain\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_keepalive_http_10(self):\n        # Handling of Keep-Alive within HTTP 1.0\n        data = \"Default: Don't keep me alive\"\n        s = tobytes(\n            \"GET / HTTP/1.0\\n\" \"Content-Length: %d\\n\" \"\\n\" \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        response = httplib.HTTPResponse(self.sock)\n        response.begin()\n        self.assertEqual(int(response.status), 200)\n        connection = response.getheader(\"Connection\", \"\")\n        # We sent no Connection: Keep-Alive header\n        # Connection: close (or no header) is default.\n        self.assertTrue(connection != \"Keep-Alive\")\n\n    def test_keepalive_http10_explicit(self):\n        # If header Connection: Keep-Alive is explicitly sent,\n        # we want to keept the connection open, we also need to return\n        # the corresponding header\n        data = \"Keep me alive\"\n        s = tobytes(\n            \"GET / HTTP/1.0\\n\"\n            \"Connection: Keep-Alive\\n\"\n            \"Content-Length: %d\\n\"\n            \"\\n\"\n            \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        response = httplib.HTTPResponse(self.sock)\n        response.begin()\n        self.assertEqual(int(response.status), 200)\n        connection = response.getheader(\"Connection\", \"\")\n        self.assertEqual(connection, \"Keep-Alive\")\n\n    def test_keepalive_http_11(self):\n        # Handling of Keep-Alive within HTTP 1.1\n\n        # All connections are kept alive, unless stated otherwise\n        data = \"Default: Keep me alive\"\n        s = tobytes(\n            \"GET / HTTP/1.1\\n\" \"Content-Length: %d\\n\" \"\\n\" \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        response = httplib.HTTPResponse(self.sock)\n        response.begin()\n        self.assertEqual(int(response.status), 200)\n        self.assertTrue(response.getheader(\"connection\") != \"close\")\n\n    def test_keepalive_http11_explicit(self):\n        # Explicitly set keep-alive\n        data = \"Default: Keep me alive\"\n        s = tobytes(\n            \"GET / HTTP/1.1\\n\"\n            \"Connection: keep-alive\\n\"\n            \"Content-Length: %d\\n\"\n            \"\\n\"\n            \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        response = httplib.HTTPResponse(self.sock)\n        response.begin()\n        self.assertEqual(int(response.status), 200)\n        self.assertTrue(response.getheader(\"connection\") != \"close\")\n\n    def test_keepalive_http11_connclose(self):\n        # specifying Connection: close explicitly\n        data = \"Don't keep me alive\"\n        s = tobytes(\n            \"GET / HTTP/1.1\\n\"\n            \"Connection: close\\n\"\n            \"Content-Length: %d\\n\"\n            \"\\n\"\n            \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        response = httplib.HTTPResponse(self.sock)\n        response.begin()\n        self.assertEqual(int(response.status), 200)\n        self.assertEqual(response.getheader(\"connection\"), \"close\")\n\n    def test_proxy_headers(self):\n        to_send = (\n            \"GET / HTTP/1.0\\n\"\n            \"Content-Length: 0\\n\"\n            \"Host: www.google.com:8080\\n\"\n            \"X-Forwarded-For: 192.168.1.1\\n\"\n            \"X-Forwarded-Proto: https\\n\"\n            \"X-Forwarded-Port: 5000\\n\\n\"\n        )\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(headers.get(\"server\"), \"waitress\")\n        self.assertTrue(headers.get(\"date\"))\n        self.assertIsNone(echo.headers.get(\"X_FORWARDED_PORT\"))\n        self.assertEqual(echo.headers[\"HOST\"], \"www.google.com:8080\")\n        self.assertEqual(echo.scheme, \"https\")\n        self.assertEqual(echo.remote_addr, \"192.168.1.1\")\n        self.assertEqual(echo.remote_host, \"192.168.1.1\")\n\n\nclass PipeliningTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import echo\n\n        self.start_subprocess(echo.app_body_only)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_pipelining(self):\n        s = (\n            \"GET / HTTP/1.0\\r\\n\"\n            \"Connection: %s\\r\\n\"\n            \"Content-Length: %d\\r\\n\"\n            \"\\r\\n\"\n            \"%s\"\n        )\n        to_send = b\"\"\n        count = 25\n        for n in range(count):\n            body = \"Response #%d\\r\\n\" % (n + 1)\n            if n + 1 < count:\n                conn = \"keep-alive\"\n            else:\n                conn = \"close\"\n            to_send += tobytes(s % (conn, len(body), body))\n\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        for n in range(count):\n            expect_body = tobytes(\"Response #%d\\r\\n\" % (n + 1))\n            line = fp.readline()  # status line\n            version, status, reason = (x.strip() for x in line.split(None, 2))\n            headers = parse_headers(fp)\n            length = int(headers.get(\"content-length\")) or None\n            response_body = fp.read(length)\n            self.assertEqual(int(status), 200)\n            self.assertEqual(length, len(response_body))\n            self.assertEqual(response_body, expect_body)\n\n\nclass ExpectContinueTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import echo\n\n        self.start_subprocess(echo.app_body_only)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_expect_continue(self):\n        # specifying Connection: close explicitly\n        data = \"I have expectations\"\n        to_send = tobytes(\n            \"GET / HTTP/1.1\\n\"\n            \"Connection: close\\n\"\n            \"Content-Length: %d\\n\"\n            \"Expect: 100-continue\\n\"\n            \"\\n\"\n            \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line = fp.readline()  # continue status line\n        version, status, reason = (x.strip() for x in line.split(None, 2))\n        self.assertEqual(int(status), 100)\n        self.assertEqual(reason, b\"Continue\")\n        self.assertEqual(version, b\"HTTP/1.1\")\n        fp.readline()  # blank line\n        line = fp.readline()  # next status line\n        version, status, reason = (x.strip() for x in line.split(None, 2))\n        headers = parse_headers(fp)\n        length = int(headers.get(\"content-length\")) or None\n        response_body = fp.read(length)\n        self.assertEqual(int(status), 200)\n        self.assertEqual(length, len(response_body))\n        self.assertEqual(response_body, tobytes(data))\n\n\nclass BadContentLengthTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import badcl\n\n        self.start_subprocess(badcl.app)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_short_body(self):\n        # check to see if server closes connection when body is too short\n        # for cl header\n        to_send = tobytes(\n            \"GET /short_body HTTP/1.0\\n\"\n            \"Connection: Keep-Alive\\n\"\n            \"Content-Length: 0\\n\"\n            \"\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line = fp.readline()  # status line\n        version, status, reason = (x.strip() for x in line.split(None, 2))\n        headers = parse_headers(fp)\n        content_length = int(headers.get(\"content-length\"))\n        response_body = fp.read(content_length)\n        self.assertEqual(int(status), 200)\n        self.assertNotEqual(content_length, len(response_body))\n        self.assertEqual(len(response_body), content_length - 1)\n        self.assertEqual(response_body, tobytes(\"abcdefghi\"))\n        # remote closed connection (despite keepalive header); not sure why\n        # first send succeeds\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_long_body(self):\n        # check server doesnt close connection when body is too short\n        # for cl header\n        to_send = tobytes(\n            \"GET /long_body HTTP/1.0\\n\"\n            \"Connection: Keep-Alive\\n\"\n            \"Content-Length: 0\\n\"\n            \"\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line = fp.readline()  # status line\n        version, status, reason = (x.strip() for x in line.split(None, 2))\n        headers = parse_headers(fp)\n        content_length = int(headers.get(\"content-length\")) or None\n        response_body = fp.read(content_length)\n        self.assertEqual(int(status), 200)\n        self.assertEqual(content_length, len(response_body))\n        self.assertEqual(response_body, tobytes(\"abcdefgh\"))\n        # remote does not close connection (keepalive header)\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line = fp.readline()  # status line\n        version, status, reason = (x.strip() for x in line.split(None, 2))\n        headers = parse_headers(fp)\n        content_length = int(headers.get(\"content-length\")) or None\n        response_body = fp.read(content_length)\n        self.assertEqual(int(status), 200)\n\n\nclass NoContentLengthTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import nocl\n\n        self.start_subprocess(nocl.app)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_http10_generator(self):\n        body = string.ascii_letters\n        to_send = (\n            \"GET / HTTP/1.0\\n\"\n            \"Connection: Keep-Alive\\n\"\n            \"Content-Length: %d\\n\\n\" % len(body)\n        )\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(headers.get(\"content-length\"), None)\n        self.assertEqual(headers.get(\"connection\"), \"close\")\n        self.assertEqual(response_body, tobytes(body))\n        # remote closed connection (despite keepalive header), because\n        # generators cannot have a content-length divined\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_http10_list(self):\n        body = string.ascii_letters\n        to_send = (\n            \"GET /list HTTP/1.0\\n\"\n            \"Connection: Keep-Alive\\n\"\n            \"Content-Length: %d\\n\\n\" % len(body)\n        )\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(headers[\"content-length\"], str(len(body)))\n        self.assertEqual(headers.get(\"connection\"), \"Keep-Alive\")\n        self.assertEqual(response_body, tobytes(body))\n        # remote keeps connection open because it divined the content length\n        # from a length-1 list\n        self.sock.send(to_send)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n\n    def test_http10_listlentwo(self):\n        body = string.ascii_letters\n        to_send = (\n            \"GET /list_lentwo HTTP/1.0\\n\"\n            \"Connection: Keep-Alive\\n\"\n            \"Content-Length: %d\\n\\n\" % len(body)\n        )\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(headers.get(\"content-length\"), None)\n        self.assertEqual(headers.get(\"connection\"), \"close\")\n        self.assertEqual(response_body, tobytes(body))\n        # remote closed connection (despite keepalive header), because\n        # lists of length > 1 cannot have their content length divined\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_http11_generator(self):\n        body = string.ascii_letters\n        to_send = \"GET / HTTP/1.1\\n\" \"Content-Length: %s\\n\\n\" % len(body)\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        expected = b\"\"\n        for chunk in chunks(body, 10):\n            expected += tobytes(\n                \"%s\\r\\n%s\\r\\n\" % (str(hex(len(chunk))[2:].upper()), chunk)\n            )\n        expected += b\"0\\r\\n\\r\\n\"\n        self.assertEqual(response_body, expected)\n        # connection is always closed at the end of a chunked response\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_http11_list(self):\n        body = string.ascii_letters\n        to_send = \"GET /list HTTP/1.1\\n\" \"Content-Length: %d\\n\\n\" % len(body)\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        self.assertEqual(headers[\"content-length\"], str(len(body)))\n        self.assertEqual(response_body, tobytes(body))\n        # remote keeps connection open because it divined the content length\n        # from a length-1 list\n        self.sock.send(to_send)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n\n    def test_http11_listlentwo(self):\n        body = string.ascii_letters\n        to_send = \"GET /list_lentwo HTTP/1.1\\n\" \"Content-Length: %s\\n\\n\" % len(body)\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        expected = b\"\"\n        for chunk in (body[0], body[1:]):\n            expected += tobytes(\n                \"%s\\r\\n%s\\r\\n\" % (str(hex(len(chunk))[2:].upper()), chunk)\n            )\n        expected += b\"0\\r\\n\\r\\n\"\n        self.assertEqual(response_body, expected)\n        # connection is always closed at the end of a chunked response\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n\nclass WriteCallbackTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import writecb\n\n        self.start_subprocess(writecb.app)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_short_body(self):\n        # check to see if server closes connection when body is too short\n        # for cl header\n        to_send = tobytes(\n            \"GET /short_body HTTP/1.0\\n\"\n            \"Connection: Keep-Alive\\n\"\n            \"Content-Length: 0\\n\"\n            \"\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # server trusts the content-length header (5)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, 9)\n        self.assertNotEqual(cl, len(response_body))\n        self.assertEqual(len(response_body), cl - 1)\n        self.assertEqual(response_body, tobytes(\"abcdefgh\"))\n        # remote closed connection (despite keepalive header)\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_long_body(self):\n        # check server doesnt close connection when body is too long\n        # for cl header\n        to_send = tobytes(\n            \"GET /long_body HTTP/1.0\\n\"\n            \"Connection: Keep-Alive\\n\"\n            \"Content-Length: 0\\n\"\n            \"\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        content_length = int(headers.get(\"content-length\")) or None\n        self.assertEqual(content_length, 9)\n        self.assertEqual(content_length, len(response_body))\n        self.assertEqual(response_body, tobytes(\"abcdefghi\"))\n        # remote does not close connection (keepalive header)\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n\n    def test_equal_body(self):\n        # check server doesnt close connection when body is equal to\n        # cl header\n        to_send = tobytes(\n            \"GET /equal_body HTTP/1.0\\n\"\n            \"Connection: Keep-Alive\\n\"\n            \"Content-Length: 0\\n\"\n            \"\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        content_length = int(headers.get(\"content-length\")) or None\n        self.assertEqual(content_length, 9)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(content_length, len(response_body))\n        self.assertEqual(response_body, tobytes(\"abcdefghi\"))\n        # remote does not close connection (keepalive header)\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n\n    def test_no_content_length(self):\n        # wtf happens when there's no content-length\n        to_send = tobytes(\n            \"GET /no_content_length HTTP/1.0\\n\"\n            \"Connection: Keep-Alive\\n\"\n            \"Content-Length: 0\\n\"\n            \"\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line = fp.readline()  # status line\n        line, headers, response_body = read_http(fp)\n        content_length = headers.get(\"content-length\")\n        self.assertEqual(content_length, None)\n        self.assertEqual(response_body, tobytes(\"abcdefghi\"))\n        # remote closed connection (despite keepalive header)\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n\nclass TooLargeTests(object):\n\n    toobig = 1050\n\n    def setUp(self):\n        from waitress.tests.fixtureapps import toolarge\n\n        self.start_subprocess(\n            toolarge.app, max_request_header_size=1000, max_request_body_size=1000\n        )\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_request_body_too_large_with_wrong_cl_http10(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.0\\n\" \"Content-Length: 5\\n\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        # first request succeeds (content-length 5)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # server trusts the content-length header; no pipelining,\n        # so request fulfilled, extra bytes are thrown away\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_wrong_cl_http10_keepalive(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.0\\n\" \"Content-Length: 5\\n\" \"Connection: Keep-Alive\\n\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        # first request succeeds (content-length 5)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"431\", \"Request Header Fields Too Large\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_no_cl_http10(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.0\\n\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # extra bytes are thrown away (no pipelining), connection closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_no_cl_http10_keepalive(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.0\\nConnection: Keep-Alive\\n\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # server trusts the content-length header (assumed zero)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        line, headers, response_body = read_http(fp)\n        # next response overruns because the extra data appears to be\n        # header data\n        self.assertline(line, \"431\", \"Request Header Fields Too Large\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_wrong_cl_http11(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.1\\n\" \"Content-Length: 5\\n\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        # first request succeeds (content-length 5)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # second response is an error response\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"431\", \"Request Header Fields Too Large\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_wrong_cl_http11_connclose(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.1\\nContent-Length: 5\\nConnection: close\\n\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # server trusts the content-length header (5)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_no_cl_http11(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.1\\n\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        # server trusts the content-length header (assumed 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # server assumes pipelined requests due to http/1.1, and the first\n        # request was assumed c-l 0 because it had no content-length header,\n        # so entire body looks like the header of the subsequent request\n        # second response is an error response\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"431\", \"Request Header Fields Too Large\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_no_cl_http11_connclose(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.1\\nConnection: close\\n\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # server trusts the content-length header (assumed 0)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_chunked_encoding(self):\n        control_line = \"20;\\r\\n\"  # 20 hex = 32 dec\n        s = \"This string has 32 characters.\\r\\n\"\n        to_send = \"GET / HTTP/1.1\\nTransfer-Encoding: chunked\\n\\n\"\n        repeat = control_line + s\n        to_send += repeat * ((self.toobig // len(repeat)) + 1)\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # body bytes counter caught a max_request_body_size overrun\n        self.assertline(line, \"413\", \"Request Entity Too Large\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertEqual(headers[\"content-type\"], \"text/plain\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n\nclass InternalServerErrorTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import error\n\n        self.start_subprocess(error.app, expose_tracebacks=True)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_before_start_response_http_10(self):\n        to_send = \"GET /before_start_response HTTP/1.0\\n\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(headers[\"connection\"], \"close\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_before_start_response_http_11(self):\n        to_send = \"GET /before_start_response HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(\n            sorted(headers.keys()), [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"]\n        )\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_before_start_response_http_11_close(self):\n        to_send = tobytes(\n            \"GET /before_start_response HTTP/1.1\\n\" \"Connection: close\\n\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(\n            sorted(headers.keys()),\n            [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"],\n        )\n        self.assertEqual(headers[\"connection\"], \"close\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_after_start_response_http10(self):\n        to_send = \"GET /after_start_response HTTP/1.0\\n\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(\n            sorted(headers.keys()),\n            [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"],\n        )\n        self.assertEqual(headers[\"connection\"], \"close\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_after_start_response_http11(self):\n        to_send = \"GET /after_start_response HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(\n            sorted(headers.keys()), [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"]\n        )\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_after_start_response_http11_close(self):\n        to_send = tobytes(\n            \"GET /after_start_response HTTP/1.1\\n\" \"Connection: close\\n\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(\n            sorted(headers.keys()),\n            [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"],\n        )\n        self.assertEqual(headers[\"connection\"], \"close\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_after_write_cb(self):\n        to_send = \"GET /after_write_cb HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        self.assertEqual(response_body, b\"\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_in_generator(self):\n        to_send = \"GET /in_generator HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        self.assertEqual(response_body, b\"\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n\nclass FileWrapperTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import filewrapper\n\n        self.start_subprocess(filewrapper.app)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_filelike_http11(self):\n        to_send = \"GET /filelike HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\\330\\377\" in response_body)\n            # connection has not been closed\n\n    def test_filelike_nocl_http11(self):\n        to_send = \"GET /filelike_nocl HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\\330\\377\" in response_body)\n            # connection has not been closed\n\n    def test_filelike_shortcl_http11(self):\n        to_send = \"GET /filelike_shortcl HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, 1)\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\" in response_body)\n            # connection has not been closed\n\n    def test_filelike_longcl_http11(self):\n        to_send = \"GET /filelike_longcl HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\\330\\377\" in response_body)\n            # connection has not been closed\n\n    def test_notfilelike_http11(self):\n        to_send = \"GET /notfilelike HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\\330\\377\" in response_body)\n            # connection has not been closed\n\n    def test_notfilelike_iobase_http11(self):\n        to_send = \"GET /notfilelike_iobase HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\\330\\377\" in response_body)\n            # connection has not been closed\n\n    def test_notfilelike_nocl_http11(self):\n        to_send = \"GET /notfilelike_nocl HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed (no content-length)\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_notfilelike_shortcl_http11(self):\n        to_send = \"GET /notfilelike_shortcl HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, 1)\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\" in response_body)\n            # connection has not been closed\n\n    def test_notfilelike_longcl_http11(self):\n        to_send = \"GET /notfilelike_longcl HTTP/1.1\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body) + 10)\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_filelike_http10(self):\n        to_send = \"GET /filelike HTTP/1.0\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_filelike_nocl_http10(self):\n        to_send = \"GET /filelike_nocl HTTP/1.0\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_notfilelike_http10(self):\n        to_send = \"GET /notfilelike HTTP/1.0\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_notfilelike_nocl_http10(self):\n        to_send = \"GET /notfilelike_nocl HTTP/1.0\\n\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed (no content-length)\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n\nclass TcpEchoTests(EchoTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpPipeliningTests(PipeliningTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpExpectContinueTests(ExpectContinueTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpBadContentLengthTests(BadContentLengthTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpNoContentLengthTests(NoContentLengthTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpWriteCallbackTests(WriteCallbackTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpTooLargeTests(TooLargeTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpInternalServerErrorTests(\n    InternalServerErrorTests, TcpTests, unittest.TestCase\n):\n    pass\n\n\nclass TcpFileWrapperTests(FileWrapperTests, TcpTests, unittest.TestCase):\n    pass\n\n\nif hasattr(socket, \"AF_UNIX\"):\n\n    class FixtureUnixWSGIServer(server.UnixWSGIServer):\n        \"\"\"A version of UnixWSGIServer that relays back what it's bound to.\n        \"\"\"\n\n        family = socket.AF_UNIX  # Testing\n\n        def __init__(self, application, queue, **kw):  # pragma: no cover\n            # Coverage doesn't see this as it's ran in a separate process.\n            # To permit parallel testing, use a PID-dependent socket.\n            kw[\"unix_socket\"] = \"/tmp/waitress.test-%d.sock\" % os.getpid()\n            super(FixtureUnixWSGIServer, self).__init__(application, **kw)\n            queue.put(self.socket.getsockname())\n\n    class UnixTests(SubprocessTests):\n\n        server = FixtureUnixWSGIServer\n\n        def make_http_connection(self):\n            return UnixHTTPConnection(self.bound_to)\n\n        def stop_subprocess(self):\n            super(UnixTests, self).stop_subprocess()\n            cleanup_unix_socket(self.bound_to)\n\n        def send_check_error(self, to_send):\n            # Unlike inet domain sockets, Unix domain sockets can trigger a\n            # 'Broken pipe' error when the socket it closed.\n            try:\n                self.sock.send(to_send)\n            except socket.error as exc:\n                self.assertEqual(get_errno(exc), errno.EPIPE)\n\n    class UnixEchoTests(EchoTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixPipeliningTests(PipeliningTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixExpectContinueTests(ExpectContinueTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixBadContentLengthTests(\n        BadContentLengthTests, UnixTests, unittest.TestCase\n    ):\n        pass\n\n    class UnixNoContentLengthTests(NoContentLengthTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixWriteCallbackTests(WriteCallbackTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixTooLargeTests(TooLargeTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixInternalServerErrorTests(\n        InternalServerErrorTests, UnixTests, unittest.TestCase\n    ):\n        pass\n\n    class UnixFileWrapperTests(FileWrapperTests, UnixTests, unittest.TestCase):\n        pass\n\n\ndef parse_headers(fp):\n    \"\"\"Parses only RFC2822 headers from a file pointer.\n    \"\"\"\n    headers = {}\n    while True:\n        line = fp.readline()\n        if line in (b\"\\r\\n\", b\"\\n\", b\"\"):\n            break\n        line = line.decode(\"iso-8859-1\")\n        name, value = line.strip().split(\":\", 1)\n        headers[name.lower().strip()] = value.lower().strip()\n    return headers\n\n\nclass UnixHTTPConnection(httplib.HTTPConnection):\n    \"\"\"Patched version of HTTPConnection that uses Unix domain sockets.\n    \"\"\"\n\n    def __init__(self, path):\n        httplib.HTTPConnection.__init__(self, \"localhost\")\n        self.path = path\n\n    def connect(self):\n        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        sock.connect(self.path)\n        self.sock = sock\n\n\nclass ConnectionClosed(Exception):\n    pass\n\n\n# stolen from gevent\ndef read_http(fp):  # pragma: no cover\n    try:\n        response_line = fp.readline()\n    except socket.error as exc:\n        fp.close()\n        # errno 104 is ENOTRECOVERABLE, In WinSock 10054 is ECONNRESET\n        if get_errno(exc) in (errno.ECONNABORTED, errno.ECONNRESET, 104, 10054):\n            raise ConnectionClosed\n        raise\n    if not response_line:\n        raise ConnectionClosed\n\n    header_lines = []\n    while True:\n        line = fp.readline()\n        if line in (b\"\\r\\n\", b\"\\n\", b\"\"):\n            break\n        else:\n            header_lines.append(line)\n    headers = dict()\n    for x in header_lines:\n        x = x.strip()\n        if not x:\n            continue\n        key, value = x.split(b\": \", 1)\n        key = key.decode(\"iso-8859-1\").lower()\n        value = value.decode(\"iso-8859-1\")\n        assert key not in headers, \"%s header duplicated\" % key\n        headers[key] = value\n\n    if \"content-length\" in headers:\n        num = int(headers[\"content-length\"])\n        body = b\"\"\n        left = num\n        while left > 0:\n            data = fp.read(left)\n            if not data:\n                break\n            body += data\n            left -= len(data)\n    else:\n        # read until EOF\n        body = fp.read()\n\n    return response_line, headers, body\n\n\n# stolen from gevent\ndef get_errno(exc):  # pragma: no cover\n    \"\"\" Get the error code out of socket.error objects.\n    socket.error in <2.5 does not have errno attribute\n    socket.error in 3.x does not allow indexing access\n    e.args[0] works for all.\n    There are cases when args[0] is not errno.\n    i.e. http://bugs.python.org/issue6471\n    Maybe there are cases when errno is set, but it is not the first argument?\n    \"\"\"\n    try:\n        if exc.errno is not None:\n            return exc.errno\n    except AttributeError:\n        pass\n    try:\n        return exc.args[0]\n    except IndexError:\n        return None\n\n\ndef chunks(l, n):\n    \"\"\" Yield successive n-sized chunks from l.\n    \"\"\"\n    for i in range(0, len(l), n):\n        yield l[i : i + n]\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"HTTP Request Parser tests\n\"\"\"\nimport unittest\n\nfrom waitress.compat import (\n    text_,\n    tobytes,\n)\n\n\nclass TestHTTPRequestParser(unittest.TestCase):\n    def setUp(self):\n        from waitress.parser import HTTPRequestParser\n        from waitress.adjustments import Adjustments\n\n        my_adj = Adjustments()\n        self.parser = HTTPRequestParser(my_adj)\n\n    def test_get_body_stream_None(self):\n        self.parser.body_recv = None\n        result = self.parser.get_body_stream()\n        self.assertEqual(result.getvalue(), b\"\")\n\n    def test_get_body_stream_nonNone(self):\n        body_rcv = DummyBodyStream()\n        self.parser.body_rcv = body_rcv\n        result = self.parser.get_body_stream()\n        self.assertEqual(result, body_rcv)\n\n    def test_received_nonsense_with_double_cr(self):\n        data = b\"\"\"\\\nHTTP/1.0 GET /foobar\n\n\n\"\"\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 22)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_bad_host_header(self):\n        from waitress.utilities import BadRequest\n\n        data = b\"\"\"\\\nHTTP/1.0 GET /foobar\n Host: foo\n\n\n\"\"\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 33)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.error.__class__, BadRequest)\n\n    def test_received_nonsense_nothing(self):\n        data = b\"\"\"\\\n\n\n\"\"\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 2)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_no_doublecr(self):\n        data = b\"\"\"\\\nGET /foobar HTTP/8.4\n\"\"\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 21)\n        self.assertFalse(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_already_completed(self):\n        self.parser.completed = True\n        result = self.parser.received(b\"a\")\n        self.assertEqual(result, 0)\n\n    def test_received_cl_too_large(self):\n        from waitress.utilities import RequestEntityTooLarge\n\n        self.parser.adj.max_request_body_size = 2\n        data = b\"\"\"\\\nGET /foobar HTTP/8.4\nContent-Length: 10\n\n\"\"\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 41)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))\n\n    def test_received_headers_too_large(self):\n        from waitress.utilities import RequestHeaderFieldsTooLarge\n\n        self.parser.adj.max_request_header_size = 2\n        data = b\"\"\"\\\nGET /foobar HTTP/8.4\nX-Foo: 1\n\"\"\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 30)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestHeaderFieldsTooLarge))\n\n    def test_received_body_too_large(self):\n        from waitress.utilities import RequestEntityTooLarge\n\n        self.parser.adj.max_request_body_size = 2\n        data = b\"\"\"\\\nGET /foobar HTTP/1.1\nTransfer-Encoding: chunked\nX-Foo: 1\n\n20;\\r\\n\nThis string has 32 characters\\r\\n\n0\\r\\n\\r\\n\"\"\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 58)\n        self.parser.received(data[result:])\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))\n\n    def test_received_error_from_parser(self):\n        from waitress.utilities import BadRequest\n\n        data = b\"\"\"\\\nGET /foobar HTTP/1.1\nTransfer-Encoding: chunked\nX-Foo: 1\n\ngarbage\n\"\"\"\n        # header\n        result = self.parser.received(data)\n        # body\n        result = self.parser.received(data[result:])\n        self.assertEqual(result, 8)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, BadRequest))\n\n    def test_received_chunked_completed_sets_content_length(self):\n        data = b\"\"\"\\\nGET /foobar HTTP/1.1\nTransfer-Encoding: chunked\nX-Foo: 1\n\n20;\\r\\n\nThis string has 32 characters\\r\\n\n0\\r\\n\\r\\n\"\"\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 58)\n        data = data[result:]\n        result = self.parser.received(data)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(self.parser.error is None)\n        self.assertEqual(self.parser.headers[\"CONTENT_LENGTH\"], \"32\")\n\n    def test_parse_header_gardenpath(self):\n        data = b\"\"\"\\\nGET /foobar HTTP/8.4\nfoo: bar\"\"\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.first_line, b\"GET /foobar HTTP/8.4\")\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar\")\n\n    def test_parse_header_no_cr_in_headerplus(self):\n        data = b\"GET /foobar HTTP/8.4\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.first_line, data)\n\n    def test_parse_header_bad_content_length(self):\n        data = b\"GET /foobar HTTP/8.4\\ncontent-length: abc\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.body_rcv, None)\n\n    def test_parse_header_11_te_chunked(self):\n        # NB: test that capitalization of header value is unimportant\n        data = b\"GET /foobar HTTP/1.1\\ntransfer-encoding: ChUnKed\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.body_rcv.__class__.__name__, \"ChunkedReceiver\")\n\n    def test_parse_header_11_expect_continue(self):\n        data = b\"GET /foobar HTTP/1.1\\nexpect: 100-continue\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.expect_continue, True)\n\n    def test_parse_header_connection_close(self):\n        data = b\"GET /foobar HTTP/1.1\\nConnection: close\\n\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.connection_close, True)\n\n    def test_close_with_body_rcv(self):\n        body_rcv = DummyBodyStream()\n        self.parser.body_rcv = body_rcv\n        self.parser.close()\n        self.assertTrue(body_rcv.closed)\n\n    def test_close_with_no_body_rcv(self):\n        self.parser.body_rcv = None\n        self.parser.close()  # doesn't raise\n\n\nclass Test_split_uri(unittest.TestCase):\n    def _callFUT(self, uri):\n        from waitress.parser import split_uri\n\n        (\n            self.proxy_scheme,\n            self.proxy_netloc,\n            self.path,\n            self.query,\n            self.fragment,\n        ) = split_uri(uri)\n\n    def test_split_uri_unquoting_unneeded(self):\n        self._callFUT(b\"http://localhost:8080/abc def\")\n        self.assertEqual(self.path, \"/abc def\")\n\n    def test_split_uri_unquoting_needed(self):\n        self._callFUT(b\"http://localhost:8080/abc%20def\")\n        self.assertEqual(self.path, \"/abc def\")\n\n    def test_split_url_with_query(self):\n        self._callFUT(b\"http://localhost:8080/abc?a=1&b=2\")\n        self.assertEqual(self.path, \"/abc\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n\n    def test_split_url_with_query_empty(self):\n        self._callFUT(b\"http://localhost:8080/abc?\")\n        self.assertEqual(self.path, \"/abc\")\n        self.assertEqual(self.query, \"\")\n\n    def test_split_url_with_fragment(self):\n        self._callFUT(b\"http://localhost:8080/#foo\")\n        self.assertEqual(self.path, \"/\")\n        self.assertEqual(self.fragment, \"foo\")\n\n    def test_split_url_https(self):\n        self._callFUT(b\"https://localhost:8080/\")\n        self.assertEqual(self.path, \"/\")\n        self.assertEqual(self.proxy_scheme, \"https\")\n        self.assertEqual(self.proxy_netloc, \"localhost:8080\")\n\n    def test_split_uri_unicode_error_raises_parsing_error(self):\n        # See https://github.com/Pylons/waitress/issues/64\n        from waitress.parser import ParsingError\n\n        # Either pass or throw a ParsingError, just don't throw another type of\n        # exception as that will cause the connection to close badly:\n        try:\n            self._callFUT(b\"/\\xd0\")\n        except ParsingError:\n            pass\n\n    def test_split_uri_path(self):\n        self._callFUT(b\"//testing/whatever\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"\")\n        self.assertEqual(self.fragment, \"\")\n\n    def test_split_uri_path_query(self):\n        self._callFUT(b\"//testing/whatever?a=1&b=2\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n        self.assertEqual(self.fragment, \"\")\n\n    def test_split_uri_path_query_fragment(self):\n        self._callFUT(b\"//testing/whatever?a=1&b=2#fragment\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n        self.assertEqual(self.fragment, \"fragment\")\n\n\nclass Test_get_header_lines(unittest.TestCase):\n    def _callFUT(self, data):\n        from waitress.parser import get_header_lines\n\n        return get_header_lines(data)\n\n    def test_get_header_lines(self):\n        result = self._callFUT(b\"slam\\nslim\")\n        self.assertEqual(result, [b\"slam\", b\"slim\"])\n\n    def test_get_header_lines_folded(self):\n        # From RFC2616:\n        # HTTP/1.1 header field values can be folded onto multiple lines if the\n        # continuation line begins with a space or horizontal tab. All linear\n        # white space, including folding, has the same semantics as SP. A\n        # recipient MAY replace any linear white space with a single SP before\n        # interpreting the field value or forwarding the message downstream.\n\n        # We are just preserving the whitespace that indicates folding.\n        result = self._callFUT(b\"slim\\n slam\")\n        self.assertEqual(result, [b\"slim slam\"])\n\n    def test_get_header_lines_tabbed(self):\n        result = self._callFUT(b\"slam\\n\\tslim\")\n        self.assertEqual(result, [b\"slam\\tslim\"])\n\n    def test_get_header_lines_malformed(self):\n        # https://corte.si/posts/code/pathod/pythonservers/index.html\n        from waitress.parser import ParsingError\n\n        self.assertRaises(ParsingError, self._callFUT, b\" Host: localhost\\r\\n\\r\\n\")\n\n\nclass Test_crack_first_line(unittest.TestCase):\n    def _callFUT(self, line):\n        from waitress.parser import crack_first_line\n\n        return crack_first_line(line)\n\n    def test_crack_first_line_matchok(self):\n        result = self._callFUT(b\"GET / HTTP/1.0\")\n        self.assertEqual(result, (b\"GET\", b\"/\", b\"1.0\"))\n\n    def test_crack_first_line_lowercase_method(self):\n        from waitress.parser import ParsingError\n\n        self.assertRaises(ParsingError, self._callFUT, b\"get / HTTP/1.0\")\n\n    def test_crack_first_line_nomatch(self):\n        result = self._callFUT(b\"GET / bleh\")\n        self.assertEqual(result, (b\"\", b\"\", b\"\"))\n\n        result = self._callFUT(b\"GET /info?txtAirPlay&txtRAOP RTSP/1.0\")\n        self.assertEqual(result, (b\"\", b\"\", b\"\"))\n\n    def test_crack_first_line_missing_version(self):\n        result = self._callFUT(b\"GET /\")\n        self.assertEqual(result, (b\"GET\", b\"/\", b\"\"))\n\n\nclass TestHTTPRequestParserIntegration(unittest.TestCase):\n    def setUp(self):\n        from waitress.parser import HTTPRequestParser\n        from waitress.adjustments import Adjustments\n\n        my_adj = Adjustments()\n        self.parser = HTTPRequestParser(my_adj)\n\n    def feed(self, data):\n        parser = self.parser\n        for n in range(100):  # make sure we never loop forever\n            consumed = parser.received(data)\n            data = data[consumed:]\n            if parser.completed:\n                return\n        raise ValueError(\"Looping\")  # pragma: no cover\n\n    def testSimpleGET(self):\n        data = b\"\"\"\\\nGET /foobar HTTP/8.4\nFirstName: mickey\nlastname: Mouse\ncontent-length: 7\n\nHello.\n\"\"\"\n        parser = self.parser\n        self.feed(data)\n        self.assertTrue(parser.completed)\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(\n            parser.headers,\n            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"7\",},\n        )\n        self.assertEqual(parser.path, \"/foobar\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.query, \"\")\n        self.assertEqual(parser.proxy_scheme, \"\")\n        self.assertEqual(parser.proxy_netloc, \"\")\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\\n\")\n\n    def testComplexGET(self):\n        data = b\"\"\"\\\nGET /foo/a+%2B%2F%C3%A4%3D%26a%3Aint?d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6 HTTP/8.4\nFirstName: mickey\nlastname: Mouse\ncontent-length: 10\n\nHello mickey.\n\"\"\"\n        parser = self.parser\n        self.feed(data)\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(\n            parser.headers,\n            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"10\",},\n        )\n        # path should be utf-8 encoded\n        self.assertEqual(\n            tobytes(parser.path).decode(\"utf-8\"),\n            text_(b\"/foo/a++/\\xc3\\xa4=&a:int\", \"utf-8\"),\n        )\n        self.assertEqual(\n            parser.query, \"d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6\"\n        )\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello mick\")\n\n    def testProxyGET(self):\n        data = b\"\"\"\\\nGET https://example.com:8080/foobar HTTP/8.4\ncontent-length: 7\n\nHello.\n\"\"\"\n        parser = self.parser\n        self.feed(data)\n        self.assertTrue(parser.completed)\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(parser.headers, {\"CONTENT_LENGTH\": \"7\",})\n        self.assertEqual(parser.path, \"/foobar\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.proxy_scheme, \"https\")\n        self.assertEqual(parser.proxy_netloc, \"example.com:8080\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.query, \"\")\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\\n\")\n\n    def testDuplicateHeaders(self):\n        # Ensure that headers with the same key get concatenated as per\n        # RFC2616.\n        data = b\"\"\"\\\nGET /foobar HTTP/8.4\nx-forwarded-for: 10.11.12.13\nx-forwarded-for: unknown,127.0.0.1\nX-Forwarded_for: 255.255.255.255\ncontent-length: 7\n\nHello.\n\"\"\"\n        self.feed(data)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(\n            self.parser.headers,\n            {\n                \"CONTENT_LENGTH\": \"7\",\n                \"X_FORWARDED_FOR\": \"10.11.12.13, unknown,127.0.0.1\",\n            },\n        )\n\n    def testSpoofedHeadersDropped(self):\n        data = b\"\"\"\\\nGET /foobar HTTP/8.4\nx-auth_user: bob\ncontent-length: 7\n\nHello.\n\"\"\"\n        self.feed(data)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {\"CONTENT_LENGTH\": \"7\",})\n\n\nclass DummyBodyStream(object):\n    def getfile(self):\n        return self\n\n    def getbuf(self):\n        return self\n\n    def close(self):\n        self.closed = True\n", "import unittest\n\n\nclass TestFixedStreamReceiver(unittest.TestCase):\n    def _makeOne(self, cl, buf):\n        from waitress.receiver import FixedStreamReceiver\n\n        return FixedStreamReceiver(cl, buf)\n\n    def test_received_remain_lt_1(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(0, buf)\n        result = inst.received(\"a\")\n        self.assertEqual(result, 0)\n        self.assertEqual(inst.completed, True)\n\n    def test_received_remain_lte_datalen(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(1, buf)\n        result = inst.received(\"aa\")\n        self.assertEqual(result, 1)\n        self.assertEqual(inst.completed, True)\n        self.assertEqual(inst.completed, 1)\n        self.assertEqual(inst.remain, 0)\n        self.assertEqual(buf.data, [\"a\"])\n\n    def test_received_remain_gt_datalen(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(10, buf)\n        result = inst.received(\"aa\")\n        self.assertEqual(result, 2)\n        self.assertEqual(inst.completed, False)\n        self.assertEqual(inst.remain, 8)\n        self.assertEqual(buf.data, [\"aa\"])\n\n    def test_getfile(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(10, buf)\n        self.assertEqual(inst.getfile(), buf)\n\n    def test_getbuf(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(10, buf)\n        self.assertEqual(inst.getbuf(), buf)\n\n    def test___len__(self):\n        buf = DummyBuffer([\"1\", \"2\"])\n        inst = self._makeOne(10, buf)\n        self.assertEqual(inst.__len__(), 2)\n\n\nclass TestChunkedReceiver(unittest.TestCase):\n    def _makeOne(self, buf):\n        from waitress.receiver import ChunkedReceiver\n\n        return ChunkedReceiver(buf)\n\n    def test_alreadycompleted(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.completed = True\n        result = inst.received(b\"a\")\n        self.assertEqual(result, 0)\n        self.assertEqual(inst.completed, True)\n\n    def test_received_remain_gt_zero(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.chunk_remainder = 100\n        result = inst.received(b\"a\")\n        self.assertEqual(inst.chunk_remainder, 99)\n        self.assertEqual(result, 1)\n        self.assertEqual(inst.completed, False)\n\n    def test_received_control_line_notfinished(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        result = inst.received(b\"a\")\n        self.assertEqual(inst.control_line, b\"a\")\n        self.assertEqual(result, 1)\n        self.assertEqual(inst.completed, False)\n\n    def test_received_control_line_finished_garbage_in_input(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        result = inst.received(b\"garbage\\n\")\n        self.assertEqual(result, 8)\n        self.assertTrue(inst.error)\n\n    def test_received_control_line_finished_all_chunks_not_received(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        result = inst.received(b\"a;discard\\n\")\n        self.assertEqual(inst.control_line, b\"\")\n        self.assertEqual(inst.chunk_remainder, 10)\n        self.assertEqual(inst.all_chunks_received, False)\n        self.assertEqual(result, 10)\n        self.assertEqual(inst.completed, False)\n\n    def test_received_control_line_finished_all_chunks_received(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        result = inst.received(b\"0;discard\\n\")\n        self.assertEqual(inst.control_line, b\"\")\n        self.assertEqual(inst.all_chunks_received, True)\n        self.assertEqual(result, 10)\n        self.assertEqual(inst.completed, False)\n\n    def test_received_trailer_startswith_crlf(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.all_chunks_received = True\n        result = inst.received(b\"\\r\\n\")\n        self.assertEqual(result, 2)\n        self.assertEqual(inst.completed, True)\n\n    def test_received_trailer_startswith_lf(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.all_chunks_received = True\n        result = inst.received(b\"\\n\")\n        self.assertEqual(result, 1)\n        self.assertEqual(inst.completed, True)\n\n    def test_received_trailer_not_finished(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.all_chunks_received = True\n        result = inst.received(b\"a\")\n        self.assertEqual(result, 1)\n        self.assertEqual(inst.completed, False)\n\n    def test_received_trailer_finished(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.all_chunks_received = True\n        result = inst.received(b\"abc\\r\\n\\r\\n\")\n        self.assertEqual(inst.trailer, b\"abc\\r\\n\\r\\n\")\n        self.assertEqual(result, 7)\n        self.assertEqual(inst.completed, True)\n\n    def test_getfile(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        self.assertEqual(inst.getfile(), buf)\n\n    def test_getbuf(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        self.assertEqual(inst.getbuf(), buf)\n\n    def test___len__(self):\n        buf = DummyBuffer([\"1\", \"2\"])\n        inst = self._makeOne(buf)\n        self.assertEqual(inst.__len__(), 2)\n\n\nclass DummyBuffer(object):\n    def __init__(self, data=None):\n        if data is None:\n            data = []\n        self.data = data\n\n    def append(self, s):\n        self.data.append(s)\n\n    def getfile(self):\n        return self\n\n    def __len__(self):\n        return len(self.data)\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\nimport unittest\n\n\nclass Test_parse_http_date(unittest.TestCase):\n    def _callFUT(self, v):\n        from waitress.utilities import parse_http_date\n\n        return parse_http_date(v)\n\n    def test_rfc850(self):\n        val = \"Tuesday, 08-Feb-94 14:15:29 GMT\"\n        result = self._callFUT(val)\n        self.assertEqual(result, 760716929)\n\n    def test_rfc822(self):\n        val = \"Sun, 08 Feb 1994 14:15:29 GMT\"\n        result = self._callFUT(val)\n        self.assertEqual(result, 760716929)\n\n    def test_neither(self):\n        val = \"\"\n        result = self._callFUT(val)\n        self.assertEqual(result, 0)\n\n\nclass Test_build_http_date(unittest.TestCase):\n    def test_rountdrip(self):\n        from waitress.utilities import build_http_date, parse_http_date\n        from time import time\n\n        t = int(time())\n        self.assertEqual(t, parse_http_date(build_http_date(t)))\n\n\nclass Test_unpack_rfc850(unittest.TestCase):\n    def _callFUT(self, val):\n        from waitress.utilities import unpack_rfc850, rfc850_reg\n\n        return unpack_rfc850(rfc850_reg.match(val.lower()))\n\n    def test_it(self):\n        val = \"Tuesday, 08-Feb-94 14:15:29 GMT\"\n        result = self._callFUT(val)\n        self.assertEqual(result, (1994, 2, 8, 14, 15, 29, 0, 0, 0))\n\n\nclass Test_unpack_rfc_822(unittest.TestCase):\n    def _callFUT(self, val):\n        from waitress.utilities import unpack_rfc822, rfc822_reg\n\n        return unpack_rfc822(rfc822_reg.match(val.lower()))\n\n    def test_it(self):\n        val = \"Sun, 08 Feb 1994 14:15:29 GMT\"\n        result = self._callFUT(val)\n        self.assertEqual(result, (1994, 2, 8, 14, 15, 29, 0, 0, 0))\n\n\nclass Test_find_double_newline(unittest.TestCase):\n    def _callFUT(self, val):\n        from waitress.utilities import find_double_newline\n\n        return find_double_newline(val)\n\n    def test_empty(self):\n        self.assertEqual(self._callFUT(b\"\"), -1)\n\n    def test_one_linefeed(self):\n        self.assertEqual(self._callFUT(b\"\\n\"), -1)\n\n    def test_double_linefeed(self):\n        self.assertEqual(self._callFUT(b\"\\n\\n\"), 2)\n\n    def test_one_crlf(self):\n        self.assertEqual(self._callFUT(b\"\\r\\n\"), -1)\n\n    def test_double_crfl(self):\n        self.assertEqual(self._callFUT(b\"\\r\\n\\r\\n\"), 4)\n\n    def test_mixed(self):\n        self.assertEqual(self._callFUT(b\"\\n\\n00\\r\\n\\r\\n\"), 2)\n\n\nclass TestBadRequest(unittest.TestCase):\n    def _makeOne(self):\n        from waitress.utilities import BadRequest\n\n        return BadRequest(1)\n\n    def test_it(self):\n        inst = self._makeOne()\n        self.assertEqual(inst.body, 1)\n\n\nclass Test_undquote(unittest.TestCase):\n    def _callFUT(self, value):\n        from waitress.utilities import undquote\n\n        return undquote(value)\n\n    def test_empty(self):\n        self.assertEqual(self._callFUT(\"\"), \"\")\n\n    def test_quoted(self):\n        self.assertEqual(self._callFUT('\"test\"'), \"test\")\n\n    def test_unquoted(self):\n        self.assertEqual(self._callFUT(\"test\"), \"test\")\n\n    def test_quoted_backslash_quote(self):\n        self.assertEqual(self._callFUT('\"\\\\\"\"'), '\"')\n\n    def test_quoted_htab(self):\n        self.assertEqual(self._callFUT('\"\\t\"'), \"\\t\")\n\n    def test_quoted_backslash_htab(self):\n        self.assertEqual(self._callFUT('\"\\\\\\t\"'), \"\\t\")\n\n    def test_quoted_backslash_invalid(self):\n        self.assertRaises(ValueError, self._callFUT, '\"\\\\\"')\n\n    def test_invalid_quoting(self):\n        self.assertRaises(ValueError, self._callFUT, '\"test')\n\n    def test_invalid_quoting_single_quote(self):\n        self.assertRaises(ValueError, self._callFUT, '\"')\n", "##############################################################################\n#\n# Copyright (c) 2004 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Utility functions\n\"\"\"\n\nimport calendar\nimport errno\nimport logging\nimport os\nimport re\nimport stat\nimport time\n\nlogger = logging.getLogger(\"waitress\")\nqueue_logger = logging.getLogger(\"waitress.queue\")\n\n\ndef find_double_newline(s):\n    \"\"\"Returns the position just after a double newline in the given string.\"\"\"\n    pos1 = s.find(b\"\\n\\r\\n\")  # One kind of double newline\n    if pos1 >= 0:\n        pos1 += 3\n    pos2 = s.find(b\"\\n\\n\")  # Another kind of double newline\n    if pos2 >= 0:\n        pos2 += 2\n\n    if pos1 >= 0:\n        if pos2 >= 0:\n            return min(pos1, pos2)\n        else:\n            return pos1\n    else:\n        return pos2\n\n\ndef concat(*args):\n    return \"\".join(args)\n\n\ndef join(seq, field=\" \"):\n    return field.join(seq)\n\n\ndef group(s):\n    return \"(\" + s + \")\"\n\n\nshort_days = [\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\"]\nlong_days = [\n    \"sunday\",\n    \"monday\",\n    \"tuesday\",\n    \"wednesday\",\n    \"thursday\",\n    \"friday\",\n    \"saturday\",\n]\n\nshort_day_reg = group(join(short_days, \"|\"))\nlong_day_reg = group(join(long_days, \"|\"))\n\ndaymap = {}\nfor i in range(7):\n    daymap[short_days[i]] = i\n    daymap[long_days[i]] = i\n\nhms_reg = join(3 * [group(\"[0-9][0-9]\")], \":\")\n\nmonths = [\n    \"jan\",\n    \"feb\",\n    \"mar\",\n    \"apr\",\n    \"may\",\n    \"jun\",\n    \"jul\",\n    \"aug\",\n    \"sep\",\n    \"oct\",\n    \"nov\",\n    \"dec\",\n]\n\nmonmap = {}\nfor i in range(12):\n    monmap[months[i]] = i + 1\n\nmonths_reg = group(join(months, \"|\"))\n\n# From draft-ietf-http-v11-spec-07.txt/3.3.1\n#       Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123\n#       Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036\n#       Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format\n\n# rfc822 format\nrfc822_date = join(\n    [\n        concat(short_day_reg, \",\"),  # day\n        group(\"[0-9][0-9]?\"),  # date\n        months_reg,  # month\n        group(\"[0-9]+\"),  # year\n        hms_reg,  # hour minute second\n        \"gmt\",\n    ],\n    \" \",\n)\n\nrfc822_reg = re.compile(rfc822_date)\n\n\ndef unpack_rfc822(m):\n    g = m.group\n    return (\n        int(g(4)),  # year\n        monmap[g(3)],  # month\n        int(g(2)),  # day\n        int(g(5)),  # hour\n        int(g(6)),  # minute\n        int(g(7)),  # second\n        0,\n        0,\n        0,\n    )\n\n\n# rfc850 format\nrfc850_date = join(\n    [\n        concat(long_day_reg, \",\"),\n        join([group(\"[0-9][0-9]?\"), months_reg, group(\"[0-9]+\")], \"-\"),\n        hms_reg,\n        \"gmt\",\n    ],\n    \" \",\n)\n\nrfc850_reg = re.compile(rfc850_date)\n# they actually unpack the same way\ndef unpack_rfc850(m):\n    g = m.group\n    yr = g(4)\n    if len(yr) == 2:\n        yr = \"19\" + yr\n    return (\n        int(yr),  # year\n        monmap[g(3)],  # month\n        int(g(2)),  # day\n        int(g(5)),  # hour\n        int(g(6)),  # minute\n        int(g(7)),  # second\n        0,\n        0,\n        0,\n    )\n\n\n# parsdate.parsedate - ~700/sec.\n# parse_http_date    - ~1333/sec.\n\nweekdayname = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]\nmonthname = [\n    None,\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\",\n]\n\n\ndef build_http_date(when):\n    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(when)\n    return \"%s, %02d %3s %4d %02d:%02d:%02d GMT\" % (\n        weekdayname[wd],\n        day,\n        monthname[month],\n        year,\n        hh,\n        mm,\n        ss,\n    )\n\n\ndef parse_http_date(d):\n    d = d.lower()\n    m = rfc850_reg.match(d)\n    if m and m.end() == len(d):\n        retval = int(calendar.timegm(unpack_rfc850(m)))\n    else:\n        m = rfc822_reg.match(d)\n        if m and m.end() == len(d):\n            retval = int(calendar.timegm(unpack_rfc822(m)))\n        else:\n            return 0\n    return retval\n\n\n# RFC 5234 Appendix B.1 \"Core Rules\":\n# VCHAR         =  %x21-7E\n#                  ; visible (printing) characters\nvchar_re = \"\\x21-\\x7e\"\n\n# RFC 7230 Section 3.2.6 \"Field Value Components\":\n# quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n# qdtext        = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text\n# obs-text      = %x80-FF\n# quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\nobs_text_re = \"\\x80-\\xff\"\n\n# The '\\\\' between \\x5b and \\x5d is needed to escape \\x5d (']')\nqdtext_re = \"[\\t \\x21\\x23-\\x5b\\\\\\x5d-\\x7e\" + obs_text_re + \"]\"\n\nquoted_pair_re = r\"\\\\\" + \"([\\t \" + vchar_re + obs_text_re + \"])\"\nquoted_string_re = '\"(?:(?:' + qdtext_re + \")|(?:\" + quoted_pair_re + '))*\"'\n\nquoted_string = re.compile(quoted_string_re)\nquoted_pair = re.compile(quoted_pair_re)\n\n\ndef undquote(value):\n    if value.startswith('\"') and value.endswith('\"'):\n        # So it claims to be DQUOTE'ed, let's validate that\n        matches = quoted_string.match(value)\n\n        if matches and matches.end() == len(value):\n            # Remove the DQUOTE's from the value\n            value = value[1:-1]\n\n            # Remove all backslashes that are followed by a valid vchar or\n            # obs-text\n            value = quoted_pair.sub(r\"\\1\", value)\n\n            return value\n    elif not value.startswith('\"') and not value.endswith('\"'):\n        return value\n\n    raise ValueError(\"Invalid quoting in value\")\n\n\ndef cleanup_unix_socket(path):\n    try:\n        st = os.stat(path)\n    except OSError as exc:\n        if exc.errno != errno.ENOENT:\n            raise  # pragma: no cover\n    else:\n        if stat.S_ISSOCK(st.st_mode):\n            try:\n                os.remove(path)\n            except OSError:  # pragma: no cover\n                # avoid race condition error during tests\n                pass\n\n\nclass Error(object):\n    code = 500\n    reason = \"Internal Server Error\"\n\n    def __init__(self, body):\n        self.body = body\n\n    def to_response(self):\n        status = \"%s %s\" % (self.code, self.reason)\n        body = \"%s\\r\\n\\r\\n%s\" % (self.reason, self.body)\n        tag = \"\\r\\n\\r\\n(generated by waitress)\"\n        body = body + tag\n        headers = [(\"Content-Type\", \"text/plain\")]\n\n        return status, headers, body\n\n    def wsgi_response(self, environ, start_response):\n        status, headers, body = self.to_response()\n        start_response(status, headers)\n        yield body\n\n\nclass BadRequest(Error):\n    code = 400\n    reason = \"Bad Request\"\n\n\nclass RequestHeaderFieldsTooLarge(BadRequest):\n    code = 431\n    reason = \"Request Header Fields Too Large\"\n\n\nclass RequestEntityTooLarge(BadRequest):\n    code = 413\n    reason = \"Request Entity Too Large\"\n\n\nclass InternalServerError(Error):\n    code = 500\n    reason = \"Internal Server Error\"\n"], "fixing_code": ["##############################################################################\n#\n# Copyright (c) 2001, 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"HTTP Request Parser\n\nThis server uses asyncore to accept connections and do initial\nprocessing but threads to do work.\n\"\"\"\nimport re\nfrom io import BytesIO\n\nfrom waitress.buffers import OverflowableBuffer\nfrom waitress.compat import tostr, unquote_bytes_to_wsgi, urlparse\nfrom waitress.receiver import ChunkedReceiver, FixedStreamReceiver\nfrom waitress.utilities import (\n    BadRequest,\n    RequestEntityTooLarge,\n    RequestHeaderFieldsTooLarge,\n    find_double_newline,\n)\n\n\nclass ParsingError(Exception):\n    pass\n\n\nclass HTTPRequestParser(object):\n    \"\"\"A structure that collects the HTTP request.\n\n    Once the stream is completed, the instance is passed to\n    a server task constructor.\n    \"\"\"\n\n    completed = False  # Set once request is completed.\n    empty = False  # Set if no request was made.\n    expect_continue = False  # client sent \"Expect: 100-continue\" header\n    headers_finished = False  # True when headers have been read\n    header_plus = b\"\"\n    chunked = False\n    content_length = 0\n    header_bytes_received = 0\n    body_bytes_received = 0\n    body_rcv = None\n    version = \"1.0\"\n    error = None\n    connection_close = False\n\n    # Other attributes: first_line, header, headers, command, uri, version,\n    # path, query, fragment\n\n    def __init__(self, adj):\n        \"\"\"\n        adj is an Adjustments object.\n        \"\"\"\n        # headers is a mapping containing keys translated to uppercase\n        # with dashes turned into underscores.\n        self.headers = {}\n        self.adj = adj\n\n    def received(self, data):\n        \"\"\"\n        Receives the HTTP stream for one request.  Returns the number of\n        bytes consumed.  Sets the completed flag once both the header and the\n        body have been received.\n        \"\"\"\n        if self.completed:\n            return 0  # Can't consume any more.\n        datalen = len(data)\n        br = self.body_rcv\n        if br is None:\n            # In header.\n            s = self.header_plus + data\n            index = find_double_newline(s)\n            if index >= 0:\n                # Header finished.\n                header_plus = s[:index]\n                consumed = len(data) - (len(s) - index)\n\n                # Remove preceeding blank lines. This is suggested by\n                # https://tools.ietf.org/html/rfc7230#section-3.5 to support\n                # clients sending an extra CR LF after another request when\n                # using HTTP pipelining\n                header_plus = header_plus.lstrip()\n\n                if not header_plus:\n                    self.empty = True\n                    self.completed = True\n                else:\n                    try:\n                        self.parse_header(header_plus)\n                    except ParsingError as e:\n                        self.error = BadRequest(e.args[0])\n                        self.completed = True\n                    else:\n                        if self.body_rcv is None:\n                            # no content-length header and not a t-e: chunked\n                            # request\n                            self.completed = True\n                        if self.content_length > 0:\n                            max_body = self.adj.max_request_body_size\n                            # we won't accept this request if the content-length\n                            # is too large\n                            if self.content_length >= max_body:\n                                self.error = RequestEntityTooLarge(\n                                    \"exceeds max_body of %s\" % max_body\n                                )\n                                self.completed = True\n                self.headers_finished = True\n                return consumed\n            else:\n                # Header not finished yet.\n                self.header_bytes_received += datalen\n                max_header = self.adj.max_request_header_size\n                if self.header_bytes_received >= max_header:\n                    # malformed header, we need to construct some request\n                    # on our own. we disregard the incoming(?) requests HTTP\n                    # version and just use 1.0. IOW someone just sent garbage\n                    # over the wire\n                    self.parse_header(b\"GET / HTTP/1.0\\n\")\n                    self.error = RequestHeaderFieldsTooLarge(\n                        \"exceeds max_header of %s\" % max_header\n                    )\n                    self.completed = True\n                self.header_plus = s\n                return datalen\n        else:\n            # In body.\n            consumed = br.received(data)\n            self.body_bytes_received += consumed\n            max_body = self.adj.max_request_body_size\n            if self.body_bytes_received >= max_body:\n                # this will only be raised during t-e: chunked requests\n                self.error = RequestEntityTooLarge(\"exceeds max_body of %s\" % max_body)\n                self.completed = True\n            elif br.error:\n                # garbage in chunked encoding input probably\n                self.error = br.error\n                self.completed = True\n            elif br.completed:\n                # The request (with the body) is ready to use.\n                self.completed = True\n                if self.chunked:\n                    # We've converted the chunked transfer encoding request\n                    # body into a normal request body, so we know its content\n                    # length; set the header here.  We already popped the\n                    # TRANSFER_ENCODING header in parse_header, so this will\n                    # appear to the client to be an entirely non-chunked HTTP\n                    # request with a valid content-length.\n                    self.headers[\"CONTENT_LENGTH\"] = str(br.__len__())\n            return consumed\n\n    def parse_header(self, header_plus):\n        \"\"\"\n        Parses the header_plus block of text (the headers plus the\n        first line of the request).\n        \"\"\"\n        index = header_plus.find(b\"\\r\\n\")\n        if index >= 0:\n            first_line = header_plus[:index].rstrip()\n            header = header_plus[index + 2 :]\n        else:\n            raise ParsingError(\"HTTP message header invalid\")\n\n        if b\"\\r\" in first_line or b\"\\n\" in first_line:\n            raise ParsingError(\"Bare CR or LF found in HTTP message\")\n\n        self.first_line = first_line  # for testing\n\n        lines = get_header_lines(header)\n\n        headers = self.headers\n        for line in lines:\n            index = line.find(b\":\")\n            if index > 0:\n                key = line[:index]\n                if b\"_\" in key:\n                    continue\n                value = line[index + 1 :].strip()\n                key1 = tostr(key.upper().replace(b\"-\", b\"_\"))\n                # If a header already exists, we append subsequent values\n                # seperated by a comma. Applications already need to handle\n                # the comma seperated values, as HTTP front ends might do\n                # the concatenation for you (behavior specified in RFC2616).\n                try:\n                    headers[key1] += tostr(b\", \" + value)\n                except KeyError:\n                    headers[key1] = tostr(value)\n            # else there's garbage in the headers?\n\n        # command, uri, version will be bytes\n        command, uri, version = crack_first_line(first_line)\n        version = tostr(version)\n        command = tostr(command)\n        self.command = command\n        self.version = version\n        (\n            self.proxy_scheme,\n            self.proxy_netloc,\n            self.path,\n            self.query,\n            self.fragment,\n        ) = split_uri(uri)\n        self.url_scheme = self.adj.url_scheme\n        connection = headers.get(\"CONNECTION\", \"\")\n\n        if version == \"1.0\":\n            if connection.lower() != \"keep-alive\":\n                self.connection_close = True\n\n        if version == \"1.1\":\n            # since the server buffers data from chunked transfers and clients\n            # never need to deal with chunked requests, downstream clients\n            # should not see the HTTP_TRANSFER_ENCODING header; we pop it\n            # here\n            te = headers.pop(\"TRANSFER_ENCODING\", \"\")\n            if te.lower() == \"chunked\":\n                self.chunked = True\n                buf = OverflowableBuffer(self.adj.inbuf_overflow)\n                self.body_rcv = ChunkedReceiver(buf)\n            expect = headers.get(\"EXPECT\", \"\").lower()\n            self.expect_continue = expect == \"100-continue\"\n            if connection.lower() == \"close\":\n                self.connection_close = True\n\n        if not self.chunked:\n            try:\n                cl = int(headers.get(\"CONTENT_LENGTH\", 0))\n            except ValueError:\n                cl = 0\n            self.content_length = cl\n            if cl > 0:\n                buf = OverflowableBuffer(self.adj.inbuf_overflow)\n                self.body_rcv = FixedStreamReceiver(cl, buf)\n\n    def get_body_stream(self):\n        body_rcv = self.body_rcv\n        if body_rcv is not None:\n            return body_rcv.getfile()\n        else:\n            return BytesIO()\n\n    def close(self):\n        body_rcv = self.body_rcv\n        if body_rcv is not None:\n            body_rcv.getbuf().close()\n\n\ndef split_uri(uri):\n    # urlsplit handles byte input by returning bytes on py3, so\n    # scheme, netloc, path, query, and fragment are bytes\n\n    scheme = netloc = path = query = fragment = b\"\"\n\n    # urlsplit below will treat this as a scheme-less netloc, thereby losing\n    # the original intent of the request. Here we shamelessly stole 4 lines of\n    # code from the CPython stdlib to parse out the fragment and query but\n    # leave the path alone. See\n    # https://github.com/python/cpython/blob/8c9e9b0cd5b24dfbf1424d1f253d02de80e8f5ef/Lib/urllib/parse.py#L465-L468\n    # and https://github.com/Pylons/waitress/issues/260\n\n    if uri[:2] == b\"//\":\n        path = uri\n\n        if b\"#\" in path:\n            path, fragment = path.split(b\"#\", 1)\n\n        if b\"?\" in path:\n            path, query = path.split(b\"?\", 1)\n    else:\n        try:\n            scheme, netloc, path, query, fragment = urlparse.urlsplit(uri)\n        except UnicodeError:\n            raise ParsingError(\"Bad URI\")\n\n    return (\n        tostr(scheme),\n        tostr(netloc),\n        unquote_bytes_to_wsgi(path),\n        tostr(query),\n        tostr(fragment),\n    )\n\n\ndef get_header_lines(header):\n    \"\"\"\n    Splits the header into lines, putting multi-line headers together.\n    \"\"\"\n    r = []\n    lines = header.split(b\"\\r\\n\")\n    for line in lines:\n        if b\"\\r\" in line or b\"\\n\" in line:\n            raise ParsingError('Bare CR or LF found in header line \"%s\"' % tostr(line))\n\n        if line.startswith((b\" \", b\"\\t\")):\n            if not r:\n                # https://corte.si/posts/code/pathod/pythonservers/index.html\n                raise ParsingError('Malformed header line \"%s\"' % tostr(line))\n            r[-1] += line\n        else:\n            r.append(line)\n    return r\n\n\nfirst_line_re = re.compile(\n    b\"([^ ]+) \"\n    b\"((?:[^ :?#]+://[^ ?#/]*(?:[0-9]{1,5})?)?[^ ]+)\"\n    b\"(( HTTP/([0-9.]+))$|$)\"\n)\n\n\ndef crack_first_line(line):\n    m = first_line_re.match(line)\n    if m is not None and m.end() == len(line):\n        if m.group(3):\n            version = m.group(5)\n        else:\n            version = b\"\"\n        method = m.group(1)\n\n        # the request methods that are currently defined are all uppercase:\n        # https://www.iana.org/assignments/http-methods/http-methods.xhtml and\n        # the request method is case sensitive according to\n        # https://tools.ietf.org/html/rfc7231#section-4.1\n\n        # By disallowing anything but uppercase methods we save poor\n        # unsuspecting souls from sending lowercase HTTP methods to waitress\n        # and having the request complete, while servers like nginx drop the\n        # request onto the floor.\n        if method != method.upper():\n            raise ParsingError('Malformed HTTP method \"%s\"' % tostr(method))\n        uri = m.group(2)\n        return method, uri, version\n    else:\n        return b\"\", b\"\", b\"\"\n", "##############################################################################\n#\n# Copyright (c) 2001, 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Data Chunk Receiver\n\"\"\"\n\nfrom waitress.utilities import BadRequest, find_double_newline\n\n\nclass FixedStreamReceiver(object):\n\n    # See IStreamConsumer\n    completed = False\n    error = None\n\n    def __init__(self, cl, buf):\n        self.remain = cl\n        self.buf = buf\n\n    def __len__(self):\n        return self.buf.__len__()\n\n    def received(self, data):\n        \"See IStreamConsumer\"\n        rm = self.remain\n\n        if rm < 1:\n            self.completed = True  # Avoid any chance of spinning\n\n            return 0\n        datalen = len(data)\n\n        if rm <= datalen:\n            self.buf.append(data[:rm])\n            self.remain = 0\n            self.completed = True\n\n            return rm\n        else:\n            self.buf.append(data)\n            self.remain -= datalen\n\n            return datalen\n\n    def getfile(self):\n        return self.buf.getfile()\n\n    def getbuf(self):\n        return self.buf\n\n\nclass ChunkedReceiver(object):\n\n    chunk_remainder = 0\n    validate_chunk_end = False\n    control_line = b\"\"\n    all_chunks_received = False\n    trailer = b\"\"\n    completed = False\n    error = None\n\n    # max_control_line = 1024\n    # max_trailer = 65536\n\n    def __init__(self, buf):\n        self.buf = buf\n\n    def __len__(self):\n        return self.buf.__len__()\n\n    def received(self, s):\n        # Returns the number of bytes consumed.\n\n        if self.completed:\n            return 0\n        orig_size = len(s)\n\n        while s:\n            rm = self.chunk_remainder\n\n            if rm > 0:\n                # Receive the remainder of a chunk.\n                to_write = s[:rm]\n                self.buf.append(to_write)\n                written = len(to_write)\n                s = s[written:]\n\n                self.chunk_remainder -= written\n\n                if self.chunk_remainder == 0:\n                    self.validate_chunk_end = True\n            elif self.validate_chunk_end:\n                pos = s.find(b\"\\r\\n\")\n\n                if pos == 0:\n                    # Chop off the terminating CR LF from the chunk\n                    s = s[2:]\n                else:\n                    self.error = BadRequest(\"Chunk not properly terminated\")\n                    self.all_chunks_received = True\n\n                # Always exit this loop\n                self.validate_chunk_end = False\n            elif not self.all_chunks_received:\n                # Receive a control line.\n                s = self.control_line + s\n                pos = s.find(b\"\\r\\n\")\n\n                if pos < 0:\n                    # Control line not finished.\n                    self.control_line = s\n                    s = \"\"\n                else:\n                    # Control line finished.\n                    line = s[:pos]\n                    s = s[pos + 2 :]\n                    self.control_line = b\"\"\n                    line = line.strip()\n\n                    if line:\n                        # Begin a new chunk.\n                        semi = line.find(b\";\")\n\n                        if semi >= 0:\n                            # discard extension info.\n                            line = line[:semi]\n                        try:\n                            sz = int(line.strip(), 16)  # hexadecimal\n                        except ValueError:  # garbage in input\n                            self.error = BadRequest(\"garbage in chunked encoding input\")\n                            sz = 0\n\n                        if sz > 0:\n                            # Start a new chunk.\n                            self.chunk_remainder = sz\n                        else:\n                            # Finished chunks.\n                            self.all_chunks_received = True\n                    # else expect a control line.\n            else:\n                # Receive the trailer.\n                trailer = self.trailer + s\n\n                if trailer.startswith(b\"\\r\\n\"):\n                    # No trailer.\n                    self.completed = True\n\n                    return orig_size - (len(trailer) - 2)\n                pos = find_double_newline(trailer)\n\n                if pos < 0:\n                    # Trailer not finished.\n                    self.trailer = trailer\n                    s = b\"\"\n                else:\n                    # Finished the trailer.\n                    self.completed = True\n                    self.trailer = trailer[:pos]\n\n                    return orig_size - (len(trailer) - pos)\n\n        return orig_size\n\n    def getfile(self):\n        return self.buf.getfile()\n\n    def getbuf(self):\n        return self.buf\n", "import unittest\nimport io\n\n\nclass TestHTTPChannel(unittest.TestCase):\n    def _makeOne(self, sock, addr, adj, map=None):\n        from waitress.channel import HTTPChannel\n\n        server = DummyServer()\n        return HTTPChannel(server, sock, addr, adj=adj, map=map)\n\n    def _makeOneWithMap(self, adj=None):\n        if adj is None:\n            adj = DummyAdjustments()\n        sock = DummySock()\n        map = {}\n        inst = self._makeOne(sock, \"127.0.0.1\", adj, map=map)\n        inst.outbuf_lock = DummyLock()\n        return inst, sock, map\n\n    def test_ctor(self):\n        inst, _, map = self._makeOneWithMap()\n        self.assertEqual(inst.addr, \"127.0.0.1\")\n        self.assertEqual(inst.sendbuf_len, 2048)\n        self.assertEqual(map[100], inst)\n\n    def test_total_outbufs_len_an_outbuf_size_gt_sys_maxint(self):\n        from waitress.compat import MAXINT\n\n        inst, _, map = self._makeOneWithMap()\n\n        class DummyBuffer(object):\n            chunks = []\n\n            def append(self, data):\n                self.chunks.append(data)\n\n        class DummyData(object):\n            def __len__(self):\n                return MAXINT\n\n        inst.total_outbufs_len = 1\n        inst.outbufs = [DummyBuffer()]\n        inst.write_soon(DummyData())\n        # we are testing that this method does not raise an OverflowError\n        # (see https://github.com/Pylons/waitress/issues/47)\n        self.assertEqual(inst.total_outbufs_len, MAXINT + 1)\n\n    def test_writable_something_in_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.total_outbufs_len = 3\n        self.assertTrue(inst.writable())\n\n    def test_writable_nothing_in_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        self.assertFalse(inst.writable())\n\n    def test_writable_nothing_in_outbuf_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = True\n        self.assertTrue(inst.writable())\n\n    def test_handle_write_not_connected(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.connected = False\n        self.assertFalse(inst.handle_write())\n\n    def test_handle_write_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n\n    def test_handle_write_no_request_with_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertNotEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_outbuf_raises_socketerror(self):\n        import socket\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"abc\", socket.error)\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_outbuf_raises_othererror(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"abc\", IOError)\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_no_requests_no_outbuf_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"\")\n        inst.outbufs = [outbuf]\n        inst.will_close = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_no_requests_outbuf_gt_send_bytes(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 2\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_close_when_flushed(self):\n        inst, sock, map = self._makeOneWithMap()\n        outbuf = DummyBuffer(b\"abc\")\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.will_close = False\n        inst.close_when_flushed = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, True)\n        self.assertEqual(inst.close_when_flushed, False)\n        self.assertEqual(sock.sent, b\"abc\")\n        self.assertTrue(outbuf.closed)\n\n    def test_readable_no_requests_not_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.will_close = False\n        self.assertEqual(inst.readable(), True)\n\n    def test_readable_no_requests_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.will_close = True\n        self.assertEqual(inst.readable(), False)\n\n    def test_readable_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = True\n        self.assertEqual(inst.readable(), False)\n\n    def test_handle_read_no_error(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = False\n        inst.recv = lambda *arg: b\"abc\"\n        inst.last_activity = 0\n        L = []\n        inst.received = lambda x: L.append(x)\n        result = inst.handle_read()\n        self.assertEqual(result, None)\n        self.assertNotEqual(inst.last_activity, 0)\n        self.assertEqual(L, [b\"abc\"])\n\n    def test_handle_read_error(self):\n        import socket\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = False\n\n        def recv(b):\n            raise socket.error\n\n        inst.recv = recv\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_read()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test_write_soon_empty_byte(self):\n        inst, sock, map = self._makeOneWithMap()\n        wrote = inst.write_soon(b\"\")\n        self.assertEqual(wrote, 0)\n        self.assertEqual(len(inst.outbufs[0]), 0)\n\n    def test_write_soon_nonempty_byte(self):\n        inst, sock, map = self._makeOneWithMap()\n        wrote = inst.write_soon(b\"a\")\n        self.assertEqual(wrote, 1)\n        self.assertEqual(len(inst.outbufs[0]), 1)\n\n    def test_write_soon_filewrapper(self):\n        from waitress.buffers import ReadOnlyFileBasedBuffer\n\n        f = io.BytesIO(b\"abc\")\n        wrapper = ReadOnlyFileBasedBuffer(f, 8192)\n        wrapper.prepare()\n        inst, sock, map = self._makeOneWithMap()\n        outbufs = inst.outbufs\n        orig_outbuf = outbufs[0]\n        wrote = inst.write_soon(wrapper)\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(outbufs), 3)\n        self.assertEqual(outbufs[0], orig_outbuf)\n        self.assertEqual(outbufs[1], wrapper)\n        self.assertEqual(outbufs[2].__class__.__name__, \"OverflowableBuffer\")\n\n    def test_write_soon_disconnected(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.connected = False\n        self.assertRaises(ClientDisconnected, lambda: inst.write_soon(b\"stuff\"))\n\n    def test_write_soon_disconnected_while_over_watermark(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n\n        def dummy_flush():\n            inst.connected = False\n\n        inst._flush_outbufs_below_high_watermark = dummy_flush\n        self.assertRaises(ClientDisconnected, lambda: inst.write_soon(b\"stuff\"))\n\n    def test_write_soon_rotates_outbuf_on_overflow(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.outbuf_high_watermark = 3\n        inst.current_outbuf_count = 4\n        wrote = inst.write_soon(b\"xyz\")\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(inst.outbufs), 2)\n        self.assertEqual(inst.outbufs[0].get(), b\"\")\n        self.assertEqual(inst.outbufs[1].get(), b\"xyz\")\n\n    def test_write_soon_waits_on_backpressure(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.outbuf_high_watermark = 3\n        inst.total_outbufs_len = 4\n        inst.current_outbuf_count = 4\n\n        class Lock(DummyLock):\n            def wait(self):\n                inst.total_outbufs_len = 0\n                super(Lock, self).wait()\n\n        inst.outbuf_lock = Lock()\n        wrote = inst.write_soon(b\"xyz\")\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(inst.outbufs), 2)\n        self.assertEqual(inst.outbufs[0].get(), b\"\")\n        self.assertEqual(inst.outbufs[1].get(), b\"xyz\")\n        self.assertTrue(inst.outbuf_lock.waited)\n\n    def test_handle_write_notify_after_flush(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 1\n        inst.adj.outbuf_high_watermark = 5\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertTrue(inst.outbuf_lock.notified)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_no_notify_after_flush(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 1\n        inst.adj.outbuf_high_watermark = 2\n        sock.send = lambda x: False\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertFalse(inst.outbuf_lock.notified)\n        self.assertEqual(sock.sent, b\"\")\n\n    def test__flush_some_empty_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        result = inst._flush_some()\n        self.assertEqual(result, False)\n\n    def test__flush_some_full_outbuf_socket_returns_nonzero(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.outbufs[0].append(b\"abc\")\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n\n    def test__flush_some_full_outbuf_socket_returns_zero(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: False\n        inst.outbufs[0].append(b\"abc\")\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, False)\n\n    def test_flush_some_multiple_buffers_first_empty(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: len(x)\n        buffer = DummyBuffer(b\"abc\")\n        inst.outbufs.append(buffer)\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n        self.assertEqual(buffer.skipped, 3)\n        self.assertEqual(inst.outbufs, [buffer])\n\n    def test_flush_some_multiple_buffers_close_raises(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: len(x)\n        buffer = DummyBuffer(b\"abc\")\n        inst.outbufs.append(buffer)\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        inst.logger = DummyLogger()\n\n        def doraise():\n            raise NotImplementedError\n\n        inst.outbufs[0].close = doraise\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n        self.assertEqual(buffer.skipped, 3)\n        self.assertEqual(inst.outbufs, [buffer])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test__flush_some_outbuf_len_gt_sys_maxint(self):\n        from waitress.compat import MAXINT\n\n        inst, sock, map = self._makeOneWithMap()\n\n        class DummyHugeOutbuffer(object):\n            def __init__(self):\n                self.length = MAXINT + 1\n\n            def __len__(self):\n                return self.length\n\n            def get(self, numbytes):\n                self.length = 0\n                return b\"123\"\n\n        buf = DummyHugeOutbuffer()\n        inst.outbufs = [buf]\n        inst.send = lambda *arg: 0\n        result = inst._flush_some()\n        # we are testing that _flush_some doesn't raise an OverflowError\n        # when one of its outbufs has a __len__ that returns gt sys.maxint\n        self.assertEqual(result, False)\n\n    def test_handle_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.handle_close()\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n\n    def test_handle_close_outbuf_raises_on_close(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        def doraise():\n            raise NotImplementedError\n\n        inst.outbufs[0].close = doraise\n        inst.logger = DummyLogger()\n        inst.handle_close()\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test_add_channel(self):\n        inst, sock, map = self._makeOneWithMap()\n        fileno = inst._fileno\n        inst.add_channel(map)\n        self.assertEqual(map[fileno], inst)\n        self.assertEqual(inst.server.active_channels[fileno], inst)\n\n    def test_del_channel(self):\n        inst, sock, map = self._makeOneWithMap()\n        fileno = inst._fileno\n        inst.server.active_channels[fileno] = True\n        inst.del_channel(map)\n        self.assertEqual(map.get(fileno), None)\n        self.assertEqual(inst.server.active_channels.get(fileno), None)\n\n    def test_received(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.server.tasks, [inst])\n        self.assertTrue(inst.requests)\n\n    def test_received_no_chunk(self):\n        inst, sock, map = self._makeOneWithMap()\n        self.assertEqual(inst.received(b\"\"), False)\n\n    def test_received_preq_not_completed(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = False\n        preq.empty = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.requests, ())\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_preq_completed_empty(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.empty = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, None)\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_preq_error(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.error = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, None)\n        self.assertEqual(len(inst.server.tasks), 1)\n        self.assertTrue(inst.requests)\n\n    def test_received_preq_completed_connection_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.empty = True\n        preq.connection_close = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\" + b\"a\" * 50000)\n        self.assertEqual(inst.request, None)\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_headers_finished_expect_continue_false(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = False\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        preq.retval = 1\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(inst.outbufs[0].get(100), b\"\")\n\n    def test_received_headers_finished_expect_continue_true(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = True\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(sock.sent, b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n        self.assertEqual(inst.sent_continue, True)\n        self.assertEqual(preq.completed, False)\n\n    def test_received_headers_finished_expect_continue_true_sent_true(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = True\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        inst.sent_continue = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(inst.sent_continue, True)\n        self.assertEqual(preq.completed, False)\n\n    def test_service_no_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n\n    def test_service_with_one_request(self):\n        inst, sock, map = self._makeOneWithMap()\n        request = DummyRequest()\n        inst.task_class = DummyTaskClass()\n        inst.requests = [request]\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request.serviced)\n        self.assertTrue(request.closed)\n\n    def test_service_with_one_error_request(self):\n        inst, sock, map = self._makeOneWithMap()\n        request = DummyRequest()\n        request.error = DummyError()\n        inst.error_task_class = DummyTaskClass()\n        inst.requests = [request]\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request.serviced)\n        self.assertTrue(request.closed)\n\n    def test_service_with_multiple_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        request1 = DummyRequest()\n        request2 = DummyRequest()\n        inst.task_class = DummyTaskClass()\n        inst.requests = [request1, request2]\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request1.serviced)\n        self.assertTrue(request2.serviced)\n        self.assertTrue(request1.closed)\n        self.assertTrue(request2.closed)\n\n    def test_service_with_request_raises(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_already_wrote_header(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertTrue(inst.close_when_flushed)\n        self.assertEqual(inst.error_task_class.serviced, False)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_didnt_write_header_expose_tbs(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = True\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_didnt_write_header(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertTrue(inst.close_when_flushed)\n        self.assertTrue(request.closed)\n\n    def test_service_with_request_raises_disconnect(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ClientDisconnected)\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.infos), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.error_task_class.serviced, False)\n        self.assertTrue(request.closed)\n\n    def test_service_with_request_error_raises_disconnect(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        err_request = DummyRequest()\n        inst.requests = [request]\n        inst.parser_class = lambda x: err_request\n        inst.task_class = DummyTaskClass(RuntimeError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass(ClientDisconnected)\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertTrue(err_request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertEqual(len(inst.logger.infos), 0)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.task_class.serviced, True)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_cancel_no_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = ()\n        inst.cancel()\n        self.assertEqual(inst.requests, [])\n\n    def test_cancel_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [None]\n        inst.cancel()\n        self.assertEqual(inst.requests, [])\n\n\nclass DummySock(object):\n    blocking = False\n    closed = False\n\n    def __init__(self):\n        self.sent = b\"\"\n\n    def setblocking(self, *arg):\n        self.blocking = True\n\n    def fileno(self):\n        return 100\n\n    def getpeername(self):\n        return \"127.0.0.1\"\n\n    def getsockopt(self, level, option):\n        return 2048\n\n    def close(self):\n        self.closed = True\n\n    def send(self, data):\n        self.sent += data\n        return len(data)\n\n\nclass DummyLock(object):\n    notified = False\n\n    def __init__(self, acquirable=True):\n        self.acquirable = acquirable\n\n    def acquire(self, val):\n        self.val = val\n        self.acquired = True\n        return self.acquirable\n\n    def release(self):\n        self.released = True\n\n    def notify(self):\n        self.notified = True\n\n    def wait(self):\n        self.waited = True\n\n    def __exit__(self, type, val, traceback):\n        self.acquire(True)\n\n    def __enter__(self):\n        pass\n\n\nclass DummyBuffer(object):\n    closed = False\n\n    def __init__(self, data, toraise=None):\n        self.data = data\n        self.toraise = toraise\n\n    def get(self, *arg):\n        if self.toraise:\n            raise self.toraise\n        data = self.data\n        self.data = b\"\"\n        return data\n\n    def skip(self, num, x):\n        self.skipped = num\n\n    def __len__(self):\n        return len(self.data)\n\n    def close(self):\n        self.closed = True\n\n\nclass DummyAdjustments(object):\n    outbuf_overflow = 1048576\n    outbuf_high_watermark = 1048576\n    inbuf_overflow = 512000\n    cleanup_interval = 900\n    url_scheme = \"http\"\n    channel_timeout = 300\n    log_socket_errors = True\n    recv_bytes = 8192\n    send_bytes = 1\n    expose_tracebacks = True\n    ident = \"waitress\"\n    max_request_header_size = 10000\n\n\nclass DummyServer(object):\n    trigger_pulled = False\n    adj = DummyAdjustments()\n\n    def __init__(self):\n        self.tasks = []\n        self.active_channels = {}\n\n    def add_task(self, task):\n        self.tasks.append(task)\n\n    def pull_trigger(self):\n        self.trigger_pulled = True\n\n\nclass DummyParser(object):\n    version = 1\n    data = None\n    completed = True\n    empty = False\n    headers_finished = False\n    expect_continue = False\n    retval = None\n    error = None\n    connection_close = False\n\n    def received(self, data):\n        self.data = data\n        if self.retval is not None:\n            return self.retval\n        return len(data)\n\n\nclass DummyRequest(object):\n    error = None\n    path = \"/\"\n    version = \"1.0\"\n    closed = False\n\n    def __init__(self):\n        self.headers = {}\n\n    def close(self):\n        self.closed = True\n\n\nclass DummyLogger(object):\n    def __init__(self):\n        self.exceptions = []\n        self.infos = []\n        self.warnings = []\n\n    def info(self, msg):\n        self.infos.append(msg)\n\n    def exception(self, msg):\n        self.exceptions.append(msg)\n\n\nclass DummyError(object):\n    code = \"431\"\n    reason = \"Bleh\"\n    body = \"My body\"\n\n\nclass DummyTaskClass(object):\n    wrote_header = True\n    close_on_finish = False\n    serviced = False\n\n    def __init__(self, toraise=None):\n        self.toraise = toraise\n\n    def __call__(self, channel, request):\n        self.request = request\n        return self\n\n    def service(self):\n        self.serviced = True\n        self.request.serviced = True\n        if self.toraise:\n            raise self.toraise\n", "import errno\nimport logging\nimport multiprocessing\nimport os\nimport signal\nimport socket\nimport string\nimport subprocess\nimport sys\nimport time\nimport unittest\nfrom waitress import server\nfrom waitress.compat import httplib, tobytes\nfrom waitress.utilities import cleanup_unix_socket\n\ndn = os.path.dirname\nhere = dn(__file__)\n\n\nclass NullHandler(logging.Handler):  # pragma: no cover\n    \"\"\"A logging handler that swallows all emitted messages.\n    \"\"\"\n\n    def emit(self, record):\n        pass\n\n\ndef start_server(app, svr, queue, **kwargs):  # pragma: no cover\n    \"\"\"Run a fixture application.\n    \"\"\"\n    logging.getLogger(\"waitress\").addHandler(NullHandler())\n    try_register_coverage()\n    svr(app, queue, **kwargs).run()\n\n\ndef try_register_coverage():  # pragma: no cover\n    # Hack around multiprocessing exiting early and not triggering coverage's\n    # atexit handler by always registering a signal handler\n\n    if \"COVERAGE_PROCESS_START\" in os.environ:\n        def sigterm(*args):\n            sys.exit(0)\n\n        signal.signal(signal.SIGTERM, sigterm)\n\n\nclass FixtureTcpWSGIServer(server.TcpWSGIServer):\n    \"\"\"A version of TcpWSGIServer that relays back what it's bound to.\n    \"\"\"\n\n    family = socket.AF_INET  # Testing\n\n    def __init__(self, application, queue, **kw):  # pragma: no cover\n        # Coverage doesn't see this as it's ran in a separate process.\n        kw[\"port\"] = 0  # Bind to any available port.\n        super(FixtureTcpWSGIServer, self).__init__(application, **kw)\n        host, port = self.socket.getsockname()\n        if os.name == \"nt\":\n            host = \"127.0.0.1\"\n        queue.put((host, port))\n\n\nclass SubprocessTests(object):\n\n    # For nose: all tests may be ran in separate processes.\n    _multiprocess_can_split_ = True\n\n    exe = sys.executable\n\n    server = None\n\n    def start_subprocess(self, target, **kw):\n        # Spawn a server process.\n        self.queue = multiprocessing.Queue()\n\n        if \"COVERAGE_RCFILE\" in os.environ:\n            os.environ[\"COVERAGE_PROCESS_START\"] = os.environ[\"COVERAGE_RCFILE\"]\n\n        self.proc = multiprocessing.Process(\n            target=start_server, args=(target, self.server, self.queue), kwargs=kw,\n        )\n        self.proc.start()\n\n        if self.proc.exitcode is not None:  # pragma: no cover\n            raise RuntimeError(\"%s didn't start\" % str(target))\n        # Get the socket the server is listening on.\n        self.bound_to = self.queue.get(timeout=5)\n        self.sock = self.create_socket()\n\n    def stop_subprocess(self):\n        if self.proc.exitcode is None:\n            self.proc.terminate()\n        self.sock.close()\n        # This give us one FD back ...\n        self.queue.close()\n        self.proc.join()\n\n    def assertline(self, line, status, reason, version):\n        v, s, r = (x.strip() for x in line.split(None, 2))\n        self.assertEqual(s, tobytes(status))\n        self.assertEqual(r, tobytes(reason))\n        self.assertEqual(v, tobytes(version))\n\n    def create_socket(self):\n        return socket.socket(self.server.family, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.sock.connect(self.bound_to)\n\n    def make_http_connection(self):\n        raise NotImplementedError  # pragma: no cover\n\n    def send_check_error(self, to_send):\n        self.sock.send(to_send)\n\n\nclass TcpTests(SubprocessTests):\n\n    server = FixtureTcpWSGIServer\n\n    def make_http_connection(self):\n        return httplib.HTTPConnection(*self.bound_to)\n\n\nclass SleepyThreadTests(TcpTests, unittest.TestCase):\n    # test that sleepy thread doesnt block other requests\n\n    def setUp(self):\n        from waitress.tests.fixtureapps import sleepy\n\n        self.start_subprocess(sleepy.app)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_it(self):\n        getline = os.path.join(here, \"fixtureapps\", \"getline.py\")\n        cmds = (\n            [self.exe, getline, \"http://%s:%d/sleepy\" % self.bound_to],\n            [self.exe, getline, \"http://%s:%d/\" % self.bound_to],\n        )\n        r, w = os.pipe()\n        procs = []\n        for cmd in cmds:\n            procs.append(subprocess.Popen(cmd, stdout=w))\n        time.sleep(3)\n        for proc in procs:\n            if proc.returncode is not None:  # pragma: no cover\n                proc.terminate()\n            proc.wait()\n        # the notsleepy response should always be first returned (it sleeps\n        # for 2 seconds, then returns; the notsleepy response should be\n        # processed in the meantime)\n        result = os.read(r, 10000)\n        os.close(r)\n        os.close(w)\n        self.assertEqual(result, b\"notsleepy returnedsleepy returned\")\n\n\nclass EchoTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import echo\n\n        self.start_subprocess(\n            echo.app,\n            trusted_proxy=\"*\",\n            trusted_proxy_count=1,\n            trusted_proxy_headers={\"x-forwarded-for\", \"x-forwarded-proto\"},\n            clear_untrusted_proxy_headers=True,\n        )\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def _read_echo(self, fp):\n        from waitress.tests.fixtureapps import echo\n\n        line, headers, body = read_http(fp)\n        return line, headers, echo.parse_response(body)\n\n    def test_date_and_server(self):\n        to_send = \"GET / HTTP/1.0\\r\\nContent-Length: 0\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(headers.get(\"server\"), \"waitress\")\n        self.assertTrue(headers.get(\"date\"))\n\n    def test_bad_host_header(self):\n        # https://corte.si/posts/code/pathod/pythonservers/index.html\n        to_send = \"GET / HTTP/1.0\\r\\n Host: 0\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"400\", \"Bad Request\", \"HTTP/1.0\")\n        self.assertEqual(headers.get(\"server\"), \"waitress\")\n        self.assertTrue(headers.get(\"date\"))\n\n    def test_send_with_body(self):\n        to_send = \"GET / HTTP/1.0\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n        to_send += \"hello\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(echo.content_length, \"5\")\n        self.assertEqual(echo.body, b\"hello\")\n\n    def test_send_empty_body(self):\n        to_send = \"GET / HTTP/1.0\\r\\nContent-Length: 0\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(echo.content_length, \"0\")\n        self.assertEqual(echo.body, b\"\")\n\n    def test_multiple_requests_with_body(self):\n        orig_sock = self.sock\n        for x in range(3):\n            self.sock = self.create_socket()\n            self.test_send_with_body()\n            self.sock.close()\n        self.sock = orig_sock\n\n    def test_multiple_requests_without_body(self):\n        orig_sock = self.sock\n        for x in range(3):\n            self.sock = self.create_socket()\n            self.test_send_empty_body()\n            self.sock.close()\n        self.sock = orig_sock\n\n    def test_without_crlf(self):\n        data = \"Echo\\r\\nthis\\r\\nplease\"\n        s = tobytes(\n            \"GET / HTTP/1.0\\r\\n\"\n            \"Connection: close\\r\\n\"\n            \"Content-Length: %d\\r\\n\"\n            \"\\r\\n\"\n            \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(int(echo.content_length), len(data))\n        self.assertEqual(len(echo.body), len(data))\n        self.assertEqual(echo.body, tobytes(data))\n\n    def test_large_body(self):\n        # 1024 characters.\n        body = \"This string has 32 characters.\\r\\n\" * 32\n        s = tobytes(\n            \"GET / HTTP/1.0\\r\\nContent-Length: %d\\r\\n\\r\\n%s\" % (len(body), body)\n        )\n        self.connect()\n        self.sock.send(s)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(echo.content_length, \"1024\")\n        self.assertEqual(echo.body, tobytes(body))\n\n    def test_many_clients(self):\n        conns = []\n        for n in range(50):\n            h = self.make_http_connection()\n            h.request(\"GET\", \"/\", headers={\"Accept\": \"text/plain\"})\n            conns.append(h)\n        responses = []\n        for h in conns:\n            response = h.getresponse()\n            self.assertEqual(response.status, 200)\n            responses.append(response)\n        for response in responses:\n            response.read()\n        for h in conns:\n            h.close()\n\n    def test_chunking_request_without_content(self):\n        header = tobytes(\"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\")\n        self.connect()\n        self.sock.send(header)\n        self.sock.send(b\"0\\r\\n\\r\\n\")\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        self.assertEqual(echo.body, b\"\")\n        self.assertEqual(echo.content_length, \"0\")\n        self.assertFalse(\"transfer-encoding\" in headers)\n\n    def test_chunking_request_with_content(self):\n        control_line = b\"20;\\r\\n\"  # 20 hex = 32 dec\n        s = b\"This string has 32 characters.\\r\\n\"\n        expected = s * 12\n        header = tobytes(\"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\")\n        self.connect()\n        self.sock.send(header)\n        fp = self.sock.makefile(\"rb\", 0)\n        for n in range(12):\n            self.sock.send(control_line)\n            self.sock.send(s)\n            self.sock.send(b\"\\r\\n\")  # End the chunk\n        self.sock.send(b\"0\\r\\n\\r\\n\")\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        self.assertEqual(echo.body, expected)\n        self.assertEqual(echo.content_length, str(len(expected)))\n        self.assertFalse(\"transfer-encoding\" in headers)\n\n    def test_broken_chunked_encoding(self):\n        control_line = \"20;\\r\\n\"  # 20 hex = 32 dec\n        s = \"This string has 32 characters.\\r\\n\"\n        to_send = \"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n        to_send += control_line + s + \"\\r\\n\"\n        # garbage in input\n        to_send += \"garbage\\r\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # receiver caught garbage and turned it into a 400\n        self.assertline(line, \"400\", \"Bad Request\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertEqual(\n            sorted(headers.keys()), [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"]\n        )\n        self.assertEqual(headers[\"content-type\"], \"text/plain\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_broken_chunked_encoding_missing_chunk_end(self):\n        control_line = \"20;\\r\\n\"  # 20 hex = 32 dec\n        s = \"This string has 32 characters.\\r\\n\"\n        to_send = \"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n        to_send += control_line + s\n        # garbage in input\n        to_send += \"garbage\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # receiver caught garbage and turned it into a 400\n        self.assertline(line, \"400\", \"Bad Request\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(b\"Chunk not properly terminated\" in response_body)\n        self.assertEqual(\n            sorted(headers.keys()), [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"]\n        )\n        self.assertEqual(headers[\"content-type\"], \"text/plain\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_keepalive_http_10(self):\n        # Handling of Keep-Alive within HTTP 1.0\n        data = \"Default: Don't keep me alive\"\n        s = tobytes(\n            \"GET / HTTP/1.0\\r\\nContent-Length: %d\\r\\n\\r\\n%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        response = httplib.HTTPResponse(self.sock)\n        response.begin()\n        self.assertEqual(int(response.status), 200)\n        connection = response.getheader(\"Connection\", \"\")\n        # We sent no Connection: Keep-Alive header\n        # Connection: close (or no header) is default.\n        self.assertTrue(connection != \"Keep-Alive\")\n\n    def test_keepalive_http10_explicit(self):\n        # If header Connection: Keep-Alive is explicitly sent,\n        # we want to keept the connection open, we also need to return\n        # the corresponding header\n        data = \"Keep me alive\"\n        s = tobytes(\n            \"GET / HTTP/1.0\\r\\n\"\n            \"Connection: Keep-Alive\\r\\n\"\n            \"Content-Length: %d\\r\\n\"\n            \"\\r\\n\"\n            \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        response = httplib.HTTPResponse(self.sock)\n        response.begin()\n        self.assertEqual(int(response.status), 200)\n        connection = response.getheader(\"Connection\", \"\")\n        self.assertEqual(connection, \"Keep-Alive\")\n\n    def test_keepalive_http_11(self):\n        # Handling of Keep-Alive within HTTP 1.1\n\n        # All connections are kept alive, unless stated otherwise\n        data = \"Default: Keep me alive\"\n        s = tobytes(\n            \"GET / HTTP/1.1\\r\\nContent-Length: %d\\r\\n\\r\\n%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        response = httplib.HTTPResponse(self.sock)\n        response.begin()\n        self.assertEqual(int(response.status), 200)\n        self.assertTrue(response.getheader(\"connection\") != \"close\")\n\n    def test_keepalive_http11_explicit(self):\n        # Explicitly set keep-alive\n        data = \"Default: Keep me alive\"\n        s = tobytes(\n            \"GET / HTTP/1.1\\r\\n\"\n            \"Connection: keep-alive\\r\\n\"\n            \"Content-Length: %d\\r\\n\"\n            \"\\r\\n\"\n            \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        response = httplib.HTTPResponse(self.sock)\n        response.begin()\n        self.assertEqual(int(response.status), 200)\n        self.assertTrue(response.getheader(\"connection\") != \"close\")\n\n    def test_keepalive_http11_connclose(self):\n        # specifying Connection: close explicitly\n        data = \"Don't keep me alive\"\n        s = tobytes(\n            \"GET / HTTP/1.1\\r\\n\"\n            \"Connection: close\\r\\n\"\n            \"Content-Length: %d\\r\\n\"\n            \"\\r\\n\"\n            \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(s)\n        response = httplib.HTTPResponse(self.sock)\n        response.begin()\n        self.assertEqual(int(response.status), 200)\n        self.assertEqual(response.getheader(\"connection\"), \"close\")\n\n    def test_proxy_headers(self):\n        to_send = (\n            \"GET / HTTP/1.0\\r\\n\"\n            \"Content-Length: 0\\r\\n\"\n            \"Host: www.google.com:8080\\r\\n\"\n            \"X-Forwarded-For: 192.168.1.1\\r\\n\"\n            \"X-Forwarded-Proto: https\\r\\n\"\n            \"X-Forwarded-Port: 5000\\r\\n\\r\\n\"\n        )\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, echo = self._read_echo(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(headers.get(\"server\"), \"waitress\")\n        self.assertTrue(headers.get(\"date\"))\n        self.assertIsNone(echo.headers.get(\"X_FORWARDED_PORT\"))\n        self.assertEqual(echo.headers[\"HOST\"], \"www.google.com:8080\")\n        self.assertEqual(echo.scheme, \"https\")\n        self.assertEqual(echo.remote_addr, \"192.168.1.1\")\n        self.assertEqual(echo.remote_host, \"192.168.1.1\")\n\n\nclass PipeliningTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import echo\n\n        self.start_subprocess(echo.app_body_only)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_pipelining(self):\n        s = (\n            \"GET / HTTP/1.0\\r\\n\"\n            \"Connection: %s\\r\\n\"\n            \"Content-Length: %d\\r\\n\"\n            \"\\r\\n\"\n            \"%s\"\n        )\n        to_send = b\"\"\n        count = 25\n        for n in range(count):\n            body = \"Response #%d\\r\\n\" % (n + 1)\n            if n + 1 < count:\n                conn = \"keep-alive\"\n            else:\n                conn = \"close\"\n            to_send += tobytes(s % (conn, len(body), body))\n\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        for n in range(count):\n            expect_body = tobytes(\"Response #%d\\r\\n\" % (n + 1))\n            line = fp.readline()  # status line\n            version, status, reason = (x.strip() for x in line.split(None, 2))\n            headers = parse_headers(fp)\n            length = int(headers.get(\"content-length\")) or None\n            response_body = fp.read(length)\n            self.assertEqual(int(status), 200)\n            self.assertEqual(length, len(response_body))\n            self.assertEqual(response_body, expect_body)\n\n\nclass ExpectContinueTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import echo\n\n        self.start_subprocess(echo.app_body_only)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_expect_continue(self):\n        # specifying Connection: close explicitly\n        data = \"I have expectations\"\n        to_send = tobytes(\n            \"GET / HTTP/1.1\\r\\n\"\n            \"Connection: close\\r\\n\"\n            \"Content-Length: %d\\r\\n\"\n            \"Expect: 100-continue\\r\\n\"\n            \"\\r\\n\"\n            \"%s\" % (len(data), data)\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line = fp.readline()  # continue status line\n        version, status, reason = (x.strip() for x in line.split(None, 2))\n        self.assertEqual(int(status), 100)\n        self.assertEqual(reason, b\"Continue\")\n        self.assertEqual(version, b\"HTTP/1.1\")\n        fp.readline()  # blank line\n        line = fp.readline()  # next status line\n        version, status, reason = (x.strip() for x in line.split(None, 2))\n        headers = parse_headers(fp)\n        length = int(headers.get(\"content-length\")) or None\n        response_body = fp.read(length)\n        self.assertEqual(int(status), 200)\n        self.assertEqual(length, len(response_body))\n        self.assertEqual(response_body, tobytes(data))\n\n\nclass BadContentLengthTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import badcl\n\n        self.start_subprocess(badcl.app)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_short_body(self):\n        # check to see if server closes connection when body is too short\n        # for cl header\n        to_send = tobytes(\n            \"GET /short_body HTTP/1.0\\r\\n\"\n            \"Connection: Keep-Alive\\r\\n\"\n            \"Content-Length: 0\\r\\n\"\n            \"\\r\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line = fp.readline()  # status line\n        version, status, reason = (x.strip() for x in line.split(None, 2))\n        headers = parse_headers(fp)\n        content_length = int(headers.get(\"content-length\"))\n        response_body = fp.read(content_length)\n        self.assertEqual(int(status), 200)\n        self.assertNotEqual(content_length, len(response_body))\n        self.assertEqual(len(response_body), content_length - 1)\n        self.assertEqual(response_body, tobytes(\"abcdefghi\"))\n        # remote closed connection (despite keepalive header); not sure why\n        # first send succeeds\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_long_body(self):\n        # check server doesnt close connection when body is too short\n        # for cl header\n        to_send = tobytes(\n            \"GET /long_body HTTP/1.0\\r\\n\"\n            \"Connection: Keep-Alive\\r\\n\"\n            \"Content-Length: 0\\r\\n\"\n            \"\\r\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line = fp.readline()  # status line\n        version, status, reason = (x.strip() for x in line.split(None, 2))\n        headers = parse_headers(fp)\n        content_length = int(headers.get(\"content-length\")) or None\n        response_body = fp.read(content_length)\n        self.assertEqual(int(status), 200)\n        self.assertEqual(content_length, len(response_body))\n        self.assertEqual(response_body, tobytes(\"abcdefgh\"))\n        # remote does not close connection (keepalive header)\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line = fp.readline()  # status line\n        version, status, reason = (x.strip() for x in line.split(None, 2))\n        headers = parse_headers(fp)\n        content_length = int(headers.get(\"content-length\")) or None\n        response_body = fp.read(content_length)\n        self.assertEqual(int(status), 200)\n\n\nclass NoContentLengthTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import nocl\n\n        self.start_subprocess(nocl.app)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_http10_generator(self):\n        body = string.ascii_letters\n        to_send = (\n            \"GET / HTTP/1.0\\r\\n\"\n            \"Connection: Keep-Alive\\r\\n\"\n            \"Content-Length: %d\\r\\n\\r\\n\" % len(body)\n        )\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(headers.get(\"content-length\"), None)\n        self.assertEqual(headers.get(\"connection\"), \"close\")\n        self.assertEqual(response_body, tobytes(body))\n        # remote closed connection (despite keepalive header), because\n        # generators cannot have a content-length divined\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_http10_list(self):\n        body = string.ascii_letters\n        to_send = (\n            \"GET /list HTTP/1.0\\r\\n\"\n            \"Connection: Keep-Alive\\r\\n\"\n            \"Content-Length: %d\\r\\n\\r\\n\" % len(body)\n        )\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(headers[\"content-length\"], str(len(body)))\n        self.assertEqual(headers.get(\"connection\"), \"Keep-Alive\")\n        self.assertEqual(response_body, tobytes(body))\n        # remote keeps connection open because it divined the content length\n        # from a length-1 list\n        self.sock.send(to_send)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n\n    def test_http10_listlentwo(self):\n        body = string.ascii_letters\n        to_send = (\n            \"GET /list_lentwo HTTP/1.0\\r\\n\"\n            \"Connection: Keep-Alive\\r\\n\"\n            \"Content-Length: %d\\r\\n\\r\\n\" % len(body)\n        )\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(headers.get(\"content-length\"), None)\n        self.assertEqual(headers.get(\"connection\"), \"close\")\n        self.assertEqual(response_body, tobytes(body))\n        # remote closed connection (despite keepalive header), because\n        # lists of length > 1 cannot have their content length divined\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_http11_generator(self):\n        body = string.ascii_letters\n        to_send = \"GET / HTTP/1.1\\r\\nContent-Length: %s\\r\\n\\r\\n\" % len(body)\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        expected = b\"\"\n        for chunk in chunks(body, 10):\n            expected += tobytes(\n                \"%s\\r\\n%s\\r\\n\" % (str(hex(len(chunk))[2:].upper()), chunk)\n            )\n        expected += b\"0\\r\\n\\r\\n\"\n        self.assertEqual(response_body, expected)\n        # connection is always closed at the end of a chunked response\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_http11_list(self):\n        body = string.ascii_letters\n        to_send = \"GET /list HTTP/1.1\\r\\nContent-Length: %d\\r\\n\\r\\n\" % len(body)\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        self.assertEqual(headers[\"content-length\"], str(len(body)))\n        self.assertEqual(response_body, tobytes(body))\n        # remote keeps connection open because it divined the content length\n        # from a length-1 list\n        self.sock.send(to_send)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n\n    def test_http11_listlentwo(self):\n        body = string.ascii_letters\n        to_send = \"GET /list_lentwo HTTP/1.1\\r\\nContent-Length: %s\\r\\n\\r\\n\" % len(body)\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        expected = b\"\"\n        for chunk in (body[0], body[1:]):\n            expected += tobytes(\n                \"%s\\r\\n%s\\r\\n\" % (str(hex(len(chunk))[2:].upper()), chunk)\n            )\n        expected += b\"0\\r\\n\\r\\n\"\n        self.assertEqual(response_body, expected)\n        # connection is always closed at the end of a chunked response\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n\nclass WriteCallbackTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import writecb\n\n        self.start_subprocess(writecb.app)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_short_body(self):\n        # check to see if server closes connection when body is too short\n        # for cl header\n        to_send = tobytes(\n            \"GET /short_body HTTP/1.0\\r\\n\"\n            \"Connection: Keep-Alive\\r\\n\"\n            \"Content-Length: 0\\r\\n\"\n            \"\\r\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # server trusts the content-length header (5)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, 9)\n        self.assertNotEqual(cl, len(response_body))\n        self.assertEqual(len(response_body), cl - 1)\n        self.assertEqual(response_body, tobytes(\"abcdefgh\"))\n        # remote closed connection (despite keepalive header)\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_long_body(self):\n        # check server doesnt close connection when body is too long\n        # for cl header\n        to_send = tobytes(\n            \"GET /long_body HTTP/1.0\\r\\n\"\n            \"Connection: Keep-Alive\\r\\n\"\n            \"Content-Length: 0\\r\\n\"\n            \"\\r\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        content_length = int(headers.get(\"content-length\")) or None\n        self.assertEqual(content_length, 9)\n        self.assertEqual(content_length, len(response_body))\n        self.assertEqual(response_body, tobytes(\"abcdefghi\"))\n        # remote does not close connection (keepalive header)\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n\n    def test_equal_body(self):\n        # check server doesnt close connection when body is equal to\n        # cl header\n        to_send = tobytes(\n            \"GET /equal_body HTTP/1.0\\r\\n\"\n            \"Connection: Keep-Alive\\r\\n\"\n            \"Content-Length: 0\\r\\n\"\n            \"\\r\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        content_length = int(headers.get(\"content-length\")) or None\n        self.assertEqual(content_length, 9)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        self.assertEqual(content_length, len(response_body))\n        self.assertEqual(response_body, tobytes(\"abcdefghi\"))\n        # remote does not close connection (keepalive header)\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n\n    def test_no_content_length(self):\n        # wtf happens when there's no content-length\n        to_send = tobytes(\n            \"GET /no_content_length HTTP/1.0\\r\\n\"\n            \"Connection: Keep-Alive\\r\\n\"\n            \"Content-Length: 0\\r\\n\"\n            \"\\r\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line = fp.readline()  # status line\n        line, headers, response_body = read_http(fp)\n        content_length = headers.get(\"content-length\")\n        self.assertEqual(content_length, None)\n        self.assertEqual(response_body, tobytes(\"abcdefghi\"))\n        # remote closed connection (despite keepalive header)\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n\nclass TooLargeTests(object):\n\n    toobig = 1050\n\n    def setUp(self):\n        from waitress.tests.fixtureapps import toolarge\n\n        self.start_subprocess(\n            toolarge.app, max_request_header_size=1000, max_request_body_size=1000\n        )\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_request_body_too_large_with_wrong_cl_http10(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.0\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        # first request succeeds (content-length 5)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # server trusts the content-length header; no pipelining,\n        # so request fulfilled, extra bytes are thrown away\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_wrong_cl_http10_keepalive(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.0\\r\\nContent-Length: 5\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        # first request succeeds (content-length 5)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"431\", \"Request Header Fields Too Large\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_no_cl_http10(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.0\\r\\n\\r\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # extra bytes are thrown away (no pipelining), connection closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_no_cl_http10_keepalive(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.0\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # server trusts the content-length header (assumed zero)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        line, headers, response_body = read_http(fp)\n        # next response overruns because the extra data appears to be\n        # header data\n        self.assertline(line, \"431\", \"Request Header Fields Too Large\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_wrong_cl_http11(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.1\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        # first request succeeds (content-length 5)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # second response is an error response\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"431\", \"Request Header Fields Too Large\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_wrong_cl_http11_connclose(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.1\\r\\nContent-Length: 5\\r\\nConnection: close\\r\\n\\r\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # server trusts the content-length header (5)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_no_cl_http11(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.1\\r\\n\\r\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\")\n        # server trusts the content-length header (assumed 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # server assumes pipelined requests due to http/1.1, and the first\n        # request was assumed c-l 0 because it had no content-length header,\n        # so entire body looks like the header of the subsequent request\n        # second response is an error response\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"431\", \"Request Header Fields Too Large\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_with_no_cl_http11_connclose(self):\n        body = \"a\" * self.toobig\n        to_send = \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n        to_send += body\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # server trusts the content-length header (assumed 0)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_request_body_too_large_chunked_encoding(self):\n        control_line = \"20;\\r\\n\"  # 20 hex = 32 dec\n        s = \"This string has 32 characters.\\r\\n\"\n        to_send = \"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n        repeat = control_line + s\n        to_send += repeat * ((self.toobig // len(repeat)) + 1)\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        # body bytes counter caught a max_request_body_size overrun\n        self.assertline(line, \"413\", \"Request Entity Too Large\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertEqual(headers[\"content-type\"], \"text/plain\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n\nclass InternalServerErrorTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import error\n\n        self.start_subprocess(error.app, expose_tracebacks=True)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_before_start_response_http_10(self):\n        to_send = \"GET /before_start_response HTTP/1.0\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(headers[\"connection\"], \"close\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_before_start_response_http_11(self):\n        to_send = \"GET /before_start_response HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(\n            sorted(headers.keys()), [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"]\n        )\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_before_start_response_http_11_close(self):\n        to_send = tobytes(\n            \"GET /before_start_response HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(\n            sorted(headers.keys()),\n            [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"],\n        )\n        self.assertEqual(headers[\"connection\"], \"close\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_after_start_response_http10(self):\n        to_send = \"GET /after_start_response HTTP/1.0\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(\n            sorted(headers.keys()),\n            [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"],\n        )\n        self.assertEqual(headers[\"connection\"], \"close\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_after_start_response_http11(self):\n        to_send = \"GET /after_start_response HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(\n            sorted(headers.keys()), [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"]\n        )\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_after_start_response_http11_close(self):\n        to_send = tobytes(\n            \"GET /after_start_response HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n        )\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"500\", \"Internal Server Error\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        self.assertTrue(response_body.startswith(b\"Internal Server Error\"))\n        self.assertEqual(\n            sorted(headers.keys()),\n            [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"],\n        )\n        self.assertEqual(headers[\"connection\"], \"close\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_after_write_cb(self):\n        to_send = \"GET /after_write_cb HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        self.assertEqual(response_body, b\"\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_in_generator(self):\n        to_send = \"GET /in_generator HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n        self.connect()\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        self.assertEqual(response_body, b\"\")\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n\nclass FileWrapperTests(object):\n    def setUp(self):\n        from waitress.tests.fixtureapps import filewrapper\n\n        self.start_subprocess(filewrapper.app)\n\n    def tearDown(self):\n        self.stop_subprocess()\n\n    def test_filelike_http11(self):\n        to_send = \"GET /filelike HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\\330\\377\" in response_body)\n            # connection has not been closed\n\n    def test_filelike_nocl_http11(self):\n        to_send = \"GET /filelike_nocl HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\\330\\377\" in response_body)\n            # connection has not been closed\n\n    def test_filelike_shortcl_http11(self):\n        to_send = \"GET /filelike_shortcl HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, 1)\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\" in response_body)\n            # connection has not been closed\n\n    def test_filelike_longcl_http11(self):\n        to_send = \"GET /filelike_longcl HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\\330\\377\" in response_body)\n            # connection has not been closed\n\n    def test_notfilelike_http11(self):\n        to_send = \"GET /notfilelike HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\\330\\377\" in response_body)\n            # connection has not been closed\n\n    def test_notfilelike_iobase_http11(self):\n        to_send = \"GET /notfilelike_iobase HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\\330\\377\" in response_body)\n            # connection has not been closed\n\n    def test_notfilelike_nocl_http11(self):\n        to_send = \"GET /notfilelike_nocl HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed (no content-length)\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_notfilelike_shortcl_http11(self):\n        to_send = \"GET /notfilelike_shortcl HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        for t in range(0, 2):\n            self.sock.send(to_send)\n            fp = self.sock.makefile(\"rb\", 0)\n            line, headers, response_body = read_http(fp)\n            self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n            cl = int(headers[\"content-length\"])\n            self.assertEqual(cl, 1)\n            self.assertEqual(cl, len(response_body))\n            ct = headers[\"content-type\"]\n            self.assertEqual(ct, \"image/jpeg\")\n            self.assertTrue(b\"\\377\" in response_body)\n            # connection has not been closed\n\n    def test_notfilelike_longcl_http11(self):\n        to_send = \"GET /notfilelike_longcl HTTP/1.1\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body) + 10)\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_filelike_http10(self):\n        to_send = \"GET /filelike HTTP/1.0\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_filelike_nocl_http10(self):\n        to_send = \"GET /filelike_nocl HTTP/1.0\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_notfilelike_http10(self):\n        to_send = \"GET /notfilelike HTTP/1.0\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        cl = int(headers[\"content-length\"])\n        self.assertEqual(cl, len(response_body))\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n    def test_notfilelike_nocl_http10(self):\n        to_send = \"GET /notfilelike_nocl HTTP/1.0\\r\\n\\r\\n\"\n        to_send = tobytes(to_send)\n\n        self.connect()\n\n        self.sock.send(to_send)\n        fp = self.sock.makefile(\"rb\", 0)\n        line, headers, response_body = read_http(fp)\n        self.assertline(line, \"200\", \"OK\", \"HTTP/1.0\")\n        ct = headers[\"content-type\"]\n        self.assertEqual(ct, \"image/jpeg\")\n        self.assertTrue(b\"\\377\\330\\377\" in response_body)\n        # connection has been closed (no content-length)\n        self.send_check_error(to_send)\n        self.assertRaises(ConnectionClosed, read_http, fp)\n\n\nclass TcpEchoTests(EchoTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpPipeliningTests(PipeliningTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpExpectContinueTests(ExpectContinueTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpBadContentLengthTests(BadContentLengthTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpNoContentLengthTests(NoContentLengthTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpWriteCallbackTests(WriteCallbackTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpTooLargeTests(TooLargeTests, TcpTests, unittest.TestCase):\n    pass\n\n\nclass TcpInternalServerErrorTests(\n    InternalServerErrorTests, TcpTests, unittest.TestCase\n):\n    pass\n\n\nclass TcpFileWrapperTests(FileWrapperTests, TcpTests, unittest.TestCase):\n    pass\n\n\nif hasattr(socket, \"AF_UNIX\"):\n\n    class FixtureUnixWSGIServer(server.UnixWSGIServer):\n        \"\"\"A version of UnixWSGIServer that relays back what it's bound to.\n        \"\"\"\n\n        family = socket.AF_UNIX  # Testing\n\n        def __init__(self, application, queue, **kw):  # pragma: no cover\n            # Coverage doesn't see this as it's ran in a separate process.\n            # To permit parallel testing, use a PID-dependent socket.\n            kw[\"unix_socket\"] = \"/tmp/waitress.test-%d.sock\" % os.getpid()\n            super(FixtureUnixWSGIServer, self).__init__(application, **kw)\n            queue.put(self.socket.getsockname())\n\n    class UnixTests(SubprocessTests):\n\n        server = FixtureUnixWSGIServer\n\n        def make_http_connection(self):\n            return UnixHTTPConnection(self.bound_to)\n\n        def stop_subprocess(self):\n            super(UnixTests, self).stop_subprocess()\n            cleanup_unix_socket(self.bound_to)\n\n        def send_check_error(self, to_send):\n            # Unlike inet domain sockets, Unix domain sockets can trigger a\n            # 'Broken pipe' error when the socket it closed.\n            try:\n                self.sock.send(to_send)\n            except socket.error as exc:\n                self.assertEqual(get_errno(exc), errno.EPIPE)\n\n    class UnixEchoTests(EchoTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixPipeliningTests(PipeliningTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixExpectContinueTests(ExpectContinueTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixBadContentLengthTests(\n        BadContentLengthTests, UnixTests, unittest.TestCase\n    ):\n        pass\n\n    class UnixNoContentLengthTests(NoContentLengthTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixWriteCallbackTests(WriteCallbackTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixTooLargeTests(TooLargeTests, UnixTests, unittest.TestCase):\n        pass\n\n    class UnixInternalServerErrorTests(\n        InternalServerErrorTests, UnixTests, unittest.TestCase\n    ):\n        pass\n\n    class UnixFileWrapperTests(FileWrapperTests, UnixTests, unittest.TestCase):\n        pass\n\n\ndef parse_headers(fp):\n    \"\"\"Parses only RFC2822 headers from a file pointer.\n    \"\"\"\n    headers = {}\n    while True:\n        line = fp.readline()\n        if line in (b\"\\r\\n\", b\"\\n\", b\"\"):\n            break\n        line = line.decode(\"iso-8859-1\")\n        name, value = line.strip().split(\":\", 1)\n        headers[name.lower().strip()] = value.lower().strip()\n    return headers\n\n\nclass UnixHTTPConnection(httplib.HTTPConnection):\n    \"\"\"Patched version of HTTPConnection that uses Unix domain sockets.\n    \"\"\"\n\n    def __init__(self, path):\n        httplib.HTTPConnection.__init__(self, \"localhost\")\n        self.path = path\n\n    def connect(self):\n        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        sock.connect(self.path)\n        self.sock = sock\n\n\nclass ConnectionClosed(Exception):\n    pass\n\n\n# stolen from gevent\ndef read_http(fp):  # pragma: no cover\n    try:\n        response_line = fp.readline()\n    except socket.error as exc:\n        fp.close()\n        # errno 104 is ENOTRECOVERABLE, In WinSock 10054 is ECONNRESET\n        if get_errno(exc) in (errno.ECONNABORTED, errno.ECONNRESET, 104, 10054):\n            raise ConnectionClosed\n        raise\n    if not response_line:\n        raise ConnectionClosed\n\n    header_lines = []\n    while True:\n        line = fp.readline()\n        if line in (b\"\\r\\n\", b\"\\r\\n\", b\"\"):\n            break\n        else:\n            header_lines.append(line)\n    headers = dict()\n    for x in header_lines:\n        x = x.strip()\n        if not x:\n            continue\n        key, value = x.split(b\": \", 1)\n        key = key.decode(\"iso-8859-1\").lower()\n        value = value.decode(\"iso-8859-1\")\n        assert key not in headers, \"%s header duplicated\" % key\n        headers[key] = value\n\n    if \"content-length\" in headers:\n        num = int(headers[\"content-length\"])\n        body = b\"\"\n        left = num\n        while left > 0:\n            data = fp.read(left)\n            if not data:\n                break\n            body += data\n            left -= len(data)\n    else:\n        # read until EOF\n        body = fp.read()\n\n    return response_line, headers, body\n\n\n# stolen from gevent\ndef get_errno(exc):  # pragma: no cover\n    \"\"\" Get the error code out of socket.error objects.\n    socket.error in <2.5 does not have errno attribute\n    socket.error in 3.x does not allow indexing access\n    e.args[0] works for all.\n    There are cases when args[0] is not errno.\n    i.e. http://bugs.python.org/issue6471\n    Maybe there are cases when errno is set, but it is not the first argument?\n    \"\"\"\n    try:\n        if exc.errno is not None:\n            return exc.errno\n    except AttributeError:\n        pass\n    try:\n        return exc.args[0]\n    except IndexError:\n        return None\n\n\ndef chunks(l, n):\n    \"\"\" Yield successive n-sized chunks from l.\n    \"\"\"\n    for i in range(0, len(l), n):\n        yield l[i : i + n]\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"HTTP Request Parser tests\n\"\"\"\nimport unittest\n\nfrom waitress.compat import text_, tobytes\n\n\nclass TestHTTPRequestParser(unittest.TestCase):\n    def setUp(self):\n        from waitress.parser import HTTPRequestParser\n        from waitress.adjustments import Adjustments\n\n        my_adj = Adjustments()\n        self.parser = HTTPRequestParser(my_adj)\n\n    def test_get_body_stream_None(self):\n        self.parser.body_recv = None\n        result = self.parser.get_body_stream()\n        self.assertEqual(result.getvalue(), b\"\")\n\n    def test_get_body_stream_nonNone(self):\n        body_rcv = DummyBodyStream()\n        self.parser.body_rcv = body_rcv\n        result = self.parser.get_body_stream()\n        self.assertEqual(result, body_rcv)\n\n    def test_received_get_no_headers(self):\n        data = b\"HTTP/1.0 GET /foobar\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 24)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_bad_host_header(self):\n        from waitress.utilities import BadRequest\n\n        data = b\"HTTP/1.0 GET /foobar\\r\\n Host: foo\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 36)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.error.__class__, BadRequest)\n\n    def test_received_nonsense_nothing(self):\n        data = b\"\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 4)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_no_doublecr(self):\n        data = b\"GET /foobar HTTP/8.4\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 22)\n        self.assertFalse(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_already_completed(self):\n        self.parser.completed = True\n        result = self.parser.received(b\"a\")\n        self.assertEqual(result, 0)\n\n    def test_received_cl_too_large(self):\n        from waitress.utilities import RequestEntityTooLarge\n\n        self.parser.adj.max_request_body_size = 2\n        data = b\"GET /foobar HTTP/8.4\\r\\nContent-Length: 10\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 44)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))\n\n    def test_received_headers_too_large(self):\n        from waitress.utilities import RequestHeaderFieldsTooLarge\n\n        self.parser.adj.max_request_header_size = 2\n        data = b\"GET /foobar HTTP/8.4\\r\\nX-Foo: 1\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 34)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestHeaderFieldsTooLarge))\n\n    def test_received_body_too_large(self):\n        from waitress.utilities import RequestEntityTooLarge\n\n        self.parser.adj.max_request_body_size = 2\n        data = (\n            b\"GET /foobar HTTP/1.1\\r\\n\"\n            b\"Transfer-Encoding: chunked\\r\\n\"\n            b\"X-Foo: 1\\r\\n\"\n            b\"\\r\\n\"\n            b\"1d;\\r\\n\"\n            b\"This string has 29 characters\\r\\n\"\n            b\"0\\r\\n\\r\\n\"\n        )\n\n        result = self.parser.received(data)\n        self.assertEqual(result, 62)\n        self.parser.received(data[result:])\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))\n\n    def test_received_error_from_parser(self):\n        from waitress.utilities import BadRequest\n\n        data = (\n            b\"GET /foobar HTTP/1.1\\r\\n\"\n            b\"Transfer-Encoding: chunked\\r\\n\"\n            b\"X-Foo: 1\\r\\n\"\n            b\"\\r\\n\"\n            b\"garbage\\r\\n\"\n        )\n        # header\n        result = self.parser.received(data)\n        # body\n        result = self.parser.received(data[result:])\n        self.assertEqual(result, 9)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, BadRequest))\n\n    def test_received_chunked_completed_sets_content_length(self):\n        data = (\n            b\"GET /foobar HTTP/1.1\\r\\n\"\n            b\"Transfer-Encoding: chunked\\r\\n\"\n            b\"X-Foo: 1\\r\\n\"\n            b\"\\r\\n\"\n            b\"1d;\\r\\n\"\n            b\"This string has 29 characters\\r\\n\"\n            b\"0\\r\\n\\r\\n\"\n        )\n        result = self.parser.received(data)\n        self.assertEqual(result, 62)\n        data = data[result:]\n        result = self.parser.received(data)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(self.parser.error is None)\n        self.assertEqual(self.parser.headers[\"CONTENT_LENGTH\"], \"29\")\n\n    def test_parse_header_gardenpath(self):\n        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: bar\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.first_line, b\"GET /foobar HTTP/8.4\")\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar\")\n\n    def test_parse_header_no_cr_in_headerplus(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\"\n\n        try:\n            self.parser.parse_header(data)\n        except ParsingError:\n            pass\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_bad_content_length(self):\n        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: abc\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.body_rcv, None)\n\n    def test_parse_header_11_te_chunked(self):\n        # NB: test that capitalization of header value is unimportant\n        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: ChUnKed\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.body_rcv.__class__.__name__, \"ChunkedReceiver\")\n\n    def test_parse_header_11_expect_continue(self):\n        data = b\"GET /foobar HTTP/1.1\\r\\nexpect: 100-continue\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.expect_continue, True)\n\n    def test_parse_header_connection_close(self):\n        data = b\"GET /foobar HTTP/1.1\\r\\nConnection: close\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.connection_close, True)\n\n    def test_close_with_body_rcv(self):\n        body_rcv = DummyBodyStream()\n        self.parser.body_rcv = body_rcv\n        self.parser.close()\n        self.assertTrue(body_rcv.closed)\n\n    def test_close_with_no_body_rcv(self):\n        self.parser.body_rcv = None\n        self.parser.close()  # doesn't raise\n\n    def test_parse_header_lf_only(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\nfoo: bar\"\n\n        try:\n            self.parser.parse_header(data)\n        except ParsingError:\n            pass\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_cr_only(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\rfoo: bar\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError:\n            pass\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_extra_lf_in_header(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: \\nbar\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Bare CR or LF found in header line\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_extra_lf_in_first_line(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar\\n HTTP/8.4\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Bare CR or LF found in HTTP message\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\nclass Test_split_uri(unittest.TestCase):\n    def _callFUT(self, uri):\n        from waitress.parser import split_uri\n\n        (\n            self.proxy_scheme,\n            self.proxy_netloc,\n            self.path,\n            self.query,\n            self.fragment,\n        ) = split_uri(uri)\n\n    def test_split_uri_unquoting_unneeded(self):\n        self._callFUT(b\"http://localhost:8080/abc def\")\n        self.assertEqual(self.path, \"/abc def\")\n\n    def test_split_uri_unquoting_needed(self):\n        self._callFUT(b\"http://localhost:8080/abc%20def\")\n        self.assertEqual(self.path, \"/abc def\")\n\n    def test_split_url_with_query(self):\n        self._callFUT(b\"http://localhost:8080/abc?a=1&b=2\")\n        self.assertEqual(self.path, \"/abc\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n\n    def test_split_url_with_query_empty(self):\n        self._callFUT(b\"http://localhost:8080/abc?\")\n        self.assertEqual(self.path, \"/abc\")\n        self.assertEqual(self.query, \"\")\n\n    def test_split_url_with_fragment(self):\n        self._callFUT(b\"http://localhost:8080/#foo\")\n        self.assertEqual(self.path, \"/\")\n        self.assertEqual(self.fragment, \"foo\")\n\n    def test_split_url_https(self):\n        self._callFUT(b\"https://localhost:8080/\")\n        self.assertEqual(self.path, \"/\")\n        self.assertEqual(self.proxy_scheme, \"https\")\n        self.assertEqual(self.proxy_netloc, \"localhost:8080\")\n\n    def test_split_uri_unicode_error_raises_parsing_error(self):\n        # See https://github.com/Pylons/waitress/issues/64\n        from waitress.parser import ParsingError\n\n        # Either pass or throw a ParsingError, just don't throw another type of\n        # exception as that will cause the connection to close badly:\n        try:\n            self._callFUT(b\"/\\xd0\")\n        except ParsingError:\n            pass\n\n    def test_split_uri_path(self):\n        self._callFUT(b\"//testing/whatever\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"\")\n        self.assertEqual(self.fragment, \"\")\n\n    def test_split_uri_path_query(self):\n        self._callFUT(b\"//testing/whatever?a=1&b=2\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n        self.assertEqual(self.fragment, \"\")\n\n    def test_split_uri_path_query_fragment(self):\n        self._callFUT(b\"//testing/whatever?a=1&b=2#fragment\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n        self.assertEqual(self.fragment, \"fragment\")\n\n\nclass Test_get_header_lines(unittest.TestCase):\n    def _callFUT(self, data):\n        from waitress.parser import get_header_lines\n\n        return get_header_lines(data)\n\n    def test_get_header_lines(self):\n        result = self._callFUT(b\"slam\\r\\nslim\")\n        self.assertEqual(result, [b\"slam\", b\"slim\"])\n\n    def test_get_header_lines_folded(self):\n        # From RFC2616:\n        # HTTP/1.1 header field values can be folded onto multiple lines if the\n        # continuation line begins with a space or horizontal tab. All linear\n        # white space, including folding, has the same semantics as SP. A\n        # recipient MAY replace any linear white space with a single SP before\n        # interpreting the field value or forwarding the message downstream.\n\n        # We are just preserving the whitespace that indicates folding.\n        result = self._callFUT(b\"slim\\r\\n slam\")\n        self.assertEqual(result, [b\"slim slam\"])\n\n    def test_get_header_lines_tabbed(self):\n        result = self._callFUT(b\"slam\\r\\n\\tslim\")\n        self.assertEqual(result, [b\"slam\\tslim\"])\n\n    def test_get_header_lines_malformed(self):\n        # https://corte.si/posts/code/pathod/pythonservers/index.html\n        from waitress.parser import ParsingError\n\n        self.assertRaises(ParsingError, self._callFUT, b\" Host: localhost\\r\\n\\r\\n\")\n\n\nclass Test_crack_first_line(unittest.TestCase):\n    def _callFUT(self, line):\n        from waitress.parser import crack_first_line\n\n        return crack_first_line(line)\n\n    def test_crack_first_line_matchok(self):\n        result = self._callFUT(b\"GET / HTTP/1.0\")\n        self.assertEqual(result, (b\"GET\", b\"/\", b\"1.0\"))\n\n    def test_crack_first_line_lowercase_method(self):\n        from waitress.parser import ParsingError\n\n        self.assertRaises(ParsingError, self._callFUT, b\"get / HTTP/1.0\")\n\n    def test_crack_first_line_nomatch(self):\n        result = self._callFUT(b\"GET / bleh\")\n        self.assertEqual(result, (b\"\", b\"\", b\"\"))\n\n        result = self._callFUT(b\"GET /info?txtAirPlay&txtRAOP RTSP/1.0\")\n        self.assertEqual(result, (b\"\", b\"\", b\"\"))\n\n    def test_crack_first_line_missing_version(self):\n        result = self._callFUT(b\"GET /\")\n        self.assertEqual(result, (b\"GET\", b\"/\", b\"\"))\n\n\nclass TestHTTPRequestParserIntegration(unittest.TestCase):\n    def setUp(self):\n        from waitress.parser import HTTPRequestParser\n        from waitress.adjustments import Adjustments\n\n        my_adj = Adjustments()\n        self.parser = HTTPRequestParser(my_adj)\n\n    def feed(self, data):\n        parser = self.parser\n\n        for n in range(100):  # make sure we never loop forever\n            consumed = parser.received(data)\n            data = data[consumed:]\n\n            if parser.completed:\n                return\n        raise ValueError(\"Looping\")  # pragma: no cover\n\n    def testSimpleGET(self):\n        data = (\n            b\"GET /foobar HTTP/8.4\\r\\n\"\n            b\"FirstName: mickey\\r\\n\"\n            b\"lastname: Mouse\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        parser = self.parser\n        self.feed(data)\n        self.assertTrue(parser.completed)\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(\n            parser.headers,\n            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"6\",},\n        )\n        self.assertEqual(parser.path, \"/foobar\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.query, \"\")\n        self.assertEqual(parser.proxy_scheme, \"\")\n        self.assertEqual(parser.proxy_netloc, \"\")\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")\n\n    def testComplexGET(self):\n        data = (\n            b\"GET /foo/a+%2B%2F%C3%A4%3D%26a%3Aint?d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6 HTTP/8.4\\r\\n\"\n            b\"FirstName: mickey\\r\\n\"\n            b\"lastname: Mouse\\r\\n\"\n            b\"content-length: 10\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello mickey.\"\n        )\n        parser = self.parser\n        self.feed(data)\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(\n            parser.headers,\n            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"10\"},\n        )\n        # path should be utf-8 encoded\n        self.assertEqual(\n            tobytes(parser.path).decode(\"utf-8\"),\n            text_(b\"/foo/a++/\\xc3\\xa4=&a:int\", \"utf-8\"),\n        )\n        self.assertEqual(\n            parser.query, \"d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6\"\n        )\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello mick\")\n\n    def testProxyGET(self):\n        data = (\n            b\"GET https://example.com:8080/foobar HTTP/8.4\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        parser = self.parser\n        self.feed(data)\n        self.assertTrue(parser.completed)\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(parser.headers, {\"CONTENT_LENGTH\": \"6\"})\n        self.assertEqual(parser.path, \"/foobar\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.proxy_scheme, \"https\")\n        self.assertEqual(parser.proxy_netloc, \"example.com:8080\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.query, \"\")\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")\n\n    def testDuplicateHeaders(self):\n        # Ensure that headers with the same key get concatenated as per\n        # RFC2616.\n        data = (\n            b\"GET /foobar HTTP/8.4\\r\\n\"\n            b\"x-forwarded-for: 10.11.12.13\\r\\n\"\n            b\"x-forwarded-for: unknown,127.0.0.1\\r\\n\"\n            b\"X-Forwarded_for: 255.255.255.255\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        self.feed(data)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(\n            self.parser.headers,\n            {\n                \"CONTENT_LENGTH\": \"6\",\n                \"X_FORWARDED_FOR\": \"10.11.12.13, unknown,127.0.0.1\",\n            },\n        )\n\n    def testSpoofedHeadersDropped(self):\n        data = (\n            b\"GET /foobar HTTP/8.4\\r\\n\"\n            b\"x-auth_user: bob\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        self.feed(data)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {\"CONTENT_LENGTH\": \"6\",})\n\n\nclass DummyBodyStream(object):\n    def getfile(self):\n        return self\n\n    def getbuf(self):\n        return self\n\n    def close(self):\n        self.closed = True\n", "import unittest\n\n\nclass TestFixedStreamReceiver(unittest.TestCase):\n    def _makeOne(self, cl, buf):\n        from waitress.receiver import FixedStreamReceiver\n\n        return FixedStreamReceiver(cl, buf)\n\n    def test_received_remain_lt_1(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(0, buf)\n        result = inst.received(\"a\")\n        self.assertEqual(result, 0)\n        self.assertEqual(inst.completed, True)\n\n    def test_received_remain_lte_datalen(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(1, buf)\n        result = inst.received(\"aa\")\n        self.assertEqual(result, 1)\n        self.assertEqual(inst.completed, True)\n        self.assertEqual(inst.completed, 1)\n        self.assertEqual(inst.remain, 0)\n        self.assertEqual(buf.data, [\"a\"])\n\n    def test_received_remain_gt_datalen(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(10, buf)\n        result = inst.received(\"aa\")\n        self.assertEqual(result, 2)\n        self.assertEqual(inst.completed, False)\n        self.assertEqual(inst.remain, 8)\n        self.assertEqual(buf.data, [\"aa\"])\n\n    def test_getfile(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(10, buf)\n        self.assertEqual(inst.getfile(), buf)\n\n    def test_getbuf(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(10, buf)\n        self.assertEqual(inst.getbuf(), buf)\n\n    def test___len__(self):\n        buf = DummyBuffer([\"1\", \"2\"])\n        inst = self._makeOne(10, buf)\n        self.assertEqual(inst.__len__(), 2)\n\n\nclass TestChunkedReceiver(unittest.TestCase):\n    def _makeOne(self, buf):\n        from waitress.receiver import ChunkedReceiver\n\n        return ChunkedReceiver(buf)\n\n    def test_alreadycompleted(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.completed = True\n        result = inst.received(b\"a\")\n        self.assertEqual(result, 0)\n        self.assertEqual(inst.completed, True)\n\n    def test_received_remain_gt_zero(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.chunk_remainder = 100\n        result = inst.received(b\"a\")\n        self.assertEqual(inst.chunk_remainder, 99)\n        self.assertEqual(result, 1)\n        self.assertEqual(inst.completed, False)\n\n    def test_received_control_line_notfinished(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        result = inst.received(b\"a\")\n        self.assertEqual(inst.control_line, b\"a\")\n        self.assertEqual(result, 1)\n        self.assertEqual(inst.completed, False)\n\n    def test_received_control_line_finished_garbage_in_input(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        result = inst.received(b\"garbage\\r\\n\")\n        self.assertEqual(result, 9)\n        self.assertTrue(inst.error)\n\n    def test_received_control_line_finished_all_chunks_not_received(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        result = inst.received(b\"a;discard\\r\\n\")\n        self.assertEqual(inst.control_line, b\"\")\n        self.assertEqual(inst.chunk_remainder, 10)\n        self.assertEqual(inst.all_chunks_received, False)\n        self.assertEqual(result, 11)\n        self.assertEqual(inst.completed, False)\n\n    def test_received_control_line_finished_all_chunks_received(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        result = inst.received(b\"0;discard\\r\\n\")\n        self.assertEqual(inst.control_line, b\"\")\n        self.assertEqual(inst.all_chunks_received, True)\n        self.assertEqual(result, 11)\n        self.assertEqual(inst.completed, False)\n\n    def test_received_trailer_startswith_crlf(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.all_chunks_received = True\n        result = inst.received(b\"\\r\\n\")\n        self.assertEqual(result, 2)\n        self.assertEqual(inst.completed, True)\n\n    def test_received_trailer_startswith_lf(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.all_chunks_received = True\n        result = inst.received(b\"\\n\")\n        self.assertEqual(result, 1)\n        self.assertEqual(inst.completed, False)\n\n    def test_received_trailer_not_finished(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.all_chunks_received = True\n        result = inst.received(b\"a\")\n        self.assertEqual(result, 1)\n        self.assertEqual(inst.completed, False)\n\n    def test_received_trailer_finished(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        inst.all_chunks_received = True\n        result = inst.received(b\"abc\\r\\n\\r\\n\")\n        self.assertEqual(inst.trailer, b\"abc\\r\\n\\r\\n\")\n        self.assertEqual(result, 7)\n        self.assertEqual(inst.completed, True)\n\n    def test_getfile(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        self.assertEqual(inst.getfile(), buf)\n\n    def test_getbuf(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        self.assertEqual(inst.getbuf(), buf)\n\n    def test___len__(self):\n        buf = DummyBuffer([\"1\", \"2\"])\n        inst = self._makeOne(buf)\n        self.assertEqual(inst.__len__(), 2)\n\n    def test_received_chunk_is_properly_terminated(self):\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        data = b\"4\\r\\nWiki\\r\\n\"\n        result = inst.received(data)\n        self.assertEqual(result, len(data))\n        self.assertEqual(inst.completed, False)\n        self.assertEqual(buf.data[0], b\"Wiki\")\n\n    def test_received_chunk_not_properly_terminated(self):\n        from waitress.utilities import BadRequest\n\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        data = b\"4\\r\\nWikibadchunk\\r\\n\"\n        result = inst.received(data)\n        self.assertEqual(result, len(data))\n        self.assertEqual(inst.completed, False)\n        self.assertEqual(buf.data[0], b\"Wiki\")\n        self.assertEqual(inst.error.__class__, BadRequest)\n\n    def test_received_multiple_chunks(self):\n        from waitress.utilities import BadRequest\n\n        buf = DummyBuffer()\n        inst = self._makeOne(buf)\n        data = (\n            b\"4\\r\\n\"\n            b\"Wiki\\r\\n\"\n            b\"5\\r\\n\"\n            b\"pedia\\r\\n\"\n            b\"E\\r\\n\"\n            b\" in\\r\\n\"\n            b\"\\r\\n\"\n            b\"chunks.\\r\\n\"\n            b\"0\\r\\n\"\n            b\"\\r\\n\"\n        )\n        result = inst.received(data)\n        self.assertEqual(result, len(data))\n        self.assertEqual(inst.completed, True)\n        self.assertEqual(b\"\".join(buf.data), b\"Wikipedia in\\r\\n\\r\\nchunks.\")\n        self.assertEqual(inst.error, None)\n\n\nclass DummyBuffer(object):\n    def __init__(self, data=None):\n        if data is None:\n            data = []\n        self.data = data\n\n    def append(self, s):\n        self.data.append(s)\n\n    def getfile(self):\n        return self\n\n    def __len__(self):\n        return len(self.data)\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\nimport unittest\n\n\nclass Test_parse_http_date(unittest.TestCase):\n    def _callFUT(self, v):\n        from waitress.utilities import parse_http_date\n\n        return parse_http_date(v)\n\n    def test_rfc850(self):\n        val = \"Tuesday, 08-Feb-94 14:15:29 GMT\"\n        result = self._callFUT(val)\n        self.assertEqual(result, 760716929)\n\n    def test_rfc822(self):\n        val = \"Sun, 08 Feb 1994 14:15:29 GMT\"\n        result = self._callFUT(val)\n        self.assertEqual(result, 760716929)\n\n    def test_neither(self):\n        val = \"\"\n        result = self._callFUT(val)\n        self.assertEqual(result, 0)\n\n\nclass Test_build_http_date(unittest.TestCase):\n    def test_rountdrip(self):\n        from waitress.utilities import build_http_date, parse_http_date\n        from time import time\n\n        t = int(time())\n        self.assertEqual(t, parse_http_date(build_http_date(t)))\n\n\nclass Test_unpack_rfc850(unittest.TestCase):\n    def _callFUT(self, val):\n        from waitress.utilities import unpack_rfc850, rfc850_reg\n\n        return unpack_rfc850(rfc850_reg.match(val.lower()))\n\n    def test_it(self):\n        val = \"Tuesday, 08-Feb-94 14:15:29 GMT\"\n        result = self._callFUT(val)\n        self.assertEqual(result, (1994, 2, 8, 14, 15, 29, 0, 0, 0))\n\n\nclass Test_unpack_rfc_822(unittest.TestCase):\n    def _callFUT(self, val):\n        from waitress.utilities import unpack_rfc822, rfc822_reg\n\n        return unpack_rfc822(rfc822_reg.match(val.lower()))\n\n    def test_it(self):\n        val = \"Sun, 08 Feb 1994 14:15:29 GMT\"\n        result = self._callFUT(val)\n        self.assertEqual(result, (1994, 2, 8, 14, 15, 29, 0, 0, 0))\n\n\nclass Test_find_double_newline(unittest.TestCase):\n    def _callFUT(self, val):\n        from waitress.utilities import find_double_newline\n\n        return find_double_newline(val)\n\n    def test_empty(self):\n        self.assertEqual(self._callFUT(b\"\"), -1)\n\n    def test_one_linefeed(self):\n        self.assertEqual(self._callFUT(b\"\\n\"), -1)\n\n    def test_double_linefeed(self):\n        self.assertEqual(self._callFUT(b\"\\n\\n\"), -1)\n\n    def test_one_crlf(self):\n        self.assertEqual(self._callFUT(b\"\\r\\n\"), -1)\n\n    def test_double_crfl(self):\n        self.assertEqual(self._callFUT(b\"\\r\\n\\r\\n\"), 4)\n\n    def test_mixed(self):\n        self.assertEqual(self._callFUT(b\"\\n\\n00\\r\\n\\r\\n\"), 8)\n\n\nclass TestBadRequest(unittest.TestCase):\n    def _makeOne(self):\n        from waitress.utilities import BadRequest\n\n        return BadRequest(1)\n\n    def test_it(self):\n        inst = self._makeOne()\n        self.assertEqual(inst.body, 1)\n\n\nclass Test_undquote(unittest.TestCase):\n    def _callFUT(self, value):\n        from waitress.utilities import undquote\n\n        return undquote(value)\n\n    def test_empty(self):\n        self.assertEqual(self._callFUT(\"\"), \"\")\n\n    def test_quoted(self):\n        self.assertEqual(self._callFUT('\"test\"'), \"test\")\n\n    def test_unquoted(self):\n        self.assertEqual(self._callFUT(\"test\"), \"test\")\n\n    def test_quoted_backslash_quote(self):\n        self.assertEqual(self._callFUT('\"\\\\\"\"'), '\"')\n\n    def test_quoted_htab(self):\n        self.assertEqual(self._callFUT('\"\\t\"'), \"\\t\")\n\n    def test_quoted_backslash_htab(self):\n        self.assertEqual(self._callFUT('\"\\\\\\t\"'), \"\\t\")\n\n    def test_quoted_backslash_invalid(self):\n        self.assertRaises(ValueError, self._callFUT, '\"\\\\\"')\n\n    def test_invalid_quoting(self):\n        self.assertRaises(ValueError, self._callFUT, '\"test')\n\n    def test_invalid_quoting_single_quote(self):\n        self.assertRaises(ValueError, self._callFUT, '\"')\n", "##############################################################################\n#\n# Copyright (c) 2004 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Utility functions\n\"\"\"\n\nimport calendar\nimport errno\nimport logging\nimport os\nimport re\nimport stat\nimport time\n\nlogger = logging.getLogger(\"waitress\")\nqueue_logger = logging.getLogger(\"waitress.queue\")\n\n\ndef find_double_newline(s):\n    \"\"\"Returns the position just after a double newline in the given string.\"\"\"\n    pos = s.find(b\"\\r\\n\\r\\n\")\n\n    if pos >= 0:\n        pos += 4\n\n    return pos\n\n\ndef concat(*args):\n    return \"\".join(args)\n\n\ndef join(seq, field=\" \"):\n    return field.join(seq)\n\n\ndef group(s):\n    return \"(\" + s + \")\"\n\n\nshort_days = [\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\"]\nlong_days = [\n    \"sunday\",\n    \"monday\",\n    \"tuesday\",\n    \"wednesday\",\n    \"thursday\",\n    \"friday\",\n    \"saturday\",\n]\n\nshort_day_reg = group(join(short_days, \"|\"))\nlong_day_reg = group(join(long_days, \"|\"))\n\ndaymap = {}\nfor i in range(7):\n    daymap[short_days[i]] = i\n    daymap[long_days[i]] = i\n\nhms_reg = join(3 * [group(\"[0-9][0-9]\")], \":\")\n\nmonths = [\n    \"jan\",\n    \"feb\",\n    \"mar\",\n    \"apr\",\n    \"may\",\n    \"jun\",\n    \"jul\",\n    \"aug\",\n    \"sep\",\n    \"oct\",\n    \"nov\",\n    \"dec\",\n]\n\nmonmap = {}\nfor i in range(12):\n    monmap[months[i]] = i + 1\n\nmonths_reg = group(join(months, \"|\"))\n\n# From draft-ietf-http-v11-spec-07.txt/3.3.1\n#       Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123\n#       Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036\n#       Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format\n\n# rfc822 format\nrfc822_date = join(\n    [\n        concat(short_day_reg, \",\"),  # day\n        group(\"[0-9][0-9]?\"),  # date\n        months_reg,  # month\n        group(\"[0-9]+\"),  # year\n        hms_reg,  # hour minute second\n        \"gmt\",\n    ],\n    \" \",\n)\n\nrfc822_reg = re.compile(rfc822_date)\n\n\ndef unpack_rfc822(m):\n    g = m.group\n    return (\n        int(g(4)),  # year\n        monmap[g(3)],  # month\n        int(g(2)),  # day\n        int(g(5)),  # hour\n        int(g(6)),  # minute\n        int(g(7)),  # second\n        0,\n        0,\n        0,\n    )\n\n\n# rfc850 format\nrfc850_date = join(\n    [\n        concat(long_day_reg, \",\"),\n        join([group(\"[0-9][0-9]?\"), months_reg, group(\"[0-9]+\")], \"-\"),\n        hms_reg,\n        \"gmt\",\n    ],\n    \" \",\n)\n\nrfc850_reg = re.compile(rfc850_date)\n# they actually unpack the same way\ndef unpack_rfc850(m):\n    g = m.group\n    yr = g(4)\n    if len(yr) == 2:\n        yr = \"19\" + yr\n    return (\n        int(yr),  # year\n        monmap[g(3)],  # month\n        int(g(2)),  # day\n        int(g(5)),  # hour\n        int(g(6)),  # minute\n        int(g(7)),  # second\n        0,\n        0,\n        0,\n    )\n\n\n# parsdate.parsedate - ~700/sec.\n# parse_http_date    - ~1333/sec.\n\nweekdayname = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]\nmonthname = [\n    None,\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\",\n]\n\n\ndef build_http_date(when):\n    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(when)\n    return \"%s, %02d %3s %4d %02d:%02d:%02d GMT\" % (\n        weekdayname[wd],\n        day,\n        monthname[month],\n        year,\n        hh,\n        mm,\n        ss,\n    )\n\n\ndef parse_http_date(d):\n    d = d.lower()\n    m = rfc850_reg.match(d)\n    if m and m.end() == len(d):\n        retval = int(calendar.timegm(unpack_rfc850(m)))\n    else:\n        m = rfc822_reg.match(d)\n        if m and m.end() == len(d):\n            retval = int(calendar.timegm(unpack_rfc822(m)))\n        else:\n            return 0\n    return retval\n\n\n# RFC 5234 Appendix B.1 \"Core Rules\":\n# VCHAR         =  %x21-7E\n#                  ; visible (printing) characters\nvchar_re = \"\\x21-\\x7e\"\n\n# RFC 7230 Section 3.2.6 \"Field Value Components\":\n# quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n# qdtext        = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text\n# obs-text      = %x80-FF\n# quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\nobs_text_re = \"\\x80-\\xff\"\n\n# The '\\\\' between \\x5b and \\x5d is needed to escape \\x5d (']')\nqdtext_re = \"[\\t \\x21\\x23-\\x5b\\\\\\x5d-\\x7e\" + obs_text_re + \"]\"\n\nquoted_pair_re = r\"\\\\\" + \"([\\t \" + vchar_re + obs_text_re + \"])\"\nquoted_string_re = '\"(?:(?:' + qdtext_re + \")|(?:\" + quoted_pair_re + '))*\"'\n\nquoted_string = re.compile(quoted_string_re)\nquoted_pair = re.compile(quoted_pair_re)\n\n\ndef undquote(value):\n    if value.startswith('\"') and value.endswith('\"'):\n        # So it claims to be DQUOTE'ed, let's validate that\n        matches = quoted_string.match(value)\n\n        if matches and matches.end() == len(value):\n            # Remove the DQUOTE's from the value\n            value = value[1:-1]\n\n            # Remove all backslashes that are followed by a valid vchar or\n            # obs-text\n            value = quoted_pair.sub(r\"\\1\", value)\n\n            return value\n    elif not value.startswith('\"') and not value.endswith('\"'):\n        return value\n\n    raise ValueError(\"Invalid quoting in value\")\n\n\ndef cleanup_unix_socket(path):\n    try:\n        st = os.stat(path)\n    except OSError as exc:\n        if exc.errno != errno.ENOENT:\n            raise  # pragma: no cover\n    else:\n        if stat.S_ISSOCK(st.st_mode):\n            try:\n                os.remove(path)\n            except OSError:  # pragma: no cover\n                # avoid race condition error during tests\n                pass\n\n\nclass Error(object):\n    code = 500\n    reason = \"Internal Server Error\"\n\n    def __init__(self, body):\n        self.body = body\n\n    def to_response(self):\n        status = \"%s %s\" % (self.code, self.reason)\n        body = \"%s\\r\\n\\r\\n%s\" % (self.reason, self.body)\n        tag = \"\\r\\n\\r\\n(generated by waitress)\"\n        body = body + tag\n        headers = [(\"Content-Type\", \"text/plain\")]\n\n        return status, headers, body\n\n    def wsgi_response(self, environ, start_response):\n        status, headers, body = self.to_response()\n        start_response(status, headers)\n        yield body\n\n\nclass BadRequest(Error):\n    code = 400\n    reason = \"Bad Request\"\n\n\nclass RequestHeaderFieldsTooLarge(BadRequest):\n    code = 431\n    reason = \"Request Header Fields Too Large\"\n\n\nclass RequestEntityTooLarge(BadRequest):\n    code = 413\n    reason = \"Request Entity Too Large\"\n\n\nclass InternalServerError(Error):\n    code = 500\n    reason = \"Internal Server Error\"\n"], "filenames": ["waitress/parser.py", "waitress/receiver.py", "waitress/tests/test_channel.py", "waitress/tests/test_functional.py", "waitress/tests/test_parser.py", "waitress/tests/test_receiver.py", "waitress/tests/test_utilities.py", "waitress/utilities.py"], "buggy_code_start_loc": [22, 17, 426, 182, 18, 86, 86, 31], "buggy_code_end_loc": [303, 143, 536, 1586, 478, 155, 96, 45], "fixing_code_start_loc": [21, 17, 426, 182, 18, 86, 86, 31], "fixing_code_end_loc": [304, 172, 522, 1611, 508, 200, 96, 37], "type": "CWE-444", "message": "Waitress through version 1.3.1 implemented a \"MAY\" part of the RFC7230 which states: \"Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.\" Unfortunately if a front-end server does not parse header fields with an LF the same way as it does those with a CRLF it can lead to the front-end and the back-end server parsing the same HTTP message in two different ways. This can lead to a potential for HTTP request smuggling/splitting whereby Waitress may see two requests while the front-end server only sees a single HTTP message. This issue is fixed in Waitress 1.4.0.", "other": {"cve": {"id": "CVE-2019-16785", "sourceIdentifier": "security-advisories@github.com", "published": "2019-12-20T23:15:11.167", "lastModified": "2022-09-23T18:58:00.460", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Waitress through version 1.3.1 implemented a \"MAY\" part of the RFC7230 which states: \"Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.\" Unfortunately if a front-end server does not parse header fields with an LF the same way as it does those with a CRLF it can lead to the front-end and the back-end server parsing the same HTTP message in two different ways. This can lead to a potential for HTTP request smuggling/splitting whereby Waitress may see two requests while the front-end server only sees a single HTTP message. This issue is fixed in Waitress 1.4.0."}, {"lang": "es", "value": "Waitress versi\u00f3n hasta 1.3.1, implement\u00f3 una parte \"MAY\" del RFC7230 que declara: \"Aunque el terminador de l\u00ednea para los campos de l\u00ednea de inicio y encabezado es la secuencia CRLF, un receptor PUEDE reconocer un LF \u00fanico como un terminador de l\u00ednea e ignorar cualquier CR anterior\". Desafortunadamente, si un servidor front-end no analiza los campos de encabezado con un LF de igual forma que los que tienen un CRLF, puede conllevar a que el servidor front-end y el back-end analice el mismo mensaje HTTP de dos maneras diferentes. Esto puede conllevar a un posible tr\u00e1fico no autorizado y una divisi\u00f3n de peticiones HTTP, por lo que Waitress puede visualizar dos peticiones mientras que el servidor front-end solo visualiza un solo mensaje HTTP. Este problema fue corregido en Waitress versi\u00f3n 1.4.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:agendaless:waitress:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.3.1", "matchCriteriaId": "2A7E9C06-F243-47BE-984D-8247F2F179FE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_function_cloud_native_environment:1.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "C2A5B24D-BDF2-423C-98EA-A40778C01A05"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:15:*:*:*:*:*:*:*", "matchCriteriaId": "70108B60-8817-40B4-8412-796A592E4E5E"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2020:0720", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://docs.pylonsproject.org/projects/waitress/en/latest/#security-fixes", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/Pylons/waitress/commit/8eba394ad75deaf9e5cd15b78a3d16b12e6b0eba", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Pylons/waitress/security/advisories/GHSA-pg36-wpm5-g57p", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00011.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GVDHR2DNKCNQ7YQXISJ45NT4IQDX3LJ7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LYEOTGWJZVKPRXX2HBNVIYWCX73QYPM5/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Pylons/waitress/commit/8eba394ad75deaf9e5cd15b78a3d16b12e6b0eba"}}