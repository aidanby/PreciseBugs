{"buggy_code": ["# The contents of this file are subject to the terms\n# of the Common Development and Distribution License\n# (the License). You may not use this file except in\n# compliance with the License.\n#\n# You can obtain a copy of the License at\n# https://opensso.dev.java.net/public/CDDLv1.0.html or\n# opensso/legal/CDDLv1.0.txt\n# See the License for the specific language governing\n# permission and limitations under the License.\n#\n# When distributing Covered Code, include this CDDL\n# Header Notice in each file and include the License file\n# at opensso/legal/CDDLv1.0.txt.\n# If applicable, add the following below the CDDL Header,\n# with the fields enclosed by brackets [] replaced by\n# your own identifying information:\n# \"Portions Copyrighted [year] [name of copyright owner]\"\n#\n# $Id: xml_sec.rb,v 1.6 2007/10/24 00:28:41 todddd Exp $\n#\n# Copyright 2007 Sun Microsystems Inc. All Rights Reserved\n# Portions Copyrighted 2007 Todd W Saxton.\n\nrequire 'rubygems'\nrequire \"rexml/document\"\nrequire \"rexml/xpath\"\nrequire \"openssl\"\nrequire 'nokogiri'\nrequire \"digest/sha1\"\nrequire \"digest/sha2\"\nrequire \"onelogin/ruby-saml/validation_error\"\n\nmodule XMLSecurity\n\n  class BaseDocument < REXML::Document\n\n    C14N            = \"http://www.w3.org/2001/10/xml-exc-c14n#\"\n    DSIG            = \"http://www.w3.org/2000/09/xmldsig#\"\n\n    def canon_algorithm(element)\n      algorithm = element\n      if algorithm.is_a?(REXML::Element)\n        algorithm = element.attribute('Algorithm').value\n      end\n\n      case algorithm\n        when \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" then Nokogiri::XML::XML_C14N_1_0\n        when \"http://www.w3.org/2006/12/xml-c14n11\"            then Nokogiri::XML::XML_C14N_1_1\n        else                                                        Nokogiri::XML::XML_C14N_EXCLUSIVE_1_0\n      end\n    end\n\n    def algorithm(element)\n      algorithm = element\n      if algorithm.is_a?(REXML::Element)\n        algorithm = element.attribute(\"Algorithm\").value\n      end\n\n      algorithm = algorithm && algorithm =~ /(rsa-)?sha(.*?)$/i && $2.to_i\n\n      case algorithm\n      when 256 then OpenSSL::Digest::SHA256\n      when 384 then OpenSSL::Digest::SHA384\n      when 512 then OpenSSL::Digest::SHA512\n      else\n        OpenSSL::Digest::SHA1\n      end\n    end\n\n  end\n\n  class Document < BaseDocument\n    RSA_SHA1            = \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"\n    RSA_SHA256            = \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"\n    RSA_SHA384            = \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha384\"\n    RSA_SHA512            = \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\"\n    SHA1            = \"http://www.w3.org/2000/09/xmldsig#sha1\"\n    SHA256          = \"http://www.w3.org/2001/04/xmldsig-more#sha256\"\n    SHA384          = \"http://www.w3.org/2001/04/xmldsig-more#sha384\"\n    SHA512          = \"http://www.w3.org/2001/04/xmldsig-more#sha512\"\n    ENVELOPED_SIG   = \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"\n    INC_PREFIX_LIST = \"#default samlp saml ds xs xsi md\"\n\n    attr_accessor :uuid\n\n    def uuid\n      @uuid ||= begin\n        document.root.nil? ? nil : document.root.attributes['ID']\n      end\n    end\n\n    #<Signature>\n      #<SignedInfo>\n        #<CanonicalizationMethod />\n        #<SignatureMethod />\n        #<Reference>\n           #<Transforms>\n           #<DigestMethod>\n           #<DigestValue>\n        #</Reference>\n        #<Reference /> etc.\n      #</SignedInfo>\n      #<SignatureValue />\n      #<KeyInfo />\n      #<Object />\n    #</Signature>\n    def sign_document(private_key, certificate, signature_method = RSA_SHA1, digest_method = SHA1)\n      noko = Nokogiri.parse(self.to_s)\n\n      signature_element = REXML::Element.new(\"ds:Signature\").add_namespace('ds', DSIG)\n      signed_info_element = signature_element.add_element(\"ds:SignedInfo\")\n      signed_info_element.add_element(\"ds:CanonicalizationMethod\", {\"Algorithm\" => C14N})\n      signed_info_element.add_element(\"ds:SignatureMethod\", {\"Algorithm\"=>signature_method})\n\n      # Add Reference\n      reference_element = signed_info_element.add_element(\"ds:Reference\", {\"URI\" => \"##{uuid}\"})\n\n      # Add Transforms\n      transforms_element = reference_element.add_element(\"ds:Transforms\")\n      transforms_element.add_element(\"ds:Transform\", {\"Algorithm\" => ENVELOPED_SIG})\n      c14element = transforms_element.add_element(\"ds:Transform\", {\"Algorithm\" => C14N})\n      c14element.add_element(\"ec:InclusiveNamespaces\", {\"xmlns:ec\" => C14N, \"PrefixList\" => INC_PREFIX_LIST})\n\n      digest_method_element = reference_element.add_element(\"ds:DigestMethod\", {\"Algorithm\" => digest_method})\n      inclusive_namespaces = INC_PREFIX_LIST.split(\" \")\n      canon_doc = noko.canonicalize(canon_algorithm(C14N), inclusive_namespaces)\n      reference_element.add_element(\"ds:DigestValue\").text = compute_digest(canon_doc, algorithm(digest_method_element))\n\n      # add SignatureValue\n      noko_sig_element = Nokogiri.parse(signature_element.to_s)\n      noko_signed_info_element = noko_sig_element.at_xpath('//ds:Signature/ds:SignedInfo', 'ds' => DSIG)\n      canon_string = noko_signed_info_element.canonicalize(canon_algorithm(C14N))\n\n      signature = compute_signature(private_key, algorithm(signature_method).new, canon_string)\n      signature_element.add_element(\"ds:SignatureValue\").text = signature\n\n      # add KeyInfo\n      key_info_element       = signature_element.add_element(\"ds:KeyInfo\")\n      x509_element           = key_info_element.add_element(\"ds:X509Data\")\n      x509_cert_element      = x509_element.add_element(\"ds:X509Certificate\")\n      if certificate.is_a?(String)\n        certificate = OpenSSL::X509::Certificate.new(certificate)\n      end\n      x509_cert_element.text = Base64.encode64(certificate.to_der).gsub(/\\n/, \"\")\n\n      # add the signature\n      issuer_element = self.elements[\"//saml:Issuer\"]\n      if issuer_element\n        self.root.insert_after issuer_element, signature_element\n      else\n        if sp_sso_descriptor = self.elements[\"/md:EntityDescriptor\"]\n          self.root.insert_before sp_sso_descriptor, signature_element\n        else\n          self.root.add_element(signature_element)\n        end\n      end\n    end\n\n    protected\n\n    def compute_signature(private_key, signature_algorithm, document)\n      Base64.encode64(private_key.sign(signature_algorithm, document)).gsub(/\\n/, \"\")\n    end\n\n    def compute_digest(document, digest_algorithm)\n      digest = digest_algorithm.digest(document)\n      Base64.encode64(digest).strip!\n    end\n\n  end\n\n  class SignedDocument < BaseDocument\n\n    attr_accessor :signed_element_id\n    attr_accessor :errors\n\n    def initialize(response, errors = [])\n      super(response)\n      @errors = errors\n      extract_signed_element_id\n    end\n\n    def validate_document(idp_cert_fingerprint, soft = true, options = {})\n      # get cert from response\n      cert_element = REXML::XPath.first(\n        self,\n        \"//ds:X509Certificate\",\n        { \"ds\"=>DSIG }\n      )\n      unless cert_element\n        if soft\n          return false\n        else\n          raise OneLogin::RubySaml::ValidationError.new(\"Certificate element missing in response (ds:X509Certificate)\")\n        end\n      end\n      base64_cert = cert_element.text\n      cert_text = Base64.decode64(base64_cert)\n      cert = OpenSSL::X509::Certificate.new(cert_text)\n\n      if options[:fingerprint_alg]\n        fingerprint_alg = XMLSecurity::BaseDocument.new.algorithm(options[:fingerprint_alg]).new\n      else\n        fingerprint_alg = OpenSSL::Digest::SHA1.new\n      end\n      fingerprint = fingerprint_alg.hexdigest(cert.to_der)\n\n      # check cert matches registered idp cert\n      if fingerprint != idp_cert_fingerprint.gsub(/[^a-zA-Z0-9]/,\"\").downcase\n        @errors << \"Fingerprint mismatch\"\n        return soft ? false : (raise OneLogin::RubySaml::ValidationError.new(\"Fingerprint mismatch\"))\n      end\n\n      validate_signature(base64_cert, soft)\n    end\n\n    def validate_signature(base64_cert, soft = true)\n      # validate references\n\n      # check for inclusive namespaces\n      inclusive_namespaces = extract_inclusive_namespaces\n\n      document = Nokogiri.parse(self.to_s)\n\n      # create a working copy so we don't modify the original\n      @working_copy ||= REXML::Document.new(self.to_s).root\n\n      # store and remove signature node\n      @sig_element ||= begin\n        element = REXML::XPath.first(\n          @working_copy,\n          \"//ds:Signature\",\n          {\"ds\"=>DSIG}\n        )\n        element.remove\n      end\n\n      # verify signature\n      signed_info_element = REXML::XPath.first(\n        @sig_element,\n        \"//ds:SignedInfo\",\n        {\"ds\"=>DSIG}\n      )\n      noko_sig_element = document.at_xpath('//ds:Signature', 'ds' => DSIG)\n      noko_signed_info_element = noko_sig_element.at_xpath('./ds:SignedInfo', 'ds' => DSIG)\n      canon_algorithm = canon_algorithm REXML::XPath.first(\n        @sig_element,\n        '//ds:CanonicalizationMethod',\n        'ds' => DSIG\n      )\n      canon_string = noko_signed_info_element.canonicalize(canon_algorithm)\n      noko_sig_element.remove\n\n      # check digests\n      REXML::XPath.each(@sig_element, \"//ds:Reference\", {\"ds\"=>DSIG}) do |ref|\n        uri = ref.attributes.get_attribute(\"URI\").value\n\n        hashed_element = document.at_xpath(\"//*[@ID='#{uri[1..-1]}']\")\n        canon_algorithm = canon_algorithm REXML::XPath.first(\n          ref,\n          '//ds:CanonicalizationMethod',\n          { \"ds\" => DSIG }\n        )\n        canon_hashed_element = hashed_element.canonicalize(canon_algorithm, inclusive_namespaces)\n\n        digest_algorithm = algorithm(REXML::XPath.first(\n          ref,\n          \"//ds:DigestMethod\",\n          { \"ds\" => DSIG }\n        ))\n        hash = digest_algorithm.digest(canon_hashed_element)\n        encoded_digest_value = REXML::XPath.first(\n          ref,\n          \"//ds:DigestValue\",\n          { \"ds\" => DSIG }\n        ).text\n        digest_value = Base64.decode64(encoded_digest_value)\n\n        unless digests_match?(hash, digest_value)\n          @errors << \"Digest mismatch\"\n          return soft ? false : (raise OneLogin::RubySaml::ValidationError.new(\"Digest mismatch\"))\n        end\n      end\n\n      base64_signature = REXML::XPath.first(\n        @sig_element,\n        \"//ds:SignatureValue\",\n        {\"ds\" => DSIG}\n      ).text\n\n      signature = Base64.decode64(base64_signature)\n\n      # get certificate object\n      cert_text = Base64.decode64(base64_cert)\n      cert = OpenSSL::X509::Certificate.new(cert_text)\n\n      # signature method\n      sig_alg_value = REXML::XPath.first(\n        signed_info_element,\n        \"//ds:SignatureMethod\",\n        {\"ds\"=>DSIG}\n      )\n      signature_algorithm = algorithm(sig_alg_value)\n\n      unless cert.public_key.verify(signature_algorithm.new, signature, canon_string)\n        @errors << \"Key validation error\"\n        return soft ? false : (raise OneLogin::RubySaml::ValidationError.new(\"Key validation error\"))\n      end\n\n      return true\n    end\n\n    private\n\n    def digests_match?(hash, digest_value)\n      hash == digest_value\n    end\n\n    def extract_signed_element_id\n      reference_element = REXML::XPath.first(\n        self,\n        \"//ds:Signature/ds:SignedInfo/ds:Reference\",\n        {\"ds\"=>DSIG}\n      )\n      self.signed_element_id = reference_element.attribute(\"URI\").value[1..-1] unless reference_element.nil?\n    end\n\n    def extract_inclusive_namespaces\n      element = REXML::XPath.first(\n        self,\n        \"//ec:InclusiveNamespaces\",\n        { \"ec\" => C14N }\n      )\n      if element\n        prefix_list = element.attributes.get_attribute(\"PrefixList\").value\n        prefix_list.split(\" \")\n      else\n        []\n      end\n    end\n\n  end\nend\n"], "fixing_code": ["# The contents of this file are subject to the terms\n# of the Common Development and Distribution License\n# (the License). You may not use this file except in\n# compliance with the License.\n#\n# You can obtain a copy of the License at\n# https://opensso.dev.java.net/public/CDDLv1.0.html or\n# opensso/legal/CDDLv1.0.txt\n# See the License for the specific language governing\n# permission and limitations under the License.\n#\n# When distributing Covered Code, include this CDDL\n# Header Notice in each file and include the License file\n# at opensso/legal/CDDLv1.0.txt.\n# If applicable, add the following below the CDDL Header,\n# with the fields enclosed by brackets [] replaced by\n# your own identifying information:\n# \"Portions Copyrighted [year] [name of copyright owner]\"\n#\n# $Id: xml_sec.rb,v 1.6 2007/10/24 00:28:41 todddd Exp $\n#\n# Copyright 2007 Sun Microsystems Inc. All Rights Reserved\n# Portions Copyrighted 2007 Todd W Saxton.\n\nrequire 'rubygems'\nrequire \"rexml/document\"\nrequire \"rexml/xpath\"\nrequire \"openssl\"\nrequire 'nokogiri'\nrequire \"digest/sha1\"\nrequire \"digest/sha2\"\nrequire \"onelogin/ruby-saml/validation_error\"\n\nmodule XMLSecurity\n\n  class BaseDocument < REXML::Document\n\n    C14N            = \"http://www.w3.org/2001/10/xml-exc-c14n#\"\n    DSIG            = \"http://www.w3.org/2000/09/xmldsig#\"\n\n    def canon_algorithm(element)\n      algorithm = element\n      if algorithm.is_a?(REXML::Element)\n        algorithm = element.attribute('Algorithm').value\n      end\n\n      case algorithm\n        when \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" then Nokogiri::XML::XML_C14N_1_0\n        when \"http://www.w3.org/2006/12/xml-c14n11\"            then Nokogiri::XML::XML_C14N_1_1\n        else                                                        Nokogiri::XML::XML_C14N_EXCLUSIVE_1_0\n      end\n    end\n\n    def algorithm(element)\n      algorithm = element\n      if algorithm.is_a?(REXML::Element)\n        algorithm = element.attribute(\"Algorithm\").value\n      end\n\n      algorithm = algorithm && algorithm =~ /(rsa-)?sha(.*?)$/i && $2.to_i\n\n      case algorithm\n      when 256 then OpenSSL::Digest::SHA256\n      when 384 then OpenSSL::Digest::SHA384\n      when 512 then OpenSSL::Digest::SHA512\n      else\n        OpenSSL::Digest::SHA1\n      end\n    end\n\n  end\n\n  class Document < BaseDocument\n    RSA_SHA1            = \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"\n    RSA_SHA256            = \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"\n    RSA_SHA384            = \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha384\"\n    RSA_SHA512            = \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\"\n    SHA1            = \"http://www.w3.org/2000/09/xmldsig#sha1\"\n    SHA256          = \"http://www.w3.org/2001/04/xmldsig-more#sha256\"\n    SHA384          = \"http://www.w3.org/2001/04/xmldsig-more#sha384\"\n    SHA512          = \"http://www.w3.org/2001/04/xmldsig-more#sha512\"\n    ENVELOPED_SIG   = \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"\n    INC_PREFIX_LIST = \"#default samlp saml ds xs xsi md\"\n\n    attr_accessor :uuid\n\n    def uuid\n      @uuid ||= begin\n        document.root.nil? ? nil : document.root.attributes['ID']\n      end\n    end\n\n    #<Signature>\n      #<SignedInfo>\n        #<CanonicalizationMethod />\n        #<SignatureMethod />\n        #<Reference>\n           #<Transforms>\n           #<DigestMethod>\n           #<DigestValue>\n        #</Reference>\n        #<Reference /> etc.\n      #</SignedInfo>\n      #<SignatureValue />\n      #<KeyInfo />\n      #<Object />\n    #</Signature>\n    def sign_document(private_key, certificate, signature_method = RSA_SHA1, digest_method = SHA1)\n      noko = Nokogiri.parse(self.to_s)\n\n      signature_element = REXML::Element.new(\"ds:Signature\").add_namespace('ds', DSIG)\n      signed_info_element = signature_element.add_element(\"ds:SignedInfo\")\n      signed_info_element.add_element(\"ds:CanonicalizationMethod\", {\"Algorithm\" => C14N})\n      signed_info_element.add_element(\"ds:SignatureMethod\", {\"Algorithm\"=>signature_method})\n\n      # Add Reference\n      reference_element = signed_info_element.add_element(\"ds:Reference\", {\"URI\" => \"##{uuid}\"})\n\n      # Add Transforms\n      transforms_element = reference_element.add_element(\"ds:Transforms\")\n      transforms_element.add_element(\"ds:Transform\", {\"Algorithm\" => ENVELOPED_SIG})\n      c14element = transforms_element.add_element(\"ds:Transform\", {\"Algorithm\" => C14N})\n      c14element.add_element(\"ec:InclusiveNamespaces\", {\"xmlns:ec\" => C14N, \"PrefixList\" => INC_PREFIX_LIST})\n\n      digest_method_element = reference_element.add_element(\"ds:DigestMethod\", {\"Algorithm\" => digest_method})\n      inclusive_namespaces = INC_PREFIX_LIST.split(\" \")\n      canon_doc = noko.canonicalize(canon_algorithm(C14N), inclusive_namespaces)\n      reference_element.add_element(\"ds:DigestValue\").text = compute_digest(canon_doc, algorithm(digest_method_element))\n\n      # add SignatureValue\n      noko_sig_element = Nokogiri.parse(signature_element.to_s)\n      noko_signed_info_element = noko_sig_element.at_xpath('//ds:Signature/ds:SignedInfo', 'ds' => DSIG)\n      canon_string = noko_signed_info_element.canonicalize(canon_algorithm(C14N))\n\n      signature = compute_signature(private_key, algorithm(signature_method).new, canon_string)\n      signature_element.add_element(\"ds:SignatureValue\").text = signature\n\n      # add KeyInfo\n      key_info_element       = signature_element.add_element(\"ds:KeyInfo\")\n      x509_element           = key_info_element.add_element(\"ds:X509Data\")\n      x509_cert_element      = x509_element.add_element(\"ds:X509Certificate\")\n      if certificate.is_a?(String)\n        certificate = OpenSSL::X509::Certificate.new(certificate)\n      end\n      x509_cert_element.text = Base64.encode64(certificate.to_der).gsub(/\\n/, \"\")\n\n      # add the signature\n      issuer_element = self.elements[\"//saml:Issuer\"]\n      if issuer_element\n        self.root.insert_after issuer_element, signature_element\n      else\n        if sp_sso_descriptor = self.elements[\"/md:EntityDescriptor\"]\n          self.root.insert_before sp_sso_descriptor, signature_element\n        else\n          self.root.add_element(signature_element)\n        end\n      end\n    end\n\n    protected\n\n    def compute_signature(private_key, signature_algorithm, document)\n      Base64.encode64(private_key.sign(signature_algorithm, document)).gsub(/\\n/, \"\")\n    end\n\n    def compute_digest(document, digest_algorithm)\n      digest = digest_algorithm.digest(document)\n      Base64.encode64(digest).strip!\n    end\n\n  end\n\n  class SignedDocument < BaseDocument\n\n    attr_accessor :signed_element_id\n    attr_accessor :errors\n\n    def initialize(response, errors = [])\n      super(response)\n      @errors = errors\n      extract_signed_element_id\n    end\n\n    def validate_document(idp_cert_fingerprint, soft = true, options = {})\n      # get cert from response\n      cert_element = REXML::XPath.first(\n        self,\n        \"//ds:X509Certificate\",\n        { \"ds\"=>DSIG }\n      )\n      unless cert_element\n        if soft\n          return false\n        else\n          raise OneLogin::RubySaml::ValidationError.new(\"Certificate element missing in response (ds:X509Certificate)\")\n        end\n      end\n      base64_cert = cert_element.text\n      cert_text = Base64.decode64(base64_cert)\n      cert = OpenSSL::X509::Certificate.new(cert_text)\n\n      if options[:fingerprint_alg]\n        fingerprint_alg = XMLSecurity::BaseDocument.new.algorithm(options[:fingerprint_alg]).new\n      else\n        fingerprint_alg = OpenSSL::Digest::SHA1.new\n      end\n      fingerprint = fingerprint_alg.hexdigest(cert.to_der)\n\n      # check cert matches registered idp cert\n      if fingerprint != idp_cert_fingerprint.gsub(/[^a-zA-Z0-9]/,\"\").downcase\n        @errors << \"Fingerprint mismatch\"\n        return soft ? false : (raise OneLogin::RubySaml::ValidationError.new(\"Fingerprint mismatch\"))\n      end\n\n      validate_signature(base64_cert, soft)\n    end\n\n    def validate_signature(base64_cert, soft = true)\n      # validate references\n\n      # check for inclusive namespaces\n      inclusive_namespaces = extract_inclusive_namespaces\n\n      document = Nokogiri.parse(self.to_s)\n\n      # create a working copy so we don't modify the original\n      @working_copy ||= REXML::Document.new(self.to_s).root\n\n      # store and remove signature node\n      @sig_element ||= begin\n        element = REXML::XPath.first(\n          @working_copy,\n          \"//ds:Signature\",\n          {\"ds\"=>DSIG}\n        )\n        element.remove\n      end\n\n      # verify signature\n      signed_info_element = REXML::XPath.first(\n        @sig_element,\n        \"//ds:SignedInfo\",\n        {\"ds\"=>DSIG}\n      )\n      noko_sig_element = document.at_xpath('//ds:Signature', 'ds' => DSIG)\n      noko_signed_info_element = noko_sig_element.at_xpath('./ds:SignedInfo', 'ds' => DSIG)\n      canon_algorithm = canon_algorithm REXML::XPath.first(\n        @sig_element,\n        '//ds:CanonicalizationMethod',\n        'ds' => DSIG\n      )\n      canon_string = noko_signed_info_element.canonicalize(canon_algorithm)\n      noko_sig_element.remove\n\n      # check digests\n      REXML::XPath.each(@sig_element, \"//ds:Reference\", {\"ds\"=>DSIG}) do |ref|\n        uri = ref.attributes.get_attribute(\"URI\").value\n\n        hashed_element = document.at_xpath(\"//*[@ID=$uri]\", nil, { 'uri' => uri[1..-1] })\n        canon_algorithm = canon_algorithm REXML::XPath.first(\n          ref,\n          '//ds:CanonicalizationMethod',\n          { \"ds\" => DSIG }\n        )\n        canon_hashed_element = hashed_element.canonicalize(canon_algorithm, inclusive_namespaces)\n\n        digest_algorithm = algorithm(REXML::XPath.first(\n          ref,\n          \"//ds:DigestMethod\",\n          { \"ds\" => DSIG }\n        ))\n        hash = digest_algorithm.digest(canon_hashed_element)\n        encoded_digest_value = REXML::XPath.first(\n          ref,\n          \"//ds:DigestValue\",\n          { \"ds\" => DSIG }\n        ).text\n        digest_value = Base64.decode64(encoded_digest_value)\n\n        unless digests_match?(hash, digest_value)\n          @errors << \"Digest mismatch\"\n          return soft ? false : (raise OneLogin::RubySaml::ValidationError.new(\"Digest mismatch\"))\n        end\n      end\n\n      base64_signature = REXML::XPath.first(\n        @sig_element,\n        \"//ds:SignatureValue\",\n        {\"ds\" => DSIG}\n      ).text\n\n      signature = Base64.decode64(base64_signature)\n\n      # get certificate object\n      cert_text = Base64.decode64(base64_cert)\n      cert = OpenSSL::X509::Certificate.new(cert_text)\n\n      # signature method\n      sig_alg_value = REXML::XPath.first(\n        signed_info_element,\n        \"//ds:SignatureMethod\",\n        {\"ds\"=>DSIG}\n      )\n      signature_algorithm = algorithm(sig_alg_value)\n\n      unless cert.public_key.verify(signature_algorithm.new, signature, canon_string)\n        @errors << \"Key validation error\"\n        return soft ? false : (raise OneLogin::RubySaml::ValidationError.new(\"Key validation error\"))\n      end\n\n      return true\n    end\n\n    private\n\n    def digests_match?(hash, digest_value)\n      hash == digest_value\n    end\n\n    def extract_signed_element_id\n      reference_element = REXML::XPath.first(\n        self,\n        \"//ds:Signature/ds:SignedInfo/ds:Reference\",\n        {\"ds\"=>DSIG}\n      )\n      self.signed_element_id = reference_element.attribute(\"URI\").value[1..-1] unless reference_element.nil?\n    end\n\n    def extract_inclusive_namespaces\n      element = REXML::XPath.first(\n        self,\n        \"//ec:InclusiveNamespaces\",\n        { \"ec\" => C14N }\n      )\n      if element\n        prefix_list = element.attributes.get_attribute(\"PrefixList\").value\n        prefix_list.split(\" \")\n      else\n        []\n      end\n    end\n\n  end\nend\n"], "filenames": ["lib/xml_security.rb"], "buggy_code_start_loc": [259], "buggy_code_end_loc": [260], "fixing_code_start_loc": [259], "fixing_code_end_loc": [260], "type": "CWE-77", "message": "xml_security.rb in the ruby-saml gem before 1.0.0 for Ruby allows XPath injection and code execution because prepared statements are not used.", "other": {"cve": {"id": "CVE-2015-20108", "sourceIdentifier": "cve@mitre.org", "published": "2023-05-27T19:15:09.043", "lastModified": "2023-06-05T16:03:03.603", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "xml_security.rb in the ruby-saml gem before 1.0.0 for Ruby allows XPath injection and code execution because prepared statements are not used."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:onelogin:ruby-saml:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.0", "matchCriteriaId": "5A9CA94C-AADE-4415-8F5C-CD19F0CDDF7D"}]}]}], "references": [{"url": "https://github.com/SAML-Toolkits/ruby-saml/commit/9853651b96b99653ea8627d757d46bfe62ab6448", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/SAML-Toolkits/ruby-saml/compare/v0.9.2...v1.0.0", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/SAML-Toolkits/ruby-saml/pull/225", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/rubysec/ruby-advisory-db/blob/master/gems/ruby-saml/OSVDB-124991.yml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/SAML-Toolkits/ruby-saml/commit/9853651b96b99653ea8627d757d46bfe62ab6448"}}