{"buggy_code": ["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport {\n  IRouter,\n  JupyterFrontEnd,\n  JupyterFrontEndPlugin\n} from '@jupyterlab/application';\nimport { Dialog, IWindowResolver, showDialog } from '@jupyterlab/apputils';\nimport { URLExt } from '@jupyterlab/coreutils';\nimport {\n  ABCWidgetFactory,\n  DocumentRegistry,\n  DocumentWidget,\n  IDocumentWidget\n} from '@jupyterlab/docregistry';\nimport { IDefaultFileBrowser } from '@jupyterlab/filebrowser';\nimport { Contents, Workspace, WorkspaceManager } from '@jupyterlab/services';\nimport { IStateDB } from '@jupyterlab/statedb';\nimport { ITranslator, nullTranslator } from '@jupyterlab/translation';\nimport { Widget } from '@lumino/widgets';\n\nnamespace CommandIDs {\n  export const saveWorkspace = 'workspace-ui:save';\n\n  export const saveWorkspaceAs = 'workspace-ui:save-as';\n}\n\nconst WORKSPACE_NAME = 'jupyterlab-workspace';\nconst WORKSPACE_EXT = '.' + WORKSPACE_NAME;\nconst LAST_SAVE_ID = 'workspace-ui:lastSave';\nconst ICON_NAME = 'jp-JupyterIcon';\n\n/**\n * The workspace MIME renderer and save plugin.\n */\nexport const workspacesPlugin: JupyterFrontEndPlugin<void> = {\n  id: '@jupyterlab/apputils-extension:workspaces',\n  description: 'Add workspace file type and commands.',\n  autoStart: true,\n  requires: [\n    IDefaultFileBrowser,\n    IWindowResolver,\n    IStateDB,\n    ITranslator,\n    JupyterFrontEnd.IPaths\n  ],\n  optional: [IRouter],\n  activate: (\n    app: JupyterFrontEnd,\n    fileBrowser: IDefaultFileBrowser,\n    resolver: IWindowResolver,\n    state: IStateDB,\n    translator: ITranslator,\n    paths: JupyterFrontEnd.IPaths,\n    router: IRouter | null\n  ): void => {\n    // The workspace factory creates dummy widgets to load a new workspace.\n    const factory = new Private.WorkspaceFactory({\n      workspaces: app.serviceManager.workspaces,\n      router,\n      state,\n      translator,\n      paths\n    });\n    const trans = translator.load('jupyterlab');\n\n    app.docRegistry.addFileType({\n      name: WORKSPACE_NAME,\n      contentType: 'file',\n      fileFormat: 'text',\n      displayName: trans.__('JupyterLab workspace File'),\n      extensions: [WORKSPACE_EXT],\n      mimeTypes: ['text/json'],\n      iconClass: ICON_NAME\n    });\n    app.docRegistry.addWidgetFactory(factory);\n    app.commands.addCommand(CommandIDs.saveWorkspaceAs, {\n      label: trans.__('Save Current Workspace As\u2026'),\n      execute: async () => {\n        const data = app.serviceManager.workspaces.fetch(resolver.name);\n        await Private.saveAs(\n          fileBrowser,\n          app.serviceManager.contents,\n          data,\n          state,\n          translator\n        );\n      }\n    });\n\n    app.commands.addCommand(CommandIDs.saveWorkspace, {\n      label: trans.__('Save Current Workspace'),\n      execute: async () => {\n        const { contents } = app.serviceManager;\n        const data = app.serviceManager.workspaces.fetch(resolver.name);\n        const lastSave = (await state.fetch(LAST_SAVE_ID)) as string;\n        if (lastSave === undefined) {\n          await Private.saveAs(fileBrowser, contents, data, state, translator);\n        } else {\n          await Private.save(lastSave, contents, data, state);\n        }\n      }\n    });\n  }\n};\n\nnamespace Private {\n  /**\n   * Save workspace to a user provided location\n   */\n  export async function save(\n    userPath: string,\n    contents: Contents.IManager,\n    data: Promise<Workspace.IWorkspace>,\n    state: IStateDB\n  ): Promise<void> {\n    let name = userPath.split('/').pop();\n\n    // Add extension if not provided or remove extension from name if it was.\n    if (name !== undefined && name.includes('.')) {\n      name = name.split('.')[0];\n    } else {\n      userPath = userPath + WORKSPACE_EXT;\n    }\n\n    // Save last save location, for save button to work\n    await state.save(LAST_SAVE_ID, userPath);\n\n    const resolvedData = await data;\n    resolvedData.metadata.id = `${name}`;\n    await contents.save(userPath, {\n      type: 'file',\n      format: 'text',\n      content: JSON.stringify(resolvedData)\n    });\n  }\n\n  /**\n   * Ask user for location, and save workspace.\n   * Default location is the current directory in the file browser\n   */\n  export async function saveAs(\n    browser: IDefaultFileBrowser,\n    contents: Contents.IManager,\n    data: Promise<Workspace.IWorkspace>,\n    state: IStateDB,\n    translator?: ITranslator\n  ): Promise<void> {\n    translator = translator || nullTranslator;\n    const lastSave = await state.fetch(LAST_SAVE_ID);\n\n    let defaultName;\n    if (lastSave === undefined) {\n      defaultName = 'new-workspace';\n    } else {\n      defaultName = (lastSave as string).split('/').pop()?.split('.')[0];\n    }\n\n    const defaultPath = browser.model.path + '/' + defaultName + WORKSPACE_EXT;\n    const userPath = await getSavePath(defaultPath, translator);\n\n    if (userPath) {\n      await save(userPath, contents, data, state);\n    }\n  }\n\n  /**\n   * This widget factory is used to handle double click on workspace\n   */\n  export class WorkspaceFactory extends ABCWidgetFactory<IDocumentWidget> {\n    /**\n     * Construct a widget factory that uploads a workspace and navigates to it.\n     *\n     * @param options - The instantiation options for a `WorkspaceFactory`.\n     */\n    constructor(options: WorkspaceFactory.IOptions) {\n      const trans = (options.translator || nullTranslator).load('jupyterlab');\n      super({\n        name: 'Workspace loader',\n        label: trans.__('Workspace loader'),\n        fileTypes: [WORKSPACE_NAME],\n        defaultFor: [WORKSPACE_NAME],\n        readOnly: true\n      });\n      this._application = options.paths.urls.app;\n      this._router = options.router;\n      this._state = options.state;\n      this._workspaces = options.workspaces;\n    }\n\n    /**\n     * Loads the workspace into load, and jump to it\n     * @param context This is used queried to query the workspace content\n     */\n    protected createNewWidget(\n      context: DocumentRegistry.Context\n    ): IDocumentWidget {\n      // Save a file's contents as a workspace and navigate to that workspace.\n      void context.ready.then(async () => {\n        const file = context.model;\n        const workspace = file.toJSON() as unknown as Workspace.IWorkspace;\n        const path = context.path;\n        const id = workspace.metadata.id;\n\n        // Save the file contents as a workspace.\n        await this._workspaces.save(id, workspace);\n\n        // Save last save location for the save command.\n        await this._state.save(LAST_SAVE_ID, path);\n\n        // Navigate to new workspace.\n        const url = URLExt.join(this._application, 'workspaces', id);\n        if (this._router) {\n          this._router.navigate(url, { hard: true });\n        } else {\n          document.location.href = url;\n        }\n      });\n      return dummyWidget(context);\n    }\n\n    private _application: string;\n    private _router: IRouter | null;\n    private _state: IStateDB;\n    private _workspaces: WorkspaceManager;\n  }\n\n  /**\n   * A namespace for `WorkspaceFactory`\n   */\n  export namespace WorkspaceFactory {\n    /**\n     * Instantiation options for a `WorkspaceFactory`\n     */\n    export interface IOptions {\n      paths: JupyterFrontEnd.IPaths;\n      router: IRouter | null;\n      state: IStateDB;\n      translator: ITranslator;\n      workspaces: WorkspaceManager;\n    }\n  }\n\n  /**\n   * Returns a dummy widget with disposed content that doesn't render in the UI.\n   *\n   * @param context - The file context.\n   */\n  function dummyWidget(context: DocumentRegistry.Context): IDocumentWidget {\n    const widget = new DocumentWidget({ content: new Widget(), context });\n    widget.content.dispose();\n    return widget;\n  }\n\n  /**\n   * Ask user for a path to save to.\n   * @param defaultPath Path already present when the dialog is shown\n   */\n  async function getSavePath(\n    defaultPath: string,\n    translator?: ITranslator\n  ): Promise<string | null> {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    const saveBtn = Dialog.okButton({\n      label: trans.__('Save'),\n      ariaLabel: trans.__('Save Current Workspace')\n    });\n    const result = await showDialog({\n      title: trans.__('Save Current Workspace As\u2026'),\n      body: new SaveWidget(defaultPath),\n      buttons: [Dialog.cancelButton(), saveBtn]\n    });\n    if (result.button.label === trans.__('Save')) {\n      return result.value;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * A widget that gets a file path from a user.\n   */\n  class SaveWidget extends Widget {\n    /**\n     * Gets a modal node for getting save location. Will have a default to the current opened directory\n     * @param path Default location\n     */\n    constructor(path: string) {\n      super({ node: createSaveNode(path) });\n    }\n\n    /**\n     * Gets the save path entered by the user\n     */\n    getValue(): string {\n      return (this.node as HTMLInputElement).value;\n    }\n  }\n\n  /**\n   * Create the node for a save widget.\n   */\n  function createSaveNode(path: string): HTMLElement {\n    const input = document.createElement('input');\n    input.value = path;\n    return input;\n  }\n}\n", "/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module hub-extension\n */\n\nimport {\n  ConnectionLost,\n  IConnectionLost,\n  JupyterFrontEnd,\n  JupyterFrontEndPlugin,\n  JupyterLab\n} from '@jupyterlab/application';\nimport { Dialog, ICommandPalette, showDialog } from '@jupyterlab/apputils';\nimport { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection, ServiceManager } from '@jupyterlab/services';\nimport { ITranslator } from '@jupyterlab/translation';\n\n/**\n * The command IDs used by the plugin.\n */\nexport namespace CommandIDs {\n  export const controlPanel: string = 'hub:control-panel';\n\n  export const logout: string = 'hub:logout';\n\n  export const restart: string = 'hub:restart';\n}\n\n/**\n * Activate the jupyterhub extension.\n */\nfunction activateHubExtension(\n  app: JupyterFrontEnd,\n  paths: JupyterFrontEnd.IPaths,\n  translator: ITranslator,\n  palette: ICommandPalette | null\n): void {\n  const trans = translator.load('jupyterlab');\n  const hubHost = paths.urls.hubHost || '';\n  const hubPrefix = paths.urls.hubPrefix || '';\n  const hubUser = paths.urls.hubUser || '';\n  const hubServerName = paths.urls.hubServerName || '';\n  const baseUrl = paths.urls.base;\n\n  // Bail if not running on JupyterHub.\n  if (!hubPrefix) {\n    return;\n  }\n\n  console.debug('hub-extension: Found configuration ', {\n    hubHost: hubHost,\n    hubPrefix: hubPrefix\n  });\n\n  // If hubServerName is set, use JupyterHub 1.0 URL.\n  const restartUrl = hubServerName\n    ? hubHost + URLExt.join(hubPrefix, 'spawn', hubUser, hubServerName)\n    : hubHost + URLExt.join(hubPrefix, 'spawn');\n\n  const { commands } = app;\n\n  commands.addCommand(CommandIDs.restart, {\n    label: trans.__('Restart Server'),\n    caption: trans.__('Request that the Hub restart this server'),\n    execute: () => {\n      window.open(restartUrl, '_blank');\n    }\n  });\n\n  commands.addCommand(CommandIDs.controlPanel, {\n    label: trans.__('Hub Control Panel'),\n    caption: trans.__('Open the Hub control panel in a new browser tab'),\n    execute: () => {\n      window.open(hubHost + URLExt.join(hubPrefix, 'home'), '_blank');\n    }\n  });\n\n  commands.addCommand(CommandIDs.logout, {\n    label: trans.__('Log Out'),\n    caption: trans.__('Log out of the Hub'),\n    execute: () => {\n      window.location.href = hubHost + URLExt.join(baseUrl, 'logout');\n    }\n  });\n\n  // Add palette items.\n  if (palette) {\n    const category = trans.__('Hub');\n    palette.addItem({ category, command: CommandIDs.controlPanel });\n    palette.addItem({ category, command: CommandIDs.logout });\n  }\n}\n\n/**\n * Initialization data for the hub-extension.\n */\nconst hubExtension: JupyterFrontEndPlugin<void> = {\n  activate: activateHubExtension,\n  id: '@jupyterlab/hub-extension:plugin',\n  description: 'Registers commands related to the hub server',\n  requires: [JupyterFrontEnd.IPaths, ITranslator],\n  optional: [ICommandPalette],\n  autoStart: true\n};\n\n/**\n * Plugin to load menu description based on settings file\n */\nconst hubExtensionMenu: JupyterFrontEndPlugin<void> = {\n  activate: () => void 0,\n  id: '@jupyterlab/hub-extension:menu',\n  description: 'Adds hub related commands to the menu.',\n  autoStart: true\n};\n\n/**\n * The default JupyterLab connection lost provider. This may be overridden\n * to provide custom behavior when a connection to the server is lost.\n *\n * If the application is being deployed within a JupyterHub context,\n * this will provide a dialog that prompts the user to restart the server.\n * Otherwise, it shows an error dialog.\n */\nconst connectionlost: JupyterFrontEndPlugin<IConnectionLost> = {\n  id: '@jupyterlab/hub-extension:connectionlost',\n  description:\n    'Provides a service to be notified when the connection to the hub server is lost.',\n  requires: [JupyterFrontEnd.IPaths, ITranslator],\n  optional: [JupyterLab.IInfo],\n  activate: (\n    app: JupyterFrontEnd,\n    paths: JupyterFrontEnd.IPaths,\n    translator: ITranslator,\n    info: JupyterLab.IInfo | null\n  ): IConnectionLost => {\n    const trans = translator.load('jupyterlab');\n    const hubPrefix = paths.urls.hubPrefix || '';\n    const baseUrl = paths.urls.base;\n\n    // Return the default error message if not running on JupyterHub.\n    if (!hubPrefix) {\n      return ConnectionLost;\n    }\n\n    // If we are running on JupyterHub, return a dialog\n    // that prompts the user to restart their server.\n    let showingError = false;\n    const onConnectionLost: IConnectionLost = async (\n      manager: ServiceManager.IManager,\n      err: ServerConnection.NetworkError\n    ): Promise<void> => {\n      if (showingError) {\n        return;\n      }\n\n      showingError = true;\n      if (info) {\n        info.isConnected = false;\n      }\n\n      const result = await showDialog({\n        title: trans.__('Server unavailable or unreachable'),\n        body: trans.__(\n          'Your server at %1 is not running.\\nWould you like to restart it?',\n          baseUrl\n        ),\n        buttons: [\n          Dialog.okButton({ label: trans.__('Restart') }),\n          Dialog.cancelButton({ label: trans.__('Dismiss') })\n        ]\n      });\n\n      if (info) {\n        info.isConnected = true;\n      }\n      showingError = false;\n\n      if (result.button.accept) {\n        await app.commands.execute(CommandIDs.restart);\n      }\n    };\n    return onConnectionLost;\n  },\n  autoStart: true,\n  provides: IConnectionLost\n};\n\nexport default [\n  hubExtension,\n  hubExtensionMenu,\n  connectionlost\n] as JupyterFrontEndPlugin<any>[];\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { ServerConnection } from '../serverconnection';\nimport { Session } from '.';\nimport { URLExt } from '@jupyterlab/coreutils';\nimport { updateLegacySessionModel, validateModel } from './validate';\n\ntype DeepPartial<T> = {\n  [P in keyof T]?: DeepPartial<T[P]>;\n};\n\n/**\n * The url for the session service.\n */\nexport const SESSION_SERVICE_URL = 'api/sessions';\n\n/**\n * List the running sessions.\n */\nexport async function listRunning(\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<Session.IModel[]> {\n  const url = URLExt.join(settings.baseUrl, SESSION_SERVICE_URL);\n  const response = await ServerConnection.makeRequest(url, {}, settings);\n  if (response.status !== 200) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n  if (!Array.isArray(data)) {\n    throw new Error('Invalid Session list');\n  }\n  data.forEach(m => {\n    updateLegacySessionModel(m);\n    validateModel(m);\n  });\n  return data;\n}\n\n/**\n * Get a session url.\n */\nexport function getSessionUrl(baseUrl: string, id: string): string {\n  return URLExt.join(baseUrl, SESSION_SERVICE_URL, id);\n}\n\n/**\n * Shut down a session by id.\n */\nexport async function shutdownSession(\n  id: string,\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<void> {\n  const url = getSessionUrl(settings.baseUrl, id);\n  const init = { method: 'DELETE' };\n  const response = await ServerConnection.makeRequest(url, init, settings);\n\n  if (response.status === 404) {\n    const data = await response.json();\n    const msg =\n      data.message ?? `The session \"${id}\"\" does not exist on the server`;\n    console.warn(msg);\n  } else if (response.status === 410) {\n    throw new ServerConnection.ResponseError(\n      response,\n      'The kernel was deleted but the session was not'\n    );\n  } else if (response.status !== 204) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n}\n\n/**\n * Get a full session model from the server by session id string.\n */\nexport async function getSessionModel(\n  id: string,\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<Session.IModel> {\n  const url = getSessionUrl(settings.baseUrl, id);\n  const response = await ServerConnection.makeRequest(url, {}, settings);\n  if (response.status !== 200) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n  updateLegacySessionModel(data);\n  validateModel(data);\n  return data;\n}\n\n/**\n * Create a new session, or return an existing session if the session path\n * already exists.\n */\nexport async function startSession(\n  options: Session.ISessionOptions,\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<Session.IModel> {\n  const url = URLExt.join(settings.baseUrl, SESSION_SERVICE_URL);\n  const init = {\n    method: 'POST',\n    body: JSON.stringify(options)\n  };\n  const response = await ServerConnection.makeRequest(url, init, settings);\n  if (response.status !== 201) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n  updateLegacySessionModel(data);\n  validateModel(data);\n  return data;\n}\n\n/**\n * Send a PATCH to the server, updating the session path or the kernel.\n */\nexport async function updateSession(\n  model: Pick<Session.IModel, 'id'> & DeepPartial<Omit<Session.IModel, 'id'>>,\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<Session.IModel> {\n  const url = getSessionUrl(settings.baseUrl, model.id);\n  const init = {\n    method: 'PATCH',\n    body: JSON.stringify(model)\n  };\n  const response = await ServerConnection.makeRequest(url, init, settings);\n  if (response.status !== 200) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n  updateLegacySessionModel(data);\n  validateModel(data);\n  return data;\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { URLExt } from '@jupyterlab/coreutils';\n\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\n\nimport { DataConnector } from '@jupyterlab/statedb';\n\nimport { ServerConnection } from '../serverconnection';\n\n/**\n * The url for the lab settings service.\n */\nconst SERVICE_SETTINGS_URL = 'api/settings';\n\n/**\n * The settings API service manager.\n */\nexport class SettingManager extends DataConnector<\n  ISettingRegistry.IPlugin,\n  string\n> {\n  /**\n   * Create a new setting manager.\n   */\n  constructor(options: SettingManager.IOptions = {}) {\n    super();\n    this.serverSettings =\n      options.serverSettings ?? ServerConnection.makeSettings();\n  }\n\n  /**\n   * The server settings used to make API requests.\n   */\n  readonly serverSettings: ServerConnection.ISettings;\n\n  /**\n   * Fetch a plugin's settings.\n   *\n   * @param id - The plugin's ID.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async fetch(id: string): Promise<ISettingRegistry.IPlugin> {\n    if (!id) {\n      throw new Error('Plugin `id` parameter is required for settings fetch.');\n    }\n\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, id);\n    const response = await makeRequest(url, {}, serverSettings);\n\n    if (response.status !== 200) {\n      const err = await ResponseError.create(response);\n      throw err;\n    }\n\n    // Assert what type the server response is returning.\n    return response.json() as Promise<ISettingRegistry.IPlugin>;\n  }\n\n  /**\n   * Fetch the list of all plugin setting bundles.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async list(\n    query?: 'ids'\n  ): Promise<{ ids: string[]; values: ISettingRegistry.IPlugin[] }> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, '', query === 'ids');\n    const response = await makeRequest(url, {}, serverSettings);\n\n    if (response.status !== 200) {\n      throw new ResponseError(response);\n    }\n\n    const json = await response.json();\n    const ids =\n      json?.['settings']?.map(\n        (plugin: ISettingRegistry.IPlugin) => plugin.id\n      ) ?? [];\n\n    let values: ISettingRegistry.IPlugin[] = [];\n    if (!query) {\n      values =\n        json?.['settings']?.map((plugin: ISettingRegistry.IPlugin) => {\n          plugin.data = { composite: {}, user: {} };\n          return plugin;\n        }) ?? [];\n    }\n\n    return { ids, values };\n  }\n\n  /**\n   * Save a plugin's settings.\n   *\n   * @param id - The plugin's ID.\n   *\n   * @param raw - The user setting values as a raw string of JSON with comments.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async save(id: string, raw: string): Promise<void> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, id);\n    // NOTE: 'raw' is JSON5 (not valid JSON), so we encode it as a string in a valid JSON body\n    const init = { body: JSON.stringify({ raw }), method: 'PUT' };\n    const response = await makeRequest(url, init, serverSettings);\n\n    if (response.status !== 204) {\n      throw new ResponseError(response);\n    }\n  }\n}\n\n/**\n * A namespace for `SettingManager` statics.\n */\nexport namespace SettingManager {\n  /**\n   * The instantiation options for a setting manager.\n   */\n  export interface IOptions {\n    /**\n     * The server settings used to make API requests.\n     */\n    serverSettings?: ServerConnection.ISettings;\n  }\n}\n\n/**\n * A namespace for setting API interfaces.\n */\nexport namespace Setting {\n  /**\n   * The interface for the setting system manager.\n   */\n  export interface IManager extends SettingManager {}\n}\n\n/**\n * A namespace for private data.\n */\nnamespace Private {\n  /**\n   * Get the url for a plugin's settings.\n   */\n  export function url(base: string, id: string, idsOnly?: boolean): string {\n    const idsOnlyParam = idsOnly\n      ? URLExt.objectToQueryString({ ids_only: true })\n      : '';\n    return `${URLExt.join(base, SERVICE_SETTINGS_URL, id)}${idsOnlyParam}`;\n  }\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '../serverconnection';\n\n/**\n * The url for the terminal service.\n */\nexport const TERMINAL_SERVICE_URL = 'api/terminals';\n\n/**\n * Whether the terminal service is available.\n */\nexport function isAvailable(): boolean {\n  const available = String(PageConfig.getOption('terminalsAvailable'));\n  return available.toLowerCase() === 'true';\n}\n\n/**\n * The server model for a terminal session.\n */\nexport interface IModel {\n  /**\n   * The name of the terminal session.\n   */\n  readonly name: string;\n}\n\n/**\n * Start a new terminal session.\n *\n * @param settings - The server settings to use.\n *\n * @param name - The name of the target terminal.\n *\n * @param cwd - The path in which the terminal will start.\n *\n * @returns A promise that resolves with the session model.\n */\nexport async function startNew(\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings(),\n  name?: string,\n  cwd?: string\n): Promise<IModel> {\n  Private.errorIfNotAvailable();\n  const url = URLExt.join(settings.baseUrl, TERMINAL_SERVICE_URL);\n  const init = {\n    method: 'POST',\n    body: JSON.stringify({ name, cwd })\n  };\n\n  const response = await ServerConnection.makeRequest(url, init, settings);\n  if (response.status !== 200) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n  // TODO: Validate model\n  return data;\n}\n\n/**\n * List the running terminal sessions.\n *\n * @param settings - The server settings to use.\n *\n * @returns A promise that resolves with the list of running session models.\n */\nexport async function listRunning(\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<IModel[]> {\n  Private.errorIfNotAvailable();\n  const url = URLExt.join(settings.baseUrl, TERMINAL_SERVICE_URL);\n  const response = await ServerConnection.makeRequest(url, {}, settings);\n  if (response.status !== 200) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n\n  if (!Array.isArray(data)) {\n    throw new Error('Invalid terminal list');\n  }\n\n  // TODO: validate each model\n  return data;\n}\n\n/**\n * Shut down a terminal session by name.\n *\n * @param name - The name of the target session.\n *\n * @param settings - The server settings to use.\n *\n * @returns A promise that resolves when the session is shut down.\n */\nexport async function shutdownTerminal(\n  name: string,\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<void> {\n  Private.errorIfNotAvailable();\n  const url = URLExt.join(settings.baseUrl, TERMINAL_SERVICE_URL, name);\n  const init = { method: 'DELETE' };\n  const response = await ServerConnection.makeRequest(url, init, settings);\n  if (response.status === 404) {\n    const data = await response.json();\n    const msg =\n      data.message ??\n      `The terminal session \"${name}\"\" does not exist on the server`;\n    console.warn(msg);\n  } else if (response.status !== 204) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n}\n\nnamespace Private {\n  /**\n   * Throw an error if terminals are not available.\n   */\n  export function errorIfNotAvailable(): void {\n    if (!isAvailable()) {\n      throw new Error('Terminals Unavailable');\n    }\n  }\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { URLExt } from '@jupyterlab/coreutils';\n\nimport { DataConnector } from '@jupyterlab/statedb';\n\nimport { ReadonlyPartialJSONObject } from '@lumino/coreutils';\n\nimport { ServerConnection } from '../serverconnection';\n\n/**\n * The url for the lab workspaces service.\n */\nconst SERVICE_WORKSPACES_URL = 'api/workspaces';\n\n/**\n * The workspaces API service manager.\n */\nexport class WorkspaceManager extends DataConnector<Workspace.IWorkspace> {\n  /**\n   * Create a new workspace manager.\n   */\n  constructor(options: WorkspaceManager.IOptions = {}) {\n    super();\n    this.serverSettings =\n      options.serverSettings ?? ServerConnection.makeSettings();\n  }\n\n  /**\n   * The server settings used to make API requests.\n   */\n  readonly serverSettings: ServerConnection.ISettings;\n\n  /**\n   * Fetch a workspace.\n   *\n   * @param id - The workspace's ID.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async fetch(id: string): Promise<Workspace.IWorkspace> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, id);\n    const response = await makeRequest(url, {}, serverSettings);\n\n    if (response.status !== 200) {\n      const err = await ResponseError.create(response);\n      throw err;\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Fetch the list of workspace IDs that exist on the server.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async list(): Promise<{ ids: string[]; values: Workspace.IWorkspace[] }> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, '');\n    const response = await makeRequest(url, {}, serverSettings);\n\n    if (response.status !== 200) {\n      const err = await ResponseError.create(response);\n      throw err;\n    }\n\n    const result = await response.json();\n\n    return result.workspaces;\n  }\n\n  /**\n   * Remove a workspace from the server.\n   *\n   * @param id - The workspaces's ID.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async remove(id: string): Promise<void> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, id);\n    const init = { method: 'DELETE' };\n    const response = await makeRequest(url, init, serverSettings);\n\n    if (response.status !== 204) {\n      const err = await ResponseError.create(response);\n      throw err;\n    }\n  }\n\n  /**\n   * Save a workspace.\n   *\n   * @param id - The workspace's ID.\n   *\n   * @param workspace - The workspace being saved.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async save(id: string, workspace: Workspace.IWorkspace): Promise<void> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, id);\n    const init = { body: JSON.stringify(workspace), method: 'PUT' };\n    const response = await makeRequest(url, init, serverSettings);\n\n    if (response.status !== 204) {\n      const err = await ResponseError.create(response);\n      throw err;\n    }\n  }\n}\n\n/**\n * A namespace for `WorkspaceManager` statics.\n */\nexport namespace WorkspaceManager {\n  /**\n   * The instantiation options for a workspace manager.\n   */\n  export interface IOptions {\n    /**\n     * The server settings used to make API requests.\n     */\n    serverSettings?: ServerConnection.ISettings;\n  }\n}\n\n/**\n * A namespace for workspace API interfaces.\n */\nexport namespace Workspace {\n  /**\n   * The interface for the workspace API manager.\n   */\n  export interface IManager extends WorkspaceManager {}\n\n  /**\n   * The interface describing a workspace API response.\n   */\n  export interface IWorkspace {\n    /**\n     * The workspace data.\n     */\n    data: ReadonlyPartialJSONObject;\n\n    /**\n     * The metadata for a workspace.\n     */\n    metadata: {\n      /**\n       * The workspace ID.\n       */\n      id: string;\n    };\n  }\n}\n\n/**\n * A namespace for private data.\n */\nnamespace Private {\n  /**\n   * Get the url for a workspace.\n   */\n  export function url(base: string, id: string): string {\n    return URLExt.join(base, SERVICE_WORKSPACES_URL, id);\n  }\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { JupyterServer } from '@jupyterlab/testing';\nimport { UUID } from '@lumino/coreutils';\nimport { Session, SessionAPI } from '../../src';\nimport { createSessionModel, getRequestHandler, makeSettings } from '../utils';\n\ndescribe('session', () => {\n  let session: Session.IModel;\n  let server: JupyterServer;\n\n  jest.retryTimes(3);\n\n  beforeAll(async () => {\n    server = new JupyterServer();\n    await server.start();\n    const sessions = await SessionAPI.listRunning();\n    await Promise.all(sessions.map(s => SessionAPI.shutdownSession(s.id)));\n  }, 30000);\n\n  afterAll(async () => {\n    await server.shutdown();\n  });\n\n  afterEach(async () => {\n    const sessions = await SessionAPI.listRunning();\n    await Promise.all(sessions.map(s => SessionAPI.shutdownSession(s.id)));\n  });\n\n  describe('Session.listRunning()', () => {\n    it('should yield a list of valid session models', async () => {\n      expect(Array.from(await SessionAPI.listRunning()).length).toBe(0);\n      const session = await SessionAPI.startSession({\n        name: UUID.uuid4(),\n        path: UUID.uuid4(),\n        type: 'test'\n      });\n      expect(Array.from(await SessionAPI.listRunning())).toEqual([session]);\n    });\n\n    it('should throw an error for an invalid model', async () => {\n      const data = { id: '1234', path: 'test' };\n      const serverSettings = getRequestHandler(200, data);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });\n\n    it('should throw an error for another invalid model', async () => {\n      const data = [{ id: '1234', kernel: { id: '', name: '' }, path: '' }];\n      const serverSettings = getRequestHandler(200, data);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });\n\n    it('should fail for wrong response status', async () => {\n      const serverSettings = getRequestHandler(201, [createSessionModel()]);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });\n\n    it('should fail for error response status', async () => {\n      const serverSettings = getRequestHandler(500, {});\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });\n  });\n\n  describe('SessionAPI.startNew', () => {\n    it('should start a session', async () => {\n      session = await SessionAPI.startSession({\n        path: UUID.uuid4(),\n        name: UUID.uuid4(),\n        type: 'test'\n      });\n      expect(session.id).toBeTruthy();\n    });\n\n    it('should accept ajax options', async () => {\n      const serverSettings = makeSettings();\n      session = await SessionAPI.startSession(\n        {\n          path: UUID.uuid4(),\n          name: UUID.uuid4(),\n          type: 'test'\n        },\n        serverSettings\n      );\n      expect(session.id).toBeTruthy();\n    });\n\n    it('should fail for wrong response status', async () => {\n      const sessionModel = createSessionModel();\n      const serverSettings = getRequestHandler(200, sessionModel);\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow();\n    });\n\n    it('should fail for error response status', async () => {\n      const serverSettings = getRequestHandler(500, {});\n      const sessionModel = createSessionModel();\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow();\n    });\n\n    it('should fail for wrong response model', async () => {\n      const sessionModel = createSessionModel();\n      (sessionModel as any).path = 1;\n      const serverSettings = getRequestHandler(201, sessionModel);\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow(/Property 'path' is not of type 'string'/);\n    });\n\n    it('should handle a deprecated response model', async () => {\n      const sessionModel = createSessionModel();\n      const data = {\n        id: sessionModel.id,\n        kernel: sessionModel.kernel,\n        notebook: { path: sessionModel.path }\n      };\n      const serverSettings = getRequestHandler(201, data);\n      const model = await SessionAPI.startSession(\n        sessionModel as any,\n        serverSettings\n      );\n      expect(model).toHaveProperty('id');\n      expect(model.path).toBeTruthy();\n    });\n  });\n\n  describe('Session.shutdown()', () => {\n    it('should shut down a kernel by id', async () => {\n      session = await SessionAPI.startSession({\n        path: UUID.uuid4(),\n        name: UUID.uuid4(),\n        type: 'test'\n      });\n      await expect(\n        SessionAPI.shutdownSession(session.id)\n      ).resolves.not.toThrow();\n    });\n\n    it('should handle a 404 status', async () => {\n      await expect(\n        SessionAPI.shutdownSession(UUID.uuid4())\n      ).resolves.not.toThrow();\n    });\n  });\n});\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { JupyterServer } from '@jupyterlab/testing';\nimport { ServerConnection, SettingManager } from '../../src';\n\nconst server = new JupyterServer();\n\nbeforeAll(async () => {\n  await server.start();\n}, 30000);\n\nafterAll(async () => {\n  await server.shutdown();\n});\n\ndescribe('setting', () => {\n  describe('SettingManager', () => {\n    let manager: SettingManager;\n\n    beforeAll(() => {\n      manager = new SettingManager({\n        serverSettings: ServerConnection.makeSettings({ appUrl: 'lab' })\n      });\n    });\n\n    describe('#constructor()', () => {\n      it('should accept no options', () => {\n        const manager = new SettingManager();\n        expect(manager).toBeInstanceOf(SettingManager);\n      });\n\n      it('should accept options', () => {\n        const manager = new SettingManager({\n          serverSettings: ServerConnection.makeSettings()\n        });\n        expect(manager).toBeInstanceOf(SettingManager);\n      });\n    });\n\n    describe('#serverSettings', () => {\n      it('should be the server settings', () => {\n        const baseUrl = 'http://localhost/foo';\n        const serverSettings = ServerConnection.makeSettings({ baseUrl });\n        const manager = new SettingManager({ serverSettings });\n        expect(manager.serverSettings.baseUrl).toBe(baseUrl);\n      });\n    });\n\n    describe('#fetch()', () => {\n      it('should fetch settings for an extension', async () => {\n        const id = '@jupyterlab/apputils-extension:themes';\n\n        expect((await manager.fetch(id)).id).toBe(id);\n      });\n    });\n\n    describe('#save()', () => {\n      it('should save a setting', async () => {\n        const id = '@jupyterlab/apputils-extension:themes';\n        const theme = 'Foo Theme';\n        const raw = `{\"theme\": \"${theme}\"}`;\n\n        await manager.save(id, raw);\n        expect(JSON.parse((await manager.fetch(id)).raw).theme).toBe(theme);\n      });\n    });\n  });\n});\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { JupyterServer } from '@jupyterlab/testing';\nimport { ServerConnection, WorkspaceManager } from '../../src';\n\nconst server = new JupyterServer();\n\nbeforeAll(async () => {\n  await server.start();\n}, 30000);\n\nafterAll(async () => {\n  await server.shutdown();\n});\n\ndescribe('workspace', () => {\n  describe('WorkspaceManager', () => {\n    let manager: WorkspaceManager;\n\n    beforeAll(() => {\n      manager = new WorkspaceManager({\n        serverSettings: ServerConnection.makeSettings({ appUrl: 'lab' })\n      });\n    });\n\n    describe('#constructor()', () => {\n      it('should accept no options', () => {\n        const manager = new WorkspaceManager();\n        expect(manager).toBeInstanceOf(WorkspaceManager);\n      });\n\n      it('should accept options', () => {\n        const manager = new WorkspaceManager({\n          serverSettings: ServerConnection.makeSettings()\n        });\n        expect(manager).toBeInstanceOf(WorkspaceManager);\n      });\n    });\n\n    describe('#serverSettings', () => {\n      it('should be the server settings', () => {\n        const baseUrl = 'http://localhost/foo';\n        const serverSettings = ServerConnection.makeSettings({ baseUrl });\n        const manager = new WorkspaceManager({ serverSettings });\n        expect(manager.serverSettings.baseUrl).toBe(baseUrl);\n      });\n    });\n\n    describe('#fetch()', () => {\n      it('should fetch a saved workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });\n    });\n\n    describe('#list()', () => {\n      it('should fetch a workspace list supporting arbitrary IDs', async () => {\n        const ids = ['foo', 'bar', 'baz', 'f/o/o', 'b/a/r', 'b/a/z'];\n        const promises = ids.map(id =>\n          manager.save(id, { data: {}, metadata: { id } })\n        );\n\n        await Promise.all(promises);\n        expect((await manager.list()).ids.sort()).toEqual(ids.sort());\n      });\n    });\n\n    describe('#remove()', () => {\n      it('should remove a workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });\n    });\n\n    describe('#save()', () => {\n      it('should save a workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });\n    });\n  });\n});\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { URLExt } from '@jupyterlab/coreutils';\n\nimport { ServerConnection } from '@jupyterlab/services';\n\n/**\n * The url for the translations service.\n */\nconst TRANSLATIONS_SETTINGS_URL = 'api/translations';\n\n/**\n * Call the API extension\n *\n * @param locale API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestTranslationsAPI<T>(\n  translationsUrl: string = '',\n  locale = '',\n  init: RequestInit = {},\n  serverSettings: ServerConnection.ISettings | undefined = undefined\n): Promise<T> {\n  // Make request to Jupyter API\n  const settings = serverSettings ?? ServerConnection.makeSettings();\n  translationsUrl =\n    translationsUrl || `${settings.appUrl}/${TRANSLATIONS_SETTINGS_URL}`;\n  const requestUrl = URLExt.join(settings.baseUrl, translationsUrl, locale);\n  let response: Response;\n  try {\n    response = await ServerConnection.makeRequest(requestUrl, init, settings);\n  } catch (error) {\n    throw new ServerConnection.NetworkError(error);\n  }\n\n  let data: any = await response.text();\n\n  if (data.length > 0) {\n    try {\n      data = JSON.parse(data);\n    } catch (error) {\n      console.error('Not a JSON response body.', response);\n    }\n  }\n\n  if (!response.ok) {\n    throw new ServerConnection.ResponseError(response, data.message || data);\n  }\n\n  return data;\n}\n"], "fixing_code": ["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport {\n  IRouter,\n  JupyterFrontEnd,\n  JupyterFrontEndPlugin\n} from '@jupyterlab/application';\nimport { Dialog, IWindowResolver, showDialog } from '@jupyterlab/apputils';\nimport { URLExt } from '@jupyterlab/coreutils';\nimport {\n  ABCWidgetFactory,\n  DocumentRegistry,\n  DocumentWidget,\n  IDocumentWidget\n} from '@jupyterlab/docregistry';\nimport { IDefaultFileBrowser } from '@jupyterlab/filebrowser';\nimport { Contents, Workspace, WorkspaceManager } from '@jupyterlab/services';\nimport { IStateDB } from '@jupyterlab/statedb';\nimport { ITranslator, nullTranslator } from '@jupyterlab/translation';\nimport { Widget } from '@lumino/widgets';\n\nnamespace CommandIDs {\n  export const saveWorkspace = 'workspace-ui:save';\n\n  export const saveWorkspaceAs = 'workspace-ui:save-as';\n}\n\nconst WORKSPACE_NAME = 'jupyterlab-workspace';\nconst WORKSPACE_EXT = '.' + WORKSPACE_NAME;\nconst LAST_SAVE_ID = 'workspace-ui:lastSave';\nconst ICON_NAME = 'jp-JupyterIcon';\n\n/**\n * The workspace MIME renderer and save plugin.\n */\nexport const workspacesPlugin: JupyterFrontEndPlugin<void> = {\n  id: '@jupyterlab/apputils-extension:workspaces',\n  description: 'Add workspace file type and commands.',\n  autoStart: true,\n  requires: [\n    IDefaultFileBrowser,\n    IWindowResolver,\n    IStateDB,\n    ITranslator,\n    JupyterFrontEnd.IPaths\n  ],\n  optional: [IRouter],\n  activate: (\n    app: JupyterFrontEnd,\n    fileBrowser: IDefaultFileBrowser,\n    resolver: IWindowResolver,\n    state: IStateDB,\n    translator: ITranslator,\n    paths: JupyterFrontEnd.IPaths,\n    router: IRouter | null\n  ): void => {\n    // The workspace factory creates dummy widgets to load a new workspace.\n    const factory = new Private.WorkspaceFactory({\n      workspaces: app.serviceManager.workspaces,\n      router,\n      state,\n      translator,\n      paths\n    });\n    const trans = translator.load('jupyterlab');\n\n    app.docRegistry.addFileType({\n      name: WORKSPACE_NAME,\n      contentType: 'file',\n      fileFormat: 'text',\n      displayName: trans.__('JupyterLab workspace File'),\n      extensions: [WORKSPACE_EXT],\n      mimeTypes: ['text/json'],\n      iconClass: ICON_NAME\n    });\n    app.docRegistry.addWidgetFactory(factory);\n    app.commands.addCommand(CommandIDs.saveWorkspaceAs, {\n      label: trans.__('Save Current Workspace As\u2026'),\n      execute: async () => {\n        const data = app.serviceManager.workspaces.fetch(resolver.name);\n        await Private.saveAs(\n          fileBrowser,\n          app.serviceManager.contents,\n          data,\n          state,\n          translator\n        );\n      }\n    });\n\n    app.commands.addCommand(CommandIDs.saveWorkspace, {\n      label: trans.__('Save Current Workspace'),\n      execute: async () => {\n        const { contents } = app.serviceManager;\n        const data = app.serviceManager.workspaces.fetch(resolver.name);\n        const lastSave = (await state.fetch(LAST_SAVE_ID)) as string;\n        if (lastSave === undefined) {\n          await Private.saveAs(fileBrowser, contents, data, state, translator);\n        } else {\n          await Private.save(lastSave, contents, data, state);\n        }\n      }\n    });\n  }\n};\n\nnamespace Private {\n  /**\n   * Save workspace to a user provided location\n   */\n  export async function save(\n    userPath: string,\n    contents: Contents.IManager,\n    data: Promise<Workspace.IWorkspace>,\n    state: IStateDB\n  ): Promise<void> {\n    let name = userPath.split('/').pop();\n\n    // Add extension if not provided or remove extension from name if it was.\n    if (name !== undefined && name.includes('.')) {\n      name = name.split('.')[0];\n    } else {\n      userPath = userPath + WORKSPACE_EXT;\n    }\n\n    // Save last save location, for save button to work\n    await state.save(LAST_SAVE_ID, userPath);\n\n    const resolvedData = await data;\n    resolvedData.metadata.id = `${name}`;\n    await contents.save(userPath, {\n      type: 'file',\n      format: 'text',\n      content: JSON.stringify(resolvedData)\n    });\n  }\n\n  /**\n   * Ask user for location, and save workspace.\n   * Default location is the current directory in the file browser\n   */\n  export async function saveAs(\n    browser: IDefaultFileBrowser,\n    contents: Contents.IManager,\n    data: Promise<Workspace.IWorkspace>,\n    state: IStateDB,\n    translator?: ITranslator\n  ): Promise<void> {\n    translator = translator || nullTranslator;\n    const lastSave = await state.fetch(LAST_SAVE_ID);\n\n    let defaultName;\n    if (lastSave === undefined) {\n      defaultName = 'new-workspace';\n    } else {\n      defaultName = (lastSave as string).split('/').pop()?.split('.')[0];\n    }\n\n    const defaultPath = browser.model.path + '/' + defaultName + WORKSPACE_EXT;\n    const userPath = await getSavePath(defaultPath, translator);\n\n    if (userPath) {\n      await save(userPath, contents, data, state);\n    }\n  }\n\n  /**\n   * This widget factory is used to handle double click on workspace\n   */\n  export class WorkspaceFactory extends ABCWidgetFactory<IDocumentWidget> {\n    /**\n     * Construct a widget factory that uploads a workspace and navigates to it.\n     *\n     * @param options - The instantiation options for a `WorkspaceFactory`.\n     */\n    constructor(options: WorkspaceFactory.IOptions) {\n      const trans = (options.translator || nullTranslator).load('jupyterlab');\n      super({\n        name: 'Workspace loader',\n        label: trans.__('Workspace loader'),\n        fileTypes: [WORKSPACE_NAME],\n        defaultFor: [WORKSPACE_NAME],\n        readOnly: true\n      });\n      this._application = options.paths.urls.app;\n      this._router = options.router;\n      this._state = options.state;\n      this._workspaces = options.workspaces;\n    }\n\n    /**\n     * Loads the workspace into load, and jump to it\n     * @param context This is used queried to query the workspace content\n     */\n    protected createNewWidget(\n      context: DocumentRegistry.Context\n    ): IDocumentWidget {\n      // Save a file's contents as a workspace and navigate to that workspace.\n      void context.ready.then(async () => {\n        const file = context.model;\n        const workspace = file.toJSON() as unknown as Workspace.IWorkspace;\n        const path = context.path;\n        const id = workspace.metadata.id;\n\n        // Save the file contents as a workspace.\n        await this._workspaces.save(id, workspace);\n\n        // Save last save location for the save command.\n        await this._state.save(LAST_SAVE_ID, path);\n\n        // Navigate to new workspace.\n        const workspacesBase = URLExt.join(this._application, 'workspaces');\n        const url = URLExt.join(workspacesBase, id);\n        if (!workspacesBase.startsWith(url)) {\n          throw new Error('Can only be used for workspaces');\n        }\n        if (this._router) {\n          this._router.navigate(url, { hard: true });\n        } else {\n          document.location.href = url;\n        }\n      });\n      return dummyWidget(context);\n    }\n\n    private _application: string;\n    private _router: IRouter | null;\n    private _state: IStateDB;\n    private _workspaces: WorkspaceManager;\n  }\n\n  /**\n   * A namespace for `WorkspaceFactory`\n   */\n  export namespace WorkspaceFactory {\n    /**\n     * Instantiation options for a `WorkspaceFactory`\n     */\n    export interface IOptions {\n      paths: JupyterFrontEnd.IPaths;\n      router: IRouter | null;\n      state: IStateDB;\n      translator: ITranslator;\n      workspaces: WorkspaceManager;\n    }\n  }\n\n  /**\n   * Returns a dummy widget with disposed content that doesn't render in the UI.\n   *\n   * @param context - The file context.\n   */\n  function dummyWidget(context: DocumentRegistry.Context): IDocumentWidget {\n    const widget = new DocumentWidget({ content: new Widget(), context });\n    widget.content.dispose();\n    return widget;\n  }\n\n  /**\n   * Ask user for a path to save to.\n   * @param defaultPath Path already present when the dialog is shown\n   */\n  async function getSavePath(\n    defaultPath: string,\n    translator?: ITranslator\n  ): Promise<string | null> {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    const saveBtn = Dialog.okButton({\n      label: trans.__('Save'),\n      ariaLabel: trans.__('Save Current Workspace')\n    });\n    const result = await showDialog({\n      title: trans.__('Save Current Workspace As\u2026'),\n      body: new SaveWidget(defaultPath),\n      buttons: [Dialog.cancelButton(), saveBtn]\n    });\n    if (result.button.label === trans.__('Save')) {\n      return result.value;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * A widget that gets a file path from a user.\n   */\n  class SaveWidget extends Widget {\n    /**\n     * Gets a modal node for getting save location. Will have a default to the current opened directory\n     * @param path Default location\n     */\n    constructor(path: string) {\n      super({ node: createSaveNode(path) });\n    }\n\n    /**\n     * Gets the save path entered by the user\n     */\n    getValue(): string {\n      return (this.node as HTMLInputElement).value;\n    }\n  }\n\n  /**\n   * Create the node for a save widget.\n   */\n  function createSaveNode(path: string): HTMLElement {\n    const input = document.createElement('input');\n    input.value = path;\n    return input;\n  }\n}\n", "/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module hub-extension\n */\n\nimport {\n  ConnectionLost,\n  IConnectionLost,\n  JupyterFrontEnd,\n  JupyterFrontEndPlugin,\n  JupyterLab\n} from '@jupyterlab/application';\nimport { Dialog, ICommandPalette, showDialog } from '@jupyterlab/apputils';\nimport { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection, ServiceManager } from '@jupyterlab/services';\nimport { ITranslator } from '@jupyterlab/translation';\n\n/**\n * The command IDs used by the plugin.\n */\nexport namespace CommandIDs {\n  export const controlPanel: string = 'hub:control-panel';\n\n  export const logout: string = 'hub:logout';\n\n  export const restart: string = 'hub:restart';\n}\n\n/**\n * Activate the jupyterhub extension.\n */\nfunction activateHubExtension(\n  app: JupyterFrontEnd,\n  paths: JupyterFrontEnd.IPaths,\n  translator: ITranslator,\n  palette: ICommandPalette | null\n): void {\n  const trans = translator.load('jupyterlab');\n  const hubHost = paths.urls.hubHost || '';\n  const hubPrefix = paths.urls.hubPrefix || '';\n  const hubUser = paths.urls.hubUser || '';\n  const hubServerName = paths.urls.hubServerName || '';\n  const baseUrl = paths.urls.base;\n\n  // Bail if not running on JupyterHub.\n  if (!hubPrefix) {\n    return;\n  }\n\n  console.debug('hub-extension: Found configuration ', {\n    hubHost: hubHost,\n    hubPrefix: hubPrefix\n  });\n\n  // If hubServerName is set, use JupyterHub 1.0 URL.\n  const spawnBase = URLExt.join(hubPrefix, 'spawn');\n  let restartUrl: string;\n  if (hubServerName) {\n    const suffix = URLExt.join(spawnBase, hubUser, hubServerName);\n    if (!suffix.startsWith(spawnBase)) {\n      throw new Error('Can only be used for spawn requests');\n    }\n    restartUrl = hubHost + suffix;\n  }\n  restartUrl = hubHost + spawnBase;\n\n  const { commands } = app;\n\n  commands.addCommand(CommandIDs.restart, {\n    label: trans.__('Restart Server'),\n    caption: trans.__('Request that the Hub restart this server'),\n    execute: () => {\n      window.open(restartUrl, '_blank');\n    }\n  });\n\n  commands.addCommand(CommandIDs.controlPanel, {\n    label: trans.__('Hub Control Panel'),\n    caption: trans.__('Open the Hub control panel in a new browser tab'),\n    execute: () => {\n      window.open(hubHost + URLExt.join(hubPrefix, 'home'), '_blank');\n    }\n  });\n\n  commands.addCommand(CommandIDs.logout, {\n    label: trans.__('Log Out'),\n    caption: trans.__('Log out of the Hub'),\n    execute: () => {\n      window.location.href = hubHost + URLExt.join(baseUrl, 'logout');\n    }\n  });\n\n  // Add palette items.\n  if (palette) {\n    const category = trans.__('Hub');\n    palette.addItem({ category, command: CommandIDs.controlPanel });\n    palette.addItem({ category, command: CommandIDs.logout });\n  }\n}\n\n/**\n * Initialization data for the hub-extension.\n */\nconst hubExtension: JupyterFrontEndPlugin<void> = {\n  activate: activateHubExtension,\n  id: '@jupyterlab/hub-extension:plugin',\n  description: 'Registers commands related to the hub server',\n  requires: [JupyterFrontEnd.IPaths, ITranslator],\n  optional: [ICommandPalette],\n  autoStart: true\n};\n\n/**\n * Plugin to load menu description based on settings file\n */\nconst hubExtensionMenu: JupyterFrontEndPlugin<void> = {\n  activate: () => void 0,\n  id: '@jupyterlab/hub-extension:menu',\n  description: 'Adds hub related commands to the menu.',\n  autoStart: true\n};\n\n/**\n * The default JupyterLab connection lost provider. This may be overridden\n * to provide custom behavior when a connection to the server is lost.\n *\n * If the application is being deployed within a JupyterHub context,\n * this will provide a dialog that prompts the user to restart the server.\n * Otherwise, it shows an error dialog.\n */\nconst connectionlost: JupyterFrontEndPlugin<IConnectionLost> = {\n  id: '@jupyterlab/hub-extension:connectionlost',\n  description:\n    'Provides a service to be notified when the connection to the hub server is lost.',\n  requires: [JupyterFrontEnd.IPaths, ITranslator],\n  optional: [JupyterLab.IInfo],\n  activate: (\n    app: JupyterFrontEnd,\n    paths: JupyterFrontEnd.IPaths,\n    translator: ITranslator,\n    info: JupyterLab.IInfo | null\n  ): IConnectionLost => {\n    const trans = translator.load('jupyterlab');\n    const hubPrefix = paths.urls.hubPrefix || '';\n    const baseUrl = paths.urls.base;\n\n    // Return the default error message if not running on JupyterHub.\n    if (!hubPrefix) {\n      return ConnectionLost;\n    }\n\n    // If we are running on JupyterHub, return a dialog\n    // that prompts the user to restart their server.\n    let showingError = false;\n    const onConnectionLost: IConnectionLost = async (\n      manager: ServiceManager.IManager,\n      err: ServerConnection.NetworkError\n    ): Promise<void> => {\n      if (showingError) {\n        return;\n      }\n\n      showingError = true;\n      if (info) {\n        info.isConnected = false;\n      }\n\n      const result = await showDialog({\n        title: trans.__('Server unavailable or unreachable'),\n        body: trans.__(\n          'Your server at %1 is not running.\\nWould you like to restart it?',\n          baseUrl\n        ),\n        buttons: [\n          Dialog.okButton({ label: trans.__('Restart') }),\n          Dialog.cancelButton({ label: trans.__('Dismiss') })\n        ]\n      });\n\n      if (info) {\n        info.isConnected = true;\n      }\n      showingError = false;\n\n      if (result.button.accept) {\n        await app.commands.execute(CommandIDs.restart);\n      }\n    };\n    return onConnectionLost;\n  },\n  autoStart: true,\n  provides: IConnectionLost\n};\n\nexport default [\n  hubExtension,\n  hubExtensionMenu,\n  connectionlost\n] as JupyterFrontEndPlugin<any>[];\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { ServerConnection } from '../serverconnection';\nimport { Session } from '.';\nimport { URLExt } from '@jupyterlab/coreutils';\nimport { updateLegacySessionModel, validateModel } from './validate';\n\ntype DeepPartial<T> = {\n  [P in keyof T]?: DeepPartial<T[P]>;\n};\n\n/**\n * The url for the session service.\n */\nexport const SESSION_SERVICE_URL = 'api/sessions';\n\n/**\n * List the running sessions.\n */\nexport async function listRunning(\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<Session.IModel[]> {\n  const url = URLExt.join(settings.baseUrl, SESSION_SERVICE_URL);\n  const response = await ServerConnection.makeRequest(url, {}, settings);\n  if (response.status !== 200) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n  if (!Array.isArray(data)) {\n    throw new Error('Invalid Session list');\n  }\n  data.forEach(m => {\n    updateLegacySessionModel(m);\n    validateModel(m);\n  });\n  return data;\n}\n\n/**\n * Get a session url.\n */\nexport function getSessionUrl(baseUrl: string, id: string): string {\n  const servicesBase = URLExt.join(baseUrl, SESSION_SERVICE_URL);\n  const result = URLExt.join(servicesBase, id);\n  if (!result.startsWith(servicesBase)) {\n    throw new Error('Can only be used for services requests');\n  }\n  return result;\n}\n\n/**\n * Shut down a session by id.\n */\nexport async function shutdownSession(\n  id: string,\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<void> {\n  const url = getSessionUrl(settings.baseUrl, id);\n  const init = { method: 'DELETE' };\n  const response = await ServerConnection.makeRequest(url, init, settings);\n\n  if (response.status === 404) {\n    const data = await response.json();\n    const msg =\n      data.message ?? `The session \"${id}\"\" does not exist on the server`;\n    console.warn(msg);\n  } else if (response.status === 410) {\n    throw new ServerConnection.ResponseError(\n      response,\n      'The kernel was deleted but the session was not'\n    );\n  } else if (response.status !== 204) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n}\n\n/**\n * Get a full session model from the server by session id string.\n */\nexport async function getSessionModel(\n  id: string,\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<Session.IModel> {\n  const url = getSessionUrl(settings.baseUrl, id);\n  const response = await ServerConnection.makeRequest(url, {}, settings);\n  if (response.status !== 200) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n  updateLegacySessionModel(data);\n  validateModel(data);\n  return data;\n}\n\n/**\n * Create a new session, or return an existing session if the session path\n * already exists.\n */\nexport async function startSession(\n  options: Session.ISessionOptions,\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<Session.IModel> {\n  const url = URLExt.join(settings.baseUrl, SESSION_SERVICE_URL);\n  const init = {\n    method: 'POST',\n    body: JSON.stringify(options)\n  };\n  const response = await ServerConnection.makeRequest(url, init, settings);\n  if (response.status !== 201) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n  updateLegacySessionModel(data);\n  validateModel(data);\n  return data;\n}\n\n/**\n * Send a PATCH to the server, updating the session path or the kernel.\n */\nexport async function updateSession(\n  model: Pick<Session.IModel, 'id'> & DeepPartial<Omit<Session.IModel, 'id'>>,\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<Session.IModel> {\n  const url = getSessionUrl(settings.baseUrl, model.id);\n  const init = {\n    method: 'PATCH',\n    body: JSON.stringify(model)\n  };\n  const response = await ServerConnection.makeRequest(url, init, settings);\n  if (response.status !== 200) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n  updateLegacySessionModel(data);\n  validateModel(data);\n  return data;\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { URLExt } from '@jupyterlab/coreutils';\n\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\n\nimport { DataConnector } from '@jupyterlab/statedb';\n\nimport { ServerConnection } from '../serverconnection';\n\n/**\n * The url for the lab settings service.\n */\nconst SERVICE_SETTINGS_URL = 'api/settings';\n\n/**\n * The settings API service manager.\n */\nexport class SettingManager extends DataConnector<\n  ISettingRegistry.IPlugin,\n  string\n> {\n  /**\n   * Create a new setting manager.\n   */\n  constructor(options: SettingManager.IOptions = {}) {\n    super();\n    this.serverSettings =\n      options.serverSettings ?? ServerConnection.makeSettings();\n  }\n\n  /**\n   * The server settings used to make API requests.\n   */\n  readonly serverSettings: ServerConnection.ISettings;\n\n  /**\n   * Fetch a plugin's settings.\n   *\n   * @param id - The plugin's ID.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async fetch(id: string): Promise<ISettingRegistry.IPlugin> {\n    if (!id) {\n      throw new Error('Plugin `id` parameter is required for settings fetch.');\n    }\n\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, id);\n    const response = await makeRequest(url, {}, serverSettings);\n\n    if (response.status !== 200) {\n      const err = await ResponseError.create(response);\n      throw err;\n    }\n\n    // Assert what type the server response is returning.\n    return response.json() as Promise<ISettingRegistry.IPlugin>;\n  }\n\n  /**\n   * Fetch the list of all plugin setting bundles.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async list(\n    query?: 'ids'\n  ): Promise<{ ids: string[]; values: ISettingRegistry.IPlugin[] }> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, '', query === 'ids');\n    const response = await makeRequest(url, {}, serverSettings);\n\n    if (response.status !== 200) {\n      throw new ResponseError(response);\n    }\n\n    const json = await response.json();\n    const ids =\n      json?.['settings']?.map(\n        (plugin: ISettingRegistry.IPlugin) => plugin.id\n      ) ?? [];\n\n    let values: ISettingRegistry.IPlugin[] = [];\n    if (!query) {\n      values =\n        json?.['settings']?.map((plugin: ISettingRegistry.IPlugin) => {\n          plugin.data = { composite: {}, user: {} };\n          return plugin;\n        }) ?? [];\n    }\n\n    return { ids, values };\n  }\n\n  /**\n   * Save a plugin's settings.\n   *\n   * @param id - The plugin's ID.\n   *\n   * @param raw - The user setting values as a raw string of JSON with comments.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async save(id: string, raw: string): Promise<void> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, id);\n    // NOTE: 'raw' is JSON5 (not valid JSON), so we encode it as a string in a valid JSON body\n    const init = { body: JSON.stringify({ raw }), method: 'PUT' };\n    const response = await makeRequest(url, init, serverSettings);\n\n    if (response.status !== 204) {\n      throw new ResponseError(response);\n    }\n  }\n}\n\n/**\n * A namespace for `SettingManager` statics.\n */\nexport namespace SettingManager {\n  /**\n   * The instantiation options for a setting manager.\n   */\n  export interface IOptions {\n    /**\n     * The server settings used to make API requests.\n     */\n    serverSettings?: ServerConnection.ISettings;\n  }\n}\n\n/**\n * A namespace for setting API interfaces.\n */\nexport namespace Setting {\n  /**\n   * The interface for the setting system manager.\n   */\n  export interface IManager extends SettingManager {}\n}\n\n/**\n * A namespace for private data.\n */\nnamespace Private {\n  /**\n   * Get the url for a plugin's settings.\n   */\n  export function url(base: string, id: string, idsOnly?: boolean): string {\n    const idsOnlyParam = idsOnly\n      ? URLExt.objectToQueryString({ ids_only: true })\n      : '';\n    const settingsBase = URLExt.join(base, SERVICE_SETTINGS_URL);\n    const result = URLExt.join(settingsBase, id);\n    if (!result.startsWith(settingsBase)) {\n      throw new Error('Can only be used for workspaces requests');\n    }\n    return `${result}${idsOnlyParam}`;\n  }\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '../serverconnection';\n\n/**\n * The url for the terminal service.\n */\nexport const TERMINAL_SERVICE_URL = 'api/terminals';\n\n/**\n * Whether the terminal service is available.\n */\nexport function isAvailable(): boolean {\n  const available = String(PageConfig.getOption('terminalsAvailable'));\n  return available.toLowerCase() === 'true';\n}\n\n/**\n * The server model for a terminal session.\n */\nexport interface IModel {\n  /**\n   * The name of the terminal session.\n   */\n  readonly name: string;\n}\n\n/**\n * Start a new terminal session.\n *\n * @param settings - The server settings to use.\n *\n * @param name - The name of the target terminal.\n *\n * @param cwd - The path in which the terminal will start.\n *\n * @returns A promise that resolves with the session model.\n */\nexport async function startNew(\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings(),\n  name?: string,\n  cwd?: string\n): Promise<IModel> {\n  Private.errorIfNotAvailable();\n  const url = URLExt.join(settings.baseUrl, TERMINAL_SERVICE_URL);\n  const init = {\n    method: 'POST',\n    body: JSON.stringify({ name, cwd })\n  };\n\n  const response = await ServerConnection.makeRequest(url, init, settings);\n  if (response.status !== 200) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n  // TODO: Validate model\n  return data;\n}\n\n/**\n * List the running terminal sessions.\n *\n * @param settings - The server settings to use.\n *\n * @returns A promise that resolves with the list of running session models.\n */\nexport async function listRunning(\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<IModel[]> {\n  Private.errorIfNotAvailable();\n  const url = URLExt.join(settings.baseUrl, TERMINAL_SERVICE_URL);\n  const response = await ServerConnection.makeRequest(url, {}, settings);\n  if (response.status !== 200) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n  const data = await response.json();\n\n  if (!Array.isArray(data)) {\n    throw new Error('Invalid terminal list');\n  }\n\n  // TODO: validate each model\n  return data;\n}\n\n/**\n * Shut down a terminal session by name.\n *\n * @param name - The name of the target session.\n *\n * @param settings - The server settings to use.\n *\n * @returns A promise that resolves when the session is shut down.\n */\nexport async function shutdownTerminal(\n  name: string,\n  settings: ServerConnection.ISettings = ServerConnection.makeSettings()\n): Promise<void> {\n  Private.errorIfNotAvailable();\n  const workspacesBase = URLExt.join(settings.baseUrl, TERMINAL_SERVICE_URL);\n  const url = URLExt.join(workspacesBase, name);\n  if (!url.startsWith(workspacesBase)) {\n    throw new Error('Can only be used for terminal requests');\n  }\n  const init = { method: 'DELETE' };\n  const response = await ServerConnection.makeRequest(url, init, settings);\n  if (response.status === 404) {\n    const data = await response.json();\n    const msg =\n      data.message ??\n      `The terminal session \"${name}\"\" does not exist on the server`;\n    console.warn(msg);\n  } else if (response.status !== 204) {\n    const err = await ServerConnection.ResponseError.create(response);\n    throw err;\n  }\n}\n\nnamespace Private {\n  /**\n   * Throw an error if terminals are not available.\n   */\n  export function errorIfNotAvailable(): void {\n    if (!isAvailable()) {\n      throw new Error('Terminals Unavailable');\n    }\n  }\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { URLExt } from '@jupyterlab/coreutils';\n\nimport { DataConnector } from '@jupyterlab/statedb';\n\nimport { ReadonlyPartialJSONObject } from '@lumino/coreutils';\n\nimport { ServerConnection } from '../serverconnection';\n\n/**\n * The url for the lab workspaces service.\n */\nconst SERVICE_WORKSPACES_URL = 'api/workspaces';\n\n/**\n * The workspaces API service manager.\n */\nexport class WorkspaceManager extends DataConnector<Workspace.IWorkspace> {\n  /**\n   * Create a new workspace manager.\n   */\n  constructor(options: WorkspaceManager.IOptions = {}) {\n    super();\n    this.serverSettings =\n      options.serverSettings ?? ServerConnection.makeSettings();\n  }\n\n  /**\n   * The server settings used to make API requests.\n   */\n  readonly serverSettings: ServerConnection.ISettings;\n\n  /**\n   * Fetch a workspace.\n   *\n   * @param id - The workspace's ID.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async fetch(id: string): Promise<Workspace.IWorkspace> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, id);\n    const response = await makeRequest(url, {}, serverSettings);\n\n    if (response.status !== 200) {\n      const err = await ResponseError.create(response);\n      throw err;\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Fetch the list of workspace IDs that exist on the server.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async list(): Promise<{ ids: string[]; values: Workspace.IWorkspace[] }> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, '');\n    const response = await makeRequest(url, {}, serverSettings);\n\n    if (response.status !== 200) {\n      const err = await ResponseError.create(response);\n      throw err;\n    }\n\n    const result = await response.json();\n\n    return result.workspaces;\n  }\n\n  /**\n   * Remove a workspace from the server.\n   *\n   * @param id - The workspaces's ID.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async remove(id: string): Promise<void> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, id);\n    const init = { method: 'DELETE' };\n    const response = await makeRequest(url, init, serverSettings);\n\n    if (response.status !== 204) {\n      const err = await ResponseError.create(response);\n      throw err;\n    }\n  }\n\n  /**\n   * Save a workspace.\n   *\n   * @param id - The workspace's ID.\n   *\n   * @param workspace - The workspace being saved.\n   *\n   * @returns A promise that resolves if successful.\n   */\n  async save(id: string, workspace: Workspace.IWorkspace): Promise<void> {\n    const { serverSettings } = this;\n    const { baseUrl, appUrl } = serverSettings;\n    const { makeRequest, ResponseError } = ServerConnection;\n    const base = baseUrl + appUrl;\n    const url = Private.url(base, id);\n    const init = { body: JSON.stringify(workspace), method: 'PUT' };\n    const response = await makeRequest(url, init, serverSettings);\n\n    if (response.status !== 204) {\n      const err = await ResponseError.create(response);\n      throw err;\n    }\n  }\n}\n\n/**\n * A namespace for `WorkspaceManager` statics.\n */\nexport namespace WorkspaceManager {\n  /**\n   * The instantiation options for a workspace manager.\n   */\n  export interface IOptions {\n    /**\n     * The server settings used to make API requests.\n     */\n    serverSettings?: ServerConnection.ISettings;\n  }\n}\n\n/**\n * A namespace for workspace API interfaces.\n */\nexport namespace Workspace {\n  /**\n   * The interface for the workspace API manager.\n   */\n  export interface IManager extends WorkspaceManager {}\n\n  /**\n   * The interface describing a workspace API response.\n   */\n  export interface IWorkspace {\n    /**\n     * The workspace data.\n     */\n    data: ReadonlyPartialJSONObject;\n\n    /**\n     * The metadata for a workspace.\n     */\n    metadata: {\n      /**\n       * The workspace ID.\n       */\n      id: string;\n    };\n  }\n}\n\n/**\n * A namespace for private data.\n */\nnamespace Private {\n  /**\n   * Get the url for a workspace.\n   */\n  export function url(base: string, id: string): string {\n    const workspacesBase = URLExt.join(base, SERVICE_WORKSPACES_URL);\n    const result = URLExt.join(workspacesBase, id);\n    if (!result.startsWith(workspacesBase)) {\n      throw new Error('Can only be used for workspaces requests');\n    }\n    return result;\n  }\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { JupyterServer } from '@jupyterlab/testing';\nimport { UUID } from '@lumino/coreutils';\nimport { Session, SessionAPI } from '../../src';\nimport { createSessionModel, getRequestHandler, makeSettings } from '../utils';\n\ndescribe('session', () => {\n  let session: Session.IModel;\n  let server: JupyterServer;\n\n  jest.retryTimes(3);\n\n  beforeAll(async () => {\n    server = new JupyterServer();\n    await server.start();\n    const sessions = await SessionAPI.listRunning();\n    await Promise.all(sessions.map(s => SessionAPI.shutdownSession(s.id)));\n  }, 30000);\n\n  afterAll(async () => {\n    await server.shutdown();\n  });\n\n  afterEach(async () => {\n    const sessions = await SessionAPI.listRunning();\n    await Promise.all(sessions.map(s => SessionAPI.shutdownSession(s.id)));\n  });\n\n  describe('Session.listRunning()', () => {\n    it('should yield a list of valid session models', async () => {\n      expect(Array.from(await SessionAPI.listRunning()).length).toBe(0);\n      const session = await SessionAPI.startSession({\n        name: UUID.uuid4(),\n        path: UUID.uuid4(),\n        type: 'test'\n      });\n      expect(Array.from(await SessionAPI.listRunning())).toEqual([session]);\n    });\n\n    it('should throw an error for an invalid model', async () => {\n      const data = { id: '1234', path: 'test' };\n      const serverSettings = getRequestHandler(200, data);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });\n\n    it('should throw an error for another invalid model', async () => {\n      const data = [{ id: '1234', kernel: { id: '', name: '' }, path: '' }];\n      const serverSettings = getRequestHandler(200, data);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });\n\n    it('should fail for wrong response status', async () => {\n      const serverSettings = getRequestHandler(201, [createSessionModel()]);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });\n\n    it('should fail for error response status', async () => {\n      const serverSettings = getRequestHandler(500, {});\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });\n  });\n\n  describe('SessionAPI.startNew', () => {\n    it('should start a session', async () => {\n      session = await SessionAPI.startSession({\n        path: UUID.uuid4(),\n        name: UUID.uuid4(),\n        type: 'test'\n      });\n      expect(session.id).toBeTruthy();\n    });\n\n    it('should accept ajax options', async () => {\n      const serverSettings = makeSettings();\n      session = await SessionAPI.startSession(\n        {\n          path: UUID.uuid4(),\n          name: UUID.uuid4(),\n          type: 'test'\n        },\n        serverSettings\n      );\n      expect(session.id).toBeTruthy();\n    });\n\n    it('should fail for wrong response status', async () => {\n      const sessionModel = createSessionModel();\n      const serverSettings = getRequestHandler(200, sessionModel);\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow();\n    });\n\n    it('should fail for error response status', async () => {\n      const serverSettings = getRequestHandler(500, {});\n      const sessionModel = createSessionModel();\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow();\n    });\n\n    it('should fail for wrong response model', async () => {\n      const sessionModel = createSessionModel();\n      (sessionModel as any).path = 1;\n      const serverSettings = getRequestHandler(201, sessionModel);\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow(/Property 'path' is not of type 'string'/);\n    });\n\n    it('should handle a deprecated response model', async () => {\n      const sessionModel = createSessionModel();\n      const data = {\n        id: sessionModel.id,\n        kernel: sessionModel.kernel,\n        notebook: { path: sessionModel.path }\n      };\n      const serverSettings = getRequestHandler(201, data);\n      const model = await SessionAPI.startSession(\n        sessionModel as any,\n        serverSettings\n      );\n      expect(model).toHaveProperty('id');\n      expect(model.path).toBeTruthy();\n    });\n  });\n\n  describe('Session.shutdown()', () => {\n    it('should shut down a kernel by id', async () => {\n      session = await SessionAPI.startSession({\n        path: UUID.uuid4(),\n        name: UUID.uuid4(),\n        type: 'test'\n      });\n      await expect(\n        SessionAPI.shutdownSession(session.id)\n      ).resolves.not.toThrow();\n    });\n\n    it('should handle a 404 status', async () => {\n      await expect(\n        SessionAPI.shutdownSession(UUID.uuid4())\n      ).resolves.not.toThrow();\n    });\n\n    it('should reject invalid on invalid id', async () => {\n      await expect(SessionAPI.shutdownSession('../')).rejects.toThrow();\n    });\n  });\n});\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { JupyterServer } from '@jupyterlab/testing';\nimport { ServerConnection, SettingManager } from '../../src';\n\nconst server = new JupyterServer();\n\nbeforeAll(async () => {\n  await server.start();\n}, 30000);\n\nafterAll(async () => {\n  await server.shutdown();\n});\n\ndescribe('setting', () => {\n  describe('SettingManager', () => {\n    let manager: SettingManager;\n\n    beforeAll(() => {\n      manager = new SettingManager({\n        serverSettings: ServerConnection.makeSettings({ appUrl: 'lab' })\n      });\n    });\n\n    describe('#constructor()', () => {\n      it('should accept no options', () => {\n        const manager = new SettingManager();\n        expect(manager).toBeInstanceOf(SettingManager);\n      });\n\n      it('should accept options', () => {\n        const manager = new SettingManager({\n          serverSettings: ServerConnection.makeSettings()\n        });\n        expect(manager).toBeInstanceOf(SettingManager);\n      });\n    });\n\n    describe('#serverSettings', () => {\n      it('should be the server settings', () => {\n        const baseUrl = 'http://localhost/foo';\n        const serverSettings = ServerConnection.makeSettings({ baseUrl });\n        const manager = new SettingManager({ serverSettings });\n        expect(manager.serverSettings.baseUrl).toBe(baseUrl);\n      });\n    });\n\n    describe('#fetch()', () => {\n      it('should fetch settings for an extension', async () => {\n        const id = '@jupyterlab/apputils-extension:themes';\n\n        expect((await manager.fetch(id)).id).toBe(id);\n      });\n\n      it('should reject on invalid id', async () => {\n        const id = '../';\n\n        const callback = async () => {\n          await manager.fetch(id);\n        };\n        await expect(callback).rejects.toThrow();\n      });\n    });\n\n    describe('#save()', () => {\n      it('should save a setting', async () => {\n        const id = '@jupyterlab/apputils-extension:themes';\n        const theme = 'Foo Theme';\n        const raw = `{\"theme\": \"${theme}\"}`;\n\n        await manager.save(id, raw);\n        expect(JSON.parse((await manager.fetch(id)).raw).theme).toBe(theme);\n      });\n\n      it('should reject on invalid id', async () => {\n        const id = '../';\n        const theme = 'Foo Theme';\n        const raw = `{\"theme\": \"${theme}\"}`;\n\n        const callback = async () => {\n          await manager.save(id, raw);\n        };\n        await expect(callback).rejects.toThrow();\n      });\n    });\n  });\n});\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { JupyterServer } from '@jupyterlab/testing';\nimport { ServerConnection, WorkspaceManager } from '../../src';\n\nconst server = new JupyterServer();\n\nbeforeAll(async () => {\n  await server.start();\n}, 30000);\n\nafterAll(async () => {\n  await server.shutdown();\n});\n\ndescribe('workspace', () => {\n  describe('WorkspaceManager', () => {\n    let manager: WorkspaceManager;\n\n    beforeAll(() => {\n      manager = new WorkspaceManager({\n        serverSettings: ServerConnection.makeSettings({ appUrl: 'lab' })\n      });\n    });\n\n    describe('#constructor()', () => {\n      it('should accept no options', () => {\n        const manager = new WorkspaceManager();\n        expect(manager).toBeInstanceOf(WorkspaceManager);\n      });\n\n      it('should accept options', () => {\n        const manager = new WorkspaceManager({\n          serverSettings: ServerConnection.makeSettings()\n        });\n        expect(manager).toBeInstanceOf(WorkspaceManager);\n      });\n    });\n\n    describe('#serverSettings', () => {\n      it('should be the server settings', () => {\n        const baseUrl = 'http://localhost/foo';\n        const serverSettings = ServerConnection.makeSettings({ baseUrl });\n        const manager = new WorkspaceManager({ serverSettings });\n        expect(manager.serverSettings.baseUrl).toBe(baseUrl);\n      });\n    });\n\n    describe('#fetch()', () => {\n      it('should fetch a saved workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });\n\n      it('should reject on invalid id', async () => {\n        const id = '../';\n\n        const callback = async () => {\n          await manager.fetch(id);\n        };\n        await expect(callback).rejects.toThrow();\n      });\n    });\n\n    describe('#list()', () => {\n      it('should fetch a workspace list supporting arbitrary IDs', async () => {\n        const ids = ['foo', 'bar', 'baz', 'f/o/o', 'b/a/r', 'b/a/z'];\n        const promises = ids.map(id =>\n          manager.save(id, { data: {}, metadata: { id } })\n        );\n\n        await Promise.all(promises);\n        expect((await manager.list()).ids.sort()).toEqual(ids.sort());\n      });\n    });\n\n    describe('#remove()', () => {\n      it('should remove a workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });\n    });\n\n    describe('#save()', () => {\n      it('should save a workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });\n\n      it('should reject on invalid id', async () => {\n        const id = '../';\n\n        const callback = async () => {\n          await manager.save(id, { data: {}, metadata: { id } });\n        };\n        await expect(callback).rejects.toThrow();\n      });\n    });\n  });\n});\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { URLExt } from '@jupyterlab/coreutils';\n\nimport { ServerConnection } from '@jupyterlab/services';\n\n/**\n * The url for the translations service.\n */\nconst TRANSLATIONS_SETTINGS_URL = 'api/translations';\n\n/**\n * Call the API extension\n *\n * @param locale API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestTranslationsAPI<T>(\n  translationsUrl: string = '',\n  locale = '',\n  init: RequestInit = {},\n  serverSettings: ServerConnection.ISettings | undefined = undefined\n): Promise<T> {\n  // Make request to Jupyter API\n  const settings = serverSettings ?? ServerConnection.makeSettings();\n  translationsUrl =\n    translationsUrl || `${settings.appUrl}/${TRANSLATIONS_SETTINGS_URL}`;\n  const translationsBase = URLExt.join(settings.baseUrl, translationsUrl);\n  const requestUrl = URLExt.join(translationsBase, locale);\n  if (!requestUrl.startsWith(translationsBase)) {\n    throw new Error('Can only be used for translations requests');\n  }\n  let response: Response;\n  try {\n    response = await ServerConnection.makeRequest(requestUrl, init, settings);\n  } catch (error) {\n    throw new ServerConnection.NetworkError(error);\n  }\n\n  let data: any = await response.text();\n\n  if (data.length > 0) {\n    try {\n      data = JSON.parse(data);\n    } catch (error) {\n      console.error('Not a JSON response body.', response);\n    }\n  }\n\n  if (!response.ok) {\n    throw new ServerConnection.ResponseError(response, data.message || data);\n  }\n\n  return data;\n}\n"], "filenames": ["packages/apputils-extension/src/workspacesplugin.ts", "packages/hub-extension/src/index.ts", "packages/services/src/session/restapi.ts", "packages/services/src/setting/index.ts", "packages/services/src/terminal/restapi.ts", "packages/services/src/workspace/index.ts", "packages/services/test/session/session.spec.ts", "packages/services/test/setting/manager.spec.ts", "packages/services/test/workspace/manager.spec.ts", "packages/translation/src/server.ts"], "buggy_code_start_loc": [213, 60, 45, 164, 104, 181, 146, 55, 57, 30], "buggy_code_end_loc": [214, 63, 46, 165, 105, 182, 146, 66, 89, 31], "fixing_code_start_loc": [213, 60, 45, 164, 104, 181, 147, 56, 58, 30], "fixing_code_end_loc": [218, 70, 51, 170, 109, 187, 151, 87, 108, 35], "type": "CWE-200", "message": "JupyterLab is an extensible environment for interactive and reproducible computing, based on the Jupyter Notebook and Architecture. Users of JupyterLab who click on a malicious link may get their `Authorization` and `XSRFToken` tokens exposed to a third party when running an older `jupyter-server` version. JupyterLab versions 4.1.0b2, 4.0.11, and 3.6.7 are patched. No workaround has been identified, however users should ensure to upgrade `jupyter-server` to version 2.7.2 or newer which includes a redirect vulnerability fix.", "other": {"cve": {"id": "CVE-2024-22421", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-19T21:15:09.870", "lastModified": "2024-02-10T02:51:03.987", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "JupyterLab is an extensible environment for interactive and reproducible computing, based on the Jupyter Notebook and Architecture. Users of JupyterLab who click on a malicious link may get their `Authorization` and `XSRFToken` tokens exposed to a third party when running an older `jupyter-server` version. JupyterLab versions 4.1.0b2, 4.0.11, and 3.6.7 are patched. No workaround has been identified, however users should ensure to upgrade `jupyter-server` to version 2.7.2 or newer which includes a redirect vulnerability fix."}, {"lang": "es", "value": "JupyterLab es un entorno extensible para inform\u00e1tica interactiva y reproducible, basado en Jupyter Notebook y Architecture. Los usuarios de JupyterLab que hacen clic en un enlace malicioso pueden exponer sus tokens de \"Autorizaci\u00f3n\" y \"XSRFToken\" a un tercero cuando ejecutan una versi\u00f3n anterior de \"jupyter-server\". Las versiones 4.1.0b2, 4.0.11 y 3.6.7 de JupyterLab est\u00e1n parcheadas. No se ha identificado ning\u00fan workaround; sin embargo, los usuarios deben asegurarse de actualizar `jupyter-server` a la versi\u00f3n 2.7.2 o posterior, que incluye una soluci\u00f3n de vulnerabilidad de redireccionamiento."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}, {"lang": "en", "value": "CWE-23"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:jupyterlab:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.6.7", "matchCriteriaId": "6AB04D05-8A11-4C88-A8BC-654A2A735313"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:jupyterlab:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.0.11", "matchCriteriaId": "98056E64-C6C4-498A-9C3F-67A7F4F11261"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:notebook:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.7", "matchCriteriaId": "EF4CC1C2-B78B-466A-ACDE-4604DE69D4FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "https://github.com/jupyterlab/jupyterlab/commit/19bd9b96cb2e77170a67e43121637d0b5619e8c6", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/jupyterlab/jupyterlab/security/advisories/GHSA-44cc-43rp-5947", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UQJKNRDRFMKGVRIYNNN6CKMNJDNYWO2H/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jupyterlab/jupyterlab/commit/19bd9b96cb2e77170a67e43121637d0b5619e8c6"}}