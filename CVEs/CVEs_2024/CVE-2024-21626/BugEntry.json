{"buggy_code": ["package cgroups\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// OpenFile opens a cgroup file in a given dir with given flags.\n// It is supposed to be used for cgroup files only, and returns\n// an error if the file is not a cgroup file.\n//\n// Arguments dir and file are joined together to form an absolute path\n// to a file being opened.\nfunc OpenFile(dir, file string, flags int) (*os.File, error) {\n\tif dir == \"\" {\n\t\treturn nil, fmt.Errorf(\"no directory specified for %s\", file)\n\t}\n\treturn openFile(dir, file, flags)\n}\n\n// ReadFile reads data from a cgroup file in dir.\n// It is supposed to be used for cgroup files only.\nfunc ReadFile(dir, file string) (string, error) {\n\tfd, err := OpenFile(dir, file, unix.O_RDONLY)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer fd.Close()\n\tvar buf bytes.Buffer\n\n\t_, err = buf.ReadFrom(fd)\n\treturn buf.String(), err\n}\n\n// WriteFile writes data to a cgroup file in dir.\n// It is supposed to be used for cgroup files only.\nfunc WriteFile(dir, file, data string) error {\n\tfd, err := OpenFile(dir, file, unix.O_WRONLY)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fd.Close()\n\tif _, err := fd.WriteString(data); err != nil {\n\t\t// Having data in the error message helps in debugging.\n\t\treturn fmt.Errorf(\"failed to write %q: %w\", data, err)\n\t}\n\treturn nil\n}\n\nconst (\n\tcgroupfsDir    = \"/sys/fs/cgroup\"\n\tcgroupfsPrefix = cgroupfsDir + \"/\"\n)\n\nvar (\n\t// TestMode is set to true by unit tests that need \"fake\" cgroupfs.\n\tTestMode bool\n\n\tcgroupFd     int = -1\n\tprepOnce     sync.Once\n\tprepErr      error\n\tresolveFlags uint64\n)\n\nfunc prepareOpenat2() error {\n\tprepOnce.Do(func() {\n\t\tfd, err := unix.Openat2(-1, cgroupfsDir, &unix.OpenHow{\n\t\t\tFlags: unix.O_DIRECTORY | unix.O_PATH,\n\t\t})\n\t\tif err != nil {\n\t\t\tprepErr = &os.PathError{Op: \"openat2\", Path: cgroupfsDir, Err: err}\n\t\t\tif err != unix.ENOSYS {\n\t\t\t\tlogrus.Warnf(\"falling back to securejoin: %s\", prepErr)\n\t\t\t} else {\n\t\t\t\tlogrus.Debug(\"openat2 not available, falling back to securejoin\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tvar st unix.Statfs_t\n\t\tif err = unix.Fstatfs(fd, &st); err != nil {\n\t\t\tprepErr = &os.PathError{Op: \"statfs\", Path: cgroupfsDir, Err: err}\n\t\t\tlogrus.Warnf(\"falling back to securejoin: %s\", prepErr)\n\t\t\treturn\n\t\t}\n\n\t\tcgroupFd = fd\n\n\t\tresolveFlags = unix.RESOLVE_BENEATH | unix.RESOLVE_NO_MAGICLINKS\n\t\tif st.Type == unix.CGROUP2_SUPER_MAGIC {\n\t\t\t// cgroupv2 has a single mountpoint and no \"cpu,cpuacct\" symlinks\n\t\t\tresolveFlags |= unix.RESOLVE_NO_XDEV | unix.RESOLVE_NO_SYMLINKS\n\t\t}\n\t})\n\n\treturn prepErr\n}\n\nfunc openFile(dir, file string, flags int) (*os.File, error) {\n\tmode := os.FileMode(0)\n\tif TestMode && flags&os.O_WRONLY != 0 {\n\t\t// \"emulate\" cgroup fs for unit tests\n\t\tflags |= os.O_TRUNC | os.O_CREATE\n\t\tmode = 0o600\n\t}\n\tpath := path.Join(dir, utils.CleanPath(file))\n\tif prepareOpenat2() != nil {\n\t\treturn openFallback(path, flags, mode)\n\t}\n\trelPath := strings.TrimPrefix(path, cgroupfsPrefix)\n\tif len(relPath) == len(path) { // non-standard path, old system?\n\t\treturn openFallback(path, flags, mode)\n\t}\n\n\tfd, err := unix.Openat2(cgroupFd, relPath,\n\t\t&unix.OpenHow{\n\t\t\tResolve: resolveFlags,\n\t\t\tFlags:   uint64(flags) | unix.O_CLOEXEC,\n\t\t\tMode:    uint64(mode),\n\t\t})\n\tif err != nil {\n\t\terr = &os.PathError{Op: \"openat2\", Path: path, Err: err}\n\t\t// Check if cgroupFd is still opened to cgroupfsDir\n\t\t// (happens when this package is incorrectly used\n\t\t// across the chroot/pivot_root/mntns boundary, or\n\t\t// when /sys/fs/cgroup is remounted).\n\t\t//\n\t\t// TODO: if such usage will ever be common, amend this\n\t\t// to reopen cgroupFd and retry openat2.\n\t\tfdPath, closer := utils.ProcThreadSelf(\"fd/\" + strconv.Itoa(cgroupFd))\n\t\tdefer closer()\n\t\tfdDest, _ := os.Readlink(fdPath)\n\t\tif fdDest != cgroupfsDir {\n\t\t\t// Wrap the error so it is clear that cgroupFd\n\t\t\t// is opened to an unexpected/wrong directory.\n\t\t\terr = fmt.Errorf(\"cgroupFd %d unexpectedly opened to %s != %s: %w\",\n\t\t\t\tcgroupFd, fdDest, cgroupfsDir, err)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn os.NewFile(uintptr(fd), path), nil\n}\n\nvar errNotCgroupfs = errors.New(\"not a cgroup file\")\n\n// Can be changed by unit tests.\nvar openFallback = openAndCheck\n\n// openAndCheck is used when openat2(2) is not available. It checks the opened\n// file is on cgroupfs, returning an error otherwise.\nfunc openAndCheck(path string, flags int, mode os.FileMode) (*os.File, error) {\n\tfd, err := os.OpenFile(path, flags, mode)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif TestMode {\n\t\treturn fd, nil\n\t}\n\t// Check this is a cgroupfs file.\n\tvar st unix.Statfs_t\n\tif err := unix.Fstatfs(int(fd.Fd()), &st); err != nil {\n\t\t_ = fd.Close()\n\t\treturn nil, &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\tif st.Type != unix.CGROUP_SUPER_MAGIC && st.Type != unix.CGROUP2_SUPER_MAGIC {\n\t\t_ = fd.Close()\n\t\treturn nil, &os.PathError{Op: \"open\", Path: path, Err: errNotCgroupfs}\n\t}\n\n\treturn fd, nil\n}\n", "package libcontainer\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/execabs\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/dmz\"\n\t\"github.com/opencontainers/runc/libcontainer/intelrdt\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/system/kernelversion\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\nconst stdioFdCount = 3\n\n// Container is a libcontainer container object.\ntype Container struct {\n\tid                   string\n\tstateDir             string\n\tconfig               *configs.Config\n\tcgroupManager        cgroups.Manager\n\tintelRdtManager      *intelrdt.Manager\n\tinitProcess          parentProcess\n\tinitProcessStartTime uint64\n\tm                    sync.Mutex\n\tcriuVersion          int\n\tstate                containerState\n\tcreated              time.Time\n\tfifo                 *os.File\n}\n\n// State represents a running container's state\ntype State struct {\n\tBaseState\n\n\t// Platform specific fields below here\n\n\t// Specified if the container was started under the rootless mode.\n\t// Set to true if BaseState.Config.RootlessEUID && BaseState.Config.RootlessCgroups\n\tRootless bool `json:\"rootless\"`\n\n\t// Paths to all the container's cgroups, as returned by (*cgroups.Manager).GetPaths\n\t//\n\t// For cgroup v1, a key is cgroup subsystem name, and the value is the path\n\t// to the cgroup for this subsystem.\n\t//\n\t// For cgroup v2 unified hierarchy, a key is \"\", and the value is the unified path.\n\tCgroupPaths map[string]string `json:\"cgroup_paths\"`\n\n\t// NamespacePaths are filepaths to the container's namespaces. Key is the namespace type\n\t// with the value as the path.\n\tNamespacePaths map[configs.NamespaceType]string `json:\"namespace_paths\"`\n\n\t// Container's standard descriptors (std{in,out,err}), needed for checkpoint and restore\n\tExternalDescriptors []string `json:\"external_descriptors,omitempty\"`\n\n\t// Intel RDT \"resource control\" filesystem path\n\tIntelRdtPath string `json:\"intel_rdt_path\"`\n}\n\n// ID returns the container's unique ID\nfunc (c *Container) ID() string {\n\treturn c.id\n}\n\n// Config returns the container's configuration\nfunc (c *Container) Config() configs.Config {\n\treturn *c.config\n}\n\n// Status returns the current status of the container.\nfunc (c *Container) Status() (Status, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentStatus()\n}\n\n// State returns the current container's state information.\nfunc (c *Container) State() (*State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentState()\n}\n\n// OCIState returns the current container's state information.\nfunc (c *Container) OCIState() (*specs.State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentOCIState()\n}\n\n// ignoreCgroupError filters out cgroup-related errors that can be ignored,\n// because the container is stopped and its cgroup is gone.\nfunc (c *Container) ignoreCgroupError(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif errors.Is(err, os.ErrNotExist) && !c.hasInit() && !c.cgroupManager.Exists() {\n\t\treturn nil\n\t}\n\treturn err\n}\n\n// Processes returns the PIDs inside this container. The PIDs are in the\n// namespace of the calling process.\n//\n// Some of the returned PIDs may no longer refer to processes in the container,\n// unless the container state is PAUSED in which case every PID in the slice is\n// valid.\nfunc (c *Container) Processes() ([]int, error) {\n\tpids, err := c.cgroupManager.GetAllPids()\n\tif err = c.ignoreCgroupError(err); err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get all container pids: %w\", err)\n\t}\n\treturn pids, nil\n}\n\n// Stats returns statistics for the container.\nfunc (c *Container) Stats() (*Stats, error) {\n\tvar (\n\t\terr   error\n\t\tstats = &Stats{}\n\t)\n\tif stats.CgroupStats, err = c.cgroupManager.GetStats(); err != nil {\n\t\treturn stats, fmt.Errorf(\"unable to get container cgroup stats: %w\", err)\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif stats.IntelRdtStats, err = c.intelRdtManager.GetStats(); err != nil {\n\t\t\treturn stats, fmt.Errorf(\"unable to get container Intel RDT stats: %w\", err)\n\t\t}\n\t}\n\tfor _, iface := range c.config.Networks {\n\t\tswitch iface.Type {\n\t\tcase \"veth\":\n\t\t\tistats, err := getNetworkInterfaceStats(iface.HostInterfaceName)\n\t\t\tif err != nil {\n\t\t\t\treturn stats, fmt.Errorf(\"unable to get network stats for interface %q: %w\", iface.HostInterfaceName, err)\n\t\t\t}\n\t\t\tstats.Interfaces = append(stats.Interfaces, istats)\n\t\t}\n\t}\n\treturn stats, nil\n}\n\n// Set resources of container as configured. Can be used to change resources\n// when the container is running.\nfunc (c *Container) Set(config configs.Config) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status == Stopped {\n\t\treturn ErrNotRunning\n\t}\n\tif err := c.cgroupManager.Set(config.Cgroups.Resources); err != nil {\n\t\t// Set configs back\n\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t}\n\t\treturn err\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif err := c.intelRdtManager.Set(&config); err != nil {\n\t\t\t// Set configs back\n\t\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\tif err2 := c.intelRdtManager.Set(c.config); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back intelrdt configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\t// After config setting succeed, update config and states\n\tc.config = &config\n\t_, err = c.updateState(nil)\n\treturn err\n}\n\n// Start starts a process inside the container. Returns error if process fails\n// to start. You can track process lifecycle with passed Process structure.\nfunc (c *Container) Start(process *Process) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tif c.config.Cgroups.Resources.SkipDevices {\n\t\treturn errors.New(\"can't start container with SkipDevices set\")\n\t}\n\tif process.Init {\n\t\tif err := c.createExecFifo(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := c.start(process); err != nil {\n\t\tif process.Init {\n\t\t\tc.deleteExecFifo()\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Run immediately starts the process inside the container. Returns an error if\n// the process fails to start. It does not block waiting for the exec fifo\n// after start returns but opens the fifo after start returns.\nfunc (c *Container) Run(process *Process) error {\n\tif err := c.Start(process); err != nil {\n\t\treturn err\n\t}\n\tif process.Init {\n\t\treturn c.exec()\n\t}\n\treturn nil\n}\n\n// Exec signals the container to exec the users process at the end of the init.\nfunc (c *Container) Exec() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.exec()\n}\n\nfunc (c *Container) exec() error {\n\tpath := filepath.Join(c.stateDir, execFifoFilename)\n\tpid := c.initProcess.pid()\n\tblockingFifoOpenCh := awaitFifoOpen(path)\n\tfor {\n\t\tselect {\n\t\tcase result := <-blockingFifoOpenCh:\n\t\t\treturn handleFifoResult(result)\n\n\t\tcase <-time.After(time.Millisecond * 100):\n\t\t\tstat, err := system.Stat(pid)\n\t\t\tif err != nil || stat.State == system.Zombie {\n\t\t\t\t// could be because process started, ran, and completed between our 100ms timeout and our system.Stat() check.\n\t\t\t\t// see if the fifo exists and has data (with a non-blocking open, which will succeed if the writing process is complete).\n\t\t\t\tif err := handleFifoResult(fifoOpen(path, false)); err != nil {\n\t\t\t\t\treturn errors.New(\"container process is already dead\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc readFromExecFifo(execFifo io.Reader) error {\n\tdata, err := io.ReadAll(execFifo)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(data) <= 0 {\n\t\treturn errors.New(\"cannot start an already running container\")\n\t}\n\treturn nil\n}\n\nfunc awaitFifoOpen(path string) <-chan openResult {\n\tfifoOpened := make(chan openResult)\n\tgo func() {\n\t\tresult := fifoOpen(path, true)\n\t\tfifoOpened <- result\n\t}()\n\treturn fifoOpened\n}\n\nfunc fifoOpen(path string, block bool) openResult {\n\tflags := os.O_RDONLY\n\tif !block {\n\t\tflags |= unix.O_NONBLOCK\n\t}\n\tf, err := os.OpenFile(path, flags, 0)\n\tif err != nil {\n\t\treturn openResult{err: fmt.Errorf(\"exec fifo: %w\", err)}\n\t}\n\treturn openResult{file: f}\n}\n\nfunc handleFifoResult(result openResult) error {\n\tif result.err != nil {\n\t\treturn result.err\n\t}\n\tf := result.file\n\tdefer f.Close()\n\tif err := readFromExecFifo(f); err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(f.Name())\n}\n\ntype openResult struct {\n\tfile *os.File\n\terr  error\n}\n\nfunc (c *Container) start(process *Process) (retErr error) {\n\tparent, err := c.newParentProcess(process)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to create new parent process: %w\", err)\n\t}\n\t// We do not need the cloned binaries once the process is spawned.\n\tdefer process.closeClonedExes()\n\n\tlogsDone := parent.forwardChildLogs()\n\tif logsDone != nil {\n\t\tdefer func() {\n\t\t\t// Wait for log forwarder to finish. This depends on\n\t\t\t// runc init closing the _LIBCONTAINER_LOGPIPE log fd.\n\t\t\terr := <-logsDone\n\t\t\tif err != nil && retErr == nil {\n\t\t\t\tretErr = fmt.Errorf(\"unable to forward init logs: %w\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\tif err := parent.start(); err != nil {\n\t\treturn fmt.Errorf(\"unable to start container process: %w\", err)\n\t}\n\n\tif process.Init {\n\t\tc.fifo.Close()\n\t\tif c.config.Hooks != nil {\n\t\t\ts, err := c.currentOCIState()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := c.config.Hooks.Run(configs.Poststart, s); err != nil {\n\t\t\t\tif err := ignoreTerminateErrors(parent.terminate()); err != nil {\n\t\t\t\t\tlogrus.Warn(fmt.Errorf(\"error running poststart hook: %w\", err))\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Signal sends a specified signal to container's init.\n//\n// When s is SIGKILL and the container does not have its own PID namespace, all\n// the container's processes are killed. In this scenario, the libcontainer\n// user may be required to implement a proper child reaper.\nfunc (c *Container) Signal(s os.Signal) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\t// When a container has its own PID namespace, inside it the init PID\n\t// is 1, and thus it is handled specially by the kernel. In particular,\n\t// killing init with SIGKILL from an ancestor namespace will also kill\n\t// all other processes in that PID namespace (see pid_namespaces(7)).\n\t//\n\t// OTOH, if PID namespace is shared, we should kill all pids to avoid\n\t// leftover processes. Handle this special case here.\n\tif s == unix.SIGKILL && !c.config.Namespaces.IsPrivate(configs.NEWPID) {\n\t\tif err := signalAllProcesses(c.cgroupManager, unix.SIGKILL); err != nil {\n\t\t\treturn fmt.Errorf(\"unable to kill all processes: %w\", err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// To avoid a PID reuse attack, don't kill non-running container.\n\tif !c.hasInit() {\n\t\treturn ErrNotRunning\n\t}\n\tif err := c.initProcess.signal(s); err != nil {\n\t\treturn fmt.Errorf(\"unable to signal init: %w\", err)\n\t}\n\tif s == unix.SIGKILL {\n\t\t// For cgroup v1, killing a process in a frozen cgroup\n\t\t// does nothing until it's thawed. Only thaw the cgroup\n\t\t// for SIGKILL.\n\t\tif paused, _ := c.isPaused(); paused {\n\t\t\t_ = c.cgroupManager.Freeze(configs.Thawed)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *Container) createExecFifo() error {\n\trootuid, err := c.Config().HostRootUID()\n\tif err != nil {\n\t\treturn err\n\t}\n\trootgid, err := c.Config().HostRootGID()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfifoName := filepath.Join(c.stateDir, execFifoFilename)\n\tif _, err := os.Stat(fifoName); err == nil {\n\t\treturn fmt.Errorf(\"exec fifo %s already exists\", fifoName)\n\t}\n\tif err := unix.Mkfifo(fifoName, 0o622); err != nil {\n\t\treturn &os.PathError{Op: \"mkfifo\", Path: fifoName, Err: err}\n\t}\n\t// Ensure permission bits (can be different because of umask).\n\tif err := os.Chmod(fifoName, 0o622); err != nil {\n\t\treturn err\n\t}\n\treturn os.Chown(fifoName, rootuid, rootgid)\n}\n\nfunc (c *Container) deleteExecFifo() {\n\tfifoName := filepath.Join(c.stateDir, execFifoFilename)\n\tos.Remove(fifoName)\n}\n\n// includeExecFifo opens the container's execfifo as a pathfd, so that the\n// container cannot access the statedir (and the FIFO itself remains\n// un-opened). It then adds the FifoFd to the given exec.Cmd as an inherited\n// fd, with _LIBCONTAINER_FIFOFD set to its fd number.\nfunc (c *Container) includeExecFifo(cmd *exec.Cmd) error {\n\tfifoName := filepath.Join(c.stateDir, execFifoFilename)\n\tfifo, err := os.OpenFile(fifoName, unix.O_PATH|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fifo = fifo\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, fifo)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_FIFOFD=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1))\n\treturn nil\n}\n\n// No longer needed in Go 1.21.\nfunc slicesContains[S ~[]E, E comparable](slice S, needle E) bool {\n\tfor _, val := range slice {\n\t\tif val == needle {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isDmzBinarySafe(c *configs.Config) bool {\n\tif !dmz.WorksWithSELinux(c) {\n\t\treturn false\n\t}\n\n\t// Because we set the dumpable flag in nsexec, the only time when it is\n\t// unsafe to use runc-dmz is when the container process would be able to\n\t// race against \"runc init\" and bypass the ptrace_may_access() checks.\n\t//\n\t// This is only the case if the container processes could have\n\t// CAP_SYS_PTRACE somehow (i.e. the capability is present in the bounding,\n\t// inheritable, or ambient sets). Luckily, most containers do not have this\n\t// capability.\n\tif c.Capabilities == nil ||\n\t\t(!slicesContains(c.Capabilities.Bounding, \"CAP_SYS_PTRACE\") &&\n\t\t\t!slicesContains(c.Capabilities.Inheritable, \"CAP_SYS_PTRACE\") &&\n\t\t\t!slicesContains(c.Capabilities.Ambient, \"CAP_SYS_PTRACE\")) {\n\t\treturn true\n\t}\n\n\t// Since Linux 4.10 (see bfedb589252c0) user namespaced containers cannot\n\t// access /proc/$pid/exe of runc after it joins the namespace (until it\n\t// does an exec), regardless of the capability set. This has been\n\t// backported to other distribution kernels, but there's no way of checking\n\t// this cheaply -- better to be safe than sorry here.\n\tlinux410 := kernelversion.KernelVersion{Kernel: 4, Major: 10}\n\tif ok, err := kernelversion.GreaterEqualThan(linux410); ok && err == nil {\n\t\tif c.Namespaces.Contains(configs.NEWUSER) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// Assume it's unsafe otherwise.\n\treturn false\n}\n\nfunc (c *Container) newParentProcess(p *Process) (parentProcess, error) {\n\tcomm, err := newProcessComm()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Make sure we use a new safe copy of /proc/self/exe or the runc-dmz\n\t// binary each time this is called, to make sure that if a container\n\t// manages to overwrite the file it cannot affect other containers on the\n\t// system. For runc, this code will only ever be called once, but\n\t// libcontainer users might call this more than once.\n\tp.closeClonedExes()\n\tvar (\n\t\texePath string\n\t\t// only one of dmzExe or safeExe are used at a time\n\t\tdmzExe, safeExe *os.File\n\t)\n\tif dmz.IsSelfExeCloned() {\n\t\t// /proc/self/exe is already a cloned binary -- no need to do anything\n\t\tlogrus.Debug(\"skipping binary cloning -- /proc/self/exe is already cloned!\")\n\t\t// We don't need to use /proc/thread-self here because the exe mm of a\n\t\t// thread-group is guaranteed to be the same for all threads by\n\t\t// definition. This lets us avoid having to do runtime.LockOSThread.\n\t\texePath = \"/proc/self/exe\"\n\t} else {\n\t\tvar err error\n\t\tif isDmzBinarySafe(c.config) {\n\t\t\tdmzExe, err = dmz.Binary(c.stateDir)\n\t\t\tif err == nil {\n\t\t\t\t// We can use our own executable without cloning if we are\n\t\t\t\t// using runc-dmz. We don't need to use /proc/thread-self here\n\t\t\t\t// because the exe mm of a thread-group is guaranteed to be the\n\t\t\t\t// same for all threads by definition. This lets us avoid\n\t\t\t\t// having to do runtime.LockOSThread.\n\t\t\t\texePath = \"/proc/self/exe\"\n\t\t\t\tp.clonedExes = append(p.clonedExes, dmzExe)\n\t\t\t\tlogrus.Debug(\"runc-dmz: using runc-dmz\") // used for tests\n\t\t\t} else if errors.Is(err, dmz.ErrNoDmzBinary) {\n\t\t\t\tlogrus.Debug(\"runc-dmz binary not embedded in runc binary, falling back to /proc/self/exe clone\")\n\t\t\t} else if err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to create runc-dmz binary clone: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t// If the configuration makes it unsafe to use runc-dmz, pretend we\n\t\t\t// don't have it embedded so we do /proc/self/exe cloning.\n\t\t\tlogrus.Debug(\"container configuration unsafe for runc-dmz, falling back to /proc/self/exe clone\")\n\t\t\terr = dmz.ErrNoDmzBinary\n\t\t}\n\t\tif errors.Is(err, dmz.ErrNoDmzBinary) {\n\t\t\tsafeExe, err = dmz.CloneSelfExe(c.stateDir)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to create safe /proc/self/exe clone for runc init: %w\", err)\n\t\t\t}\n\t\t\texePath = \"/proc/self/fd/\" + strconv.Itoa(int(safeExe.Fd()))\n\t\t\tp.clonedExes = append(p.clonedExes, safeExe)\n\t\t\tlogrus.Debug(\"runc-dmz: using /proc/self/exe clone\") // used for tests\n\t\t}\n\t\t// Just to make sure we don't run without protection.\n\t\tif dmzExe == nil && safeExe == nil {\n\t\t\t// This should never happen.\n\t\t\treturn nil, fmt.Errorf(\"[internal error] attempted to spawn a container with no /proc/self/exe protection\")\n\t\t}\n\t}\n\n\tcmd := exec.Command(exePath, \"init\")\n\tcmd.Args[0] = os.Args[0]\n\tcmd.Stdin = p.Stdin\n\tcmd.Stdout = p.Stdout\n\tcmd.Stderr = p.Stderr\n\tcmd.Dir = c.config.Rootfs\n\tif cmd.SysProcAttr == nil {\n\t\tcmd.SysProcAttr = &unix.SysProcAttr{}\n\t}\n\tcmd.Env = append(cmd.Env, \"GOMAXPROCS=\"+os.Getenv(\"GOMAXPROCS\"))\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)\n\tif p.ConsoleSocket != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket)\n\t\tcmd.Env = append(cmd.Env,\n\t\t\t\"_LIBCONTAINER_CONSOLE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t)\n\t}\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, comm.initSockChild)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_INITPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t)\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, comm.syncSockChild.File())\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_SYNCPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t)\n\n\tif dmzExe != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, dmzExe)\n\t\tcmd.Env = append(cmd.Env,\n\t\t\t\"_LIBCONTAINER_DMZEXEFD=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1))\n\t}\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, comm.logPipeChild)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_LOGPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1))\n\tif p.LogLevel != \"\" {\n\t\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_LOGLEVEL=\"+p.LogLevel)\n\t}\n\n\tif p.PidfdSocket != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.PidfdSocket)\n\t\tcmd.Env = append(cmd.Env,\n\t\t\t\"_LIBCONTAINER_PIDFD_SOCK=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t)\n\t}\n\n\tif safeExe != nil {\n\t\t// Due to a Go stdlib bug, we need to add safeExe to the set of\n\t\t// ExtraFiles otherwise it is possible for the stdlib to clobber the fd\n\t\t// during forkAndExecInChild1 and replace it with some other file that\n\t\t// might be malicious. This is less than ideal (because the descriptor\n\t\t// will be non-O_CLOEXEC) however we have protections in \"runc init\" to\n\t\t// stop us from leaking extra file descriptors.\n\t\t//\n\t\t// See <https://github.com/golang/go/issues/61751>.\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, safeExe)\n\t}\n\n\t// NOTE: when running a container with no PID namespace and the parent\n\t//       process spawning the container is PID1 the pdeathsig is being\n\t//       delivered to the container's init process by the kernel for some\n\t//       reason even with the parent still running.\n\tif c.config.ParentDeathSignal > 0 {\n\t\tcmd.SysProcAttr.Pdeathsig = unix.Signal(c.config.ParentDeathSignal)\n\t}\n\n\tif p.Init {\n\t\t// We only set up fifoFd if we're not doing a `runc exec`. The historic\n\t\t// reason for this is that previously we would pass a dirfd that allowed\n\t\t// for container rootfs escape (and not doing it in `runc exec` avoided\n\t\t// that problem), but we no longer do that. However, there's no need to do\n\t\t// this for `runc exec` so we just keep it this way to be safe.\n\t\tif err := c.includeExecFifo(cmd); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to setup exec fifo: %w\", err)\n\t\t}\n\t\treturn c.newInitProcess(p, cmd, comm)\n\t}\n\treturn c.newSetnsProcess(p, cmd, comm)\n}\n\nfunc (c *Container) newInitProcess(p *Process, cmd *exec.Cmd, comm *processComm) (*initProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initStandard))\n\tnsMaps := make(map[configs.NamespaceType]string)\n\tfor _, ns := range c.config.Namespaces {\n\t\tif ns.Path != \"\" {\n\t\t\tnsMaps[ns.Type] = ns.Path\n\t\t}\n\t}\n\tdata, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinit := &initProcess{\n\t\tcmd:             cmd,\n\t\tcomm:            comm,\n\t\tmanager:         c.cgroupManager,\n\t\tintelRdtManager: c.intelRdtManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tcontainer:       c,\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t}\n\tc.initProcess = init\n\treturn init, nil\n}\n\nfunc (c *Container) newSetnsProcess(p *Process, cmd *exec.Cmd, comm *processComm) (*setnsProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initSetns))\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get container state: %w\", err)\n\t}\n\t// for setns process, we don't have to set cloneflags as the process namespaces\n\t// will only be set via setns syscall\n\tdata, err := c.bootstrapData(0, state.NamespacePaths)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tproc := &setnsProcess{\n\t\tcmd:             cmd,\n\t\tcgroupPaths:     state.CgroupPaths,\n\t\trootlessCgroups: c.config.RootlessCgroups,\n\t\tintelRdtPath:    state.IntelRdtPath,\n\t\tcomm:            comm,\n\t\tmanager:         c.cgroupManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t\tinitProcessPid:  state.InitProcessPid,\n\t}\n\tif len(p.SubCgroupPaths) > 0 {\n\t\tif add, ok := p.SubCgroupPaths[\"\"]; ok {\n\t\t\t// cgroup v1: using the same path for all controllers.\n\t\t\t// cgroup v2: the only possible way.\n\t\t\tfor k := range proc.cgroupPaths {\n\t\t\t\tsubPath := path.Join(proc.cgroupPaths[k], add)\n\t\t\t\tif !strings.HasPrefix(subPath, proc.cgroupPaths[k]) {\n\t\t\t\t\treturn nil, fmt.Errorf(\"%s is not a sub cgroup path\", add)\n\t\t\t\t}\n\t\t\t\tproc.cgroupPaths[k] = subPath\n\t\t\t}\n\t\t\t// cgroup v2: do not try to join init process's cgroup\n\t\t\t// as a fallback (see (*setnsProcess).start).\n\t\t\tproc.initProcessPid = 0\n\t\t} else {\n\t\t\t// Per-controller paths.\n\t\t\tfor ctrl, add := range p.SubCgroupPaths {\n\t\t\t\tif val, ok := proc.cgroupPaths[ctrl]; ok {\n\t\t\t\t\tsubPath := path.Join(val, add)\n\t\t\t\t\tif !strings.HasPrefix(subPath, val) {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"%s is not a sub cgroup path\", add)\n\t\t\t\t\t}\n\t\t\t\t\tproc.cgroupPaths[ctrl] = subPath\n\t\t\t\t} else {\n\t\t\t\t\treturn nil, fmt.Errorf(\"unknown controller %s in SubCgroupPaths\", ctrl)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn proc, nil\n}\n\nfunc (c *Container) newInitConfig(process *Process) *initConfig {\n\tcfg := &initConfig{\n\t\tConfig:           c.config,\n\t\tArgs:             process.Args,\n\t\tEnv:              process.Env,\n\t\tUser:             process.User,\n\t\tAdditionalGroups: process.AdditionalGroups,\n\t\tCwd:              process.Cwd,\n\t\tCapabilities:     process.Capabilities,\n\t\tPassedFilesCount: len(process.ExtraFiles),\n\t\tContainerID:      c.ID(),\n\t\tNoNewPrivileges:  c.config.NoNewPrivileges,\n\t\tRootlessEUID:     c.config.RootlessEUID,\n\t\tRootlessCgroups:  c.config.RootlessCgroups,\n\t\tAppArmorProfile:  c.config.AppArmorProfile,\n\t\tProcessLabel:     c.config.ProcessLabel,\n\t\tRlimits:          c.config.Rlimits,\n\t\tCreateConsole:    process.ConsoleSocket != nil,\n\t\tConsoleWidth:     process.ConsoleWidth,\n\t\tConsoleHeight:    process.ConsoleHeight,\n\t}\n\tif process.NoNewPrivileges != nil {\n\t\tcfg.NoNewPrivileges = *process.NoNewPrivileges\n\t}\n\tif process.AppArmorProfile != \"\" {\n\t\tcfg.AppArmorProfile = process.AppArmorProfile\n\t}\n\tif process.Label != \"\" {\n\t\tcfg.ProcessLabel = process.Label\n\t}\n\tif len(process.Rlimits) > 0 {\n\t\tcfg.Rlimits = process.Rlimits\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tcfg.Cgroup2Path = c.cgroupManager.Path(\"\")\n\t}\n\n\treturn cfg\n}\n\n// Destroy destroys the container, if its in a valid state.\n//\n// Any event registrations are removed before the container is destroyed.\n// No error is returned if the container is already destroyed.\n//\n// Running containers must first be stopped using Signal.\n// Paused containers must first be resumed using Resume.\nfunc (c *Container) Destroy() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tif err := c.state.destroy(); err != nil {\n\t\treturn fmt.Errorf(\"unable to destroy container: %w\", err)\n\t}\n\treturn nil\n}\n\n// Pause pauses the container, if its state is RUNNING or CREATED, changing\n// its state to PAUSED. If the state is already PAUSED, does nothing.\nfunc (c *Container) Pause() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch status {\n\tcase Running, Created:\n\t\tif err := c.cgroupManager.Freeze(configs.Frozen); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.state.transition(&pausedState{\n\t\t\tc: c,\n\t\t})\n\t}\n\treturn ErrNotRunning\n}\n\n// Resume resumes the execution of any user processes in the\n// container before setting the container state to RUNNING.\n// This is only performed if the current state is PAUSED.\n// If the Container state is RUNNING, does nothing.\nfunc (c *Container) Resume() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status != Paused {\n\t\treturn ErrNotPaused\n\t}\n\tif err := c.cgroupManager.Freeze(configs.Thawed); err != nil {\n\t\treturn err\n\t}\n\treturn c.state.transition(&runningState{\n\t\tc: c,\n\t})\n}\n\n// NotifyOOM returns a read-only channel signaling when the container receives\n// an OOM notification.\nfunc (c *Container) NotifyOOM() (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting OOM notifications may fail if you don't have the full access to cgroups\")\n\t}\n\tpath := c.cgroupManager.Path(\"memory\")\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\treturn notifyOnOOMV2(path)\n\t}\n\treturn notifyOnOOM(path)\n}\n\n// NotifyMemoryPressure returns a read-only channel signaling when the\n// container reaches a given pressure level.\nfunc (c *Container) NotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting memory pressure notifications may fail if you don't have the full access to cgroups\")\n\t}\n\treturn notifyMemoryPressure(c.cgroupManager.Path(\"memory\"), level)\n}\n\nfunc (c *Container) updateState(process parentProcess) (*State, error) {\n\tif process != nil {\n\t\tc.initProcess = process\n\t}\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = c.saveState(state)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn state, nil\n}\n\nfunc (c *Container) saveState(s *State) (retErr error) {\n\ttmpFile, err := os.CreateTemp(c.stateDir, \"state-\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\ttmpFile.Close()\n\t\t\tos.Remove(tmpFile.Name())\n\t\t}\n\t}()\n\n\terr = utils.WriteJSON(tmpFile, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = tmpFile.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstateFilePath := filepath.Join(c.stateDir, stateFilename)\n\treturn os.Rename(tmpFile.Name(), stateFilePath)\n}\n\nfunc (c *Container) currentStatus() (Status, error) {\n\tif err := c.refreshState(); err != nil {\n\t\treturn -1, err\n\t}\n\treturn c.state.status(), nil\n}\n\n// refreshState needs to be called to verify that the current state on the\n// container is what is true.  Because consumers of libcontainer can use it\n// out of process we need to verify the container's status based on runtime\n// information and not rely on our in process info.\nfunc (c *Container) refreshState() error {\n\tpaused, err := c.isPaused()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif paused {\n\t\treturn c.state.transition(&pausedState{c: c})\n\t}\n\tif !c.hasInit() {\n\t\treturn c.state.transition(&stoppedState{c: c})\n\t}\n\t// The presence of exec fifo helps to distinguish between\n\t// the created and the running states.\n\tif _, err := os.Stat(filepath.Join(c.stateDir, execFifoFilename)); err == nil {\n\t\treturn c.state.transition(&createdState{c: c})\n\t}\n\treturn c.state.transition(&runningState{c: c})\n}\n\n// hasInit tells whether the container init process exists.\nfunc (c *Container) hasInit() bool {\n\tif c.initProcess == nil {\n\t\treturn false\n\t}\n\tpid := c.initProcess.pid()\n\tstat, err := system.Stat(pid)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif stat.StartTime != c.initProcessStartTime || stat.State == system.Zombie || stat.State == system.Dead {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (c *Container) isPaused() (bool, error) {\n\tstate, err := c.cgroupManager.GetFreezerState()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn state == configs.Frozen, nil\n}\n\nfunc (c *Container) currentState() (*State, error) {\n\tvar (\n\t\tstartTime           uint64\n\t\texternalDescriptors []string\n\t\tpid                 = -1\n\t)\n\tif c.initProcess != nil {\n\t\tpid = c.initProcess.pid()\n\t\tstartTime, _ = c.initProcess.startTime()\n\t\texternalDescriptors = c.initProcess.externalDescriptors()\n\t}\n\n\tintelRdtPath := \"\"\n\tif c.intelRdtManager != nil {\n\t\tintelRdtPath = c.intelRdtManager.GetPath()\n\t}\n\tstate := &State{\n\t\tBaseState: BaseState{\n\t\t\tID:                   c.ID(),\n\t\t\tConfig:               *c.config,\n\t\t\tInitProcessPid:       pid,\n\t\t\tInitProcessStartTime: startTime,\n\t\t\tCreated:              c.created,\n\t\t},\n\t\tRootless:            c.config.RootlessEUID && c.config.RootlessCgroups,\n\t\tCgroupPaths:         c.cgroupManager.GetPaths(),\n\t\tIntelRdtPath:        intelRdtPath,\n\t\tNamespacePaths:      make(map[configs.NamespaceType]string),\n\t\tExternalDescriptors: externalDescriptors,\n\t}\n\tif pid > 0 {\n\t\tfor _, ns := range c.config.Namespaces {\n\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t}\n\t\tfor _, nsType := range configs.NamespaceTypes() {\n\t\t\tif !configs.IsNamespaceSupported(nsType) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, ok := state.NamespacePaths[nsType]; !ok {\n\t\t\t\tns := configs.Namespace{Type: nsType}\n\t\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t\t}\n\t\t}\n\t}\n\treturn state, nil\n}\n\nfunc (c *Container) currentOCIState() (*specs.State, error) {\n\tbundle, annotations := utils.Annotations(c.config.Labels)\n\tstate := &specs.State{\n\t\tVersion:     specs.Version,\n\t\tID:          c.ID(),\n\t\tBundle:      bundle,\n\t\tAnnotations: annotations,\n\t}\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstate.Status = specs.ContainerState(status.String())\n\tif status != Stopped {\n\t\tif c.initProcess != nil {\n\t\t\tstate.Pid = c.initProcess.pid()\n\t\t}\n\t}\n\treturn state, nil\n}\n\n// orderNamespacePaths sorts namespace paths into a list of paths that we\n// can setns in order.\nfunc (c *Container) orderNamespacePaths(namespaces map[configs.NamespaceType]string) ([]string, error) {\n\tpaths := []string{}\n\tfor _, ns := range configs.NamespaceTypes() {\n\n\t\t// Remove namespaces that we don't need to join.\n\t\tif !c.config.Namespaces.Contains(ns) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif p, ok := namespaces[ns]; ok && p != \"\" {\n\t\t\t// check if the requested namespace is supported\n\t\t\tif !configs.IsNamespaceSupported(ns) {\n\t\t\t\treturn nil, fmt.Errorf(\"namespace %s is not supported\", ns)\n\t\t\t}\n\t\t\t// only set to join this namespace if it exists\n\t\t\tif _, err := os.Lstat(p); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"namespace path: %w\", err)\n\t\t\t}\n\t\t\t// do not allow namespace path with comma as we use it to separate\n\t\t\t// the namespace paths\n\t\t\tif strings.ContainsRune(p, ',') {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid namespace path %s\", p)\n\t\t\t}\n\t\t\tpaths = append(paths, fmt.Sprintf(\"%s:%s\", configs.NsName(ns), p))\n\t\t}\n\n\t}\n\n\treturn paths, nil\n}\n\nfunc encodeIDMapping(idMap []configs.IDMap) ([]byte, error) {\n\tdata := bytes.NewBuffer(nil)\n\tfor _, im := range idMap {\n\t\tline := fmt.Sprintf(\"%d %d %d\\n\", im.ContainerID, im.HostID, im.Size)\n\t\tif _, err := data.WriteString(line); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn data.Bytes(), nil\n}\n\n// netlinkError is an error wrapper type for use by custom netlink message\n// types. Panics with errors are wrapped in netlinkError so that the recover\n// in bootstrapData can distinguish intentional panics.\ntype netlinkError struct{ error }\n\n// bootstrapData encodes the necessary data in netlink binary format\n// as a io.Reader.\n// Consumer can write the data to a bootstrap program\n// such as one that uses nsenter package to bootstrap the container's\n// init process correctly, i.e. with correct namespaces, uid/gid\n// mapping etc.\nfunc (c *Container) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string) (_ io.Reader, Err error) {\n\t// create the netlink message\n\tr := nl.NewNetlinkRequest(int(InitMsg), 0)\n\n\t// Our custom messages cannot bubble up an error using returns, instead\n\t// they will panic with the specific error type, netlinkError. In that\n\t// case, recover from the panic and return that as an error.\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif e, ok := r.(netlinkError); ok {\n\t\t\t\tErr = e.error\n\t\t\t} else {\n\t\t\t\tpanic(r)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// write cloneFlags\n\tr.AddData(&Int32msg{\n\t\tType:  CloneFlagsAttr,\n\t\tValue: uint32(cloneFlags),\n\t})\n\n\t// write custom namespace paths\n\tif len(nsMaps) > 0 {\n\t\tnsPaths, err := c.orderNamespacePaths(nsMaps)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  NsPathsAttr,\n\t\t\tValue: []byte(strings.Join(nsPaths, \",\")),\n\t\t})\n\t}\n\n\t// write namespace paths only when we are not joining an existing user ns\n\t_, joinExistingUser := nsMaps[configs.NEWUSER]\n\tif !joinExistingUser {\n\t\t// write uid mappings\n\t\tif len(c.config.UIDMappings) > 0 {\n\t\t\tif c.config.RootlessEUID {\n\t\t\t\t// We resolve the paths for new{u,g}idmap from\n\t\t\t\t// the context of runc to avoid doing a path\n\t\t\t\t// lookup in the nsexec context.\n\t\t\t\tif path, err := execabs.LookPath(\"newuidmap\"); err == nil {\n\t\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\t\tType:  UidmapPathAttr,\n\t\t\t\t\t\tValue: []byte(path),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tb, err := encodeIDMapping(c.config.UIDMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  UidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t}\n\n\t\t// write gid mappings\n\t\tif len(c.config.GIDMappings) > 0 {\n\t\t\tb, err := encodeIDMapping(c.config.GIDMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  GidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t\tif c.config.RootlessEUID {\n\t\t\t\tif path, err := execabs.LookPath(\"newgidmap\"); err == nil {\n\t\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\t\tType:  GidmapPathAttr,\n\t\t\t\t\t\tValue: []byte(path),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tif requiresRootOrMappingTool(c.config) {\n\t\t\t\tr.AddData(&Boolmsg{\n\t\t\t\t\tType:  SetgroupAttr,\n\t\t\t\t\tValue: true,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.config.OomScoreAdj != nil {\n\t\t// write oom_score_adj\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  OomScoreAdjAttr,\n\t\t\tValue: []byte(strconv.Itoa(*c.config.OomScoreAdj)),\n\t\t})\n\t}\n\n\t// write rootless\n\tr.AddData(&Boolmsg{\n\t\tType:  RootlessEUIDAttr,\n\t\tValue: c.config.RootlessEUID,\n\t})\n\n\t// write boottime and monotonic time ns offsets.\n\tif c.config.TimeOffsets != nil {\n\t\tvar offsetSpec bytes.Buffer\n\t\tfor clock, offset := range c.config.TimeOffsets {\n\t\t\tfmt.Fprintf(&offsetSpec, \"%s %d %d\\n\", clock, offset.Secs, offset.Nanosecs)\n\t\t}\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  TimeOffsetsAttr,\n\t\t\tValue: offsetSpec.Bytes(),\n\t\t})\n\t}\n\n\treturn bytes.NewReader(r.Serialize()), nil\n}\n\n// ignoreTerminateErrors returns nil if the given err matches an error known\n// to indicate that the terminate occurred successfully or err was nil, otherwise\n// err is returned unaltered.\nfunc ignoreTerminateErrors(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\t// terminate() might return an error from either Kill or Wait.\n\t// The (*Cmd).Wait documentation says: \"If the command fails to run\n\t// or doesn't complete successfully, the error is of type *ExitError\".\n\t// Filter out such errors (like \"exit status 1\" or \"signal: killed\").\n\tvar exitErr *exec.ExitError\n\tif errors.As(err, &exitErr) {\n\t\treturn nil\n\t}\n\tif errors.Is(err, os.ErrProcessDone) {\n\t\treturn nil\n\t}\n\ts := err.Error()\n\tif strings.Contains(s, \"Wait was already called\") {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc requiresRootOrMappingTool(c *configs.Config) bool {\n\tgidMap := []configs.IDMap{\n\t\t{ContainerID: 0, HostID: int64(os.Getegid()), Size: 1},\n\t}\n\treturn !reflect.DeepEqual(c.GIDMappings, gidMap)\n}\n", "package libcontainer\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/containerd/console\"\n\t\"github.com/moby/sys/user\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/vishvananda/netlink\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/capabilities\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\ntype initType string\n\nconst (\n\tinitSetns    initType = \"setns\"\n\tinitStandard initType = \"standard\"\n)\n\ntype pid struct {\n\tPid           int `json:\"stage2_pid\"`\n\tPidFirstChild int `json:\"stage1_pid\"`\n}\n\n// network is an internal struct used to setup container networks.\ntype network struct {\n\tconfigs.Network\n\n\t// TempVethPeerName is a unique temporary veth peer name that was placed into\n\t// the container's namespace.\n\tTempVethPeerName string `json:\"temp_veth_peer_name\"`\n}\n\n// initConfig is used for transferring parameters from Exec() to Init()\ntype initConfig struct {\n\tArgs             []string              `json:\"args\"`\n\tEnv              []string              `json:\"env\"`\n\tCwd              string                `json:\"cwd\"`\n\tCapabilities     *configs.Capabilities `json:\"capabilities\"`\n\tProcessLabel     string                `json:\"process_label\"`\n\tAppArmorProfile  string                `json:\"apparmor_profile\"`\n\tNoNewPrivileges  bool                  `json:\"no_new_privileges\"`\n\tUser             string                `json:\"user\"`\n\tAdditionalGroups []string              `json:\"additional_groups\"`\n\tConfig           *configs.Config       `json:\"config\"`\n\tNetworks         []*network            `json:\"network\"`\n\tPassedFilesCount int                   `json:\"passed_files_count\"`\n\tContainerID      string                `json:\"containerid\"`\n\tRlimits          []configs.Rlimit      `json:\"rlimits\"`\n\tCreateConsole    bool                  `json:\"create_console\"`\n\tConsoleWidth     uint16                `json:\"console_width\"`\n\tConsoleHeight    uint16                `json:\"console_height\"`\n\tRootlessEUID     bool                  `json:\"rootless_euid,omitempty\"`\n\tRootlessCgroups  bool                  `json:\"rootless_cgroups,omitempty\"`\n\tSpecState        *specs.State          `json:\"spec_state,omitempty\"`\n\tCgroup2Path      string                `json:\"cgroup2_path,omitempty\"`\n}\n\n// Init is part of \"runc init\" implementation.\nfunc Init() {\n\truntime.GOMAXPROCS(1)\n\truntime.LockOSThread()\n\n\tif err := startInitialization(); err != nil {\n\t\t// If the error is returned, it was not communicated\n\t\t// back to the parent (which is not a common case),\n\t\t// so print it to stderr here as a last resort.\n\t\t//\n\t\t// Do not use logrus as we are not sure if it has been\n\t\t// set up yet, but most important, if the parent is\n\t\t// alive (and its log forwarding is working).\n\t\tfmt.Fprintln(os.Stderr, err)\n\t}\n\t// Normally, StartInitialization() never returns, meaning\n\t// if we are here, it had failed.\n\tos.Exit(1)\n}\n\n// Normally, this function does not return. If it returns, with or without an\n// error, it means the initialization has failed. If the error is returned,\n// it means the error can not be communicated back to the parent.\nfunc startInitialization() (retErr error) {\n\t// Get the synchronisation pipe.\n\tenvSyncPipe := os.Getenv(\"_LIBCONTAINER_SYNCPIPE\")\n\tsyncPipeFd, err := strconv.Atoi(envSyncPipe)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_SYNCPIPE: %w\", err)\n\t}\n\tsyncPipe := newSyncSocket(os.NewFile(uintptr(syncPipeFd), \"sync\"))\n\tdefer syncPipe.Close()\n\n\tdefer func() {\n\t\t// If this defer is ever called, this means initialization has failed.\n\t\t// Send the error back to the parent process in the form of an initError\n\t\t// if the sync socket has not been closed.\n\t\tif syncPipe.isClosed() {\n\t\t\treturn\n\t\t}\n\t\tierr := initError{Message: retErr.Error()}\n\t\tif err := writeSyncArg(syncPipe, procError, ierr); err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\treturn\n\t\t}\n\t\t// The error is sent, no need to also return it (or it will be reported twice).\n\t\tretErr = nil\n\t}()\n\n\t// Get the INITPIPE.\n\tenvInitPipe := os.Getenv(\"_LIBCONTAINER_INITPIPE\")\n\tinitPipeFd, err := strconv.Atoi(envInitPipe)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_INITPIPE: %w\", err)\n\t}\n\tinitPipe := os.NewFile(uintptr(initPipeFd), \"init\")\n\tdefer initPipe.Close()\n\n\t// Set up logging. This is used rarely, and mostly for init debugging.\n\n\t// Passing log level is optional; currently libcontainer/integration does not do it.\n\tif levelStr := os.Getenv(\"_LIBCONTAINER_LOGLEVEL\"); levelStr != \"\" {\n\t\tlogLevel, err := strconv.Atoi(levelStr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_LOGLEVEL: %w\", err)\n\t\t}\n\t\tlogrus.SetLevel(logrus.Level(logLevel))\n\t}\n\n\tlogFd, err := strconv.Atoi(os.Getenv(\"_LIBCONTAINER_LOGPIPE\"))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_LOGPIPE: %w\", err)\n\t}\n\tlogPipe := os.NewFile(uintptr(logFd), \"logpipe\")\n\n\tlogrus.SetOutput(logPipe)\n\tlogrus.SetFormatter(new(logrus.JSONFormatter))\n\tlogrus.Debug(\"child process in init()\")\n\n\t// Only init processes have FIFOFD.\n\tvar fifoFile *os.File\n\tenvInitType := os.Getenv(\"_LIBCONTAINER_INITTYPE\")\n\tit := initType(envInitType)\n\tif it == initStandard {\n\t\tfifoFd, err := strconv.Atoi(os.Getenv(\"_LIBCONTAINER_FIFOFD\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_FIFOFD: %w\", err)\n\t\t}\n\t\tfifoFile = os.NewFile(uintptr(fifoFd), \"initfifo\")\n\t}\n\n\tvar consoleSocket *os.File\n\tif envConsole := os.Getenv(\"_LIBCONTAINER_CONSOLE\"); envConsole != \"\" {\n\t\tconsole, err := strconv.Atoi(envConsole)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_CONSOLE: %w\", err)\n\t\t}\n\t\tconsoleSocket = os.NewFile(uintptr(console), \"console-socket\")\n\t\tdefer consoleSocket.Close()\n\t}\n\n\tvar pidfdSocket *os.File\n\tif envSockFd := os.Getenv(\"_LIBCONTAINER_PIDFD_SOCK\"); envSockFd != \"\" {\n\t\tsockFd, err := strconv.Atoi(envSockFd)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_PIDFD_SOCK: %w\", err)\n\t\t}\n\t\tpidfdSocket = os.NewFile(uintptr(sockFd), \"pidfd-socket\")\n\t\tdefer pidfdSocket.Close()\n\t}\n\n\t// Get runc-dmz fds.\n\tvar dmzExe *os.File\n\tif dmzFdStr := os.Getenv(\"_LIBCONTAINER_DMZEXEFD\"); dmzFdStr != \"\" {\n\t\tdmzFd, err := strconv.Atoi(dmzFdStr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_DMZEXEFD: %w\", err)\n\t\t}\n\t\tunix.CloseOnExec(dmzFd)\n\t\tdmzExe = os.NewFile(uintptr(dmzFd), \"runc-dmz\")\n\t}\n\n\t// clear the current process's environment to clean any libcontainer\n\t// specific env vars.\n\tos.Clearenv()\n\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tif err2, ok := err.(error); ok {\n\t\t\t\tretErr = fmt.Errorf(\"panic from initialization: %w, %s\", err2, debug.Stack())\n\t\t\t} else {\n\t\t\t\tretErr = fmt.Errorf(\"panic from initialization: %v, %s\", err, debug.Stack())\n\t\t\t}\n\t\t}\n\t}()\n\n\tvar config initConfig\n\tif err := json.NewDecoder(initPipe).Decode(&config); err != nil {\n\t\treturn err\n\t}\n\n\t// If init succeeds, it will not return, hence none of the defers will be called.\n\treturn containerInit(it, &config, syncPipe, consoleSocket, pidfdSocket, fifoFile, logPipe, dmzExe)\n}\n\nfunc containerInit(t initType, config *initConfig, pipe *syncSocket, consoleSocket, pidfdSocket, fifoFile, logPipe, dmzExe *os.File) error {\n\tif err := populateProcessEnvironment(config.Env); err != nil {\n\t\treturn err\n\t}\n\n\tswitch t {\n\tcase initSetns:\n\t\ti := &linuxSetnsInit{\n\t\t\tpipe:          pipe,\n\t\t\tconsoleSocket: consoleSocket,\n\t\t\tpidfdSocket:   pidfdSocket,\n\t\t\tconfig:        config,\n\t\t\tlogPipe:       logPipe,\n\t\t\tdmzExe:        dmzExe,\n\t\t}\n\t\treturn i.Init()\n\tcase initStandard:\n\t\ti := &linuxStandardInit{\n\t\t\tpipe:          pipe,\n\t\t\tconsoleSocket: consoleSocket,\n\t\t\tpidfdSocket:   pidfdSocket,\n\t\t\tparentPid:     unix.Getppid(),\n\t\t\tconfig:        config,\n\t\t\tfifoFile:      fifoFile,\n\t\t\tlogPipe:       logPipe,\n\t\t\tdmzExe:        dmzExe,\n\t\t}\n\t\treturn i.Init()\n\t}\n\treturn fmt.Errorf(\"unknown init type %q\", t)\n}\n\n// populateProcessEnvironment loads the provided environment variables into the\n// current processes's environment.\nfunc populateProcessEnvironment(env []string) error {\n\tfor _, pair := range env {\n\t\tp := strings.SplitN(pair, \"=\", 2)\n\t\tif len(p) < 2 {\n\t\t\treturn errors.New(\"invalid environment variable: missing '='\")\n\t\t}\n\t\tname, val := p[0], p[1]\n\t\tif name == \"\" {\n\t\t\treturn errors.New(\"invalid environment variable: name cannot be empty\")\n\t\t}\n\t\tif strings.IndexByte(name, 0) >= 0 {\n\t\t\treturn fmt.Errorf(\"invalid environment variable %q: name contains nul byte (\\\\x00)\", name)\n\t\t}\n\t\tif strings.IndexByte(val, 0) >= 0 {\n\t\t\treturn fmt.Errorf(\"invalid environment variable %q: value contains nul byte (\\\\x00)\", name)\n\t\t}\n\t\tif err := os.Setenv(name, val); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// finalizeNamespace drops the caps, sets the correct user\n// and working dir, and closes any leaked file descriptors\n// before executing the command inside the namespace\nfunc finalizeNamespace(config *initConfig) error {\n\t// Ensure that all unwanted fds we may have accidentally\n\t// inherited are marked close-on-exec so they stay out of the\n\t// container\n\tif err := utils.CloseExecFrom(config.PassedFilesCount + 3); err != nil {\n\t\treturn fmt.Errorf(\"error closing exec fds: %w\", err)\n\t}\n\n\t// we only do chdir if it's specified\n\tdoChdir := config.Cwd != \"\"\n\tif doChdir {\n\t\t// First, attempt the chdir before setting up the user.\n\t\t// This could allow us to access a directory that the user running runc can access\n\t\t// but the container user cannot.\n\t\terr := unix.Chdir(config.Cwd)\n\t\tswitch {\n\t\tcase err == nil:\n\t\t\tdoChdir = false\n\t\tcase os.IsPermission(err):\n\t\t\t// If we hit an EPERM, we should attempt again after setting up user.\n\t\t\t// This will allow us to successfully chdir if the container user has access\n\t\t\t// to the directory, but the user running runc does not.\n\t\t\t// This is useful in cases where the cwd is also a volume that's been chowned to the container user.\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"chdir to cwd (%q) set in config.json failed: %w\", config.Cwd, err)\n\t\t}\n\t}\n\n\tcaps := &configs.Capabilities{}\n\tif config.Capabilities != nil {\n\t\tcaps = config.Capabilities\n\t} else if config.Config.Capabilities != nil {\n\t\tcaps = config.Config.Capabilities\n\t}\n\tw, err := capabilities.New(caps)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// drop capabilities in bounding set before changing user\n\tif err := w.ApplyBoundingSet(); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply bounding set: %w\", err)\n\t}\n\t// preserve existing capabilities while we change users\n\tif err := system.SetKeepCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to set keep caps: %w\", err)\n\t}\n\tif err := setupUser(config); err != nil {\n\t\treturn fmt.Errorf(\"unable to setup user: %w\", err)\n\t}\n\t// Change working directory AFTER the user has been set up, if we haven't done it yet.\n\tif doChdir {\n\t\tif err := unix.Chdir(config.Cwd); err != nil {\n\t\t\treturn fmt.Errorf(\"chdir to cwd (%q) set in config.json failed: %w\", config.Cwd, err)\n\t\t}\n\t}\n\tif err := system.ClearKeepCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to clear keep caps: %w\", err)\n\t}\n\tif err := w.ApplyCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply caps: %w\", err)\n\t}\n\treturn nil\n}\n\n// setupConsole sets up the console from inside the container, and sends the\n// master pty fd to the config.Pipe (using cmsg). This is done to ensure that\n// consoles are scoped to a container properly (see runc#814 and the many\n// issues related to that). This has to be run *after* we've pivoted to the new\n// rootfs (and the users' configuration is entirely set up).\nfunc setupConsole(socket *os.File, config *initConfig, mount bool) error {\n\tdefer socket.Close()\n\t// At this point, /dev/ptmx points to something that we would expect. We\n\t// used to change the owner of the slave path, but since the /dev/pts mount\n\t// can have gid=X set (at the users' option). So touching the owner of the\n\t// slave PTY is not necessary, as the kernel will handle that for us. Note\n\t// however, that setupUser (specifically fixStdioPermissions) *will* change\n\t// the UID owner of the console to be the user the process will run as (so\n\t// they can actually control their console).\n\n\tpty, slavePath, err := console.NewPty()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// After we return from here, we don't need the console anymore.\n\tdefer pty.Close()\n\n\tif config.ConsoleHeight != 0 && config.ConsoleWidth != 0 {\n\t\terr = pty.Resize(console.WinSize{\n\t\t\tHeight: config.ConsoleHeight,\n\t\t\tWidth:  config.ConsoleWidth,\n\t\t})\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Mount the console inside our rootfs.\n\tif mount {\n\t\tif err := mountConsole(slavePath); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// While we can access console.master, using the API is a good idea.\n\tif err := utils.SendRawFd(socket, pty.Name(), pty.Fd()); err != nil {\n\t\treturn err\n\t}\n\truntime.KeepAlive(pty)\n\n\t// Now, dup over all the things.\n\treturn dupStdio(slavePath)\n}\n\n// syncParentReady sends to the given pipe a JSON payload which indicates that\n// the init is ready to Exec the child process. It then waits for the parent to\n// indicate that it is cleared to Exec.\nfunc syncParentReady(pipe *syncSocket) error {\n\t// Tell parent.\n\tif err := writeSync(pipe, procReady); err != nil {\n\t\treturn err\n\t}\n\t// Wait for parent to give the all-clear.\n\treturn readSync(pipe, procRun)\n}\n\n// syncParentHooks sends to the given pipe a JSON payload which indicates that\n// the parent should execute pre-start hooks. It then waits for the parent to\n// indicate that it is cleared to resume.\nfunc syncParentHooks(pipe *syncSocket) error {\n\t// Tell parent.\n\tif err := writeSync(pipe, procHooks); err != nil {\n\t\treturn err\n\t}\n\t// Wait for parent to give the all-clear.\n\treturn readSync(pipe, procHooksDone)\n}\n\n// syncParentSeccomp sends the fd associated with the seccomp file descriptor\n// to the parent, and wait for the parent to do pidfd_getfd() to grab a copy.\nfunc syncParentSeccomp(pipe *syncSocket, seccompFd *os.File) error {\n\tif seccompFd == nil {\n\t\treturn nil\n\t}\n\tdefer seccompFd.Close()\n\n\t// Tell parent to grab our fd.\n\t//\n\t// Notably, we do not use writeSyncFile here because a container might have\n\t// an SCMP_ACT_NOTIFY action on sendmsg(2) so we need to use the smallest\n\t// possible number of system calls here because all of those syscalls\n\t// cannot be used with SCMP_ACT_NOTIFY as a result (any syscall we use here\n\t// before the parent gets the file descriptor would deadlock \"runc init\" if\n\t// we allowed it for SCMP_ACT_NOTIFY). See seccomp.InitSeccomp() for more\n\t// details.\n\tif err := writeSyncArg(pipe, procSeccomp, seccompFd.Fd()); err != nil {\n\t\treturn err\n\t}\n\t// Wait for parent to tell us they've grabbed the seccompfd.\n\treturn readSync(pipe, procSeccompDone)\n}\n\n// setupUser changes the groups, gid, and uid for the user inside the container\nfunc setupUser(config *initConfig) error {\n\t// Set up defaults.\n\tdefaultExecUser := user.ExecUser{\n\t\tUid:  0,\n\t\tGid:  0,\n\t\tHome: \"/\",\n\t}\n\n\tpasswdPath, err := user.GetPasswdPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgroupPath, err := user.GetGroupPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\texecUser, err := user.GetExecUserPath(config.User, &defaultExecUser, passwdPath, groupPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar addGroups []int\n\tif len(config.AdditionalGroups) > 0 {\n\t\taddGroups, err = user.GetAdditionalGroupsPath(config.AdditionalGroups, groupPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif config.RootlessEUID {\n\t\t// We cannot set any additional groups in a rootless container and thus\n\t\t// we bail if the user asked us to do so. TODO: We currently can't do\n\t\t// this check earlier, but if libcontainer.Process.User was typesafe\n\t\t// this might work.\n\t\tif len(addGroups) > 0 {\n\t\t\treturn errors.New(\"cannot set any additional groups in a rootless container\")\n\t\t}\n\t}\n\n\t// Before we change to the container's user make sure that the processes\n\t// STDIO is correctly owned by the user that we are switching to.\n\tif err := fixStdioPermissions(execUser); err != nil {\n\t\treturn err\n\t}\n\n\t// We don't need to use /proc/thread-self here because setgroups is a\n\t// per-userns file and thus is global to all threads in a thread-group.\n\t// This lets us avoid having to do runtime.LockOSThread.\n\tsetgroups, err := os.ReadFile(\"/proc/self/setgroups\")\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\n\t// This isn't allowed in an unprivileged user namespace since Linux 3.19.\n\t// There's nothing we can do about /etc/group entries, so we silently\n\t// ignore setting groups here (since the user didn't explicitly ask us to\n\t// set the group).\n\tallowSupGroups := !config.RootlessEUID && string(bytes.TrimSpace(setgroups)) != \"deny\"\n\n\tif allowSupGroups {\n\t\tsuppGroups := append(execUser.Sgids, addGroups...)\n\t\tif err := unix.Setgroups(suppGroups); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"setgroups\", Err: err}\n\t\t}\n\t}\n\n\tif err := unix.Setgid(execUser.Gid); err != nil {\n\t\tif err == unix.EINVAL {\n\t\t\treturn fmt.Errorf(\"cannot setgid to unmapped gid %d in user namespace\", execUser.Gid)\n\t\t}\n\t\treturn err\n\t}\n\tif err := unix.Setuid(execUser.Uid); err != nil {\n\t\tif err == unix.EINVAL {\n\t\t\treturn fmt.Errorf(\"cannot setuid to unmapped uid %d in user namespace\", execUser.Uid)\n\t\t}\n\t\treturn err\n\t}\n\n\t// if we didn't get HOME already, set it based on the user's HOME\n\tif envHome := os.Getenv(\"HOME\"); envHome == \"\" {\n\t\tif err := os.Setenv(\"HOME\", execUser.Home); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// fixStdioPermissions fixes the permissions of PID 1's STDIO within the container to the specified user.\n// The ownership needs to match because it is created outside of the container and needs to be\n// localized.\nfunc fixStdioPermissions(u *user.ExecUser) error {\n\tvar null unix.Stat_t\n\tif err := unix.Stat(\"/dev/null\", &null); err != nil {\n\t\treturn &os.PathError{Op: \"stat\", Path: \"/dev/null\", Err: err}\n\t}\n\tfor _, file := range []*os.File{os.Stdin, os.Stdout, os.Stderr} {\n\t\tvar s unix.Stat_t\n\t\tif err := unix.Fstat(int(file.Fd()), &s); err != nil {\n\t\t\treturn &os.PathError{Op: \"fstat\", Path: file.Name(), Err: err}\n\t\t}\n\n\t\t// Skip chown if uid is already the one we want or any of the STDIO descriptors\n\t\t// were redirected to /dev/null.\n\t\tif int(s.Uid) == u.Uid || s.Rdev == null.Rdev {\n\t\t\tcontinue\n\t\t}\n\n\t\t// We only change the uid (as it is possible for the mount to\n\t\t// prefer a different gid, and there's no reason for us to change it).\n\t\t// The reason why we don't just leave the default uid=X mount setup is\n\t\t// that users expect to be able to actually use their console. Without\n\t\t// this code, you couldn't effectively run as a non-root user inside a\n\t\t// container and also have a console set up.\n\t\tif err := file.Chown(u.Uid, int(s.Gid)); err != nil {\n\t\t\t// If we've hit an EINVAL then s.Gid isn't mapped in the user\n\t\t\t// namespace. If we've hit an EPERM then the inode's current owner\n\t\t\t// is not mapped in our user namespace (in particular,\n\t\t\t// privileged_wrt_inode_uidgid() has failed). Read-only\n\t\t\t// /dev can result in EROFS error. In any case, it's\n\t\t\t// better for us to just not touch the stdio rather\n\t\t\t// than bail at this point.\n\n\t\t\tif errors.Is(err, unix.EINVAL) || errors.Is(err, unix.EPERM) || errors.Is(err, unix.EROFS) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// setupNetwork sets up and initializes any network interface inside the container.\nfunc setupNetwork(config *initConfig) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := strategy.initialize(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRoute(config *configs.Config) error {\n\tfor _, config := range config.Routes {\n\t\t_, dst, err := net.ParseCIDR(config.Destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrc := net.ParseIP(config.Source)\n\t\tif src == nil {\n\t\t\treturn fmt.Errorf(\"Invalid source for route: %s\", config.Source)\n\t\t}\n\t\tgw := net.ParseIP(config.Gateway)\n\t\tif gw == nil {\n\t\t\treturn fmt.Errorf(\"Invalid gateway for route: %s\", config.Gateway)\n\t\t}\n\t\tl, err := netlink.LinkByName(config.InterfaceName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\troute := &netlink.Route{\n\t\t\tScope:     netlink.SCOPE_UNIVERSE,\n\t\t\tDst:       dst,\n\t\t\tSrc:       src,\n\t\t\tGw:        gw,\n\t\t\tLinkIndex: l.Attrs().Index,\n\t\t}\n\t\tif err := netlink.RouteAdd(route); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRlimits(limits []configs.Rlimit, pid int) error {\n\tfor _, rlimit := range limits {\n\t\tif err := unix.Prlimit(pid, rlimit.Type, &unix.Rlimit{Max: rlimit.Hard, Cur: rlimit.Soft}, nil); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting rlimit type %v: %w\", rlimit.Type, err)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupScheduler(config *configs.Config) error {\n\tattr, err := configs.ToSchedAttr(config.Scheduler)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := unix.SchedSetAttr(0, attr, 0); err != nil {\n\t\tif errors.Is(err, unix.EPERM) && config.Cgroups.CpusetCpus != \"\" {\n\t\t\treturn errors.New(\"process scheduler can't be used together with AllowedCPUs\")\n\t\t}\n\t\treturn fmt.Errorf(\"error setting scheduler: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc setupPersonality(config *configs.Config) error {\n\treturn system.SetLinuxPersonality(config.Personality.Domain)\n}\n\n// signalAllProcesses freezes then iterates over all the processes inside the\n// manager's cgroups sending the signal s to them.\nfunc signalAllProcesses(m cgroups.Manager, s unix.Signal) error {\n\tif !m.Exists() {\n\t\treturn ErrNotRunning\n\t}\n\t// Use cgroup.kill, if available.\n\tif s == unix.SIGKILL {\n\t\tif p := m.Path(\"\"); p != \"\" { // Either cgroup v2 or hybrid.\n\t\t\terr := cgroups.WriteFile(p, \"cgroup.kill\", \"1\")\n\t\t\tif err == nil || !errors.Is(err, os.ErrNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Fallback to old implementation.\n\t\t}\n\t}\n\n\tif err := m.Freeze(configs.Frozen); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\tpids, err := m.GetAllPids()\n\tif err != nil {\n\t\tif err := m.Freeze(configs.Thawed); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t\treturn err\n\t}\n\tfor _, pid := range pids {\n\t\terr := unix.Kill(pid, s)\n\t\tif err != nil && err != unix.ESRCH {\n\t\t\tlogrus.Warnf(\"kill %d: %v\", pid, err)\n\t\t}\n\t}\n\tif err := m.Freeze(configs.Thawed); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\n\treturn nil\n}\n\n// setupPidfd opens a process file descriptor of init process, and sends the\n// file descriptor back to the socket.\nfunc setupPidfd(socket *os.File, initType string) error {\n\tdefer socket.Close()\n\n\tpidFd, err := unix.PidfdOpen(os.Getpid(), 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to pidfd_open: %w\", err)\n\t}\n\n\tif err := utils.SendRawFd(socket, initType, uintptr(pidFd)); err != nil {\n\t\tunix.Close(pidFd)\n\t\treturn fmt.Errorf(\"failed to send pidfd on socket: %w\", err)\n\t}\n\treturn unix.Close(pidFd)\n}\n", "//go:build linux && cgo && seccomp\n// +build linux,cgo,seccomp\n\npackage integration\n\nimport (\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\tlibseccomp \"github.com/seccomp/libseccomp-golang\"\n)\n\nfunc TestSeccompDenyGetcwdWithErrno(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\terrnoRet := uint(syscall.ESRCH)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:     \"getcwd\",\n\t\t\t\tAction:   configs.Errno,\n\t\t\t\tErrnoRet: &errnoRet,\n\t\t\t},\n\t\t},\n\t}\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer container.Destroy() //nolint:errcheck\n\n\tbuffers := newStdBuffers()\n\tpwd := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"pwd\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  buffers.Stdin,\n\t\tStdout: buffers.Stdout,\n\t\tStderr: buffers.Stderr,\n\t\tInit:   true,\n\t}\n\n\terr = container.Run(pwd)\n\tok(t, err)\n\tps, err := pwd.Wait()\n\tif err == nil {\n\t\tt.Fatal(\"Expecting error (negative return code); instead exited cleanly!\")\n\t}\n\n\tvar exitCode int\n\tstatus := ps.Sys().(syscall.WaitStatus)\n\tif status.Exited() {\n\t\texitCode = status.ExitStatus()\n\t} else if status.Signaled() {\n\t\texitCode = -int(status.Signal())\n\t} else {\n\t\tt.Fatalf(\"Unrecognized exit reason!\")\n\t}\n\n\tif exitCode == 0 {\n\t\tt.Fatalf(\"Getcwd should fail with negative exit code, instead got %d!\", exitCode)\n\t}\n\n\texpected := \"pwd: getcwd: No such process\"\n\tactual := strings.Trim(buffers.Stderr.String(), \"\\n\")\n\tif actual != expected {\n\t\tt.Fatalf(\"Expected output %s but got %s\\n\", expected, actual)\n\t}\n}\n\nfunc TestSeccompDenyGetcwd(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"getcwd\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t},\n\t\t},\n\t}\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer container.Destroy() //nolint:errcheck\n\n\tbuffers := newStdBuffers()\n\tpwd := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"pwd\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  buffers.Stdin,\n\t\tStdout: buffers.Stdout,\n\t\tStderr: buffers.Stderr,\n\t\tInit:   true,\n\t}\n\n\terr = container.Run(pwd)\n\tok(t, err)\n\tps, err := pwd.Wait()\n\tif err == nil {\n\t\tt.Fatal(\"Expecting error (negative return code); instead exited cleanly!\")\n\t}\n\n\tvar exitCode int\n\tstatus := ps.Sys().(syscall.WaitStatus)\n\tif status.Exited() {\n\t\texitCode = status.ExitStatus()\n\t} else if status.Signaled() {\n\t\texitCode = -int(status.Signal())\n\t} else {\n\t\tt.Fatalf(\"Unrecognized exit reason!\")\n\t}\n\n\tif exitCode == 0 {\n\t\tt.Fatalf(\"Getcwd should fail with negative exit code, instead got %d!\", exitCode)\n\t}\n\n\texpected := \"pwd: getcwd: Operation not permitted\"\n\tactual := strings.Trim(buffers.Stderr.String(), \"\\n\")\n\tif actual != expected {\n\t\tt.Fatalf(\"Expected output %s but got %s\\n\", expected, actual)\n\t}\n}\n\nfunc TestSeccompPermitWriteConditional(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer container.Destroy() //nolint:errcheck\n\n\tbuffers := newStdBuffers()\n\tdmesg := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"busybox\", \"ls\", \"/\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  buffers.Stdin,\n\t\tStdout: buffers.Stdout,\n\t\tStderr: buffers.Stderr,\n\t\tInit:   true,\n\t}\n\n\terr = container.Run(dmesg)\n\tok(t, err)\n\tif _, err := dmesg.Wait(); err != nil {\n\t\tt.Fatalf(\"%s: %s\", err, buffers.Stderr)\n\t}\n}\n\nfunc TestSeccompDenyWriteConditional(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\t// Only test if library version is v2.2.1 or higher\n\t// Conditional filtering will always error in v2.2.0 and lower\n\tmajor, minor, micro := libseccomp.GetLibraryVersion()\n\tif (major == 2 && minor < 2) || (major == 2 && minor == 2 && micro < 1) {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer container.Destroy() //nolint:errcheck\n\n\tbuffers := newStdBuffers()\n\tdmesg := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"busybox\", \"ls\", \"does_not_exist\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  buffers.Stdin,\n\t\tStdout: buffers.Stdout,\n\t\tStderr: buffers.Stderr,\n\t\tInit:   true,\n\t}\n\n\terr = container.Run(dmesg)\n\tok(t, err)\n\n\tps, err := dmesg.Wait()\n\tif err == nil {\n\t\tt.Fatal(\"Expecting negative return, instead got 0!\")\n\t}\n\n\tvar exitCode int\n\tstatus := ps.Sys().(syscall.WaitStatus)\n\tif status.Exited() {\n\t\texitCode = status.ExitStatus()\n\t} else if status.Signaled() {\n\t\texitCode = -int(status.Signal())\n\t} else {\n\t\tt.Fatalf(\"Unrecognized exit reason!\")\n\t}\n\n\tif exitCode == 0 {\n\t\tt.Fatalf(\"Busybox should fail with negative exit code, instead got %d!\", exitCode)\n\t}\n\n\t// We're denying write to stderr, so we expect an empty buffer\n\texpected := \"\"\n\tactual := strings.Trim(buffers.Stderr.String(), \"\\n\")\n\tif actual != expected {\n\t\tt.Fatalf(\"Expected output %s but got %s\\n\", expected, actual)\n\t}\n}\n\nfunc TestSeccompPermitWriteMultipleConditions(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 2,\n\t\t\t\t\t\tValue: 0,\n\t\t\t\t\t\tOp:    configs.NotEqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tbuffers := runContainerOk(t, config, \"ls\", \"/\")\n\t// We don't need to verify the actual thing printed\n\t// Just that something was written to stdout\n\tif len(buffers.Stdout.String()) == 0 {\n\t\tt.Fatalf(\"Nothing was written to stdout, write call failed!\\n\")\n\t}\n}\n\nfunc TestSeccompDenyWriteMultipleConditions(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\t// Only test if library version is v2.2.1 or higher\n\t// Conditional filtering will always error in v2.2.0 and lower\n\tmajor, minor, micro := libseccomp.GetLibraryVersion()\n\tif (major == 2 && minor < 2) || (major == 2 && minor == 2 && micro < 1) {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 2,\n\t\t\t\t\t\tValue: 0,\n\t\t\t\t\t\tOp:    configs.NotEqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tbuffers, exitCode, err := runContainer(t, config, \"ls\", \"/does_not_exist\")\n\tif err == nil {\n\t\tt.Fatalf(\"Expecting error return, instead got 0\")\n\t}\n\tif exitCode == 0 {\n\t\tt.Fatalf(\"Busybox should fail with negative exit code, instead got %d!\", exitCode)\n\t}\n\n\texpected := \"\"\n\tactual := strings.Trim(buffers.Stderr.String(), \"\\n\")\n\tif actual != expected {\n\t\tt.Fatalf(\"Expected output %s but got %s\\n\", expected, actual)\n\t}\n}\n\nfunc TestSeccompMultipleConditionSameArgDeniesStdout(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\t// Prevent writing to both stdout and stderr.\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 1,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tbuffers := runContainerOk(t, config, \"ls\", \"/\")\n\t// Verify that nothing was printed\n\tif len(buffers.Stdout.String()) != 0 {\n\t\tt.Fatalf(\"Something was written to stdout, write call succeeded!\\n\")\n\t}\n}\n\nfunc TestSeccompMultipleConditionSameArgDeniesStderr(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\t// Prevent writing to both stdout and stderr.\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 1,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tbuffers, exitCode, err := runContainer(t, config, \"ls\", \"/does_not_exist\")\n\tif err == nil {\n\t\tt.Fatalf(\"Expecting error return, instead got 0\")\n\t}\n\tif exitCode == 0 {\n\t\tt.Fatalf(\"Busybox should fail with negative exit code, instead got %d!\", exitCode)\n\t}\n\t// Verify nothing was printed\n\tif len(buffers.Stderr.String()) != 0 {\n\t\tt.Fatalf(\"Something was written to stderr, write call succeeded!\\n\")\n\t}\n}\n", "package libcontainer\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\n\t\"github.com/opencontainers/selinux/go-selinux\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runc/libcontainer/keys\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n)\n\n// linuxSetnsInit performs the container's initialization for running a new process\n// inside an existing container.\ntype linuxSetnsInit struct {\n\tpipe          *syncSocket\n\tconsoleSocket *os.File\n\tpidfdSocket   *os.File\n\tconfig        *initConfig\n\tlogPipe       *os.File\n\tdmzExe        *os.File\n}\n\nfunc (l *linuxSetnsInit) getSessionRingName() string {\n\treturn \"_ses.\" + l.config.ContainerID\n}\n\nfunc (l *linuxSetnsInit) Init() error {\n\tif !l.config.Config.NoNewKeyring {\n\t\tif err := selinux.SetKeyLabel(l.config.ProcessLabel); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer selinux.SetKeyLabel(\"\") //nolint: errcheck\n\t\t// Do not inherit the parent's session keyring.\n\t\tif _, err := keys.JoinSessionKeyring(l.getSessionRingName()); err != nil {\n\t\t\t// Same justification as in standart_init_linux.go as to why we\n\t\t\t// don't bail on ENOSYS.\n\t\t\t//\n\t\t\t// TODO(cyphar): And we should have logging here too.\n\t\t\tif !errors.Is(err, unix.ENOSYS) {\n\t\t\t\treturn fmt.Errorf(\"unable to join session keyring: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\tif l.config.CreateConsole {\n\t\tif err := setupConsole(l.consoleSocket, l.config, false); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := system.Setctty(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif l.pidfdSocket != nil {\n\t\tif err := setupPidfd(l.pidfdSocket, \"setns\"); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to setup pidfd: %w\", err)\n\t\t}\n\t}\n\tif l.config.NoNewPrivileges {\n\t\tif err := unix.Prctl(unix.PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif l.config.Config.Umask != nil {\n\t\tunix.Umask(int(*l.config.Config.Umask))\n\t}\n\n\tif l.config.Config.Scheduler != nil {\n\t\tif err := setupScheduler(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := selinux.SetExecLabel(l.config.ProcessLabel); err != nil {\n\t\treturn err\n\t}\n\tdefer selinux.SetExecLabel(\"\") //nolint: errcheck\n\t// Without NoNewPrivileges seccomp is a privileged operation, so we need to\n\t// do this before dropping capabilities; otherwise do it as late as possible\n\t// just before execve so as few syscalls take place after it as possible.\n\tif l.config.Config.Seccomp != nil && !l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := finalizeNamespace(l.config); err != nil {\n\t\treturn err\n\t}\n\tif err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {\n\t\treturn err\n\t}\n\tif l.config.Config.Personality != nil {\n\t\tif err := setupPersonality(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Check for the arg early to make sure it exists.\n\tname, err := exec.LookPath(l.config.Args[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\t// exec.LookPath in Go < 1.20 might return no error for an executable\n\t// residing on a file system mounted with noexec flag, so perform this\n\t// extra check now while we can still return a proper error.\n\t// TODO: remove this once go < 1.20 is not supported.\n\tif err := eaccess(name); err != nil {\n\t\treturn &os.PathError{Op: \"eaccess\", Path: name, Err: err}\n\t}\n\t// Set seccomp as close to execve as possible, so as few syscalls take\n\t// place afterward (reducing the amount of syscalls that users need to\n\t// enable in their seccomp profiles).\n\tif l.config.Config.Seccomp != nil && l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to init seccomp: %w\", err)\n\t\t}\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Close the log pipe fd so the parent's ForwardLogs can exit.\n\tlogrus.Debugf(\"setns_init: about to exec\")\n\tif err := l.logPipe.Close(); err != nil {\n\t\treturn fmt.Errorf(\"close log pipe: %w\", err)\n\t}\n\n\tif l.dmzExe != nil {\n\t\tl.config.Args[0] = name\n\t\treturn system.Fexecve(l.dmzExe.Fd(), l.config.Args, os.Environ())\n\t}\n\treturn system.Exec(name, l.config.Args, os.Environ())\n}\n", "package libcontainer\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/keys\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\ntype linuxStandardInit struct {\n\tpipe          *syncSocket\n\tconsoleSocket *os.File\n\tpidfdSocket   *os.File\n\tparentPid     int\n\tfifoFile      *os.File\n\tlogPipe       *os.File\n\tdmzExe        *os.File\n\tconfig        *initConfig\n}\n\nfunc (l *linuxStandardInit) getSessionRingParams() (string, uint32, uint32) {\n\tvar newperms uint32\n\n\tif l.config.Config.Namespaces.Contains(configs.NEWUSER) {\n\t\t// With user ns we need 'other' search permissions.\n\t\tnewperms = 0x8\n\t} else {\n\t\t// Without user ns we need 'UID' search permissions.\n\t\tnewperms = 0x80000\n\t}\n\n\t// Create a unique per session container name that we can join in setns;\n\t// However, other containers can also join it.\n\treturn \"_ses.\" + l.config.ContainerID, 0xffffffff, newperms\n}\n\nfunc (l *linuxStandardInit) Init() error {\n\tif !l.config.Config.NoNewKeyring {\n\t\tif err := selinux.SetKeyLabel(l.config.ProcessLabel); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer selinux.SetKeyLabel(\"\") //nolint: errcheck\n\t\tringname, keepperms, newperms := l.getSessionRingParams()\n\n\t\t// Do not inherit the parent's session keyring.\n\t\tif sessKeyId, err := keys.JoinSessionKeyring(ringname); err != nil {\n\t\t\t// If keyrings aren't supported then it is likely we are on an\n\t\t\t// older kernel (or inside an LXC container). While we could bail,\n\t\t\t// the security feature we are using here is best-effort (it only\n\t\t\t// really provides marginal protection since VFS credentials are\n\t\t\t// the only significant protection of keyrings).\n\t\t\t//\n\t\t\t// TODO(cyphar): Log this so people know what's going on, once we\n\t\t\t//               have proper logging in 'runc init'.\n\t\t\tif !errors.Is(err, unix.ENOSYS) {\n\t\t\t\treturn fmt.Errorf(\"unable to join session keyring: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t// Make session keyring searchable. If we've gotten this far we\n\t\t\t// bail on any error -- we don't want to have a keyring with bad\n\t\t\t// permissions.\n\t\t\tif err := keys.ModKeyringPerm(sessKeyId, keepperms, newperms); err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to mod keyring permissions: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := setupNetwork(l.config); err != nil {\n\t\treturn err\n\t}\n\tif err := setupRoute(l.config.Config); err != nil {\n\t\treturn err\n\t}\n\n\t// initialises the labeling system\n\tselinux.GetEnabled()\n\n\terr := prepareRootfs(l.pipe, l.config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set up the console. This has to be done *before* we finalize the rootfs,\n\t// but *after* we've given the user the chance to set up all of the mounts\n\t// they wanted.\n\tif l.config.CreateConsole {\n\t\tif err := setupConsole(l.consoleSocket, l.config, true); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := system.Setctty(); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"ioctl(setctty)\", Err: err}\n\t\t}\n\t}\n\n\tif l.pidfdSocket != nil {\n\t\tif err := setupPidfd(l.pidfdSocket, \"standard\"); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to setup pidfd: %w\", err)\n\t\t}\n\t}\n\n\t// Finish the rootfs setup.\n\tif l.config.Config.Namespaces.Contains(configs.NEWNS) {\n\t\tif err := finalizeRootfs(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif hostname := l.config.Config.Hostname; hostname != \"\" {\n\t\tif err := unix.Sethostname([]byte(hostname)); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"sethostname\", Err: err}\n\t\t}\n\t}\n\tif domainname := l.config.Config.Domainname; domainname != \"\" {\n\t\tif err := unix.Setdomainname([]byte(domainname)); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"setdomainname\", Err: err}\n\t\t}\n\t}\n\tif err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply apparmor profile: %w\", err)\n\t}\n\n\tfor key, value := range l.config.Config.Sysctl {\n\t\tif err := writeSystemProperty(key, value); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.ReadonlyPaths {\n\t\tif err := readonlyPath(path); err != nil {\n\t\t\treturn fmt.Errorf(\"can't make %q read-only: %w\", path, err)\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.MaskPaths {\n\t\tif err := maskPath(path, l.config.Config.MountLabel); err != nil {\n\t\t\treturn fmt.Errorf(\"can't mask path %s: %w\", path, err)\n\t\t}\n\t}\n\tpdeath, err := system.GetParentDeathSignal()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"can't get pdeath signal: %w\", err)\n\t}\n\tif l.config.NoNewPrivileges {\n\t\tif err := unix.Prctl(unix.PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"prctl(SET_NO_NEW_PRIVS)\", Err: err}\n\t\t}\n\t}\n\n\tif l.config.Config.Scheduler != nil {\n\t\tif err := setupScheduler(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Tell our parent that we're ready to Execv. This must be done before the\n\t// Seccomp rules have been applied, because we need to be able to read and\n\t// write to a socket.\n\tif err := syncParentReady(l.pipe); err != nil {\n\t\treturn fmt.Errorf(\"sync ready: %w\", err)\n\t}\n\tif err := selinux.SetExecLabel(l.config.ProcessLabel); err != nil {\n\t\treturn fmt.Errorf(\"can't set process label: %w\", err)\n\t}\n\tdefer selinux.SetExecLabel(\"\") //nolint: errcheck\n\t// Without NoNewPrivileges seccomp is a privileged operation, so we need to\n\t// do this before dropping capabilities; otherwise do it as late as possible\n\t// just before execve so as few syscalls take place after it as possible.\n\tif l.config.Config.Seccomp != nil && !l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := finalizeNamespace(l.config); err != nil {\n\t\treturn err\n\t}\n\t// finalizeNamespace can change user/group which clears the parent death\n\t// signal, so we restore it here.\n\tif err := pdeath.Restore(); err != nil {\n\t\treturn fmt.Errorf(\"can't restore pdeath signal: %w\", err)\n\t}\n\t// Compare the parent from the initial start of the init process and make\n\t// sure that it did not change.  if the parent changes that means it died\n\t// and we were reparented to something else so we should just kill ourself\n\t// and not cause problems for someone else.\n\tif unix.Getppid() != l.parentPid {\n\t\treturn unix.Kill(unix.Getpid(), unix.SIGKILL)\n\t}\n\t// Check for the arg before waiting to make sure it exists and it is\n\t// returned as a create time error.\n\tname, err := exec.LookPath(l.config.Args[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\t// exec.LookPath in Go < 1.20 might return no error for an executable\n\t// residing on a file system mounted with noexec flag, so perform this\n\t// extra check now while we can still return a proper error.\n\t// TODO: remove this once go < 1.20 is not supported.\n\tif err := eaccess(name); err != nil {\n\t\treturn &os.PathError{Op: \"eaccess\", Path: name, Err: err}\n\t}\n\n\t// Set seccomp as close to execve as possible, so as few syscalls take\n\t// place afterward (reducing the amount of syscalls that users need to\n\t// enable in their seccomp profiles). However, this needs to be done\n\t// before closing the pipe since we need it to pass the seccompFd to\n\t// the parent.\n\tif l.config.Config.Seccomp != nil && l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to init seccomp: %w\", err)\n\t\t}\n\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Set personality if specified.\n\tif l.config.Config.Personality != nil {\n\t\tif err := setupPersonality(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Close the pipe to signal that we have completed our init.\n\tlogrus.Debugf(\"init: closing the pipe to signal completion\")\n\t_ = l.pipe.Close()\n\n\t// Close the log pipe fd so the parent's ForwardLogs can exit.\n\tlogrus.Debugf(\"init: about to wait on exec fifo\")\n\tif err := l.logPipe.Close(); err != nil {\n\t\treturn fmt.Errorf(\"close log pipe: %w\", err)\n\t}\n\n\tfifoPath, closer := utils.ProcThreadSelfFd(l.fifoFile.Fd())\n\tdefer closer()\n\n\t// Wait for the FIFO to be opened on the other side before exec-ing the\n\t// user process. We open it through /proc/self/fd/$fd, because the fd that\n\t// was given to us was an O_PATH fd to the fifo itself. Linux allows us to\n\t// re-open an O_PATH fd through /proc.\n\tfd, err := unix.Open(fifoPath, unix.O_WRONLY|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open exec fifo\", Path: fifoPath, Err: err}\n\t}\n\tif _, err := unix.Write(fd, []byte(\"0\")); err != nil {\n\t\treturn &os.PathError{Op: \"write exec fifo\", Path: fifoPath, Err: err}\n\t}\n\n\t// Close the O_PATH fifofd fd before exec because the kernel resets\n\t// dumpable in the wrong order. This has been fixed in newer kernels, but\n\t// we keep this to ensure CVE-2016-9962 doesn't re-emerge on older kernels.\n\t// N.B. the core issue itself (passing dirfds to the host filesystem) has\n\t// since been resolved.\n\t// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318\n\t_ = l.fifoFile.Close()\n\n\ts := l.config.SpecState\n\ts.Pid = unix.Getpid()\n\ts.Status = specs.StateCreated\n\tif err := l.config.Config.Hooks.Run(configs.StartContainer, s); err != nil {\n\t\treturn err\n\t}\n\n\tif l.dmzExe != nil {\n\t\tl.config.Args[0] = name\n\t\treturn system.Fexecve(l.dmzExe.Fd(), l.config.Args, os.Environ())\n\t}\n\treturn system.Exec(name, l.config.Args, os.Environ())\n}\n", "//go:build !windows\n// +build !windows\n\npackage utils\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"sync\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// EnsureProcHandle returns whether or not the given file handle is on procfs.\nfunc EnsureProcHandle(fh *os.File) error {\n\tvar buf unix.Statfs_t\n\tif err := unix.Fstatfs(int(fh.Fd()), &buf); err != nil {\n\t\treturn fmt.Errorf(\"ensure %s is on procfs: %w\", fh.Name(), err)\n\t}\n\tif buf.Type != unix.PROC_SUPER_MAGIC {\n\t\treturn fmt.Errorf(\"%s is not on procfs\", fh.Name())\n\t}\n\treturn nil\n}\n\nvar (\n\thaveCloseRangeCloexecBool bool\n\thaveCloseRangeCloexecOnce sync.Once\n)\n\nfunc haveCloseRangeCloexec() bool {\n\thaveCloseRangeCloexecOnce.Do(func() {\n\t\t// Make sure we're not closing a random file descriptor.\n\t\ttmpFd, err := unix.FcntlInt(0, unix.F_DUPFD_CLOEXEC, 0)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer unix.Close(tmpFd)\n\n\t\terr = unix.CloseRange(uint(tmpFd), uint(tmpFd), unix.CLOSE_RANGE_CLOEXEC)\n\t\t// Any error means we cannot use close_range(CLOSE_RANGE_CLOEXEC).\n\t\t// -ENOSYS and -EINVAL ultimately mean we don't have support, but any\n\t\t// other potential error would imply that even the most basic close\n\t\t// operation wouldn't work.\n\t\thaveCloseRangeCloexecBool = err == nil\n\t})\n\treturn haveCloseRangeCloexecBool\n}\n\n// CloseExecFrom applies O_CLOEXEC to all file descriptors currently open for\n// the process (except for those below the given fd value).\nfunc CloseExecFrom(minFd int) error {\n\tif haveCloseRangeCloexec() {\n\t\terr := unix.CloseRange(uint(minFd), math.MaxUint, unix.CLOSE_RANGE_CLOEXEC)\n\t\treturn os.NewSyscallError(\"close_range\", err)\n\t}\n\n\tprocSelfFd, closer := ProcThreadSelf(\"fd\")\n\tdefer closer()\n\n\tfdDir, err := os.Open(procSelfFd)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fdDir.Close()\n\n\tif err := EnsureProcHandle(fdDir); err != nil {\n\t\treturn err\n\t}\n\n\tfdList, err := fdDir.Readdirnames(-1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, fdStr := range fdList {\n\t\tfd, err := strconv.Atoi(fdStr)\n\t\t// Ignore non-numeric file names.\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t// Ignore descriptors lower than our specified minimum.\n\t\tif fd < minFd {\n\t\t\tcontinue\n\t\t}\n\t\t// Intentionally ignore errors from unix.CloseOnExec -- the cases where\n\t\t// this might fail are basically file descriptors that have already\n\t\t// been closed (including and especially the one that was created when\n\t\t// os.ReadDir did the \"opendir\" syscall).\n\t\tunix.CloseOnExec(fd)\n\t}\n\treturn nil\n}\n\n// NewSockPair returns a new SOCK_STREAM unix socket pair.\nfunc NewSockPair(name string) (parent, child *os.File, err error) {\n\tfds, err := unix.Socketpair(unix.AF_LOCAL, unix.SOCK_STREAM|unix.SOCK_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn os.NewFile(uintptr(fds[1]), name+\"-p\"), os.NewFile(uintptr(fds[0]), name+\"-c\"), nil\n}\n\n// WithProcfd runs the passed closure with a procfd path (/proc/self/fd/...)\n// corresponding to the unsafePath resolved within the root. Before passing the\n// fd, this path is verified to have been inside the root -- so operating on it\n// through the passed fdpath should be safe. Do not access this path through\n// the original path strings, and do not attempt to use the pathname outside of\n// the passed closure (the file handle will be freed once the closure returns).\nfunc WithProcfd(root, unsafePath string, fn func(procfd string) error) error {\n\t// Remove the root then forcefully resolve inside the root.\n\tunsafePath = stripRoot(root, unsafePath)\n\tpath, err := securejoin.SecureJoin(root, unsafePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"resolving path inside rootfs failed: %w\", err)\n\t}\n\n\tprocSelfFd, closer := ProcThreadSelf(\"fd/\")\n\tdefer closer()\n\n\t// Open the target path.\n\tfh, err := os.OpenFile(path, unix.O_PATH|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"open o_path procfd: %w\", err)\n\t}\n\tdefer fh.Close()\n\n\tprocfd := filepath.Join(procSelfFd, strconv.Itoa(int(fh.Fd())))\n\t// Double-check the path is the one we expected.\n\tif realpath, err := os.Readlink(procfd); err != nil {\n\t\treturn fmt.Errorf(\"procfd verification failed: %w\", err)\n\t} else if realpath != path {\n\t\treturn fmt.Errorf(\"possibly malicious path detected -- refusing to operate on %s\", realpath)\n\t}\n\n\treturn fn(procfd)\n}\n\ntype ProcThreadSelfCloser func()\n\nvar (\n\thaveProcThreadSelf     bool\n\thaveProcThreadSelfOnce sync.Once\n)\n\n// ProcThreadSelf returns a string that is equivalent to\n// /proc/thread-self/<subpath>, with a graceful fallback on older kernels where\n// /proc/thread-self doesn't exist. This method DOES NOT use SecureJoin,\n// meaning that the passed string needs to be trusted. The caller _must_ call\n// the returned procThreadSelfCloser function (which is runtime.UnlockOSThread)\n// *only once* after it has finished using the returned path string.\nfunc ProcThreadSelf(subpath string) (string, ProcThreadSelfCloser) {\n\thaveProcThreadSelfOnce.Do(func() {\n\t\tif _, err := os.Stat(\"/proc/thread-self/\"); err == nil {\n\t\t\thaveProcThreadSelf = true\n\t\t} else {\n\t\t\tlogrus.Debugf(\"cannot stat /proc/thread-self (%v), falling back to /proc/self/task/<tid>\", err)\n\t\t}\n\t})\n\n\t// We need to lock our thread until the caller is done with the path string\n\t// because any non-atomic operation on the path (such as opening a file,\n\t// then reading it) could be interrupted by the Go runtime where the\n\t// underlying thread is swapped out and the original thread is killed,\n\t// resulting in pull-your-hair-out-hard-to-debug issues in the caller. In\n\t// addition, the pre-3.17 fallback makes everything non-atomic because the\n\t// same thing could happen between unix.Gettid() and the path operations.\n\t//\n\t// In theory, we don't need to lock in the atomic user case when using\n\t// /proc/thread-self/, but it's better to be safe than sorry (and there are\n\t// only one or two truly atomic users of /proc/thread-self/).\n\truntime.LockOSThread()\n\n\tthreadSelf := \"/proc/thread-self/\"\n\tif !haveProcThreadSelf {\n\t\t// Pre-3.17 kernels did not have /proc/thread-self, so do it manually.\n\t\tthreadSelf = \"/proc/self/task/\" + strconv.Itoa(unix.Gettid()) + \"/\"\n\t\tif _, err := os.Stat(threadSelf); err != nil {\n\t\t\t// Unfortunately, this code is called from rootfs_linux.go where we\n\t\t\t// are running inside the pid namespace of the container but /proc\n\t\t\t// is the host's procfs. Unfortunately there is no real way to get\n\t\t\t// the correct tid to use here (the kernel age means we cannot do\n\t\t\t// things like set up a private fsopen(\"proc\") -- even scanning\n\t\t\t// NSpid in all of the tasks in /proc/self/task/*/status requires\n\t\t\t// Linux 4.1).\n\t\t\t//\n\t\t\t// So, we just have to assume that /proc/self is acceptable in this\n\t\t\t// one specific case.\n\t\t\tif os.Getpid() == 1 {\n\t\t\t\tlogrus.Debugf(\"/proc/thread-self (tid=%d) cannot be emulated inside the initial container setup -- using /proc/self instead: %v\", unix.Gettid(), err)\n\t\t\t} else {\n\t\t\t\t// This should never happen, but the fallback should work in most cases...\n\t\t\t\tlogrus.Warnf(\"/proc/thread-self could not be emulated for pid=%d (tid=%d) -- using more buggy /proc/self fallback instead: %v\", os.Getpid(), unix.Gettid(), err)\n\t\t\t}\n\t\t\tthreadSelf = \"/proc/self/\"\n\t\t}\n\t}\n\treturn threadSelf + subpath, runtime.UnlockOSThread\n}\n\n// ProcThreadSelfFd is small wrapper around ProcThreadSelf to make it easier to\n// create a /proc/thread-self handle for given file descriptor.\n//\n// It is basically equivalent to ProcThreadSelf(fmt.Sprintf(\"fd/%d\", fd)), but\n// without using fmt.Sprintf to avoid unneeded overhead.\nfunc ProcThreadSelfFd(fd uintptr) (string, ProcThreadSelfCloser) {\n\treturn ProcThreadSelf(\"fd/\" + strconv.FormatUint(uint64(fd), 10))\n}\n"], "fixing_code": ["package cgroups\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// OpenFile opens a cgroup file in a given dir with given flags.\n// It is supposed to be used for cgroup files only, and returns\n// an error if the file is not a cgroup file.\n//\n// Arguments dir and file are joined together to form an absolute path\n// to a file being opened.\nfunc OpenFile(dir, file string, flags int) (*os.File, error) {\n\tif dir == \"\" {\n\t\treturn nil, fmt.Errorf(\"no directory specified for %s\", file)\n\t}\n\treturn openFile(dir, file, flags)\n}\n\n// ReadFile reads data from a cgroup file in dir.\n// It is supposed to be used for cgroup files only.\nfunc ReadFile(dir, file string) (string, error) {\n\tfd, err := OpenFile(dir, file, unix.O_RDONLY)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer fd.Close()\n\tvar buf bytes.Buffer\n\n\t_, err = buf.ReadFrom(fd)\n\treturn buf.String(), err\n}\n\n// WriteFile writes data to a cgroup file in dir.\n// It is supposed to be used for cgroup files only.\nfunc WriteFile(dir, file, data string) error {\n\tfd, err := OpenFile(dir, file, unix.O_WRONLY)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fd.Close()\n\tif _, err := fd.WriteString(data); err != nil {\n\t\t// Having data in the error message helps in debugging.\n\t\treturn fmt.Errorf(\"failed to write %q: %w\", data, err)\n\t}\n\treturn nil\n}\n\nconst (\n\tcgroupfsDir    = \"/sys/fs/cgroup\"\n\tcgroupfsPrefix = cgroupfsDir + \"/\"\n)\n\nvar (\n\t// TestMode is set to true by unit tests that need \"fake\" cgroupfs.\n\tTestMode bool\n\n\tcgroupRootHandle *os.File\n\tprepOnce         sync.Once\n\tprepErr          error\n\tresolveFlags     uint64\n)\n\nfunc prepareOpenat2() error {\n\tprepOnce.Do(func() {\n\t\tfd, err := unix.Openat2(-1, cgroupfsDir, &unix.OpenHow{\n\t\t\tFlags: unix.O_DIRECTORY | unix.O_PATH | unix.O_CLOEXEC,\n\t\t})\n\t\tif err != nil {\n\t\t\tprepErr = &os.PathError{Op: \"openat2\", Path: cgroupfsDir, Err: err}\n\t\t\tif err != unix.ENOSYS {\n\t\t\t\tlogrus.Warnf(\"falling back to securejoin: %s\", prepErr)\n\t\t\t} else {\n\t\t\t\tlogrus.Debug(\"openat2 not available, falling back to securejoin\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tfile := os.NewFile(uintptr(fd), cgroupfsDir)\n\n\t\tvar st unix.Statfs_t\n\t\tif err := unix.Fstatfs(int(file.Fd()), &st); err != nil {\n\t\t\tprepErr = &os.PathError{Op: \"statfs\", Path: cgroupfsDir, Err: err}\n\t\t\tlogrus.Warnf(\"falling back to securejoin: %s\", prepErr)\n\t\t\treturn\n\t\t}\n\n\t\tcgroupRootHandle = file\n\t\tresolveFlags = unix.RESOLVE_BENEATH | unix.RESOLVE_NO_MAGICLINKS\n\t\tif st.Type == unix.CGROUP2_SUPER_MAGIC {\n\t\t\t// cgroupv2 has a single mountpoint and no \"cpu,cpuacct\" symlinks\n\t\t\tresolveFlags |= unix.RESOLVE_NO_XDEV | unix.RESOLVE_NO_SYMLINKS\n\t\t}\n\t})\n\n\treturn prepErr\n}\n\nfunc openFile(dir, file string, flags int) (*os.File, error) {\n\tmode := os.FileMode(0)\n\tif TestMode && flags&os.O_WRONLY != 0 {\n\t\t// \"emulate\" cgroup fs for unit tests\n\t\tflags |= os.O_TRUNC | os.O_CREATE\n\t\tmode = 0o600\n\t}\n\tpath := path.Join(dir, utils.CleanPath(file))\n\tif prepareOpenat2() != nil {\n\t\treturn openFallback(path, flags, mode)\n\t}\n\trelPath := strings.TrimPrefix(path, cgroupfsPrefix)\n\tif len(relPath) == len(path) { // non-standard path, old system?\n\t\treturn openFallback(path, flags, mode)\n\t}\n\n\tfd, err := unix.Openat2(int(cgroupRootHandle.Fd()), relPath,\n\t\t&unix.OpenHow{\n\t\t\tResolve: resolveFlags,\n\t\t\tFlags:   uint64(flags) | unix.O_CLOEXEC,\n\t\t\tMode:    uint64(mode),\n\t\t})\n\tif err != nil {\n\t\terr = &os.PathError{Op: \"openat2\", Path: path, Err: err}\n\t\t// Check if cgroupRootHandle is still opened to cgroupfsDir\n\t\t// (happens when this package is incorrectly used\n\t\t// across the chroot/pivot_root/mntns boundary, or\n\t\t// when /sys/fs/cgroup is remounted).\n\t\t//\n\t\t// TODO: if such usage will ever be common, amend this\n\t\t// to reopen cgroupRootHandle and retry openat2.\n\t\tfdPath, closer := utils.ProcThreadSelf(\"fd/\" + strconv.Itoa(int(cgroupRootHandle.Fd())))\n\t\tdefer closer()\n\t\tfdDest, _ := os.Readlink(fdPath)\n\t\tif fdDest != cgroupfsDir {\n\t\t\t// Wrap the error so it is clear that cgroupRootHandle\n\t\t\t// is opened to an unexpected/wrong directory.\n\t\t\terr = fmt.Errorf(\"cgroupRootHandle %d unexpectedly opened to %s != %s: %w\",\n\t\t\t\tcgroupRootHandle.Fd(), fdDest, cgroupfsDir, err)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn os.NewFile(uintptr(fd), path), nil\n}\n\nvar errNotCgroupfs = errors.New(\"not a cgroup file\")\n\n// Can be changed by unit tests.\nvar openFallback = openAndCheck\n\n// openAndCheck is used when openat2(2) is not available. It checks the opened\n// file is on cgroupfs, returning an error otherwise.\nfunc openAndCheck(path string, flags int, mode os.FileMode) (*os.File, error) {\n\tfd, err := os.OpenFile(path, flags, mode)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif TestMode {\n\t\treturn fd, nil\n\t}\n\t// Check this is a cgroupfs file.\n\tvar st unix.Statfs_t\n\tif err := unix.Fstatfs(int(fd.Fd()), &st); err != nil {\n\t\t_ = fd.Close()\n\t\treturn nil, &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\tif st.Type != unix.CGROUP_SUPER_MAGIC && st.Type != unix.CGROUP2_SUPER_MAGIC {\n\t\t_ = fd.Close()\n\t\treturn nil, &os.PathError{Op: \"open\", Path: path, Err: errNotCgroupfs}\n\t}\n\n\treturn fd, nil\n}\n", "package libcontainer\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/execabs\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/dmz\"\n\t\"github.com/opencontainers/runc/libcontainer/intelrdt\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/system/kernelversion\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\nconst stdioFdCount = 3\n\n// Container is a libcontainer container object.\ntype Container struct {\n\tid                   string\n\tstateDir             string\n\tconfig               *configs.Config\n\tcgroupManager        cgroups.Manager\n\tintelRdtManager      *intelrdt.Manager\n\tinitProcess          parentProcess\n\tinitProcessStartTime uint64\n\tm                    sync.Mutex\n\tcriuVersion          int\n\tstate                containerState\n\tcreated              time.Time\n\tfifo                 *os.File\n}\n\n// State represents a running container's state\ntype State struct {\n\tBaseState\n\n\t// Platform specific fields below here\n\n\t// Specified if the container was started under the rootless mode.\n\t// Set to true if BaseState.Config.RootlessEUID && BaseState.Config.RootlessCgroups\n\tRootless bool `json:\"rootless\"`\n\n\t// Paths to all the container's cgroups, as returned by (*cgroups.Manager).GetPaths\n\t//\n\t// For cgroup v1, a key is cgroup subsystem name, and the value is the path\n\t// to the cgroup for this subsystem.\n\t//\n\t// For cgroup v2 unified hierarchy, a key is \"\", and the value is the unified path.\n\tCgroupPaths map[string]string `json:\"cgroup_paths\"`\n\n\t// NamespacePaths are filepaths to the container's namespaces. Key is the namespace type\n\t// with the value as the path.\n\tNamespacePaths map[configs.NamespaceType]string `json:\"namespace_paths\"`\n\n\t// Container's standard descriptors (std{in,out,err}), needed for checkpoint and restore\n\tExternalDescriptors []string `json:\"external_descriptors,omitempty\"`\n\n\t// Intel RDT \"resource control\" filesystem path\n\tIntelRdtPath string `json:\"intel_rdt_path\"`\n}\n\n// ID returns the container's unique ID\nfunc (c *Container) ID() string {\n\treturn c.id\n}\n\n// Config returns the container's configuration\nfunc (c *Container) Config() configs.Config {\n\treturn *c.config\n}\n\n// Status returns the current status of the container.\nfunc (c *Container) Status() (Status, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentStatus()\n}\n\n// State returns the current container's state information.\nfunc (c *Container) State() (*State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentState()\n}\n\n// OCIState returns the current container's state information.\nfunc (c *Container) OCIState() (*specs.State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentOCIState()\n}\n\n// ignoreCgroupError filters out cgroup-related errors that can be ignored,\n// because the container is stopped and its cgroup is gone.\nfunc (c *Container) ignoreCgroupError(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif errors.Is(err, os.ErrNotExist) && !c.hasInit() && !c.cgroupManager.Exists() {\n\t\treturn nil\n\t}\n\treturn err\n}\n\n// Processes returns the PIDs inside this container. The PIDs are in the\n// namespace of the calling process.\n//\n// Some of the returned PIDs may no longer refer to processes in the container,\n// unless the container state is PAUSED in which case every PID in the slice is\n// valid.\nfunc (c *Container) Processes() ([]int, error) {\n\tpids, err := c.cgroupManager.GetAllPids()\n\tif err = c.ignoreCgroupError(err); err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get all container pids: %w\", err)\n\t}\n\treturn pids, nil\n}\n\n// Stats returns statistics for the container.\nfunc (c *Container) Stats() (*Stats, error) {\n\tvar (\n\t\terr   error\n\t\tstats = &Stats{}\n\t)\n\tif stats.CgroupStats, err = c.cgroupManager.GetStats(); err != nil {\n\t\treturn stats, fmt.Errorf(\"unable to get container cgroup stats: %w\", err)\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif stats.IntelRdtStats, err = c.intelRdtManager.GetStats(); err != nil {\n\t\t\treturn stats, fmt.Errorf(\"unable to get container Intel RDT stats: %w\", err)\n\t\t}\n\t}\n\tfor _, iface := range c.config.Networks {\n\t\tswitch iface.Type {\n\t\tcase \"veth\":\n\t\t\tistats, err := getNetworkInterfaceStats(iface.HostInterfaceName)\n\t\t\tif err != nil {\n\t\t\t\treturn stats, fmt.Errorf(\"unable to get network stats for interface %q: %w\", iface.HostInterfaceName, err)\n\t\t\t}\n\t\t\tstats.Interfaces = append(stats.Interfaces, istats)\n\t\t}\n\t}\n\treturn stats, nil\n}\n\n// Set resources of container as configured. Can be used to change resources\n// when the container is running.\nfunc (c *Container) Set(config configs.Config) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status == Stopped {\n\t\treturn ErrNotRunning\n\t}\n\tif err := c.cgroupManager.Set(config.Cgroups.Resources); err != nil {\n\t\t// Set configs back\n\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t}\n\t\treturn err\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif err := c.intelRdtManager.Set(&config); err != nil {\n\t\t\t// Set configs back\n\t\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\tif err2 := c.intelRdtManager.Set(c.config); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back intelrdt configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\t// After config setting succeed, update config and states\n\tc.config = &config\n\t_, err = c.updateState(nil)\n\treturn err\n}\n\n// Start starts a process inside the container. Returns error if process fails\n// to start. You can track process lifecycle with passed Process structure.\nfunc (c *Container) Start(process *Process) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tif c.config.Cgroups.Resources.SkipDevices {\n\t\treturn errors.New(\"can't start container with SkipDevices set\")\n\t}\n\tif process.Init {\n\t\tif err := c.createExecFifo(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := c.start(process); err != nil {\n\t\tif process.Init {\n\t\t\tc.deleteExecFifo()\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Run immediately starts the process inside the container. Returns an error if\n// the process fails to start. It does not block waiting for the exec fifo\n// after start returns but opens the fifo after start returns.\nfunc (c *Container) Run(process *Process) error {\n\tif err := c.Start(process); err != nil {\n\t\treturn err\n\t}\n\tif process.Init {\n\t\treturn c.exec()\n\t}\n\treturn nil\n}\n\n// Exec signals the container to exec the users process at the end of the init.\nfunc (c *Container) Exec() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.exec()\n}\n\nfunc (c *Container) exec() error {\n\tpath := filepath.Join(c.stateDir, execFifoFilename)\n\tpid := c.initProcess.pid()\n\tblockingFifoOpenCh := awaitFifoOpen(path)\n\tfor {\n\t\tselect {\n\t\tcase result := <-blockingFifoOpenCh:\n\t\t\treturn handleFifoResult(result)\n\n\t\tcase <-time.After(time.Millisecond * 100):\n\t\t\tstat, err := system.Stat(pid)\n\t\t\tif err != nil || stat.State == system.Zombie {\n\t\t\t\t// could be because process started, ran, and completed between our 100ms timeout and our system.Stat() check.\n\t\t\t\t// see if the fifo exists and has data (with a non-blocking open, which will succeed if the writing process is complete).\n\t\t\t\tif err := handleFifoResult(fifoOpen(path, false)); err != nil {\n\t\t\t\t\treturn errors.New(\"container process is already dead\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc readFromExecFifo(execFifo io.Reader) error {\n\tdata, err := io.ReadAll(execFifo)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(data) <= 0 {\n\t\treturn errors.New(\"cannot start an already running container\")\n\t}\n\treturn nil\n}\n\nfunc awaitFifoOpen(path string) <-chan openResult {\n\tfifoOpened := make(chan openResult)\n\tgo func() {\n\t\tresult := fifoOpen(path, true)\n\t\tfifoOpened <- result\n\t}()\n\treturn fifoOpened\n}\n\nfunc fifoOpen(path string, block bool) openResult {\n\tflags := os.O_RDONLY\n\tif !block {\n\t\tflags |= unix.O_NONBLOCK\n\t}\n\tf, err := os.OpenFile(path, flags, 0)\n\tif err != nil {\n\t\treturn openResult{err: fmt.Errorf(\"exec fifo: %w\", err)}\n\t}\n\treturn openResult{file: f}\n}\n\nfunc handleFifoResult(result openResult) error {\n\tif result.err != nil {\n\t\treturn result.err\n\t}\n\tf := result.file\n\tdefer f.Close()\n\tif err := readFromExecFifo(f); err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(f.Name())\n}\n\ntype openResult struct {\n\tfile *os.File\n\terr  error\n}\n\nfunc (c *Container) start(process *Process) (retErr error) {\n\tparent, err := c.newParentProcess(process)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to create new parent process: %w\", err)\n\t}\n\t// We do not need the cloned binaries once the process is spawned.\n\tdefer process.closeClonedExes()\n\n\tlogsDone := parent.forwardChildLogs()\n\tif logsDone != nil {\n\t\tdefer func() {\n\t\t\t// Wait for log forwarder to finish. This depends on\n\t\t\t// runc init closing the _LIBCONTAINER_LOGPIPE log fd.\n\t\t\terr := <-logsDone\n\t\t\tif err != nil && retErr == nil {\n\t\t\t\tretErr = fmt.Errorf(\"unable to forward init logs: %w\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Before starting \"runc init\", mark all non-stdio open files as O_CLOEXEC\n\t// to make sure we don't leak any files into \"runc init\". Any files to be\n\t// passed to \"runc init\" through ExtraFiles will get dup2'd by the Go\n\t// runtime and thus their O_CLOEXEC flag will be cleared. This is some\n\t// additional protection against attacks like CVE-2024-21626, by making\n\t// sure we never leak files to \"runc init\" we didn't intend to.\n\tif err := utils.CloseExecFrom(3); err != nil {\n\t\treturn fmt.Errorf(\"unable to mark non-stdio fds as cloexec: %w\", err)\n\t}\n\tif err := parent.start(); err != nil {\n\t\treturn fmt.Errorf(\"unable to start container process: %w\", err)\n\t}\n\n\tif process.Init {\n\t\tc.fifo.Close()\n\t\tif c.config.Hooks != nil {\n\t\t\ts, err := c.currentOCIState()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := c.config.Hooks.Run(configs.Poststart, s); err != nil {\n\t\t\t\tif err := ignoreTerminateErrors(parent.terminate()); err != nil {\n\t\t\t\t\tlogrus.Warn(fmt.Errorf(\"error running poststart hook: %w\", err))\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Signal sends a specified signal to container's init.\n//\n// When s is SIGKILL and the container does not have its own PID namespace, all\n// the container's processes are killed. In this scenario, the libcontainer\n// user may be required to implement a proper child reaper.\nfunc (c *Container) Signal(s os.Signal) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\t// When a container has its own PID namespace, inside it the init PID\n\t// is 1, and thus it is handled specially by the kernel. In particular,\n\t// killing init with SIGKILL from an ancestor namespace will also kill\n\t// all other processes in that PID namespace (see pid_namespaces(7)).\n\t//\n\t// OTOH, if PID namespace is shared, we should kill all pids to avoid\n\t// leftover processes. Handle this special case here.\n\tif s == unix.SIGKILL && !c.config.Namespaces.IsPrivate(configs.NEWPID) {\n\t\tif err := signalAllProcesses(c.cgroupManager, unix.SIGKILL); err != nil {\n\t\t\treturn fmt.Errorf(\"unable to kill all processes: %w\", err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// To avoid a PID reuse attack, don't kill non-running container.\n\tif !c.hasInit() {\n\t\treturn ErrNotRunning\n\t}\n\tif err := c.initProcess.signal(s); err != nil {\n\t\treturn fmt.Errorf(\"unable to signal init: %w\", err)\n\t}\n\tif s == unix.SIGKILL {\n\t\t// For cgroup v1, killing a process in a frozen cgroup\n\t\t// does nothing until it's thawed. Only thaw the cgroup\n\t\t// for SIGKILL.\n\t\tif paused, _ := c.isPaused(); paused {\n\t\t\t_ = c.cgroupManager.Freeze(configs.Thawed)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *Container) createExecFifo() error {\n\trootuid, err := c.Config().HostRootUID()\n\tif err != nil {\n\t\treturn err\n\t}\n\trootgid, err := c.Config().HostRootGID()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfifoName := filepath.Join(c.stateDir, execFifoFilename)\n\tif _, err := os.Stat(fifoName); err == nil {\n\t\treturn fmt.Errorf(\"exec fifo %s already exists\", fifoName)\n\t}\n\tif err := unix.Mkfifo(fifoName, 0o622); err != nil {\n\t\treturn &os.PathError{Op: \"mkfifo\", Path: fifoName, Err: err}\n\t}\n\t// Ensure permission bits (can be different because of umask).\n\tif err := os.Chmod(fifoName, 0o622); err != nil {\n\t\treturn err\n\t}\n\treturn os.Chown(fifoName, rootuid, rootgid)\n}\n\nfunc (c *Container) deleteExecFifo() {\n\tfifoName := filepath.Join(c.stateDir, execFifoFilename)\n\tos.Remove(fifoName)\n}\n\n// includeExecFifo opens the container's execfifo as a pathfd, so that the\n// container cannot access the statedir (and the FIFO itself remains\n// un-opened). It then adds the FifoFd to the given exec.Cmd as an inherited\n// fd, with _LIBCONTAINER_FIFOFD set to its fd number.\nfunc (c *Container) includeExecFifo(cmd *exec.Cmd) error {\n\tfifoName := filepath.Join(c.stateDir, execFifoFilename)\n\tfifo, err := os.OpenFile(fifoName, unix.O_PATH|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fifo = fifo\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, fifo)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_FIFOFD=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1))\n\treturn nil\n}\n\n// No longer needed in Go 1.21.\nfunc slicesContains[S ~[]E, E comparable](slice S, needle E) bool {\n\tfor _, val := range slice {\n\t\tif val == needle {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isDmzBinarySafe(c *configs.Config) bool {\n\tif !dmz.WorksWithSELinux(c) {\n\t\treturn false\n\t}\n\n\t// Because we set the dumpable flag in nsexec, the only time when it is\n\t// unsafe to use runc-dmz is when the container process would be able to\n\t// race against \"runc init\" and bypass the ptrace_may_access() checks.\n\t//\n\t// This is only the case if the container processes could have\n\t// CAP_SYS_PTRACE somehow (i.e. the capability is present in the bounding,\n\t// inheritable, or ambient sets). Luckily, most containers do not have this\n\t// capability.\n\tif c.Capabilities == nil ||\n\t\t(!slicesContains(c.Capabilities.Bounding, \"CAP_SYS_PTRACE\") &&\n\t\t\t!slicesContains(c.Capabilities.Inheritable, \"CAP_SYS_PTRACE\") &&\n\t\t\t!slicesContains(c.Capabilities.Ambient, \"CAP_SYS_PTRACE\")) {\n\t\treturn true\n\t}\n\n\t// Since Linux 4.10 (see bfedb589252c0) user namespaced containers cannot\n\t// access /proc/$pid/exe of runc after it joins the namespace (until it\n\t// does an exec), regardless of the capability set. This has been\n\t// backported to other distribution kernels, but there's no way of checking\n\t// this cheaply -- better to be safe than sorry here.\n\tlinux410 := kernelversion.KernelVersion{Kernel: 4, Major: 10}\n\tif ok, err := kernelversion.GreaterEqualThan(linux410); ok && err == nil {\n\t\tif c.Namespaces.Contains(configs.NEWUSER) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// Assume it's unsafe otherwise.\n\treturn false\n}\n\nfunc (c *Container) newParentProcess(p *Process) (parentProcess, error) {\n\tcomm, err := newProcessComm()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Make sure we use a new safe copy of /proc/self/exe or the runc-dmz\n\t// binary each time this is called, to make sure that if a container\n\t// manages to overwrite the file it cannot affect other containers on the\n\t// system. For runc, this code will only ever be called once, but\n\t// libcontainer users might call this more than once.\n\tp.closeClonedExes()\n\tvar (\n\t\texePath string\n\t\t// only one of dmzExe or safeExe are used at a time\n\t\tdmzExe, safeExe *os.File\n\t)\n\tif dmz.IsSelfExeCloned() {\n\t\t// /proc/self/exe is already a cloned binary -- no need to do anything\n\t\tlogrus.Debug(\"skipping binary cloning -- /proc/self/exe is already cloned!\")\n\t\t// We don't need to use /proc/thread-self here because the exe mm of a\n\t\t// thread-group is guaranteed to be the same for all threads by\n\t\t// definition. This lets us avoid having to do runtime.LockOSThread.\n\t\texePath = \"/proc/self/exe\"\n\t} else {\n\t\tvar err error\n\t\tif isDmzBinarySafe(c.config) {\n\t\t\tdmzExe, err = dmz.Binary(c.stateDir)\n\t\t\tif err == nil {\n\t\t\t\t// We can use our own executable without cloning if we are\n\t\t\t\t// using runc-dmz. We don't need to use /proc/thread-self here\n\t\t\t\t// because the exe mm of a thread-group is guaranteed to be the\n\t\t\t\t// same for all threads by definition. This lets us avoid\n\t\t\t\t// having to do runtime.LockOSThread.\n\t\t\t\texePath = \"/proc/self/exe\"\n\t\t\t\tp.clonedExes = append(p.clonedExes, dmzExe)\n\t\t\t\tlogrus.Debug(\"runc-dmz: using runc-dmz\") // used for tests\n\t\t\t} else if errors.Is(err, dmz.ErrNoDmzBinary) {\n\t\t\t\tlogrus.Debug(\"runc-dmz binary not embedded in runc binary, falling back to /proc/self/exe clone\")\n\t\t\t} else if err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to create runc-dmz binary clone: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t// If the configuration makes it unsafe to use runc-dmz, pretend we\n\t\t\t// don't have it embedded so we do /proc/self/exe cloning.\n\t\t\tlogrus.Debug(\"container configuration unsafe for runc-dmz, falling back to /proc/self/exe clone\")\n\t\t\terr = dmz.ErrNoDmzBinary\n\t\t}\n\t\tif errors.Is(err, dmz.ErrNoDmzBinary) {\n\t\t\tsafeExe, err = dmz.CloneSelfExe(c.stateDir)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to create safe /proc/self/exe clone for runc init: %w\", err)\n\t\t\t}\n\t\t\texePath = \"/proc/self/fd/\" + strconv.Itoa(int(safeExe.Fd()))\n\t\t\tp.clonedExes = append(p.clonedExes, safeExe)\n\t\t\tlogrus.Debug(\"runc-dmz: using /proc/self/exe clone\") // used for tests\n\t\t}\n\t\t// Just to make sure we don't run without protection.\n\t\tif dmzExe == nil && safeExe == nil {\n\t\t\t// This should never happen.\n\t\t\treturn nil, fmt.Errorf(\"[internal error] attempted to spawn a container with no /proc/self/exe protection\")\n\t\t}\n\t}\n\n\tcmd := exec.Command(exePath, \"init\")\n\tcmd.Args[0] = os.Args[0]\n\tcmd.Stdin = p.Stdin\n\tcmd.Stdout = p.Stdout\n\tcmd.Stderr = p.Stderr\n\tcmd.Dir = c.config.Rootfs\n\tif cmd.SysProcAttr == nil {\n\t\tcmd.SysProcAttr = &unix.SysProcAttr{}\n\t}\n\tcmd.Env = append(cmd.Env, \"GOMAXPROCS=\"+os.Getenv(\"GOMAXPROCS\"))\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)\n\tif p.ConsoleSocket != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket)\n\t\tcmd.Env = append(cmd.Env,\n\t\t\t\"_LIBCONTAINER_CONSOLE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t)\n\t}\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, comm.initSockChild)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_INITPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t)\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, comm.syncSockChild.File())\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_SYNCPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t)\n\n\tif dmzExe != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, dmzExe)\n\t\tcmd.Env = append(cmd.Env,\n\t\t\t\"_LIBCONTAINER_DMZEXEFD=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1))\n\t}\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, comm.logPipeChild)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_LOGPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1))\n\tif p.LogLevel != \"\" {\n\t\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_LOGLEVEL=\"+p.LogLevel)\n\t}\n\n\tif p.PidfdSocket != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.PidfdSocket)\n\t\tcmd.Env = append(cmd.Env,\n\t\t\t\"_LIBCONTAINER_PIDFD_SOCK=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t)\n\t}\n\n\tif safeExe != nil {\n\t\t// Due to a Go stdlib bug, we need to add safeExe to the set of\n\t\t// ExtraFiles otherwise it is possible for the stdlib to clobber the fd\n\t\t// during forkAndExecInChild1 and replace it with some other file that\n\t\t// might be malicious. This is less than ideal (because the descriptor\n\t\t// will be non-O_CLOEXEC) however we have protections in \"runc init\" to\n\t\t// stop us from leaking extra file descriptors.\n\t\t//\n\t\t// See <https://github.com/golang/go/issues/61751>.\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, safeExe)\n\t}\n\n\t// NOTE: when running a container with no PID namespace and the parent\n\t//       process spawning the container is PID1 the pdeathsig is being\n\t//       delivered to the container's init process by the kernel for some\n\t//       reason even with the parent still running.\n\tif c.config.ParentDeathSignal > 0 {\n\t\tcmd.SysProcAttr.Pdeathsig = unix.Signal(c.config.ParentDeathSignal)\n\t}\n\n\tif p.Init {\n\t\t// We only set up fifoFd if we're not doing a `runc exec`. The historic\n\t\t// reason for this is that previously we would pass a dirfd that allowed\n\t\t// for container rootfs escape (and not doing it in `runc exec` avoided\n\t\t// that problem), but we no longer do that. However, there's no need to do\n\t\t// this for `runc exec` so we just keep it this way to be safe.\n\t\tif err := c.includeExecFifo(cmd); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to setup exec fifo: %w\", err)\n\t\t}\n\t\treturn c.newInitProcess(p, cmd, comm)\n\t}\n\treturn c.newSetnsProcess(p, cmd, comm)\n}\n\nfunc (c *Container) newInitProcess(p *Process, cmd *exec.Cmd, comm *processComm) (*initProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initStandard))\n\tnsMaps := make(map[configs.NamespaceType]string)\n\tfor _, ns := range c.config.Namespaces {\n\t\tif ns.Path != \"\" {\n\t\t\tnsMaps[ns.Type] = ns.Path\n\t\t}\n\t}\n\tdata, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinit := &initProcess{\n\t\tcmd:             cmd,\n\t\tcomm:            comm,\n\t\tmanager:         c.cgroupManager,\n\t\tintelRdtManager: c.intelRdtManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tcontainer:       c,\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t}\n\tc.initProcess = init\n\treturn init, nil\n}\n\nfunc (c *Container) newSetnsProcess(p *Process, cmd *exec.Cmd, comm *processComm) (*setnsProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initSetns))\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get container state: %w\", err)\n\t}\n\t// for setns process, we don't have to set cloneflags as the process namespaces\n\t// will only be set via setns syscall\n\tdata, err := c.bootstrapData(0, state.NamespacePaths)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tproc := &setnsProcess{\n\t\tcmd:             cmd,\n\t\tcgroupPaths:     state.CgroupPaths,\n\t\trootlessCgroups: c.config.RootlessCgroups,\n\t\tintelRdtPath:    state.IntelRdtPath,\n\t\tcomm:            comm,\n\t\tmanager:         c.cgroupManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t\tinitProcessPid:  state.InitProcessPid,\n\t}\n\tif len(p.SubCgroupPaths) > 0 {\n\t\tif add, ok := p.SubCgroupPaths[\"\"]; ok {\n\t\t\t// cgroup v1: using the same path for all controllers.\n\t\t\t// cgroup v2: the only possible way.\n\t\t\tfor k := range proc.cgroupPaths {\n\t\t\t\tsubPath := path.Join(proc.cgroupPaths[k], add)\n\t\t\t\tif !strings.HasPrefix(subPath, proc.cgroupPaths[k]) {\n\t\t\t\t\treturn nil, fmt.Errorf(\"%s is not a sub cgroup path\", add)\n\t\t\t\t}\n\t\t\t\tproc.cgroupPaths[k] = subPath\n\t\t\t}\n\t\t\t// cgroup v2: do not try to join init process's cgroup\n\t\t\t// as a fallback (see (*setnsProcess).start).\n\t\t\tproc.initProcessPid = 0\n\t\t} else {\n\t\t\t// Per-controller paths.\n\t\t\tfor ctrl, add := range p.SubCgroupPaths {\n\t\t\t\tif val, ok := proc.cgroupPaths[ctrl]; ok {\n\t\t\t\t\tsubPath := path.Join(val, add)\n\t\t\t\t\tif !strings.HasPrefix(subPath, val) {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"%s is not a sub cgroup path\", add)\n\t\t\t\t\t}\n\t\t\t\t\tproc.cgroupPaths[ctrl] = subPath\n\t\t\t\t} else {\n\t\t\t\t\treturn nil, fmt.Errorf(\"unknown controller %s in SubCgroupPaths\", ctrl)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn proc, nil\n}\n\nfunc (c *Container) newInitConfig(process *Process) *initConfig {\n\tcfg := &initConfig{\n\t\tConfig:           c.config,\n\t\tArgs:             process.Args,\n\t\tEnv:              process.Env,\n\t\tUser:             process.User,\n\t\tAdditionalGroups: process.AdditionalGroups,\n\t\tCwd:              process.Cwd,\n\t\tCapabilities:     process.Capabilities,\n\t\tPassedFilesCount: len(process.ExtraFiles),\n\t\tContainerID:      c.ID(),\n\t\tNoNewPrivileges:  c.config.NoNewPrivileges,\n\t\tRootlessEUID:     c.config.RootlessEUID,\n\t\tRootlessCgroups:  c.config.RootlessCgroups,\n\t\tAppArmorProfile:  c.config.AppArmorProfile,\n\t\tProcessLabel:     c.config.ProcessLabel,\n\t\tRlimits:          c.config.Rlimits,\n\t\tCreateConsole:    process.ConsoleSocket != nil,\n\t\tConsoleWidth:     process.ConsoleWidth,\n\t\tConsoleHeight:    process.ConsoleHeight,\n\t}\n\tif process.NoNewPrivileges != nil {\n\t\tcfg.NoNewPrivileges = *process.NoNewPrivileges\n\t}\n\tif process.AppArmorProfile != \"\" {\n\t\tcfg.AppArmorProfile = process.AppArmorProfile\n\t}\n\tif process.Label != \"\" {\n\t\tcfg.ProcessLabel = process.Label\n\t}\n\tif len(process.Rlimits) > 0 {\n\t\tcfg.Rlimits = process.Rlimits\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tcfg.Cgroup2Path = c.cgroupManager.Path(\"\")\n\t}\n\n\treturn cfg\n}\n\n// Destroy destroys the container, if its in a valid state.\n//\n// Any event registrations are removed before the container is destroyed.\n// No error is returned if the container is already destroyed.\n//\n// Running containers must first be stopped using Signal.\n// Paused containers must first be resumed using Resume.\nfunc (c *Container) Destroy() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tif err := c.state.destroy(); err != nil {\n\t\treturn fmt.Errorf(\"unable to destroy container: %w\", err)\n\t}\n\treturn nil\n}\n\n// Pause pauses the container, if its state is RUNNING or CREATED, changing\n// its state to PAUSED. If the state is already PAUSED, does nothing.\nfunc (c *Container) Pause() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch status {\n\tcase Running, Created:\n\t\tif err := c.cgroupManager.Freeze(configs.Frozen); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.state.transition(&pausedState{\n\t\t\tc: c,\n\t\t})\n\t}\n\treturn ErrNotRunning\n}\n\n// Resume resumes the execution of any user processes in the\n// container before setting the container state to RUNNING.\n// This is only performed if the current state is PAUSED.\n// If the Container state is RUNNING, does nothing.\nfunc (c *Container) Resume() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status != Paused {\n\t\treturn ErrNotPaused\n\t}\n\tif err := c.cgroupManager.Freeze(configs.Thawed); err != nil {\n\t\treturn err\n\t}\n\treturn c.state.transition(&runningState{\n\t\tc: c,\n\t})\n}\n\n// NotifyOOM returns a read-only channel signaling when the container receives\n// an OOM notification.\nfunc (c *Container) NotifyOOM() (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting OOM notifications may fail if you don't have the full access to cgroups\")\n\t}\n\tpath := c.cgroupManager.Path(\"memory\")\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\treturn notifyOnOOMV2(path)\n\t}\n\treturn notifyOnOOM(path)\n}\n\n// NotifyMemoryPressure returns a read-only channel signaling when the\n// container reaches a given pressure level.\nfunc (c *Container) NotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting memory pressure notifications may fail if you don't have the full access to cgroups\")\n\t}\n\treturn notifyMemoryPressure(c.cgroupManager.Path(\"memory\"), level)\n}\n\nfunc (c *Container) updateState(process parentProcess) (*State, error) {\n\tif process != nil {\n\t\tc.initProcess = process\n\t}\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = c.saveState(state)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn state, nil\n}\n\nfunc (c *Container) saveState(s *State) (retErr error) {\n\ttmpFile, err := os.CreateTemp(c.stateDir, \"state-\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\ttmpFile.Close()\n\t\t\tos.Remove(tmpFile.Name())\n\t\t}\n\t}()\n\n\terr = utils.WriteJSON(tmpFile, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = tmpFile.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstateFilePath := filepath.Join(c.stateDir, stateFilename)\n\treturn os.Rename(tmpFile.Name(), stateFilePath)\n}\n\nfunc (c *Container) currentStatus() (Status, error) {\n\tif err := c.refreshState(); err != nil {\n\t\treturn -1, err\n\t}\n\treturn c.state.status(), nil\n}\n\n// refreshState needs to be called to verify that the current state on the\n// container is what is true.  Because consumers of libcontainer can use it\n// out of process we need to verify the container's status based on runtime\n// information and not rely on our in process info.\nfunc (c *Container) refreshState() error {\n\tpaused, err := c.isPaused()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif paused {\n\t\treturn c.state.transition(&pausedState{c: c})\n\t}\n\tif !c.hasInit() {\n\t\treturn c.state.transition(&stoppedState{c: c})\n\t}\n\t// The presence of exec fifo helps to distinguish between\n\t// the created and the running states.\n\tif _, err := os.Stat(filepath.Join(c.stateDir, execFifoFilename)); err == nil {\n\t\treturn c.state.transition(&createdState{c: c})\n\t}\n\treturn c.state.transition(&runningState{c: c})\n}\n\n// hasInit tells whether the container init process exists.\nfunc (c *Container) hasInit() bool {\n\tif c.initProcess == nil {\n\t\treturn false\n\t}\n\tpid := c.initProcess.pid()\n\tstat, err := system.Stat(pid)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif stat.StartTime != c.initProcessStartTime || stat.State == system.Zombie || stat.State == system.Dead {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (c *Container) isPaused() (bool, error) {\n\tstate, err := c.cgroupManager.GetFreezerState()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn state == configs.Frozen, nil\n}\n\nfunc (c *Container) currentState() (*State, error) {\n\tvar (\n\t\tstartTime           uint64\n\t\texternalDescriptors []string\n\t\tpid                 = -1\n\t)\n\tif c.initProcess != nil {\n\t\tpid = c.initProcess.pid()\n\t\tstartTime, _ = c.initProcess.startTime()\n\t\texternalDescriptors = c.initProcess.externalDescriptors()\n\t}\n\n\tintelRdtPath := \"\"\n\tif c.intelRdtManager != nil {\n\t\tintelRdtPath = c.intelRdtManager.GetPath()\n\t}\n\tstate := &State{\n\t\tBaseState: BaseState{\n\t\t\tID:                   c.ID(),\n\t\t\tConfig:               *c.config,\n\t\t\tInitProcessPid:       pid,\n\t\t\tInitProcessStartTime: startTime,\n\t\t\tCreated:              c.created,\n\t\t},\n\t\tRootless:            c.config.RootlessEUID && c.config.RootlessCgroups,\n\t\tCgroupPaths:         c.cgroupManager.GetPaths(),\n\t\tIntelRdtPath:        intelRdtPath,\n\t\tNamespacePaths:      make(map[configs.NamespaceType]string),\n\t\tExternalDescriptors: externalDescriptors,\n\t}\n\tif pid > 0 {\n\t\tfor _, ns := range c.config.Namespaces {\n\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t}\n\t\tfor _, nsType := range configs.NamespaceTypes() {\n\t\t\tif !configs.IsNamespaceSupported(nsType) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, ok := state.NamespacePaths[nsType]; !ok {\n\t\t\t\tns := configs.Namespace{Type: nsType}\n\t\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t\t}\n\t\t}\n\t}\n\treturn state, nil\n}\n\nfunc (c *Container) currentOCIState() (*specs.State, error) {\n\tbundle, annotations := utils.Annotations(c.config.Labels)\n\tstate := &specs.State{\n\t\tVersion:     specs.Version,\n\t\tID:          c.ID(),\n\t\tBundle:      bundle,\n\t\tAnnotations: annotations,\n\t}\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstate.Status = specs.ContainerState(status.String())\n\tif status != Stopped {\n\t\tif c.initProcess != nil {\n\t\t\tstate.Pid = c.initProcess.pid()\n\t\t}\n\t}\n\treturn state, nil\n}\n\n// orderNamespacePaths sorts namespace paths into a list of paths that we\n// can setns in order.\nfunc (c *Container) orderNamespacePaths(namespaces map[configs.NamespaceType]string) ([]string, error) {\n\tpaths := []string{}\n\tfor _, ns := range configs.NamespaceTypes() {\n\n\t\t// Remove namespaces that we don't need to join.\n\t\tif !c.config.Namespaces.Contains(ns) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif p, ok := namespaces[ns]; ok && p != \"\" {\n\t\t\t// check if the requested namespace is supported\n\t\t\tif !configs.IsNamespaceSupported(ns) {\n\t\t\t\treturn nil, fmt.Errorf(\"namespace %s is not supported\", ns)\n\t\t\t}\n\t\t\t// only set to join this namespace if it exists\n\t\t\tif _, err := os.Lstat(p); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"namespace path: %w\", err)\n\t\t\t}\n\t\t\t// do not allow namespace path with comma as we use it to separate\n\t\t\t// the namespace paths\n\t\t\tif strings.ContainsRune(p, ',') {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid namespace path %s\", p)\n\t\t\t}\n\t\t\tpaths = append(paths, fmt.Sprintf(\"%s:%s\", configs.NsName(ns), p))\n\t\t}\n\n\t}\n\n\treturn paths, nil\n}\n\nfunc encodeIDMapping(idMap []configs.IDMap) ([]byte, error) {\n\tdata := bytes.NewBuffer(nil)\n\tfor _, im := range idMap {\n\t\tline := fmt.Sprintf(\"%d %d %d\\n\", im.ContainerID, im.HostID, im.Size)\n\t\tif _, err := data.WriteString(line); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn data.Bytes(), nil\n}\n\n// netlinkError is an error wrapper type for use by custom netlink message\n// types. Panics with errors are wrapped in netlinkError so that the recover\n// in bootstrapData can distinguish intentional panics.\ntype netlinkError struct{ error }\n\n// bootstrapData encodes the necessary data in netlink binary format\n// as a io.Reader.\n// Consumer can write the data to a bootstrap program\n// such as one that uses nsenter package to bootstrap the container's\n// init process correctly, i.e. with correct namespaces, uid/gid\n// mapping etc.\nfunc (c *Container) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string) (_ io.Reader, Err error) {\n\t// create the netlink message\n\tr := nl.NewNetlinkRequest(int(InitMsg), 0)\n\n\t// Our custom messages cannot bubble up an error using returns, instead\n\t// they will panic with the specific error type, netlinkError. In that\n\t// case, recover from the panic and return that as an error.\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif e, ok := r.(netlinkError); ok {\n\t\t\t\tErr = e.error\n\t\t\t} else {\n\t\t\t\tpanic(r)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// write cloneFlags\n\tr.AddData(&Int32msg{\n\t\tType:  CloneFlagsAttr,\n\t\tValue: uint32(cloneFlags),\n\t})\n\n\t// write custom namespace paths\n\tif len(nsMaps) > 0 {\n\t\tnsPaths, err := c.orderNamespacePaths(nsMaps)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  NsPathsAttr,\n\t\t\tValue: []byte(strings.Join(nsPaths, \",\")),\n\t\t})\n\t}\n\n\t// write namespace paths only when we are not joining an existing user ns\n\t_, joinExistingUser := nsMaps[configs.NEWUSER]\n\tif !joinExistingUser {\n\t\t// write uid mappings\n\t\tif len(c.config.UIDMappings) > 0 {\n\t\t\tif c.config.RootlessEUID {\n\t\t\t\t// We resolve the paths for new{u,g}idmap from\n\t\t\t\t// the context of runc to avoid doing a path\n\t\t\t\t// lookup in the nsexec context.\n\t\t\t\tif path, err := execabs.LookPath(\"newuidmap\"); err == nil {\n\t\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\t\tType:  UidmapPathAttr,\n\t\t\t\t\t\tValue: []byte(path),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tb, err := encodeIDMapping(c.config.UIDMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  UidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t}\n\n\t\t// write gid mappings\n\t\tif len(c.config.GIDMappings) > 0 {\n\t\t\tb, err := encodeIDMapping(c.config.GIDMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  GidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t\tif c.config.RootlessEUID {\n\t\t\t\tif path, err := execabs.LookPath(\"newgidmap\"); err == nil {\n\t\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\t\tType:  GidmapPathAttr,\n\t\t\t\t\t\tValue: []byte(path),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tif requiresRootOrMappingTool(c.config) {\n\t\t\t\tr.AddData(&Boolmsg{\n\t\t\t\t\tType:  SetgroupAttr,\n\t\t\t\t\tValue: true,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.config.OomScoreAdj != nil {\n\t\t// write oom_score_adj\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  OomScoreAdjAttr,\n\t\t\tValue: []byte(strconv.Itoa(*c.config.OomScoreAdj)),\n\t\t})\n\t}\n\n\t// write rootless\n\tr.AddData(&Boolmsg{\n\t\tType:  RootlessEUIDAttr,\n\t\tValue: c.config.RootlessEUID,\n\t})\n\n\t// write boottime and monotonic time ns offsets.\n\tif c.config.TimeOffsets != nil {\n\t\tvar offsetSpec bytes.Buffer\n\t\tfor clock, offset := range c.config.TimeOffsets {\n\t\t\tfmt.Fprintf(&offsetSpec, \"%s %d %d\\n\", clock, offset.Secs, offset.Nanosecs)\n\t\t}\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  TimeOffsetsAttr,\n\t\t\tValue: offsetSpec.Bytes(),\n\t\t})\n\t}\n\n\treturn bytes.NewReader(r.Serialize()), nil\n}\n\n// ignoreTerminateErrors returns nil if the given err matches an error known\n// to indicate that the terminate occurred successfully or err was nil, otherwise\n// err is returned unaltered.\nfunc ignoreTerminateErrors(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\t// terminate() might return an error from either Kill or Wait.\n\t// The (*Cmd).Wait documentation says: \"If the command fails to run\n\t// or doesn't complete successfully, the error is of type *ExitError\".\n\t// Filter out such errors (like \"exit status 1\" or \"signal: killed\").\n\tvar exitErr *exec.ExitError\n\tif errors.As(err, &exitErr) {\n\t\treturn nil\n\t}\n\tif errors.Is(err, os.ErrProcessDone) {\n\t\treturn nil\n\t}\n\ts := err.Error()\n\tif strings.Contains(s, \"Wait was already called\") {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc requiresRootOrMappingTool(c *configs.Config) bool {\n\tgidMap := []configs.IDMap{\n\t\t{ContainerID: 0, HostID: int64(os.Getegid()), Size: 1},\n\t}\n\treturn !reflect.DeepEqual(c.GIDMappings, gidMap)\n}\n", "package libcontainer\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/containerd/console\"\n\t\"github.com/moby/sys/user\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/vishvananda/netlink\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/capabilities\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\ntype initType string\n\nconst (\n\tinitSetns    initType = \"setns\"\n\tinitStandard initType = \"standard\"\n)\n\ntype pid struct {\n\tPid           int `json:\"stage2_pid\"`\n\tPidFirstChild int `json:\"stage1_pid\"`\n}\n\n// network is an internal struct used to setup container networks.\ntype network struct {\n\tconfigs.Network\n\n\t// TempVethPeerName is a unique temporary veth peer name that was placed into\n\t// the container's namespace.\n\tTempVethPeerName string `json:\"temp_veth_peer_name\"`\n}\n\n// initConfig is used for transferring parameters from Exec() to Init()\ntype initConfig struct {\n\tArgs             []string              `json:\"args\"`\n\tEnv              []string              `json:\"env\"`\n\tCwd              string                `json:\"cwd\"`\n\tCapabilities     *configs.Capabilities `json:\"capabilities\"`\n\tProcessLabel     string                `json:\"process_label\"`\n\tAppArmorProfile  string                `json:\"apparmor_profile\"`\n\tNoNewPrivileges  bool                  `json:\"no_new_privileges\"`\n\tUser             string                `json:\"user\"`\n\tAdditionalGroups []string              `json:\"additional_groups\"`\n\tConfig           *configs.Config       `json:\"config\"`\n\tNetworks         []*network            `json:\"network\"`\n\tPassedFilesCount int                   `json:\"passed_files_count\"`\n\tContainerID      string                `json:\"containerid\"`\n\tRlimits          []configs.Rlimit      `json:\"rlimits\"`\n\tCreateConsole    bool                  `json:\"create_console\"`\n\tConsoleWidth     uint16                `json:\"console_width\"`\n\tConsoleHeight    uint16                `json:\"console_height\"`\n\tRootlessEUID     bool                  `json:\"rootless_euid,omitempty\"`\n\tRootlessCgroups  bool                  `json:\"rootless_cgroups,omitempty\"`\n\tSpecState        *specs.State          `json:\"spec_state,omitempty\"`\n\tCgroup2Path      string                `json:\"cgroup2_path,omitempty\"`\n}\n\n// Init is part of \"runc init\" implementation.\nfunc Init() {\n\truntime.GOMAXPROCS(1)\n\truntime.LockOSThread()\n\n\tif err := startInitialization(); err != nil {\n\t\t// If the error is returned, it was not communicated\n\t\t// back to the parent (which is not a common case),\n\t\t// so print it to stderr here as a last resort.\n\t\t//\n\t\t// Do not use logrus as we are not sure if it has been\n\t\t// set up yet, but most important, if the parent is\n\t\t// alive (and its log forwarding is working).\n\t\tfmt.Fprintln(os.Stderr, err)\n\t}\n\t// Normally, StartInitialization() never returns, meaning\n\t// if we are here, it had failed.\n\tos.Exit(255)\n}\n\n// Normally, this function does not return. If it returns, with or without an\n// error, it means the initialization has failed. If the error is returned,\n// it means the error can not be communicated back to the parent.\nfunc startInitialization() (retErr error) {\n\t// Get the synchronisation pipe.\n\tenvSyncPipe := os.Getenv(\"_LIBCONTAINER_SYNCPIPE\")\n\tsyncPipeFd, err := strconv.Atoi(envSyncPipe)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_SYNCPIPE: %w\", err)\n\t}\n\tsyncPipe := newSyncSocket(os.NewFile(uintptr(syncPipeFd), \"sync\"))\n\tdefer syncPipe.Close()\n\n\tdefer func() {\n\t\t// If this defer is ever called, this means initialization has failed.\n\t\t// Send the error back to the parent process in the form of an initError\n\t\t// if the sync socket has not been closed.\n\t\tif syncPipe.isClosed() {\n\t\t\treturn\n\t\t}\n\t\tierr := initError{Message: retErr.Error()}\n\t\tif err := writeSyncArg(syncPipe, procError, ierr); err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\treturn\n\t\t}\n\t\t// The error is sent, no need to also return it (or it will be reported twice).\n\t\tretErr = nil\n\t}()\n\n\t// Get the INITPIPE.\n\tenvInitPipe := os.Getenv(\"_LIBCONTAINER_INITPIPE\")\n\tinitPipeFd, err := strconv.Atoi(envInitPipe)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_INITPIPE: %w\", err)\n\t}\n\tinitPipe := os.NewFile(uintptr(initPipeFd), \"init\")\n\tdefer initPipe.Close()\n\n\t// Set up logging. This is used rarely, and mostly for init debugging.\n\n\t// Passing log level is optional; currently libcontainer/integration does not do it.\n\tif levelStr := os.Getenv(\"_LIBCONTAINER_LOGLEVEL\"); levelStr != \"\" {\n\t\tlogLevel, err := strconv.Atoi(levelStr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_LOGLEVEL: %w\", err)\n\t\t}\n\t\tlogrus.SetLevel(logrus.Level(logLevel))\n\t}\n\n\tlogFd, err := strconv.Atoi(os.Getenv(\"_LIBCONTAINER_LOGPIPE\"))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_LOGPIPE: %w\", err)\n\t}\n\tlogPipe := os.NewFile(uintptr(logFd), \"logpipe\")\n\n\tlogrus.SetOutput(logPipe)\n\tlogrus.SetFormatter(new(logrus.JSONFormatter))\n\tlogrus.Debug(\"child process in init()\")\n\n\t// Only init processes have FIFOFD.\n\tvar fifoFile *os.File\n\tenvInitType := os.Getenv(\"_LIBCONTAINER_INITTYPE\")\n\tit := initType(envInitType)\n\tif it == initStandard {\n\t\tfifoFd, err := strconv.Atoi(os.Getenv(\"_LIBCONTAINER_FIFOFD\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_FIFOFD: %w\", err)\n\t\t}\n\t\tfifoFile = os.NewFile(uintptr(fifoFd), \"initfifo\")\n\t}\n\n\tvar consoleSocket *os.File\n\tif envConsole := os.Getenv(\"_LIBCONTAINER_CONSOLE\"); envConsole != \"\" {\n\t\tconsole, err := strconv.Atoi(envConsole)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_CONSOLE: %w\", err)\n\t\t}\n\t\tconsoleSocket = os.NewFile(uintptr(console), \"console-socket\")\n\t\tdefer consoleSocket.Close()\n\t}\n\n\tvar pidfdSocket *os.File\n\tif envSockFd := os.Getenv(\"_LIBCONTAINER_PIDFD_SOCK\"); envSockFd != \"\" {\n\t\tsockFd, err := strconv.Atoi(envSockFd)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_PIDFD_SOCK: %w\", err)\n\t\t}\n\t\tpidfdSocket = os.NewFile(uintptr(sockFd), \"pidfd-socket\")\n\t\tdefer pidfdSocket.Close()\n\t}\n\n\t// Get runc-dmz fds.\n\tvar dmzExe *os.File\n\tif dmzFdStr := os.Getenv(\"_LIBCONTAINER_DMZEXEFD\"); dmzFdStr != \"\" {\n\t\tdmzFd, err := strconv.Atoi(dmzFdStr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_DMZEXEFD: %w\", err)\n\t\t}\n\t\tunix.CloseOnExec(dmzFd)\n\t\tdmzExe = os.NewFile(uintptr(dmzFd), \"runc-dmz\")\n\t}\n\n\t// clear the current process's environment to clean any libcontainer\n\t// specific env vars.\n\tos.Clearenv()\n\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tif err2, ok := err.(error); ok {\n\t\t\t\tretErr = fmt.Errorf(\"panic from initialization: %w, %s\", err2, debug.Stack())\n\t\t\t} else {\n\t\t\t\tretErr = fmt.Errorf(\"panic from initialization: %v, %s\", err, debug.Stack())\n\t\t\t}\n\t\t}\n\t}()\n\n\tvar config initConfig\n\tif err := json.NewDecoder(initPipe).Decode(&config); err != nil {\n\t\treturn err\n\t}\n\n\t// If init succeeds, it will not return, hence none of the defers will be called.\n\treturn containerInit(it, &config, syncPipe, consoleSocket, pidfdSocket, fifoFile, logPipe, dmzExe)\n}\n\nfunc containerInit(t initType, config *initConfig, pipe *syncSocket, consoleSocket, pidfdSocket, fifoFile, logPipe, dmzExe *os.File) error {\n\tif err := populateProcessEnvironment(config.Env); err != nil {\n\t\treturn err\n\t}\n\n\tswitch t {\n\tcase initSetns:\n\t\ti := &linuxSetnsInit{\n\t\t\tpipe:          pipe,\n\t\t\tconsoleSocket: consoleSocket,\n\t\t\tpidfdSocket:   pidfdSocket,\n\t\t\tconfig:        config,\n\t\t\tlogPipe:       logPipe,\n\t\t\tdmzExe:        dmzExe,\n\t\t}\n\t\treturn i.Init()\n\tcase initStandard:\n\t\ti := &linuxStandardInit{\n\t\t\tpipe:          pipe,\n\t\t\tconsoleSocket: consoleSocket,\n\t\t\tpidfdSocket:   pidfdSocket,\n\t\t\tparentPid:     unix.Getppid(),\n\t\t\tconfig:        config,\n\t\t\tfifoFile:      fifoFile,\n\t\t\tlogPipe:       logPipe,\n\t\t\tdmzExe:        dmzExe,\n\t\t}\n\t\treturn i.Init()\n\t}\n\treturn fmt.Errorf(\"unknown init type %q\", t)\n}\n\n// populateProcessEnvironment loads the provided environment variables into the\n// current processes's environment.\nfunc populateProcessEnvironment(env []string) error {\n\tfor _, pair := range env {\n\t\tp := strings.SplitN(pair, \"=\", 2)\n\t\tif len(p) < 2 {\n\t\t\treturn errors.New(\"invalid environment variable: missing '='\")\n\t\t}\n\t\tname, val := p[0], p[1]\n\t\tif name == \"\" {\n\t\t\treturn errors.New(\"invalid environment variable: name cannot be empty\")\n\t\t}\n\t\tif strings.IndexByte(name, 0) >= 0 {\n\t\t\treturn fmt.Errorf(\"invalid environment variable %q: name contains nul byte (\\\\x00)\", name)\n\t\t}\n\t\tif strings.IndexByte(val, 0) >= 0 {\n\t\t\treturn fmt.Errorf(\"invalid environment variable %q: value contains nul byte (\\\\x00)\", name)\n\t\t}\n\t\tif err := os.Setenv(name, val); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// verifyCwd ensures that the current directory is actually inside the mount\n// namespace root of the current process.\nfunc verifyCwd() error {\n\t// getcwd(2) on Linux detects if cwd is outside of the rootfs of the\n\t// current mount namespace root, and in that case prefixes \"(unreachable)\"\n\t// to the returned string. glibc's getcwd(3) and Go's Getwd() both detect\n\t// when this happens and return ENOENT rather than returning a non-absolute\n\t// path. In both cases we can therefore easily detect if we have an invalid\n\t// cwd by checking the return value of getcwd(3). See getcwd(3) for more\n\t// details, and CVE-2024-21626 for the security issue that motivated this\n\t// check.\n\t//\n\t// We have to use unix.Getwd() here because os.Getwd() has a workaround for\n\t// $PWD which involves doing stat(.), which can fail if the current\n\t// directory is inaccessible to the container process.\n\tif wd, err := unix.Getwd(); errors.Is(err, unix.ENOENT) {\n\t\treturn errors.New(\"current working directory is outside of container mount namespace root -- possible container breakout detected\")\n\t} else if err != nil {\n\t\treturn fmt.Errorf(\"failed to verify if current working directory is safe: %w\", err)\n\t} else if !filepath.IsAbs(wd) {\n\t\t// We shouldn't ever hit this, but check just in case.\n\t\treturn fmt.Errorf(\"current working directory is not absolute -- possible container breakout detected: cwd is %q\", wd)\n\t}\n\treturn nil\n}\n\n// finalizeNamespace drops the caps, sets the correct user\n// and working dir, and closes any leaked file descriptors\n// before executing the command inside the namespace\nfunc finalizeNamespace(config *initConfig) error {\n\t// Ensure that all unwanted fds we may have accidentally\n\t// inherited are marked close-on-exec so they stay out of the\n\t// container\n\tif err := utils.CloseExecFrom(config.PassedFilesCount + 3); err != nil {\n\t\treturn fmt.Errorf(\"error closing exec fds: %w\", err)\n\t}\n\n\t// we only do chdir if it's specified\n\tdoChdir := config.Cwd != \"\"\n\tif doChdir {\n\t\t// First, attempt the chdir before setting up the user.\n\t\t// This could allow us to access a directory that the user running runc can access\n\t\t// but the container user cannot.\n\t\terr := unix.Chdir(config.Cwd)\n\t\tswitch {\n\t\tcase err == nil:\n\t\t\tdoChdir = false\n\t\tcase os.IsPermission(err):\n\t\t\t// If we hit an EPERM, we should attempt again after setting up user.\n\t\t\t// This will allow us to successfully chdir if the container user has access\n\t\t\t// to the directory, but the user running runc does not.\n\t\t\t// This is useful in cases where the cwd is also a volume that's been chowned to the container user.\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"chdir to cwd (%q) set in config.json failed: %w\", config.Cwd, err)\n\t\t}\n\t}\n\n\tcaps := &configs.Capabilities{}\n\tif config.Capabilities != nil {\n\t\tcaps = config.Capabilities\n\t} else if config.Config.Capabilities != nil {\n\t\tcaps = config.Config.Capabilities\n\t}\n\tw, err := capabilities.New(caps)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// drop capabilities in bounding set before changing user\n\tif err := w.ApplyBoundingSet(); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply bounding set: %w\", err)\n\t}\n\t// preserve existing capabilities while we change users\n\tif err := system.SetKeepCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to set keep caps: %w\", err)\n\t}\n\tif err := setupUser(config); err != nil {\n\t\treturn fmt.Errorf(\"unable to setup user: %w\", err)\n\t}\n\t// Change working directory AFTER the user has been set up, if we haven't done it yet.\n\tif doChdir {\n\t\tif err := unix.Chdir(config.Cwd); err != nil {\n\t\t\treturn fmt.Errorf(\"chdir to cwd (%q) set in config.json failed: %w\", config.Cwd, err)\n\t\t}\n\t}\n\t// Make sure our final working directory is inside the container.\n\tif err := verifyCwd(); err != nil {\n\t\treturn err\n\t}\n\tif err := system.ClearKeepCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to clear keep caps: %w\", err)\n\t}\n\tif err := w.ApplyCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply caps: %w\", err)\n\t}\n\treturn nil\n}\n\n// setupConsole sets up the console from inside the container, and sends the\n// master pty fd to the config.Pipe (using cmsg). This is done to ensure that\n// consoles are scoped to a container properly (see runc#814 and the many\n// issues related to that). This has to be run *after* we've pivoted to the new\n// rootfs (and the users' configuration is entirely set up).\nfunc setupConsole(socket *os.File, config *initConfig, mount bool) error {\n\tdefer socket.Close()\n\t// At this point, /dev/ptmx points to something that we would expect. We\n\t// used to change the owner of the slave path, but since the /dev/pts mount\n\t// can have gid=X set (at the users' option). So touching the owner of the\n\t// slave PTY is not necessary, as the kernel will handle that for us. Note\n\t// however, that setupUser (specifically fixStdioPermissions) *will* change\n\t// the UID owner of the console to be the user the process will run as (so\n\t// they can actually control their console).\n\n\tpty, slavePath, err := console.NewPty()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// After we return from here, we don't need the console anymore.\n\tdefer pty.Close()\n\n\tif config.ConsoleHeight != 0 && config.ConsoleWidth != 0 {\n\t\terr = pty.Resize(console.WinSize{\n\t\t\tHeight: config.ConsoleHeight,\n\t\t\tWidth:  config.ConsoleWidth,\n\t\t})\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Mount the console inside our rootfs.\n\tif mount {\n\t\tif err := mountConsole(slavePath); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// While we can access console.master, using the API is a good idea.\n\tif err := utils.SendRawFd(socket, pty.Name(), pty.Fd()); err != nil {\n\t\treturn err\n\t}\n\truntime.KeepAlive(pty)\n\n\t// Now, dup over all the things.\n\treturn dupStdio(slavePath)\n}\n\n// syncParentReady sends to the given pipe a JSON payload which indicates that\n// the init is ready to Exec the child process. It then waits for the parent to\n// indicate that it is cleared to Exec.\nfunc syncParentReady(pipe *syncSocket) error {\n\t// Tell parent.\n\tif err := writeSync(pipe, procReady); err != nil {\n\t\treturn err\n\t}\n\t// Wait for parent to give the all-clear.\n\treturn readSync(pipe, procRun)\n}\n\n// syncParentHooks sends to the given pipe a JSON payload which indicates that\n// the parent should execute pre-start hooks. It then waits for the parent to\n// indicate that it is cleared to resume.\nfunc syncParentHooks(pipe *syncSocket) error {\n\t// Tell parent.\n\tif err := writeSync(pipe, procHooks); err != nil {\n\t\treturn err\n\t}\n\t// Wait for parent to give the all-clear.\n\treturn readSync(pipe, procHooksDone)\n}\n\n// syncParentSeccomp sends the fd associated with the seccomp file descriptor\n// to the parent, and wait for the parent to do pidfd_getfd() to grab a copy.\nfunc syncParentSeccomp(pipe *syncSocket, seccompFd *os.File) error {\n\tif seccompFd == nil {\n\t\treturn nil\n\t}\n\tdefer seccompFd.Close()\n\n\t// Tell parent to grab our fd.\n\t//\n\t// Notably, we do not use writeSyncFile here because a container might have\n\t// an SCMP_ACT_NOTIFY action on sendmsg(2) so we need to use the smallest\n\t// possible number of system calls here because all of those syscalls\n\t// cannot be used with SCMP_ACT_NOTIFY as a result (any syscall we use here\n\t// before the parent gets the file descriptor would deadlock \"runc init\" if\n\t// we allowed it for SCMP_ACT_NOTIFY). See seccomp.InitSeccomp() for more\n\t// details.\n\tif err := writeSyncArg(pipe, procSeccomp, seccompFd.Fd()); err != nil {\n\t\treturn err\n\t}\n\t// Wait for parent to tell us they've grabbed the seccompfd.\n\treturn readSync(pipe, procSeccompDone)\n}\n\n// setupUser changes the groups, gid, and uid for the user inside the container\nfunc setupUser(config *initConfig) error {\n\t// Set up defaults.\n\tdefaultExecUser := user.ExecUser{\n\t\tUid:  0,\n\t\tGid:  0,\n\t\tHome: \"/\",\n\t}\n\n\tpasswdPath, err := user.GetPasswdPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgroupPath, err := user.GetGroupPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\texecUser, err := user.GetExecUserPath(config.User, &defaultExecUser, passwdPath, groupPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar addGroups []int\n\tif len(config.AdditionalGroups) > 0 {\n\t\taddGroups, err = user.GetAdditionalGroupsPath(config.AdditionalGroups, groupPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif config.RootlessEUID {\n\t\t// We cannot set any additional groups in a rootless container and thus\n\t\t// we bail if the user asked us to do so. TODO: We currently can't do\n\t\t// this check earlier, but if libcontainer.Process.User was typesafe\n\t\t// this might work.\n\t\tif len(addGroups) > 0 {\n\t\t\treturn errors.New(\"cannot set any additional groups in a rootless container\")\n\t\t}\n\t}\n\n\t// Before we change to the container's user make sure that the processes\n\t// STDIO is correctly owned by the user that we are switching to.\n\tif err := fixStdioPermissions(execUser); err != nil {\n\t\treturn err\n\t}\n\n\t// We don't need to use /proc/thread-self here because setgroups is a\n\t// per-userns file and thus is global to all threads in a thread-group.\n\t// This lets us avoid having to do runtime.LockOSThread.\n\tsetgroups, err := os.ReadFile(\"/proc/self/setgroups\")\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\n\t// This isn't allowed in an unprivileged user namespace since Linux 3.19.\n\t// There's nothing we can do about /etc/group entries, so we silently\n\t// ignore setting groups here (since the user didn't explicitly ask us to\n\t// set the group).\n\tallowSupGroups := !config.RootlessEUID && string(bytes.TrimSpace(setgroups)) != \"deny\"\n\n\tif allowSupGroups {\n\t\tsuppGroups := append(execUser.Sgids, addGroups...)\n\t\tif err := unix.Setgroups(suppGroups); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"setgroups\", Err: err}\n\t\t}\n\t}\n\n\tif err := unix.Setgid(execUser.Gid); err != nil {\n\t\tif err == unix.EINVAL {\n\t\t\treturn fmt.Errorf(\"cannot setgid to unmapped gid %d in user namespace\", execUser.Gid)\n\t\t}\n\t\treturn err\n\t}\n\tif err := unix.Setuid(execUser.Uid); err != nil {\n\t\tif err == unix.EINVAL {\n\t\t\treturn fmt.Errorf(\"cannot setuid to unmapped uid %d in user namespace\", execUser.Uid)\n\t\t}\n\t\treturn err\n\t}\n\n\t// if we didn't get HOME already, set it based on the user's HOME\n\tif envHome := os.Getenv(\"HOME\"); envHome == \"\" {\n\t\tif err := os.Setenv(\"HOME\", execUser.Home); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// fixStdioPermissions fixes the permissions of PID 1's STDIO within the container to the specified user.\n// The ownership needs to match because it is created outside of the container and needs to be\n// localized.\nfunc fixStdioPermissions(u *user.ExecUser) error {\n\tvar null unix.Stat_t\n\tif err := unix.Stat(\"/dev/null\", &null); err != nil {\n\t\treturn &os.PathError{Op: \"stat\", Path: \"/dev/null\", Err: err}\n\t}\n\tfor _, file := range []*os.File{os.Stdin, os.Stdout, os.Stderr} {\n\t\tvar s unix.Stat_t\n\t\tif err := unix.Fstat(int(file.Fd()), &s); err != nil {\n\t\t\treturn &os.PathError{Op: \"fstat\", Path: file.Name(), Err: err}\n\t\t}\n\n\t\t// Skip chown if uid is already the one we want or any of the STDIO descriptors\n\t\t// were redirected to /dev/null.\n\t\tif int(s.Uid) == u.Uid || s.Rdev == null.Rdev {\n\t\t\tcontinue\n\t\t}\n\n\t\t// We only change the uid (as it is possible for the mount to\n\t\t// prefer a different gid, and there's no reason for us to change it).\n\t\t// The reason why we don't just leave the default uid=X mount setup is\n\t\t// that users expect to be able to actually use their console. Without\n\t\t// this code, you couldn't effectively run as a non-root user inside a\n\t\t// container and also have a console set up.\n\t\tif err := file.Chown(u.Uid, int(s.Gid)); err != nil {\n\t\t\t// If we've hit an EINVAL then s.Gid isn't mapped in the user\n\t\t\t// namespace. If we've hit an EPERM then the inode's current owner\n\t\t\t// is not mapped in our user namespace (in particular,\n\t\t\t// privileged_wrt_inode_uidgid() has failed). Read-only\n\t\t\t// /dev can result in EROFS error. In any case, it's\n\t\t\t// better for us to just not touch the stdio rather\n\t\t\t// than bail at this point.\n\n\t\t\tif errors.Is(err, unix.EINVAL) || errors.Is(err, unix.EPERM) || errors.Is(err, unix.EROFS) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// setupNetwork sets up and initializes any network interface inside the container.\nfunc setupNetwork(config *initConfig) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := strategy.initialize(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRoute(config *configs.Config) error {\n\tfor _, config := range config.Routes {\n\t\t_, dst, err := net.ParseCIDR(config.Destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrc := net.ParseIP(config.Source)\n\t\tif src == nil {\n\t\t\treturn fmt.Errorf(\"Invalid source for route: %s\", config.Source)\n\t\t}\n\t\tgw := net.ParseIP(config.Gateway)\n\t\tif gw == nil {\n\t\t\treturn fmt.Errorf(\"Invalid gateway for route: %s\", config.Gateway)\n\t\t}\n\t\tl, err := netlink.LinkByName(config.InterfaceName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\troute := &netlink.Route{\n\t\t\tScope:     netlink.SCOPE_UNIVERSE,\n\t\t\tDst:       dst,\n\t\t\tSrc:       src,\n\t\t\tGw:        gw,\n\t\t\tLinkIndex: l.Attrs().Index,\n\t\t}\n\t\tif err := netlink.RouteAdd(route); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRlimits(limits []configs.Rlimit, pid int) error {\n\tfor _, rlimit := range limits {\n\t\tif err := unix.Prlimit(pid, rlimit.Type, &unix.Rlimit{Max: rlimit.Hard, Cur: rlimit.Soft}, nil); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting rlimit type %v: %w\", rlimit.Type, err)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupScheduler(config *configs.Config) error {\n\tattr, err := configs.ToSchedAttr(config.Scheduler)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := unix.SchedSetAttr(0, attr, 0); err != nil {\n\t\tif errors.Is(err, unix.EPERM) && config.Cgroups.CpusetCpus != \"\" {\n\t\t\treturn errors.New(\"process scheduler can't be used together with AllowedCPUs\")\n\t\t}\n\t\treturn fmt.Errorf(\"error setting scheduler: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc setupPersonality(config *configs.Config) error {\n\treturn system.SetLinuxPersonality(config.Personality.Domain)\n}\n\n// signalAllProcesses freezes then iterates over all the processes inside the\n// manager's cgroups sending the signal s to them.\nfunc signalAllProcesses(m cgroups.Manager, s unix.Signal) error {\n\tif !m.Exists() {\n\t\treturn ErrNotRunning\n\t}\n\t// Use cgroup.kill, if available.\n\tif s == unix.SIGKILL {\n\t\tif p := m.Path(\"\"); p != \"\" { // Either cgroup v2 or hybrid.\n\t\t\terr := cgroups.WriteFile(p, \"cgroup.kill\", \"1\")\n\t\t\tif err == nil || !errors.Is(err, os.ErrNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Fallback to old implementation.\n\t\t}\n\t}\n\n\tif err := m.Freeze(configs.Frozen); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\tpids, err := m.GetAllPids()\n\tif err != nil {\n\t\tif err := m.Freeze(configs.Thawed); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t\treturn err\n\t}\n\tfor _, pid := range pids {\n\t\terr := unix.Kill(pid, s)\n\t\tif err != nil && err != unix.ESRCH {\n\t\t\tlogrus.Warnf(\"kill %d: %v\", pid, err)\n\t\t}\n\t}\n\tif err := m.Freeze(configs.Thawed); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\n\treturn nil\n}\n\n// setupPidfd opens a process file descriptor of init process, and sends the\n// file descriptor back to the socket.\nfunc setupPidfd(socket *os.File, initType string) error {\n\tdefer socket.Close()\n\n\tpidFd, err := unix.PidfdOpen(os.Getpid(), 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to pidfd_open: %w\", err)\n\t}\n\n\tif err := utils.SendRawFd(socket, initType, uintptr(pidFd)); err != nil {\n\t\tunix.Close(pidFd)\n\t\treturn fmt.Errorf(\"failed to send pidfd on socket: %w\", err)\n\t}\n\treturn unix.Close(pidFd)\n}\n", "//go:build linux && cgo && seccomp\n// +build linux,cgo,seccomp\n\npackage integration\n\nimport (\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\tlibseccomp \"github.com/seccomp/libseccomp-golang\"\n)\n\nfunc TestSeccompDenySyslogWithErrno(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\terrnoRet := uint(syscall.ESRCH)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:     \"syslog\",\n\t\t\t\tAction:   configs.Errno,\n\t\t\t\tErrnoRet: &errnoRet,\n\t\t\t},\n\t\t},\n\t}\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer container.Destroy() //nolint:errcheck\n\n\tbuffers := newStdBuffers()\n\tpwd := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"dmesg\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  buffers.Stdin,\n\t\tStdout: buffers.Stdout,\n\t\tStderr: buffers.Stderr,\n\t\tInit:   true,\n\t}\n\n\terr = container.Run(pwd)\n\tok(t, err)\n\tps, err := pwd.Wait()\n\tif err == nil {\n\t\tt.Fatal(\"Expecting error (negative return code); instead exited cleanly!\")\n\t}\n\n\tvar exitCode int\n\tstatus := ps.Sys().(syscall.WaitStatus)\n\tif status.Exited() {\n\t\texitCode = status.ExitStatus()\n\t} else if status.Signaled() {\n\t\texitCode = -int(status.Signal())\n\t} else {\n\t\tt.Fatalf(\"Unrecognized exit reason!\")\n\t}\n\n\tif exitCode == 0 {\n\t\tt.Fatalf(\"dmesg should fail with negative exit code, instead got %d!\", exitCode)\n\t}\n\n\texpected := \"dmesg: klogctl: No such process\"\n\tactual := strings.Trim(buffers.Stderr.String(), \"\\n\")\n\tif actual != expected {\n\t\tt.Fatalf(\"Expected output %s but got %s\\n\", expected, actual)\n\t}\n}\n\nfunc TestSeccompDenySyslog(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"syslog\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t},\n\t\t},\n\t}\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer container.Destroy() //nolint:errcheck\n\n\tbuffers := newStdBuffers()\n\tpwd := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"dmesg\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  buffers.Stdin,\n\t\tStdout: buffers.Stdout,\n\t\tStderr: buffers.Stderr,\n\t\tInit:   true,\n\t}\n\n\terr = container.Run(pwd)\n\tok(t, err)\n\tps, err := pwd.Wait()\n\tif err == nil {\n\t\tt.Fatal(\"Expecting error (negative return code); instead exited cleanly!\")\n\t}\n\n\tvar exitCode int\n\tstatus := ps.Sys().(syscall.WaitStatus)\n\tif status.Exited() {\n\t\texitCode = status.ExitStatus()\n\t} else if status.Signaled() {\n\t\texitCode = -int(status.Signal())\n\t} else {\n\t\tt.Fatalf(\"Unrecognized exit reason!\")\n\t}\n\n\tif exitCode == 0 {\n\t\tt.Fatalf(\"dmesg should fail with negative exit code, instead got %d!\", exitCode)\n\t}\n\n\texpected := \"dmesg: klogctl: Operation not permitted\"\n\tactual := strings.Trim(buffers.Stderr.String(), \"\\n\")\n\tif actual != expected {\n\t\tt.Fatalf(\"Expected output %s but got %s\\n\", expected, actual)\n\t}\n}\n\nfunc TestSeccompPermitWriteConditional(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer container.Destroy() //nolint:errcheck\n\n\tbuffers := newStdBuffers()\n\tdmesg := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"busybox\", \"ls\", \"/\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  buffers.Stdin,\n\t\tStdout: buffers.Stdout,\n\t\tStderr: buffers.Stderr,\n\t\tInit:   true,\n\t}\n\n\terr = container.Run(dmesg)\n\tok(t, err)\n\tif _, err := dmesg.Wait(); err != nil {\n\t\tt.Fatalf(\"%s: %s\", err, buffers.Stderr)\n\t}\n}\n\nfunc TestSeccompDenyWriteConditional(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\t// Only test if library version is v2.2.1 or higher\n\t// Conditional filtering will always error in v2.2.0 and lower\n\tmajor, minor, micro := libseccomp.GetLibraryVersion()\n\tif (major == 2 && minor < 2) || (major == 2 && minor == 2 && micro < 1) {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer container.Destroy() //nolint:errcheck\n\n\tbuffers := newStdBuffers()\n\tdmesg := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"busybox\", \"ls\", \"does_not_exist\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  buffers.Stdin,\n\t\tStdout: buffers.Stdout,\n\t\tStderr: buffers.Stderr,\n\t\tInit:   true,\n\t}\n\n\terr = container.Run(dmesg)\n\tok(t, err)\n\n\tps, err := dmesg.Wait()\n\tif err == nil {\n\t\tt.Fatal(\"Expecting negative return, instead got 0!\")\n\t}\n\n\tvar exitCode int\n\tstatus := ps.Sys().(syscall.WaitStatus)\n\tif status.Exited() {\n\t\texitCode = status.ExitStatus()\n\t} else if status.Signaled() {\n\t\texitCode = -int(status.Signal())\n\t} else {\n\t\tt.Fatalf(\"Unrecognized exit reason!\")\n\t}\n\n\tif exitCode == 0 {\n\t\tt.Fatalf(\"Busybox should fail with negative exit code, instead got %d!\", exitCode)\n\t}\n\n\t// We're denying write to stderr, so we expect an empty buffer\n\texpected := \"\"\n\tactual := strings.Trim(buffers.Stderr.String(), \"\\n\")\n\tif actual != expected {\n\t\tt.Fatalf(\"Expected output %s but got %s\\n\", expected, actual)\n\t}\n}\n\nfunc TestSeccompPermitWriteMultipleConditions(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 2,\n\t\t\t\t\t\tValue: 0,\n\t\t\t\t\t\tOp:    configs.NotEqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tbuffers := runContainerOk(t, config, \"ls\", \"/\")\n\t// We don't need to verify the actual thing printed\n\t// Just that something was written to stdout\n\tif len(buffers.Stdout.String()) == 0 {\n\t\tt.Fatalf(\"Nothing was written to stdout, write call failed!\\n\")\n\t}\n}\n\nfunc TestSeccompDenyWriteMultipleConditions(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\t// Only test if library version is v2.2.1 or higher\n\t// Conditional filtering will always error in v2.2.0 and lower\n\tmajor, minor, micro := libseccomp.GetLibraryVersion()\n\tif (major == 2 && minor < 2) || (major == 2 && minor == 2 && micro < 1) {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 2,\n\t\t\t\t\t\tValue: 0,\n\t\t\t\t\t\tOp:    configs.NotEqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tbuffers, exitCode, err := runContainer(t, config, \"ls\", \"/does_not_exist\")\n\tif err == nil {\n\t\tt.Fatalf(\"Expecting error return, instead got 0\")\n\t}\n\tif exitCode == 0 {\n\t\tt.Fatalf(\"Busybox should fail with negative exit code, instead got %d!\", exitCode)\n\t}\n\n\texpected := \"\"\n\tactual := strings.Trim(buffers.Stderr.String(), \"\\n\")\n\tif actual != expected {\n\t\tt.Fatalf(\"Expected output %s but got %s\\n\", expected, actual)\n\t}\n}\n\nfunc TestSeccompMultipleConditionSameArgDeniesStdout(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\t// Prevent writing to both stdout and stderr.\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 1,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tbuffers := runContainerOk(t, config, \"ls\", \"/\")\n\t// Verify that nothing was printed\n\tif len(buffers.Stdout.String()) != 0 {\n\t\tt.Fatalf(\"Something was written to stdout, write call succeeded!\\n\")\n\t}\n}\n\nfunc TestSeccompMultipleConditionSameArgDeniesStderr(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\t// Prevent writing to both stdout and stderr.\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Seccomp = &configs.Seccomp{\n\t\tDefaultAction: configs.Allow,\n\t\tSyscalls: []*configs.Syscall{\n\t\t\t{\n\t\t\t\tName:   \"write\",\n\t\t\t\tAction: configs.Errno,\n\t\t\t\tArgs: []*configs.Arg{\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 1,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\tValue: 2,\n\t\t\t\t\t\tOp:    configs.EqualTo,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tbuffers, exitCode, err := runContainer(t, config, \"ls\", \"/does_not_exist\")\n\tif err == nil {\n\t\tt.Fatalf(\"Expecting error return, instead got 0\")\n\t}\n\tif exitCode == 0 {\n\t\tt.Fatalf(\"Busybox should fail with negative exit code, instead got %d!\", exitCode)\n\t}\n\t// Verify nothing was printed\n\tif len(buffers.Stderr.String()) != 0 {\n\t\tt.Fatalf(\"Something was written to stderr, write call succeeded!\\n\")\n\t}\n}\n", "package libcontainer\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\n\t\"github.com/opencontainers/selinux/go-selinux\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runc/libcontainer/keys\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\n// linuxSetnsInit performs the container's initialization for running a new process\n// inside an existing container.\ntype linuxSetnsInit struct {\n\tpipe          *syncSocket\n\tconsoleSocket *os.File\n\tpidfdSocket   *os.File\n\tconfig        *initConfig\n\tlogPipe       *os.File\n\tdmzExe        *os.File\n}\n\nfunc (l *linuxSetnsInit) getSessionRingName() string {\n\treturn \"_ses.\" + l.config.ContainerID\n}\n\nfunc (l *linuxSetnsInit) Init() error {\n\tif !l.config.Config.NoNewKeyring {\n\t\tif err := selinux.SetKeyLabel(l.config.ProcessLabel); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer selinux.SetKeyLabel(\"\") //nolint: errcheck\n\t\t// Do not inherit the parent's session keyring.\n\t\tif _, err := keys.JoinSessionKeyring(l.getSessionRingName()); err != nil {\n\t\t\t// Same justification as in standart_init_linux.go as to why we\n\t\t\t// don't bail on ENOSYS.\n\t\t\t//\n\t\t\t// TODO(cyphar): And we should have logging here too.\n\t\t\tif !errors.Is(err, unix.ENOSYS) {\n\t\t\t\treturn fmt.Errorf(\"unable to join session keyring: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\tif l.config.CreateConsole {\n\t\tif err := setupConsole(l.consoleSocket, l.config, false); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := system.Setctty(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif l.pidfdSocket != nil {\n\t\tif err := setupPidfd(l.pidfdSocket, \"setns\"); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to setup pidfd: %w\", err)\n\t\t}\n\t}\n\tif l.config.NoNewPrivileges {\n\t\tif err := unix.Prctl(unix.PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif l.config.Config.Umask != nil {\n\t\tunix.Umask(int(*l.config.Config.Umask))\n\t}\n\n\tif l.config.Config.Scheduler != nil {\n\t\tif err := setupScheduler(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := selinux.SetExecLabel(l.config.ProcessLabel); err != nil {\n\t\treturn err\n\t}\n\tdefer selinux.SetExecLabel(\"\") //nolint: errcheck\n\t// Without NoNewPrivileges seccomp is a privileged operation, so we need to\n\t// do this before dropping capabilities; otherwise do it as late as possible\n\t// just before execve so as few syscalls take place after it as possible.\n\tif l.config.Config.Seccomp != nil && !l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := finalizeNamespace(l.config); err != nil {\n\t\treturn err\n\t}\n\tif err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {\n\t\treturn err\n\t}\n\tif l.config.Config.Personality != nil {\n\t\tif err := setupPersonality(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Check for the arg early to make sure it exists.\n\tname, err := exec.LookPath(l.config.Args[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\t// exec.LookPath in Go < 1.20 might return no error for an executable\n\t// residing on a file system mounted with noexec flag, so perform this\n\t// extra check now while we can still return a proper error.\n\t// TODO: remove this once go < 1.20 is not supported.\n\tif err := eaccess(name); err != nil {\n\t\treturn &os.PathError{Op: \"eaccess\", Path: name, Err: err}\n\t}\n\t// Set seccomp as close to execve as possible, so as few syscalls take\n\t// place afterward (reducing the amount of syscalls that users need to\n\t// enable in their seccomp profiles).\n\tif l.config.Config.Seccomp != nil && l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to init seccomp: %w\", err)\n\t\t}\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Close the log pipe fd so the parent's ForwardLogs can exit.\n\tlogrus.Debugf(\"setns_init: about to exec\")\n\tif err := l.logPipe.Close(); err != nil {\n\t\treturn fmt.Errorf(\"close log pipe: %w\", err)\n\t}\n\n\tif l.dmzExe != nil {\n\t\tl.config.Args[0] = name\n\t\treturn system.Fexecve(l.dmzExe.Fd(), l.config.Args, os.Environ())\n\t}\n\t// Close all file descriptors we are not passing to the container. This is\n\t// necessary because the execve target could use internal runc fds as the\n\t// execve path, potentially giving access to binary files from the host\n\t// (which can then be opened by container processes, leading to container\n\t// escapes). Note that because this operation will close any open file\n\t// descriptors that are referenced by (*os.File) handles from underneath\n\t// the Go runtime, we must not do any file operations after this point\n\t// (otherwise the (*os.File) finaliser could close the wrong file). See\n\t// CVE-2024-21626 for more information as to why this protection is\n\t// necessary.\n\t//\n\t// This is not needed for runc-dmz, because the extra execve(2) step means\n\t// that all O_CLOEXEC file descriptors have already been closed and thus\n\t// the second execve(2) from runc-dmz cannot access internal file\n\t// descriptors from runc.\n\tif err := utils.UnsafeCloseFrom(l.config.PassedFilesCount + 3); err != nil {\n\t\treturn err\n\t}\n\treturn system.Exec(name, l.config.Args, os.Environ())\n}\n", "package libcontainer\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/keys\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\ntype linuxStandardInit struct {\n\tpipe          *syncSocket\n\tconsoleSocket *os.File\n\tpidfdSocket   *os.File\n\tparentPid     int\n\tfifoFile      *os.File\n\tlogPipe       *os.File\n\tdmzExe        *os.File\n\tconfig        *initConfig\n}\n\nfunc (l *linuxStandardInit) getSessionRingParams() (string, uint32, uint32) {\n\tvar newperms uint32\n\n\tif l.config.Config.Namespaces.Contains(configs.NEWUSER) {\n\t\t// With user ns we need 'other' search permissions.\n\t\tnewperms = 0x8\n\t} else {\n\t\t// Without user ns we need 'UID' search permissions.\n\t\tnewperms = 0x80000\n\t}\n\n\t// Create a unique per session container name that we can join in setns;\n\t// However, other containers can also join it.\n\treturn \"_ses.\" + l.config.ContainerID, 0xffffffff, newperms\n}\n\nfunc (l *linuxStandardInit) Init() error {\n\tif !l.config.Config.NoNewKeyring {\n\t\tif err := selinux.SetKeyLabel(l.config.ProcessLabel); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer selinux.SetKeyLabel(\"\") //nolint: errcheck\n\t\tringname, keepperms, newperms := l.getSessionRingParams()\n\n\t\t// Do not inherit the parent's session keyring.\n\t\tif sessKeyId, err := keys.JoinSessionKeyring(ringname); err != nil {\n\t\t\t// If keyrings aren't supported then it is likely we are on an\n\t\t\t// older kernel (or inside an LXC container). While we could bail,\n\t\t\t// the security feature we are using here is best-effort (it only\n\t\t\t// really provides marginal protection since VFS credentials are\n\t\t\t// the only significant protection of keyrings).\n\t\t\t//\n\t\t\t// TODO(cyphar): Log this so people know what's going on, once we\n\t\t\t//               have proper logging in 'runc init'.\n\t\t\tif !errors.Is(err, unix.ENOSYS) {\n\t\t\t\treturn fmt.Errorf(\"unable to join session keyring: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t// Make session keyring searchable. If we've gotten this far we\n\t\t\t// bail on any error -- we don't want to have a keyring with bad\n\t\t\t// permissions.\n\t\t\tif err := keys.ModKeyringPerm(sessKeyId, keepperms, newperms); err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to mod keyring permissions: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := setupNetwork(l.config); err != nil {\n\t\treturn err\n\t}\n\tif err := setupRoute(l.config.Config); err != nil {\n\t\treturn err\n\t}\n\n\t// initialises the labeling system\n\tselinux.GetEnabled()\n\n\terr := prepareRootfs(l.pipe, l.config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set up the console. This has to be done *before* we finalize the rootfs,\n\t// but *after* we've given the user the chance to set up all of the mounts\n\t// they wanted.\n\tif l.config.CreateConsole {\n\t\tif err := setupConsole(l.consoleSocket, l.config, true); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := system.Setctty(); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"ioctl(setctty)\", Err: err}\n\t\t}\n\t}\n\n\tif l.pidfdSocket != nil {\n\t\tif err := setupPidfd(l.pidfdSocket, \"standard\"); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to setup pidfd: %w\", err)\n\t\t}\n\t}\n\n\t// Finish the rootfs setup.\n\tif l.config.Config.Namespaces.Contains(configs.NEWNS) {\n\t\tif err := finalizeRootfs(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif hostname := l.config.Config.Hostname; hostname != \"\" {\n\t\tif err := unix.Sethostname([]byte(hostname)); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"sethostname\", Err: err}\n\t\t}\n\t}\n\tif domainname := l.config.Config.Domainname; domainname != \"\" {\n\t\tif err := unix.Setdomainname([]byte(domainname)); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"setdomainname\", Err: err}\n\t\t}\n\t}\n\tif err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply apparmor profile: %w\", err)\n\t}\n\n\tfor key, value := range l.config.Config.Sysctl {\n\t\tif err := writeSystemProperty(key, value); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.ReadonlyPaths {\n\t\tif err := readonlyPath(path); err != nil {\n\t\t\treturn fmt.Errorf(\"can't make %q read-only: %w\", path, err)\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.MaskPaths {\n\t\tif err := maskPath(path, l.config.Config.MountLabel); err != nil {\n\t\t\treturn fmt.Errorf(\"can't mask path %s: %w\", path, err)\n\t\t}\n\t}\n\tpdeath, err := system.GetParentDeathSignal()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"can't get pdeath signal: %w\", err)\n\t}\n\tif l.config.NoNewPrivileges {\n\t\tif err := unix.Prctl(unix.PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"prctl(SET_NO_NEW_PRIVS)\", Err: err}\n\t\t}\n\t}\n\n\tif l.config.Config.Scheduler != nil {\n\t\tif err := setupScheduler(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Tell our parent that we're ready to Execv. This must be done before the\n\t// Seccomp rules have been applied, because we need to be able to read and\n\t// write to a socket.\n\tif err := syncParentReady(l.pipe); err != nil {\n\t\treturn fmt.Errorf(\"sync ready: %w\", err)\n\t}\n\tif err := selinux.SetExecLabel(l.config.ProcessLabel); err != nil {\n\t\treturn fmt.Errorf(\"can't set process label: %w\", err)\n\t}\n\tdefer selinux.SetExecLabel(\"\") //nolint: errcheck\n\t// Without NoNewPrivileges seccomp is a privileged operation, so we need to\n\t// do this before dropping capabilities; otherwise do it as late as possible\n\t// just before execve so as few syscalls take place after it as possible.\n\tif l.config.Config.Seccomp != nil && !l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := finalizeNamespace(l.config); err != nil {\n\t\treturn err\n\t}\n\t// finalizeNamespace can change user/group which clears the parent death\n\t// signal, so we restore it here.\n\tif err := pdeath.Restore(); err != nil {\n\t\treturn fmt.Errorf(\"can't restore pdeath signal: %w\", err)\n\t}\n\t// Compare the parent from the initial start of the init process and make\n\t// sure that it did not change.  if the parent changes that means it died\n\t// and we were reparented to something else so we should just kill ourself\n\t// and not cause problems for someone else.\n\tif unix.Getppid() != l.parentPid {\n\t\treturn unix.Kill(unix.Getpid(), unix.SIGKILL)\n\t}\n\t// Check for the arg before waiting to make sure it exists and it is\n\t// returned as a create time error.\n\tname, err := exec.LookPath(l.config.Args[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\t// exec.LookPath in Go < 1.20 might return no error for an executable\n\t// residing on a file system mounted with noexec flag, so perform this\n\t// extra check now while we can still return a proper error.\n\t// TODO: remove this once go < 1.20 is not supported.\n\tif err := eaccess(name); err != nil {\n\t\treturn &os.PathError{Op: \"eaccess\", Path: name, Err: err}\n\t}\n\n\t// Set seccomp as close to execve as possible, so as few syscalls take\n\t// place afterward (reducing the amount of syscalls that users need to\n\t// enable in their seccomp profiles). However, this needs to be done\n\t// before closing the pipe since we need it to pass the seccompFd to\n\t// the parent.\n\tif l.config.Config.Seccomp != nil && l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to init seccomp: %w\", err)\n\t\t}\n\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Set personality if specified.\n\tif l.config.Config.Personality != nil {\n\t\tif err := setupPersonality(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Close the pipe to signal that we have completed our init.\n\tlogrus.Debugf(\"init: closing the pipe to signal completion\")\n\t_ = l.pipe.Close()\n\n\t// Close the log pipe fd so the parent's ForwardLogs can exit.\n\tlogrus.Debugf(\"init: about to wait on exec fifo\")\n\tif err := l.logPipe.Close(); err != nil {\n\t\treturn fmt.Errorf(\"close log pipe: %w\", err)\n\t}\n\n\tfifoPath, closer := utils.ProcThreadSelfFd(l.fifoFile.Fd())\n\tdefer closer()\n\n\t// Wait for the FIFO to be opened on the other side before exec-ing the\n\t// user process. We open it through /proc/self/fd/$fd, because the fd that\n\t// was given to us was an O_PATH fd to the fifo itself. Linux allows us to\n\t// re-open an O_PATH fd through /proc.\n\tfd, err := unix.Open(fifoPath, unix.O_WRONLY|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open exec fifo\", Path: fifoPath, Err: err}\n\t}\n\tif _, err := unix.Write(fd, []byte(\"0\")); err != nil {\n\t\treturn &os.PathError{Op: \"write exec fifo\", Path: fifoPath, Err: err}\n\t}\n\n\t// Close the O_PATH fifofd fd before exec because the kernel resets\n\t// dumpable in the wrong order. This has been fixed in newer kernels, but\n\t// we keep this to ensure CVE-2016-9962 doesn't re-emerge on older kernels.\n\t// N.B. the core issue itself (passing dirfds to the host filesystem) has\n\t// since been resolved.\n\t// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318\n\t_ = l.fifoFile.Close()\n\n\ts := l.config.SpecState\n\ts.Pid = unix.Getpid()\n\ts.Status = specs.StateCreated\n\tif err := l.config.Config.Hooks.Run(configs.StartContainer, s); err != nil {\n\t\treturn err\n\t}\n\n\tif l.dmzExe != nil {\n\t\tl.config.Args[0] = name\n\t\treturn system.Fexecve(l.dmzExe.Fd(), l.config.Args, os.Environ())\n\t}\n\t// Close all file descriptors we are not passing to the container. This is\n\t// necessary because the execve target could use internal runc fds as the\n\t// execve path, potentially giving access to binary files from the host\n\t// (which can then be opened by container processes, leading to container\n\t// escapes). Note that because this operation will close any open file\n\t// descriptors that are referenced by (*os.File) handles from underneath\n\t// the Go runtime, we must not do any file operations after this point\n\t// (otherwise the (*os.File) finaliser could close the wrong file). See\n\t// CVE-2024-21626 for more information as to why this protection is\n\t// necessary.\n\t//\n\t// This is not needed for runc-dmz, because the extra execve(2) step means\n\t// that all O_CLOEXEC file descriptors have already been closed and thus\n\t// the second execve(2) from runc-dmz cannot access internal file\n\t// descriptors from runc.\n\tif err := utils.UnsafeCloseFrom(l.config.PassedFilesCount + 3); err != nil {\n\t\treturn err\n\t}\n\treturn system.Exec(name, l.config.Args, os.Environ())\n}\n", "//go:build !windows\n// +build !windows\n\npackage utils\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"sync\"\n\t_ \"unsafe\" // for go:linkname\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// EnsureProcHandle returns whether or not the given file handle is on procfs.\nfunc EnsureProcHandle(fh *os.File) error {\n\tvar buf unix.Statfs_t\n\tif err := unix.Fstatfs(int(fh.Fd()), &buf); err != nil {\n\t\treturn fmt.Errorf(\"ensure %s is on procfs: %w\", fh.Name(), err)\n\t}\n\tif buf.Type != unix.PROC_SUPER_MAGIC {\n\t\treturn fmt.Errorf(\"%s is not on procfs\", fh.Name())\n\t}\n\treturn nil\n}\n\nvar (\n\thaveCloseRangeCloexecBool bool\n\thaveCloseRangeCloexecOnce sync.Once\n)\n\nfunc haveCloseRangeCloexec() bool {\n\thaveCloseRangeCloexecOnce.Do(func() {\n\t\t// Make sure we're not closing a random file descriptor.\n\t\ttmpFd, err := unix.FcntlInt(0, unix.F_DUPFD_CLOEXEC, 0)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer unix.Close(tmpFd)\n\n\t\terr = unix.CloseRange(uint(tmpFd), uint(tmpFd), unix.CLOSE_RANGE_CLOEXEC)\n\t\t// Any error means we cannot use close_range(CLOSE_RANGE_CLOEXEC).\n\t\t// -ENOSYS and -EINVAL ultimately mean we don't have support, but any\n\t\t// other potential error would imply that even the most basic close\n\t\t// operation wouldn't work.\n\t\thaveCloseRangeCloexecBool = err == nil\n\t})\n\treturn haveCloseRangeCloexecBool\n}\n\ntype fdFunc func(fd int)\n\n// fdRangeFrom calls the passed fdFunc for each file descriptor that is open in\n// the current process.\nfunc fdRangeFrom(minFd int, fn fdFunc) error {\n\tprocSelfFd, closer := ProcThreadSelf(\"fd\")\n\tdefer closer()\n\n\tfdDir, err := os.Open(procSelfFd)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fdDir.Close()\n\n\tif err := EnsureProcHandle(fdDir); err != nil {\n\t\treturn err\n\t}\n\n\tfdList, err := fdDir.Readdirnames(-1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, fdStr := range fdList {\n\t\tfd, err := strconv.Atoi(fdStr)\n\t\t// Ignore non-numeric file names.\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t// Ignore descriptors lower than our specified minimum.\n\t\tif fd < minFd {\n\t\t\tcontinue\n\t\t}\n\t\t// Ignore the file descriptor we used for readdir, as it will be closed\n\t\t// when we return.\n\t\tif uintptr(fd) == fdDir.Fd() {\n\t\t\tcontinue\n\t\t}\n\t\t// Run the closure.\n\t\tfn(fd)\n\t}\n\treturn nil\n}\n\n// CloseExecFrom sets the O_CLOEXEC flag on all file descriptors greater or\n// equal to minFd in the current process.\nfunc CloseExecFrom(minFd int) error {\n\t// Use close_range(CLOSE_RANGE_CLOEXEC) if possible.\n\tif haveCloseRangeCloexec() {\n\t\terr := unix.CloseRange(uint(minFd), math.MaxUint, unix.CLOSE_RANGE_CLOEXEC)\n\t\treturn os.NewSyscallError(\"close_range\", err)\n\t}\n\t// Otherwise, fall back to the standard loop.\n\treturn fdRangeFrom(minFd, unix.CloseOnExec)\n}\n\n//go:linkname runtime_IsPollDescriptor internal/poll.IsPollDescriptor\n\n// In order to make sure we do not close the internal epoll descriptors the Go\n// runtime uses, we need to ensure that we skip descriptors that match\n// \"internal/poll\".IsPollDescriptor. Yes, this is a Go runtime internal thing,\n// unfortunately there's no other way to be sure we're only keeping the file\n// descriptors the Go runtime needs. Hopefully nothing blows up doing this...\nfunc runtime_IsPollDescriptor(fd uintptr) bool //nolint:revive\n\n// UnsafeCloseFrom closes all file descriptors greater or equal to minFd in the\n// current process, except for those critical to Go's runtime (such as the\n// netpoll management descriptors).\n//\n// NOTE: That this function is incredibly dangerous to use in most Go code, as\n// closing file descriptors from underneath *os.File handles can lead to very\n// bad behaviour (the closed file descriptor can be re-used and then any\n// *os.File operations would apply to the wrong file). This function is only\n// intended to be called from the last stage of runc init.\nfunc UnsafeCloseFrom(minFd int) error {\n\t// We cannot use close_range(2) even if it is available, because we must\n\t// not close some file descriptors.\n\treturn fdRangeFrom(minFd, func(fd int) {\n\t\tif runtime_IsPollDescriptor(uintptr(fd)) {\n\t\t\t// These are the Go runtimes internal netpoll file descriptors.\n\t\t\t// These file descriptors are operated on deep in the Go scheduler,\n\t\t\t// and closing those files from underneath Go can result in panics.\n\t\t\t// There is no issue with keeping them because they are not\n\t\t\t// executable and are not useful to an attacker anyway. Also we\n\t\t\t// don't have any choice.\n\t\t\treturn\n\t\t}\n\t\t// There's nothing we can do about errors from close(2), and the\n\t\t// only likely error to be seen is EBADF which indicates the fd was\n\t\t// already closed (in which case, we got what we wanted).\n\t\t_ = unix.Close(fd)\n\t})\n}\n\n// NewSockPair returns a new SOCK_STREAM unix socket pair.\nfunc NewSockPair(name string) (parent, child *os.File, err error) {\n\tfds, err := unix.Socketpair(unix.AF_LOCAL, unix.SOCK_STREAM|unix.SOCK_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn os.NewFile(uintptr(fds[1]), name+\"-p\"), os.NewFile(uintptr(fds[0]), name+\"-c\"), nil\n}\n\n// WithProcfd runs the passed closure with a procfd path (/proc/self/fd/...)\n// corresponding to the unsafePath resolved within the root. Before passing the\n// fd, this path is verified to have been inside the root -- so operating on it\n// through the passed fdpath should be safe. Do not access this path through\n// the original path strings, and do not attempt to use the pathname outside of\n// the passed closure (the file handle will be freed once the closure returns).\nfunc WithProcfd(root, unsafePath string, fn func(procfd string) error) error {\n\t// Remove the root then forcefully resolve inside the root.\n\tunsafePath = stripRoot(root, unsafePath)\n\tpath, err := securejoin.SecureJoin(root, unsafePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"resolving path inside rootfs failed: %w\", err)\n\t}\n\n\tprocSelfFd, closer := ProcThreadSelf(\"fd/\")\n\tdefer closer()\n\n\t// Open the target path.\n\tfh, err := os.OpenFile(path, unix.O_PATH|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"open o_path procfd: %w\", err)\n\t}\n\tdefer fh.Close()\n\n\tprocfd := filepath.Join(procSelfFd, strconv.Itoa(int(fh.Fd())))\n\t// Double-check the path is the one we expected.\n\tif realpath, err := os.Readlink(procfd); err != nil {\n\t\treturn fmt.Errorf(\"procfd verification failed: %w\", err)\n\t} else if realpath != path {\n\t\treturn fmt.Errorf(\"possibly malicious path detected -- refusing to operate on %s\", realpath)\n\t}\n\n\treturn fn(procfd)\n}\n\ntype ProcThreadSelfCloser func()\n\nvar (\n\thaveProcThreadSelf     bool\n\thaveProcThreadSelfOnce sync.Once\n)\n\n// ProcThreadSelf returns a string that is equivalent to\n// /proc/thread-self/<subpath>, with a graceful fallback on older kernels where\n// /proc/thread-self doesn't exist. This method DOES NOT use SecureJoin,\n// meaning that the passed string needs to be trusted. The caller _must_ call\n// the returned procThreadSelfCloser function (which is runtime.UnlockOSThread)\n// *only once* after it has finished using the returned path string.\nfunc ProcThreadSelf(subpath string) (string, ProcThreadSelfCloser) {\n\thaveProcThreadSelfOnce.Do(func() {\n\t\tif _, err := os.Stat(\"/proc/thread-self/\"); err == nil {\n\t\t\thaveProcThreadSelf = true\n\t\t} else {\n\t\t\tlogrus.Debugf(\"cannot stat /proc/thread-self (%v), falling back to /proc/self/task/<tid>\", err)\n\t\t}\n\t})\n\n\t// We need to lock our thread until the caller is done with the path string\n\t// because any non-atomic operation on the path (such as opening a file,\n\t// then reading it) could be interrupted by the Go runtime where the\n\t// underlying thread is swapped out and the original thread is killed,\n\t// resulting in pull-your-hair-out-hard-to-debug issues in the caller. In\n\t// addition, the pre-3.17 fallback makes everything non-atomic because the\n\t// same thing could happen between unix.Gettid() and the path operations.\n\t//\n\t// In theory, we don't need to lock in the atomic user case when using\n\t// /proc/thread-self/, but it's better to be safe than sorry (and there are\n\t// only one or two truly atomic users of /proc/thread-self/).\n\truntime.LockOSThread()\n\n\tthreadSelf := \"/proc/thread-self/\"\n\tif !haveProcThreadSelf {\n\t\t// Pre-3.17 kernels did not have /proc/thread-self, so do it manually.\n\t\tthreadSelf = \"/proc/self/task/\" + strconv.Itoa(unix.Gettid()) + \"/\"\n\t\tif _, err := os.Stat(threadSelf); err != nil {\n\t\t\t// Unfortunately, this code is called from rootfs_linux.go where we\n\t\t\t// are running inside the pid namespace of the container but /proc\n\t\t\t// is the host's procfs. Unfortunately there is no real way to get\n\t\t\t// the correct tid to use here (the kernel age means we cannot do\n\t\t\t// things like set up a private fsopen(\"proc\") -- even scanning\n\t\t\t// NSpid in all of the tasks in /proc/self/task/*/status requires\n\t\t\t// Linux 4.1).\n\t\t\t//\n\t\t\t// So, we just have to assume that /proc/self is acceptable in this\n\t\t\t// one specific case.\n\t\t\tif os.Getpid() == 1 {\n\t\t\t\tlogrus.Debugf(\"/proc/thread-self (tid=%d) cannot be emulated inside the initial container setup -- using /proc/self instead: %v\", unix.Gettid(), err)\n\t\t\t} else {\n\t\t\t\t// This should never happen, but the fallback should work in most cases...\n\t\t\t\tlogrus.Warnf(\"/proc/thread-self could not be emulated for pid=%d (tid=%d) -- using more buggy /proc/self fallback instead: %v\", os.Getpid(), unix.Gettid(), err)\n\t\t\t}\n\t\t\tthreadSelf = \"/proc/self/\"\n\t\t}\n\t}\n\treturn threadSelf + subpath, runtime.UnlockOSThread\n}\n\n// ProcThreadSelfFd is small wrapper around ProcThreadSelf to make it easier to\n// create a /proc/thread-self handle for given file descriptor.\n//\n// It is basically equivalent to ProcThreadSelf(fmt.Sprintf(\"fd/%d\", fd)), but\n// without using fmt.Sprintf to avoid unneeded overhead.\nfunc ProcThreadSelfFd(fd uintptr) (string, ProcThreadSelfCloser) {\n\treturn ProcThreadSelf(\"fd/\" + strconv.FormatUint(uint64(fd), 10))\n}\n"], "filenames": ["libcontainer/cgroups/file.go", "libcontainer/container_linux.go", "libcontainer/init_linux.go", "libcontainer/integration/seccomp_test.go", "libcontainer/setns_init_linux.go", "libcontainer/standard_init_linux.go", "libcontainer/utils/utils_unix.go"], "buggy_code_start_loc": [69, 334, 9, 16, 16, 283, 13], "buggy_code_end_loc": [147, 334, 334, 131, 140, 283, 97], "fixing_code_start_loc": [69, 335, 10, 16, 17, 284, 14], "fixing_code_end_loc": [148, 344, 366, 131, 160, 302, 148], "type": "CWE-668", "message": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc 1.1.11 and earlier, due to an internal file descriptor leak, an attacker could cause a newly-spawned container process (from runc exec) to have a working directory in the host filesystem namespace, allowing for a container escape by giving access to the host filesystem (\"attack 2\"). The same attack could be used by a malicious image to allow a container process to gain access to the host filesystem through runc run (\"attack 1\"). Variants of attacks 1 and 2 could be also be used to overwrite semi-arbitrary host binaries, allowing for complete container escapes (\"attack 3a\" and \"attack 3b\"). runc 1.1.12 includes patches for this issue. ", "other": {"cve": {"id": "CVE-2024-21626", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-31T22:15:53.780", "lastModified": "2024-02-19T03:15:08.413", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc 1.1.11 and earlier, due to an internal file descriptor leak, an attacker could cause a newly-spawned container process (from runc exec) to have a working directory in the host filesystem namespace, allowing for a container escape by giving access to the host filesystem (\"attack 2\"). The same attack could be used by a malicious image to allow a container process to gain access to the host filesystem through runc run (\"attack 1\"). Variants of attacks 1 and 2 could be also be used to overwrite semi-arbitrary host binaries, allowing for complete container escapes (\"attack 3a\" and \"attack 3b\"). runc 1.1.12 includes patches for this issue. "}, {"lang": "es", "value": "runc es una herramienta CLI para generar y ejecutar contenedores en Linux de acuerdo con la especificaci\u00f3n OCI. En runc 1.1.11 y versiones anteriores, debido a una fuga interna de un descriptor de archivo, un atacante podr\u00eda provocar que un proceso contenedor reci\u00e9n generado (de runc exec) tuviera un directorio de trabajo en el espacio de nombres del sistema de archivos del host, lo que permitir\u00eda un escape del contenedor al otorgar acceso. al sistema de archivos del host (\"ataque 2\"). El mismo ataque podr\u00eda ser utilizado por una imagen maliciosa para permitir que un proceso contenedor obtenga acceso al sistema de archivos del host a trav\u00e9s de runc run (\"ataque 1\"). Las variantes de los ataques 1 y 2 tambi\u00e9n podr\u00edan usarse para sobrescribir archivos binarios de host semiarbitrarios, permitiendo escapes completos de contenedores (\"ataque 3a\" y \"ataque 3b\"). runc 1.1.12 incluye parches para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-403"}, {"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.12", "matchCriteriaId": "D656F217-AB80-4BE5-8CDC-54C53AF3DAA9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/176993/runc-1.1.11-File-Descriptor-Leak-Privilege-Escalation.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2024/02/01/1", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "http://www.openwall.com/lists/oss-security/2024/02/02/3", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://github.com/opencontainers/runc/commit/02120488a4c0fc487d1ed2867e901eeed7ce8ecf", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/opencontainers/runc/releases/tag/v1.1.12", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/02/msg00005.html", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2NLXNE23Q5ESQUAI22Z7A63JX2WMPJ2J/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SYMO3BANINS6RGFQFKPRG4FIOJ7GWYTL/", "source": "security-advisories@github.com", "tags": ["Mailing List"]}]}, "github_commit_url": "https://github.com/opencontainers/runc/commit/02120488a4c0fc487d1ed2867e901eeed7ce8ecf"}}