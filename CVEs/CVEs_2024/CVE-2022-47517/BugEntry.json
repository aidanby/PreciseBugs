{"buggy_code": ["/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n/**@CFILE url.c\n *\n * Implementation of basic URL parsing and handling.\n *\n * @author Pekka Pessi <Pekka.Pessi@nokia.com>\n *\n * @date Created: Thu Jun 29 22:44:37 2000 ppessi\n */\n\n#include \"config.h\"\n\n#include <sofia-sip/su_alloc.h>\n#include <sofia-sip/bnf.h>\n#include <sofia-sip/hostdomain.h>\n#include <sofia-sip/url.h>\n\n#include <sofia-sip/string0.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n\n/**@def URL_PRINT_FORMAT\n * Format string used when printing url with printf().\n *\n * The macro URL_PRINT_FORMAT is used in format string of printf() or\n * similar printing functions.  A URL can be printed like this:\n * @code\n *   printf(\"%s received URL \" URL_PRINT_FORMAT \"\\n\",\n *          my_name, URL_PRINT_ARGS(url));\n * @endcode\n */\n\n/** @def URL_PRINT_ARGS(u)\n * Argument list used when printing url with printf().\n *\n * The macro URL_PRINT_ARGS() is used to create a stdarg list for printf()\n * or similar printing functions.  Using it, a URL can be printed like this:\n *\n * @code\n *   printf(\"%s received URL \" URL_PRINT_FORMAT \"\\n\",\n *          my_name, URL_PRINT_ARGS(url));\n * @endcode\n */\n\n#define RESERVED        \";/?:@&=+$,\"\n#define DELIMS          \"<>#%\\\"\"\n#define UNWISE\t\t\"{}|\\\\^[]`\"\n\n#define EXCLUDED\tRESERVED DELIMS UNWISE\n\n#define UNRESERVED    \t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \\\n                      \t\"abcdefghijklmnopqrstuvwxyz\" \\\n                      \t\"0123456789\" \\\n                      \t\"-_.!~*'()\"\n\n#define IS_EXCLUDED(u, m32, m64, m96)\t\t\t\\\n  (u <= ' '\t\t\t\t\t\t\\\n   || u >= '\\177'\t\t\t\t\t\\\n   || (u < 64 ? (m32 & (1 << (63 - u)))\t\t\t\\\n       : (u < 96 ? (m64 & (1 << (95 - u)))\t\t\\\n\t  : /*u < 128*/ (m96 & (1 << (127 - u))))) != 0)\n\n#define MASKS_WITH_RESERVED(reserved, m32, m64, m96)\t\t\\\n  if (reserved == NULL) {\t\t\t\t\t\\\n    m32 = 0xbe19003f, m64 = 0x8000001e, m96 = 0x8000001d;\t\\\n  } else do {\t\t\t\t\t\t\t\\\n    m32 = 0xb400000a, m64 = 0x0000001e, m96 = 0x8000001d;\t\\\n    \t\t\t\t\t\t\t\t\\\n    for (;reserved[0]; reserved++) {\t\t\t\t\\\n      unsigned r = reserved[0];\t\t\t\t\t\\\n      RESERVE(r, m32, m64, m96);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n#define RESERVE(reserved, m32, m64, m96)\t\t\t\t\\\n  if (r < 32)\t\t\t\t\t\t\t\t\\\n    ;\t\t\t\t\t\t\t\t\t\\\n  else if (r < 64)\t\t\t\t\t\t\t\\\n    m32 |= 1U << (63 - r);\t\t\t\t\t\t\\\n  else if (r < 96)\t\t\t\t\t\t\t\\\n    m64 |= 1U << (95 - r);\t\t\t\t\t\t\\\n  else if (r < 128)\t\t\t\t\t\t\t\\\n    m96 |= 1U << (127 - r)\n\n#define MASKS_WITH_ALLOWED(allowed, mask32, mask64, mask96)\t\\\n  do {\t\t\t\t\t\t\t\t\\\n    if (allowed) {\t\t\t\t\t\t\\\n      for (;allowed[0]; allowed++) {\t\t\t\t\\\n\tunsigned a = allowed[0];\t\t\t\t\\\n\tALLOW(a, mask32, mask64, mask96);\t\t\t\\\n      }\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n#define ALLOW(a, mask32, mask64, mask96)\t\\\n  if (a < 32)\t\t\t\t\t\\\n    ;\t\t\t\t\t\t\\\n  else if (a < 64)\t\t\t\t\\\n    mask32 &= ~(1U << (63 - a));\t\t\\\n  else if (a < 96)\t\t\t\t\\\n    mask64 &= ~(1U << (95 - a));\t\t\\\n  else if (a < 128)\t\t\t\t\\\n    mask96 &= ~(1U << (127 - a))\n\n#define NUL '\\0'\n#define NULNULNUL '\\0', '\\0', '\\0'\n\n#define RMASK1 0xbe19003f\n#define RMASK2 0x8000001e\n#define RMASK3 0x8000001d\n\n#define RESERVED_MASK 0xbe19003f, 0x8000001e, 0x8000001d\n#define URIC_MASK     0xb400000a, 0x0000001e, 0x8000001d\n\n#define IS_EXCLUDED_MASK(u, m) IS_EXCLUDED(u, m)\n\n/* Internal prototypes */\nstatic char *url_canonize(char *d, char const *s, size_t n,\n\t\t\t  unsigned syn33,\n\t\t\t  char const allowed[]);\nstatic char *url_canonize2(char *d, char const *s, size_t n,\n\t\t\t   unsigned syn33,\n\t\t\t   unsigned m32, unsigned m64, unsigned m96);\nstatic int url_tel_cmp_numbers(char const *A, char const *B);\n\n/**Test if string contains excluded or url-reserved characters.\n *\n *\n *\n * @param s  string to be searched\n *\n * @retval 0 if no reserved characters were found.\n * @retval l if a reserved character was found.\n */\nint url_reserved_p(char const *s)\n{\n  if (s)\n    while (*s) {\n      unsigned char u = *s++;\n\n      if (IS_EXCLUDED(u, RMASK1, RMASK2, RMASK3))\n\treturn 1;\n    }\n\n  return 0;\n}\n\n/** Calculate length of string when escaped with %-notation.\n *\n * Calculate the length of string @a s when the excluded or reserved\n * characters in it have been escaped.\n *\n * @param s         String with reserved URL characters. [IN\n * @param reserved  Optional array of reserved characters [IN]\n *\n * @return\n * The number of characters in corresponding but escaped string.\n *\n * You can handle a part of URL with reserved characters like this:\n *\ufffd@code\n * if (url_reserved_p(s))  {\n *   n = malloc(url_esclen(s, NULL) + 1);\n *   if (n) url_escape(n, s);\n * } else {\n *   n = malloc(strlen(s) + 1);\n *   if (n) strcpy(n, s);\n * }\n * @endcode\n */\nisize_t url_esclen(char const *s, char const reserved[])\n{\n  size_t n;\n  unsigned mask32, mask64, mask96;\n\n  MASKS_WITH_RESERVED(reserved, mask32, mask64, mask96);\n\n  for (n = 0; s && *s; n++) {\n    unsigned char u = *s++;\n\n    if (IS_EXCLUDED(u, mask32, mask64, mask96))\n      n += 2;\n  }\n\n  return (isize_t)n;\n}\n\n/** Escape a string.\n *\n * The function url_escape() copies the string pointed by @a s to the array\n * pointed by @a d, @b excluding the terminating \\\\0 character.  All reserved\n * characters in @a s are copied in hexadecimal format, for instance, @c\n * \"$%#\" is copied as @c \"%24%25%23\".  The destination array @a d must be\n * large enough to receive the escaped copy.\n *\n * @param d         Destination buffer [OUT]\n * @param s         String to be copied [IN]\n * @param reserved  Array of reserved characters [IN]\n *\n * @return Pointer to the destination array.\n */\nchar *url_escape(char *d, char const *s, char const reserved[])\n{\n  char *retval = d;\n  unsigned mask32, mask64, mask96;\n\n  MASKS_WITH_RESERVED(reserved, mask32, mask64, mask96);\n\n  while (s && *s) {\n    unsigned char u = *s++;\n\n    if (IS_EXCLUDED(u, mask32, mask64, mask96)) {\n#     define URL_HEXIFY(u) ((u) + '0' + ((u) >= 10 ? 'A' - '0' - 10 : 0))\n\n      *d++ = '%';\n      *d++ = URL_HEXIFY(u >> 4);\n      *d++ = URL_HEXIFY(u & 15);\n\n#     undef URL_HEXIFY\n    }\n    else {\n      *d++ = u;\n    }\n  }\n\n  *d = '\\0';\n\n  return retval;\n}\n\n\n/**Unescape url-escaped string fragment.\n *\n * Unescape @a n characters from string @a s to the buffer @a d, including\n * the terminating \\\\0 character. All %-escaped triplets in @a s are\n * unescaped, for instance, @c \"%40%25%23\" is copied as @c \"@%#\". The\n * destination array @a d must be large enough to receive the escaped copy\n * (@a n bytes is always enough).\n *\n * @param d  destination buffer\n * @param s  string to be unescaped\n * @param n  maximum number of characters to unescape\n *\n * @return Length of unescaped string\n *\n * @NEW_1_12_4.\n */\nsize_t url_unescape_to(char *d, char const *s, size_t n)\n{\n  size_t i = 0, j = 0;\n\n  if (s == NULL)\n    return 0;\n\n  i = j = strncspn(s, n, \"%\");\n\n  if (d && d != s)\n    memmove(d, s, i);\n\n  for (; i < n;) {\n    char c = s[i++];\n\n    if (c == '\\0')\n      break;\n\n    if (c == '%' && i + 1 < n && IS_HEX(s[i]) && IS_HEX(s[i + 1])) {\n#define   UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n      c = (UNHEX(s[i]) << 4) | UNHEX(s[i + 1]);\n#undef    UNHEX\n      i += 2;\n    }\n\n    if (d)\n      d[j] = c;\n    j++;\n  }\n\n  return j;\n}\n\n/**Unescape url-escaped string.\n *\n * Unescape string @a s to the buffer @a d, including the terminating \\\\0\n * character. All %-escaped triplets in @a s are unescaped, for instance, @c\n * \"%40%25%23\" is copied as @c \"@%#\". The destination array @a d must be\n * large enough to receive the escaped copy.\n *\n * @param d  destination buffer\n * @param s  string to be copied\n *\n * @return Pointer to the destination buffer.\n */\nchar *url_unescape(char *d, char const *s)\n{\n  size_t n = url_unescape_to(d, s, SIZE_MAX);\n  if (d)\n    d[n] = '\\0';\n  return d;\n}\n\n/** Canonize a URL component */\nstatic\nchar *url_canonize(char *d, char const *s, size_t n,\n\t\t   unsigned syn33,\n\t\t   char const allowed[])\n{\n  unsigned mask32 = 0xbe19003f, mask64 = 0x8000001e, mask96 = 0x8000001d;\n\n  MASKS_WITH_ALLOWED(allowed, mask32, mask64, mask96);\n\n  return url_canonize2(d, s, n, syn33, mask32, mask64, mask96);\n}\n\n#define SYN33(c) (1U << (c - 33))\n#define IS_SYN33(syn33, c) ((syn33 & (1U << (c - 33))) != 0)\n\n/** Canonize a URL component (with precomputed mask) */\nstatic\nchar *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n\n    h1 = s[i + 1], h2 = s[i + 2];\n\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      /* Convert hex to normal character */\n      *d = c, i += 2;\n      continue;\n    }\n\n    /* Convert hex to uppercase */\n    if (h1 >= 'a' /* && h1 <= 'f' */)\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' /* && h2 <= 'f' */)\n      h2 = h2 - 'a' + 'A';\n\n    d[0] = '%', d[1] = h1, d[2] = h2;\n\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n\n  *d = '\\0';\n\n  return d;\n}\n\n\n/** Canonize a URL component (with precomputed mask).\n *\n * This version does not flag error if *s contains character that should\n * be escaped.\n */\nstatic\nchar *url_canonize3(char *d, char const * const s, size_t n,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n\n    if (c != '%') {\n      *d = c;\n      continue;\n    }\n\n    h1 = s[i + 1], h2 = s[i + 2];\n\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      *d = c, i += 2;\n      continue;\n    }\n\n    /* Convert hex to uppercase */\n    if (h1 >= 'a' /* && h1 <= 'f' */)\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' /* && h2 <= 'f' */)\n      h2 = h2 - 'a' + 'A';\n\n    d[0] = '%', d[1] = h1, d[2] = h2;\n\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n\n  *d = '\\0';\n\n  return d;\n}\n\n\n/** Get URL scheme. */\nchar const* url_scheme(enum url_type_e url_type)\n{\n  switch (url_type) {\n  case url_any:    return \"*\";\n  case url_sip:    return \"sip\";\n  case url_sips:   return \"sips\";\n  case url_tel:    return \"tel\";\n  case url_fax:    return \"fax\";\n  case url_modem:  return \"modem\";\n  case url_http:   return \"http\";\n  case url_https:  return \"https\";\n  case url_ftp:    return \"ftp\";\n  case url_file:   return \"file\";\n  case url_rtsp:   return \"rtsp\";\n  case url_rtspu:  return \"rtspu\";\n  case url_mailto: return \"mailto\";\n  case url_im:     return \"im\";\n  case url_pres:   return \"pres\";\n  case url_cid:    return \"cid\";\n  case url_msrp:   return \"msrp\";\n  case url_msrps:  return \"msrps\";\n  case url_wv:     return \"wv\";\n  default:\n    assert(url_type == url_unknown);\n    return NULL;\n  }\n}\n\nsu_inline\nint url_type_is_opaque(enum url_type_e url_type)\n{\n  return\n    url_type == url_invalid ||\n    url_type == url_tel ||\n    url_type == url_modem ||\n    url_type == url_fax ||\n    url_type == url_cid;\n}\n\n/** Init an url as given type */\nvoid url_init(url_t *url, enum url_type_e type)\n{\n  memset(url, 0, sizeof(*url));\n  url->url_type = type;\n  if (type > url_unknown) {\n    char const *scheme = url_scheme((enum url_type_e)url->url_type);\n    if (scheme)\n      url->url_scheme = scheme;\n  }\n}\n\n/** Get url type */\nsu_inline\nenum url_type_e url_get_type(char const *scheme, size_t len)\n{\n#define test_scheme(s) \\\n   if (len == strlen(#s) && !strncasecmp(scheme, #s, len)) return url_##s\n\n  switch (scheme[0]) {\n  case '*': if (strcmp(scheme, \"*\") == 0) return url_any;\n  case 'c': case 'C':\n    test_scheme(cid); break;\n  case 'f': case 'F':\n    test_scheme(ftp); test_scheme(file); test_scheme(fax); break;\n  case 'h': case 'H':\n    test_scheme(http); test_scheme(https); break;\n  case 'i': case 'I':\n    test_scheme(im); break;\n  case 'm': case 'M':\n    test_scheme(mailto); test_scheme(modem);\n    test_scheme(msrp); test_scheme(msrps); break;\n  case 'p': case 'P':\n    test_scheme(pres); break;\n  case 'r': case 'R':\n    test_scheme(rtsp); test_scheme(rtspu); break;\n  case 's': case 'S':\n    test_scheme(sip); test_scheme(sips); break;\n  case 't': case 'T':\n    test_scheme(tel); break;\n  case 'w': case 'W':\n    test_scheme(wv); break;\n\n\n  default: break;\n  }\n\n#undef test_scheme\n\n  if (len != span_unreserved(scheme))\n    return url_invalid;\n  else\n    return url_unknown;\n}\n\n/**\n * Decode a URL.\n *\n * This function decodes a (SIP) URL string to a url_t structure.\n *\n * @param url structure to store the parsing result\n * @param s   NUL-terminated string to be parsed\n *\n * @note The parsed string @a s will be modified when parsing it.\n *\n * @retval 0 if successful,\n * @retval -1 otherwise.\n */\nstatic\nint _url_d(url_t *url, char *s)\n{\n  size_t n, p;\n  char rest_c, *host, *user;\n  int have_authority = 1;\n\n  memset(url, 0, sizeof(*url));\n\n  if (strcmp(s, \"*\") == 0) {\n    url->url_type = url_any;\n    url->url_scheme = \"*\";\n    return 0;\n  }\n\n  n = strcspn(s, \":/?#\");\n\n  if (n && s[n] == ':') {\n    char *scheme;\n    url->url_scheme = scheme = s; s[n] = '\\0'; s = s + n + 1;\n\n    if (!(scheme = url_canonize(scheme, scheme, SIZE_MAX, 0, \"+\")))\n      return -1;\n\n    n = scheme - url->url_scheme;\n\n    url->url_type = url_get_type(url->url_scheme, n);\n\n    have_authority = !url_type_is_opaque((enum url_type_e)url->url_type);\n  }\n  else {\n    url->url_type = url_unknown;\n  }\n\n  user = NULL, host = s;\n\n  if (url->url_type == url_sip || url->url_type == url_sips) {\n    /* SIP URL may have /;? in user part but no path */\n    /* user-unreserved  =  \"&\" / \"=\" / \"+\" / \"$\" / \",\" / \";\" / \"?\" / \"/\" */\n    /* Some #*@#* phones include unescaped # there, too */\n    n = strcspn(s, \"@/;?#\");\n    p = strcspn(s + n, \"@\");\n    if (s[n + p] == '@') {\n      n += p;\n      user = s;\n      host = s + n + 1;\n    }\n\n    n += strcspn(s + n, \"/;?#\");\n  }\n  else if (have_authority) {\n    if (url->url_type == url_wv) {\n      /* WV URL may have / in user part */\n      n = strcspn(s, \"@#?;\");\n      if (s[n] == '@') {\n\tuser = s;\n\thost = s + n + 1;\n\tn += strcspn(s + n, \";?#\");\n      }\n    }\n    else if (host[0] == '/' && host[1] != '/') {\n      /* foo:/bar or /bar - no authority, just path */\n      url->url_root = '/';\t/* Absolute path */\n      host = NULL, n = 0;\n    }\n    else {\n      if (host[0] == '/' && host[1] == '/') {\n\t/* We have authority, / / foo or foo */\n\thost += 2; s += 2, url->url_root = '/';\n\tn = strcspn(s, \"/?#@[]\");\n      }\n      else\n\tn = strcspn(s, \"@;/?#\");\n\n      if (s[n] == '@')\n\tuser = host, host = user + n + 1;\n\n      n += strcspn(s + n, \";/?#\");\t/* Find path, query and/or fragment */\n    }\n  }\n  else /* !have_authority */ {\n    user = host, host = NULL;\n    if (url->url_type != url_invalid)\n      n = strcspn(s, \"/;?#\");\t/* Find params, query and/or fragment */\n    else\n      n = strcspn(s, \"#\");\n  }\n\n  rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;\n\n  if (user) {\n    if (host) host[-1] = '\\0';\n    url->url_user = user;\n    if (url->url_type != url_unknown) {\n      n = strcspn(user, \":\");\n      if (user[n]) {\n\tuser[n] = '\\0';\n\turl->url_password = user + n + 1;\n      }\n    }\n  }\n\n  if (host) {\n    url->url_host = host;\n    /* IPv6 (and in some cases, IPv4) addresses are quoted with [] */\n    if (host[0] == '[') {\n      n = strcspn(host, \"]\");\n      if (host[n] && (host[n + 1] == '\\0' || host[n + 1] == ':'))\n\tn++;\n      else\n\tn = 0;\n    }\n    else {\n      n = strcspn(host, \":\");\n    }\n\n    /* We allow empty host by default */\n    if (n == 0) switch (url->url_type) {\n    case url_sip:\n    case url_sips:\n    case url_im:\n    case url_pres:\n      return -1;\n    default:\n      break;\n    }\n\n    if (host[n] == ':') {\n      char *port = host + n + 1;\n      url->url_port = port;\n      switch (url->url_type) {\n      case url_any:\n      case url_sip:\n      case url_sips:\n      case url_http:\n      case url_https:\n      case url_ftp:\n      case url_file:\n      case url_rtsp:\n      case url_rtspu:\n\tif (!url_canonize2(port, port, SIZE_MAX, 0, RESERVED_MASK))\n\t  return -1;\n\n\t/* Check that port is really numeric or wildcard */\n\t/* Port can be *digit, empty string or \"*\" */\n\twhile (*port >= '0' && *port <= '9')\n\t  port++;\n\n\tif (port != url->url_port) {\n\t  if (port[0] != '\\0')\n\t    return -1;\n\t}\n\telse if (port[0] == '\\0')\n\t  /* empty string */;\n\telse if (port[0] == '*' && port[1] == '\\0')\n\t  /* wildcard */;\n\telse\n\t  return -1;\n      }\n      host[n] = 0;\n    }\n  }\n\n  if (rest_c == '/') {\n    url->url_path = s; n = strcspn(s, \"?#\");\n    rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;\n  }\n  if (rest_c == ';') {\n    url->url_params = s; n = strcspn(s, \"?#\");\n    rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;\n  }\n  if (rest_c == '?') {\n    url->url_headers = s; n = strcspn(s, \"#\");\n    rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;\n  }\n  if (rest_c == '#') {\n    url->url_fragment = s;\n    rest_c = '\\0';\n  }\n  if (rest_c)\n    return -1;\n\n  return 0;\n}\n\n/* Unreserved things */\n\n/**\n * Decode a URL.\n *\n * This function decodes a URL string to a url_t structure.\n *\n * @param url structure to store the parsing result\n * @param s   NUL-terminated string to be parsed\n *\n * @note The parsed string @a s will be modified when parsing it.\n *\n * @retval 0 if successful,\n * @retval -1 otherwise.\n */\nint url_d(url_t *url, char *s)\n{\n  if (url == NULL || _url_d(url, s) < 0)\n    return -1;\n\n  /* Canonize  URL */\n  /* scheme is canonized by _url_d() */\n  if (url->url_type == url_sip || url->url_type == url_sips) {\n\n#   define SIP_USER_UNRESERVED \"&=+$,;?/\"\n    s = (char *)url->url_user;\n    if (s && !url_canonize(s, s, SIZE_MAX, 0, SIP_USER_UNRESERVED))\n      return -1;\n\n    /* Having different charset in user and password does not make sense */\n    /* but that is how it is defined in RFC 3261 */\n#   define SIP_PASS_UNRESERVED \"&=+$,\"\n    s = (char *)url->url_password;\n    if (s && !url_canonize(s, s, SIZE_MAX, 0, SIP_PASS_UNRESERVED))\n      return -1;\n\n  }\n  else {\n\n#   define USER_UNRESERVED \"&=+$,;\"\n    s = (char *)url->url_user;\n    if (s && !url_canonize(s, s, SIZE_MAX, 0, USER_UNRESERVED))\n      return -1;\n\n#   define PASS_UNRESERVED \"&=+$,;:\"\n    s = (char *)url->url_password;\n    if (s && !url_canonize(s, s, SIZE_MAX, 0, PASS_UNRESERVED))\n      return -1;\n  }\n\n  s = (char *)url->url_host;\n  if (s && !url_canonize2(s, s, SIZE_MAX, 0, RESERVED_MASK))\n    return -1;\n\n  /* port is canonized by _url_d() */\n  s = (char *)url->url_path;\n  if (s && !url_canonize(s, s, SIZE_MAX,\n\t\t\t /* Allow all URI characters but ? */\n\t\t\t /* Allow unescaped /;?@, - but do not convert */\n\t\t\t SYN33('/') | SYN33(';') | SYN33('=') | SYN33('@') |\n\t\t\t SYN33(','),\n\t\t\t /* Convert escaped :&+$ to unescaped */\n\t\t\t \":&+$\"))\n    return -1;\n\n  s = (char *)url->url_params;\n  if (s && !url_canonize(s, s, SIZE_MAX,\n\t\t\t /* Allow all URI characters but ? */\n\t\t\t /* Allow unescaped ;=@, - but do not convert */\n\t\t\t SYN33(';') | SYN33('=') | SYN33('@') | SYN33(','),\n\t\t\t /* Convert escaped /:&+$ to unescaped */\n\t\t\t \"/:&+$\"))\n    return -1;\n\n  /* Unhex alphanumeric and unreserved URI characters */\n  s = (char *)url->url_headers;\n  if (s && !url_canonize3(s, s, SIZE_MAX, RESERVED_MASK))\n    return -1;\n\n  /* Allow all URI characters (including reserved ones) */\n  s = (char *)url->url_fragment;\n  if (s && !url_canonize2(s, s, SIZE_MAX, 0, URIC_MASK))\n    return -1;\n\n  return 0;\n}\n\n/** Encode an URL.\n *\n * The function url_e() combines a URL from substrings in url_t structure\n * according the @ref url_syntax \"URL syntax\" presented above.  The encoded\n * @a url is stored in a @a buffer of @a n bytes.\n *\n * @param buffer memory area to store the encoded @a url.\n * @param n      size of @a buffer.\n * @param url    URL to be encoded.\n *\n * @return\n * Return the number of bytes in the encoding.\n *\n * @note The function follows the convention set by C99 snprintf().  Even if\n * the result does not fit into the @a buffer and it is truncated, the\n * function returns the number of bytes in an untruncated encoding.\n */\nissize_t url_e(char buffer[], isize_t n, url_t const *url)\n{\n  size_t i;\n  char *b = buffer;\n  size_t m = n;\n  int do_copy = n > 0;\n\n  if (url == NULL)\n    return -1;\n\n  if (URL_STRING_P(url)) {\n    char const *u = (char *)url;\n    i = strlen(u);\n    if (!buffer)\n      return i;\n\n    if (i >= n) {\n      memcpy(buffer, u, n - 2);\n      buffer[n - 1] = '\\0';\n    } else {\n      memcpy(buffer, u, i + 1);\n    }\n\n    return i;\n  }\n\n\n  if (url->url_type == url_any) {\n    if (b && m > 0) {\n      if (m > 1) strcpy(b, \"*\"); else b[0] = '\\0';\n    }\n    return 1;\n  }\n\n  if (url->url_scheme && url->url_scheme[0]) {\n    i = strlen(url->url_scheme) + 1;\n    if (do_copy && (do_copy = i <= n)) {\n      memcpy(b, url->url_scheme, i - 1);\n      b[i - 1] = ':';\n    }\n    b += i; n -= i;\n  }\n\n  if (url->url_root && (url->url_host || url->url_user)) {\n    if (do_copy && (do_copy = 2 <= n))\n      memcpy(b, \"//\", 2);\n    b += 2; n -= 2;\n  }\n\n  if (url->url_user) {\n    i = strlen(url->url_user);\n    if (do_copy && (do_copy = i <= n))\n      memcpy(b, url->url_user, i);\n    b += i; n -= i;\n\n    if (url->url_password) {\n      if (do_copy && (do_copy = 1 <= n))\n\t*b = ':';\n      b++; n--;\n      i = strlen(url->url_password);\n      if (do_copy && (do_copy = i <= n))\n\tmemcpy(b, url->url_password, i);\n      b += i; n -= i;\n    }\n\n    if (url->url_host) {\n      if (do_copy && (do_copy = 1 <= n))\n\t*b = '@';\n      b++; n--;\n    }\n  }\n\n  if (url->url_host) {\n    i = strlen(url->url_host);\n    if (do_copy && (do_copy = i <= n))\n      memcpy(b, url->url_host, i);\n    b += i; n -= i;\n\n    if (url->url_port) {\n      i = strlen(url->url_port) + 1;\n      if (do_copy && (do_copy = i <= n)) {\n\tb[0] = ':';\n\tmemcpy(b + 1, url->url_port, i - 1);\n      }\n      b += i; n -= i;\n    }\n  }\n\n  if (url->url_path) {\n    if (url->url_root) {\n      if (do_copy && (do_copy = 1 <= n))\n\tb[0] = '/';\n      b++, n--;\n    }\n    i = strlen(url->url_path);\n    if (do_copy && (do_copy = i < n))\n      memcpy(b, url->url_path, i);\n    b += i; n -= i;\n  }\n\n  {\n    static char const sep[] = \";?#\";\n    char const *pp[3];\n    size_t j;\n\n    pp[0] = url->url_params;\n    pp[1] = url->url_headers;\n    pp[2] = url->url_fragment;\n\n    for (j = 0; j < 3; j++) {\n      char const *p = pp[j];\n      if (!p) continue;\n      i = strlen(p) + 1;\n      if (do_copy && (do_copy = i <= n)) {\n\t*b = sep[j];\n\tmemcpy(b + 1, p, i - 1);\n      }\n      b += i; n -= i;\n    }\n  }\n\n  if (do_copy && (do_copy = 1 <= n))\n    *b = '\\0';\n  else if (buffer && m > 0)\n    buffer[m - 1] = '\\0';\n\n  assert((size_t)(b - buffer) == (size_t)(m - n));\n\n  /* This follows the snprintf(C99) return value,\n   * Number of characters written (excluding NUL)\n   */\n  return b - buffer;\n}\n\n\n/** Calculate the length of URL when encoded.\n *\n */\nisize_t url_len(url_t const * url)\n{\n  size_t rv = 0;\n\n  if (url->url_scheme) rv += strlen(url->url_scheme) + 1; /* plus ':' */\n  if (url->url_user) {\n    rv += strlen(url->url_user);\n    if (url->url_password)\n      rv += strlen(url->url_password) + 1;   /* plus ':' */\n    rv += url->url_host != NULL;  /* plus '@' */\n  }\n  if (url->url_host) rv += strlen(url->url_host);\n  if (url->url_port) rv += strlen(url->url_port) + 1;\t        /* plus ':' */\n  if (url->url_path) rv += strlen(url->url_path) + 1;     /* plus initial / */\n  if (url->url_params) rv += strlen(url->url_params) + 1; /* plus initial ; */\n  if (url->url_headers) rv += strlen(url->url_headers) + 1;\t/* plus '?' */\n  if (url->url_fragment) rv += strlen(url->url_fragment) + 1;   /* plus '#' */\n\n  return rv;\n}\n\n/**@def URL_E(buf, end, url)\n * Encode an URL: use @a buf up to @a end.\n * @hideinitializer\n */\n\n/**\n * Calculate the size of strings associated with a #url_t sructure.\n *\n * @param url pointer to a #url_t structure or string\n * @return Number of bytes for URL\n */\nisize_t url_xtra(url_t const *url)\n{\n  size_t xtra;\n\n  if (URL_STRING_P(url)) {\n    xtra = strlen((char const *)url) + 1;\n  }\n  else {\n    size_t len_scheme, len_user, len_password,\n      len_host, len_port, len_path, len_params,\n      len_headers, len_fragment;\n\n    len_scheme = (url->url_type <= url_unknown && url->url_scheme) ?\n      strlen(url->url_scheme) + 1 : 0;\n    len_user = url->url_user ? strlen(url->url_user) + 1 : 0;\n    len_password = url->url_password ? strlen(url->url_password) + 1 : 0;\n    len_host = url->url_host ? strlen(url->url_host) + 1 : 0;\n    len_port = url->url_port ? strlen(url->url_port) + 1 : 0;\n    len_path = url->url_path ? strlen(url->url_path) + 1 : 0;\n    len_params = url->url_params ? strlen(url->url_params) + 1 : 0;\n    len_headers = url->url_headers ? strlen(url->url_headers) + 1 : 0;\n    len_fragment = url->url_fragment ? strlen(url->url_fragment) + 1 : 0;\n\n    xtra =\n      len_scheme + len_user + len_password + len_host + len_port +\n      len_path + len_params + len_headers + len_fragment;\n  }\n\n  return xtra;\n}\n\nsu_inline\nchar *copy(char *buf, char *end, char const *src)\n{\n#if HAVE_MEMCCPY\n  char *b = memccpy(buf, src, '\\0', end - buf);\n  if (b)\n    return b;\n  else\n    return end + strlen(src + (end - buf)) + 1;\n#else\n  for (; buf < end && (*buf = *src); buf++, src++)\n    ;\n\n  if (buf >= end)\n    while (*src++)\n      buf++;\n\n  return buf + 1;\n#endif\n}\n\n/**\n * Duplicate the url.\n *\n * The function url_dup() copies the url structure @a src and the strings\n * attached to it to @a url.  The non-constant strings in @a src are copied\n * to @a buf.  If the size of duplicated strings exceed @a bufsize, the\n * corresponding string fields in @a url are set to NULL.\n *\n * The calling function can calculate the size of buffer required by calling\n * url_dup() with zero as @a bufsize and NULL as @a dst.\n\n * @param buf     Buffer for non-constant strings copied from @a src.\n * @param bufsize Size of @a buf.\n * @param dst     Destination URL structure.\n *\ufffd@param src     Source URL structure.\n *\n * @return Number of characters required for\n * duplicating the strings in @a str, or -1 if an error\n * occurred.\n */\nissize_t url_dup(char *buf, isize_t bufsize, url_t *dst, url_t const *src)\n{\n  if (!src && !dst)\n    return -1;\n  else if (URL_STRING_P(src)) {\n    size_t n = strlen((char *)src) + 1;\n    if (n > bufsize || dst == NULL)\n      return n;\n\n    strcpy(buf, (char *)src);\n    memset(dst, 0, sizeof(*dst));\n    if (url_d(dst, buf) < 0)\n      return -1;\n\n    return n;\n  }\n  else {\n    char *b = buf;\n    char *end = b + bufsize;\n    char const **dstp;\n    char const * const *srcp;\n    url_t dst0[1];\n\n    if (dst == NULL)\n      dst = dst0;\n\n    memset(dst, 0, sizeof(*dst));\n\n    if (!src)\n      return 0;\n\n    memset(dst->url_pad, 0, sizeof dst->url_pad);\n    dst->url_type = src->url_type;\n    dst->url_root = src->url_root;\n\n    dstp = &dst->url_scheme;\n    srcp = &src->url_scheme;\n\n    if (dst->url_type > url_unknown)\n      *dstp = url_scheme((enum url_type_e)dst->url_type);\n\n    if (*dstp != NULL)\n      dstp++, srcp++;\t/* Skip scheme if it is constant */\n\n    if (dst != dst0 && buf != NULL && bufsize != 0)\n      for (; srcp <= &src->url_fragment; srcp++, dstp++)\n\tif (*srcp) {\n\t  char *next = copy(b, end, *srcp);\n\n\t  if (next > end)\n\t    break;\n\n\t  *dstp = b, b = next;\n\t}\n\n    for (; srcp <= &src->url_fragment; srcp++)\n      if (*srcp) {\n\tb += strlen(*srcp) + 1;\n      }\n\n    return b - buf;\n  }\n}\n\n/**@def URL_DUP(buf, end, dst, src)\n *  Duplicate the url: use @a buf up to @a end. @HI\n *\n * The macro URL_DUP() duplicates the url.  The non-constant strings in @a\n * src are copied to @a buf.  However, no strings are copied past @a end.\n * In other words, the size of buffer is @a end - @a buf.\n *\n * The macro updates the buffer pointer @a buf, so that it points to the\n * first unused byte in the buffer.  The buffer pointer @a buf is updated,\n * even if the buffer is too small for the duplicated strings.\n *\n * @param buf     Buffer for non-constant strings copied from @a src.\n * @param end     End of @a buf.\n * @param dst     Destination URL structure.\n *\ufffd@param src     Source URL structure.\n *\n * @return\n * The macro URL_DUP() returns pointer to first unused byte in the\n * buffer @a buf.\n */\n\n/** Duplicate the url to memory allocated via home.\n *\n * The function url_hdup() duplicates (deep copies) an #url_t structure.\n * Alternatively, it can be passed a string; string is then copied and\n * parsed to the #url_t structure.\n *\n * The function url_hdup() allocates the destination structure from @a home\n * as a single memory block. It is possible to free the copied url structure\n * and all the associated strings using a single call to su_free().\n *\n * @param home memory home used to allocate new url object\n * @param src  pointer to URL (or string)\n *\n * @return\n * The function url_hdup() returns a pointer to the newly allocated #url_t\n * structure, or NULL upon an error.\n */\nurl_t *url_hdup(su_home_t *home, url_t const *src)\n{\n  if (src) {\n    size_t len = sizeof(*src) + url_xtra(src);\n    url_t *dst = su_alloc(home, len);\n    if (dst) {\n      ssize_t actual;\n      actual = url_dup((char *)(dst + 1), len - sizeof(*src), dst, src);\n      if (actual < 0)\n\tsu_free(home, dst), dst = NULL;\n      else\n\tassert(len == sizeof(*src) + actual);\n    }\n    return dst;\n  }\n  else\n    return NULL;\n}\n\n\n/** Convert an string to an url */\nurl_t *url_make(su_home_t *h, char const *str)\n{\n  return url_hdup(h, URL_STRING_MAKE(str)->us_url);\n}\n\n/** Print an URL */\nurl_t *url_format(su_home_t *h, char const *fmt, ...)\n{\n  url_t *url;\n  char *us;\n  va_list ap;\n\n  va_start(ap, fmt);\n\n  us = su_vsprintf(h, fmt, ap);\n\n  va_end(ap);\n\n  if (us == NULL)\n    return NULL;\n\n  url = url_hdup(h, URL_STRING_MAKE(us)->us_url);\n\n  su_free(h, us);\n\n  return url;\n}\n\n\n/** Convert @a url to a string allocated from @a home.\n *\n * @param home memory home to allocate the new string\n * @param url  url to convert to string\n *\n * The @a url can be a string, too.\n *\n * @return Newly allocated conversion result, or NULL upon an error.\n */\nchar *url_as_string(su_home_t *home, url_t const *url)\n{\n  if (url) {\n    int len = url_e(NULL, 0, url);\n    char *b = su_alloc(home, len + 1);\n    url_e(b, len + 1, url);\n    return b;\n  } else {\n    return NULL;\n  }\n}\n\n\n/** Test if param @a tag matches to parameter string @a p.\n */\n#define URL_PARAM_MATCH(p, tag) \\\n (strncasecmp(p, tag, strlen(tag)) == 0 && \\\n  (p[strlen(tag)] == '\\0' || p[strlen(tag)] == ';' || p[strlen(tag)] == '='))\n\n/**\n * Search for a parameter.\n *\n * This function searches for a parameter from a parameter list.\n *\n * If you want to test if there is parameter @b user=phone,\n * call this function like\n * @code if (url_param(url->url_param, \"user=phone\", NULL, 0))\n * @endcode\n *\n * @param params URL parameter string (excluding first semicolon)\n * @param tag    parameter name\n * @param value  string to which the parameter value is copied\n * @param vlen   length of string reserved for value\n *\n * @retval positive length of parameter value (including final NUL) if found\n * @retval zero     if not found.\n */\nisize_t url_param(char const *params,\n\t\t  char const *tag,\n\t\t  char value[], isize_t vlen)\n{\n  size_t n, tlen, flen;\n  char *p;\n\n  if (!params)\n    return 0;\n\n  tlen = strlen(tag);\n  if (tlen && tag[tlen - 1] == '=')\n    tlen--;\n\n  for (p = (char *)params; *p; p += n + 1) {\n    n = strcspn(p, \";\");\n    if (n < tlen) {\n      if (p[n]) continue; else break;\n    }\n    if (strncasecmp(p, tag, tlen) == 0) {\n      if (n == tlen) {\n\tif (vlen > 0)\n\t  value[0] = '\\0';\n\treturn 1;\n      }\n      if (p[tlen] != '=')\n\tcontinue;\n      flen = n - tlen - 1;\n      if (flen >= (size_t)vlen)\n\treturn flen + 1;\n      memcpy(value, p + tlen + 1, flen);\n      value[flen] = '\\0';\n      return flen + 1;\n    }\n    if (!p[n])\n      break;\n  }\n\n  return 0;\n}\n\n/** Check for a parameter.\n *\n * @deprecated\n * Bad grammar. Use url_has_param().\n */\nisize_t url_have_param(char const *params, char const *tag)\n{\n  return url_param(params, tag, NULL, 0);\n}\n\n/** Check for a parameter. */\nint url_has_param(url_t const *url, char const *tag)\n{\n  return url && url->url_params && url_param(url->url_params, tag, NULL, 0);\n}\n\n/** Add an parameter. */\nint url_param_add(su_home_t *h, url_t *url, char const *param)\n{\n  /* XXX - should remove existing parameters with same name? */\n  size_t n = url->url_params ? strlen(url->url_params) + 1: 0;\n  size_t nn = strlen(param) + 1;\n  char *s = su_alloc(h, n + nn);\n\n  if (!s)\n    return -1;\n\n  if (url->url_params)\n    strcpy(s, url->url_params)[n - 1] = ';';\n  strcpy(s + n, param);\n  url->url_params = s;\n\n  return 0;\n}\n\n/** Remove a named parameter from url_param string.\n *\n * Remove a named parameter and its possible value from the URL parameter\n * string (url_s##url_param).\n *\n * @return Pointer to modified string, or NULL if nothing is left in there.\n */\nchar *url_strip_param_string(char *params, char const *name)\n{\n  if (params && name) {\n    size_t i, n = strlen(name), remove, rest;\n\n    for (i = 0; params[i];) {\n      if (strncasecmp(params + i, name, n) ||\n\t  (params[i + n] != '=' && params[i + n] != ';' && params[i + n])) {\n\ti = i + strcspn(params + i, \";\");\n\tif (!params[i++])\n\t  break;\n\tcontinue;\n      }\n      remove = n + strcspn(params + i + n, \";\");\n      if (params[i + remove] == ';')\n\tremove++;\n\n      if (i == 0) {\n\tparams += remove;\n\tcontinue;\n      }\n\n      rest = strlen(params + i + remove);\n      if (!rest) {\n\tif (i == 0)\n\t  return NULL;\t\t/* removed everything */\n\tparams[i - 1] = '\\0';\n\tbreak;\n      }\n      memmove(params + i, params + i + remove, rest + 1);\n    }\n\n    if (!params[0])\n      return NULL;\n  }\n\n  return params;\n}\n\nint url_string_p(url_string_t const *url)\n{\n  return URL_STRING_P(url);\n}\n\nint url_is_string(url_string_t const *url)\n{\n  return URL_IS_STRING(url);\n}\n\n/** Strip transport-specific stuff. */\nstatic\nint url_strip_transport2(url_t *url, int modify)\n{\n  char *p, *d;\n  size_t n;\n  int semi;\n\n  if (url->url_type != url_sip && url->url_type != url_sips)\n    return 0;\n\n  if (url->url_port != NULL) {\n    if (!modify)\n      return 1;\n    url->url_port = NULL;\n  }\n\n  if (!url->url_params)\n    return 0;\n\n  for (d = p = (char *)url->url_params; *p; p += n + semi) {\n    n = strcspn(p, \";\");\n    semi = (p[n] != '\\0');\n\n    if (modify && n == 0)\n      continue;\n    if (URL_PARAM_MATCH(p, \"method\"))\n      continue;\n    if (URL_PARAM_MATCH(p, \"maddr\"))\n      continue;\n    if (URL_PARAM_MATCH(p, \"ttl\"))\n      continue;\n    if (URL_PARAM_MATCH(p, \"transport\"))\n      continue;\n\n    if (p != d) {\n      if (d != url->url_params)\n\td++;\n      if (p != d) {\n\tif (!modify)\n\t  return 1;\n\tmemmove(d, p, n + 1);\n      }\n    }\n    d += n;\n  }\n\n  if (d == p)\n    return 0;\n  else if (d + 1 == p)\t\t/* empty param */\n    return 0;\n  else if (!modify)\n    return 1;\n\n  if (d != url->url_params)\n    *d = '\\0';\n  else\n    url->url_params = NULL;\n\n  return 1;\n}\n\n/** Strip transport-specific stuff.\n *\n * The function url_strip_transport() removes transport-specific parameters\n * from a SIP or SIPS URI.  These parameters include:\n * - the port number\n * - \"maddr=\" parameter\n * - \"transport=\" parameter\n * - \"ttl=\" parameter\n * - \"method=\" parameter\n *\n * @note\n * The @a url must be a pointer to a URL structure. It is stripped in-place.\n *\n * @note\n * If the parameter string contains empty parameters, they are stripped, too.\n *\n * @return\n * The function url_strip_transport() returns @e true, if the URL was\n * modified, @e false otherwise.\n */\nint url_strip_transport(url_t *url)\n{\n  return url_strip_transport2(url, 1);\n}\n\n/** Check for transport-specific stuff.\n *\n * The function url_have_transport() tests if there are transport-specific\n * parameters in a SIP or SIPS URI. These parameters include:\n * - the port number\n * - \"maddr=\" parameters\n * - \"transport=\" parameters\n *\n * @note\n * The @a url must be a pointer to a URL structure.\n *\n * @return The function url_have_transport() returns @e true, if the URL\n * contains transport parameters, @e false otherwise.\n */\nint url_have_transport(url_t const *url)\n{\n  return url_strip_transport2((url_t *)url, 0);\n}\n\n/**Lazily compare two URLs.\n *\n * Compare essential parts of URLs: schema, host, port, and username.\n *\n * any_url compares 0 with any other URL.\n *\n * pres: and im: URIs compares 0 with SIP URIs.\n *\n * @note\n * The @a a and @a b must be pointers to URL structures.\n *\n * @note Currently, the url parameters are not compared. This is because the\n * url_cmp() is used to sort URLs: taking parameters into account makes that\n * impossible.\n */\nint url_cmp(url_t const *a, url_t const *b)\n{\n  int rv;\n  int url_type;\n\n  if ((a && a->url_type == url_any) || (b && b->url_type == url_any))\n    return 0;\n\n  if (!a || !b)\n    return (a != NULL) - (b != NULL);\n\n  if ((rv = a->url_type - b->url_type)) {\n#if 0\n    /* presence and instant messaging URLs match magically with SIP */\n    enum url_type_e a_type = a->url_type;\n    enum url_type_e b_type = b->url_type;\n\n    if (a_type == url_im || a_type == url_pres)\n      a_type = url_sip;\n\n    if (b_type == url_im || b_type == url_pres)\n      b_type = url_sip;\n\n    if (a_type != b_type)\n#endif\n      return rv;\n  }\n\n  url_type = a->url_type;\t/* Or b->url_type, they are equal! */\n\n  if (url_type <= url_unknown &&\n      ((rv = !a->url_scheme - !b->url_scheme) ||\n       (a->url_scheme && b->url_scheme &&\n\t(rv = strcasecmp(a->url_scheme, b->url_scheme)))))\n    return rv;\n\n  if ((rv = host_cmp(a->url_host, b->url_host)))\n    return rv;\n\n  if (a->url_port != b->url_port) {\n    char const *a_port;\n    char const *b_port;\n\n    if (url_type != url_sip && url_type != url_sips)\n      a_port = b_port = url_port_default((enum url_type_e)url_type);\n    else if (host_is_ip_address(a->url_host))\n      a_port = b_port = url_port_default((enum url_type_e)url_type);\n    else\n      a_port = b_port = \"\";\n\n    if (a->url_port) a_port = a->url_port;\n    if (b->url_port) b_port = b->url_port;\n\n    if ((rv = strcmp(a_port, b_port)))\n      return rv;\n  }\n\n  if (a->url_user != b->url_user) {\n    if (a->url_user == NULL) return -1;\n    if (b->url_user == NULL) return +1;\n    switch (url_type) {\n    case url_tel: case url_modem: case url_fax:\n      rv = url_tel_cmp_numbers(a->url_user, b->url_user);\n      break;\n    default:\n      rv = strcmp(a->url_user, b->url_user);\n      break;\n    }\n    if (rv)\n      return rv;\n  }\n\n#if 0\n  if (a->url_path != b->url_path) {\n    if (a->url_path == NULL) return -1;\n    if (b->url_path == NULL) return +1;\n    if ((rv = strcmp(a->url_path, b->url_path)))\n      return rv;\n  }\n#endif\n\n  return 0;\n}\n\nstatic\nint url_tel_cmp_numbers(char const *A, char const *B)\n{\n  short a, b;\n  int rv;\n\n  while (*A && *B) {\n    #define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    /* Skip visual-separators */\n    do {\n      a = *A++;\n      if (a == '%' && IS_HEX(A[0]) && IS_HEX(A[1]))\n\ta = (UNHEX(A[0]) << 4) | UNHEX(A[1]), A +=2;\n    } while (a == ' ' || a == '-' || a == '.' || a == '(' || a == ')');\n\n    if (isupper(a))\n      a = tolower(a);\n\n    do {\n      b = *B++;\n      if (b == '%' && IS_HEX(B[0]) && IS_HEX(B[1]))\n\tb = (UNHEX(B[0]) << 4) | UNHEX(B[1]), B +=2;\n    } while (b == ' ' || b == '-' || b == '.' || b == '(' || b == ')');\n\n    if (isupper(b))\n      b = tolower(b);\n\n    if ((rv = a - b))\n      return rv;\n  }\n\n  return (int)*A - (int)*B;\n}\n\n/**Conservative comparison of urls.\n *\n * Compare all parts of URLs.\n *\n * @note\n * The @a a and @a b must be pointers to URL structures.\n *\n */\nint url_cmp_all(url_t const *a, url_t const *b)\n{\n  int rv, url_type;\n\n  if (!a || !b)\n    return (a != NULL) - (b != NULL);\n\n  if ((rv = a->url_type - b->url_type))\n    return rv;\n\n  url_type = a->url_type;\t/* Or b->url_type, they are equal! */\n\n  if (url_type <= url_unknown &&\n      ((rv = !a->url_scheme - !b->url_scheme) ||\n       (a->url_scheme && b->url_scheme &&\n\t(rv = strcasecmp(a->url_scheme, b->url_scheme)))))\n    return rv;\n\n  if ((rv = a->url_root - b->url_root))\n    return rv;\n\n  if ((rv = host_cmp(a->url_host, b->url_host)))\n    return rv;\n\n  if (a->url_port != b->url_port) {\n    char const *a_port;\n    char const *b_port;\n\n    if (url_type != url_sip && url_type != url_sips)\n      a_port = b_port = url_port_default((enum url_type_e)url_type);\n    else if (host_is_ip_address(a->url_host))\n      a_port = b_port = url_port_default((enum url_type_e)url_type);\n    else\n      a_port = b_port = \"\";\n\n    if (a->url_port) a_port = a->url_port;\n    if (b->url_port) b_port = b->url_port;\n\n    if ((rv = strcmp(a_port, b_port)))\n      return rv;\n  }\n\n  if (a->url_user != b->url_user) {\n    if (a->url_user == NULL) return -1;\n    if (b->url_user == NULL) return +1;\n\n    switch (url_type) {\n    case url_tel: case url_modem: case url_fax:\n      rv = url_tel_cmp_numbers(a->url_user, b->url_user);\n      break;\n    default:\n      rv = strcmp(a->url_user, b->url_user);\n      break;\n    }\n    if (rv)\n      return rv;\n  }\n\n  if (a->url_path != b->url_path) {\n    if (a->url_path == NULL) return -1;\n    if (b->url_path == NULL) return +1;\n    if ((rv = strcmp(a->url_path, b->url_path)))\n      return rv;\n  }\n\n  if (a->url_params != b->url_params) {\n    if (a->url_params == NULL) return -1;\n    if (b->url_params == NULL) return +1;\n    if ((rv = strcmp(a->url_params, b->url_params)))\n      return rv;\n  }\n\n  if (a->url_headers != b->url_headers) {\n    if (a->url_headers == NULL) return -1;\n    if (b->url_headers == NULL) return +1;\n    if ((rv = strcmp(a->url_headers, b->url_headers)))\n      return rv;\n  }\n\n  if (a->url_headers != b->url_headers) {\n    if (a->url_headers == NULL) return -1;\n    if (b->url_headers == NULL) return +1;\n    if ((rv = strcmp(a->url_headers, b->url_headers)))\n      return rv;\n  }\n\n  if (a->url_fragment != b->url_fragment) {\n    if (a->url_fragment == NULL) return -1;\n    if (b->url_fragment == NULL) return +1;\n    if ((rv = strcmp(a->url_fragment, b->url_fragment)))\n      return rv;\n  }\n\n  return 0;\n}\n\n/** Return default port number corresponding to the url type */\nchar const *url_port_default(enum url_type_e url_type)\n{\n  switch (url_type) {\n  case url_sip:\t\t\t/* \"sip:\" */\n    return \"5060\";\n  case url_sips:\t\t/* \"sips:\" */\n    return \"5061\";\n  case url_http:\t\t/* \"http:\" */\n    return \"80\";\n  case url_https:\t\t/* \"https:\" */\n    return \"443\";\n  case url_ftp:\t\t\t/* \"ftp:\" */\n  case url_file:\t\t/* \"file:\" */\n    return \"21\";\n  case url_rtsp:\t\t/* \"rtsp:\" */\n  case url_rtspu:\t\t/* \"rtspu:\" */\n    return \"554\";\n  case url_mailto:\t\t/* \"mailto:\" */\n    return \"25\";\n\n  case url_any:\t\t\t/* \"*\" */\n    return \"*\";\n\n  case url_msrp:\n  case url_msrps:\n    return \"9999\";\t\t/* XXXX */\n\n  case url_tel:\n  case url_fax:\n  case url_modem:\n  case url_im:\n  case url_pres:\n  case url_cid:\n  case url_wv:\n\n  default:\t\t\t/* Unknown scheme */\n    return \"\";\n  }\n}\n\n/** Return default transport name corresponding to the url type */\nchar const *url_tport_default(enum url_type_e url_type)\n{\n  switch (url_type) {\n  case url_sip:\n    return \"*\";\n  case url_sips:\n    return \"tls\";\n  case url_http:\n    return \"tcp\";\n  case url_https:\n    return \"tls\";\n  case url_ftp:\n  case url_file:\n    return \"tcp\";\n  case url_rtsp:\n    return \"tcp\";\n  case url_rtspu:\n    return \"udp\";\n  case url_mailto:\n    return \"tcp\";\n  case url_msrp:\n    return \"tcp\";\n  case url_msrps:\n    return \"tls\";\n\n  case url_any:\t\t\t/* \"*\" */\n  case url_tel:\n  case url_fax:\n  case url_modem:\n  case url_im:\n  case url_pres:\n  case url_cid:\n  case url_wv:\n\n  default:\t\t\t/* Unknown scheme */\n    return \"*\";\n  }\n}\n\n\n/** Return the URL port string */\nchar const *url_port(url_t const *u)\n{\n  if (!u)\n    return \"\";\n  else if (u->url_port && u->url_port[0])\n    return u->url_port;\n\n  if (u->url_type == url_sips || u->url_type == url_sip)\n    if (!host_is_ip_address(u->url_host))\n      return \"\";\n\n  return url_port_default((enum url_type_e)u->url_type);\n}\n\n/** Sanitize URL.\n *\n * The function url_sanitize() adds a scheme to an incomplete URL.  It\n * modifies its parameter structure @a url.  Currently, the function follows\n * simple heuristics:\n *\n * - URL with host name starting with @c ftp. is an FTP URL\n * - URL with host name starting with @c www. is an HTTP URL\n * - URL with host and path, e.g., @c host/foo;bar, is an HTTP URL\n * - URL with host name, no path is a SIP URL.\n *\n * @param url pointer to URL struct to be sanitized (IN/OUT)\n *\n * @return\n * The function url_sanitize() returns 0 if it considers URL to be\n * sane, and -1 otherwise.\n */\nint url_sanitize(url_t *url)\n{\n  if (!url)\n    return -1;\n  else if (url->url_scheme != NULL)\n    /* xyzzy */;\n  else if (url->url_host == NULL)\n    return -1;\n  else if (strncasecmp(url->url_host, \"ftp.\", strlen(\"ftp.\")) == 0)\n    url->url_type = url_ftp, url->url_scheme = \"ftp\", url->url_root = '/';\n  else if (strncasecmp(url->url_host, \"www.\", strlen(\"www.\")) == 0\n\t   || url->url_path)\n    url->url_type = url_http, url->url_scheme = \"http\", url->url_root = '/';\n  else\n    url->url_type = url_sip, url->url_scheme = \"sip\";\n\n  return 0;\n}\n\n#include <sofia-sip/su_md5.h>\n\nstatic\nvoid canon_update(su_md5_t *md5, char const *s, size_t n, char const *allow)\n{\n  size_t i, j;\n\n  for (i = 0, j = 0; i < n && s[i]; i++) {\n    char c;\n\n    if (s[i] == '%' && i + 2 < n && IS_HEX(s[i+1]) && IS_HEX(s[i+2])) {\n#define   UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n      c = (UNHEX(s[i+1]) << 4) | UNHEX(s[i+2]);\n#undef    UNHEX\n      if (c != '%' && c > ' ' && c < '\\177' &&\n\t  (!strchr(EXCLUDED, c) || strchr(allow, c))) {\n\tif (i != j)\n\t  su_md5_iupdate(md5, s + j, i - j);\n\tsu_md5_iupdate(md5, &c, 1);\n\tj = i + 3;\n      }\n      i += 2;\n    }\n  }\n\n  if (i != j)\n    su_md5_iupdate(md5, s + j, i - j);\n}\n\n/** Update MD5 sum with url-string contents */\nstatic\nvoid url_string_update(su_md5_t *md5, char const *s)\n{\n  size_t n, p;\n  int have_authority = 1;\n  enum url_type_e type = url_any;\n  char const *at, *colon;\n  char schema[48];\n\n  if (s == NULL || strlen(s) == 0 || strcmp(s, \"*\") == 0) {\n    su_md5_update(md5, \"*\\0\\0*\", 4);\n    return;\n  }\n\n  n = strcspn(s, \":/?#\");\n  if (n >= sizeof schema) {\n    su_md5_update(md5, \":\", 1);\n  }\n  else if (n && s[n] == ':' ) {\n    at = url_canonize(schema, s, n, 0, \"+\");\n\n    type = url_get_type(schema, at - schema);\n    su_md5_iupdate(md5, schema, at - schema);\n\n    have_authority = !url_type_is_opaque(type);\n    s += n + 1;\n  }\n  else {\n    su_md5_update(md5, \"\", 1);\n  }\n\n  if (type == url_sip || type == url_sips) {\n    /* SIP URL may have /;? in user part but no path */\n    /* user-unreserved  =  \"&\" / \"=\" / \"+\" / \"$\" / \",\" / \";\" / \"?\" / \"/\" */\n    /* Some #*@#* phones include unescaped # there, too */\n    n = strcspn(s, \"@/;?#\");\n    p = strcspn(s + n, \"@\");\n    if (s[n + p] == '@') {\n      n += p;\n      /* Ignore password in hash */\n      colon = memchr(s, ':', n);\n      p = colon ? (size_t)(colon - s) : n;\n      canon_update(md5, s, p, SIP_USER_UNRESERVED);\n      s += n + 1; n = 0;\n    }\n    else\n      su_md5_iupdate(md5, \"\", 1);\t/* user */\n    n += strcspn(s + n, \"/;?#\");\n  }\n  else if (have_authority) {\n    if (type == url_wv) {    /* WV URL may have / in user part */\n      n = strcspn(s, \"@;?#\");\n    }\n    else if (type != url_wv && s[0] == '/' && s[1] != '/') {\n      /* foo:/bar */\n      su_md5_update(md5, \"\\0\\0\", 2); /* user, host */\n      su_md5_striupdate(md5, url_port_default(type));\n      return;\n    }\n    else if (s[0] == '/' && s[1] == '/') {\n      /* We have authority, / / foo or foo */\n      s += 2;\n      n = strcspn(s, \"/?#@[]\");\n    }\n    else\n      n = strcspn(s, \"@;/?#\");\n\n    if (s[n] == '@') {\n      /* Ignore password in hash */\n      colon = type != url_unknown ? memchr(s, ':', n) : NULL;\n      p = colon ? (size_t)(colon - s) : n;\n      canon_update(md5, s, p, SIP_USER_UNRESERVED);\n      s += n + 1;\n      n = strcspn(s, \"/;?#\");\t/* Until path, query or fragment */\n    }\n    else {\n      su_md5_iupdate(md5, \"\", 1);\t/* user */\n      n += strcspn(s + n, \"/;?#\");\t/* Until path, query or fragment */\n    }\n  }\n  else /* if (!have_authority) */ {\n    n = strcspn(s, \":/;?#\");\t/* Until pass, path, query or fragment */\n\n    canon_update(md5, s, n, \"\"); /* user */\n    su_md5_update(md5, \"\\0\", 1); /* host, no port */\n    su_md5_striupdate(md5, url_port_default(type));\n    return;\n  }\n\n  if (n > 0 && s[0] == '[') {\t/* IPv6reference */\n    colon = memchr(s, ']', n);\n    if (colon == NULL || ++colon == s + n || *colon != ':')\n      colon = NULL;\n  }\n  else\n    colon = memchr(s, ':', n);\n\n  if (colon) {\n    canon_update(md5, s, colon - s, \"\"); /* host */\n    canon_update(md5, colon + 1, (s + n) - (colon + 1), \"\");\n  }\n  else {\n    canon_update(md5, s, n, \"\"); /* host */\n    su_md5_strupdate(md5, url_port_default(type));\t/* port */\n  }\n\n  /* ignore parameters/path/headers.... */\n}\n\n\n/** Update md5 digest with contents of URL.\n *\n */\nvoid url_update(su_md5_t *md5, url_t const *url)\n{\n  if (url_string_p((url_string_t *)url)) {\n    url_string_update(md5, (char const *)url);\n  }\n  else {\n    SU_MD5_STRI0UPDATE(md5, url->url_scheme);\n    SU_MD5_STRI0UPDATE(md5, url->url_user);\n    SU_MD5_STRI0UPDATE(md5, url->url_host);\n    su_md5_striupdate(md5, URL_PORT(url));\n    /* XXX - parameters/path.... */\n    /* SU_MD5_STRI0UPDATE(md5, url->url_path); */\n  }\n}\n\n/** Calculate a digest from URL contents. */\nvoid url_digest(void *hash, int hsize, url_t const *url, char const *key)\n{\n  su_md5_t md5[1];\n  uint8_t digest[SU_MD5_DIGEST_SIZE];\n\n  su_md5_init(md5);\n  if (key) su_md5_strupdate(md5, key);\n  url_update(md5, url);\n  su_md5_digest(md5, digest);\n\n  if (hsize > SU_MD5_DIGEST_SIZE) {\n    memset((char *)hash + SU_MD5_DIGEST_SIZE, 0, hsize - SU_MD5_DIGEST_SIZE);\n    hsize = SU_MD5_DIGEST_SIZE;\n  }\n\n  memcpy(hash, digest, hsize);\n}\n\n/** Convert a URL query to a header string.\n *\n * URL query is converted by replacing each \"=\" in header name \"=\" value\n * pair with semicolon (\":\"), and the \"&\" separating header-name-value pairs\n * with line feed (\"\\n\"). The \"body\" pseudoheader is moved last in the\n * string. The %-escaping is removed. Note that if the @a query contains %00,\n * the resulting string will be truncated.\n *\n * @param home memory home used to alloate string (if NULL, malloc() it)\n * @param query query part from SIP URL\n *\n * The result string is allocated from @a home, and it can be used as\n * argument to msg_header_parse_str(), msg_header_add_str() or\n * SIPTAG_HEADER_STR().\n *\n * @sa msg_header_add_str(), SIPTAG_HEADER_STR(),\n * sip_headers_as_url_query(), sip_url_query_as_taglist(),\n * @RFC3261 section 19.1.1 \"Headers\", #url_t, url_s#url_headers,\n * url_unescape(), url_unescape_to()\n *\n * @since New in @VERSION_1_12_4.\n */\nchar *url_query_as_header_string(su_home_t *home,\n\t\t\t\t char const *query)\n{\n  size_t i, j, n, b_start = 0, b_len = 0;\n  char *s = su_strdup(home, query);\n\n  if (!s)\n    return NULL;\n\n  for (i = 0, j = 0; s[i];) {\n    n = strcspn(s + i, \"=\");\n    if (!s[i + n])\n      break;\n    if (n == 4 && strncasecmp(s + i, \"body\", 4) == 0) {\n      if (b_start)\n\tbreak;\n      b_start = i + n + 1, b_len = strcspn(s + b_start, \"&\");\n      i = b_start + b_len + 1;\n      continue;\n    }\n    if (i != j)\n      memmove(s + j, s + i, n);\n    s[j + n] = ':';\n    i += n + 1, j += n + 1;\n    n = strcspn(s + i, \"&\");\n    j += url_unescape_to(s + j, s + i, n);\n    i += n;\n    if (s[i]) {\n      s[j++] = '\\n', i++;\n    }\n  }\n\n  if (s[i])\n    return (void)su_free(home, s), NULL;\n\n  if (b_start) {\n    s[j++] = '\\n', s[j++] = '\\n';\n    j += url_unescape_to(s + j, query + b_start, b_len);\n  }\n  s[j] = '\\0'; assert(j <= i);\n\n  return s;\n}\n"], "fixing_code": ["/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n/**@CFILE url.c\n *\n * Implementation of basic URL parsing and handling.\n *\n * @author Pekka Pessi <Pekka.Pessi@nokia.com>\n *\n * @date Created: Thu Jun 29 22:44:37 2000 ppessi\n */\n\n#include \"config.h\"\n\n#include <sofia-sip/su_alloc.h>\n#include <sofia-sip/bnf.h>\n#include <sofia-sip/hostdomain.h>\n#include <sofia-sip/url.h>\n\n#include <sofia-sip/string0.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n\n/**@def URL_PRINT_FORMAT\n * Format string used when printing url with printf().\n *\n * The macro URL_PRINT_FORMAT is used in format string of printf() or\n * similar printing functions.  A URL can be printed like this:\n * @code\n *   printf(\"%s received URL \" URL_PRINT_FORMAT \"\\n\",\n *          my_name, URL_PRINT_ARGS(url));\n * @endcode\n */\n\n/** @def URL_PRINT_ARGS(u)\n * Argument list used when printing url with printf().\n *\n * The macro URL_PRINT_ARGS() is used to create a stdarg list for printf()\n * or similar printing functions.  Using it, a URL can be printed like this:\n *\n * @code\n *   printf(\"%s received URL \" URL_PRINT_FORMAT \"\\n\",\n *          my_name, URL_PRINT_ARGS(url));\n * @endcode\n */\n\n#define RESERVED        \";/?:@&=+$,\"\n#define DELIMS          \"<>#%\\\"\"\n#define UNWISE\t\t\"{}|\\\\^[]`\"\n\n#define EXCLUDED\tRESERVED DELIMS UNWISE\n\n#define UNRESERVED    \t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \\\n                      \t\"abcdefghijklmnopqrstuvwxyz\" \\\n                      \t\"0123456789\" \\\n                      \t\"-_.!~*'()\"\n\n#define IS_EXCLUDED(u, m32, m64, m96)\t\t\t\\\n  (u <= ' '\t\t\t\t\t\t\\\n   || u >= '\\177'\t\t\t\t\t\\\n   || (u < 64 ? (m32 & (1 << (63 - u)))\t\t\t\\\n       : (u < 96 ? (m64 & (1 << (95 - u)))\t\t\\\n\t  : /*u < 128*/ (m96 & (1 << (127 - u))))) != 0)\n\n#define MASKS_WITH_RESERVED(reserved, m32, m64, m96)\t\t\\\n  if (reserved == NULL) {\t\t\t\t\t\\\n    m32 = 0xbe19003f, m64 = 0x8000001e, m96 = 0x8000001d;\t\\\n  } else do {\t\t\t\t\t\t\t\\\n    m32 = 0xb400000a, m64 = 0x0000001e, m96 = 0x8000001d;\t\\\n    \t\t\t\t\t\t\t\t\\\n    for (;reserved[0]; reserved++) {\t\t\t\t\\\n      unsigned r = reserved[0];\t\t\t\t\t\\\n      RESERVE(r, m32, m64, m96);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n#define RESERVE(reserved, m32, m64, m96)\t\t\t\t\\\n  if (r < 32)\t\t\t\t\t\t\t\t\\\n    ;\t\t\t\t\t\t\t\t\t\\\n  else if (r < 64)\t\t\t\t\t\t\t\\\n    m32 |= 1U << (63 - r);\t\t\t\t\t\t\\\n  else if (r < 96)\t\t\t\t\t\t\t\\\n    m64 |= 1U << (95 - r);\t\t\t\t\t\t\\\n  else if (r < 128)\t\t\t\t\t\t\t\\\n    m96 |= 1U << (127 - r)\n\n#define MASKS_WITH_ALLOWED(allowed, mask32, mask64, mask96)\t\\\n  do {\t\t\t\t\t\t\t\t\\\n    if (allowed) {\t\t\t\t\t\t\\\n      for (;allowed[0]; allowed++) {\t\t\t\t\\\n\tunsigned a = allowed[0];\t\t\t\t\\\n\tALLOW(a, mask32, mask64, mask96);\t\t\t\\\n      }\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n#define ALLOW(a, mask32, mask64, mask96)\t\\\n  if (a < 32)\t\t\t\t\t\\\n    ;\t\t\t\t\t\t\\\n  else if (a < 64)\t\t\t\t\\\n    mask32 &= ~(1U << (63 - a));\t\t\\\n  else if (a < 96)\t\t\t\t\\\n    mask64 &= ~(1U << (95 - a));\t\t\\\n  else if (a < 128)\t\t\t\t\\\n    mask96 &= ~(1U << (127 - a))\n\n#define NUL '\\0'\n#define NULNULNUL '\\0', '\\0', '\\0'\n\n#define RMASK1 0xbe19003f\n#define RMASK2 0x8000001e\n#define RMASK3 0x8000001d\n\n#define RESERVED_MASK 0xbe19003f, 0x8000001e, 0x8000001d\n#define URIC_MASK     0xb400000a, 0x0000001e, 0x8000001d\n\n#define IS_EXCLUDED_MASK(u, m) IS_EXCLUDED(u, m)\n\n/* Internal prototypes */\nstatic char *url_canonize(char *d, char const *s, size_t n,\n\t\t\t  unsigned syn33,\n\t\t\t  char const allowed[]);\nstatic char *url_canonize2(char *d, char const *s, size_t n,\n\t\t\t   unsigned syn33,\n\t\t\t   unsigned m32, unsigned m64, unsigned m96);\nstatic int url_tel_cmp_numbers(char const *A, char const *B);\n\n/**Test if string contains excluded or url-reserved characters.\n *\n *\n *\n * @param s  string to be searched\n *\n * @retval 0 if no reserved characters were found.\n * @retval l if a reserved character was found.\n */\nint url_reserved_p(char const *s)\n{\n  if (s)\n    while (*s) {\n      unsigned char u = *s++;\n\n      if (IS_EXCLUDED(u, RMASK1, RMASK2, RMASK3))\n\treturn 1;\n    }\n\n  return 0;\n}\n\n/** Calculate length of string when escaped with %-notation.\n *\n * Calculate the length of string @a s when the excluded or reserved\n * characters in it have been escaped.\n *\n * @param s         String with reserved URL characters. [IN\n * @param reserved  Optional array of reserved characters [IN]\n *\n * @return\n * The number of characters in corresponding but escaped string.\n *\n * You can handle a part of URL with reserved characters like this:\n *\ufffd@code\n * if (url_reserved_p(s))  {\n *   n = malloc(url_esclen(s, NULL) + 1);\n *   if (n) url_escape(n, s);\n * } else {\n *   n = malloc(strlen(s) + 1);\n *   if (n) strcpy(n, s);\n * }\n * @endcode\n */\nisize_t url_esclen(char const *s, char const reserved[])\n{\n  size_t n;\n  unsigned mask32, mask64, mask96;\n\n  MASKS_WITH_RESERVED(reserved, mask32, mask64, mask96);\n\n  for (n = 0; s && *s; n++) {\n    unsigned char u = *s++;\n\n    if (IS_EXCLUDED(u, mask32, mask64, mask96))\n      n += 2;\n  }\n\n  return (isize_t)n;\n}\n\n/** Escape a string.\n *\n * The function url_escape() copies the string pointed by @a s to the array\n * pointed by @a d, @b excluding the terminating \\\\0 character.  All reserved\n * characters in @a s are copied in hexadecimal format, for instance, @c\n * \"$%#\" is copied as @c \"%24%25%23\".  The destination array @a d must be\n * large enough to receive the escaped copy.\n *\n * @param d         Destination buffer [OUT]\n * @param s         String to be copied [IN]\n * @param reserved  Array of reserved characters [IN]\n *\n * @return Pointer to the destination array.\n */\nchar *url_escape(char *d, char const *s, char const reserved[])\n{\n  char *retval = d;\n  unsigned mask32, mask64, mask96;\n\n  MASKS_WITH_RESERVED(reserved, mask32, mask64, mask96);\n\n  while (s && *s) {\n    unsigned char u = *s++;\n\n    if (IS_EXCLUDED(u, mask32, mask64, mask96)) {\n#     define URL_HEXIFY(u) ((u) + '0' + ((u) >= 10 ? 'A' - '0' - 10 : 0))\n\n      *d++ = '%';\n      *d++ = URL_HEXIFY(u >> 4);\n      *d++ = URL_HEXIFY(u & 15);\n\n#     undef URL_HEXIFY\n    }\n    else {\n      *d++ = u;\n    }\n  }\n\n  *d = '\\0';\n\n  return retval;\n}\n\n\n/**Unescape url-escaped string fragment.\n *\n * Unescape @a n characters from string @a s to the buffer @a d, including\n * the terminating \\\\0 character. All %-escaped triplets in @a s are\n * unescaped, for instance, @c \"%40%25%23\" is copied as @c \"@%#\". The\n * destination array @a d must be large enough to receive the escaped copy\n * (@a n bytes is always enough).\n *\n * @param d  destination buffer\n * @param s  string to be unescaped\n * @param n  maximum number of characters to unescape\n *\n * @return Length of unescaped string\n *\n * @NEW_1_12_4.\n */\nsize_t url_unescape_to(char *d, char const *s, size_t n)\n{\n  size_t i = 0, j = 0;\n\n  if (s == NULL)\n    return 0;\n\n  i = j = strncspn(s, n, \"%\");\n\n  if (d && d != s)\n    memmove(d, s, i);\n\n  for (; i < n;) {\n    char c = s[i++];\n\n    if (c == '\\0')\n      break;\n\n    if (c == '%' && i + 1 < n && IS_HEX(s[i]) && IS_HEX(s[i + 1])) {\n#define   UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n      c = (UNHEX(s[i]) << 4) | UNHEX(s[i + 1]);\n#undef    UNHEX\n      i += 2;\n    }\n\n    if (d)\n      d[j] = c;\n    j++;\n  }\n\n  return j;\n}\n\n/**Unescape url-escaped string.\n *\n * Unescape string @a s to the buffer @a d, including the terminating \\\\0\n * character. All %-escaped triplets in @a s are unescaped, for instance, @c\n * \"%40%25%23\" is copied as @c \"@%#\". The destination array @a d must be\n * large enough to receive the escaped copy.\n *\n * @param d  destination buffer\n * @param s  string to be copied\n *\n * @return Pointer to the destination buffer.\n */\nchar *url_unescape(char *d, char const *s)\n{\n  size_t n = url_unescape_to(d, s, SIZE_MAX);\n  if (d)\n    d[n] = '\\0';\n  return d;\n}\n\n/** Canonize a URL component */\nstatic\nchar *url_canonize(char *d, char const *s, size_t n,\n\t\t   unsigned syn33,\n\t\t   char const allowed[])\n{\n  unsigned mask32 = 0xbe19003f, mask64 = 0x8000001e, mask96 = 0x8000001d;\n\n  MASKS_WITH_ALLOWED(allowed, mask32, mask64, mask96);\n\n  return url_canonize2(d, s, n, syn33, mask32, mask64, mask96);\n}\n\n#define SYN33(c) (1U << (c - 33))\n#define IS_SYN33(syn33, c) ((syn33 & (1U << (c - 33))) != 0)\n\n/** Canonize a URL component (with precomputed mask) */\nstatic\nchar *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n\n    if (i >= strlen(s) - 1) return NULL;\n    h1 = s[i + 1], h2 = s[i + 2];\n\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      /* Convert hex to normal character */\n      *d = c, i += 2;\n      continue;\n    }\n\n    /* Convert hex to uppercase */\n    if (h1 >= 'a' /* && h1 <= 'f' */)\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' /* && h2 <= 'f' */)\n      h2 = h2 - 'a' + 'A';\n\n    d[0] = '%', d[1] = h1, d[2] = h2;\n\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n\n  *d = '\\0';\n\n  return d;\n}\n\n\n/** Canonize a URL component (with precomputed mask).\n *\n * This version does not flag error if *s contains character that should\n * be escaped.\n */\nstatic\nchar *url_canonize3(char *d, char const * const s, size_t n,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n\n    if (c != '%') {\n      *d = c;\n      continue;\n    }\n\n    h1 = s[i + 1], h2 = s[i + 2];\n\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      *d = c, i += 2;\n      continue;\n    }\n\n    /* Convert hex to uppercase */\n    if (h1 >= 'a' /* && h1 <= 'f' */)\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' /* && h2 <= 'f' */)\n      h2 = h2 - 'a' + 'A';\n\n    d[0] = '%', d[1] = h1, d[2] = h2;\n\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n\n  *d = '\\0';\n\n  return d;\n}\n\n\n/** Get URL scheme. */\nchar const* url_scheme(enum url_type_e url_type)\n{\n  switch (url_type) {\n  case url_any:    return \"*\";\n  case url_sip:    return \"sip\";\n  case url_sips:   return \"sips\";\n  case url_tel:    return \"tel\";\n  case url_fax:    return \"fax\";\n  case url_modem:  return \"modem\";\n  case url_http:   return \"http\";\n  case url_https:  return \"https\";\n  case url_ftp:    return \"ftp\";\n  case url_file:   return \"file\";\n  case url_rtsp:   return \"rtsp\";\n  case url_rtspu:  return \"rtspu\";\n  case url_mailto: return \"mailto\";\n  case url_im:     return \"im\";\n  case url_pres:   return \"pres\";\n  case url_cid:    return \"cid\";\n  case url_msrp:   return \"msrp\";\n  case url_msrps:  return \"msrps\";\n  case url_wv:     return \"wv\";\n  default:\n    assert(url_type == url_unknown);\n    return NULL;\n  }\n}\n\nsu_inline\nint url_type_is_opaque(enum url_type_e url_type)\n{\n  return\n    url_type == url_invalid ||\n    url_type == url_tel ||\n    url_type == url_modem ||\n    url_type == url_fax ||\n    url_type == url_cid;\n}\n\n/** Init an url as given type */\nvoid url_init(url_t *url, enum url_type_e type)\n{\n  memset(url, 0, sizeof(*url));\n  url->url_type = type;\n  if (type > url_unknown) {\n    char const *scheme = url_scheme((enum url_type_e)url->url_type);\n    if (scheme)\n      url->url_scheme = scheme;\n  }\n}\n\n/** Get url type */\nsu_inline\nenum url_type_e url_get_type(char const *scheme, size_t len)\n{\n#define test_scheme(s) \\\n   if (len == strlen(#s) && !strncasecmp(scheme, #s, len)) return url_##s\n\n  switch (scheme[0]) {\n  case '*': if (strcmp(scheme, \"*\") == 0) return url_any;\n  case 'c': case 'C':\n    test_scheme(cid); break;\n  case 'f': case 'F':\n    test_scheme(ftp); test_scheme(file); test_scheme(fax); break;\n  case 'h': case 'H':\n    test_scheme(http); test_scheme(https); break;\n  case 'i': case 'I':\n    test_scheme(im); break;\n  case 'm': case 'M':\n    test_scheme(mailto); test_scheme(modem);\n    test_scheme(msrp); test_scheme(msrps); break;\n  case 'p': case 'P':\n    test_scheme(pres); break;\n  case 'r': case 'R':\n    test_scheme(rtsp); test_scheme(rtspu); break;\n  case 's': case 'S':\n    test_scheme(sip); test_scheme(sips); break;\n  case 't': case 'T':\n    test_scheme(tel); break;\n  case 'w': case 'W':\n    test_scheme(wv); break;\n\n\n  default: break;\n  }\n\n#undef test_scheme\n\n  if (len != span_unreserved(scheme))\n    return url_invalid;\n  else\n    return url_unknown;\n}\n\n/**\n * Decode a URL.\n *\n * This function decodes a (SIP) URL string to a url_t structure.\n *\n * @param url structure to store the parsing result\n * @param s   NUL-terminated string to be parsed\n *\n * @note The parsed string @a s will be modified when parsing it.\n *\n * @retval 0 if successful,\n * @retval -1 otherwise.\n */\nstatic\nint _url_d(url_t *url, char *s)\n{\n  size_t n, p;\n  char rest_c, *host, *user;\n  int have_authority = 1;\n\n  memset(url, 0, sizeof(*url));\n\n  if (strcmp(s, \"*\") == 0) {\n    url->url_type = url_any;\n    url->url_scheme = \"*\";\n    return 0;\n  }\n\n  n = strcspn(s, \":/?#\");\n\n  if (n && s[n] == ':') {\n    char *scheme;\n    url->url_scheme = scheme = s; s[n] = '\\0'; s = s + n + 1;\n\n    if (!(scheme = url_canonize(scheme, scheme, SIZE_MAX, 0, \"+\")))\n      return -1;\n\n    n = scheme - url->url_scheme;\n\n    url->url_type = url_get_type(url->url_scheme, n);\n\n    have_authority = !url_type_is_opaque((enum url_type_e)url->url_type);\n  }\n  else {\n    url->url_type = url_unknown;\n  }\n\n  user = NULL, host = s;\n\n  if (url->url_type == url_sip || url->url_type == url_sips) {\n    /* SIP URL may have /;? in user part but no path */\n    /* user-unreserved  =  \"&\" / \"=\" / \"+\" / \"$\" / \",\" / \";\" / \"?\" / \"/\" */\n    /* Some #*@#* phones include unescaped # there, too */\n    n = strcspn(s, \"@/;?#\");\n    p = strcspn(s + n, \"@\");\n    if (s[n + p] == '@') {\n      n += p;\n      user = s;\n      host = s + n + 1;\n    }\n\n    n += strcspn(s + n, \"/;?#\");\n  }\n  else if (have_authority) {\n    if (url->url_type == url_wv) {\n      /* WV URL may have / in user part */\n      n = strcspn(s, \"@#?;\");\n      if (s[n] == '@') {\n\tuser = s;\n\thost = s + n + 1;\n\tn += strcspn(s + n, \";?#\");\n      }\n    }\n    else if (host[0] == '/' && host[1] != '/') {\n      /* foo:/bar or /bar - no authority, just path */\n      url->url_root = '/';\t/* Absolute path */\n      host = NULL, n = 0;\n    }\n    else {\n      if (host[0] == '/' && host[1] == '/') {\n\t/* We have authority, / / foo or foo */\n\thost += 2; s += 2, url->url_root = '/';\n\tn = strcspn(s, \"/?#@[]\");\n      }\n      else\n\tn = strcspn(s, \"@;/?#\");\n\n      if (s[n] == '@')\n\tuser = host, host = user + n + 1;\n\n      n += strcspn(s + n, \";/?#\");\t/* Find path, query and/or fragment */\n    }\n  }\n  else /* !have_authority */ {\n    user = host, host = NULL;\n    if (url->url_type != url_invalid)\n      n = strcspn(s, \"/;?#\");\t/* Find params, query and/or fragment */\n    else\n      n = strcspn(s, \"#\");\n  }\n\n  rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;\n\n  if (user) {\n    if (host) host[-1] = '\\0';\n    url->url_user = user;\n    if (url->url_type != url_unknown) {\n      n = strcspn(user, \":\");\n      if (user[n]) {\n\tuser[n] = '\\0';\n\turl->url_password = user + n + 1;\n      }\n    }\n  }\n\n  if (host) {\n    url->url_host = host;\n    /* IPv6 (and in some cases, IPv4) addresses are quoted with [] */\n    if (host[0] == '[') {\n      n = strcspn(host, \"]\");\n      if (host[n] && (host[n + 1] == '\\0' || host[n + 1] == ':'))\n\tn++;\n      else\n\tn = 0;\n    }\n    else {\n      n = strcspn(host, \":\");\n    }\n\n    /* We allow empty host by default */\n    if (n == 0) switch (url->url_type) {\n    case url_sip:\n    case url_sips:\n    case url_im:\n    case url_pres:\n      return -1;\n    default:\n      break;\n    }\n\n    if (host[n] == ':') {\n      char *port = host + n + 1;\n      url->url_port = port;\n      switch (url->url_type) {\n      case url_any:\n      case url_sip:\n      case url_sips:\n      case url_http:\n      case url_https:\n      case url_ftp:\n      case url_file:\n      case url_rtsp:\n      case url_rtspu:\n\tif (!url_canonize2(port, port, SIZE_MAX, 0, RESERVED_MASK))\n\t  return -1;\n\n\t/* Check that port is really numeric or wildcard */\n\t/* Port can be *digit, empty string or \"*\" */\n\twhile (*port >= '0' && *port <= '9')\n\t  port++;\n\n\tif (port != url->url_port) {\n\t  if (port[0] != '\\0')\n\t    return -1;\n\t}\n\telse if (port[0] == '\\0')\n\t  /* empty string */;\n\telse if (port[0] == '*' && port[1] == '\\0')\n\t  /* wildcard */;\n\telse\n\t  return -1;\n      }\n      host[n] = 0;\n    }\n  }\n\n  if (rest_c == '/') {\n    url->url_path = s; n = strcspn(s, \"?#\");\n    rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;\n  }\n  if (rest_c == ';') {\n    url->url_params = s; n = strcspn(s, \"?#\");\n    rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;\n  }\n  if (rest_c == '?') {\n    url->url_headers = s; n = strcspn(s, \"#\");\n    rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;\n  }\n  if (rest_c == '#') {\n    url->url_fragment = s;\n    rest_c = '\\0';\n  }\n  if (rest_c)\n    return -1;\n\n  return 0;\n}\n\n/* Unreserved things */\n\n/**\n * Decode a URL.\n *\n * This function decodes a URL string to a url_t structure.\n *\n * @param url structure to store the parsing result\n * @param s   NUL-terminated string to be parsed\n *\n * @note The parsed string @a s will be modified when parsing it.\n *\n * @retval 0 if successful,\n * @retval -1 otherwise.\n */\nint url_d(url_t *url, char *s)\n{\n  if (url == NULL || _url_d(url, s) < 0)\n    return -1;\n\n  /* Canonize  URL */\n  /* scheme is canonized by _url_d() */\n  if (url->url_type == url_sip || url->url_type == url_sips) {\n\n#   define SIP_USER_UNRESERVED \"&=+$,;?/\"\n    s = (char *)url->url_user;\n    if (s && !url_canonize(s, s, SIZE_MAX, 0, SIP_USER_UNRESERVED))\n      return -1;\n\n    /* Having different charset in user and password does not make sense */\n    /* but that is how it is defined in RFC 3261 */\n#   define SIP_PASS_UNRESERVED \"&=+$,\"\n    s = (char *)url->url_password;\n    if (s && !url_canonize(s, s, SIZE_MAX, 0, SIP_PASS_UNRESERVED))\n      return -1;\n\n  }\n  else {\n\n#   define USER_UNRESERVED \"&=+$,;\"\n    s = (char *)url->url_user;\n    if (s && !url_canonize(s, s, SIZE_MAX, 0, USER_UNRESERVED))\n      return -1;\n\n#   define PASS_UNRESERVED \"&=+$,;:\"\n    s = (char *)url->url_password;\n    if (s && !url_canonize(s, s, SIZE_MAX, 0, PASS_UNRESERVED))\n      return -1;\n  }\n\n  s = (char *)url->url_host;\n  if (s && !url_canonize2(s, s, SIZE_MAX, 0, RESERVED_MASK))\n    return -1;\n\n  /* port is canonized by _url_d() */\n  s = (char *)url->url_path;\n  if (s && !url_canonize(s, s, SIZE_MAX,\n\t\t\t /* Allow all URI characters but ? */\n\t\t\t /* Allow unescaped /;?@, - but do not convert */\n\t\t\t SYN33('/') | SYN33(';') | SYN33('=') | SYN33('@') |\n\t\t\t SYN33(','),\n\t\t\t /* Convert escaped :&+$ to unescaped */\n\t\t\t \":&+$\"))\n    return -1;\n\n  s = (char *)url->url_params;\n  if (s && !url_canonize(s, s, SIZE_MAX,\n\t\t\t /* Allow all URI characters but ? */\n\t\t\t /* Allow unescaped ;=@, - but do not convert */\n\t\t\t SYN33(';') | SYN33('=') | SYN33('@') | SYN33(','),\n\t\t\t /* Convert escaped /:&+$ to unescaped */\n\t\t\t \"/:&+$\"))\n    return -1;\n\n  /* Unhex alphanumeric and unreserved URI characters */\n  s = (char *)url->url_headers;\n  if (s && !url_canonize3(s, s, SIZE_MAX, RESERVED_MASK))\n    return -1;\n\n  /* Allow all URI characters (including reserved ones) */\n  s = (char *)url->url_fragment;\n  if (s && !url_canonize2(s, s, SIZE_MAX, 0, URIC_MASK))\n    return -1;\n\n  return 0;\n}\n\n/** Encode an URL.\n *\n * The function url_e() combines a URL from substrings in url_t structure\n * according the @ref url_syntax \"URL syntax\" presented above.  The encoded\n * @a url is stored in a @a buffer of @a n bytes.\n *\n * @param buffer memory area to store the encoded @a url.\n * @param n      size of @a buffer.\n * @param url    URL to be encoded.\n *\n * @return\n * Return the number of bytes in the encoding.\n *\n * @note The function follows the convention set by C99 snprintf().  Even if\n * the result does not fit into the @a buffer and it is truncated, the\n * function returns the number of bytes in an untruncated encoding.\n */\nissize_t url_e(char buffer[], isize_t n, url_t const *url)\n{\n  size_t i;\n  char *b = buffer;\n  size_t m = n;\n  int do_copy = n > 0;\n\n  if (url == NULL)\n    return -1;\n\n  if (URL_STRING_P(url)) {\n    char const *u = (char *)url;\n    i = strlen(u);\n    if (!buffer)\n      return i;\n\n    if (i >= n) {\n      memcpy(buffer, u, n - 2);\n      buffer[n - 1] = '\\0';\n    } else {\n      memcpy(buffer, u, i + 1);\n    }\n\n    return i;\n  }\n\n\n  if (url->url_type == url_any) {\n    if (b && m > 0) {\n      if (m > 1) strcpy(b, \"*\"); else b[0] = '\\0';\n    }\n    return 1;\n  }\n\n  if (url->url_scheme && url->url_scheme[0]) {\n    i = strlen(url->url_scheme) + 1;\n    if (do_copy && (do_copy = i <= n)) {\n      memcpy(b, url->url_scheme, i - 1);\n      b[i - 1] = ':';\n    }\n    b += i; n -= i;\n  }\n\n  if (url->url_root && (url->url_host || url->url_user)) {\n    if (do_copy && (do_copy = 2 <= n))\n      memcpy(b, \"//\", 2);\n    b += 2; n -= 2;\n  }\n\n  if (url->url_user) {\n    i = strlen(url->url_user);\n    if (do_copy && (do_copy = i <= n))\n      memcpy(b, url->url_user, i);\n    b += i; n -= i;\n\n    if (url->url_password) {\n      if (do_copy && (do_copy = 1 <= n))\n\t*b = ':';\n      b++; n--;\n      i = strlen(url->url_password);\n      if (do_copy && (do_copy = i <= n))\n\tmemcpy(b, url->url_password, i);\n      b += i; n -= i;\n    }\n\n    if (url->url_host) {\n      if (do_copy && (do_copy = 1 <= n))\n\t*b = '@';\n      b++; n--;\n    }\n  }\n\n  if (url->url_host) {\n    i = strlen(url->url_host);\n    if (do_copy && (do_copy = i <= n))\n      memcpy(b, url->url_host, i);\n    b += i; n -= i;\n\n    if (url->url_port) {\n      i = strlen(url->url_port) + 1;\n      if (do_copy && (do_copy = i <= n)) {\n\tb[0] = ':';\n\tmemcpy(b + 1, url->url_port, i - 1);\n      }\n      b += i; n -= i;\n    }\n  }\n\n  if (url->url_path) {\n    if (url->url_root) {\n      if (do_copy && (do_copy = 1 <= n))\n\tb[0] = '/';\n      b++, n--;\n    }\n    i = strlen(url->url_path);\n    if (do_copy && (do_copy = i < n))\n      memcpy(b, url->url_path, i);\n    b += i; n -= i;\n  }\n\n  {\n    static char const sep[] = \";?#\";\n    char const *pp[3];\n    size_t j;\n\n    pp[0] = url->url_params;\n    pp[1] = url->url_headers;\n    pp[2] = url->url_fragment;\n\n    for (j = 0; j < 3; j++) {\n      char const *p = pp[j];\n      if (!p) continue;\n      i = strlen(p) + 1;\n      if (do_copy && (do_copy = i <= n)) {\n\t*b = sep[j];\n\tmemcpy(b + 1, p, i - 1);\n      }\n      b += i; n -= i;\n    }\n  }\n\n  if (do_copy && (do_copy = 1 <= n))\n    *b = '\\0';\n  else if (buffer && m > 0)\n    buffer[m - 1] = '\\0';\n\n  assert((size_t)(b - buffer) == (size_t)(m - n));\n\n  /* This follows the snprintf(C99) return value,\n   * Number of characters written (excluding NUL)\n   */\n  return b - buffer;\n}\n\n\n/** Calculate the length of URL when encoded.\n *\n */\nisize_t url_len(url_t const * url)\n{\n  size_t rv = 0;\n\n  if (url->url_scheme) rv += strlen(url->url_scheme) + 1; /* plus ':' */\n  if (url->url_user) {\n    rv += strlen(url->url_user);\n    if (url->url_password)\n      rv += strlen(url->url_password) + 1;   /* plus ':' */\n    rv += url->url_host != NULL;  /* plus '@' */\n  }\n  if (url->url_host) rv += strlen(url->url_host);\n  if (url->url_port) rv += strlen(url->url_port) + 1;\t        /* plus ':' */\n  if (url->url_path) rv += strlen(url->url_path) + 1;     /* plus initial / */\n  if (url->url_params) rv += strlen(url->url_params) + 1; /* plus initial ; */\n  if (url->url_headers) rv += strlen(url->url_headers) + 1;\t/* plus '?' */\n  if (url->url_fragment) rv += strlen(url->url_fragment) + 1;   /* plus '#' */\n\n  return rv;\n}\n\n/**@def URL_E(buf, end, url)\n * Encode an URL: use @a buf up to @a end.\n * @hideinitializer\n */\n\n/**\n * Calculate the size of strings associated with a #url_t sructure.\n *\n * @param url pointer to a #url_t structure or string\n * @return Number of bytes for URL\n */\nisize_t url_xtra(url_t const *url)\n{\n  size_t xtra;\n\n  if (URL_STRING_P(url)) {\n    xtra = strlen((char const *)url) + 1;\n  }\n  else {\n    size_t len_scheme, len_user, len_password,\n      len_host, len_port, len_path, len_params,\n      len_headers, len_fragment;\n\n    len_scheme = (url->url_type <= url_unknown && url->url_scheme) ?\n      strlen(url->url_scheme) + 1 : 0;\n    len_user = url->url_user ? strlen(url->url_user) + 1 : 0;\n    len_password = url->url_password ? strlen(url->url_password) + 1 : 0;\n    len_host = url->url_host ? strlen(url->url_host) + 1 : 0;\n    len_port = url->url_port ? strlen(url->url_port) + 1 : 0;\n    len_path = url->url_path ? strlen(url->url_path) + 1 : 0;\n    len_params = url->url_params ? strlen(url->url_params) + 1 : 0;\n    len_headers = url->url_headers ? strlen(url->url_headers) + 1 : 0;\n    len_fragment = url->url_fragment ? strlen(url->url_fragment) + 1 : 0;\n\n    xtra =\n      len_scheme + len_user + len_password + len_host + len_port +\n      len_path + len_params + len_headers + len_fragment;\n  }\n\n  return xtra;\n}\n\nsu_inline\nchar *copy(char *buf, char *end, char const *src)\n{\n#if HAVE_MEMCCPY\n  char *b = memccpy(buf, src, '\\0', end - buf);\n  if (b)\n    return b;\n  else\n    return end + strlen(src + (end - buf)) + 1;\n#else\n  for (; buf < end && (*buf = *src); buf++, src++)\n    ;\n\n  if (buf >= end)\n    while (*src++)\n      buf++;\n\n  return buf + 1;\n#endif\n}\n\n/**\n * Duplicate the url.\n *\n * The function url_dup() copies the url structure @a src and the strings\n * attached to it to @a url.  The non-constant strings in @a src are copied\n * to @a buf.  If the size of duplicated strings exceed @a bufsize, the\n * corresponding string fields in @a url are set to NULL.\n *\n * The calling function can calculate the size of buffer required by calling\n * url_dup() with zero as @a bufsize and NULL as @a dst.\n\n * @param buf     Buffer for non-constant strings copied from @a src.\n * @param bufsize Size of @a buf.\n * @param dst     Destination URL structure.\n *\ufffd@param src     Source URL structure.\n *\n * @return Number of characters required for\n * duplicating the strings in @a str, or -1 if an error\n * occurred.\n */\nissize_t url_dup(char *buf, isize_t bufsize, url_t *dst, url_t const *src)\n{\n  if (!src && !dst)\n    return -1;\n  else if (URL_STRING_P(src)) {\n    size_t n = strlen((char *)src) + 1;\n    if (n > bufsize || dst == NULL)\n      return n;\n\n    strcpy(buf, (char *)src);\n    memset(dst, 0, sizeof(*dst));\n    if (url_d(dst, buf) < 0)\n      return -1;\n\n    return n;\n  }\n  else {\n    char *b = buf;\n    char *end = b + bufsize;\n    char const **dstp;\n    char const * const *srcp;\n    url_t dst0[1];\n\n    if (dst == NULL)\n      dst = dst0;\n\n    memset(dst, 0, sizeof(*dst));\n\n    if (!src)\n      return 0;\n\n    memset(dst->url_pad, 0, sizeof dst->url_pad);\n    dst->url_type = src->url_type;\n    dst->url_root = src->url_root;\n\n    dstp = &dst->url_scheme;\n    srcp = &src->url_scheme;\n\n    if (dst->url_type > url_unknown)\n      *dstp = url_scheme((enum url_type_e)dst->url_type);\n\n    if (*dstp != NULL)\n      dstp++, srcp++;\t/* Skip scheme if it is constant */\n\n    if (dst != dst0 && buf != NULL && bufsize != 0)\n      for (; srcp <= &src->url_fragment; srcp++, dstp++)\n\tif (*srcp) {\n\t  char *next = copy(b, end, *srcp);\n\n\t  if (next > end)\n\t    break;\n\n\t  *dstp = b, b = next;\n\t}\n\n    for (; srcp <= &src->url_fragment; srcp++)\n      if (*srcp) {\n\tb += strlen(*srcp) + 1;\n      }\n\n    return b - buf;\n  }\n}\n\n/**@def URL_DUP(buf, end, dst, src)\n *  Duplicate the url: use @a buf up to @a end. @HI\n *\n * The macro URL_DUP() duplicates the url.  The non-constant strings in @a\n * src are copied to @a buf.  However, no strings are copied past @a end.\n * In other words, the size of buffer is @a end - @a buf.\n *\n * The macro updates the buffer pointer @a buf, so that it points to the\n * first unused byte in the buffer.  The buffer pointer @a buf is updated,\n * even if the buffer is too small for the duplicated strings.\n *\n * @param buf     Buffer for non-constant strings copied from @a src.\n * @param end     End of @a buf.\n * @param dst     Destination URL structure.\n *\ufffd@param src     Source URL structure.\n *\n * @return\n * The macro URL_DUP() returns pointer to first unused byte in the\n * buffer @a buf.\n */\n\n/** Duplicate the url to memory allocated via home.\n *\n * The function url_hdup() duplicates (deep copies) an #url_t structure.\n * Alternatively, it can be passed a string; string is then copied and\n * parsed to the #url_t structure.\n *\n * The function url_hdup() allocates the destination structure from @a home\n * as a single memory block. It is possible to free the copied url structure\n * and all the associated strings using a single call to su_free().\n *\n * @param home memory home used to allocate new url object\n * @param src  pointer to URL (or string)\n *\n * @return\n * The function url_hdup() returns a pointer to the newly allocated #url_t\n * structure, or NULL upon an error.\n */\nurl_t *url_hdup(su_home_t *home, url_t const *src)\n{\n  if (src) {\n    size_t len = sizeof(*src) + url_xtra(src);\n    url_t *dst = su_alloc(home, len);\n    if (dst) {\n      ssize_t actual;\n      actual = url_dup((char *)(dst + 1), len - sizeof(*src), dst, src);\n      if (actual < 0)\n\tsu_free(home, dst), dst = NULL;\n      else\n\tassert(len == sizeof(*src) + actual);\n    }\n    return dst;\n  }\n  else\n    return NULL;\n}\n\n\n/** Convert an string to an url */\nurl_t *url_make(su_home_t *h, char const *str)\n{\n  return url_hdup(h, URL_STRING_MAKE(str)->us_url);\n}\n\n/** Print an URL */\nurl_t *url_format(su_home_t *h, char const *fmt, ...)\n{\n  url_t *url;\n  char *us;\n  va_list ap;\n\n  va_start(ap, fmt);\n\n  us = su_vsprintf(h, fmt, ap);\n\n  va_end(ap);\n\n  if (us == NULL)\n    return NULL;\n\n  url = url_hdup(h, URL_STRING_MAKE(us)->us_url);\n\n  su_free(h, us);\n\n  return url;\n}\n\n\n/** Convert @a url to a string allocated from @a home.\n *\n * @param home memory home to allocate the new string\n * @param url  url to convert to string\n *\n * The @a url can be a string, too.\n *\n * @return Newly allocated conversion result, or NULL upon an error.\n */\nchar *url_as_string(su_home_t *home, url_t const *url)\n{\n  if (url) {\n    int len = url_e(NULL, 0, url);\n    char *b = su_alloc(home, len + 1);\n    url_e(b, len + 1, url);\n    return b;\n  } else {\n    return NULL;\n  }\n}\n\n\n/** Test if param @a tag matches to parameter string @a p.\n */\n#define URL_PARAM_MATCH(p, tag) \\\n (strncasecmp(p, tag, strlen(tag)) == 0 && \\\n  (p[strlen(tag)] == '\\0' || p[strlen(tag)] == ';' || p[strlen(tag)] == '='))\n\n/**\n * Search for a parameter.\n *\n * This function searches for a parameter from a parameter list.\n *\n * If you want to test if there is parameter @b user=phone,\n * call this function like\n * @code if (url_param(url->url_param, \"user=phone\", NULL, 0))\n * @endcode\n *\n * @param params URL parameter string (excluding first semicolon)\n * @param tag    parameter name\n * @param value  string to which the parameter value is copied\n * @param vlen   length of string reserved for value\n *\n * @retval positive length of parameter value (including final NUL) if found\n * @retval zero     if not found.\n */\nisize_t url_param(char const *params,\n\t\t  char const *tag,\n\t\t  char value[], isize_t vlen)\n{\n  size_t n, tlen, flen;\n  char *p;\n\n  if (!params)\n    return 0;\n\n  tlen = strlen(tag);\n  if (tlen && tag[tlen - 1] == '=')\n    tlen--;\n\n  for (p = (char *)params; *p; p += n + 1) {\n    n = strcspn(p, \";\");\n    if (n < tlen) {\n      if (p[n]) continue; else break;\n    }\n    if (strncasecmp(p, tag, tlen) == 0) {\n      if (n == tlen) {\n\tif (vlen > 0)\n\t  value[0] = '\\0';\n\treturn 1;\n      }\n      if (p[tlen] != '=')\n\tcontinue;\n      flen = n - tlen - 1;\n      if (flen >= (size_t)vlen)\n\treturn flen + 1;\n      memcpy(value, p + tlen + 1, flen);\n      value[flen] = '\\0';\n      return flen + 1;\n    }\n    if (!p[n])\n      break;\n  }\n\n  return 0;\n}\n\n/** Check for a parameter.\n *\n * @deprecated\n * Bad grammar. Use url_has_param().\n */\nisize_t url_have_param(char const *params, char const *tag)\n{\n  return url_param(params, tag, NULL, 0);\n}\n\n/** Check for a parameter. */\nint url_has_param(url_t const *url, char const *tag)\n{\n  return url && url->url_params && url_param(url->url_params, tag, NULL, 0);\n}\n\n/** Add an parameter. */\nint url_param_add(su_home_t *h, url_t *url, char const *param)\n{\n  /* XXX - should remove existing parameters with same name? */\n  size_t n = url->url_params ? strlen(url->url_params) + 1: 0;\n  size_t nn = strlen(param) + 1;\n  char *s = su_alloc(h, n + nn);\n\n  if (!s)\n    return -1;\n\n  if (url->url_params)\n    strcpy(s, url->url_params)[n - 1] = ';';\n  strcpy(s + n, param);\n  url->url_params = s;\n\n  return 0;\n}\n\n/** Remove a named parameter from url_param string.\n *\n * Remove a named parameter and its possible value from the URL parameter\n * string (url_s##url_param).\n *\n * @return Pointer to modified string, or NULL if nothing is left in there.\n */\nchar *url_strip_param_string(char *params, char const *name)\n{\n  if (params && name) {\n    size_t i, n = strlen(name), remove, rest;\n\n    for (i = 0; params[i];) {\n      if (strncasecmp(params + i, name, n) ||\n\t  (params[i + n] != '=' && params[i + n] != ';' && params[i + n])) {\n\ti = i + strcspn(params + i, \";\");\n\tif (!params[i++])\n\t  break;\n\tcontinue;\n      }\n      remove = n + strcspn(params + i + n, \";\");\n      if (params[i + remove] == ';')\n\tremove++;\n\n      if (i == 0) {\n\tparams += remove;\n\tcontinue;\n      }\n\n      rest = strlen(params + i + remove);\n      if (!rest) {\n\tif (i == 0)\n\t  return NULL;\t\t/* removed everything */\n\tparams[i - 1] = '\\0';\n\tbreak;\n      }\n      memmove(params + i, params + i + remove, rest + 1);\n    }\n\n    if (!params[0])\n      return NULL;\n  }\n\n  return params;\n}\n\nint url_string_p(url_string_t const *url)\n{\n  return URL_STRING_P(url);\n}\n\nint url_is_string(url_string_t const *url)\n{\n  return URL_IS_STRING(url);\n}\n\n/** Strip transport-specific stuff. */\nstatic\nint url_strip_transport2(url_t *url, int modify)\n{\n  char *p, *d;\n  size_t n;\n  int semi;\n\n  if (url->url_type != url_sip && url->url_type != url_sips)\n    return 0;\n\n  if (url->url_port != NULL) {\n    if (!modify)\n      return 1;\n    url->url_port = NULL;\n  }\n\n  if (!url->url_params)\n    return 0;\n\n  for (d = p = (char *)url->url_params; *p; p += n + semi) {\n    n = strcspn(p, \";\");\n    semi = (p[n] != '\\0');\n\n    if (modify && n == 0)\n      continue;\n    if (URL_PARAM_MATCH(p, \"method\"))\n      continue;\n    if (URL_PARAM_MATCH(p, \"maddr\"))\n      continue;\n    if (URL_PARAM_MATCH(p, \"ttl\"))\n      continue;\n    if (URL_PARAM_MATCH(p, \"transport\"))\n      continue;\n\n    if (p != d) {\n      if (d != url->url_params)\n\td++;\n      if (p != d) {\n\tif (!modify)\n\t  return 1;\n\tmemmove(d, p, n + 1);\n      }\n    }\n    d += n;\n  }\n\n  if (d == p)\n    return 0;\n  else if (d + 1 == p)\t\t/* empty param */\n    return 0;\n  else if (!modify)\n    return 1;\n\n  if (d != url->url_params)\n    *d = '\\0';\n  else\n    url->url_params = NULL;\n\n  return 1;\n}\n\n/** Strip transport-specific stuff.\n *\n * The function url_strip_transport() removes transport-specific parameters\n * from a SIP or SIPS URI.  These parameters include:\n * - the port number\n * - \"maddr=\" parameter\n * - \"transport=\" parameter\n * - \"ttl=\" parameter\n * - \"method=\" parameter\n *\n * @note\n * The @a url must be a pointer to a URL structure. It is stripped in-place.\n *\n * @note\n * If the parameter string contains empty parameters, they are stripped, too.\n *\n * @return\n * The function url_strip_transport() returns @e true, if the URL was\n * modified, @e false otherwise.\n */\nint url_strip_transport(url_t *url)\n{\n  return url_strip_transport2(url, 1);\n}\n\n/** Check for transport-specific stuff.\n *\n * The function url_have_transport() tests if there are transport-specific\n * parameters in a SIP or SIPS URI. These parameters include:\n * - the port number\n * - \"maddr=\" parameters\n * - \"transport=\" parameters\n *\n * @note\n * The @a url must be a pointer to a URL structure.\n *\n * @return The function url_have_transport() returns @e true, if the URL\n * contains transport parameters, @e false otherwise.\n */\nint url_have_transport(url_t const *url)\n{\n  return url_strip_transport2((url_t *)url, 0);\n}\n\n/**Lazily compare two URLs.\n *\n * Compare essential parts of URLs: schema, host, port, and username.\n *\n * any_url compares 0 with any other URL.\n *\n * pres: and im: URIs compares 0 with SIP URIs.\n *\n * @note\n * The @a a and @a b must be pointers to URL structures.\n *\n * @note Currently, the url parameters are not compared. This is because the\n * url_cmp() is used to sort URLs: taking parameters into account makes that\n * impossible.\n */\nint url_cmp(url_t const *a, url_t const *b)\n{\n  int rv;\n  int url_type;\n\n  if ((a && a->url_type == url_any) || (b && b->url_type == url_any))\n    return 0;\n\n  if (!a || !b)\n    return (a != NULL) - (b != NULL);\n\n  if ((rv = a->url_type - b->url_type)) {\n#if 0\n    /* presence and instant messaging URLs match magically with SIP */\n    enum url_type_e a_type = a->url_type;\n    enum url_type_e b_type = b->url_type;\n\n    if (a_type == url_im || a_type == url_pres)\n      a_type = url_sip;\n\n    if (b_type == url_im || b_type == url_pres)\n      b_type = url_sip;\n\n    if (a_type != b_type)\n#endif\n      return rv;\n  }\n\n  url_type = a->url_type;\t/* Or b->url_type, they are equal! */\n\n  if (url_type <= url_unknown &&\n      ((rv = !a->url_scheme - !b->url_scheme) ||\n       (a->url_scheme && b->url_scheme &&\n\t(rv = strcasecmp(a->url_scheme, b->url_scheme)))))\n    return rv;\n\n  if ((rv = host_cmp(a->url_host, b->url_host)))\n    return rv;\n\n  if (a->url_port != b->url_port) {\n    char const *a_port;\n    char const *b_port;\n\n    if (url_type != url_sip && url_type != url_sips)\n      a_port = b_port = url_port_default((enum url_type_e)url_type);\n    else if (host_is_ip_address(a->url_host))\n      a_port = b_port = url_port_default((enum url_type_e)url_type);\n    else\n      a_port = b_port = \"\";\n\n    if (a->url_port) a_port = a->url_port;\n    if (b->url_port) b_port = b->url_port;\n\n    if ((rv = strcmp(a_port, b_port)))\n      return rv;\n  }\n\n  if (a->url_user != b->url_user) {\n    if (a->url_user == NULL) return -1;\n    if (b->url_user == NULL) return +1;\n    switch (url_type) {\n    case url_tel: case url_modem: case url_fax:\n      rv = url_tel_cmp_numbers(a->url_user, b->url_user);\n      break;\n    default:\n      rv = strcmp(a->url_user, b->url_user);\n      break;\n    }\n    if (rv)\n      return rv;\n  }\n\n#if 0\n  if (a->url_path != b->url_path) {\n    if (a->url_path == NULL) return -1;\n    if (b->url_path == NULL) return +1;\n    if ((rv = strcmp(a->url_path, b->url_path)))\n      return rv;\n  }\n#endif\n\n  return 0;\n}\n\nstatic\nint url_tel_cmp_numbers(char const *A, char const *B)\n{\n  short a, b;\n  int rv;\n\n  while (*A && *B) {\n    #define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    /* Skip visual-separators */\n    do {\n      a = *A++;\n      if (a == '%' && IS_HEX(A[0]) && IS_HEX(A[1]))\n\ta = (UNHEX(A[0]) << 4) | UNHEX(A[1]), A +=2;\n    } while (a == ' ' || a == '-' || a == '.' || a == '(' || a == ')');\n\n    if (isupper(a))\n      a = tolower(a);\n\n    do {\n      b = *B++;\n      if (b == '%' && IS_HEX(B[0]) && IS_HEX(B[1]))\n\tb = (UNHEX(B[0]) << 4) | UNHEX(B[1]), B +=2;\n    } while (b == ' ' || b == '-' || b == '.' || b == '(' || b == ')');\n\n    if (isupper(b))\n      b = tolower(b);\n\n    if ((rv = a - b))\n      return rv;\n  }\n\n  return (int)*A - (int)*B;\n}\n\n/**Conservative comparison of urls.\n *\n * Compare all parts of URLs.\n *\n * @note\n * The @a a and @a b must be pointers to URL structures.\n *\n */\nint url_cmp_all(url_t const *a, url_t const *b)\n{\n  int rv, url_type;\n\n  if (!a || !b)\n    return (a != NULL) - (b != NULL);\n\n  if ((rv = a->url_type - b->url_type))\n    return rv;\n\n  url_type = a->url_type;\t/* Or b->url_type, they are equal! */\n\n  if (url_type <= url_unknown &&\n      ((rv = !a->url_scheme - !b->url_scheme) ||\n       (a->url_scheme && b->url_scheme &&\n\t(rv = strcasecmp(a->url_scheme, b->url_scheme)))))\n    return rv;\n\n  if ((rv = a->url_root - b->url_root))\n    return rv;\n\n  if ((rv = host_cmp(a->url_host, b->url_host)))\n    return rv;\n\n  if (a->url_port != b->url_port) {\n    char const *a_port;\n    char const *b_port;\n\n    if (url_type != url_sip && url_type != url_sips)\n      a_port = b_port = url_port_default((enum url_type_e)url_type);\n    else if (host_is_ip_address(a->url_host))\n      a_port = b_port = url_port_default((enum url_type_e)url_type);\n    else\n      a_port = b_port = \"\";\n\n    if (a->url_port) a_port = a->url_port;\n    if (b->url_port) b_port = b->url_port;\n\n    if ((rv = strcmp(a_port, b_port)))\n      return rv;\n  }\n\n  if (a->url_user != b->url_user) {\n    if (a->url_user == NULL) return -1;\n    if (b->url_user == NULL) return +1;\n\n    switch (url_type) {\n    case url_tel: case url_modem: case url_fax:\n      rv = url_tel_cmp_numbers(a->url_user, b->url_user);\n      break;\n    default:\n      rv = strcmp(a->url_user, b->url_user);\n      break;\n    }\n    if (rv)\n      return rv;\n  }\n\n  if (a->url_path != b->url_path) {\n    if (a->url_path == NULL) return -1;\n    if (b->url_path == NULL) return +1;\n    if ((rv = strcmp(a->url_path, b->url_path)))\n      return rv;\n  }\n\n  if (a->url_params != b->url_params) {\n    if (a->url_params == NULL) return -1;\n    if (b->url_params == NULL) return +1;\n    if ((rv = strcmp(a->url_params, b->url_params)))\n      return rv;\n  }\n\n  if (a->url_headers != b->url_headers) {\n    if (a->url_headers == NULL) return -1;\n    if (b->url_headers == NULL) return +1;\n    if ((rv = strcmp(a->url_headers, b->url_headers)))\n      return rv;\n  }\n\n  if (a->url_headers != b->url_headers) {\n    if (a->url_headers == NULL) return -1;\n    if (b->url_headers == NULL) return +1;\n    if ((rv = strcmp(a->url_headers, b->url_headers)))\n      return rv;\n  }\n\n  if (a->url_fragment != b->url_fragment) {\n    if (a->url_fragment == NULL) return -1;\n    if (b->url_fragment == NULL) return +1;\n    if ((rv = strcmp(a->url_fragment, b->url_fragment)))\n      return rv;\n  }\n\n  return 0;\n}\n\n/** Return default port number corresponding to the url type */\nchar const *url_port_default(enum url_type_e url_type)\n{\n  switch (url_type) {\n  case url_sip:\t\t\t/* \"sip:\" */\n    return \"5060\";\n  case url_sips:\t\t/* \"sips:\" */\n    return \"5061\";\n  case url_http:\t\t/* \"http:\" */\n    return \"80\";\n  case url_https:\t\t/* \"https:\" */\n    return \"443\";\n  case url_ftp:\t\t\t/* \"ftp:\" */\n  case url_file:\t\t/* \"file:\" */\n    return \"21\";\n  case url_rtsp:\t\t/* \"rtsp:\" */\n  case url_rtspu:\t\t/* \"rtspu:\" */\n    return \"554\";\n  case url_mailto:\t\t/* \"mailto:\" */\n    return \"25\";\n\n  case url_any:\t\t\t/* \"*\" */\n    return \"*\";\n\n  case url_msrp:\n  case url_msrps:\n    return \"9999\";\t\t/* XXXX */\n\n  case url_tel:\n  case url_fax:\n  case url_modem:\n  case url_im:\n  case url_pres:\n  case url_cid:\n  case url_wv:\n\n  default:\t\t\t/* Unknown scheme */\n    return \"\";\n  }\n}\n\n/** Return default transport name corresponding to the url type */\nchar const *url_tport_default(enum url_type_e url_type)\n{\n  switch (url_type) {\n  case url_sip:\n    return \"*\";\n  case url_sips:\n    return \"tls\";\n  case url_http:\n    return \"tcp\";\n  case url_https:\n    return \"tls\";\n  case url_ftp:\n  case url_file:\n    return \"tcp\";\n  case url_rtsp:\n    return \"tcp\";\n  case url_rtspu:\n    return \"udp\";\n  case url_mailto:\n    return \"tcp\";\n  case url_msrp:\n    return \"tcp\";\n  case url_msrps:\n    return \"tls\";\n\n  case url_any:\t\t\t/* \"*\" */\n  case url_tel:\n  case url_fax:\n  case url_modem:\n  case url_im:\n  case url_pres:\n  case url_cid:\n  case url_wv:\n\n  default:\t\t\t/* Unknown scheme */\n    return \"*\";\n  }\n}\n\n\n/** Return the URL port string */\nchar const *url_port(url_t const *u)\n{\n  if (!u)\n    return \"\";\n  else if (u->url_port && u->url_port[0])\n    return u->url_port;\n\n  if (u->url_type == url_sips || u->url_type == url_sip)\n    if (!host_is_ip_address(u->url_host))\n      return \"\";\n\n  return url_port_default((enum url_type_e)u->url_type);\n}\n\n/** Sanitize URL.\n *\n * The function url_sanitize() adds a scheme to an incomplete URL.  It\n * modifies its parameter structure @a url.  Currently, the function follows\n * simple heuristics:\n *\n * - URL with host name starting with @c ftp. is an FTP URL\n * - URL with host name starting with @c www. is an HTTP URL\n * - URL with host and path, e.g., @c host/foo;bar, is an HTTP URL\n * - URL with host name, no path is a SIP URL.\n *\n * @param url pointer to URL struct to be sanitized (IN/OUT)\n *\n * @return\n * The function url_sanitize() returns 0 if it considers URL to be\n * sane, and -1 otherwise.\n */\nint url_sanitize(url_t *url)\n{\n  if (!url)\n    return -1;\n  else if (url->url_scheme != NULL)\n    /* xyzzy */;\n  else if (url->url_host == NULL)\n    return -1;\n  else if (strncasecmp(url->url_host, \"ftp.\", strlen(\"ftp.\")) == 0)\n    url->url_type = url_ftp, url->url_scheme = \"ftp\", url->url_root = '/';\n  else if (strncasecmp(url->url_host, \"www.\", strlen(\"www.\")) == 0\n\t   || url->url_path)\n    url->url_type = url_http, url->url_scheme = \"http\", url->url_root = '/';\n  else\n    url->url_type = url_sip, url->url_scheme = \"sip\";\n\n  return 0;\n}\n\n#include <sofia-sip/su_md5.h>\n\nstatic\nvoid canon_update(su_md5_t *md5, char const *s, size_t n, char const *allow)\n{\n  size_t i, j;\n\n  for (i = 0, j = 0; i < n && s[i]; i++) {\n    char c;\n\n    if (s[i] == '%' && i + 2 < n && IS_HEX(s[i+1]) && IS_HEX(s[i+2])) {\n#define   UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n      c = (UNHEX(s[i+1]) << 4) | UNHEX(s[i+2]);\n#undef    UNHEX\n      if (c != '%' && c > ' ' && c < '\\177' &&\n\t  (!strchr(EXCLUDED, c) || strchr(allow, c))) {\n\tif (i != j)\n\t  su_md5_iupdate(md5, s + j, i - j);\n\tsu_md5_iupdate(md5, &c, 1);\n\tj = i + 3;\n      }\n      i += 2;\n    }\n  }\n\n  if (i != j)\n    su_md5_iupdate(md5, s + j, i - j);\n}\n\n/** Update MD5 sum with url-string contents */\nstatic\nvoid url_string_update(su_md5_t *md5, char const *s)\n{\n  size_t n, p;\n  int have_authority = 1;\n  enum url_type_e type = url_any;\n  char const *at, *colon;\n  char schema[48];\n\n  if (s == NULL || strlen(s) == 0 || strcmp(s, \"*\") == 0) {\n    su_md5_update(md5, \"*\\0\\0*\", 4);\n    return;\n  }\n\n  n = strcspn(s, \":/?#\");\n  if (n >= sizeof schema) {\n    su_md5_update(md5, \":\", 1);\n  }\n  else if (n && s[n] == ':' ) {\n    at = url_canonize(schema, s, n, 0, \"+\");\n\n    type = url_get_type(schema, at - schema);\n    su_md5_iupdate(md5, schema, at - schema);\n\n    have_authority = !url_type_is_opaque(type);\n    s += n + 1;\n  }\n  else {\n    su_md5_update(md5, \"\", 1);\n  }\n\n  if (type == url_sip || type == url_sips) {\n    /* SIP URL may have /;? in user part but no path */\n    /* user-unreserved  =  \"&\" / \"=\" / \"+\" / \"$\" / \",\" / \";\" / \"?\" / \"/\" */\n    /* Some #*@#* phones include unescaped # there, too */\n    n = strcspn(s, \"@/;?#\");\n    p = strcspn(s + n, \"@\");\n    if (s[n + p] == '@') {\n      n += p;\n      /* Ignore password in hash */\n      colon = memchr(s, ':', n);\n      p = colon ? (size_t)(colon - s) : n;\n      canon_update(md5, s, p, SIP_USER_UNRESERVED);\n      s += n + 1; n = 0;\n    }\n    else\n      su_md5_iupdate(md5, \"\", 1);\t/* user */\n    n += strcspn(s + n, \"/;?#\");\n  }\n  else if (have_authority) {\n    if (type == url_wv) {    /* WV URL may have / in user part */\n      n = strcspn(s, \"@;?#\");\n    }\n    else if (type != url_wv && s[0] == '/' && s[1] != '/') {\n      /* foo:/bar */\n      su_md5_update(md5, \"\\0\\0\", 2); /* user, host */\n      su_md5_striupdate(md5, url_port_default(type));\n      return;\n    }\n    else if (s[0] == '/' && s[1] == '/') {\n      /* We have authority, / / foo or foo */\n      s += 2;\n      n = strcspn(s, \"/?#@[]\");\n    }\n    else\n      n = strcspn(s, \"@;/?#\");\n\n    if (s[n] == '@') {\n      /* Ignore password in hash */\n      colon = type != url_unknown ? memchr(s, ':', n) : NULL;\n      p = colon ? (size_t)(colon - s) : n;\n      canon_update(md5, s, p, SIP_USER_UNRESERVED);\n      s += n + 1;\n      n = strcspn(s, \"/;?#\");\t/* Until path, query or fragment */\n    }\n    else {\n      su_md5_iupdate(md5, \"\", 1);\t/* user */\n      n += strcspn(s + n, \"/;?#\");\t/* Until path, query or fragment */\n    }\n  }\n  else /* if (!have_authority) */ {\n    n = strcspn(s, \":/;?#\");\t/* Until pass, path, query or fragment */\n\n    canon_update(md5, s, n, \"\"); /* user */\n    su_md5_update(md5, \"\\0\", 1); /* host, no port */\n    su_md5_striupdate(md5, url_port_default(type));\n    return;\n  }\n\n  if (n > 0 && s[0] == '[') {\t/* IPv6reference */\n    colon = memchr(s, ']', n);\n    if (colon == NULL || ++colon == s + n || *colon != ':')\n      colon = NULL;\n  }\n  else\n    colon = memchr(s, ':', n);\n\n  if (colon) {\n    canon_update(md5, s, colon - s, \"\"); /* host */\n    canon_update(md5, colon + 1, (s + n) - (colon + 1), \"\");\n  }\n  else {\n    canon_update(md5, s, n, \"\"); /* host */\n    su_md5_strupdate(md5, url_port_default(type));\t/* port */\n  }\n\n  /* ignore parameters/path/headers.... */\n}\n\n\n/** Update md5 digest with contents of URL.\n *\n */\nvoid url_update(su_md5_t *md5, url_t const *url)\n{\n  if (url_string_p((url_string_t *)url)) {\n    url_string_update(md5, (char const *)url);\n  }\n  else {\n    SU_MD5_STRI0UPDATE(md5, url->url_scheme);\n    SU_MD5_STRI0UPDATE(md5, url->url_user);\n    SU_MD5_STRI0UPDATE(md5, url->url_host);\n    su_md5_striupdate(md5, URL_PORT(url));\n    /* XXX - parameters/path.... */\n    /* SU_MD5_STRI0UPDATE(md5, url->url_path); */\n  }\n}\n\n/** Calculate a digest from URL contents. */\nvoid url_digest(void *hash, int hsize, url_t const *url, char const *key)\n{\n  su_md5_t md5[1];\n  uint8_t digest[SU_MD5_DIGEST_SIZE];\n\n  su_md5_init(md5);\n  if (key) su_md5_strupdate(md5, key);\n  url_update(md5, url);\n  su_md5_digest(md5, digest);\n\n  if (hsize > SU_MD5_DIGEST_SIZE) {\n    memset((char *)hash + SU_MD5_DIGEST_SIZE, 0, hsize - SU_MD5_DIGEST_SIZE);\n    hsize = SU_MD5_DIGEST_SIZE;\n  }\n\n  memcpy(hash, digest, hsize);\n}\n\n/** Convert a URL query to a header string.\n *\n * URL query is converted by replacing each \"=\" in header name \"=\" value\n * pair with semicolon (\":\"), and the \"&\" separating header-name-value pairs\n * with line feed (\"\\n\"). The \"body\" pseudoheader is moved last in the\n * string. The %-escaping is removed. Note that if the @a query contains %00,\n * the resulting string will be truncated.\n *\n * @param home memory home used to alloate string (if NULL, malloc() it)\n * @param query query part from SIP URL\n *\n * The result string is allocated from @a home, and it can be used as\n * argument to msg_header_parse_str(), msg_header_add_str() or\n * SIPTAG_HEADER_STR().\n *\n * @sa msg_header_add_str(), SIPTAG_HEADER_STR(),\n * sip_headers_as_url_query(), sip_url_query_as_taglist(),\n * @RFC3261 section 19.1.1 \"Headers\", #url_t, url_s#url_headers,\n * url_unescape(), url_unescape_to()\n *\n * @since New in @VERSION_1_12_4.\n */\nchar *url_query_as_header_string(su_home_t *home,\n\t\t\t\t char const *query)\n{\n  size_t i, j, n, b_start = 0, b_len = 0;\n  char *s = su_strdup(home, query);\n\n  if (!s)\n    return NULL;\n\n  for (i = 0, j = 0; s[i];) {\n    n = strcspn(s + i, \"=\");\n    if (!s[i + n])\n      break;\n    if (n == 4 && strncasecmp(s + i, \"body\", 4) == 0) {\n      if (b_start)\n\tbreak;\n      b_start = i + n + 1, b_len = strcspn(s + b_start, \"&\");\n      i = b_start + b_len + 1;\n      continue;\n    }\n    if (i != j)\n      memmove(s + j, s + i, n);\n    s[j + n] = ':';\n    i += n + 1, j += n + 1;\n    n = strcspn(s + i, \"&\");\n    j += url_unescape_to(s + j, s + i, n);\n    i += n;\n    if (s[i]) {\n      s[j++] = '\\n', i++;\n    }\n  }\n\n  if (s[i])\n    return (void)su_free(home, s), NULL;\n\n  if (b_start) {\n    s[j++] = '\\n', s[j++] = '\\n';\n    j += url_unescape_to(s + j, query + b_start, b_len);\n  }\n  s[j] = '\\0'; assert(j <= i);\n\n  return s;\n}\n"], "filenames": ["libsofia-sip-ua/url/url.c"], "buggy_code_start_loc": [366], "buggy_code_end_loc": [366], "fixing_code_start_loc": [367], "fixing_code_end_loc": [368], "type": "CWE-787", "message": "An issue was discovered in the libsofia-sip fork in drachtio-server before 0.8.19. It allows remote attackers to cause a denial of service (daemon crash) via a crafted UDP message that causes a url_canonize2 heap-based buffer over-read because of an off-by-one error.", "other": {"cve": {"id": "CVE-2022-47517", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-18T05:15:11.300", "lastModified": "2022-12-22T14:34:26.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the libsofia-sip fork in drachtio-server before 0.8.19. It allows remote attackers to cause a denial of service (daemon crash) via a crafted UDP message that causes a url_canonize2 heap-based buffer over-read because of an off-by-one error."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:drachtio:drachtio-server:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.19", "matchCriteriaId": "24320D84-70B3-4A0E-AE01-D5DCF0AD5848"}]}]}], "references": [{"url": "https://github.com/davehorton/sofia-sip/commit/22c1bd191f0acbf11f0c0fbea1845d9bf9dcd47e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/davehorton/sofia-sip/commit/bfc79d85c8f3a4798a3305fb98f5a11c11d0d29f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/drachtio/drachtio-server/issues/243", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/davehorton/sofia-sip/commit/22c1bd191f0acbf11f0c0fbea1845d9bf9dcd47e"}}