{"buggy_code": ["/*\n * Performance events x86 architecture code\n *\n *  Copyright (C) 2008 Thomas Gleixner <tglx@linutronix.de>\n *  Copyright (C) 2008-2009 Red Hat, Inc., Ingo Molnar\n *  Copyright (C) 2009 Jaswinder Singh Rajput\n *  Copyright (C) 2009 Advanced Micro Devices, Inc., Robert Richter\n *  Copyright (C) 2008-2009 Red Hat, Inc., Peter Zijlstra <pzijlstr@redhat.com>\n *  Copyright (C) 2009 Intel Corporation, <markus.t.metzger@intel.com>\n *  Copyright (C) 2009 Google, Inc., Stephane Eranian\n *\n *  For licencing details see kernel-base/COPYING\n */\n\n#include <linux/perf_event.h>\n#include <linux/capability.h>\n#include <linux/notifier.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n#include <linux/kdebug.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/bitops.h>\n\n#include <asm/apic.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/compat.h>\n#include <asm/smp.h>\n\n#if 0\n#undef wrmsrl\n#define wrmsrl(msr, val) \t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\ttrace_printk(\"wrmsrl(%lx, %lx)\\n\", (unsigned long)(msr),\\\n\t\t\t(unsigned long)(val));\t\t\t\\\n\tnative_write_msr((msr), (u32)((u64)(val)), \t\t\\\n\t\t\t(u32)((u64)(val) >> 32));\t\t\\\n} while (0)\n#endif\n\n/*\n * best effort, GUP based copy_from_user() that assumes IRQ or NMI context\n */\nstatic unsigned long\ncopy_from_user_nmi(void *to, const void __user *from, unsigned long n)\n{\n\tunsigned long offset, addr = (unsigned long)from;\n\tunsigned long size, len = 0;\n\tstruct page *page;\n\tvoid *map;\n\tint ret;\n\n\tdo {\n\t\tret = __get_user_pages_fast(addr, 1, 0, &page);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\toffset = addr & (PAGE_SIZE - 1);\n\t\tsize = min(PAGE_SIZE - offset, n - len);\n\n\t\tmap = kmap_atomic(page);\n\t\tmemcpy(to, map+offset, size);\n\t\tkunmap_atomic(map);\n\t\tput_page(page);\n\n\t\tlen  += size;\n\t\tto   += size;\n\t\taddr += size;\n\n\t} while (len < n);\n\n\treturn len;\n}\n\nstruct event_constraint {\n\tunion {\n\t\tunsigned long\tidxmsk[BITS_TO_LONGS(X86_PMC_IDX_MAX)];\n\t\tu64\t\tidxmsk64;\n\t};\n\tu64\tcode;\n\tu64\tcmask;\n\tint\tweight;\n};\n\nstruct amd_nb {\n\tint nb_id;  /* NorthBridge id */\n\tint refcnt; /* reference count */\n\tstruct perf_event *owners[X86_PMC_IDX_MAX];\n\tstruct event_constraint event_constraints[X86_PMC_IDX_MAX];\n};\n\nstruct intel_percore;\n\n#define MAX_LBR_ENTRIES\t\t16\n\nstruct cpu_hw_events {\n\t/*\n\t * Generic x86 PMC bits\n\t */\n\tstruct perf_event\t*events[X86_PMC_IDX_MAX]; /* in counter order */\n\tunsigned long\t\tactive_mask[BITS_TO_LONGS(X86_PMC_IDX_MAX)];\n\tunsigned long\t\trunning[BITS_TO_LONGS(X86_PMC_IDX_MAX)];\n\tint\t\t\tenabled;\n\n\tint\t\t\tn_events;\n\tint\t\t\tn_added;\n\tint\t\t\tn_txn;\n\tint\t\t\tassign[X86_PMC_IDX_MAX]; /* event to counter assignment */\n\tu64\t\t\ttags[X86_PMC_IDX_MAX];\n\tstruct perf_event\t*event_list[X86_PMC_IDX_MAX]; /* in enabled order */\n\n\tunsigned int\t\tgroup_flag;\n\n\t/*\n\t * Intel DebugStore bits\n\t */\n\tstruct debug_store\t*ds;\n\tu64\t\t\tpebs_enabled;\n\n\t/*\n\t * Intel LBR bits\n\t */\n\tint\t\t\t\tlbr_users;\n\tvoid\t\t\t\t*lbr_context;\n\tstruct perf_branch_stack\tlbr_stack;\n\tstruct perf_branch_entry\tlbr_entries[MAX_LBR_ENTRIES];\n\n\t/*\n\t * Intel percore register state.\n\t * Coordinate shared resources between HT threads.\n\t */\n\tint\t\t\t\tpercore_used; /* Used by this CPU? */\n\tstruct intel_percore\t\t*per_core;\n\n\t/*\n\t * AMD specific bits\n\t */\n\tstruct amd_nb\t\t*amd_nb;\n};\n\n#define __EVENT_CONSTRAINT(c, n, m, w) {\\\n\t{ .idxmsk64 = (n) },\t\t\\\n\t.code = (c),\t\t\t\\\n\t.cmask = (m),\t\t\t\\\n\t.weight = (w),\t\t\t\\\n}\n\n#define EVENT_CONSTRAINT(c, n, m)\t\\\n\t__EVENT_CONSTRAINT(c, n, m, HWEIGHT(n))\n\n/*\n * Constraint on the Event code.\n */\n#define INTEL_EVENT_CONSTRAINT(c, n)\t\\\n\tEVENT_CONSTRAINT(c, n, ARCH_PERFMON_EVENTSEL_EVENT)\n\n/*\n * Constraint on the Event code + UMask + fixed-mask\n *\n * filter mask to validate fixed counter events.\n * the following filters disqualify for fixed counters:\n *  - inv\n *  - edge\n *  - cnt-mask\n *  The other filters are supported by fixed counters.\n *  The any-thread option is supported starting with v3.\n */\n#define FIXED_EVENT_CONSTRAINT(c, n)\t\\\n\tEVENT_CONSTRAINT(c, (1ULL << (32+n)), X86_RAW_EVENT_MASK)\n\n/*\n * Constraint on the Event code + UMask\n */\n#define INTEL_UEVENT_CONSTRAINT(c, n)\t\\\n\tEVENT_CONSTRAINT(c, n, INTEL_ARCH_EVENT_MASK)\n\n#define EVENT_CONSTRAINT_END\t\t\\\n\tEVENT_CONSTRAINT(0, 0, 0)\n\n#define for_each_event_constraint(e, c)\t\\\n\tfor ((e) = (c); (e)->weight; (e)++)\n\n/*\n * Extra registers for specific events.\n * Some events need large masks and require external MSRs.\n * Define a mapping to these extra registers.\n */\nstruct extra_reg {\n\tunsigned int\t\tevent;\n\tunsigned int\t\tmsr;\n\tu64\t\t\tconfig_mask;\n\tu64\t\t\tvalid_mask;\n};\n\n#define EVENT_EXTRA_REG(e, ms, m, vm) {\t\\\n\t.event = (e),\t\t\\\n\t.msr = (ms),\t\t\\\n\t.config_mask = (m),\t\\\n\t.valid_mask = (vm),\t\\\n\t}\n#define INTEL_EVENT_EXTRA_REG(event, msr, vm)\t\\\n\tEVENT_EXTRA_REG(event, msr, ARCH_PERFMON_EVENTSEL_EVENT, vm)\n#define EVENT_EXTRA_END EVENT_EXTRA_REG(0, 0, 0, 0)\n\nunion perf_capabilities {\n\tstruct {\n\t\tu64\tlbr_format    : 6;\n\t\tu64\tpebs_trap     : 1;\n\t\tu64\tpebs_arch_reg : 1;\n\t\tu64\tpebs_format   : 4;\n\t\tu64\tsmm_freeze    : 1;\n\t};\n\tu64\tcapabilities;\n};\n\n/*\n * struct x86_pmu - generic x86 pmu\n */\nstruct x86_pmu {\n\t/*\n\t * Generic x86 PMC bits\n\t */\n\tconst char\t*name;\n\tint\t\tversion;\n\tint\t\t(*handle_irq)(struct pt_regs *);\n\tvoid\t\t(*disable_all)(void);\n\tvoid\t\t(*enable_all)(int added);\n\tvoid\t\t(*enable)(struct perf_event *);\n\tvoid\t\t(*disable)(struct perf_event *);\n\tint\t\t(*hw_config)(struct perf_event *event);\n\tint\t\t(*schedule_events)(struct cpu_hw_events *cpuc, int n, int *assign);\n\tunsigned\teventsel;\n\tunsigned\tperfctr;\n\tu64\t\t(*event_map)(int);\n\tint\t\tmax_events;\n\tint\t\tnum_counters;\n\tint\t\tnum_counters_fixed;\n\tint\t\tcntval_bits;\n\tu64\t\tcntval_mask;\n\tint\t\tapic;\n\tu64\t\tmax_period;\n\tstruct event_constraint *\n\t\t\t(*get_event_constraints)(struct cpu_hw_events *cpuc,\n\t\t\t\t\t\t struct perf_event *event);\n\n\tvoid\t\t(*put_event_constraints)(struct cpu_hw_events *cpuc,\n\t\t\t\t\t\t struct perf_event *event);\n\tstruct event_constraint *event_constraints;\n\tstruct event_constraint *percore_constraints;\n\tvoid\t\t(*quirks)(void);\n\tint\t\tperfctr_second_write;\n\n\tint\t\t(*cpu_prepare)(int cpu);\n\tvoid\t\t(*cpu_starting)(int cpu);\n\tvoid\t\t(*cpu_dying)(int cpu);\n\tvoid\t\t(*cpu_dead)(int cpu);\n\n\t/*\n\t * Intel Arch Perfmon v2+\n\t */\n\tu64\t\t\tintel_ctrl;\n\tunion perf_capabilities intel_cap;\n\n\t/*\n\t * Intel DebugStore bits\n\t */\n\tint\t\tbts, pebs;\n\tint\t\tbts_active, pebs_active;\n\tint\t\tpebs_record_size;\n\tvoid\t\t(*drain_pebs)(struct pt_regs *regs);\n\tstruct event_constraint *pebs_constraints;\n\n\t/*\n\t * Intel LBR\n\t */\n\tunsigned long\tlbr_tos, lbr_from, lbr_to; /* MSR base regs       */\n\tint\t\tlbr_nr;\t\t\t   /* hardware stack size */\n\n\t/*\n\t * Extra registers for events\n\t */\n\tstruct extra_reg *extra_regs;\n};\n\nstatic struct x86_pmu x86_pmu __read_mostly;\n\nstatic DEFINE_PER_CPU(struct cpu_hw_events, cpu_hw_events) = {\n\t.enabled = 1,\n};\n\nstatic int x86_perf_event_set_period(struct perf_event *event);\n\n/*\n * Generalized hw caching related hw_event table, filled\n * in on a per model basis. A value of 0 means\n * 'not supported', -1 means 'hw_event makes no sense on\n * this CPU', any other value means the raw hw_event\n * ID.\n */\n\n#define C(x) PERF_COUNT_HW_CACHE_##x\n\nstatic u64 __read_mostly hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX];\nstatic u64 __read_mostly hw_cache_extra_regs\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX];\n\n/*\n * Propagate event elapsed time into the generic event.\n * Can only be executed on the CPU where the event is active.\n * Returns the delta events processed.\n */\nstatic u64\nx86_perf_event_update(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint shift = 64 - x86_pmu.cntval_bits;\n\tu64 prev_raw_count, new_raw_count;\n\tint idx = hwc->idx;\n\ts64 delta;\n\n\tif (idx == X86_PMC_IDX_FIXED_BTS)\n\t\treturn 0;\n\n\t/*\n\t * Careful: an NMI might modify the previous event value.\n\t *\n\t * Our tactic to handle this is to first atomically read and\n\t * exchange a new raw count - then add that new-prev delta\n\t * count to the generic event atomically:\n\t */\nagain:\n\tprev_raw_count = local64_read(&hwc->prev_count);\n\trdmsrl(hwc->event_base, new_raw_count);\n\n\tif (local64_cmpxchg(&hwc->prev_count, prev_raw_count,\n\t\t\t\t\tnew_raw_count) != prev_raw_count)\n\t\tgoto again;\n\n\t/*\n\t * Now we have the new raw value and have updated the prev\n\t * timestamp already. We can now calculate the elapsed delta\n\t * (event-)time and add that to the generic event.\n\t *\n\t * Careful, not all hw sign-extends above the physical width\n\t * of the count.\n\t */\n\tdelta = (new_raw_count << shift) - (prev_raw_count << shift);\n\tdelta >>= shift;\n\n\tlocal64_add(delta, &event->count);\n\tlocal64_sub(delta, &hwc->period_left);\n\n\treturn new_raw_count;\n}\n\n/* using X86_FEATURE_PERFCTR_CORE to later implement ALTERNATIVE() here */\nstatic inline int x86_pmu_addr_offset(int index)\n{\n\tif (boot_cpu_has(X86_FEATURE_PERFCTR_CORE))\n\t\treturn index << 1;\n\treturn index;\n}\n\nstatic inline unsigned int x86_pmu_config_addr(int index)\n{\n\treturn x86_pmu.eventsel + x86_pmu_addr_offset(index);\n}\n\nstatic inline unsigned int x86_pmu_event_addr(int index)\n{\n\treturn x86_pmu.perfctr + x86_pmu_addr_offset(index);\n}\n\n/*\n * Find and validate any extra registers to set up.\n */\nstatic int x86_pmu_extra_regs(u64 config, struct perf_event *event)\n{\n\tstruct extra_reg *er;\n\n\tevent->hw.extra_reg = 0;\n\tevent->hw.extra_config = 0;\n\n\tif (!x86_pmu.extra_regs)\n\t\treturn 0;\n\n\tfor (er = x86_pmu.extra_regs; er->msr; er++) {\n\t\tif (er->event != (config & er->config_mask))\n\t\t\tcontinue;\n\t\tif (event->attr.config1 & ~er->valid_mask)\n\t\t\treturn -EINVAL;\n\t\tevent->hw.extra_reg = er->msr;\n\t\tevent->hw.extra_config = event->attr.config1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic atomic_t active_events;\nstatic DEFINE_MUTEX(pmc_reserve_mutex);\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\nstatic bool reserve_pmc_hardware(void)\n{\n\tint i;\n\n\tfor (i = 0; i < x86_pmu.num_counters; i++) {\n\t\tif (!reserve_perfctr_nmi(x86_pmu_event_addr(i)))\n\t\t\tgoto perfctr_fail;\n\t}\n\n\tfor (i = 0; i < x86_pmu.num_counters; i++) {\n\t\tif (!reserve_evntsel_nmi(x86_pmu_config_addr(i)))\n\t\t\tgoto eventsel_fail;\n\t}\n\n\treturn true;\n\neventsel_fail:\n\tfor (i--; i >= 0; i--)\n\t\trelease_evntsel_nmi(x86_pmu_config_addr(i));\n\n\ti = x86_pmu.num_counters;\n\nperfctr_fail:\n\tfor (i--; i >= 0; i--)\n\t\trelease_perfctr_nmi(x86_pmu_event_addr(i));\n\n\treturn false;\n}\n\nstatic void release_pmc_hardware(void)\n{\n\tint i;\n\n\tfor (i = 0; i < x86_pmu.num_counters; i++) {\n\t\trelease_perfctr_nmi(x86_pmu_event_addr(i));\n\t\trelease_evntsel_nmi(x86_pmu_config_addr(i));\n\t}\n}\n\n#else\n\nstatic bool reserve_pmc_hardware(void) { return true; }\nstatic void release_pmc_hardware(void) {}\n\n#endif\n\nstatic bool check_hw_exists(void)\n{\n\tu64 val, val_new = 0;\n\tint i, reg, ret = 0;\n\n\t/*\n\t * Check to see if the BIOS enabled any of the counters, if so\n\t * complain and bail.\n\t */\n\tfor (i = 0; i < x86_pmu.num_counters; i++) {\n\t\treg = x86_pmu_config_addr(i);\n\t\tret = rdmsrl_safe(reg, &val);\n\t\tif (ret)\n\t\t\tgoto msr_fail;\n\t\tif (val & ARCH_PERFMON_EVENTSEL_ENABLE)\n\t\t\tgoto bios_fail;\n\t}\n\n\tif (x86_pmu.num_counters_fixed) {\n\t\treg = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\tret = rdmsrl_safe(reg, &val);\n\t\tif (ret)\n\t\t\tgoto msr_fail;\n\t\tfor (i = 0; i < x86_pmu.num_counters_fixed; i++) {\n\t\t\tif (val & (0x03 << i*4))\n\t\t\t\tgoto bios_fail;\n\t\t}\n\t}\n\n\t/*\n\t * Now write a value and read it back to see if it matches,\n\t * this is needed to detect certain hardware emulators (qemu/kvm)\n\t * that don't trap on the MSR access and always return 0s.\n\t */\n\tval = 0xabcdUL;\n\tret = checking_wrmsrl(x86_pmu_event_addr(0), val);\n\tret |= rdmsrl_safe(x86_pmu_event_addr(0), &val_new);\n\tif (ret || val != val_new)\n\t\tgoto msr_fail;\n\n\treturn true;\n\nbios_fail:\n\tprintk(KERN_CONT \"Broken BIOS detected, using software events only.\\n\");\n\tprintk(KERN_ERR FW_BUG \"the BIOS has corrupted hw-PMU resources (MSR %x is %Lx)\\n\", reg, val);\n\treturn false;\n\nmsr_fail:\n\tprintk(KERN_CONT \"Broken PMU hardware detected, using software events only.\\n\");\n\treturn false;\n}\n\nstatic void reserve_ds_buffers(void);\nstatic void release_ds_buffers(void);\n\nstatic void hw_perf_event_destroy(struct perf_event *event)\n{\n\tif (atomic_dec_and_mutex_lock(&active_events, &pmc_reserve_mutex)) {\n\t\trelease_pmc_hardware();\n\t\trelease_ds_buffers();\n\t\tmutex_unlock(&pmc_reserve_mutex);\n\t}\n}\n\nstatic inline int x86_pmu_initialized(void)\n{\n\treturn x86_pmu.handle_irq != NULL;\n}\n\nstatic inline int\nset_ext_hw_attr(struct hw_perf_event *hwc, struct perf_event *event)\n{\n\tstruct perf_event_attr *attr = &event->attr;\n\tunsigned int cache_type, cache_op, cache_result;\n\tu64 config, val;\n\n\tconfig = attr->config;\n\n\tcache_type = (config >>  0) & 0xff;\n\tif (cache_type >= PERF_COUNT_HW_CACHE_MAX)\n\t\treturn -EINVAL;\n\n\tcache_op = (config >>  8) & 0xff;\n\tif (cache_op >= PERF_COUNT_HW_CACHE_OP_MAX)\n\t\treturn -EINVAL;\n\n\tcache_result = (config >> 16) & 0xff;\n\tif (cache_result >= PERF_COUNT_HW_CACHE_RESULT_MAX)\n\t\treturn -EINVAL;\n\n\tval = hw_cache_event_ids[cache_type][cache_op][cache_result];\n\n\tif (val == 0)\n\t\treturn -ENOENT;\n\n\tif (val == -1)\n\t\treturn -EINVAL;\n\n\thwc->config |= val;\n\tattr->config1 = hw_cache_extra_regs[cache_type][cache_op][cache_result];\n\treturn x86_pmu_extra_regs(val, event);\n}\n\nstatic int x86_setup_perfctr(struct perf_event *event)\n{\n\tstruct perf_event_attr *attr = &event->attr;\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 config;\n\n\tif (!is_sampling_event(event)) {\n\t\thwc->sample_period = x86_pmu.max_period;\n\t\thwc->last_period = hwc->sample_period;\n\t\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\t} else {\n\t\t/*\n\t\t * If we have a PMU initialized but no APIC\n\t\t * interrupts, we cannot sample hardware\n\t\t * events (user-space has to fall back and\n\t\t * sample via a hrtimer based software event):\n\t\t */\n\t\tif (!x86_pmu.apic)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (attr->type == PERF_TYPE_RAW)\n\t\treturn x86_pmu_extra_regs(event->attr.config, event);\n\n\tif (attr->type == PERF_TYPE_HW_CACHE)\n\t\treturn set_ext_hw_attr(hwc, event);\n\n\tif (attr->config >= x86_pmu.max_events)\n\t\treturn -EINVAL;\n\n\t/*\n\t * The generic map:\n\t */\n\tconfig = x86_pmu.event_map(attr->config);\n\n\tif (config == 0)\n\t\treturn -ENOENT;\n\n\tif (config == -1LL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Branch tracing:\n\t */\n\tif ((attr->config == PERF_COUNT_HW_BRANCH_INSTRUCTIONS) &&\n\t    (hwc->sample_period == 1)) {\n\t\t/* BTS is not supported by this architecture. */\n\t\tif (!x86_pmu.bts_active)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t/* BTS is currently only allowed for user-mode. */\n\t\tif (!attr->exclude_kernel)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\thwc->config |= config;\n\n\treturn 0;\n}\n\nstatic int x86_pmu_hw_config(struct perf_event *event)\n{\n\tif (event->attr.precise_ip) {\n\t\tint precise = 0;\n\n\t\t/* Support for constant skid */\n\t\tif (x86_pmu.pebs_active) {\n\t\t\tprecise++;\n\n\t\t\t/* Support for IP fixup */\n\t\t\tif (x86_pmu.lbr_nr)\n\t\t\t\tprecise++;\n\t\t}\n\n\t\tif (event->attr.precise_ip > precise)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/*\n\t * Generate PMC IRQs:\n\t * (keep 'enabled' bit clear for now)\n\t */\n\tevent->hw.config = ARCH_PERFMON_EVENTSEL_INT;\n\n\t/*\n\t * Count user and OS events unless requested not to\n\t */\n\tif (!event->attr.exclude_user)\n\t\tevent->hw.config |= ARCH_PERFMON_EVENTSEL_USR;\n\tif (!event->attr.exclude_kernel)\n\t\tevent->hw.config |= ARCH_PERFMON_EVENTSEL_OS;\n\n\tif (event->attr.type == PERF_TYPE_RAW)\n\t\tevent->hw.config |= event->attr.config & X86_RAW_EVENT_MASK;\n\n\treturn x86_setup_perfctr(event);\n}\n\n/*\n * Setup the hardware configuration for a given attr_type\n */\nstatic int __x86_pmu_event_init(struct perf_event *event)\n{\n\tint err;\n\n\tif (!x86_pmu_initialized())\n\t\treturn -ENODEV;\n\n\terr = 0;\n\tif (!atomic_inc_not_zero(&active_events)) {\n\t\tmutex_lock(&pmc_reserve_mutex);\n\t\tif (atomic_read(&active_events) == 0) {\n\t\t\tif (!reserve_pmc_hardware())\n\t\t\t\terr = -EBUSY;\n\t\t\telse\n\t\t\t\treserve_ds_buffers();\n\t\t}\n\t\tif (!err)\n\t\t\tatomic_inc(&active_events);\n\t\tmutex_unlock(&pmc_reserve_mutex);\n\t}\n\tif (err)\n\t\treturn err;\n\n\tevent->destroy = hw_perf_event_destroy;\n\n\tevent->hw.idx = -1;\n\tevent->hw.last_cpu = -1;\n\tevent->hw.last_tag = ~0ULL;\n\n\treturn x86_pmu.hw_config(event);\n}\n\nstatic void x86_pmu_disable_all(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint idx;\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tu64 val;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\t\trdmsrl(x86_pmu_config_addr(idx), val);\n\t\tif (!(val & ARCH_PERFMON_EVENTSEL_ENABLE))\n\t\t\tcontinue;\n\t\tval &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\n\t\twrmsrl(x86_pmu_config_addr(idx), val);\n\t}\n}\n\nstatic void x86_pmu_disable(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tif (!x86_pmu_initialized())\n\t\treturn;\n\n\tif (!cpuc->enabled)\n\t\treturn;\n\n\tcpuc->n_added = 0;\n\tcpuc->enabled = 0;\n\tbarrier();\n\n\tx86_pmu.disable_all();\n}\n\nstatic inline void __x86_pmu_enable_event(struct hw_perf_event *hwc,\n\t\t\t\t\t  u64 enable_mask)\n{\n\tif (hwc->extra_reg)\n\t\twrmsrl(hwc->extra_reg, hwc->extra_config);\n\twrmsrl(hwc->config_base, hwc->config | enable_mask);\n}\n\nstatic void x86_pmu_enable_all(int added)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint idx;\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tstruct hw_perf_event *hwc = &cpuc->events[idx]->hw;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\t__x86_pmu_enable_event(hwc, ARCH_PERFMON_EVENTSEL_ENABLE);\n\t}\n}\n\nstatic struct pmu pmu;\n\nstatic inline int is_x86_event(struct perf_event *event)\n{\n\treturn event->pmu == &pmu;\n}\n\nstatic int x86_schedule_events(struct cpu_hw_events *cpuc, int n, int *assign)\n{\n\tstruct event_constraint *c, *constraints[X86_PMC_IDX_MAX];\n\tunsigned long used_mask[BITS_TO_LONGS(X86_PMC_IDX_MAX)];\n\tint i, j, w, wmax, num = 0;\n\tstruct hw_perf_event *hwc;\n\n\tbitmap_zero(used_mask, X86_PMC_IDX_MAX);\n\n\tfor (i = 0; i < n; i++) {\n\t\tc = x86_pmu.get_event_constraints(cpuc, cpuc->event_list[i]);\n\t\tconstraints[i] = c;\n\t}\n\n\t/*\n\t * fastpath, try to reuse previous register\n\t */\n\tfor (i = 0; i < n; i++) {\n\t\thwc = &cpuc->event_list[i]->hw;\n\t\tc = constraints[i];\n\n\t\t/* never assigned */\n\t\tif (hwc->idx == -1)\n\t\t\tbreak;\n\n\t\t/* constraint still honored */\n\t\tif (!test_bit(hwc->idx, c->idxmsk))\n\t\t\tbreak;\n\n\t\t/* not already used */\n\t\tif (test_bit(hwc->idx, used_mask))\n\t\t\tbreak;\n\n\t\t__set_bit(hwc->idx, used_mask);\n\t\tif (assign)\n\t\t\tassign[i] = hwc->idx;\n\t}\n\tif (i == n)\n\t\tgoto done;\n\n\t/*\n\t * begin slow path\n\t */\n\n\tbitmap_zero(used_mask, X86_PMC_IDX_MAX);\n\n\t/*\n\t * weight = number of possible counters\n\t *\n\t * 1    = most constrained, only works on one counter\n\t * wmax = least constrained, works on any counter\n\t *\n\t * assign events to counters starting with most\n\t * constrained events.\n\t */\n\twmax = x86_pmu.num_counters;\n\n\t/*\n\t * when fixed event counters are present,\n\t * wmax is incremented by 1 to account\n\t * for one more choice\n\t */\n\tif (x86_pmu.num_counters_fixed)\n\t\twmax++;\n\n\tfor (w = 1, num = n; num && w <= wmax; w++) {\n\t\t/* for each event */\n\t\tfor (i = 0; num && i < n; i++) {\n\t\t\tc = constraints[i];\n\t\t\thwc = &cpuc->event_list[i]->hw;\n\n\t\t\tif (c->weight != w)\n\t\t\t\tcontinue;\n\n\t\t\tfor_each_set_bit(j, c->idxmsk, X86_PMC_IDX_MAX) {\n\t\t\t\tif (!test_bit(j, used_mask))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (j == X86_PMC_IDX_MAX)\n\t\t\t\tbreak;\n\n\t\t\t__set_bit(j, used_mask);\n\n\t\t\tif (assign)\n\t\t\t\tassign[i] = j;\n\t\t\tnum--;\n\t\t}\n\t}\ndone:\n\t/*\n\t * scheduling failed or is just a simulation,\n\t * free resources if necessary\n\t */\n\tif (!assign || num) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (x86_pmu.put_event_constraints)\n\t\t\t\tx86_pmu.put_event_constraints(cpuc, cpuc->event_list[i]);\n\t\t}\n\t}\n\treturn num ? -ENOSPC : 0;\n}\n\n/*\n * dogrp: true if must collect siblings events (group)\n * returns total number of events and error code\n */\nstatic int collect_events(struct cpu_hw_events *cpuc, struct perf_event *leader, bool dogrp)\n{\n\tstruct perf_event *event;\n\tint n, max_count;\n\n\tmax_count = x86_pmu.num_counters + x86_pmu.num_counters_fixed;\n\n\t/* current number of events already accepted */\n\tn = cpuc->n_events;\n\n\tif (is_x86_event(leader)) {\n\t\tif (n >= max_count)\n\t\t\treturn -ENOSPC;\n\t\tcpuc->event_list[n] = leader;\n\t\tn++;\n\t}\n\tif (!dogrp)\n\t\treturn n;\n\n\tlist_for_each_entry(event, &leader->sibling_list, group_entry) {\n\t\tif (!is_x86_event(event) ||\n\t\t    event->state <= PERF_EVENT_STATE_OFF)\n\t\t\tcontinue;\n\n\t\tif (n >= max_count)\n\t\t\treturn -ENOSPC;\n\n\t\tcpuc->event_list[n] = event;\n\t\tn++;\n\t}\n\treturn n;\n}\n\nstatic inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}\n\nstatic inline int match_prev_assignment(struct hw_perf_event *hwc,\n\t\t\t\t\tstruct cpu_hw_events *cpuc,\n\t\t\t\t\tint i)\n{\n\treturn hwc->idx == cpuc->assign[i] &&\n\t\thwc->last_cpu == smp_processor_id() &&\n\t\thwc->last_tag == cpuc->tags[i];\n}\n\nstatic void x86_pmu_start(struct perf_event *event, int flags);\nstatic void x86_pmu_stop(struct perf_event *event, int flags);\n\nstatic void x86_pmu_enable(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tint i, added = cpuc->n_added;\n\n\tif (!x86_pmu_initialized())\n\t\treturn;\n\n\tif (cpuc->enabled)\n\t\treturn;\n\n\tif (cpuc->n_added) {\n\t\tint n_running = cpuc->n_events - cpuc->n_added;\n\t\t/*\n\t\t * apply assignment obtained either from\n\t\t * hw_perf_group_sched_in() or x86_pmu_enable()\n\t\t *\n\t\t * step1: save events moving to new counters\n\t\t * step2: reprogram moved events into new counters\n\t\t */\n\t\tfor (i = 0; i < n_running; i++) {\n\t\t\tevent = cpuc->event_list[i];\n\t\t\thwc = &event->hw;\n\n\t\t\t/*\n\t\t\t * we can avoid reprogramming counter if:\n\t\t\t * - assigned same counter as last time\n\t\t\t * - running on same CPU as last time\n\t\t\t * - no other event has used the counter since\n\t\t\t */\n\t\t\tif (hwc->idx == -1 ||\n\t\t\t    match_prev_assignment(hwc, cpuc, i))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Ensure we don't accidentally enable a stopped\n\t\t\t * counter simply because we rescheduled.\n\t\t\t */\n\t\t\tif (hwc->state & PERF_HES_STOPPED)\n\t\t\t\thwc->state |= PERF_HES_ARCH;\n\n\t\t\tx86_pmu_stop(event, PERF_EF_UPDATE);\n\t\t}\n\n\t\tfor (i = 0; i < cpuc->n_events; i++) {\n\t\t\tevent = cpuc->event_list[i];\n\t\t\thwc = &event->hw;\n\n\t\t\tif (!match_prev_assignment(hwc, cpuc, i))\n\t\t\t\tx86_assign_hw_event(event, cpuc, i);\n\t\t\telse if (i < n_running)\n\t\t\t\tcontinue;\n\n\t\t\tif (hwc->state & PERF_HES_ARCH)\n\t\t\t\tcontinue;\n\n\t\t\tx86_pmu_start(event, PERF_EF_RELOAD);\n\t\t}\n\t\tcpuc->n_added = 0;\n\t\tperf_events_lapic_init();\n\t}\n\n\tcpuc->enabled = 1;\n\tbarrier();\n\n\tx86_pmu.enable_all(added);\n}\n\nstatic inline void x86_pmu_disable_event(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\twrmsrl(hwc->config_base, hwc->config);\n}\n\nstatic DEFINE_PER_CPU(u64 [X86_PMC_IDX_MAX], pmc_prev_left);\n\n/*\n * Set the next IRQ period, based on the hwc->period_left value.\n * To be called with the event disabled in hw:\n */\nstatic int\nx86_perf_event_set_period(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\ts64 left = local64_read(&hwc->period_left);\n\ts64 period = hwc->sample_period;\n\tint ret = 0, idx = hwc->idx;\n\n\tif (idx == X86_PMC_IDX_FIXED_BTS)\n\t\treturn 0;\n\n\t/*\n\t * If we are way outside a reasonable range then just skip forward:\n\t */\n\tif (unlikely(left <= -period)) {\n\t\tleft = period;\n\t\tlocal64_set(&hwc->period_left, left);\n\t\thwc->last_period = period;\n\t\tret = 1;\n\t}\n\n\tif (unlikely(left <= 0)) {\n\t\tleft += period;\n\t\tlocal64_set(&hwc->period_left, left);\n\t\thwc->last_period = period;\n\t\tret = 1;\n\t}\n\t/*\n\t * Quirk: certain CPUs dont like it if just 1 hw_event is left:\n\t */\n\tif (unlikely(left < 2))\n\t\tleft = 2;\n\n\tif (left > x86_pmu.max_period)\n\t\tleft = x86_pmu.max_period;\n\n\tper_cpu(pmc_prev_left[idx], smp_processor_id()) = left;\n\n\t/*\n\t * The hw event starts counting from this event offset,\n\t * mark it to be able to extra future deltas:\n\t */\n\tlocal64_set(&hwc->prev_count, (u64)-left);\n\n\twrmsrl(hwc->event_base, (u64)(-left) & x86_pmu.cntval_mask);\n\n\t/*\n\t * Due to erratum on certan cpu we need\n\t * a second write to be sure the register\n\t * is updated properly\n\t */\n\tif (x86_pmu.perfctr_second_write) {\n\t\twrmsrl(hwc->event_base,\n\t\t\t(u64)(-left) & x86_pmu.cntval_mask);\n\t}\n\n\tperf_event_update_userpage(event);\n\n\treturn ret;\n}\n\nstatic void x86_pmu_enable_event(struct perf_event *event)\n{\n\tif (__this_cpu_read(cpu_hw_events.enabled))\n\t\t__x86_pmu_enable_event(&event->hw,\n\t\t\t\t       ARCH_PERFMON_EVENTSEL_ENABLE);\n}\n\n/*\n * Add a single event to the PMU.\n *\n * The event is added to the group of enabled events\n * but only if it can be scehduled with existing events.\n */\nstatic int x86_pmu_add(struct perf_event *event, int flags)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct hw_perf_event *hwc;\n\tint assign[X86_PMC_IDX_MAX];\n\tint n, n0, ret;\n\n\thwc = &event->hw;\n\n\tperf_pmu_disable(event->pmu);\n\tn0 = cpuc->n_events;\n\tret = n = collect_events(cpuc, event, false);\n\tif (ret < 0)\n\t\tgoto out;\n\n\thwc->state = PERF_HES_UPTODATE | PERF_HES_STOPPED;\n\tif (!(flags & PERF_EF_START))\n\t\thwc->state |= PERF_HES_ARCH;\n\n\t/*\n\t * If group events scheduling transaction was started,\n\t * skip the schedulability test here, it will be peformed\n\t * at commit time (->commit_txn) as a whole\n\t */\n\tif (cpuc->group_flag & PERF_EVENT_TXN)\n\t\tgoto done_collect;\n\n\tret = x86_pmu.schedule_events(cpuc, n, assign);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * copy new assignment, now we know it is possible\n\t * will be used by hw_perf_enable()\n\t */\n\tmemcpy(cpuc->assign, assign, n*sizeof(int));\n\ndone_collect:\n\tcpuc->n_events = n;\n\tcpuc->n_added += n - n0;\n\tcpuc->n_txn += n - n0;\n\n\tret = 0;\nout:\n\tperf_pmu_enable(event->pmu);\n\treturn ret;\n}\n\nstatic void x86_pmu_start(struct perf_event *event, int flags)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint idx = event->hw.idx;\n\n\tif (WARN_ON_ONCE(!(event->hw.state & PERF_HES_STOPPED)))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(idx == -1))\n\t\treturn;\n\n\tif (flags & PERF_EF_RELOAD) {\n\t\tWARN_ON_ONCE(!(event->hw.state & PERF_HES_UPTODATE));\n\t\tx86_perf_event_set_period(event);\n\t}\n\n\tevent->hw.state = 0;\n\n\tcpuc->events[idx] = event;\n\t__set_bit(idx, cpuc->active_mask);\n\t__set_bit(idx, cpuc->running);\n\tx86_pmu.enable(event);\n\tperf_event_update_userpage(event);\n}\n\nvoid perf_event_print_debug(void)\n{\n\tu64 ctrl, status, overflow, pmc_ctrl, pmc_count, prev_left, fixed;\n\tu64 pebs;\n\tstruct cpu_hw_events *cpuc;\n\tunsigned long flags;\n\tint cpu, idx;\n\n\tif (!x86_pmu.num_counters)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tcpu = smp_processor_id();\n\tcpuc = &per_cpu(cpu_hw_events, cpu);\n\n\tif (x86_pmu.version >= 2) {\n\t\trdmsrl(MSR_CORE_PERF_GLOBAL_CTRL, ctrl);\n\t\trdmsrl(MSR_CORE_PERF_GLOBAL_STATUS, status);\n\t\trdmsrl(MSR_CORE_PERF_GLOBAL_OVF_CTRL, overflow);\n\t\trdmsrl(MSR_ARCH_PERFMON_FIXED_CTR_CTRL, fixed);\n\t\trdmsrl(MSR_IA32_PEBS_ENABLE, pebs);\n\n\t\tpr_info(\"\\n\");\n\t\tpr_info(\"CPU#%d: ctrl:       %016llx\\n\", cpu, ctrl);\n\t\tpr_info(\"CPU#%d: status:     %016llx\\n\", cpu, status);\n\t\tpr_info(\"CPU#%d: overflow:   %016llx\\n\", cpu, overflow);\n\t\tpr_info(\"CPU#%d: fixed:      %016llx\\n\", cpu, fixed);\n\t\tpr_info(\"CPU#%d: pebs:       %016llx\\n\", cpu, pebs);\n\t}\n\tpr_info(\"CPU#%d: active:     %016llx\\n\", cpu, *(u64 *)cpuc->active_mask);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\trdmsrl(x86_pmu_config_addr(idx), pmc_ctrl);\n\t\trdmsrl(x86_pmu_event_addr(idx), pmc_count);\n\n\t\tprev_left = per_cpu(pmc_prev_left[idx], cpu);\n\n\t\tpr_info(\"CPU#%d:   gen-PMC%d ctrl:  %016llx\\n\",\n\t\t\tcpu, idx, pmc_ctrl);\n\t\tpr_info(\"CPU#%d:   gen-PMC%d count: %016llx\\n\",\n\t\t\tcpu, idx, pmc_count);\n\t\tpr_info(\"CPU#%d:   gen-PMC%d left:  %016llx\\n\",\n\t\t\tcpu, idx, prev_left);\n\t}\n\tfor (idx = 0; idx < x86_pmu.num_counters_fixed; idx++) {\n\t\trdmsrl(MSR_ARCH_PERFMON_FIXED_CTR0 + idx, pmc_count);\n\n\t\tpr_info(\"CPU#%d: fixed-PMC%d count: %016llx\\n\",\n\t\t\tcpu, idx, pmc_count);\n\t}\n\tlocal_irq_restore(flags);\n}\n\nstatic void x86_pmu_stop(struct perf_event *event, int flags)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (__test_and_clear_bit(hwc->idx, cpuc->active_mask)) {\n\t\tx86_pmu.disable(event);\n\t\tcpuc->events[hwc->idx] = NULL;\n\t\tWARN_ON_ONCE(hwc->state & PERF_HES_STOPPED);\n\t\thwc->state |= PERF_HES_STOPPED;\n\t}\n\n\tif ((flags & PERF_EF_UPDATE) && !(hwc->state & PERF_HES_UPTODATE)) {\n\t\t/*\n\t\t * Drain the remaining delta count out of a event\n\t\t * that we are disabling:\n\t\t */\n\t\tx86_perf_event_update(event);\n\t\thwc->state |= PERF_HES_UPTODATE;\n\t}\n}\n\nstatic void x86_pmu_del(struct perf_event *event, int flags)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint i;\n\n\t/*\n\t * If we're called during a txn, we don't need to do anything.\n\t * The events never got scheduled and ->cancel_txn will truncate\n\t * the event_list.\n\t */\n\tif (cpuc->group_flag & PERF_EVENT_TXN)\n\t\treturn;\n\n\tx86_pmu_stop(event, PERF_EF_UPDATE);\n\n\tfor (i = 0; i < cpuc->n_events; i++) {\n\t\tif (event == cpuc->event_list[i]) {\n\n\t\t\tif (x86_pmu.put_event_constraints)\n\t\t\t\tx86_pmu.put_event_constraints(cpuc, event);\n\n\t\t\twhile (++i < cpuc->n_events)\n\t\t\t\tcpuc->event_list[i-1] = cpuc->event_list[i];\n\n\t\t\t--cpuc->n_events;\n\t\t\tbreak;\n\t\t}\n\t}\n\tperf_event_update_userpage(event);\n}\n\nstatic int x86_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tif (!test_bit(idx, cpuc->active_mask)) {\n\t\t\t/*\n\t\t\t * Though we deactivated the counter some cpus\n\t\t\t * might still deliver spurious interrupts still\n\t\t\t * in flight. Catch them:\n\t\t\t */\n\t\t\tif (__test_and_clear_bit(idx, cpuc->running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc->events[idx];\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (val & (1ULL << (x86_pmu.cntval_bits - 1)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * event overflow\n\t\t */\n\t\thandled++;\n\t\tdata.period\t= event->hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, 1, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}\n\nvoid perf_events_lapic_init(void)\n{\n\tif (!x86_pmu.apic || !x86_pmu_initialized())\n\t\treturn;\n\n\t/*\n\t * Always use NMI for PMU\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n}\n\nstruct pmu_nmi_state {\n\tunsigned int\tmarked;\n\tint\t\thandled;\n};\n\nstatic DEFINE_PER_CPU(struct pmu_nmi_state, pmu_nmi);\n\nstatic int __kprobes\nperf_event_nmi_handler(struct notifier_block *self,\n\t\t\t unsigned long cmd, void *__args)\n{\n\tstruct die_args *args = __args;\n\tunsigned int this_nmi;\n\tint handled;\n\n\tif (!atomic_read(&active_events))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (cmd) {\n\tcase DIE_NMI:\n\t\tbreak;\n\tcase DIE_NMIUNKNOWN:\n\t\tthis_nmi = percpu_read(irq_stat.__nmi_count);\n\t\tif (this_nmi != __this_cpu_read(pmu_nmi.marked))\n\t\t\t/* let the kernel handle the unknown nmi */\n\t\t\treturn NOTIFY_DONE;\n\t\t/*\n\t\t * This one is a PMU back-to-back nmi. Two events\n\t\t * trigger 'simultaneously' raising two back-to-back\n\t\t * NMIs. If the first NMI handles both, the latter\n\t\t * will be empty and daze the CPU. So, we drop it to\n\t\t * avoid false-positive 'unknown nmi' messages.\n\t\t */\n\t\treturn NOTIFY_STOP;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\thandled = x86_pmu.handle_irq(args->regs);\n\tif (!handled)\n\t\treturn NOTIFY_DONE;\n\n\tthis_nmi = percpu_read(irq_stat.__nmi_count);\n\tif ((handled > 1) ||\n\t\t/* the next nmi could be a back-to-back nmi */\n\t    ((__this_cpu_read(pmu_nmi.marked) == this_nmi) &&\n\t     (__this_cpu_read(pmu_nmi.handled) > 1))) {\n\t\t/*\n\t\t * We could have two subsequent back-to-back nmis: The\n\t\t * first handles more than one counter, the 2nd\n\t\t * handles only one counter and the 3rd handles no\n\t\t * counter.\n\t\t *\n\t\t * This is the 2nd nmi because the previous was\n\t\t * handling more than one counter. We will mark the\n\t\t * next (3rd) and then drop it if unhandled.\n\t\t */\n\t\t__this_cpu_write(pmu_nmi.marked, this_nmi + 1);\n\t\t__this_cpu_write(pmu_nmi.handled, handled);\n\t}\n\n\treturn NOTIFY_STOP;\n}\n\nstatic __read_mostly struct notifier_block perf_event_nmi_notifier = {\n\t.notifier_call\t\t= perf_event_nmi_handler,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= NMI_LOCAL_LOW_PRIOR,\n};\n\nstatic struct event_constraint unconstrained;\nstatic struct event_constraint emptyconstraint;\n\nstatic struct event_constraint *\nx86_get_event_constraints(struct cpu_hw_events *cpuc, struct perf_event *event)\n{\n\tstruct event_constraint *c;\n\n\tif (x86_pmu.event_constraints) {\n\t\tfor_each_event_constraint(c, x86_pmu.event_constraints) {\n\t\t\tif ((event->hw.config & c->cmask) == c->code)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\n\treturn &unconstrained;\n}\n\n#include \"perf_event_amd.c\"\n#include \"perf_event_p6.c\"\n#include \"perf_event_p4.c\"\n#include \"perf_event_intel_lbr.c\"\n#include \"perf_event_intel_ds.c\"\n#include \"perf_event_intel.c\"\n\nstatic int __cpuinit\nx86_pmu_notifier(struct notifier_block *self, unsigned long action, void *hcpu)\n{\n\tunsigned int cpu = (long)hcpu;\n\tint ret = NOTIFY_OK;\n\n\tswitch (action & ~CPU_TASKS_FROZEN) {\n\tcase CPU_UP_PREPARE:\n\t\tif (x86_pmu.cpu_prepare)\n\t\t\tret = x86_pmu.cpu_prepare(cpu);\n\t\tbreak;\n\n\tcase CPU_STARTING:\n\t\tif (x86_pmu.cpu_starting)\n\t\t\tx86_pmu.cpu_starting(cpu);\n\t\tbreak;\n\n\tcase CPU_DYING:\n\t\tif (x86_pmu.cpu_dying)\n\t\t\tx86_pmu.cpu_dying(cpu);\n\t\tbreak;\n\n\tcase CPU_UP_CANCELED:\n\tcase CPU_DEAD:\n\t\tif (x86_pmu.cpu_dead)\n\t\t\tx86_pmu.cpu_dead(cpu);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void __init pmu_check_apic(void)\n{\n\tif (cpu_has_apic)\n\t\treturn;\n\n\tx86_pmu.apic = 0;\n\tpr_info(\"no APIC, boot with the \\\"lapic\\\" boot parameter to force-enable it.\\n\");\n\tpr_info(\"no hardware sampling interrupt available.\\n\");\n}\n\nstatic int __init init_hw_perf_events(void)\n{\n\tstruct event_constraint *c;\n\tint err;\n\n\tpr_info(\"Performance Events: \");\n\n\tswitch (boot_cpu_data.x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\terr = intel_pmu_init();\n\t\tbreak;\n\tcase X86_VENDOR_AMD:\n\t\terr = amd_pmu_init();\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (err != 0) {\n\t\tpr_cont(\"no PMU driver, software events only.\\n\");\n\t\treturn 0;\n\t}\n\n\tpmu_check_apic();\n\n\t/* sanity check that the hardware exists or is emulated */\n\tif (!check_hw_exists())\n\t\treturn 0;\n\n\tpr_cont(\"%s PMU driver.\\n\", x86_pmu.name);\n\n\tif (x86_pmu.quirks)\n\t\tx86_pmu.quirks();\n\n\tif (x86_pmu.num_counters > X86_PMC_MAX_GENERIC) {\n\t\tWARN(1, KERN_ERR \"hw perf events %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters, X86_PMC_MAX_GENERIC);\n\t\tx86_pmu.num_counters = X86_PMC_MAX_GENERIC;\n\t}\n\tx86_pmu.intel_ctrl = (1 << x86_pmu.num_counters) - 1;\n\n\tif (x86_pmu.num_counters_fixed > X86_PMC_MAX_FIXED) {\n\t\tWARN(1, KERN_ERR \"hw perf events fixed %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters_fixed, X86_PMC_MAX_FIXED);\n\t\tx86_pmu.num_counters_fixed = X86_PMC_MAX_FIXED;\n\t}\n\n\tx86_pmu.intel_ctrl |=\n\t\t((1LL << x86_pmu.num_counters_fixed)-1) << X86_PMC_IDX_FIXED;\n\n\tperf_events_lapic_init();\n\tregister_die_notifier(&perf_event_nmi_notifier);\n\n\tunconstrained = (struct event_constraint)\n\t\t__EVENT_CONSTRAINT(0, (1ULL << x86_pmu.num_counters) - 1,\n\t\t\t\t   0, x86_pmu.num_counters);\n\n\tif (x86_pmu.event_constraints) {\n\t\tfor_each_event_constraint(c, x86_pmu.event_constraints) {\n\t\t\tif (c->cmask != X86_RAW_EVENT_MASK)\n\t\t\t\tcontinue;\n\n\t\t\tc->idxmsk64 |= (1ULL << x86_pmu.num_counters) - 1;\n\t\t\tc->weight += x86_pmu.num_counters;\n\t\t}\n\t}\n\n\tpr_info(\"... version:                %d\\n\",     x86_pmu.version);\n\tpr_info(\"... bit width:              %d\\n\",     x86_pmu.cntval_bits);\n\tpr_info(\"... generic registers:      %d\\n\",     x86_pmu.num_counters);\n\tpr_info(\"... value mask:             %016Lx\\n\", x86_pmu.cntval_mask);\n\tpr_info(\"... max period:             %016Lx\\n\", x86_pmu.max_period);\n\tpr_info(\"... fixed-purpose events:   %d\\n\",     x86_pmu.num_counters_fixed);\n\tpr_info(\"... event mask:             %016Lx\\n\", x86_pmu.intel_ctrl);\n\n\tperf_pmu_register(&pmu, \"cpu\", PERF_TYPE_RAW);\n\tperf_cpu_notifier(x86_pmu_notifier);\n\n\treturn 0;\n}\nearly_initcall(init_hw_perf_events);\n\nstatic inline void x86_pmu_read(struct perf_event *event)\n{\n\tx86_perf_event_update(event);\n}\n\n/*\n * Start group events scheduling transaction\n * Set the flag to make pmu::enable() not perform the\n * schedulability test, it will be performed at commit time\n */\nstatic void x86_pmu_start_txn(struct pmu *pmu)\n{\n\tperf_pmu_disable(pmu);\n\t__this_cpu_or(cpu_hw_events.group_flag, PERF_EVENT_TXN);\n\t__this_cpu_write(cpu_hw_events.n_txn, 0);\n}\n\n/*\n * Stop group events scheduling transaction\n * Clear the flag and pmu::enable() will perform the\n * schedulability test.\n */\nstatic void x86_pmu_cancel_txn(struct pmu *pmu)\n{\n\t__this_cpu_and(cpu_hw_events.group_flag, ~PERF_EVENT_TXN);\n\t/*\n\t * Truncate the collected events.\n\t */\n\t__this_cpu_sub(cpu_hw_events.n_added, __this_cpu_read(cpu_hw_events.n_txn));\n\t__this_cpu_sub(cpu_hw_events.n_events, __this_cpu_read(cpu_hw_events.n_txn));\n\tperf_pmu_enable(pmu);\n}\n\n/*\n * Commit group events scheduling transaction\n * Perform the group schedulability test as a whole\n * Return 0 if success\n */\nstatic int x86_pmu_commit_txn(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint assign[X86_PMC_IDX_MAX];\n\tint n, ret;\n\n\tn = cpuc->n_events;\n\n\tif (!x86_pmu_initialized())\n\t\treturn -EAGAIN;\n\n\tret = x86_pmu.schedule_events(cpuc, n, assign);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * copy new assignment, now we know it is possible\n\t * will be used by hw_perf_enable()\n\t */\n\tmemcpy(cpuc->assign, assign, n*sizeof(int));\n\n\tcpuc->group_flag &= ~PERF_EVENT_TXN;\n\tperf_pmu_enable(pmu);\n\treturn 0;\n}\n\n/*\n * validate that we can schedule this event\n */\nstatic int validate_event(struct perf_event *event)\n{\n\tstruct cpu_hw_events *fake_cpuc;\n\tstruct event_constraint *c;\n\tint ret = 0;\n\n\tfake_cpuc = kmalloc(sizeof(*fake_cpuc), GFP_KERNEL | __GFP_ZERO);\n\tif (!fake_cpuc)\n\t\treturn -ENOMEM;\n\n\tc = x86_pmu.get_event_constraints(fake_cpuc, event);\n\n\tif (!c || !c->weight)\n\t\tret = -ENOSPC;\n\n\tif (x86_pmu.put_event_constraints)\n\t\tx86_pmu.put_event_constraints(fake_cpuc, event);\n\n\tkfree(fake_cpuc);\n\n\treturn ret;\n}\n\n/*\n * validate a single event group\n *\n * validation include:\n *\t- check events are compatible which each other\n *\t- events do not compete for the same counter\n *\t- number of events <= number of counters\n *\n * validation ensures the group can be loaded onto the\n * PMU if it was the only group available.\n */\nstatic int validate_group(struct perf_event *event)\n{\n\tstruct perf_event *leader = event->group_leader;\n\tstruct cpu_hw_events *fake_cpuc;\n\tint ret, n;\n\n\tret = -ENOMEM;\n\tfake_cpuc = kmalloc(sizeof(*fake_cpuc), GFP_KERNEL | __GFP_ZERO);\n\tif (!fake_cpuc)\n\t\tgoto out;\n\n\t/*\n\t * the event is not yet connected with its\n\t * siblings therefore we must first collect\n\t * existing siblings, then add the new event\n\t * before we can simulate the scheduling\n\t */\n\tret = -ENOSPC;\n\tn = collect_events(fake_cpuc, leader, true);\n\tif (n < 0)\n\t\tgoto out_free;\n\n\tfake_cpuc->n_events = n;\n\tn = collect_events(fake_cpuc, event, false);\n\tif (n < 0)\n\t\tgoto out_free;\n\n\tfake_cpuc->n_events = n;\n\n\tret = x86_pmu.schedule_events(fake_cpuc, n, NULL);\n\nout_free:\n\tkfree(fake_cpuc);\nout:\n\treturn ret;\n}\n\nstatic int x86_pmu_event_init(struct perf_event *event)\n{\n\tstruct pmu *tmp;\n\tint err;\n\n\tswitch (event->attr.type) {\n\tcase PERF_TYPE_RAW:\n\tcase PERF_TYPE_HARDWARE:\n\tcase PERF_TYPE_HW_CACHE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOENT;\n\t}\n\n\terr = __x86_pmu_event_init(event);\n\tif (!err) {\n\t\t/*\n\t\t * we temporarily connect event to its pmu\n\t\t * such that validate_group() can classify\n\t\t * it as an x86 event using is_x86_event()\n\t\t */\n\t\ttmp = event->pmu;\n\t\tevent->pmu = &pmu;\n\n\t\tif (event->group_leader != event)\n\t\t\terr = validate_group(event);\n\t\telse\n\t\t\terr = validate_event(event);\n\n\t\tevent->pmu = tmp;\n\t}\n\tif (err) {\n\t\tif (event->destroy)\n\t\t\tevent->destroy(event);\n\t}\n\n\treturn err;\n}\n\nstatic struct pmu pmu = {\n\t.pmu_enable\t= x86_pmu_enable,\n\t.pmu_disable\t= x86_pmu_disable,\n\n\t.event_init\t= x86_pmu_event_init,\n\n\t.add\t\t= x86_pmu_add,\n\t.del\t\t= x86_pmu_del,\n\t.start\t\t= x86_pmu_start,\n\t.stop\t\t= x86_pmu_stop,\n\t.read\t\t= x86_pmu_read,\n\n\t.start_txn\t= x86_pmu_start_txn,\n\t.cancel_txn\t= x86_pmu_cancel_txn,\n\t.commit_txn\t= x86_pmu_commit_txn,\n};\n\n/*\n * callchain support\n */\n\nstatic void\nbacktrace_warning_symbol(void *data, char *msg, unsigned long symbol)\n{\n\t/* Ignore warnings */\n}\n\nstatic void backtrace_warning(void *data, char *msg)\n{\n\t/* Ignore warnings */\n}\n\nstatic int backtrace_stack(void *data, char *name)\n{\n\treturn 0;\n}\n\nstatic void backtrace_address(void *data, unsigned long addr, int reliable)\n{\n\tstruct perf_callchain_entry *entry = data;\n\n\tperf_callchain_store(entry, addr);\n}\n\nstatic const struct stacktrace_ops backtrace_ops = {\n\t.warning\t\t= backtrace_warning,\n\t.warning_symbol\t\t= backtrace_warning_symbol,\n\t.stack\t\t\t= backtrace_stack,\n\t.address\t\t= backtrace_address,\n\t.walk_stack\t\t= print_context_stack_bp,\n};\n\nvoid\nperf_callchain_kernel(struct perf_callchain_entry *entry, struct pt_regs *regs)\n{\n\tif (perf_guest_cbs && perf_guest_cbs->is_in_guest()) {\n\t\t/* TODO: We don't support guest os callchain now */\n\t\treturn;\n\t}\n\n\tperf_callchain_store(entry, regs->ip);\n\n\tdump_trace(NULL, regs, NULL, &backtrace_ops, entry);\n}\n\n#ifdef CONFIG_COMPAT\nstatic inline int\nperf_callchain_user32(struct pt_regs *regs, struct perf_callchain_entry *entry)\n{\n\t/* 32-bit process in 64-bit kernel. */\n\tstruct stack_frame_ia32 frame;\n\tconst void __user *fp;\n\n\tif (!test_thread_flag(TIF_IA32))\n\t\treturn 0;\n\n\tfp = compat_ptr(regs->bp);\n\twhile (entry->nr < PERF_MAX_STACK_DEPTH) {\n\t\tunsigned long bytes;\n\t\tframe.next_frame     = 0;\n\t\tframe.return_address = 0;\n\n\t\tbytes = copy_from_user_nmi(&frame, fp, sizeof(frame));\n\t\tif (bytes != sizeof(frame))\n\t\t\tbreak;\n\n\t\tif (fp < compat_ptr(regs->sp))\n\t\t\tbreak;\n\n\t\tperf_callchain_store(entry, frame.return_address);\n\t\tfp = compat_ptr(frame.next_frame);\n\t}\n\treturn 1;\n}\n#else\nstatic inline int\nperf_callchain_user32(struct pt_regs *regs, struct perf_callchain_entry *entry)\n{\n    return 0;\n}\n#endif\n\nvoid\nperf_callchain_user(struct perf_callchain_entry *entry, struct pt_regs *regs)\n{\n\tstruct stack_frame frame;\n\tconst void __user *fp;\n\n\tif (perf_guest_cbs && perf_guest_cbs->is_in_guest()) {\n\t\t/* TODO: We don't support guest os callchain now */\n\t\treturn;\n\t}\n\n\tfp = (void __user *)regs->bp;\n\n\tperf_callchain_store(entry, regs->ip);\n\n\tif (perf_callchain_user32(regs, entry))\n\t\treturn;\n\n\twhile (entry->nr < PERF_MAX_STACK_DEPTH) {\n\t\tunsigned long bytes;\n\t\tframe.next_frame\t     = NULL;\n\t\tframe.return_address = 0;\n\n\t\tbytes = copy_from_user_nmi(&frame, fp, sizeof(frame));\n\t\tif (bytes != sizeof(frame))\n\t\t\tbreak;\n\n\t\tif ((unsigned long)fp < regs->sp)\n\t\t\tbreak;\n\n\t\tperf_callchain_store(entry, frame.return_address);\n\t\tfp = frame.next_frame;\n\t}\n}\n\nunsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tunsigned long ip;\n\n\tif (perf_guest_cbs && perf_guest_cbs->is_in_guest())\n\t\tip = perf_guest_cbs->get_guest_ip();\n\telse\n\t\tip = instruction_pointer(regs);\n\n\treturn ip;\n}\n\nunsigned long perf_misc_flags(struct pt_regs *regs)\n{\n\tint misc = 0;\n\n\tif (perf_guest_cbs && perf_guest_cbs->is_in_guest()) {\n\t\tif (perf_guest_cbs->is_user_mode())\n\t\t\tmisc |= PERF_RECORD_MISC_GUEST_USER;\n\t\telse\n\t\t\tmisc |= PERF_RECORD_MISC_GUEST_KERNEL;\n\t} else {\n\t\tif (user_mode(regs))\n\t\t\tmisc |= PERF_RECORD_MISC_USER;\n\t\telse\n\t\t\tmisc |= PERF_RECORD_MISC_KERNEL;\n\t}\n\n\tif (regs->flags & PERF_EFLAGS_EXACT)\n\t\tmisc |= PERF_RECORD_MISC_EXACT_IP;\n\n\treturn misc;\n}\n"], "fixing_code": ["/*\n * Performance events x86 architecture code\n *\n *  Copyright (C) 2008 Thomas Gleixner <tglx@linutronix.de>\n *  Copyright (C) 2008-2009 Red Hat, Inc., Ingo Molnar\n *  Copyright (C) 2009 Jaswinder Singh Rajput\n *  Copyright (C) 2009 Advanced Micro Devices, Inc., Robert Richter\n *  Copyright (C) 2008-2009 Red Hat, Inc., Peter Zijlstra <pzijlstr@redhat.com>\n *  Copyright (C) 2009 Intel Corporation, <markus.t.metzger@intel.com>\n *  Copyright (C) 2009 Google, Inc., Stephane Eranian\n *\n *  For licencing details see kernel-base/COPYING\n */\n\n#include <linux/perf_event.h>\n#include <linux/capability.h>\n#include <linux/notifier.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n#include <linux/kdebug.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/bitops.h>\n\n#include <asm/apic.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/compat.h>\n#include <asm/smp.h>\n\n#if 0\n#undef wrmsrl\n#define wrmsrl(msr, val) \t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\ttrace_printk(\"wrmsrl(%lx, %lx)\\n\", (unsigned long)(msr),\\\n\t\t\t(unsigned long)(val));\t\t\t\\\n\tnative_write_msr((msr), (u32)((u64)(val)), \t\t\\\n\t\t\t(u32)((u64)(val) >> 32));\t\t\\\n} while (0)\n#endif\n\n/*\n * best effort, GUP based copy_from_user() that assumes IRQ or NMI context\n */\nstatic unsigned long\ncopy_from_user_nmi(void *to, const void __user *from, unsigned long n)\n{\n\tunsigned long offset, addr = (unsigned long)from;\n\tunsigned long size, len = 0;\n\tstruct page *page;\n\tvoid *map;\n\tint ret;\n\n\tdo {\n\t\tret = __get_user_pages_fast(addr, 1, 0, &page);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\toffset = addr & (PAGE_SIZE - 1);\n\t\tsize = min(PAGE_SIZE - offset, n - len);\n\n\t\tmap = kmap_atomic(page);\n\t\tmemcpy(to, map+offset, size);\n\t\tkunmap_atomic(map);\n\t\tput_page(page);\n\n\t\tlen  += size;\n\t\tto   += size;\n\t\taddr += size;\n\n\t} while (len < n);\n\n\treturn len;\n}\n\nstruct event_constraint {\n\tunion {\n\t\tunsigned long\tidxmsk[BITS_TO_LONGS(X86_PMC_IDX_MAX)];\n\t\tu64\t\tidxmsk64;\n\t};\n\tu64\tcode;\n\tu64\tcmask;\n\tint\tweight;\n};\n\nstruct amd_nb {\n\tint nb_id;  /* NorthBridge id */\n\tint refcnt; /* reference count */\n\tstruct perf_event *owners[X86_PMC_IDX_MAX];\n\tstruct event_constraint event_constraints[X86_PMC_IDX_MAX];\n};\n\nstruct intel_percore;\n\n#define MAX_LBR_ENTRIES\t\t16\n\nstruct cpu_hw_events {\n\t/*\n\t * Generic x86 PMC bits\n\t */\n\tstruct perf_event\t*events[X86_PMC_IDX_MAX]; /* in counter order */\n\tunsigned long\t\tactive_mask[BITS_TO_LONGS(X86_PMC_IDX_MAX)];\n\tunsigned long\t\trunning[BITS_TO_LONGS(X86_PMC_IDX_MAX)];\n\tint\t\t\tenabled;\n\n\tint\t\t\tn_events;\n\tint\t\t\tn_added;\n\tint\t\t\tn_txn;\n\tint\t\t\tassign[X86_PMC_IDX_MAX]; /* event to counter assignment */\n\tu64\t\t\ttags[X86_PMC_IDX_MAX];\n\tstruct perf_event\t*event_list[X86_PMC_IDX_MAX]; /* in enabled order */\n\n\tunsigned int\t\tgroup_flag;\n\n\t/*\n\t * Intel DebugStore bits\n\t */\n\tstruct debug_store\t*ds;\n\tu64\t\t\tpebs_enabled;\n\n\t/*\n\t * Intel LBR bits\n\t */\n\tint\t\t\t\tlbr_users;\n\tvoid\t\t\t\t*lbr_context;\n\tstruct perf_branch_stack\tlbr_stack;\n\tstruct perf_branch_entry\tlbr_entries[MAX_LBR_ENTRIES];\n\n\t/*\n\t * Intel percore register state.\n\t * Coordinate shared resources between HT threads.\n\t */\n\tint\t\t\t\tpercore_used; /* Used by this CPU? */\n\tstruct intel_percore\t\t*per_core;\n\n\t/*\n\t * AMD specific bits\n\t */\n\tstruct amd_nb\t\t*amd_nb;\n};\n\n#define __EVENT_CONSTRAINT(c, n, m, w) {\\\n\t{ .idxmsk64 = (n) },\t\t\\\n\t.code = (c),\t\t\t\\\n\t.cmask = (m),\t\t\t\\\n\t.weight = (w),\t\t\t\\\n}\n\n#define EVENT_CONSTRAINT(c, n, m)\t\\\n\t__EVENT_CONSTRAINT(c, n, m, HWEIGHT(n))\n\n/*\n * Constraint on the Event code.\n */\n#define INTEL_EVENT_CONSTRAINT(c, n)\t\\\n\tEVENT_CONSTRAINT(c, n, ARCH_PERFMON_EVENTSEL_EVENT)\n\n/*\n * Constraint on the Event code + UMask + fixed-mask\n *\n * filter mask to validate fixed counter events.\n * the following filters disqualify for fixed counters:\n *  - inv\n *  - edge\n *  - cnt-mask\n *  The other filters are supported by fixed counters.\n *  The any-thread option is supported starting with v3.\n */\n#define FIXED_EVENT_CONSTRAINT(c, n)\t\\\n\tEVENT_CONSTRAINT(c, (1ULL << (32+n)), X86_RAW_EVENT_MASK)\n\n/*\n * Constraint on the Event code + UMask\n */\n#define INTEL_UEVENT_CONSTRAINT(c, n)\t\\\n\tEVENT_CONSTRAINT(c, n, INTEL_ARCH_EVENT_MASK)\n\n#define EVENT_CONSTRAINT_END\t\t\\\n\tEVENT_CONSTRAINT(0, 0, 0)\n\n#define for_each_event_constraint(e, c)\t\\\n\tfor ((e) = (c); (e)->weight; (e)++)\n\n/*\n * Extra registers for specific events.\n * Some events need large masks and require external MSRs.\n * Define a mapping to these extra registers.\n */\nstruct extra_reg {\n\tunsigned int\t\tevent;\n\tunsigned int\t\tmsr;\n\tu64\t\t\tconfig_mask;\n\tu64\t\t\tvalid_mask;\n};\n\n#define EVENT_EXTRA_REG(e, ms, m, vm) {\t\\\n\t.event = (e),\t\t\\\n\t.msr = (ms),\t\t\\\n\t.config_mask = (m),\t\\\n\t.valid_mask = (vm),\t\\\n\t}\n#define INTEL_EVENT_EXTRA_REG(event, msr, vm)\t\\\n\tEVENT_EXTRA_REG(event, msr, ARCH_PERFMON_EVENTSEL_EVENT, vm)\n#define EVENT_EXTRA_END EVENT_EXTRA_REG(0, 0, 0, 0)\n\nunion perf_capabilities {\n\tstruct {\n\t\tu64\tlbr_format    : 6;\n\t\tu64\tpebs_trap     : 1;\n\t\tu64\tpebs_arch_reg : 1;\n\t\tu64\tpebs_format   : 4;\n\t\tu64\tsmm_freeze    : 1;\n\t};\n\tu64\tcapabilities;\n};\n\n/*\n * struct x86_pmu - generic x86 pmu\n */\nstruct x86_pmu {\n\t/*\n\t * Generic x86 PMC bits\n\t */\n\tconst char\t*name;\n\tint\t\tversion;\n\tint\t\t(*handle_irq)(struct pt_regs *);\n\tvoid\t\t(*disable_all)(void);\n\tvoid\t\t(*enable_all)(int added);\n\tvoid\t\t(*enable)(struct perf_event *);\n\tvoid\t\t(*disable)(struct perf_event *);\n\tint\t\t(*hw_config)(struct perf_event *event);\n\tint\t\t(*schedule_events)(struct cpu_hw_events *cpuc, int n, int *assign);\n\tunsigned\teventsel;\n\tunsigned\tperfctr;\n\tu64\t\t(*event_map)(int);\n\tint\t\tmax_events;\n\tint\t\tnum_counters;\n\tint\t\tnum_counters_fixed;\n\tint\t\tcntval_bits;\n\tu64\t\tcntval_mask;\n\tint\t\tapic;\n\tu64\t\tmax_period;\n\tstruct event_constraint *\n\t\t\t(*get_event_constraints)(struct cpu_hw_events *cpuc,\n\t\t\t\t\t\t struct perf_event *event);\n\n\tvoid\t\t(*put_event_constraints)(struct cpu_hw_events *cpuc,\n\t\t\t\t\t\t struct perf_event *event);\n\tstruct event_constraint *event_constraints;\n\tstruct event_constraint *percore_constraints;\n\tvoid\t\t(*quirks)(void);\n\tint\t\tperfctr_second_write;\n\n\tint\t\t(*cpu_prepare)(int cpu);\n\tvoid\t\t(*cpu_starting)(int cpu);\n\tvoid\t\t(*cpu_dying)(int cpu);\n\tvoid\t\t(*cpu_dead)(int cpu);\n\n\t/*\n\t * Intel Arch Perfmon v2+\n\t */\n\tu64\t\t\tintel_ctrl;\n\tunion perf_capabilities intel_cap;\n\n\t/*\n\t * Intel DebugStore bits\n\t */\n\tint\t\tbts, pebs;\n\tint\t\tbts_active, pebs_active;\n\tint\t\tpebs_record_size;\n\tvoid\t\t(*drain_pebs)(struct pt_regs *regs);\n\tstruct event_constraint *pebs_constraints;\n\n\t/*\n\t * Intel LBR\n\t */\n\tunsigned long\tlbr_tos, lbr_from, lbr_to; /* MSR base regs       */\n\tint\t\tlbr_nr;\t\t\t   /* hardware stack size */\n\n\t/*\n\t * Extra registers for events\n\t */\n\tstruct extra_reg *extra_regs;\n};\n\nstatic struct x86_pmu x86_pmu __read_mostly;\n\nstatic DEFINE_PER_CPU(struct cpu_hw_events, cpu_hw_events) = {\n\t.enabled = 1,\n};\n\nstatic int x86_perf_event_set_period(struct perf_event *event);\n\n/*\n * Generalized hw caching related hw_event table, filled\n * in on a per model basis. A value of 0 means\n * 'not supported', -1 means 'hw_event makes no sense on\n * this CPU', any other value means the raw hw_event\n * ID.\n */\n\n#define C(x) PERF_COUNT_HW_CACHE_##x\n\nstatic u64 __read_mostly hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX];\nstatic u64 __read_mostly hw_cache_extra_regs\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX];\n\n/*\n * Propagate event elapsed time into the generic event.\n * Can only be executed on the CPU where the event is active.\n * Returns the delta events processed.\n */\nstatic u64\nx86_perf_event_update(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint shift = 64 - x86_pmu.cntval_bits;\n\tu64 prev_raw_count, new_raw_count;\n\tint idx = hwc->idx;\n\ts64 delta;\n\n\tif (idx == X86_PMC_IDX_FIXED_BTS)\n\t\treturn 0;\n\n\t/*\n\t * Careful: an NMI might modify the previous event value.\n\t *\n\t * Our tactic to handle this is to first atomically read and\n\t * exchange a new raw count - then add that new-prev delta\n\t * count to the generic event atomically:\n\t */\nagain:\n\tprev_raw_count = local64_read(&hwc->prev_count);\n\trdmsrl(hwc->event_base, new_raw_count);\n\n\tif (local64_cmpxchg(&hwc->prev_count, prev_raw_count,\n\t\t\t\t\tnew_raw_count) != prev_raw_count)\n\t\tgoto again;\n\n\t/*\n\t * Now we have the new raw value and have updated the prev\n\t * timestamp already. We can now calculate the elapsed delta\n\t * (event-)time and add that to the generic event.\n\t *\n\t * Careful, not all hw sign-extends above the physical width\n\t * of the count.\n\t */\n\tdelta = (new_raw_count << shift) - (prev_raw_count << shift);\n\tdelta >>= shift;\n\n\tlocal64_add(delta, &event->count);\n\tlocal64_sub(delta, &hwc->period_left);\n\n\treturn new_raw_count;\n}\n\n/* using X86_FEATURE_PERFCTR_CORE to later implement ALTERNATIVE() here */\nstatic inline int x86_pmu_addr_offset(int index)\n{\n\tif (boot_cpu_has(X86_FEATURE_PERFCTR_CORE))\n\t\treturn index << 1;\n\treturn index;\n}\n\nstatic inline unsigned int x86_pmu_config_addr(int index)\n{\n\treturn x86_pmu.eventsel + x86_pmu_addr_offset(index);\n}\n\nstatic inline unsigned int x86_pmu_event_addr(int index)\n{\n\treturn x86_pmu.perfctr + x86_pmu_addr_offset(index);\n}\n\n/*\n * Find and validate any extra registers to set up.\n */\nstatic int x86_pmu_extra_regs(u64 config, struct perf_event *event)\n{\n\tstruct extra_reg *er;\n\n\tevent->hw.extra_reg = 0;\n\tevent->hw.extra_config = 0;\n\n\tif (!x86_pmu.extra_regs)\n\t\treturn 0;\n\n\tfor (er = x86_pmu.extra_regs; er->msr; er++) {\n\t\tif (er->event != (config & er->config_mask))\n\t\t\tcontinue;\n\t\tif (event->attr.config1 & ~er->valid_mask)\n\t\t\treturn -EINVAL;\n\t\tevent->hw.extra_reg = er->msr;\n\t\tevent->hw.extra_config = event->attr.config1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic atomic_t active_events;\nstatic DEFINE_MUTEX(pmc_reserve_mutex);\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\nstatic bool reserve_pmc_hardware(void)\n{\n\tint i;\n\n\tfor (i = 0; i < x86_pmu.num_counters; i++) {\n\t\tif (!reserve_perfctr_nmi(x86_pmu_event_addr(i)))\n\t\t\tgoto perfctr_fail;\n\t}\n\n\tfor (i = 0; i < x86_pmu.num_counters; i++) {\n\t\tif (!reserve_evntsel_nmi(x86_pmu_config_addr(i)))\n\t\t\tgoto eventsel_fail;\n\t}\n\n\treturn true;\n\neventsel_fail:\n\tfor (i--; i >= 0; i--)\n\t\trelease_evntsel_nmi(x86_pmu_config_addr(i));\n\n\ti = x86_pmu.num_counters;\n\nperfctr_fail:\n\tfor (i--; i >= 0; i--)\n\t\trelease_perfctr_nmi(x86_pmu_event_addr(i));\n\n\treturn false;\n}\n\nstatic void release_pmc_hardware(void)\n{\n\tint i;\n\n\tfor (i = 0; i < x86_pmu.num_counters; i++) {\n\t\trelease_perfctr_nmi(x86_pmu_event_addr(i));\n\t\trelease_evntsel_nmi(x86_pmu_config_addr(i));\n\t}\n}\n\n#else\n\nstatic bool reserve_pmc_hardware(void) { return true; }\nstatic void release_pmc_hardware(void) {}\n\n#endif\n\nstatic bool check_hw_exists(void)\n{\n\tu64 val, val_new = 0;\n\tint i, reg, ret = 0;\n\n\t/*\n\t * Check to see if the BIOS enabled any of the counters, if so\n\t * complain and bail.\n\t */\n\tfor (i = 0; i < x86_pmu.num_counters; i++) {\n\t\treg = x86_pmu_config_addr(i);\n\t\tret = rdmsrl_safe(reg, &val);\n\t\tif (ret)\n\t\t\tgoto msr_fail;\n\t\tif (val & ARCH_PERFMON_EVENTSEL_ENABLE)\n\t\t\tgoto bios_fail;\n\t}\n\n\tif (x86_pmu.num_counters_fixed) {\n\t\treg = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\tret = rdmsrl_safe(reg, &val);\n\t\tif (ret)\n\t\t\tgoto msr_fail;\n\t\tfor (i = 0; i < x86_pmu.num_counters_fixed; i++) {\n\t\t\tif (val & (0x03 << i*4))\n\t\t\t\tgoto bios_fail;\n\t\t}\n\t}\n\n\t/*\n\t * Now write a value and read it back to see if it matches,\n\t * this is needed to detect certain hardware emulators (qemu/kvm)\n\t * that don't trap on the MSR access and always return 0s.\n\t */\n\tval = 0xabcdUL;\n\tret = checking_wrmsrl(x86_pmu_event_addr(0), val);\n\tret |= rdmsrl_safe(x86_pmu_event_addr(0), &val_new);\n\tif (ret || val != val_new)\n\t\tgoto msr_fail;\n\n\treturn true;\n\nbios_fail:\n\tprintk(KERN_CONT \"Broken BIOS detected, using software events only.\\n\");\n\tprintk(KERN_ERR FW_BUG \"the BIOS has corrupted hw-PMU resources (MSR %x is %Lx)\\n\", reg, val);\n\treturn false;\n\nmsr_fail:\n\tprintk(KERN_CONT \"Broken PMU hardware detected, using software events only.\\n\");\n\treturn false;\n}\n\nstatic void reserve_ds_buffers(void);\nstatic void release_ds_buffers(void);\n\nstatic void hw_perf_event_destroy(struct perf_event *event)\n{\n\tif (atomic_dec_and_mutex_lock(&active_events, &pmc_reserve_mutex)) {\n\t\trelease_pmc_hardware();\n\t\trelease_ds_buffers();\n\t\tmutex_unlock(&pmc_reserve_mutex);\n\t}\n}\n\nstatic inline int x86_pmu_initialized(void)\n{\n\treturn x86_pmu.handle_irq != NULL;\n}\n\nstatic inline int\nset_ext_hw_attr(struct hw_perf_event *hwc, struct perf_event *event)\n{\n\tstruct perf_event_attr *attr = &event->attr;\n\tunsigned int cache_type, cache_op, cache_result;\n\tu64 config, val;\n\n\tconfig = attr->config;\n\n\tcache_type = (config >>  0) & 0xff;\n\tif (cache_type >= PERF_COUNT_HW_CACHE_MAX)\n\t\treturn -EINVAL;\n\n\tcache_op = (config >>  8) & 0xff;\n\tif (cache_op >= PERF_COUNT_HW_CACHE_OP_MAX)\n\t\treturn -EINVAL;\n\n\tcache_result = (config >> 16) & 0xff;\n\tif (cache_result >= PERF_COUNT_HW_CACHE_RESULT_MAX)\n\t\treturn -EINVAL;\n\n\tval = hw_cache_event_ids[cache_type][cache_op][cache_result];\n\n\tif (val == 0)\n\t\treturn -ENOENT;\n\n\tif (val == -1)\n\t\treturn -EINVAL;\n\n\thwc->config |= val;\n\tattr->config1 = hw_cache_extra_regs[cache_type][cache_op][cache_result];\n\treturn x86_pmu_extra_regs(val, event);\n}\n\nstatic int x86_setup_perfctr(struct perf_event *event)\n{\n\tstruct perf_event_attr *attr = &event->attr;\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 config;\n\n\tif (!is_sampling_event(event)) {\n\t\thwc->sample_period = x86_pmu.max_period;\n\t\thwc->last_period = hwc->sample_period;\n\t\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\t} else {\n\t\t/*\n\t\t * If we have a PMU initialized but no APIC\n\t\t * interrupts, we cannot sample hardware\n\t\t * events (user-space has to fall back and\n\t\t * sample via a hrtimer based software event):\n\t\t */\n\t\tif (!x86_pmu.apic)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (attr->type == PERF_TYPE_RAW)\n\t\treturn x86_pmu_extra_regs(event->attr.config, event);\n\n\tif (attr->type == PERF_TYPE_HW_CACHE)\n\t\treturn set_ext_hw_attr(hwc, event);\n\n\tif (attr->config >= x86_pmu.max_events)\n\t\treturn -EINVAL;\n\n\t/*\n\t * The generic map:\n\t */\n\tconfig = x86_pmu.event_map(attr->config);\n\n\tif (config == 0)\n\t\treturn -ENOENT;\n\n\tif (config == -1LL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Branch tracing:\n\t */\n\tif ((attr->config == PERF_COUNT_HW_BRANCH_INSTRUCTIONS) &&\n\t    (hwc->sample_period == 1)) {\n\t\t/* BTS is not supported by this architecture. */\n\t\tif (!x86_pmu.bts_active)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t/* BTS is currently only allowed for user-mode. */\n\t\tif (!attr->exclude_kernel)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\thwc->config |= config;\n\n\treturn 0;\n}\n\nstatic int x86_pmu_hw_config(struct perf_event *event)\n{\n\tif (event->attr.precise_ip) {\n\t\tint precise = 0;\n\n\t\t/* Support for constant skid */\n\t\tif (x86_pmu.pebs_active) {\n\t\t\tprecise++;\n\n\t\t\t/* Support for IP fixup */\n\t\t\tif (x86_pmu.lbr_nr)\n\t\t\t\tprecise++;\n\t\t}\n\n\t\tif (event->attr.precise_ip > precise)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/*\n\t * Generate PMC IRQs:\n\t * (keep 'enabled' bit clear for now)\n\t */\n\tevent->hw.config = ARCH_PERFMON_EVENTSEL_INT;\n\n\t/*\n\t * Count user and OS events unless requested not to\n\t */\n\tif (!event->attr.exclude_user)\n\t\tevent->hw.config |= ARCH_PERFMON_EVENTSEL_USR;\n\tif (!event->attr.exclude_kernel)\n\t\tevent->hw.config |= ARCH_PERFMON_EVENTSEL_OS;\n\n\tif (event->attr.type == PERF_TYPE_RAW)\n\t\tevent->hw.config |= event->attr.config & X86_RAW_EVENT_MASK;\n\n\treturn x86_setup_perfctr(event);\n}\n\n/*\n * Setup the hardware configuration for a given attr_type\n */\nstatic int __x86_pmu_event_init(struct perf_event *event)\n{\n\tint err;\n\n\tif (!x86_pmu_initialized())\n\t\treturn -ENODEV;\n\n\terr = 0;\n\tif (!atomic_inc_not_zero(&active_events)) {\n\t\tmutex_lock(&pmc_reserve_mutex);\n\t\tif (atomic_read(&active_events) == 0) {\n\t\t\tif (!reserve_pmc_hardware())\n\t\t\t\terr = -EBUSY;\n\t\t\telse\n\t\t\t\treserve_ds_buffers();\n\t\t}\n\t\tif (!err)\n\t\t\tatomic_inc(&active_events);\n\t\tmutex_unlock(&pmc_reserve_mutex);\n\t}\n\tif (err)\n\t\treturn err;\n\n\tevent->destroy = hw_perf_event_destroy;\n\n\tevent->hw.idx = -1;\n\tevent->hw.last_cpu = -1;\n\tevent->hw.last_tag = ~0ULL;\n\n\treturn x86_pmu.hw_config(event);\n}\n\nstatic void x86_pmu_disable_all(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint idx;\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tu64 val;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\t\trdmsrl(x86_pmu_config_addr(idx), val);\n\t\tif (!(val & ARCH_PERFMON_EVENTSEL_ENABLE))\n\t\t\tcontinue;\n\t\tval &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\n\t\twrmsrl(x86_pmu_config_addr(idx), val);\n\t}\n}\n\nstatic void x86_pmu_disable(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tif (!x86_pmu_initialized())\n\t\treturn;\n\n\tif (!cpuc->enabled)\n\t\treturn;\n\n\tcpuc->n_added = 0;\n\tcpuc->enabled = 0;\n\tbarrier();\n\n\tx86_pmu.disable_all();\n}\n\nstatic inline void __x86_pmu_enable_event(struct hw_perf_event *hwc,\n\t\t\t\t\t  u64 enable_mask)\n{\n\tif (hwc->extra_reg)\n\t\twrmsrl(hwc->extra_reg, hwc->extra_config);\n\twrmsrl(hwc->config_base, hwc->config | enable_mask);\n}\n\nstatic void x86_pmu_enable_all(int added)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint idx;\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tstruct hw_perf_event *hwc = &cpuc->events[idx]->hw;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\t__x86_pmu_enable_event(hwc, ARCH_PERFMON_EVENTSEL_ENABLE);\n\t}\n}\n\nstatic struct pmu pmu;\n\nstatic inline int is_x86_event(struct perf_event *event)\n{\n\treturn event->pmu == &pmu;\n}\n\nstatic int x86_schedule_events(struct cpu_hw_events *cpuc, int n, int *assign)\n{\n\tstruct event_constraint *c, *constraints[X86_PMC_IDX_MAX];\n\tunsigned long used_mask[BITS_TO_LONGS(X86_PMC_IDX_MAX)];\n\tint i, j, w, wmax, num = 0;\n\tstruct hw_perf_event *hwc;\n\n\tbitmap_zero(used_mask, X86_PMC_IDX_MAX);\n\n\tfor (i = 0; i < n; i++) {\n\t\tc = x86_pmu.get_event_constraints(cpuc, cpuc->event_list[i]);\n\t\tconstraints[i] = c;\n\t}\n\n\t/*\n\t * fastpath, try to reuse previous register\n\t */\n\tfor (i = 0; i < n; i++) {\n\t\thwc = &cpuc->event_list[i]->hw;\n\t\tc = constraints[i];\n\n\t\t/* never assigned */\n\t\tif (hwc->idx == -1)\n\t\t\tbreak;\n\n\t\t/* constraint still honored */\n\t\tif (!test_bit(hwc->idx, c->idxmsk))\n\t\t\tbreak;\n\n\t\t/* not already used */\n\t\tif (test_bit(hwc->idx, used_mask))\n\t\t\tbreak;\n\n\t\t__set_bit(hwc->idx, used_mask);\n\t\tif (assign)\n\t\t\tassign[i] = hwc->idx;\n\t}\n\tif (i == n)\n\t\tgoto done;\n\n\t/*\n\t * begin slow path\n\t */\n\n\tbitmap_zero(used_mask, X86_PMC_IDX_MAX);\n\n\t/*\n\t * weight = number of possible counters\n\t *\n\t * 1    = most constrained, only works on one counter\n\t * wmax = least constrained, works on any counter\n\t *\n\t * assign events to counters starting with most\n\t * constrained events.\n\t */\n\twmax = x86_pmu.num_counters;\n\n\t/*\n\t * when fixed event counters are present,\n\t * wmax is incremented by 1 to account\n\t * for one more choice\n\t */\n\tif (x86_pmu.num_counters_fixed)\n\t\twmax++;\n\n\tfor (w = 1, num = n; num && w <= wmax; w++) {\n\t\t/* for each event */\n\t\tfor (i = 0; num && i < n; i++) {\n\t\t\tc = constraints[i];\n\t\t\thwc = &cpuc->event_list[i]->hw;\n\n\t\t\tif (c->weight != w)\n\t\t\t\tcontinue;\n\n\t\t\tfor_each_set_bit(j, c->idxmsk, X86_PMC_IDX_MAX) {\n\t\t\t\tif (!test_bit(j, used_mask))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (j == X86_PMC_IDX_MAX)\n\t\t\t\tbreak;\n\n\t\t\t__set_bit(j, used_mask);\n\n\t\t\tif (assign)\n\t\t\t\tassign[i] = j;\n\t\t\tnum--;\n\t\t}\n\t}\ndone:\n\t/*\n\t * scheduling failed or is just a simulation,\n\t * free resources if necessary\n\t */\n\tif (!assign || num) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (x86_pmu.put_event_constraints)\n\t\t\t\tx86_pmu.put_event_constraints(cpuc, cpuc->event_list[i]);\n\t\t}\n\t}\n\treturn num ? -ENOSPC : 0;\n}\n\n/*\n * dogrp: true if must collect siblings events (group)\n * returns total number of events and error code\n */\nstatic int collect_events(struct cpu_hw_events *cpuc, struct perf_event *leader, bool dogrp)\n{\n\tstruct perf_event *event;\n\tint n, max_count;\n\n\tmax_count = x86_pmu.num_counters + x86_pmu.num_counters_fixed;\n\n\t/* current number of events already accepted */\n\tn = cpuc->n_events;\n\n\tif (is_x86_event(leader)) {\n\t\tif (n >= max_count)\n\t\t\treturn -ENOSPC;\n\t\tcpuc->event_list[n] = leader;\n\t\tn++;\n\t}\n\tif (!dogrp)\n\t\treturn n;\n\n\tlist_for_each_entry(event, &leader->sibling_list, group_entry) {\n\t\tif (!is_x86_event(event) ||\n\t\t    event->state <= PERF_EVENT_STATE_OFF)\n\t\t\tcontinue;\n\n\t\tif (n >= max_count)\n\t\t\treturn -ENOSPC;\n\n\t\tcpuc->event_list[n] = event;\n\t\tn++;\n\t}\n\treturn n;\n}\n\nstatic inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + (hwc->idx - X86_PMC_IDX_FIXED);\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}\n\nstatic inline int match_prev_assignment(struct hw_perf_event *hwc,\n\t\t\t\t\tstruct cpu_hw_events *cpuc,\n\t\t\t\t\tint i)\n{\n\treturn hwc->idx == cpuc->assign[i] &&\n\t\thwc->last_cpu == smp_processor_id() &&\n\t\thwc->last_tag == cpuc->tags[i];\n}\n\nstatic void x86_pmu_start(struct perf_event *event, int flags);\nstatic void x86_pmu_stop(struct perf_event *event, int flags);\n\nstatic void x86_pmu_enable(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tint i, added = cpuc->n_added;\n\n\tif (!x86_pmu_initialized())\n\t\treturn;\n\n\tif (cpuc->enabled)\n\t\treturn;\n\n\tif (cpuc->n_added) {\n\t\tint n_running = cpuc->n_events - cpuc->n_added;\n\t\t/*\n\t\t * apply assignment obtained either from\n\t\t * hw_perf_group_sched_in() or x86_pmu_enable()\n\t\t *\n\t\t * step1: save events moving to new counters\n\t\t * step2: reprogram moved events into new counters\n\t\t */\n\t\tfor (i = 0; i < n_running; i++) {\n\t\t\tevent = cpuc->event_list[i];\n\t\t\thwc = &event->hw;\n\n\t\t\t/*\n\t\t\t * we can avoid reprogramming counter if:\n\t\t\t * - assigned same counter as last time\n\t\t\t * - running on same CPU as last time\n\t\t\t * - no other event has used the counter since\n\t\t\t */\n\t\t\tif (hwc->idx == -1 ||\n\t\t\t    match_prev_assignment(hwc, cpuc, i))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Ensure we don't accidentally enable a stopped\n\t\t\t * counter simply because we rescheduled.\n\t\t\t */\n\t\t\tif (hwc->state & PERF_HES_STOPPED)\n\t\t\t\thwc->state |= PERF_HES_ARCH;\n\n\t\t\tx86_pmu_stop(event, PERF_EF_UPDATE);\n\t\t}\n\n\t\tfor (i = 0; i < cpuc->n_events; i++) {\n\t\t\tevent = cpuc->event_list[i];\n\t\t\thwc = &event->hw;\n\n\t\t\tif (!match_prev_assignment(hwc, cpuc, i))\n\t\t\t\tx86_assign_hw_event(event, cpuc, i);\n\t\t\telse if (i < n_running)\n\t\t\t\tcontinue;\n\n\t\t\tif (hwc->state & PERF_HES_ARCH)\n\t\t\t\tcontinue;\n\n\t\t\tx86_pmu_start(event, PERF_EF_RELOAD);\n\t\t}\n\t\tcpuc->n_added = 0;\n\t\tperf_events_lapic_init();\n\t}\n\n\tcpuc->enabled = 1;\n\tbarrier();\n\n\tx86_pmu.enable_all(added);\n}\n\nstatic inline void x86_pmu_disable_event(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\twrmsrl(hwc->config_base, hwc->config);\n}\n\nstatic DEFINE_PER_CPU(u64 [X86_PMC_IDX_MAX], pmc_prev_left);\n\n/*\n * Set the next IRQ period, based on the hwc->period_left value.\n * To be called with the event disabled in hw:\n */\nstatic int\nx86_perf_event_set_period(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\ts64 left = local64_read(&hwc->period_left);\n\ts64 period = hwc->sample_period;\n\tint ret = 0, idx = hwc->idx;\n\n\tif (idx == X86_PMC_IDX_FIXED_BTS)\n\t\treturn 0;\n\n\t/*\n\t * If we are way outside a reasonable range then just skip forward:\n\t */\n\tif (unlikely(left <= -period)) {\n\t\tleft = period;\n\t\tlocal64_set(&hwc->period_left, left);\n\t\thwc->last_period = period;\n\t\tret = 1;\n\t}\n\n\tif (unlikely(left <= 0)) {\n\t\tleft += period;\n\t\tlocal64_set(&hwc->period_left, left);\n\t\thwc->last_period = period;\n\t\tret = 1;\n\t}\n\t/*\n\t * Quirk: certain CPUs dont like it if just 1 hw_event is left:\n\t */\n\tif (unlikely(left < 2))\n\t\tleft = 2;\n\n\tif (left > x86_pmu.max_period)\n\t\tleft = x86_pmu.max_period;\n\n\tper_cpu(pmc_prev_left[idx], smp_processor_id()) = left;\n\n\t/*\n\t * The hw event starts counting from this event offset,\n\t * mark it to be able to extra future deltas:\n\t */\n\tlocal64_set(&hwc->prev_count, (u64)-left);\n\n\twrmsrl(hwc->event_base, (u64)(-left) & x86_pmu.cntval_mask);\n\n\t/*\n\t * Due to erratum on certan cpu we need\n\t * a second write to be sure the register\n\t * is updated properly\n\t */\n\tif (x86_pmu.perfctr_second_write) {\n\t\twrmsrl(hwc->event_base,\n\t\t\t(u64)(-left) & x86_pmu.cntval_mask);\n\t}\n\n\tperf_event_update_userpage(event);\n\n\treturn ret;\n}\n\nstatic void x86_pmu_enable_event(struct perf_event *event)\n{\n\tif (__this_cpu_read(cpu_hw_events.enabled))\n\t\t__x86_pmu_enable_event(&event->hw,\n\t\t\t\t       ARCH_PERFMON_EVENTSEL_ENABLE);\n}\n\n/*\n * Add a single event to the PMU.\n *\n * The event is added to the group of enabled events\n * but only if it can be scehduled with existing events.\n */\nstatic int x86_pmu_add(struct perf_event *event, int flags)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct hw_perf_event *hwc;\n\tint assign[X86_PMC_IDX_MAX];\n\tint n, n0, ret;\n\n\thwc = &event->hw;\n\n\tperf_pmu_disable(event->pmu);\n\tn0 = cpuc->n_events;\n\tret = n = collect_events(cpuc, event, false);\n\tif (ret < 0)\n\t\tgoto out;\n\n\thwc->state = PERF_HES_UPTODATE | PERF_HES_STOPPED;\n\tif (!(flags & PERF_EF_START))\n\t\thwc->state |= PERF_HES_ARCH;\n\n\t/*\n\t * If group events scheduling transaction was started,\n\t * skip the schedulability test here, it will be peformed\n\t * at commit time (->commit_txn) as a whole\n\t */\n\tif (cpuc->group_flag & PERF_EVENT_TXN)\n\t\tgoto done_collect;\n\n\tret = x86_pmu.schedule_events(cpuc, n, assign);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * copy new assignment, now we know it is possible\n\t * will be used by hw_perf_enable()\n\t */\n\tmemcpy(cpuc->assign, assign, n*sizeof(int));\n\ndone_collect:\n\tcpuc->n_events = n;\n\tcpuc->n_added += n - n0;\n\tcpuc->n_txn += n - n0;\n\n\tret = 0;\nout:\n\tperf_pmu_enable(event->pmu);\n\treturn ret;\n}\n\nstatic void x86_pmu_start(struct perf_event *event, int flags)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint idx = event->hw.idx;\n\n\tif (WARN_ON_ONCE(!(event->hw.state & PERF_HES_STOPPED)))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(idx == -1))\n\t\treturn;\n\n\tif (flags & PERF_EF_RELOAD) {\n\t\tWARN_ON_ONCE(!(event->hw.state & PERF_HES_UPTODATE));\n\t\tx86_perf_event_set_period(event);\n\t}\n\n\tevent->hw.state = 0;\n\n\tcpuc->events[idx] = event;\n\t__set_bit(idx, cpuc->active_mask);\n\t__set_bit(idx, cpuc->running);\n\tx86_pmu.enable(event);\n\tperf_event_update_userpage(event);\n}\n\nvoid perf_event_print_debug(void)\n{\n\tu64 ctrl, status, overflow, pmc_ctrl, pmc_count, prev_left, fixed;\n\tu64 pebs;\n\tstruct cpu_hw_events *cpuc;\n\tunsigned long flags;\n\tint cpu, idx;\n\n\tif (!x86_pmu.num_counters)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tcpu = smp_processor_id();\n\tcpuc = &per_cpu(cpu_hw_events, cpu);\n\n\tif (x86_pmu.version >= 2) {\n\t\trdmsrl(MSR_CORE_PERF_GLOBAL_CTRL, ctrl);\n\t\trdmsrl(MSR_CORE_PERF_GLOBAL_STATUS, status);\n\t\trdmsrl(MSR_CORE_PERF_GLOBAL_OVF_CTRL, overflow);\n\t\trdmsrl(MSR_ARCH_PERFMON_FIXED_CTR_CTRL, fixed);\n\t\trdmsrl(MSR_IA32_PEBS_ENABLE, pebs);\n\n\t\tpr_info(\"\\n\");\n\t\tpr_info(\"CPU#%d: ctrl:       %016llx\\n\", cpu, ctrl);\n\t\tpr_info(\"CPU#%d: status:     %016llx\\n\", cpu, status);\n\t\tpr_info(\"CPU#%d: overflow:   %016llx\\n\", cpu, overflow);\n\t\tpr_info(\"CPU#%d: fixed:      %016llx\\n\", cpu, fixed);\n\t\tpr_info(\"CPU#%d: pebs:       %016llx\\n\", cpu, pebs);\n\t}\n\tpr_info(\"CPU#%d: active:     %016llx\\n\", cpu, *(u64 *)cpuc->active_mask);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\trdmsrl(x86_pmu_config_addr(idx), pmc_ctrl);\n\t\trdmsrl(x86_pmu_event_addr(idx), pmc_count);\n\n\t\tprev_left = per_cpu(pmc_prev_left[idx], cpu);\n\n\t\tpr_info(\"CPU#%d:   gen-PMC%d ctrl:  %016llx\\n\",\n\t\t\tcpu, idx, pmc_ctrl);\n\t\tpr_info(\"CPU#%d:   gen-PMC%d count: %016llx\\n\",\n\t\t\tcpu, idx, pmc_count);\n\t\tpr_info(\"CPU#%d:   gen-PMC%d left:  %016llx\\n\",\n\t\t\tcpu, idx, prev_left);\n\t}\n\tfor (idx = 0; idx < x86_pmu.num_counters_fixed; idx++) {\n\t\trdmsrl(MSR_ARCH_PERFMON_FIXED_CTR0 + idx, pmc_count);\n\n\t\tpr_info(\"CPU#%d: fixed-PMC%d count: %016llx\\n\",\n\t\t\tcpu, idx, pmc_count);\n\t}\n\tlocal_irq_restore(flags);\n}\n\nstatic void x86_pmu_stop(struct perf_event *event, int flags)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (__test_and_clear_bit(hwc->idx, cpuc->active_mask)) {\n\t\tx86_pmu.disable(event);\n\t\tcpuc->events[hwc->idx] = NULL;\n\t\tWARN_ON_ONCE(hwc->state & PERF_HES_STOPPED);\n\t\thwc->state |= PERF_HES_STOPPED;\n\t}\n\n\tif ((flags & PERF_EF_UPDATE) && !(hwc->state & PERF_HES_UPTODATE)) {\n\t\t/*\n\t\t * Drain the remaining delta count out of a event\n\t\t * that we are disabling:\n\t\t */\n\t\tx86_perf_event_update(event);\n\t\thwc->state |= PERF_HES_UPTODATE;\n\t}\n}\n\nstatic void x86_pmu_del(struct perf_event *event, int flags)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint i;\n\n\t/*\n\t * If we're called during a txn, we don't need to do anything.\n\t * The events never got scheduled and ->cancel_txn will truncate\n\t * the event_list.\n\t */\n\tif (cpuc->group_flag & PERF_EVENT_TXN)\n\t\treturn;\n\n\tx86_pmu_stop(event, PERF_EF_UPDATE);\n\n\tfor (i = 0; i < cpuc->n_events; i++) {\n\t\tif (event == cpuc->event_list[i]) {\n\n\t\t\tif (x86_pmu.put_event_constraints)\n\t\t\t\tx86_pmu.put_event_constraints(cpuc, event);\n\n\t\t\twhile (++i < cpuc->n_events)\n\t\t\t\tcpuc->event_list[i-1] = cpuc->event_list[i];\n\n\t\t\t--cpuc->n_events;\n\t\t\tbreak;\n\t\t}\n\t}\n\tperf_event_update_userpage(event);\n}\n\nstatic int x86_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tif (!test_bit(idx, cpuc->active_mask)) {\n\t\t\t/*\n\t\t\t * Though we deactivated the counter some cpus\n\t\t\t * might still deliver spurious interrupts still\n\t\t\t * in flight. Catch them:\n\t\t\t */\n\t\t\tif (__test_and_clear_bit(idx, cpuc->running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc->events[idx];\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (val & (1ULL << (x86_pmu.cntval_bits - 1)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * event overflow\n\t\t */\n\t\thandled++;\n\t\tdata.period\t= event->hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, 1, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}\n\nvoid perf_events_lapic_init(void)\n{\n\tif (!x86_pmu.apic || !x86_pmu_initialized())\n\t\treturn;\n\n\t/*\n\t * Always use NMI for PMU\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n}\n\nstruct pmu_nmi_state {\n\tunsigned int\tmarked;\n\tint\t\thandled;\n};\n\nstatic DEFINE_PER_CPU(struct pmu_nmi_state, pmu_nmi);\n\nstatic int __kprobes\nperf_event_nmi_handler(struct notifier_block *self,\n\t\t\t unsigned long cmd, void *__args)\n{\n\tstruct die_args *args = __args;\n\tunsigned int this_nmi;\n\tint handled;\n\n\tif (!atomic_read(&active_events))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (cmd) {\n\tcase DIE_NMI:\n\t\tbreak;\n\tcase DIE_NMIUNKNOWN:\n\t\tthis_nmi = percpu_read(irq_stat.__nmi_count);\n\t\tif (this_nmi != __this_cpu_read(pmu_nmi.marked))\n\t\t\t/* let the kernel handle the unknown nmi */\n\t\t\treturn NOTIFY_DONE;\n\t\t/*\n\t\t * This one is a PMU back-to-back nmi. Two events\n\t\t * trigger 'simultaneously' raising two back-to-back\n\t\t * NMIs. If the first NMI handles both, the latter\n\t\t * will be empty and daze the CPU. So, we drop it to\n\t\t * avoid false-positive 'unknown nmi' messages.\n\t\t */\n\t\treturn NOTIFY_STOP;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\thandled = x86_pmu.handle_irq(args->regs);\n\tif (!handled)\n\t\treturn NOTIFY_DONE;\n\n\tthis_nmi = percpu_read(irq_stat.__nmi_count);\n\tif ((handled > 1) ||\n\t\t/* the next nmi could be a back-to-back nmi */\n\t    ((__this_cpu_read(pmu_nmi.marked) == this_nmi) &&\n\t     (__this_cpu_read(pmu_nmi.handled) > 1))) {\n\t\t/*\n\t\t * We could have two subsequent back-to-back nmis: The\n\t\t * first handles more than one counter, the 2nd\n\t\t * handles only one counter and the 3rd handles no\n\t\t * counter.\n\t\t *\n\t\t * This is the 2nd nmi because the previous was\n\t\t * handling more than one counter. We will mark the\n\t\t * next (3rd) and then drop it if unhandled.\n\t\t */\n\t\t__this_cpu_write(pmu_nmi.marked, this_nmi + 1);\n\t\t__this_cpu_write(pmu_nmi.handled, handled);\n\t}\n\n\treturn NOTIFY_STOP;\n}\n\nstatic __read_mostly struct notifier_block perf_event_nmi_notifier = {\n\t.notifier_call\t\t= perf_event_nmi_handler,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= NMI_LOCAL_LOW_PRIOR,\n};\n\nstatic struct event_constraint unconstrained;\nstatic struct event_constraint emptyconstraint;\n\nstatic struct event_constraint *\nx86_get_event_constraints(struct cpu_hw_events *cpuc, struct perf_event *event)\n{\n\tstruct event_constraint *c;\n\n\tif (x86_pmu.event_constraints) {\n\t\tfor_each_event_constraint(c, x86_pmu.event_constraints) {\n\t\t\tif ((event->hw.config & c->cmask) == c->code)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\n\treturn &unconstrained;\n}\n\n#include \"perf_event_amd.c\"\n#include \"perf_event_p6.c\"\n#include \"perf_event_p4.c\"\n#include \"perf_event_intel_lbr.c\"\n#include \"perf_event_intel_ds.c\"\n#include \"perf_event_intel.c\"\n\nstatic int __cpuinit\nx86_pmu_notifier(struct notifier_block *self, unsigned long action, void *hcpu)\n{\n\tunsigned int cpu = (long)hcpu;\n\tint ret = NOTIFY_OK;\n\n\tswitch (action & ~CPU_TASKS_FROZEN) {\n\tcase CPU_UP_PREPARE:\n\t\tif (x86_pmu.cpu_prepare)\n\t\t\tret = x86_pmu.cpu_prepare(cpu);\n\t\tbreak;\n\n\tcase CPU_STARTING:\n\t\tif (x86_pmu.cpu_starting)\n\t\t\tx86_pmu.cpu_starting(cpu);\n\t\tbreak;\n\n\tcase CPU_DYING:\n\t\tif (x86_pmu.cpu_dying)\n\t\t\tx86_pmu.cpu_dying(cpu);\n\t\tbreak;\n\n\tcase CPU_UP_CANCELED:\n\tcase CPU_DEAD:\n\t\tif (x86_pmu.cpu_dead)\n\t\t\tx86_pmu.cpu_dead(cpu);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void __init pmu_check_apic(void)\n{\n\tif (cpu_has_apic)\n\t\treturn;\n\n\tx86_pmu.apic = 0;\n\tpr_info(\"no APIC, boot with the \\\"lapic\\\" boot parameter to force-enable it.\\n\");\n\tpr_info(\"no hardware sampling interrupt available.\\n\");\n}\n\nstatic int __init init_hw_perf_events(void)\n{\n\tstruct event_constraint *c;\n\tint err;\n\n\tpr_info(\"Performance Events: \");\n\n\tswitch (boot_cpu_data.x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\terr = intel_pmu_init();\n\t\tbreak;\n\tcase X86_VENDOR_AMD:\n\t\terr = amd_pmu_init();\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (err != 0) {\n\t\tpr_cont(\"no PMU driver, software events only.\\n\");\n\t\treturn 0;\n\t}\n\n\tpmu_check_apic();\n\n\t/* sanity check that the hardware exists or is emulated */\n\tif (!check_hw_exists())\n\t\treturn 0;\n\n\tpr_cont(\"%s PMU driver.\\n\", x86_pmu.name);\n\n\tif (x86_pmu.quirks)\n\t\tx86_pmu.quirks();\n\n\tif (x86_pmu.num_counters > X86_PMC_MAX_GENERIC) {\n\t\tWARN(1, KERN_ERR \"hw perf events %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters, X86_PMC_MAX_GENERIC);\n\t\tx86_pmu.num_counters = X86_PMC_MAX_GENERIC;\n\t}\n\tx86_pmu.intel_ctrl = (1 << x86_pmu.num_counters) - 1;\n\n\tif (x86_pmu.num_counters_fixed > X86_PMC_MAX_FIXED) {\n\t\tWARN(1, KERN_ERR \"hw perf events fixed %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters_fixed, X86_PMC_MAX_FIXED);\n\t\tx86_pmu.num_counters_fixed = X86_PMC_MAX_FIXED;\n\t}\n\n\tx86_pmu.intel_ctrl |=\n\t\t((1LL << x86_pmu.num_counters_fixed)-1) << X86_PMC_IDX_FIXED;\n\n\tperf_events_lapic_init();\n\tregister_die_notifier(&perf_event_nmi_notifier);\n\n\tunconstrained = (struct event_constraint)\n\t\t__EVENT_CONSTRAINT(0, (1ULL << x86_pmu.num_counters) - 1,\n\t\t\t\t   0, x86_pmu.num_counters);\n\n\tif (x86_pmu.event_constraints) {\n\t\tfor_each_event_constraint(c, x86_pmu.event_constraints) {\n\t\t\tif (c->cmask != X86_RAW_EVENT_MASK)\n\t\t\t\tcontinue;\n\n\t\t\tc->idxmsk64 |= (1ULL << x86_pmu.num_counters) - 1;\n\t\t\tc->weight += x86_pmu.num_counters;\n\t\t}\n\t}\n\n\tpr_info(\"... version:                %d\\n\",     x86_pmu.version);\n\tpr_info(\"... bit width:              %d\\n\",     x86_pmu.cntval_bits);\n\tpr_info(\"... generic registers:      %d\\n\",     x86_pmu.num_counters);\n\tpr_info(\"... value mask:             %016Lx\\n\", x86_pmu.cntval_mask);\n\tpr_info(\"... max period:             %016Lx\\n\", x86_pmu.max_period);\n\tpr_info(\"... fixed-purpose events:   %d\\n\",     x86_pmu.num_counters_fixed);\n\tpr_info(\"... event mask:             %016Lx\\n\", x86_pmu.intel_ctrl);\n\n\tperf_pmu_register(&pmu, \"cpu\", PERF_TYPE_RAW);\n\tperf_cpu_notifier(x86_pmu_notifier);\n\n\treturn 0;\n}\nearly_initcall(init_hw_perf_events);\n\nstatic inline void x86_pmu_read(struct perf_event *event)\n{\n\tx86_perf_event_update(event);\n}\n\n/*\n * Start group events scheduling transaction\n * Set the flag to make pmu::enable() not perform the\n * schedulability test, it will be performed at commit time\n */\nstatic void x86_pmu_start_txn(struct pmu *pmu)\n{\n\tperf_pmu_disable(pmu);\n\t__this_cpu_or(cpu_hw_events.group_flag, PERF_EVENT_TXN);\n\t__this_cpu_write(cpu_hw_events.n_txn, 0);\n}\n\n/*\n * Stop group events scheduling transaction\n * Clear the flag and pmu::enable() will perform the\n * schedulability test.\n */\nstatic void x86_pmu_cancel_txn(struct pmu *pmu)\n{\n\t__this_cpu_and(cpu_hw_events.group_flag, ~PERF_EVENT_TXN);\n\t/*\n\t * Truncate the collected events.\n\t */\n\t__this_cpu_sub(cpu_hw_events.n_added, __this_cpu_read(cpu_hw_events.n_txn));\n\t__this_cpu_sub(cpu_hw_events.n_events, __this_cpu_read(cpu_hw_events.n_txn));\n\tperf_pmu_enable(pmu);\n}\n\n/*\n * Commit group events scheduling transaction\n * Perform the group schedulability test as a whole\n * Return 0 if success\n */\nstatic int x86_pmu_commit_txn(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint assign[X86_PMC_IDX_MAX];\n\tint n, ret;\n\n\tn = cpuc->n_events;\n\n\tif (!x86_pmu_initialized())\n\t\treturn -EAGAIN;\n\n\tret = x86_pmu.schedule_events(cpuc, n, assign);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * copy new assignment, now we know it is possible\n\t * will be used by hw_perf_enable()\n\t */\n\tmemcpy(cpuc->assign, assign, n*sizeof(int));\n\n\tcpuc->group_flag &= ~PERF_EVENT_TXN;\n\tperf_pmu_enable(pmu);\n\treturn 0;\n}\n\n/*\n * validate that we can schedule this event\n */\nstatic int validate_event(struct perf_event *event)\n{\n\tstruct cpu_hw_events *fake_cpuc;\n\tstruct event_constraint *c;\n\tint ret = 0;\n\n\tfake_cpuc = kmalloc(sizeof(*fake_cpuc), GFP_KERNEL | __GFP_ZERO);\n\tif (!fake_cpuc)\n\t\treturn -ENOMEM;\n\n\tc = x86_pmu.get_event_constraints(fake_cpuc, event);\n\n\tif (!c || !c->weight)\n\t\tret = -ENOSPC;\n\n\tif (x86_pmu.put_event_constraints)\n\t\tx86_pmu.put_event_constraints(fake_cpuc, event);\n\n\tkfree(fake_cpuc);\n\n\treturn ret;\n}\n\n/*\n * validate a single event group\n *\n * validation include:\n *\t- check events are compatible which each other\n *\t- events do not compete for the same counter\n *\t- number of events <= number of counters\n *\n * validation ensures the group can be loaded onto the\n * PMU if it was the only group available.\n */\nstatic int validate_group(struct perf_event *event)\n{\n\tstruct perf_event *leader = event->group_leader;\n\tstruct cpu_hw_events *fake_cpuc;\n\tint ret, n;\n\n\tret = -ENOMEM;\n\tfake_cpuc = kmalloc(sizeof(*fake_cpuc), GFP_KERNEL | __GFP_ZERO);\n\tif (!fake_cpuc)\n\t\tgoto out;\n\n\t/*\n\t * the event is not yet connected with its\n\t * siblings therefore we must first collect\n\t * existing siblings, then add the new event\n\t * before we can simulate the scheduling\n\t */\n\tret = -ENOSPC;\n\tn = collect_events(fake_cpuc, leader, true);\n\tif (n < 0)\n\t\tgoto out_free;\n\n\tfake_cpuc->n_events = n;\n\tn = collect_events(fake_cpuc, event, false);\n\tif (n < 0)\n\t\tgoto out_free;\n\n\tfake_cpuc->n_events = n;\n\n\tret = x86_pmu.schedule_events(fake_cpuc, n, NULL);\n\nout_free:\n\tkfree(fake_cpuc);\nout:\n\treturn ret;\n}\n\nstatic int x86_pmu_event_init(struct perf_event *event)\n{\n\tstruct pmu *tmp;\n\tint err;\n\n\tswitch (event->attr.type) {\n\tcase PERF_TYPE_RAW:\n\tcase PERF_TYPE_HARDWARE:\n\tcase PERF_TYPE_HW_CACHE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOENT;\n\t}\n\n\terr = __x86_pmu_event_init(event);\n\tif (!err) {\n\t\t/*\n\t\t * we temporarily connect event to its pmu\n\t\t * such that validate_group() can classify\n\t\t * it as an x86 event using is_x86_event()\n\t\t */\n\t\ttmp = event->pmu;\n\t\tevent->pmu = &pmu;\n\n\t\tif (event->group_leader != event)\n\t\t\terr = validate_group(event);\n\t\telse\n\t\t\terr = validate_event(event);\n\n\t\tevent->pmu = tmp;\n\t}\n\tif (err) {\n\t\tif (event->destroy)\n\t\t\tevent->destroy(event);\n\t}\n\n\treturn err;\n}\n\nstatic struct pmu pmu = {\n\t.pmu_enable\t= x86_pmu_enable,\n\t.pmu_disable\t= x86_pmu_disable,\n\n\t.event_init\t= x86_pmu_event_init,\n\n\t.add\t\t= x86_pmu_add,\n\t.del\t\t= x86_pmu_del,\n\t.start\t\t= x86_pmu_start,\n\t.stop\t\t= x86_pmu_stop,\n\t.read\t\t= x86_pmu_read,\n\n\t.start_txn\t= x86_pmu_start_txn,\n\t.cancel_txn\t= x86_pmu_cancel_txn,\n\t.commit_txn\t= x86_pmu_commit_txn,\n};\n\n/*\n * callchain support\n */\n\nstatic void\nbacktrace_warning_symbol(void *data, char *msg, unsigned long symbol)\n{\n\t/* Ignore warnings */\n}\n\nstatic void backtrace_warning(void *data, char *msg)\n{\n\t/* Ignore warnings */\n}\n\nstatic int backtrace_stack(void *data, char *name)\n{\n\treturn 0;\n}\n\nstatic void backtrace_address(void *data, unsigned long addr, int reliable)\n{\n\tstruct perf_callchain_entry *entry = data;\n\n\tperf_callchain_store(entry, addr);\n}\n\nstatic const struct stacktrace_ops backtrace_ops = {\n\t.warning\t\t= backtrace_warning,\n\t.warning_symbol\t\t= backtrace_warning_symbol,\n\t.stack\t\t\t= backtrace_stack,\n\t.address\t\t= backtrace_address,\n\t.walk_stack\t\t= print_context_stack_bp,\n};\n\nvoid\nperf_callchain_kernel(struct perf_callchain_entry *entry, struct pt_regs *regs)\n{\n\tif (perf_guest_cbs && perf_guest_cbs->is_in_guest()) {\n\t\t/* TODO: We don't support guest os callchain now */\n\t\treturn;\n\t}\n\n\tperf_callchain_store(entry, regs->ip);\n\n\tdump_trace(NULL, regs, NULL, &backtrace_ops, entry);\n}\n\n#ifdef CONFIG_COMPAT\nstatic inline int\nperf_callchain_user32(struct pt_regs *regs, struct perf_callchain_entry *entry)\n{\n\t/* 32-bit process in 64-bit kernel. */\n\tstruct stack_frame_ia32 frame;\n\tconst void __user *fp;\n\n\tif (!test_thread_flag(TIF_IA32))\n\t\treturn 0;\n\n\tfp = compat_ptr(regs->bp);\n\twhile (entry->nr < PERF_MAX_STACK_DEPTH) {\n\t\tunsigned long bytes;\n\t\tframe.next_frame     = 0;\n\t\tframe.return_address = 0;\n\n\t\tbytes = copy_from_user_nmi(&frame, fp, sizeof(frame));\n\t\tif (bytes != sizeof(frame))\n\t\t\tbreak;\n\n\t\tif (fp < compat_ptr(regs->sp))\n\t\t\tbreak;\n\n\t\tperf_callchain_store(entry, frame.return_address);\n\t\tfp = compat_ptr(frame.next_frame);\n\t}\n\treturn 1;\n}\n#else\nstatic inline int\nperf_callchain_user32(struct pt_regs *regs, struct perf_callchain_entry *entry)\n{\n    return 0;\n}\n#endif\n\nvoid\nperf_callchain_user(struct perf_callchain_entry *entry, struct pt_regs *regs)\n{\n\tstruct stack_frame frame;\n\tconst void __user *fp;\n\n\tif (perf_guest_cbs && perf_guest_cbs->is_in_guest()) {\n\t\t/* TODO: We don't support guest os callchain now */\n\t\treturn;\n\t}\n\n\tfp = (void __user *)regs->bp;\n\n\tperf_callchain_store(entry, regs->ip);\n\n\tif (perf_callchain_user32(regs, entry))\n\t\treturn;\n\n\twhile (entry->nr < PERF_MAX_STACK_DEPTH) {\n\t\tunsigned long bytes;\n\t\tframe.next_frame\t     = NULL;\n\t\tframe.return_address = 0;\n\n\t\tbytes = copy_from_user_nmi(&frame, fp, sizeof(frame));\n\t\tif (bytes != sizeof(frame))\n\t\t\tbreak;\n\n\t\tif ((unsigned long)fp < regs->sp)\n\t\t\tbreak;\n\n\t\tperf_callchain_store(entry, frame.return_address);\n\t\tfp = frame.next_frame;\n\t}\n}\n\nunsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tunsigned long ip;\n\n\tif (perf_guest_cbs && perf_guest_cbs->is_in_guest())\n\t\tip = perf_guest_cbs->get_guest_ip();\n\telse\n\t\tip = instruction_pointer(regs);\n\n\treturn ip;\n}\n\nunsigned long perf_misc_flags(struct pt_regs *regs)\n{\n\tint misc = 0;\n\n\tif (perf_guest_cbs && perf_guest_cbs->is_in_guest()) {\n\t\tif (perf_guest_cbs->is_user_mode())\n\t\t\tmisc |= PERF_RECORD_MISC_GUEST_USER;\n\t\telse\n\t\t\tmisc |= PERF_RECORD_MISC_GUEST_KERNEL;\n\t} else {\n\t\tif (user_mode(regs))\n\t\t\tmisc |= PERF_RECORD_MISC_USER;\n\t\telse\n\t\t\tmisc |= PERF_RECORD_MISC_KERNEL;\n\t}\n\n\tif (regs->flags & PERF_EFLAGS_EXACT)\n\t\tmisc |= PERF_RECORD_MISC_EXACT_IP;\n\n\treturn misc;\n}\n"], "filenames": ["arch/x86/kernel/cpu/perf_event.c"], "buggy_code_start_loc": [915], "buggy_code_end_loc": [916], "fixing_code_start_loc": [915], "fixing_code_end_loc": [916], "type": "CWE-189", "message": "The x86_assign_hw_event function in arch/x86/kernel/cpu/perf_event.c in the Performance Events subsystem in the Linux kernel before 2.6.39 does not properly calculate counter values, which allows local users to cause a denial of service (panic) via the perf program.", "other": {"cve": {"id": "CVE-2011-2521", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-24T23:55:01.683", "lastModified": "2023-02-13T04:31:08.237", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The x86_assign_hw_event function in arch/x86/kernel/cpu/perf_event.c in the Performance Events subsystem in the Linux kernel before 2.6.39 does not properly calculate counter values, which allows local users to cause a denial of service (panic) via the perf program."}, {"lang": "es", "value": "La funci\u00f3n x86_assign_hw_event de arch/x86/kernel/cpu/perf_event.c en el rendimiento del subsistema de eventos en el kernel de Linux antes de 2.6.39 no calcula correctamente los valores de contador, lo que permite a usuarios locales causar una denegaci\u00f3n de servicio (panic) a trav\u00e9s del programa perfs."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.39", "matchCriteriaId": "176353CE-F17E-4776-AD9F-19014DA75B76"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=fc66c5210ec2539e800e87d7b3a985323c7be96e", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/07/06/4", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=719228", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/fc66c5210ec2539e800e87d7b3a985323c7be96e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/fc66c5210ec2539e800e87d7b3a985323c7be96e"}}