{"buggy_code": ["/* $OpenBSD: scp.c,v 1.197 2018/06/01 04:31:48 dtucker Exp $ */\n/*\n * scp - secure remote copy.  This is basically patched BSD rcp which\n * uses ssh to do the data transfer (instead of using rcmd).\n *\n * NOTE: This version should NOT be suid root.  (This uses ssh to\n * do the transfer and ssh has the necessary privileges.)\n *\n * 1995 Timo Rinne <tri@iki.fi>, Tatu Ylonen <ylo@cs.hut.fi>\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n/*\n * Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n * Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Parts from:\n *\n * Copyright (c) 1983, 1990, 1992, 1993, 1995\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#else\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# endif\n#endif\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/wait.h>\n#include <sys/uio.h>\n\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <locale.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#if defined(HAVE_STRNVIS) && defined(HAVE_VIS_H) && !defined(BROKEN_STRNVIS)\n#include <vis.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"utf8.h\"\n\nextern char *__progname;\n\n#define COPY_BUFLEN\t16384\n\nint do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);\nint do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);\n\n/* Struct for addargs */\narglist args;\narglist remote_remote_args;\n\n/* Bandwidth limit */\nlong long limit_kbps = 0;\nstruct bwlimit bwlimit;\n\n/* Name of current file being transferred. */\nchar *curfile;\n\n/* This is set to non-zero to enable verbose mode. */\nint verbose_mode = 0;\n\n/* This is set to zero if the progressmeter is not desired. */\nint showprogress = 1;\n\n/*\n * This is set to non-zero if remote-remote copy should be piped\n * through this process.\n */\nint throughlocal = 0;\n\n/* Non-standard port to use for the ssh connection or -1. */\nint sshport = -1;\n\n/* This is the program to execute for the secured connection. (\"ssh\" or -S) */\nchar *ssh_program = _PATH_SSH_PROGRAM;\n\n/* This is used to store the pid of ssh_program */\npid_t do_cmd_pid = -1;\n\nstatic void\nkillchild(int signo)\n{\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo ? signo : SIGTERM);\n\t\twaitpid(do_cmd_pid, NULL, 0);\n\t}\n\n\tif (signo)\n\t\t_exit(1);\n\texit(1);\n}\n\nstatic void\nsuspchild(int signo)\n{\n\tint status;\n\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo);\n\t\twhile (waitpid(do_cmd_pid, &status, WUNTRACED) == -1 &&\n\t\t    errno == EINTR)\n\t\t\t;\n\t\tkill(getpid(), SIGSTOP);\n\t}\n}\n\nstatic int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfmprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n\t\texit(1);\n\t}\n\n\tdo_cmd_pid = pid;\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n/*\n * This function executes the given command as the specified user on the\n * given host.  This returns < 0 if execution fails, and >= 0 otherwise. This\n * assigns the input and output file descriptors on success.\n */\n\nint\ndo_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout)\n{\n\tint pin[2], pout[2], reserved[2];\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/*\n\t * Reserve two descriptors so that the real pipes won't get\n\t * descriptors 0 and 1 because that will screw up dup2 below.\n\t */\n\tif (pipe(reserved) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Create a socket pair for communicating with ssh. */\n\tif (pipe(pin) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\tif (pipe(pout) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Free the reserved descriptors. */\n\tclose(reserved[0]);\n\tclose(reserved[1]);\n\n\tsignal(SIGTSTP, suspchild);\n\tsignal(SIGTTIN, suspchild);\n\tsignal(SIGTTOU, suspchild);\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tdo_cmd_pid = fork();\n\tif (do_cmd_pid == 0) {\n\t\t/* Child. */\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tdup2(pin[0], 0);\n\t\tdup2(pout[1], 1);\n\t\tclose(pin[0]);\n\t\tclose(pout[1]);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (do_cmd_pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\t/* Parent.  Close the other side, and return the local side. */\n\tclose(pin[0]);\n\t*fdout = pin[1];\n\tclose(pout[1]);\n\t*fdin = pout[0];\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\treturn 0;\n}\n\n/*\n * This function executes a command similar to do_cmd(), but expects the\n * input and output descriptors to be setup by a previous call to do_cmd().\n * This way the input and output of two commands can be connected.\n */\nint\ndo_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout)\n{\n\tpid_t pid;\n\tint status;\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: 2nd program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tpid = fork();\n\tif (pid == 0) {\n\t\tdup2(fdin, 0);\n\t\tdup2(fdout, 1);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_cmd2: waitpid: %s\", strerror(errno));\n\treturn 0;\n}\n\ntypedef struct {\n\tsize_t cnt;\n\tchar *buf;\n} BUF;\n\nBUF *allocbuf(BUF *, int, int);\nvoid lostconn(int);\nint okname(char *);\nvoid run_err(const char *,...);\nvoid verifydir(char *);\n\nstruct passwd *pwd;\nuid_t userid;\nint errs, remin, remout;\nint pflag, iamremote, iamrecursive, targetshouldbedirectory;\n\n#define\tCMDNEEDS\t64\nchar cmd[CMDNEEDS];\t\t/* must hold \"rcp -r -p -d\\0\" */\n\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid sink(int, char *[]);\nvoid source(int, char *[]);\nvoid tolocal(int, char *[]);\nvoid toremote(int, char *[]);\nvoid usage(void);\n\nint\nmain(int argc, char **argv)\n{\n\tint ch, fflag, tflag, status, n;\n\tchar **newargv;\n\tconst char *errstr;\n\textern char *optarg;\n\textern int optind;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tmsetlocale();\n\n\t/* Copy argv, because we modify it */\n\tnewargv = xcalloc(MAXIMUM(argc + 1, 1), sizeof(*newargv));\n\tfor (n = 0; n < argc; n++)\n\t\tnewargv[n] = xstrdup(argv[n]);\n\targv = newargv;\n\n\t__progname = ssh_get_progname(argv[0]);\n\n\tmemset(&args, '\\0', sizeof(args));\n\tmemset(&remote_remote_args, '\\0', sizeof(remote_remote_args));\n\targs.list = remote_remote_args.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-x\");\n\taddargs(&args, \"-oForwardAgent=no\");\n\taddargs(&args, \"-oPermitLocalCommand=no\");\n\taddargs(&args, \"-oClearAllForwardings=yes\");\n\taddargs(&args, \"-oRemoteCommand=none\");\n\taddargs(&args, \"-oRequestTTY=no\");\n\n\tfflag = tflag = 0;\n\twhile ((ch = getopt(argc, argv, \"dfl:prtvBCc:i:P:q12346S:o:F:\")) != -1)\n\t\tswitch (ch) {\n\t\t/* User-visible flags. */\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tthroughlocal = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'F':\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"%s\", optarg);\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tsshport = a2port(optarg);\n\t\t\tif (sshport <= 0)\n\t\t\t\tfatal(\"bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\taddargs(&remote_remote_args, \"-oBatchmode=yes\");\n\t\t\taddargs(&args, \"-oBatchmode=yes\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024; /* kbps */\n\t\t\tbandwidth_limit_init(&bwlimit, limit_kbps, COPY_BUFLEN);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tiamrecursive = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\taddargs(&args, \"-v\");\n\t\t\taddargs(&remote_remote_args, \"-v\");\n\t\t\tverbose_mode = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\taddargs(&args, \"-q\");\n\t\t\taddargs(&remote_remote_args, \"-q\");\n\t\t\tshowprogress = 0;\n\t\t\tbreak;\n\n\t\t/* Server options. */\n\t\tcase 'd':\n\t\t\ttargetshouldbedirectory = 1;\n\t\t\tbreak;\n\t\tcase 'f':\t/* \"from\" */\n\t\t\tiamremote = 1;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\t/* \"to\" */\n\t\t\tiamremote = 1;\n\t\t\ttflag = 1;\n#ifdef HAVE_CYGWIN\n\t\t\tsetmode(0, O_BINARY);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tif ((pwd = getpwuid(userid = getuid())) == NULL)\n\t\tfatal(\"unknown user %u\", (u_int) userid);\n\n\tif (!isatty(STDOUT_FILENO))\n\t\tshowprogress = 0;\n\n\tif (pflag) {\n\t\t/* Cannot pledge: -p allows setuid/setgid files... */\n\t} else {\n\t\tif (pledge(\"stdio rpath wpath cpath fattr tty proc exec\",\n\t\t    NULL) == -1) {\n\t\t\tperror(\"pledge\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tremin = STDIN_FILENO;\n\tremout = STDOUT_FILENO;\n\n\tif (fflag) {\n\t\t/* Follow \"protocol\", send data. */\n\t\t(void) response();\n\t\tsource(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (tflag) {\n\t\t/* Receive data. */\n\t\tsink(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (argc < 2)\n\t\tusage();\n\tif (argc > 2)\n\t\ttargetshouldbedirectory = 1;\n\n\tremin = remout = -1;\n\tdo_cmd_pid = -1;\n\t/* Command to be executed on remote system using \"ssh\". */\n\t(void) snprintf(cmd, sizeof cmd, \"scp%s%s%s%s\",\n\t    verbose_mode ? \" -v\" : \"\",\n\t    iamrecursive ? \" -r\" : \"\", pflag ? \" -p\" : \"\",\n\t    targetshouldbedirectory ? \" -d\" : \"\");\n\n\t(void) signal(SIGPIPE, lostconn);\n\n\tif (colon(argv[argc - 1]))\t/* Dest is remote host. */\n\t\ttoremote(argc, argv);\n\telse {\n\t\tif (targetshouldbedirectory)\n\t\t\tverifydir(argv[argc - 1]);\n\t\ttolocal(argc, argv);\t/* Dest is local host. */\n\t}\n\t/*\n\t * Finally check the exit status of the ssh process, if one was forked\n\t * and no error has occurred yet\n\t */\n\tif (do_cmd_pid != -1 && errs == 0) {\n\t\tif (remin != -1)\n\t\t    (void) close(remin);\n\t\tif (remout != -1)\n\t\t    (void) close(remout);\n\t\tif (waitpid(do_cmd_pid, &status, 0) == -1)\n\t\t\terrs = 1;\n\t\telse {\n\t\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\t\t\terrs = 1;\n\t\t}\n\t}\n\texit(errs != 0);\n}\n\n/* Callback from atomicio6 to update progress meter and limit bandwidth */\nstatic int\nscpio(void *_cnt, size_t s)\n{\n\toff_t *cnt = (off_t *)_cnt;\n\n\t*cnt += s;\n\tif (limit_kbps > 0)\n\t\tbandwidth_limit(&bwlimit, s);\n\treturn 0;\n}\n\nstatic int\ndo_times(int fd, int verb, const struct stat *sb)\n{\n\t/* strlen(2^64) == 20; strlen(10^6) == 7 */\n\tchar buf[(20 + 7 + 2) * 2 + 2];\n\n\t(void)snprintf(buf, sizeof(buf), \"T%llu 0 %llu 0\\n\",\n\t    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),\n\t    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));\n\tif (verb) {\n\t\tfprintf(stderr, \"File mtime %lld atime %lld\\n\",\n\t\t    (long long)sb->st_mtime, (long long)sb->st_atime);\n\t\tfprintf(stderr, \"Sending file timestamps: %s\", buf);\n\t}\n\t(void) atomicio(vwrite, fd, buf, strlen(buf));\n\treturn (response());\n}\n\nstatic int\nparse_scp_uri(const char *uri, char **userp, char **hostp, int *portp,\n     char **pathp)\n{\n\tint r;\n\n\tr = parse_uri(\"scp\", uri, userp, hostp, portp, pathp);\n\tif (r == 0 && *pathp == NULL)\n\t\t*pathp = xstrdup(\".\");\n\treturn r;\n}\n\nvoid\ntoremote(int argc, char **argv)\n{\n\tchar *suser = NULL, *host = NULL, *src = NULL;\n\tchar *bp, *tuser, *thost, *targ;\n\tint sport = -1, tport = -1;\n\targlist alist;\n\tint i, r;\n\tu_int j;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\t/* Parse target */\n\tr = parse_scp_uri(argv[argc - 1], &tuser, &thost, &tport, &targ);\n\tif (r == -1) {\n\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[argc - 1]);\n\t\t++errs;\n\t\tgoto out;\n\t}\n\tif (r != 0) {\n\t\tif (parse_user_host_path(argv[argc - 1], &tuser, &thost,\n\t\t    &targ) == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid target\\n\", argv[argc - 1]);\n\t\t\t++errs;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (tuser != NULL && !okname(tuser)) {\n\t\t++errs;\n\t\tgoto out;\n\t}\n\n\t/* Parse source files */\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0) {\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\t}\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (host && throughlocal) {\t/* extended remote to remote */\n\t\t\txasprintf(&bp, \"%s -f %s%s\", cmd,\n\t\t\t    *src == '-' ? \"-- \" : \"\", src);\n\t\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\tif (do_cmd2(thost, tuser, tport, bp, remin, remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\t(void) close(remin);\n\t\t\t(void) close(remout);\n\t\t\tremin = remout = -1;\n\t\t} else if (host) {\t/* standard remote to remote */\n\t\t\tif (tport != -1 && tport != SSH_DEFAULT_PORT) {\n\t\t\t\t/* This would require the remote support URIs */\n\t\t\t\tfatal(\"target port not supported with two \"\n\t\t\t\t    \"remote hosts without the -3 option\");\n\t\t\t}\n\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", ssh_program);\n\t\t\taddargs(&alist, \"-x\");\n\t\t\taddargs(&alist, \"-oClearAllForwardings=yes\");\n\t\t\taddargs(&alist, \"-n\");\n\t\t\tfor (j = 0; j < remote_remote_args.num; j++) {\n\t\t\t\taddargs(&alist, \"%s\",\n\t\t\t\t    remote_remote_args.list[j]);\n\t\t\t}\n\n\t\t\tif (sport != -1) {\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\t\taddargs(&alist, \"%d\", sport);\n\t\t\t}\n\t\t\tif (suser) {\n\t\t\t\taddargs(&alist, \"-l\");\n\t\t\t\taddargs(&alist, \"%s\", suser);\n\t\t\t}\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", host);\n\t\t\taddargs(&alist, \"%s\", cmd);\n\t\t\taddargs(&alist, \"%s\", src);\n\t\t\taddargs(&alist, \"%s%s%s:%s\",\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ);\n\t\t\tif (do_local_cmd(&alist) != 0)\n\t\t\t\terrs = 1;\n\t\t} else {\t/* local to remote */\n\t\t\tif (remin == -1) {\n\t\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\t\tif (do_cmd(thost, tuser, tport, bp, &remin,\n\t\t\t\t    &remout) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tif (response() < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tfree(bp);\n\t\t\t}\n\t\t\tsource(1, argv + i);\n\t\t}\n\t}\nout:\n\tfree(tuser);\n\tfree(thost);\n\tfree(targ);\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}\n\nvoid\ntolocal(int argc, char **argv)\n{\n\tchar *bp, *host = NULL, *src = NULL, *suser = NULL;\n\targlist alist;\n\tint i, r, sport = -1;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0)\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!host) {\t/* Local to local. */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", _PATH_CP);\n\t\t\tif (iamrecursive)\n\t\t\t\taddargs(&alist, \"-r\");\n\t\t\tif (pflag)\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", argv[i]);\n\t\t\taddargs(&alist, \"%s\", argv[argc-1]);\n\t\t\tif (do_local_cmd(&alist))\n\t\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Remote to local. */\n\t\txasprintf(&bp, \"%s -f %s%s\",\n\t\t    cmd, *src == '-' ? \"-- \" : \"\", src);\n\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0) {\n\t\t\tfree(bp);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(bp);\n\t\tsink(1, argv + argc - 1);\n\t\t(void) close(remin);\n\t\tremin = remout = -1;\n\t}\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}\n\nvoid\nsource(int argc, char **argv)\n{\n\tstruct stat stb;\n\tstatic BUF buffer;\n\tBUF *bp;\n\toff_t i, statbytes;\n\tsize_t amt, nr;\n\tint fd = -1, haderr, indx;\n\tchar *last, *name, buf[2048], encname[PATH_MAX];\n\tint len;\n\n\tfor (indx = 0; indx < argc; ++indx) {\n\t\tname = argv[indx];\n\t\tstatbytes = 0;\n\t\tlen = strlen(name);\n\t\twhile (len > 1 && name[len-1] == '/')\n\t\t\tname[--len] = '\\0';\n\t\tif ((fd = open(name, O_RDONLY|O_NONBLOCK, 0)) < 0)\n\t\t\tgoto syserr;\n\t\tif (strchr(name, '\\n') != NULL) {\n\t\t\tstrnvis(encname, name, sizeof(encname), VIS_NL);\n\t\t\tname = encname;\n\t\t}\n\t\tif (fstat(fd, &stb) < 0) {\nsyserr:\t\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\t\tgoto next;\n\t\t}\n\t\tif (stb.st_size < 0) {\n\t\t\trun_err(\"%s: %s\", name, \"Negative file size\");\n\t\t\tgoto next;\n\t\t}\n\t\tunset_nonblock(fd);\n\t\tswitch (stb.st_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tif (iamrecursive) {\n\t\t\t\trsource(name, &stb);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\trun_err(\"%s: not a regular file\", name);\n\t\t\tgoto next;\n\t\t}\n\t\tif ((last = strrchr(name, '/')) == NULL)\n\t\t\tlast = name;\n\t\telse\n\t\t\t++last;\n\t\tcurfile = last;\n\t\tif (pflag) {\n\t\t\tif (do_times(remout, verbose_mode, &stb) < 0)\n\t\t\t\tgoto next;\n\t\t}\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\t\tsnprintf(buf, sizeof buf, \"C%04o %lld %s\\n\",\n\t\t    (u_int) (stb.st_mode & FILEMODEMASK),\n\t\t    (long long)stb.st_size, last);\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sending file modes: %s\", buf);\n\t\t(void) atomicio(vwrite, remout, buf, strlen(buf));\n\t\tif (response() < 0)\n\t\t\tgoto next;\n\t\tif ((bp = allocbuf(&buffer, fd, COPY_BUFLEN)) == NULL) {\nnext:\t\t\tif (fd != -1) {\n\t\t\t\t(void) close(fd);\n\t\t\t\tfd = -1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, stb.st_size, &statbytes);\n\t\tset_nonblock(remout);\n\t\tfor (haderr = i = 0; i < stb.st_size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + (off_t)amt > stb.st_size)\n\t\t\t\tamt = stb.st_size - i;\n\t\t\tif (!haderr) {\n\t\t\t\tif ((nr = atomicio(read, fd,\n\t\t\t\t    bp->buf, amt)) != amt) {\n\t\t\t\t\thaderr = errno;\n\t\t\t\t\tmemset(bp->buf + nr, 0, amt - nr);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Keep writing after error to retain sync */\n\t\t\tif (haderr) {\n\t\t\t\t(void)atomicio(vwrite, remout, bp->buf, amt);\n\t\t\t\tmemset(bp->buf, 0, amt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (atomicio6(vwrite, remout, bp->buf, amt, scpio,\n\t\t\t    &statbytes) != amt)\n\t\t\t\thaderr = errno;\n\t\t}\n\t\tunset_nonblock(remout);\n\n\t\tif (fd != -1) {\n\t\t\tif (close(fd) < 0 && !haderr)\n\t\t\t\thaderr = errno;\n\t\t\tfd = -1;\n\t\t}\n\t\tif (!haderr)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\telse\n\t\t\trun_err(\"%s: %s\", name, strerror(haderr));\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t}\n}\n\nvoid\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}\n\n#define TYPE_OVERFLOW(type, val) \\\n\t((sizeof(type) == 4 && (val) > INT32_MAX) || \\\n\t (sizeof(type) == 8 && (val) > INT64_MAX) || \\\n\t (sizeof(type) != 4 && sizeof(type) != 8))\n\nvoid\nsink(int argc, char **argv)\n{\n\tstatic BUF buffer;\n\tstruct stat stb;\n\tenum {\n\t\tYES, NO, DISPLAYED\n\t} wrerr;\n\tBUF *bp;\n\toff_t i;\n\tsize_t j, count;\n\tint amt, exists, first, ofd;\n\tmode_t mode, omode, mask;\n\toff_t size, statbytes;\n\tunsigned long long ull;\n\tint setimes, targisdir, wrerrno = 0;\n\tchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\tstruct timeval tv[2];\n\n#define\tatime\ttv[0]\n#define\tmtime\ttv[1]\n#define\tSCREWUP(str)\t{ why = str; goto screwup; }\n\n\tif (TYPE_OVERFLOW(time_t, 0) || TYPE_OVERFLOW(off_t, 0))\n\t\tSCREWUP(\"Unexpected off_t/time_t size\");\n\n\tsetimes = targisdir = 0;\n\tmask = umask(0);\n\tif (!pflag)\n\t\t(void) umask(mask);\n\tif (argc != 1) {\n\t\trun_err(\"ambiguous target\");\n\t\texit(1);\n\t}\n\ttarg = *argv;\n\tif (targetshouldbedirectory)\n\t\tverifydir(targ);\n\n\t(void) atomicio(vwrite, remout, \"\", 1);\n\tif (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))\n\t\ttargisdir = 1;\n\tfor (first = 1;; first = 0) {\n\t\tcp = buf;\n\t\tif (atomicio(read, remin, cp, 1) != 1)\n\t\t\treturn;\n\t\tif (*cp++ == '\\n')\n\t\t\tSCREWUP(\"unexpected <newline>\");\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tSCREWUP(\"lost connection\");\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &buf[sizeof(buf) - 1] && ch != '\\n');\n\t\t*cp = 0;\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sink: %s\", buf);\n\n\t\tif (buf[0] == '\\01' || buf[0] == '\\02') {\n\t\t\tif (iamremote == 0) {\n\t\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t\t    NULL, \"%s\", buf + 1);\n\t\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t\t    visbuf, strlen(visbuf));\n\t\t\t}\n\t\t\tif (buf[0] == '\\02')\n\t\t\t\texit(1);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'E') {\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\treturn;\n\t\t}\n\t\tif (ch == '\\n')\n\t\t\t*--cp = 0;\n\n\t\tcp = buf;\n\t\tif (*cp == 'T') {\n\t\t\tsetimes++;\n\t\t\tcp++;\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\"mtime.sec not present\");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"mtime.sec not delimited\");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tmtime.tv_sec = ull;\n\t\t\tmtime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ' || mtime.tv_usec < 0 ||\n\t\t\t    mtime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\"mtime.usec not delimited\");\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\"atime.sec not present\");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"atime.sec not delimited\");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tatime.tv_sec = ull;\n\t\t\tatime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != '\\0' || atime.tv_usec < 0 ||\n\t\t\t    atime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\"atime.usec not delimited\");\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*cp != 'C' && *cp != 'D') {\n\t\t\t/*\n\t\t\t * Check for the case \"rcp remote:foo\\* local:bar\".\n\t\t\t * In this case, the line \"No match.\" can be returned\n\t\t\t * by the shell before the rcp command on the remote is\n\t\t\t * executed so the ^Aerror_message convention isn't\n\t\t\t * followed.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\trun_err(\"%s\", cp);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tSCREWUP(\"expected control record\");\n\t\t}\n\t\tmode = 0;\n\t\tfor (++cp; cp < buf + 5; cp++) {\n\t\t\tif (*cp < '0' || *cp > '7')\n\t\t\t\tSCREWUP(\"bad mode\");\n\t\t\tmode = (mode << 3) | (*cp - '0');\n\t\t}\n\t\tif (!pflag)\n\t\t\tmode &= ~mask;\n\t\tif (*cp++ != ' ')\n\t\t\tSCREWUP(\"mode not delimited\");\n\n\t\tif (!isdigit((unsigned char)*cp))\n\t\t\tSCREWUP(\"size not present\");\n\t\tull = strtoull(cp, &cp, 10);\n\t\tif (!cp || *cp++ != ' ')\n\t\t\tSCREWUP(\"size not delimited\");\n\t\tif (TYPE_OVERFLOW(off_t, ull))\n\t\t\tSCREWUP(\"size out of range\");\n\t\tsize = (off_t)ull;\n\n\t\tif ((strchr(cp, '/') != NULL) || (strcmp(cp, \"..\") == 0)) {\n\t\t\trun_err(\"error: unexpected filename: %s\", cp);\n\t\t\texit(1);\n\t\t}\n\t\tif (targisdir) {\n\t\t\tstatic char *namebuf;\n\t\t\tstatic size_t cursize;\n\t\t\tsize_t need;\n\n\t\t\tneed = strlen(targ) + strlen(cp) + 250;\n\t\t\tif (need > cursize) {\n\t\t\t\tfree(namebuf);\n\t\t\t\tnamebuf = xmalloc(need);\n\t\t\t\tcursize = need;\n\t\t\t}\n\t\t\t(void) snprintf(namebuf, need, \"%s%s%s\", targ,\n\t\t\t    strcmp(targ, \"/\") ? \"/\" : \"\", cp);\n\t\t\tnp = namebuf;\n\t\t} else\n\t\t\tnp = targ;\n\t\tcurfile = cp;\n\t\texists = stat(np, &stb) == 0;\n\t\tif (buf[0] == 'D') {\n\t\t\tint mod_flag = pflag;\n\t\t\tif (!iamrecursive)\n\t\t\t\tSCREWUP(\"received directory without -r\");\n\t\t\tif (exists) {\n\t\t\t\tif (!S_ISDIR(stb.st_mode)) {\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (pflag)\n\t\t\t\t\t(void) chmod(np, mode);\n\t\t\t} else {\n\t\t\t\t/* Handle copying from a read-only\n\t\t\t\t   directory */\n\t\t\t\tmod_flag = 1;\n\t\t\t\tif (mkdir(np, mode | S_IRWXU) < 0)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tvect[0] = xstrdup(np);\n\t\t\tsink(1, vect);\n\t\t\tif (setimes) {\n\t\t\t\tsetimes = 0;\n\t\t\t\tif (utimes(vect[0], tv) < 0)\n\t\t\t\t\trun_err(\"%s: set times: %s\",\n\t\t\t\t\t    vect[0], strerror(errno));\n\t\t\t}\n\t\t\tif (mod_flag)\n\t\t\t\t(void) chmod(vect[0], mode);\n\t\t\tfree(vect[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tomode = mode;\n\t\tmode |= S_IWUSR;\n\t\tif ((ofd = open(np, O_WRONLY|O_CREAT, mode)) < 0) {\nbad:\t\t\trun_err(\"%s: %s\", np, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\tif ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {\n\t\t\t(void) close(ofd);\n\t\t\tcontinue;\n\t\t}\n\t\tcp = bp->buf;\n\t\twrerr = NO;\n\n\t\tstatbytes = 0;\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, size, &statbytes);\n\t\tset_nonblock(remin);\n\t\tfor (count = i = 0; i < size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + amt > size)\n\t\t\t\tamt = size - i;\n\t\t\tcount += amt;\n\t\t\tdo {\n\t\t\t\tj = atomicio6(read, remin, cp, amt,\n\t\t\t\t    scpio, &statbytes);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\trun_err(\"%s\", j != EPIPE ?\n\t\t\t\t\t    strerror(errno) :\n\t\t\t\t\t    \"dropped connection\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tamt -= j;\n\t\t\t\tcp += j;\n\t\t\t} while (amt > 0);\n\n\t\t\tif (count == bp->cnt) {\n\t\t\t\t/* Keep reading so we stay sync'd up. */\n\t\t\t\tif (wrerr == NO) {\n\t\t\t\t\tif (atomicio(vwrite, ofd, bp->buf,\n\t\t\t\t\t    count) != count) {\n\t\t\t\t\t\twrerr = YES;\n\t\t\t\t\t\twrerrno = errno;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tcp = bp->buf;\n\t\t\t}\n\t\t}\n\t\tunset_nonblock(remin);\n\t\tif (count != 0 && wrerr == NO &&\n\t\t    atomicio(vwrite, ofd, bp->buf, count) != count) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\tif (wrerr == NO && (!exists || S_ISREG(stb.st_mode)) &&\n\t\t    ftruncate(ofd, size) != 0) {\n\t\t\trun_err(\"%s: truncate: %s\", np, strerror(errno));\n\t\t\twrerr = DISPLAYED;\n\t\t}\n\t\tif (pflag) {\n\t\t\tif (exists || omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t} else {\n\t\t\tif (!exists && omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode & ~mask)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode & ~mask)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t}\n\t\tif (close(ofd) == -1) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t\tif (setimes && wrerr == NO) {\n\t\t\tsetimes = 0;\n\t\t\tif (utimes(np, tv) < 0) {\n\t\t\t\trun_err(\"%s: set times: %s\",\n\t\t\t\t    np, strerror(errno));\n\t\t\t\twrerr = DISPLAYED;\n\t\t\t}\n\t\t}\n\t\tswitch (wrerr) {\n\t\tcase YES:\n\t\t\trun_err(\"%s: %s\", np, strerror(wrerrno));\n\t\t\tbreak;\n\t\tcase NO:\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tbreak;\n\t\tcase DISPLAYED:\n\t\t\tbreak;\n\t\t}\n\t}\nscrewup:\n\trun_err(\"protocol error: %s\", why);\n\texit(1);\n}\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}\n\nvoid\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: scp [-346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"           [-l limit] [-o ssh_option] [-P port] [-S program] source ... target\\n\");\n\texit(1);\n}\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid\nverifydir(char *cp)\n{\n\tstruct stat stb;\n\n\tif (!stat(cp, &stb)) {\n\t\tif (S_ISDIR(stb.st_mode))\n\t\t\treturn;\n\t\terrno = ENOTDIR;\n\t}\n\trun_err(\"%s: %s\", cp, strerror(errno));\n\tkillchild(0);\n}\n\nint\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit((unsigned char)c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfmprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}\n\nBUF *\nallocbuf(BUF *bp, int fd, int blksize)\n{\n\tsize_t size;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tstruct stat stb;\n\n\tif (fstat(fd, &stb) < 0) {\n\t\trun_err(\"fstat: %s\", strerror(errno));\n\t\treturn (0);\n\t}\n\tsize = ROUNDUP(stb.st_blksize, blksize);\n\tif (size == 0)\n\t\tsize = blksize;\n#else /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tsize = blksize;\n#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tif (bp->cnt >= size)\n\t\treturn (bp);\n\tbp->buf = xrecallocarray(bp->buf, bp->cnt, size, 1);\n\tbp->cnt = size;\n\treturn (bp);\n}\n\nvoid\nlostconn(int signo)\n{\n\tif (!iamremote)\n\t\t(void)write(STDERR_FILENO, \"lost connection\\n\", 16);\n\tif (signo)\n\t\t_exit(1);\n\telse\n\t\texit(1);\n}\n"], "fixing_code": ["/* $OpenBSD: scp.c,v 1.198 2018/11/16 03:03:10 djm Exp $ */\n/*\n * scp - secure remote copy.  This is basically patched BSD rcp which\n * uses ssh to do the data transfer (instead of using rcmd).\n *\n * NOTE: This version should NOT be suid root.  (This uses ssh to\n * do the transfer and ssh has the necessary privileges.)\n *\n * 1995 Timo Rinne <tri@iki.fi>, Tatu Ylonen <ylo@cs.hut.fi>\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n/*\n * Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n * Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Parts from:\n *\n * Copyright (c) 1983, 1990, 1992, 1993, 1995\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#else\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# endif\n#endif\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/wait.h>\n#include <sys/uio.h>\n\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <locale.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#if defined(HAVE_STRNVIS) && defined(HAVE_VIS_H) && !defined(BROKEN_STRNVIS)\n#include <vis.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"utf8.h\"\n\nextern char *__progname;\n\n#define COPY_BUFLEN\t16384\n\nint do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);\nint do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);\n\n/* Struct for addargs */\narglist args;\narglist remote_remote_args;\n\n/* Bandwidth limit */\nlong long limit_kbps = 0;\nstruct bwlimit bwlimit;\n\n/* Name of current file being transferred. */\nchar *curfile;\n\n/* This is set to non-zero to enable verbose mode. */\nint verbose_mode = 0;\n\n/* This is set to zero if the progressmeter is not desired. */\nint showprogress = 1;\n\n/*\n * This is set to non-zero if remote-remote copy should be piped\n * through this process.\n */\nint throughlocal = 0;\n\n/* Non-standard port to use for the ssh connection or -1. */\nint sshport = -1;\n\n/* This is the program to execute for the secured connection. (\"ssh\" or -S) */\nchar *ssh_program = _PATH_SSH_PROGRAM;\n\n/* This is used to store the pid of ssh_program */\npid_t do_cmd_pid = -1;\n\nstatic void\nkillchild(int signo)\n{\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo ? signo : SIGTERM);\n\t\twaitpid(do_cmd_pid, NULL, 0);\n\t}\n\n\tif (signo)\n\t\t_exit(1);\n\texit(1);\n}\n\nstatic void\nsuspchild(int signo)\n{\n\tint status;\n\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo);\n\t\twhile (waitpid(do_cmd_pid, &status, WUNTRACED) == -1 &&\n\t\t    errno == EINTR)\n\t\t\t;\n\t\tkill(getpid(), SIGSTOP);\n\t}\n}\n\nstatic int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfmprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n\t\texit(1);\n\t}\n\n\tdo_cmd_pid = pid;\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n/*\n * This function executes the given command as the specified user on the\n * given host.  This returns < 0 if execution fails, and >= 0 otherwise. This\n * assigns the input and output file descriptors on success.\n */\n\nint\ndo_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout)\n{\n\tint pin[2], pout[2], reserved[2];\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/*\n\t * Reserve two descriptors so that the real pipes won't get\n\t * descriptors 0 and 1 because that will screw up dup2 below.\n\t */\n\tif (pipe(reserved) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Create a socket pair for communicating with ssh. */\n\tif (pipe(pin) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\tif (pipe(pout) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Free the reserved descriptors. */\n\tclose(reserved[0]);\n\tclose(reserved[1]);\n\n\tsignal(SIGTSTP, suspchild);\n\tsignal(SIGTTIN, suspchild);\n\tsignal(SIGTTOU, suspchild);\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tdo_cmd_pid = fork();\n\tif (do_cmd_pid == 0) {\n\t\t/* Child. */\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tdup2(pin[0], 0);\n\t\tdup2(pout[1], 1);\n\t\tclose(pin[0]);\n\t\tclose(pout[1]);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (do_cmd_pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\t/* Parent.  Close the other side, and return the local side. */\n\tclose(pin[0]);\n\t*fdout = pin[1];\n\tclose(pout[1]);\n\t*fdin = pout[0];\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\treturn 0;\n}\n\n/*\n * This function executes a command similar to do_cmd(), but expects the\n * input and output descriptors to be setup by a previous call to do_cmd().\n * This way the input and output of two commands can be connected.\n */\nint\ndo_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout)\n{\n\tpid_t pid;\n\tint status;\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: 2nd program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tpid = fork();\n\tif (pid == 0) {\n\t\tdup2(fdin, 0);\n\t\tdup2(fdout, 1);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_cmd2: waitpid: %s\", strerror(errno));\n\treturn 0;\n}\n\ntypedef struct {\n\tsize_t cnt;\n\tchar *buf;\n} BUF;\n\nBUF *allocbuf(BUF *, int, int);\nvoid lostconn(int);\nint okname(char *);\nvoid run_err(const char *,...);\nvoid verifydir(char *);\n\nstruct passwd *pwd;\nuid_t userid;\nint errs, remin, remout;\nint pflag, iamremote, iamrecursive, targetshouldbedirectory;\n\n#define\tCMDNEEDS\t64\nchar cmd[CMDNEEDS];\t\t/* must hold \"rcp -r -p -d\\0\" */\n\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid sink(int, char *[]);\nvoid source(int, char *[]);\nvoid tolocal(int, char *[]);\nvoid toremote(int, char *[]);\nvoid usage(void);\n\nint\nmain(int argc, char **argv)\n{\n\tint ch, fflag, tflag, status, n;\n\tchar **newargv;\n\tconst char *errstr;\n\textern char *optarg;\n\textern int optind;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tmsetlocale();\n\n\t/* Copy argv, because we modify it */\n\tnewargv = xcalloc(MAXIMUM(argc + 1, 1), sizeof(*newargv));\n\tfor (n = 0; n < argc; n++)\n\t\tnewargv[n] = xstrdup(argv[n]);\n\targv = newargv;\n\n\t__progname = ssh_get_progname(argv[0]);\n\n\tmemset(&args, '\\0', sizeof(args));\n\tmemset(&remote_remote_args, '\\0', sizeof(remote_remote_args));\n\targs.list = remote_remote_args.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-x\");\n\taddargs(&args, \"-oForwardAgent=no\");\n\taddargs(&args, \"-oPermitLocalCommand=no\");\n\taddargs(&args, \"-oClearAllForwardings=yes\");\n\taddargs(&args, \"-oRemoteCommand=none\");\n\taddargs(&args, \"-oRequestTTY=no\");\n\n\tfflag = tflag = 0;\n\twhile ((ch = getopt(argc, argv, \"dfl:prtvBCc:i:P:q12346S:o:F:\")) != -1)\n\t\tswitch (ch) {\n\t\t/* User-visible flags. */\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tthroughlocal = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'F':\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"%s\", optarg);\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tsshport = a2port(optarg);\n\t\t\tif (sshport <= 0)\n\t\t\t\tfatal(\"bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\taddargs(&remote_remote_args, \"-oBatchmode=yes\");\n\t\t\taddargs(&args, \"-oBatchmode=yes\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024; /* kbps */\n\t\t\tbandwidth_limit_init(&bwlimit, limit_kbps, COPY_BUFLEN);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tiamrecursive = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\taddargs(&args, \"-v\");\n\t\t\taddargs(&remote_remote_args, \"-v\");\n\t\t\tverbose_mode = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\taddargs(&args, \"-q\");\n\t\t\taddargs(&remote_remote_args, \"-q\");\n\t\t\tshowprogress = 0;\n\t\t\tbreak;\n\n\t\t/* Server options. */\n\t\tcase 'd':\n\t\t\ttargetshouldbedirectory = 1;\n\t\t\tbreak;\n\t\tcase 'f':\t/* \"from\" */\n\t\t\tiamremote = 1;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\t/* \"to\" */\n\t\t\tiamremote = 1;\n\t\t\ttflag = 1;\n#ifdef HAVE_CYGWIN\n\t\t\tsetmode(0, O_BINARY);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tif ((pwd = getpwuid(userid = getuid())) == NULL)\n\t\tfatal(\"unknown user %u\", (u_int) userid);\n\n\tif (!isatty(STDOUT_FILENO))\n\t\tshowprogress = 0;\n\n\tif (pflag) {\n\t\t/* Cannot pledge: -p allows setuid/setgid files... */\n\t} else {\n\t\tif (pledge(\"stdio rpath wpath cpath fattr tty proc exec\",\n\t\t    NULL) == -1) {\n\t\t\tperror(\"pledge\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tremin = STDIN_FILENO;\n\tremout = STDOUT_FILENO;\n\n\tif (fflag) {\n\t\t/* Follow \"protocol\", send data. */\n\t\t(void) response();\n\t\tsource(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (tflag) {\n\t\t/* Receive data. */\n\t\tsink(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (argc < 2)\n\t\tusage();\n\tif (argc > 2)\n\t\ttargetshouldbedirectory = 1;\n\n\tremin = remout = -1;\n\tdo_cmd_pid = -1;\n\t/* Command to be executed on remote system using \"ssh\". */\n\t(void) snprintf(cmd, sizeof cmd, \"scp%s%s%s%s\",\n\t    verbose_mode ? \" -v\" : \"\",\n\t    iamrecursive ? \" -r\" : \"\", pflag ? \" -p\" : \"\",\n\t    targetshouldbedirectory ? \" -d\" : \"\");\n\n\t(void) signal(SIGPIPE, lostconn);\n\n\tif (colon(argv[argc - 1]))\t/* Dest is remote host. */\n\t\ttoremote(argc, argv);\n\telse {\n\t\tif (targetshouldbedirectory)\n\t\t\tverifydir(argv[argc - 1]);\n\t\ttolocal(argc, argv);\t/* Dest is local host. */\n\t}\n\t/*\n\t * Finally check the exit status of the ssh process, if one was forked\n\t * and no error has occurred yet\n\t */\n\tif (do_cmd_pid != -1 && errs == 0) {\n\t\tif (remin != -1)\n\t\t    (void) close(remin);\n\t\tif (remout != -1)\n\t\t    (void) close(remout);\n\t\tif (waitpid(do_cmd_pid, &status, 0) == -1)\n\t\t\terrs = 1;\n\t\telse {\n\t\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\t\t\terrs = 1;\n\t\t}\n\t}\n\texit(errs != 0);\n}\n\n/* Callback from atomicio6 to update progress meter and limit bandwidth */\nstatic int\nscpio(void *_cnt, size_t s)\n{\n\toff_t *cnt = (off_t *)_cnt;\n\n\t*cnt += s;\n\tif (limit_kbps > 0)\n\t\tbandwidth_limit(&bwlimit, s);\n\treturn 0;\n}\n\nstatic int\ndo_times(int fd, int verb, const struct stat *sb)\n{\n\t/* strlen(2^64) == 20; strlen(10^6) == 7 */\n\tchar buf[(20 + 7 + 2) * 2 + 2];\n\n\t(void)snprintf(buf, sizeof(buf), \"T%llu 0 %llu 0\\n\",\n\t    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),\n\t    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));\n\tif (verb) {\n\t\tfprintf(stderr, \"File mtime %lld atime %lld\\n\",\n\t\t    (long long)sb->st_mtime, (long long)sb->st_atime);\n\t\tfprintf(stderr, \"Sending file timestamps: %s\", buf);\n\t}\n\t(void) atomicio(vwrite, fd, buf, strlen(buf));\n\treturn (response());\n}\n\nstatic int\nparse_scp_uri(const char *uri, char **userp, char **hostp, int *portp,\n     char **pathp)\n{\n\tint r;\n\n\tr = parse_uri(\"scp\", uri, userp, hostp, portp, pathp);\n\tif (r == 0 && *pathp == NULL)\n\t\t*pathp = xstrdup(\".\");\n\treturn r;\n}\n\nvoid\ntoremote(int argc, char **argv)\n{\n\tchar *suser = NULL, *host = NULL, *src = NULL;\n\tchar *bp, *tuser, *thost, *targ;\n\tint sport = -1, tport = -1;\n\targlist alist;\n\tint i, r;\n\tu_int j;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\t/* Parse target */\n\tr = parse_scp_uri(argv[argc - 1], &tuser, &thost, &tport, &targ);\n\tif (r == -1) {\n\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[argc - 1]);\n\t\t++errs;\n\t\tgoto out;\n\t}\n\tif (r != 0) {\n\t\tif (parse_user_host_path(argv[argc - 1], &tuser, &thost,\n\t\t    &targ) == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid target\\n\", argv[argc - 1]);\n\t\t\t++errs;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (tuser != NULL && !okname(tuser)) {\n\t\t++errs;\n\t\tgoto out;\n\t}\n\n\t/* Parse source files */\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0) {\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\t}\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (host && throughlocal) {\t/* extended remote to remote */\n\t\t\txasprintf(&bp, \"%s -f %s%s\", cmd,\n\t\t\t    *src == '-' ? \"-- \" : \"\", src);\n\t\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\tif (do_cmd2(thost, tuser, tport, bp, remin, remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\t(void) close(remin);\n\t\t\t(void) close(remout);\n\t\t\tremin = remout = -1;\n\t\t} else if (host) {\t/* standard remote to remote */\n\t\t\tif (tport != -1 && tport != SSH_DEFAULT_PORT) {\n\t\t\t\t/* This would require the remote support URIs */\n\t\t\t\tfatal(\"target port not supported with two \"\n\t\t\t\t    \"remote hosts without the -3 option\");\n\t\t\t}\n\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", ssh_program);\n\t\t\taddargs(&alist, \"-x\");\n\t\t\taddargs(&alist, \"-oClearAllForwardings=yes\");\n\t\t\taddargs(&alist, \"-n\");\n\t\t\tfor (j = 0; j < remote_remote_args.num; j++) {\n\t\t\t\taddargs(&alist, \"%s\",\n\t\t\t\t    remote_remote_args.list[j]);\n\t\t\t}\n\n\t\t\tif (sport != -1) {\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\t\taddargs(&alist, \"%d\", sport);\n\t\t\t}\n\t\t\tif (suser) {\n\t\t\t\taddargs(&alist, \"-l\");\n\t\t\t\taddargs(&alist, \"%s\", suser);\n\t\t\t}\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", host);\n\t\t\taddargs(&alist, \"%s\", cmd);\n\t\t\taddargs(&alist, \"%s\", src);\n\t\t\taddargs(&alist, \"%s%s%s:%s\",\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ);\n\t\t\tif (do_local_cmd(&alist) != 0)\n\t\t\t\terrs = 1;\n\t\t} else {\t/* local to remote */\n\t\t\tif (remin == -1) {\n\t\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\t\tif (do_cmd(thost, tuser, tport, bp, &remin,\n\t\t\t\t    &remout) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tif (response() < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tfree(bp);\n\t\t\t}\n\t\t\tsource(1, argv + i);\n\t\t}\n\t}\nout:\n\tfree(tuser);\n\tfree(thost);\n\tfree(targ);\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}\n\nvoid\ntolocal(int argc, char **argv)\n{\n\tchar *bp, *host = NULL, *src = NULL, *suser = NULL;\n\targlist alist;\n\tint i, r, sport = -1;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0)\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!host) {\t/* Local to local. */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", _PATH_CP);\n\t\t\tif (iamrecursive)\n\t\t\t\taddargs(&alist, \"-r\");\n\t\t\tif (pflag)\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", argv[i]);\n\t\t\taddargs(&alist, \"%s\", argv[argc-1]);\n\t\t\tif (do_local_cmd(&alist))\n\t\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Remote to local. */\n\t\txasprintf(&bp, \"%s -f %s%s\",\n\t\t    cmd, *src == '-' ? \"-- \" : \"\", src);\n\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0) {\n\t\t\tfree(bp);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(bp);\n\t\tsink(1, argv + argc - 1);\n\t\t(void) close(remin);\n\t\tremin = remout = -1;\n\t}\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}\n\nvoid\nsource(int argc, char **argv)\n{\n\tstruct stat stb;\n\tstatic BUF buffer;\n\tBUF *bp;\n\toff_t i, statbytes;\n\tsize_t amt, nr;\n\tint fd = -1, haderr, indx;\n\tchar *last, *name, buf[2048], encname[PATH_MAX];\n\tint len;\n\n\tfor (indx = 0; indx < argc; ++indx) {\n\t\tname = argv[indx];\n\t\tstatbytes = 0;\n\t\tlen = strlen(name);\n\t\twhile (len > 1 && name[len-1] == '/')\n\t\t\tname[--len] = '\\0';\n\t\tif ((fd = open(name, O_RDONLY|O_NONBLOCK, 0)) < 0)\n\t\t\tgoto syserr;\n\t\tif (strchr(name, '\\n') != NULL) {\n\t\t\tstrnvis(encname, name, sizeof(encname), VIS_NL);\n\t\t\tname = encname;\n\t\t}\n\t\tif (fstat(fd, &stb) < 0) {\nsyserr:\t\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\t\tgoto next;\n\t\t}\n\t\tif (stb.st_size < 0) {\n\t\t\trun_err(\"%s: %s\", name, \"Negative file size\");\n\t\t\tgoto next;\n\t\t}\n\t\tunset_nonblock(fd);\n\t\tswitch (stb.st_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tif (iamrecursive) {\n\t\t\t\trsource(name, &stb);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\trun_err(\"%s: not a regular file\", name);\n\t\t\tgoto next;\n\t\t}\n\t\tif ((last = strrchr(name, '/')) == NULL)\n\t\t\tlast = name;\n\t\telse\n\t\t\t++last;\n\t\tcurfile = last;\n\t\tif (pflag) {\n\t\t\tif (do_times(remout, verbose_mode, &stb) < 0)\n\t\t\t\tgoto next;\n\t\t}\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\t\tsnprintf(buf, sizeof buf, \"C%04o %lld %s\\n\",\n\t\t    (u_int) (stb.st_mode & FILEMODEMASK),\n\t\t    (long long)stb.st_size, last);\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sending file modes: %s\", buf);\n\t\t(void) atomicio(vwrite, remout, buf, strlen(buf));\n\t\tif (response() < 0)\n\t\t\tgoto next;\n\t\tif ((bp = allocbuf(&buffer, fd, COPY_BUFLEN)) == NULL) {\nnext:\t\t\tif (fd != -1) {\n\t\t\t\t(void) close(fd);\n\t\t\t\tfd = -1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, stb.st_size, &statbytes);\n\t\tset_nonblock(remout);\n\t\tfor (haderr = i = 0; i < stb.st_size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + (off_t)amt > stb.st_size)\n\t\t\t\tamt = stb.st_size - i;\n\t\t\tif (!haderr) {\n\t\t\t\tif ((nr = atomicio(read, fd,\n\t\t\t\t    bp->buf, amt)) != amt) {\n\t\t\t\t\thaderr = errno;\n\t\t\t\t\tmemset(bp->buf + nr, 0, amt - nr);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Keep writing after error to retain sync */\n\t\t\tif (haderr) {\n\t\t\t\t(void)atomicio(vwrite, remout, bp->buf, amt);\n\t\t\t\tmemset(bp->buf, 0, amt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (atomicio6(vwrite, remout, bp->buf, amt, scpio,\n\t\t\t    &statbytes) != amt)\n\t\t\t\thaderr = errno;\n\t\t}\n\t\tunset_nonblock(remout);\n\n\t\tif (fd != -1) {\n\t\t\tif (close(fd) < 0 && !haderr)\n\t\t\t\thaderr = errno;\n\t\t\tfd = -1;\n\t\t}\n\t\tif (!haderr)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\telse\n\t\t\trun_err(\"%s: %s\", name, strerror(haderr));\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t}\n}\n\nvoid\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}\n\n#define TYPE_OVERFLOW(type, val) \\\n\t((sizeof(type) == 4 && (val) > INT32_MAX) || \\\n\t (sizeof(type) == 8 && (val) > INT64_MAX) || \\\n\t (sizeof(type) != 4 && sizeof(type) != 8))\n\nvoid\nsink(int argc, char **argv)\n{\n\tstatic BUF buffer;\n\tstruct stat stb;\n\tenum {\n\t\tYES, NO, DISPLAYED\n\t} wrerr;\n\tBUF *bp;\n\toff_t i;\n\tsize_t j, count;\n\tint amt, exists, first, ofd;\n\tmode_t mode, omode, mask;\n\toff_t size, statbytes;\n\tunsigned long long ull;\n\tint setimes, targisdir, wrerrno = 0;\n\tchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\tstruct timeval tv[2];\n\n#define\tatime\ttv[0]\n#define\tmtime\ttv[1]\n#define\tSCREWUP(str)\t{ why = str; goto screwup; }\n\n\tif (TYPE_OVERFLOW(time_t, 0) || TYPE_OVERFLOW(off_t, 0))\n\t\tSCREWUP(\"Unexpected off_t/time_t size\");\n\n\tsetimes = targisdir = 0;\n\tmask = umask(0);\n\tif (!pflag)\n\t\t(void) umask(mask);\n\tif (argc != 1) {\n\t\trun_err(\"ambiguous target\");\n\t\texit(1);\n\t}\n\ttarg = *argv;\n\tif (targetshouldbedirectory)\n\t\tverifydir(targ);\n\n\t(void) atomicio(vwrite, remout, \"\", 1);\n\tif (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))\n\t\ttargisdir = 1;\n\tfor (first = 1;; first = 0) {\n\t\tcp = buf;\n\t\tif (atomicio(read, remin, cp, 1) != 1)\n\t\t\treturn;\n\t\tif (*cp++ == '\\n')\n\t\t\tSCREWUP(\"unexpected <newline>\");\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tSCREWUP(\"lost connection\");\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &buf[sizeof(buf) - 1] && ch != '\\n');\n\t\t*cp = 0;\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sink: %s\", buf);\n\n\t\tif (buf[0] == '\\01' || buf[0] == '\\02') {\n\t\t\tif (iamremote == 0) {\n\t\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t\t    NULL, \"%s\", buf + 1);\n\t\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t\t    visbuf, strlen(visbuf));\n\t\t\t}\n\t\t\tif (buf[0] == '\\02')\n\t\t\t\texit(1);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'E') {\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\treturn;\n\t\t}\n\t\tif (ch == '\\n')\n\t\t\t*--cp = 0;\n\n\t\tcp = buf;\n\t\tif (*cp == 'T') {\n\t\t\tsetimes++;\n\t\t\tcp++;\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\"mtime.sec not present\");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"mtime.sec not delimited\");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tmtime.tv_sec = ull;\n\t\t\tmtime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ' || mtime.tv_usec < 0 ||\n\t\t\t    mtime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\"mtime.usec not delimited\");\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\"atime.sec not present\");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"atime.sec not delimited\");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tatime.tv_sec = ull;\n\t\t\tatime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != '\\0' || atime.tv_usec < 0 ||\n\t\t\t    atime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\"atime.usec not delimited\");\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*cp != 'C' && *cp != 'D') {\n\t\t\t/*\n\t\t\t * Check for the case \"rcp remote:foo\\* local:bar\".\n\t\t\t * In this case, the line \"No match.\" can be returned\n\t\t\t * by the shell before the rcp command on the remote is\n\t\t\t * executed so the ^Aerror_message convention isn't\n\t\t\t * followed.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\trun_err(\"%s\", cp);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tSCREWUP(\"expected control record\");\n\t\t}\n\t\tmode = 0;\n\t\tfor (++cp; cp < buf + 5; cp++) {\n\t\t\tif (*cp < '0' || *cp > '7')\n\t\t\t\tSCREWUP(\"bad mode\");\n\t\t\tmode = (mode << 3) | (*cp - '0');\n\t\t}\n\t\tif (!pflag)\n\t\t\tmode &= ~mask;\n\t\tif (*cp++ != ' ')\n\t\t\tSCREWUP(\"mode not delimited\");\n\n\t\tif (!isdigit((unsigned char)*cp))\n\t\t\tSCREWUP(\"size not present\");\n\t\tull = strtoull(cp, &cp, 10);\n\t\tif (!cp || *cp++ != ' ')\n\t\t\tSCREWUP(\"size not delimited\");\n\t\tif (TYPE_OVERFLOW(off_t, ull))\n\t\t\tSCREWUP(\"size out of range\");\n\t\tsize = (off_t)ull;\n\n\t\tif (*cp == '\\0' || strchr(cp, '/') != NULL ||\n\t\t    strcmp(cp, \".\") == 0 || strcmp(cp, \"..\") == 0) {\n\t\t\trun_err(\"error: unexpected filename: %s\", cp);\n\t\t\texit(1);\n\t\t}\n\t\tif (targisdir) {\n\t\t\tstatic char *namebuf;\n\t\t\tstatic size_t cursize;\n\t\t\tsize_t need;\n\n\t\t\tneed = strlen(targ) + strlen(cp) + 250;\n\t\t\tif (need > cursize) {\n\t\t\t\tfree(namebuf);\n\t\t\t\tnamebuf = xmalloc(need);\n\t\t\t\tcursize = need;\n\t\t\t}\n\t\t\t(void) snprintf(namebuf, need, \"%s%s%s\", targ,\n\t\t\t    strcmp(targ, \"/\") ? \"/\" : \"\", cp);\n\t\t\tnp = namebuf;\n\t\t} else\n\t\t\tnp = targ;\n\t\tcurfile = cp;\n\t\texists = stat(np, &stb) == 0;\n\t\tif (buf[0] == 'D') {\n\t\t\tint mod_flag = pflag;\n\t\t\tif (!iamrecursive)\n\t\t\t\tSCREWUP(\"received directory without -r\");\n\t\t\tif (exists) {\n\t\t\t\tif (!S_ISDIR(stb.st_mode)) {\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (pflag)\n\t\t\t\t\t(void) chmod(np, mode);\n\t\t\t} else {\n\t\t\t\t/* Handle copying from a read-only\n\t\t\t\t   directory */\n\t\t\t\tmod_flag = 1;\n\t\t\t\tif (mkdir(np, mode | S_IRWXU) < 0)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tvect[0] = xstrdup(np);\n\t\t\tsink(1, vect);\n\t\t\tif (setimes) {\n\t\t\t\tsetimes = 0;\n\t\t\t\tif (utimes(vect[0], tv) < 0)\n\t\t\t\t\trun_err(\"%s: set times: %s\",\n\t\t\t\t\t    vect[0], strerror(errno));\n\t\t\t}\n\t\t\tif (mod_flag)\n\t\t\t\t(void) chmod(vect[0], mode);\n\t\t\tfree(vect[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tomode = mode;\n\t\tmode |= S_IWUSR;\n\t\tif ((ofd = open(np, O_WRONLY|O_CREAT, mode)) < 0) {\nbad:\t\t\trun_err(\"%s: %s\", np, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\tif ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {\n\t\t\t(void) close(ofd);\n\t\t\tcontinue;\n\t\t}\n\t\tcp = bp->buf;\n\t\twrerr = NO;\n\n\t\tstatbytes = 0;\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, size, &statbytes);\n\t\tset_nonblock(remin);\n\t\tfor (count = i = 0; i < size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + amt > size)\n\t\t\t\tamt = size - i;\n\t\t\tcount += amt;\n\t\t\tdo {\n\t\t\t\tj = atomicio6(read, remin, cp, amt,\n\t\t\t\t    scpio, &statbytes);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\trun_err(\"%s\", j != EPIPE ?\n\t\t\t\t\t    strerror(errno) :\n\t\t\t\t\t    \"dropped connection\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tamt -= j;\n\t\t\t\tcp += j;\n\t\t\t} while (amt > 0);\n\n\t\t\tif (count == bp->cnt) {\n\t\t\t\t/* Keep reading so we stay sync'd up. */\n\t\t\t\tif (wrerr == NO) {\n\t\t\t\t\tif (atomicio(vwrite, ofd, bp->buf,\n\t\t\t\t\t    count) != count) {\n\t\t\t\t\t\twrerr = YES;\n\t\t\t\t\t\twrerrno = errno;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tcp = bp->buf;\n\t\t\t}\n\t\t}\n\t\tunset_nonblock(remin);\n\t\tif (count != 0 && wrerr == NO &&\n\t\t    atomicio(vwrite, ofd, bp->buf, count) != count) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\tif (wrerr == NO && (!exists || S_ISREG(stb.st_mode)) &&\n\t\t    ftruncate(ofd, size) != 0) {\n\t\t\trun_err(\"%s: truncate: %s\", np, strerror(errno));\n\t\t\twrerr = DISPLAYED;\n\t\t}\n\t\tif (pflag) {\n\t\t\tif (exists || omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t} else {\n\t\t\tif (!exists && omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode & ~mask)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode & ~mask)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t}\n\t\tif (close(ofd) == -1) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t\tif (setimes && wrerr == NO) {\n\t\t\tsetimes = 0;\n\t\t\tif (utimes(np, tv) < 0) {\n\t\t\t\trun_err(\"%s: set times: %s\",\n\t\t\t\t    np, strerror(errno));\n\t\t\t\twrerr = DISPLAYED;\n\t\t\t}\n\t\t}\n\t\tswitch (wrerr) {\n\t\tcase YES:\n\t\t\trun_err(\"%s: %s\", np, strerror(wrerrno));\n\t\t\tbreak;\n\t\tcase NO:\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tbreak;\n\t\tcase DISPLAYED:\n\t\t\tbreak;\n\t\t}\n\t}\nscrewup:\n\trun_err(\"protocol error: %s\", why);\n\texit(1);\n}\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}\n\nvoid\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: scp [-346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"           [-l limit] [-o ssh_option] [-P port] [-S program] source ... target\\n\");\n\texit(1);\n}\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid\nverifydir(char *cp)\n{\n\tstruct stat stb;\n\n\tif (!stat(cp, &stb)) {\n\t\tif (S_ISDIR(stb.st_mode))\n\t\t\treturn;\n\t\terrno = ENOTDIR;\n\t}\n\trun_err(\"%s: %s\", cp, strerror(errno));\n\tkillchild(0);\n}\n\nint\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit((unsigned char)c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfmprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}\n\nBUF *\nallocbuf(BUF *bp, int fd, int blksize)\n{\n\tsize_t size;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tstruct stat stb;\n\n\tif (fstat(fd, &stb) < 0) {\n\t\trun_err(\"fstat: %s\", strerror(errno));\n\t\treturn (0);\n\t}\n\tsize = ROUNDUP(stb.st_blksize, blksize);\n\tif (size == 0)\n\t\tsize = blksize;\n#else /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tsize = blksize;\n#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tif (bp->cnt >= size)\n\t\treturn (bp);\n\tbp->buf = xrecallocarray(bp->buf, bp->cnt, size, 1);\n\tbp->cnt = size;\n\treturn (bp);\n}\n\nvoid\nlostconn(int signo)\n{\n\tif (!iamremote)\n\t\t(void)write(STDERR_FILENO, \"lost connection\\n\", 16);\n\tif (signo)\n\t\t_exit(1);\n\telse\n\t\texit(1);\n}\n"], "filenames": ["scp.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [1110], "fixing_code_start_loc": [1], "fixing_code_end_loc": [1111], "type": "CWE-863", "message": "In OpenSSH 7.9, scp.c in the scp client allows remote SSH servers to bypass intended access restrictions via the filename of . or an empty filename. The impact is modifying the permissions of the target directory on the client side.", "other": {"cve": {"id": "CVE-2018-20685", "sourceIdentifier": "cve@mitre.org", "published": "2019-01-10T21:29:00.377", "lastModified": "2023-02-23T23:15:18.260", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In OpenSSH 7.9, scp.c in the scp client allows remote SSH servers to bypass intended access restrictions via the filename of . or an empty filename. The impact is modifying the permissions of the target directory on the client side."}, {"lang": "es", "value": "En OpenSSH 7.9, scp.c en el cliente scp permite que los servidores SSH omitan las restricciones de acceso planeadas mediante un nombre de archivo \".\" o un nombre de archivo vac\u00edo. El impacto consiste en modificar los permisos del directorio objetivo en el lado del cliente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:*:*:*:*:*:*:*:*", "versionEndIncluding": "7.9", "matchCriteriaId": "52D09A55-B853-43B5-8397-E2AC6CD0EBBC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:winscp:winscp:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.13", "matchCriteriaId": "3D0A98E2-B715-4EF5-9CF8-07500E119271"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "85DF4B3F-4BBC-42B7-B729-096934523D63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy:-:*:*:*:*:*:*:*", "matchCriteriaId": "7E968916-8CE0-4165-851F-14E37ECEA948"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:storage_automation_store:-:*:*:*:*:*:*:*", "matchCriteriaId": "7B7A6697-98CC-4E36-93DB-B7160F8399F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "92BC9265-6959-4D37-BE5E-8C45E98992F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "831F0F47-3565-4763-B16F-C87B1FF2035E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "0E3F09B5-569F-4C58-9FCA-3C0953D107B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "6C3741B8-851F-475D-B428-523F4F722350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "6897676D-53F9-45B3-B27F-7FF9A4C58D33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "E28F226A-CBC7-4A32-BE58-398FA5B42481"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "76C24D94-834A-4E9D-8F73-624AFA99AAA2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "B09ACF2D-D83F-4A86-8185-9569605D8EE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "AC10D919-57FD-4725-B8D2-39ECB476902F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "1272DF03-7674-4BD4-8E64-94004B195448"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:10:*:*:*:*:*:*:*", "matchCriteriaId": "964B57CD-CB8A-4520-B358-1C93EC5EF2DC"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m10-1_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp2361", "matchCriteriaId": "271CACEB-10F5-4CA8-9C99-3274F18EE62D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m10-1:-:*:*:*:*:*:*:*", "matchCriteriaId": "983D27DE-BC89-454E-AE47-95A26A3651E2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m10-4_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp2361", "matchCriteriaId": "433EEE1B-134C-48F9-8688-23C5F1ABBF0F"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m10-4:-:*:*:*:*:*:*:*", "matchCriteriaId": "5825AEE1-B668-40BD-86A9-2799430C742C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m10-4s_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp2361", "matchCriteriaId": "47FFEE5C-5DAE-4FAD-9651-7983DE092120"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m10-4s:-:*:*:*:*:*:*:*", "matchCriteriaId": "3DA2D526-BDCF-4A65-914A-B3BA3A0CD613"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m12-1_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp2361", "matchCriteriaId": "2FD8BD3B-C35B-4C44-B5A1-FA4646ACB374"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m12-1:-:*:*:*:*:*:*:*", "matchCriteriaId": "EE0CF40B-E5BD-4558-9321-184D58EF621D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m12-2_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp2361", "matchCriteriaId": "66D6EF49-7094-41D9-BDF5-AE5846E37418"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m12-2:-:*:*:*:*:*:*:*", "matchCriteriaId": "0F3C9C09-7B2B-4DB6-8BE0-35302ED35776"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m12-2s_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp2361", "matchCriteriaId": "6593DA00-EE33-4223-BEAE-8DC629E79287"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m12-2s:-:*:*:*:*:*:*:*", "matchCriteriaId": "95503CE5-1D06-4092-A60D-D310AADCAFB1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m10-1_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp3070", "matchCriteriaId": "67E048EC-4A4F-4F0A-B0B5-F234700293DA"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m10-1:-:*:*:*:*:*:*:*", "matchCriteriaId": "983D27DE-BC89-454E-AE47-95A26A3651E2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m10-4_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp3070", "matchCriteriaId": "FF6FAFAE-EBA5-43D2-9CA8-ECF3DD3B285E"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m10-4:-:*:*:*:*:*:*:*", "matchCriteriaId": "5825AEE1-B668-40BD-86A9-2799430C742C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m10-4s_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp3070", "matchCriteriaId": "665502CB-FCC8-4619-B673-408F7190252A"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m10-4s:-:*:*:*:*:*:*:*", "matchCriteriaId": "3DA2D526-BDCF-4A65-914A-B3BA3A0CD613"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m10-4s_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp3070", "matchCriteriaId": "665502CB-FCC8-4619-B673-408F7190252A"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m10-4s:-:*:*:*:*:*:*:*", "matchCriteriaId": "3DA2D526-BDCF-4A65-914A-B3BA3A0CD613"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m12-1_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp3070", "matchCriteriaId": "483F5457-7E06-46F3-A808-194289B98AFF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m12-1:-:*:*:*:*:*:*:*", "matchCriteriaId": "EE0CF40B-E5BD-4558-9321-184D58EF621D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m12-2_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp3070", "matchCriteriaId": "D5644E3E-941A-429A-9AFB-C1023659C1C2"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m12-2:-:*:*:*:*:*:*:*", "matchCriteriaId": "0F3C9C09-7B2B-4DB6-8BE0-35302ED35776"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fujitsu:m12-2s_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "xcp3070", "matchCriteriaId": "0C1318DD-6AF4-490D-A4AE-079BA544EF8F"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:fujitsu:m12-2s:-:*:*:*:*:*:*:*", "matchCriteriaId": "95503CE5-1D06-4092-A60D-D310AADCAFB1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:scalance_x204rna_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.7", "matchCriteriaId": "0D3A0312-1249-4257-98F1-57E8959989C5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:scalance_x204rna:-:*:*:*:*:*:*:*", "matchCriteriaId": "EA8B483F-0FD2-49F8-A86A-672A6E007949"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:scalance_x204rna_eec_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.7", "matchCriteriaId": "FC0C9671-47BB-43CB-8906-9BC2B86B3229"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:scalance_x204rna_eec:-:*:*:*:*:*:*:*", "matchCriteriaId": "C834C295-D600-44E8-9783-49A319084F5A"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/106531", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:3702", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-412672.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.bin/ssh/scp.c.diff?r1=1.197&r2=1.198&f=h", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/openssh/openssh-portable/commit/6010c0303a422a9c5fa8860c061bf7105eb7f8b2", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00030.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201903-16", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-53", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190215-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://sintonen.fi/advisories/scp-client-multiple-vulnerabilities.txt", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3885-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4387", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuapr2019-5072813.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuoct2019-5072832.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openssh/openssh-portable/commit/6010c0303a422a9c5fa8860c061bf7105eb7f8b2"}}