{"buggy_code": ["/*-\n* Copyright (c) 2003-2007 Tim Kientzle\n* Copyright (c) 2011 Andres Mejia\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions\n* are met:\n* 1. Redistributions of source code must retain the above copyright\n*    notice, this list of conditions and the following disclaimer.\n* 2. Redistributions in binary form must reproduce the above copyright\n*    notice, this list of conditions and the following disclaimer in the\n*    documentation and/or other materials provided with the distribution.\n*\n* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"archive_platform.h\"\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#include <time.h>\n#include <limits.h>\n#ifdef HAVE_ZLIB_H\n#include <zlib.h> /* crc32 */\n#endif\n\n#include \"archive.h\"\n#ifndef HAVE_ZLIB_H\n#include \"archive_crc32.h\"\n#endif\n#include \"archive_endian.h\"\n#include \"archive_entry.h\"\n#include \"archive_entry_locale.h\"\n#include \"archive_ppmd7_private.h\"\n#include \"archive_private.h\"\n#include \"archive_read_private.h\"\n\n/* RAR signature, also known as the mark header */\n#define RAR_SIGNATURE \"\\x52\\x61\\x72\\x21\\x1A\\x07\\x00\"\n\n/* Header types */\n#define MARK_HEAD    0x72\n#define MAIN_HEAD    0x73\n#define FILE_HEAD    0x74\n#define COMM_HEAD    0x75\n#define AV_HEAD      0x76\n#define SUB_HEAD     0x77\n#define PROTECT_HEAD 0x78\n#define SIGN_HEAD    0x79\n#define NEWSUB_HEAD  0x7a\n#define ENDARC_HEAD  0x7b\n\n/* Main Header Flags */\n#define MHD_VOLUME       0x0001\n#define MHD_COMMENT      0x0002\n#define MHD_LOCK         0x0004\n#define MHD_SOLID        0x0008\n#define MHD_NEWNUMBERING 0x0010\n#define MHD_AV           0x0020\n#define MHD_PROTECT      0x0040\n#define MHD_PASSWORD     0x0080\n#define MHD_FIRSTVOLUME  0x0100\n#define MHD_ENCRYPTVER   0x0200\n\n/* Flags common to all headers */\n#define HD_MARKDELETION     0x4000\n#define HD_ADD_SIZE_PRESENT 0x8000\n\n/* File Header Flags */\n#define FHD_SPLIT_BEFORE 0x0001\n#define FHD_SPLIT_AFTER  0x0002\n#define FHD_PASSWORD     0x0004\n#define FHD_COMMENT      0x0008\n#define FHD_SOLID        0x0010\n#define FHD_LARGE        0x0100\n#define FHD_UNICODE      0x0200\n#define FHD_SALT         0x0400\n#define FHD_VERSION      0x0800\n#define FHD_EXTTIME      0x1000\n#define FHD_EXTFLAGS     0x2000\n\n/* File dictionary sizes */\n#define DICTIONARY_SIZE_64   0x00\n#define DICTIONARY_SIZE_128  0x20\n#define DICTIONARY_SIZE_256  0x40\n#define DICTIONARY_SIZE_512  0x60\n#define DICTIONARY_SIZE_1024 0x80\n#define DICTIONARY_SIZE_2048 0xA0\n#define DICTIONARY_SIZE_4096 0xC0\n#define FILE_IS_DIRECTORY    0xE0\n#define DICTIONARY_MASK      FILE_IS_DIRECTORY\n\n/* OS Flags */\n#define OS_MSDOS  0\n#define OS_OS2    1\n#define OS_WIN32  2\n#define OS_UNIX   3\n#define OS_MAC_OS 4\n#define OS_BEOS   5\n\n/* Compression Methods */\n#define COMPRESS_METHOD_STORE   0x30\n/* LZSS */\n#define COMPRESS_METHOD_FASTEST 0x31\n#define COMPRESS_METHOD_FAST    0x32\n#define COMPRESS_METHOD_NORMAL  0x33\n/* PPMd Variant H */\n#define COMPRESS_METHOD_GOOD    0x34\n#define COMPRESS_METHOD_BEST    0x35\n\n#define CRC_POLYNOMIAL 0xEDB88320\n\n#define NS_UNIT 10000000\n\n#define DICTIONARY_MAX_SIZE 0x400000\n\n#define MAINCODE_SIZE      299\n#define OFFSETCODE_SIZE    60\n#define LOWOFFSETCODE_SIZE 17\n#define LENGTHCODE_SIZE    28\n#define HUFFMAN_TABLE_SIZE \\\n  MAINCODE_SIZE + OFFSETCODE_SIZE + LOWOFFSETCODE_SIZE + LENGTHCODE_SIZE\n\n#define MAX_SYMBOL_LENGTH 0xF\n#define MAX_SYMBOLS       20\n\n/*\n * Considering L1,L2 cache miss and a calling of write system-call,\n * the best size of the output buffer(uncompressed buffer) is 128K.\n * If the structure of extracting process is changed, this value\n * might be researched again.\n */\n#define UNP_BUFFER_SIZE   (128 * 1024)\n\n/* Define this here for non-Windows platforms */\n#if !((defined(__WIN32__) || defined(_WIN32) || defined(__WIN32)) && !defined(__CYGWIN__))\n#define FILE_ATTRIBUTE_DIRECTORY 0x10\n#endif\n\n/* Fields common to all headers */\nstruct rar_header\n{\n  char crc[2];\n  char type;\n  char flags[2];\n  char size[2];\n};\n\n/* Fields common to all file headers */\nstruct rar_file_header\n{\n  char pack_size[4];\n  char unp_size[4];\n  char host_os;\n  char file_crc[4];\n  char file_time[4];\n  char unp_ver;\n  char method;\n  char name_size[2];\n  char file_attr[4];\n};\n\nstruct huffman_tree_node\n{\n  int branches[2];\n};\n\nstruct huffman_table_entry\n{\n  unsigned int length;\n  int value;\n};\n\nstruct huffman_code\n{\n  struct huffman_tree_node *tree;\n  int numentries;\n  int numallocatedentries;\n  int minlength;\n  int maxlength;\n  int tablesize;\n  struct huffman_table_entry *table;\n};\n\nstruct lzss\n{\n  unsigned char *window;\n  int mask;\n  int64_t position;\n};\n\nstruct data_block_offsets\n{\n  int64_t header_size;\n  int64_t start_offset;\n  int64_t end_offset;\n};\n\nstruct rar\n{\n  /* Entries from main RAR header */\n  unsigned main_flags;\n  unsigned long file_crc;\n  char reserved1[2];\n  char reserved2[4];\n  char encryptver;\n\n  /* File header entries */\n  char compression_method;\n  unsigned file_flags;\n  int64_t packed_size;\n  int64_t unp_size;\n  time_t mtime;\n  long mnsec;\n  mode_t mode;\n  char *filename;\n  char *filename_save;\n  size_t filename_save_size;\n  size_t filename_allocated;\n\n  /* File header optional entries */\n  char salt[8];\n  time_t atime;\n  long ansec;\n  time_t ctime;\n  long cnsec;\n  time_t arctime;\n  long arcnsec;\n\n  /* Fields to help with tracking decompression of files. */\n  int64_t bytes_unconsumed;\n  int64_t bytes_remaining;\n  int64_t bytes_uncopied;\n  int64_t offset;\n  int64_t offset_outgoing;\n  int64_t offset_seek;\n  char valid;\n  unsigned int unp_offset;\n  unsigned int unp_buffer_size;\n  unsigned char *unp_buffer;\n  unsigned int dictionary_size;\n  char start_new_block;\n  char entry_eof;\n  unsigned long crc_calculated;\n  int found_first_header;\n  char has_endarc_header;\n  struct data_block_offsets *dbo;\n  unsigned int cursor;\n  unsigned int nodes;\n  char filename_must_match;\n\n  /* LZSS members */\n  struct huffman_code maincode;\n  struct huffman_code offsetcode;\n  struct huffman_code lowoffsetcode;\n  struct huffman_code lengthcode;\n  unsigned char lengthtable[HUFFMAN_TABLE_SIZE];\n  struct lzss lzss;\n  char output_last_match;\n  unsigned int lastlength;\n  unsigned int lastoffset;\n  unsigned int oldoffset[4];\n  unsigned int lastlowoffset;\n  unsigned int numlowoffsetrepeats;\n  int64_t filterstart;\n  char start_new_table;\n\n  /* PPMd Variant H members */\n  char ppmd_valid;\n  char ppmd_eod;\n  char is_ppmd_block;\n  int ppmd_escape;\n  CPpmd7 ppmd7_context;\n  CPpmd7z_RangeDec range_dec;\n  IByteIn bytein;\n\n  /*\n   * String conversion object.\n   */\n  int init_default_conversion;\n  struct archive_string_conv *sconv_default;\n  struct archive_string_conv *opt_sconv;\n  struct archive_string_conv *sconv_utf8;\n  struct archive_string_conv *sconv_utf16be;\n\n  /*\n   * Bit stream reader.\n   */\n  struct rar_br {\n#define CACHE_TYPE\tuint64_t\n#define CACHE_BITS\t(8 * sizeof(CACHE_TYPE))\n    /* Cache buffer. */\n    CACHE_TYPE\t\t cache_buffer;\n    /* Indicates how many bits avail in cache_buffer. */\n    int\t\t\t cache_avail;\n    ssize_t\t\t avail_in;\n    const unsigned char *next_in;\n  } br;\n\n  /*\n   * Custom field to denote that this archive contains encrypted entries\n   */\n  int has_encrypted_entries;\n};\n\nstatic int archive_read_support_format_rar_capabilities(struct archive_read *);\nstatic int archive_read_format_rar_has_encrypted_entries(struct archive_read *);\nstatic int archive_read_format_rar_bid(struct archive_read *, int);\nstatic int archive_read_format_rar_options(struct archive_read *,\n    const char *, const char *);\nstatic int archive_read_format_rar_read_header(struct archive_read *,\n    struct archive_entry *);\nstatic int archive_read_format_rar_read_data(struct archive_read *,\n    const void **, size_t *, int64_t *);\nstatic int archive_read_format_rar_read_data_skip(struct archive_read *a);\nstatic int64_t archive_read_format_rar_seek_data(struct archive_read *, int64_t,\n    int);\nstatic int archive_read_format_rar_cleanup(struct archive_read *);\n\n/* Support functions */\nstatic int read_header(struct archive_read *, struct archive_entry *, char);\nstatic time_t get_time(int);\nstatic int read_exttime(const char *, struct rar *, const char *);\nstatic int read_symlink_stored(struct archive_read *, struct archive_entry *,\n                               struct archive_string_conv *);\nstatic int read_data_stored(struct archive_read *, const void **, size_t *,\n                            int64_t *);\nstatic int read_data_compressed(struct archive_read *, const void **, size_t *,\n                          int64_t *);\nstatic int rar_br_preparation(struct archive_read *, struct rar_br *);\nstatic int parse_codes(struct archive_read *);\nstatic void free_codes(struct archive_read *);\nstatic int read_next_symbol(struct archive_read *, struct huffman_code *);\nstatic int create_code(struct archive_read *, struct huffman_code *,\n                        unsigned char *, int, char);\nstatic int add_value(struct archive_read *, struct huffman_code *, int, int,\n                     int);\nstatic int new_node(struct huffman_code *);\nstatic int make_table(struct archive_read *, struct huffman_code *);\nstatic int make_table_recurse(struct archive_read *, struct huffman_code *, int,\n                              struct huffman_table_entry *, int, int);\nstatic int64_t expand(struct archive_read *, int64_t);\nstatic int copy_from_lzss_window(struct archive_read *, const void **,\n                                   int64_t, int);\nstatic const void *rar_read_ahead(struct archive_read *, size_t, ssize_t *);\n\n/*\n * Bit stream reader.\n */\n/* Check that the cache buffer has enough bits. */\n#define rar_br_has(br, n) ((br)->cache_avail >= n)\n/* Get compressed data by bit. */\n#define rar_br_bits(br, n)        \\\n  (((uint32_t)((br)->cache_buffer >>    \\\n    ((br)->cache_avail - (n)))) & cache_masks[n])\n#define rar_br_bits_forced(br, n)     \\\n  (((uint32_t)((br)->cache_buffer <<    \\\n    ((n) - (br)->cache_avail))) & cache_masks[n])\n/* Read ahead to make sure the cache buffer has enough compressed data we\n * will use.\n *  True  : completed, there is enough data in the cache buffer.\n *  False : there is no data in the stream. */\n#define rar_br_read_ahead(a, br, n) \\\n  ((rar_br_has(br, (n)) || rar_br_fillup(a, br)) || rar_br_has(br, (n)))\n/* Notify how many bits we consumed. */\n#define rar_br_consume(br, n) ((br)->cache_avail -= (n))\n#define rar_br_consume_unalined_bits(br) ((br)->cache_avail &= ~7)\n\nstatic const uint32_t cache_masks[] = {\n  0x00000000, 0x00000001, 0x00000003, 0x00000007,\n  0x0000000F, 0x0000001F, 0x0000003F, 0x0000007F,\n  0x000000FF, 0x000001FF, 0x000003FF, 0x000007FF,\n  0x00000FFF, 0x00001FFF, 0x00003FFF, 0x00007FFF,\n  0x0000FFFF, 0x0001FFFF, 0x0003FFFF, 0x0007FFFF,\n  0x000FFFFF, 0x001FFFFF, 0x003FFFFF, 0x007FFFFF,\n  0x00FFFFFF, 0x01FFFFFF, 0x03FFFFFF, 0x07FFFFFF,\n  0x0FFFFFFF, 0x1FFFFFFF, 0x3FFFFFFF, 0x7FFFFFFF,\n  0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF\n};\n\n/*\n * Shift away used bits in the cache data and fill it up with following bits.\n * Call this when cache buffer does not have enough bits you need.\n *\n * Returns 1 if the cache buffer is full.\n * Returns 0 if the cache buffer is not full; input buffer is empty.\n */\nstatic int\nrar_br_fillup(struct archive_read *a, struct rar_br *br)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int n = CACHE_BITS - br->cache_avail;\n\n  for (;;) {\n    switch (n >> 3) {\n    case 8:\n      if (br->avail_in >= 8) {\n        br->cache_buffer =\n            ((uint64_t)br->next_in[0]) << 56 |\n            ((uint64_t)br->next_in[1]) << 48 |\n            ((uint64_t)br->next_in[2]) << 40 |\n            ((uint64_t)br->next_in[3]) << 32 |\n            ((uint32_t)br->next_in[4]) << 24 |\n            ((uint32_t)br->next_in[5]) << 16 |\n            ((uint32_t)br->next_in[6]) << 8 |\n             (uint32_t)br->next_in[7];\n        br->next_in += 8;\n        br->avail_in -= 8;\n        br->cache_avail += 8 * 8;\n        rar->bytes_unconsumed += 8;\n        rar->bytes_remaining -= 8;\n        return (1);\n      }\n      break;\n    case 7:\n      if (br->avail_in >= 7) {\n        br->cache_buffer =\n           (br->cache_buffer << 56) |\n            ((uint64_t)br->next_in[0]) << 48 |\n            ((uint64_t)br->next_in[1]) << 40 |\n            ((uint64_t)br->next_in[2]) << 32 |\n            ((uint32_t)br->next_in[3]) << 24 |\n            ((uint32_t)br->next_in[4]) << 16 |\n            ((uint32_t)br->next_in[5]) << 8 |\n             (uint32_t)br->next_in[6];\n        br->next_in += 7;\n        br->avail_in -= 7;\n        br->cache_avail += 7 * 8;\n        rar->bytes_unconsumed += 7;\n        rar->bytes_remaining -= 7;\n        return (1);\n      }\n      break;\n    case 6:\n      if (br->avail_in >= 6) {\n        br->cache_buffer =\n           (br->cache_buffer << 48) |\n            ((uint64_t)br->next_in[0]) << 40 |\n            ((uint64_t)br->next_in[1]) << 32 |\n            ((uint32_t)br->next_in[2]) << 24 |\n            ((uint32_t)br->next_in[3]) << 16 |\n            ((uint32_t)br->next_in[4]) << 8 |\n             (uint32_t)br->next_in[5];\n        br->next_in += 6;\n        br->avail_in -= 6;\n        br->cache_avail += 6 * 8;\n        rar->bytes_unconsumed += 6;\n        rar->bytes_remaining -= 6;\n        return (1);\n      }\n      break;\n    case 0:\n      /* We have enough compressed data in\n       * the cache buffer.*/\n      return (1);\n    default:\n      break;\n    }\n    if (br->avail_in <= 0) {\n\n      if (rar->bytes_unconsumed > 0) {\n        /* Consume as much as the decompressor\n         * actually used. */\n        __archive_read_consume(a, rar->bytes_unconsumed);\n        rar->bytes_unconsumed = 0;\n      }\n      br->next_in = rar_read_ahead(a, 1, &(br->avail_in));\n      if (br->next_in == NULL)\n        return (0);\n      if (br->avail_in == 0)\n        return (0);\n    }\n    br->cache_buffer =\n       (br->cache_buffer << 8) | *br->next_in++;\n    br->avail_in--;\n    br->cache_avail += 8;\n    n -= 8;\n    rar->bytes_unconsumed++;\n    rar->bytes_remaining--;\n  }\n}\n\nstatic int\nrar_br_preparation(struct archive_read *a, struct rar_br *br)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n\n  if (rar->bytes_remaining > 0) {\n    br->next_in = rar_read_ahead(a, 1, &(br->avail_in));\n    if (br->next_in == NULL) {\n      archive_set_error(&a->archive,\n          ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Truncated RAR file data\");\n      return (ARCHIVE_FATAL);\n    }\n    if (br->cache_avail == 0)\n      (void)rar_br_fillup(a, br);\n  }\n  return (ARCHIVE_OK);\n}\n\n/* Find last bit set */\nstatic inline int\nrar_fls(unsigned int word)\n{\n  word |= (word >>  1);\n  word |= (word >>  2);\n  word |= (word >>  4);\n  word |= (word >>  8);\n  word |= (word >> 16);\n  return word - (word >> 1);\n}\n\n/* LZSS functions */\nstatic inline int64_t\nlzss_position(struct lzss *lzss)\n{\n  return lzss->position;\n}\n\nstatic inline int\nlzss_mask(struct lzss *lzss)\n{\n  return lzss->mask;\n}\n\nstatic inline int\nlzss_size(struct lzss *lzss)\n{\n  return lzss->mask + 1;\n}\n\nstatic inline int\nlzss_offset_for_position(struct lzss *lzss, int64_t pos)\n{\n  return (int)(pos & lzss->mask);\n}\n\nstatic inline unsigned char *\nlzss_pointer_for_position(struct lzss *lzss, int64_t pos)\n{\n  return &lzss->window[lzss_offset_for_position(lzss, pos)];\n}\n\nstatic inline int\nlzss_current_offset(struct lzss *lzss)\n{\n  return lzss_offset_for_position(lzss, lzss->position);\n}\n\nstatic inline uint8_t *\nlzss_current_pointer(struct lzss *lzss)\n{\n  return lzss_pointer_for_position(lzss, lzss->position);\n}\n\nstatic inline void\nlzss_emit_literal(struct rar *rar, uint8_t literal)\n{\n  *lzss_current_pointer(&rar->lzss) = literal;\n  rar->lzss.position++;\n}\n\nstatic inline void\nlzss_emit_match(struct rar *rar, int offset, int length)\n{\n  int dstoffs = lzss_current_offset(&rar->lzss);\n  int srcoffs = (dstoffs - offset) & lzss_mask(&rar->lzss);\n  int l, li, remaining;\n  unsigned char *d, *s;\n\n  remaining = length;\n  while (remaining > 0) {\n    l = remaining;\n    if (dstoffs > srcoffs) {\n      if (l > lzss_size(&rar->lzss) - dstoffs)\n        l = lzss_size(&rar->lzss) - dstoffs;\n    } else {\n      if (l > lzss_size(&rar->lzss) - srcoffs)\n        l = lzss_size(&rar->lzss) - srcoffs;\n    }\n    d = &(rar->lzss.window[dstoffs]);\n    s = &(rar->lzss.window[srcoffs]);\n    if ((dstoffs + l < srcoffs) || (srcoffs + l < dstoffs))\n      memcpy(d, s, l);\n    else {\n      for (li = 0; li < l; li++)\n        d[li] = s[li];\n    }\n    remaining -= l;\n    dstoffs = (dstoffs + l) & lzss_mask(&(rar->lzss));\n    srcoffs = (srcoffs + l) & lzss_mask(&(rar->lzss));\n  }\n  rar->lzss.position += length;\n}\n\nstatic Byte\nppmd_read(void *p)\n{\n  struct archive_read *a = ((IByteIn*)p)->a;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n  Byte b;\n  if (!rar_br_read_ahead(a, br, 8))\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    rar->valid = 0;\n    return 0;\n  }\n  b = rar_br_bits(br, 8);\n  rar_br_consume(br, 8);\n  return b;\n}\n\nint\narchive_read_support_format_rar(struct archive *_a)\n{\n  struct archive_read *a = (struct archive_read *)_a;\n  struct rar *rar;\n  int r;\n\n  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n                      \"archive_read_support_format_rar\");\n\n  rar = (struct rar *)calloc(sizeof(*rar), 1);\n  if (rar == NULL)\n  {\n    archive_set_error(&a->archive, ENOMEM, \"Can't allocate rar data\");\n    return (ARCHIVE_FATAL);\n  }\n\n\t/*\n\t * Until enough data has been read, we cannot tell about\n\t * any encrypted entries yet.\n\t */\n\trar->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\n  r = __archive_read_register_format(a,\n                                     rar,\n                                     \"rar\",\n                                     archive_read_format_rar_bid,\n                                     archive_read_format_rar_options,\n                                     archive_read_format_rar_read_header,\n                                     archive_read_format_rar_read_data,\n                                     archive_read_format_rar_read_data_skip,\n                                     archive_read_format_rar_seek_data,\n                                     archive_read_format_rar_cleanup,\n                                     archive_read_support_format_rar_capabilities,\n                                     archive_read_format_rar_has_encrypted_entries);\n\n  if (r != ARCHIVE_OK)\n    free(rar);\n  return (r);\n}\n\nstatic int\narchive_read_support_format_rar_capabilities(struct archive_read * a)\n{\n\t(void)a; /* UNUSED */\n\treturn (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA\n\t\t\t| ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);\n}\n\nstatic int\narchive_read_format_rar_has_encrypted_entries(struct archive_read *_a)\n{\n\tif (_a && _a->format) {\n\t\tstruct rar * rar = (struct rar *)_a->format->data;\n\t\tif (rar) {\n\t\t\treturn rar->has_encrypted_entries;\n\t\t}\n\t}\n\treturn ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n}\n\n\nstatic int\narchive_read_format_rar_bid(struct archive_read *a, int best_bid)\n{\n  const char *p;\n\n  /* If there's already a bid > 30, we'll never win. */\n  if (best_bid > 30)\n\t  return (-1);\n\n  if ((p = __archive_read_ahead(a, 7, NULL)) == NULL)\n    return (-1);\n\n  if (memcmp(p, RAR_SIGNATURE, 7) == 0)\n    return (30);\n\n  if ((p[0] == 'M' && p[1] == 'Z') || memcmp(p, \"\\x7F\\x45LF\", 4) == 0) {\n    /* This is a PE file */\n    ssize_t offset = 0x10000;\n    ssize_t window = 4096;\n    ssize_t bytes_avail;\n    while (offset + window <= (1024 * 128)) {\n      const char *buff = __archive_read_ahead(a, offset + window, &bytes_avail);\n      if (buff == NULL) {\n        /* Remaining bytes are less than window. */\n        window >>= 1;\n        if (window < 0x40)\n          return (0);\n        continue;\n      }\n      p = buff + offset;\n      while (p + 7 < buff + bytes_avail) {\n        if (memcmp(p, RAR_SIGNATURE, 7) == 0)\n          return (30);\n        p += 0x10;\n      }\n      offset = p - buff;\n    }\n  }\n  return (0);\n}\n\nstatic int\nskip_sfx(struct archive_read *a)\n{\n  const void *h;\n  const char *p, *q;\n  size_t skip, total;\n  ssize_t bytes, window;\n\n  total = 0;\n  window = 4096;\n  while (total + window <= (1024 * 128)) {\n    h = __archive_read_ahead(a, window, &bytes);\n    if (h == NULL) {\n      /* Remaining bytes are less than window. */\n      window >>= 1;\n      if (window < 0x40)\n      \tgoto fatal;\n      continue;\n    }\n    if (bytes < 0x40)\n      goto fatal;\n    p = h;\n    q = p + bytes;\n\n    /*\n     * Scan ahead until we find something that looks\n     * like the RAR header.\n     */\n    while (p + 7 < q) {\n      if (memcmp(p, RAR_SIGNATURE, 7) == 0) {\n      \tskip = p - (const char *)h;\n      \t__archive_read_consume(a, skip);\n      \treturn (ARCHIVE_OK);\n      }\n      p += 0x10;\n    }\n    skip = p - (const char *)h;\n    __archive_read_consume(a, skip);\n\ttotal += skip;\n  }\nfatal:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Couldn't find out RAR header\");\n  return (ARCHIVE_FATAL);\n}\n\nstatic int\narchive_read_format_rar_options(struct archive_read *a,\n    const char *key, const char *val)\n{\n  struct rar *rar;\n  int ret = ARCHIVE_FAILED;\n\n  rar = (struct rar *)(a->format->data);\n  if (strcmp(key, \"hdrcharset\")  == 0) {\n    if (val == NULL || val[0] == 0)\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n          \"rar: hdrcharset option needs a character-set name\");\n    else {\n      rar->opt_sconv =\n          archive_string_conversion_from_charset(\n              &a->archive, val, 0);\n      if (rar->opt_sconv != NULL)\n        ret = ARCHIVE_OK;\n      else\n        ret = ARCHIVE_FATAL;\n    }\n    return (ret);\n  }\n\n  /* Note: The \"warn\" return is just to inform the options\n   * supervisor that we didn't handle it.  It will generate\n   * a suitable error if no one used this option. */\n  return (ARCHIVE_WARN);\n}\n\nstatic int\narchive_read_format_rar_read_header(struct archive_read *a,\n                                    struct archive_entry *entry)\n{\n  const void *h;\n  const char *p;\n  struct rar *rar;\n  size_t skip;\n  char head_type;\n  int ret;\n  unsigned flags;\n  unsigned long crc32_expected;\n\n  a->archive.archive_format = ARCHIVE_FORMAT_RAR;\n  if (a->archive.archive_format_name == NULL)\n    a->archive.archive_format_name = \"RAR\";\n\n  rar = (struct rar *)(a->format->data);\n\n  /*\n   * It should be sufficient to call archive_read_next_header() for\n   * a reader to determine if an entry is encrypted or not. If the\n   * encryption of an entry is only detectable when calling\n   * archive_read_data(), so be it. We'll do the same check there\n   * as well.\n   */\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n\n  /* RAR files can be generated without EOF headers, so return ARCHIVE_EOF if\n  * this fails.\n  */\n  if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)\n    return (ARCHIVE_EOF);\n\n  p = h;\n  if (rar->found_first_header == 0 &&\n     ((p[0] == 'M' && p[1] == 'Z') || memcmp(p, \"\\x7F\\x45LF\", 4) == 0)) {\n    /* This is an executable ? Must be self-extracting... */\n    ret = skip_sfx(a);\n    if (ret < ARCHIVE_WARN)\n      return (ret);\n  }\n  rar->found_first_header = 1;\n\n  while (1)\n  {\n    unsigned long crc32_val;\n\n    if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)\n      return (ARCHIVE_FATAL);\n    p = h;\n\n    head_type = p[2];\n    switch(head_type)\n    {\n    case MARK_HEAD:\n      if (memcmp(p, RAR_SIGNATURE, 7) != 0) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid marker header\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_read_consume(a, 7);\n      break;\n\n    case MAIN_HEAD:\n      rar->main_flags = archive_le16dec(p + 3);\n      skip = archive_le16dec(p + 5);\n      if (skip < 7 + sizeof(rar->reserved1) + sizeof(rar->reserved2)) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid header size\");\n        return (ARCHIVE_FATAL);\n      }\n      if ((h = __archive_read_ahead(a, skip, NULL)) == NULL)\n        return (ARCHIVE_FATAL);\n      p = h;\n      memcpy(rar->reserved1, p + 7, sizeof(rar->reserved1));\n      memcpy(rar->reserved2, p + 7 + sizeof(rar->reserved1),\n             sizeof(rar->reserved2));\n      if (rar->main_flags & MHD_ENCRYPTVER) {\n        if (skip < 7 + sizeof(rar->reserved1) + sizeof(rar->reserved2)+1) {\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n            \"Invalid header size\");\n          return (ARCHIVE_FATAL);\n        }\n        rar->encryptver = *(p + 7 + sizeof(rar->reserved1) +\n                            sizeof(rar->reserved2));\n      }\n\n      /* Main header is password encrypted, so we cannot read any\n         file names or any other info about files from the header. */\n      if (rar->main_flags & MHD_PASSWORD)\n      {\n        archive_entry_set_is_metadata_encrypted(entry, 1);\n        archive_entry_set_is_data_encrypted(entry, 1);\n        rar->has_encrypted_entries = 1;\n         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"RAR encryption support unavailable.\");\n        return (ARCHIVE_FATAL);\n      }\n\n      crc32_val = crc32(0, (const unsigned char *)p + 2, (unsigned)skip - 2);\n      if ((crc32_val & 0xffff) != archive_le16dec(p)) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Header CRC error\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_read_consume(a, skip);\n      break;\n\n    case FILE_HEAD:\n      return read_header(a, entry, head_type);\n\n    case COMM_HEAD:\n    case AV_HEAD:\n    case SUB_HEAD:\n    case PROTECT_HEAD:\n    case SIGN_HEAD:\n    case ENDARC_HEAD:\n      flags = archive_le16dec(p + 3);\n      skip = archive_le16dec(p + 5);\n      if (skip < 7) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid header size too small\");\n        return (ARCHIVE_FATAL);\n      }\n      if (flags & HD_ADD_SIZE_PRESENT)\n      {\n        if (skip < 7 + 4) {\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n            \"Invalid header size too small\");\n          return (ARCHIVE_FATAL);\n        }\n        if ((h = __archive_read_ahead(a, skip, NULL)) == NULL)\n          return (ARCHIVE_FATAL);\n        p = h;\n        skip += archive_le32dec(p + 7);\n      }\n\n      /* Skip over the 2-byte CRC at the beginning of the header. */\n      crc32_expected = archive_le16dec(p);\n      __archive_read_consume(a, 2);\n      skip -= 2;\n\n      /* Skim the entire header and compute the CRC. */\n      crc32_val = 0;\n      while (skip > 0) {\n\t      size_t to_read = skip;\n\t      ssize_t did_read;\n\t      if (to_read > 32 * 1024) {\n\t\t      to_read = 32 * 1024;\n\t      }\n\t      if ((h = __archive_read_ahead(a, to_read, &did_read)) == NULL) {\n\t\t      return (ARCHIVE_FATAL);\n\t      }\n\t      p = h;\n\t      crc32_val = crc32(crc32_val, (const unsigned char *)p, (unsigned)did_read);\n\t      __archive_read_consume(a, did_read);\n\t      skip -= did_read;\n      }\n      if ((crc32_val & 0xffff) != crc32_expected) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t  \"Header CRC error\");\n\t      return (ARCHIVE_FATAL);\n      }\n      if (head_type == ENDARC_HEAD)\n\t      return (ARCHIVE_EOF);\n      break;\n\n    case NEWSUB_HEAD:\n      if ((ret = read_header(a, entry, head_type)) < ARCHIVE_WARN)\n        return ret;\n      break;\n\n    default:\n      archive_set_error(&a->archive,  ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Bad RAR file\");\n      return (ARCHIVE_FATAL);\n    }\n  }\n}\n\nstatic int\narchive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n\n  if (rar->bytes_unconsumed > 0) {\n      /* Consume as much as the decompressor actually used. */\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}\n\nstatic int\narchive_read_format_rar_read_data_skip(struct archive_read *a)\n{\n  struct rar *rar;\n  int64_t bytes_skipped;\n  int ret;\n\n  rar = (struct rar *)(a->format->data);\n\n  if (rar->bytes_unconsumed > 0) {\n      /* Consume as much as the decompressor actually used. */\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n\n  if (rar->bytes_remaining > 0) {\n    bytes_skipped = __archive_read_consume(a, rar->bytes_remaining);\n    if (bytes_skipped < 0)\n      return (ARCHIVE_FATAL);\n  }\n\n  /* Compressed data to skip must be read from each header in a multivolume\n   * archive.\n   */\n  if (rar->main_flags & MHD_VOLUME && rar->file_flags & FHD_SPLIT_AFTER)\n  {\n    ret = archive_read_format_rar_read_header(a, a->entry);\n    if (ret == (ARCHIVE_EOF))\n      ret = archive_read_format_rar_read_header(a, a->entry);\n    if (ret != (ARCHIVE_OK))\n      return ret;\n    return archive_read_format_rar_read_data_skip(a);\n  }\n\n  return (ARCHIVE_OK);\n}\n\nstatic int64_t\narchive_read_format_rar_seek_data(struct archive_read *a, int64_t offset,\n    int whence)\n{\n  int64_t client_offset, ret;\n  unsigned int i;\n  struct rar *rar = (struct rar *)(a->format->data);\n\n  if (rar->compression_method == COMPRESS_METHOD_STORE)\n  {\n    /* Modify the offset for use with SEEK_SET */\n    switch (whence)\n    {\n      case SEEK_CUR:\n        client_offset = rar->offset_seek;\n        break;\n      case SEEK_END:\n        client_offset = rar->unp_size;\n        break;\n      case SEEK_SET:\n      default:\n        client_offset = 0;\n    }\n    client_offset += offset;\n    if (client_offset < 0)\n    {\n      /* Can't seek past beginning of data block */\n      return -1;\n    }\n    else if (client_offset > rar->unp_size)\n    {\n      /*\n       * Set the returned offset but only seek to the end of\n       * the data block.\n       */\n      rar->offset_seek = client_offset;\n      client_offset = rar->unp_size;\n    }\n\n    client_offset += rar->dbo[0].start_offset;\n    i = 0;\n    while (i < rar->cursor)\n    {\n      i++;\n      client_offset += rar->dbo[i].start_offset - rar->dbo[i-1].end_offset;\n    }\n    if (rar->main_flags & MHD_VOLUME)\n    {\n      /* Find the appropriate offset among the multivolume archive */\n      while (1)\n      {\n        if (client_offset < rar->dbo[rar->cursor].start_offset &&\n          rar->file_flags & FHD_SPLIT_BEFORE)\n        {\n          /* Search backwards for the correct data block */\n          if (rar->cursor == 0)\n          {\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n              \"Attempt to seek past beginning of RAR data block\");\n            return (ARCHIVE_FAILED);\n          }\n          rar->cursor--;\n          client_offset -= rar->dbo[rar->cursor+1].start_offset -\n            rar->dbo[rar->cursor].end_offset;\n          if (client_offset < rar->dbo[rar->cursor].start_offset)\n            continue;\n          ret = __archive_read_seek(a, rar->dbo[rar->cursor].start_offset -\n            rar->dbo[rar->cursor].header_size, SEEK_SET);\n          if (ret < (ARCHIVE_OK))\n            return ret;\n          ret = archive_read_format_rar_read_header(a, a->entry);\n          if (ret != (ARCHIVE_OK))\n          {\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n              \"Error during seek of RAR file\");\n            return (ARCHIVE_FAILED);\n          }\n          rar->cursor--;\n          break;\n        }\n        else if (client_offset > rar->dbo[rar->cursor].end_offset &&\n          rar->file_flags & FHD_SPLIT_AFTER)\n        {\n          /* Search forward for the correct data block */\n          rar->cursor++;\n          if (rar->cursor < rar->nodes &&\n            client_offset > rar->dbo[rar->cursor].end_offset)\n          {\n            client_offset += rar->dbo[rar->cursor].start_offset -\n              rar->dbo[rar->cursor-1].end_offset;\n            continue;\n          }\n          rar->cursor--;\n          ret = __archive_read_seek(a, rar->dbo[rar->cursor].end_offset,\n                                    SEEK_SET);\n          if (ret < (ARCHIVE_OK))\n            return ret;\n          ret = archive_read_format_rar_read_header(a, a->entry);\n          if (ret == (ARCHIVE_EOF))\n          {\n            rar->has_endarc_header = 1;\n            ret = archive_read_format_rar_read_header(a, a->entry);\n          }\n          if (ret != (ARCHIVE_OK))\n          {\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n              \"Error during seek of RAR file\");\n            return (ARCHIVE_FAILED);\n          }\n          client_offset += rar->dbo[rar->cursor].start_offset -\n            rar->dbo[rar->cursor-1].end_offset;\n          continue;\n        }\n        break;\n      }\n    }\n\n    ret = __archive_read_seek(a, client_offset, SEEK_SET);\n    if (ret < (ARCHIVE_OK))\n      return ret;\n    rar->bytes_remaining = rar->dbo[rar->cursor].end_offset - ret;\n    i = rar->cursor;\n    while (i > 0)\n    {\n      i--;\n      ret -= rar->dbo[i+1].start_offset - rar->dbo[i].end_offset;\n    }\n    ret -= rar->dbo[0].start_offset;\n\n    /* Always restart reading the file after a seek */\n    __archive_reset_read_data(&a->archive);\n\n    rar->bytes_unconsumed = 0;\n    rar->offset = 0;\n\n    /*\n     * If a seek past the end of file was requested, return the requested\n     * offset.\n     */\n    if (ret == rar->unp_size && rar->offset_seek > rar->unp_size)\n      return rar->offset_seek;\n\n    /* Return the new offset */\n    rar->offset_seek = ret;\n    return rar->offset_seek;\n  }\n  else\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n      \"Seeking of compressed RAR files is unsupported\");\n  }\n  return (ARCHIVE_FAILED);\n}\n\nstatic int\narchive_read_format_rar_cleanup(struct archive_read *a)\n{\n  struct rar *rar;\n\n  rar = (struct rar *)(a->format->data);\n  free_codes(a);\n  free(rar->filename);\n  free(rar->filename_save);\n  free(rar->dbo);\n  free(rar->unp_buffer);\n  free(rar->lzss.window);\n  __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n  free(rar);\n  (a->format->data) = NULL;\n  return (ARCHIVE_OK);\n}\n\nstatic int\nread_header(struct archive_read *a, struct archive_entry *entry,\n            char head_type)\n{\n  const void *h;\n  const char *p, *endp;\n  struct rar *rar;\n  struct rar_header rar_header;\n  struct rar_file_header file_header;\n  int64_t header_size;\n  unsigned filename_size, end;\n  char *filename;\n  char *strp;\n  char packed_size[8];\n  char unp_size[8];\n  int ttime;\n  struct archive_string_conv *sconv, *fn_sconv;\n  unsigned long crc32_val;\n  int ret = (ARCHIVE_OK), ret2;\n\n  rar = (struct rar *)(a->format->data);\n\n  /* Setup a string conversion object for non-rar-unicode filenames. */\n  sconv = rar->opt_sconv;\n  if (sconv == NULL) {\n    if (!rar->init_default_conversion) {\n      rar->sconv_default =\n          archive_string_default_conversion_for_read(\n            &(a->archive));\n      rar->init_default_conversion = 1;\n    }\n    sconv = rar->sconv_default;\n  }\n\n\n  if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n  p = h;\n  memcpy(&rar_header, p, sizeof(rar_header));\n  rar->file_flags = archive_le16dec(rar_header.flags);\n  header_size = archive_le16dec(rar_header.size);\n  if (header_size < (int64_t)sizeof(file_header) + 7) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid header size\");\n    return (ARCHIVE_FATAL);\n  }\n  crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);\n  __archive_read_consume(a, 7);\n\n  if (!(rar->file_flags & FHD_SOLID))\n  {\n    rar->compression_method = 0;\n    rar->packed_size = 0;\n    rar->unp_size = 0;\n    rar->mtime = 0;\n    rar->ctime = 0;\n    rar->atime = 0;\n    rar->arctime = 0;\n    rar->mode = 0;\n    memset(&rar->salt, 0, sizeof(rar->salt));\n    rar->atime = 0;\n    rar->ansec = 0;\n    rar->ctime = 0;\n    rar->cnsec = 0;\n    rar->mtime = 0;\n    rar->mnsec = 0;\n    rar->arctime = 0;\n    rar->arcnsec = 0;\n  }\n  else\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR solid archive support unavailable.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n\n  /* File Header CRC check. */\n  crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));\n  if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Header CRC error\");\n    return (ARCHIVE_FATAL);\n  }\n  /* If no CRC error, Go on parsing File Header. */\n  p = h;\n  endp = p + header_size - 7;\n  memcpy(&file_header, p, sizeof(file_header));\n  p += sizeof(file_header);\n\n  rar->compression_method = file_header.method;\n\n  ttime = archive_le32dec(file_header.file_time);\n  rar->mtime = get_time(ttime);\n\n  rar->file_crc = archive_le32dec(file_header.file_crc);\n\n  if (rar->file_flags & FHD_PASSWORD)\n  {\n\tarchive_entry_set_is_data_encrypted(entry, 1);\n\trar->has_encrypted_entries = 1;\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR encryption support unavailable.\");\n    /* Since it is only the data part itself that is encrypted we can at least\n       extract information about the currently processed entry and don't need\n       to return ARCHIVE_FATAL here. */\n    /*return (ARCHIVE_FATAL);*/\n  }\n\n  if (rar->file_flags & FHD_LARGE)\n  {\n    memcpy(packed_size, file_header.pack_size, 4);\n    memcpy(packed_size + 4, p, 4); /* High pack size */\n    p += 4;\n    memcpy(unp_size, file_header.unp_size, 4);\n    memcpy(unp_size + 4, p, 4); /* High unpack size */\n    p += 4;\n    rar->packed_size = archive_le64dec(&packed_size);\n    rar->unp_size = archive_le64dec(&unp_size);\n  }\n  else\n  {\n    rar->packed_size = archive_le32dec(file_header.pack_size);\n    rar->unp_size = archive_le32dec(file_header.unp_size);\n  }\n\n  if (rar->packed_size < 0 || rar->unp_size < 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid sizes specified.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_remaining = rar->packed_size;\n\n  /* TODO: RARv3 subblocks contain comments. For now the complete block is\n   * consumed at the end.\n   */\n  if (head_type == NEWSUB_HEAD) {\n    size_t distance = p - (const char *)h;\n    header_size += rar->packed_size;\n    /* Make sure we have the extended data. */\n    if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n        return (ARCHIVE_FATAL);\n    p = h;\n    endp = p + header_size - 7;\n    p += distance;\n  }\n\n  filename_size = archive_le16dec(file_header.name_size);\n  if (p + filename_size > endp) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid filename size\");\n    return (ARCHIVE_FATAL);\n  }\n  if (rar->filename_allocated < filename_size * 2 + 2) {\n    char *newptr;\n    size_t newsize = filename_size * 2 + 2;\n    newptr = realloc(rar->filename, newsize);\n    if (newptr == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Couldn't allocate memory.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->filename = newptr;\n    rar->filename_allocated = newsize;\n  }\n  filename = rar->filename;\n  memcpy(filename, p, filename_size);\n  filename[filename_size] = '\\0';\n  if (rar->file_flags & FHD_UNICODE)\n  {\n    if (filename_size != strlen(filename))\n    {\n      unsigned char highbyte, flagbits, flagbyte;\n      unsigned fn_end, offset;\n\n      end = filename_size;\n      fn_end = filename_size * 2;\n      filename_size = 0;\n      offset = (unsigned)strlen(filename) + 1;\n      highbyte = *(p + offset++);\n      flagbits = 0;\n      flagbyte = 0;\n      while (offset < end && filename_size < fn_end)\n      {\n        if (!flagbits)\n        {\n          flagbyte = *(p + offset++);\n          flagbits = 8;\n        }\n\n        flagbits -= 2;\n        switch((flagbyte >> flagbits) & 3)\n        {\n          case 0:\n            filename[filename_size++] = '\\0';\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 1:\n            filename[filename_size++] = highbyte;\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 2:\n            filename[filename_size++] = *(p + offset + 1);\n            filename[filename_size++] = *(p + offset);\n            offset += 2;\n            break;\n          case 3:\n          {\n            char extra, high;\n            uint8_t length = *(p + offset++);\n\n            if (length & 0x80) {\n              extra = *(p + offset++);\n              high = (char)highbyte;\n            } else\n              extra = high = 0;\n            length = (length & 0x7f) + 2;\n            while (length && filename_size < fn_end) {\n              unsigned cp = filename_size >> 1;\n              filename[filename_size++] = high;\n              filename[filename_size++] = p[cp] + extra;\n              length--;\n            }\n          }\n          break;\n        }\n      }\n      if (filename_size > fn_end) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid filename\");\n        return (ARCHIVE_FATAL);\n      }\n      filename[filename_size++] = '\\0';\n      /*\n       * Do not increment filename_size here as the computations below\n       * add the space for the terminating NUL explicitly.\n       */\n      filename[filename_size] = '\\0';\n\n      /* Decoded unicode form is UTF-16BE, so we have to update a string\n       * conversion object for it. */\n      if (rar->sconv_utf16be == NULL) {\n        rar->sconv_utf16be = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-16BE\", 1);\n        if (rar->sconv_utf16be == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf16be;\n\n      strp = filename;\n      while (memcmp(strp, \"\\x00\\x00\", 2))\n      {\n        if (!memcmp(strp, \"\\x00\\\\\", 2))\n          *(strp + 1) = '/';\n        strp += 2;\n      }\n      p += offset;\n    } else {\n      /*\n       * If FHD_UNICODE is set but no unicode data, this file name form\n       * is UTF-8, so we have to update a string conversion object for\n       * it accordingly.\n       */\n      if (rar->sconv_utf8 == NULL) {\n        rar->sconv_utf8 = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-8\", 1);\n        if (rar->sconv_utf8 == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf8;\n      while ((strp = strchr(filename, '\\\\')) != NULL)\n        *strp = '/';\n      p += filename_size;\n    }\n  }\n  else\n  {\n    fn_sconv = sconv;\n    while ((strp = strchr(filename, '\\\\')) != NULL)\n      *strp = '/';\n    p += filename_size;\n  }\n\n  /* Split file in multivolume RAR. No more need to process header. */\n  if (rar->filename_save &&\n    filename_size == rar->filename_save_size &&\n    !memcmp(rar->filename, rar->filename_save, filename_size + 1))\n  {\n    __archive_read_consume(a, header_size - 7);\n    rar->cursor++;\n    if (rar->cursor >= rar->nodes)\n    {\n      rar->nodes++;\n      if ((rar->dbo =\n        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)\n      {\n        archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n        return (ARCHIVE_FATAL);\n      }\n      rar->dbo[rar->cursor].header_size = header_size;\n      rar->dbo[rar->cursor].start_offset = -1;\n      rar->dbo[rar->cursor].end_offset = -1;\n    }\n    if (rar->dbo[rar->cursor].start_offset < 0)\n    {\n      rar->dbo[rar->cursor].start_offset = a->filter->position;\n      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +\n        rar->packed_size;\n    }\n    return ret;\n  }\n  else if (rar->filename_must_match)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Mismatch of file parts split across multi-volume archive\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->filename_save = (char*)realloc(rar->filename_save,\n                                      filename_size + 1);\n  memcpy(rar->filename_save, rar->filename, filename_size + 1);\n  rar->filename_save_size = filename_size;\n\n  /* Set info for seeking */\n  free(rar->dbo);\n  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)\n  {\n    archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n    return (ARCHIVE_FATAL);\n  }\n  rar->dbo[0].header_size = header_size;\n  rar->dbo[0].start_offset = -1;\n  rar->dbo[0].end_offset = -1;\n  rar->cursor = 0;\n  rar->nodes = 1;\n\n  if (rar->file_flags & FHD_SALT)\n  {\n    if (p + 8 > endp) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n    memcpy(rar->salt, p, 8);\n    p += 8;\n  }\n\n  if (rar->file_flags & FHD_EXTTIME) {\n    if (read_exttime(p, rar, endp) < 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n  }\n\n  __archive_read_consume(a, header_size - 7);\n  rar->dbo[0].start_offset = a->filter->position;\n  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;\n\n  switch(file_header.host_os)\n  {\n  case OS_MSDOS:\n  case OS_OS2:\n  case OS_WIN32:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)\n      rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;\n    else\n      rar->mode = AE_IFREG;\n    rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;\n    break;\n\n  case OS_UNIX:\n  case OS_MAC_OS:\n  case OS_BEOS:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unknown file attributes from RAR file's host OS\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_uncopied = rar->bytes_unconsumed = 0;\n  rar->lzss.position = rar->offset = 0;\n  rar->offset_seek = 0;\n  rar->dictionary_size = 0;\n  rar->offset_outgoing = 0;\n  rar->br.cache_avail = 0;\n  rar->br.avail_in = 0;\n  rar->crc_calculated = 0;\n  rar->entry_eof = 0;\n  rar->valid = 1;\n  rar->is_ppmd_block = 0;\n  rar->start_new_table = 1;\n  free(rar->unp_buffer);\n  rar->unp_buffer = NULL;\n  rar->unp_offset = 0;\n  rar->unp_buffer_size = UNP_BUFFER_SIZE;\n  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n  __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n  rar->ppmd_valid = rar->ppmd_eod = 0;\n\n  /* Don't set any archive entries for non-file header types */\n  if (head_type == NEWSUB_HEAD)\n    return ret;\n\n  archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);\n  archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);\n  archive_entry_set_atime(entry, rar->atime, rar->ansec);\n  archive_entry_set_size(entry, rar->unp_size);\n  archive_entry_set_mode(entry, rar->mode);\n\n  if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))\n  {\n    if (errno == ENOMEM)\n    {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Can't allocate memory for Pathname\");\n      return (ARCHIVE_FATAL);\n    }\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Pathname cannot be converted from %s to current locale.\",\n                      archive_string_conversion_charset_name(fn_sconv));\n    ret = (ARCHIVE_WARN);\n  }\n\n  if (((rar->mode) & AE_IFMT) == AE_IFLNK)\n  {\n    /* Make sure a symbolic-link file does not have its body. */\n    rar->bytes_remaining = 0;\n    archive_entry_set_size(entry, 0);\n\n    /* Read a symbolic-link name. */\n    if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))\n      return ret2;\n    if (ret > ret2)\n      ret = ret2;\n  }\n\n  if (rar->bytes_remaining == 0)\n    rar->entry_eof = 1;\n\n  return ret;\n}\n\nstatic time_t\nget_time(int ttime)\n{\n  struct tm tm;\n  tm.tm_sec = 2 * (ttime & 0x1f);\n  tm.tm_min = (ttime >> 5) & 0x3f;\n  tm.tm_hour = (ttime >> 11) & 0x1f;\n  tm.tm_mday = (ttime >> 16) & 0x1f;\n  tm.tm_mon = ((ttime >> 21) & 0x0f) - 1;\n  tm.tm_year = ((ttime >> 25) & 0x7f) + 80;\n  tm.tm_isdst = -1;\n  return mktime(&tm);\n}\n\nstatic int\nread_exttime(const char *p, struct rar *rar, const char *endp)\n{\n  unsigned rmode, flags, rem, j, count;\n  int ttime, i;\n  struct tm *tm;\n  time_t t;\n  long nsec;\n\n  if (p + 2 > endp)\n    return (-1);\n  flags = archive_le16dec(p);\n  p += 2;\n\n  for (i = 3; i >= 0; i--)\n  {\n    t = 0;\n    if (i == 3)\n      t = rar->mtime;\n    rmode = flags >> i * 4;\n    if (rmode & 8)\n    {\n      if (!t)\n      {\n        if (p + 4 > endp)\n          return (-1);\n        ttime = archive_le32dec(p);\n        t = get_time(ttime);\n        p += 4;\n      }\n      rem = 0;\n      count = rmode & 3;\n      if (p + count > endp)\n        return (-1);\n      for (j = 0; j < count; j++)\n      {\n        rem = (((unsigned)(unsigned char)*p) << 16) | (rem >> 8);\n        p++;\n      }\n      tm = localtime(&t);\n      nsec = tm->tm_sec + rem / NS_UNIT;\n      if (rmode & 4)\n      {\n        tm->tm_sec++;\n        t = mktime(tm);\n      }\n      if (i == 3)\n      {\n        rar->mtime = t;\n        rar->mnsec = nsec;\n      }\n      else if (i == 2)\n      {\n        rar->ctime = t;\n        rar->cnsec = nsec;\n      }\n      else if (i == 1)\n      {\n        rar->atime = t;\n        rar->ansec = nsec;\n      }\n      else\n      {\n        rar->arctime = t;\n        rar->arcnsec = nsec;\n      }\n    }\n  }\n  return (0);\n}\n\nstatic int\nread_symlink_stored(struct archive_read *a, struct archive_entry *entry,\n                    struct archive_string_conv *sconv)\n{\n  const void *h;\n  const char *p;\n  struct rar *rar;\n  int ret = (ARCHIVE_OK);\n\n  rar = (struct rar *)(a->format->data);\n  if ((h = rar_read_ahead(a, (size_t)rar->packed_size, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n  p = h;\n\n  if (archive_entry_copy_symlink_l(entry,\n      p, (size_t)rar->packed_size, sconv))\n  {\n    if (errno == ENOMEM)\n    {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Can't allocate memory for link\");\n      return (ARCHIVE_FATAL);\n    }\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"link cannot be converted from %s to current locale.\",\n                      archive_string_conversion_charset_name(sconv));\n    ret = (ARCHIVE_WARN);\n  }\n  __archive_read_consume(a, rar->packed_size);\n  return ret;\n}\n\nstatic int\nread_data_stored(struct archive_read *a, const void **buff, size_t *size,\n                 int64_t *offset)\n{\n  struct rar *rar;\n  ssize_t bytes_avail;\n\n  rar = (struct rar *)(a->format->data);\n  if (rar->bytes_remaining == 0 &&\n    !(rar->main_flags & MHD_VOLUME && rar->file_flags & FHD_SPLIT_AFTER))\n  {\n    *buff = NULL;\n    *size = 0;\n    *offset = rar->offset;\n    if (rar->file_crc != rar->crc_calculated) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"File CRC error\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->entry_eof = 1;\n    return (ARCHIVE_EOF);\n  }\n\n  *buff = rar_read_ahead(a, 1, &bytes_avail);\n  if (bytes_avail <= 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    return (ARCHIVE_FATAL);\n  }\n\n  *size = bytes_avail;\n  *offset = rar->offset;\n  rar->offset += bytes_avail;\n  rar->offset_seek += bytes_avail;\n  rar->bytes_remaining -= bytes_avail;\n  rar->bytes_unconsumed = bytes_avail;\n  /* Calculate File CRC. */\n  rar->crc_calculated = crc32(rar->crc_calculated, *buff,\n    (unsigned)bytes_avail);\n  return (ARCHIVE_OK);\n}\n\nstatic int\nread_data_compressed(struct archive_read *a, const void **buff, size_t *size,\n               int64_t *offset)\n{\n  struct rar *rar;\n  int64_t start, end, actualend;\n  size_t bs;\n  int ret = (ARCHIVE_OK), sym, code, lzss_offset, length, i;\n\n  rar = (struct rar *)(a->format->data);\n\n  do {\n    if (!rar->valid)\n      return (ARCHIVE_FATAL);\n    if (rar->ppmd_eod ||\n       (rar->dictionary_size && rar->offset >= rar->unp_size))\n    {\n      if (rar->unp_offset > 0) {\n        /*\n         * We have unprocessed extracted data. write it out.\n         */\n        *buff = rar->unp_buffer;\n        *size = rar->unp_offset;\n        *offset = rar->offset_outgoing;\n        rar->offset_outgoing += *size;\n        /* Calculate File CRC. */\n        rar->crc_calculated = crc32(rar->crc_calculated, *buff,\n          (unsigned)*size);\n        rar->unp_offset = 0;\n        return (ARCHIVE_OK);\n      }\n      *buff = NULL;\n      *size = 0;\n      *offset = rar->offset;\n      if (rar->file_crc != rar->crc_calculated) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"File CRC error\");\n        return (ARCHIVE_FATAL);\n      }\n      rar->entry_eof = 1;\n      return (ARCHIVE_EOF);\n    }\n\n    if (!rar->is_ppmd_block && rar->dictionary_size && rar->bytes_uncopied > 0)\n    {\n      if (rar->bytes_uncopied > (rar->unp_buffer_size - rar->unp_offset))\n        bs = rar->unp_buffer_size - rar->unp_offset;\n      else\n        bs = (size_t)rar->bytes_uncopied;\n      ret = copy_from_lzss_window(a, buff, rar->offset, (int)bs);\n      if (ret != ARCHIVE_OK)\n        return (ret);\n      rar->offset += bs;\n      rar->bytes_uncopied -= bs;\n      if (*buff != NULL) {\n        rar->unp_offset = 0;\n        *size = rar->unp_buffer_size;\n        *offset = rar->offset_outgoing;\n        rar->offset_outgoing += *size;\n        /* Calculate File CRC. */\n        rar->crc_calculated = crc32(rar->crc_calculated, *buff,\n          (unsigned)*size);\n        return (ret);\n      }\n      continue;\n    }\n\n    if (!rar->br.next_in &&\n      (ret = rar_br_preparation(a, &(rar->br))) < ARCHIVE_WARN)\n      return (ret);\n    if (rar->start_new_table && ((ret = parse_codes(a)) < (ARCHIVE_WARN)))\n      return (ret);\n\n    if (rar->is_ppmd_block)\n    {\n      if ((sym = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n        &rar->ppmd7_context, &rar->range_dec.p)) < 0)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid symbol\");\n        return (ARCHIVE_FATAL);\n      }\n      if(sym != rar->ppmd_escape)\n      {\n        lzss_emit_literal(rar, sym);\n        rar->bytes_uncopied++;\n      }\n      else\n      {\n        if ((code = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n          &rar->ppmd7_context, &rar->range_dec.p)) < 0)\n        {\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Invalid symbol\");\n          return (ARCHIVE_FATAL);\n        }\n\n        switch(code)\n        {\n          case 0:\n            rar->start_new_table = 1;\n            return read_data_compressed(a, buff, size, offset);\n\n          case 2:\n            rar->ppmd_eod = 1;/* End Of ppmd Data. */\n            continue;\n\n          case 3:\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n                              \"Parsing filters is unsupported.\");\n            return (ARCHIVE_FAILED);\n\n          case 4:\n            lzss_offset = 0;\n            for (i = 2; i >= 0; i--)\n            {\n              if ((code = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n                &rar->ppmd7_context, &rar->range_dec.p)) < 0)\n              {\n                archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                                  \"Invalid symbol\");\n                return (ARCHIVE_FATAL);\n              }\n              lzss_offset |= code << (i * 8);\n            }\n            if ((length = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n              &rar->ppmd7_context, &rar->range_dec.p)) < 0)\n            {\n              archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                                \"Invalid symbol\");\n              return (ARCHIVE_FATAL);\n            }\n            lzss_emit_match(rar, lzss_offset + 2, length + 32);\n            rar->bytes_uncopied += length + 32;\n            break;\n\n          case 5:\n            if ((length = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n              &rar->ppmd7_context, &rar->range_dec.p)) < 0)\n            {\n              archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                                \"Invalid symbol\");\n              return (ARCHIVE_FATAL);\n            }\n            lzss_emit_match(rar, 1, length + 4);\n            rar->bytes_uncopied += length + 4;\n            break;\n\n         default:\n           lzss_emit_literal(rar, sym);\n           rar->bytes_uncopied++;\n        }\n      }\n    }\n    else\n    {\n      start = rar->offset;\n      end = start + rar->dictionary_size;\n      rar->filterstart = INT64_MAX;\n\n      if ((actualend = expand(a, end)) < 0)\n        return ((int)actualend);\n\n      rar->bytes_uncopied = actualend - start;\n      if (rar->bytes_uncopied == 0) {\n          /* Broken RAR files cause this case.\n          * NOTE: If this case were possible on a normal RAR file\n          * we would find out where it was actually bad and\n          * what we would do to solve it. */\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Internal error extracting RAR file\");\n          return (ARCHIVE_FATAL);\n      }\n    }\n    if (rar->bytes_uncopied > (rar->unp_buffer_size - rar->unp_offset))\n      bs = rar->unp_buffer_size - rar->unp_offset;\n    else\n      bs = (size_t)rar->bytes_uncopied;\n    ret = copy_from_lzss_window(a, buff, rar->offset, (int)bs);\n    if (ret != ARCHIVE_OK)\n      return (ret);\n    rar->offset += bs;\n    rar->bytes_uncopied -= bs;\n    /*\n     * If *buff is NULL, it means unp_buffer is not full.\n     * So we have to continue extracting a RAR file.\n     */\n  } while (*buff == NULL);\n\n  rar->unp_offset = 0;\n  *size = rar->unp_buffer_size;\n  *offset = rar->offset_outgoing;\n  rar->offset_outgoing += *size;\n  /* Calculate File CRC. */\n  rar->crc_calculated = crc32(rar->crc_calculated, *buff, (unsigned)*size);\n  return ret;\n}\n\nstatic int\nparse_codes(struct archive_read *a)\n{\n  int i, j, val, n, r;\n  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;\n  unsigned int maxorder;\n  struct huffman_code precode;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  free_codes(a);\n\n  /* Skip to the next byte */\n  rar_br_consume_unalined_bits(br);\n\n  /* PPMd block flag */\n  if (!rar_br_read_ahead(a, br, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)\n  {\n    rar_br_consume(br, 1);\n    if (!rar_br_read_ahead(a, br, 7))\n      goto truncated_data;\n    ppmd_flags = rar_br_bits(br, 7);\n    rar_br_consume(br, 7);\n\n    /* Memory is allocated in MB */\n    if (ppmd_flags & 0x20)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;\n      rar_br_consume(br, 8);\n    }\n\n    if (ppmd_flags & 0x40)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);\n      rar_br_consume(br, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (ppmd_flags & 0x20)\n    {\n      maxorder = (ppmd_flags & 0x1F) + 1;\n      if(maxorder > 16)\n        maxorder = 16 + (maxorder - 16) * 3;\n\n      if (maxorder == 1)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Truncated RAR file data\");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Make sure ppmd7_contest is freed before Ppmd7_Construct\n       * because reading a broken file cause this abnormal sequence. */\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n\n      rar->bytein.a = a;\n      rar->bytein.Read = &ppmd_read;\n      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid zero dictionary size\");\n\t      return (ARCHIVE_FATAL);\n      }\n\n      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size))\n      {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Out of memory\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid PPMd sequence\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(br, 1);\n\n    /* Keep existing table flag */\n    if (!rar_br_read_ahead(a, br, 1))\n      goto truncated_data;\n    if (!rar_br_bits(br, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(br, 1);\n\n    memset(&bitlengths, 0, sizeof(bitlengths));\n    for (i = 0; i < MAX_SYMBOLS;)\n    {\n      if (!rar_br_read_ahead(a, br, 4))\n        goto truncated_data;\n      bitlengths[i++] = rar_br_bits(br, 4);\n      rar_br_consume(br, 4);\n      if (bitlengths[i-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(a, br, 4))\n          goto truncated_data;\n        zerocount = rar_br_bits(br, 4);\n        rar_br_consume(br, 4);\n        if (zerocount)\n        {\n          i--;\n          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)\n            bitlengths[i++] = 0;\n        }\n      }\n    }\n\n    memset(&precode, 0, sizeof(precode));\n    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK) {\n      free(precode.tree);\n      free(precode.table);\n      return (r);\n    }\n\n    for (i = 0; i < HUFFMAN_TABLE_SIZE;)\n    {\n      if ((val = read_next_symbol(a, &precode)) < 0) {\n        free(precode.tree);\n        free(precode.table);\n        return (ARCHIVE_FATAL);\n      }\n      if (val < 16)\n      {\n        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;\n        i++;\n      }\n      else if (val < 18)\n      {\n        if (i == 0)\n        {\n          free(precode.tree);\n          free(precode.table);\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Internal error extracting RAR file.\");\n          return (ARCHIVE_FATAL);\n        }\n\n        if(val == 16) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n        {\n          rar->lengthtable[i] = rar->lengthtable[i-1];\n          i++;\n        }\n      }\n      else\n      {\n        if(val == 18) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n          rar->lengthtable[i++] = 0;\n      }\n    }\n    free(precode.tree);\n    free(precode.table);\n\n    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,\n                MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],\n                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lowoffsetcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],\n                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lengthcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +\n                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* Seems as though dictionary sizes are not used. Even so, minimize\n     * memory usage as much as possible.\n     */\n    void *new_window;\n    unsigned int new_size;\n\n    if (rar->unp_size >= DICTIONARY_MAX_SIZE)\n      new_size = DICTIONARY_MAX_SIZE;\n    else\n      new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n    if (new_size == 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Zero window size is invalid.\");\n      return (ARCHIVE_FATAL);\n    }\n    new_window = realloc(rar->lzss.window, new_size);\n    if (new_window == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->lzss.window = (unsigned char *)new_window;\n    rar->dictionary_size = new_size;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (ARCHIVE_OK);\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\n}\n\nstatic void\nfree_codes(struct archive_read *a)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  free(rar->maincode.tree);\n  free(rar->offsetcode.tree);\n  free(rar->lowoffsetcode.tree);\n  free(rar->lengthcode.tree);\n  free(rar->maincode.table);\n  free(rar->offsetcode.table);\n  free(rar->lowoffsetcode.table);\n  free(rar->lengthcode.table);\n  memset(&rar->maincode, 0, sizeof(rar->maincode));\n  memset(&rar->offsetcode, 0, sizeof(rar->offsetcode));\n  memset(&rar->lowoffsetcode, 0, sizeof(rar->lowoffsetcode));\n  memset(&rar->lengthcode, 0, sizeof(rar->lengthcode));\n}\n\n\nstatic int\nread_next_symbol(struct archive_read *a, struct huffman_code *code)\n{\n  unsigned char bit;\n  unsigned int bits;\n  int length, value, node;\n  struct rar *rar;\n  struct rar_br *br;\n\n  if (!code->table)\n  {\n    if (make_table(a, code) != (ARCHIVE_OK))\n      return -1;\n  }\n\n  rar = (struct rar *)(a->format->data);\n  br = &(rar->br);\n\n  /* Look ahead (peek) at bits */\n  if (!rar_br_read_ahead(a, br, code->tablesize)) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    rar->valid = 0;\n    return -1;\n  }\n  bits = rar_br_bits(br, code->tablesize);\n\n  length = code->table[bits].length;\n  value = code->table[bits].value;\n\n  if (length < 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid prefix code in bitstream\");\n    return -1;\n  }\n\n  if (length <= code->tablesize)\n  {\n    /* Skip length bits */\n    rar_br_consume(br, length);\n    return value;\n  }\n\n  /* Skip tablesize bits */\n  rar_br_consume(br, code->tablesize);\n\n  node = value;\n  while (!(code->tree[node].branches[0] ==\n    code->tree[node].branches[1]))\n  {\n    if (!rar_br_read_ahead(a, br, 1)) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Truncated RAR file data\");\n      rar->valid = 0;\n      return -1;\n    }\n    bit = rar_br_bits(br, 1);\n    rar_br_consume(br, 1);\n\n    if (code->tree[node].branches[bit] < 0)\n    {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Invalid prefix code in bitstream\");\n      return -1;\n    }\n    node = code->tree[node].branches[bit];\n  }\n\n  return code->tree[node].branches[0];\n}\n\nstatic int\ncreate_code(struct archive_read *a, struct huffman_code *code,\n            unsigned char *lengths, int numsymbols, char maxlength)\n{\n  int i, j, codebits = 0, symbolsleft = numsymbols;\n\n  code->numentries = 0;\n  code->numallocatedentries = 0;\n  if (new_node(code) < 0) {\n    archive_set_error(&a->archive, ENOMEM,\n                      \"Unable to allocate memory for node data.\");\n    return (ARCHIVE_FATAL);\n  }\n  code->numentries = 1;\n  code->minlength = INT_MAX;\n  code->maxlength = INT_MIN;\n  codebits = 0;\n  for(i = 1; i <= maxlength; i++)\n  {\n    for(j = 0; j < numsymbols; j++)\n    {\n      if (lengths[j] != i) continue;\n      if (add_value(a, code, j, codebits, i) != ARCHIVE_OK)\n        return (ARCHIVE_FATAL);\n      codebits++;\n      if (--symbolsleft <= 0) { break; break; }\n    }\n    codebits <<= 1;\n  }\n  return (ARCHIVE_OK);\n}\n\nstatic int\nadd_value(struct archive_read *a, struct huffman_code *code, int value,\n          int codebits, int length)\n{\n  int repeatpos, lastnode, bitpos, bit, repeatnode, nextnode;\n\n  free(code->table);\n  code->table = NULL;\n\n  if(length > code->maxlength)\n    code->maxlength = length;\n  if(length < code->minlength)\n    code->minlength = length;\n\n  repeatpos = -1;\n  if (repeatpos == 0 || (repeatpos >= 0\n    && (((codebits >> (repeatpos - 1)) & 3) == 0\n    || ((codebits >> (repeatpos - 1)) & 3) == 3)))\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid repeat position\");\n    return (ARCHIVE_FATAL);\n  }\n\n  lastnode = 0;\n  for (bitpos = length - 1; bitpos >= 0; bitpos--)\n  {\n    bit = (codebits >> bitpos) & 1;\n\n    /* Leaf node check */\n    if (code->tree[lastnode].branches[0] ==\n      code->tree[lastnode].branches[1])\n    {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Prefix found\");\n      return (ARCHIVE_FATAL);\n    }\n\n    if (bitpos == repeatpos)\n    {\n      /* Open branch check */\n      if (!(code->tree[lastnode].branches[bit] < 0))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid repeating code\");\n        return (ARCHIVE_FATAL);\n      }\n\n      if ((repeatnode = new_node(code)) < 0) {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Unable to allocate memory for node data.\");\n        return (ARCHIVE_FATAL);\n      }\n      if ((nextnode = new_node(code)) < 0) {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Unable to allocate memory for node data.\");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Set branches */\n      code->tree[lastnode].branches[bit] = repeatnode;\n      code->tree[repeatnode].branches[bit] = repeatnode;\n      code->tree[repeatnode].branches[bit^1] = nextnode;\n      lastnode = nextnode;\n\n      bitpos++; /* terminating bit already handled, skip it */\n    }\n    else\n    {\n      /* Open branch check */\n      if (code->tree[lastnode].branches[bit] < 0)\n      {\n        if (new_node(code) < 0) {\n          archive_set_error(&a->archive, ENOMEM,\n                            \"Unable to allocate memory for node data.\");\n          return (ARCHIVE_FATAL);\n        }\n        code->tree[lastnode].branches[bit] = code->numentries++;\n      }\n\n      /* set to branch */\n      lastnode = code->tree[lastnode].branches[bit];\n    }\n  }\n\n  if (!(code->tree[lastnode].branches[0] == -1\n    && code->tree[lastnode].branches[1] == -2))\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Prefix found\");\n    return (ARCHIVE_FATAL);\n  }\n\n  /* Set leaf value */\n  code->tree[lastnode].branches[0] = value;\n  code->tree[lastnode].branches[1] = value;\n\n  return (ARCHIVE_OK);\n}\n\nstatic int\nnew_node(struct huffman_code *code)\n{\n  void *new_tree;\n  if (code->numallocatedentries == code->numentries) {\n    int new_num_entries = 256;\n    if (code->numentries > 0) {\n        new_num_entries = code->numentries * 2;\n    }\n    new_tree = realloc(code->tree, new_num_entries * sizeof(*code->tree));\n    if (new_tree == NULL)\n        return (-1);\n    code->tree = (struct huffman_tree_node *)new_tree;\n    code->numallocatedentries = new_num_entries;\n  }\n  code->tree[code->numentries].branches[0] = -1;\n  code->tree[code->numentries].branches[1] = -2;\n  return 1;\n}\n\nstatic int\nmake_table(struct archive_read *a, struct huffman_code *code)\n{\n  if (code->maxlength < code->minlength || code->maxlength > 10)\n    code->tablesize = 10;\n  else\n    code->tablesize = code->maxlength;\n\n  code->table =\n    (struct huffman_table_entry *)calloc(1, sizeof(*code->table)\n    * ((size_t)1 << code->tablesize));\n\n  return make_table_recurse(a, code, 0, code->table, 0, code->tablesize);\n}\n\nstatic int\nmake_table_recurse(struct archive_read *a, struct huffman_code *code, int node,\n                   struct huffman_table_entry *table, int depth,\n                   int maxdepth)\n{\n  int currtablesize, i, ret = (ARCHIVE_OK);\n\n  if (!code->tree)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Huffman tree was not created.\");\n    return (ARCHIVE_FATAL);\n  }\n  if (node < 0 || node >= code->numentries)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid location to Huffman tree specified.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  currtablesize = 1 << (maxdepth - depth);\n\n  if (code->tree[node].branches[0] ==\n    code->tree[node].branches[1])\n  {\n    for(i = 0; i < currtablesize; i++)\n    {\n      table[i].length = depth;\n      table[i].value = code->tree[node].branches[0];\n    }\n  }\n  else if (node < 0)\n  {\n    for(i = 0; i < currtablesize; i++)\n      table[i].length = -1;\n  }\n  else\n  {\n    if(depth == maxdepth)\n    {\n      table[0].length = maxdepth + 1;\n      table[0].value = node;\n    }\n    else\n    {\n      ret |= make_table_recurse(a, code, code->tree[node].branches[0], table,\n                                depth + 1, maxdepth);\n      ret |= make_table_recurse(a, code, code->tree[node].branches[1],\n                         table + currtablesize / 2, depth + 1, maxdepth);\n    }\n  }\n  return ret;\n}\n\nstatic int64_t\nexpand(struct archive_read *a, int64_t end)\n{\n  static const unsigned char lengthbases[] =\n    {   0,   1,   2,   3,   4,   5,   6,\n        7,   8,  10,  12,  14,  16,  20,\n       24,  28,  32,  40,  48,  56,  64,\n       80,  96, 112, 128, 160, 192, 224 };\n  static const unsigned char lengthbits[] =\n    { 0, 0, 0, 0, 0, 0, 0,\n      0, 1, 1, 1, 1, 2, 2,\n      2, 2, 3, 3, 3, 3, 4,\n      4, 4, 4, 5, 5, 5, 5 };\n  static const unsigned int offsetbases[] =\n    {       0,       1,       2,       3,       4,       6,\n            8,      12,      16,      24,      32,      48,\n           64,      96,     128,     192,     256,     384,\n          512,     768,    1024,    1536,    2048,    3072,\n         4096,    6144,    8192,   12288,   16384,   24576,\n        32768,   49152,   65536,   98304,  131072,  196608,\n       262144,  327680,  393216,  458752,  524288,  589824,\n       655360,  720896,  786432,  851968,  917504,  983040,\n      1048576, 1310720, 1572864, 1835008, 2097152, 2359296,\n      2621440, 2883584, 3145728, 3407872, 3670016, 3932160 };\n  static const unsigned char offsetbits[] =\n    {  0,  0,  0,  0,  1,  1,  2,  2,  3,  3,  4,  4,\n       5,  5,  6,  6,  7,  7,  8,  8,  9,  9, 10, 10,\n      11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16,\n      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18 };\n  static const unsigned char shortbases[] =\n    { 0, 4, 8, 16, 32, 64, 128, 192 };\n  static const unsigned char shortbits[] =\n    { 2, 2, 3, 4, 5, 6, 6, 6 };\n\n  int symbol, offs, len, offsindex, lensymbol, i, offssymbol, lowoffsetsymbol;\n  unsigned char newfile;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  if (rar->filterstart < end)\n    end = rar->filterstart;\n\n  while (1)\n  {\n    if (rar->output_last_match &&\n      lzss_position(&rar->lzss) + rar->lastlength <= end)\n    {\n      lzss_emit_match(rar, rar->lastoffset, rar->lastlength);\n      rar->output_last_match = 0;\n    }\n\n    if(rar->is_ppmd_block || rar->output_last_match ||\n      lzss_position(&rar->lzss) >= end)\n      return lzss_position(&rar->lzss);\n\n    if ((symbol = read_next_symbol(a, &rar->maincode)) < 0)\n      return (ARCHIVE_FATAL);\n    rar->output_last_match = 0;\n\n    if (symbol < 256)\n    {\n      lzss_emit_literal(rar, symbol);\n      continue;\n    }\n    else if (symbol == 256)\n    {\n      if (!rar_br_read_ahead(a, br, 1))\n        goto truncated_data;\n      newfile = !rar_br_bits(br, 1);\n      rar_br_consume(br, 1);\n\n      if(newfile)\n      {\n        rar->start_new_block = 1;\n        if (!rar_br_read_ahead(a, br, 1))\n          goto truncated_data;\n        rar->start_new_table = rar_br_bits(br, 1);\n        rar_br_consume(br, 1);\n        return lzss_position(&rar->lzss);\n      }\n      else\n      {\n        if (parse_codes(a) != ARCHIVE_OK)\n          return (ARCHIVE_FATAL);\n        continue;\n      }\n    }\n    else if(symbol==257)\n    {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n                        \"Parsing filters is unsupported.\");\n      return (ARCHIVE_FAILED);\n    }\n    else if(symbol==258)\n    {\n      if(rar->lastlength == 0)\n        continue;\n\n      offs = rar->lastoffset;\n      len = rar->lastlength;\n    }\n    else if (symbol <= 262)\n    {\n      offsindex = symbol - 259;\n      offs = rar->oldoffset[offsindex];\n\n      if ((lensymbol = read_next_symbol(a, &rar->lengthcode)) < 0)\n        goto bad_data;\n      if (lensymbol > (int)(sizeof(lengthbases)/sizeof(lengthbases[0])))\n        goto bad_data;\n      if (lensymbol > (int)(sizeof(lengthbits)/sizeof(lengthbits[0])))\n        goto bad_data;\n      len = lengthbases[lensymbol] + 2;\n      if (lengthbits[lensymbol] > 0) {\n        if (!rar_br_read_ahead(a, br, lengthbits[lensymbol]))\n          goto truncated_data;\n        len += rar_br_bits(br, lengthbits[lensymbol]);\n        rar_br_consume(br, lengthbits[lensymbol]);\n      }\n\n      for (i = offsindex; i > 0; i--)\n        rar->oldoffset[i] = rar->oldoffset[i-1];\n      rar->oldoffset[0] = offs;\n    }\n    else if(symbol<=270)\n    {\n      offs = shortbases[symbol-263] + 1;\n      if(shortbits[symbol-263] > 0) {\n        if (!rar_br_read_ahead(a, br, shortbits[symbol-263]))\n          goto truncated_data;\n        offs += rar_br_bits(br, shortbits[symbol-263]);\n        rar_br_consume(br, shortbits[symbol-263]);\n      }\n\n      len = 2;\n\n      for(i = 3; i > 0; i--)\n        rar->oldoffset[i] = rar->oldoffset[i-1];\n      rar->oldoffset[0] = offs;\n    }\n    else\n    {\n      if (symbol-271 > (int)(sizeof(lengthbases)/sizeof(lengthbases[0])))\n        goto bad_data;\n      if (symbol-271 > (int)(sizeof(lengthbits)/sizeof(lengthbits[0])))\n        goto bad_data;\n      len = lengthbases[symbol-271]+3;\n      if(lengthbits[symbol-271] > 0) {\n        if (!rar_br_read_ahead(a, br, lengthbits[symbol-271]))\n          goto truncated_data;\n        len += rar_br_bits(br, lengthbits[symbol-271]);\n        rar_br_consume(br, lengthbits[symbol-271]);\n      }\n\n      if ((offssymbol = read_next_symbol(a, &rar->offsetcode)) < 0)\n        goto bad_data;\n      if (offssymbol > (int)(sizeof(offsetbases)/sizeof(offsetbases[0])))\n        goto bad_data;\n      if (offssymbol > (int)(sizeof(offsetbits)/sizeof(offsetbits[0])))\n        goto bad_data;\n      offs = offsetbases[offssymbol]+1;\n      if(offsetbits[offssymbol] > 0)\n      {\n        if(offssymbol > 9)\n        {\n          if(offsetbits[offssymbol] > 4) {\n            if (!rar_br_read_ahead(a, br, offsetbits[offssymbol] - 4))\n              goto truncated_data;\n            offs += rar_br_bits(br, offsetbits[offssymbol] - 4) << 4;\n            rar_br_consume(br, offsetbits[offssymbol] - 4);\n\t  }\n\n          if(rar->numlowoffsetrepeats > 0)\n          {\n            rar->numlowoffsetrepeats--;\n            offs += rar->lastlowoffset;\n          }\n          else\n          {\n            if ((lowoffsetsymbol =\n              read_next_symbol(a, &rar->lowoffsetcode)) < 0)\n              return (ARCHIVE_FATAL);\n            if(lowoffsetsymbol == 16)\n            {\n              rar->numlowoffsetrepeats = 15;\n              offs += rar->lastlowoffset;\n            }\n            else\n            {\n              offs += lowoffsetsymbol;\n              rar->lastlowoffset = lowoffsetsymbol;\n            }\n          }\n        }\n        else {\n          if (!rar_br_read_ahead(a, br, offsetbits[offssymbol]))\n            goto truncated_data;\n          offs += rar_br_bits(br, offsetbits[offssymbol]);\n          rar_br_consume(br, offsetbits[offssymbol]);\n        }\n      }\n\n      if (offs >= 0x40000)\n        len++;\n      if (offs >= 0x2000)\n        len++;\n\n      for(i = 3; i > 0; i--)\n        rar->oldoffset[i] = rar->oldoffset[i-1];\n      rar->oldoffset[0] = offs;\n    }\n\n    rar->lastoffset = offs;\n    rar->lastlength = len;\n    rar->output_last_match = 1;\n  }\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\nbad_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Bad RAR file data\");\n  return (ARCHIVE_FATAL);\n}\n\nstatic int\ncopy_from_lzss_window(struct archive_read *a, const void **buffer,\n                        int64_t startpos, int length)\n{\n  int windowoffs, firstpart;\n  struct rar *rar = (struct rar *)(a->format->data);\n\n  if (!rar->unp_buffer)\n  {\n    if ((rar->unp_buffer = malloc(rar->unp_buffer_size)) == NULL)\n    {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (ARCHIVE_FATAL);\n    }\n  }\n\n  windowoffs = lzss_offset_for_position(&rar->lzss, startpos);\n  if(windowoffs + length <= lzss_size(&rar->lzss)) {\n    memcpy(&rar->unp_buffer[rar->unp_offset], &rar->lzss.window[windowoffs],\n           length);\n  } else if (length <= lzss_size(&rar->lzss)) {\n    firstpart = lzss_size(&rar->lzss) - windowoffs;\n    if (firstpart < 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Bad RAR file data\");\n      return (ARCHIVE_FATAL);\n    }\n    if (firstpart < length) {\n      memcpy(&rar->unp_buffer[rar->unp_offset],\n             &rar->lzss.window[windowoffs], firstpart);\n      memcpy(&rar->unp_buffer[rar->unp_offset + firstpart],\n             &rar->lzss.window[0], length - firstpart);\n    } else {\n      memcpy(&rar->unp_buffer[rar->unp_offset],\n             &rar->lzss.window[windowoffs], length);\n    }\n  } else {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Bad RAR file data\");\n      return (ARCHIVE_FATAL);\n  }\n  rar->unp_offset += length;\n  if (rar->unp_offset >= rar->unp_buffer_size)\n    *buffer = rar->unp_buffer;\n  else\n    *buffer = NULL;\n  return (ARCHIVE_OK);\n}\n\nstatic const void *\nrar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  const void *h = __archive_read_ahead(a, min, avail);\n  int ret;\n  if (avail)\n  {\n    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)\n      *avail = a->archive.read_data_requested;\n    if (*avail > rar->bytes_remaining)\n      *avail = (ssize_t)rar->bytes_remaining;\n    if (*avail < 0)\n      return NULL;\n    else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n      rar->file_flags & FHD_SPLIT_AFTER)\n    {\n      rar->filename_must_match = 1;\n      ret = archive_read_format_rar_read_header(a, a->entry);\n      if (ret == (ARCHIVE_EOF))\n      {\n        rar->has_endarc_header = 1;\n        ret = archive_read_format_rar_read_header(a, a->entry);\n      }\n      rar->filename_must_match = 0;\n      if (ret != (ARCHIVE_OK))\n        return NULL;\n      return rar_read_ahead(a, min, avail);\n    }\n  }\n  return h;\n}\n"], "fixing_code": ["/*-\n* Copyright (c) 2003-2007 Tim Kientzle\n* Copyright (c) 2011 Andres Mejia\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions\n* are met:\n* 1. Redistributions of source code must retain the above copyright\n*    notice, this list of conditions and the following disclaimer.\n* 2. Redistributions in binary form must reproduce the above copyright\n*    notice, this list of conditions and the following disclaimer in the\n*    documentation and/or other materials provided with the distribution.\n*\n* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"archive_platform.h\"\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#include <time.h>\n#include <limits.h>\n#ifdef HAVE_ZLIB_H\n#include <zlib.h> /* crc32 */\n#endif\n\n#include \"archive.h\"\n#ifndef HAVE_ZLIB_H\n#include \"archive_crc32.h\"\n#endif\n#include \"archive_endian.h\"\n#include \"archive_entry.h\"\n#include \"archive_entry_locale.h\"\n#include \"archive_ppmd7_private.h\"\n#include \"archive_private.h\"\n#include \"archive_read_private.h\"\n\n/* RAR signature, also known as the mark header */\n#define RAR_SIGNATURE \"\\x52\\x61\\x72\\x21\\x1A\\x07\\x00\"\n\n/* Header types */\n#define MARK_HEAD    0x72\n#define MAIN_HEAD    0x73\n#define FILE_HEAD    0x74\n#define COMM_HEAD    0x75\n#define AV_HEAD      0x76\n#define SUB_HEAD     0x77\n#define PROTECT_HEAD 0x78\n#define SIGN_HEAD    0x79\n#define NEWSUB_HEAD  0x7a\n#define ENDARC_HEAD  0x7b\n\n/* Main Header Flags */\n#define MHD_VOLUME       0x0001\n#define MHD_COMMENT      0x0002\n#define MHD_LOCK         0x0004\n#define MHD_SOLID        0x0008\n#define MHD_NEWNUMBERING 0x0010\n#define MHD_AV           0x0020\n#define MHD_PROTECT      0x0040\n#define MHD_PASSWORD     0x0080\n#define MHD_FIRSTVOLUME  0x0100\n#define MHD_ENCRYPTVER   0x0200\n\n/* Flags common to all headers */\n#define HD_MARKDELETION     0x4000\n#define HD_ADD_SIZE_PRESENT 0x8000\n\n/* File Header Flags */\n#define FHD_SPLIT_BEFORE 0x0001\n#define FHD_SPLIT_AFTER  0x0002\n#define FHD_PASSWORD     0x0004\n#define FHD_COMMENT      0x0008\n#define FHD_SOLID        0x0010\n#define FHD_LARGE        0x0100\n#define FHD_UNICODE      0x0200\n#define FHD_SALT         0x0400\n#define FHD_VERSION      0x0800\n#define FHD_EXTTIME      0x1000\n#define FHD_EXTFLAGS     0x2000\n\n/* File dictionary sizes */\n#define DICTIONARY_SIZE_64   0x00\n#define DICTIONARY_SIZE_128  0x20\n#define DICTIONARY_SIZE_256  0x40\n#define DICTIONARY_SIZE_512  0x60\n#define DICTIONARY_SIZE_1024 0x80\n#define DICTIONARY_SIZE_2048 0xA0\n#define DICTIONARY_SIZE_4096 0xC0\n#define FILE_IS_DIRECTORY    0xE0\n#define DICTIONARY_MASK      FILE_IS_DIRECTORY\n\n/* OS Flags */\n#define OS_MSDOS  0\n#define OS_OS2    1\n#define OS_WIN32  2\n#define OS_UNIX   3\n#define OS_MAC_OS 4\n#define OS_BEOS   5\n\n/* Compression Methods */\n#define COMPRESS_METHOD_STORE   0x30\n/* LZSS */\n#define COMPRESS_METHOD_FASTEST 0x31\n#define COMPRESS_METHOD_FAST    0x32\n#define COMPRESS_METHOD_NORMAL  0x33\n/* PPMd Variant H */\n#define COMPRESS_METHOD_GOOD    0x34\n#define COMPRESS_METHOD_BEST    0x35\n\n#define CRC_POLYNOMIAL 0xEDB88320\n\n#define NS_UNIT 10000000\n\n#define DICTIONARY_MAX_SIZE 0x400000\n\n#define MAINCODE_SIZE      299\n#define OFFSETCODE_SIZE    60\n#define LOWOFFSETCODE_SIZE 17\n#define LENGTHCODE_SIZE    28\n#define HUFFMAN_TABLE_SIZE \\\n  MAINCODE_SIZE + OFFSETCODE_SIZE + LOWOFFSETCODE_SIZE + LENGTHCODE_SIZE\n\n#define MAX_SYMBOL_LENGTH 0xF\n#define MAX_SYMBOLS       20\n\n/*\n * Considering L1,L2 cache miss and a calling of write system-call,\n * the best size of the output buffer(uncompressed buffer) is 128K.\n * If the structure of extracting process is changed, this value\n * might be researched again.\n */\n#define UNP_BUFFER_SIZE   (128 * 1024)\n\n/* Define this here for non-Windows platforms */\n#if !((defined(__WIN32__) || defined(_WIN32) || defined(__WIN32)) && !defined(__CYGWIN__))\n#define FILE_ATTRIBUTE_DIRECTORY 0x10\n#endif\n\n/* Fields common to all headers */\nstruct rar_header\n{\n  char crc[2];\n  char type;\n  char flags[2];\n  char size[2];\n};\n\n/* Fields common to all file headers */\nstruct rar_file_header\n{\n  char pack_size[4];\n  char unp_size[4];\n  char host_os;\n  char file_crc[4];\n  char file_time[4];\n  char unp_ver;\n  char method;\n  char name_size[2];\n  char file_attr[4];\n};\n\nstruct huffman_tree_node\n{\n  int branches[2];\n};\n\nstruct huffman_table_entry\n{\n  unsigned int length;\n  int value;\n};\n\nstruct huffman_code\n{\n  struct huffman_tree_node *tree;\n  int numentries;\n  int numallocatedentries;\n  int minlength;\n  int maxlength;\n  int tablesize;\n  struct huffman_table_entry *table;\n};\n\nstruct lzss\n{\n  unsigned char *window;\n  int mask;\n  int64_t position;\n};\n\nstruct data_block_offsets\n{\n  int64_t header_size;\n  int64_t start_offset;\n  int64_t end_offset;\n};\n\nstruct rar\n{\n  /* Entries from main RAR header */\n  unsigned main_flags;\n  unsigned long file_crc;\n  char reserved1[2];\n  char reserved2[4];\n  char encryptver;\n\n  /* File header entries */\n  char compression_method;\n  unsigned file_flags;\n  int64_t packed_size;\n  int64_t unp_size;\n  time_t mtime;\n  long mnsec;\n  mode_t mode;\n  char *filename;\n  char *filename_save;\n  size_t filename_save_size;\n  size_t filename_allocated;\n\n  /* File header optional entries */\n  char salt[8];\n  time_t atime;\n  long ansec;\n  time_t ctime;\n  long cnsec;\n  time_t arctime;\n  long arcnsec;\n\n  /* Fields to help with tracking decompression of files. */\n  int64_t bytes_unconsumed;\n  int64_t bytes_remaining;\n  int64_t bytes_uncopied;\n  int64_t offset;\n  int64_t offset_outgoing;\n  int64_t offset_seek;\n  char valid;\n  unsigned int unp_offset;\n  unsigned int unp_buffer_size;\n  unsigned char *unp_buffer;\n  unsigned int dictionary_size;\n  char start_new_block;\n  char entry_eof;\n  unsigned long crc_calculated;\n  int found_first_header;\n  char has_endarc_header;\n  struct data_block_offsets *dbo;\n  unsigned int cursor;\n  unsigned int nodes;\n  char filename_must_match;\n\n  /* LZSS members */\n  struct huffman_code maincode;\n  struct huffman_code offsetcode;\n  struct huffman_code lowoffsetcode;\n  struct huffman_code lengthcode;\n  unsigned char lengthtable[HUFFMAN_TABLE_SIZE];\n  struct lzss lzss;\n  char output_last_match;\n  unsigned int lastlength;\n  unsigned int lastoffset;\n  unsigned int oldoffset[4];\n  unsigned int lastlowoffset;\n  unsigned int numlowoffsetrepeats;\n  int64_t filterstart;\n  char start_new_table;\n\n  /* PPMd Variant H members */\n  char ppmd_valid;\n  char ppmd_eod;\n  char is_ppmd_block;\n  int ppmd_escape;\n  CPpmd7 ppmd7_context;\n  CPpmd7z_RangeDec range_dec;\n  IByteIn bytein;\n\n  /*\n   * String conversion object.\n   */\n  int init_default_conversion;\n  struct archive_string_conv *sconv_default;\n  struct archive_string_conv *opt_sconv;\n  struct archive_string_conv *sconv_utf8;\n  struct archive_string_conv *sconv_utf16be;\n\n  /*\n   * Bit stream reader.\n   */\n  struct rar_br {\n#define CACHE_TYPE\tuint64_t\n#define CACHE_BITS\t(8 * sizeof(CACHE_TYPE))\n    /* Cache buffer. */\n    CACHE_TYPE\t\t cache_buffer;\n    /* Indicates how many bits avail in cache_buffer. */\n    int\t\t\t cache_avail;\n    ssize_t\t\t avail_in;\n    const unsigned char *next_in;\n  } br;\n\n  /*\n   * Custom field to denote that this archive contains encrypted entries\n   */\n  int has_encrypted_entries;\n};\n\nstatic int archive_read_support_format_rar_capabilities(struct archive_read *);\nstatic int archive_read_format_rar_has_encrypted_entries(struct archive_read *);\nstatic int archive_read_format_rar_bid(struct archive_read *, int);\nstatic int archive_read_format_rar_options(struct archive_read *,\n    const char *, const char *);\nstatic int archive_read_format_rar_read_header(struct archive_read *,\n    struct archive_entry *);\nstatic int archive_read_format_rar_read_data(struct archive_read *,\n    const void **, size_t *, int64_t *);\nstatic int archive_read_format_rar_read_data_skip(struct archive_read *a);\nstatic int64_t archive_read_format_rar_seek_data(struct archive_read *, int64_t,\n    int);\nstatic int archive_read_format_rar_cleanup(struct archive_read *);\n\n/* Support functions */\nstatic int read_header(struct archive_read *, struct archive_entry *, char);\nstatic time_t get_time(int);\nstatic int read_exttime(const char *, struct rar *, const char *);\nstatic int read_symlink_stored(struct archive_read *, struct archive_entry *,\n                               struct archive_string_conv *);\nstatic int read_data_stored(struct archive_read *, const void **, size_t *,\n                            int64_t *);\nstatic int read_data_compressed(struct archive_read *, const void **, size_t *,\n                          int64_t *);\nstatic int rar_br_preparation(struct archive_read *, struct rar_br *);\nstatic int parse_codes(struct archive_read *);\nstatic void free_codes(struct archive_read *);\nstatic int read_next_symbol(struct archive_read *, struct huffman_code *);\nstatic int create_code(struct archive_read *, struct huffman_code *,\n                        unsigned char *, int, char);\nstatic int add_value(struct archive_read *, struct huffman_code *, int, int,\n                     int);\nstatic int new_node(struct huffman_code *);\nstatic int make_table(struct archive_read *, struct huffman_code *);\nstatic int make_table_recurse(struct archive_read *, struct huffman_code *, int,\n                              struct huffman_table_entry *, int, int);\nstatic int64_t expand(struct archive_read *, int64_t);\nstatic int copy_from_lzss_window(struct archive_read *, const void **,\n                                   int64_t, int);\nstatic const void *rar_read_ahead(struct archive_read *, size_t, ssize_t *);\n\n/*\n * Bit stream reader.\n */\n/* Check that the cache buffer has enough bits. */\n#define rar_br_has(br, n) ((br)->cache_avail >= n)\n/* Get compressed data by bit. */\n#define rar_br_bits(br, n)        \\\n  (((uint32_t)((br)->cache_buffer >>    \\\n    ((br)->cache_avail - (n)))) & cache_masks[n])\n#define rar_br_bits_forced(br, n)     \\\n  (((uint32_t)((br)->cache_buffer <<    \\\n    ((n) - (br)->cache_avail))) & cache_masks[n])\n/* Read ahead to make sure the cache buffer has enough compressed data we\n * will use.\n *  True  : completed, there is enough data in the cache buffer.\n *  False : there is no data in the stream. */\n#define rar_br_read_ahead(a, br, n) \\\n  ((rar_br_has(br, (n)) || rar_br_fillup(a, br)) || rar_br_has(br, (n)))\n/* Notify how many bits we consumed. */\n#define rar_br_consume(br, n) ((br)->cache_avail -= (n))\n#define rar_br_consume_unalined_bits(br) ((br)->cache_avail &= ~7)\n\nstatic const uint32_t cache_masks[] = {\n  0x00000000, 0x00000001, 0x00000003, 0x00000007,\n  0x0000000F, 0x0000001F, 0x0000003F, 0x0000007F,\n  0x000000FF, 0x000001FF, 0x000003FF, 0x000007FF,\n  0x00000FFF, 0x00001FFF, 0x00003FFF, 0x00007FFF,\n  0x0000FFFF, 0x0001FFFF, 0x0003FFFF, 0x0007FFFF,\n  0x000FFFFF, 0x001FFFFF, 0x003FFFFF, 0x007FFFFF,\n  0x00FFFFFF, 0x01FFFFFF, 0x03FFFFFF, 0x07FFFFFF,\n  0x0FFFFFFF, 0x1FFFFFFF, 0x3FFFFFFF, 0x7FFFFFFF,\n  0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF\n};\n\n/*\n * Shift away used bits in the cache data and fill it up with following bits.\n * Call this when cache buffer does not have enough bits you need.\n *\n * Returns 1 if the cache buffer is full.\n * Returns 0 if the cache buffer is not full; input buffer is empty.\n */\nstatic int\nrar_br_fillup(struct archive_read *a, struct rar_br *br)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int n = CACHE_BITS - br->cache_avail;\n\n  for (;;) {\n    switch (n >> 3) {\n    case 8:\n      if (br->avail_in >= 8) {\n        br->cache_buffer =\n            ((uint64_t)br->next_in[0]) << 56 |\n            ((uint64_t)br->next_in[1]) << 48 |\n            ((uint64_t)br->next_in[2]) << 40 |\n            ((uint64_t)br->next_in[3]) << 32 |\n            ((uint32_t)br->next_in[4]) << 24 |\n            ((uint32_t)br->next_in[5]) << 16 |\n            ((uint32_t)br->next_in[6]) << 8 |\n             (uint32_t)br->next_in[7];\n        br->next_in += 8;\n        br->avail_in -= 8;\n        br->cache_avail += 8 * 8;\n        rar->bytes_unconsumed += 8;\n        rar->bytes_remaining -= 8;\n        return (1);\n      }\n      break;\n    case 7:\n      if (br->avail_in >= 7) {\n        br->cache_buffer =\n           (br->cache_buffer << 56) |\n            ((uint64_t)br->next_in[0]) << 48 |\n            ((uint64_t)br->next_in[1]) << 40 |\n            ((uint64_t)br->next_in[2]) << 32 |\n            ((uint32_t)br->next_in[3]) << 24 |\n            ((uint32_t)br->next_in[4]) << 16 |\n            ((uint32_t)br->next_in[5]) << 8 |\n             (uint32_t)br->next_in[6];\n        br->next_in += 7;\n        br->avail_in -= 7;\n        br->cache_avail += 7 * 8;\n        rar->bytes_unconsumed += 7;\n        rar->bytes_remaining -= 7;\n        return (1);\n      }\n      break;\n    case 6:\n      if (br->avail_in >= 6) {\n        br->cache_buffer =\n           (br->cache_buffer << 48) |\n            ((uint64_t)br->next_in[0]) << 40 |\n            ((uint64_t)br->next_in[1]) << 32 |\n            ((uint32_t)br->next_in[2]) << 24 |\n            ((uint32_t)br->next_in[3]) << 16 |\n            ((uint32_t)br->next_in[4]) << 8 |\n             (uint32_t)br->next_in[5];\n        br->next_in += 6;\n        br->avail_in -= 6;\n        br->cache_avail += 6 * 8;\n        rar->bytes_unconsumed += 6;\n        rar->bytes_remaining -= 6;\n        return (1);\n      }\n      break;\n    case 0:\n      /* We have enough compressed data in\n       * the cache buffer.*/\n      return (1);\n    default:\n      break;\n    }\n    if (br->avail_in <= 0) {\n\n      if (rar->bytes_unconsumed > 0) {\n        /* Consume as much as the decompressor\n         * actually used. */\n        __archive_read_consume(a, rar->bytes_unconsumed);\n        rar->bytes_unconsumed = 0;\n      }\n      br->next_in = rar_read_ahead(a, 1, &(br->avail_in));\n      if (br->next_in == NULL)\n        return (0);\n      if (br->avail_in == 0)\n        return (0);\n    }\n    br->cache_buffer =\n       (br->cache_buffer << 8) | *br->next_in++;\n    br->avail_in--;\n    br->cache_avail += 8;\n    n -= 8;\n    rar->bytes_unconsumed++;\n    rar->bytes_remaining--;\n  }\n}\n\nstatic int\nrar_br_preparation(struct archive_read *a, struct rar_br *br)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n\n  if (rar->bytes_remaining > 0) {\n    br->next_in = rar_read_ahead(a, 1, &(br->avail_in));\n    if (br->next_in == NULL) {\n      archive_set_error(&a->archive,\n          ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Truncated RAR file data\");\n      return (ARCHIVE_FATAL);\n    }\n    if (br->cache_avail == 0)\n      (void)rar_br_fillup(a, br);\n  }\n  return (ARCHIVE_OK);\n}\n\n/* Find last bit set */\nstatic inline int\nrar_fls(unsigned int word)\n{\n  word |= (word >>  1);\n  word |= (word >>  2);\n  word |= (word >>  4);\n  word |= (word >>  8);\n  word |= (word >> 16);\n  return word - (word >> 1);\n}\n\n/* LZSS functions */\nstatic inline int64_t\nlzss_position(struct lzss *lzss)\n{\n  return lzss->position;\n}\n\nstatic inline int\nlzss_mask(struct lzss *lzss)\n{\n  return lzss->mask;\n}\n\nstatic inline int\nlzss_size(struct lzss *lzss)\n{\n  return lzss->mask + 1;\n}\n\nstatic inline int\nlzss_offset_for_position(struct lzss *lzss, int64_t pos)\n{\n  return (int)(pos & lzss->mask);\n}\n\nstatic inline unsigned char *\nlzss_pointer_for_position(struct lzss *lzss, int64_t pos)\n{\n  return &lzss->window[lzss_offset_for_position(lzss, pos)];\n}\n\nstatic inline int\nlzss_current_offset(struct lzss *lzss)\n{\n  return lzss_offset_for_position(lzss, lzss->position);\n}\n\nstatic inline uint8_t *\nlzss_current_pointer(struct lzss *lzss)\n{\n  return lzss_pointer_for_position(lzss, lzss->position);\n}\n\nstatic inline void\nlzss_emit_literal(struct rar *rar, uint8_t literal)\n{\n  *lzss_current_pointer(&rar->lzss) = literal;\n  rar->lzss.position++;\n}\n\nstatic inline void\nlzss_emit_match(struct rar *rar, int offset, int length)\n{\n  int dstoffs = lzss_current_offset(&rar->lzss);\n  int srcoffs = (dstoffs - offset) & lzss_mask(&rar->lzss);\n  int l, li, remaining;\n  unsigned char *d, *s;\n\n  remaining = length;\n  while (remaining > 0) {\n    l = remaining;\n    if (dstoffs > srcoffs) {\n      if (l > lzss_size(&rar->lzss) - dstoffs)\n        l = lzss_size(&rar->lzss) - dstoffs;\n    } else {\n      if (l > lzss_size(&rar->lzss) - srcoffs)\n        l = lzss_size(&rar->lzss) - srcoffs;\n    }\n    d = &(rar->lzss.window[dstoffs]);\n    s = &(rar->lzss.window[srcoffs]);\n    if ((dstoffs + l < srcoffs) || (srcoffs + l < dstoffs))\n      memcpy(d, s, l);\n    else {\n      for (li = 0; li < l; li++)\n        d[li] = s[li];\n    }\n    remaining -= l;\n    dstoffs = (dstoffs + l) & lzss_mask(&(rar->lzss));\n    srcoffs = (srcoffs + l) & lzss_mask(&(rar->lzss));\n  }\n  rar->lzss.position += length;\n}\n\nstatic Byte\nppmd_read(void *p)\n{\n  struct archive_read *a = ((IByteIn*)p)->a;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n  Byte b;\n  if (!rar_br_read_ahead(a, br, 8))\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    rar->valid = 0;\n    return 0;\n  }\n  b = rar_br_bits(br, 8);\n  rar_br_consume(br, 8);\n  return b;\n}\n\nint\narchive_read_support_format_rar(struct archive *_a)\n{\n  struct archive_read *a = (struct archive_read *)_a;\n  struct rar *rar;\n  int r;\n\n  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n                      \"archive_read_support_format_rar\");\n\n  rar = (struct rar *)calloc(sizeof(*rar), 1);\n  if (rar == NULL)\n  {\n    archive_set_error(&a->archive, ENOMEM, \"Can't allocate rar data\");\n    return (ARCHIVE_FATAL);\n  }\n\n\t/*\n\t * Until enough data has been read, we cannot tell about\n\t * any encrypted entries yet.\n\t */\n\trar->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\n  r = __archive_read_register_format(a,\n                                     rar,\n                                     \"rar\",\n                                     archive_read_format_rar_bid,\n                                     archive_read_format_rar_options,\n                                     archive_read_format_rar_read_header,\n                                     archive_read_format_rar_read_data,\n                                     archive_read_format_rar_read_data_skip,\n                                     archive_read_format_rar_seek_data,\n                                     archive_read_format_rar_cleanup,\n                                     archive_read_support_format_rar_capabilities,\n                                     archive_read_format_rar_has_encrypted_entries);\n\n  if (r != ARCHIVE_OK)\n    free(rar);\n  return (r);\n}\n\nstatic int\narchive_read_support_format_rar_capabilities(struct archive_read * a)\n{\n\t(void)a; /* UNUSED */\n\treturn (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA\n\t\t\t| ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);\n}\n\nstatic int\narchive_read_format_rar_has_encrypted_entries(struct archive_read *_a)\n{\n\tif (_a && _a->format) {\n\t\tstruct rar * rar = (struct rar *)_a->format->data;\n\t\tif (rar) {\n\t\t\treturn rar->has_encrypted_entries;\n\t\t}\n\t}\n\treturn ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n}\n\n\nstatic int\narchive_read_format_rar_bid(struct archive_read *a, int best_bid)\n{\n  const char *p;\n\n  /* If there's already a bid > 30, we'll never win. */\n  if (best_bid > 30)\n\t  return (-1);\n\n  if ((p = __archive_read_ahead(a, 7, NULL)) == NULL)\n    return (-1);\n\n  if (memcmp(p, RAR_SIGNATURE, 7) == 0)\n    return (30);\n\n  if ((p[0] == 'M' && p[1] == 'Z') || memcmp(p, \"\\x7F\\x45LF\", 4) == 0) {\n    /* This is a PE file */\n    ssize_t offset = 0x10000;\n    ssize_t window = 4096;\n    ssize_t bytes_avail;\n    while (offset + window <= (1024 * 128)) {\n      const char *buff = __archive_read_ahead(a, offset + window, &bytes_avail);\n      if (buff == NULL) {\n        /* Remaining bytes are less than window. */\n        window >>= 1;\n        if (window < 0x40)\n          return (0);\n        continue;\n      }\n      p = buff + offset;\n      while (p + 7 < buff + bytes_avail) {\n        if (memcmp(p, RAR_SIGNATURE, 7) == 0)\n          return (30);\n        p += 0x10;\n      }\n      offset = p - buff;\n    }\n  }\n  return (0);\n}\n\nstatic int\nskip_sfx(struct archive_read *a)\n{\n  const void *h;\n  const char *p, *q;\n  size_t skip, total;\n  ssize_t bytes, window;\n\n  total = 0;\n  window = 4096;\n  while (total + window <= (1024 * 128)) {\n    h = __archive_read_ahead(a, window, &bytes);\n    if (h == NULL) {\n      /* Remaining bytes are less than window. */\n      window >>= 1;\n      if (window < 0x40)\n      \tgoto fatal;\n      continue;\n    }\n    if (bytes < 0x40)\n      goto fatal;\n    p = h;\n    q = p + bytes;\n\n    /*\n     * Scan ahead until we find something that looks\n     * like the RAR header.\n     */\n    while (p + 7 < q) {\n      if (memcmp(p, RAR_SIGNATURE, 7) == 0) {\n      \tskip = p - (const char *)h;\n      \t__archive_read_consume(a, skip);\n      \treturn (ARCHIVE_OK);\n      }\n      p += 0x10;\n    }\n    skip = p - (const char *)h;\n    __archive_read_consume(a, skip);\n\ttotal += skip;\n  }\nfatal:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Couldn't find out RAR header\");\n  return (ARCHIVE_FATAL);\n}\n\nstatic int\narchive_read_format_rar_options(struct archive_read *a,\n    const char *key, const char *val)\n{\n  struct rar *rar;\n  int ret = ARCHIVE_FAILED;\n\n  rar = (struct rar *)(a->format->data);\n  if (strcmp(key, \"hdrcharset\")  == 0) {\n    if (val == NULL || val[0] == 0)\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n          \"rar: hdrcharset option needs a character-set name\");\n    else {\n      rar->opt_sconv =\n          archive_string_conversion_from_charset(\n              &a->archive, val, 0);\n      if (rar->opt_sconv != NULL)\n        ret = ARCHIVE_OK;\n      else\n        ret = ARCHIVE_FATAL;\n    }\n    return (ret);\n  }\n\n  /* Note: The \"warn\" return is just to inform the options\n   * supervisor that we didn't handle it.  It will generate\n   * a suitable error if no one used this option. */\n  return (ARCHIVE_WARN);\n}\n\nstatic int\narchive_read_format_rar_read_header(struct archive_read *a,\n                                    struct archive_entry *entry)\n{\n  const void *h;\n  const char *p;\n  struct rar *rar;\n  size_t skip;\n  char head_type;\n  int ret;\n  unsigned flags;\n  unsigned long crc32_expected;\n\n  a->archive.archive_format = ARCHIVE_FORMAT_RAR;\n  if (a->archive.archive_format_name == NULL)\n    a->archive.archive_format_name = \"RAR\";\n\n  rar = (struct rar *)(a->format->data);\n\n  /*\n   * It should be sufficient to call archive_read_next_header() for\n   * a reader to determine if an entry is encrypted or not. If the\n   * encryption of an entry is only detectable when calling\n   * archive_read_data(), so be it. We'll do the same check there\n   * as well.\n   */\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n\n  /* RAR files can be generated without EOF headers, so return ARCHIVE_EOF if\n  * this fails.\n  */\n  if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)\n    return (ARCHIVE_EOF);\n\n  p = h;\n  if (rar->found_first_header == 0 &&\n     ((p[0] == 'M' && p[1] == 'Z') || memcmp(p, \"\\x7F\\x45LF\", 4) == 0)) {\n    /* This is an executable ? Must be self-extracting... */\n    ret = skip_sfx(a);\n    if (ret < ARCHIVE_WARN)\n      return (ret);\n  }\n  rar->found_first_header = 1;\n\n  while (1)\n  {\n    unsigned long crc32_val;\n\n    if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)\n      return (ARCHIVE_FATAL);\n    p = h;\n\n    head_type = p[2];\n    switch(head_type)\n    {\n    case MARK_HEAD:\n      if (memcmp(p, RAR_SIGNATURE, 7) != 0) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid marker header\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_read_consume(a, 7);\n      break;\n\n    case MAIN_HEAD:\n      rar->main_flags = archive_le16dec(p + 3);\n      skip = archive_le16dec(p + 5);\n      if (skip < 7 + sizeof(rar->reserved1) + sizeof(rar->reserved2)) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid header size\");\n        return (ARCHIVE_FATAL);\n      }\n      if ((h = __archive_read_ahead(a, skip, NULL)) == NULL)\n        return (ARCHIVE_FATAL);\n      p = h;\n      memcpy(rar->reserved1, p + 7, sizeof(rar->reserved1));\n      memcpy(rar->reserved2, p + 7 + sizeof(rar->reserved1),\n             sizeof(rar->reserved2));\n      if (rar->main_flags & MHD_ENCRYPTVER) {\n        if (skip < 7 + sizeof(rar->reserved1) + sizeof(rar->reserved2)+1) {\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n            \"Invalid header size\");\n          return (ARCHIVE_FATAL);\n        }\n        rar->encryptver = *(p + 7 + sizeof(rar->reserved1) +\n                            sizeof(rar->reserved2));\n      }\n\n      /* Main header is password encrypted, so we cannot read any\n         file names or any other info about files from the header. */\n      if (rar->main_flags & MHD_PASSWORD)\n      {\n        archive_entry_set_is_metadata_encrypted(entry, 1);\n        archive_entry_set_is_data_encrypted(entry, 1);\n        rar->has_encrypted_entries = 1;\n         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"RAR encryption support unavailable.\");\n        return (ARCHIVE_FATAL);\n      }\n\n      crc32_val = crc32(0, (const unsigned char *)p + 2, (unsigned)skip - 2);\n      if ((crc32_val & 0xffff) != archive_le16dec(p)) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Header CRC error\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_read_consume(a, skip);\n      break;\n\n    case FILE_HEAD:\n      return read_header(a, entry, head_type);\n\n    case COMM_HEAD:\n    case AV_HEAD:\n    case SUB_HEAD:\n    case PROTECT_HEAD:\n    case SIGN_HEAD:\n    case ENDARC_HEAD:\n      flags = archive_le16dec(p + 3);\n      skip = archive_le16dec(p + 5);\n      if (skip < 7) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid header size too small\");\n        return (ARCHIVE_FATAL);\n      }\n      if (flags & HD_ADD_SIZE_PRESENT)\n      {\n        if (skip < 7 + 4) {\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n            \"Invalid header size too small\");\n          return (ARCHIVE_FATAL);\n        }\n        if ((h = __archive_read_ahead(a, skip, NULL)) == NULL)\n          return (ARCHIVE_FATAL);\n        p = h;\n        skip += archive_le32dec(p + 7);\n      }\n\n      /* Skip over the 2-byte CRC at the beginning of the header. */\n      crc32_expected = archive_le16dec(p);\n      __archive_read_consume(a, 2);\n      skip -= 2;\n\n      /* Skim the entire header and compute the CRC. */\n      crc32_val = 0;\n      while (skip > 0) {\n\t      size_t to_read = skip;\n\t      ssize_t did_read;\n\t      if (to_read > 32 * 1024) {\n\t\t      to_read = 32 * 1024;\n\t      }\n\t      if ((h = __archive_read_ahead(a, to_read, &did_read)) == NULL) {\n\t\t      return (ARCHIVE_FATAL);\n\t      }\n\t      p = h;\n\t      crc32_val = crc32(crc32_val, (const unsigned char *)p, (unsigned)did_read);\n\t      __archive_read_consume(a, did_read);\n\t      skip -= did_read;\n      }\n      if ((crc32_val & 0xffff) != crc32_expected) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t  \"Header CRC error\");\n\t      return (ARCHIVE_FATAL);\n      }\n      if (head_type == ENDARC_HEAD)\n\t      return (ARCHIVE_EOF);\n      break;\n\n    case NEWSUB_HEAD:\n      if ((ret = read_header(a, entry, head_type)) < ARCHIVE_WARN)\n        return ret;\n      break;\n\n    default:\n      archive_set_error(&a->archive,  ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Bad RAR file\");\n      return (ARCHIVE_FATAL);\n    }\n  }\n}\n\nstatic int\narchive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n\n  if (rar->bytes_unconsumed > 0) {\n      /* Consume as much as the decompressor actually used. */\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN) {\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n      rar->start_new_table = 1;\n    }\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}\n\nstatic int\narchive_read_format_rar_read_data_skip(struct archive_read *a)\n{\n  struct rar *rar;\n  int64_t bytes_skipped;\n  int ret;\n\n  rar = (struct rar *)(a->format->data);\n\n  if (rar->bytes_unconsumed > 0) {\n      /* Consume as much as the decompressor actually used. */\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n\n  if (rar->bytes_remaining > 0) {\n    bytes_skipped = __archive_read_consume(a, rar->bytes_remaining);\n    if (bytes_skipped < 0)\n      return (ARCHIVE_FATAL);\n  }\n\n  /* Compressed data to skip must be read from each header in a multivolume\n   * archive.\n   */\n  if (rar->main_flags & MHD_VOLUME && rar->file_flags & FHD_SPLIT_AFTER)\n  {\n    ret = archive_read_format_rar_read_header(a, a->entry);\n    if (ret == (ARCHIVE_EOF))\n      ret = archive_read_format_rar_read_header(a, a->entry);\n    if (ret != (ARCHIVE_OK))\n      return ret;\n    return archive_read_format_rar_read_data_skip(a);\n  }\n\n  return (ARCHIVE_OK);\n}\n\nstatic int64_t\narchive_read_format_rar_seek_data(struct archive_read *a, int64_t offset,\n    int whence)\n{\n  int64_t client_offset, ret;\n  unsigned int i;\n  struct rar *rar = (struct rar *)(a->format->data);\n\n  if (rar->compression_method == COMPRESS_METHOD_STORE)\n  {\n    /* Modify the offset for use with SEEK_SET */\n    switch (whence)\n    {\n      case SEEK_CUR:\n        client_offset = rar->offset_seek;\n        break;\n      case SEEK_END:\n        client_offset = rar->unp_size;\n        break;\n      case SEEK_SET:\n      default:\n        client_offset = 0;\n    }\n    client_offset += offset;\n    if (client_offset < 0)\n    {\n      /* Can't seek past beginning of data block */\n      return -1;\n    }\n    else if (client_offset > rar->unp_size)\n    {\n      /*\n       * Set the returned offset but only seek to the end of\n       * the data block.\n       */\n      rar->offset_seek = client_offset;\n      client_offset = rar->unp_size;\n    }\n\n    client_offset += rar->dbo[0].start_offset;\n    i = 0;\n    while (i < rar->cursor)\n    {\n      i++;\n      client_offset += rar->dbo[i].start_offset - rar->dbo[i-1].end_offset;\n    }\n    if (rar->main_flags & MHD_VOLUME)\n    {\n      /* Find the appropriate offset among the multivolume archive */\n      while (1)\n      {\n        if (client_offset < rar->dbo[rar->cursor].start_offset &&\n          rar->file_flags & FHD_SPLIT_BEFORE)\n        {\n          /* Search backwards for the correct data block */\n          if (rar->cursor == 0)\n          {\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n              \"Attempt to seek past beginning of RAR data block\");\n            return (ARCHIVE_FAILED);\n          }\n          rar->cursor--;\n          client_offset -= rar->dbo[rar->cursor+1].start_offset -\n            rar->dbo[rar->cursor].end_offset;\n          if (client_offset < rar->dbo[rar->cursor].start_offset)\n            continue;\n          ret = __archive_read_seek(a, rar->dbo[rar->cursor].start_offset -\n            rar->dbo[rar->cursor].header_size, SEEK_SET);\n          if (ret < (ARCHIVE_OK))\n            return ret;\n          ret = archive_read_format_rar_read_header(a, a->entry);\n          if (ret != (ARCHIVE_OK))\n          {\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n              \"Error during seek of RAR file\");\n            return (ARCHIVE_FAILED);\n          }\n          rar->cursor--;\n          break;\n        }\n        else if (client_offset > rar->dbo[rar->cursor].end_offset &&\n          rar->file_flags & FHD_SPLIT_AFTER)\n        {\n          /* Search forward for the correct data block */\n          rar->cursor++;\n          if (rar->cursor < rar->nodes &&\n            client_offset > rar->dbo[rar->cursor].end_offset)\n          {\n            client_offset += rar->dbo[rar->cursor].start_offset -\n              rar->dbo[rar->cursor-1].end_offset;\n            continue;\n          }\n          rar->cursor--;\n          ret = __archive_read_seek(a, rar->dbo[rar->cursor].end_offset,\n                                    SEEK_SET);\n          if (ret < (ARCHIVE_OK))\n            return ret;\n          ret = archive_read_format_rar_read_header(a, a->entry);\n          if (ret == (ARCHIVE_EOF))\n          {\n            rar->has_endarc_header = 1;\n            ret = archive_read_format_rar_read_header(a, a->entry);\n          }\n          if (ret != (ARCHIVE_OK))\n          {\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n              \"Error during seek of RAR file\");\n            return (ARCHIVE_FAILED);\n          }\n          client_offset += rar->dbo[rar->cursor].start_offset -\n            rar->dbo[rar->cursor-1].end_offset;\n          continue;\n        }\n        break;\n      }\n    }\n\n    ret = __archive_read_seek(a, client_offset, SEEK_SET);\n    if (ret < (ARCHIVE_OK))\n      return ret;\n    rar->bytes_remaining = rar->dbo[rar->cursor].end_offset - ret;\n    i = rar->cursor;\n    while (i > 0)\n    {\n      i--;\n      ret -= rar->dbo[i+1].start_offset - rar->dbo[i].end_offset;\n    }\n    ret -= rar->dbo[0].start_offset;\n\n    /* Always restart reading the file after a seek */\n    __archive_reset_read_data(&a->archive);\n\n    rar->bytes_unconsumed = 0;\n    rar->offset = 0;\n\n    /*\n     * If a seek past the end of file was requested, return the requested\n     * offset.\n     */\n    if (ret == rar->unp_size && rar->offset_seek > rar->unp_size)\n      return rar->offset_seek;\n\n    /* Return the new offset */\n    rar->offset_seek = ret;\n    return rar->offset_seek;\n  }\n  else\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n      \"Seeking of compressed RAR files is unsupported\");\n  }\n  return (ARCHIVE_FAILED);\n}\n\nstatic int\narchive_read_format_rar_cleanup(struct archive_read *a)\n{\n  struct rar *rar;\n\n  rar = (struct rar *)(a->format->data);\n  free_codes(a);\n  free(rar->filename);\n  free(rar->filename_save);\n  free(rar->dbo);\n  free(rar->unp_buffer);\n  free(rar->lzss.window);\n  __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n  free(rar);\n  (a->format->data) = NULL;\n  return (ARCHIVE_OK);\n}\n\nstatic int\nread_header(struct archive_read *a, struct archive_entry *entry,\n            char head_type)\n{\n  const void *h;\n  const char *p, *endp;\n  struct rar *rar;\n  struct rar_header rar_header;\n  struct rar_file_header file_header;\n  int64_t header_size;\n  unsigned filename_size, end;\n  char *filename;\n  char *strp;\n  char packed_size[8];\n  char unp_size[8];\n  int ttime;\n  struct archive_string_conv *sconv, *fn_sconv;\n  unsigned long crc32_val;\n  int ret = (ARCHIVE_OK), ret2;\n\n  rar = (struct rar *)(a->format->data);\n\n  /* Setup a string conversion object for non-rar-unicode filenames. */\n  sconv = rar->opt_sconv;\n  if (sconv == NULL) {\n    if (!rar->init_default_conversion) {\n      rar->sconv_default =\n          archive_string_default_conversion_for_read(\n            &(a->archive));\n      rar->init_default_conversion = 1;\n    }\n    sconv = rar->sconv_default;\n  }\n\n\n  if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n  p = h;\n  memcpy(&rar_header, p, sizeof(rar_header));\n  rar->file_flags = archive_le16dec(rar_header.flags);\n  header_size = archive_le16dec(rar_header.size);\n  if (header_size < (int64_t)sizeof(file_header) + 7) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid header size\");\n    return (ARCHIVE_FATAL);\n  }\n  crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);\n  __archive_read_consume(a, 7);\n\n  if (!(rar->file_flags & FHD_SOLID))\n  {\n    rar->compression_method = 0;\n    rar->packed_size = 0;\n    rar->unp_size = 0;\n    rar->mtime = 0;\n    rar->ctime = 0;\n    rar->atime = 0;\n    rar->arctime = 0;\n    rar->mode = 0;\n    memset(&rar->salt, 0, sizeof(rar->salt));\n    rar->atime = 0;\n    rar->ansec = 0;\n    rar->ctime = 0;\n    rar->cnsec = 0;\n    rar->mtime = 0;\n    rar->mnsec = 0;\n    rar->arctime = 0;\n    rar->arcnsec = 0;\n  }\n  else\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR solid archive support unavailable.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n\n  /* File Header CRC check. */\n  crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));\n  if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Header CRC error\");\n    return (ARCHIVE_FATAL);\n  }\n  /* If no CRC error, Go on parsing File Header. */\n  p = h;\n  endp = p + header_size - 7;\n  memcpy(&file_header, p, sizeof(file_header));\n  p += sizeof(file_header);\n\n  rar->compression_method = file_header.method;\n\n  ttime = archive_le32dec(file_header.file_time);\n  rar->mtime = get_time(ttime);\n\n  rar->file_crc = archive_le32dec(file_header.file_crc);\n\n  if (rar->file_flags & FHD_PASSWORD)\n  {\n\tarchive_entry_set_is_data_encrypted(entry, 1);\n\trar->has_encrypted_entries = 1;\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR encryption support unavailable.\");\n    /* Since it is only the data part itself that is encrypted we can at least\n       extract information about the currently processed entry and don't need\n       to return ARCHIVE_FATAL here. */\n    /*return (ARCHIVE_FATAL);*/\n  }\n\n  if (rar->file_flags & FHD_LARGE)\n  {\n    memcpy(packed_size, file_header.pack_size, 4);\n    memcpy(packed_size + 4, p, 4); /* High pack size */\n    p += 4;\n    memcpy(unp_size, file_header.unp_size, 4);\n    memcpy(unp_size + 4, p, 4); /* High unpack size */\n    p += 4;\n    rar->packed_size = archive_le64dec(&packed_size);\n    rar->unp_size = archive_le64dec(&unp_size);\n  }\n  else\n  {\n    rar->packed_size = archive_le32dec(file_header.pack_size);\n    rar->unp_size = archive_le32dec(file_header.unp_size);\n  }\n\n  if (rar->packed_size < 0 || rar->unp_size < 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid sizes specified.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_remaining = rar->packed_size;\n\n  /* TODO: RARv3 subblocks contain comments. For now the complete block is\n   * consumed at the end.\n   */\n  if (head_type == NEWSUB_HEAD) {\n    size_t distance = p - (const char *)h;\n    header_size += rar->packed_size;\n    /* Make sure we have the extended data. */\n    if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n        return (ARCHIVE_FATAL);\n    p = h;\n    endp = p + header_size - 7;\n    p += distance;\n  }\n\n  filename_size = archive_le16dec(file_header.name_size);\n  if (p + filename_size > endp) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid filename size\");\n    return (ARCHIVE_FATAL);\n  }\n  if (rar->filename_allocated < filename_size * 2 + 2) {\n    char *newptr;\n    size_t newsize = filename_size * 2 + 2;\n    newptr = realloc(rar->filename, newsize);\n    if (newptr == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Couldn't allocate memory.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->filename = newptr;\n    rar->filename_allocated = newsize;\n  }\n  filename = rar->filename;\n  memcpy(filename, p, filename_size);\n  filename[filename_size] = '\\0';\n  if (rar->file_flags & FHD_UNICODE)\n  {\n    if (filename_size != strlen(filename))\n    {\n      unsigned char highbyte, flagbits, flagbyte;\n      unsigned fn_end, offset;\n\n      end = filename_size;\n      fn_end = filename_size * 2;\n      filename_size = 0;\n      offset = (unsigned)strlen(filename) + 1;\n      highbyte = *(p + offset++);\n      flagbits = 0;\n      flagbyte = 0;\n      while (offset < end && filename_size < fn_end)\n      {\n        if (!flagbits)\n        {\n          flagbyte = *(p + offset++);\n          flagbits = 8;\n        }\n\n        flagbits -= 2;\n        switch((flagbyte >> flagbits) & 3)\n        {\n          case 0:\n            filename[filename_size++] = '\\0';\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 1:\n            filename[filename_size++] = highbyte;\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 2:\n            filename[filename_size++] = *(p + offset + 1);\n            filename[filename_size++] = *(p + offset);\n            offset += 2;\n            break;\n          case 3:\n          {\n            char extra, high;\n            uint8_t length = *(p + offset++);\n\n            if (length & 0x80) {\n              extra = *(p + offset++);\n              high = (char)highbyte;\n            } else\n              extra = high = 0;\n            length = (length & 0x7f) + 2;\n            while (length && filename_size < fn_end) {\n              unsigned cp = filename_size >> 1;\n              filename[filename_size++] = high;\n              filename[filename_size++] = p[cp] + extra;\n              length--;\n            }\n          }\n          break;\n        }\n      }\n      if (filename_size > fn_end) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid filename\");\n        return (ARCHIVE_FATAL);\n      }\n      filename[filename_size++] = '\\0';\n      /*\n       * Do not increment filename_size here as the computations below\n       * add the space for the terminating NUL explicitly.\n       */\n      filename[filename_size] = '\\0';\n\n      /* Decoded unicode form is UTF-16BE, so we have to update a string\n       * conversion object for it. */\n      if (rar->sconv_utf16be == NULL) {\n        rar->sconv_utf16be = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-16BE\", 1);\n        if (rar->sconv_utf16be == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf16be;\n\n      strp = filename;\n      while (memcmp(strp, \"\\x00\\x00\", 2))\n      {\n        if (!memcmp(strp, \"\\x00\\\\\", 2))\n          *(strp + 1) = '/';\n        strp += 2;\n      }\n      p += offset;\n    } else {\n      /*\n       * If FHD_UNICODE is set but no unicode data, this file name form\n       * is UTF-8, so we have to update a string conversion object for\n       * it accordingly.\n       */\n      if (rar->sconv_utf8 == NULL) {\n        rar->sconv_utf8 = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-8\", 1);\n        if (rar->sconv_utf8 == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf8;\n      while ((strp = strchr(filename, '\\\\')) != NULL)\n        *strp = '/';\n      p += filename_size;\n    }\n  }\n  else\n  {\n    fn_sconv = sconv;\n    while ((strp = strchr(filename, '\\\\')) != NULL)\n      *strp = '/';\n    p += filename_size;\n  }\n\n  /* Split file in multivolume RAR. No more need to process header. */\n  if (rar->filename_save &&\n    filename_size == rar->filename_save_size &&\n    !memcmp(rar->filename, rar->filename_save, filename_size + 1))\n  {\n    __archive_read_consume(a, header_size - 7);\n    rar->cursor++;\n    if (rar->cursor >= rar->nodes)\n    {\n      rar->nodes++;\n      if ((rar->dbo =\n        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)\n      {\n        archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n        return (ARCHIVE_FATAL);\n      }\n      rar->dbo[rar->cursor].header_size = header_size;\n      rar->dbo[rar->cursor].start_offset = -1;\n      rar->dbo[rar->cursor].end_offset = -1;\n    }\n    if (rar->dbo[rar->cursor].start_offset < 0)\n    {\n      rar->dbo[rar->cursor].start_offset = a->filter->position;\n      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +\n        rar->packed_size;\n    }\n    return ret;\n  }\n  else if (rar->filename_must_match)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Mismatch of file parts split across multi-volume archive\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->filename_save = (char*)realloc(rar->filename_save,\n                                      filename_size + 1);\n  memcpy(rar->filename_save, rar->filename, filename_size + 1);\n  rar->filename_save_size = filename_size;\n\n  /* Set info for seeking */\n  free(rar->dbo);\n  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)\n  {\n    archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n    return (ARCHIVE_FATAL);\n  }\n  rar->dbo[0].header_size = header_size;\n  rar->dbo[0].start_offset = -1;\n  rar->dbo[0].end_offset = -1;\n  rar->cursor = 0;\n  rar->nodes = 1;\n\n  if (rar->file_flags & FHD_SALT)\n  {\n    if (p + 8 > endp) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n    memcpy(rar->salt, p, 8);\n    p += 8;\n  }\n\n  if (rar->file_flags & FHD_EXTTIME) {\n    if (read_exttime(p, rar, endp) < 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n  }\n\n  __archive_read_consume(a, header_size - 7);\n  rar->dbo[0].start_offset = a->filter->position;\n  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;\n\n  switch(file_header.host_os)\n  {\n  case OS_MSDOS:\n  case OS_OS2:\n  case OS_WIN32:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)\n      rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;\n    else\n      rar->mode = AE_IFREG;\n    rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;\n    break;\n\n  case OS_UNIX:\n  case OS_MAC_OS:\n  case OS_BEOS:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unknown file attributes from RAR file's host OS\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_uncopied = rar->bytes_unconsumed = 0;\n  rar->lzss.position = rar->offset = 0;\n  rar->offset_seek = 0;\n  rar->dictionary_size = 0;\n  rar->offset_outgoing = 0;\n  rar->br.cache_avail = 0;\n  rar->br.avail_in = 0;\n  rar->crc_calculated = 0;\n  rar->entry_eof = 0;\n  rar->valid = 1;\n  rar->is_ppmd_block = 0;\n  rar->start_new_table = 1;\n  free(rar->unp_buffer);\n  rar->unp_buffer = NULL;\n  rar->unp_offset = 0;\n  rar->unp_buffer_size = UNP_BUFFER_SIZE;\n  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n  __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n  rar->ppmd_valid = rar->ppmd_eod = 0;\n\n  /* Don't set any archive entries for non-file header types */\n  if (head_type == NEWSUB_HEAD)\n    return ret;\n\n  archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);\n  archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);\n  archive_entry_set_atime(entry, rar->atime, rar->ansec);\n  archive_entry_set_size(entry, rar->unp_size);\n  archive_entry_set_mode(entry, rar->mode);\n\n  if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))\n  {\n    if (errno == ENOMEM)\n    {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Can't allocate memory for Pathname\");\n      return (ARCHIVE_FATAL);\n    }\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Pathname cannot be converted from %s to current locale.\",\n                      archive_string_conversion_charset_name(fn_sconv));\n    ret = (ARCHIVE_WARN);\n  }\n\n  if (((rar->mode) & AE_IFMT) == AE_IFLNK)\n  {\n    /* Make sure a symbolic-link file does not have its body. */\n    rar->bytes_remaining = 0;\n    archive_entry_set_size(entry, 0);\n\n    /* Read a symbolic-link name. */\n    if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))\n      return ret2;\n    if (ret > ret2)\n      ret = ret2;\n  }\n\n  if (rar->bytes_remaining == 0)\n    rar->entry_eof = 1;\n\n  return ret;\n}\n\nstatic time_t\nget_time(int ttime)\n{\n  struct tm tm;\n  tm.tm_sec = 2 * (ttime & 0x1f);\n  tm.tm_min = (ttime >> 5) & 0x3f;\n  tm.tm_hour = (ttime >> 11) & 0x1f;\n  tm.tm_mday = (ttime >> 16) & 0x1f;\n  tm.tm_mon = ((ttime >> 21) & 0x0f) - 1;\n  tm.tm_year = ((ttime >> 25) & 0x7f) + 80;\n  tm.tm_isdst = -1;\n  return mktime(&tm);\n}\n\nstatic int\nread_exttime(const char *p, struct rar *rar, const char *endp)\n{\n  unsigned rmode, flags, rem, j, count;\n  int ttime, i;\n  struct tm *tm;\n  time_t t;\n  long nsec;\n\n  if (p + 2 > endp)\n    return (-1);\n  flags = archive_le16dec(p);\n  p += 2;\n\n  for (i = 3; i >= 0; i--)\n  {\n    t = 0;\n    if (i == 3)\n      t = rar->mtime;\n    rmode = flags >> i * 4;\n    if (rmode & 8)\n    {\n      if (!t)\n      {\n        if (p + 4 > endp)\n          return (-1);\n        ttime = archive_le32dec(p);\n        t = get_time(ttime);\n        p += 4;\n      }\n      rem = 0;\n      count = rmode & 3;\n      if (p + count > endp)\n        return (-1);\n      for (j = 0; j < count; j++)\n      {\n        rem = (((unsigned)(unsigned char)*p) << 16) | (rem >> 8);\n        p++;\n      }\n      tm = localtime(&t);\n      nsec = tm->tm_sec + rem / NS_UNIT;\n      if (rmode & 4)\n      {\n        tm->tm_sec++;\n        t = mktime(tm);\n      }\n      if (i == 3)\n      {\n        rar->mtime = t;\n        rar->mnsec = nsec;\n      }\n      else if (i == 2)\n      {\n        rar->ctime = t;\n        rar->cnsec = nsec;\n      }\n      else if (i == 1)\n      {\n        rar->atime = t;\n        rar->ansec = nsec;\n      }\n      else\n      {\n        rar->arctime = t;\n        rar->arcnsec = nsec;\n      }\n    }\n  }\n  return (0);\n}\n\nstatic int\nread_symlink_stored(struct archive_read *a, struct archive_entry *entry,\n                    struct archive_string_conv *sconv)\n{\n  const void *h;\n  const char *p;\n  struct rar *rar;\n  int ret = (ARCHIVE_OK);\n\n  rar = (struct rar *)(a->format->data);\n  if ((h = rar_read_ahead(a, (size_t)rar->packed_size, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n  p = h;\n\n  if (archive_entry_copy_symlink_l(entry,\n      p, (size_t)rar->packed_size, sconv))\n  {\n    if (errno == ENOMEM)\n    {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Can't allocate memory for link\");\n      return (ARCHIVE_FATAL);\n    }\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"link cannot be converted from %s to current locale.\",\n                      archive_string_conversion_charset_name(sconv));\n    ret = (ARCHIVE_WARN);\n  }\n  __archive_read_consume(a, rar->packed_size);\n  return ret;\n}\n\nstatic int\nread_data_stored(struct archive_read *a, const void **buff, size_t *size,\n                 int64_t *offset)\n{\n  struct rar *rar;\n  ssize_t bytes_avail;\n\n  rar = (struct rar *)(a->format->data);\n  if (rar->bytes_remaining == 0 &&\n    !(rar->main_flags & MHD_VOLUME && rar->file_flags & FHD_SPLIT_AFTER))\n  {\n    *buff = NULL;\n    *size = 0;\n    *offset = rar->offset;\n    if (rar->file_crc != rar->crc_calculated) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"File CRC error\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->entry_eof = 1;\n    return (ARCHIVE_EOF);\n  }\n\n  *buff = rar_read_ahead(a, 1, &bytes_avail);\n  if (bytes_avail <= 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    return (ARCHIVE_FATAL);\n  }\n\n  *size = bytes_avail;\n  *offset = rar->offset;\n  rar->offset += bytes_avail;\n  rar->offset_seek += bytes_avail;\n  rar->bytes_remaining -= bytes_avail;\n  rar->bytes_unconsumed = bytes_avail;\n  /* Calculate File CRC. */\n  rar->crc_calculated = crc32(rar->crc_calculated, *buff,\n    (unsigned)bytes_avail);\n  return (ARCHIVE_OK);\n}\n\nstatic int\nread_data_compressed(struct archive_read *a, const void **buff, size_t *size,\n               int64_t *offset)\n{\n  struct rar *rar;\n  int64_t start, end, actualend;\n  size_t bs;\n  int ret = (ARCHIVE_OK), sym, code, lzss_offset, length, i;\n\n  rar = (struct rar *)(a->format->data);\n\n  do {\n    if (!rar->valid)\n      return (ARCHIVE_FATAL);\n    if (rar->ppmd_eod ||\n       (rar->dictionary_size && rar->offset >= rar->unp_size))\n    {\n      if (rar->unp_offset > 0) {\n        /*\n         * We have unprocessed extracted data. write it out.\n         */\n        *buff = rar->unp_buffer;\n        *size = rar->unp_offset;\n        *offset = rar->offset_outgoing;\n        rar->offset_outgoing += *size;\n        /* Calculate File CRC. */\n        rar->crc_calculated = crc32(rar->crc_calculated, *buff,\n          (unsigned)*size);\n        rar->unp_offset = 0;\n        return (ARCHIVE_OK);\n      }\n      *buff = NULL;\n      *size = 0;\n      *offset = rar->offset;\n      if (rar->file_crc != rar->crc_calculated) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"File CRC error\");\n        return (ARCHIVE_FATAL);\n      }\n      rar->entry_eof = 1;\n      return (ARCHIVE_EOF);\n    }\n\n    if (!rar->is_ppmd_block && rar->dictionary_size && rar->bytes_uncopied > 0)\n    {\n      if (rar->bytes_uncopied > (rar->unp_buffer_size - rar->unp_offset))\n        bs = rar->unp_buffer_size - rar->unp_offset;\n      else\n        bs = (size_t)rar->bytes_uncopied;\n      ret = copy_from_lzss_window(a, buff, rar->offset, (int)bs);\n      if (ret != ARCHIVE_OK)\n        return (ret);\n      rar->offset += bs;\n      rar->bytes_uncopied -= bs;\n      if (*buff != NULL) {\n        rar->unp_offset = 0;\n        *size = rar->unp_buffer_size;\n        *offset = rar->offset_outgoing;\n        rar->offset_outgoing += *size;\n        /* Calculate File CRC. */\n        rar->crc_calculated = crc32(rar->crc_calculated, *buff,\n          (unsigned)*size);\n        return (ret);\n      }\n      continue;\n    }\n\n    if (!rar->br.next_in &&\n      (ret = rar_br_preparation(a, &(rar->br))) < ARCHIVE_WARN)\n      return (ret);\n    if (rar->start_new_table && ((ret = parse_codes(a)) < (ARCHIVE_WARN)))\n      return (ret);\n\n    if (rar->is_ppmd_block)\n    {\n      if ((sym = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n        &rar->ppmd7_context, &rar->range_dec.p)) < 0)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid symbol\");\n        return (ARCHIVE_FATAL);\n      }\n      if(sym != rar->ppmd_escape)\n      {\n        lzss_emit_literal(rar, sym);\n        rar->bytes_uncopied++;\n      }\n      else\n      {\n        if ((code = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n          &rar->ppmd7_context, &rar->range_dec.p)) < 0)\n        {\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Invalid symbol\");\n          return (ARCHIVE_FATAL);\n        }\n\n        switch(code)\n        {\n          case 0:\n            rar->start_new_table = 1;\n            return read_data_compressed(a, buff, size, offset);\n\n          case 2:\n            rar->ppmd_eod = 1;/* End Of ppmd Data. */\n            continue;\n\n          case 3:\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n                              \"Parsing filters is unsupported.\");\n            return (ARCHIVE_FAILED);\n\n          case 4:\n            lzss_offset = 0;\n            for (i = 2; i >= 0; i--)\n            {\n              if ((code = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n                &rar->ppmd7_context, &rar->range_dec.p)) < 0)\n              {\n                archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                                  \"Invalid symbol\");\n                return (ARCHIVE_FATAL);\n              }\n              lzss_offset |= code << (i * 8);\n            }\n            if ((length = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n              &rar->ppmd7_context, &rar->range_dec.p)) < 0)\n            {\n              archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                                \"Invalid symbol\");\n              return (ARCHIVE_FATAL);\n            }\n            lzss_emit_match(rar, lzss_offset + 2, length + 32);\n            rar->bytes_uncopied += length + 32;\n            break;\n\n          case 5:\n            if ((length = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n              &rar->ppmd7_context, &rar->range_dec.p)) < 0)\n            {\n              archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                                \"Invalid symbol\");\n              return (ARCHIVE_FATAL);\n            }\n            lzss_emit_match(rar, 1, length + 4);\n            rar->bytes_uncopied += length + 4;\n            break;\n\n         default:\n           lzss_emit_literal(rar, sym);\n           rar->bytes_uncopied++;\n        }\n      }\n    }\n    else\n    {\n      start = rar->offset;\n      end = start + rar->dictionary_size;\n      rar->filterstart = INT64_MAX;\n\n      if ((actualend = expand(a, end)) < 0)\n        return ((int)actualend);\n\n      rar->bytes_uncopied = actualend - start;\n      if (rar->bytes_uncopied == 0) {\n          /* Broken RAR files cause this case.\n          * NOTE: If this case were possible on a normal RAR file\n          * we would find out where it was actually bad and\n          * what we would do to solve it. */\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Internal error extracting RAR file\");\n          return (ARCHIVE_FATAL);\n      }\n    }\n    if (rar->bytes_uncopied > (rar->unp_buffer_size - rar->unp_offset))\n      bs = rar->unp_buffer_size - rar->unp_offset;\n    else\n      bs = (size_t)rar->bytes_uncopied;\n    ret = copy_from_lzss_window(a, buff, rar->offset, (int)bs);\n    if (ret != ARCHIVE_OK)\n      return (ret);\n    rar->offset += bs;\n    rar->bytes_uncopied -= bs;\n    /*\n     * If *buff is NULL, it means unp_buffer is not full.\n     * So we have to continue extracting a RAR file.\n     */\n  } while (*buff == NULL);\n\n  rar->unp_offset = 0;\n  *size = rar->unp_buffer_size;\n  *offset = rar->offset_outgoing;\n  rar->offset_outgoing += *size;\n  /* Calculate File CRC. */\n  rar->crc_calculated = crc32(rar->crc_calculated, *buff, (unsigned)*size);\n  return ret;\n}\n\nstatic int\nparse_codes(struct archive_read *a)\n{\n  int i, j, val, n, r;\n  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;\n  unsigned int maxorder;\n  struct huffman_code precode;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  free_codes(a);\n\n  /* Skip to the next byte */\n  rar_br_consume_unalined_bits(br);\n\n  /* PPMd block flag */\n  if (!rar_br_read_ahead(a, br, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)\n  {\n    rar_br_consume(br, 1);\n    if (!rar_br_read_ahead(a, br, 7))\n      goto truncated_data;\n    ppmd_flags = rar_br_bits(br, 7);\n    rar_br_consume(br, 7);\n\n    /* Memory is allocated in MB */\n    if (ppmd_flags & 0x20)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;\n      rar_br_consume(br, 8);\n    }\n\n    if (ppmd_flags & 0x40)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);\n      rar_br_consume(br, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (ppmd_flags & 0x20)\n    {\n      maxorder = (ppmd_flags & 0x1F) + 1;\n      if(maxorder > 16)\n        maxorder = 16 + (maxorder - 16) * 3;\n\n      if (maxorder == 1)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Truncated RAR file data\");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Make sure ppmd7_contest is freed before Ppmd7_Construct\n       * because reading a broken file cause this abnormal sequence. */\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n\n      rar->bytein.a = a;\n      rar->bytein.Read = &ppmd_read;\n      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid zero dictionary size\");\n\t      return (ARCHIVE_FATAL);\n      }\n\n      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size))\n      {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Out of memory\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid PPMd sequence\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(br, 1);\n\n    /* Keep existing table flag */\n    if (!rar_br_read_ahead(a, br, 1))\n      goto truncated_data;\n    if (!rar_br_bits(br, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(br, 1);\n\n    memset(&bitlengths, 0, sizeof(bitlengths));\n    for (i = 0; i < MAX_SYMBOLS;)\n    {\n      if (!rar_br_read_ahead(a, br, 4))\n        goto truncated_data;\n      bitlengths[i++] = rar_br_bits(br, 4);\n      rar_br_consume(br, 4);\n      if (bitlengths[i-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(a, br, 4))\n          goto truncated_data;\n        zerocount = rar_br_bits(br, 4);\n        rar_br_consume(br, 4);\n        if (zerocount)\n        {\n          i--;\n          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)\n            bitlengths[i++] = 0;\n        }\n      }\n    }\n\n    memset(&precode, 0, sizeof(precode));\n    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK) {\n      free(precode.tree);\n      free(precode.table);\n      return (r);\n    }\n\n    for (i = 0; i < HUFFMAN_TABLE_SIZE;)\n    {\n      if ((val = read_next_symbol(a, &precode)) < 0) {\n        free(precode.tree);\n        free(precode.table);\n        return (ARCHIVE_FATAL);\n      }\n      if (val < 16)\n      {\n        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;\n        i++;\n      }\n      else if (val < 18)\n      {\n        if (i == 0)\n        {\n          free(precode.tree);\n          free(precode.table);\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Internal error extracting RAR file.\");\n          return (ARCHIVE_FATAL);\n        }\n\n        if(val == 16) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n        {\n          rar->lengthtable[i] = rar->lengthtable[i-1];\n          i++;\n        }\n      }\n      else\n      {\n        if(val == 18) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n          rar->lengthtable[i++] = 0;\n      }\n    }\n    free(precode.tree);\n    free(precode.table);\n\n    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,\n                MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],\n                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lowoffsetcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],\n                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lengthcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +\n                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* Seems as though dictionary sizes are not used. Even so, minimize\n     * memory usage as much as possible.\n     */\n    void *new_window;\n    unsigned int new_size;\n\n    if (rar->unp_size >= DICTIONARY_MAX_SIZE)\n      new_size = DICTIONARY_MAX_SIZE;\n    else\n      new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n    if (new_size == 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Zero window size is invalid.\");\n      return (ARCHIVE_FATAL);\n    }\n    new_window = realloc(rar->lzss.window, new_size);\n    if (new_window == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->lzss.window = (unsigned char *)new_window;\n    rar->dictionary_size = new_size;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (ARCHIVE_OK);\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\n}\n\nstatic void\nfree_codes(struct archive_read *a)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  free(rar->maincode.tree);\n  free(rar->offsetcode.tree);\n  free(rar->lowoffsetcode.tree);\n  free(rar->lengthcode.tree);\n  free(rar->maincode.table);\n  free(rar->offsetcode.table);\n  free(rar->lowoffsetcode.table);\n  free(rar->lengthcode.table);\n  memset(&rar->maincode, 0, sizeof(rar->maincode));\n  memset(&rar->offsetcode, 0, sizeof(rar->offsetcode));\n  memset(&rar->lowoffsetcode, 0, sizeof(rar->lowoffsetcode));\n  memset(&rar->lengthcode, 0, sizeof(rar->lengthcode));\n}\n\n\nstatic int\nread_next_symbol(struct archive_read *a, struct huffman_code *code)\n{\n  unsigned char bit;\n  unsigned int bits;\n  int length, value, node;\n  struct rar *rar;\n  struct rar_br *br;\n\n  if (!code->table)\n  {\n    if (make_table(a, code) != (ARCHIVE_OK))\n      return -1;\n  }\n\n  rar = (struct rar *)(a->format->data);\n  br = &(rar->br);\n\n  /* Look ahead (peek) at bits */\n  if (!rar_br_read_ahead(a, br, code->tablesize)) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    rar->valid = 0;\n    return -1;\n  }\n  bits = rar_br_bits(br, code->tablesize);\n\n  length = code->table[bits].length;\n  value = code->table[bits].value;\n\n  if (length < 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid prefix code in bitstream\");\n    return -1;\n  }\n\n  if (length <= code->tablesize)\n  {\n    /* Skip length bits */\n    rar_br_consume(br, length);\n    return value;\n  }\n\n  /* Skip tablesize bits */\n  rar_br_consume(br, code->tablesize);\n\n  node = value;\n  while (!(code->tree[node].branches[0] ==\n    code->tree[node].branches[1]))\n  {\n    if (!rar_br_read_ahead(a, br, 1)) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Truncated RAR file data\");\n      rar->valid = 0;\n      return -1;\n    }\n    bit = rar_br_bits(br, 1);\n    rar_br_consume(br, 1);\n\n    if (code->tree[node].branches[bit] < 0)\n    {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Invalid prefix code in bitstream\");\n      return -1;\n    }\n    node = code->tree[node].branches[bit];\n  }\n\n  return code->tree[node].branches[0];\n}\n\nstatic int\ncreate_code(struct archive_read *a, struct huffman_code *code,\n            unsigned char *lengths, int numsymbols, char maxlength)\n{\n  int i, j, codebits = 0, symbolsleft = numsymbols;\n\n  code->numentries = 0;\n  code->numallocatedentries = 0;\n  if (new_node(code) < 0) {\n    archive_set_error(&a->archive, ENOMEM,\n                      \"Unable to allocate memory for node data.\");\n    return (ARCHIVE_FATAL);\n  }\n  code->numentries = 1;\n  code->minlength = INT_MAX;\n  code->maxlength = INT_MIN;\n  codebits = 0;\n  for(i = 1; i <= maxlength; i++)\n  {\n    for(j = 0; j < numsymbols; j++)\n    {\n      if (lengths[j] != i) continue;\n      if (add_value(a, code, j, codebits, i) != ARCHIVE_OK)\n        return (ARCHIVE_FATAL);\n      codebits++;\n      if (--symbolsleft <= 0) { break; break; }\n    }\n    codebits <<= 1;\n  }\n  return (ARCHIVE_OK);\n}\n\nstatic int\nadd_value(struct archive_read *a, struct huffman_code *code, int value,\n          int codebits, int length)\n{\n  int repeatpos, lastnode, bitpos, bit, repeatnode, nextnode;\n\n  free(code->table);\n  code->table = NULL;\n\n  if(length > code->maxlength)\n    code->maxlength = length;\n  if(length < code->minlength)\n    code->minlength = length;\n\n  repeatpos = -1;\n  if (repeatpos == 0 || (repeatpos >= 0\n    && (((codebits >> (repeatpos - 1)) & 3) == 0\n    || ((codebits >> (repeatpos - 1)) & 3) == 3)))\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid repeat position\");\n    return (ARCHIVE_FATAL);\n  }\n\n  lastnode = 0;\n  for (bitpos = length - 1; bitpos >= 0; bitpos--)\n  {\n    bit = (codebits >> bitpos) & 1;\n\n    /* Leaf node check */\n    if (code->tree[lastnode].branches[0] ==\n      code->tree[lastnode].branches[1])\n    {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Prefix found\");\n      return (ARCHIVE_FATAL);\n    }\n\n    if (bitpos == repeatpos)\n    {\n      /* Open branch check */\n      if (!(code->tree[lastnode].branches[bit] < 0))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid repeating code\");\n        return (ARCHIVE_FATAL);\n      }\n\n      if ((repeatnode = new_node(code)) < 0) {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Unable to allocate memory for node data.\");\n        return (ARCHIVE_FATAL);\n      }\n      if ((nextnode = new_node(code)) < 0) {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Unable to allocate memory for node data.\");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Set branches */\n      code->tree[lastnode].branches[bit] = repeatnode;\n      code->tree[repeatnode].branches[bit] = repeatnode;\n      code->tree[repeatnode].branches[bit^1] = nextnode;\n      lastnode = nextnode;\n\n      bitpos++; /* terminating bit already handled, skip it */\n    }\n    else\n    {\n      /* Open branch check */\n      if (code->tree[lastnode].branches[bit] < 0)\n      {\n        if (new_node(code) < 0) {\n          archive_set_error(&a->archive, ENOMEM,\n                            \"Unable to allocate memory for node data.\");\n          return (ARCHIVE_FATAL);\n        }\n        code->tree[lastnode].branches[bit] = code->numentries++;\n      }\n\n      /* set to branch */\n      lastnode = code->tree[lastnode].branches[bit];\n    }\n  }\n\n  if (!(code->tree[lastnode].branches[0] == -1\n    && code->tree[lastnode].branches[1] == -2))\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Prefix found\");\n    return (ARCHIVE_FATAL);\n  }\n\n  /* Set leaf value */\n  code->tree[lastnode].branches[0] = value;\n  code->tree[lastnode].branches[1] = value;\n\n  return (ARCHIVE_OK);\n}\n\nstatic int\nnew_node(struct huffman_code *code)\n{\n  void *new_tree;\n  if (code->numallocatedentries == code->numentries) {\n    int new_num_entries = 256;\n    if (code->numentries > 0) {\n        new_num_entries = code->numentries * 2;\n    }\n    new_tree = realloc(code->tree, new_num_entries * sizeof(*code->tree));\n    if (new_tree == NULL)\n        return (-1);\n    code->tree = (struct huffman_tree_node *)new_tree;\n    code->numallocatedentries = new_num_entries;\n  }\n  code->tree[code->numentries].branches[0] = -1;\n  code->tree[code->numentries].branches[1] = -2;\n  return 1;\n}\n\nstatic int\nmake_table(struct archive_read *a, struct huffman_code *code)\n{\n  if (code->maxlength < code->minlength || code->maxlength > 10)\n    code->tablesize = 10;\n  else\n    code->tablesize = code->maxlength;\n\n  code->table =\n    (struct huffman_table_entry *)calloc(1, sizeof(*code->table)\n    * ((size_t)1 << code->tablesize));\n\n  return make_table_recurse(a, code, 0, code->table, 0, code->tablesize);\n}\n\nstatic int\nmake_table_recurse(struct archive_read *a, struct huffman_code *code, int node,\n                   struct huffman_table_entry *table, int depth,\n                   int maxdepth)\n{\n  int currtablesize, i, ret = (ARCHIVE_OK);\n\n  if (!code->tree)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Huffman tree was not created.\");\n    return (ARCHIVE_FATAL);\n  }\n  if (node < 0 || node >= code->numentries)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid location to Huffman tree specified.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  currtablesize = 1 << (maxdepth - depth);\n\n  if (code->tree[node].branches[0] ==\n    code->tree[node].branches[1])\n  {\n    for(i = 0; i < currtablesize; i++)\n    {\n      table[i].length = depth;\n      table[i].value = code->tree[node].branches[0];\n    }\n  }\n  else if (node < 0)\n  {\n    for(i = 0; i < currtablesize; i++)\n      table[i].length = -1;\n  }\n  else\n  {\n    if(depth == maxdepth)\n    {\n      table[0].length = maxdepth + 1;\n      table[0].value = node;\n    }\n    else\n    {\n      ret |= make_table_recurse(a, code, code->tree[node].branches[0], table,\n                                depth + 1, maxdepth);\n      ret |= make_table_recurse(a, code, code->tree[node].branches[1],\n                         table + currtablesize / 2, depth + 1, maxdepth);\n    }\n  }\n  return ret;\n}\n\nstatic int64_t\nexpand(struct archive_read *a, int64_t end)\n{\n  static const unsigned char lengthbases[] =\n    {   0,   1,   2,   3,   4,   5,   6,\n        7,   8,  10,  12,  14,  16,  20,\n       24,  28,  32,  40,  48,  56,  64,\n       80,  96, 112, 128, 160, 192, 224 };\n  static const unsigned char lengthbits[] =\n    { 0, 0, 0, 0, 0, 0, 0,\n      0, 1, 1, 1, 1, 2, 2,\n      2, 2, 3, 3, 3, 3, 4,\n      4, 4, 4, 5, 5, 5, 5 };\n  static const unsigned int offsetbases[] =\n    {       0,       1,       2,       3,       4,       6,\n            8,      12,      16,      24,      32,      48,\n           64,      96,     128,     192,     256,     384,\n          512,     768,    1024,    1536,    2048,    3072,\n         4096,    6144,    8192,   12288,   16384,   24576,\n        32768,   49152,   65536,   98304,  131072,  196608,\n       262144,  327680,  393216,  458752,  524288,  589824,\n       655360,  720896,  786432,  851968,  917504,  983040,\n      1048576, 1310720, 1572864, 1835008, 2097152, 2359296,\n      2621440, 2883584, 3145728, 3407872, 3670016, 3932160 };\n  static const unsigned char offsetbits[] =\n    {  0,  0,  0,  0,  1,  1,  2,  2,  3,  3,  4,  4,\n       5,  5,  6,  6,  7,  7,  8,  8,  9,  9, 10, 10,\n      11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16,\n      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18 };\n  static const unsigned char shortbases[] =\n    { 0, 4, 8, 16, 32, 64, 128, 192 };\n  static const unsigned char shortbits[] =\n    { 2, 2, 3, 4, 5, 6, 6, 6 };\n\n  int symbol, offs, len, offsindex, lensymbol, i, offssymbol, lowoffsetsymbol;\n  unsigned char newfile;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  if (rar->filterstart < end)\n    end = rar->filterstart;\n\n  while (1)\n  {\n    if (rar->output_last_match &&\n      lzss_position(&rar->lzss) + rar->lastlength <= end)\n    {\n      lzss_emit_match(rar, rar->lastoffset, rar->lastlength);\n      rar->output_last_match = 0;\n    }\n\n    if(rar->is_ppmd_block || rar->output_last_match ||\n      lzss_position(&rar->lzss) >= end)\n      return lzss_position(&rar->lzss);\n\n    if ((symbol = read_next_symbol(a, &rar->maincode)) < 0)\n      return (ARCHIVE_FATAL);\n    rar->output_last_match = 0;\n\n    if (symbol < 256)\n    {\n      lzss_emit_literal(rar, symbol);\n      continue;\n    }\n    else if (symbol == 256)\n    {\n      if (!rar_br_read_ahead(a, br, 1))\n        goto truncated_data;\n      newfile = !rar_br_bits(br, 1);\n      rar_br_consume(br, 1);\n\n      if(newfile)\n      {\n        rar->start_new_block = 1;\n        if (!rar_br_read_ahead(a, br, 1))\n          goto truncated_data;\n        rar->start_new_table = rar_br_bits(br, 1);\n        rar_br_consume(br, 1);\n        return lzss_position(&rar->lzss);\n      }\n      else\n      {\n        if (parse_codes(a) != ARCHIVE_OK)\n          return (ARCHIVE_FATAL);\n        continue;\n      }\n    }\n    else if(symbol==257)\n    {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n                        \"Parsing filters is unsupported.\");\n      return (ARCHIVE_FAILED);\n    }\n    else if(symbol==258)\n    {\n      if(rar->lastlength == 0)\n        continue;\n\n      offs = rar->lastoffset;\n      len = rar->lastlength;\n    }\n    else if (symbol <= 262)\n    {\n      offsindex = symbol - 259;\n      offs = rar->oldoffset[offsindex];\n\n      if ((lensymbol = read_next_symbol(a, &rar->lengthcode)) < 0)\n        goto bad_data;\n      if (lensymbol > (int)(sizeof(lengthbases)/sizeof(lengthbases[0])))\n        goto bad_data;\n      if (lensymbol > (int)(sizeof(lengthbits)/sizeof(lengthbits[0])))\n        goto bad_data;\n      len = lengthbases[lensymbol] + 2;\n      if (lengthbits[lensymbol] > 0) {\n        if (!rar_br_read_ahead(a, br, lengthbits[lensymbol]))\n          goto truncated_data;\n        len += rar_br_bits(br, lengthbits[lensymbol]);\n        rar_br_consume(br, lengthbits[lensymbol]);\n      }\n\n      for (i = offsindex; i > 0; i--)\n        rar->oldoffset[i] = rar->oldoffset[i-1];\n      rar->oldoffset[0] = offs;\n    }\n    else if(symbol<=270)\n    {\n      offs = shortbases[symbol-263] + 1;\n      if(shortbits[symbol-263] > 0) {\n        if (!rar_br_read_ahead(a, br, shortbits[symbol-263]))\n          goto truncated_data;\n        offs += rar_br_bits(br, shortbits[symbol-263]);\n        rar_br_consume(br, shortbits[symbol-263]);\n      }\n\n      len = 2;\n\n      for(i = 3; i > 0; i--)\n        rar->oldoffset[i] = rar->oldoffset[i-1];\n      rar->oldoffset[0] = offs;\n    }\n    else\n    {\n      if (symbol-271 > (int)(sizeof(lengthbases)/sizeof(lengthbases[0])))\n        goto bad_data;\n      if (symbol-271 > (int)(sizeof(lengthbits)/sizeof(lengthbits[0])))\n        goto bad_data;\n      len = lengthbases[symbol-271]+3;\n      if(lengthbits[symbol-271] > 0) {\n        if (!rar_br_read_ahead(a, br, lengthbits[symbol-271]))\n          goto truncated_data;\n        len += rar_br_bits(br, lengthbits[symbol-271]);\n        rar_br_consume(br, lengthbits[symbol-271]);\n      }\n\n      if ((offssymbol = read_next_symbol(a, &rar->offsetcode)) < 0)\n        goto bad_data;\n      if (offssymbol > (int)(sizeof(offsetbases)/sizeof(offsetbases[0])))\n        goto bad_data;\n      if (offssymbol > (int)(sizeof(offsetbits)/sizeof(offsetbits[0])))\n        goto bad_data;\n      offs = offsetbases[offssymbol]+1;\n      if(offsetbits[offssymbol] > 0)\n      {\n        if(offssymbol > 9)\n        {\n          if(offsetbits[offssymbol] > 4) {\n            if (!rar_br_read_ahead(a, br, offsetbits[offssymbol] - 4))\n              goto truncated_data;\n            offs += rar_br_bits(br, offsetbits[offssymbol] - 4) << 4;\n            rar_br_consume(br, offsetbits[offssymbol] - 4);\n\t  }\n\n          if(rar->numlowoffsetrepeats > 0)\n          {\n            rar->numlowoffsetrepeats--;\n            offs += rar->lastlowoffset;\n          }\n          else\n          {\n            if ((lowoffsetsymbol =\n              read_next_symbol(a, &rar->lowoffsetcode)) < 0)\n              return (ARCHIVE_FATAL);\n            if(lowoffsetsymbol == 16)\n            {\n              rar->numlowoffsetrepeats = 15;\n              offs += rar->lastlowoffset;\n            }\n            else\n            {\n              offs += lowoffsetsymbol;\n              rar->lastlowoffset = lowoffsetsymbol;\n            }\n          }\n        }\n        else {\n          if (!rar_br_read_ahead(a, br, offsetbits[offssymbol]))\n            goto truncated_data;\n          offs += rar_br_bits(br, offsetbits[offssymbol]);\n          rar_br_consume(br, offsetbits[offssymbol]);\n        }\n      }\n\n      if (offs >= 0x40000)\n        len++;\n      if (offs >= 0x2000)\n        len++;\n\n      for(i = 3; i > 0; i--)\n        rar->oldoffset[i] = rar->oldoffset[i-1];\n      rar->oldoffset[0] = offs;\n    }\n\n    rar->lastoffset = offs;\n    rar->lastlength = len;\n    rar->output_last_match = 1;\n  }\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\nbad_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Bad RAR file data\");\n  return (ARCHIVE_FATAL);\n}\n\nstatic int\ncopy_from_lzss_window(struct archive_read *a, const void **buffer,\n                        int64_t startpos, int length)\n{\n  int windowoffs, firstpart;\n  struct rar *rar = (struct rar *)(a->format->data);\n\n  if (!rar->unp_buffer)\n  {\n    if ((rar->unp_buffer = malloc(rar->unp_buffer_size)) == NULL)\n    {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (ARCHIVE_FATAL);\n    }\n  }\n\n  windowoffs = lzss_offset_for_position(&rar->lzss, startpos);\n  if(windowoffs + length <= lzss_size(&rar->lzss)) {\n    memcpy(&rar->unp_buffer[rar->unp_offset], &rar->lzss.window[windowoffs],\n           length);\n  } else if (length <= lzss_size(&rar->lzss)) {\n    firstpart = lzss_size(&rar->lzss) - windowoffs;\n    if (firstpart < 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Bad RAR file data\");\n      return (ARCHIVE_FATAL);\n    }\n    if (firstpart < length) {\n      memcpy(&rar->unp_buffer[rar->unp_offset],\n             &rar->lzss.window[windowoffs], firstpart);\n      memcpy(&rar->unp_buffer[rar->unp_offset + firstpart],\n             &rar->lzss.window[0], length - firstpart);\n    } else {\n      memcpy(&rar->unp_buffer[rar->unp_offset],\n             &rar->lzss.window[windowoffs], length);\n    }\n  } else {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Bad RAR file data\");\n      return (ARCHIVE_FATAL);\n  }\n  rar->unp_offset += length;\n  if (rar->unp_offset >= rar->unp_buffer_size)\n    *buffer = rar->unp_buffer;\n  else\n    *buffer = NULL;\n  return (ARCHIVE_OK);\n}\n\nstatic const void *\nrar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  const void *h = __archive_read_ahead(a, min, avail);\n  int ret;\n  if (avail)\n  {\n    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)\n      *avail = a->archive.read_data_requested;\n    if (*avail > rar->bytes_remaining)\n      *avail = (ssize_t)rar->bytes_remaining;\n    if (*avail < 0)\n      return NULL;\n    else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n      rar->file_flags & FHD_SPLIT_AFTER)\n    {\n      rar->filename_must_match = 1;\n      ret = archive_read_format_rar_read_header(a, a->entry);\n      if (ret == (ARCHIVE_EOF))\n      {\n        rar->has_endarc_header = 1;\n        ret = archive_read_format_rar_read_header(a, a->entry);\n      }\n      rar->filename_must_match = 0;\n      if (ret != (ARCHIVE_OK))\n        return NULL;\n      return rar_read_ahead(a, min, avail);\n    }\n  }\n  return h;\n}\n"], "filenames": ["libarchive/archive_read_support_format_rar.c"], "buggy_code_start_loc": [1027], "buggy_code_end_loc": [1028], "fixing_code_start_loc": [1027], "fixing_code_end_loc": [1031], "type": "CWE-416", "message": "archive_read_format_rar_read_data in archive_read_support_format_rar.c in libarchive before 3.4.0 has a use-after-free in a certain ARCHIVE_FAILED situation, related to Ppmd7_DecodeSymbol.", "other": {"cve": {"id": "CVE-2019-18408", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-24T14:15:11.457", "lastModified": "2019-11-01T11:15:10.823", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "archive_read_format_rar_read_data in archive_read_support_format_rar.c in libarchive before 3.4.0 has a use-after-free in a certain ARCHIVE_FAILED situation, related to Ppmd7_DecodeSymbol."}, {"lang": "es", "value": "La funci\u00f3n archive_read_format_rar_read_data en el archivo archive_read_support_format_rar.c en libarchive versiones anteriores a 3.4.0, presenta un uso de la memoria previamente liberada en una determinada situaci\u00f3n de ARCHIVE_FAILED, relacionada con Ppmd7_DecodeSymbol."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libarchive:libarchive:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.0", "matchCriteriaId": "CD8C4D61-FC17-4094-8516-F9DB094DEB8B"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00012.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00015.html", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0203", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0246", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0271", "source": "cve@mitre.org"}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=14689", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/libarchive/libarchive/commit/b8592ecba2f9e451e1f5cb7ab6dcee8b8e7b3f60", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libarchive/libarchive/compare/v3.3.3...v3.4.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00034.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6LZ4VJGTCYEJSDLOEWUUFG6TM4SUPFSY/", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Nov/2", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202003-28", "source": "cve@mitre.org"}, {"url": "https://support.f5.com/csp/article/K52144175?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4169-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4557", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/libarchive/libarchive/commit/b8592ecba2f9e451e1f5cb7ab6dcee8b8e7b3f60"}}