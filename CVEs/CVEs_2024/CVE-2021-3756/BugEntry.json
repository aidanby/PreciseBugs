{"buggy_code": ["/*\n\n Copyright 2016 Christian Hoene, Symonics GmbH\n\n */\n\n/* IV.A.1.b. Version 2 Data Object Header Prefix\n\n 00000030  4f 48 44 52 02 2d d3 18  2b 53 d3 18 2b 53 d3 18  |OHDR.-..+S..+S..|\n 00000040  2b 53 d3 18 2b 53 f4 01  02 22 00 00 00 00        |+S..+S...\"......|\n ....\n 00000230  00 00 00 00 00 00 00 00  00 00 00 00 f9 ba 5d c9  |..............].|\n */\n\n#include \"reader.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic int readOCHK(struct READER *reader, struct DATAOBJECT *dataobject,\n                    uint64_t end);\n\nstatic struct DATAOBJECT *findDataobject(struct READER *reader,\n                                         uint64_t address) {\n  struct DATAOBJECT *p = reader->all;\n  while (p && p->address != address)\n    p = p->all;\n\n  return p;\n}\n\n/*\n * IV.A.2.a. The NIL Message\n\n 00000090                                 00 9c 01 00 00 00  |................|\n 000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n *\n 00000230  00 00 00 00 00 00 00 00  00 00 00 00 f9 ba 5d c9  |..............].|\n\n */\n\nstatic int readOHDRHeaderMessageNIL(struct READER *reader, int length) {\n\n  if (fseek(reader->fhd, length, SEEK_CUR) < 0)\n    return errno; // LCOV_EXCL_LINE\n\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.b. The Dataspace Message\n\n */\n\nstatic int readOHDRHeaderMessageDataspace1(struct READER *reader,\n                                           struct DATASPACE *ds) {\n\n  int i;\n\n  readValue(reader, 5);\n\n  for (i = 0; i < ds->dimensionality; i++) {\n    if (i < 4) {\n      ds->dimension_size[i] =\n          readValue(reader, reader->superblock.size_of_lengths);\n      if (ds->dimension_size[i] > 1000000) {\n        mylog(\"dimension_size is too large\\n\"); // LCOV_EXCL_LINE\n        return MYSOFA_INVALID_FORMAT;           // LCOV_EXCL_LINE\n      }\n      mylog(\"   dimension %d %\" PRIu64 \"\\n\", i, ds->dimension_size[i]);\n    } else\n      readValue(reader, reader->superblock.size_of_lengths);\n  }\n\n  if (ds->flags & 1) {\n    for (i = 0; i < ds->dimensionality; i++) {\n      if (i < 4)\n        ds->dimension_max_size[i] =\n            readValue(reader, reader->superblock.size_of_lengths);\n      else\n        readValue(reader, reader->superblock.size_of_lengths);\n    }\n  }\n\n  if (ds->flags & 2) {\n    mylog(\"permutation in OHDR not supported\\n\"); // LCOV_EXCL_LINE\n    return MYSOFA_INVALID_FORMAT;                 // LCOV_EXCL_LINE\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageDataspace2(struct READER *reader,\n                                           struct DATASPACE *ds) {\n\n  int i;\n\n  ds->type = (uint8_t)fgetc(reader->fhd);\n\n  for (i = 0; i < ds->dimensionality; i++) {\n    if (i < 4) {\n      ds->dimension_size[i] =\n          readValue(reader, reader->superblock.size_of_lengths);\n      mylog(\"   dimension %d %\" PRIu64 \"\\n\", i, ds->dimension_size[i]);\n    } else\n      readValue(reader, reader->superblock.size_of_lengths);\n  }\n\n  if (ds->flags & 1) {\n    for (i = 0; i < ds->dimensionality; i++) {\n      if (i < 4)\n        ds->dimension_max_size[i] =\n            readValue(reader, reader->superblock.size_of_lengths);\n      else\n        readValue(reader, reader->superblock.size_of_lengths);\n    }\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageDataspace(struct READER *reader,\n                                          struct DATASPACE *ds) {\n\n  int version = fgetc(reader->fhd);\n\n  ds->dimensionality = (uint8_t)fgetc(reader->fhd);\n  if (ds->dimensionality > 4) {\n    mylog(\"dimensionality must be lower than 5\\n\"); // LCOV_EXCL_LINE\n    return MYSOFA_INVALID_FORMAT;                   // LCOV_EXCL_LINE\n  }\n\n  ds->flags = (uint8_t)fgetc(reader->fhd);\n\n  switch (version) {\n  case 1:\n    return readOHDRHeaderMessageDataspace1(reader, ds);\n  case 2:\n    return readOHDRHeaderMessageDataspace2(reader, ds);\n  default:\n    // LCOV_EXCL_START\n    mylog(\"object OHDR dataspace message must have version 1 or 2 but is %X at \"\n          \"%lX\\n\",\n          version, ftell(reader->fhd) - 1);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n}\n\n/*\n * IV.A.2.c. The Link Info Message\n\n 00 03  |+S..+S...\"......|\n 00000050  0f 00 00 00 00 00 00 00  c9 11 00 00 00 00 00 00  |................|\n 00000060  5b 12 00 00 00 00 00 00  81 12 00 00 00 00 00 00  |[...............|\n */\n\nstatic int readOHDRHeaderMessageLinkInfo(struct READER *reader,\n                                         struct LINKINFO *li) {\n\n  if (fgetc(reader->fhd) != 0) {\n    mylog(\n        \"object OHDR link info message must have version 0\\n\"); // LCOV_EXCL_LINE\n    return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n  }\n\n  li->flags = (uint8_t)fgetc(reader->fhd);\n\n  if (li->flags & 1)\n    li->maximum_creation_index = readValue(reader, 8);\n\n  li->fractal_heap_address =\n      readValue(reader, reader->superblock.size_of_offsets);\n  li->address_btree_index =\n      readValue(reader, reader->superblock.size_of_offsets);\n\n  if (li->flags & 2)\n    li->address_btree_order =\n        readValue(reader, reader->superblock.size_of_offsets);\n\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.d. The Datatype Message\n\n 000007c0                       03  14 00 01 00 00|11|21 1f  |..............!.|\n 000007d0  00|04 00 00 00|00 00|20  00|17|08|00|17|7f 00 00  |....... ........|\n 000007e0  00|05 02 00 01 00 00 03  0a 10 10 00 00 07 00 6d  |...............m|\n 000007f0  36 00 00 00 00 00 00 ea  00 00 00 00 00 00 00 15  |6...............|\n\n */\n\nstatic int readOHDRHeaderMessageDatatype(struct READER *reader,\n                                         struct DATATYPE *dt) {\n\n  int i, j, c, err;\n  char *buffer;\n  struct DATATYPE dt2;\n\n  dt->class_and_version = (uint8_t)fgetc(reader->fhd);\n  if ((dt->class_and_version & 0xf0) != 0x10 &&\n      (dt->class_and_version & 0xf0) != 0x30) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR datatype message must have version 1 not %d at %lX\\n\",\n          dt->class_and_version >> 4, ftell(reader->fhd) - 1);\n    return MYSOFA_UNSUPPORTED_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  dt->class_bit_field = (uint32_t)readValue(reader, 3);\n  dt->size = (uint32_t)readValue(reader, 4);\n  if (dt->size > 64)\n    return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n\n  switch (dt->class_and_version & 0xf) {\n  case 0: /* int */\n    dt->u.i.bit_offset = readValue(reader, 2);\n    dt->u.i.bit_precision = readValue(reader, 2);\n    mylog(\"    INT bit %d %d %d %d\\n\", dt->u.i.bit_offset,\n          dt->u.i.bit_precision, dt->class_and_version >> 4, dt->size);\n    break;\n\n  case 1: /* float */\n    dt->u.f.bit_offset = (uint16_t)readValue(reader, 2);\n    dt->u.f.bit_precision = (uint16_t)readValue(reader, 2);\n    dt->u.f.exponent_location = (uint8_t)fgetc(reader->fhd);\n    dt->u.f.exponent_size = (uint8_t)fgetc(reader->fhd);\n    dt->u.f.mantissa_location = (uint8_t)fgetc(reader->fhd);\n    dt->u.f.mantissa_size = (uint8_t)fgetc(reader->fhd);\n    dt->u.f.exponent_bias = (uint32_t)readValue(reader, 4);\n\n    mylog(\"    FLOAT bit %d %d exponent %d %d MANTISSA %d %d OFFSET %d\\n\",\n          dt->u.f.bit_offset, dt->u.f.bit_precision, dt->u.f.exponent_location,\n          dt->u.f.exponent_size, dt->u.f.mantissa_location,\n          dt->u.f.mantissa_size, dt->u.f.exponent_bias);\n\n    /* FLOAT bit 0 32 exponent 23 8 MANTISSA 0 23 OFFSET 127\n     FLOAT bit 0 64 exponent 52 11 MANTISSA 0 52 OFFSET 1023 */\n\n    if (dt->u.f.bit_offset != 0 || dt->u.f.mantissa_location != 0 ||\n        (dt->u.f.bit_precision != 32 && dt->u.f.bit_precision != 64) ||\n        (dt->u.f.bit_precision == 32 &&\n         (dt->u.f.exponent_location != 23 || dt->u.f.exponent_size != 8 ||\n          dt->u.f.mantissa_size != 23 || dt->u.f.exponent_bias != 127)) ||\n        (dt->u.f.bit_precision == 64 &&\n         (dt->u.f.exponent_location != 52 || dt->u.f.exponent_size != 11 ||\n          dt->u.f.mantissa_size != 52 || dt->u.f.exponent_bias != 1023)))\n      return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n    break;\n\n  case 3: /* string */\n    mylog(\"    STRING %d %02X\\n\", dt->size, dt->class_bit_field);\n    break;\n\n  case 6:\n    mylog(\"    COMPOUND %d %02X\\n\", dt->size, dt->class_bit_field);\n    switch (dt->class_and_version >> 4) {\n    case 3:\n      for (i = 0; i < (dt->class_bit_field & 0xffff); i++) {\n        int maxsize = 0x1000;\n        buffer = malloc(maxsize);\n        if (!buffer)\n          return MYSOFA_NO_MEMORY;\n        for (j = 0; j < maxsize - 1; j++) {\n          c = fgetc(reader->fhd);\n          if (c < 0) {\n            free(buffer);\n            return MYSOFA_READ_ERROR;\n          }\n          buffer[j] = c;\n          if (c == 0)\n            break;\n        }\n        buffer[j] = 0;\n\n        for (j = 0, c = 0; (dt->size >> (8 * j)) > 0; j++) {\n          c |= fgetc(reader->fhd) << (8 * j);\n        }\n\n        mylog(\"   COMPOUND %s offset %d\\n\", buffer, c);\n\n        /* not needed until the data is stored somewhere permanently\n         p = realloc(buffer, j);\n         if (!p) {\n         free(buffer);\n         return errno;\n         }\n         buffer = p;\n         */\n        free(buffer);\n\n        err = readOHDRHeaderMessageDatatype(reader, &dt2);\n        if (err)\n          return err; // LCOV_EXCL_LINE\n      }\n      break;\n\n    case 1:\n      for (i = 0; i < (dt->class_bit_field & 0xffff); i++) {\n        char name[256];\n        int res;\n        for (j = 0;; j++) {\n          if (j == sizeof(name))\n            return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n          res = fgetc(reader->fhd);\n          if (res < 0)\n            return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n          name[j] = res;\n          if (name[j] == 0)\n            break;\n        }\n        if (fseek(reader->fhd, (7 - j) & 7, SEEK_CUR))\n          return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n\n        c = readValue(reader, 4);\n        int dimension = fgetc(reader->fhd);\n        if (dimension != 0) {\n          mylog(\"COMPOUND v1 with dimension not supported\");\n          return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n        }\n\n        // ignore the following fields\n        if (fseek(reader->fhd, 3 + 4 + 4 + 4 * 4, SEEK_CUR))\n          return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n\n        mylog(\"  COMPOUND %s %d %d %lX\\n\", name, c, dimension,\n              ftell(reader->fhd));\n        err = readOHDRHeaderMessageDatatype(reader, &dt2);\n        if (err)\n          return err; // LCOV_EXCL_LINE\n      }\n      break;\n    default:\n      // LCOV_EXCL_START\n      mylog(\"object OHDR datatype message must have version 1 or 3 not %d\\n\",\n            dt->class_and_version >> 4);\n      return MYSOFA_INVALID_FORMAT;\n      // LCOV_EXCL_STOP\n    }\n    break;\n  case 7: /* reference */\n    mylog(\"    REFERENCE %d %02X\\n\", dt->size, dt->class_bit_field);\n    break;\n\n  case 9: /* list */\n    dt->list = dt->size;\n    mylog(\"  LIST %d\\n\", dt->size);\n    err = readOHDRHeaderMessageDatatype(reader, dt);\n    if (err)\n      return err; // LCOV_EXCL_LINE\n    break;\n\n  default:\n    // LCOV_EXCL_START\n    mylog(\"object OHDR datatype message has unknown variable type %d\\n\",\n          dt->class_and_version & 0xf);\n    return MYSOFA_UNSUPPORTED_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.f. The Data Storage - Fill Value Message\n\n 000007e0    |05 02 00 01 00 00|03  0a\n\n */\n\nstatic int readOHDRHeaderMessageDataFill1or2(struct READER *reader) {\n\n  int spaceAllocationTime = fgetc(reader->fhd);\n  int fillValueWriteTime = fgetc(reader->fhd);\n  int fillValueDefined = fgetc(reader->fhd);\n  if (spaceAllocationTime < 0 || fillValueWriteTime < 0 || fillValueDefined < 0)\n    return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n\n  if ((spaceAllocationTime & ~1) != 2 || fillValueWriteTime != 2 ||\n      (fillValueDefined & ~1) != 0) {\n    mylog(\"spaceAllocationTime %d fillValueWriteTime %d fillValueDefined %d\\n\",\n          spaceAllocationTime, fillValueWriteTime, fillValueDefined);\n    return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n  }\n  if (fillValueDefined > 0) {\n    uint32_t size = (uint32_t)readValue(reader, 4);\n    if (fseek(reader->fhd, size, SEEK_CUR) < 0)\n      return errno; // LCOV_EXCL_LINE\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageDataFill3(struct READER *reader) {\n  uint8_t flags;\n  uint32_t size;\n\n  flags = (uint8_t)fgetc(reader->fhd);\n\n  if (flags & (1 << 5)) {\n    size = (uint32_t)readValue(reader, 4);\n    if (fseek(reader->fhd, size, SEEK_CUR) < 0)\n      return errno; // LCOV_EXCL_LINE\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageDataFill(struct READER *reader) {\n\n  int version = fgetc(reader->fhd);\n  switch (version) {\n  case 1:\n  case 2:\n    return readOHDRHeaderMessageDataFill1or2(reader);\n  case 3:\n    return readOHDRHeaderMessageDataFill3(reader);\n  default:\n    // LCOV_EXCL_START\n    mylog(\"object OHDR data storage fill value message must have version 1,2, \"\n          \"or 3 not \"\n          \"%d\\n\",\n          version);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n}\n\nstatic int readOHDRHeaderMessageDataFillOld(struct READER *reader) {\n\n  uint32_t size;\n\n  size = (uint32_t)readValue(reader, 4);\n  if (fseek(reader->fhd, size, SEEK_CUR) < 0)\n    return errno; // LCOV_EXCL_LINE\n\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.i. The Data Layout Message\n\n 00000ec0                       08  00 00 00 00 00 00 00 00 |......+.........|\n 00000ed0  00 9e 47 0b 16 00 01 00  00 02 02 02 00 01 00 01 |..G.............|\n 00000ee0  00 08 00 00 00 01 00 01  00 01 00 01 00 00 00 08 |................|\n 00000ef0  17 00 01 00 00 03 02 03  01 42 00 00 00 00 00 00 |.........B......|\n 00000f00  01 00 00 00 03 00 00 00  08 00 00 00 15 1c 00 04 |................|\n\n\n 03 02 03  01 42 00 00 00 00 00 00  |.........B......|\n 00000f00  01 00 00 00 03 00 00 00  08 00 00 00 15 1c 00 04 |................|\n 00000f10  00 00 00 03 03 00 ff ff  ff ff ff ff ff ff ff ff |................|\n 00000f20  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff 0c 23 |...............#|\n 00000f30  00 00 00 00 03 00 05 00  08 00 04 00 00 54 79 70 |.............Typ|\n\n\n */\n\nstatic int readOHDRHeaderMessageDataLayout(struct READER *reader,\n                                           struct DATAOBJECT *data) {\n\n  int i, err;\n  unsigned size;\n\n  uint8_t dimensionality, layout_class;\n  uint32_t dataset_element_size;\n  uint64_t data_address, store, data_size;\n\n  UNUSED(dataset_element_size);\n  UNUSED(data_size);\n\n  if (fgetc(reader->fhd) != 3) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR message data layout message must have version 3\\n\");\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  layout_class = (uint8_t)fgetc(reader->fhd);\n  mylog(\"data layout %d\\n\", layout_class);\n\n  switch (layout_class) {\n#if 0\n\tcase 0:\n\tdata_size = readValue(reader, 2);\n\tfseek(reader->fhd, data_size, SEEK_CUR);\n\tmylog(\"TODO 0 SIZE %u\\n\", data_size);\n\tbreak;\n#endif\n  case 1:\n    data_address = readValue(reader, reader->superblock.size_of_offsets);\n    data_size = readValue(reader, reader->superblock.size_of_lengths);\n    mylog(\"CHUNK Contiguous SIZE %\" PRIu64 \"\\n\", data_size);\n\n    if (validAddress(reader, data_address)) {\n      store = ftell(reader->fhd);\n      if (fseek(reader->fhd, data_address, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n      if (!data->data) {\n        if (data_size > 0x10000000)\n          return MYSOFA_INVALID_FORMAT;\n        data->data_len = data_size;\n        data->data = calloc(1, data_size);\n        if (!data->data)\n          return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n      }\n      err = fread(data->data, 1, data_size, reader->fhd);\n      if (err != data_size)\n        return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n      if (fseek(reader->fhd, store, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n    }\n    break;\n\n  case 2:\n    dimensionality = (uint8_t)fgetc(reader->fhd);\n    mylog(\"dimensionality %d\\n\", dimensionality);\n\n    if (dimensionality < 1 || dimensionality > DATAOBJECT_MAX_DIMENSIONALITY) {\n      mylog(\"data layout 2: invalid dimensionality %d %lu %lu\\n\",\n            dimensionality, sizeof(data->datalayout_chunk),\n            sizeof(data->datalayout_chunk[0]));\n      return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n    }\n    data_address = readValue(reader, reader->superblock.size_of_offsets);\n    mylog(\" CHUNK %\" PRIX64 \"\\n\", data_address);\n    for (i = 0; i < dimensionality; i++) {\n      data->datalayout_chunk[i] = readValue(reader, 4);\n      mylog(\" %d\\n\", data->datalayout_chunk[i]);\n    }\n    /* TODO last entry? error in spec: ?*/\n\n    size = data->datalayout_chunk[dimensionality - 1];\n    for (i = 0; i < data->ds.dimensionality; i++)\n      size *= data->ds.dimension_size[i];\n\n    if (validAddress(reader, data_address) && dimensionality <= 4) {\n      store = ftell(reader->fhd);\n      if (fseek(reader->fhd, data_address, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n      if (!data->data) {\n        if (size > 0x10000000)\n          return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n        data->data_len = size;\n        data->data = calloc(1, size);\n        if (!data->data)\n          return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n      }\n      err = treeRead(reader, data);\n      if (err)\n        return err; // LCOV_EXCL_LINE\n      if (fseek(reader->fhd, store, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n    }\n    break;\n\n  default:\n    // LCOV_EXCL_START\n    mylog(\"object OHDR message data layout message has unknown layout class \"\n          \"%d\\n\",\n          layout_class);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.k. The Group Info Message\n\n *  00000070  0a 02 00 01 00 00 00 00\n *\n */\n\nstatic int readOHDRHeaderMessageGroupInfo(struct READER *reader,\n                                          struct GROUPINFO *gi) {\n\n  if (fgetc(reader->fhd) != 0) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR group info message must have version 0\\n\");\n    return MYSOFA_UNSUPPORTED_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  gi->flags = (uint8_t)fgetc(reader->fhd);\n\n  if (gi->flags & 1) {\n    gi->maximum_compact_value = (uint16_t)readValue(reader, 2);\n    gi->minimum_dense_value = (uint16_t)readValue(reader, 2);\n  }\n\n  if (gi->flags & 2) {\n    gi->number_of_entries = (uint16_t)readValue(reader, 2);\n    gi->length_of_entries = (uint16_t)readValue(reader, 2);\n  }\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.l. The Data Storage - Filter Pipeline Message\n *\n *  00000070  0a 02 00 01 00 00 00 00\n *\n */\n\n/* type 1\n\n                                                        00  |......G.8.......|\n000010a0  00 00 00 00 00 02 00 08  00 01 00 01 00 73 68 75  |.............shu|\n000010b0  66 66 6c 65 00 08 00 00  00 00 00 00 00 01 00 08  |ffle............|\n000010c0  00 01 00 01 00 64 65 66  6c 61 74 65 00 01 00 00  |.....deflate....|\n000010d0  00 00 00 00 00 08 17 00  01 00 00 03 02 03 01 48  |...............H|\n*/\nstatic int readOHDRHeaderMessageFilterPipelineV1(struct READER *reader,\n                                                 uint8_t filters) {\n  int i, j;\n  uint16_t filter_identification_value, flags, number_client_data_values,\n      namelength;\n\n  if (readValue(reader, 6) != 0) {\n    mylog(\"reserved values not zero\\n\");\n    return MYSOFA_INVALID_FORMAT;\n  }\n\n  for (i = 0; i < filters; i++) {\n    filter_identification_value = (uint16_t)readValue(reader, 2);\n    switch (filter_identification_value) {\n    case 1:\n    case 2:\n      break;\n    default:\n      // LCOV_EXCL_START\n      mylog(\"object OHDR filter pipeline message contains unsupported filter: \"\n            \"%d %lX\\n\",\n            filter_identification_value, ftell(reader->fhd) - 2);\n      return MYSOFA_INVALID_FORMAT;\n      // LCOV_EXCL_STOP\n    }\n    namelength = (uint16_t)readValue(reader, 2);\n    flags = (uint16_t)readValue(reader, 2);\n    number_client_data_values = (uint16_t)readValue(reader, 2);\n\n    if (namelength > 0)\n      if (fseek(reader->fhd, ((namelength - 1) & ~7) + 8, SEEK_CUR) ==\n          -1)                     // skip name\n        return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n\n    mylog(\"  filter %d namelen %d flags %04X values %d\\n\",\n          filter_identification_value, namelength, flags,\n          number_client_data_values);\n\n    if (number_client_data_values > 0x1000)\n      return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n    /* no name here */\n    for (j = 0; j < number_client_data_values; j++) {\n      readValue(reader, 4);\n    }\n    if ((number_client_data_values & 1) == 1)\n      readValue(reader, 4);\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageFilterPipelineV2(struct READER *reader,\n                                                 uint8_t filters) {\n  int i, j;\n  uint16_t filter_identification_value, flags, number_client_data_values;\n  uint32_t client_data;\n  uint64_t maximum_compact_value, minimum_dense_value, number_of_entries,\n      length_of_entries;\n\n  UNUSED(flags);\n  UNUSED(client_data);\n  UNUSED(maximum_compact_value);\n  UNUSED(minimum_dense_value);\n  UNUSED(number_of_entries);\n  UNUSED(length_of_entries);\n\n  for (i = 0; i < filters; i++) {\n    filter_identification_value = (uint16_t)readValue(reader, 2);\n    switch (filter_identification_value) {\n    case 1:\n    case 2:\n      break;\n    default:\n      // LCOV_EXCL_START\n      mylog(\"object OHDR filter pipeline message contains unsupported filter: \"\n            \"%d\\n\",\n            filter_identification_value);\n      return MYSOFA_INVALID_FORMAT;\n      // LCOV_EXCL_STOP\n    }\n    mylog(\"  filter %d\\n\", filter_identification_value);\n    flags = (uint16_t)readValue(reader, 2);\n    number_client_data_values = (uint16_t)readValue(reader, 2);\n    if (number_client_data_values > 0x1000)\n      return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n    /* no name here */\n    for (j = 0; j < number_client_data_values; j++) {\n      client_data = readValue(reader, 4);\n    }\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageFilterPipeline(struct READER *reader) {\n  int filterversion, filters;\n\n  filterversion = fgetc(reader->fhd);\n  filters = fgetc(reader->fhd);\n\n  if (filterversion < 0 || filters < 0)\n    return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n\n  if (filters > 32) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR filter pipeline message has too many filters: %d\\n\",\n          filters);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  switch (filterversion) {\n  case 1:\n    return readOHDRHeaderMessageFilterPipelineV1(reader, filters);\n  case 2:\n    return readOHDRHeaderMessageFilterPipelineV2(reader, filters);\n  default:\n    // LCOV_EXCL_START\n    mylog(\n        \"object OHDR filter pipeline message must have version 1 or 2 not %d\\n\",\n        filterversion);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n}\n\nint readDataVar(struct READER *reader, struct DATAOBJECT *data,\n                struct DATATYPE *dt, struct DATASPACE *ds) {\n\n  char *buffer, number[20];\n  uint64_t reference, gcol = 0, dataobject;\n  int err;\n  struct DATAOBJECT *referenceData;\n\n  if (dt->list) {\n    if (dt->list - dt->size == 8) {\n      readValue(reader, 4); /* TODO unknown? */\n      gcol = readValue(reader, 4);\n    } else {\n      gcol = readValue(reader, dt->list - dt->size);\n    }\n    mylog(\"    GCOL %d %8\" PRIX64 \" %8lX\\n\", dt->list - dt->size, gcol,\n          ftell(reader->fhd));\n    /*\t\tfseek(reader->fhd, dt->list - dt->size, SEEK_CUR); TODO:\n     * TODO: missing part in specification */\n  }\n\n  switch (dt->class_and_version & 0xf) {\n  case 0:\n    mylog(\"FIXED POINT todo %lX %d\\n\", ftell(reader->fhd), dt->size);\n    if (fseek(reader->fhd, dt->size, SEEK_CUR))\n      return errno; // LCOV_EXCL_LINE\n    break;\n\n  case 3:\n    buffer = malloc(dt->size + 1);\n    if (buffer == NULL) {\n      return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n    }\n    if (fread(buffer, 1, dt->size, reader->fhd) != dt->size) {\n      free(buffer);             // LCOV_EXCL_LINE\n      return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n    }\n    buffer[dt->size] = 0;\n    mylog(\"STRING %s\\n\", buffer);\n    data->string = buffer;\n    break;\n\n    /*\n     * 000036e3   67 0e 00 00 00  00 00 00 00 00 00 00 00  |...g............|\n     000036f0  00 00 00\n     */\n  case 6:\n    /* TODO unclear spec */\n    mylog(\"COMPONENT todo %lX %d\\n\", ftell(reader->fhd), dt->size);\n    if (fseek(reader->fhd, dt->size, SEEK_CUR))\n      return errno; // LCOV_EXCL_LINE\n    break;\n\n  case 7:\n    readValue(reader, 4); /* TODO unclear reference */\n    reference = readValue(reader, dt->size - 4);\n    mylog(\" REFERENCE size %d %\" PRIX64 \"\\n\", dt->size, reference);\n    if (!!(err = gcolRead(reader, gcol, reference, &dataobject))) {\n      return MYSOFA_OK; /* ignore error. TODO: why?\n       return err; */\n    }\n    referenceData = findDataobject(reader, dataobject);\n    if (referenceData)\n      buffer = referenceData->name;\n    else {\n      sprintf(number, \"REF%08lX\", (long unsigned int)reference);\n      buffer = number;\n    }\n    mylog(\"    REFERENCE %\" PRIX64 \" %\" PRIX64 \" %s\\n\", reference, dataobject,\n          buffer);\n    /*\t\tif(!referenceData) { TODO?\n     return MYSOFA_UNSUPPORTED_FORMAT;\n     } */\n    if (data->string) {\n      data->string =\n          realloc(data->string, strlen(data->string) + strlen(buffer) + 2);\n      if (!data->string)\n        return MYSOFA_NO_MEMORY;\n      strcat(data->string, \",\");\n      strcat(data->string, buffer);\n    } else {\n      data->string = mysofa_strdup(buffer);\n    }\n    break;\n\n  default:\n    // LCOV_EXCL_START\n    mylog(\"data reader unknown type %d\\n\", dt->class_and_version & 0xf);\n    return MYSOFA_INTERNAL_ERROR;\n    // LCOV_EXCL_STOP\n  }\n  return MYSOFA_OK;\n}\n\nint readDataDim(struct READER *reader, struct DATAOBJECT *da,\n                struct DATATYPE *dt, struct DATASPACE *ds, int dim) {\n  int i, err;\n\n  if (dim >= sizeof(ds->dimension_size) / sizeof(ds->dimension_size[0]))\n    return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n\n  for (i = 0; i < ds->dimension_size[dim]; i++) {\n    if (dim + 1 < ds->dimensionality) {\n      if (!!(err = readDataDim(reader, da, dt, ds, dim + 1))) {\n        return err; // LCOV_EXCL_LINE\n      }\n    } else {\n      if (!!(err = readDataVar(reader, da, dt, ds))) {\n        return err; // LCOV_EXCL_LINE\n      }\n    }\n  }\n  return MYSOFA_OK;\n}\n\nint readData(struct READER *reader, struct DATAOBJECT *da, struct DATATYPE *dt,\n             struct DATASPACE *ds) {\n  if (ds->dimensionality == 0) {\n    ds->dimension_size[0] = 1;\n  }\n  return readDataDim(reader, da, dt, ds, 0);\n}\n\n/*\n IV.A.2.q. The Object Header Continuation Message\n\n 10 10 00 00 07 00 6d  |...............m|\n 000007f0  36 00 00 00 00 00 00 ea  00 00 00 00 00 00 00 15 |6...............|\n */\n\nstatic int readOHDRHeaderMessageContinue(struct READER *reader,\n                                         struct DATAOBJECT *dataobject) {\n\n  int err;\n  uint64_t offset, length;\n  long store;\n\n  offset = readValue(reader, reader->superblock.size_of_offsets);\n  length = readValue(reader, reader->superblock.size_of_lengths);\n  if (offset > 0x2000000 || length > 0x10000000)\n    return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n\n  mylog(\" continue %08\" PRIX64 \" %08\" PRIX64 \"\\n\", offset, length);\n  if (reader->recursive_counter >= 25) {\n    mylog(\"recursive problem\");\n    return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n  } else\n    reader->recursive_counter++;\n\n  store = ftell(reader->fhd);\n\n  if (fseek(reader->fhd, offset, SEEK_SET) < 0)\n    return errno; // LCOV_EXCL_LINE\n\n  err = readOCHK(reader, dataobject, offset + length);\n  if (err)\n    return err; // LCOV_EXCL_LINE\n\n  if (store < 0)\n    return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n  if (fseek(reader->fhd, store, SEEK_SET) < 0)\n    return errno; // LCOV_EXCL_LINE\n\n  mylog(\" continue back\\n\");\n  return MYSOFA_OK;\n}\n\n/*\n IV.A.2.m. The Attribute Message\n\n */\n\nstatic int readOHDRHeaderMessageAttribute(struct READER *reader,\n                                          struct DATAOBJECT *dataobject) {\n  int err;\n\n  uint8_t flags, encoding;\n  uint16_t name_size, datatype_size, dataspace_size;\n  char *name;\n  struct DATAOBJECT d;\n  struct MYSOFA_ATTRIBUTE *attr;\n\n  UNUSED(encoding);\n  UNUSED(datatype_size);\n  UNUSED(dataspace_size);\n\n  memset(&d, 0, sizeof(d));\n\n  int version = fgetc(reader->fhd);\n\n  if (version != 1 && version != 3) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR attribute message must have version 1 or 3\\n\");\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  flags = (uint8_t)fgetc(reader->fhd);\n\n  name_size = (uint16_t)readValue(reader, 2);\n  datatype_size = (uint16_t)readValue(reader, 2);\n  dataspace_size = (uint16_t)readValue(reader, 2);\n  if (version == 3)\n    encoding = (uint8_t)fgetc(reader->fhd);\n\n  if (name_size > 0x1000)\n    return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n  name = malloc(name_size + 1);\n  if (!name)\n    return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n  if (fread(name, 1, name_size, reader->fhd) != name_size) {\n    free(name);   // LCOV_EXCL_LINE\n    return errno; // LCOV_EXCL_LINE\n  }\n  if (version == 1 && fseek(reader->fhd, (8 - name_size) & 7, SEEK_CUR) != 0) {\n    free(name);   // LCOV_EXCL_LINE\n    return errno; // LCOV_EXCL_LINE\n  }\n\n  name[name_size] = 0;\n  mylog(\"  attribute name %s %d %d %lX\\n\", name, datatype_size, dataspace_size,\n        ftell(reader->fhd));\n\n  if (version == 3 && (flags & 3)) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR attribute message must not have any flags set\\n\");\n    free(name);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n  err = readOHDRHeaderMessageDatatype(reader, &d.dt);\n  if (err) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR attribute message read datatype error\\n\");\n    free(name);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n  if (version == 1) {\n    if (fseek(reader->fhd, (8 - datatype_size) & 7, SEEK_CUR) < 0) {\n      // LCOV_EXCL_START\n      free(name);\n      return errno;\n      // LCOV_EXCL_STOP\n    }\n  }\n\n  err = readOHDRHeaderMessageDataspace(reader, &d.ds);\n  if (err) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR attribute message read dataspace error\\n\");\n    free(name);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n  if (version == 1) {\n    if (fseek(reader->fhd, (8 - dataspace_size) & 7, SEEK_CUR) < 0) {\n      // LCOV_EXCL_START\n      free(name);\n      return errno;\n      // LCOV_EXCL_STOP\n    }\n  }\n  err = readData(reader, &d, &d.dt, &d.ds);\n  if (err) {\n    mylog(\"object OHDR attribute message read data error\\n\");\n    free(name);\n    return MYSOFA_INVALID_FORMAT;\n  }\n\n  attr = malloc(sizeof(struct MYSOFA_ATTRIBUTE));\n  if (!attr) {\n    // LCOV_EXCL_START\n    free(name);\n    return MYSOFA_NO_MEMORY;\n    // LCOV_EXCL_STOP\n  }\n  attr->name = name;\n  attr->value = d.string;\n  d.string = NULL;\n  attr->next = dataobject->attributes;\n  dataobject->attributes = attr;\n\n  dataobjectFree(reader, &d);\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.v. The Attribute Info Message\n\n 00000070                           15 1c 00 04 00 00 00 03 |................|\n 00000080  16 00 40 02 00 00 00 00  00 00 d2 02 00 00 00 00 |..@.............|\n 00000090  00 00 f8 02 00 00 00 00  00 00\n\n */\n\nstatic int readOHDRHeaderMessageAttributeInfo(struct READER *reader,\n                                              struct ATTRIBUTEINFO *ai) {\n\n  if (fgetc(reader->fhd) != 0) {\n    mylog(\"object OHDR attribute info message must have version 0\\n\");\n    return MYSOFA_UNSUPPORTED_FORMAT;\n  }\n\n  ai->flags = (uint8_t)fgetc(reader->fhd);\n\n  if (ai->flags & 1)\n    ai->maximum_creation_index = readValue(reader, 2);\n\n  ai->fractal_heap_address =\n      readValue(reader, reader->superblock.size_of_offsets);\n  ai->attribute_name_btree =\n      readValue(reader, reader->superblock.size_of_offsets);\n\n  if (ai->flags & 2)\n    ai->attribute_creation_order_btree =\n        readValue(reader, reader->superblock.size_of_offsets);\n\n  return MYSOFA_OK;\n}\n\n/**\n * read all OHDR messages\n */\nstatic int readOHDRmessages(struct READER *reader,\n                            struct DATAOBJECT *dataobject,\n                            uint64_t end_of_messages) {\n\n  FILE *fhd = reader->fhd;\n  int err;\n  long end;\n\n  while (ftell(fhd) <\n         end_of_messages - 4) { /* final gap may has a size of up to 3 */\n    uint8_t header_message_type = (uint8_t)fgetc(fhd);\n    uint16_t header_message_size = (uint16_t)readValue(reader, 2);\n    uint8_t header_message_flags = (uint8_t)fgetc(fhd);\n    if ((header_message_flags & ~5) != 0) {\n      mylog(\"OHDR unsupported OHDR message flag %02X\\n\", header_message_flags);\n      return MYSOFA_UNSUPPORTED_FORMAT;\n    }\n\n    if ((dataobject->flags & (1 << 2)) != 0)\n      /* ignore header_creation_order */\n      if (fseek(reader->fhd, 2, SEEK_CUR) < 0)\n        return errno;\n\n    mylog(\" OHDR message type %2d offset %6lX len %4X\\n\", header_message_type,\n          ftell(fhd), header_message_size);\n\n    end = ftell(fhd) + header_message_size;\n\n    switch (header_message_type) {\n    case 0: /* NIL Message */\n      if (!!(err = readOHDRHeaderMessageNIL(reader, header_message_size)))\n        return err;\n      break;\n    case 1: /* Dataspace Message */\n      if (!!(err = readOHDRHeaderMessageDataspace(reader, &dataobject->ds)))\n        return err;\n      break;\n    case 2: /* Link Info Message */\n      if (!!(err = readOHDRHeaderMessageLinkInfo(reader, &dataobject->li)))\n        return err;\n      break;\n    case 3: /* Datatype Message */\n      if (!!(err = readOHDRHeaderMessageDatatype(reader, &dataobject->dt)))\n        return err;\n      break;\n    case 4: /* Data Fill Message Old */\n      if (!!(err = readOHDRHeaderMessageDataFillOld(reader)))\n        return err;\n      break;\n    case 5: /* Data Fill Message */\n      if (!!(err = readOHDRHeaderMessageDataFill(reader)))\n        return err;\n      break;\n    case 8: /* Data Layout Message */\n      if (!!(err = readOHDRHeaderMessageDataLayout(reader, dataobject)))\n        return err;\n      break;\n    case 10: /* Group Info Message */\n      if (!!(err = readOHDRHeaderMessageGroupInfo(reader, &dataobject->gi)))\n        return err;\n      break;\n    case 11: /* Filter Pipeline Message */\n      if (!!(err = readOHDRHeaderMessageFilterPipeline(reader)))\n        return err;\n      break;\n    case 12: /* Attribute Message */\n      if (!!(err = readOHDRHeaderMessageAttribute(reader, dataobject)))\n        return err;\n      break;\n    case 16: /* Continue Message */\n      if (!!(err = readOHDRHeaderMessageContinue(reader, dataobject)))\n        return err;\n      break;\n    case 21: /* Attribute Info Message */\n      if (!!(err = readOHDRHeaderMessageAttributeInfo(reader, &dataobject->ai)))\n        return err;\n      break;\n    default:\n      mylog(\"OHDR unknown header message of type %d\\n\", header_message_type);\n\n      return MYSOFA_UNSUPPORTED_FORMAT;\n    }\n\n    if (ftell(fhd) != end) {\n      mylog(\"OHDR message length mismatch by %ld\\n\", ftell(fhd) - end);\n      return MYSOFA_INTERNAL_ERROR;\n    }\n  }\n\n  if (fseek(fhd, end_of_messages + 4, SEEK_SET) < 0) /* skip checksum */\n    return errno;\n\n  return MYSOFA_OK;\n}\n\nstatic int readOCHK(struct READER *reader, struct DATAOBJECT *dataobject,\n                    uint64_t end) {\n  int err;\n  char buf[5];\n\n  /* read signature */\n  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"OCHK\", 4)) {\n    mylog(\"cannot read signature of OCHK\\n\");\n    return MYSOFA_INVALID_FORMAT;\n  }\n  buf[4] = 0;\n  mylog(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t)ftell(reader->fhd) - 4, buf);\n\n  err = readOHDRmessages(reader, dataobject, end - 4); /* subtract checksum */\n  if (err) {\n    return err;\n  }\n\n  return MYSOFA_OK;\n}\n\nint dataobjectRead(struct READER *reader, struct DATAOBJECT *dataobject,\n                   char *name) {\n  uint64_t size_of_chunk, end_of_messages;\n  int err;\n  char buf[5];\n\n  memset(dataobject, 0, sizeof(*dataobject));\n  dataobject->address = ftell(reader->fhd);\n  dataobject->name = name;\n\n  /* read signature */\n  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"OHDR\", 4)) {\n    mylog(\"cannot read signature of data object\\n\");\n    return MYSOFA_INVALID_FORMAT;\n  }\n  buf[4] = 0;\n  mylog(\"%08\" PRIX64 \" %.4s\\n\", dataobject->address, buf);\n\n  if (fgetc(reader->fhd) != 2) {\n    mylog(\"object OHDR must have version 2\\n\");\n    return MYSOFA_UNSUPPORTED_FORMAT;\n  }\n\n  dataobject->flags = (uint8_t)fgetc(reader->fhd);\n\n  if (dataobject->flags & (1 << 5)) {         /* bit 5 indicated time stamps */\n    if (fseek(reader->fhd, 16, SEEK_CUR) < 0) /* skip them */\n      return errno;\n  }\n\n  if (dataobject->flags & (1 << 4)) { /* bit 4 ? */\n    mylog(\"OHDR: unsupported flags bit 4: %02X\\n\", dataobject->flags);\n    return MYSOFA_UNSUPPORTED_FORMAT;\n  }\n\n  size_of_chunk = readValue(reader, 1 << (dataobject->flags & 3));\n  if (size_of_chunk > 0x1000000)\n    return MYSOFA_UNSUPPORTED_FORMAT;\n\n  end_of_messages = ftell(reader->fhd) + size_of_chunk;\n\n  err = readOHDRmessages(reader, dataobject, end_of_messages);\n\n  if (err) {\n    return err;\n  }\n\n  if (validAddress(reader, dataobject->ai.attribute_name_btree)) {\n    /* not needed\n         fseek(reader->fhd, dataobject->ai.attribute_name_btree, SEEK_SET);\n         btreeRead(reader, &dataobject->attributes);\n    */\n  }\n\n  /* parse message attribute info */\n  if (validAddress(reader, dataobject->ai.fractal_heap_address)) {\n    if (fseek(reader->fhd, dataobject->ai.fractal_heap_address, SEEK_SET) < 0)\n      return errno;\n    err = fractalheapRead(reader, dataobject, &dataobject->attributes_heap);\n    if (err)\n      return err;\n  }\n\n  /* parse message link info */\n  if (validAddress(reader, dataobject->li.fractal_heap_address)) {\n    fseek(reader->fhd, dataobject->li.fractal_heap_address, SEEK_SET);\n    err = fractalheapRead(reader, dataobject, &dataobject->objects_heap);\n    if (err)\n      return err;\n  }\n\n  if (validAddress(reader, dataobject->li.address_btree_index)) {\n    /* not needed\n       fseek(reader->fhd, dataobject->li.address_btree_index, SEEK_SET);\n       btreeRead(reader, &dataobject->objects);\n     */\n  }\n\n  dataobject->all = reader->all;\n  reader->all = dataobject;\n\n  return MYSOFA_OK;\n}\n\nvoid dataobjectFree(struct READER *reader, struct DATAOBJECT *dataobject) {\n  struct DATAOBJECT **p;\n\n  btreeFree(&dataobject->attributes_btree);\n  fractalheapFree(&dataobject->attributes_heap);\n  btreeFree(&dataobject->objects_btree);\n  fractalheapFree(&dataobject->objects_heap);\n\n  while (dataobject->attributes) {\n    struct MYSOFA_ATTRIBUTE *attr = dataobject->attributes;\n    dataobject->attributes = attr->next;\n    free(attr->name);\n    free(attr->value);\n    free(attr);\n  }\n\n  while (dataobject->directory) {\n    struct DIR *dir = dataobject->directory;\n    dataobject->directory = dir->next;\n    dataobjectFree(reader, &dir->dataobject);\n    free(dir);\n  }\n\n  free(dataobject->data);\n  free(dataobject->string);\n  free(dataobject->name);\n\n  p = &reader->all;\n  while (*p) {\n    if ((*p) == dataobject) {\n      *p = dataobject->all;\n      break;\n    }\n    p = &((*p)->all);\n  }\n}\n"], "fixing_code": ["/*\n\n Copyright 2016 Christian Hoene, Symonics GmbH\n\n */\n\n/* IV.A.1.b. Version 2 Data Object Header Prefix\n\n 00000030  4f 48 44 52 02 2d d3 18  2b 53 d3 18 2b 53 d3 18  |OHDR.-..+S..+S..|\n 00000040  2b 53 d3 18 2b 53 f4 01  02 22 00 00 00 00        |+S..+S...\"......|\n ....\n 00000230  00 00 00 00 00 00 00 00  00 00 00 00 f9 ba 5d c9  |..............].|\n */\n\n#include \"reader.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic int readOCHK(struct READER *reader, struct DATAOBJECT *dataobject,\n                    uint64_t end);\n\nstatic struct DATAOBJECT *findDataobject(struct READER *reader,\n                                         uint64_t address) {\n  struct DATAOBJECT *p = reader->all;\n  while (p && p->address != address)\n    p = p->all;\n\n  return p;\n}\n\n/*\n * IV.A.2.a. The NIL Message\n\n 00000090                                 00 9c 01 00 00 00  |................|\n 000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n *\n 00000230  00 00 00 00 00 00 00 00  00 00 00 00 f9 ba 5d c9  |..............].|\n\n */\n\nstatic int readOHDRHeaderMessageNIL(struct READER *reader, int length) {\n\n  if (fseek(reader->fhd, length, SEEK_CUR) < 0)\n    return errno; // LCOV_EXCL_LINE\n\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.b. The Dataspace Message\n\n */\n\nstatic int readOHDRHeaderMessageDataspace1(struct READER *reader,\n                                           struct DATASPACE *ds) {\n\n  int i;\n\n  readValue(reader, 5);\n\n  for (i = 0; i < ds->dimensionality; i++) {\n    if (i < 4) {\n      ds->dimension_size[i] =\n          readValue(reader, reader->superblock.size_of_lengths);\n      if (ds->dimension_size[i] > 1000000) {\n        mylog(\"dimension_size is too large\\n\"); // LCOV_EXCL_LINE\n        return MYSOFA_INVALID_FORMAT;           // LCOV_EXCL_LINE\n      }\n      mylog(\"   dimension %d %\" PRIu64 \"\\n\", i, ds->dimension_size[i]);\n    } else\n      readValue(reader, reader->superblock.size_of_lengths);\n  }\n\n  if (ds->flags & 1) {\n    for (i = 0; i < ds->dimensionality; i++) {\n      if (i < 4)\n        ds->dimension_max_size[i] =\n            readValue(reader, reader->superblock.size_of_lengths);\n      else\n        readValue(reader, reader->superblock.size_of_lengths);\n    }\n  }\n\n  if (ds->flags & 2) {\n    mylog(\"permutation in OHDR not supported\\n\"); // LCOV_EXCL_LINE\n    return MYSOFA_INVALID_FORMAT;                 // LCOV_EXCL_LINE\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageDataspace2(struct READER *reader,\n                                           struct DATASPACE *ds) {\n\n  int i;\n\n  ds->type = (uint8_t)fgetc(reader->fhd);\n\n  for (i = 0; i < ds->dimensionality; i++) {\n    if (i < 4) {\n      ds->dimension_size[i] =\n          readValue(reader, reader->superblock.size_of_lengths);\n      mylog(\"   dimension %d %\" PRIu64 \"\\n\", i, ds->dimension_size[i]);\n    } else\n      readValue(reader, reader->superblock.size_of_lengths);\n  }\n\n  if (ds->flags & 1) {\n    for (i = 0; i < ds->dimensionality; i++) {\n      if (i < 4)\n        ds->dimension_max_size[i] =\n            readValue(reader, reader->superblock.size_of_lengths);\n      else\n        readValue(reader, reader->superblock.size_of_lengths);\n    }\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageDataspace(struct READER *reader,\n                                          struct DATASPACE *ds) {\n\n  int version = fgetc(reader->fhd);\n\n  ds->dimensionality = (uint8_t)fgetc(reader->fhd);\n  if (ds->dimensionality > 4) {\n    mylog(\"dimensionality must be lower than 5\\n\"); // LCOV_EXCL_LINE\n    return MYSOFA_INVALID_FORMAT;                   // LCOV_EXCL_LINE\n  }\n\n  ds->flags = (uint8_t)fgetc(reader->fhd);\n\n  switch (version) {\n  case 1:\n    return readOHDRHeaderMessageDataspace1(reader, ds);\n  case 2:\n    return readOHDRHeaderMessageDataspace2(reader, ds);\n  default:\n    // LCOV_EXCL_START\n    mylog(\"object OHDR dataspace message must have version 1 or 2 but is %X at \"\n          \"%lX\\n\",\n          version, ftell(reader->fhd) - 1);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n}\n\n/*\n * IV.A.2.c. The Link Info Message\n\n 00 03  |+S..+S...\"......|\n 00000050  0f 00 00 00 00 00 00 00  c9 11 00 00 00 00 00 00  |................|\n 00000060  5b 12 00 00 00 00 00 00  81 12 00 00 00 00 00 00  |[...............|\n */\n\nstatic int readOHDRHeaderMessageLinkInfo(struct READER *reader,\n                                         struct LINKINFO *li) {\n\n  if (fgetc(reader->fhd) != 0) {\n    mylog(\n        \"object OHDR link info message must have version 0\\n\"); // LCOV_EXCL_LINE\n    return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n  }\n\n  li->flags = (uint8_t)fgetc(reader->fhd);\n\n  if (li->flags & 1)\n    li->maximum_creation_index = readValue(reader, 8);\n\n  li->fractal_heap_address =\n      readValue(reader, reader->superblock.size_of_offsets);\n  li->address_btree_index =\n      readValue(reader, reader->superblock.size_of_offsets);\n\n  if (li->flags & 2)\n    li->address_btree_order =\n        readValue(reader, reader->superblock.size_of_offsets);\n\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.d. The Datatype Message\n\n 000007c0                       03  14 00 01 00 00|11|21 1f  |..............!.|\n 000007d0  00|04 00 00 00|00 00|20  00|17|08|00|17|7f 00 00  |....... ........|\n 000007e0  00|05 02 00 01 00 00 03  0a 10 10 00 00 07 00 6d  |...............m|\n 000007f0  36 00 00 00 00 00 00 ea  00 00 00 00 00 00 00 15  |6...............|\n\n */\n\nstatic int readOHDRHeaderMessageDatatype(struct READER *reader,\n                                         struct DATATYPE *dt) {\n\n  int i, j, c, err;\n  char *buffer;\n  struct DATATYPE dt2;\n\n  dt->class_and_version = (uint8_t)fgetc(reader->fhd);\n  if ((dt->class_and_version & 0xf0) != 0x10 &&\n      (dt->class_and_version & 0xf0) != 0x30) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR datatype message must have version 1 not %d at %lX\\n\",\n          dt->class_and_version >> 4, ftell(reader->fhd) - 1);\n    return MYSOFA_UNSUPPORTED_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  dt->class_bit_field = (uint32_t)readValue(reader, 3);\n  dt->size = (uint32_t)readValue(reader, 4);\n  if (dt->size > 64)\n    return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n\n  switch (dt->class_and_version & 0xf) {\n  case 0: /* int */\n    dt->u.i.bit_offset = readValue(reader, 2);\n    dt->u.i.bit_precision = readValue(reader, 2);\n    mylog(\"    INT bit %d %d %d %d\\n\", dt->u.i.bit_offset,\n          dt->u.i.bit_precision, dt->class_and_version >> 4, dt->size);\n    break;\n\n  case 1: /* float */\n    dt->u.f.bit_offset = (uint16_t)readValue(reader, 2);\n    dt->u.f.bit_precision = (uint16_t)readValue(reader, 2);\n    dt->u.f.exponent_location = (uint8_t)fgetc(reader->fhd);\n    dt->u.f.exponent_size = (uint8_t)fgetc(reader->fhd);\n    dt->u.f.mantissa_location = (uint8_t)fgetc(reader->fhd);\n    dt->u.f.mantissa_size = (uint8_t)fgetc(reader->fhd);\n    dt->u.f.exponent_bias = (uint32_t)readValue(reader, 4);\n\n    mylog(\"    FLOAT bit %d %d exponent %d %d MANTISSA %d %d OFFSET %d\\n\",\n          dt->u.f.bit_offset, dt->u.f.bit_precision, dt->u.f.exponent_location,\n          dt->u.f.exponent_size, dt->u.f.mantissa_location,\n          dt->u.f.mantissa_size, dt->u.f.exponent_bias);\n\n    /* FLOAT bit 0 32 exponent 23 8 MANTISSA 0 23 OFFSET 127\n     FLOAT bit 0 64 exponent 52 11 MANTISSA 0 52 OFFSET 1023 */\n\n    if (dt->u.f.bit_offset != 0 || dt->u.f.mantissa_location != 0 ||\n        (dt->u.f.bit_precision != 32 && dt->u.f.bit_precision != 64) ||\n        (dt->u.f.bit_precision == 32 &&\n         (dt->u.f.exponent_location != 23 || dt->u.f.exponent_size != 8 ||\n          dt->u.f.mantissa_size != 23 || dt->u.f.exponent_bias != 127)) ||\n        (dt->u.f.bit_precision == 64 &&\n         (dt->u.f.exponent_location != 52 || dt->u.f.exponent_size != 11 ||\n          dt->u.f.mantissa_size != 52 || dt->u.f.exponent_bias != 1023)))\n      return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n    break;\n\n  case 3: /* string */\n    mylog(\"    STRING %d %02X\\n\", dt->size, dt->class_bit_field);\n    break;\n\n  case 6:\n    mylog(\"    COMPOUND %d %02X\\n\", dt->size, dt->class_bit_field);\n    switch (dt->class_and_version >> 4) {\n    case 3:\n      for (i = 0; i < (dt->class_bit_field & 0xffff); i++) {\n        int maxsize = 0x1000;\n        buffer = malloc(maxsize);\n        if (!buffer)\n          return MYSOFA_NO_MEMORY;\n        for (j = 0; j < maxsize - 1; j++) {\n          c = fgetc(reader->fhd);\n          if (c < 0) {\n            free(buffer);\n            return MYSOFA_READ_ERROR;\n          }\n          buffer[j] = c;\n          if (c == 0)\n            break;\n        }\n        buffer[j] = 0;\n\n        for (j = 0, c = 0; (dt->size >> (8 * j)) > 0; j++) {\n          c |= fgetc(reader->fhd) << (8 * j);\n        }\n\n        mylog(\"   COMPOUND %s offset %d\\n\", buffer, c);\n\n        /* not needed until the data is stored somewhere permanently\n         p = realloc(buffer, j);\n         if (!p) {\n         free(buffer);\n         return errno;\n         }\n         buffer = p;\n         */\n        free(buffer);\n\n        err = readOHDRHeaderMessageDatatype(reader, &dt2);\n        if (err)\n          return err; // LCOV_EXCL_LINE\n      }\n      break;\n\n    case 1:\n      for (i = 0; i < (dt->class_bit_field & 0xffff); i++) {\n        char name[256];\n        int res;\n        for (j = 0;; j++) {\n          if (j == sizeof(name))\n            return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n          res = fgetc(reader->fhd);\n          if (res < 0)\n            return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n          name[j] = res;\n          if (name[j] == 0)\n            break;\n        }\n        if (fseek(reader->fhd, (7 - j) & 7, SEEK_CUR))\n          return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n\n        c = readValue(reader, 4);\n        int dimension = fgetc(reader->fhd);\n        if (dimension != 0) {\n          mylog(\"COMPOUND v1 with dimension not supported\");\n          return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n        }\n\n        // ignore the following fields\n        if (fseek(reader->fhd, 3 + 4 + 4 + 4 * 4, SEEK_CUR))\n          return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n\n        mylog(\"  COMPOUND %s %d %d %lX\\n\", name, c, dimension,\n              ftell(reader->fhd));\n        err = readOHDRHeaderMessageDatatype(reader, &dt2);\n        if (err)\n          return err; // LCOV_EXCL_LINE\n      }\n      break;\n    default:\n      // LCOV_EXCL_START\n      mylog(\"object OHDR datatype message must have version 1 or 3 not %d\\n\",\n            dt->class_and_version >> 4);\n      return MYSOFA_INVALID_FORMAT;\n      // LCOV_EXCL_STOP\n    }\n    break;\n  case 7: /* reference */\n    mylog(\"    REFERENCE %d %02X\\n\", dt->size, dt->class_bit_field);\n    break;\n\n  case 9: /* list */\n    dt->list = dt->size;\n    mylog(\"  LIST %d\\n\", dt->size);\n    err = readOHDRHeaderMessageDatatype(reader, dt);\n    if (err)\n      return err; // LCOV_EXCL_LINE\n    break;\n\n  default:\n    // LCOV_EXCL_START\n    mylog(\"object OHDR datatype message has unknown variable type %d\\n\",\n          dt->class_and_version & 0xf);\n    return MYSOFA_UNSUPPORTED_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.f. The Data Storage - Fill Value Message\n\n 000007e0    |05 02 00 01 00 00|03  0a\n\n */\n\nstatic int readOHDRHeaderMessageDataFill1or2(struct READER *reader) {\n\n  int spaceAllocationTime = fgetc(reader->fhd);\n  int fillValueWriteTime = fgetc(reader->fhd);\n  int fillValueDefined = fgetc(reader->fhd);\n  if (spaceAllocationTime < 0 || fillValueWriteTime < 0 || fillValueDefined < 0)\n    return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n\n  if ((spaceAllocationTime & ~1) != 2 || fillValueWriteTime != 2 ||\n      (fillValueDefined & ~1) != 0) {\n    mylog(\"spaceAllocationTime %d fillValueWriteTime %d fillValueDefined %d\\n\",\n          spaceAllocationTime, fillValueWriteTime, fillValueDefined);\n    return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n  }\n  if (fillValueDefined > 0) {\n    uint32_t size = (uint32_t)readValue(reader, 4);\n    if (fseek(reader->fhd, size, SEEK_CUR) < 0)\n      return errno; // LCOV_EXCL_LINE\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageDataFill3(struct READER *reader) {\n  uint8_t flags;\n  uint32_t size;\n\n  flags = (uint8_t)fgetc(reader->fhd);\n\n  if (flags & (1 << 5)) {\n    size = (uint32_t)readValue(reader, 4);\n    if (fseek(reader->fhd, size, SEEK_CUR) < 0)\n      return errno; // LCOV_EXCL_LINE\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageDataFill(struct READER *reader) {\n\n  int version = fgetc(reader->fhd);\n  switch (version) {\n  case 1:\n  case 2:\n    return readOHDRHeaderMessageDataFill1or2(reader);\n  case 3:\n    return readOHDRHeaderMessageDataFill3(reader);\n  default:\n    // LCOV_EXCL_START\n    mylog(\"object OHDR data storage fill value message must have version 1,2, \"\n          \"or 3 not \"\n          \"%d\\n\",\n          version);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n}\n\nstatic int readOHDRHeaderMessageDataFillOld(struct READER *reader) {\n\n  uint32_t size;\n\n  size = (uint32_t)readValue(reader, 4);\n  if (fseek(reader->fhd, size, SEEK_CUR) < 0)\n    return errno; // LCOV_EXCL_LINE\n\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.i. The Data Layout Message\n\n 00000ec0                       08  00 00 00 00 00 00 00 00 |......+.........|\n 00000ed0  00 9e 47 0b 16 00 01 00  00 02 02 02 00 01 00 01 |..G.............|\n 00000ee0  00 08 00 00 00 01 00 01  00 01 00 01 00 00 00 08 |................|\n 00000ef0  17 00 01 00 00 03 02 03  01 42 00 00 00 00 00 00 |.........B......|\n 00000f00  01 00 00 00 03 00 00 00  08 00 00 00 15 1c 00 04 |................|\n\n\n 03 02 03  01 42 00 00 00 00 00 00  |.........B......|\n 00000f00  01 00 00 00 03 00 00 00  08 00 00 00 15 1c 00 04 |................|\n 00000f10  00 00 00 03 03 00 ff ff  ff ff ff ff ff ff ff ff |................|\n 00000f20  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff 0c 23 |...............#|\n 00000f30  00 00 00 00 03 00 05 00  08 00 04 00 00 54 79 70 |.............Typ|\n\n\n */\n\nstatic int readOHDRHeaderMessageDataLayout(struct READER *reader,\n                                           struct DATAOBJECT *data) {\n\n  int i, err;\n  unsigned size;\n\n  uint8_t dimensionality, layout_class;\n  uint32_t dataset_element_size;\n  uint64_t data_address, store, data_size;\n\n  UNUSED(dataset_element_size);\n  UNUSED(data_size);\n\n  if (fgetc(reader->fhd) != 3) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR message data layout message must have version 3\\n\");\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  layout_class = (uint8_t)fgetc(reader->fhd);\n  mylog(\"data layout %d\\n\", layout_class);\n\n  switch (layout_class) {\n#if 0\n\tcase 0:\n\tdata_size = readValue(reader, 2);\n\tfseek(reader->fhd, data_size, SEEK_CUR);\n\tmylog(\"TODO 0 SIZE %u\\n\", data_size);\n\tbreak;\n#endif\n  case 1:\n    data_address = readValue(reader, reader->superblock.size_of_offsets);\n    data_size = readValue(reader, reader->superblock.size_of_lengths);\n    mylog(\"CHUNK Contiguous SIZE %\" PRIu64 \"\\n\", data_size);\n\n    if (validAddress(reader, data_address)) {\n      store = ftell(reader->fhd);\n      if (fseek(reader->fhd, data_address, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n      if (data->data) {\n        free(data->data);\n        data->data = NULL;\n      }\n      if (data_size > 0x10000000)\n        return MYSOFA_INVALID_FORMAT;\n      data->data_len = data_size;\n      data->data = calloc(1, data_size);\n      if (!data->data)\n        return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n\n      err = fread(data->data, 1, data_size, reader->fhd);\n      if (err != data_size)\n        return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n      if (fseek(reader->fhd, store, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n    }\n    break;\n\n  case 2:\n    dimensionality = (uint8_t)fgetc(reader->fhd);\n    mylog(\"dimensionality %d\\n\", dimensionality);\n\n    if (dimensionality < 1 || dimensionality > DATAOBJECT_MAX_DIMENSIONALITY) {\n      mylog(\"data layout 2: invalid dimensionality %d %lu %lu\\n\",\n            dimensionality, sizeof(data->datalayout_chunk),\n            sizeof(data->datalayout_chunk[0]));\n      return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n    }\n    data_address = readValue(reader, reader->superblock.size_of_offsets);\n    mylog(\" CHUNK %\" PRIX64 \"\\n\", data_address);\n    for (i = 0; i < dimensionality; i++) {\n      data->datalayout_chunk[i] = readValue(reader, 4);\n      mylog(\" %d\\n\", data->datalayout_chunk[i]);\n    }\n    /* TODO last entry? error in spec: ?*/\n\n    size = data->datalayout_chunk[dimensionality - 1];\n    for (i = 0; i < data->ds.dimensionality; i++)\n      size *= data->ds.dimension_size[i];\n\n    if (validAddress(reader, data_address) && dimensionality <= 4) {\n      store = ftell(reader->fhd);\n      if (fseek(reader->fhd, data_address, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n      if (!data->data) {\n        if (size > 0x10000000)\n          return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n        data->data_len = size;\n        data->data = calloc(1, size);\n        if (!data->data)\n          return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n      }\n      err = treeRead(reader, data);\n      if (err)\n        return err; // LCOV_EXCL_LINE\n      if (fseek(reader->fhd, store, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n    }\n    break;\n\n  default:\n    // LCOV_EXCL_START\n    mylog(\"object OHDR message data layout message has unknown layout class \"\n          \"%d\\n\",\n          layout_class);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.k. The Group Info Message\n\n *  00000070  0a 02 00 01 00 00 00 00\n *\n */\n\nstatic int readOHDRHeaderMessageGroupInfo(struct READER *reader,\n                                          struct GROUPINFO *gi) {\n\n  if (fgetc(reader->fhd) != 0) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR group info message must have version 0\\n\");\n    return MYSOFA_UNSUPPORTED_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  gi->flags = (uint8_t)fgetc(reader->fhd);\n\n  if (gi->flags & 1) {\n    gi->maximum_compact_value = (uint16_t)readValue(reader, 2);\n    gi->minimum_dense_value = (uint16_t)readValue(reader, 2);\n  }\n\n  if (gi->flags & 2) {\n    gi->number_of_entries = (uint16_t)readValue(reader, 2);\n    gi->length_of_entries = (uint16_t)readValue(reader, 2);\n  }\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.l. The Data Storage - Filter Pipeline Message\n *\n *  00000070  0a 02 00 01 00 00 00 00\n *\n */\n\n/* type 1\n\n                                                        00  |......G.8.......|\n000010a0  00 00 00 00 00 02 00 08  00 01 00 01 00 73 68 75  |.............shu|\n000010b0  66 66 6c 65 00 08 00 00  00 00 00 00 00 01 00 08  |ffle............|\n000010c0  00 01 00 01 00 64 65 66  6c 61 74 65 00 01 00 00  |.....deflate....|\n000010d0  00 00 00 00 00 08 17 00  01 00 00 03 02 03 01 48  |...............H|\n*/\nstatic int readOHDRHeaderMessageFilterPipelineV1(struct READER *reader,\n                                                 uint8_t filters) {\n  int i, j;\n  uint16_t filter_identification_value, flags, number_client_data_values,\n      namelength;\n\n  if (readValue(reader, 6) != 0) {\n    mylog(\"reserved values not zero\\n\");\n    return MYSOFA_INVALID_FORMAT;\n  }\n\n  for (i = 0; i < filters; i++) {\n    filter_identification_value = (uint16_t)readValue(reader, 2);\n    switch (filter_identification_value) {\n    case 1:\n    case 2:\n      break;\n    default:\n      // LCOV_EXCL_START\n      mylog(\"object OHDR filter pipeline message contains unsupported filter: \"\n            \"%d %lX\\n\",\n            filter_identification_value, ftell(reader->fhd) - 2);\n      return MYSOFA_INVALID_FORMAT;\n      // LCOV_EXCL_STOP\n    }\n    namelength = (uint16_t)readValue(reader, 2);\n    flags = (uint16_t)readValue(reader, 2);\n    number_client_data_values = (uint16_t)readValue(reader, 2);\n\n    if (namelength > 0)\n      if (fseek(reader->fhd, ((namelength - 1) & ~7) + 8, SEEK_CUR) ==\n          -1)                     // skip name\n        return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n\n    mylog(\"  filter %d namelen %d flags %04X values %d\\n\",\n          filter_identification_value, namelength, flags,\n          number_client_data_values);\n\n    if (number_client_data_values > 0x1000)\n      return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n    /* no name here */\n    for (j = 0; j < number_client_data_values; j++) {\n      readValue(reader, 4);\n    }\n    if ((number_client_data_values & 1) == 1)\n      readValue(reader, 4);\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageFilterPipelineV2(struct READER *reader,\n                                                 uint8_t filters) {\n  int i, j;\n  uint16_t filter_identification_value, flags, number_client_data_values;\n  uint32_t client_data;\n  uint64_t maximum_compact_value, minimum_dense_value, number_of_entries,\n      length_of_entries;\n\n  UNUSED(flags);\n  UNUSED(client_data);\n  UNUSED(maximum_compact_value);\n  UNUSED(minimum_dense_value);\n  UNUSED(number_of_entries);\n  UNUSED(length_of_entries);\n\n  for (i = 0; i < filters; i++) {\n    filter_identification_value = (uint16_t)readValue(reader, 2);\n    switch (filter_identification_value) {\n    case 1:\n    case 2:\n      break;\n    default:\n      // LCOV_EXCL_START\n      mylog(\"object OHDR filter pipeline message contains unsupported filter: \"\n            \"%d\\n\",\n            filter_identification_value);\n      return MYSOFA_INVALID_FORMAT;\n      // LCOV_EXCL_STOP\n    }\n    mylog(\"  filter %d\\n\", filter_identification_value);\n    flags = (uint16_t)readValue(reader, 2);\n    number_client_data_values = (uint16_t)readValue(reader, 2);\n    if (number_client_data_values > 0x1000)\n      return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n    /* no name here */\n    for (j = 0; j < number_client_data_values; j++) {\n      client_data = readValue(reader, 4);\n    }\n  }\n\n  return MYSOFA_OK;\n}\n\nstatic int readOHDRHeaderMessageFilterPipeline(struct READER *reader) {\n  int filterversion, filters;\n\n  filterversion = fgetc(reader->fhd);\n  filters = fgetc(reader->fhd);\n\n  if (filterversion < 0 || filters < 0)\n    return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n\n  if (filters > 32) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR filter pipeline message has too many filters: %d\\n\",\n          filters);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  switch (filterversion) {\n  case 1:\n    return readOHDRHeaderMessageFilterPipelineV1(reader, filters);\n  case 2:\n    return readOHDRHeaderMessageFilterPipelineV2(reader, filters);\n  default:\n    // LCOV_EXCL_START\n    mylog(\n        \"object OHDR filter pipeline message must have version 1 or 2 not %d\\n\",\n        filterversion);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n}\n\nint readDataVar(struct READER *reader, struct DATAOBJECT *data,\n                struct DATATYPE *dt, struct DATASPACE *ds) {\n\n  char *buffer, number[20];\n  uint64_t reference, gcol = 0, dataobject;\n  int err;\n  struct DATAOBJECT *referenceData;\n\n  if (dt->list) {\n    if (dt->list - dt->size == 8) {\n      readValue(reader, 4); /* TODO unknown? */\n      gcol = readValue(reader, 4);\n    } else {\n      gcol = readValue(reader, dt->list - dt->size);\n    }\n    mylog(\"    GCOL %d %8\" PRIX64 \" %8lX\\n\", dt->list - dt->size, gcol,\n          ftell(reader->fhd));\n    /*\t\tfseek(reader->fhd, dt->list - dt->size, SEEK_CUR); TODO:\n     * TODO: missing part in specification */\n  }\n\n  switch (dt->class_and_version & 0xf) {\n  case 0:\n    mylog(\"FIXED POINT todo %lX %d\\n\", ftell(reader->fhd), dt->size);\n    if (fseek(reader->fhd, dt->size, SEEK_CUR))\n      return errno; // LCOV_EXCL_LINE\n    break;\n\n  case 3:\n    buffer = malloc(dt->size + 1);\n    if (buffer == NULL) {\n      return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n    }\n    if (fread(buffer, 1, dt->size, reader->fhd) != dt->size) {\n      free(buffer);             // LCOV_EXCL_LINE\n      return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n    }\n    buffer[dt->size] = 0;\n    mylog(\"STRING %s\\n\", buffer);\n    data->string = buffer;\n    break;\n\n    /*\n     * 000036e3   67 0e 00 00 00  00 00 00 00 00 00 00 00  |...g............|\n     000036f0  00 00 00\n     */\n  case 6:\n    /* TODO unclear spec */\n    mylog(\"COMPONENT todo %lX %d\\n\", ftell(reader->fhd), dt->size);\n    if (fseek(reader->fhd, dt->size, SEEK_CUR))\n      return errno; // LCOV_EXCL_LINE\n    break;\n\n  case 7:\n    readValue(reader, 4); /* TODO unclear reference */\n    reference = readValue(reader, dt->size - 4);\n    mylog(\" REFERENCE size %d %\" PRIX64 \"\\n\", dt->size, reference);\n    if (!!(err = gcolRead(reader, gcol, reference, &dataobject))) {\n      return MYSOFA_OK; /* ignore error. TODO: why?\n       return err; */\n    }\n    referenceData = findDataobject(reader, dataobject);\n    if (referenceData)\n      buffer = referenceData->name;\n    else {\n      sprintf(number, \"REF%08lX\", (long unsigned int)reference);\n      buffer = number;\n    }\n    mylog(\"    REFERENCE %\" PRIX64 \" %\" PRIX64 \" %s\\n\", reference, dataobject,\n          buffer);\n    /*\t\tif(!referenceData) { TODO?\n     return MYSOFA_UNSUPPORTED_FORMAT;\n     } */\n    if (data->string) {\n      data->string =\n          realloc(data->string, strlen(data->string) + strlen(buffer) + 2);\n      if (!data->string)\n        return MYSOFA_NO_MEMORY;\n      strcat(data->string, \",\");\n      strcat(data->string, buffer);\n    } else {\n      data->string = mysofa_strdup(buffer);\n    }\n    break;\n\n  default:\n    // LCOV_EXCL_START\n    mylog(\"data reader unknown type %d\\n\", dt->class_and_version & 0xf);\n    return MYSOFA_INTERNAL_ERROR;\n    // LCOV_EXCL_STOP\n  }\n  return MYSOFA_OK;\n}\n\nint readDataDim(struct READER *reader, struct DATAOBJECT *da,\n                struct DATATYPE *dt, struct DATASPACE *ds, int dim) {\n  int i, err;\n\n  if (dim >= sizeof(ds->dimension_size) / sizeof(ds->dimension_size[0]))\n    return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n\n  for (i = 0; i < ds->dimension_size[dim]; i++) {\n    if (dim + 1 < ds->dimensionality) {\n      if (!!(err = readDataDim(reader, da, dt, ds, dim + 1))) {\n        return err; // LCOV_EXCL_LINE\n      }\n    } else {\n      if (!!(err = readDataVar(reader, da, dt, ds))) {\n        return err; // LCOV_EXCL_LINE\n      }\n    }\n  }\n  return MYSOFA_OK;\n}\n\nint readData(struct READER *reader, struct DATAOBJECT *da, struct DATATYPE *dt,\n             struct DATASPACE *ds) {\n  if (ds->dimensionality == 0) {\n    ds->dimension_size[0] = 1;\n  }\n  return readDataDim(reader, da, dt, ds, 0);\n}\n\n/*\n IV.A.2.q. The Object Header Continuation Message\n\n 10 10 00 00 07 00 6d  |...............m|\n 000007f0  36 00 00 00 00 00 00 ea  00 00 00 00 00 00 00 15 |6...............|\n */\n\nstatic int readOHDRHeaderMessageContinue(struct READER *reader,\n                                         struct DATAOBJECT *dataobject) {\n\n  int err;\n  uint64_t offset, length;\n  long store;\n\n  offset = readValue(reader, reader->superblock.size_of_offsets);\n  length = readValue(reader, reader->superblock.size_of_lengths);\n  if (offset > 0x2000000 || length > 0x10000000)\n    return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n\n  mylog(\" continue %08\" PRIX64 \" %08\" PRIX64 \"\\n\", offset, length);\n  if (reader->recursive_counter >= 25) {\n    mylog(\"recursive problem\");\n    return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE\n  } else\n    reader->recursive_counter++;\n\n  store = ftell(reader->fhd);\n\n  if (fseek(reader->fhd, offset, SEEK_SET) < 0)\n    return errno; // LCOV_EXCL_LINE\n\n  err = readOCHK(reader, dataobject, offset + length);\n  if (err)\n    return err; // LCOV_EXCL_LINE\n\n  if (store < 0)\n    return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n  if (fseek(reader->fhd, store, SEEK_SET) < 0)\n    return errno; // LCOV_EXCL_LINE\n\n  mylog(\" continue back\\n\");\n  return MYSOFA_OK;\n}\n\n/*\n IV.A.2.m. The Attribute Message\n\n */\n\nstatic int readOHDRHeaderMessageAttribute(struct READER *reader,\n                                          struct DATAOBJECT *dataobject) {\n  int err;\n\n  uint8_t flags, encoding;\n  uint16_t name_size, datatype_size, dataspace_size;\n  char *name;\n  struct DATAOBJECT d;\n  struct MYSOFA_ATTRIBUTE *attr;\n\n  UNUSED(encoding);\n  UNUSED(datatype_size);\n  UNUSED(dataspace_size);\n\n  memset(&d, 0, sizeof(d));\n\n  int version = fgetc(reader->fhd);\n\n  if (version != 1 && version != 3) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR attribute message must have version 1 or 3\\n\");\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  flags = (uint8_t)fgetc(reader->fhd);\n\n  name_size = (uint16_t)readValue(reader, 2);\n  datatype_size = (uint16_t)readValue(reader, 2);\n  dataspace_size = (uint16_t)readValue(reader, 2);\n  if (version == 3)\n    encoding = (uint8_t)fgetc(reader->fhd);\n\n  if (name_size > 0x1000)\n    return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n  name = malloc(name_size + 1);\n  if (!name)\n    return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n  if (fread(name, 1, name_size, reader->fhd) != name_size) {\n    free(name);   // LCOV_EXCL_LINE\n    return errno; // LCOV_EXCL_LINE\n  }\n  if (version == 1 && fseek(reader->fhd, (8 - name_size) & 7, SEEK_CUR) != 0) {\n    free(name);   // LCOV_EXCL_LINE\n    return errno; // LCOV_EXCL_LINE\n  }\n\n  name[name_size] = 0;\n  mylog(\"  attribute name %s %d %d %lX\\n\", name, datatype_size, dataspace_size,\n        ftell(reader->fhd));\n\n  if (version == 3 && (flags & 3)) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR attribute message must not have any flags set\\n\");\n    free(name);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n  err = readOHDRHeaderMessageDatatype(reader, &d.dt);\n  if (err) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR attribute message read datatype error\\n\");\n    free(name);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n  if (version == 1) {\n    if (fseek(reader->fhd, (8 - datatype_size) & 7, SEEK_CUR) < 0) {\n      // LCOV_EXCL_START\n      free(name);\n      return errno;\n      // LCOV_EXCL_STOP\n    }\n  }\n\n  err = readOHDRHeaderMessageDataspace(reader, &d.ds);\n  if (err) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR attribute message read dataspace error\\n\");\n    free(name);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n  if (version == 1) {\n    if (fseek(reader->fhd, (8 - dataspace_size) & 7, SEEK_CUR) < 0) {\n      // LCOV_EXCL_START\n      free(name);\n      return errno;\n      // LCOV_EXCL_STOP\n    }\n  }\n  err = readData(reader, &d, &d.dt, &d.ds);\n  if (err) {\n    mylog(\"object OHDR attribute message read data error\\n\");\n    free(name);\n    return MYSOFA_INVALID_FORMAT;\n  }\n\n  attr = malloc(sizeof(struct MYSOFA_ATTRIBUTE));\n  if (!attr) {\n    // LCOV_EXCL_START\n    free(name);\n    return MYSOFA_NO_MEMORY;\n    // LCOV_EXCL_STOP\n  }\n  attr->name = name;\n  attr->value = d.string;\n  d.string = NULL;\n  attr->next = dataobject->attributes;\n  dataobject->attributes = attr;\n\n  dataobjectFree(reader, &d);\n  return MYSOFA_OK;\n}\n\n/*\n * IV.A.2.v. The Attribute Info Message\n\n 00000070                           15 1c 00 04 00 00 00 03 |................|\n 00000080  16 00 40 02 00 00 00 00  00 00 d2 02 00 00 00 00 |..@.............|\n 00000090  00 00 f8 02 00 00 00 00  00 00\n\n */\n\nstatic int readOHDRHeaderMessageAttributeInfo(struct READER *reader,\n                                              struct ATTRIBUTEINFO *ai) {\n\n  if (fgetc(reader->fhd) != 0) {\n    mylog(\"object OHDR attribute info message must have version 0\\n\");\n    return MYSOFA_UNSUPPORTED_FORMAT;\n  }\n\n  ai->flags = (uint8_t)fgetc(reader->fhd);\n\n  if (ai->flags & 1)\n    ai->maximum_creation_index = readValue(reader, 2);\n\n  ai->fractal_heap_address =\n      readValue(reader, reader->superblock.size_of_offsets);\n  ai->attribute_name_btree =\n      readValue(reader, reader->superblock.size_of_offsets);\n\n  if (ai->flags & 2)\n    ai->attribute_creation_order_btree =\n        readValue(reader, reader->superblock.size_of_offsets);\n\n  return MYSOFA_OK;\n}\n\n/**\n * read all OHDR messages\n */\nstatic int readOHDRmessages(struct READER *reader,\n                            struct DATAOBJECT *dataobject,\n                            uint64_t end_of_messages) {\n\n  FILE *fhd = reader->fhd;\n  int err;\n  long end;\n\n  while (ftell(fhd) <\n         end_of_messages - 4) { /* final gap may has a size of up to 3 */\n    uint8_t header_message_type = (uint8_t)fgetc(fhd);\n    uint16_t header_message_size = (uint16_t)readValue(reader, 2);\n    uint8_t header_message_flags = (uint8_t)fgetc(fhd);\n    if ((header_message_flags & ~5) != 0) {\n      mylog(\"OHDR unsupported OHDR message flag %02X\\n\", header_message_flags);\n      return MYSOFA_UNSUPPORTED_FORMAT;\n    }\n\n    if ((dataobject->flags & (1 << 2)) != 0)\n      /* ignore header_creation_order */\n      if (fseek(reader->fhd, 2, SEEK_CUR) < 0)\n        return errno;\n\n    mylog(\" OHDR message type %2d offset %6lX len %4X\\n\", header_message_type,\n          ftell(fhd), header_message_size);\n\n    end = ftell(fhd) + header_message_size;\n\n    switch (header_message_type) {\n    case 0: /* NIL Message */\n      if (!!(err = readOHDRHeaderMessageNIL(reader, header_message_size)))\n        return err;\n      break;\n    case 1: /* Dataspace Message */\n      if (!!(err = readOHDRHeaderMessageDataspace(reader, &dataobject->ds)))\n        return err;\n      break;\n    case 2: /* Link Info Message */\n      if (!!(err = readOHDRHeaderMessageLinkInfo(reader, &dataobject->li)))\n        return err;\n      break;\n    case 3: /* Datatype Message */\n      if (!!(err = readOHDRHeaderMessageDatatype(reader, &dataobject->dt)))\n        return err;\n      break;\n    case 4: /* Data Fill Message Old */\n      if (!!(err = readOHDRHeaderMessageDataFillOld(reader)))\n        return err;\n      break;\n    case 5: /* Data Fill Message */\n      if (!!(err = readOHDRHeaderMessageDataFill(reader)))\n        return err;\n      break;\n    case 8: /* Data Layout Message */\n      if (!!(err = readOHDRHeaderMessageDataLayout(reader, dataobject)))\n        return err;\n      break;\n    case 10: /* Group Info Message */\n      if (!!(err = readOHDRHeaderMessageGroupInfo(reader, &dataobject->gi)))\n        return err;\n      break;\n    case 11: /* Filter Pipeline Message */\n      if (!!(err = readOHDRHeaderMessageFilterPipeline(reader)))\n        return err;\n      break;\n    case 12: /* Attribute Message */\n      if (!!(err = readOHDRHeaderMessageAttribute(reader, dataobject)))\n        return err;\n      break;\n    case 16: /* Continue Message */\n      if (!!(err = readOHDRHeaderMessageContinue(reader, dataobject)))\n        return err;\n      break;\n    case 21: /* Attribute Info Message */\n      if (!!(err = readOHDRHeaderMessageAttributeInfo(reader, &dataobject->ai)))\n        return err;\n      break;\n    default:\n      mylog(\"OHDR unknown header message of type %d\\n\", header_message_type);\n\n      return MYSOFA_UNSUPPORTED_FORMAT;\n    }\n\n    if (ftell(fhd) != end) {\n      mylog(\"OHDR message length mismatch by %ld\\n\", ftell(fhd) - end);\n      return MYSOFA_INTERNAL_ERROR;\n    }\n  }\n\n  if (fseek(fhd, end_of_messages + 4, SEEK_SET) < 0) /* skip checksum */\n    return errno;\n\n  return MYSOFA_OK;\n}\n\nstatic int readOCHK(struct READER *reader, struct DATAOBJECT *dataobject,\n                    uint64_t end) {\n  int err;\n  char buf[5];\n\n  /* read signature */\n  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"OCHK\", 4)) {\n    mylog(\"cannot read signature of OCHK\\n\");\n    return MYSOFA_INVALID_FORMAT;\n  }\n  buf[4] = 0;\n  mylog(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t)ftell(reader->fhd) - 4, buf);\n\n  err = readOHDRmessages(reader, dataobject, end - 4); /* subtract checksum */\n  if (err) {\n    return err;\n  }\n\n  return MYSOFA_OK;\n}\n\nint dataobjectRead(struct READER *reader, struct DATAOBJECT *dataobject,\n                   char *name) {\n  uint64_t size_of_chunk, end_of_messages;\n  int err;\n  char buf[5];\n\n  memset(dataobject, 0, sizeof(*dataobject));\n  dataobject->address = ftell(reader->fhd);\n  dataobject->name = name;\n\n  /* read signature */\n  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"OHDR\", 4)) {\n    mylog(\"cannot read signature of data object\\n\");\n    return MYSOFA_INVALID_FORMAT;\n  }\n  buf[4] = 0;\n  mylog(\"%08\" PRIX64 \" %.4s\\n\", dataobject->address, buf);\n\n  if (fgetc(reader->fhd) != 2) {\n    mylog(\"object OHDR must have version 2\\n\");\n    return MYSOFA_UNSUPPORTED_FORMAT;\n  }\n\n  dataobject->flags = (uint8_t)fgetc(reader->fhd);\n\n  if (dataobject->flags & (1 << 5)) {         /* bit 5 indicated time stamps */\n    if (fseek(reader->fhd, 16, SEEK_CUR) < 0) /* skip them */\n      return errno;\n  }\n\n  if (dataobject->flags & (1 << 4)) { /* bit 4 ? */\n    mylog(\"OHDR: unsupported flags bit 4: %02X\\n\", dataobject->flags);\n    return MYSOFA_UNSUPPORTED_FORMAT;\n  }\n\n  size_of_chunk = readValue(reader, 1 << (dataobject->flags & 3));\n  if (size_of_chunk > 0x1000000)\n    return MYSOFA_UNSUPPORTED_FORMAT;\n\n  end_of_messages = ftell(reader->fhd) + size_of_chunk;\n\n  err = readOHDRmessages(reader, dataobject, end_of_messages);\n\n  if (err) {\n    return err;\n  }\n\n  if (validAddress(reader, dataobject->ai.attribute_name_btree)) {\n    /* not needed\n         fseek(reader->fhd, dataobject->ai.attribute_name_btree, SEEK_SET);\n         btreeRead(reader, &dataobject->attributes);\n    */\n  }\n\n  /* parse message attribute info */\n  if (validAddress(reader, dataobject->ai.fractal_heap_address)) {\n    if (fseek(reader->fhd, dataobject->ai.fractal_heap_address, SEEK_SET) < 0)\n      return errno;\n    err = fractalheapRead(reader, dataobject, &dataobject->attributes_heap);\n    if (err)\n      return err;\n  }\n\n  /* parse message link info */\n  if (validAddress(reader, dataobject->li.fractal_heap_address)) {\n    fseek(reader->fhd, dataobject->li.fractal_heap_address, SEEK_SET);\n    err = fractalheapRead(reader, dataobject, &dataobject->objects_heap);\n    if (err)\n      return err;\n  }\n\n  if (validAddress(reader, dataobject->li.address_btree_index)) {\n    /* not needed\n       fseek(reader->fhd, dataobject->li.address_btree_index, SEEK_SET);\n       btreeRead(reader, &dataobject->objects);\n     */\n  }\n\n  dataobject->all = reader->all;\n  reader->all = dataobject;\n\n  return MYSOFA_OK;\n}\n\nvoid dataobjectFree(struct READER *reader, struct DATAOBJECT *dataobject) {\n  struct DATAOBJECT **p;\n\n  btreeFree(&dataobject->attributes_btree);\n  fractalheapFree(&dataobject->attributes_heap);\n  btreeFree(&dataobject->objects_btree);\n  fractalheapFree(&dataobject->objects_heap);\n\n  while (dataobject->attributes) {\n    struct MYSOFA_ATTRIBUTE *attr = dataobject->attributes;\n    dataobject->attributes = attr->next;\n    free(attr->name);\n    free(attr->value);\n    free(attr);\n  }\n\n  while (dataobject->directory) {\n    struct DIR *dir = dataobject->directory;\n    dataobject->directory = dir->next;\n    dataobjectFree(reader, &dir->dataobject);\n    free(dir);\n  }\n\n  free(dataobject->data);\n  free(dataobject->string);\n  free(dataobject->name);\n\n  p = &reader->all;\n  while (*p) {\n    if ((*p) == dataobject) {\n      *p = dataobject->all;\n      break;\n    }\n    p = &((*p)->all);\n  }\n}\n"], "filenames": ["src/hdf/dataobject.c"], "buggy_code_start_loc": [503], "buggy_code_end_loc": [510], "fixing_code_start_loc": [503], "fixing_code_end_loc": [514], "type": "CWE-787", "message": "libmysofa is vulnerable to Heap-based Buffer Overflow", "other": {"cve": {"id": "CVE-2021-3756", "sourceIdentifier": "security@huntr.dev", "published": "2021-10-29T16:15:07.537", "lastModified": "2021-12-22T17:37:31.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libmysofa is vulnerable to Heap-based Buffer Overflow"}, {"lang": "es", "value": "libmysofa es vulnerable al desbordamiento del b\u00fafer en la regi\u00f3n Heap de la memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.4, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:symonics:libmysofa:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.1", "matchCriteriaId": "5506C312-15EA-44AC-9D89-044863C7045C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/hoene/libmysofa/commit/890400ebd092c574707d0c132124f8ff047e20e1", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/7ca8d9ea-e2a6-4294-af28-70260bb53bc1", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PGQ45S4RH7MC42NHTAGOIHYR4C5IRTMZ/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WGY7TAZX2M4NYXXGNHIBBKKN5XMSMKQ4/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hoene/libmysofa/commit/890400ebd092c574707d0c132124f8ff047e20e1"}}