{"buggy_code": ["\"\"\"\nThis module defines the mpf, mpc classes, and standard functions for\noperating with them.\n\"\"\"\n__docformat__ = 'plaintext'\n\nimport functools\n\nimport re\n\nfrom .ctx_base import StandardBaseContext\n\nfrom .libmp.backend import basestring, BACKEND\n\nfrom . import libmp\n\nfrom .libmp import (MPZ, MPZ_ZERO, MPZ_ONE, int_types, repr_dps,\n    round_floor, round_ceiling, dps_to_prec, round_nearest, prec_to_dps,\n    ComplexResult, to_pickable, from_pickable, normalize,\n    from_int, from_float, from_str, to_int, to_float, to_str,\n    from_rational, from_man_exp,\n    fone, fzero, finf, fninf, fnan,\n    mpf_abs, mpf_pos, mpf_neg, mpf_add, mpf_sub, mpf_mul, mpf_mul_int,\n    mpf_div, mpf_rdiv_int, mpf_pow_int, mpf_mod,\n    mpf_eq, mpf_cmp, mpf_lt, mpf_gt, mpf_le, mpf_ge,\n    mpf_hash, mpf_rand,\n    mpf_sum,\n    bitcount, to_fixed,\n    mpc_to_str,\n    mpc_to_complex, mpc_hash, mpc_pos, mpc_is_nonzero, mpc_neg, mpc_conjugate,\n    mpc_abs, mpc_add, mpc_add_mpf, mpc_sub, mpc_sub_mpf, mpc_mul, mpc_mul_mpf,\n    mpc_mul_int, mpc_div, mpc_div_mpf, mpc_pow, mpc_pow_mpf, mpc_pow_int,\n    mpc_mpf_div,\n    mpf_pow,\n    mpf_pi, mpf_degree, mpf_e, mpf_phi, mpf_ln2, mpf_ln10,\n    mpf_euler, mpf_catalan, mpf_apery, mpf_khinchin,\n    mpf_glaisher, mpf_twinprime, mpf_mertens,\n    int_types)\n\nfrom . import function_docs\nfrom . import rational\n\nnew = object.__new__\n\nget_complex = re.compile(r'^\\(?(?P<re>[\\+\\-]?\\d*\\.?\\d*(e[\\+\\-]?\\d+)?)??'\n                         r'(?P<im>[\\+\\-]?\\d*\\.?\\d*(e[\\+\\-]?\\d+)?j)?\\)?$')\n\nif BACKEND == 'sage':\n    from sage.libs.mpmath.ext_main import Context as BaseMPContext\n    # pickle hack\n    import sage.libs.mpmath.ext_main as _mpf_module\nelse:\n    from .ctx_mp_python import PythonMPContext as BaseMPContext\n    from . import ctx_mp_python as _mpf_module\n\nfrom .ctx_mp_python import _mpf, _mpc, mpnumeric\n\nclass MPContext(BaseMPContext, StandardBaseContext):\n    \"\"\"\n    Context for multiprecision arithmetic with a global precision.\n    \"\"\"\n\n    def __init__(ctx):\n        BaseMPContext.__init__(ctx)\n        ctx.trap_complex = False\n        ctx.pretty = False\n        ctx.types = [ctx.mpf, ctx.mpc, ctx.constant]\n        ctx._mpq = rational.mpq\n        ctx.default()\n        StandardBaseContext.__init__(ctx)\n\n        ctx.mpq = rational.mpq\n        ctx.init_builtins()\n\n        ctx.hyp_summators = {}\n\n        ctx._init_aliases()\n\n        # XXX: automate\n        try:\n            ctx.bernoulli.im_func.func_doc = function_docs.bernoulli\n            ctx.primepi.im_func.func_doc = function_docs.primepi\n            ctx.psi.im_func.func_doc = function_docs.psi\n            ctx.atan2.im_func.func_doc = function_docs.atan2\n        except AttributeError:\n            # python 3\n            ctx.bernoulli.__func__.func_doc = function_docs.bernoulli\n            ctx.primepi.__func__.func_doc = function_docs.primepi\n            ctx.psi.__func__.func_doc = function_docs.psi\n            ctx.atan2.__func__.func_doc = function_docs.atan2\n\n        ctx.digamma.func_doc = function_docs.digamma\n        ctx.cospi.func_doc = function_docs.cospi\n        ctx.sinpi.func_doc = function_docs.sinpi\n\n    def init_builtins(ctx):\n\n        mpf = ctx.mpf\n        mpc = ctx.mpc\n\n        # Exact constants\n        ctx.one = ctx.make_mpf(fone)\n        ctx.zero = ctx.make_mpf(fzero)\n        ctx.j = ctx.make_mpc((fzero,fone))\n        ctx.inf = ctx.make_mpf(finf)\n        ctx.ninf = ctx.make_mpf(fninf)\n        ctx.nan = ctx.make_mpf(fnan)\n\n        eps = ctx.constant(lambda prec, rnd: (0, MPZ_ONE, 1-prec, 1),\n            \"epsilon of working precision\", \"eps\")\n        ctx.eps = eps\n\n        # Approximate constants\n        ctx.pi = ctx.constant(mpf_pi, \"pi\", \"pi\")\n        ctx.ln2 = ctx.constant(mpf_ln2, \"ln(2)\", \"ln2\")\n        ctx.ln10 = ctx.constant(mpf_ln10, \"ln(10)\", \"ln10\")\n        ctx.phi = ctx.constant(mpf_phi, \"Golden ratio phi\", \"phi\")\n        ctx.e = ctx.constant(mpf_e, \"e = exp(1)\", \"e\")\n        ctx.euler = ctx.constant(mpf_euler, \"Euler's constant\", \"euler\")\n        ctx.catalan = ctx.constant(mpf_catalan, \"Catalan's constant\", \"catalan\")\n        ctx.khinchin = ctx.constant(mpf_khinchin, \"Khinchin's constant\", \"khinchin\")\n        ctx.glaisher = ctx.constant(mpf_glaisher, \"Glaisher's constant\", \"glaisher\")\n        ctx.apery = ctx.constant(mpf_apery, \"Apery's constant\", \"apery\")\n        ctx.degree = ctx.constant(mpf_degree, \"1 deg = pi / 180\", \"degree\")\n        ctx.twinprime = ctx.constant(mpf_twinprime, \"Twin prime constant\", \"twinprime\")\n        ctx.mertens = ctx.constant(mpf_mertens, \"Mertens' constant\", \"mertens\")\n\n        # Standard functions\n        ctx.sqrt = ctx._wrap_libmp_function(libmp.mpf_sqrt, libmp.mpc_sqrt)\n        ctx.cbrt = ctx._wrap_libmp_function(libmp.mpf_cbrt, libmp.mpc_cbrt)\n        ctx.ln = ctx._wrap_libmp_function(libmp.mpf_log, libmp.mpc_log)\n        ctx.atan = ctx._wrap_libmp_function(libmp.mpf_atan, libmp.mpc_atan)\n        ctx.exp = ctx._wrap_libmp_function(libmp.mpf_exp, libmp.mpc_exp)\n        ctx.expj = ctx._wrap_libmp_function(libmp.mpf_expj, libmp.mpc_expj)\n        ctx.expjpi = ctx._wrap_libmp_function(libmp.mpf_expjpi, libmp.mpc_expjpi)\n        ctx.sin = ctx._wrap_libmp_function(libmp.mpf_sin, libmp.mpc_sin)\n        ctx.cos = ctx._wrap_libmp_function(libmp.mpf_cos, libmp.mpc_cos)\n        ctx.tan = ctx._wrap_libmp_function(libmp.mpf_tan, libmp.mpc_tan)\n        ctx.sinh = ctx._wrap_libmp_function(libmp.mpf_sinh, libmp.mpc_sinh)\n        ctx.cosh = ctx._wrap_libmp_function(libmp.mpf_cosh, libmp.mpc_cosh)\n        ctx.tanh = ctx._wrap_libmp_function(libmp.mpf_tanh, libmp.mpc_tanh)\n        ctx.asin = ctx._wrap_libmp_function(libmp.mpf_asin, libmp.mpc_asin)\n        ctx.acos = ctx._wrap_libmp_function(libmp.mpf_acos, libmp.mpc_acos)\n        ctx.atan = ctx._wrap_libmp_function(libmp.mpf_atan, libmp.mpc_atan)\n        ctx.asinh = ctx._wrap_libmp_function(libmp.mpf_asinh, libmp.mpc_asinh)\n        ctx.acosh = ctx._wrap_libmp_function(libmp.mpf_acosh, libmp.mpc_acosh)\n        ctx.atanh = ctx._wrap_libmp_function(libmp.mpf_atanh, libmp.mpc_atanh)\n        ctx.sinpi = ctx._wrap_libmp_function(libmp.mpf_sin_pi, libmp.mpc_sin_pi)\n        ctx.cospi = ctx._wrap_libmp_function(libmp.mpf_cos_pi, libmp.mpc_cos_pi)\n        ctx.floor = ctx._wrap_libmp_function(libmp.mpf_floor, libmp.mpc_floor)\n        ctx.ceil = ctx._wrap_libmp_function(libmp.mpf_ceil, libmp.mpc_ceil)\n        ctx.nint = ctx._wrap_libmp_function(libmp.mpf_nint, libmp.mpc_nint)\n        ctx.frac = ctx._wrap_libmp_function(libmp.mpf_frac, libmp.mpc_frac)\n        ctx.fib = ctx.fibonacci = ctx._wrap_libmp_function(libmp.mpf_fibonacci, libmp.mpc_fibonacci)\n\n        ctx.gamma = ctx._wrap_libmp_function(libmp.mpf_gamma, libmp.mpc_gamma)\n        ctx.rgamma = ctx._wrap_libmp_function(libmp.mpf_rgamma, libmp.mpc_rgamma)\n        ctx.loggamma = ctx._wrap_libmp_function(libmp.mpf_loggamma, libmp.mpc_loggamma)\n        ctx.fac = ctx.factorial = ctx._wrap_libmp_function(libmp.mpf_factorial, libmp.mpc_factorial)\n\n        ctx.digamma = ctx._wrap_libmp_function(libmp.mpf_psi0, libmp.mpc_psi0)\n        ctx.harmonic = ctx._wrap_libmp_function(libmp.mpf_harmonic, libmp.mpc_harmonic)\n        ctx.ei = ctx._wrap_libmp_function(libmp.mpf_ei, libmp.mpc_ei)\n        ctx.e1 = ctx._wrap_libmp_function(libmp.mpf_e1, libmp.mpc_e1)\n        ctx._ci = ctx._wrap_libmp_function(libmp.mpf_ci, libmp.mpc_ci)\n        ctx._si = ctx._wrap_libmp_function(libmp.mpf_si, libmp.mpc_si)\n        ctx.ellipk = ctx._wrap_libmp_function(libmp.mpf_ellipk, libmp.mpc_ellipk)\n        ctx._ellipe = ctx._wrap_libmp_function(libmp.mpf_ellipe, libmp.mpc_ellipe)\n        ctx.agm1 = ctx._wrap_libmp_function(libmp.mpf_agm1, libmp.mpc_agm1)\n        ctx._erf = ctx._wrap_libmp_function(libmp.mpf_erf, None)\n        ctx._erfc = ctx._wrap_libmp_function(libmp.mpf_erfc, None)\n        ctx._zeta = ctx._wrap_libmp_function(libmp.mpf_zeta, libmp.mpc_zeta)\n        ctx._altzeta = ctx._wrap_libmp_function(libmp.mpf_altzeta, libmp.mpc_altzeta)\n\n        # Faster versions\n        ctx.sqrt = getattr(ctx, \"_sage_sqrt\", ctx.sqrt)\n        ctx.exp = getattr(ctx, \"_sage_exp\", ctx.exp)\n        ctx.ln = getattr(ctx, \"_sage_ln\", ctx.ln)\n        ctx.cos = getattr(ctx, \"_sage_cos\", ctx.cos)\n        ctx.sin = getattr(ctx, \"_sage_sin\", ctx.sin)\n\n    def to_fixed(ctx, x, prec):\n        return x.to_fixed(prec)\n\n    def hypot(ctx, x, y):\n        r\"\"\"\n        Computes the Euclidean norm of the vector `(x, y)`, equal\n        to `\\sqrt{x^2 + y^2}`. Both `x` and `y` must be real.\"\"\"\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        return ctx.make_mpf(libmp.mpf_hypot(x._mpf_, y._mpf_, *ctx._prec_rounding))\n\n    def _gamma_upper_int(ctx, n, z):\n        n = int(ctx._re(n))\n        if n == 0:\n            return ctx.e1(z)\n        if not hasattr(z, '_mpf_'):\n            raise NotImplementedError\n        prec, rounding = ctx._prec_rounding\n        real, imag = libmp.mpf_expint(n, z._mpf_, prec, rounding, gamma=True)\n        if imag is None:\n            return ctx.make_mpf(real)\n        else:\n            return ctx.make_mpc((real, imag))\n\n    def _expint_int(ctx, n, z):\n        n = int(n)\n        if n == 1:\n            return ctx.e1(z)\n        if not hasattr(z, '_mpf_'):\n            raise NotImplementedError\n        prec, rounding = ctx._prec_rounding\n        real, imag = libmp.mpf_expint(n, z._mpf_, prec, rounding)\n        if imag is None:\n            return ctx.make_mpf(real)\n        else:\n            return ctx.make_mpc((real, imag))\n\n    def _nthroot(ctx, x, n):\n        if hasattr(x, '_mpf_'):\n            try:\n                return ctx.make_mpf(libmp.mpf_nthroot(x._mpf_, n, *ctx._prec_rounding))\n            except ComplexResult:\n                if ctx.trap_complex:\n                    raise\n                x = (x._mpf_, libmp.fzero)\n        else:\n            x = x._mpc_\n        return ctx.make_mpc(libmp.mpc_nthroot(x, n, *ctx._prec_rounding))\n\n    def _besselj(ctx, n, z):\n        prec, rounding = ctx._prec_rounding\n        if hasattr(z, '_mpf_'):\n            return ctx.make_mpf(libmp.mpf_besseljn(n, z._mpf_, prec, rounding))\n        elif hasattr(z, '_mpc_'):\n            return ctx.make_mpc(libmp.mpc_besseljn(n, z._mpc_, prec, rounding))\n\n    def _agm(ctx, a, b=1):\n        prec, rounding = ctx._prec_rounding\n        if hasattr(a, '_mpf_') and hasattr(b, '_mpf_'):\n            try:\n                v = libmp.mpf_agm(a._mpf_, b._mpf_, prec, rounding)\n                return ctx.make_mpf(v)\n            except ComplexResult:\n                pass\n        if hasattr(a, '_mpf_'): a = (a._mpf_, libmp.fzero)\n        else: a = a._mpc_\n        if hasattr(b, '_mpf_'): b = (b._mpf_, libmp.fzero)\n        else: b = b._mpc_\n        return ctx.make_mpc(libmp.mpc_agm(a, b, prec, rounding))\n\n    def bernoulli(ctx, n):\n        return ctx.make_mpf(libmp.mpf_bernoulli(int(n), *ctx._prec_rounding))\n\n    def _zeta_int(ctx, n):\n        return ctx.make_mpf(libmp.mpf_zeta_int(int(n), *ctx._prec_rounding))\n\n    def atan2(ctx, y, x):\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        return ctx.make_mpf(libmp.mpf_atan2(y._mpf_, x._mpf_, *ctx._prec_rounding))\n\n    def psi(ctx, m, z):\n        z = ctx.convert(z)\n        m = int(m)\n        if ctx._is_real_type(z):\n            return ctx.make_mpf(libmp.mpf_psi(m, z._mpf_, *ctx._prec_rounding))\n        else:\n            return ctx.make_mpc(libmp.mpc_psi(m, z._mpc_, *ctx._prec_rounding))\n\n    def cos_sin(ctx, x, **kwargs):\n        if type(x) not in ctx.types:\n            x = ctx.convert(x)\n        prec, rounding = ctx._parse_prec(kwargs)\n        if hasattr(x, '_mpf_'):\n            c, s = libmp.mpf_cos_sin(x._mpf_, prec, rounding)\n            return ctx.make_mpf(c), ctx.make_mpf(s)\n        elif hasattr(x, '_mpc_'):\n            c, s = libmp.mpc_cos_sin(x._mpc_, prec, rounding)\n            return ctx.make_mpc(c), ctx.make_mpc(s)\n        else:\n            return ctx.cos(x, **kwargs), ctx.sin(x, **kwargs)\n\n    def cospi_sinpi(ctx, x, **kwargs):\n        if type(x) not in ctx.types:\n            x = ctx.convert(x)\n        prec, rounding = ctx._parse_prec(kwargs)\n        if hasattr(x, '_mpf_'):\n            c, s = libmp.mpf_cos_sin_pi(x._mpf_, prec, rounding)\n            return ctx.make_mpf(c), ctx.make_mpf(s)\n        elif hasattr(x, '_mpc_'):\n            c, s = libmp.mpc_cos_sin_pi(x._mpc_, prec, rounding)\n            return ctx.make_mpc(c), ctx.make_mpc(s)\n        else:\n            return ctx.cos(x, **kwargs), ctx.sin(x, **kwargs)\n\n    def clone(ctx):\n        \"\"\"\n        Create a copy of the context, with the same working precision.\n        \"\"\"\n        a = ctx.__class__()\n        a.prec = ctx.prec\n        return a\n\n    # Several helper methods\n    # TODO: add more of these, make consistent, write docstrings, ...\n\n    def _is_real_type(ctx, x):\n        if hasattr(x, '_mpc_') or type(x) is complex:\n            return False\n        return True\n\n    def _is_complex_type(ctx, x):\n        if hasattr(x, '_mpc_') or type(x) is complex:\n            return True\n        return False\n\n    def isnan(ctx, x):\n        \"\"\"\n        Return *True* if *x* is a NaN (not-a-number), or for a complex\n        number, whether either the real or complex part is NaN;\n        otherwise return *False*::\n\n            >>> from mpmath import *\n            >>> isnan(3.14)\n            False\n            >>> isnan(nan)\n            True\n            >>> isnan(mpc(3.14,2.72))\n            False\n            >>> isnan(mpc(3.14,nan))\n            True\n\n        \"\"\"\n        if hasattr(x, \"_mpf_\"):\n            return x._mpf_ == fnan\n        if hasattr(x, \"_mpc_\"):\n            return fnan in x._mpc_\n        if isinstance(x, int_types) or isinstance(x, rational.mpq):\n            return False\n        x = ctx.convert(x)\n        if hasattr(x, '_mpf_') or hasattr(x, '_mpc_'):\n            return ctx.isnan(x)\n        raise TypeError(\"isnan() needs a number as input\")\n\n    def isfinite(ctx, x):\n        \"\"\"\n        Return *True* if *x* is a finite number, i.e. neither\n        an infinity or a NaN.\n\n            >>> from mpmath import *\n            >>> isfinite(inf)\n            False\n            >>> isfinite(-inf)\n            False\n            >>> isfinite(3)\n            True\n            >>> isfinite(nan)\n            False\n            >>> isfinite(3+4j)\n            True\n            >>> isfinite(mpc(3,inf))\n            False\n            >>> isfinite(mpc(nan,3))\n            False\n\n        \"\"\"\n        if ctx.isinf(x) or ctx.isnan(x):\n            return False\n        return True\n\n    def isnpint(ctx, x):\n        \"\"\"\n        Determine if *x* is a nonpositive integer.\n        \"\"\"\n        if not x:\n            return True\n        if hasattr(x, '_mpf_'):\n            sign, man, exp, bc = x._mpf_\n            return sign and exp >= 0\n        if hasattr(x, '_mpc_'):\n            return not x.imag and ctx.isnpint(x.real)\n        if type(x) in int_types:\n            return x <= 0\n        if isinstance(x, ctx.mpq):\n            p, q = x._mpq_\n            if not p:\n                return True\n            return q == 1 and p <= 0\n        return ctx.isnpint(ctx.convert(x))\n\n    def __str__(ctx):\n        lines = [\"Mpmath settings:\",\n            (\"  mp.prec = %s\" % ctx.prec).ljust(30) + \"[default: 53]\",\n            (\"  mp.dps = %s\" % ctx.dps).ljust(30) + \"[default: 15]\",\n            (\"  mp.trap_complex = %s\" % ctx.trap_complex).ljust(30) + \"[default: False]\",\n        ]\n        return \"\\n\".join(lines)\n\n    @property\n    def _repr_digits(ctx):\n        return repr_dps(ctx._prec)\n\n    @property\n    def _str_digits(ctx):\n        return ctx._dps\n\n    def extraprec(ctx, n, normalize_output=False):\n        \"\"\"\n        The block\n\n            with extraprec(n):\n                <code>\n\n        increases the precision n bits, executes <code>, and then\n        restores the precision.\n\n        extraprec(n)(f) returns a decorated version of the function f\n        that increases the working precision by n bits before execution,\n        and restores the parent precision afterwards. With\n        normalize_output=True, it rounds the return value to the parent\n        precision.\n        \"\"\"\n        return PrecisionManager(ctx, lambda p: p + n, None, normalize_output)\n\n    def extradps(ctx, n, normalize_output=False):\n        \"\"\"\n        This function is analogous to extraprec (see documentation)\n        but changes the decimal precision instead of the number of bits.\n        \"\"\"\n        return PrecisionManager(ctx, None, lambda d: d + n, normalize_output)\n\n    def workprec(ctx, n, normalize_output=False):\n        \"\"\"\n        The block\n\n            with workprec(n):\n                <code>\n\n        sets the precision to n bits, executes <code>, and then restores\n        the precision.\n\n        workprec(n)(f) returns a decorated version of the function f\n        that sets the precision to n bits before execution,\n        and restores the precision afterwards. With normalize_output=True,\n        it rounds the return value to the parent precision.\n        \"\"\"\n        return PrecisionManager(ctx, lambda p: n, None, normalize_output)\n\n    def workdps(ctx, n, normalize_output=False):\n        \"\"\"\n        This function is analogous to workprec (see documentation)\n        but changes the decimal precision instead of the number of bits.\n        \"\"\"\n        return PrecisionManager(ctx, None, lambda d: n, normalize_output)\n\n    def autoprec(ctx, f, maxprec=None, catch=(), verbose=False):\n        r\"\"\"\n        Return a wrapped copy of *f* that repeatedly evaluates *f*\n        with increasing precision until the result converges to the\n        full precision used at the point of the call.\n\n        This heuristically protects against rounding errors, at the cost of\n        roughly a 2x slowdown compared to manually setting the optimal\n        precision. This method can, however, easily be fooled if the results\n        from *f* depend \"discontinuously\" on the precision, for instance\n        if catastrophic cancellation can occur. Therefore, :func:`~mpmath.autoprec`\n        should be used judiciously.\n\n        **Examples**\n\n        Many functions are sensitive to perturbations of the input arguments.\n        If the arguments are decimal numbers, they may have to be converted\n        to binary at a much higher precision. If the amount of required\n        extra precision is unknown, :func:`~mpmath.autoprec` is convenient::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15\n            >>> mp.pretty = True\n            >>> besselj(5, 125 * 10**28)    # Exact input\n            -8.03284785591801e-17\n            >>> besselj(5, '1.25e30')   # Bad\n            7.12954868316652e-16\n            >>> autoprec(besselj)(5, '1.25e30')   # Good\n            -8.03284785591801e-17\n\n        The following fails to converge because `\\sin(\\pi) = 0` whereas all\n        finite-precision approximations of `\\pi` give nonzero values::\n\n            >>> autoprec(sin)(pi) # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n              ...\n            NoConvergence: autoprec: prec increased to 2910 without convergence\n\n        As the following example shows, :func:`~mpmath.autoprec` can protect against\n        cancellation, but is fooled by too severe cancellation::\n\n            >>> x = 1e-10\n            >>> exp(x)-1; expm1(x); autoprec(lambda t: exp(t)-1)(x)\n            1.00000008274037e-10\n            1.00000000005e-10\n            1.00000000005e-10\n            >>> x = 1e-50\n            >>> exp(x)-1; expm1(x); autoprec(lambda t: exp(t)-1)(x)\n            0.0\n            1.0e-50\n            0.0\n\n        With *catch*, an exception or list of exceptions to intercept\n        may be specified. The raised exception is interpreted\n        as signaling insufficient precision. This permits, for example,\n        evaluating a function where a too low precision results in a\n        division by zero::\n\n            >>> f = lambda x: 1/(exp(x)-1)\n            >>> f(1e-30)\n            Traceback (most recent call last):\n              ...\n            ZeroDivisionError\n            >>> autoprec(f, catch=ZeroDivisionError)(1e-30)\n            1.0e+30\n\n\n        \"\"\"\n        def f_autoprec_wrapped(*args, **kwargs):\n            prec = ctx.prec\n            if maxprec is None:\n                maxprec2 = ctx._default_hyper_maxprec(prec)\n            else:\n                maxprec2 = maxprec\n            try:\n                ctx.prec = prec + 10\n                try:\n                    v1 = f(*args, **kwargs)\n                except catch:\n                    v1 = ctx.nan\n                prec2 = prec + 20\n                while 1:\n                    ctx.prec = prec2\n                    try:\n                        v2 = f(*args, **kwargs)\n                    except catch:\n                        v2 = ctx.nan\n                    if v1 == v2:\n                        break\n                    err = ctx.mag(v2-v1) - ctx.mag(v2)\n                    if err < (-prec):\n                        break\n                    if verbose:\n                        print(\"autoprec: target=%s, prec=%s, accuracy=%s\" \\\n                            % (prec, prec2, -err))\n                    v1 = v2\n                    if prec2 >= maxprec2:\n                        raise ctx.NoConvergence(\\\n                        \"autoprec: prec increased to %i without convergence\"\\\n                        % prec2)\n                    prec2 += int(prec2*2)\n                    prec2 = min(prec2, maxprec2)\n            finally:\n                ctx.prec = prec\n            return +v2\n        return f_autoprec_wrapped\n\n    def nstr(ctx, x, n=6, **kwargs):\n        \"\"\"\n        Convert an ``mpf`` or ``mpc`` to a decimal string literal with *n*\n        significant digits. The small default value for *n* is chosen to\n        make this function useful for printing collections of numbers\n        (lists, matrices, etc).\n\n        If *x* is a list or tuple, :func:`~mpmath.nstr` is applied recursively\n        to each element. For unrecognized classes, :func:`~mpmath.nstr`\n        simply returns ``str(x)``.\n\n        The companion function :func:`~mpmath.nprint` prints the result\n        instead of returning it.\n\n        The keyword arguments *strip_zeros*, *min_fixed*, *max_fixed*\n        and *show_zero_exponent* are forwarded to :func:`~mpmath.libmp.to_str`.\n\n        The number will be printed in fixed-point format if the position\n        of the leading digit is strictly between min_fixed\n        (default = min(-dps/3,-5)) and max_fixed (default = dps).\n\n        To force fixed-point format always, set min_fixed = -inf,\n        max_fixed = +inf. To force floating-point format, set\n        min_fixed >= max_fixed.\n\n            >>> from mpmath import *\n            >>> nstr([+pi, ldexp(1,-500)])\n            '[3.14159, 3.05494e-151]'\n            >>> nprint([+pi, ldexp(1,-500)])\n            [3.14159, 3.05494e-151]\n            >>> nstr(mpf(\"5e-10\"), 5)\n            '5.0e-10'\n            >>> nstr(mpf(\"5e-10\"), 5, strip_zeros=False)\n            '5.0000e-10'\n            >>> nstr(mpf(\"5e-10\"), 5, strip_zeros=False, min_fixed=-11)\n            '0.00000000050000'\n            >>> nstr(mpf(0), 5, show_zero_exponent=True)\n            '0.0e+0'\n\n        \"\"\"\n        if isinstance(x, list):\n            return \"[%s]\" % (\", \".join(ctx.nstr(c, n, **kwargs) for c in x))\n        if isinstance(x, tuple):\n            return \"(%s)\" % (\", \".join(ctx.nstr(c, n, **kwargs) for c in x))\n        if hasattr(x, '_mpf_'):\n            return to_str(x._mpf_, n, **kwargs)\n        if hasattr(x, '_mpc_'):\n            return \"(\" + mpc_to_str(x._mpc_, n, **kwargs)  + \")\"\n        if isinstance(x, basestring):\n            return repr(x)\n        if isinstance(x, ctx.matrix):\n            return x.__nstr__(n, **kwargs)\n        return str(x)\n\n    def _convert_fallback(ctx, x, strings):\n        if strings and isinstance(x, basestring):\n            if 'j' in x.lower():\n                x = x.lower().replace(' ', '')\n                match = get_complex.match(x)\n                re = match.group('re')\n                if not re:\n                    re = 0\n                im = match.group('im').rstrip('j')\n                return ctx.mpc(ctx.convert(re), ctx.convert(im))\n        if hasattr(x, \"_mpi_\"):\n            a, b = x._mpi_\n            if a == b:\n                return ctx.make_mpf(a)\n            else:\n                raise ValueError(\"can only create mpf from zero-width interval\")\n        raise TypeError(\"cannot create mpf from \" + repr(x))\n\n    def mpmathify(ctx, *args, **kwargs):\n        return ctx.convert(*args, **kwargs)\n\n    def _parse_prec(ctx, kwargs):\n        if kwargs:\n            if kwargs.get('exact'):\n                return 0, 'f'\n            prec, rounding = ctx._prec_rounding\n            if 'rounding' in kwargs:\n                rounding = kwargs['rounding']\n            if 'prec' in kwargs:\n                prec = kwargs['prec']\n                if prec == ctx.inf:\n                    return 0, 'f'\n                else:\n                    prec = int(prec)\n            elif 'dps' in kwargs:\n                dps = kwargs['dps']\n                if dps == ctx.inf:\n                    return 0, 'f'\n                prec = dps_to_prec(dps)\n            return prec, rounding\n        return ctx._prec_rounding\n\n    _exact_overflow_msg = \"the exact result does not fit in memory\"\n\n    _hypsum_msg = \"\"\"hypsum() failed to converge to the requested %i bits of accuracy\nusing a working precision of %i bits. Try with a higher maxprec,\nmaxterms, or set zeroprec.\"\"\"\n\n    def hypsum(ctx, p, q, flags, coeffs, z, accurate_small=True, **kwargs):\n        if hasattr(z, \"_mpf_\"):\n            key = p, q, flags, 'R'\n            v = z._mpf_\n        elif hasattr(z, \"_mpc_\"):\n            key = p, q, flags, 'C'\n            v = z._mpc_\n        if key not in ctx.hyp_summators:\n            ctx.hyp_summators[key] = libmp.make_hyp_summator(key)[1]\n        summator = ctx.hyp_summators[key]\n        prec = ctx.prec\n        maxprec = kwargs.get('maxprec', ctx._default_hyper_maxprec(prec))\n        extraprec = 50\n        epsshift = 25\n        # Jumps in magnitude occur when parameters are close to negative\n        # integers. We must ensure that these terms are included in\n        # the sum and added accurately\n        magnitude_check = {}\n        max_total_jump = 0\n        for i, c in enumerate(coeffs):\n            if flags[i] == 'Z':\n                if i >= p and c <= 0:\n                    ok = False\n                    for ii, cc in enumerate(coeffs[:p]):\n                        # Note: c <= cc or c < cc, depending on convention\n                        if flags[ii] == 'Z' and cc <= 0 and c <= cc:\n                            ok = True\n                    if not ok:\n                        raise ZeroDivisionError(\"pole in hypergeometric series\")\n                continue\n            n, d = ctx.nint_distance(c)\n            n = -int(n)\n            d = -d\n            if i >= p and n >= 0 and d > 4:\n                if n in magnitude_check:\n                    magnitude_check[n] += d\n                else:\n                    magnitude_check[n] = d\n                extraprec = max(extraprec, d - prec + 60)\n            max_total_jump += abs(d)\n        while 1:\n            if extraprec > maxprec:\n                raise ValueError(ctx._hypsum_msg % (prec, prec+extraprec))\n            wp = prec + extraprec\n            if magnitude_check:\n                mag_dict = dict((n,None) for n in magnitude_check)\n            else:\n                mag_dict = {}\n            zv, have_complex, magnitude = summator(coeffs, v, prec, wp, \\\n                epsshift, mag_dict, **kwargs)\n            cancel = -magnitude\n            jumps_resolved = True\n            if extraprec < max_total_jump:\n                for n in mag_dict.values():\n                    if (n is None) or (n < prec):\n                        jumps_resolved = False\n                        break\n            accurate = (cancel < extraprec-25-5 or not accurate_small)\n            if jumps_resolved:\n                if accurate:\n                    break\n                # zero?\n                zeroprec = kwargs.get('zeroprec')\n                if zeroprec is not None:\n                    if cancel > zeroprec:\n                        if have_complex:\n                            return ctx.mpc(0)\n                        else:\n                            return ctx.zero\n\n            # Some near-singularities were not included, so increase\n            # precision and repeat until they are\n            extraprec *= 2\n            # Possible workaround for bad roundoff in fixed-point arithmetic\n            epsshift += 5\n            extraprec += 5\n\n        if type(zv) is tuple:\n            if have_complex:\n                return ctx.make_mpc(zv)\n            else:\n                return ctx.make_mpf(zv)\n        else:\n            return zv\n\n    def ldexp(ctx, x, n):\n        r\"\"\"\n        Computes `x 2^n` efficiently. No rounding is performed.\n        The argument `x` must be a real floating-point number (or\n        possible to convert into one) and `n` must be a Python ``int``.\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> ldexp(1, 10)\n            mpf('1024.0')\n            >>> ldexp(1, -3)\n            mpf('0.125')\n\n        \"\"\"\n        x = ctx.convert(x)\n        return ctx.make_mpf(libmp.mpf_shift(x._mpf_, n))\n\n    def frexp(ctx, x):\n        r\"\"\"\n        Given a real number `x`, returns `(y, n)` with `y \\in [0.5, 1)`,\n        `n` a Python integer, and such that `x = y 2^n`. No rounding is\n        performed.\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> frexp(7.5)\n            (mpf('0.9375'), 3)\n\n        \"\"\"\n        x = ctx.convert(x)\n        y, n = libmp.mpf_frexp(x._mpf_)\n        return ctx.make_mpf(y), n\n\n    def fneg(ctx, x, **kwargs):\n        \"\"\"\n        Negates the number *x*, giving a floating-point result, optionally\n        using a custom precision and rounding mode.\n\n        See the documentation of :func:`~mpmath.fadd` for a detailed description\n        of how to specify precision and rounding.\n\n        **Examples**\n\n        An mpmath number is returned::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fneg(2.5)\n            mpf('-2.5')\n            >>> fneg(-5+2j)\n            mpc(real='5.0', imag='-2.0')\n\n        Precise control over rounding is possible::\n\n            >>> x = fadd(2, 1e-100, exact=True)\n            >>> fneg(x)\n            mpf('-2.0')\n            >>> fneg(x, rounding='f')\n            mpf('-2.0000000000000004')\n\n        Negating with and without roundoff::\n\n            >>> n = 200000000000000000000001\n            >>> print(int(-mpf(n)))\n            -200000000000000016777216\n            >>> print(int(fneg(n)))\n            -200000000000000016777216\n            >>> print(int(fneg(n, prec=log(n,2)+1)))\n            -200000000000000000000001\n            >>> print(int(fneg(n, dps=log(n,10)+1)))\n            -200000000000000000000001\n            >>> print(int(fneg(n, prec=inf)))\n            -200000000000000000000001\n            >>> print(int(fneg(n, dps=inf)))\n            -200000000000000000000001\n            >>> print(int(fneg(n, exact=True)))\n            -200000000000000000000001\n\n        \"\"\"\n        prec, rounding = ctx._parse_prec(kwargs)\n        x = ctx.convert(x)\n        if hasattr(x, '_mpf_'):\n            return ctx.make_mpf(mpf_neg(x._mpf_, prec, rounding))\n        if hasattr(x, '_mpc_'):\n            return ctx.make_mpc(mpc_neg(x._mpc_, prec, rounding))\n        raise ValueError(\"Arguments need to be mpf or mpc compatible numbers\")\n\n    def fadd(ctx, x, y, **kwargs):\n        \"\"\"\n        Adds the numbers *x* and *y*, giving a floating-point result,\n        optionally using a custom precision and rounding mode.\n\n        The default precision is the working precision of the context.\n        You can specify a custom precision in bits by passing the *prec* keyword\n        argument, or by providing an equivalent decimal precision with the *dps*\n        keyword argument. If the precision is set to ``+inf``, or if the flag\n        *exact=True* is passed, an exact addition with no rounding is performed.\n\n        When the precision is finite, the optional *rounding* keyword argument\n        specifies the direction of rounding. Valid options are ``'n'`` for\n        nearest (default), ``'f'`` for floor, ``'c'`` for ceiling, ``'d'``\n        for down, ``'u'`` for up.\n\n        **Examples**\n\n        Using :func:`~mpmath.fadd` with precision and rounding control::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fadd(2, 1e-20)\n            mpf('2.0')\n            >>> fadd(2, 1e-20, rounding='u')\n            mpf('2.0000000000000004')\n            >>> nprint(fadd(2, 1e-20, prec=100), 25)\n            2.00000000000000000001\n            >>> nprint(fadd(2, 1e-20, dps=15), 25)\n            2.0\n            >>> nprint(fadd(2, 1e-20, dps=25), 25)\n            2.00000000000000000001\n            >>> nprint(fadd(2, 1e-20, exact=True), 25)\n            2.00000000000000000001\n\n        Exact addition avoids cancellation errors, enforcing familiar laws\n        of numbers such as `x+y-x = y`, which don't hold in floating-point\n        arithmetic with finite precision::\n\n            >>> x, y = mpf(2), mpf('1e-1000')\n            >>> print(x + y - x)\n            0.0\n            >>> print(fadd(x, y, prec=inf) - x)\n            1.0e-1000\n            >>> print(fadd(x, y, exact=True) - x)\n            1.0e-1000\n\n        Exact addition can be inefficient and may be impossible to perform\n        with large magnitude differences::\n\n            >>> fadd(1, '1e-100000000000000000000', prec=inf)\n            Traceback (most recent call last):\n              ...\n            OverflowError: the exact result does not fit in memory\n\n        \"\"\"\n        prec, rounding = ctx._parse_prec(kwargs)\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        try:\n            if hasattr(x, '_mpf_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpf(mpf_add(x._mpf_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_add_mpf(y._mpc_, x._mpf_, prec, rounding))\n            if hasattr(x, '_mpc_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpc(mpc_add_mpf(x._mpc_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_add(x._mpc_, y._mpc_, prec, rounding))\n        except (ValueError, OverflowError):\n            raise OverflowError(ctx._exact_overflow_msg)\n        raise ValueError(\"Arguments need to be mpf or mpc compatible numbers\")\n\n    def fsub(ctx, x, y, **kwargs):\n        \"\"\"\n        Subtracts the numbers *x* and *y*, giving a floating-point result,\n        optionally using a custom precision and rounding mode.\n\n        See the documentation of :func:`~mpmath.fadd` for a detailed description\n        of how to specify precision and rounding.\n\n        **Examples**\n\n        Using :func:`~mpmath.fsub` with precision and rounding control::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fsub(2, 1e-20)\n            mpf('2.0')\n            >>> fsub(2, 1e-20, rounding='d')\n            mpf('1.9999999999999998')\n            >>> nprint(fsub(2, 1e-20, prec=100), 25)\n            1.99999999999999999999\n            >>> nprint(fsub(2, 1e-20, dps=15), 25)\n            2.0\n            >>> nprint(fsub(2, 1e-20, dps=25), 25)\n            1.99999999999999999999\n            >>> nprint(fsub(2, 1e-20, exact=True), 25)\n            1.99999999999999999999\n\n        Exact subtraction avoids cancellation errors, enforcing familiar laws\n        of numbers such as `x-y+y = x`, which don't hold in floating-point\n        arithmetic with finite precision::\n\n            >>> x, y = mpf(2), mpf('1e1000')\n            >>> print(x - y + y)\n            0.0\n            >>> print(fsub(x, y, prec=inf) + y)\n            2.0\n            >>> print(fsub(x, y, exact=True) + y)\n            2.0\n\n        Exact addition can be inefficient and may be impossible to perform\n        with large magnitude differences::\n\n            >>> fsub(1, '1e-100000000000000000000', prec=inf)\n            Traceback (most recent call last):\n              ...\n            OverflowError: the exact result does not fit in memory\n\n        \"\"\"\n        prec, rounding = ctx._parse_prec(kwargs)\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        try:\n            if hasattr(x, '_mpf_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpf(mpf_sub(x._mpf_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_sub((x._mpf_, fzero), y._mpc_, prec, rounding))\n            if hasattr(x, '_mpc_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpc(mpc_sub_mpf(x._mpc_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_sub(x._mpc_, y._mpc_, prec, rounding))\n        except (ValueError, OverflowError):\n            raise OverflowError(ctx._exact_overflow_msg)\n        raise ValueError(\"Arguments need to be mpf or mpc compatible numbers\")\n\n    def fmul(ctx, x, y, **kwargs):\n        \"\"\"\n        Multiplies the numbers *x* and *y*, giving a floating-point result,\n        optionally using a custom precision and rounding mode.\n\n        See the documentation of :func:`~mpmath.fadd` for a detailed description\n        of how to specify precision and rounding.\n\n        **Examples**\n\n        The result is an mpmath number::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fmul(2, 5.0)\n            mpf('10.0')\n            >>> fmul(0.5j, 0.5)\n            mpc(real='0.0', imag='0.25')\n\n        Avoiding roundoff::\n\n            >>> x, y = 10**10+1, 10**15+1\n            >>> print(x*y)\n            10000000001000010000000001\n            >>> print(mpf(x) * mpf(y))\n            1.0000000001e+25\n            >>> print(int(mpf(x) * mpf(y)))\n            10000000001000011026399232\n            >>> print(int(fmul(x, y)))\n            10000000001000011026399232\n            >>> print(int(fmul(x, y, dps=25)))\n            10000000001000010000000001\n            >>> print(int(fmul(x, y, exact=True)))\n            10000000001000010000000001\n\n        Exact multiplication with complex numbers can be inefficient and may\n        be impossible to perform with large magnitude differences between\n        real and imaginary parts::\n\n            >>> x = 1+2j\n            >>> y = mpc(2, '1e-100000000000000000000')\n            >>> fmul(x, y)\n            mpc(real='2.0', imag='4.0')\n            >>> fmul(x, y, rounding='u')\n            mpc(real='2.0', imag='4.0000000000000009')\n            >>> fmul(x, y, exact=True)\n            Traceback (most recent call last):\n              ...\n            OverflowError: the exact result does not fit in memory\n\n        \"\"\"\n        prec, rounding = ctx._parse_prec(kwargs)\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        try:\n            if hasattr(x, '_mpf_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpf(mpf_mul(x._mpf_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_mul_mpf(y._mpc_, x._mpf_, prec, rounding))\n            if hasattr(x, '_mpc_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpc(mpc_mul_mpf(x._mpc_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_mul(x._mpc_, y._mpc_, prec, rounding))\n        except (ValueError, OverflowError):\n            raise OverflowError(ctx._exact_overflow_msg)\n        raise ValueError(\"Arguments need to be mpf or mpc compatible numbers\")\n\n    def fdiv(ctx, x, y, **kwargs):\n        \"\"\"\n        Divides the numbers *x* and *y*, giving a floating-point result,\n        optionally using a custom precision and rounding mode.\n\n        See the documentation of :func:`~mpmath.fadd` for a detailed description\n        of how to specify precision and rounding.\n\n        **Examples**\n\n        The result is an mpmath number::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fdiv(3, 2)\n            mpf('1.5')\n            >>> fdiv(2, 3)\n            mpf('0.66666666666666663')\n            >>> fdiv(2+4j, 0.5)\n            mpc(real='4.0', imag='8.0')\n\n        The rounding direction and precision can be controlled::\n\n            >>> fdiv(2, 3, dps=3)    # Should be accurate to at least 3 digits\n            mpf('0.6666259765625')\n            >>> fdiv(2, 3, rounding='d')\n            mpf('0.66666666666666663')\n            >>> fdiv(2, 3, prec=60)\n            mpf('0.66666666666666667')\n            >>> fdiv(2, 3, rounding='u')\n            mpf('0.66666666666666674')\n\n        Checking the error of a division by performing it at higher precision::\n\n            >>> fdiv(2, 3) - fdiv(2, 3, prec=100)\n            mpf('-3.7007434154172148e-17')\n\n        Unlike :func:`~mpmath.fadd`, :func:`~mpmath.fmul`, etc., exact division is not\n        allowed since the quotient of two floating-point numbers generally\n        does not have an exact floating-point representation. (In the\n        future this might be changed to allow the case where the division\n        is actually exact.)\n\n            >>> fdiv(2, 3, exact=True)\n            Traceback (most recent call last):\n              ...\n            ValueError: division is not an exact operation\n\n        \"\"\"\n        prec, rounding = ctx._parse_prec(kwargs)\n        if not prec:\n            raise ValueError(\"division is not an exact operation\")\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        if hasattr(x, '_mpf_'):\n            if hasattr(y, '_mpf_'):\n                return ctx.make_mpf(mpf_div(x._mpf_, y._mpf_, prec, rounding))\n            if hasattr(y, '_mpc_'):\n                return ctx.make_mpc(mpc_div((x._mpf_, fzero), y._mpc_, prec, rounding))\n        if hasattr(x, '_mpc_'):\n            if hasattr(y, '_mpf_'):\n                return ctx.make_mpc(mpc_div_mpf(x._mpc_, y._mpf_, prec, rounding))\n            if hasattr(y, '_mpc_'):\n                return ctx.make_mpc(mpc_div(x._mpc_, y._mpc_, prec, rounding))\n        raise ValueError(\"Arguments need to be mpf or mpc compatible numbers\")\n\n    def nint_distance(ctx, x):\n        r\"\"\"\n        Return `(n,d)` where `n` is the nearest integer to `x` and `d` is\n        an estimate of `\\log_2(|x-n|)`. If `d < 0`, `-d` gives the precision\n        (measured in bits) lost to cancellation when computing `x-n`.\n\n            >>> from mpmath import *\n            >>> n, d = nint_distance(5)\n            >>> print(n); print(d)\n            5\n            -inf\n            >>> n, d = nint_distance(mpf(5))\n            >>> print(n); print(d)\n            5\n            -inf\n            >>> n, d = nint_distance(mpf(5.00000001))\n            >>> print(n); print(d)\n            5\n            -26\n            >>> n, d = nint_distance(mpf(4.99999999))\n            >>> print(n); print(d)\n            5\n            -26\n            >>> n, d = nint_distance(mpc(5,10))\n            >>> print(n); print(d)\n            5\n            4\n            >>> n, d = nint_distance(mpc(5,0.000001))\n            >>> print(n); print(d)\n            5\n            -19\n\n        \"\"\"\n        typx = type(x)\n        if typx in int_types:\n            return int(x), ctx.ninf\n        elif typx is rational.mpq:\n            p, q = x._mpq_\n            n, r = divmod(p, q)\n            if 2*r >= q:\n                n += 1\n            elif not r:\n                return n, ctx.ninf\n            # log(p/q-n) = log((p-nq)/q) = log(p-nq) - log(q)\n            d = bitcount(abs(p-n*q)) - bitcount(q)\n            return n, d\n        if hasattr(x, \"_mpf_\"):\n            re = x._mpf_\n            im_dist = ctx.ninf\n        elif hasattr(x, \"_mpc_\"):\n            re, im = x._mpc_\n            isign, iman, iexp, ibc = im\n            if iman:\n                im_dist = iexp + ibc\n            elif im == fzero:\n                im_dist = ctx.ninf\n            else:\n                raise ValueError(\"requires a finite number\")\n        else:\n            x = ctx.convert(x)\n            if hasattr(x, \"_mpf_\") or hasattr(x, \"_mpc_\"):\n                return ctx.nint_distance(x)\n            else:\n                raise TypeError(\"requires an mpf/mpc\")\n        sign, man, exp, bc = re\n        mag = exp+bc\n        # |x| < 0.5\n        if mag < 0:\n            n = 0\n            re_dist = mag\n        elif man:\n            # exact integer\n            if exp >= 0:\n                n = man << exp\n                re_dist = ctx.ninf\n            # exact half-integer\n            elif exp == -1:\n                n = (man>>1)+1\n                re_dist = 0\n            else:\n                d = (-exp-1)\n                t = man >> d\n                if t & 1:\n                    t += 1\n                    man = (t<<d) - man\n                else:\n                    man -= (t<<d)\n                n = t>>1   # int(t)>>1\n                re_dist = exp+bitcount(man)\n            if sign:\n                n = -n\n        elif re == fzero:\n            re_dist = ctx.ninf\n            n = 0\n        else:\n            raise ValueError(\"requires a finite number\")\n        return n, max(re_dist, im_dist)\n\n    def fprod(ctx, factors):\n        r\"\"\"\n        Calculates a product containing a finite number of factors (for\n        infinite products, see :func:`~mpmath.nprod`). The factors will be\n        converted to mpmath numbers.\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fprod([1, 2, 0.5, 7])\n            mpf('7.0')\n\n        \"\"\"\n        orig = ctx.prec\n        try:\n            v = ctx.one\n            for p in factors:\n                v *= p\n        finally:\n            ctx.prec = orig\n        return +v\n\n    def rand(ctx):\n        \"\"\"\n        Returns an ``mpf`` with value chosen randomly from `[0, 1)`.\n        The number of randomly generated bits in the mantissa is equal\n        to the working precision.\n        \"\"\"\n        return ctx.make_mpf(mpf_rand(ctx._prec))\n\n    def fraction(ctx, p, q):\n        \"\"\"\n        Given Python integers `(p, q)`, returns a lazy ``mpf`` representing\n        the fraction `p/q`. The value is updated with the precision.\n\n            >>> from mpmath import *\n            >>> mp.dps = 15\n            >>> a = fraction(1,100)\n            >>> b = mpf(1)/100\n            >>> print(a); print(b)\n            0.01\n            0.01\n            >>> mp.dps = 30\n            >>> print(a); print(b)      # a will be accurate\n            0.01\n            0.0100000000000000002081668171172\n            >>> mp.dps = 15\n        \"\"\"\n        return ctx.constant(lambda prec, rnd: from_rational(p, q, prec, rnd),\n            '%s/%s' % (p, q))\n\n    def absmin(ctx, x):\n        return abs(ctx.convert(x))\n\n    def absmax(ctx, x):\n        return abs(ctx.convert(x))\n\n    def _as_points(ctx, x):\n        # XXX: remove this?\n        if hasattr(x, '_mpi_'):\n            a, b = x._mpi_\n            return [ctx.make_mpf(a), ctx.make_mpf(b)]\n        return x\n\n    '''\n    def _zetasum(ctx, s, a, b):\n        \"\"\"\n        Computes sum of k^(-s) for k = a, a+1, ..., b with a, b both small\n        integers.\n        \"\"\"\n        a = int(a)\n        b = int(b)\n        s = ctx.convert(s)\n        prec, rounding = ctx._prec_rounding\n        if hasattr(s, '_mpf_'):\n            v = ctx.make_mpf(libmp.mpf_zetasum(s._mpf_, a, b, prec))\n        elif hasattr(s, '_mpc_'):\n            v = ctx.make_mpc(libmp.mpc_zetasum(s._mpc_, a, b, prec))\n        return v\n    '''\n\n    def _zetasum_fast(ctx, s, a, n, derivatives=[0], reflect=False):\n        if not (ctx.isint(a) and hasattr(s, \"_mpc_\")):\n            raise NotImplementedError\n        a = int(a)\n        prec = ctx._prec\n        xs, ys = libmp.mpc_zetasum(s._mpc_, a, n, derivatives, reflect, prec)\n        xs = [ctx.make_mpc(x) for x in xs]\n        ys = [ctx.make_mpc(y) for y in ys]\n        return xs, ys\n\nclass PrecisionManager:\n    def __init__(self, ctx, precfun, dpsfun, normalize_output=False):\n        self.ctx = ctx\n        self.precfun = precfun\n        self.dpsfun = dpsfun\n        self.normalize_output = normalize_output\n    def __call__(self, f):\n        @functools.wraps(f)\n        def g(*args, **kwargs):\n            orig = self.ctx.prec\n            try:\n                if self.precfun:\n                    self.ctx.prec = self.precfun(self.ctx.prec)\n                else:\n                    self.ctx.dps = self.dpsfun(self.ctx.dps)\n                if self.normalize_output:\n                    v = f(*args, **kwargs)\n                    if type(v) is tuple:\n                        return tuple([+a for a in v])\n                    return +v\n                else:\n                    return f(*args, **kwargs)\n            finally:\n                self.ctx.prec = orig\n        return g\n    def __enter__(self):\n        self.origp = self.ctx.prec\n        if self.precfun:\n            self.ctx.prec = self.precfun(self.ctx.prec)\n        else:\n            self.ctx.dps = self.dpsfun(self.ctx.dps)\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.ctx.prec = self.origp\n        return False\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n", "import random\nfrom mpmath import *\nfrom mpmath.libmp import *\n\n\ndef test_basic_string():\n    \"\"\"\n    Test basic string conversion\n    \"\"\"\n    mp.dps = 15\n    assert mpf('3') == mpf('3.0') == mpf('0003.') == mpf('0.03e2') == mpf(3.0)\n    assert mpf('30') == mpf('30.0') == mpf('00030.') == mpf(30.0)\n    for i in range(10):\n        for j in range(10):\n            assert mpf('%ie%i' % (i,j)) == i * 10**j\n    assert str(mpf('25000.0')) == '25000.0'\n    assert str(mpf('2500.0')) == '2500.0'\n    assert str(mpf('250.0')) == '250.0'\n    assert str(mpf('25.0')) == '25.0'\n    assert str(mpf('2.5')) == '2.5'\n    assert str(mpf('0.25')) == '0.25'\n    assert str(mpf('0.025')) == '0.025'\n    assert str(mpf('0.0025')) == '0.0025'\n    assert str(mpf('0.00025')) == '0.00025'\n    assert str(mpf('0.000025')) == '2.5e-5'\n    assert str(mpf(0)) == '0.0'\n    assert str(mpf('2.5e1000000000000000000000')) == '2.5e+1000000000000000000000'\n    assert str(mpf('2.6e-1000000000000000000000')) == '2.6e-1000000000000000000000'\n    assert str(mpf(1.23402834e-15)) == '1.23402834e-15'\n    assert str(mpf(-1.23402834e-15)) == '-1.23402834e-15'\n    assert str(mpf(-1.2344e-15)) == '-1.2344e-15'\n    assert repr(mpf(-1.2344e-15)) == \"mpf('-1.2343999999999999e-15')\"\n    assert str(mpf(\"2163048125L\")) == '2163048125.0'\n    assert str(mpf(\"-2163048125l\")) == '-2163048125.0'\n    assert str(mpf(\"-2163048125L/1088391168\")) == '-1.98738118113799'\n    assert str(mpf(\"2163048125/1088391168l\")) == '1.98738118113799'\n\ndef test_pretty():\n    mp.pretty = True\n    assert repr(mpf(2.5)) == '2.5'\n    assert repr(mpc(2.5,3.5)) == '(2.5 + 3.5j)'\n    mp.pretty = False\n    iv.pretty = True\n    assert repr(mpi(2.5,3.5)) == '[2.5, 3.5]'\n    iv.pretty = False\n\ndef test_str_whitespace():\n    assert mpf('1.26 ') == 1.26\n\ndef test_unicode():\n    mp.dps = 15\n    try:\n        unicode = unicode\n    except NameError:\n        unicode = str\n    assert mpf(unicode('2.76')) == 2.76\n    assert mpf(unicode('inf')) == inf\n\ndef test_str_format():\n    assert to_str(from_float(0.1),15,strip_zeros=False) == '0.100000000000000'\n    assert to_str(from_float(0.0),15,show_zero_exponent=True) == '0.0e+0'\n    assert to_str(from_float(0.0),0,show_zero_exponent=True) == '.0e+0'\n    assert to_str(from_float(0.0),0,show_zero_exponent=False) == '.0'\n    assert to_str(from_float(0.0),1,show_zero_exponent=True) == '0.0e+0'\n    assert to_str(from_float(0.0),1,show_zero_exponent=False) == '0.0'\n    assert to_str(from_float(1.23),3,show_zero_exponent=True) == '1.23e+0'\n    assert to_str(from_float(1.23456789000000e-2),15,strip_zeros=False,min_fixed=0,max_fixed=0) == '1.23456789000000e-2'\n    assert to_str(from_float(1.23456789000000e+2),15,strip_zeros=False,min_fixed=0,max_fixed=0) == '1.23456789000000e+2'\n    assert to_str(from_float(2.1287e14), 15, max_fixed=1000) == '212870000000000.0'\n    assert to_str(from_float(2.1287e15), 15, max_fixed=1000) == '2128700000000000.0'\n    assert to_str(from_float(2.1287e16), 15, max_fixed=1000) == '21287000000000000.0'\n    assert to_str(from_float(2.1287e30), 15, max_fixed=1000) == '2128700000000000000000000000000.0'\n\ndef test_tight_string_conversion():\n    mp.dps = 15\n    # In an old version, '0.5' wasn't recognized as representing\n    # an exact binary number and was erroneously rounded up or down\n    assert from_str('0.5', 10, round_floor) == fhalf\n    assert from_str('0.5', 10, round_ceiling) == fhalf\n\ndef test_eval_repr_invariant():\n    \"\"\"Test that eval(repr(x)) == x\"\"\"\n    random.seed(123)\n    for dps in [10, 15, 20, 50, 100]:\n        mp.dps = dps\n        for i in range(1000):\n            a = mpf(random.random())**0.5 * 10**random.randint(-100, 100)\n            assert eval(repr(a)) == a\n    mp.dps = 15\n\ndef test_str_bugs():\n    mp.dps = 15\n    # Decimal rounding used to give the wrong exponent in some cases\n    assert str(mpf('1e600')) == '1.0e+600'\n    assert str(mpf('1e10000')) == '1.0e+10000'\n\ndef test_str_prec0():\n    assert to_str(from_float(1.234), 0) == '.0e+0'\n    assert to_str(from_float(1e-15), 0) == '.0e-15'\n    assert to_str(from_float(1e+15), 0) == '.0e+15'\n    assert to_str(from_float(-1e-15), 0) == '-.0e-15'\n    assert to_str(from_float(-1e+15), 0) == '-.0e+15'\n\ndef test_convert_rational():\n    mp.dps = 15\n    assert from_rational(30, 5, 53, round_nearest) == (0, 3, 1, 2)\n    assert from_rational(-7, 4, 53, round_nearest) == (1, 7, -2, 3)\n    assert to_rational((0, 1, -1, 1)) == (1, 2)\n\ndef test_custom_class():\n    class mympf:\n        @property\n        def _mpf_(self):\n            return mpf(3.5)._mpf_\n    class mympc:\n        @property\n        def _mpc_(self):\n            return mpf(3.5)._mpf_, mpf(2.5)._mpf_\n    assert mpf(2) + mympf() == 5.5\n    assert mympf() + mpf(2) == 5.5\n    assert mpf(mympf()) == 3.5\n    assert mympc() + mpc(2) == mpc(5.5, 2.5)\n    assert mpc(2) + mympc() == mpc(5.5, 2.5)\n    assert mpc(mympc()) == (3.5+2.5j)\n\ndef test_conversion_methods():\n    class SomethingRandom:\n        pass\n    class SomethingReal:\n        def _mpmath_(self, prec, rounding):\n            return mp.make_mpf(from_str('1.3', prec, rounding))\n    class SomethingComplex:\n        def _mpmath_(self, prec, rounding):\n            return mp.make_mpc((from_str('1.3', prec, rounding), \\\n                from_str('1.7', prec, rounding)))\n    x = mpf(3)\n    z = mpc(3)\n    a = SomethingRandom()\n    y = SomethingReal()\n    w = SomethingComplex()\n    for d in [15, 45]:\n        mp.dps = d\n        assert (x+y).ae(mpf('4.3'))\n        assert (y+x).ae(mpf('4.3'))\n        assert (x+w).ae(mpc('4.3', '1.7'))\n        assert (w+x).ae(mpc('4.3', '1.7'))\n        assert (z+y).ae(mpc('4.3'))\n        assert (y+z).ae(mpc('4.3'))\n        assert (z+w).ae(mpc('4.3', '1.7'))\n        assert (w+z).ae(mpc('4.3', '1.7'))\n        x-y; y-x; x-w; w-x; z-y; y-z; z-w; w-z\n        x*y; y*x; x*w; w*x; z*y; y*z; z*w; w*z\n        x/y; y/x; x/w; w/x; z/y; y/z; z/w; w/z\n        x**y; y**x; x**w; w**x; z**y; y**z; z**w; w**z\n        x==y; y==x; x==w; w==x; z==y; y==z; z==w; w==z\n    mp.dps = 15\n    assert x.__add__(a) is NotImplemented\n    assert x.__radd__(a) is NotImplemented\n    assert x.__lt__(a) is NotImplemented\n    assert x.__gt__(a) is NotImplemented\n    assert x.__le__(a) is NotImplemented\n    assert x.__ge__(a) is NotImplemented\n    assert x.__eq__(a) is NotImplemented\n    assert x.__ne__(a) is NotImplemented\n    # implementation detail\n    if hasattr(x, \"__cmp__\"):\n        assert x.__cmp__(a) is NotImplemented\n    assert x.__sub__(a) is NotImplemented\n    assert x.__rsub__(a) is NotImplemented\n    assert x.__mul__(a) is NotImplemented\n    assert x.__rmul__(a) is NotImplemented\n    assert x.__div__(a) is NotImplemented\n    assert x.__rdiv__(a) is NotImplemented\n    assert x.__mod__(a) is NotImplemented\n    assert x.__rmod__(a) is NotImplemented\n    assert x.__pow__(a) is NotImplemented\n    assert x.__rpow__(a) is NotImplemented\n    assert z.__add__(a) is NotImplemented\n    assert z.__radd__(a) is NotImplemented\n    assert z.__eq__(a) is NotImplemented\n    assert z.__ne__(a) is NotImplemented\n    assert z.__sub__(a) is NotImplemented\n    assert z.__rsub__(a) is NotImplemented\n    assert z.__mul__(a) is NotImplemented\n    assert z.__rmul__(a) is NotImplemented\n    assert z.__div__(a) is NotImplemented\n    assert z.__rdiv__(a) is NotImplemented\n    assert z.__pow__(a) is NotImplemented\n    assert z.__rpow__(a) is NotImplemented\n\ndef test_mpmathify():\n    assert mpmathify('1/2') == 0.5\n    assert mpmathify('(1.0+1.0j)') == mpc(1, 1)\n    assert mpmathify('(1.2e-10 - 3.4e5j)') == mpc('1.2e-10', '-3.4e5')\n    assert mpmathify('1j') == mpc(1j)\n\ndef test_compatibility():\n    try:\n        import numpy as np\n        from fractions import Fraction\n        from decimal import Decimal\n        import decimal\n    except ImportError:\n        return\n    # numpy types\n    for nptype in np.core.numerictypes.typeDict.values():\n        if issubclass(nptype, np.complexfloating):\n            x = nptype(complex(0.5, -0.5))\n        elif issubclass(nptype, np.floating):\n            x = nptype(0.5)\n        elif issubclass(nptype, np.integer):\n            x = nptype(2)\n        # Handle the weird types\n        try: diff = np.abs(type(np.sqrt(x))(sqrt(x)) - np.sqrt(x))\n        except: continue\n        assert diff < 2.0**-53\n    #Fraction and Decimal\n    oldprec = mp.prec\n    mp.prec = 1000\n    decimal.getcontext().prec = mp.dps\n    assert sqrt(Fraction(2, 3)).ae(sqrt(mpf('2/3')))\n    assert sqrt(Decimal(2)/Decimal(3)).ae(sqrt(mpf('2/3')))\n    mp.prec = oldprec\n"], "fixing_code": ["\"\"\"\nThis module defines the mpf, mpc classes, and standard functions for\noperating with them.\n\"\"\"\n__docformat__ = 'plaintext'\n\nimport functools\n\nimport re\n\nfrom .ctx_base import StandardBaseContext\n\nfrom .libmp.backend import basestring, BACKEND\n\nfrom . import libmp\n\nfrom .libmp import (MPZ, MPZ_ZERO, MPZ_ONE, int_types, repr_dps,\n    round_floor, round_ceiling, dps_to_prec, round_nearest, prec_to_dps,\n    ComplexResult, to_pickable, from_pickable, normalize,\n    from_int, from_float, from_str, to_int, to_float, to_str,\n    from_rational, from_man_exp,\n    fone, fzero, finf, fninf, fnan,\n    mpf_abs, mpf_pos, mpf_neg, mpf_add, mpf_sub, mpf_mul, mpf_mul_int,\n    mpf_div, mpf_rdiv_int, mpf_pow_int, mpf_mod,\n    mpf_eq, mpf_cmp, mpf_lt, mpf_gt, mpf_le, mpf_ge,\n    mpf_hash, mpf_rand,\n    mpf_sum,\n    bitcount, to_fixed,\n    mpc_to_str,\n    mpc_to_complex, mpc_hash, mpc_pos, mpc_is_nonzero, mpc_neg, mpc_conjugate,\n    mpc_abs, mpc_add, mpc_add_mpf, mpc_sub, mpc_sub_mpf, mpc_mul, mpc_mul_mpf,\n    mpc_mul_int, mpc_div, mpc_div_mpf, mpc_pow, mpc_pow_mpf, mpc_pow_int,\n    mpc_mpf_div,\n    mpf_pow,\n    mpf_pi, mpf_degree, mpf_e, mpf_phi, mpf_ln2, mpf_ln10,\n    mpf_euler, mpf_catalan, mpf_apery, mpf_khinchin,\n    mpf_glaisher, mpf_twinprime, mpf_mertens,\n    int_types)\n\nfrom . import function_docs\nfrom . import rational\n\nnew = object.__new__\n\nget_complex = re.compile(r'^\\(?(?P<re>[\\+\\-]?\\d*(\\.\\d*)?(e[\\+\\-]?\\d+)?)??'\n                         r'(?P<im>[\\+\\-]?\\d*(\\.\\d*)?(e[\\+\\-]?\\d+)?j)?\\)?$')\n\nif BACKEND == 'sage':\n    from sage.libs.mpmath.ext_main import Context as BaseMPContext\n    # pickle hack\n    import sage.libs.mpmath.ext_main as _mpf_module\nelse:\n    from .ctx_mp_python import PythonMPContext as BaseMPContext\n    from . import ctx_mp_python as _mpf_module\n\nfrom .ctx_mp_python import _mpf, _mpc, mpnumeric\n\nclass MPContext(BaseMPContext, StandardBaseContext):\n    \"\"\"\n    Context for multiprecision arithmetic with a global precision.\n    \"\"\"\n\n    def __init__(ctx):\n        BaseMPContext.__init__(ctx)\n        ctx.trap_complex = False\n        ctx.pretty = False\n        ctx.types = [ctx.mpf, ctx.mpc, ctx.constant]\n        ctx._mpq = rational.mpq\n        ctx.default()\n        StandardBaseContext.__init__(ctx)\n\n        ctx.mpq = rational.mpq\n        ctx.init_builtins()\n\n        ctx.hyp_summators = {}\n\n        ctx._init_aliases()\n\n        # XXX: automate\n        try:\n            ctx.bernoulli.im_func.func_doc = function_docs.bernoulli\n            ctx.primepi.im_func.func_doc = function_docs.primepi\n            ctx.psi.im_func.func_doc = function_docs.psi\n            ctx.atan2.im_func.func_doc = function_docs.atan2\n        except AttributeError:\n            # python 3\n            ctx.bernoulli.__func__.func_doc = function_docs.bernoulli\n            ctx.primepi.__func__.func_doc = function_docs.primepi\n            ctx.psi.__func__.func_doc = function_docs.psi\n            ctx.atan2.__func__.func_doc = function_docs.atan2\n\n        ctx.digamma.func_doc = function_docs.digamma\n        ctx.cospi.func_doc = function_docs.cospi\n        ctx.sinpi.func_doc = function_docs.sinpi\n\n    def init_builtins(ctx):\n\n        mpf = ctx.mpf\n        mpc = ctx.mpc\n\n        # Exact constants\n        ctx.one = ctx.make_mpf(fone)\n        ctx.zero = ctx.make_mpf(fzero)\n        ctx.j = ctx.make_mpc((fzero,fone))\n        ctx.inf = ctx.make_mpf(finf)\n        ctx.ninf = ctx.make_mpf(fninf)\n        ctx.nan = ctx.make_mpf(fnan)\n\n        eps = ctx.constant(lambda prec, rnd: (0, MPZ_ONE, 1-prec, 1),\n            \"epsilon of working precision\", \"eps\")\n        ctx.eps = eps\n\n        # Approximate constants\n        ctx.pi = ctx.constant(mpf_pi, \"pi\", \"pi\")\n        ctx.ln2 = ctx.constant(mpf_ln2, \"ln(2)\", \"ln2\")\n        ctx.ln10 = ctx.constant(mpf_ln10, \"ln(10)\", \"ln10\")\n        ctx.phi = ctx.constant(mpf_phi, \"Golden ratio phi\", \"phi\")\n        ctx.e = ctx.constant(mpf_e, \"e = exp(1)\", \"e\")\n        ctx.euler = ctx.constant(mpf_euler, \"Euler's constant\", \"euler\")\n        ctx.catalan = ctx.constant(mpf_catalan, \"Catalan's constant\", \"catalan\")\n        ctx.khinchin = ctx.constant(mpf_khinchin, \"Khinchin's constant\", \"khinchin\")\n        ctx.glaisher = ctx.constant(mpf_glaisher, \"Glaisher's constant\", \"glaisher\")\n        ctx.apery = ctx.constant(mpf_apery, \"Apery's constant\", \"apery\")\n        ctx.degree = ctx.constant(mpf_degree, \"1 deg = pi / 180\", \"degree\")\n        ctx.twinprime = ctx.constant(mpf_twinprime, \"Twin prime constant\", \"twinprime\")\n        ctx.mertens = ctx.constant(mpf_mertens, \"Mertens' constant\", \"mertens\")\n\n        # Standard functions\n        ctx.sqrt = ctx._wrap_libmp_function(libmp.mpf_sqrt, libmp.mpc_sqrt)\n        ctx.cbrt = ctx._wrap_libmp_function(libmp.mpf_cbrt, libmp.mpc_cbrt)\n        ctx.ln = ctx._wrap_libmp_function(libmp.mpf_log, libmp.mpc_log)\n        ctx.atan = ctx._wrap_libmp_function(libmp.mpf_atan, libmp.mpc_atan)\n        ctx.exp = ctx._wrap_libmp_function(libmp.mpf_exp, libmp.mpc_exp)\n        ctx.expj = ctx._wrap_libmp_function(libmp.mpf_expj, libmp.mpc_expj)\n        ctx.expjpi = ctx._wrap_libmp_function(libmp.mpf_expjpi, libmp.mpc_expjpi)\n        ctx.sin = ctx._wrap_libmp_function(libmp.mpf_sin, libmp.mpc_sin)\n        ctx.cos = ctx._wrap_libmp_function(libmp.mpf_cos, libmp.mpc_cos)\n        ctx.tan = ctx._wrap_libmp_function(libmp.mpf_tan, libmp.mpc_tan)\n        ctx.sinh = ctx._wrap_libmp_function(libmp.mpf_sinh, libmp.mpc_sinh)\n        ctx.cosh = ctx._wrap_libmp_function(libmp.mpf_cosh, libmp.mpc_cosh)\n        ctx.tanh = ctx._wrap_libmp_function(libmp.mpf_tanh, libmp.mpc_tanh)\n        ctx.asin = ctx._wrap_libmp_function(libmp.mpf_asin, libmp.mpc_asin)\n        ctx.acos = ctx._wrap_libmp_function(libmp.mpf_acos, libmp.mpc_acos)\n        ctx.atan = ctx._wrap_libmp_function(libmp.mpf_atan, libmp.mpc_atan)\n        ctx.asinh = ctx._wrap_libmp_function(libmp.mpf_asinh, libmp.mpc_asinh)\n        ctx.acosh = ctx._wrap_libmp_function(libmp.mpf_acosh, libmp.mpc_acosh)\n        ctx.atanh = ctx._wrap_libmp_function(libmp.mpf_atanh, libmp.mpc_atanh)\n        ctx.sinpi = ctx._wrap_libmp_function(libmp.mpf_sin_pi, libmp.mpc_sin_pi)\n        ctx.cospi = ctx._wrap_libmp_function(libmp.mpf_cos_pi, libmp.mpc_cos_pi)\n        ctx.floor = ctx._wrap_libmp_function(libmp.mpf_floor, libmp.mpc_floor)\n        ctx.ceil = ctx._wrap_libmp_function(libmp.mpf_ceil, libmp.mpc_ceil)\n        ctx.nint = ctx._wrap_libmp_function(libmp.mpf_nint, libmp.mpc_nint)\n        ctx.frac = ctx._wrap_libmp_function(libmp.mpf_frac, libmp.mpc_frac)\n        ctx.fib = ctx.fibonacci = ctx._wrap_libmp_function(libmp.mpf_fibonacci, libmp.mpc_fibonacci)\n\n        ctx.gamma = ctx._wrap_libmp_function(libmp.mpf_gamma, libmp.mpc_gamma)\n        ctx.rgamma = ctx._wrap_libmp_function(libmp.mpf_rgamma, libmp.mpc_rgamma)\n        ctx.loggamma = ctx._wrap_libmp_function(libmp.mpf_loggamma, libmp.mpc_loggamma)\n        ctx.fac = ctx.factorial = ctx._wrap_libmp_function(libmp.mpf_factorial, libmp.mpc_factorial)\n\n        ctx.digamma = ctx._wrap_libmp_function(libmp.mpf_psi0, libmp.mpc_psi0)\n        ctx.harmonic = ctx._wrap_libmp_function(libmp.mpf_harmonic, libmp.mpc_harmonic)\n        ctx.ei = ctx._wrap_libmp_function(libmp.mpf_ei, libmp.mpc_ei)\n        ctx.e1 = ctx._wrap_libmp_function(libmp.mpf_e1, libmp.mpc_e1)\n        ctx._ci = ctx._wrap_libmp_function(libmp.mpf_ci, libmp.mpc_ci)\n        ctx._si = ctx._wrap_libmp_function(libmp.mpf_si, libmp.mpc_si)\n        ctx.ellipk = ctx._wrap_libmp_function(libmp.mpf_ellipk, libmp.mpc_ellipk)\n        ctx._ellipe = ctx._wrap_libmp_function(libmp.mpf_ellipe, libmp.mpc_ellipe)\n        ctx.agm1 = ctx._wrap_libmp_function(libmp.mpf_agm1, libmp.mpc_agm1)\n        ctx._erf = ctx._wrap_libmp_function(libmp.mpf_erf, None)\n        ctx._erfc = ctx._wrap_libmp_function(libmp.mpf_erfc, None)\n        ctx._zeta = ctx._wrap_libmp_function(libmp.mpf_zeta, libmp.mpc_zeta)\n        ctx._altzeta = ctx._wrap_libmp_function(libmp.mpf_altzeta, libmp.mpc_altzeta)\n\n        # Faster versions\n        ctx.sqrt = getattr(ctx, \"_sage_sqrt\", ctx.sqrt)\n        ctx.exp = getattr(ctx, \"_sage_exp\", ctx.exp)\n        ctx.ln = getattr(ctx, \"_sage_ln\", ctx.ln)\n        ctx.cos = getattr(ctx, \"_sage_cos\", ctx.cos)\n        ctx.sin = getattr(ctx, \"_sage_sin\", ctx.sin)\n\n    def to_fixed(ctx, x, prec):\n        return x.to_fixed(prec)\n\n    def hypot(ctx, x, y):\n        r\"\"\"\n        Computes the Euclidean norm of the vector `(x, y)`, equal\n        to `\\sqrt{x^2 + y^2}`. Both `x` and `y` must be real.\"\"\"\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        return ctx.make_mpf(libmp.mpf_hypot(x._mpf_, y._mpf_, *ctx._prec_rounding))\n\n    def _gamma_upper_int(ctx, n, z):\n        n = int(ctx._re(n))\n        if n == 0:\n            return ctx.e1(z)\n        if not hasattr(z, '_mpf_'):\n            raise NotImplementedError\n        prec, rounding = ctx._prec_rounding\n        real, imag = libmp.mpf_expint(n, z._mpf_, prec, rounding, gamma=True)\n        if imag is None:\n            return ctx.make_mpf(real)\n        else:\n            return ctx.make_mpc((real, imag))\n\n    def _expint_int(ctx, n, z):\n        n = int(n)\n        if n == 1:\n            return ctx.e1(z)\n        if not hasattr(z, '_mpf_'):\n            raise NotImplementedError\n        prec, rounding = ctx._prec_rounding\n        real, imag = libmp.mpf_expint(n, z._mpf_, prec, rounding)\n        if imag is None:\n            return ctx.make_mpf(real)\n        else:\n            return ctx.make_mpc((real, imag))\n\n    def _nthroot(ctx, x, n):\n        if hasattr(x, '_mpf_'):\n            try:\n                return ctx.make_mpf(libmp.mpf_nthroot(x._mpf_, n, *ctx._prec_rounding))\n            except ComplexResult:\n                if ctx.trap_complex:\n                    raise\n                x = (x._mpf_, libmp.fzero)\n        else:\n            x = x._mpc_\n        return ctx.make_mpc(libmp.mpc_nthroot(x, n, *ctx._prec_rounding))\n\n    def _besselj(ctx, n, z):\n        prec, rounding = ctx._prec_rounding\n        if hasattr(z, '_mpf_'):\n            return ctx.make_mpf(libmp.mpf_besseljn(n, z._mpf_, prec, rounding))\n        elif hasattr(z, '_mpc_'):\n            return ctx.make_mpc(libmp.mpc_besseljn(n, z._mpc_, prec, rounding))\n\n    def _agm(ctx, a, b=1):\n        prec, rounding = ctx._prec_rounding\n        if hasattr(a, '_mpf_') and hasattr(b, '_mpf_'):\n            try:\n                v = libmp.mpf_agm(a._mpf_, b._mpf_, prec, rounding)\n                return ctx.make_mpf(v)\n            except ComplexResult:\n                pass\n        if hasattr(a, '_mpf_'): a = (a._mpf_, libmp.fzero)\n        else: a = a._mpc_\n        if hasattr(b, '_mpf_'): b = (b._mpf_, libmp.fzero)\n        else: b = b._mpc_\n        return ctx.make_mpc(libmp.mpc_agm(a, b, prec, rounding))\n\n    def bernoulli(ctx, n):\n        return ctx.make_mpf(libmp.mpf_bernoulli(int(n), *ctx._prec_rounding))\n\n    def _zeta_int(ctx, n):\n        return ctx.make_mpf(libmp.mpf_zeta_int(int(n), *ctx._prec_rounding))\n\n    def atan2(ctx, y, x):\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        return ctx.make_mpf(libmp.mpf_atan2(y._mpf_, x._mpf_, *ctx._prec_rounding))\n\n    def psi(ctx, m, z):\n        z = ctx.convert(z)\n        m = int(m)\n        if ctx._is_real_type(z):\n            return ctx.make_mpf(libmp.mpf_psi(m, z._mpf_, *ctx._prec_rounding))\n        else:\n            return ctx.make_mpc(libmp.mpc_psi(m, z._mpc_, *ctx._prec_rounding))\n\n    def cos_sin(ctx, x, **kwargs):\n        if type(x) not in ctx.types:\n            x = ctx.convert(x)\n        prec, rounding = ctx._parse_prec(kwargs)\n        if hasattr(x, '_mpf_'):\n            c, s = libmp.mpf_cos_sin(x._mpf_, prec, rounding)\n            return ctx.make_mpf(c), ctx.make_mpf(s)\n        elif hasattr(x, '_mpc_'):\n            c, s = libmp.mpc_cos_sin(x._mpc_, prec, rounding)\n            return ctx.make_mpc(c), ctx.make_mpc(s)\n        else:\n            return ctx.cos(x, **kwargs), ctx.sin(x, **kwargs)\n\n    def cospi_sinpi(ctx, x, **kwargs):\n        if type(x) not in ctx.types:\n            x = ctx.convert(x)\n        prec, rounding = ctx._parse_prec(kwargs)\n        if hasattr(x, '_mpf_'):\n            c, s = libmp.mpf_cos_sin_pi(x._mpf_, prec, rounding)\n            return ctx.make_mpf(c), ctx.make_mpf(s)\n        elif hasattr(x, '_mpc_'):\n            c, s = libmp.mpc_cos_sin_pi(x._mpc_, prec, rounding)\n            return ctx.make_mpc(c), ctx.make_mpc(s)\n        else:\n            return ctx.cos(x, **kwargs), ctx.sin(x, **kwargs)\n\n    def clone(ctx):\n        \"\"\"\n        Create a copy of the context, with the same working precision.\n        \"\"\"\n        a = ctx.__class__()\n        a.prec = ctx.prec\n        return a\n\n    # Several helper methods\n    # TODO: add more of these, make consistent, write docstrings, ...\n\n    def _is_real_type(ctx, x):\n        if hasattr(x, '_mpc_') or type(x) is complex:\n            return False\n        return True\n\n    def _is_complex_type(ctx, x):\n        if hasattr(x, '_mpc_') or type(x) is complex:\n            return True\n        return False\n\n    def isnan(ctx, x):\n        \"\"\"\n        Return *True* if *x* is a NaN (not-a-number), or for a complex\n        number, whether either the real or complex part is NaN;\n        otherwise return *False*::\n\n            >>> from mpmath import *\n            >>> isnan(3.14)\n            False\n            >>> isnan(nan)\n            True\n            >>> isnan(mpc(3.14,2.72))\n            False\n            >>> isnan(mpc(3.14,nan))\n            True\n\n        \"\"\"\n        if hasattr(x, \"_mpf_\"):\n            return x._mpf_ == fnan\n        if hasattr(x, \"_mpc_\"):\n            return fnan in x._mpc_\n        if isinstance(x, int_types) or isinstance(x, rational.mpq):\n            return False\n        x = ctx.convert(x)\n        if hasattr(x, '_mpf_') or hasattr(x, '_mpc_'):\n            return ctx.isnan(x)\n        raise TypeError(\"isnan() needs a number as input\")\n\n    def isfinite(ctx, x):\n        \"\"\"\n        Return *True* if *x* is a finite number, i.e. neither\n        an infinity or a NaN.\n\n            >>> from mpmath import *\n            >>> isfinite(inf)\n            False\n            >>> isfinite(-inf)\n            False\n            >>> isfinite(3)\n            True\n            >>> isfinite(nan)\n            False\n            >>> isfinite(3+4j)\n            True\n            >>> isfinite(mpc(3,inf))\n            False\n            >>> isfinite(mpc(nan,3))\n            False\n\n        \"\"\"\n        if ctx.isinf(x) or ctx.isnan(x):\n            return False\n        return True\n\n    def isnpint(ctx, x):\n        \"\"\"\n        Determine if *x* is a nonpositive integer.\n        \"\"\"\n        if not x:\n            return True\n        if hasattr(x, '_mpf_'):\n            sign, man, exp, bc = x._mpf_\n            return sign and exp >= 0\n        if hasattr(x, '_mpc_'):\n            return not x.imag and ctx.isnpint(x.real)\n        if type(x) in int_types:\n            return x <= 0\n        if isinstance(x, ctx.mpq):\n            p, q = x._mpq_\n            if not p:\n                return True\n            return q == 1 and p <= 0\n        return ctx.isnpint(ctx.convert(x))\n\n    def __str__(ctx):\n        lines = [\"Mpmath settings:\",\n            (\"  mp.prec = %s\" % ctx.prec).ljust(30) + \"[default: 53]\",\n            (\"  mp.dps = %s\" % ctx.dps).ljust(30) + \"[default: 15]\",\n            (\"  mp.trap_complex = %s\" % ctx.trap_complex).ljust(30) + \"[default: False]\",\n        ]\n        return \"\\n\".join(lines)\n\n    @property\n    def _repr_digits(ctx):\n        return repr_dps(ctx._prec)\n\n    @property\n    def _str_digits(ctx):\n        return ctx._dps\n\n    def extraprec(ctx, n, normalize_output=False):\n        \"\"\"\n        The block\n\n            with extraprec(n):\n                <code>\n\n        increases the precision n bits, executes <code>, and then\n        restores the precision.\n\n        extraprec(n)(f) returns a decorated version of the function f\n        that increases the working precision by n bits before execution,\n        and restores the parent precision afterwards. With\n        normalize_output=True, it rounds the return value to the parent\n        precision.\n        \"\"\"\n        return PrecisionManager(ctx, lambda p: p + n, None, normalize_output)\n\n    def extradps(ctx, n, normalize_output=False):\n        \"\"\"\n        This function is analogous to extraprec (see documentation)\n        but changes the decimal precision instead of the number of bits.\n        \"\"\"\n        return PrecisionManager(ctx, None, lambda d: d + n, normalize_output)\n\n    def workprec(ctx, n, normalize_output=False):\n        \"\"\"\n        The block\n\n            with workprec(n):\n                <code>\n\n        sets the precision to n bits, executes <code>, and then restores\n        the precision.\n\n        workprec(n)(f) returns a decorated version of the function f\n        that sets the precision to n bits before execution,\n        and restores the precision afterwards. With normalize_output=True,\n        it rounds the return value to the parent precision.\n        \"\"\"\n        return PrecisionManager(ctx, lambda p: n, None, normalize_output)\n\n    def workdps(ctx, n, normalize_output=False):\n        \"\"\"\n        This function is analogous to workprec (see documentation)\n        but changes the decimal precision instead of the number of bits.\n        \"\"\"\n        return PrecisionManager(ctx, None, lambda d: n, normalize_output)\n\n    def autoprec(ctx, f, maxprec=None, catch=(), verbose=False):\n        r\"\"\"\n        Return a wrapped copy of *f* that repeatedly evaluates *f*\n        with increasing precision until the result converges to the\n        full precision used at the point of the call.\n\n        This heuristically protects against rounding errors, at the cost of\n        roughly a 2x slowdown compared to manually setting the optimal\n        precision. This method can, however, easily be fooled if the results\n        from *f* depend \"discontinuously\" on the precision, for instance\n        if catastrophic cancellation can occur. Therefore, :func:`~mpmath.autoprec`\n        should be used judiciously.\n\n        **Examples**\n\n        Many functions are sensitive to perturbations of the input arguments.\n        If the arguments are decimal numbers, they may have to be converted\n        to binary at a much higher precision. If the amount of required\n        extra precision is unknown, :func:`~mpmath.autoprec` is convenient::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15\n            >>> mp.pretty = True\n            >>> besselj(5, 125 * 10**28)    # Exact input\n            -8.03284785591801e-17\n            >>> besselj(5, '1.25e30')   # Bad\n            7.12954868316652e-16\n            >>> autoprec(besselj)(5, '1.25e30')   # Good\n            -8.03284785591801e-17\n\n        The following fails to converge because `\\sin(\\pi) = 0` whereas all\n        finite-precision approximations of `\\pi` give nonzero values::\n\n            >>> autoprec(sin)(pi) # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n              ...\n            NoConvergence: autoprec: prec increased to 2910 without convergence\n\n        As the following example shows, :func:`~mpmath.autoprec` can protect against\n        cancellation, but is fooled by too severe cancellation::\n\n            >>> x = 1e-10\n            >>> exp(x)-1; expm1(x); autoprec(lambda t: exp(t)-1)(x)\n            1.00000008274037e-10\n            1.00000000005e-10\n            1.00000000005e-10\n            >>> x = 1e-50\n            >>> exp(x)-1; expm1(x); autoprec(lambda t: exp(t)-1)(x)\n            0.0\n            1.0e-50\n            0.0\n\n        With *catch*, an exception or list of exceptions to intercept\n        may be specified. The raised exception is interpreted\n        as signaling insufficient precision. This permits, for example,\n        evaluating a function where a too low precision results in a\n        division by zero::\n\n            >>> f = lambda x: 1/(exp(x)-1)\n            >>> f(1e-30)\n            Traceback (most recent call last):\n              ...\n            ZeroDivisionError\n            >>> autoprec(f, catch=ZeroDivisionError)(1e-30)\n            1.0e+30\n\n\n        \"\"\"\n        def f_autoprec_wrapped(*args, **kwargs):\n            prec = ctx.prec\n            if maxprec is None:\n                maxprec2 = ctx._default_hyper_maxprec(prec)\n            else:\n                maxprec2 = maxprec\n            try:\n                ctx.prec = prec + 10\n                try:\n                    v1 = f(*args, **kwargs)\n                except catch:\n                    v1 = ctx.nan\n                prec2 = prec + 20\n                while 1:\n                    ctx.prec = prec2\n                    try:\n                        v2 = f(*args, **kwargs)\n                    except catch:\n                        v2 = ctx.nan\n                    if v1 == v2:\n                        break\n                    err = ctx.mag(v2-v1) - ctx.mag(v2)\n                    if err < (-prec):\n                        break\n                    if verbose:\n                        print(\"autoprec: target=%s, prec=%s, accuracy=%s\" \\\n                            % (prec, prec2, -err))\n                    v1 = v2\n                    if prec2 >= maxprec2:\n                        raise ctx.NoConvergence(\\\n                        \"autoprec: prec increased to %i without convergence\"\\\n                        % prec2)\n                    prec2 += int(prec2*2)\n                    prec2 = min(prec2, maxprec2)\n            finally:\n                ctx.prec = prec\n            return +v2\n        return f_autoprec_wrapped\n\n    def nstr(ctx, x, n=6, **kwargs):\n        \"\"\"\n        Convert an ``mpf`` or ``mpc`` to a decimal string literal with *n*\n        significant digits. The small default value for *n* is chosen to\n        make this function useful for printing collections of numbers\n        (lists, matrices, etc).\n\n        If *x* is a list or tuple, :func:`~mpmath.nstr` is applied recursively\n        to each element. For unrecognized classes, :func:`~mpmath.nstr`\n        simply returns ``str(x)``.\n\n        The companion function :func:`~mpmath.nprint` prints the result\n        instead of returning it.\n\n        The keyword arguments *strip_zeros*, *min_fixed*, *max_fixed*\n        and *show_zero_exponent* are forwarded to :func:`~mpmath.libmp.to_str`.\n\n        The number will be printed in fixed-point format if the position\n        of the leading digit is strictly between min_fixed\n        (default = min(-dps/3,-5)) and max_fixed (default = dps).\n\n        To force fixed-point format always, set min_fixed = -inf,\n        max_fixed = +inf. To force floating-point format, set\n        min_fixed >= max_fixed.\n\n            >>> from mpmath import *\n            >>> nstr([+pi, ldexp(1,-500)])\n            '[3.14159, 3.05494e-151]'\n            >>> nprint([+pi, ldexp(1,-500)])\n            [3.14159, 3.05494e-151]\n            >>> nstr(mpf(\"5e-10\"), 5)\n            '5.0e-10'\n            >>> nstr(mpf(\"5e-10\"), 5, strip_zeros=False)\n            '5.0000e-10'\n            >>> nstr(mpf(\"5e-10\"), 5, strip_zeros=False, min_fixed=-11)\n            '0.00000000050000'\n            >>> nstr(mpf(0), 5, show_zero_exponent=True)\n            '0.0e+0'\n\n        \"\"\"\n        if isinstance(x, list):\n            return \"[%s]\" % (\", \".join(ctx.nstr(c, n, **kwargs) for c in x))\n        if isinstance(x, tuple):\n            return \"(%s)\" % (\", \".join(ctx.nstr(c, n, **kwargs) for c in x))\n        if hasattr(x, '_mpf_'):\n            return to_str(x._mpf_, n, **kwargs)\n        if hasattr(x, '_mpc_'):\n            return \"(\" + mpc_to_str(x._mpc_, n, **kwargs)  + \")\"\n        if isinstance(x, basestring):\n            return repr(x)\n        if isinstance(x, ctx.matrix):\n            return x.__nstr__(n, **kwargs)\n        return str(x)\n\n    def _convert_fallback(ctx, x, strings):\n        if strings and isinstance(x, basestring):\n            if 'j' in x.lower():\n                x = x.lower().replace(' ', '')\n                match = get_complex.match(x)\n                re = match.group('re')\n                if not re:\n                    re = 0\n                im = match.group('im').rstrip('j')\n                return ctx.mpc(ctx.convert(re), ctx.convert(im))\n        if hasattr(x, \"_mpi_\"):\n            a, b = x._mpi_\n            if a == b:\n                return ctx.make_mpf(a)\n            else:\n                raise ValueError(\"can only create mpf from zero-width interval\")\n        raise TypeError(\"cannot create mpf from \" + repr(x))\n\n    def mpmathify(ctx, *args, **kwargs):\n        return ctx.convert(*args, **kwargs)\n\n    def _parse_prec(ctx, kwargs):\n        if kwargs:\n            if kwargs.get('exact'):\n                return 0, 'f'\n            prec, rounding = ctx._prec_rounding\n            if 'rounding' in kwargs:\n                rounding = kwargs['rounding']\n            if 'prec' in kwargs:\n                prec = kwargs['prec']\n                if prec == ctx.inf:\n                    return 0, 'f'\n                else:\n                    prec = int(prec)\n            elif 'dps' in kwargs:\n                dps = kwargs['dps']\n                if dps == ctx.inf:\n                    return 0, 'f'\n                prec = dps_to_prec(dps)\n            return prec, rounding\n        return ctx._prec_rounding\n\n    _exact_overflow_msg = \"the exact result does not fit in memory\"\n\n    _hypsum_msg = \"\"\"hypsum() failed to converge to the requested %i bits of accuracy\nusing a working precision of %i bits. Try with a higher maxprec,\nmaxterms, or set zeroprec.\"\"\"\n\n    def hypsum(ctx, p, q, flags, coeffs, z, accurate_small=True, **kwargs):\n        if hasattr(z, \"_mpf_\"):\n            key = p, q, flags, 'R'\n            v = z._mpf_\n        elif hasattr(z, \"_mpc_\"):\n            key = p, q, flags, 'C'\n            v = z._mpc_\n        if key not in ctx.hyp_summators:\n            ctx.hyp_summators[key] = libmp.make_hyp_summator(key)[1]\n        summator = ctx.hyp_summators[key]\n        prec = ctx.prec\n        maxprec = kwargs.get('maxprec', ctx._default_hyper_maxprec(prec))\n        extraprec = 50\n        epsshift = 25\n        # Jumps in magnitude occur when parameters are close to negative\n        # integers. We must ensure that these terms are included in\n        # the sum and added accurately\n        magnitude_check = {}\n        max_total_jump = 0\n        for i, c in enumerate(coeffs):\n            if flags[i] == 'Z':\n                if i >= p and c <= 0:\n                    ok = False\n                    for ii, cc in enumerate(coeffs[:p]):\n                        # Note: c <= cc or c < cc, depending on convention\n                        if flags[ii] == 'Z' and cc <= 0 and c <= cc:\n                            ok = True\n                    if not ok:\n                        raise ZeroDivisionError(\"pole in hypergeometric series\")\n                continue\n            n, d = ctx.nint_distance(c)\n            n = -int(n)\n            d = -d\n            if i >= p and n >= 0 and d > 4:\n                if n in magnitude_check:\n                    magnitude_check[n] += d\n                else:\n                    magnitude_check[n] = d\n                extraprec = max(extraprec, d - prec + 60)\n            max_total_jump += abs(d)\n        while 1:\n            if extraprec > maxprec:\n                raise ValueError(ctx._hypsum_msg % (prec, prec+extraprec))\n            wp = prec + extraprec\n            if magnitude_check:\n                mag_dict = dict((n,None) for n in magnitude_check)\n            else:\n                mag_dict = {}\n            zv, have_complex, magnitude = summator(coeffs, v, prec, wp, \\\n                epsshift, mag_dict, **kwargs)\n            cancel = -magnitude\n            jumps_resolved = True\n            if extraprec < max_total_jump:\n                for n in mag_dict.values():\n                    if (n is None) or (n < prec):\n                        jumps_resolved = False\n                        break\n            accurate = (cancel < extraprec-25-5 or not accurate_small)\n            if jumps_resolved:\n                if accurate:\n                    break\n                # zero?\n                zeroprec = kwargs.get('zeroprec')\n                if zeroprec is not None:\n                    if cancel > zeroprec:\n                        if have_complex:\n                            return ctx.mpc(0)\n                        else:\n                            return ctx.zero\n\n            # Some near-singularities were not included, so increase\n            # precision and repeat until they are\n            extraprec *= 2\n            # Possible workaround for bad roundoff in fixed-point arithmetic\n            epsshift += 5\n            extraprec += 5\n\n        if type(zv) is tuple:\n            if have_complex:\n                return ctx.make_mpc(zv)\n            else:\n                return ctx.make_mpf(zv)\n        else:\n            return zv\n\n    def ldexp(ctx, x, n):\n        r\"\"\"\n        Computes `x 2^n` efficiently. No rounding is performed.\n        The argument `x` must be a real floating-point number (or\n        possible to convert into one) and `n` must be a Python ``int``.\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> ldexp(1, 10)\n            mpf('1024.0')\n            >>> ldexp(1, -3)\n            mpf('0.125')\n\n        \"\"\"\n        x = ctx.convert(x)\n        return ctx.make_mpf(libmp.mpf_shift(x._mpf_, n))\n\n    def frexp(ctx, x):\n        r\"\"\"\n        Given a real number `x`, returns `(y, n)` with `y \\in [0.5, 1)`,\n        `n` a Python integer, and such that `x = y 2^n`. No rounding is\n        performed.\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> frexp(7.5)\n            (mpf('0.9375'), 3)\n\n        \"\"\"\n        x = ctx.convert(x)\n        y, n = libmp.mpf_frexp(x._mpf_)\n        return ctx.make_mpf(y), n\n\n    def fneg(ctx, x, **kwargs):\n        \"\"\"\n        Negates the number *x*, giving a floating-point result, optionally\n        using a custom precision and rounding mode.\n\n        See the documentation of :func:`~mpmath.fadd` for a detailed description\n        of how to specify precision and rounding.\n\n        **Examples**\n\n        An mpmath number is returned::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fneg(2.5)\n            mpf('-2.5')\n            >>> fneg(-5+2j)\n            mpc(real='5.0', imag='-2.0')\n\n        Precise control over rounding is possible::\n\n            >>> x = fadd(2, 1e-100, exact=True)\n            >>> fneg(x)\n            mpf('-2.0')\n            >>> fneg(x, rounding='f')\n            mpf('-2.0000000000000004')\n\n        Negating with and without roundoff::\n\n            >>> n = 200000000000000000000001\n            >>> print(int(-mpf(n)))\n            -200000000000000016777216\n            >>> print(int(fneg(n)))\n            -200000000000000016777216\n            >>> print(int(fneg(n, prec=log(n,2)+1)))\n            -200000000000000000000001\n            >>> print(int(fneg(n, dps=log(n,10)+1)))\n            -200000000000000000000001\n            >>> print(int(fneg(n, prec=inf)))\n            -200000000000000000000001\n            >>> print(int(fneg(n, dps=inf)))\n            -200000000000000000000001\n            >>> print(int(fneg(n, exact=True)))\n            -200000000000000000000001\n\n        \"\"\"\n        prec, rounding = ctx._parse_prec(kwargs)\n        x = ctx.convert(x)\n        if hasattr(x, '_mpf_'):\n            return ctx.make_mpf(mpf_neg(x._mpf_, prec, rounding))\n        if hasattr(x, '_mpc_'):\n            return ctx.make_mpc(mpc_neg(x._mpc_, prec, rounding))\n        raise ValueError(\"Arguments need to be mpf or mpc compatible numbers\")\n\n    def fadd(ctx, x, y, **kwargs):\n        \"\"\"\n        Adds the numbers *x* and *y*, giving a floating-point result,\n        optionally using a custom precision and rounding mode.\n\n        The default precision is the working precision of the context.\n        You can specify a custom precision in bits by passing the *prec* keyword\n        argument, or by providing an equivalent decimal precision with the *dps*\n        keyword argument. If the precision is set to ``+inf``, or if the flag\n        *exact=True* is passed, an exact addition with no rounding is performed.\n\n        When the precision is finite, the optional *rounding* keyword argument\n        specifies the direction of rounding. Valid options are ``'n'`` for\n        nearest (default), ``'f'`` for floor, ``'c'`` for ceiling, ``'d'``\n        for down, ``'u'`` for up.\n\n        **Examples**\n\n        Using :func:`~mpmath.fadd` with precision and rounding control::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fadd(2, 1e-20)\n            mpf('2.0')\n            >>> fadd(2, 1e-20, rounding='u')\n            mpf('2.0000000000000004')\n            >>> nprint(fadd(2, 1e-20, prec=100), 25)\n            2.00000000000000000001\n            >>> nprint(fadd(2, 1e-20, dps=15), 25)\n            2.0\n            >>> nprint(fadd(2, 1e-20, dps=25), 25)\n            2.00000000000000000001\n            >>> nprint(fadd(2, 1e-20, exact=True), 25)\n            2.00000000000000000001\n\n        Exact addition avoids cancellation errors, enforcing familiar laws\n        of numbers such as `x+y-x = y`, which don't hold in floating-point\n        arithmetic with finite precision::\n\n            >>> x, y = mpf(2), mpf('1e-1000')\n            >>> print(x + y - x)\n            0.0\n            >>> print(fadd(x, y, prec=inf) - x)\n            1.0e-1000\n            >>> print(fadd(x, y, exact=True) - x)\n            1.0e-1000\n\n        Exact addition can be inefficient and may be impossible to perform\n        with large magnitude differences::\n\n            >>> fadd(1, '1e-100000000000000000000', prec=inf)\n            Traceback (most recent call last):\n              ...\n            OverflowError: the exact result does not fit in memory\n\n        \"\"\"\n        prec, rounding = ctx._parse_prec(kwargs)\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        try:\n            if hasattr(x, '_mpf_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpf(mpf_add(x._mpf_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_add_mpf(y._mpc_, x._mpf_, prec, rounding))\n            if hasattr(x, '_mpc_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpc(mpc_add_mpf(x._mpc_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_add(x._mpc_, y._mpc_, prec, rounding))\n        except (ValueError, OverflowError):\n            raise OverflowError(ctx._exact_overflow_msg)\n        raise ValueError(\"Arguments need to be mpf or mpc compatible numbers\")\n\n    def fsub(ctx, x, y, **kwargs):\n        \"\"\"\n        Subtracts the numbers *x* and *y*, giving a floating-point result,\n        optionally using a custom precision and rounding mode.\n\n        See the documentation of :func:`~mpmath.fadd` for a detailed description\n        of how to specify precision and rounding.\n\n        **Examples**\n\n        Using :func:`~mpmath.fsub` with precision and rounding control::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fsub(2, 1e-20)\n            mpf('2.0')\n            >>> fsub(2, 1e-20, rounding='d')\n            mpf('1.9999999999999998')\n            >>> nprint(fsub(2, 1e-20, prec=100), 25)\n            1.99999999999999999999\n            >>> nprint(fsub(2, 1e-20, dps=15), 25)\n            2.0\n            >>> nprint(fsub(2, 1e-20, dps=25), 25)\n            1.99999999999999999999\n            >>> nprint(fsub(2, 1e-20, exact=True), 25)\n            1.99999999999999999999\n\n        Exact subtraction avoids cancellation errors, enforcing familiar laws\n        of numbers such as `x-y+y = x`, which don't hold in floating-point\n        arithmetic with finite precision::\n\n            >>> x, y = mpf(2), mpf('1e1000')\n            >>> print(x - y + y)\n            0.0\n            >>> print(fsub(x, y, prec=inf) + y)\n            2.0\n            >>> print(fsub(x, y, exact=True) + y)\n            2.0\n\n        Exact addition can be inefficient and may be impossible to perform\n        with large magnitude differences::\n\n            >>> fsub(1, '1e-100000000000000000000', prec=inf)\n            Traceback (most recent call last):\n              ...\n            OverflowError: the exact result does not fit in memory\n\n        \"\"\"\n        prec, rounding = ctx._parse_prec(kwargs)\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        try:\n            if hasattr(x, '_mpf_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpf(mpf_sub(x._mpf_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_sub((x._mpf_, fzero), y._mpc_, prec, rounding))\n            if hasattr(x, '_mpc_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpc(mpc_sub_mpf(x._mpc_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_sub(x._mpc_, y._mpc_, prec, rounding))\n        except (ValueError, OverflowError):\n            raise OverflowError(ctx._exact_overflow_msg)\n        raise ValueError(\"Arguments need to be mpf or mpc compatible numbers\")\n\n    def fmul(ctx, x, y, **kwargs):\n        \"\"\"\n        Multiplies the numbers *x* and *y*, giving a floating-point result,\n        optionally using a custom precision and rounding mode.\n\n        See the documentation of :func:`~mpmath.fadd` for a detailed description\n        of how to specify precision and rounding.\n\n        **Examples**\n\n        The result is an mpmath number::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fmul(2, 5.0)\n            mpf('10.0')\n            >>> fmul(0.5j, 0.5)\n            mpc(real='0.0', imag='0.25')\n\n        Avoiding roundoff::\n\n            >>> x, y = 10**10+1, 10**15+1\n            >>> print(x*y)\n            10000000001000010000000001\n            >>> print(mpf(x) * mpf(y))\n            1.0000000001e+25\n            >>> print(int(mpf(x) * mpf(y)))\n            10000000001000011026399232\n            >>> print(int(fmul(x, y)))\n            10000000001000011026399232\n            >>> print(int(fmul(x, y, dps=25)))\n            10000000001000010000000001\n            >>> print(int(fmul(x, y, exact=True)))\n            10000000001000010000000001\n\n        Exact multiplication with complex numbers can be inefficient and may\n        be impossible to perform with large magnitude differences between\n        real and imaginary parts::\n\n            >>> x = 1+2j\n            >>> y = mpc(2, '1e-100000000000000000000')\n            >>> fmul(x, y)\n            mpc(real='2.0', imag='4.0')\n            >>> fmul(x, y, rounding='u')\n            mpc(real='2.0', imag='4.0000000000000009')\n            >>> fmul(x, y, exact=True)\n            Traceback (most recent call last):\n              ...\n            OverflowError: the exact result does not fit in memory\n\n        \"\"\"\n        prec, rounding = ctx._parse_prec(kwargs)\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        try:\n            if hasattr(x, '_mpf_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpf(mpf_mul(x._mpf_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_mul_mpf(y._mpc_, x._mpf_, prec, rounding))\n            if hasattr(x, '_mpc_'):\n                if hasattr(y, '_mpf_'):\n                    return ctx.make_mpc(mpc_mul_mpf(x._mpc_, y._mpf_, prec, rounding))\n                if hasattr(y, '_mpc_'):\n                    return ctx.make_mpc(mpc_mul(x._mpc_, y._mpc_, prec, rounding))\n        except (ValueError, OverflowError):\n            raise OverflowError(ctx._exact_overflow_msg)\n        raise ValueError(\"Arguments need to be mpf or mpc compatible numbers\")\n\n    def fdiv(ctx, x, y, **kwargs):\n        \"\"\"\n        Divides the numbers *x* and *y*, giving a floating-point result,\n        optionally using a custom precision and rounding mode.\n\n        See the documentation of :func:`~mpmath.fadd` for a detailed description\n        of how to specify precision and rounding.\n\n        **Examples**\n\n        The result is an mpmath number::\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fdiv(3, 2)\n            mpf('1.5')\n            >>> fdiv(2, 3)\n            mpf('0.66666666666666663')\n            >>> fdiv(2+4j, 0.5)\n            mpc(real='4.0', imag='8.0')\n\n        The rounding direction and precision can be controlled::\n\n            >>> fdiv(2, 3, dps=3)    # Should be accurate to at least 3 digits\n            mpf('0.6666259765625')\n            >>> fdiv(2, 3, rounding='d')\n            mpf('0.66666666666666663')\n            >>> fdiv(2, 3, prec=60)\n            mpf('0.66666666666666667')\n            >>> fdiv(2, 3, rounding='u')\n            mpf('0.66666666666666674')\n\n        Checking the error of a division by performing it at higher precision::\n\n            >>> fdiv(2, 3) - fdiv(2, 3, prec=100)\n            mpf('-3.7007434154172148e-17')\n\n        Unlike :func:`~mpmath.fadd`, :func:`~mpmath.fmul`, etc., exact division is not\n        allowed since the quotient of two floating-point numbers generally\n        does not have an exact floating-point representation. (In the\n        future this might be changed to allow the case where the division\n        is actually exact.)\n\n            >>> fdiv(2, 3, exact=True)\n            Traceback (most recent call last):\n              ...\n            ValueError: division is not an exact operation\n\n        \"\"\"\n        prec, rounding = ctx._parse_prec(kwargs)\n        if not prec:\n            raise ValueError(\"division is not an exact operation\")\n        x = ctx.convert(x)\n        y = ctx.convert(y)\n        if hasattr(x, '_mpf_'):\n            if hasattr(y, '_mpf_'):\n                return ctx.make_mpf(mpf_div(x._mpf_, y._mpf_, prec, rounding))\n            if hasattr(y, '_mpc_'):\n                return ctx.make_mpc(mpc_div((x._mpf_, fzero), y._mpc_, prec, rounding))\n        if hasattr(x, '_mpc_'):\n            if hasattr(y, '_mpf_'):\n                return ctx.make_mpc(mpc_div_mpf(x._mpc_, y._mpf_, prec, rounding))\n            if hasattr(y, '_mpc_'):\n                return ctx.make_mpc(mpc_div(x._mpc_, y._mpc_, prec, rounding))\n        raise ValueError(\"Arguments need to be mpf or mpc compatible numbers\")\n\n    def nint_distance(ctx, x):\n        r\"\"\"\n        Return `(n,d)` where `n` is the nearest integer to `x` and `d` is\n        an estimate of `\\log_2(|x-n|)`. If `d < 0`, `-d` gives the precision\n        (measured in bits) lost to cancellation when computing `x-n`.\n\n            >>> from mpmath import *\n            >>> n, d = nint_distance(5)\n            >>> print(n); print(d)\n            5\n            -inf\n            >>> n, d = nint_distance(mpf(5))\n            >>> print(n); print(d)\n            5\n            -inf\n            >>> n, d = nint_distance(mpf(5.00000001))\n            >>> print(n); print(d)\n            5\n            -26\n            >>> n, d = nint_distance(mpf(4.99999999))\n            >>> print(n); print(d)\n            5\n            -26\n            >>> n, d = nint_distance(mpc(5,10))\n            >>> print(n); print(d)\n            5\n            4\n            >>> n, d = nint_distance(mpc(5,0.000001))\n            >>> print(n); print(d)\n            5\n            -19\n\n        \"\"\"\n        typx = type(x)\n        if typx in int_types:\n            return int(x), ctx.ninf\n        elif typx is rational.mpq:\n            p, q = x._mpq_\n            n, r = divmod(p, q)\n            if 2*r >= q:\n                n += 1\n            elif not r:\n                return n, ctx.ninf\n            # log(p/q-n) = log((p-nq)/q) = log(p-nq) - log(q)\n            d = bitcount(abs(p-n*q)) - bitcount(q)\n            return n, d\n        if hasattr(x, \"_mpf_\"):\n            re = x._mpf_\n            im_dist = ctx.ninf\n        elif hasattr(x, \"_mpc_\"):\n            re, im = x._mpc_\n            isign, iman, iexp, ibc = im\n            if iman:\n                im_dist = iexp + ibc\n            elif im == fzero:\n                im_dist = ctx.ninf\n            else:\n                raise ValueError(\"requires a finite number\")\n        else:\n            x = ctx.convert(x)\n            if hasattr(x, \"_mpf_\") or hasattr(x, \"_mpc_\"):\n                return ctx.nint_distance(x)\n            else:\n                raise TypeError(\"requires an mpf/mpc\")\n        sign, man, exp, bc = re\n        mag = exp+bc\n        # |x| < 0.5\n        if mag < 0:\n            n = 0\n            re_dist = mag\n        elif man:\n            # exact integer\n            if exp >= 0:\n                n = man << exp\n                re_dist = ctx.ninf\n            # exact half-integer\n            elif exp == -1:\n                n = (man>>1)+1\n                re_dist = 0\n            else:\n                d = (-exp-1)\n                t = man >> d\n                if t & 1:\n                    t += 1\n                    man = (t<<d) - man\n                else:\n                    man -= (t<<d)\n                n = t>>1   # int(t)>>1\n                re_dist = exp+bitcount(man)\n            if sign:\n                n = -n\n        elif re == fzero:\n            re_dist = ctx.ninf\n            n = 0\n        else:\n            raise ValueError(\"requires a finite number\")\n        return n, max(re_dist, im_dist)\n\n    def fprod(ctx, factors):\n        r\"\"\"\n        Calculates a product containing a finite number of factors (for\n        infinite products, see :func:`~mpmath.nprod`). The factors will be\n        converted to mpmath numbers.\n\n            >>> from mpmath import *\n            >>> mp.dps = 15; mp.pretty = False\n            >>> fprod([1, 2, 0.5, 7])\n            mpf('7.0')\n\n        \"\"\"\n        orig = ctx.prec\n        try:\n            v = ctx.one\n            for p in factors:\n                v *= p\n        finally:\n            ctx.prec = orig\n        return +v\n\n    def rand(ctx):\n        \"\"\"\n        Returns an ``mpf`` with value chosen randomly from `[0, 1)`.\n        The number of randomly generated bits in the mantissa is equal\n        to the working precision.\n        \"\"\"\n        return ctx.make_mpf(mpf_rand(ctx._prec))\n\n    def fraction(ctx, p, q):\n        \"\"\"\n        Given Python integers `(p, q)`, returns a lazy ``mpf`` representing\n        the fraction `p/q`. The value is updated with the precision.\n\n            >>> from mpmath import *\n            >>> mp.dps = 15\n            >>> a = fraction(1,100)\n            >>> b = mpf(1)/100\n            >>> print(a); print(b)\n            0.01\n            0.01\n            >>> mp.dps = 30\n            >>> print(a); print(b)      # a will be accurate\n            0.01\n            0.0100000000000000002081668171172\n            >>> mp.dps = 15\n        \"\"\"\n        return ctx.constant(lambda prec, rnd: from_rational(p, q, prec, rnd),\n            '%s/%s' % (p, q))\n\n    def absmin(ctx, x):\n        return abs(ctx.convert(x))\n\n    def absmax(ctx, x):\n        return abs(ctx.convert(x))\n\n    def _as_points(ctx, x):\n        # XXX: remove this?\n        if hasattr(x, '_mpi_'):\n            a, b = x._mpi_\n            return [ctx.make_mpf(a), ctx.make_mpf(b)]\n        return x\n\n    '''\n    def _zetasum(ctx, s, a, b):\n        \"\"\"\n        Computes sum of k^(-s) for k = a, a+1, ..., b with a, b both small\n        integers.\n        \"\"\"\n        a = int(a)\n        b = int(b)\n        s = ctx.convert(s)\n        prec, rounding = ctx._prec_rounding\n        if hasattr(s, '_mpf_'):\n            v = ctx.make_mpf(libmp.mpf_zetasum(s._mpf_, a, b, prec))\n        elif hasattr(s, '_mpc_'):\n            v = ctx.make_mpc(libmp.mpc_zetasum(s._mpc_, a, b, prec))\n        return v\n    '''\n\n    def _zetasum_fast(ctx, s, a, n, derivatives=[0], reflect=False):\n        if not (ctx.isint(a) and hasattr(s, \"_mpc_\")):\n            raise NotImplementedError\n        a = int(a)\n        prec = ctx._prec\n        xs, ys = libmp.mpc_zetasum(s._mpc_, a, n, derivatives, reflect, prec)\n        xs = [ctx.make_mpc(x) for x in xs]\n        ys = [ctx.make_mpc(y) for y in ys]\n        return xs, ys\n\nclass PrecisionManager:\n    def __init__(self, ctx, precfun, dpsfun, normalize_output=False):\n        self.ctx = ctx\n        self.precfun = precfun\n        self.dpsfun = dpsfun\n        self.normalize_output = normalize_output\n    def __call__(self, f):\n        @functools.wraps(f)\n        def g(*args, **kwargs):\n            orig = self.ctx.prec\n            try:\n                if self.precfun:\n                    self.ctx.prec = self.precfun(self.ctx.prec)\n                else:\n                    self.ctx.dps = self.dpsfun(self.ctx.dps)\n                if self.normalize_output:\n                    v = f(*args, **kwargs)\n                    if type(v) is tuple:\n                        return tuple([+a for a in v])\n                    return +v\n                else:\n                    return f(*args, **kwargs)\n            finally:\n                self.ctx.prec = orig\n        return g\n    def __enter__(self):\n        self.origp = self.ctx.prec\n        if self.precfun:\n            self.ctx.prec = self.precfun(self.ctx.prec)\n        else:\n            self.ctx.dps = self.dpsfun(self.ctx.dps)\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.ctx.prec = self.origp\n        return False\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n", "import random\nfrom mpmath import *\nfrom mpmath.libmp import *\n\n\ndef test_basic_string():\n    \"\"\"\n    Test basic string conversion\n    \"\"\"\n    mp.dps = 15\n    assert mpf('3') == mpf('3.0') == mpf('0003.') == mpf('0.03e2') == mpf(3.0)\n    assert mpf('30') == mpf('30.0') == mpf('00030.') == mpf(30.0)\n    for i in range(10):\n        for j in range(10):\n            assert mpf('%ie%i' % (i,j)) == i * 10**j\n    assert str(mpf('25000.0')) == '25000.0'\n    assert str(mpf('2500.0')) == '2500.0'\n    assert str(mpf('250.0')) == '250.0'\n    assert str(mpf('25.0')) == '25.0'\n    assert str(mpf('2.5')) == '2.5'\n    assert str(mpf('0.25')) == '0.25'\n    assert str(mpf('0.025')) == '0.025'\n    assert str(mpf('0.0025')) == '0.0025'\n    assert str(mpf('0.00025')) == '0.00025'\n    assert str(mpf('0.000025')) == '2.5e-5'\n    assert str(mpf(0)) == '0.0'\n    assert str(mpf('2.5e1000000000000000000000')) == '2.5e+1000000000000000000000'\n    assert str(mpf('2.6e-1000000000000000000000')) == '2.6e-1000000000000000000000'\n    assert str(mpf(1.23402834e-15)) == '1.23402834e-15'\n    assert str(mpf(-1.23402834e-15)) == '-1.23402834e-15'\n    assert str(mpf(-1.2344e-15)) == '-1.2344e-15'\n    assert repr(mpf(-1.2344e-15)) == \"mpf('-1.2343999999999999e-15')\"\n    assert str(mpf(\"2163048125L\")) == '2163048125.0'\n    assert str(mpf(\"-2163048125l\")) == '-2163048125.0'\n    assert str(mpf(\"-2163048125L/1088391168\")) == '-1.98738118113799'\n    assert str(mpf(\"2163048125/1088391168l\")) == '1.98738118113799'\n\ndef test_pretty():\n    mp.pretty = True\n    assert repr(mpf(2.5)) == '2.5'\n    assert repr(mpc(2.5,3.5)) == '(2.5 + 3.5j)'\n    mp.pretty = False\n    iv.pretty = True\n    assert repr(mpi(2.5,3.5)) == '[2.5, 3.5]'\n    iv.pretty = False\n\ndef test_str_whitespace():\n    assert mpf('1.26 ') == 1.26\n\ndef test_unicode():\n    mp.dps = 15\n    try:\n        unicode = unicode\n    except NameError:\n        unicode = str\n    assert mpf(unicode('2.76')) == 2.76\n    assert mpf(unicode('inf')) == inf\n\ndef test_str_format():\n    assert to_str(from_float(0.1),15,strip_zeros=False) == '0.100000000000000'\n    assert to_str(from_float(0.0),15,show_zero_exponent=True) == '0.0e+0'\n    assert to_str(from_float(0.0),0,show_zero_exponent=True) == '.0e+0'\n    assert to_str(from_float(0.0),0,show_zero_exponent=False) == '.0'\n    assert to_str(from_float(0.0),1,show_zero_exponent=True) == '0.0e+0'\n    assert to_str(from_float(0.0),1,show_zero_exponent=False) == '0.0'\n    assert to_str(from_float(1.23),3,show_zero_exponent=True) == '1.23e+0'\n    assert to_str(from_float(1.23456789000000e-2),15,strip_zeros=False,min_fixed=0,max_fixed=0) == '1.23456789000000e-2'\n    assert to_str(from_float(1.23456789000000e+2),15,strip_zeros=False,min_fixed=0,max_fixed=0) == '1.23456789000000e+2'\n    assert to_str(from_float(2.1287e14), 15, max_fixed=1000) == '212870000000000.0'\n    assert to_str(from_float(2.1287e15), 15, max_fixed=1000) == '2128700000000000.0'\n    assert to_str(from_float(2.1287e16), 15, max_fixed=1000) == '21287000000000000.0'\n    assert to_str(from_float(2.1287e30), 15, max_fixed=1000) == '2128700000000000000000000000000.0'\n\ndef test_tight_string_conversion():\n    mp.dps = 15\n    # In an old version, '0.5' wasn't recognized as representing\n    # an exact binary number and was erroneously rounded up or down\n    assert from_str('0.5', 10, round_floor) == fhalf\n    assert from_str('0.5', 10, round_ceiling) == fhalf\n\ndef test_eval_repr_invariant():\n    \"\"\"Test that eval(repr(x)) == x\"\"\"\n    random.seed(123)\n    for dps in [10, 15, 20, 50, 100]:\n        mp.dps = dps\n        for i in range(1000):\n            a = mpf(random.random())**0.5 * 10**random.randint(-100, 100)\n            assert eval(repr(a)) == a\n    mp.dps = 15\n\ndef test_str_bugs():\n    mp.dps = 15\n    # Decimal rounding used to give the wrong exponent in some cases\n    assert str(mpf('1e600')) == '1.0e+600'\n    assert str(mpf('1e10000')) == '1.0e+10000'\n\ndef test_str_prec0():\n    assert to_str(from_float(1.234), 0) == '.0e+0'\n    assert to_str(from_float(1e-15), 0) == '.0e-15'\n    assert to_str(from_float(1e+15), 0) == '.0e+15'\n    assert to_str(from_float(-1e-15), 0) == '-.0e-15'\n    assert to_str(from_float(-1e+15), 0) == '-.0e+15'\n\ndef test_convert_rational():\n    mp.dps = 15\n    assert from_rational(30, 5, 53, round_nearest) == (0, 3, 1, 2)\n    assert from_rational(-7, 4, 53, round_nearest) == (1, 7, -2, 3)\n    assert to_rational((0, 1, -1, 1)) == (1, 2)\n\ndef test_custom_class():\n    class mympf:\n        @property\n        def _mpf_(self):\n            return mpf(3.5)._mpf_\n    class mympc:\n        @property\n        def _mpc_(self):\n            return mpf(3.5)._mpf_, mpf(2.5)._mpf_\n    assert mpf(2) + mympf() == 5.5\n    assert mympf() + mpf(2) == 5.5\n    assert mpf(mympf()) == 3.5\n    assert mympc() + mpc(2) == mpc(5.5, 2.5)\n    assert mpc(2) + mympc() == mpc(5.5, 2.5)\n    assert mpc(mympc()) == (3.5+2.5j)\n\ndef test_conversion_methods():\n    class SomethingRandom:\n        pass\n    class SomethingReal:\n        def _mpmath_(self, prec, rounding):\n            return mp.make_mpf(from_str('1.3', prec, rounding))\n    class SomethingComplex:\n        def _mpmath_(self, prec, rounding):\n            return mp.make_mpc((from_str('1.3', prec, rounding), \\\n                from_str('1.7', prec, rounding)))\n    x = mpf(3)\n    z = mpc(3)\n    a = SomethingRandom()\n    y = SomethingReal()\n    w = SomethingComplex()\n    for d in [15, 45]:\n        mp.dps = d\n        assert (x+y).ae(mpf('4.3'))\n        assert (y+x).ae(mpf('4.3'))\n        assert (x+w).ae(mpc('4.3', '1.7'))\n        assert (w+x).ae(mpc('4.3', '1.7'))\n        assert (z+y).ae(mpc('4.3'))\n        assert (y+z).ae(mpc('4.3'))\n        assert (z+w).ae(mpc('4.3', '1.7'))\n        assert (w+z).ae(mpc('4.3', '1.7'))\n        x-y; y-x; x-w; w-x; z-y; y-z; z-w; w-z\n        x*y; y*x; x*w; w*x; z*y; y*z; z*w; w*z\n        x/y; y/x; x/w; w/x; z/y; y/z; z/w; w/z\n        x**y; y**x; x**w; w**x; z**y; y**z; z**w; w**z\n        x==y; y==x; x==w; w==x; z==y; y==z; z==w; w==z\n    mp.dps = 15\n    assert x.__add__(a) is NotImplemented\n    assert x.__radd__(a) is NotImplemented\n    assert x.__lt__(a) is NotImplemented\n    assert x.__gt__(a) is NotImplemented\n    assert x.__le__(a) is NotImplemented\n    assert x.__ge__(a) is NotImplemented\n    assert x.__eq__(a) is NotImplemented\n    assert x.__ne__(a) is NotImplemented\n    # implementation detail\n    if hasattr(x, \"__cmp__\"):\n        assert x.__cmp__(a) is NotImplemented\n    assert x.__sub__(a) is NotImplemented\n    assert x.__rsub__(a) is NotImplemented\n    assert x.__mul__(a) is NotImplemented\n    assert x.__rmul__(a) is NotImplemented\n    assert x.__div__(a) is NotImplemented\n    assert x.__rdiv__(a) is NotImplemented\n    assert x.__mod__(a) is NotImplemented\n    assert x.__rmod__(a) is NotImplemented\n    assert x.__pow__(a) is NotImplemented\n    assert x.__rpow__(a) is NotImplemented\n    assert z.__add__(a) is NotImplemented\n    assert z.__radd__(a) is NotImplemented\n    assert z.__eq__(a) is NotImplemented\n    assert z.__ne__(a) is NotImplemented\n    assert z.__sub__(a) is NotImplemented\n    assert z.__rsub__(a) is NotImplemented\n    assert z.__mul__(a) is NotImplemented\n    assert z.__rmul__(a) is NotImplemented\n    assert z.__div__(a) is NotImplemented\n    assert z.__rdiv__(a) is NotImplemented\n    assert z.__pow__(a) is NotImplemented\n    assert z.__rpow__(a) is NotImplemented\n\ndef test_mpmathify():\n    assert mpmathify('1/2') == 0.5\n    assert mpmathify('(1.0+1.0j)') == mpc(1, 1)\n    assert mpmathify('(1.2e-10 - 3.4e5j)') == mpc('1.2e-10', '-3.4e5')\n    assert mpmathify('1j') == mpc(1j)\n\ndef test_issue548():\n    try:\n        # This expression is invalid, but may trigger the ReDOS vulnerability\n        # in the regular expression for parsing complex numbers.\n        mpmathify('(' + '1' * 5000 + '!j')\n    except:\n        return\n    # The expression is invalid and should raise an exception.\n    assert False\n\ndef test_compatibility():\n    try:\n        import numpy as np\n        from fractions import Fraction\n        from decimal import Decimal\n        import decimal\n    except ImportError:\n        return\n    # numpy types\n    for nptype in np.core.numerictypes.typeDict.values():\n        if issubclass(nptype, np.complexfloating):\n            x = nptype(complex(0.5, -0.5))\n        elif issubclass(nptype, np.floating):\n            x = nptype(0.5)\n        elif issubclass(nptype, np.integer):\n            x = nptype(2)\n        # Handle the weird types\n        try: diff = np.abs(type(np.sqrt(x))(sqrt(x)) - np.sqrt(x))\n        except: continue\n        assert diff < 2.0**-53\n    #Fraction and Decimal\n    oldprec = mp.prec\n    mp.prec = 1000\n    decimal.getcontext().prec = mp.dps\n    assert sqrt(Fraction(2, 3)).ae(sqrt(mpf('2/3')))\n    assert sqrt(Decimal(2)/Decimal(3)).ae(sqrt(mpf('2/3')))\n    mp.prec = oldprec\n"], "filenames": ["mpmath/ctx_mp.py", "mpmath/tests/test_convert.py"], "buggy_code_start_loc": [45, 196], "buggy_code_end_loc": [47, 196], "fixing_code_start_loc": [45, 197], "fixing_code_end_loc": [47, 207], "type": "CWE-770", "message": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in Mpmath v1.0.0 through v1.2.1 when the mpmathify function is called.", "other": {"cve": {"id": "CVE-2021-29063", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-21T20:15:09.477", "lastModified": "2023-05-16T18:15:15.993", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in Mpmath v1.0.0 through v1.2.1 when the mpmathify function is called."}, {"lang": "es", "value": "Se ha descubierto una vulnerabilidad de denegaci\u00f3n de servicio de expresiones regulares (ReDOS) en Mpmath v1.0.0 hasta v1.2.1 cuando se llama a la funci\u00f3n mpmathify"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mpmath:mpmath:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndIncluding": "1.2.1", "matchCriteriaId": "411AC4E0-EC58-4622-B290-B997406F60B9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/fredrik-johansson/mpmath/commit/46d44c3c8f3244017fe1eb102d564eb4ab8ef750", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mpmath/mpmath/releases/tag/1.3.0", "source": "cve@mitre.org"}, {"url": "https://github.com/npm/hosted-git-info/pull/76", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/yetingli/PoCs/blob/main/CVE-2021-29063/Mpmath.md", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/yetingli/SaveResults/blob/main/js/hosted-git-info.js", "source": "cve@mitre.org", "tags": ["Not Applicable", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3M5O55E7VUDMXCPQR6MQTOIFDKHP36AA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EIUX3XWY2K3MSO7QXMZXQQYAURARSPC5/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MS2U6GLXQSRZJE2HVUAUMVFR2DWQLCZG/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/hosted-git-info", "source": "cve@mitre.org", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/fredrik-johansson/mpmath/commit/46d44c3c8f3244017fe1eb102d564eb4ab8ef750"}}