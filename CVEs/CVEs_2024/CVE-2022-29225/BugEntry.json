{"buggy_code": ["1.22.1 (Pending)\n================\n\nIncompatible Behavior Changes\n-----------------------------\n*Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\nMinor Behavior Changes\n----------------------\n*Changes that may cause incompatibilities for some users, but should not for most*\n\nBug Fixes\n---------\n*Changes expected to improve the state of the world and are unlikely to have negative effects*\n\n\nRemoved Config or Runtime\n-------------------------\n*Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n\n\nNew Features\n------------\n\nDeprecated\n----------\n", "#include \"source/common/runtime/runtime_features.h\"\n\n#include \"absl/flags/commandlineflag.h\"\n#include \"absl/flags/flag.h\"\n#include \"absl/strings/match.h\"\n#include \"absl/strings/str_replace.h\"\n\n#define RUNTIME_GUARD(name) ABSL_FLAG(bool, name, true, \"\");        // NOLINT\n#define FALSE_RUNTIME_GUARD(name) ABSL_FLAG(bool, name, false, \"\"); // NOLINT\n\n// Add additional features here to enable the new code paths by default.\n//\n// Per documentation in CONTRIBUTING.md is expected that new high risk code paths be guarded\n// by runtime feature guards. If you add a guard of the form\n// RUNTIME_GUARD(envoy_reloadable_features_my_feature_name)\n// here you can guard code checking against \"envoy.reloadable_features.my_feature_name\".\n// Please note the swap of envoy_reloadable_features_ to envoy.reloadable_features.!\n//\n// if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.my_feature_name\")) {\n//   [new code path]\n// else {\n//   [old_code_path]\n// }\n//\n// Runtime features are true by default, so the new code path is exercised.\n// To make a runtime feature false by default, use FALSE_RUNTIME_GUARD, and add\n// a TODO to change it to true.\n//\n// If issues are found that require a runtime feature to be disabled, it should be reported\n// ASAP by filing a bug on github. Overriding non-buggy code is strongly discouraged to avoid the\n// problem of the bugs being found after the old code path has been removed.\nRUNTIME_GUARD(envoy_reloadable_features_allow_adding_content_type_in_local_replies);\nRUNTIME_GUARD(envoy_reloadable_features_allow_upstream_inline_write);\nRUNTIME_GUARD(envoy_reloadable_features_append_or_truncate);\nRUNTIME_GUARD(envoy_reloadable_features_append_to_accept_content_encoding_only_once);\nRUNTIME_GUARD(envoy_reloadable_features_conn_pool_delete_when_idle);\nRUNTIME_GUARD(envoy_reloadable_features_conn_pool_new_stream_with_early_data_and_http3);\nRUNTIME_GUARD(envoy_reloadable_features_correct_scheme_and_xfp);\nRUNTIME_GUARD(envoy_reloadable_features_correctly_validate_alpn);\nRUNTIME_GUARD(envoy_reloadable_features_deprecate_global_ints);\nRUNTIME_GUARD(envoy_reloadable_features_disable_tls_inspector_injection);\nRUNTIME_GUARD(envoy_reloadable_features_do_not_await_headers_on_upstream_timeout_to_emit_stats);\nRUNTIME_GUARD(envoy_reloadable_features_enable_grpc_async_client_cache);\nRUNTIME_GUARD(envoy_reloadable_features_fix_added_trailers);\nRUNTIME_GUARD(envoy_reloadable_features_handle_stream_reset_during_hcm_encoding);\nRUNTIME_GUARD(envoy_reloadable_features_http1_lazy_read_disable);\nRUNTIME_GUARD(envoy_reloadable_features_http2_allow_capacity_increase_by_settings);\nRUNTIME_GUARD(envoy_reloadable_features_http2_new_codec_wrapper);\nRUNTIME_GUARD(envoy_reloadable_features_http_100_continue_case_insensitive);\nRUNTIME_GUARD(envoy_reloadable_features_http_ext_authz_do_not_skip_direct_response_and_redirect);\nRUNTIME_GUARD(envoy_reloadable_features_http_reject_path_with_fragment);\nRUNTIME_GUARD(envoy_reloadable_features_http_strip_fragment_from_path_unsafe_if_disabled);\nRUNTIME_GUARD(envoy_reloadable_features_internal_address);\nRUNTIME_GUARD(envoy_reloadable_features_listener_reuse_port_default_enabled);\nRUNTIME_GUARD(envoy_reloadable_features_new_tcp_connection_pool);\nRUNTIME_GUARD(envoy_reloadable_features_no_extension_lookup_by_name);\nRUNTIME_GUARD(envoy_reloadable_features_override_request_timeout_by_gateway_timeout);\nRUNTIME_GUARD(envoy_reloadable_features_postpone_h3_client_connect_to_next_loop);\nRUNTIME_GUARD(envoy_reloadable_features_proxy_102_103);\nRUNTIME_GUARD(envoy_reloadable_features_sanitize_http_header_referer);\nRUNTIME_GUARD(envoy_reloadable_features_skip_delay_close);\nRUNTIME_GUARD(envoy_reloadable_features_skip_dispatching_frames_for_closed_connection);\nRUNTIME_GUARD(envoy_reloadable_features_strict_check_on_ipv4_compat);\nRUNTIME_GUARD(envoy_reloadable_features_support_locality_update_on_eds_cluster_endpoints);\nRUNTIME_GUARD(envoy_reloadable_features_test_feature_true);\nRUNTIME_GUARD(envoy_reloadable_features_top_level_ecds_stats);\nRUNTIME_GUARD(envoy_reloadable_features_udp_listener_updates_filter_chain_in_place);\nRUNTIME_GUARD(envoy_reloadable_features_update_expected_rq_timeout_on_retry);\nRUNTIME_GUARD(envoy_reloadable_features_update_grpc_response_error_tag);\nRUNTIME_GUARD(envoy_reloadable_features_use_dns_ttl);\nRUNTIME_GUARD(envoy_reloadable_features_validate_connect);\nRUNTIME_GUARD(envoy_restart_features_explicit_wildcard_resource);\nRUNTIME_GUARD(envoy_restart_features_no_runtime_singleton);\nRUNTIME_GUARD(envoy_restart_features_use_apple_api_for_dns_lookups);\n\n// Begin false flags. These should come with a TODO to flip true.\n// Sentinel and test flag.\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_test_feature_false);\n// TODO(alyssawilk) flip true once H2 caching is on by default.\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_allow_concurrency_for_alpn_pool);\n// TODO(alyssawilk, junr03) flip (and add release notes + docs) these after Lyft tests\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_allow_multiple_dns_addresses);\n// TODO(adisuissa) reset to true to enable unified mux by default\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_unified_mux);\n// TODO(kbaichoo): Make this enabled by default when fairness and chunking\n// are implemented, and we've had more cpu time.\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_defer_processing_backedup_streams);\n// TODO(rgs1): Make this enabled after Pinterest tests\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_thrift_connection_draining);\n// TODO(birenroy) flip after a burn-in period\n// Requires envoy_reloadable_features_http2_new_codec_wrapper to be enabled.\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_http2_use_oghttp2);\n// Used to track if runtime is initialized.\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_runtime_initialized);\n\n// Block of non-boolean flags. These are deprecated. Do not add more.\nABSL_FLAG(uint64_t, envoy_headermap_lazy_map_min_size, 3, \"\");  // NOLINT\nABSL_FLAG(uint64_t, re2_max_program_size_error_level, 100, \"\"); // NOLINT\nABSL_FLAG(uint64_t, re2_max_program_size_warn_level,            // NOLINT\n          std::numeric_limits<uint32_t>::max(), \"\");            // NOLINT\n\nnamespace Envoy {\nnamespace Runtime {\nnamespace {\n\nstd::string swapPrefix(std::string name) {\n  return absl::StrReplaceAll(name, {{\"envoy_\", \"envoy.\"}, {\"features_\", \"features.\"}});\n}\n\n} // namespace\n\n// This is a singleton class to map Envoy style flag names to absl flags\nclass RuntimeFeatures {\npublic:\n  RuntimeFeatures();\n\n  // Get the command line flag corresponding to the Envoy style feature name, or\n  // nullptr if it is not a registered flag.\n  absl::CommandLineFlag* getFlag(absl::string_view feature) const {\n    auto it = all_features_.find(feature);\n    if (it == all_features_.end()) {\n      return nullptr;\n    }\n    return it->second;\n  }\n\nprivate:\n  absl::flat_hash_map<std::string, absl::CommandLineFlag*> all_features_;\n};\n\nusing RuntimeFeaturesDefaults = ConstSingleton<RuntimeFeatures>;\n\nRuntimeFeatures::RuntimeFeatures() {\n  absl::flat_hash_map<absl::string_view, absl::CommandLineFlag*> flags = absl::GetAllFlags();\n  for (auto& it : flags) {\n    absl::string_view name = it.second->Name();\n    if ((!absl::StartsWith(name, \"envoy_reloadable_features_\") &&\n         !absl::StartsWith(name, \"envoy_restart_features_\")) ||\n        !it.second->TryGet<bool>().has_value()) {\n      continue;\n    }\n    std::string envoy_name = swapPrefix(std::string(name));\n    all_features_.emplace(envoy_name, it.second);\n  }\n}\n\nbool hasRuntimePrefix(absl::string_view feature) {\n  // Track Envoy reloadable and restart features, excluding synthetic QUIC flags\n  // which are not tracked in the list below.\n  return (absl::StartsWith(feature, \"envoy.reloadable_features.\") &&\n          !absl::StartsWith(feature, \"envoy.reloadable_features.FLAGS_quic\")) ||\n         absl::StartsWith(feature, \"envoy.restart_features.\");\n}\n\nbool isRuntimeFeature(absl::string_view feature) {\n  return RuntimeFeaturesDefaults::get().getFlag(feature) != nullptr;\n}\n\nbool runtimeFeatureEnabled(absl::string_view feature) {\n  absl::CommandLineFlag* flag = RuntimeFeaturesDefaults::get().getFlag(feature);\n  if (flag == nullptr) {\n    IS_ENVOY_BUG(absl::StrCat(\"Unable to find runtime feature \", feature));\n    return false;\n  }\n  // We validate in map creation that the flag is a boolean.\n  return flag->TryGet<bool>().value();\n}\n\nuint64_t getInteger(absl::string_view feature, uint64_t default_value) {\n  if (absl::StartsWith(feature, \"envoy.\")) {\n    // DO NOT ADD MORE FLAGS HERE. This function deprecated.\n    if (feature == \"envoy.http.headermap.lazy_map_min_size\") {\n      return absl::GetFlag(FLAGS_envoy_headermap_lazy_map_min_size);\n    }\n  }\n  if (absl::StartsWith(feature, \"re2.\")) {\n    if (feature == \"re2.max_program_size.error_level\") {\n      return absl::GetFlag(FLAGS_re2_max_program_size_error_level);\n    } else if (feature == \"re2.max_program_size.warn_level\") {\n      return absl::GetFlag(FLAGS_re2_max_program_size_warn_level);\n    }\n  }\n  IS_ENVOY_BUG(absl::StrCat(\"requested an unsupported integer \", feature));\n  return default_value;\n}\n\nvoid markRuntimeInitialized() {\n  maybeSetRuntimeGuard(\"envoy.reloadable_features.runtime_initialized\", true);\n}\n\nbool isRuntimeInitialized() {\n  return runtimeFeatureEnabled(\"envoy.reloadable_features.runtime_initialized\");\n}\n\nvoid maybeSetRuntimeGuard(absl::string_view name, bool value) {\n  absl::CommandLineFlag* flag = RuntimeFeaturesDefaults::get().getFlag(name);\n  if (flag == nullptr) {\n    IS_ENVOY_BUG(absl::StrCat(\"Unable to find runtime feature \", name));\n    return;\n  }\n  std::string err;\n  flag->ParseFrom(value ? \"true\" : \"false\", &err);\n}\n\nvoid maybeSetDeprecatedInts(absl::string_view name, uint32_t value) {\n  if (!absl::StartsWith(name, \"envoy.\") && !absl::StartsWith(name, \"re2.\")) {\n    return;\n  }\n\n  // DO NOT ADD MORE FLAGS HERE. This function deprecated and being removed.\n  if (name == \"envoy.http.headermap.lazy_map_min_size\") {\n    if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.deprecate_global_ints\")) {\n      IS_ENVOY_BUG(absl::StrCat(\n          \"The Envoy community is attempting to remove global integers. Given you use \", name,\n          \" please immediately file an upstream issue to retain the functionality as it will \"\n          \"otherwise be removed following the usual deprecation cycle.\"));\n    }\n    absl::SetFlag(&FLAGS_envoy_headermap_lazy_map_min_size, value);\n  } else if (name == \"re2.max_program_size.error_level\") {\n    absl::SetFlag(&FLAGS_re2_max_program_size_error_level, value);\n  } else if (name == \"re2.max_program_size.warn_level\") {\n    absl::SetFlag(&FLAGS_re2_max_program_size_warn_level, value);\n  }\n}\n\n} // namespace Runtime\n} // namespace Envoy\n", "#include \"source/extensions/compression/brotli/common/base.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Brotli {\nnamespace Common {\n\nBrotliContext::BrotliContext(const uint32_t chunk_size)\n    : chunk_size_{chunk_size}, chunk_ptr_{std::make_unique<uint8_t[]>(chunk_size)}, next_in_{},\n      next_out_{chunk_ptr_.get()}, avail_in_{0}, avail_out_{chunk_size} {}\n\nvoid BrotliContext::updateOutput(Buffer::Instance& output_buffer) {\n  if (avail_out_ == 0) {\n    output_buffer.add(static_cast<void*>(chunk_ptr_.get()), chunk_size_);\n    resetOut();\n  }\n}\n\nvoid BrotliContext::finalizeOutput(Buffer::Instance& output_buffer) {\n  const size_t n_output = chunk_size_ - avail_out_;\n  if (n_output > 0) {\n    output_buffer.add(static_cast<void*>(chunk_ptr_.get()), n_output);\n  }\n}\n\nvoid BrotliContext::resetOut() {\n  avail_out_ = chunk_size_;\n  next_out_ = chunk_ptr_.get();\n}\n\n} // namespace Common\n} // namespace Brotli\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include <memory>\n\n#include \"envoy/buffer/buffer.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Brotli {\nnamespace Common {\n\n// Keeps a `Brotli` compression stream's state.\nstruct BrotliContext {\n  BrotliContext(const uint32_t chunk_size);\n\n  void updateOutput(Buffer::Instance& output_buffer);\n  void finalizeOutput(Buffer::Instance& output_buffer);\n\n  const uint32_t chunk_size_;\n  std::unique_ptr<uint8_t[]> chunk_ptr_;\n  const uint8_t* next_in_;\n  uint8_t* next_out_;\n  size_t avail_in_;\n  size_t avail_out_;\n\nprivate:\n  void resetOut();\n};\n\n} // namespace Common\n} // namespace Brotli\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "load(\n    \"//bazel:envoy_build_system.bzl\",\n    \"envoy_cc_extension\",\n    \"envoy_cc_library\",\n    \"envoy_extension_package\",\n)\n\nlicenses([\"notice\"])  # Apache 2\n\nenvoy_extension_package()\n\nenvoy_cc_library(\n    name = \"decompressor_lib\",\n    srcs = [\"brotli_decompressor_impl.cc\"],\n    hdrs = [\"brotli_decompressor_impl.h\"],\n    external_deps = [\"brotlidec\"],\n    deps = [\n        \"//envoy/compression/decompressor:decompressor_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//envoy/stats:stats_macros\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/extensions/compression/brotli/common:brotli_base_lib\",\n    ],\n)\n\nenvoy_cc_extension(\n    name = \"config\",\n    srcs = [\"config.cc\"],\n    hdrs = [\"config.h\"],\n    deps = [\n        \":decompressor_lib\",\n        \"//source/common/http:headers_lib\",\n        \"//source/extensions/compression/common/decompressor:decompressor_factory_base_lib\",\n        \"@envoy_api//envoy/extensions/compression/brotli/decompressor/v3:pkg_cc_proto\",\n    ],\n)\n", "#include \"source/extensions/compression/brotli/decompressor/brotli_decompressor_impl.h\"\n\n#include <memory>\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Brotli {\nnamespace Decompressor {\n\nBrotliDecompressorImpl::BrotliDecompressorImpl(Stats::Scope& scope, const std::string& stats_prefix,\n                                               const uint32_t chunk_size,\n                                               const bool disable_ring_buffer_reallocation)\n    : chunk_size_{chunk_size},\n      state_(BrotliDecoderCreateInstance(nullptr, nullptr, nullptr), &BrotliDecoderDestroyInstance),\n      stats_(generateStats(stats_prefix, scope)) {\n  BROTLI_BOOL result =\n      BrotliDecoderSetParameter(state_.get(), BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION,\n                                disable_ring_buffer_reallocation ? BROTLI_TRUE : BROTLI_FALSE);\n  RELEASE_ASSERT(result == BROTLI_TRUE, \"\");\n}\n\nvoid BrotliDecompressorImpl::decompress(const Buffer::Instance& input_buffer,\n                                        Buffer::Instance& output_buffer) {\n  Common::BrotliContext ctx(chunk_size_);\n\n  for (const Buffer::RawSlice& input_slice : input_buffer.getRawSlices()) {\n    ctx.avail_in_ = input_slice.len_;\n    ctx.next_in_ = static_cast<uint8_t*>(input_slice.mem_);\n\n    while (ctx.avail_in_ > 0) {\n      if (!process(ctx, output_buffer)) {\n        ctx.finalizeOutput(output_buffer);\n        return;\n      }\n    }\n  }\n\n  // Even though the input has been fully consumed by the decoder it still can\n  // be unfolded into output not fitting the output chunk. Thus keep processing\n  // until the decoder's output is fully depleted.\n  bool success;\n  do {\n    success = process(ctx, output_buffer);\n  } while (success && BrotliDecoderHasMoreOutput(state_.get()));\n\n  ctx.finalizeOutput(output_buffer);\n}\n\nbool BrotliDecompressorImpl::process(Common::BrotliContext& ctx, Buffer::Instance& output_buffer) {\n  BrotliDecoderResult result;\n  result = BrotliDecoderDecompressStream(state_.get(), &ctx.avail_in_, &ctx.next_in_,\n                                         &ctx.avail_out_, &ctx.next_out_, nullptr);\n  if (result == BROTLI_DECODER_RESULT_ERROR) {\n    // TODO(rojkov): currently the Brotli library doesn't specify possible errors in its API. Add\n    // more detailed stats when they are documented.\n    stats_.brotli_error_.inc();\n    return false;\n  }\n\n  ctx.updateOutput(output_buffer);\n\n  return true;\n}\n\n} // namespace Decompressor\n} // namespace Brotli\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include <memory>\n\n#include \"envoy/buffer/buffer.h\"\n\n#include \"zlib.h\"\n\nnamespace Envoy {\nnamespace Zlib {\n\n/**\n * Shared code between the compressor and the decompressor.\n */\n// TODO(junr03): move to extensions tree once the compressor side is moved to extensions.\nclass Base {\npublic:\n  Base(uint64_t chunk_size, std::function<void(z_stream*)> zstream_deleter);\n\n  /**\n   * It returns the checksum of all output produced so far. Compressor's checksum at the end of\n   * the stream has to match decompressor's checksum produced at the end of the decompression.\n   * Likewise, the decompressor's checksum has to match the compressor's checksum at the end of\n   * compression.\n   * @return uint64_t CRC-32 if a gzip stream is being read or Adler-32 for other compression\n   * types.\n   */\n  uint64_t checksum();\n\nprotected:\n  void updateOutput(Buffer::Instance& output_buffer);\n\n  const uint64_t chunk_size_;\n  bool initialized_{false};\n\n  const std::unique_ptr<unsigned char[]> chunk_char_ptr_;\n  const std::unique_ptr<z_stream, std::function<void(z_stream*)>> zstream_ptr_;\n};\n\n} // namespace Zlib\n} // namespace Envoy\n", "load(\n    \"//bazel:envoy_build_system.bzl\",\n    \"envoy_cc_extension\",\n    \"envoy_cc_library\",\n    \"envoy_extension_package\",\n)\n\nlicenses([\"notice\"])  # Apache 2\n\nenvoy_extension_package()\n\nenvoy_cc_library(\n    name = \"zlib_decompressor_impl_lib\",\n    srcs = [\"zlib_decompressor_impl.cc\"],\n    hdrs = [\"zlib_decompressor_impl.h\"],\n    external_deps = [\"zlib\"],\n    deps = [\n        \"//envoy/compression/decompressor:decompressor_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//envoy/stats:stats_macros\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:minimal_logger_lib\",\n        \"//source/extensions/compression/gzip/common:zlib_base_lib\",\n    ],\n)\n\nenvoy_cc_extension(\n    name = \"config\",\n    srcs = [\"config.cc\"],\n    hdrs = [\"config.h\"],\n    deps = [\n        \":zlib_decompressor_impl_lib\",\n        \"//source/common/http:headers_lib\",\n        \"//source/extensions/compression/common/decompressor:decompressor_factory_base_lib\",\n        \"@envoy_api//envoy/extensions/compression/gzip/decompressor/v3:pkg_cc_proto\",\n    ],\n)\n", "#include \"source/extensions/compression/gzip/decompressor/zlib_decompressor_impl.h\"\n\n#include <zlib.h>\n\n#include <memory>\n\n#include \"envoy/common/exception.h\"\n\n#include \"source/common/common/assert.h\"\n\n#include \"absl/container/fixed_array.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Gzip {\nnamespace Decompressor {\n\nZlibDecompressorImpl::ZlibDecompressorImpl(Stats::Scope& scope, const std::string& stats_prefix)\n    : ZlibDecompressorImpl(scope, stats_prefix, 4096) {}\n\nZlibDecompressorImpl::ZlibDecompressorImpl(Stats::Scope& scope, const std::string& stats_prefix,\n                                           uint64_t chunk_size)\n    : Zlib::Base(chunk_size,\n                 [](z_stream* z) {\n                   inflateEnd(z);\n                   delete z;\n                 }),\n      stats_(generateStats(stats_prefix, scope)) {\n  zstream_ptr_->zalloc = Z_NULL;\n  zstream_ptr_->zfree = Z_NULL;\n  zstream_ptr_->opaque = Z_NULL;\n  zstream_ptr_->avail_out = chunk_size_;\n  zstream_ptr_->next_out = chunk_char_ptr_.get();\n}\n\nvoid ZlibDecompressorImpl::init(int64_t window_bits) {\n  ASSERT(initialized_ == false);\n  const int result = inflateInit2(zstream_ptr_.get(), window_bits);\n  RELEASE_ASSERT(result >= 0, \"\");\n  initialized_ = true;\n}\n\nvoid ZlibDecompressorImpl::decompress(const Buffer::Instance& input_buffer,\n                                      Buffer::Instance& output_buffer) {\n  for (const Buffer::RawSlice& input_slice : input_buffer.getRawSlices()) {\n    zstream_ptr_->avail_in = input_slice.len_;\n    zstream_ptr_->next_in = static_cast<Bytef*>(input_slice.mem_);\n    while (inflateNext()) {\n      if (zstream_ptr_->avail_out == 0) {\n        updateOutput(output_buffer);\n      }\n    }\n  }\n\n  // Flush z_stream and reset its buffer. Otherwise the stale content of the buffer\n  // will pollute output upon the next call to decompress().\n  updateOutput(output_buffer);\n}\n\nbool ZlibDecompressorImpl::inflateNext() {\n  const int result = inflate(zstream_ptr_.get(), Z_NO_FLUSH);\n  if (result == Z_STREAM_END) {\n    // Z_FINISH informs inflate to not maintain a sliding window if the stream completes, which\n    // reduces inflate's memory footprint. Ref: https://www.zlib.net/manual.html.\n    inflate(zstream_ptr_.get(), Z_FINISH);\n    return false;\n  }\n\n  if (result == Z_BUF_ERROR && zstream_ptr_->avail_in == 0) {\n    return false; // This means that zlib needs more input, so stop here.\n  }\n\n  if (result < 0) {\n    decompression_error_ = result;\n    ENVOY_LOG(trace,\n              \"zlib decompression error: {}, msg: {}. Error codes are defined in \"\n              \"https://www.zlib.net/manual.html\",\n              result, zstream_ptr_->msg);\n    chargeErrorStats(result);\n    return false;\n  }\n\n  return true;\n}\n\nvoid ZlibDecompressorImpl::chargeErrorStats(const int result) {\n  switch (result) {\n  case Z_ERRNO:\n    stats_.zlib_errno_.inc();\n    break;\n  case Z_STREAM_ERROR:\n    stats_.zlib_stream_error_.inc();\n    break;\n  case Z_DATA_ERROR:\n    stats_.zlib_data_error_.inc();\n    break;\n  case Z_MEM_ERROR:\n    stats_.zlib_mem_error_.inc();\n    break;\n  case Z_BUF_ERROR:\n    stats_.zlib_buf_error_.inc();\n    break;\n  case Z_VERSION_ERROR:\n    stats_.zlib_version_error_.inc();\n    break;\n  }\n}\n\n} // namespace Decompressor\n} // namespace Gzip\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/compression/zstd/decompressor/zstd_decompressor_impl.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Zstd {\nnamespace Decompressor {\n\nZstdDecompressorImpl::ZstdDecompressorImpl(Stats::Scope& scope, const std::string& stats_prefix,\n                                           const ZstdDDictManagerPtr& ddict_manager,\n                                           uint32_t chunk_size)\n    : Common::Base(chunk_size), dctx_(ZSTD_createDCtx(), &ZSTD_freeDCtx),\n      ddict_manager_(ddict_manager), stats_(generateStats(stats_prefix, scope)) {}\n\nvoid ZstdDecompressorImpl::decompress(const Buffer::Instance& input_buffer,\n                                      Buffer::Instance& output_buffer) {\n  for (const Buffer::RawSlice& input_slice : input_buffer.getRawSlices()) {\n    if (input_slice.len_ > 0) {\n      if (ddict_manager_ && !is_dictionary_set_) {\n        is_dictionary_set_ = true;\n        // If id == 0, it means that dictionary id could not be decoded.\n        dictionary_id_ =\n            ZSTD_getDictID_fromFrame(static_cast<uint8_t*>(input_slice.mem_), input_slice.len_);\n        if (dictionary_id_ != 0) {\n          auto dictionary = ddict_manager_->getDictionaryById(dictionary_id_);\n          if (!dictionary) {\n            stats_.zstd_dictionary_error_.inc();\n            return;\n          }\n          const size_t result = ZSTD_DCtx_refDDict(dctx_.get(), dictionary);\n          if (isError(result)) {\n            return;\n          }\n        }\n      }\n\n      setInput(input_slice);\n      if (!process(output_buffer)) {\n        return;\n      }\n    }\n  }\n}\n\nbool ZstdDecompressorImpl::process(Buffer::Instance& output_buffer) {\n  while (input_.pos < input_.size) {\n    const size_t result = ZSTD_decompressStream(dctx_.get(), &output_, &input_);\n    if (isError(result)) {\n      return false;\n    }\n\n    getOutput(output_buffer);\n  }\n\n  return true;\n}\n\nbool ZstdDecompressorImpl::isError(size_t result) {\n  switch (ZSTD_getErrorCode(result)) {\n  case ZSTD_error_no_error:\n    return false;\n  case ZSTD_error_memory_allocation:\n    stats_.zstd_memory_error_.inc();\n    break;\n  case ZSTD_error_dictionary_corrupted:\n  case ZSTD_error_dictionary_wrong:\n    stats_.zstd_dictionary_error_.inc();\n    break;\n  case ZSTD_error_checksum_wrong:\n    stats_.zstd_checksum_wrong_error_.inc();\n    break;\n  default:\n    stats_.zstd_generic_error_.inc();\n    break;\n  }\n  return true;\n}\n\n} // namespace Decompressor\n} // namespace Zstd\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include \"envoy/compression/decompressor/decompressor.h\"\n#include \"envoy/stats/scope.h\"\n#include \"envoy/stats/stats_macros.h\"\n\n#include \"source/extensions/compression/zstd/common/base.h\"\n#include \"source/extensions/compression/zstd/common/dictionary_manager.h\"\n\n#include \"zstd_errors.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Zstd {\nnamespace Decompressor {\n\nusing ZstdDDictManager =\n    Common::DictionaryManager<ZSTD_DDict, ZSTD_freeDDict, ZSTD_getDictID_fromDDict>;\nusing ZstdDDictManagerPtr = std::unique_ptr<ZstdDDictManager>;\n\n/**\n * All zstd decompressor stats. @see stats_macros.h\n */\n#define ALL_ZSTD_DECOMPRESSOR_STATS(COUNTER)                                                       \\\n  COUNTER(zstd_generic_error)                                                                      \\\n  COUNTER(zstd_dictionary_error)                                                                   \\\n  COUNTER(zstd_checksum_wrong_error)                                                               \\\n  COUNTER(zstd_memory_error)\n\n/**\n * Struct definition for zstd decompressor stats. @see stats_macros.h\n */\nstruct ZstdDecompressorStats {\n  ALL_ZSTD_DECOMPRESSOR_STATS(GENERATE_COUNTER_STRUCT)\n};\n\n/**\n * Implementation of decompressor's interface.\n */\nclass ZstdDecompressorImpl : public Common::Base,\n                             public Envoy::Compression::Decompressor::Decompressor,\n                             NonCopyable {\npublic:\n  ZstdDecompressorImpl(Stats::Scope& scope, const std::string& stats_prefix,\n                       const ZstdDDictManagerPtr& ddict_manager, uint32_t chunk_size);\n\n  // Envoy::Compression::Decompressor::Decompressor\n  void decompress(const Buffer::Instance& input_buffer, Buffer::Instance& output_buffer) override;\n\nprivate:\n  static ZstdDecompressorStats generateStats(const std::string& prefix, Stats::Scope& scope) {\n    return ZstdDecompressorStats{ALL_ZSTD_DECOMPRESSOR_STATS(POOL_COUNTER_PREFIX(scope, prefix))};\n  }\n\n  friend class ZstdDecompressorStatsTest;\n  bool process(Buffer::Instance& output_buffer);\n  bool isError(size_t result);\n\n  std::unique_ptr<ZSTD_DCtx, decltype(&ZSTD_freeDCtx)> dctx_;\n  const ZstdDDictManagerPtr& ddict_manager_;\n  const ZstdDecompressorStats stats_;\n  bool is_dictionary_set_{false};\n};\n\n} // namespace Decompressor\n} // namespace Zstd\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/stats/isolated_store_impl.h\"\n#include \"source/extensions/compression/brotli/compressor/brotli_compressor_impl.h\"\n#include \"source/extensions/compression/brotli/decompressor/config.h\"\n\n#include \"test/mocks/server/factory_context.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Brotli {\nnamespace Decompressor {\nnamespace {\n\nclass BrotliDecompressorImplTest : public testing::Test {\nprotected:\n  void drainBuffer(Buffer::OwnedImpl& buffer) { buffer.drain(buffer.length()); }\n\n  static constexpr uint32_t default_quality{2};\n  static constexpr uint32_t default_window_bits{22};\n  static constexpr uint32_t default_input_block_bits{22};\n  static constexpr uint32_t default_input_size{796};\n};\n\n// Exercises compression and decompression by compressing some data, decompressing it and then\n// comparing compressor's input/checksum with decompressor's output/checksum.\nTEST_F(BrotliDecompressorImplTest, CompressAndDecompress) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  Brotli::Compressor::BrotliCompressorImpl compressor{\n      default_quality,\n      default_window_bits,\n      default_input_block_bits,\n      false,\n      Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Default,\n      4096};\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n    original_text.append(buffer.toString());\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n\n  ASSERT_EQ(0, buffer.length());\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  ASSERT_GE(10, buffer.length());\n\n  accumulation_buffer.add(buffer);\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  std::string json{R\"EOF({\n  \"disable_ring_buffer_reallocation\": false,\n  \"chunk_size\": 4096\n})EOF\"};\n  envoy::extensions::compression::brotli::decompressor::v3::Brotli brotli;\n  TestUtility::loadFromJson(json, brotli);\n\n  BrotliDecompressorLibraryFactory lib_factory;\n  NiceMock<Server::Configuration::MockFactoryContext> context;\n  Envoy::Compression::Decompressor::DecompressorFactoryPtr factory =\n      lib_factory.createDecompressorFactoryFromProto(brotli, context);\n  EXPECT_EQ(\"brotli.\", factory->statsPrefix());\n  EXPECT_EQ(\"br\", factory->contentEncoding());\n\n  Envoy::Compression::Decompressor::DecompressorPtr decompressor =\n      factory->createDecompressor(\"test.\");\n  decompressor->decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n}\n\n// Exercises decompression with a very small output buffer.\nTEST_F(BrotliDecompressorImplTest, DecompressWithSmallOutputBuffer) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  Brotli::Compressor::BrotliCompressorImpl compressor{\n      default_quality,\n      default_window_bits,\n      default_input_block_bits,\n      false,\n      Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Default,\n      4096};\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n    original_text.append(buffer.toString());\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n\n  ASSERT_EQ(0, buffer.length());\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  ASSERT_GE(10, buffer.length());\n\n  accumulation_buffer.add(buffer);\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  Stats::IsolatedStoreImpl stats_store{};\n  BrotliDecompressorImpl decompressor{stats_store, \"test.\", 16, false};\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  EXPECT_EQ(0, stats_store.counterFromString(\"test.brotli_error\").value());\n}\n\nTEST_F(BrotliDecompressorImplTest, WrongInput) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl output_buffer;\n  const char zeros[20]{};\n\n  Buffer::BufferFragmentImpl* frag = new Buffer::BufferFragmentImpl(\n      zeros, 20, [](const void*, size_t, const Buffer::BufferFragmentImpl* frag) { delete frag; });\n  buffer.addBufferFragment(*frag);\n  Stats::IsolatedStoreImpl stats_store{};\n  BrotliDecompressorImpl decompressor{stats_store, \"test.\", 16, false};\n  decompressor.decompress(buffer, output_buffer);\n  EXPECT_EQ(1, stats_store.counterFromString(\"test.brotli_error\").value());\n}\n\nTEST_F(BrotliDecompressorImplTest, CompressDecompressOfMultipleSlices) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  const std::string sample{\"slice, slice, slice, slice, slice, \"};\n  std::string original_text;\n  for (uint64_t i = 0; i < 20; ++i) {\n    Buffer::BufferFragmentImpl* frag = new Buffer::BufferFragmentImpl(\n        sample.c_str(), sample.size(),\n        [](const void*, size_t, const Buffer::BufferFragmentImpl* frag) { delete frag; });\n\n    buffer.addBufferFragment(*frag);\n    original_text.append(sample);\n  }\n\n  const uint64_t num_slices = buffer.getRawSlices().size();\n  EXPECT_EQ(num_slices, 20);\n\n  Brotli::Compressor::BrotliCompressorImpl compressor{\n      default_quality,\n      default_window_bits,\n      default_input_block_bits,\n      false,\n      Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Default,\n      4096};\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n  accumulation_buffer.add(buffer);\n\n  Stats::IsolatedStoreImpl stats_store{};\n  BrotliDecompressorImpl decompressor{stats_store, \"test.\", 16, false};\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  EXPECT_EQ(0, stats_store.counterFromString(\"test.brotli_error\").value());\n}\n\nclass UncommonParamsTest : public BrotliDecompressorImplTest,\n                           public testing::WithParamInterface<std::tuple<bool, bool>> {\nprotected:\n  void testcompressDecompressWithUncommonParams(\n      const uint32_t quality, const uint32_t window_bits, const uint32_t input_block_bits,\n      const bool disable_literal_context_modeling,\n      const Compression::Brotli::Compressor::BrotliCompressorImpl::EncoderMode encoder_mode,\n      const bool disable_ring_buffer_reallocation) {\n    Buffer::OwnedImpl buffer;\n    Buffer::OwnedImpl accumulation_buffer;\n\n    Compression::Brotli::Compressor::BrotliCompressorImpl compressor{\n        quality,      window_bits, input_block_bits, disable_literal_context_modeling,\n        encoder_mode, 4096};\n\n    std::string original_text{};\n    for (uint64_t i = 0; i < 30; ++i) {\n      TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n      original_text.append(buffer.toString());\n      compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n      accumulation_buffer.add(buffer);\n      drainBuffer(buffer);\n    }\n    ASSERT_EQ(0, buffer.length());\n\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n    accumulation_buffer.add(buffer);\n\n    drainBuffer(buffer);\n    ASSERT_EQ(0, buffer.length());\n\n    Stats::IsolatedStoreImpl stats_store{};\n    BrotliDecompressorImpl decompressor{stats_store, \"test.\", 4096,\n                                        disable_ring_buffer_reallocation};\n\n    decompressor.decompress(accumulation_buffer, buffer);\n    std::string decompressed_text{buffer.toString()};\n\n    ASSERT_EQ(original_text.length(), decompressed_text.length());\n    EXPECT_EQ(original_text, decompressed_text);\n    EXPECT_EQ(0, stats_store.counterFromString(\"test.brotli_error\").value());\n  }\n};\n\nINSTANTIATE_TEST_SUITE_P(UncommonParamsTestSuite, UncommonParamsTest,\n                         testing::Values(std::make_tuple(false, false),\n                                         std::make_tuple(false, true), std::make_tuple(true, false),\n                                         std::make_tuple(true, true)));\n\n// Exercises decompression with other supported brotli initialization params.\nTEST_P(UncommonParamsTest, Validate) {\n  const bool disable_literal_context_modeling = std::get<0>(GetParam());\n  const bool disable_ring_buffer_reallocation = std::get<1>(GetParam());\n\n  // Test with different memory levels.\n  for (uint32_t i = 1; i < 8; ++i) {\n    testcompressDecompressWithUncommonParams(\n        i - 1,                    // quality\n        default_window_bits,      // window_bits\n        default_input_block_bits, // input_block_bits\n        disable_literal_context_modeling,\n        Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Font,\n        disable_ring_buffer_reallocation);\n\n    testcompressDecompressWithUncommonParams(\n        default_quality,     // quality\n        default_window_bits, // window_bits\n        i + 15,              // input_block_bits\n        disable_literal_context_modeling,\n        Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Text,\n        disable_ring_buffer_reallocation);\n\n    testcompressDecompressWithUncommonParams(\n        default_quality,          // quality\n        i + 10,                   // window_bits\n        default_input_block_bits, // input_block_bits\n        disable_literal_context_modeling,\n        Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Generic,\n        disable_ring_buffer_reallocation);\n  }\n}\n\n} // namespace\n} // namespace Decompressor\n} // namespace Brotli\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/common/assert.h\"\n#include \"source/common/stats/isolated_store_impl.h\"\n#include \"source/extensions/compression/gzip/compressor/zlib_compressor_impl.h\"\n#include \"source/extensions/compression/gzip/decompressor/zlib_decompressor_impl.h\"\n\n#include \"test/fuzz/fuzz_runner.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Gzip {\nnamespace Compressor {\nnamespace Fuzz {\n\n// Fuzzer for zlib compression. While the zlib project has its own fuzzer, this\n// fuzzer validates that the Envoy wiring around zlib makes sense and the\n// specific ways we configure it are safe. The fuzzer below validates a round\n// trip compress-decompress pair; the decompressor itself is not fuzzed beyond\n// whatever the compressor emits, as it exists only as a test utility today.\nDEFINE_FUZZER(const uint8_t* buf, size_t len) {\n\n  FuzzedDataProvider provider(buf, len);\n  ZlibCompressorImpl compressor;\n  Stats::IsolatedStoreImpl stats_store;\n  Decompressor::ZlibDecompressorImpl decompressor{stats_store, \"test\"};\n\n  // Select target compression level. We can't use ConsumeEnum() since the range\n  // is non-contiguous.\n  const ZlibCompressorImpl::CompressionLevel compression_levels[] = {\n      ZlibCompressorImpl::CompressionLevel::Best,\n      ZlibCompressorImpl::CompressionLevel::Speed,\n      ZlibCompressorImpl::CompressionLevel::Standard,\n  };\n  const ZlibCompressorImpl::CompressionLevel target_compression_level =\n      provider.PickValueInArray(compression_levels);\n\n  // Select target compression strategy. We can't use ConsumeEnum() since the\n  // range does not start with zero.\n  const ZlibCompressorImpl::CompressionStrategy compression_strategies[] = {\n      ZlibCompressorImpl::CompressionStrategy::Filtered,\n      ZlibCompressorImpl::CompressionStrategy::Huffman,\n      ZlibCompressorImpl::CompressionStrategy::Rle,\n      ZlibCompressorImpl::CompressionStrategy::Standard,\n  };\n  const ZlibCompressorImpl::CompressionStrategy target_compression_strategy =\n      provider.PickValueInArray(compression_strategies);\n\n  // Select target window bits. The range comes from the PGV constraints in\n  // api/envoy/config/filter/http/gzip/v2/gzip.proto.\n  const int64_t target_window_bits = provider.ConsumeIntegralInRange(9, 15);\n\n  // Select memory level. The range comes from the restriction in the init()\n  // header comments.\n  const uint64_t target_memory_level = provider.ConsumeIntegralInRange(1, 9);\n\n  compressor.init(target_compression_level, target_compression_strategy, target_window_bits,\n                  target_memory_level);\n  decompressor.init(target_window_bits);\n\n  bool provider_empty = provider.remaining_bytes() == 0;\n  Buffer::OwnedImpl full_input;\n  Buffer::OwnedImpl full_output;\n  while (!provider_empty) {\n    const std::string next_data = provider.ConsumeRandomLengthString(provider.remaining_bytes());\n    ENVOY_LOG_MISC(debug, \"Processing {} bytes\", next_data.size());\n    full_input.add(next_data);\n    Buffer::OwnedImpl buffer{next_data.data(), next_data.size()};\n    provider_empty = provider.remaining_bytes() == 0;\n    compressor.compress(buffer, provider_empty ? Envoy::Compression::Compressor::State::Finish\n                                               : Envoy::Compression::Compressor::State::Flush);\n    decompressor.decompress(buffer, full_output);\n  }\n  RELEASE_ASSERT(full_input.toString() == full_output.toString(), \"\");\n  RELEASE_ASSERT(compressor.checksum() == decompressor.checksum(), \"\");\n}\n\n} // namespace Fuzz\n} // namespace Compressor\n} // namespace Gzip\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/stats/isolated_store_impl.h\"\n#include \"source/extensions/compression/gzip/compressor/zlib_compressor_impl.h\"\n#include \"source/extensions/compression/gzip/decompressor/zlib_decompressor_impl.h\"\n\n#include \"test/test_common/utility.h\"\n\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Gzip {\nnamespace Decompressor {\n\nclass ZlibDecompressorImplTest : public testing::Test {\nprotected:\n  void drainBuffer(Buffer::OwnedImpl& buffer) { buffer.drain(buffer.length()); }\n\n  void testcompressDecompressWithUncommonParams(\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel comp_level,\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy\n          comp_strategy,\n      int64_t window_bits, uint64_t memory_level) {\n    Buffer::OwnedImpl buffer;\n    Buffer::OwnedImpl accumulation_buffer;\n\n    Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;\n    compressor.init(comp_level, comp_strategy, window_bits, memory_level);\n\n    std::string original_text{};\n    for (uint64_t i = 0; i < 30; ++i) {\n      TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n      original_text.append(buffer.toString());\n      compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n      accumulation_buffer.add(buffer);\n      drainBuffer(buffer);\n    }\n    ASSERT_EQ(0, buffer.length());\n\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n    accumulation_buffer.add(buffer);\n\n    drainBuffer(buffer);\n    ASSERT_EQ(0, buffer.length());\n\n    Stats::IsolatedStoreImpl stats_store{};\n    ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n    decompressor.init(window_bits);\n\n    decompressor.decompress(accumulation_buffer, buffer);\n    std::string decompressed_text{buffer.toString()};\n\n    ASSERT_EQ(compressor.checksum(), decompressor.checksum());\n    ASSERT_EQ(original_text.length(), decompressed_text.length());\n    EXPECT_EQ(original_text, decompressed_text);\n    ASSERT_EQ(0, decompressor.decompression_error_);\n  }\n\n  static constexpr int64_t gzip_window_bits{31};\n  static constexpr int64_t memory_level{8};\n  static constexpr uint64_t default_input_size{796};\n};\n\nclass ZlibDecompressorImplFailureTest : public ZlibDecompressorImplTest {\nprotected:\n  static void decompressorBadInitTestHelper(int64_t window_bits) {\n    Stats::IsolatedStoreImpl stats_store{};\n    ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n    decompressor.init(window_bits);\n  }\n\n  static void uninitializedDecompressorTestHelper() {\n    Buffer::OwnedImpl input_buffer;\n    Buffer::OwnedImpl output_buffer;\n    Stats::IsolatedStoreImpl stats_store{};\n    ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n    TestUtility::feedBufferWithRandomCharacters(input_buffer, 100);\n    decompressor.decompress(input_buffer, output_buffer);\n    ASSERT_TRUE(decompressor.decompression_error_ < 0);\n    ASSERT_EQ(stats_store.counterFromString(\"test.zlib_stream_error\").value(), 1);\n  }\n};\n\n// Test different failures by passing bad initialization params or by calling decompress before\n// init.\nTEST_F(ZlibDecompressorImplFailureTest, DecompressorFailureTest) {\n  EXPECT_DEATH(decompressorBadInitTestHelper(100), \"assert failure: result >= 0\");\n  uninitializedDecompressorTestHelper();\n}\n\n// Exercises decompressor's checksum by calling it before init or decompress.\nTEST_F(ZlibDecompressorImplTest, CallingChecksum) {\n  Buffer::OwnedImpl compressor_buffer;\n  Buffer::OwnedImpl decompressor_output_buffer;\n\n  Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;\n  ASSERT_EQ(0, compressor.checksum());\n\n  compressor.init(\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Standard,\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Standard,\n      gzip_window_bits, memory_level);\n  ASSERT_EQ(0, compressor.checksum());\n\n  TestUtility::feedBufferWithRandomCharacters(compressor_buffer, 4096);\n  compressor.compress(compressor_buffer, Envoy::Compression::Compressor::State::Flush);\n  ASSERT_TRUE(compressor.checksum() > 0);\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n  decompressor.init(gzip_window_bits);\n  EXPECT_EQ(0, decompressor.checksum());\n\n  decompressor.decompress(compressor_buffer, decompressor_output_buffer);\n\n  drainBuffer(compressor_buffer);\n  drainBuffer(decompressor_output_buffer);\n\n  EXPECT_EQ(compressor.checksum(), decompressor.checksum());\n  ASSERT_EQ(0, decompressor.decompression_error_);\n}\n\n// Exercises compression and decompression by compressing some data, decompressing it and then\n// comparing compressor's input/checksum with decompressor's output/checksum.\nTEST_F(ZlibDecompressorImplTest, CompressAndDecompress) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n  Buffer::OwnedImpl empty_buffer;\n\n  Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;\n  compressor.init(\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Standard,\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Standard,\n      gzip_window_bits, memory_level);\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n    original_text.append(buffer.toString());\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n\n  ASSERT_EQ(0, buffer.length());\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  ASSERT_GE(10, buffer.length());\n\n  accumulation_buffer.add(buffer);\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n  decompressor.init(gzip_window_bits);\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  // Check decompressor's internal state isn't broken.\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n  decompressor.decompress(empty_buffer, buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  ASSERT_EQ(compressor.checksum(), decompressor.checksum());\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  ASSERT_EQ(0, decompressor.decompression_error_);\n}\n\n// Tests decompression_error_ set to True when Decompression Fails\nTEST_F(ZlibDecompressorImplTest, FailedDecompression) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n    original_text.append(buffer.toString());\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n  Stats::IsolatedStoreImpl stats_store{};\n  ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n  decompressor.init(gzip_window_bits);\n\n  decompressor.decompress(accumulation_buffer, buffer);\n\n  ASSERT_TRUE(decompressor.decompression_error_ < 0);\n  ASSERT_EQ(stats_store.counterFromString(\"test.zlib_data_error\").value(), 17);\n}\n\n// Exercises decompression with a very small output buffer.\nTEST_F(ZlibDecompressorImplTest, DecompressWithSmallOutputBuffer) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  Envoy::Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;\n  compressor.init(\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Standard,\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Standard,\n      gzip_window_bits, memory_level);\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n    original_text.append(buffer.toString());\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n\n  ASSERT_EQ(0, buffer.length());\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  ASSERT_GE(10, buffer.length());\n\n  accumulation_buffer.add(buffer);\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZlibDecompressorImpl decompressor{stats_store, \"test.\", 16};\n  decompressor.init(gzip_window_bits);\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(compressor.checksum(), decompressor.checksum());\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  ASSERT_EQ(0, decompressor.decompression_error_);\n}\n\n// Exercises decompression with other supported zlib initialization params.\nTEST_F(ZlibDecompressorImplTest, CompressDecompressWithUncommonParams) {\n  // Test with different memory levels.\n  for (uint64_t i = 1; i < 10; ++i) {\n    testcompressDecompressWithUncommonParams(\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Best,\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Rle, 15,\n        i);\n\n    testcompressDecompressWithUncommonParams(\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Best,\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Rle, 15,\n        i);\n\n    testcompressDecompressWithUncommonParams(\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Speed,\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Huffman,\n        15, i);\n\n    testcompressDecompressWithUncommonParams(\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Speed,\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::\n            Filtered,\n        15, i);\n  }\n}\n\nTEST_F(ZlibDecompressorImplTest, CompressDecompressOfMultipleSlices) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  const std::string sample{\"slice, slice, slice, slice, slice, \"};\n  std::string original_text;\n  for (uint64_t i = 0; i < 20; ++i) {\n    Buffer::BufferFragmentImpl* frag = new Buffer::BufferFragmentImpl(\n        sample.c_str(), sample.size(),\n        [](const void*, size_t, const Buffer::BufferFragmentImpl* frag) { delete frag; });\n\n    buffer.addBufferFragment(*frag);\n    original_text.append(sample);\n  }\n\n  const uint64_t num_slices = buffer.getRawSlices().size();\n  EXPECT_EQ(num_slices, 20);\n\n  Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;\n  compressor.init(\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Standard,\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Standard,\n      gzip_window_bits, memory_level);\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n  accumulation_buffer.add(buffer);\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n  decompressor.init(gzip_window_bits);\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(compressor.checksum(), decompressor.checksum());\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n}\n\nclass ZlibDecompressorStatsTest : public testing::Test {\nprotected:\n  void chargeErrorStats(const int result) { decompressor_.chargeErrorStats(result); }\n\n  Stats::IsolatedStoreImpl stats_store_{};\n  ZlibDecompressorImpl decompressor_{stats_store_, \"test.\"};\n};\n\nTEST_F(ZlibDecompressorStatsTest, ChargeErrorStats) {\n  decompressor_.init(31);\n\n  chargeErrorStats(Z_ERRNO);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_errno\").value(), 1);\n  chargeErrorStats(Z_STREAM_ERROR);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_stream_error\").value(), 1);\n  chargeErrorStats(Z_DATA_ERROR);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_data_error\").value(), 1);\n  chargeErrorStats(Z_MEM_ERROR);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_mem_error\").value(), 1);\n  chargeErrorStats(Z_BUF_ERROR);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_buf_error\").value(), 1);\n  chargeErrorStats(Z_VERSION_ERROR);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_version_error\").value(), 1);\n}\n\n} // namespace Decompressor\n} // namespace Gzip\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/stats/isolated_store_impl.h\"\n#include \"source/extensions/compression/zstd/compressor/zstd_compressor_impl.h\"\n#include \"source/extensions/compression/zstd/decompressor/config.h\"\n\n#include \"test/mocks/server/factory_context.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Zstd {\nnamespace Decompressor {\nnamespace {\n\nclass ZstdDecompressorImplTest : public testing::Test {\nprotected:\n  void drainBuffer(Buffer::OwnedImpl& buffer) {\n    buffer.drain(buffer.length());\n    ASSERT_EQ(0, buffer.length());\n  }\n\n  static constexpr uint32_t default_compression_level_{6};\n  static constexpr uint32_t default_enable_checksum_{0};\n  static constexpr uint32_t default_strategy_{0};\n  static constexpr uint32_t default_input_size_{796};\n  Zstd::Compressor::ZstdCDictManagerPtr default_cdict_manager_{nullptr};\n  ZstdDDictManagerPtr default_ddict_manager_{nullptr};\n};\n\n// Exercises decompression with a very small output buffer.\nTEST_F(ZstdDecompressorImplTest, DecompressWithSmallOutputBuffer) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  Zstd::Compressor::ZstdCompressorImpl compressor{default_compression_level_,\n                                                  default_enable_checksum_, default_strategy_,\n                                                  default_cdict_manager_, 4096};\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size_ * i, i);\n    original_text.append(buffer.toString());\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  accumulation_buffer.add(buffer);\n  drainBuffer(buffer);\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZstdDecompressorImpl decompressor{stats_store, \"test.\", default_ddict_manager_, 16};\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  EXPECT_EQ(0, stats_store.counterFromString(\"test.zstd_generic_error\").value());\n}\n\nTEST_F(ZstdDecompressorImplTest, WrongInput) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl output_buffer;\n  const char zeros[20]{};\n\n  Buffer::BufferFragmentImpl* frag = new Buffer::BufferFragmentImpl(\n      zeros, 20, [](const void*, size_t, const Buffer::BufferFragmentImpl* frag) { delete frag; });\n  buffer.addBufferFragment(*frag);\n  Stats::IsolatedStoreImpl stats_store{};\n  ZstdDecompressorImpl decompressor{stats_store, \"test.\", default_ddict_manager_, 16};\n  decompressor.decompress(buffer, output_buffer);\n  EXPECT_EQ(1, stats_store.counterFromString(\"test.zstd_generic_error\").value());\n}\n\nTEST_F(ZstdDecompressorImplTest, CompressDecompressOfMultipleSlices) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  const std::string sample{\"slice, slice, slice, slice, slice, \"};\n  std::string original_text;\n  for (uint64_t i = 0; i < 20; ++i) {\n    Buffer::BufferFragmentImpl* frag = new Buffer::BufferFragmentImpl(\n        sample.c_str(), sample.size(),\n        [](const void*, size_t, const Buffer::BufferFragmentImpl* frag) { delete frag; });\n\n    buffer.addBufferFragment(*frag);\n    original_text.append(sample);\n  }\n\n  const uint64_t num_slices = buffer.getRawSlices().size();\n  EXPECT_EQ(num_slices, 20);\n\n  Zstd::Compressor::ZstdCompressorImpl compressor{default_compression_level_,\n                                                  default_enable_checksum_, default_strategy_,\n                                                  default_cdict_manager_, 4096};\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n  accumulation_buffer.add(buffer);\n  drainBuffer(buffer);\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  accumulation_buffer.add(buffer);\n  drainBuffer(buffer);\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZstdDecompressorImpl decompressor{stats_store, \"test.\", default_ddict_manager_, 16};\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  EXPECT_EQ(0, stats_store.counterFromString(\"test.zstd_generic_error\").value());\n}\n\nTEST_F(ZstdDecompressorImplTest, IllegalConfig) {\n  envoy::extensions::compression::zstd::decompressor::v3::Zstd zstd;\n  Zstd::Decompressor::ZstdDecompressorLibraryFactory lib_factory;\n  NiceMock<Server::Configuration::MockFactoryContext> mock_context;\n  std::string json;\n\n  json = R\"EOF({\n  \"chunk_size\": 4096,\n  \"dictionaries\": [\n    {\n      \"inline_string\": \"\"\n    }\n  ]\n})EOF\";\n  TestUtility::loadFromJson(json, zstd);\n  EXPECT_THROW_WITH_MESSAGE(lib_factory.createDecompressorFactoryFromProto(zstd, mock_context),\n                            EnvoyException, \"DataSource cannot be empty\");\n\n  json = R\"EOF({\n  \"chunk_size\": 4096,\n  \"dictionaries\": [\n    {\n      \"inline_string\": \"456789\"\n    }\n  ]\n})EOF\";\n  TestUtility::loadFromJson(json, zstd);\n  EXPECT_DEATH({ lib_factory.createDecompressorFactoryFromProto(zstd, mock_context); },\n               \"assert failure: id != 0. Details: Illegal Zstd dictionary\");\n}\n\n} // namespace\n\n// Copy from\n// https://github.com/facebook/zstd/blob/dev/contrib/seekable_format/zstdseek_decompress.c#L123\n// For test only\n#define ZSTD_ERROR(name) static_cast<size_t>(-ZSTD_error_##name)\n\nclass ZstdDecompressorStatsTest : public testing::Test {\nprotected:\n  bool isError(size_t result) { return decompressor_.isError(result); }\n\n  Stats::IsolatedStoreImpl stats_store_{};\n  ZstdDDictManagerPtr ddict_manager_{nullptr};\n  ZstdDecompressorImpl decompressor_{stats_store_, \"test.\", ddict_manager_, 16};\n};\n\nTEST_F(ZstdDecompressorStatsTest, ChargeErrorStats) {\n  EXPECT_FALSE(isError(0)); // no error\n\n  EXPECT_TRUE(isError(ZSTD_ERROR(memory_allocation)));\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zstd_memory_error\").value(), 1);\n\n  EXPECT_TRUE(isError(ZSTD_ERROR(dictionary_corrupted)));\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zstd_dictionary_error\").value(), 1);\n  EXPECT_TRUE(isError(ZSTD_ERROR(dictionary_wrong)));\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zstd_dictionary_error\").value(), 2);\n\n  EXPECT_TRUE(isError(ZSTD_ERROR(checksum_wrong)));\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zstd_checksum_wrong_error\").value(), 1);\n\n  EXPECT_TRUE(isError(-1)); // generic error\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zstd_generic_error\").value(), 1);\n}\n\n} // namespace Decompressor\n} // namespace Zstd\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n"], "fixing_code": ["1.22.1 (Pending)\n================\n\nIncompatible Behavior Changes\n-----------------------------\n*Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\nMinor Behavior Changes\n----------------------\n*Changes that may cause incompatibilities for some users, but should not for most*\n\nBug Fixes\n---------\n*Changes expected to improve the state of the world and are unlikely to have negative effects*\n\nRemoved Config or Runtime\n-------------------------\n*Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n\n\nNew Features\n------------\n\nDeprecated\n----------\n", "#include \"source/common/runtime/runtime_features.h\"\n\n#include \"absl/flags/commandlineflag.h\"\n#include \"absl/flags/flag.h\"\n#include \"absl/strings/match.h\"\n#include \"absl/strings/str_replace.h\"\n\n#define RUNTIME_GUARD(name) ABSL_FLAG(bool, name, true, \"\");        // NOLINT\n#define FALSE_RUNTIME_GUARD(name) ABSL_FLAG(bool, name, false, \"\"); // NOLINT\n\n// Add additional features here to enable the new code paths by default.\n//\n// Per documentation in CONTRIBUTING.md is expected that new high risk code paths be guarded\n// by runtime feature guards. If you add a guard of the form\n// RUNTIME_GUARD(envoy_reloadable_features_my_feature_name)\n// here you can guard code checking against \"envoy.reloadable_features.my_feature_name\".\n// Please note the swap of envoy_reloadable_features_ to envoy.reloadable_features.!\n//\n// if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.my_feature_name\")) {\n//   [new code path]\n// else {\n//   [old_code_path]\n// }\n//\n// Runtime features are true by default, so the new code path is exercised.\n// To make a runtime feature false by default, use FALSE_RUNTIME_GUARD, and add\n// a TODO to change it to true.\n//\n// If issues are found that require a runtime feature to be disabled, it should be reported\n// ASAP by filing a bug on github. Overriding non-buggy code is strongly discouraged to avoid the\n// problem of the bugs being found after the old code path has been removed.\nRUNTIME_GUARD(envoy_reloadable_features_allow_adding_content_type_in_local_replies);\nRUNTIME_GUARD(envoy_reloadable_features_allow_upstream_inline_write);\nRUNTIME_GUARD(envoy_reloadable_features_append_or_truncate);\nRUNTIME_GUARD(envoy_reloadable_features_append_to_accept_content_encoding_only_once);\nRUNTIME_GUARD(envoy_reloadable_features_conn_pool_delete_when_idle);\nRUNTIME_GUARD(envoy_reloadable_features_conn_pool_new_stream_with_early_data_and_http3);\nRUNTIME_GUARD(envoy_reloadable_features_correct_scheme_and_xfp);\nRUNTIME_GUARD(envoy_reloadable_features_correctly_validate_alpn);\nRUNTIME_GUARD(envoy_reloadable_features_deprecate_global_ints);\nRUNTIME_GUARD(envoy_reloadable_features_disable_tls_inspector_injection);\nRUNTIME_GUARD(envoy_reloadable_features_do_not_await_headers_on_upstream_timeout_to_emit_stats);\nRUNTIME_GUARD(envoy_reloadable_features_enable_compression_bomb_protection);\nRUNTIME_GUARD(envoy_reloadable_features_enable_grpc_async_client_cache);\nRUNTIME_GUARD(envoy_reloadable_features_fix_added_trailers);\nRUNTIME_GUARD(envoy_reloadable_features_handle_stream_reset_during_hcm_encoding);\nRUNTIME_GUARD(envoy_reloadable_features_http1_lazy_read_disable);\nRUNTIME_GUARD(envoy_reloadable_features_http2_allow_capacity_increase_by_settings);\nRUNTIME_GUARD(envoy_reloadable_features_http2_new_codec_wrapper);\nRUNTIME_GUARD(envoy_reloadable_features_http_100_continue_case_insensitive);\nRUNTIME_GUARD(envoy_reloadable_features_http_ext_authz_do_not_skip_direct_response_and_redirect);\nRUNTIME_GUARD(envoy_reloadable_features_http_reject_path_with_fragment);\nRUNTIME_GUARD(envoy_reloadable_features_http_strip_fragment_from_path_unsafe_if_disabled);\nRUNTIME_GUARD(envoy_reloadable_features_internal_address);\nRUNTIME_GUARD(envoy_reloadable_features_listener_reuse_port_default_enabled);\nRUNTIME_GUARD(envoy_reloadable_features_new_tcp_connection_pool);\nRUNTIME_GUARD(envoy_reloadable_features_no_extension_lookup_by_name);\nRUNTIME_GUARD(envoy_reloadable_features_override_request_timeout_by_gateway_timeout);\nRUNTIME_GUARD(envoy_reloadable_features_postpone_h3_client_connect_to_next_loop);\nRUNTIME_GUARD(envoy_reloadable_features_proxy_102_103);\nRUNTIME_GUARD(envoy_reloadable_features_sanitize_http_header_referer);\nRUNTIME_GUARD(envoy_reloadable_features_skip_delay_close);\nRUNTIME_GUARD(envoy_reloadable_features_skip_dispatching_frames_for_closed_connection);\nRUNTIME_GUARD(envoy_reloadable_features_strict_check_on_ipv4_compat);\nRUNTIME_GUARD(envoy_reloadable_features_support_locality_update_on_eds_cluster_endpoints);\nRUNTIME_GUARD(envoy_reloadable_features_test_feature_true);\nRUNTIME_GUARD(envoy_reloadable_features_top_level_ecds_stats);\nRUNTIME_GUARD(envoy_reloadable_features_udp_listener_updates_filter_chain_in_place);\nRUNTIME_GUARD(envoy_reloadable_features_update_expected_rq_timeout_on_retry);\nRUNTIME_GUARD(envoy_reloadable_features_update_grpc_response_error_tag);\nRUNTIME_GUARD(envoy_reloadable_features_use_dns_ttl);\nRUNTIME_GUARD(envoy_reloadable_features_validate_connect);\nRUNTIME_GUARD(envoy_restart_features_explicit_wildcard_resource);\nRUNTIME_GUARD(envoy_restart_features_no_runtime_singleton);\nRUNTIME_GUARD(envoy_restart_features_use_apple_api_for_dns_lookups);\n\n// Begin false flags. These should come with a TODO to flip true.\n// Sentinel and test flag.\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_test_feature_false);\n// TODO(alyssawilk) flip true once H2 caching is on by default.\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_allow_concurrency_for_alpn_pool);\n// TODO(alyssawilk, junr03) flip (and add release notes + docs) these after Lyft tests\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_allow_multiple_dns_addresses);\n// TODO(adisuissa) reset to true to enable unified mux by default\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_unified_mux);\n// TODO(kbaichoo): Make this enabled by default when fairness and chunking\n// are implemented, and we've had more cpu time.\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_defer_processing_backedup_streams);\n// TODO(rgs1): Make this enabled after Pinterest tests\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_thrift_connection_draining);\n// TODO(birenroy) flip after a burn-in period\n// Requires envoy_reloadable_features_http2_new_codec_wrapper to be enabled.\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_http2_use_oghttp2);\n// Used to track if runtime is initialized.\nFALSE_RUNTIME_GUARD(envoy_reloadable_features_runtime_initialized);\n\n// Block of non-boolean flags. These are deprecated. Do not add more.\nABSL_FLAG(uint64_t, envoy_headermap_lazy_map_min_size, 3, \"\");  // NOLINT\nABSL_FLAG(uint64_t, re2_max_program_size_error_level, 100, \"\"); // NOLINT\nABSL_FLAG(uint64_t, re2_max_program_size_warn_level,            // NOLINT\n          std::numeric_limits<uint32_t>::max(), \"\");            // NOLINT\n\nnamespace Envoy {\nnamespace Runtime {\nnamespace {\n\nstd::string swapPrefix(std::string name) {\n  return absl::StrReplaceAll(name, {{\"envoy_\", \"envoy.\"}, {\"features_\", \"features.\"}});\n}\n\n} // namespace\n\n// This is a singleton class to map Envoy style flag names to absl flags\nclass RuntimeFeatures {\npublic:\n  RuntimeFeatures();\n\n  // Get the command line flag corresponding to the Envoy style feature name, or\n  // nullptr if it is not a registered flag.\n  absl::CommandLineFlag* getFlag(absl::string_view feature) const {\n    auto it = all_features_.find(feature);\n    if (it == all_features_.end()) {\n      return nullptr;\n    }\n    return it->second;\n  }\n\nprivate:\n  absl::flat_hash_map<std::string, absl::CommandLineFlag*> all_features_;\n};\n\nusing RuntimeFeaturesDefaults = ConstSingleton<RuntimeFeatures>;\n\nRuntimeFeatures::RuntimeFeatures() {\n  absl::flat_hash_map<absl::string_view, absl::CommandLineFlag*> flags = absl::GetAllFlags();\n  for (auto& it : flags) {\n    absl::string_view name = it.second->Name();\n    if ((!absl::StartsWith(name, \"envoy_reloadable_features_\") &&\n         !absl::StartsWith(name, \"envoy_restart_features_\")) ||\n        !it.second->TryGet<bool>().has_value()) {\n      continue;\n    }\n    std::string envoy_name = swapPrefix(std::string(name));\n    all_features_.emplace(envoy_name, it.second);\n  }\n}\n\nbool hasRuntimePrefix(absl::string_view feature) {\n  // Track Envoy reloadable and restart features, excluding synthetic QUIC flags\n  // which are not tracked in the list below.\n  return (absl::StartsWith(feature, \"envoy.reloadable_features.\") &&\n          !absl::StartsWith(feature, \"envoy.reloadable_features.FLAGS_quic\")) ||\n         absl::StartsWith(feature, \"envoy.restart_features.\");\n}\n\nbool isRuntimeFeature(absl::string_view feature) {\n  return RuntimeFeaturesDefaults::get().getFlag(feature) != nullptr;\n}\n\nbool runtimeFeatureEnabled(absl::string_view feature) {\n  absl::CommandLineFlag* flag = RuntimeFeaturesDefaults::get().getFlag(feature);\n  if (flag == nullptr) {\n    IS_ENVOY_BUG(absl::StrCat(\"Unable to find runtime feature \", feature));\n    return false;\n  }\n  // We validate in map creation that the flag is a boolean.\n  return flag->TryGet<bool>().value();\n}\n\nuint64_t getInteger(absl::string_view feature, uint64_t default_value) {\n  if (absl::StartsWith(feature, \"envoy.\")) {\n    // DO NOT ADD MORE FLAGS HERE. This function deprecated.\n    if (feature == \"envoy.http.headermap.lazy_map_min_size\") {\n      return absl::GetFlag(FLAGS_envoy_headermap_lazy_map_min_size);\n    }\n  }\n  if (absl::StartsWith(feature, \"re2.\")) {\n    if (feature == \"re2.max_program_size.error_level\") {\n      return absl::GetFlag(FLAGS_re2_max_program_size_error_level);\n    } else if (feature == \"re2.max_program_size.warn_level\") {\n      return absl::GetFlag(FLAGS_re2_max_program_size_warn_level);\n    }\n  }\n  IS_ENVOY_BUG(absl::StrCat(\"requested an unsupported integer \", feature));\n  return default_value;\n}\n\nvoid markRuntimeInitialized() {\n  maybeSetRuntimeGuard(\"envoy.reloadable_features.runtime_initialized\", true);\n}\n\nbool isRuntimeInitialized() {\n  return runtimeFeatureEnabled(\"envoy.reloadable_features.runtime_initialized\");\n}\n\nvoid maybeSetRuntimeGuard(absl::string_view name, bool value) {\n  absl::CommandLineFlag* flag = RuntimeFeaturesDefaults::get().getFlag(name);\n  if (flag == nullptr) {\n    IS_ENVOY_BUG(absl::StrCat(\"Unable to find runtime feature \", name));\n    return;\n  }\n  std::string err;\n  flag->ParseFrom(value ? \"true\" : \"false\", &err);\n}\n\nvoid maybeSetDeprecatedInts(absl::string_view name, uint32_t value) {\n  if (!absl::StartsWith(name, \"envoy.\") && !absl::StartsWith(name, \"re2.\")) {\n    return;\n  }\n\n  // DO NOT ADD MORE FLAGS HERE. This function deprecated and being removed.\n  if (name == \"envoy.http.headermap.lazy_map_min_size\") {\n    if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.deprecate_global_ints\")) {\n      IS_ENVOY_BUG(absl::StrCat(\n          \"The Envoy community is attempting to remove global integers. Given you use \", name,\n          \" please immediately file an upstream issue to retain the functionality as it will \"\n          \"otherwise be removed following the usual deprecation cycle.\"));\n    }\n    absl::SetFlag(&FLAGS_envoy_headermap_lazy_map_min_size, value);\n  } else if (name == \"re2.max_program_size.error_level\") {\n    absl::SetFlag(&FLAGS_re2_max_program_size_error_level, value);\n  } else if (name == \"re2.max_program_size.warn_level\") {\n    absl::SetFlag(&FLAGS_re2_max_program_size_warn_level, value);\n  }\n}\n\n} // namespace Runtime\n} // namespace Envoy\n", "#include \"source/extensions/compression/brotli/common/base.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Brotli {\nnamespace Common {\n\nBrotliContext::BrotliContext(uint32_t chunk_size, uint32_t max_output_size)\n    : max_output_size_{max_output_size}, chunk_size_{chunk_size},\n      chunk_ptr_{std::make_unique<uint8_t[]>(chunk_size)}, next_in_{}, next_out_{chunk_ptr_.get()},\n      avail_in_{0}, avail_out_{chunk_size} {}\n\nvoid BrotliContext::updateOutput(Buffer::Instance& output_buffer) {\n  if (avail_out_ == 0) {\n    output_buffer.add(static_cast<void*>(chunk_ptr_.get()), chunk_size_);\n    resetOut();\n  }\n}\n\nvoid BrotliContext::finalizeOutput(Buffer::Instance& output_buffer) {\n  const size_t n_output = chunk_size_ - avail_out_;\n  if (n_output > 0) {\n    output_buffer.add(static_cast<void*>(chunk_ptr_.get()), n_output);\n  }\n}\n\nvoid BrotliContext::resetOut() {\n  avail_out_ = chunk_size_;\n  next_out_ = chunk_ptr_.get();\n}\n\n} // namespace Common\n} // namespace Brotli\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include <memory>\n\n#include \"envoy/buffer/buffer.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Brotli {\nnamespace Common {\n\n// Keeps a `Brotli` compression stream's state.\nstruct BrotliContext {\n  BrotliContext(uint32_t chunk_size, uint32_t max_output_size = 0);\n\n  void updateOutput(Buffer::Instance& output_buffer);\n  void finalizeOutput(Buffer::Instance& output_buffer);\n\n  const uint32_t max_output_size_;\n  const uint32_t chunk_size_;\n  std::unique_ptr<uint8_t[]> chunk_ptr_;\n  const uint8_t* next_in_;\n  uint8_t* next_out_;\n  size_t avail_in_;\n  size_t avail_out_;\n\nprivate:\n  void resetOut();\n};\n\n} // namespace Common\n} // namespace Brotli\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "load(\n    \"//bazel:envoy_build_system.bzl\",\n    \"envoy_cc_extension\",\n    \"envoy_cc_library\",\n    \"envoy_extension_package\",\n)\n\nlicenses([\"notice\"])  # Apache 2\n\nenvoy_extension_package()\n\nenvoy_cc_library(\n    name = \"decompressor_lib\",\n    srcs = [\"brotli_decompressor_impl.cc\"],\n    hdrs = [\"brotli_decompressor_impl.h\"],\n    external_deps = [\"brotlidec\"],\n    deps = [\n        \"//envoy/compression/decompressor:decompressor_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//envoy/stats:stats_macros\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/runtime:runtime_features_lib\",\n        \"//source/extensions/compression/brotli/common:brotli_base_lib\",\n    ],\n)\n\nenvoy_cc_extension(\n    name = \"config\",\n    srcs = [\"config.cc\"],\n    hdrs = [\"config.h\"],\n    deps = [\n        \":decompressor_lib\",\n        \"//source/common/http:headers_lib\",\n        \"//source/extensions/compression/common/decompressor:decompressor_factory_base_lib\",\n        \"@envoy_api//envoy/extensions/compression/brotli/decompressor/v3:pkg_cc_proto\",\n    ],\n)\n", "#include \"source/extensions/compression/brotli/decompressor/brotli_decompressor_impl.h\"\n\n#include <memory>\n\n#include \"source/common/runtime/runtime_features.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Brotli {\nnamespace Decompressor {\n\nnamespace {\n\n// How many times the output buffer is allowed to be bigger than the input\n// buffer. This value is used to detect compression bombs.\n// TODO(rojkov): Re-design the Decompressor interface to handle compression\n// bombs gracefully instead of this quick solution.\nconstexpr uint32_t MaxInflateRatio = 100;\n\n} // namespace\n\nBrotliDecompressorImpl::BrotliDecompressorImpl(Stats::Scope& scope, const std::string& stats_prefix,\n                                               const uint32_t chunk_size,\n                                               const bool disable_ring_buffer_reallocation)\n    : chunk_size_{chunk_size},\n      state_(BrotliDecoderCreateInstance(nullptr, nullptr, nullptr), &BrotliDecoderDestroyInstance),\n      stats_(generateStats(stats_prefix, scope)) {\n  BROTLI_BOOL result =\n      BrotliDecoderSetParameter(state_.get(), BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION,\n                                disable_ring_buffer_reallocation ? BROTLI_TRUE : BROTLI_FALSE);\n  RELEASE_ASSERT(result == BROTLI_TRUE, \"\");\n}\n\nvoid BrotliDecompressorImpl::decompress(const Buffer::Instance& input_buffer,\n                                        Buffer::Instance& output_buffer) {\n  Common::BrotliContext ctx(chunk_size_, MaxInflateRatio * input_buffer.length());\n\n  for (const Buffer::RawSlice& input_slice : input_buffer.getRawSlices()) {\n    ctx.avail_in_ = input_slice.len_;\n    ctx.next_in_ = static_cast<uint8_t*>(input_slice.mem_);\n\n    while (ctx.avail_in_ > 0) {\n      if (!process(ctx, output_buffer)) {\n        ctx.finalizeOutput(output_buffer);\n        return;\n      }\n    }\n  }\n\n  // Even though the input has been fully consumed by the decoder it still can\n  // be unfolded into output not fitting the output chunk. Thus keep processing\n  // until the decoder's output is fully depleted.\n  bool success;\n  do {\n    success = process(ctx, output_buffer);\n  } while (success && BrotliDecoderHasMoreOutput(state_.get()));\n\n  ctx.finalizeOutput(output_buffer);\n}\n\nbool BrotliDecompressorImpl::process(Common::BrotliContext& ctx, Buffer::Instance& output_buffer) {\n  BrotliDecoderResult result;\n  result = BrotliDecoderDecompressStream(state_.get(), &ctx.avail_in_, &ctx.next_in_,\n                                         &ctx.avail_out_, &ctx.next_out_, nullptr);\n  if (result == BROTLI_DECODER_RESULT_ERROR) {\n    // TODO(rojkov): currently the Brotli library doesn't specify possible errors in its API. Add\n    // more detailed stats when they are documented.\n    stats_.brotli_error_.inc();\n    return false;\n  }\n\n  if (Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.enable_compression_bomb_protection\") &&\n      (output_buffer.length() > ctx.max_output_size_)) {\n    stats_.brotli_error_.inc();\n    return false;\n  }\n\n  ctx.updateOutput(output_buffer);\n\n  return true;\n}\n\n} // namespace Decompressor\n} // namespace Brotli\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include <memory>\n\n#include \"envoy/buffer/buffer.h\"\n\n#include \"zlib.h\"\n\nnamespace Envoy {\nnamespace Zlib {\n\n/**\n * Shared code between the compressor and the decompressor.\n */\nclass Base {\npublic:\n  Base(uint64_t chunk_size, std::function<void(z_stream*)> zstream_deleter);\n\n  /**\n   * It returns the checksum of all output produced so far. Compressor's checksum at the end of\n   * the stream has to match decompressor's checksum produced at the end of the decompression.\n   * Likewise, the decompressor's checksum has to match the compressor's checksum at the end of\n   * compression.\n   * @return uint64_t CRC-32 if a gzip stream is being read or Adler-32 for other compression\n   * types.\n   */\n  uint64_t checksum();\n\nprotected:\n  void updateOutput(Buffer::Instance& output_buffer);\n\n  const uint64_t chunk_size_;\n  bool initialized_{false};\n\n  const std::unique_ptr<unsigned char[]> chunk_char_ptr_;\n  const std::unique_ptr<z_stream, std::function<void(z_stream*)>> zstream_ptr_;\n};\n\n} // namespace Zlib\n} // namespace Envoy\n", "load(\n    \"//bazel:envoy_build_system.bzl\",\n    \"envoy_cc_extension\",\n    \"envoy_cc_library\",\n    \"envoy_extension_package\",\n)\n\nlicenses([\"notice\"])  # Apache 2\n\nenvoy_extension_package()\n\nenvoy_cc_library(\n    name = \"zlib_decompressor_impl_lib\",\n    srcs = [\"zlib_decompressor_impl.cc\"],\n    hdrs = [\"zlib_decompressor_impl.h\"],\n    external_deps = [\"zlib\"],\n    deps = [\n        \"//envoy/compression/decompressor:decompressor_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//envoy/stats:stats_macros\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:minimal_logger_lib\",\n        \"//source/common/runtime:runtime_features_lib\",\n        \"//source/extensions/compression/gzip/common:zlib_base_lib\",\n    ],\n)\n\nenvoy_cc_extension(\n    name = \"config\",\n    srcs = [\"config.cc\"],\n    hdrs = [\"config.h\"],\n    deps = [\n        \":zlib_decompressor_impl_lib\",\n        \"//source/common/http:headers_lib\",\n        \"//source/extensions/compression/common/decompressor:decompressor_factory_base_lib\",\n        \"@envoy_api//envoy/extensions/compression/gzip/decompressor/v3:pkg_cc_proto\",\n    ],\n)\n", "#include \"source/extensions/compression/gzip/decompressor/zlib_decompressor_impl.h\"\n\n#include <zlib.h>\n\n#include <memory>\n\n#include \"envoy/common/exception.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/runtime/runtime_features.h\"\n\n#include \"absl/container/fixed_array.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Gzip {\nnamespace Decompressor {\n\nnamespace {\n\n// How many times the output buffer is allowed to be bigger than the size of\n// accumulated input. This value is used to detect compression bombs.\n// TODO(rojkov): Re-design the Decompressor interface to handle compression\n// bombs gracefully instead of this quick solution.\nconstexpr uint64_t MaxInflateRatio = 100;\n\n} // namespace\n\nZlibDecompressorImpl::ZlibDecompressorImpl(Stats::Scope& scope, const std::string& stats_prefix)\n    : ZlibDecompressorImpl(scope, stats_prefix, 4096) {}\n\nZlibDecompressorImpl::ZlibDecompressorImpl(Stats::Scope& scope, const std::string& stats_prefix,\n                                           uint64_t chunk_size)\n    : Zlib::Base(chunk_size,\n                 [](z_stream* z) {\n                   inflateEnd(z);\n                   delete z;\n                 }),\n      stats_(generateStats(stats_prefix, scope)) {\n  zstream_ptr_->zalloc = Z_NULL;\n  zstream_ptr_->zfree = Z_NULL;\n  zstream_ptr_->opaque = Z_NULL;\n  zstream_ptr_->avail_out = chunk_size_;\n  zstream_ptr_->next_out = chunk_char_ptr_.get();\n}\n\nvoid ZlibDecompressorImpl::init(int64_t window_bits) {\n  ASSERT(initialized_ == false);\n  const int result = inflateInit2(zstream_ptr_.get(), window_bits);\n  RELEASE_ASSERT(result >= 0, \"\");\n  initialized_ = true;\n}\n\nvoid ZlibDecompressorImpl::decompress(const Buffer::Instance& input_buffer,\n                                      Buffer::Instance& output_buffer) {\n  uint64_t limit = MaxInflateRatio * input_buffer.length();\n\n  for (const Buffer::RawSlice& input_slice : input_buffer.getRawSlices()) {\n    zstream_ptr_->avail_in = input_slice.len_;\n    zstream_ptr_->next_in = static_cast<Bytef*>(input_slice.mem_);\n    while (inflateNext()) {\n      if (zstream_ptr_->avail_out == 0) {\n        updateOutput(output_buffer);\n      }\n\n      if (Runtime::runtimeFeatureEnabled(\n              \"envoy.reloadable_features.enable_compression_bomb_protection\") &&\n          (output_buffer.length() > limit)) {\n        stats_.zlib_data_error_.inc();\n        ENVOY_LOG(trace,\n                  \"excessive decompression ratio detected: output \"\n                  \"size {} for input size {}\",\n                  output_buffer.length(), input_buffer.length());\n        return;\n      }\n    }\n  }\n\n  // Flush z_stream and reset its buffer. Otherwise the stale content of the buffer\n  // will pollute output upon the next call to decompress().\n  updateOutput(output_buffer);\n}\n\nbool ZlibDecompressorImpl::inflateNext() {\n  const int result = inflate(zstream_ptr_.get(), Z_NO_FLUSH);\n  if (result == Z_STREAM_END) {\n    // Z_FINISH informs inflate to not maintain a sliding window if the stream completes, which\n    // reduces inflate's memory footprint. Ref: https://www.zlib.net/manual.html.\n    inflate(zstream_ptr_.get(), Z_FINISH);\n    return false;\n  }\n\n  if (result == Z_BUF_ERROR && zstream_ptr_->avail_in == 0) {\n    return false; // This means that zlib needs more input, so stop here.\n  }\n\n  if (result < 0) {\n    decompression_error_ = result;\n    ENVOY_LOG(trace,\n              \"zlib decompression error: {}, msg: {}. Error codes are defined in \"\n              \"https://www.zlib.net/manual.html\",\n              result, zstream_ptr_->msg);\n    chargeErrorStats(result);\n    return false;\n  }\n\n  return true;\n}\n\nvoid ZlibDecompressorImpl::chargeErrorStats(const int result) {\n  switch (result) {\n  case Z_ERRNO:\n    stats_.zlib_errno_.inc();\n    break;\n  case Z_STREAM_ERROR:\n    stats_.zlib_stream_error_.inc();\n    break;\n  case Z_DATA_ERROR:\n    stats_.zlib_data_error_.inc();\n    break;\n  case Z_MEM_ERROR:\n    stats_.zlib_mem_error_.inc();\n    break;\n  case Z_BUF_ERROR:\n    stats_.zlib_buf_error_.inc();\n    break;\n  case Z_VERSION_ERROR:\n    stats_.zlib_version_error_.inc();\n    break;\n  }\n}\n\n} // namespace Decompressor\n} // namespace Gzip\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/compression/zstd/decompressor/zstd_decompressor_impl.h\"\n\n#include \"source/common/runtime/runtime_features.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Zstd {\nnamespace Decompressor {\n\nnamespace {\n\n// How many times the output buffer is allowed to be bigger than the size of\n// accumulated input. This value is used to detect compression bombs.\n// TODO(rojkov): Re-design the Decompressor interface to handle compression\n// bombs gracefully instead of this quick solution.\nconstexpr uint64_t MaxInflateRatio = 100;\n\n} // namespace\n\nZstdDecompressorImpl::ZstdDecompressorImpl(Stats::Scope& scope, const std::string& stats_prefix,\n                                           const ZstdDDictManagerPtr& ddict_manager,\n                                           uint32_t chunk_size)\n    : Common::Base(chunk_size), dctx_(ZSTD_createDCtx(), &ZSTD_freeDCtx),\n      ddict_manager_(ddict_manager), stats_(generateStats(stats_prefix, scope)) {}\n\nvoid ZstdDecompressorImpl::decompress(const Buffer::Instance& input_buffer,\n                                      Buffer::Instance& output_buffer) {\n  uint64_t limit = MaxInflateRatio * input_buffer.length();\n\n  for (const Buffer::RawSlice& input_slice : input_buffer.getRawSlices()) {\n    if (input_slice.len_ > 0) {\n      if (ddict_manager_ && !is_dictionary_set_) {\n        is_dictionary_set_ = true;\n        // If id == 0, it means that dictionary id could not be decoded.\n        dictionary_id_ =\n            ZSTD_getDictID_fromFrame(static_cast<uint8_t*>(input_slice.mem_), input_slice.len_);\n        if (dictionary_id_ != 0) {\n          auto dictionary = ddict_manager_->getDictionaryById(dictionary_id_);\n          if (!dictionary) {\n            stats_.zstd_dictionary_error_.inc();\n            return;\n          }\n          const size_t result = ZSTD_DCtx_refDDict(dctx_.get(), dictionary);\n          if (isError(result)) {\n            return;\n          }\n        }\n      }\n\n      setInput(input_slice);\n      if (!process(output_buffer)) {\n        return;\n      }\n      if (Runtime::runtimeFeatureEnabled(\n              \"envoy.reloadable_features.enable_compression_bomb_protection\") &&\n          (output_buffer.length() > limit)) {\n        stats_.zstd_generic_error_.inc();\n        ENVOY_LOG(trace,\n                  \"excessive decompression ratio detected: output \"\n                  \"size {} for input size {}\",\n                  output_buffer.length(), input_buffer.length());\n        return;\n      }\n    }\n  }\n}\n\nbool ZstdDecompressorImpl::process(Buffer::Instance& output_buffer) {\n  while (input_.pos < input_.size) {\n    const size_t result = ZSTD_decompressStream(dctx_.get(), &output_, &input_);\n    if (isError(result)) {\n      return false;\n    }\n\n    getOutput(output_buffer);\n  }\n\n  return true;\n}\n\nbool ZstdDecompressorImpl::isError(size_t result) {\n  switch (ZSTD_getErrorCode(result)) {\n  case ZSTD_error_no_error:\n    return false;\n  case ZSTD_error_memory_allocation:\n    stats_.zstd_memory_error_.inc();\n    break;\n  case ZSTD_error_dictionary_corrupted:\n  case ZSTD_error_dictionary_wrong:\n    stats_.zstd_dictionary_error_.inc();\n    break;\n  case ZSTD_error_checksum_wrong:\n    stats_.zstd_checksum_wrong_error_.inc();\n    break;\n  default:\n    stats_.zstd_generic_error_.inc();\n    break;\n  }\n  return true;\n}\n\n} // namespace Decompressor\n} // namespace Zstd\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include \"envoy/compression/decompressor/decompressor.h\"\n#include \"envoy/stats/scope.h\"\n#include \"envoy/stats/stats_macros.h\"\n\n#include \"source/common/common/logger.h\"\n#include \"source/extensions/compression/zstd/common/base.h\"\n#include \"source/extensions/compression/zstd/common/dictionary_manager.h\"\n\n#include \"zstd_errors.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Zstd {\nnamespace Decompressor {\n\nusing ZstdDDictManager =\n    Common::DictionaryManager<ZSTD_DDict, ZSTD_freeDDict, ZSTD_getDictID_fromDDict>;\nusing ZstdDDictManagerPtr = std::unique_ptr<ZstdDDictManager>;\n\n/**\n * All zstd decompressor stats. @see stats_macros.h\n */\n#define ALL_ZSTD_DECOMPRESSOR_STATS(COUNTER)                                                       \\\n  COUNTER(zstd_generic_error)                                                                      \\\n  COUNTER(zstd_dictionary_error)                                                                   \\\n  COUNTER(zstd_checksum_wrong_error)                                                               \\\n  COUNTER(zstd_memory_error)\n\n/**\n * Struct definition for zstd decompressor stats. @see stats_macros.h\n */\nstruct ZstdDecompressorStats {\n  ALL_ZSTD_DECOMPRESSOR_STATS(GENERATE_COUNTER_STRUCT)\n};\n\n/**\n * Implementation of decompressor's interface.\n */\nclass ZstdDecompressorImpl : public Common::Base,\n                             public Envoy::Compression::Decompressor::Decompressor,\n                             public Logger::Loggable<Logger::Id::decompression>,\n                             NonCopyable {\npublic:\n  ZstdDecompressorImpl(Stats::Scope& scope, const std::string& stats_prefix,\n                       const ZstdDDictManagerPtr& ddict_manager, uint32_t chunk_size);\n\n  // Envoy::Compression::Decompressor::Decompressor\n  void decompress(const Buffer::Instance& input_buffer, Buffer::Instance& output_buffer) override;\n\nprivate:\n  static ZstdDecompressorStats generateStats(const std::string& prefix, Stats::Scope& scope) {\n    return ZstdDecompressorStats{ALL_ZSTD_DECOMPRESSOR_STATS(POOL_COUNTER_PREFIX(scope, prefix))};\n  }\n\n  friend class ZstdDecompressorStatsTest;\n  bool process(Buffer::Instance& output_buffer);\n  bool isError(size_t result);\n\n  std::unique_ptr<ZSTD_DCtx, decltype(&ZSTD_freeDCtx)> dctx_;\n  const ZstdDDictManagerPtr& ddict_manager_;\n  const ZstdDecompressorStats stats_;\n  bool is_dictionary_set_{false};\n};\n\n} // namespace Decompressor\n} // namespace Zstd\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/stats/isolated_store_impl.h\"\n#include \"source/extensions/compression/brotli/compressor/brotli_compressor_impl.h\"\n#include \"source/extensions/compression/brotli/decompressor/config.h\"\n\n#include \"test/mocks/server/factory_context.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Brotli {\nnamespace Decompressor {\nnamespace {\n\nclass BrotliDecompressorImplTest : public testing::Test {\nprotected:\n  void drainBuffer(Buffer::OwnedImpl& buffer) { buffer.drain(buffer.length()); }\n\n  static constexpr uint32_t default_quality{2};\n  static constexpr uint32_t default_window_bits{22};\n  static constexpr uint32_t default_input_block_bits{22};\n  static constexpr uint32_t default_input_size{796};\n};\n\n// Detect excessive compression ratio by compressing a long whitespace string\n// into a very small chunk of data and decompressing it again.\nTEST_F(BrotliDecompressorImplTest, DetectExcessiveCompressionRatio) {\n  const absl::string_view ten_whitespaces = \"          \";\n  Brotli::Compressor::BrotliCompressorImpl compressor{\n      default_quality,\n      default_window_bits,\n      default_input_block_bits,\n      false,\n      Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Default,\n      4096};\n  Buffer::OwnedImpl buffer;\n\n  for (int i = 0; i < 1000; i++) {\n    buffer.add(ten_whitespaces);\n  }\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n\n  Buffer::OwnedImpl output_buffer;\n  Stats::IsolatedStoreImpl stats_store{};\n  BrotliDecompressorImpl decompressor{stats_store, \"test.\", 16, false};\n  decompressor.decompress(buffer, output_buffer);\n  EXPECT_EQ(1, stats_store.counterFromString(\"test.brotli_error\").value());\n}\n\n// Exercises compression and decompression by compressing some data, decompressing it and then\n// comparing compressor's input/checksum with decompressor's output/checksum.\nTEST_F(BrotliDecompressorImplTest, CompressAndDecompress) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  Brotli::Compressor::BrotliCompressorImpl compressor{\n      default_quality,\n      default_window_bits,\n      default_input_block_bits,\n      false,\n      Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Default,\n      4096};\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n    original_text.append(buffer.toString());\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n\n  ASSERT_EQ(0, buffer.length());\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  ASSERT_GE(10, buffer.length());\n\n  accumulation_buffer.add(buffer);\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  std::string json{R\"EOF({\n  \"disable_ring_buffer_reallocation\": false,\n  \"chunk_size\": 4096\n})EOF\"};\n  envoy::extensions::compression::brotli::decompressor::v3::Brotli brotli;\n  TestUtility::loadFromJson(json, brotli);\n\n  BrotliDecompressorLibraryFactory lib_factory;\n  NiceMock<Server::Configuration::MockFactoryContext> context;\n  Envoy::Compression::Decompressor::DecompressorFactoryPtr factory =\n      lib_factory.createDecompressorFactoryFromProto(brotli, context);\n  EXPECT_EQ(\"brotli.\", factory->statsPrefix());\n  EXPECT_EQ(\"br\", factory->contentEncoding());\n\n  Envoy::Compression::Decompressor::DecompressorPtr decompressor =\n      factory->createDecompressor(\"test.\");\n  decompressor->decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n}\n\n// Exercises decompression with a very small output buffer.\nTEST_F(BrotliDecompressorImplTest, DecompressWithSmallOutputBuffer) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  Brotli::Compressor::BrotliCompressorImpl compressor{\n      default_quality,\n      default_window_bits,\n      default_input_block_bits,\n      false,\n      Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Default,\n      4096};\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n    original_text.append(buffer.toString());\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n\n  ASSERT_EQ(0, buffer.length());\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  ASSERT_GE(10, buffer.length());\n\n  accumulation_buffer.add(buffer);\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  Stats::IsolatedStoreImpl stats_store{};\n  BrotliDecompressorImpl decompressor{stats_store, \"test.\", 16, false};\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  EXPECT_EQ(0, stats_store.counterFromString(\"test.brotli_error\").value());\n}\n\nTEST_F(BrotliDecompressorImplTest, WrongInput) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl output_buffer;\n  const char zeros[20]{};\n\n  Buffer::BufferFragmentImpl* frag = new Buffer::BufferFragmentImpl(\n      zeros, 20, [](const void*, size_t, const Buffer::BufferFragmentImpl* frag) { delete frag; });\n  buffer.addBufferFragment(*frag);\n  Stats::IsolatedStoreImpl stats_store{};\n  BrotliDecompressorImpl decompressor{stats_store, \"test.\", 16, false};\n  decompressor.decompress(buffer, output_buffer);\n  EXPECT_EQ(1, stats_store.counterFromString(\"test.brotli_error\").value());\n}\n\nTEST_F(BrotliDecompressorImplTest, CompressDecompressOfMultipleSlices) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  const std::string sample{\"slice, slice, slice, slice, slice, \"};\n  std::string original_text;\n  for (uint64_t i = 0; i < 20; ++i) {\n    Buffer::BufferFragmentImpl* frag = new Buffer::BufferFragmentImpl(\n        sample.c_str(), sample.size(),\n        [](const void*, size_t, const Buffer::BufferFragmentImpl* frag) { delete frag; });\n\n    buffer.addBufferFragment(*frag);\n    original_text.append(sample);\n  }\n\n  const uint64_t num_slices = buffer.getRawSlices().size();\n  EXPECT_EQ(num_slices, 20);\n\n  Brotli::Compressor::BrotliCompressorImpl compressor{\n      default_quality,\n      default_window_bits,\n      default_input_block_bits,\n      false,\n      Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Default,\n      4096};\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n  accumulation_buffer.add(buffer);\n\n  Stats::IsolatedStoreImpl stats_store{};\n  BrotliDecompressorImpl decompressor{stats_store, \"test.\", 16, false};\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  EXPECT_EQ(0, stats_store.counterFromString(\"test.brotli_error\").value());\n}\n\nclass UncommonParamsTest : public BrotliDecompressorImplTest,\n                           public testing::WithParamInterface<std::tuple<bool, bool>> {\nprotected:\n  void testcompressDecompressWithUncommonParams(\n      const uint32_t quality, const uint32_t window_bits, const uint32_t input_block_bits,\n      const bool disable_literal_context_modeling,\n      const Compression::Brotli::Compressor::BrotliCompressorImpl::EncoderMode encoder_mode,\n      const bool disable_ring_buffer_reallocation) {\n    Buffer::OwnedImpl buffer;\n    Buffer::OwnedImpl accumulation_buffer;\n\n    Compression::Brotli::Compressor::BrotliCompressorImpl compressor{\n        quality,      window_bits, input_block_bits, disable_literal_context_modeling,\n        encoder_mode, 4096};\n\n    std::string original_text{};\n    for (uint64_t i = 0; i < 30; ++i) {\n      TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n      original_text.append(buffer.toString());\n      compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n      accumulation_buffer.add(buffer);\n      drainBuffer(buffer);\n    }\n    ASSERT_EQ(0, buffer.length());\n\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n    accumulation_buffer.add(buffer);\n\n    drainBuffer(buffer);\n    ASSERT_EQ(0, buffer.length());\n\n    Stats::IsolatedStoreImpl stats_store{};\n    BrotliDecompressorImpl decompressor{stats_store, \"test.\", 4096,\n                                        disable_ring_buffer_reallocation};\n\n    decompressor.decompress(accumulation_buffer, buffer);\n    std::string decompressed_text{buffer.toString()};\n\n    ASSERT_EQ(original_text.length(), decompressed_text.length());\n    EXPECT_EQ(original_text, decompressed_text);\n    EXPECT_EQ(0, stats_store.counterFromString(\"test.brotli_error\").value());\n  }\n};\n\nINSTANTIATE_TEST_SUITE_P(UncommonParamsTestSuite, UncommonParamsTest,\n                         testing::Values(std::make_tuple(false, false),\n                                         std::make_tuple(false, true), std::make_tuple(true, false),\n                                         std::make_tuple(true, true)));\n\n// Exercises decompression with other supported brotli initialization params.\nTEST_P(UncommonParamsTest, Validate) {\n  const bool disable_literal_context_modeling = std::get<0>(GetParam());\n  const bool disable_ring_buffer_reallocation = std::get<1>(GetParam());\n\n  // Test with different memory levels.\n  for (uint32_t i = 1; i < 8; ++i) {\n    testcompressDecompressWithUncommonParams(\n        i - 1,                    // quality\n        default_window_bits,      // window_bits\n        default_input_block_bits, // input_block_bits\n        disable_literal_context_modeling,\n        Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Font,\n        disable_ring_buffer_reallocation);\n\n    testcompressDecompressWithUncommonParams(\n        default_quality,     // quality\n        default_window_bits, // window_bits\n        i + 15,              // input_block_bits\n        disable_literal_context_modeling,\n        Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Text,\n        disable_ring_buffer_reallocation);\n\n    testcompressDecompressWithUncommonParams(\n        default_quality,          // quality\n        i + 10,                   // window_bits\n        default_input_block_bits, // input_block_bits\n        disable_literal_context_modeling,\n        Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Generic,\n        disable_ring_buffer_reallocation);\n  }\n}\n\n} // namespace\n} // namespace Decompressor\n} // namespace Brotli\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/common/assert.h\"\n#include \"source/common/stats/isolated_store_impl.h\"\n#include \"source/extensions/compression/gzip/compressor/zlib_compressor_impl.h\"\n#include \"source/extensions/compression/gzip/decompressor/zlib_decompressor_impl.h\"\n\n#include \"test/fuzz/fuzz_runner.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Gzip {\nnamespace Compressor {\nnamespace Fuzz {\n\n// Fuzzer for zlib compression. While the zlib project has its own fuzzer, this\n// fuzzer validates that the Envoy wiring around zlib makes sense and the\n// specific ways we configure it are safe. The fuzzer below validates a round\n// trip compress-decompress pair; the decompressor itself is not fuzzed beyond\n// whatever the compressor emits, as it exists only as a test utility today.\nDEFINE_FUZZER(const uint8_t* buf, size_t len) {\n\n  FuzzedDataProvider provider(buf, len);\n  ZlibCompressorImpl compressor;\n  Stats::IsolatedStoreImpl stats_store;\n  Decompressor::ZlibDecompressorImpl decompressor{stats_store, \"test\"};\n\n  // Select target compression level. We can't use ConsumeEnum() since the range\n  // is non-contiguous.\n  const ZlibCompressorImpl::CompressionLevel compression_levels[] = {\n      ZlibCompressorImpl::CompressionLevel::Best,\n      ZlibCompressorImpl::CompressionLevel::Speed,\n      ZlibCompressorImpl::CompressionLevel::Standard,\n  };\n  const ZlibCompressorImpl::CompressionLevel target_compression_level =\n      provider.PickValueInArray(compression_levels);\n\n  // Select target compression strategy. We can't use ConsumeEnum() since the\n  // range does not start with zero.\n  const ZlibCompressorImpl::CompressionStrategy compression_strategies[] = {\n      ZlibCompressorImpl::CompressionStrategy::Filtered,\n      ZlibCompressorImpl::CompressionStrategy::Huffman,\n      ZlibCompressorImpl::CompressionStrategy::Rle,\n      ZlibCompressorImpl::CompressionStrategy::Standard,\n  };\n  const ZlibCompressorImpl::CompressionStrategy target_compression_strategy =\n      provider.PickValueInArray(compression_strategies);\n\n  // Select target window bits. The range comes from the PGV constraints in\n  // api/envoy/config/filter/http/gzip/v2/gzip.proto.\n  const int64_t target_window_bits = provider.ConsumeIntegralInRange(9, 15);\n\n  // Select memory level. The range comes from the restriction in the init()\n  // header comments.\n  const uint64_t target_memory_level = provider.ConsumeIntegralInRange(1, 9);\n\n  compressor.init(target_compression_level, target_compression_strategy, target_window_bits,\n                  target_memory_level);\n  decompressor.init(target_window_bits);\n\n  bool provider_empty = provider.remaining_bytes() == 0;\n  Buffer::OwnedImpl full_input;\n  Buffer::OwnedImpl full_output;\n  while (!provider_empty) {\n    const std::string next_data = provider.ConsumeRandomLengthString(provider.remaining_bytes());\n    ENVOY_LOG_MISC(debug, \"Processing {} bytes\", next_data.size());\n    full_input.add(next_data);\n    Buffer::OwnedImpl buffer{next_data.data(), next_data.size()};\n    provider_empty = provider.remaining_bytes() == 0;\n    compressor.compress(buffer, provider_empty ? Envoy::Compression::Compressor::State::Finish\n                                               : Envoy::Compression::Compressor::State::Flush);\n    decompressor.decompress(buffer, full_output);\n  }\n  if (stats_store.counterFromString(\"test.zlib_data_error\").value() == 0) {\n    RELEASE_ASSERT(full_input.toString() == full_output.toString(), \"\");\n    RELEASE_ASSERT(compressor.checksum() == decompressor.checksum(), \"\");\n  }\n}\n\n} // namespace Fuzz\n} // namespace Compressor\n} // namespace Gzip\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/stats/isolated_store_impl.h\"\n#include \"source/extensions/compression/gzip/compressor/zlib_compressor_impl.h\"\n#include \"source/extensions/compression/gzip/decompressor/zlib_decompressor_impl.h\"\n\n#include \"test/test_common/utility.h\"\n\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Gzip {\nnamespace Decompressor {\n\nclass ZlibDecompressorImplTest : public testing::Test {\nprotected:\n  void drainBuffer(Buffer::OwnedImpl& buffer) { buffer.drain(buffer.length()); }\n\n  void testcompressDecompressWithUncommonParams(\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel comp_level,\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy\n          comp_strategy,\n      int64_t window_bits, uint64_t memory_level) {\n    Buffer::OwnedImpl buffer;\n    Buffer::OwnedImpl accumulation_buffer;\n\n    Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;\n    compressor.init(comp_level, comp_strategy, window_bits, memory_level);\n\n    std::string original_text{};\n    for (uint64_t i = 0; i < 30; ++i) {\n      TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n      original_text.append(buffer.toString());\n      compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n      accumulation_buffer.add(buffer);\n      drainBuffer(buffer);\n    }\n    ASSERT_EQ(0, buffer.length());\n\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n    accumulation_buffer.add(buffer);\n\n    drainBuffer(buffer);\n    ASSERT_EQ(0, buffer.length());\n\n    Stats::IsolatedStoreImpl stats_store{};\n    ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n    decompressor.init(window_bits);\n\n    decompressor.decompress(accumulation_buffer, buffer);\n    std::string decompressed_text{buffer.toString()};\n\n    ASSERT_EQ(compressor.checksum(), decompressor.checksum());\n    ASSERT_EQ(original_text.length(), decompressed_text.length());\n    EXPECT_EQ(original_text, decompressed_text);\n    ASSERT_EQ(0, decompressor.decompression_error_);\n  }\n\n  static constexpr int64_t gzip_window_bits{31};\n  static constexpr int64_t memory_level{8};\n  static constexpr uint64_t default_input_size{796};\n};\n\nclass ZlibDecompressorImplFailureTest : public ZlibDecompressorImplTest {\nprotected:\n  static void decompressorBadInitTestHelper(int64_t window_bits) {\n    Stats::IsolatedStoreImpl stats_store{};\n    ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n    decompressor.init(window_bits);\n  }\n\n  static void uninitializedDecompressorTestHelper() {\n    Buffer::OwnedImpl input_buffer;\n    Buffer::OwnedImpl output_buffer;\n    Stats::IsolatedStoreImpl stats_store{};\n    ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n    TestUtility::feedBufferWithRandomCharacters(input_buffer, 100);\n    decompressor.decompress(input_buffer, output_buffer);\n    ASSERT_TRUE(decompressor.decompression_error_ < 0);\n    ASSERT_EQ(stats_store.counterFromString(\"test.zlib_stream_error\").value(), 1);\n  }\n};\n\n// Test different failures by passing bad initialization params or by calling decompress before\n// init.\nTEST_F(ZlibDecompressorImplFailureTest, DecompressorFailureTest) {\n  EXPECT_DEATH(decompressorBadInitTestHelper(100), \"assert failure: result >= 0\");\n  uninitializedDecompressorTestHelper();\n}\n\n// Exercises decompressor's checksum by calling it before init or decompress.\nTEST_F(ZlibDecompressorImplTest, CallingChecksum) {\n  Buffer::OwnedImpl compressor_buffer;\n  Buffer::OwnedImpl decompressor_output_buffer;\n\n  Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;\n  ASSERT_EQ(0, compressor.checksum());\n\n  compressor.init(\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Standard,\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Standard,\n      gzip_window_bits, memory_level);\n  ASSERT_EQ(0, compressor.checksum());\n\n  TestUtility::feedBufferWithRandomCharacters(compressor_buffer, 4096);\n  compressor.compress(compressor_buffer, Envoy::Compression::Compressor::State::Flush);\n  ASSERT_TRUE(compressor.checksum() > 0);\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n  decompressor.init(gzip_window_bits);\n  EXPECT_EQ(0, decompressor.checksum());\n\n  decompressor.decompress(compressor_buffer, decompressor_output_buffer);\n\n  drainBuffer(compressor_buffer);\n  drainBuffer(decompressor_output_buffer);\n\n  EXPECT_EQ(compressor.checksum(), decompressor.checksum());\n  ASSERT_EQ(0, decompressor.decompression_error_);\n}\n\n// Detect excessive compression ratio by compressing a long whitespace string\n// into a very small chunk of data and decompressing it again.\nTEST_F(ZlibDecompressorImplTest, DetectExcessiveCompressionRatio) {\n  const absl::string_view ten_whitespaces = \"          \";\n  Buffer::OwnedImpl buffer;\n  Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;\n  compressor.init(\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Standard,\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Standard,\n      gzip_window_bits, memory_level);\n\n  for (int i = 0; i < 1000; i++) {\n    buffer.add(ten_whitespaces);\n  }\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n\n  Buffer::OwnedImpl output_buffer;\n  Stats::IsolatedStoreImpl stats_store{};\n  ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n  decompressor.init(gzip_window_bits);\n  decompressor.decompress(buffer, output_buffer);\n  ASSERT_EQ(stats_store.counterFromString(\"test.zlib_data_error\").value(), 1);\n}\n\n// Exercises compression and decompression by compressing some data, decompressing it and then\n// comparing compressor's input/checksum with decompressor's output/checksum.\nTEST_F(ZlibDecompressorImplTest, CompressAndDecompress) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n  Buffer::OwnedImpl empty_buffer;\n\n  Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;\n  compressor.init(\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Standard,\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Standard,\n      gzip_window_bits, memory_level);\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n    original_text.append(buffer.toString());\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n\n  ASSERT_EQ(0, buffer.length());\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  ASSERT_GE(10, buffer.length());\n\n  accumulation_buffer.add(buffer);\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n  decompressor.init(gzip_window_bits);\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  // Check decompressor's internal state isn't broken.\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n  decompressor.decompress(empty_buffer, buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  ASSERT_EQ(compressor.checksum(), decompressor.checksum());\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  ASSERT_EQ(0, decompressor.decompression_error_);\n}\n\n// Tests decompression_error_ set to True when Decompression Fails\nTEST_F(ZlibDecompressorImplTest, FailedDecompression) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n    original_text.append(buffer.toString());\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n  Stats::IsolatedStoreImpl stats_store{};\n  ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n  decompressor.init(gzip_window_bits);\n\n  decompressor.decompress(accumulation_buffer, buffer);\n\n  ASSERT_TRUE(decompressor.decompression_error_ < 0);\n  ASSERT_EQ(stats_store.counterFromString(\"test.zlib_data_error\").value(), 17);\n}\n\n// Exercises decompression with a very small output buffer.\nTEST_F(ZlibDecompressorImplTest, DecompressWithSmallOutputBuffer) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  Envoy::Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;\n  compressor.init(\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Standard,\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Standard,\n      gzip_window_bits, memory_level);\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);\n    original_text.append(buffer.toString());\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n\n  ASSERT_EQ(0, buffer.length());\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  ASSERT_GE(10, buffer.length());\n\n  accumulation_buffer.add(buffer);\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZlibDecompressorImpl decompressor{stats_store, \"test.\", 16};\n  decompressor.init(gzip_window_bits);\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(compressor.checksum(), decompressor.checksum());\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  ASSERT_EQ(0, decompressor.decompression_error_);\n}\n\n// Exercises decompression with other supported zlib initialization params.\nTEST_F(ZlibDecompressorImplTest, CompressDecompressWithUncommonParams) {\n  // Test with different memory levels.\n  for (uint64_t i = 1; i < 10; ++i) {\n    testcompressDecompressWithUncommonParams(\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Best,\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Rle, 15,\n        i);\n\n    testcompressDecompressWithUncommonParams(\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Best,\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Rle, 15,\n        i);\n\n    testcompressDecompressWithUncommonParams(\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Speed,\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Huffman,\n        15, i);\n\n    testcompressDecompressWithUncommonParams(\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Speed,\n        Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::\n            Filtered,\n        15, i);\n  }\n}\n\nTEST_F(ZlibDecompressorImplTest, CompressDecompressOfMultipleSlices) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  const std::string sample{\"slice, slice, slice, slice, slice, \"};\n  std::string original_text;\n  for (uint64_t i = 0; i < 20; ++i) {\n    Buffer::BufferFragmentImpl* frag = new Buffer::BufferFragmentImpl(\n        sample.c_str(), sample.size(),\n        [](const void*, size_t, const Buffer::BufferFragmentImpl* frag) { delete frag; });\n\n    buffer.addBufferFragment(*frag);\n    original_text.append(sample);\n  }\n\n  const uint64_t num_slices = buffer.getRawSlices().size();\n  EXPECT_EQ(num_slices, 20);\n\n  Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;\n  compressor.init(\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Standard,\n      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Standard,\n      gzip_window_bits, memory_level);\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n  accumulation_buffer.add(buffer);\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZlibDecompressorImpl decompressor{stats_store, \"test.\"};\n  decompressor.init(gzip_window_bits);\n\n  drainBuffer(buffer);\n  ASSERT_EQ(0, buffer.length());\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(compressor.checksum(), decompressor.checksum());\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n}\n\nclass ZlibDecompressorStatsTest : public testing::Test {\nprotected:\n  void chargeErrorStats(const int result) { decompressor_.chargeErrorStats(result); }\n\n  Stats::IsolatedStoreImpl stats_store_{};\n  ZlibDecompressorImpl decompressor_{stats_store_, \"test.\"};\n};\n\nTEST_F(ZlibDecompressorStatsTest, ChargeErrorStats) {\n  decompressor_.init(31);\n\n  chargeErrorStats(Z_ERRNO);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_errno\").value(), 1);\n  chargeErrorStats(Z_STREAM_ERROR);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_stream_error\").value(), 1);\n  chargeErrorStats(Z_DATA_ERROR);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_data_error\").value(), 1);\n  chargeErrorStats(Z_MEM_ERROR);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_mem_error\").value(), 1);\n  chargeErrorStats(Z_BUF_ERROR);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_buf_error\").value(), 1);\n  chargeErrorStats(Z_VERSION_ERROR);\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zlib_version_error\").value(), 1);\n}\n\n} // namespace Decompressor\n} // namespace Gzip\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/stats/isolated_store_impl.h\"\n#include \"source/extensions/compression/zstd/compressor/zstd_compressor_impl.h\"\n#include \"source/extensions/compression/zstd/decompressor/config.h\"\n\n#include \"test/mocks/server/factory_context.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Compression {\nnamespace Zstd {\nnamespace Decompressor {\nnamespace {\n\nclass ZstdDecompressorImplTest : public testing::Test {\nprotected:\n  void drainBuffer(Buffer::OwnedImpl& buffer) {\n    buffer.drain(buffer.length());\n    ASSERT_EQ(0, buffer.length());\n  }\n\n  static constexpr uint32_t default_compression_level_{6};\n  static constexpr uint32_t default_enable_checksum_{0};\n  static constexpr uint32_t default_strategy_{0};\n  static constexpr uint32_t default_input_size_{796};\n  Zstd::Compressor::ZstdCDictManagerPtr default_cdict_manager_{nullptr};\n  ZstdDDictManagerPtr default_ddict_manager_{nullptr};\n};\n\n// Exercises decompression with a very small output buffer.\nTEST_F(ZstdDecompressorImplTest, DecompressWithSmallOutputBuffer) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  Zstd::Compressor::ZstdCompressorImpl compressor{default_compression_level_,\n                                                  default_enable_checksum_, default_strategy_,\n                                                  default_cdict_manager_, 4096};\n\n  std::string original_text{};\n  for (uint64_t i = 0; i < 20; ++i) {\n    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size_ * i, i);\n    original_text.append(buffer.toString());\n    compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n    accumulation_buffer.add(buffer);\n    drainBuffer(buffer);\n  }\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  accumulation_buffer.add(buffer);\n  drainBuffer(buffer);\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZstdDecompressorImpl decompressor{stats_store, \"test.\", default_ddict_manager_, 16};\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  EXPECT_EQ(0, stats_store.counterFromString(\"test.zstd_generic_error\").value());\n}\n\nTEST_F(ZstdDecompressorImplTest, WrongInput) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl output_buffer;\n  const char zeros[20]{};\n\n  Buffer::BufferFragmentImpl* frag = new Buffer::BufferFragmentImpl(\n      zeros, 20, [](const void*, size_t, const Buffer::BufferFragmentImpl* frag) { delete frag; });\n  buffer.addBufferFragment(*frag);\n  Stats::IsolatedStoreImpl stats_store{};\n  ZstdDecompressorImpl decompressor{stats_store, \"test.\", default_ddict_manager_, 16};\n  decompressor.decompress(buffer, output_buffer);\n  EXPECT_EQ(1, stats_store.counterFromString(\"test.zstd_generic_error\").value());\n}\n\nTEST_F(ZstdDecompressorImplTest, CompressDecompressOfMultipleSlices) {\n  Buffer::OwnedImpl buffer;\n  Buffer::OwnedImpl accumulation_buffer;\n\n  const std::string sample{\"slice, slice, slice, slice, slice, \"};\n  std::string original_text;\n  for (uint64_t i = 0; i < 20; ++i) {\n    Buffer::BufferFragmentImpl* frag = new Buffer::BufferFragmentImpl(\n        sample.c_str(), sample.size(),\n        [](const void*, size_t, const Buffer::BufferFragmentImpl* frag) { delete frag; });\n\n    buffer.addBufferFragment(*frag);\n    original_text.append(sample);\n  }\n\n  const uint64_t num_slices = buffer.getRawSlices().size();\n  EXPECT_EQ(num_slices, 20);\n\n  Zstd::Compressor::ZstdCompressorImpl compressor{default_compression_level_,\n                                                  default_enable_checksum_, default_strategy_,\n                                                  default_cdict_manager_, 4096};\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);\n  accumulation_buffer.add(buffer);\n  drainBuffer(buffer);\n\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n  accumulation_buffer.add(buffer);\n  drainBuffer(buffer);\n\n  Stats::IsolatedStoreImpl stats_store{};\n  ZstdDecompressorImpl decompressor{stats_store, \"test.\", default_ddict_manager_, 16};\n\n  decompressor.decompress(accumulation_buffer, buffer);\n  std::string decompressed_text{buffer.toString()};\n\n  ASSERT_EQ(original_text.length(), decompressed_text.length());\n  EXPECT_EQ(original_text, decompressed_text);\n  EXPECT_EQ(0, stats_store.counterFromString(\"test.zstd_generic_error\").value());\n}\n\nTEST_F(ZstdDecompressorImplTest, IllegalConfig) {\n  envoy::extensions::compression::zstd::decompressor::v3::Zstd zstd;\n  Zstd::Decompressor::ZstdDecompressorLibraryFactory lib_factory;\n  NiceMock<Server::Configuration::MockFactoryContext> mock_context;\n  std::string json;\n\n  json = R\"EOF({\n  \"chunk_size\": 4096,\n  \"dictionaries\": [\n    {\n      \"inline_string\": \"\"\n    }\n  ]\n})EOF\";\n  TestUtility::loadFromJson(json, zstd);\n  EXPECT_THROW_WITH_MESSAGE(lib_factory.createDecompressorFactoryFromProto(zstd, mock_context),\n                            EnvoyException, \"DataSource cannot be empty\");\n\n  json = R\"EOF({\n  \"chunk_size\": 4096,\n  \"dictionaries\": [\n    {\n      \"inline_string\": \"456789\"\n    }\n  ]\n})EOF\";\n  TestUtility::loadFromJson(json, zstd);\n  EXPECT_DEATH({ lib_factory.createDecompressorFactoryFromProto(zstd, mock_context); },\n               \"assert failure: id != 0. Details: Illegal Zstd dictionary\");\n}\n\n// Detect excessive compression ratio by compressing a long whitespace string\n// into a very small chunk of data and decompressing it again.\nTEST_F(ZstdDecompressorImplTest, DetectExcessiveCompressionRatio) {\n  const absl::string_view ten_whitespaces = \"          \";\n  Buffer::OwnedImpl buffer;\n  for (int i = 0; i < 1000; i++) {\n    buffer.add(ten_whitespaces);\n  }\n\n  Zstd::Compressor::ZstdCompressorImpl compressor{default_compression_level_,\n                                                  default_enable_checksum_, default_strategy_,\n                                                  default_cdict_manager_, 4096};\n  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);\n\n  Buffer::OwnedImpl output_buffer;\n  Stats::IsolatedStoreImpl stats_store{};\n  ZstdDecompressorImpl decompressor{stats_store, \"test.\", default_ddict_manager_, 16};\n  decompressor.decompress(buffer, output_buffer);\n  ASSERT_EQ(stats_store.counterFromString(\"test.zstd_generic_error\").value(), 1);\n}\n\n} // namespace\n\n// Copy from\n// https://github.com/facebook/zstd/blob/dev/contrib/seekable_format/zstdseek_decompress.c#L123\n// For test only\n#define ZSTD_ERROR(name) static_cast<size_t>(-ZSTD_error_##name)\n\nclass ZstdDecompressorStatsTest : public testing::Test {\nprotected:\n  bool isError(size_t result) { return decompressor_.isError(result); }\n\n  Stats::IsolatedStoreImpl stats_store_{};\n  ZstdDDictManagerPtr ddict_manager_{nullptr};\n  ZstdDecompressorImpl decompressor_{stats_store_, \"test.\", ddict_manager_, 16};\n};\n\nTEST_F(ZstdDecompressorStatsTest, ChargeErrorStats) {\n  EXPECT_FALSE(isError(0)); // no error\n\n  EXPECT_TRUE(isError(ZSTD_ERROR(memory_allocation)));\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zstd_memory_error\").value(), 1);\n\n  EXPECT_TRUE(isError(ZSTD_ERROR(dictionary_corrupted)));\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zstd_dictionary_error\").value(), 1);\n  EXPECT_TRUE(isError(ZSTD_ERROR(dictionary_wrong)));\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zstd_dictionary_error\").value(), 2);\n\n  EXPECT_TRUE(isError(ZSTD_ERROR(checksum_wrong)));\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zstd_checksum_wrong_error\").value(), 1);\n\n  EXPECT_TRUE(isError(-1)); // generic error\n  ASSERT_EQ(stats_store_.counterFromString(\"test.zstd_generic_error\").value(), 1);\n}\n\n} // namespace Decompressor\n} // namespace Zstd\n} // namespace Compression\n} // namespace Extensions\n} // namespace Envoy\n"], "filenames": ["docs/root/version_history/current.rst", "source/common/runtime/runtime_features.cc", "source/extensions/compression/brotli/common/base.cc", "source/extensions/compression/brotli/common/base.h", "source/extensions/compression/brotli/decompressor/BUILD", "source/extensions/compression/brotli/decompressor/brotli_decompressor_impl.cc", "source/extensions/compression/gzip/common/base.h", "source/extensions/compression/gzip/decompressor/BUILD", "source/extensions/compression/gzip/decompressor/zlib_decompressor_impl.cc", "source/extensions/compression/zstd/decompressor/zstd_decompressor_impl.cc", "source/extensions/compression/zstd/decompressor/zstd_decompressor_impl.h", "test/extensions/compression/brotli/decompressor/brotli_decompressor_impl_test.cc", "test/extensions/compression/gzip/compressor_fuzz_test.cc", "test/extensions/compression/gzip/decompressor/zlib_decompressor_impl_test.cc", "test/extensions/compression/zstd/decompressor/zstd_decompressor_impl_test.cc"], "buggy_code_start_loc": [16, 42, 9, 15, 21, 3, 15, 23, 9, 1, 6, 26, 74, 122, 151], "buggy_code_end_loc": [17, 42, 12, 19, 21, 60, 16, 23, 51, 38, 42, 26, 76, 122, 151], "fixing_code_start_loc": [15, 43, 9, 15, 22, 4, 14, 24, 10, 2, 7, 27, 74, 123, 152], "fixing_code_end_loc": [15, 44, 13, 21, 23, 80, 14, 25, 76, 63, 45, 53, 78, 148, 173], "type": "CWE-400", "message": "Envoy is a cloud-native high-performance proxy. In versions prior to 1.22.1 secompressors accumulate decompressed data into an intermediate buffer before overwriting the body in the decode/encodeBody. This may allow an attacker to zip bomb the decompressor by sending a small highly compressed payload. Maliciously constructed zip files may exhaust system memory and cause a denial of service. Users are advised to upgrade. Users unable to upgrade may consider disabling decompression.", "other": {"cve": {"id": "CVE-2022-29225", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-09T20:15:08.000", "lastModified": "2022-06-16T17:30:42.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Envoy is a cloud-native high-performance proxy. In versions prior to 1.22.1 secompressors accumulate decompressed data into an intermediate buffer before overwriting the body in the decode/encodeBody. This may allow an attacker to zip bomb the decompressor by sending a small highly compressed payload. Maliciously constructed zip files may exhaust system memory and cause a denial of service. Users are advised to upgrade. Users unable to upgrade may consider disabling decompression."}, {"lang": "es", "value": "Envoy es un proxy de alto rendimiento nativo de la nube. En versiones anteriores a 1.22.1, los secompresores acumulan los datos descomprimidos en un buffer intermedio antes de sobrescribir el cuerpo en el decode/encodeBody. Esto puede permitir a un atacante bombardear el descompresor mediante el env\u00edo de una peque\u00f1a carga \u00fatil altamente comprimida. Los archivos zip construidos de forma maliciosa pueden agotar la memoria del sistema y causar una denegaci\u00f3n de servicio. Es recomendado a usuarios actualizar. Los usuarios que no puedan actualizar pueden considerar deshabilitar la descompresi\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}, {"lang": "en", "value": "CWE-409"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.22.1", "matchCriteriaId": "343FE7CD-C2BF-42EE-8384-AAD008BE690D"}]}]}], "references": [{"url": "https://github.com/envoyproxy/envoy/commit/cb4ef0b09200c720dfdb07e097092dd105450343", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-75hv-2jjj-89hh", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/envoyproxy/envoy/commit/cb4ef0b09200c720dfdb07e097092dd105450343"}}