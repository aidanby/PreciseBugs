{"buggy_code": ["<?php\n/**\n * edih_csv_inc.php\n *\n * Copyright 2012 Kevin McCormick\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 3 or later.  You should have\n * received a copy of the GNU General Public License along with this program;\n * if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n *  <http://opensource.org/licenses/gpl-license.php>\n *\n * @author Kevin McCormick\n * @link: http://www.open-emr.org\n * @package OpenEMR\n * @subpackage ediHistory\n */\n\n/*\n * The purpose of this file is to hold functions of general utility for\n * my edi_claim_history project.  It began as a php \"class\" but I am now\n * thinking that instantiating the class is too much bother and probably\n * a waste of memory, since the contents of the file have to be read into\n * memory anyway.\n *\n * <pre>\n * ******* important *********\n * function csv_parameters($type=\"ALL\")\n *   This function must have the correct values or nothing will work\n * function csv_verify_file( $file_path, $type, $val_array=FALSE )\n *   critical for file verification and x12 parsing\n * function (in ibr_uploads.php) ibr_upload_match_file($param_ar, $fidx, &$html_str)\n *   contains a regular expression that must be correct\n *\n * Also, the constant IBR_HISTORY_DIR must be correct\n * **************************\n * </pre>\n *\n * The claim_history x12 files are claim (837) acknowledgement (997/999) claim status (277) and claim payment (835)\n * Also eligibility request (270) and eligibility response (271)  \n *\n * <pre>\n * Basic workflow:\n *  Each file type has a row in the array from csv_paramaters()\n *     type  directory files_csv  claims_csv  column  regex\n *\n *  1. open submitted file in edih_x12_class to verify and produce properties\n *  2. Read the parameters array and choose the parameters using 'type'\n *  2. Search the matched type 'directory' for the filename files matching the 'regex' regular expressions and\n *     compare the results to the files listed in the 'files_csv' files.csv record -- unmatched files are \"new\"\n *  3. Each \"new\" x12 file should be read by csv_x12_segments -- returns array('path', 'delimiters', 'segments')\n *      ibr, ebr, ack -- basically Availity formats have their own read functions\n *  4. Pass the array to various functions which parse for claims information\n *  5. Write the results to files.csv or claims.csv and create html output for display\n *\n *  6. Other outputs as called for in ibr_history.php -- from user input from claim_history.html\n * </pre>\n *\n *  Key usability issue is the \"new\" files are in the users home directory -- downloaded there\n *   while the OpenEMR is on the server -- so there is a basic issue of access to the files\n *\n *  The ibr_uploads.php script handles uploads of zip archives or multiple file uploads\n *\n * The csv data files are just php written .csv files, so anything different may cause errors\n * You can open and edit them in OpenOffice, but you must save them in \"original format\"\n *\n * TO_DO Some type of \"find in files\" search would be helpful for locating all references to a claim, patient, etc.\n *    [ grep -nHIrF 'findtext']\n *\n * TO_DO functions to zip old files, put them aside, and remove them from csv tables\n */\n\n///**\n// *  a security measure to prevent direct web access to this file\n// */\n// if (!defined('SITE_IN')) die('Direct access not allowed!');\n// $GLOBALS['OE_EDIH_DIR']  $GLOBALS['OE_SITE_DIR']\n\n/* *********** GLOBALS used for testing only **********\n */\n// //$GLOBALS['OE_SITE_DIR'].'/edi/history';\n//$OE_SITES_BASE = $GLOBALS['OE_SITE_DIR'];\n//$OE_SITE_DIR = $OE_SITES_BASE.'/testing';\n//$OE_EDIH_DIR = $OE_SITE_DIR.'/edi/history';\n\n/* ***********\n */\n/**\n * Constant that is checked in included files to prevent direct access.\n * concept taken from Joomla\n */\ndefine('_EDIH', 1);\n//DIRECTORY_SEPARATOR;\nif (!defined('DS')) define('DS', DIRECTORY_SEPARATOR);\n\n/**\n * Log messages to the log file\n *\n * @param string $msg_str  the log message\n * @return int             number of characters written\n */\nfunction csv_edihist_log ( $msg_str ) {\n\t//\n\t//$dir = dirname(__FILE__).DS.'log';\n\t//$dir = $GLOBALS['OE_EDIH_DIR'].DS.'log';\n\t//$logfile = $GLOBALS['OE_EDIH_DIR'] . \"/log/edi_history_log.txt\";\n\t$logfile = 'edih_log_'.date('Y-m-d').'.txt';\n\t$dir = csv_edih_basedir().DS.'log';\n\t$rslt = 0;\n\tif ( is_string($msg_str) && strlen($msg_str) ) {\n\t\t$tm = date('Ymd:Hms') . ' ' . $msg_str . PHP_EOL;\n\t\t//\n\t\t$rslt = file_put_contents($dir.DS.$logfile, $tm, FILE_APPEND);\n\t} else {\n\t\t//\n\t\t$fnctn = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2)[1]['function'];\n\t\tcsv_edihist_log ('invalid message string '.$fnctn);\n\t}\n\t//\n\treturn $rslt;  // number of characters written\n}\n\n/**\n * read the edi_history_log.txt file into an\n * html formatted ordered list\n *\n * @return string\n */\nfunction csv_log_html($logname='') {\n\t$html_str = \"<div class='filetext'>\".PHP_EOL.\"<ol class='logview'>\".PHP_EOL;\n    $fp = csv_edih_basedir().DS.'log'.DS.$logname;\n    if ( is_file($fp) ) {\n\t\t$fh = fopen( $fp, 'r');\n\t\tif ($fh !== FALSE) {\n\t\t\twhile (($buffer = fgets($fh)) !== false) {\n\t\t\t\t$html_str .= \"<li>\".$buffer.\"</li>\".PHP_EOL;\n\t\t\t}\n\t\t\t$html_str .= \"</ol>\".PHP_EOL.\"</div>\".PHP_EOL;\n\t\t\tif (!feof($fh)) {\n\t\t\t\t$html_str .= \"<p>Error in logfile: unexpected file ending</p>\".PHP_EOL;\n\t\t\t}\n\t\t\tfclose($fh);\n\t\t} else {\n\t\t\t$html_str = \"<p>Error: unable to open log file</p>\".PHP_EOL;\n\t\t}\n\t}\n\treturn $html_str;\n}\n\n\n/**\n * list log files and store old logs in an archive\n *\n * @param bool\n * @return array (json)\n */\nfunction csv_log_manage($list=true) {\n\t//\n\t//$dir = dirname(__FILE__).DS.'log';\n\t$dir = csv_edih_basedir().DS.'log';\n\t$list_ar = array();\n\t$old_ar = array();\n\t$lognames = scandir($dir);\n\tif ($list) {\n\t\tforeach($lognames as $log) {\n\t\t\tif (!strpos($log, '_log_')) { continue; }\n\t\t\t$list_ar[] = $log;\n\t\t}\n\t\t$s = (count($list_ar)) ? rsort($list_ar) : false;\n\t\t//\n\t\treturn json_encode($list_ar);\n\t\t//\n\t} else {\n\t\t// list is false, must be archive\n\t\t$datetime1 = date_create(date('Y-m-d'));\n\t\t//\t\t\t\t\n\t\tforeach($lognames as $log) {\n\t\t\tif ($log == '.' || $log == '..') { continue; }\n\t\t\t//\n\t\t\t$pos1 = strrpos($log, '_');\n\t\t\tif ($pos1) {\n\t\t\t\t$ldate = substr($log, $pos1+1, 10);\n\t\t\t\t$datetime2 = date_create($ldate);\n\t\t\t\t$interval = date_diff($datetime1, $datetime2);\n\t\t\t\t//echo '== date difference '.$ldate.' '.$interval->format('%R%a days').PHP_EOL;\n\t\t\t\tif ($interval->format('%R%a') < -7) {\n\t\t\t\t\t// older log files are put in zip archive\n\t\t\t\t\tif ( is_file($dir.DS.$log) ) { $old_ar[] = $log; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//\n\t$ok = false;\n\t$archname = $dir.DS.'edih-log-archive.zip';\n\t$filelimit = 200;\n\t//\n\tif (count($old_ar)) {\n\t\t$zip = new ZipArchive;\n\t\tif (is_file($archname)) {\n\t\t\t$ok = $zip->open($archname, ZipArchive::CHECKCONS);\n\t\t} else {\n\t\t\t$ok = $zip->open($archname, ZipArchive::CREATE);\n\t\t}\n\t\t//\n\t\tif ($ok) {\n\t\t\tif ($zip->numFiles >= $filelimit) {\n\t\t\t\t$zip->close();\n\t\t\t\t$dte = $datetime1->format('Ymd');\n\t\t\t\t$ok = rename($dir.DS.$archname, $dir.DS.$dte.'_'.$archname);\n\t\t\t\tcsv_edihist_log('csv_log_archive: rename full archive '.$dte.'_'.$archname );\n\t\t\t\tif ($ok) {\n\t\t\t\t\t$ok = $zip->open($archname, ZipArchive::CREATE);\n\t\t\t\t\tif (!$ok) {\n\t\t\t\t\t\tcsv_edihist_log('csv_log_archive: cannot create '.$archname);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcsv_edihist_log('csv_log_archive: cannot rename '.$archname);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\tif ($ok) {\n\t\t\t\tforeach($old_ar as $lg) {\n\t\t\t\t\tif (is_file($dir.DS.$lg)) {\n\t\t\t\t\t\t$a = $zip->addFile($dir.DS.$lg, $lg);\n\t\t\t\t\t\tif ($a) {\n\t\t\t\t\t\t\tcsv_edihist_log('csv_log_archive: add to archive '.$lg );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcsv_edihist_log('csv_log_archive: error archiving '.$lg );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$c = $zip->close();\n\t\t\t\tif ($c) {\n\t\t\t\t\tforeach($old_ar as $lg) {\n\t\t\t\t\t\t$u = unlink($dir.DS.$lg);\n\t\t\t\t\t\tif ($u) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcsv_edihist_log('csv_log_archive: error removing '.$dir.DS.$lg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcsv_edihist_log('csv_log_archive: error closing log file archive');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcsv_edihist_log('csv_log_manage: error failed to open '.$archname);\n\t\t\t}\n\t\t}\n\t}\n\t//\n\treturn json_encode($old_ar);\n}\n\n\n/**\n * open or save a user notes file\n *\n * @param string\n * @param bool\n * @return string\n */\nfunction csv_notes_file($content='', $open=true) {\n\t//\n\t$str_html = '';\n    //$fp = $GLOBALS['OE_EDIH_DIR'].'/edi_notes.txt';\n    $fp = csv_edih_basedir().DS.'archive'.DS.'edi_notes.txt';\n\tif (! is_writable($fp) ) {\n\t\t$fh = fopen( $fp, 'a+b');\n\t\tfclose($fh);\n\t}\n\t// for retrieving notes\n\tif ($open) {\n\t\t// if contents were previously deleted by user and file is empty,\n\t\t// the text 'empty' is put in content in save operation\n\t\t$ftxt = file_get_contents($fp);\n\t\tif ($ftxt === false) {\n\t\t\t$str_html .= 'csv_notes_file: file error <br>'.PHP_EOL;\n\t\t\tcsv_edihist_log('csv_notes_file: file error');\n\t\t}\n\t\tif (substr($ftxt, 0, 5) == 'empty' && strlen($ftxt) == 5) {\n\t\t\t$ftxt = '## '. date(\"F j, Y, g:i a\");\n\t\t} elseif (!$ftxt) {\n\t\t\t$ftxt = '## '. date(\"F j, Y, g:i a\");\n\t\t}\n\t\t$str_html .= PHP_EOL.$ftxt.PHP_EOL;\n\t// next stanza for saving content\n\t} elseif (strlen($content)) {\n\t\t//echo \"csv_notes_file: we have content<br>\".PHP_EOL;\n\t\t// use finfo php class\n\t\tif ( class_exists('finfo') ) {\n\t\t\t$finfo = new finfo(FILEINFO_MIME);\n\t\t    $mimeinfo = $finfo->buffer($content);\n\t\t    if ( strncmp($mimeinfo, 'text/plain; charset=us-ascii', 28) !== 0 ) {\n\t\t\t\tcsv_edihist_log('csv_notes_file: invalid mime-type '.$mimeinfo);\n\t\t\t\t$str_html = 'csv_notes_file: invalid mime-type <br>'.$mimeinfo;\n\t\t\t\t//\n\t\t\t\treturn $str_html;\n\t\t\t}\n\t\t} elseif (preg_match('/[^\\x20-\\x7E\\x0A\\x0D]|(<\\?)|(<%)|(<asp)|(<ASP)|(#!)|(\\$\\{)|(<scr)|(<SCR)/', $content, $matches, PREG_OFFSET_CAPTURE)) {\n\t\t\tcsv_edihist_log('csv_notes_file: Filtered character in file content -- character: '.$matches[0][0].' position: '.$matches[0][1]);\n\t\t\t$str_html .= 'Filtered character in file content not accepted <br>'. PHP_EOL;\n\t\t\t$str_html .= ' character: ' . $matches[0][0] . '  position: ' . $matches[0][1] . '<br>' . PHP_EOL;\n\t\t\t//\n\t\t\treturn $str_html;\n\t\t}\n\t} else {\n\t\t$ftxt = ($content) ? $content : 'empty';\n\t\t$saved = file_put_contents($fp, $ftxt);\n\t\t$str_html .= ($saved) ? '<p>Save Error with notes file</p>' : '<p>Notes content saved</p>';\n\t}\n\t//\n\treturn $str_html;\n}\n\n/**\n * generates path to edi history files\n *\n * @return string|bool   directory path\n */\nfunction csv_edih_basedir() {\n    // should be something like /var/www/htdocs/openemr/sites/default\n    if (isset($GLOBALS['OE_SITE_DIR'])) {\n\t\t// debug\n\t\t//echo 'csv_edih_basedir OE_SITE_DIR '.$GLOBALS['OE_SITE_DIR'].'<br>'.PHP_EOL;\n        return $GLOBALS['OE_SITE_DIR'].DS.'edi'.DS.'history';\n    } else {\n        csv_edihist_log('csv_edih_basedir: failed to obtain OpenEMR Site directory');\n        return false;\n    }\n}\n\n/**\n * generates path to edi_history tmp dir for file upload operations\n * \n * @uses csv_edih_basedir()\n * @return string   directory path\n */\nfunction csv_edih_tmpdir() {\n    //\n    $bdir = csv_edih_basedir();\n    $tdir = ($bdir) ? $bdir.DS.'tmp' : false;\n    //$systmp = sys_get_temp_dir();\n    //$systmp = stripcslashes($systmp);\n    //$systdir = $systmp.DS.'edihist';\n    //if ( $tdir && (is_dir($tdir) || mkdir($tdir, 0755) ) ) {\n\tif ( $tdir) {\n\t\treturn $tdir;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n\n\n/**\n * Initial setup function\n *\n * Create the directory tree and write the column headers into the csv files\n * This function will accept a directory argument and it appends the value\n * from IBR_HISTORY_DIR to the path.  Then a directory for each type of file\n * and the csv files are created under that.\n *\n * @uses csv_parameters()\n * @uses csv_table_header()\n * @uses csv_edih_basedir()\n *\n * @param string &$out_str  referenced, should be created in calling function\n * @return boolean\n */\nfunction csv_setup() {\n\t//\n\t$isOK = false;\n\t$out_str = '';\n\t$chr = 0;\n\t// $GLOBALS['OE_SITE_DIR'] should be like /var/www/htdocs/openemr/sites/default\n\t$sitedir = $GLOBALS['OE_SITE_DIR'];\n\t//$sitedir = csv_edih_basedir();\n    //\n    if (is_readable($sitedir)) {\n\t\t$basedir = $sitedir.DS.'edi';\n\t\t$edihist_dir = $basedir.DS.'history';\n        $csv_dir = $edihist_dir.DS.'csv';\n        $archive_dir = $edihist_dir.DS.'archive';\n        $log_dir = $edihist_dir.DS.'log';\n        $tmp_dir = $edihist_dir.DS.'tmp';\n    } else {\n       //csv_edihist_log('setup: failed to obtain OpenEMR Site directory');\n       echo 'setup: failed to obtain OpenEMR Site directory<br>'.PHP_EOL;\n       return false;\n    }\n\t//\n\tif (is_writable($basedir) ) {\n\t\t$isOK = true;\n\t\t//csv_edihist_log('setup: directory '.$basedir);\n\t\t$out_str .= 'EDI_History Setup should not overwrite existing data.<br>'.PHP_EOL;\n\t\t$out_str .= 'Setup: directory '.$basedir.'<br>'.PHP_EOL;\n\t\t//\n\t\tif (is_dir($edihist_dir) || mkdir($edihist_dir, 0755)) {\n\t\t\t$out_str .= 'created folder '.$edihist_dir.'<br>'.PHP_EOL;\n\t\t\t$isOK = true;\n\t\t\tif (is_dir($csv_dir) || mkdir($csv_dir, 0755) ) {\n\t\t\t\t$out_str .= 'created folder '.$csv_dir.'<br>'.PHP_EOL;\n\t\t\t\t$isOK = true;\n\t\t\t} else {\n\t\t\t\t$isOK = false;\n\t\t\t\t$out_str .= 'Setup: Failed to create csv folder... '.'<br>'.PHP_EOL;\n\t\t\t\tdie('Failed to create csv folder... '.$archive_dir);\n\t\t\t}\n\t\t\tif (is_dir($archive_dir) || mkdir($archive_dir, 0755) ) {\n\t\t\t\t$out_str .= 'created folder '.$archive_dir.'<br>'.PHP_EOL;\n\t\t\t\t$isOK = true;\n\t\t\t} else {\n\t\t\t\t$isOK = false;\n\t\t\t\t$out_str .= 'Setup: Failed to create archive folder... '.'<br>'.PHP_EOL;\n\t\t\t\tdie('Failed to create archive folder... ');\n\t\t\t}\n\t\t\tif (is_dir($log_dir) || mkdir($log_dir, 0755) ) {\n\t\t\t\t$out_str .= 'created folder '.$log_dir.'<br>'.PHP_EOL;\n\t\t\t\t$isOK = true;\n\t\t\t} else {\n\t\t\t\t$isOK = false;\n\t\t\t\t$out_str .= 'Setup: Failed to create log folder... '.'<br>'.PHP_EOL;\n\t\t\t\tdie('Failed to create log folder... ');\n\t\t\t}\n\t\t\tif (is_dir($tmp_dir) || mkdir($tmp_dir, 0755) ) {\n\t\t\t\t$out_str .= 'created folder '.$tmp_dir.PHP_EOL;\n\t\t\t\t$isOK = true;\n\t\t\t} else {\n\t\t\t\t$isOK = false;\n\t\t\t\t$out_str .= 'Setup: Failed to create tmp folder... '.'<br>'.PHP_EOL;\n\t\t\t\tdie('Failed to create tmp folder... ');\n\t\t\t}\n\t\t} else {\n\t\t\t$isOK = false;\n\t\t\t$out_str .= 'Setup failed: cannot write to folder '.$basedir.'<br>'.PHP_EOL;\n\t\t\tdie('Setup failed: cannot write to '.$basedir);\n\t\t}\n\t} else {\n\t\t$isOK = false;\n\t\t$out_str .= 'Setup: Failed to create history folder... '.'<br>'.PHP_EOL;\n\t\tdie('Failed to create history folder... '.$edihist_dir);\n\t}\n\tif ($isOK) {\n\t\t$p_ar = csv_parameters('ALL');\n\t\t$old_csv = array('f837'=>'batch', 'f835'=>'era');\n\t\tforeach ($p_ar as $key=>$val) {\n\t\t\t// rename existing csv files to old_filename\n\t\t\tif (is_dir($csv_dir)) {\n\t\t\t\tif ($dh = opendir($csv_dir)) {\n\t\t\t\t\twhile (($file = readdir($dh)) !== false) {\n\t\t\t\t\t\tif (is_file($csv_dir.DS.$file) && strpos($file, 'csv')) {\n\t\t\t\t\t\t\t$rn = rename($csv_dir.DS.$file, $csv_dir.DS.'old_'.$file);\n\t\t\t\t\t\t\tif ($rn) {\n\t\t\t\t\t\t\t\t$out_str .= 'renamed csv/'.$file.' to old_'.$file.'<br />'.PHP_EOL;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$out_str .= 'attempt to rename csv/'.$file.' failed<br />'.PHP_EOL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//;\n\t\t\t// make the edi files storage subdirs\n\t\t\t$tp = $p_ar[$key]['type'];\n\t\t\t$type_dir = $p_ar[$key]['directory'];\n\t\t\t//\n\t\t\tif (is_dir($type_dir)) {\n\t\t\t\t$out_str .= 'folder for '.$tp.' exists '.$type_dir.'<br>'.PHP_EOL;\n\t\t\t} elseif (mkdir($type_dir, 0755)) {\n\t\t\t\tif ($tp == 'f835') {\n\t\t\t\t\t// in upgrade case the f835 directory should not exist\n\t\t\t\t\t// move 'era' files from /era to /f835\n\t\t\t\t\tif (is_dir($edihist_dir.DS.'era')) {\n\t\t\t\t\t\t$fct = 0; $rct = 0;\n\t\t\t\t\t\tif ($dh = opendir($edihist_dir.DS.'era')) {\n\t\t\t\t\t\t\twhile (($file = readdir($dh)) !== false) {\n\t\t\t\t\t\t\t\tif (is_file($edihist_dir.DS.'era'.DS.$file)) {\n\t\t\t\t\t\t\t\t\t$rct++;\n\t\t\t\t\t\t\t\t\t$rn = rename($edihist_dir.DS.'era'.DS.$file, $type_dir.DS.$file);\n\t\t\t\t\t\t\t\t\t$fct = ($rn) ? $fct + 1 : $fct;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$out_str .= 'created type folder '.$type_dir.' and moved '.$fct.' of '.$rct.' files from /era<br>'.PHP_EOL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$out_str .= 'created type folder '.$type_dir.'<br>'.PHP_EOL;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t$out_str .= 'Setup failed to create directory for '.$tp.'<br>'.PHP_EOL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t$out_str .= 'Setup failed: Can not create directories <br>'.PHP_EOL;\n\t}\n \n\tif ($isOK) {\n\t\tcsv_edihist_log($out_str);\n\t\treturn true;\n\t} else {\n\t\treturn $out_str;\n\t}\n}\n\n\n/**\n * Empty all contents of tmp dir /edi/history/tmp\n *\n * @uses csv_edih_tmpdir()\n * @param  none\n * @return bool\n */\nfunction csv_clear_tmpdir() {\n\t//\n    $tmpdir = csv_edih_tmpdir();\n    if ( basename($tmpdir) != 'tmp' ) {\n\t\tcsv_edihist_log ( 'tmp dir not /edi/history/tmp');\n\t\treturn false;\n\t}\n\t$tmp_files = scandir($tmpdir);\n\tif (count($tmp_files) > 2) {\n\t\tforeach($tmp_files as $idx=>$tmpf) {\n\t\t\tif ($tmpf == \".\" || $tmpf == \"..\") {\n\t\t\t\t// can't delete . and ..\n\t\t\t\tcontinue;\n\t\t\t} elseif (is_file($tmpdir.DS.$tmpf) ) {\n\t\t\t\tunlink($tmpdir.DS.$tmpf);\n\t\t\t} elseif(is_dir($tmpdir.DS.$tmpf)) {\n\t\t\t\t$tdir_ar = scandir($tmpdir.DS.$tmpf);\n\t\t\t\tforeach($tdir_ar as $tfn) {\n\t\t\t\t\tif ($tfn == \".\" || $tfn == \"..\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} elseif (is_file($tmpdir.DS.$tmpf.DS.$tfn)) {\n\t\t\t\t\t\tunlink($tmpdir.DS.$tmpf.DS.$tfn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trmdir($tmpdir.DS.$tmpf);\n\t\t\t}\n\t\t}\n\t}\n\t$tmp_files = scandir($tmpdir);\n\tif (count($tmp_files) > 2) {\n\t\tcsv_edihist_log ('tmp dir contents remain in ... /edi/history/tmp');\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\n/**\n * open and verify a default edih_x12_file object\n * \n * @uses csv_check_filepath()\n * \n * @param string   filepath or filename\n * @parm string    file x12 type\n * @return object  edih_x12_file class \n */\nfunction csv_check_x12_obj($filepath, $type='') {\n\t//\t\n\t$x12obj = false;\n\t$ok = false;\n\t//\n\t$fp = csv_check_filepath($filepath, $type);\n\t//\n\tif ($fp) {\n\t\t$x12obj = new edih_x12_file($fp);\n\t\tif ( 'edih_x12_file' == get_class($x12obj) ) {\n\t\t\tif ($x12obj->edih_valid() == 'ovigs') {\n\t\t\t\t$ok = count( $x12obj->edih_segments() );\n\t\t\t\t$ok = ($ok) ?  count( $x12obj->edih_envelopes() ) : false;\n\t\t\t\t$ok = ($ok) ?  count( $x12obj->edih_delimiters() ) : false;\n\t\t\t\tif (!$ok) {\n\t\t\t\t\tcsv_edihist_log(\"csv_check_x12_obj: object missing properties [$filepath]\");\n\t\t\t\t\tcsv_edihist_log( $x12obj->edih_message() );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcsv_edihist_log(\"csv_check_x12_obj: invalid object $filepath\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tcsv_edihist_log(\"csv_check_x12_obj: object not edih_x12_file $filepath\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tcsv_edihist_log(\"csv_check_x12_obj: invalid file path $filepath\");\n\t\treturn false;\n\t}\n\t//\n\treturn $x12obj;\n}\n\n/**\n * Check that the file path we are working with is a readable file.\n *\n * If it is a file we have uploaded and we have only the file name\n * this function will type the file and find it in the uploaded files directories\n * and return the complete path.\n *\n * @uses csv_parameters()\n * @param string $filename    name of a file that is one of our types\n * @param string $type        optional; one of our file types\n * @return string             either an empty string or a readable filepath\n */\nfunction csv_check_filepath($filename, $type='ALL') {\n\t//\n\t// if file is readable, just return it\n\tif ( is_file($filename) && is_readable($filename) ) {\n\t\treturn $filename;\n\t}\n\t//\n\t$goodpath = '';\n\t$fp = '';\n\t$fn = basename($filename);\n\t//\n\tif ($type && $type != 'ALL') {\n\t\t$p = csv_parameters($type);\n\t\tif (is_array($p) && array_key_exists('type', $p) ) {\n            $fp = $p['directory'].DS.$fn;\n\t\t}\n\t} else {\n\t\t$p_ar = csv_parameters(\"ALL\");\n\t\tforeach ($p_ar as $tp=>$par) {\n\t\t\tif ( !$p_ar[$tp]['regex'] || !preg_match($p_ar[$tp]['regex'], $fn) ) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n                $fp = $p_ar[$tp]['directory'].DS.$fn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif ( is_file($fp) && is_readable($fp) ) { $goodpath = realpath($fp); }\n\t//\n\treturn $goodpath;\n}\n\n/**\n * verify file type parameter\n *\n * @param string    file type\n * @param bool      return GS02 code or fXXX\n * @return string   file type or empty \n */\nfunction csv_file_type($type, $gs_code=false) {\n\t//\n\tif (!$type) {\n\t\tcsv_edihist_log('csv_file_type: invalid or missing type argument '.$type);\n\t\treturn false;\n\t} else {\n\t\t$tp_type = (string)$type;\n\t}\n\t//\n\tif ( strpos('|f837|batch|HC', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HC' : 'f837';\n\t} elseif ( strpos('|f835|era|HP', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HP' : 'f835';\n\t} elseif ( strpos('|f999|f997|ack|ta1|FA', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'FA' : 'f997';\n\t} elseif ( strpos('|f277|HN', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HN' : 'f277';\n\t} elseif ( strpos('|f276|HR', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HR' : 'f276';\n\t} elseif ( strpos('|f271|HB', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HB' : 'f271';\n\t} elseif ( strpos('|f270|HS', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HS' : 'f270';\n\t} elseif ( strpos('|f278|HI', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HI' : 'f278';\n\t} else {\n\t\t$tp = '';\n\t}\n\t//\n\tif ( !$tp) {\n\t\tcsv_edihist_log('csv_file_type error: incorrect type '.$tp_type);\n\t}\n\treturn $tp;\n}\n\n\n/**\n * The array that holds the various parameters used in dealing with files\n *\n * A key function since it holds the paths, columns, etc.  \n * Unfortunately, there is an issue with matching the type in  * the case of the \n * values '997', '277', '999', etc, becasue these strings may be recast\n * from strings to integers, so the 'type' originally supplied is lost.\n * This introduces an inconsistency when the 'type' is used in comparison tests.\n * We call the csv_file_type() function to return a usable file type identifier.\n * The 'datecolumn' and 'fncolumn' entries are used in csv_to_html() to filter by date\n * or place links to files.\n *\n * @param string $type -- default = ALL or one of batch, ibr, ebr, dpr, f997, f277, era, ack, text\n * @return array\n */\nfunction csv_parameters($type='ALL') {\n\t//\n\t// This will need the OpenEMR 'oe_site_dir' to replace global\n\t//\n\t$p_ar = array();\n\n    $tp = ($type === 'ALL') ? $type : csv_file_type($type);\n\tif (!$tp) {\n\t\tcsv_edihist_log('csv_parameters() error: incorrect type '.$type);\n\t\treturn $p_ar;\n\t}\n\t//$edihist_dir = $GLOBALS['OE_SITE_DIR'].'/edi/history';\n\t$edihist_dir = csv_edih_basedir();\n\t//\n\t// the batch file directory is a special case - decide whether to use OpenEMR batch files or make our own copies\n\t// OpenEMR copies each batch file to sites/default/edi and this project never writes to that directory\n\t// batch reg ex -- '/20[01][0-9]-[01][0-9]-[0-3][0-9]-[0-9]{4}-batch*\\.txt/' '/\\d{4}-\\d{2}-\\d{2}-batch*\\.txt$/'\n\t//\n    $p_ar['f837'] = array('type'=>'f837', 'directory'=>$GLOBALS['OE_SITE_DIR'].DS.'edi', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f837.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f837.csv', 'filedate'=>'Date', 'claimdate'=>'SvcDate', 'regex'=>'/\\-batch(.*)\\.txt$/');\n\t//\n\t//$p_ar['csv'] = array(\"type\"=>'csv', \"directory\"=>$edihist_dir.'/csv', \"claims_csv\"=>'ibr_parameters.csv',\n\t//\t\t\t\t\t\"files_csv\"=>'', \"column\"=>'', \"regex\"=>'/\\.csv$/');\n\t$p_ar['f997'] = array('type'=>'f997', 'directory'=>$edihist_dir.DS.'f997', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f997.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f997.csv', 'filedate'=>'Date', 'claimdate'=>'RspDate', 'regex'=>'/\\.(99[79]|ta1|ack)$/i');\n\t$p_ar['f276'] = array('type'=>'f276', 'directory'=>$edihist_dir.DS.'f276', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f276.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f276.csv', 'filedate'=>'Date', 'claimdate'=>'ReqDate', 'regex'=>'/\\.276([ei]br)?$/');\n\t$p_ar['f277'] = array('type'=>'f277', 'directory'=>$edihist_dir.DS.'f277', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f277.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f277.csv', 'filedate'=>'Date', 'claimdate'=>'SvcDate', 'regex'=>'/\\.277([ei]br)?$/i');\n\t$p_ar['f270'] = array('type'=>'f270', 'directory'=>$edihist_dir.DS.'f270', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f270.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f270.csv', 'filedate'=>'Date', 'claimdate'=>'ReqDate', 'regex'=>'/\\.270([ei]br)?$/i');\n\t$p_ar['f271'] = array('type'=>'f271', 'directory'=>$edihist_dir.DS.'f271', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f271.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f271.csv', 'filedate'=>'Date', 'claimdate'=>'RspDate', 'regex'=>'/\\.271([ei]br)?$/i');\n\t$p_ar['f278'] = array('type'=>'f278', 'directory'=>$edihist_dir.DS.'f278', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f278.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f278.csv', 'filedate'=>'Date', 'claimdate'=>'FileDate', 'regex'=>'/\\.278/');\n\t// OpenEMR stores era files, but the naming scheme is confusing, so we will just use our own directory for them\n\t$p_ar['f835'] = array('type'=>'f835', 'directory'=>$edihist_dir.DS.'f835', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f835.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f835.csv', 'filedate'=>'Date', 'claimdate'=>'SvcDate', 'regex'=>'/835[0-9]{5}\\.835*|\\.(era|ERA|835)$/i');\n\t//\n\tif ( array_key_exists($tp, $p_ar) ) {\n\t\treturn $p_ar[$tp];\n\t} else {\n\t\treturn $p_ar;\n\t}\n}\n\n/**\n * determine if a csv table has data for select dropdown\n *\n * @param string   default 'json'\n * @return array   json if argument is 'json'\n */\nfunction csv_table_select_list($outtp='json') {\n\t$optlist = array();\n\t$labels = array('f835'=>'Payments', 'f837'=>'Claims', 'batch'=>'Claims', 'f277'=>'Status', 'f276'=>'Status Req',\n\t                'f997'=>'Ack','f271'=>'Benefit', 'f270'=>'Benefit Req', 'f278'=>'Auth');\n\n    $edihist_dir = csv_edih_basedir();  // $GLOBALS['OE_SITE_DIR'].'/edi/history'\n    $csvdir = $edihist_dir.DS.'csv';\n\t$tbllist = scandir($csvdir);\n\t$idx = 0;\n\tforeach($tbllist as $csvf) {\n\t\tif ($csvf == \".\" || $csvf == \"..\" ) { continue; }\n\t\tif (strpos($csvf, 'old') === 0) { continue; }\n\t\tif (filesize($csvdir.DS.$csvf) < 70) { continue; }\n\t\tif (substr($csvf, -1) == '~') { continue; }\n\t\t$finfo = pathinfo($csvdir.DS.$csvf);\n\t\t$fn = $finfo['filename'];\n\t\t// e.g. files_f997\n\t\t$tp = explode('_', $fn);\n\t\t//$lblkey = $labels[$tp[1]];\n\t\t$optlist[$tp[0]][$tp[1]]['fname'] = $fn;\n\t\t$optlist[$tp[0]][$tp[1]]['desc'] = $tp[0].'-'.$labels[$tp[1]]; //$tp[1] .' '.$tp[0];\n\t\t$idx++;\n\t}\n\tif ($outtp == 'json') {\n\t\treturn json_encode($optlist);\n\t} else {\n\t\treturn $optlist;\n\t}\n}\n\n/**\n * list existing archive files\n *\n * @param string   default 'json'\n * @return array   json if argument is 'json'\n */\nfunction csv_archive_select_list($outtp='json') {\n\t//\n\t$flist = array();\n\t$archdir = csv_edih_basedir().DS.'archive';\n\t//\n\t// debug\n\tcsv_edihist_log(\"csv_archive_select_list: using $archdir\");\n\t//\n\t$scan = scandir($archdir);\n\tif (is_array($scan) && count($scan)) {\n\t\tforeach($scan as $s) {\n\t\t\tif ($s == '.' || $s == '..') {\n\t\t\t\tcontinue;\n\t\t\t} elseif (strpos($s, 'note')) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t$flist[] = $s;\n\t\t\t}\n\t\t}\n\t}\n\tif ($outtp == 'json') {\n\t\treturn json_encode($flist);\n\t} else {\n\t\treturn $flist;\n\t}\n}\n\n/**\n * List files in the directory for the given type\n *\n * Write an entry in the log if an file is in the directory\n * that does not match the type\n *\n * @uses csv_parameters()\n * @param string $type    a type from our list\n * @return array\n */\nfunction csv_dirfile_list($type) {\n\t// return false if location is not appropriate\n\t$tp = csv_file_type($type);\n\tif (!$tp) {\n\t\tcsv_edihist_log(\"csv_dirfile_list error: incorrect type $type\");\n\t\treturn false;\n\t}\n\t$params = csv_parameters($tp);\n\tif (empty($params) || csv_singlerecord_test($params) == false ) {\n\t\tcsv_edihist_log(\"csv_dirfile_list() error: incorrect type $type\");\n\t\treturn false;\n\t}\n    $search_dir = $params['directory'];\n\t$ext_re = $params['regex'];\n\t$dirfiles = array();\n\t// \n\tif (is_dir($search_dir)) {\n\t    if ($dh = opendir($search_dir)) {\n\t        while (($file = readdir($dh)) !== false) {\n\t\t\t\tif ($file == '.' || $file == '..') {\n\t\t\t\t\tcontinue;\n\t\t\t\t} elseif ($tp == 'f837' && ($file == 'history' || $file == 'README.txt')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} elseif (is_file($search_dir.DS.$file) ) {\n\t\t\t\t\t$dirfiles[] = $file;\n\t\t\t\t} else {\n\t\t\t\t\tif ($tp == 'f837' && $file == 'history') { continue; }\n\t\t\t\t\tcsv_edihist_log(\"csv_dirfile_list $type : not a file $file\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcsv_edihist_log(\"csv_dirfile_list $type : error in scan $search_dir\");\n\t\t}\n\t} else {\n\t\tcsv_edihist_log(\"csv_dirfile_list $type : not a directory $search_dir\");\n\t}\n\t//\n\treturn $dirfiles;\n} // end function\n\n\n/**\n * List files that are in the csv record\n *\n * @uses csv_parameters()\n * @uses csv_table_header()\n * \n * @param string $type -- one of our types\n * @return array\n */\nfunction csv_processed_files_list($type) {\n\t//\n\t$tp = csv_file_type($type);\n\tif (!$tp) {\n\t\tcsv_edihist_log(\"csv_processed_files_list: incorrect type $type\");\n\t\treturn false;\n\t}\n\t$processed_files = array();\n\t$param = csv_parameters($tp);\n\t$hdr_ar = csv_table_header($tp, 'file');\n\tif ( is_array($hdr_ar) ) {\n\t\tforeach($hdr_ar as $k=>$hd) {\n\t\t\tif ($hd == 'FileName') { $csv_col = $k; break; }\n\t\t}\n\t}\n\t$csv_col = (isset($csv_col)) ? $csv_col : 1;\n\t$csv_file = $param['files_csv'];\n\t//if ($tp == 'dpr') {\n        //$csv_file = $param['claims_csv'];\n\t\t//$csv_col = '5';\n\t//} else {\n        //$csv_file = $param['files_csv'];\n\t//}\n\t//\n\t//$idx = 0;\n\tif (is_file($csv_file)) {\n\t\tif (($fh1 = fopen( $csv_file, \"r\" )) !== FALSE) {\n\t\t    while (($data = fgetcsv($fh1, 1024, \",\")) !== FALSE) {\n\t\t\t\t$processed_files[] = $data[$csv_col];\n\t\t\t\t//\n\t\t        //if ($idx) { $processed_files[] = $data[$csv_col]; }\n\t\t        // skip the header row\n\t\t        //$idx++;\n\t\t\t}\n\t\t\tfclose($fh1);\n\t\t} else {\n\t\t\tcsv_edihist_log (\"csv_list_processed_files: failed to access $csv_file\" );\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// first run - no file exists\n\t\tcsv_edihist_log(\"csv_processed_files_list: csv file does not exist \".basename($csv_file));\n\t}\n\t// remove the header row, but avoid NULL or false\n\t$ret_ar = (empty($processed_files)) ? $processed_files : array_slice($processed_files, 1);\n\treturn $ret_ar;\n} // end function\n\n\n/**\n * Give an array of files in the storage directories that are not in the csv record\n *\n * @param string $type -- one of our types\n * @return array\n */\nfunction csv_newfile_list($type) {\n\t//\n\t$ar_new = array();\n\t$tp = csv_file_type($type);\n\tif (!$tp) {\n\t\tcsv_edihist_log('csv_newfile_list: incorrect type '.$type);\n\t\treturn false;\n\t}\n\t//\n\t$dir_files = csv_dirfile_list($tp);\n\t$csv_files = csv_processed_files_list($tp);\n\t//\n\t// $dir_files should come first in array_diff()\n\tif (empty($dir_files)) {\n\t\t$ar_new = array();\n\t} elseif (empty($csv_files) || is_null($csv_files)) {\n\t\t$ar_new = $dir_files;\n\t} else {\n\t\t$ar_new = array_diff($dir_files, $csv_files);\n\t}\n\t//\n\treturn $ar_new;\n}\n\n/**\n * Parse 997 IK3 error segment to identify segment causing rejection\n * The error segment string is specially created in edih_997_csv_data()\n * Simple analysis, but the idea is just to identify the bad segment\n * \n * @param string\t\t\terror segment from edih_997_csv_data()\n * @param bool\t\t\t\ttrue if only the 1st segmentID is wanted\n * return array|string\n */\nfunction edih_errseg_parse($err_seg, $id=false) {\n\t// ['err_seg'] = '|IK3*segID*segpos*loop*errcode*bht03syn|CTX-IK3*transID*segID*segpos*elempos\n\t//                |IK4*elempos*errcode*elem*|CTX-IK4*segID*segpos*elempos\n\t//\n\t// note: multiple IK3 segments are allowed in 997/999 x12\n\t//\n\t$ret_ar = array();\n\tif ( !$err_seg || strpos($err_seg, 'IK3') === false) {\n\t\tcsv_edihist_log('edih_errseg_parse: invalid argument');\n\t\treturn $ret_ar;\n\t}\n\t//'|IK3*segID*segpos*loop*errcode*bht03syn|CTX-IK3*segID*segPos*loopLS*elemPos:compositePos:repPos\n\t// revised: 123456789004*IK3*segID*segpos[*segID*segpos*segID*segpos]\n\t$ik = explode('*', $err_seg);\n\tforeach($ik as $i=>$k) {\n\t\tswitch((int)$i) {\n\t\t\tcase 0:$ret_ar['trace'] = $k; break;\n\t\t\tcase 1: break;  // IK3\n\t\t\tcase 2: $ret_ar['id'][] = $k; break;   // segment ID\n\t\t\tcase 3: $ret_ar['err'][] = $k; break;  // segment position\n\t\t\tcase 4: $ret_ar['id'][] = $k; break;\n\t\t\tcase 5: $ret_ar['err'][] = $k; break;\n\t\t\tcase 6: $ret_ar['id'][] = $k; break;\n\t\t\tcase 7: $ret_ar['err'][] = $k; break;\n\t\t}\n\t}\n\t//\n\treturn $ret_ar;\n}\n\n/**\n * Order the csv data array according to the csv table heading row\n * so the data to be added to csv table rows are correctly ordered\n *  the supplied data should be in an array with thie structure\n *  array['icn'] ['file'][i]['key']  ['claim'][i]['key']  ['type']['type']\n *\n * @uses csv_table_header()\n * \n * @param array   data_ar    data array from edih_XXX_csv_data()\n * @return array|bool        ordered array or false on error\n */\nfunction edih_csv_order($csvdata) {\n\t//\n\t$wrcsv = array();\n\t$order_ar = array();\n\t//\n\tforeach($csvdata as $icn=>$data) {\n\t\t// [icn]['type']['file']['claim']\n\t\t$ft = $data['type'];\n\t\t$wrcsv[$icn]['type'] = $ft;\n\t\t//\n\t\tforeach($data as $key=>$val) {\n\t\t\tif ($key == 'type') { continue; }\n\t\t\t$order_ar[$icn][$key] = csv_table_header($ft, $key);\n\t\t\t$ct = count($order_ar[$icn][$key]);\n\t\t\tforeach($val as $k=>$rcrd) {\n\t\t\t\t//\n\t\t\t\tforeach($order_ar[$icn][$key] as $ky=>$vl) {\n\t\t\t\t\t$wrcsv[$icn][$key][$k][$ky] = $rcrd[$vl];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn $wrcsv;\n}\n\n/**\n * insert dashes in ten-digit telephone numbers\n * \n * @param string $str_val   the telephone number\n * @return string           the telephone number with dashes\n */\nfunction edih_format_telephone ($str_val) {\n\t$strtel = (string)$str_val;\n\t$strtel = preg_replace('/\\D/', '', $strtel);\n\tif ( strlen($strtel) != 10 ) {\n\t\tcsv_edihist_log('edih_format_telephone: invalid argument: '.$str_val);\n\t\treturn $str_val;\n\t} else {\n\t\t$tel = substr($strtel,0,3) . \"-\" . substr($strtel,3,3) . \"-\" . substr($strtel,6);\n\t}\n\treturn $tel;\n}\n\n/**\n * order MM DD YYYY values and insert slashes in eight-digit dates\n * \n * US MM/DD/YYYY or general YYYY-MM-DD \n *  \n * @param string $str_val   the eight-digit date\n * @param string $pref      if 'US' (default) anything else means YYYY-MM-DD\n * @return string           the date with slashes\n */\nfunction edih_format_date ($str_val, $pref = \"Y-m-d\") {\n\t$strdt = (string)$str_val;\n\t$strdt = preg_replace('/\\D/', '', $strdt);\n\t$dt = '';\n\tif (strlen($strdt) == 6) {\n\t\t$tdy = date('Ymd');\n\t\tif ($pref == \"US\") {\n\t\t\t// assume mmddyy\n\t\t\t$strdt = substr($tdy,0,2).substr($strdt,-2).substr($strdt,0,4);\n\t\t} else {\n\t\t\t// assume yymmdd\n\t\t\t$strdt = substr($tdy,0,2).$strdt;\n\t\t}\n\t}\n\tif ($pref == \"US\") {\n\t\t$dt = substr($strdt,4,2) . \"/\" . substr($strdt,6) . \"/\" . substr($strdt,0,4);\n\t} else {\n\t\t$dt = substr($strdt,0,4) . \"-\" . substr($strdt,4,2) . \"-\" . substr($strdt,6);\n\t}\n\treturn $dt;\n}\n\n/**\n * format monetary amounts with two digits after the decimal place\n * \n * @todo                    add other formats\n * @param string $str_val   the amount string\n * @return string           the telephone number with dashes\n */\nfunction edih_format_money ($str_val) {\n\t//  \n\tif ($str_val || $str_val === '0') {\n\t\t$mny = sprintf(\"$%01.2f\", $str_val);\n\t} else {\n\t\t$mny = $str_val;\n\t}\n\treturn $mny;\n}\n\n/**\n * format percentage amounts with % sign\n * typical example \".50\" from x12 edi segment element\n * \n * @param string $str_val   the amount string \n * @return string           the value as a percentage\n */\nfunction edih_format_percent ($str_val) {\n\t$val = (float)$str_val;\n\tif (is_float($val)) {\n\t\t$pct = $val*100 . '%';\n\t} else {\n\t\t$pct = $str_val.'%';\n\t}\n\treturn $pct;\n}\n\n/**\n * HTML string for table thead element\n * \n * @uses csv_table_header()\n * @param string\n * @param string\n * @return string\n */\nfunction csv_thead_html($file_type, $csv_type, $tblhd=null) {\n\t//\n\tif (is_array($tblhd) & count($tblhd) ) {\n\t\t$hvals = $tblhd;\n\t} else {\n\t\t$hvals = csv_table_header($file_type, $csv_type);\n\t}\n\tif ( is_array($hvals) && count($hvals) ) {\n\t\t$str_html = '';\n\t} else {\n\t\treturn false;\n\t}\n\t$str_html .= \"<thead>\".PHP_EOL.\"<tr>\".PHP_EOL;\n\tforeach($hvals as $val) {\n\t\t$str_html .=\"<th>$val</th>\";\n\t}\n\t$str_html .= PHP_EOL.\"</tr>\".PHP_EOL.\"</thead>\".PHP_EOL;\n\t//\n\treturn $str_html;\n}\n\n\n/**\n * Give the column headings for the csv files\n * \n * @uses csv_file_type()\n * @param string $file_type  \tone of our edi types\n * @param string $csv_type \t\teither 'file' or 'claim'\n * @return array\n */\nfunction csv_table_header($file_type, $csv_type) {\n\t//\n\t$ft = csv_file_type($file_type);\n\t$ct = strpos('|file', $csv_type) ? 'file' : $csv_type;\n\t$ct = strpos('|claim', $ct) ? 'claim' : $ct;\n\t//\n\t$hdr = array();\n\tif (!$ft || !$ct ) {\n\t\tcsv_edihist_log ('csv_table_header error: incorrect file ['.$file_type.']or csv ['.$csv_type.'] type');\n\t\treturn $hdr;\n\t}\n\t//\n\tif ($ct === 'file') {\n\t\tswitch((string)$ft) {\n\t\t\t//case 'ack': $hdr = array('Date', 'FileName', 'isa13', 'ta1ctrl', 'Code'); break;\n\t\t\t//case 'ebr': $hdr = array('Date', 'FileName', 'clrhsid', 'claim_ct', 'reject_ct', 'Batch'); break;\n\t\t\t//case 'ibr': $hdr = array('Date', 'FileName', 'clrhsid', 'claim_ct', 'reject_ct', 'Batch'); break;\n\t\t\t//\n\t\t\tcase 'f837': $hdr = array('Date', 'FileName', 'Control', 'Claim_ct', 'x12Partner'); break;\n\t\t\tcase 'ta1': $hdr = array('Date', 'FileName', 'Control', 'Trace', 'Code'); break;\n\t\t\tcase 'f997': $hdr = array('Date', 'FileName', 'Control', 'Trace', 'RspType', 'RejCt'); break;\n\t\t\tcase 'f276': $hdr = array('Date', 'FileName', 'Control', 'Claim_ct', 'x12Partner'); break;\n\t\t\tcase 'f277': $hdr = array('Date', 'FileName', 'Control', 'Accept', 'AccAmt', 'Reject', 'RejAmt'); break;\n\t\t\tcase 'f270': $hdr = array('Date', 'FileName', 'Control', 'Claim_ct', 'x12Partner'); break;\n\t\t\tcase 'f271': $hdr = array('Date', 'FileName', 'Control', 'Claim_ct', 'Reject', 'Payer'); break;\n\t\t\tcase 'f278': $hdr = array('Date', 'FileName', 'Control', 'TrnCount', 'Auth', 'Payer'); break;\n\t\t\tcase 'f835': $hdr = array('Date', 'FileName', 'Control', 'Trace', 'Claim_ct', 'Denied', 'Payer'); break;\n\t\t}\n\t} elseif ($ct === 'claim') {\n\t\tswitch((string)$ft) {\n\t\t\t//case 'ebr': $hdr = array('PtName','SvcDate', 'CLM01', 'Status', 'Batch', 'FileName', 'Payer'); break;\n\t\t\t//case 'ibr': $hdr = array('PtName','SvcDate', 'CLM01', 'Status', 'Batch', 'FileName', 'Payer'); break;\n\t\t\t//case 'dpr': $hdr = array('PtName','SvcDate', 'CLM01', 'Status', 'Batch', 'FileName', 'Payer'); break;\n\t\t\t//\n\t\t\tcase 'f837': $hdr = array('PtName', 'SvcDate', 'CLM01', 'InsLevel', 'BHT03', 'FileName', 'Fee', 'PtPaid', 'Provider' ); break;\n\t\t\tcase 'f997': $hdr = array('PtName', 'RspDate', 'Trace', 'Status', 'Control', 'FileName', 'RspType', 'err_seg'); break;\n\t\t\tcase 'f276': $hdr = array('PtName', 'SvcDate', 'CLM01', 'ClaimID', 'BHT03', 'FileName', 'Payer', 'Trace'); break;\n\t\t\tcase 'f277': $hdr = array('PtName', 'SvcDate', 'CLM01', 'Status', 'BHT03', 'FileName', 'Payer', 'Trace'); break;\n\t\t\tcase 'f270': $hdr = array('PtName', 'ReqDate', 'Trace', 'InsBnft', 'BHT03', 'FileName', 'Payer'); break;\n\t\t\tcase 'f271': $hdr = array('PtName', 'RspDate', 'Trace', 'Status', 'BHT03', 'FileName', 'Payer'); break;\n\t\t\tcase 'f278': $hdr = array('PtName', 'FileDate', 'Trace', 'Status', 'BHT03', 'FileName', 'Auth', 'Payer'); break;\n\t\t\tcase 'f835': $hdr = array('PtName', 'SvcDate', 'CLM01', 'Status', 'Trace', 'FileName', 'ClaimID', 'Pmt', 'PtResp', 'Payer'); break;\n\t\t}\n\t} else {\n\t\t// unexpected error  \n\t\tcsv_edihist_log ('edih_csv_table_header() error: failed to match file type ['.$ft.'] or csv type ['.$ct.']');\n\t\treturn false;\n\t}\n\tif (count($hdr) ) {\n\t\treturn $hdr;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/*\nfunction csv_files_header($file_type, $csv_type) {\n\t//\n\t$tp = csv_file_type($type);\n\tif (!$tp) {\n\t\tcsv_edihist_log('csv_files_header: incorrect type '.$file_type);\n\t\treturn false;\n\t}\n\tif (!strpos('|file|claim', $csv_type) ) {\n\t\tcsv_edihist_log('csv_files_header error: incorrect csv type '.$csv_type);\n\t\treturn false;\n\t}\n\t//\n\t$ft = strpos('|277', $file_type) ? 'f277' : $file_type;\n\t$ft = strpos('|835', $file_type) ? 'era' : $ft;\n\t$ft = strpos('|837', $file_type) ? 'batch' : $ft;\n\t$ft = strpos('|999|997|ack|ta1', $file_type) ? 'f997' : $ft;\n\t//\n\t$csv_hd_ar = array();\n\t// dataTables: | 'date' | 'file_name (link)' | 'file_text (link fmt)' | 'claim_ct' | 'reject_ct' |\n\t$csv_hd_ar['ack']['file'] = array('Date', 'FileName', 'isa13', 'ta1ctrl', 'Code');\n\t$csv_hd_ar['ebr']['file'] = array('Date', 'FileName', 'clrhsid', 'claim_ct', 'reject_ct', 'Batch');\n\t$csv_hd_ar['ibr']['file'] = array('Date', 'FileName', 'clrhsid', 'claim_ct', 'reject_ct', 'Batch');\n\t//\n\t// dataTables: | 'date' | 'file_name (link)' | 'file_text (link fmt)' | 'claim_ct' | 'partner' |\n\t$csv_hd_ar['batch']['file'] = array('Date', 'FileName', 'Ctn_837', 'claim_ct', 'x12_partner');\n\t$csv_hd_ar['ta1']['file'] =   array('Date', 'FileName', 'Ctn_ta1', 'ta1ctrl', 'Code');\n\t$csv_hd_ar['f997']['file'] =  array('Date', 'FileName', 'Ctn_999', 'ta1ctrl', 'RejCt');\n\t$csv_hd_ar['f277']['file'] =  array('Date', 'FileName', 'Ctn_277', 'Accept', 'AccAmt', 'Reject', 'RejAmt');\n\t$csv_hd_ar['f270']['file'] =  array('Date', 'FileName', 'Ctn_270', 'claim_ct', 'x12_partner');\n\t$csv_hd_ar['f271']['file'] =  array('Date', 'FileName', 'Ctn_271', 'claim_ct', 'Denied', 'Payer');\n\t$csv_hd_ar['era']['file'] =   array('Date', 'FileName', 'Trace', 'claim_ct', 'Denied', 'Payer');\n\t//\n\t// dataTables: | 'pt_name' | 'svc_date' | 'clm01 (link clm)' | 'status (mouseover)' | b f t (links to files) | message (mouseover) |\n\t$csv_hd_ar['ebr']['claim'] = array('PtName','SvcDate', 'clm01', 'Status', 'Batch', 'FileName', 'Payer');\n\t$csv_hd_ar['ibr']['claim'] = array('PtName','SvcDate', 'clm01', 'Status', 'Batch', 'FileName', 'Payer');\n\t$csv_hd_ar['dpr']['claim'] = array('PtName','SvcDate', 'clm01', 'Status', 'Batch', 'FileName', 'Payer');\n\t//\n\t// dataTables: | 'pt_name' | 'svc_date' | 'clm01 (link clm)' | 'status (mouseover)' | 'bht03_837 (link rsp)' | message (mouseover) |\n\t$csv_hd_ar['batch']['claim'] = array('PtName', 'SvcDate', 'clm01', 'InsLevel', 'Ctn_837', 'File_837', 'Fee', 'PtPaid', 'Provider' );\n\t$csv_hd_ar['f997']['claim'] =  array('PtName', 'SvcDate', 'clm01', 'Status', 'ak_num', 'File_997', 'Ctn_837', 'err_seg');\n\t$csv_hd_ar['f277']['claim'] =  array('PtName', 'SvcDate', 'clm01', 'Status', 'st_277', 'File_277', 'payer_name', 'claim_id', 'bht03_837');\n\t$csv_hd_ar['f270']['claim'] =  array('PtName', 'SvcDate', 'clm01', 'InsLevel', 'st_270', 'File_270', 'payer_name', 'bht03_270');\n\t$csv_hd_ar['f271']['claim'] =  array('PtName', 'SvcDate', 'clm01', 'Status', 'st_271', 'File_271', 'payer_name', 'bht03_270');\n\t$csv_hd_ar['era']['claim'] =   array('PtName', 'SvcDate', 'clm01', 'Status', 'trace', 'File_835', 'claimID', 'Pmt', 'PtResp', 'Payer');\n\t//\n\treturn $csv_hd_ar[$ft][$csv_type];\n}\n*/\n\n/**\n * adapted from http://scratch99.com/web-development/javascript/convert-bytes-to-mb-kb/\n *\n * @param int\n *\n * @return string\n */\nfunction csv_convert_bytes($bytes) {\n\t$sizes = array('Bytes', 'KB', 'MB', 'GB', 'TB');\n\tif ($bytes == 0) { return 'n/a'; }\n\t$i = floor( log($bytes) / log(1024) );\n\t//$i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));\n\tif ($i == 0) {\n\t\treturn $bytes.' '.$sizes[$i];\n\t} else {\n\t\treturn round($bytes / pow(1024, $i), 1).' '.$sizes[$i];\n\t}\n}\n\n/**\n * Determine whether an array is multidimensional\n *\n * @param array\n * @return bool   false if arrayis multidimensional\n */\nfunction csv_singlerecord_test ( $array ) {\n\t// the two versions of count() are compared\n\t// if the array has a sub-array, count recursive is greater\n\tif ( is_array($array) ) {\n\t\t$is_sngl = count($array, COUNT_RECURSIVE ) == count( $array, COUNT_NORMAL);\n\t} else {\n\t\t$is_sngl = false;\n\t}\n\t//\n\treturn $is_sngl;\n}\n\n/*\n * give first and last index keys for an array\n * \n * @param array\n * @return array\n */\nfunction csv_array_bounds($array) {\n\t// get the segment array bounds\n\t$ret_ar = array();\n\tif (is_array($array) && count($array)) {\n\t\tif (reset($array) !== false) { $ret_ar[0] = key($array); }\n\t\tif (end($array) !== false) { $ret_ar[1] = key($array); }\n\t}\n\treturn $ret_ar;\n}\n\n/*\n * return a csv file as an associative array\n * the first row is the header or array keys for the row\n * array structure:\n *  array[i]=>array(hdr0=>csvrow[0], hdr1=>csvrow[1], hdr2=>csvrow[2], ...)\n * \n * @param string   file type e.g. f837\n * @param string   csv type claim or file\n * @return array\n */\nfunction csv_assoc_array($file_type, $csv_type) {\n    //\n    if (!$file_type || !$csv_type) {\n\t\tcsv_edihist_log('csv_assoc_array; invalid arguments ft: '.$file_type.' csvt: '.$csv_type);\n\t\treturn false;\n\t}\n    $csv_ar = array();\n    $h = array();\n    $fp = '';\n    //\n    $param = csv_parameters($file_type);\n    $fcsv = (strpos($csv_type, 'aim')) ? 'claims_csv' : 'files_csv';\n    //\n    $fp = (isset($param[$fcsv])) ? $param[$fcsv] : '';\n    if (!is_file($fp)) {\n\t\tcsv_edihist_log('csv_assoc_array; invalid csv file '.basename($fp));\n\t\treturn $csv_ar;\n\t}\n\t$ct = 0;\n\t$row = 0;\n\t$ky = -1;\n\tif (($fh = fopen($fp, \"rb\")) !== false) {\n\t    while (($data = fgetcsv($fh, 2048, \",\")) !== false) {\n\t\t\tif ( is_null($data) ) { continue; }\n\t\t\tif ($row) {\n\t\t\t\tfor($i=0; $i<$ct; $i++) {\n\t\t\t\t\t$csv_ar[$ky][$h[$i]] = $data[$i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$ct = count($data);\n\t\t\t\t$h = $data;\n\t\t\t}\n\t\t\t$row++;\n\t\t\t$ky++;\n        }\n        fclose($fh);\n    } else {\n\t\t // invalid file path\n\t \t csv_edihist_log('csv_assoc_array; invalid file path '.$fp);\n\t\t return false;\n\t}\n\t//\n\treturn $csv_ar;\n}\n\n\n/**\n * A multidimensional array will be flattened to a single row.\n *\n * @param array $array array to be flattened\n * @return array\n */\nfunction csv_array_flatten($array) {\n\t//\n\tif (!is_array($array)) {return FALSE;}\n\t$result = array();\n\tforeach ($array as $key => $value) {\n\t\tif (is_array($value)) {\n\t\t\t$result = array_merge($result, csv_array_flatten($value));\n\t\t} else {\n\t\t\t$result[$key] = $value;\n\t\t}\n\t}\n\treturn $result;\n}\n\n\n/**\n * Write parsed data from edi x12 files to csv file\n * \n * @uses csv_parameters()\n * @usescsv_table_header()\n * \n * @param array    data array from parse functions\n * @return bool    true if no error\n */\nfunction edih_csv_write($csv_data) {\n\t//\n\tif ( ! (is_array($csv_data) && count($csv_data)) ){\n\t\tcsv_edihist_log('edih_csv_write(): invalid data array');\n\t\treturn false;\n\t}\n\t//\n\tforeach($csv_data as $icn=>$isa) {\n\t\t// should be array[icn] => [file][j][key]  [claim][j][key]  [type]\n\t\t$ft = ( isset($isa['type']) ) ? $isa['type'] : '';\n\t\tif (!$ft) {\n\t\t\tcsv_edihist_log('edih_csv_write(): invalid file type');\n\t\t\tcontinue;\n\t\t}\n\t\t//\n\t\t$param = csv_parameters($ft);\n\t\t$f_hdr = csv_table_header($ft, 'file');\n\t\t$c_hdr = csv_table_header($ft, 'claim');\n\t\tif (is_array($param)) {\n\t\t\t// if either csv files does not exist, create them both\n\t\t\t// all unlisted files in type directory will be processed on next process round\n\t\t\tif (is_file($param['files_csv']) && (filesize($param['files_csv']) > 20)) {\n\t\t\t\tcsv_edihist_log('edih_csv_write: csv check for files csv '.$ft);\n\t\t\t} else {\n\t\t\t\t$nfcsv = $param['files_csv'];\n\t\t\t\t$fh = fopen($nfcsv, 'wb');\n\t\t\t\tif ($fh !== false) {\n\t\t\t\t\tfputcsv($fh, $f_hdr);\n\t\t\t\t\tfclose($fh);\n\t\t\t\t\tchmod($nfcsv, 0600);\n\t\t\t\t}\n\t\t\t\tcsv_edihist_log('edih_csv_write: created files_csv file for '.$ft);\n\t\t\t}\n\t\t\tif (is_file($param['claims_csv']) && filesize($param['claims_csv'])) {\n\t\t\t\tcsv_edihist_log('edih_csv_write: csv check for claims csv '.$ft);\n\t\t\t} else {\n\t\t\t\t$nfcsv = $param['claims_csv'];\n\t\t\t\t$fh = fopen($nfcsv, 'wb');\n\t\t\t\tif ($fh !== false) {\n\t\t\t\t\tfputcsv($fh, $c_hdr);\n\t\t\t\t\tfclose($fh);\n\t\t\t\t\tchmod($nfcsv, 0600);\n\t\t\t\t}\n\t\t\t\tcsv_edihist_log('edih_csv_write: created claims_csv file for '.$ft);\n\t\t\t}\n\t\t} else {\n\t\t\tcsv_edihist_log('edih_csv_write: parameters error for type '.$ft);\n\t\t\treturn false;\n\t\t}\n\t\t//\n\t\tforeach($isa as $key=>$data) {\n\t\t\tif ($key == 'type') { continue; }\n\t\t\t// get the csv file path from parameters\n\t\t\t$fp = ($key == 'file') ? $param['files_csv'] : $param['claims_csv'];\n\t\t\t// get the csv row header\n\t\t\t$order_ar = ($key == 'file') ? $f_hdr : $c_hdr;\n\t\t\t$ct = count($order_ar);\n\t\t\t$chrs = 0;\n\t\t\t$rws = 0;\n\t\t\t//\n\t\t\t$fh = fopen( $fp, 'ab');\n\t\t\tif (is_resource($fh)) {\n\t\t\t\t// to assure proper order of data in each row, the\n\t\t\t\t// csv row is assembled by matching keys to the header row\n\t\t\t\tforeach($data as $ky=>$row) {\n\t\t\t\t\t$csvrow = array();\n\t\t\t\t\tfor ($i=0; $i<$ct; $i++) {\n\t\t\t\t\t\t$csvrow[$i] = $row[$order_ar[$i]];\n\t\t\t\t\t}\n\t\t\t\t\t$chrs += fputcsv ( $fh , $csvrow );\n\t\t\t\t\t$rws++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcsv_edihist_log('edih_csv_write(): failed to open '.$fp);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//\n\t\t\tcsv_edihist_log('edih_csv_write() wrote '.$rws.' rows to '.basename($fp));\n\t\t}\n\t}\n\t//\n\treturn $rws;\n}\n\n\n/**\n * Search a csv record file and return the row or values from selected columns\n *\n * This function requires that the $search_ar parameter be an array\n * with keys ['s_val']['s_col']['r_cols'], and 'r_cols' is an array\n * 's_val' is the search value, s_col is the column to check, r_cols is an array\n * of column numbers from which values are returned.  If r_cols is not an array,\n * then the entire row will be returned.  If the 'expect' parameter is 1, then\n * the search will stop after the first success and return the result. Otherwise, the\n * entire file will be searched.\n * ex: csv_search_record('batch', 'claim', array('s_val'=>'0024', 's_col'=>9, 'r_cols'=>array(1, 2, 7)), \"1\" )\n *\n * @uses csv_parameters()\n * @param string $file_type\n * @param string $csv_type\n * @param array $search_ar\n * @param mixed $expect\n * @return array\n */\nfunction csv_search_record($file_type, $csv_type, $search_ar, $expect='1') {\n\t//\n\tcsv_edihist_log(\"csv_search_record: \".strval($file_type).\" \".strval($csv_type).\" \".strval($search_ar['s_val']));\n\t//\n\t$tp = csv_file_type($file_type);\n\tif (!$tp) {\n\t\tcsv_edihist_log(\"csv_search_record: incorrect type $file_type\");\n\t\treturn false;\n\t}\n\t//\n\t$params = csv_parameters($tp);\n\t//\n\tif ($csv_type == 'claim') {\n        $fp = $params['claims_csv'];\n\t} elseif ($csv_type == 'file') {\n        $fp = $params['files_csv'];\n\t} else {\n\t\tcsv_edihist_log('csv_search_record: incorrect csv type '.$csv_type);\n\t\treturn FALSE;\n\t}\n\t//\n\tif (!is_array($search_ar) || array_keys($search_ar) != array('s_val', 's_col', 'r_cols')) {\n\t\tcsv_edihist_log('csv_search_record: invalid search criteria');\n\t\treturn FALSE;\n\t}\n\t$sv = $search_ar['s_val'];\n\t$sc = $search_ar['s_col'];\n\t$rv = (is_array($search_ar['r_cols']) && count($search_ar['r_cols'])) ? $search_ar['r_cols'] : 'all';\n\t$ret_ar = array();\n\t$idx = 0;\n\tif (($fh1 = fopen($fp, \"r\")) !== false) {\n\t    while (($data = fgetcsv($fh1)) !== false) {\n\t\t\t// check for a match\n\t\t\tif ($data[$sc] == $sv) {\n\t\t\t\tif ($rv == 'all') {\n\t\t\t\t\t$ret_ar[$idx] = $data;\n\t\t\t\t} else {\n\t\t\t\t\t// now loop through the 'r_cols' array for data index\n\t\t\t\t\t$dct = count($data);\n\t\t\t\t\tforeach($rv as $c) {\n\t\t\t\t\t\t// make sure we don't access a non-existing index\n\t\t\t\t\t\tif ($c >= $dct) { continue; }\n\t\t\t\t\t\t//\n\t\t\t\t\t\t$ret_ar[$idx][] = $data[$c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$idx++;\n\t\t\t\tif ($expect == '1') { break; }\n\t\t\t}\n\t\t}\n\t\tfclose($fh1);\n\t} else {\n\t\tcsv_edihist_log('csv_search_record: failed to open '.$fp);\n\t\treturn false;\n\t}\n\tif (empty($ret_ar) ) {\n\t\treturn false;\n\t} else {\n\t\treturn $ret_ar;\n\t}\n}\n\n/**\n * Search the 'claims' csv table for the patient control and find the associated file name\n *\n * Searchtype \n * In 'claims' csv tables, clm01 is position 2, ISA13 number is pos 4, and filename is pos 5;\n * Since we are interested usually in the filename, ISA13 is irrelevant usually.\n *\n * @uses csv_parameters()\n * @uses csv_pid_enctr_parse()\n * @param string                     patient control-- pid-encounter, encounter, or pid\n * @param string                     filetype -- x12 type or f837, f277, etc\n * @param string                     search type encounter, pid, or clm01\n * @return array|bool\t\t\t\t [i] data row array  or empty on error\n */\nfunction csv_file_by_enctr($clm01, $filetype='f837') {\n\t//\n\t// return array of [i](pid_encounter, filename), there may be more than one file\n\t//\n\tif (!$clm01) {\n\t\treturn 'invalid encounter data<br>' . PHP_EOL;\n\t}\n\t//\n\t$ret_ar = array();\n\t$ft = csv_file_type($filetype);\n\t//\n\tif (!$ft) {\n\t\tcsv_edihist_log('csv_file_by_enctr: incorrect file type '.$filetype);\n\t\treturn $ret_ar;\n\t} else {\n\t\t$params = csv_parameters($ft);\n\t\t//$fp = isset($params['claims_csv']) ? dirname(__FILE__).$params['claims_csv'] : false;\n        $fp = isset($params['claims_csv']) ? $params['claims_csv'] : false;\n        $h_ar = csv_table_header($ft, 'claim');\n        $hct = count($h_ar);\n\t\tif (!$fp) {\n\t\t\tcsv_edihist_log('csv_file_by_enctr: incorrect file type '.$filetype);\n\t\t\treturn $ret_ar;\n\t\t}\n\t}\n\t//\n\t$enct = csv_pid_enctr_parse(strval($clm01));\n\t$p = (isset($enct['pid'])) ? $enct['pid'] : '';\n\t$e = (isset($enct['enctr'])) ? $enct['enctr'] : '';\n\tif ($p && $e) {\n\t\t$pe = $p.'-'.$e;\n\t\t$srchtype = '';\n\t} elseif ($e) {\n\t\t$srchtype = 'encounter';\n\t} elseif ($p) {\n\t\t$srchtype = 'pid';\n\t} else {\n\t\tcsv_edihist_log('csv_file_by_enctr: unable to determine encounter value '.$clm01);\n\t\treturn 'unable to determine encounter value '.$clm01.'<br />'.PHP_EOL;\n\t}\n\t// OpenEMR creates CLM01 as nnn-nnn in genX12 batch\n\t//$pm = preg_match('/\\D/', $enctr, $match2, PREG_OFFSET_CAPTURE);\n\t$val = array();\n\t//array_combine ( array $keys , array $values )\n\t// in 'claims' csv tables, clm01 is position 2 and filename is position 5\n\tif (($fh1 = fopen($fp, \"r\")) !== FALSE) {\n\t\tif ($srchtype == 'encounter') {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, \",\")) !== FALSE) {\n\t\t\t\t// check for a match\n\t\t\t\tif (strpos($data[2], $e)) {\n\t\t\t\t\t$te = substr($data[2], strpos($data[2],'-')+1);\n\t\t\t\t\tif (strcmp($te, $e) === 0) {\n\t\t\t\t\t\tfor ($i=0; $i<$hct; $i++) { $val[$h_ar[$i]] = $data[$i]; }\n\t\t\t\t\t\t$ret_ar[] = $val;  // array_combine($h_ar, $data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} elseif ($srchtype == 'pid') {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, ',')) !== FALSE) {\n\t\t\t\tif (strpos($data[2], $p) !== false) {\n\t\t\t\t\t$te = (strpos($data[2], '-')) ? substr($data[2], 0, strpos($data[2],'-')) : '';\n\t\t\t\t\tif (strcmp($te, $p) === 0) {\n\t\t\t\t\t\tfor ($i=0; $i<$hct; $i++) { $val[$h_ar[$i]] = $data[$i]; }\n\t\t\t\t\t\t$ret_ar[] = $val;  // $ret_ar[] = array_combine($h_ar, $data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, \",\")) !== FALSE) {\n\t\t\t\t// check for a match\n\t\t\t\tif ( strcmp($data[2], $pe) === 0 ) {\n\t\t\t\t\tfor ($i=0; $i<$hct; $i++) { $val[$h_ar[$i]] = $data[$i]; }\n\t\t\t\t\t$ret_ar[] = $val;  // $ret_ar[] = array_combine($h_ar, $data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfclose($fh1);\n\t} else {\n\t\tcsv_edihist_log('csv_file_by_enctr: failed to open csv file '.basename($fp));\n\t\treturn false;\n\t}\n\treturn $ret_ar;\n}\n\n   \n/**\n * get the x12 file containing the control_num ISA13\n *\n * @todo the csv for x12 files 999, 277, 835, 837 must have the control number\n *\n * @uses csv_search_record()\n * @param string $control_num   the interchange control number, isa13\n * @return  string              the file name\n */\nfunction csv_file_by_controlnum($type, $control_num) {\n\t// get the batch file containing the control_num\n\t//\n\t$tp = csv_file_type($type);\n\t//\n\t$hdr = csv_table_header($tp, 'file');\n\t$scol = array_search('Control', $hdr);\n\t$rcol = array_search('FileName', $hdr);\n\t//\n\t// $search_ar should have keys ['s_val']['s_col'] array(['r_cols'][])\n\t//    like \"batch', 'claim, array(9, '0024', array(1, 2, 7))\n\t//$csv_hd_ar['batch']['file'] = array('time', 'file_name', 'control_num', 'claims', 'x12_partner', 'x12_version');\n\t//\n\t$fn = '';\n\t$ctln = (strlen($control_num) >= 9) ? substr($control_num, 0, 9) : $control_num;\n\t$search = array('s_val'=>$ctln, 's_col'=>$scol, 'r_cols'=>array($rcol));\n\t$result = csv_search_record($tp, 'file', $search, \"1\");\n\tif (is_array($result) && count($result[0]) == 1) {\n\t\t$fn = $result[0][0];\n\t}\n\treturn $fn;\n}\n\n\n/**\n * Search the csv table to obtain the file name for a given \n * trace value (835 / 997 999 type only)\n * \n * Note: the 997/999 trace is the ISA13 of a batch file\n * \n * \n * @param string\t trace value (TRN02, TA101, or BHT03)\n * @param string     from type (default is f835)\n * @param string\t to type (default is f835)\n * @return string    file name or empty string\n */\nfunction csv_file_by_trace($trace, $from_type='f835', $to_type='f837') {\n\t// get the file referenced by the trace value\n\t//\n\t$ft = ($from_type) ? csv_file_type($from_type) : '';\n\t$tt = ($to_type) ? csv_file_type($to_type) : '';\n\t$fn = '';\n\t$csv_type = '';\n\t$type = '';\n\t$search = array();\n\t//\n\tcsv_edihist_log(\"csv_file_by_trace: $trace from  $ft to $tt\");\n\t//\n\t// $search_ar should have keys ['s_val']['s_col'] array(['r_cols'])\n\t//    like \"f837', 'claim, array(9, '0024', array(1, 2, 7))\n\t//\n\tif ($ft == 'f835') {\n\t\t// trace payment to status or claim\n\t\t$search = array('s_val'=>$trace, 's_col'=>3, 'r_cols'=>'All');\n\t\t$type = $tt;\n\t\t$csv_type = 'file';\n\t} elseif ($ft == 'f997') {\n\t\t// trace ACK to batch file\n\t\t$icn = (is_numeric($trace) && strlen($trace) >= 9) ? substr($trace, 0, 9) : $trace;\n\t\t$search = array('s_val'=>$icn, 's_col'=>2, 'r_cols'=>'All');\n\t\t$type = $tt;\n\t\t$csv_type = 'file';\n\t} elseif ($ft == 'f277') {\n\t\t// trace status to status req or claim\n\t\tif ($tt == 'f276') {\n\t\t\t$search = array('s_val'=>$trace, 's_col'=>7, 'r_cols'=>'All');\n\t\t\t$type = $tt;\n\t\t\t$csv_type = 'claim';\n\t\t} elseif ($tt == 'f837') {\n\t\t\t// expect CLM01 for trace value\n\t\t\t$search = array('s_val'=>$trace, 's_col'=>2, 'r_cols'=>'All');\n\t\t\t$type = $tt;\n\t\t\t$csv_type = 'claim';\n\t\t}\n\t} elseif ($ft == 'f271') {\n\t\t// trace benefit to benefit req\n\t\tif ($tt == 'f270') {\n\t\t\t$search = array('s_val'=>$trace, 's_col'=>2, 'r_cols'=>'All');\n\t\t\t$type = $tt;\n\t\t\t$csv_type = 'claim';\n\t\t}\n\t} elseif ($ft == 'f278') {\n\t\t// trace auth to auth req\n\t\t$search = array('s_val'=>$trace, 's_col'=>2, 'r_cols'=>'All');\n\t\t$type = 'f278';\n\t\t$csv_type = 'claim';\n\t}  else {\n\t\tcsv_edihist_log('csv_file_by_trace: incorrect file type '.$file_type);\n\t\treturn $fn;\n\t}\n\t//\n\tif ($type && $csv_type && $search) {\n\t\t$result = csv_search_record($type, $csv_type, $search, false);\n\t\tif (is_array($result) && count($result)) {\n\t\t\tif ($ft == 'f278') {\n\t\t\t\tforeach($result as $r) {\n\t\t\t\t\tif ($r[6] == 'Rsp' || $r[6] == 'Reply') {\n\t\t\t\t\t\t$fn = $result[0][5];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} elseif ($csv_type == 'claim') {\n\t\t\t\t$fn = $result[0][5];\n\t\t\t} else {\n\t\t\t\t$fn = $result[0][1];\n\t\t\t}\n\t\t} else {\n\t\t\tcsv_edihist_log(\"csv_file_by_trace: search failed $type csv $csv_type for trace $trace $from_type $to_type\");\n\t\t}\n\t} else {\n\t\tcsv_edihist_log(\"csv_file_by_trace: error type $type csv $csv_type for trace $trace $from_type $to_type\");\n\t}\n\treturn $fn;\n}\n\n/**\n * list claim records with Denied or Reject status in  given file\n *\n * @param string\n * @param string\n *\n * @return array\n */\nfunction csv_denied_by_file($filetype, $filename, $trace='') {\n\t//\n\t$ret_ar = array();\n\t$ft = csv_file_type($filetype);\n\tif (strpos('|f997|f271|f277|f835', $ft)) {\n\t\t$param = csv_parameters($ft);\n\t\t$csv_file = $param['claims_csv'];\n\t} else {\n\t\tcsv_edihist_log(\"csv_errors_by_file: incorrect file type $filetype\");\n\t\treturn $ret_ar;\n\t}\n\t//\n\tcsv_edihist_log(\"csv_errors_by_file: $ft searching $filename with trace $trace\");\n\t//\n\tif (($fh1 = fopen($csv_file, \"r\")) !== false) {\n\t\tif ($ft == 'f835') {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, \",\")) !== false) {\n\t\t\t\t// check filename, then status\n\t\t\t\tif ($trace) {\n\t\t\t\t\tif ($data[4] == $trace) {\n\t\t\t\t\t\tif (!in_array($data[3], array('1', '2', '3', '19', '20', '21')) ) { $ret_ar[] = $data; }\n\t\t\t\t\t}\n\t\t\t\t} elseif ($data[5] == $filename) {\n\t\t\t\t\tif (!in_array($data[3], array('1', '2', '3', '19', '20', '21')) ) { $ret_ar[] = $data; }\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t} elseif ($ft == 'f277') {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, \",\")) !== false) {\n\t\t\t\tif ($data[5] == $filename) {\n\t\t\t\t\tif ( !strpos('|A1|A2|A5', substr($data[3], 0, 2))) {\n\t\t\t\t\t\t$ret_ar[] = $data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} elseif (strpos('|f997|f999|f271', $ft)) {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, \",\")) !== false) {\n\t\t\t\tif ($data[5] == $filename) {\n\t\t\t\t\tif ($data[3] !== 'A') {\n\t\t\t\t\t\t$ret_ar[] = $data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcsv_edihist_log(\"csv_errors_by_file: file type did not match $filetype\");\n\t\t}\n\t\tfclose($fh1);\n\t}\n\t//\n\treturn $ret_ar;\n}\n\n\n/**\n* A function to try and assure the pid-encounter is correctly parsed\n*\n* assume a format of pid-encounter, since that is sent in the OpenEMR x12 837\n*\n* @param string $pid_enctr   the value from element CLM01\n* return array               array('pid' => $pid, 'enctr' => $enc)\n*/\nfunction csv_pid_enctr_parse( $pid_enctr ) {\n\t// evaluate the patient account field\n\t//\n\tif (!$pid_enctr || !is_string($pid_enctr) ) {\n\t\tcsv_edihist_log(\"csv_pid_enctr_parse: invalid argument\");\n\t\treturn false;\n\t}\n\t$pval = trim($pid_enctr);\n\tif ( strpos($pval, '-') ) {\n\t\t$pid = substr($pval, 0, strpos($pval, '-'));\n\t\t$enc = substr($pval, strpos($pval, '-')+1);\n\t} elseif ( ctype_digit($pval) ) {\n\t\tif ( preg_match('/(19|20)\\d{2}[01]\\d{1}[0-3]\\d{1}/', $pval) ) {\n\t\t\t$enc = $pval;\n\t\t} else {\n\t\t\t$enc = ( strlen($pval) ) >= ENCOUNTER_MIN_DIGIT_LENGTH ? $pval : '';\n\t\t\t$pid = '';\n\t\t}\n\t} elseif (\tpreg_match('/\\D/', $pval, $match2, PREG_OFFSET_CAPTURE) ) {\n\t\t$inv_split = (count($match2)) ? preg_split('/\\D/', $pval, 2, PREG_SPLIT_NO_EMPTY) : false;\n\t\tif ($inv_split) {\n\t\t\t$pid = $inv_split[0];\n\t\t\t$enc = $inv_split[1];\n\t\t}\n\t} else {\n\t\t$enc = ( strlen($pval) ) >= ENCOUNTER_MIN_DIGIT_LENGTH ? $pval : '';\n\t\t$pid = '';\n\t}\n\treturn array('pid' => $pid, 'enctr' => $enc);\n}\n", "<?php\n/**\n* Function to check and/or sanitize things for security such as\n* directories names, file names, etc.\n*\n* Copyright (C) 2012 by following Brady Miller <brady.g.miller@gmail.com>\n*\n* LICENSE: This program is free software; you can redistribute it and/or\n* modify it under the terms of the GNU General Public License\n* as published by the Free Software Foundation; either version 3\n* of the License, or (at your option) any later version.\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n* You should have received a copy of the GNU General Public License\n* along with this program. If not, see <http://opensource.org/licenses/gpl-license.php>;.\n*\n* @package OpenEMR\n* @author Brady Miller <brady.g.miller@gmail.com>\n* @author Roberto Vasquez <robertogagliotta@gmail.com>\n* @author Shachar Zilbershlag <shaharzi@matrix.co.il>\n* @link http://www.open-emr.org\n*/\n// If the label contains any illegal characters, then the script will die.\nfunction check_file_dir_name($label) {\n  if (empty($label) || preg_match('/[^A-Za-z0-9_.-]/', $label))\n    die(xlt(\"ERROR: The following variable contains invalid characters\").\": \". attr($label));\n}\n\n// Convert all illegal characters to _\nfunction convert_safe_file_dir_name($label) {\n  return preg_replace('/[^A-Za-z0-9_.-]/','_',$label);\n}\n\n//Basename functionality for nonenglish languages (without this, basename function ommits nonenglish characters).\nfunction basename_international($path){\n  $parts = preg_split('~[\\\\\\\\/]~', $path);\n  foreach ($parts as $key => $value){\n    $encoded = urlencode($value);\n    $parts[$key] = $encoded;\n  }\n  $encoded_path = implode(\"/\", $parts);\n  $encoded_file_name = basename($encoded_path);\n  $decoded_file_name = urldecode($encoded_file_name);\n\n  return $decoded_file_name;\n}\n\n\n/**\n * This function detects a MIME type for a file and check if it in the white list of the allowed mime types.\n * @param string $file - file location.\n * @param array|null $whiteList - array of mime types that allowed to upload.\n */\n// Regarding the variable below. In the case of multiple file upload the isWhiteList function will run multiple\n// times, therefore, storing the white list in the variable below to prevent multiple requests from database.\n$white_list = null;\nfunction isWhiteFile($file){\n    global $white_list;\n    if(is_null($white_list)){\n        $white_list = array();\n        $lres = sqlStatement(\"SELECT option_id FROM list_options WHERE list_id = 'files_white_list' AND activity = 1\");\n        while ($lrow = sqlFetchArray($lres)) {\n            $white_list[] = $lrow['option_id'];\n        }\n    }\n\n    $mimetype  = mime_content_type($file);\n    if(in_array($mimetype, $white_list)){\n        return true;\n    } else {\n        $splitMimeType = explode('/', $mimetype);\n        $categoryType = $splitMimeType[0];\n        if(in_array($categoryType. '/*',  $white_list))return true;\n    }\n    return false;\n}\n\n?>\n"], "fixing_code": ["<?php\n/**\n * edih_csv_inc.php\n *\n * Copyright 2012 Kevin McCormick\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 3 or later.  You should have\n * received a copy of the GNU General Public License along with this program;\n * if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n *  <http://opensource.org/licenses/gpl-license.php>\n *\n * @author Kevin McCormick\n * @link: http://www.open-emr.org\n * @package OpenEMR\n * @subpackage ediHistory\n */\n\n/*\n * The purpose of this file is to hold functions of general utility for\n * my edi_claim_history project.  It began as a php \"class\" but I am now\n * thinking that instantiating the class is too much bother and probably\n * a waste of memory, since the contents of the file have to be read into\n * memory anyway.\n *\n * <pre>\n * ******* important *********\n * function csv_parameters($type=\"ALL\")\n *   This function must have the correct values or nothing will work\n * function csv_verify_file( $file_path, $type, $val_array=FALSE )\n *   critical for file verification and x12 parsing\n * function (in ibr_uploads.php) ibr_upload_match_file($param_ar, $fidx, &$html_str)\n *   contains a regular expression that must be correct\n *\n * Also, the constant IBR_HISTORY_DIR must be correct\n * **************************\n * </pre>\n *\n * The claim_history x12 files are claim (837) acknowledgement (997/999) claim status (277) and claim payment (835)\n * Also eligibility request (270) and eligibility response (271)  \n *\n * <pre>\n * Basic workflow:\n *  Each file type has a row in the array from csv_paramaters()\n *     type  directory files_csv  claims_csv  column  regex\n *\n *  1. open submitted file in edih_x12_class to verify and produce properties\n *  2. Read the parameters array and choose the parameters using 'type'\n *  2. Search the matched type 'directory' for the filename files matching the 'regex' regular expressions and\n *     compare the results to the files listed in the 'files_csv' files.csv record -- unmatched files are \"new\"\n *  3. Each \"new\" x12 file should be read by csv_x12_segments -- returns array('path', 'delimiters', 'segments')\n *      ibr, ebr, ack -- basically Availity formats have their own read functions\n *  4. Pass the array to various functions which parse for claims information\n *  5. Write the results to files.csv or claims.csv and create html output for display\n *\n *  6. Other outputs as called for in ibr_history.php -- from user input from claim_history.html\n * </pre>\n *\n *  Key usability issue is the \"new\" files are in the users home directory -- downloaded there\n *   while the OpenEMR is on the server -- so there is a basic issue of access to the files\n *\n *  The ibr_uploads.php script handles uploads of zip archives or multiple file uploads\n *\n * The csv data files are just php written .csv files, so anything different may cause errors\n * You can open and edit them in OpenOffice, but you must save them in \"original format\"\n *\n * TO_DO Some type of \"find in files\" search would be helpful for locating all references to a claim, patient, etc.\n *    [ grep -nHIrF 'findtext']\n *\n * TO_DO functions to zip old files, put them aside, and remove them from csv tables\n */\n\n///**\n// *  a security measure to prevent direct web access to this file\n// */\n// if (!defined('SITE_IN')) die('Direct access not allowed!');\n// $GLOBALS['OE_EDIH_DIR']  $GLOBALS['OE_SITE_DIR']\n\n/* *********** GLOBALS used for testing only **********\n */\n// //$GLOBALS['OE_SITE_DIR'].'/edi/history';\n//$OE_SITES_BASE = $GLOBALS['OE_SITE_DIR'];\n//$OE_SITE_DIR = $OE_SITES_BASE.'/testing';\n//$OE_EDIH_DIR = $OE_SITE_DIR.'/edi/history';\n\n/* ***********\n */\n/**\n * Constant that is checked in included files to prevent direct access.\n * concept taken from Joomla\n */\ndefine('_EDIH', 1);\n//DIRECTORY_SEPARATOR;\nif (!defined('DS')) define('DS', DIRECTORY_SEPARATOR);\n\n/**\n * Log messages to the log file\n *\n * @param string $msg_str  the log message\n * @return int             number of characters written\n */\nfunction csv_edihist_log ( $msg_str ) {\n\t//\n\t//$dir = dirname(__FILE__).DS.'log';\n\t//$dir = $GLOBALS['OE_EDIH_DIR'].DS.'log';\n\t//$logfile = $GLOBALS['OE_EDIH_DIR'] . \"/log/edi_history_log.txt\";\n\t$logfile = 'edih_log_'.date('Y-m-d').'.txt';\n\t$dir = csv_edih_basedir().DS.'log';\n\t$rslt = 0;\n\tif ( is_string($msg_str) && strlen($msg_str) ) {\n\t\t$tm = date('Ymd:Hms') . ' ' . $msg_str . PHP_EOL;\n\t\t//\n\t\t$rslt = file_put_contents($dir.DS.$logfile, $tm, FILE_APPEND);\n\t} else {\n\t\t//\n\t\t$fnctn = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2)[1]['function'];\n\t\tcsv_edihist_log ('invalid message string '.$fnctn);\n\t}\n\t//\n\treturn $rslt;  // number of characters written\n}\n\n/**\n * read the edi_history_log.txt file into an\n * html formatted ordered list\n *\n * @return string\n */\nfunction csv_log_html($logname='') {\n\tcheck_file_dir_name($logname);\n\t$html_str = \"<div class='filetext'>\".PHP_EOL.\"<ol class='logview'>\".PHP_EOL;\n    $fp = csv_edih_basedir().DS.'log'.DS.$logname;\n    if ( is_file($fp) ) {\n\t\t$fh = fopen( $fp, 'r');\n\t\tif ($fh !== FALSE) {\n\t\t\twhile (($buffer = fgets($fh)) !== false) {\n\t\t\t\t$html_str .= \"<li>\".$buffer.\"</li>\".PHP_EOL;\n\t\t\t}\n\t\t\t$html_str .= \"</ol>\".PHP_EOL.\"</div>\".PHP_EOL;\n\t\t\tif (!feof($fh)) {\n\t\t\t\t$html_str .= \"<p>Error in logfile: unexpected file ending</p>\".PHP_EOL;\n\t\t\t}\n\t\t\tfclose($fh);\n\t\t} else {\n\t\t\t$html_str = \"<p>Error: unable to open log file</p>\".PHP_EOL;\n\t\t}\n\t}\n\treturn $html_str;\n}\n\n\n/**\n * list log files and store old logs in an archive\n *\n * @param bool\n * @return array (json)\n */\nfunction csv_log_manage($list=true) {\n\t//\n\t//$dir = dirname(__FILE__).DS.'log';\n\t$dir = csv_edih_basedir().DS.'log';\n\t$list_ar = array();\n\t$old_ar = array();\n\t$lognames = scandir($dir);\n\tif ($list) {\n\t\tforeach($lognames as $log) {\n\t\t\tif (!strpos($log, '_log_')) { continue; }\n\t\t\t$list_ar[] = $log;\n\t\t}\n\t\t$s = (count($list_ar)) ? rsort($list_ar) : false;\n\t\t//\n\t\treturn json_encode($list_ar);\n\t\t//\n\t} else {\n\t\t// list is false, must be archive\n\t\t$datetime1 = date_create(date('Y-m-d'));\n\t\t//\t\t\t\t\n\t\tforeach($lognames as $log) {\n\t\t\tif ($log == '.' || $log == '..') { continue; }\n\t\t\t//\n\t\t\t$pos1 = strrpos($log, '_');\n\t\t\tif ($pos1) {\n\t\t\t\t$ldate = substr($log, $pos1+1, 10);\n\t\t\t\t$datetime2 = date_create($ldate);\n\t\t\t\t$interval = date_diff($datetime1, $datetime2);\n\t\t\t\t//echo '== date difference '.$ldate.' '.$interval->format('%R%a days').PHP_EOL;\n\t\t\t\tif ($interval->format('%R%a') < -7) {\n\t\t\t\t\t// older log files are put in zip archive\n\t\t\t\t\tif ( is_file($dir.DS.$log) ) { $old_ar[] = $log; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//\n\t$ok = false;\n\t$archname = $dir.DS.'edih-log-archive.zip';\n\t$filelimit = 200;\n\t//\n\tif (count($old_ar)) {\n\t\t$zip = new ZipArchive;\n\t\tif (is_file($archname)) {\n\t\t\t$ok = $zip->open($archname, ZipArchive::CHECKCONS);\n\t\t} else {\n\t\t\t$ok = $zip->open($archname, ZipArchive::CREATE);\n\t\t}\n\t\t//\n\t\tif ($ok) {\n\t\t\tif ($zip->numFiles >= $filelimit) {\n\t\t\t\t$zip->close();\n\t\t\t\t$dte = $datetime1->format('Ymd');\n\t\t\t\t$ok = rename($dir.DS.$archname, $dir.DS.$dte.'_'.$archname);\n\t\t\t\tcsv_edihist_log('csv_log_archive: rename full archive '.$dte.'_'.$archname );\n\t\t\t\tif ($ok) {\n\t\t\t\t\t$ok = $zip->open($archname, ZipArchive::CREATE);\n\t\t\t\t\tif (!$ok) {\n\t\t\t\t\t\tcsv_edihist_log('csv_log_archive: cannot create '.$archname);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcsv_edihist_log('csv_log_archive: cannot rename '.$archname);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\tif ($ok) {\n\t\t\t\tforeach($old_ar as $lg) {\n\t\t\t\t\tif (is_file($dir.DS.$lg)) {\n\t\t\t\t\t\t$a = $zip->addFile($dir.DS.$lg, $lg);\n\t\t\t\t\t\tif ($a) {\n\t\t\t\t\t\t\tcsv_edihist_log('csv_log_archive: add to archive '.$lg );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcsv_edihist_log('csv_log_archive: error archiving '.$lg );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$c = $zip->close();\n\t\t\t\tif ($c) {\n\t\t\t\t\tforeach($old_ar as $lg) {\n\t\t\t\t\t\t$u = unlink($dir.DS.$lg);\n\t\t\t\t\t\tif ($u) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcsv_edihist_log('csv_log_archive: error removing '.$dir.DS.$lg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcsv_edihist_log('csv_log_archive: error closing log file archive');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcsv_edihist_log('csv_log_manage: error failed to open '.$archname);\n\t\t\t}\n\t\t}\n\t}\n\t//\n\treturn json_encode($old_ar);\n}\n\n\n/**\n * open or save a user notes file\n *\n * @param string\n * @param bool\n * @return string\n */\nfunction csv_notes_file($content='', $open=true) {\n\t//\n\t$str_html = '';\n    //$fp = $GLOBALS['OE_EDIH_DIR'].'/edi_notes.txt';\n    $fp = csv_edih_basedir().DS.'archive'.DS.'edi_notes.txt';\n\tif (! is_writable($fp) ) {\n\t\t$fh = fopen( $fp, 'a+b');\n\t\tfclose($fh);\n\t}\n\t// for retrieving notes\n\tif ($open) {\n\t\t// if contents were previously deleted by user and file is empty,\n\t\t// the text 'empty' is put in content in save operation\n\t\t$ftxt = file_get_contents($fp);\n\t\tif ($ftxt === false) {\n\t\t\t$str_html .= 'csv_notes_file: file error <br>'.PHP_EOL;\n\t\t\tcsv_edihist_log('csv_notes_file: file error');\n\t\t}\n\t\tif (substr($ftxt, 0, 5) == 'empty' && strlen($ftxt) == 5) {\n\t\t\t$ftxt = '## '. date(\"F j, Y, g:i a\");\n\t\t} elseif (!$ftxt) {\n\t\t\t$ftxt = '## '. date(\"F j, Y, g:i a\");\n\t\t}\n\t\t$str_html .= PHP_EOL.$ftxt.PHP_EOL;\n\t// next stanza for saving content\n\t} elseif (strlen($content)) {\n\t\t//echo \"csv_notes_file: we have content<br>\".PHP_EOL;\n\t\t// use finfo php class\n\t\tif ( class_exists('finfo') ) {\n\t\t\t$finfo = new finfo(FILEINFO_MIME);\n\t\t    $mimeinfo = $finfo->buffer($content);\n\t\t    if ( strncmp($mimeinfo, 'text/plain; charset=us-ascii', 28) !== 0 ) {\n\t\t\t\tcsv_edihist_log('csv_notes_file: invalid mime-type '.$mimeinfo);\n\t\t\t\t$str_html = 'csv_notes_file: invalid mime-type <br>'.$mimeinfo;\n\t\t\t\t//\n\t\t\t\treturn $str_html;\n\t\t\t}\n\t\t} elseif (preg_match('/[^\\x20-\\x7E\\x0A\\x0D]|(<\\?)|(<%)|(<asp)|(<ASP)|(#!)|(\\$\\{)|(<scr)|(<SCR)/', $content, $matches, PREG_OFFSET_CAPTURE)) {\n\t\t\tcsv_edihist_log('csv_notes_file: Filtered character in file content -- character: '.$matches[0][0].' position: '.$matches[0][1]);\n\t\t\t$str_html .= 'Filtered character in file content not accepted <br>'. PHP_EOL;\n\t\t\t$str_html .= ' character: ' . $matches[0][0] . '  position: ' . $matches[0][1] . '<br>' . PHP_EOL;\n\t\t\t//\n\t\t\treturn $str_html;\n\t\t}\n\t} else {\n\t\t$ftxt = ($content) ? $content : 'empty';\n\t\t$saved = file_put_contents($fp, $ftxt);\n\t\t$str_html .= ($saved) ? '<p>Save Error with notes file</p>' : '<p>Notes content saved</p>';\n\t}\n\t//\n\treturn $str_html;\n}\n\n/**\n * generates path to edi history files\n *\n * @return string|bool   directory path\n */\nfunction csv_edih_basedir() {\n    // should be something like /var/www/htdocs/openemr/sites/default\n    if (isset($GLOBALS['OE_SITE_DIR'])) {\n\t\t// debug\n\t\t//echo 'csv_edih_basedir OE_SITE_DIR '.$GLOBALS['OE_SITE_DIR'].'<br>'.PHP_EOL;\n        return $GLOBALS['OE_SITE_DIR'].DS.'edi'.DS.'history';\n    } else {\n        csv_edihist_log('csv_edih_basedir: failed to obtain OpenEMR Site directory');\n        return false;\n    }\n}\n\n/**\n * generates path to edi_history tmp dir for file upload operations\n * \n * @uses csv_edih_basedir()\n * @return string   directory path\n */\nfunction csv_edih_tmpdir() {\n    //\n    $bdir = csv_edih_basedir();\n    $tdir = ($bdir) ? $bdir.DS.'tmp' : false;\n    //$systmp = sys_get_temp_dir();\n    //$systmp = stripcslashes($systmp);\n    //$systdir = $systmp.DS.'edihist';\n    //if ( $tdir && (is_dir($tdir) || mkdir($tdir, 0755) ) ) {\n\tif ( $tdir) {\n\t\treturn $tdir;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n\n\n/**\n * Initial setup function\n *\n * Create the directory tree and write the column headers into the csv files\n * This function will accept a directory argument and it appends the value\n * from IBR_HISTORY_DIR to the path.  Then a directory for each type of file\n * and the csv files are created under that.\n *\n * @uses csv_parameters()\n * @uses csv_table_header()\n * @uses csv_edih_basedir()\n *\n * @param string &$out_str  referenced, should be created in calling function\n * @return boolean\n */\nfunction csv_setup() {\n\t//\n\t$isOK = false;\n\t$out_str = '';\n\t$chr = 0;\n\t// $GLOBALS['OE_SITE_DIR'] should be like /var/www/htdocs/openemr/sites/default\n\t$sitedir = $GLOBALS['OE_SITE_DIR'];\n\t//$sitedir = csv_edih_basedir();\n    //\n    if (is_readable($sitedir)) {\n\t\t$basedir = $sitedir.DS.'edi';\n\t\t$edihist_dir = $basedir.DS.'history';\n        $csv_dir = $edihist_dir.DS.'csv';\n        $archive_dir = $edihist_dir.DS.'archive';\n        $log_dir = $edihist_dir.DS.'log';\n        $tmp_dir = $edihist_dir.DS.'tmp';\n    } else {\n       //csv_edihist_log('setup: failed to obtain OpenEMR Site directory');\n       echo 'setup: failed to obtain OpenEMR Site directory<br>'.PHP_EOL;\n       return false;\n    }\n\t//\n\tif (is_writable($basedir) ) {\n\t\t$isOK = true;\n\t\t//csv_edihist_log('setup: directory '.$basedir);\n\t\t$out_str .= 'EDI_History Setup should not overwrite existing data.<br>'.PHP_EOL;\n\t\t$out_str .= 'Setup: directory '.$basedir.'<br>'.PHP_EOL;\n\t\t//\n\t\tif (is_dir($edihist_dir) || mkdir($edihist_dir, 0755)) {\n\t\t\t$out_str .= 'created folder '.$edihist_dir.'<br>'.PHP_EOL;\n\t\t\t$isOK = true;\n\t\t\tif (is_dir($csv_dir) || mkdir($csv_dir, 0755) ) {\n\t\t\t\t$out_str .= 'created folder '.$csv_dir.'<br>'.PHP_EOL;\n\t\t\t\t$isOK = true;\n\t\t\t} else {\n\t\t\t\t$isOK = false;\n\t\t\t\t$out_str .= 'Setup: Failed to create csv folder... '.'<br>'.PHP_EOL;\n\t\t\t\tdie('Failed to create csv folder... '.$archive_dir);\n\t\t\t}\n\t\t\tif (is_dir($archive_dir) || mkdir($archive_dir, 0755) ) {\n\t\t\t\t$out_str .= 'created folder '.$archive_dir.'<br>'.PHP_EOL;\n\t\t\t\t$isOK = true;\n\t\t\t} else {\n\t\t\t\t$isOK = false;\n\t\t\t\t$out_str .= 'Setup: Failed to create archive folder... '.'<br>'.PHP_EOL;\n\t\t\t\tdie('Failed to create archive folder... ');\n\t\t\t}\n\t\t\tif (is_dir($log_dir) || mkdir($log_dir, 0755) ) {\n\t\t\t\t$out_str .= 'created folder '.$log_dir.'<br>'.PHP_EOL;\n\t\t\t\t$isOK = true;\n\t\t\t} else {\n\t\t\t\t$isOK = false;\n\t\t\t\t$out_str .= 'Setup: Failed to create log folder... '.'<br>'.PHP_EOL;\n\t\t\t\tdie('Failed to create log folder... ');\n\t\t\t}\n\t\t\tif (is_dir($tmp_dir) || mkdir($tmp_dir, 0755) ) {\n\t\t\t\t$out_str .= 'created folder '.$tmp_dir.PHP_EOL;\n\t\t\t\t$isOK = true;\n\t\t\t} else {\n\t\t\t\t$isOK = false;\n\t\t\t\t$out_str .= 'Setup: Failed to create tmp folder... '.'<br>'.PHP_EOL;\n\t\t\t\tdie('Failed to create tmp folder... ');\n\t\t\t}\n\t\t} else {\n\t\t\t$isOK = false;\n\t\t\t$out_str .= 'Setup failed: cannot write to folder '.$basedir.'<br>'.PHP_EOL;\n\t\t\tdie('Setup failed: cannot write to '.$basedir);\n\t\t}\n\t} else {\n\t\t$isOK = false;\n\t\t$out_str .= 'Setup: Failed to create history folder... '.'<br>'.PHP_EOL;\n\t\tdie('Failed to create history folder... '.$edihist_dir);\n\t}\n\tif ($isOK) {\n\t\t$p_ar = csv_parameters('ALL');\n\t\t$old_csv = array('f837'=>'batch', 'f835'=>'era');\n\t\tforeach ($p_ar as $key=>$val) {\n\t\t\t// rename existing csv files to old_filename\n\t\t\tif (is_dir($csv_dir)) {\n\t\t\t\tif ($dh = opendir($csv_dir)) {\n\t\t\t\t\twhile (($file = readdir($dh)) !== false) {\n\t\t\t\t\t\tif (is_file($csv_dir.DS.$file) && strpos($file, 'csv')) {\n\t\t\t\t\t\t\t$rn = rename($csv_dir.DS.$file, $csv_dir.DS.'old_'.$file);\n\t\t\t\t\t\t\tif ($rn) {\n\t\t\t\t\t\t\t\t$out_str .= 'renamed csv/'.$file.' to old_'.$file.'<br />'.PHP_EOL;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$out_str .= 'attempt to rename csv/'.$file.' failed<br />'.PHP_EOL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//;\n\t\t\t// make the edi files storage subdirs\n\t\t\t$tp = $p_ar[$key]['type'];\n\t\t\t$type_dir = $p_ar[$key]['directory'];\n\t\t\t//\n\t\t\tif (is_dir($type_dir)) {\n\t\t\t\t$out_str .= 'folder for '.$tp.' exists '.$type_dir.'<br>'.PHP_EOL;\n\t\t\t} elseif (mkdir($type_dir, 0755)) {\n\t\t\t\tif ($tp == 'f835') {\n\t\t\t\t\t// in upgrade case the f835 directory should not exist\n\t\t\t\t\t// move 'era' files from /era to /f835\n\t\t\t\t\tif (is_dir($edihist_dir.DS.'era')) {\n\t\t\t\t\t\t$fct = 0; $rct = 0;\n\t\t\t\t\t\tif ($dh = opendir($edihist_dir.DS.'era')) {\n\t\t\t\t\t\t\twhile (($file = readdir($dh)) !== false) {\n\t\t\t\t\t\t\t\tif (is_file($edihist_dir.DS.'era'.DS.$file)) {\n\t\t\t\t\t\t\t\t\t$rct++;\n\t\t\t\t\t\t\t\t\t$rn = rename($edihist_dir.DS.'era'.DS.$file, $type_dir.DS.$file);\n\t\t\t\t\t\t\t\t\t$fct = ($rn) ? $fct + 1 : $fct;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$out_str .= 'created type folder '.$type_dir.' and moved '.$fct.' of '.$rct.' files from /era<br>'.PHP_EOL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$out_str .= 'created type folder '.$type_dir.'<br>'.PHP_EOL;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t$out_str .= 'Setup failed to create directory for '.$tp.'<br>'.PHP_EOL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t$out_str .= 'Setup failed: Can not create directories <br>'.PHP_EOL;\n\t}\n \n\tif ($isOK) {\n\t\tcsv_edihist_log($out_str);\n\t\treturn true;\n\t} else {\n\t\treturn $out_str;\n\t}\n}\n\n\n/**\n * Empty all contents of tmp dir /edi/history/tmp\n *\n * @uses csv_edih_tmpdir()\n * @param  none\n * @return bool\n */\nfunction csv_clear_tmpdir() {\n\t//\n    $tmpdir = csv_edih_tmpdir();\n    if ( basename($tmpdir) != 'tmp' ) {\n\t\tcsv_edihist_log ( 'tmp dir not /edi/history/tmp');\n\t\treturn false;\n\t}\n\t$tmp_files = scandir($tmpdir);\n\tif (count($tmp_files) > 2) {\n\t\tforeach($tmp_files as $idx=>$tmpf) {\n\t\t\tif ($tmpf == \".\" || $tmpf == \"..\") {\n\t\t\t\t// can't delete . and ..\n\t\t\t\tcontinue;\n\t\t\t} elseif (is_file($tmpdir.DS.$tmpf) ) {\n\t\t\t\tunlink($tmpdir.DS.$tmpf);\n\t\t\t} elseif(is_dir($tmpdir.DS.$tmpf)) {\n\t\t\t\t$tdir_ar = scandir($tmpdir.DS.$tmpf);\n\t\t\t\tforeach($tdir_ar as $tfn) {\n\t\t\t\t\tif ($tfn == \".\" || $tfn == \"..\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} elseif (is_file($tmpdir.DS.$tmpf.DS.$tfn)) {\n\t\t\t\t\t\tunlink($tmpdir.DS.$tmpf.DS.$tfn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trmdir($tmpdir.DS.$tmpf);\n\t\t\t}\n\t\t}\n\t}\n\t$tmp_files = scandir($tmpdir);\n\tif (count($tmp_files) > 2) {\n\t\tcsv_edihist_log ('tmp dir contents remain in ... /edi/history/tmp');\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\n/**\n * open and verify a default edih_x12_file object\n * \n * @uses csv_check_filepath()\n * \n * @param string   filepath or filename\n * @parm string    file x12 type\n * @return object  edih_x12_file class \n */\nfunction csv_check_x12_obj($filepath, $type='') {\n\t//\t\n\t$x12obj = false;\n\t$ok = false;\n\t//\n\t$fp = csv_check_filepath($filepath, $type);\n\t//\n\tif ($fp) {\n\t\t$x12obj = new edih_x12_file($fp);\n\t\tif ( 'edih_x12_file' == get_class($x12obj) ) {\n\t\t\tif ($x12obj->edih_valid() == 'ovigs') {\n\t\t\t\t$ok = count( $x12obj->edih_segments() );\n\t\t\t\t$ok = ($ok) ?  count( $x12obj->edih_envelopes() ) : false;\n\t\t\t\t$ok = ($ok) ?  count( $x12obj->edih_delimiters() ) : false;\n\t\t\t\tif (!$ok) {\n\t\t\t\t\tcsv_edihist_log(\"csv_check_x12_obj: object missing properties [$filepath]\");\n\t\t\t\t\tcsv_edihist_log( $x12obj->edih_message() );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcsv_edihist_log(\"csv_check_x12_obj: invalid object $filepath\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tcsv_edihist_log(\"csv_check_x12_obj: object not edih_x12_file $filepath\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tcsv_edihist_log(\"csv_check_x12_obj: invalid file path $filepath\");\n\t\treturn false;\n\t}\n\t//\n\treturn $x12obj;\n}\n\n/**\n * Check that the file path we are working with is a readable file.\n *\n * If it is a file we have uploaded and we have only the file name\n * this function will type the file and find it in the uploaded files directories\n * and return the complete path.\n *\n * @uses csv_parameters()\n * @param string $filename    name of a file that is one of our types\n * @param string $type        optional; one of our file types\n * @return string             either an empty string or a readable filepath\n */\nfunction csv_check_filepath($filename, $type='ALL') {\n\t//\n\t// if file is readable, just return it\n\tif ( is_file($filename) && is_readable($filename) ) {\n\t\treturn $filename;\n\t}\n\t//\n\t$goodpath = '';\n\t$fp = '';\n\t$fn = basename($filename);\n\t//\n\tif ($type && $type != 'ALL') {\n\t\t$p = csv_parameters($type);\n\t\tif (is_array($p) && array_key_exists('type', $p) ) {\n            $fp = $p['directory'].DS.$fn;\n\t\t}\n\t} else {\n\t\t$p_ar = csv_parameters(\"ALL\");\n\t\tforeach ($p_ar as $tp=>$par) {\n\t\t\tif ( !$p_ar[$tp]['regex'] || !preg_match($p_ar[$tp]['regex'], $fn) ) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n                $fp = $p_ar[$tp]['directory'].DS.$fn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif ( is_file($fp) && is_readable($fp) ) { $goodpath = realpath($fp); }\n\t//\n\treturn $goodpath;\n}\n\n/**\n * verify file type parameter\n *\n * @param string    file type\n * @param bool      return GS02 code or fXXX\n * @return string   file type or empty \n */\nfunction csv_file_type($type, $gs_code=false) {\n\t//\n\tif (!$type) {\n\t\tcsv_edihist_log('csv_file_type: invalid or missing type argument '.$type);\n\t\treturn false;\n\t} else {\n\t\t$tp_type = (string)$type;\n\t}\n\t//\n\tif ( strpos('|f837|batch|HC', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HC' : 'f837';\n\t} elseif ( strpos('|f835|era|HP', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HP' : 'f835';\n\t} elseif ( strpos('|f999|f997|ack|ta1|FA', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'FA' : 'f997';\n\t} elseif ( strpos('|f277|HN', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HN' : 'f277';\n\t} elseif ( strpos('|f276|HR', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HR' : 'f276';\n\t} elseif ( strpos('|f271|HB', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HB' : 'f271';\n\t} elseif ( strpos('|f270|HS', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HS' : 'f270';\n\t} elseif ( strpos('|f278|HI', $tp_type) ) {\n\t\t$tp = ($gs_code) ? 'HI' : 'f278';\n\t} else {\n\t\t$tp = '';\n\t}\n\t//\n\tif ( !$tp) {\n\t\tcsv_edihist_log('csv_file_type error: incorrect type '.$tp_type);\n\t}\n\treturn $tp;\n}\n\n\n/**\n * The array that holds the various parameters used in dealing with files\n *\n * A key function since it holds the paths, columns, etc.  \n * Unfortunately, there is an issue with matching the type in  * the case of the \n * values '997', '277', '999', etc, becasue these strings may be recast\n * from strings to integers, so the 'type' originally supplied is lost.\n * This introduces an inconsistency when the 'type' is used in comparison tests.\n * We call the csv_file_type() function to return a usable file type identifier.\n * The 'datecolumn' and 'fncolumn' entries are used in csv_to_html() to filter by date\n * or place links to files.\n *\n * @param string $type -- default = ALL or one of batch, ibr, ebr, dpr, f997, f277, era, ack, text\n * @return array\n */\nfunction csv_parameters($type='ALL') {\n\t//\n\t// This will need the OpenEMR 'oe_site_dir' to replace global\n\t//\n\t$p_ar = array();\n\n    $tp = ($type === 'ALL') ? $type : csv_file_type($type);\n\tif (!$tp) {\n\t\tcsv_edihist_log('csv_parameters() error: incorrect type '.$type);\n\t\treturn $p_ar;\n\t}\n\t//$edihist_dir = $GLOBALS['OE_SITE_DIR'].'/edi/history';\n\t$edihist_dir = csv_edih_basedir();\n\t//\n\t// the batch file directory is a special case - decide whether to use OpenEMR batch files or make our own copies\n\t// OpenEMR copies each batch file to sites/default/edi and this project never writes to that directory\n\t// batch reg ex -- '/20[01][0-9]-[01][0-9]-[0-3][0-9]-[0-9]{4}-batch*\\.txt/' '/\\d{4}-\\d{2}-\\d{2}-batch*\\.txt$/'\n\t//\n    $p_ar['f837'] = array('type'=>'f837', 'directory'=>$GLOBALS['OE_SITE_DIR'].DS.'edi', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f837.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f837.csv', 'filedate'=>'Date', 'claimdate'=>'SvcDate', 'regex'=>'/\\-batch(.*)\\.txt$/');\n\t//\n\t//$p_ar['csv'] = array(\"type\"=>'csv', \"directory\"=>$edihist_dir.'/csv', \"claims_csv\"=>'ibr_parameters.csv',\n\t//\t\t\t\t\t\"files_csv\"=>'', \"column\"=>'', \"regex\"=>'/\\.csv$/');\n\t$p_ar['f997'] = array('type'=>'f997', 'directory'=>$edihist_dir.DS.'f997', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f997.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f997.csv', 'filedate'=>'Date', 'claimdate'=>'RspDate', 'regex'=>'/\\.(99[79]|ta1|ack)$/i');\n\t$p_ar['f276'] = array('type'=>'f276', 'directory'=>$edihist_dir.DS.'f276', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f276.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f276.csv', 'filedate'=>'Date', 'claimdate'=>'ReqDate', 'regex'=>'/\\.276([ei]br)?$/');\n\t$p_ar['f277'] = array('type'=>'f277', 'directory'=>$edihist_dir.DS.'f277', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f277.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f277.csv', 'filedate'=>'Date', 'claimdate'=>'SvcDate', 'regex'=>'/\\.277([ei]br)?$/i');\n\t$p_ar['f270'] = array('type'=>'f270', 'directory'=>$edihist_dir.DS.'f270', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f270.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f270.csv', 'filedate'=>'Date', 'claimdate'=>'ReqDate', 'regex'=>'/\\.270([ei]br)?$/i');\n\t$p_ar['f271'] = array('type'=>'f271', 'directory'=>$edihist_dir.DS.'f271', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f271.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f271.csv', 'filedate'=>'Date', 'claimdate'=>'RspDate', 'regex'=>'/\\.271([ei]br)?$/i');\n\t$p_ar['f278'] = array('type'=>'f278', 'directory'=>$edihist_dir.DS.'f278', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f278.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f278.csv', 'filedate'=>'Date', 'claimdate'=>'FileDate', 'regex'=>'/\\.278/');\n\t// OpenEMR stores era files, but the naming scheme is confusing, so we will just use our own directory for them\n\t$p_ar['f835'] = array('type'=>'f835', 'directory'=>$edihist_dir.DS.'f835', 'claims_csv'=>$edihist_dir.DS.'csv'.DS.'claims_f835.csv',\n\t\t\t\t\t\t'files_csv'=>$edihist_dir.DS.'csv'.DS.'files_f835.csv', 'filedate'=>'Date', 'claimdate'=>'SvcDate', 'regex'=>'/835[0-9]{5}\\.835*|\\.(era|ERA|835)$/i');\n\t//\n\tif ( array_key_exists($tp, $p_ar) ) {\n\t\treturn $p_ar[$tp];\n\t} else {\n\t\treturn $p_ar;\n\t}\n}\n\n/**\n * determine if a csv table has data for select dropdown\n *\n * @param string   default 'json'\n * @return array   json if argument is 'json'\n */\nfunction csv_table_select_list($outtp='json') {\n\t$optlist = array();\n\t$labels = array('f835'=>'Payments', 'f837'=>'Claims', 'batch'=>'Claims', 'f277'=>'Status', 'f276'=>'Status Req',\n\t                'f997'=>'Ack','f271'=>'Benefit', 'f270'=>'Benefit Req', 'f278'=>'Auth');\n\n    $edihist_dir = csv_edih_basedir();  // $GLOBALS['OE_SITE_DIR'].'/edi/history'\n    $csvdir = $edihist_dir.DS.'csv';\n\t$tbllist = scandir($csvdir);\n\t$idx = 0;\n\tforeach($tbllist as $csvf) {\n\t\tif ($csvf == \".\" || $csvf == \"..\" ) { continue; }\n\t\tif (strpos($csvf, 'old') === 0) { continue; }\n\t\tif (filesize($csvdir.DS.$csvf) < 70) { continue; }\n\t\tif (substr($csvf, -1) == '~') { continue; }\n\t\t$finfo = pathinfo($csvdir.DS.$csvf);\n\t\t$fn = $finfo['filename'];\n\t\t// e.g. files_f997\n\t\t$tp = explode('_', $fn);\n\t\t//$lblkey = $labels[$tp[1]];\n\t\t$optlist[$tp[0]][$tp[1]]['fname'] = $fn;\n\t\t$optlist[$tp[0]][$tp[1]]['desc'] = $tp[0].'-'.$labels[$tp[1]]; //$tp[1] .' '.$tp[0];\n\t\t$idx++;\n\t}\n\tif ($outtp == 'json') {\n\t\treturn json_encode($optlist);\n\t} else {\n\t\treturn $optlist;\n\t}\n}\n\n/**\n * list existing archive files\n *\n * @param string   default 'json'\n * @return array   json if argument is 'json'\n */\nfunction csv_archive_select_list($outtp='json') {\n\t//\n\t$flist = array();\n\t$archdir = csv_edih_basedir().DS.'archive';\n\t//\n\t// debug\n\tcsv_edihist_log(\"csv_archive_select_list: using $archdir\");\n\t//\n\t$scan = scandir($archdir);\n\tif (is_array($scan) && count($scan)) {\n\t\tforeach($scan as $s) {\n\t\t\tif ($s == '.' || $s == '..') {\n\t\t\t\tcontinue;\n\t\t\t} elseif (strpos($s, 'note')) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t$flist[] = $s;\n\t\t\t}\n\t\t}\n\t}\n\tif ($outtp == 'json') {\n\t\treturn json_encode($flist);\n\t} else {\n\t\treturn $flist;\n\t}\n}\n\n/**\n * List files in the directory for the given type\n *\n * Write an entry in the log if an file is in the directory\n * that does not match the type\n *\n * @uses csv_parameters()\n * @param string $type    a type from our list\n * @return array\n */\nfunction csv_dirfile_list($type) {\n\t// return false if location is not appropriate\n\t$tp = csv_file_type($type);\n\tif (!$tp) {\n\t\tcsv_edihist_log(\"csv_dirfile_list error: incorrect type $type\");\n\t\treturn false;\n\t}\n\t$params = csv_parameters($tp);\n\tif (empty($params) || csv_singlerecord_test($params) == false ) {\n\t\tcsv_edihist_log(\"csv_dirfile_list() error: incorrect type $type\");\n\t\treturn false;\n\t}\n    $search_dir = $params['directory'];\n\t$ext_re = $params['regex'];\n\t$dirfiles = array();\n\t// \n\tif (is_dir($search_dir)) {\n\t    if ($dh = opendir($search_dir)) {\n\t        while (($file = readdir($dh)) !== false) {\n\t\t\t\tif ($file == '.' || $file == '..') {\n\t\t\t\t\tcontinue;\n\t\t\t\t} elseif ($tp == 'f837' && ($file == 'history' || $file == 'README.txt')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} elseif (is_file($search_dir.DS.$file) ) {\n\t\t\t\t\t$dirfiles[] = $file;\n\t\t\t\t} else {\n\t\t\t\t\tif ($tp == 'f837' && $file == 'history') { continue; }\n\t\t\t\t\tcsv_edihist_log(\"csv_dirfile_list $type : not a file $file\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcsv_edihist_log(\"csv_dirfile_list $type : error in scan $search_dir\");\n\t\t}\n\t} else {\n\t\tcsv_edihist_log(\"csv_dirfile_list $type : not a directory $search_dir\");\n\t}\n\t//\n\treturn $dirfiles;\n} // end function\n\n\n/**\n * List files that are in the csv record\n *\n * @uses csv_parameters()\n * @uses csv_table_header()\n * \n * @param string $type -- one of our types\n * @return array\n */\nfunction csv_processed_files_list($type) {\n\t//\n\t$tp = csv_file_type($type);\n\tif (!$tp) {\n\t\tcsv_edihist_log(\"csv_processed_files_list: incorrect type $type\");\n\t\treturn false;\n\t}\n\t$processed_files = array();\n\t$param = csv_parameters($tp);\n\t$hdr_ar = csv_table_header($tp, 'file');\n\tif ( is_array($hdr_ar) ) {\n\t\tforeach($hdr_ar as $k=>$hd) {\n\t\t\tif ($hd == 'FileName') { $csv_col = $k; break; }\n\t\t}\n\t}\n\t$csv_col = (isset($csv_col)) ? $csv_col : 1;\n\t$csv_file = $param['files_csv'];\n\t//if ($tp == 'dpr') {\n        //$csv_file = $param['claims_csv'];\n\t\t//$csv_col = '5';\n\t//} else {\n        //$csv_file = $param['files_csv'];\n\t//}\n\t//\n\t//$idx = 0;\n\tif (is_file($csv_file)) {\n\t\tif (($fh1 = fopen( $csv_file, \"r\" )) !== FALSE) {\n\t\t    while (($data = fgetcsv($fh1, 1024, \",\")) !== FALSE) {\n\t\t\t\t$processed_files[] = $data[$csv_col];\n\t\t\t\t//\n\t\t        //if ($idx) { $processed_files[] = $data[$csv_col]; }\n\t\t        // skip the header row\n\t\t        //$idx++;\n\t\t\t}\n\t\t\tfclose($fh1);\n\t\t} else {\n\t\t\tcsv_edihist_log (\"csv_list_processed_files: failed to access $csv_file\" );\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// first run - no file exists\n\t\tcsv_edihist_log(\"csv_processed_files_list: csv file does not exist \".basename($csv_file));\n\t}\n\t// remove the header row, but avoid NULL or false\n\t$ret_ar = (empty($processed_files)) ? $processed_files : array_slice($processed_files, 1);\n\treturn $ret_ar;\n} // end function\n\n\n/**\n * Give an array of files in the storage directories that are not in the csv record\n *\n * @param string $type -- one of our types\n * @return array\n */\nfunction csv_newfile_list($type) {\n\t//\n\t$ar_new = array();\n\t$tp = csv_file_type($type);\n\tif (!$tp) {\n\t\tcsv_edihist_log('csv_newfile_list: incorrect type '.$type);\n\t\treturn false;\n\t}\n\t//\n\t$dir_files = csv_dirfile_list($tp);\n\t$csv_files = csv_processed_files_list($tp);\n\t//\n\t// $dir_files should come first in array_diff()\n\tif (empty($dir_files)) {\n\t\t$ar_new = array();\n\t} elseif (empty($csv_files) || is_null($csv_files)) {\n\t\t$ar_new = $dir_files;\n\t} else {\n\t\t$ar_new = array_diff($dir_files, $csv_files);\n\t}\n\t//\n\treturn $ar_new;\n}\n\n/**\n * Parse 997 IK3 error segment to identify segment causing rejection\n * The error segment string is specially created in edih_997_csv_data()\n * Simple analysis, but the idea is just to identify the bad segment\n * \n * @param string\t\t\terror segment from edih_997_csv_data()\n * @param bool\t\t\t\ttrue if only the 1st segmentID is wanted\n * return array|string\n */\nfunction edih_errseg_parse($err_seg, $id=false) {\n\t// ['err_seg'] = '|IK3*segID*segpos*loop*errcode*bht03syn|CTX-IK3*transID*segID*segpos*elempos\n\t//                |IK4*elempos*errcode*elem*|CTX-IK4*segID*segpos*elempos\n\t//\n\t// note: multiple IK3 segments are allowed in 997/999 x12\n\t//\n\t$ret_ar = array();\n\tif ( !$err_seg || strpos($err_seg, 'IK3') === false) {\n\t\tcsv_edihist_log('edih_errseg_parse: invalid argument');\n\t\treturn $ret_ar;\n\t}\n\t//'|IK3*segID*segpos*loop*errcode*bht03syn|CTX-IK3*segID*segPos*loopLS*elemPos:compositePos:repPos\n\t// revised: 123456789004*IK3*segID*segpos[*segID*segpos*segID*segpos]\n\t$ik = explode('*', $err_seg);\n\tforeach($ik as $i=>$k) {\n\t\tswitch((int)$i) {\n\t\t\tcase 0:$ret_ar['trace'] = $k; break;\n\t\t\tcase 1: break;  // IK3\n\t\t\tcase 2: $ret_ar['id'][] = $k; break;   // segment ID\n\t\t\tcase 3: $ret_ar['err'][] = $k; break;  // segment position\n\t\t\tcase 4: $ret_ar['id'][] = $k; break;\n\t\t\tcase 5: $ret_ar['err'][] = $k; break;\n\t\t\tcase 6: $ret_ar['id'][] = $k; break;\n\t\t\tcase 7: $ret_ar['err'][] = $k; break;\n\t\t}\n\t}\n\t//\n\treturn $ret_ar;\n}\n\n/**\n * Order the csv data array according to the csv table heading row\n * so the data to be added to csv table rows are correctly ordered\n *  the supplied data should be in an array with thie structure\n *  array['icn'] ['file'][i]['key']  ['claim'][i]['key']  ['type']['type']\n *\n * @uses csv_table_header()\n * \n * @param array   data_ar    data array from edih_XXX_csv_data()\n * @return array|bool        ordered array or false on error\n */\nfunction edih_csv_order($csvdata) {\n\t//\n\t$wrcsv = array();\n\t$order_ar = array();\n\t//\n\tforeach($csvdata as $icn=>$data) {\n\t\t// [icn]['type']['file']['claim']\n\t\t$ft = $data['type'];\n\t\t$wrcsv[$icn]['type'] = $ft;\n\t\t//\n\t\tforeach($data as $key=>$val) {\n\t\t\tif ($key == 'type') { continue; }\n\t\t\t$order_ar[$icn][$key] = csv_table_header($ft, $key);\n\t\t\t$ct = count($order_ar[$icn][$key]);\n\t\t\tforeach($val as $k=>$rcrd) {\n\t\t\t\t//\n\t\t\t\tforeach($order_ar[$icn][$key] as $ky=>$vl) {\n\t\t\t\t\t$wrcsv[$icn][$key][$k][$ky] = $rcrd[$vl];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn $wrcsv;\n}\n\n/**\n * insert dashes in ten-digit telephone numbers\n * \n * @param string $str_val   the telephone number\n * @return string           the telephone number with dashes\n */\nfunction edih_format_telephone ($str_val) {\n\t$strtel = (string)$str_val;\n\t$strtel = preg_replace('/\\D/', '', $strtel);\n\tif ( strlen($strtel) != 10 ) {\n\t\tcsv_edihist_log('edih_format_telephone: invalid argument: '.$str_val);\n\t\treturn $str_val;\n\t} else {\n\t\t$tel = substr($strtel,0,3) . \"-\" . substr($strtel,3,3) . \"-\" . substr($strtel,6);\n\t}\n\treturn $tel;\n}\n\n/**\n * order MM DD YYYY values and insert slashes in eight-digit dates\n * \n * US MM/DD/YYYY or general YYYY-MM-DD \n *  \n * @param string $str_val   the eight-digit date\n * @param string $pref      if 'US' (default) anything else means YYYY-MM-DD\n * @return string           the date with slashes\n */\nfunction edih_format_date ($str_val, $pref = \"Y-m-d\") {\n\t$strdt = (string)$str_val;\n\t$strdt = preg_replace('/\\D/', '', $strdt);\n\t$dt = '';\n\tif (strlen($strdt) == 6) {\n\t\t$tdy = date('Ymd');\n\t\tif ($pref == \"US\") {\n\t\t\t// assume mmddyy\n\t\t\t$strdt = substr($tdy,0,2).substr($strdt,-2).substr($strdt,0,4);\n\t\t} else {\n\t\t\t// assume yymmdd\n\t\t\t$strdt = substr($tdy,0,2).$strdt;\n\t\t}\n\t}\n\tif ($pref == \"US\") {\n\t\t$dt = substr($strdt,4,2) . \"/\" . substr($strdt,6) . \"/\" . substr($strdt,0,4);\n\t} else {\n\t\t$dt = substr($strdt,0,4) . \"-\" . substr($strdt,4,2) . \"-\" . substr($strdt,6);\n\t}\n\treturn $dt;\n}\n\n/**\n * format monetary amounts with two digits after the decimal place\n * \n * @todo                    add other formats\n * @param string $str_val   the amount string\n * @return string           the telephone number with dashes\n */\nfunction edih_format_money ($str_val) {\n\t//  \n\tif ($str_val || $str_val === '0') {\n\t\t$mny = sprintf(\"$%01.2f\", $str_val);\n\t} else {\n\t\t$mny = $str_val;\n\t}\n\treturn $mny;\n}\n\n/**\n * format percentage amounts with % sign\n * typical example \".50\" from x12 edi segment element\n * \n * @param string $str_val   the amount string \n * @return string           the value as a percentage\n */\nfunction edih_format_percent ($str_val) {\n\t$val = (float)$str_val;\n\tif (is_float($val)) {\n\t\t$pct = $val*100 . '%';\n\t} else {\n\t\t$pct = $str_val.'%';\n\t}\n\treturn $pct;\n}\n\n/**\n * HTML string for table thead element\n * \n * @uses csv_table_header()\n * @param string\n * @param string\n * @return string\n */\nfunction csv_thead_html($file_type, $csv_type, $tblhd=null) {\n\t//\n\tif (is_array($tblhd) & count($tblhd) ) {\n\t\t$hvals = $tblhd;\n\t} else {\n\t\t$hvals = csv_table_header($file_type, $csv_type);\n\t}\n\tif ( is_array($hvals) && count($hvals) ) {\n\t\t$str_html = '';\n\t} else {\n\t\treturn false;\n\t}\n\t$str_html .= \"<thead>\".PHP_EOL.\"<tr>\".PHP_EOL;\n\tforeach($hvals as $val) {\n\t\t$str_html .=\"<th>$val</th>\";\n\t}\n\t$str_html .= PHP_EOL.\"</tr>\".PHP_EOL.\"</thead>\".PHP_EOL;\n\t//\n\treturn $str_html;\n}\n\n\n/**\n * Give the column headings for the csv files\n * \n * @uses csv_file_type()\n * @param string $file_type  \tone of our edi types\n * @param string $csv_type \t\teither 'file' or 'claim'\n * @return array\n */\nfunction csv_table_header($file_type, $csv_type) {\n\t//\n\t$ft = csv_file_type($file_type);\n\t$ct = strpos('|file', $csv_type) ? 'file' : $csv_type;\n\t$ct = strpos('|claim', $ct) ? 'claim' : $ct;\n\t//\n\t$hdr = array();\n\tif (!$ft || !$ct ) {\n\t\tcsv_edihist_log ('csv_table_header error: incorrect file ['.$file_type.']or csv ['.$csv_type.'] type');\n\t\treturn $hdr;\n\t}\n\t//\n\tif ($ct === 'file') {\n\t\tswitch((string)$ft) {\n\t\t\t//case 'ack': $hdr = array('Date', 'FileName', 'isa13', 'ta1ctrl', 'Code'); break;\n\t\t\t//case 'ebr': $hdr = array('Date', 'FileName', 'clrhsid', 'claim_ct', 'reject_ct', 'Batch'); break;\n\t\t\t//case 'ibr': $hdr = array('Date', 'FileName', 'clrhsid', 'claim_ct', 'reject_ct', 'Batch'); break;\n\t\t\t//\n\t\t\tcase 'f837': $hdr = array('Date', 'FileName', 'Control', 'Claim_ct', 'x12Partner'); break;\n\t\t\tcase 'ta1': $hdr = array('Date', 'FileName', 'Control', 'Trace', 'Code'); break;\n\t\t\tcase 'f997': $hdr = array('Date', 'FileName', 'Control', 'Trace', 'RspType', 'RejCt'); break;\n\t\t\tcase 'f276': $hdr = array('Date', 'FileName', 'Control', 'Claim_ct', 'x12Partner'); break;\n\t\t\tcase 'f277': $hdr = array('Date', 'FileName', 'Control', 'Accept', 'AccAmt', 'Reject', 'RejAmt'); break;\n\t\t\tcase 'f270': $hdr = array('Date', 'FileName', 'Control', 'Claim_ct', 'x12Partner'); break;\n\t\t\tcase 'f271': $hdr = array('Date', 'FileName', 'Control', 'Claim_ct', 'Reject', 'Payer'); break;\n\t\t\tcase 'f278': $hdr = array('Date', 'FileName', 'Control', 'TrnCount', 'Auth', 'Payer'); break;\n\t\t\tcase 'f835': $hdr = array('Date', 'FileName', 'Control', 'Trace', 'Claim_ct', 'Denied', 'Payer'); break;\n\t\t}\n\t} elseif ($ct === 'claim') {\n\t\tswitch((string)$ft) {\n\t\t\t//case 'ebr': $hdr = array('PtName','SvcDate', 'CLM01', 'Status', 'Batch', 'FileName', 'Payer'); break;\n\t\t\t//case 'ibr': $hdr = array('PtName','SvcDate', 'CLM01', 'Status', 'Batch', 'FileName', 'Payer'); break;\n\t\t\t//case 'dpr': $hdr = array('PtName','SvcDate', 'CLM01', 'Status', 'Batch', 'FileName', 'Payer'); break;\n\t\t\t//\n\t\t\tcase 'f837': $hdr = array('PtName', 'SvcDate', 'CLM01', 'InsLevel', 'BHT03', 'FileName', 'Fee', 'PtPaid', 'Provider' ); break;\n\t\t\tcase 'f997': $hdr = array('PtName', 'RspDate', 'Trace', 'Status', 'Control', 'FileName', 'RspType', 'err_seg'); break;\n\t\t\tcase 'f276': $hdr = array('PtName', 'SvcDate', 'CLM01', 'ClaimID', 'BHT03', 'FileName', 'Payer', 'Trace'); break;\n\t\t\tcase 'f277': $hdr = array('PtName', 'SvcDate', 'CLM01', 'Status', 'BHT03', 'FileName', 'Payer', 'Trace'); break;\n\t\t\tcase 'f270': $hdr = array('PtName', 'ReqDate', 'Trace', 'InsBnft', 'BHT03', 'FileName', 'Payer'); break;\n\t\t\tcase 'f271': $hdr = array('PtName', 'RspDate', 'Trace', 'Status', 'BHT03', 'FileName', 'Payer'); break;\n\t\t\tcase 'f278': $hdr = array('PtName', 'FileDate', 'Trace', 'Status', 'BHT03', 'FileName', 'Auth', 'Payer'); break;\n\t\t\tcase 'f835': $hdr = array('PtName', 'SvcDate', 'CLM01', 'Status', 'Trace', 'FileName', 'ClaimID', 'Pmt', 'PtResp', 'Payer'); break;\n\t\t}\n\t} else {\n\t\t// unexpected error  \n\t\tcsv_edihist_log ('edih_csv_table_header() error: failed to match file type ['.$ft.'] or csv type ['.$ct.']');\n\t\treturn false;\n\t}\n\tif (count($hdr) ) {\n\t\treturn $hdr;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/*\nfunction csv_files_header($file_type, $csv_type) {\n\t//\n\t$tp = csv_file_type($type);\n\tif (!$tp) {\n\t\tcsv_edihist_log('csv_files_header: incorrect type '.$file_type);\n\t\treturn false;\n\t}\n\tif (!strpos('|file|claim', $csv_type) ) {\n\t\tcsv_edihist_log('csv_files_header error: incorrect csv type '.$csv_type);\n\t\treturn false;\n\t}\n\t//\n\t$ft = strpos('|277', $file_type) ? 'f277' : $file_type;\n\t$ft = strpos('|835', $file_type) ? 'era' : $ft;\n\t$ft = strpos('|837', $file_type) ? 'batch' : $ft;\n\t$ft = strpos('|999|997|ack|ta1', $file_type) ? 'f997' : $ft;\n\t//\n\t$csv_hd_ar = array();\n\t// dataTables: | 'date' | 'file_name (link)' | 'file_text (link fmt)' | 'claim_ct' | 'reject_ct' |\n\t$csv_hd_ar['ack']['file'] = array('Date', 'FileName', 'isa13', 'ta1ctrl', 'Code');\n\t$csv_hd_ar['ebr']['file'] = array('Date', 'FileName', 'clrhsid', 'claim_ct', 'reject_ct', 'Batch');\n\t$csv_hd_ar['ibr']['file'] = array('Date', 'FileName', 'clrhsid', 'claim_ct', 'reject_ct', 'Batch');\n\t//\n\t// dataTables: | 'date' | 'file_name (link)' | 'file_text (link fmt)' | 'claim_ct' | 'partner' |\n\t$csv_hd_ar['batch']['file'] = array('Date', 'FileName', 'Ctn_837', 'claim_ct', 'x12_partner');\n\t$csv_hd_ar['ta1']['file'] =   array('Date', 'FileName', 'Ctn_ta1', 'ta1ctrl', 'Code');\n\t$csv_hd_ar['f997']['file'] =  array('Date', 'FileName', 'Ctn_999', 'ta1ctrl', 'RejCt');\n\t$csv_hd_ar['f277']['file'] =  array('Date', 'FileName', 'Ctn_277', 'Accept', 'AccAmt', 'Reject', 'RejAmt');\n\t$csv_hd_ar['f270']['file'] =  array('Date', 'FileName', 'Ctn_270', 'claim_ct', 'x12_partner');\n\t$csv_hd_ar['f271']['file'] =  array('Date', 'FileName', 'Ctn_271', 'claim_ct', 'Denied', 'Payer');\n\t$csv_hd_ar['era']['file'] =   array('Date', 'FileName', 'Trace', 'claim_ct', 'Denied', 'Payer');\n\t//\n\t// dataTables: | 'pt_name' | 'svc_date' | 'clm01 (link clm)' | 'status (mouseover)' | b f t (links to files) | message (mouseover) |\n\t$csv_hd_ar['ebr']['claim'] = array('PtName','SvcDate', 'clm01', 'Status', 'Batch', 'FileName', 'Payer');\n\t$csv_hd_ar['ibr']['claim'] = array('PtName','SvcDate', 'clm01', 'Status', 'Batch', 'FileName', 'Payer');\n\t$csv_hd_ar['dpr']['claim'] = array('PtName','SvcDate', 'clm01', 'Status', 'Batch', 'FileName', 'Payer');\n\t//\n\t// dataTables: | 'pt_name' | 'svc_date' | 'clm01 (link clm)' | 'status (mouseover)' | 'bht03_837 (link rsp)' | message (mouseover) |\n\t$csv_hd_ar['batch']['claim'] = array('PtName', 'SvcDate', 'clm01', 'InsLevel', 'Ctn_837', 'File_837', 'Fee', 'PtPaid', 'Provider' );\n\t$csv_hd_ar['f997']['claim'] =  array('PtName', 'SvcDate', 'clm01', 'Status', 'ak_num', 'File_997', 'Ctn_837', 'err_seg');\n\t$csv_hd_ar['f277']['claim'] =  array('PtName', 'SvcDate', 'clm01', 'Status', 'st_277', 'File_277', 'payer_name', 'claim_id', 'bht03_837');\n\t$csv_hd_ar['f270']['claim'] =  array('PtName', 'SvcDate', 'clm01', 'InsLevel', 'st_270', 'File_270', 'payer_name', 'bht03_270');\n\t$csv_hd_ar['f271']['claim'] =  array('PtName', 'SvcDate', 'clm01', 'Status', 'st_271', 'File_271', 'payer_name', 'bht03_270');\n\t$csv_hd_ar['era']['claim'] =   array('PtName', 'SvcDate', 'clm01', 'Status', 'trace', 'File_835', 'claimID', 'Pmt', 'PtResp', 'Payer');\n\t//\n\treturn $csv_hd_ar[$ft][$csv_type];\n}\n*/\n\n/**\n * adapted from http://scratch99.com/web-development/javascript/convert-bytes-to-mb-kb/\n *\n * @param int\n *\n * @return string\n */\nfunction csv_convert_bytes($bytes) {\n\t$sizes = array('Bytes', 'KB', 'MB', 'GB', 'TB');\n\tif ($bytes == 0) { return 'n/a'; }\n\t$i = floor( log($bytes) / log(1024) );\n\t//$i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));\n\tif ($i == 0) {\n\t\treturn $bytes.' '.$sizes[$i];\n\t} else {\n\t\treturn round($bytes / pow(1024, $i), 1).' '.$sizes[$i];\n\t}\n}\n\n/**\n * Determine whether an array is multidimensional\n *\n * @param array\n * @return bool   false if arrayis multidimensional\n */\nfunction csv_singlerecord_test ( $array ) {\n\t// the two versions of count() are compared\n\t// if the array has a sub-array, count recursive is greater\n\tif ( is_array($array) ) {\n\t\t$is_sngl = count($array, COUNT_RECURSIVE ) == count( $array, COUNT_NORMAL);\n\t} else {\n\t\t$is_sngl = false;\n\t}\n\t//\n\treturn $is_sngl;\n}\n\n/*\n * give first and last index keys for an array\n * \n * @param array\n * @return array\n */\nfunction csv_array_bounds($array) {\n\t// get the segment array bounds\n\t$ret_ar = array();\n\tif (is_array($array) && count($array)) {\n\t\tif (reset($array) !== false) { $ret_ar[0] = key($array); }\n\t\tif (end($array) !== false) { $ret_ar[1] = key($array); }\n\t}\n\treturn $ret_ar;\n}\n\n/*\n * return a csv file as an associative array\n * the first row is the header or array keys for the row\n * array structure:\n *  array[i]=>array(hdr0=>csvrow[0], hdr1=>csvrow[1], hdr2=>csvrow[2], ...)\n * \n * @param string   file type e.g. f837\n * @param string   csv type claim or file\n * @return array\n */\nfunction csv_assoc_array($file_type, $csv_type) {\n    //\n    if (!$file_type || !$csv_type) {\n\t\tcsv_edihist_log('csv_assoc_array; invalid arguments ft: '.$file_type.' csvt: '.$csv_type);\n\t\treturn false;\n\t}\n    $csv_ar = array();\n    $h = array();\n    $fp = '';\n    //\n    $param = csv_parameters($file_type);\n    $fcsv = (strpos($csv_type, 'aim')) ? 'claims_csv' : 'files_csv';\n    //\n    $fp = (isset($param[$fcsv])) ? $param[$fcsv] : '';\n    if (!is_file($fp)) {\n\t\tcsv_edihist_log('csv_assoc_array; invalid csv file '.basename($fp));\n\t\treturn $csv_ar;\n\t}\n\t$ct = 0;\n\t$row = 0;\n\t$ky = -1;\n\tif (($fh = fopen($fp, \"rb\")) !== false) {\n\t    while (($data = fgetcsv($fh, 2048, \",\")) !== false) {\n\t\t\tif ( is_null($data) ) { continue; }\n\t\t\tif ($row) {\n\t\t\t\tfor($i=0; $i<$ct; $i++) {\n\t\t\t\t\t$csv_ar[$ky][$h[$i]] = $data[$i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$ct = count($data);\n\t\t\t\t$h = $data;\n\t\t\t}\n\t\t\t$row++;\n\t\t\t$ky++;\n        }\n        fclose($fh);\n    } else {\n\t\t // invalid file path\n\t \t csv_edihist_log('csv_assoc_array; invalid file path '.$fp);\n\t\t return false;\n\t}\n\t//\n\treturn $csv_ar;\n}\n\n\n/**\n * A multidimensional array will be flattened to a single row.\n *\n * @param array $array array to be flattened\n * @return array\n */\nfunction csv_array_flatten($array) {\n\t//\n\tif (!is_array($array)) {return FALSE;}\n\t$result = array();\n\tforeach ($array as $key => $value) {\n\t\tif (is_array($value)) {\n\t\t\t$result = array_merge($result, csv_array_flatten($value));\n\t\t} else {\n\t\t\t$result[$key] = $value;\n\t\t}\n\t}\n\treturn $result;\n}\n\n\n/**\n * Write parsed data from edi x12 files to csv file\n * \n * @uses csv_parameters()\n * @usescsv_table_header()\n * \n * @param array    data array from parse functions\n * @return bool    true if no error\n */\nfunction edih_csv_write($csv_data) {\n\t//\n\tif ( ! (is_array($csv_data) && count($csv_data)) ){\n\t\tcsv_edihist_log('edih_csv_write(): invalid data array');\n\t\treturn false;\n\t}\n\t//\n\tforeach($csv_data as $icn=>$isa) {\n\t\t// should be array[icn] => [file][j][key]  [claim][j][key]  [type]\n\t\t$ft = ( isset($isa['type']) ) ? $isa['type'] : '';\n\t\tif (!$ft) {\n\t\t\tcsv_edihist_log('edih_csv_write(): invalid file type');\n\t\t\tcontinue;\n\t\t}\n\t\t//\n\t\t$param = csv_parameters($ft);\n\t\t$f_hdr = csv_table_header($ft, 'file');\n\t\t$c_hdr = csv_table_header($ft, 'claim');\n\t\tif (is_array($param)) {\n\t\t\t// if either csv files does not exist, create them both\n\t\t\t// all unlisted files in type directory will be processed on next process round\n\t\t\tif (is_file($param['files_csv']) && (filesize($param['files_csv']) > 20)) {\n\t\t\t\tcsv_edihist_log('edih_csv_write: csv check for files csv '.$ft);\n\t\t\t} else {\n\t\t\t\t$nfcsv = $param['files_csv'];\n\t\t\t\t$fh = fopen($nfcsv, 'wb');\n\t\t\t\tif ($fh !== false) {\n\t\t\t\t\tfputcsv($fh, $f_hdr);\n\t\t\t\t\tfclose($fh);\n\t\t\t\t\tchmod($nfcsv, 0600);\n\t\t\t\t}\n\t\t\t\tcsv_edihist_log('edih_csv_write: created files_csv file for '.$ft);\n\t\t\t}\n\t\t\tif (is_file($param['claims_csv']) && filesize($param['claims_csv'])) {\n\t\t\t\tcsv_edihist_log('edih_csv_write: csv check for claims csv '.$ft);\n\t\t\t} else {\n\t\t\t\t$nfcsv = $param['claims_csv'];\n\t\t\t\t$fh = fopen($nfcsv, 'wb');\n\t\t\t\tif ($fh !== false) {\n\t\t\t\t\tfputcsv($fh, $c_hdr);\n\t\t\t\t\tfclose($fh);\n\t\t\t\t\tchmod($nfcsv, 0600);\n\t\t\t\t}\n\t\t\t\tcsv_edihist_log('edih_csv_write: created claims_csv file for '.$ft);\n\t\t\t}\n\t\t} else {\n\t\t\tcsv_edihist_log('edih_csv_write: parameters error for type '.$ft);\n\t\t\treturn false;\n\t\t}\n\t\t//\n\t\tforeach($isa as $key=>$data) {\n\t\t\tif ($key == 'type') { continue; }\n\t\t\t// get the csv file path from parameters\n\t\t\t$fp = ($key == 'file') ? $param['files_csv'] : $param['claims_csv'];\n\t\t\t// get the csv row header\n\t\t\t$order_ar = ($key == 'file') ? $f_hdr : $c_hdr;\n\t\t\t$ct = count($order_ar);\n\t\t\t$chrs = 0;\n\t\t\t$rws = 0;\n\t\t\t//\n\t\t\t$fh = fopen( $fp, 'ab');\n\t\t\tif (is_resource($fh)) {\n\t\t\t\t// to assure proper order of data in each row, the\n\t\t\t\t// csv row is assembled by matching keys to the header row\n\t\t\t\tforeach($data as $ky=>$row) {\n\t\t\t\t\t$csvrow = array();\n\t\t\t\t\tfor ($i=0; $i<$ct; $i++) {\n\t\t\t\t\t\t$csvrow[$i] = $row[$order_ar[$i]];\n\t\t\t\t\t}\n\t\t\t\t\t$chrs += fputcsv ( $fh , $csvrow );\n\t\t\t\t\t$rws++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcsv_edihist_log('edih_csv_write(): failed to open '.$fp);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//\n\t\t\tcsv_edihist_log('edih_csv_write() wrote '.$rws.' rows to '.basename($fp));\n\t\t}\n\t}\n\t//\n\treturn $rws;\n}\n\n\n/**\n * Search a csv record file and return the row or values from selected columns\n *\n * This function requires that the $search_ar parameter be an array\n * with keys ['s_val']['s_col']['r_cols'], and 'r_cols' is an array\n * 's_val' is the search value, s_col is the column to check, r_cols is an array\n * of column numbers from which values are returned.  If r_cols is not an array,\n * then the entire row will be returned.  If the 'expect' parameter is 1, then\n * the search will stop after the first success and return the result. Otherwise, the\n * entire file will be searched.\n * ex: csv_search_record('batch', 'claim', array('s_val'=>'0024', 's_col'=>9, 'r_cols'=>array(1, 2, 7)), \"1\" )\n *\n * @uses csv_parameters()\n * @param string $file_type\n * @param string $csv_type\n * @param array $search_ar\n * @param mixed $expect\n * @return array\n */\nfunction csv_search_record($file_type, $csv_type, $search_ar, $expect='1') {\n\t//\n\tcsv_edihist_log(\"csv_search_record: \".strval($file_type).\" \".strval($csv_type).\" \".strval($search_ar['s_val']));\n\t//\n\t$tp = csv_file_type($file_type);\n\tif (!$tp) {\n\t\tcsv_edihist_log(\"csv_search_record: incorrect type $file_type\");\n\t\treturn false;\n\t}\n\t//\n\t$params = csv_parameters($tp);\n\t//\n\tif ($csv_type == 'claim') {\n        $fp = $params['claims_csv'];\n\t} elseif ($csv_type == 'file') {\n        $fp = $params['files_csv'];\n\t} else {\n\t\tcsv_edihist_log('csv_search_record: incorrect csv type '.$csv_type);\n\t\treturn FALSE;\n\t}\n\t//\n\tif (!is_array($search_ar) || array_keys($search_ar) != array('s_val', 's_col', 'r_cols')) {\n\t\tcsv_edihist_log('csv_search_record: invalid search criteria');\n\t\treturn FALSE;\n\t}\n\t$sv = $search_ar['s_val'];\n\t$sc = $search_ar['s_col'];\n\t$rv = (is_array($search_ar['r_cols']) && count($search_ar['r_cols'])) ? $search_ar['r_cols'] : 'all';\n\t$ret_ar = array();\n\t$idx = 0;\n\tif (($fh1 = fopen($fp, \"r\")) !== false) {\n\t    while (($data = fgetcsv($fh1)) !== false) {\n\t\t\t// check for a match\n\t\t\tif ($data[$sc] == $sv) {\n\t\t\t\tif ($rv == 'all') {\n\t\t\t\t\t$ret_ar[$idx] = $data;\n\t\t\t\t} else {\n\t\t\t\t\t// now loop through the 'r_cols' array for data index\n\t\t\t\t\t$dct = count($data);\n\t\t\t\t\tforeach($rv as $c) {\n\t\t\t\t\t\t// make sure we don't access a non-existing index\n\t\t\t\t\t\tif ($c >= $dct) { continue; }\n\t\t\t\t\t\t//\n\t\t\t\t\t\t$ret_ar[$idx][] = $data[$c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$idx++;\n\t\t\t\tif ($expect == '1') { break; }\n\t\t\t}\n\t\t}\n\t\tfclose($fh1);\n\t} else {\n\t\tcsv_edihist_log('csv_search_record: failed to open '.$fp);\n\t\treturn false;\n\t}\n\tif (empty($ret_ar) ) {\n\t\treturn false;\n\t} else {\n\t\treturn $ret_ar;\n\t}\n}\n\n/**\n * Search the 'claims' csv table for the patient control and find the associated file name\n *\n * Searchtype \n * In 'claims' csv tables, clm01 is position 2, ISA13 number is pos 4, and filename is pos 5;\n * Since we are interested usually in the filename, ISA13 is irrelevant usually.\n *\n * @uses csv_parameters()\n * @uses csv_pid_enctr_parse()\n * @param string                     patient control-- pid-encounter, encounter, or pid\n * @param string                     filetype -- x12 type or f837, f277, etc\n * @param string                     search type encounter, pid, or clm01\n * @return array|bool\t\t\t\t [i] data row array  or empty on error\n */\nfunction csv_file_by_enctr($clm01, $filetype='f837') {\n\t//\n\t// return array of [i](pid_encounter, filename), there may be more than one file\n\t//\n\tif (!$clm01) {\n\t\treturn 'invalid encounter data<br>' . PHP_EOL;\n\t}\n\t//\n\t$ret_ar = array();\n\t$ft = csv_file_type($filetype);\n\t//\n\tif (!$ft) {\n\t\tcsv_edihist_log('csv_file_by_enctr: incorrect file type '.$filetype);\n\t\treturn $ret_ar;\n\t} else {\n\t\t$params = csv_parameters($ft);\n\t\t//$fp = isset($params['claims_csv']) ? dirname(__FILE__).$params['claims_csv'] : false;\n        $fp = isset($params['claims_csv']) ? $params['claims_csv'] : false;\n        $h_ar = csv_table_header($ft, 'claim');\n        $hct = count($h_ar);\n\t\tif (!$fp) {\n\t\t\tcsv_edihist_log('csv_file_by_enctr: incorrect file type '.$filetype);\n\t\t\treturn $ret_ar;\n\t\t}\n\t}\n\t//\n\t$enct = csv_pid_enctr_parse(strval($clm01));\n\t$p = (isset($enct['pid'])) ? $enct['pid'] : '';\n\t$e = (isset($enct['enctr'])) ? $enct['enctr'] : '';\n\tif ($p && $e) {\n\t\t$pe = $p.'-'.$e;\n\t\t$srchtype = '';\n\t} elseif ($e) {\n\t\t$srchtype = 'encounter';\n\t} elseif ($p) {\n\t\t$srchtype = 'pid';\n\t} else {\n\t\tcsv_edihist_log('csv_file_by_enctr: unable to determine encounter value '.$clm01);\n\t\treturn 'unable to determine encounter value '.$clm01.'<br />'.PHP_EOL;\n\t}\n\t// OpenEMR creates CLM01 as nnn-nnn in genX12 batch\n\t//$pm = preg_match('/\\D/', $enctr, $match2, PREG_OFFSET_CAPTURE);\n\t$val = array();\n\t//array_combine ( array $keys , array $values )\n\t// in 'claims' csv tables, clm01 is position 2 and filename is position 5\n\tif (($fh1 = fopen($fp, \"r\")) !== FALSE) {\n\t\tif ($srchtype == 'encounter') {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, \",\")) !== FALSE) {\n\t\t\t\t// check for a match\n\t\t\t\tif (strpos($data[2], $e)) {\n\t\t\t\t\t$te = substr($data[2], strpos($data[2],'-')+1);\n\t\t\t\t\tif (strcmp($te, $e) === 0) {\n\t\t\t\t\t\tfor ($i=0; $i<$hct; $i++) { $val[$h_ar[$i]] = $data[$i]; }\n\t\t\t\t\t\t$ret_ar[] = $val;  // array_combine($h_ar, $data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} elseif ($srchtype == 'pid') {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, ',')) !== FALSE) {\n\t\t\t\tif (strpos($data[2], $p) !== false) {\n\t\t\t\t\t$te = (strpos($data[2], '-')) ? substr($data[2], 0, strpos($data[2],'-')) : '';\n\t\t\t\t\tif (strcmp($te, $p) === 0) {\n\t\t\t\t\t\tfor ($i=0; $i<$hct; $i++) { $val[$h_ar[$i]] = $data[$i]; }\n\t\t\t\t\t\t$ret_ar[] = $val;  // $ret_ar[] = array_combine($h_ar, $data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, \",\")) !== FALSE) {\n\t\t\t\t// check for a match\n\t\t\t\tif ( strcmp($data[2], $pe) === 0 ) {\n\t\t\t\t\tfor ($i=0; $i<$hct; $i++) { $val[$h_ar[$i]] = $data[$i]; }\n\t\t\t\t\t$ret_ar[] = $val;  // $ret_ar[] = array_combine($h_ar, $data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfclose($fh1);\n\t} else {\n\t\tcsv_edihist_log('csv_file_by_enctr: failed to open csv file '.basename($fp));\n\t\treturn false;\n\t}\n\treturn $ret_ar;\n}\n\n   \n/**\n * get the x12 file containing the control_num ISA13\n *\n * @todo the csv for x12 files 999, 277, 835, 837 must have the control number\n *\n * @uses csv_search_record()\n * @param string $control_num   the interchange control number, isa13\n * @return  string              the file name\n */\nfunction csv_file_by_controlnum($type, $control_num) {\n\t// get the batch file containing the control_num\n\t//\n\t$tp = csv_file_type($type);\n\t//\n\t$hdr = csv_table_header($tp, 'file');\n\t$scol = array_search('Control', $hdr);\n\t$rcol = array_search('FileName', $hdr);\n\t//\n\t// $search_ar should have keys ['s_val']['s_col'] array(['r_cols'][])\n\t//    like \"batch', 'claim, array(9, '0024', array(1, 2, 7))\n\t//$csv_hd_ar['batch']['file'] = array('time', 'file_name', 'control_num', 'claims', 'x12_partner', 'x12_version');\n\t//\n\t$fn = '';\n\t$ctln = (strlen($control_num) >= 9) ? substr($control_num, 0, 9) : $control_num;\n\t$search = array('s_val'=>$ctln, 's_col'=>$scol, 'r_cols'=>array($rcol));\n\t$result = csv_search_record($tp, 'file', $search, \"1\");\n\tif (is_array($result) && count($result[0]) == 1) {\n\t\t$fn = $result[0][0];\n\t}\n\treturn $fn;\n}\n\n\n/**\n * Search the csv table to obtain the file name for a given \n * trace value (835 / 997 999 type only)\n * \n * Note: the 997/999 trace is the ISA13 of a batch file\n * \n * \n * @param string\t trace value (TRN02, TA101, or BHT03)\n * @param string     from type (default is f835)\n * @param string\t to type (default is f835)\n * @return string    file name or empty string\n */\nfunction csv_file_by_trace($trace, $from_type='f835', $to_type='f837') {\n\t// get the file referenced by the trace value\n\t//\n\t$ft = ($from_type) ? csv_file_type($from_type) : '';\n\t$tt = ($to_type) ? csv_file_type($to_type) : '';\n\t$fn = '';\n\t$csv_type = '';\n\t$type = '';\n\t$search = array();\n\t//\n\tcsv_edihist_log(\"csv_file_by_trace: $trace from  $ft to $tt\");\n\t//\n\t// $search_ar should have keys ['s_val']['s_col'] array(['r_cols'])\n\t//    like \"f837', 'claim, array(9, '0024', array(1, 2, 7))\n\t//\n\tif ($ft == 'f835') {\n\t\t// trace payment to status or claim\n\t\t$search = array('s_val'=>$trace, 's_col'=>3, 'r_cols'=>'All');\n\t\t$type = $tt;\n\t\t$csv_type = 'file';\n\t} elseif ($ft == 'f997') {\n\t\t// trace ACK to batch file\n\t\t$icn = (is_numeric($trace) && strlen($trace) >= 9) ? substr($trace, 0, 9) : $trace;\n\t\t$search = array('s_val'=>$icn, 's_col'=>2, 'r_cols'=>'All');\n\t\t$type = $tt;\n\t\t$csv_type = 'file';\n\t} elseif ($ft == 'f277') {\n\t\t// trace status to status req or claim\n\t\tif ($tt == 'f276') {\n\t\t\t$search = array('s_val'=>$trace, 's_col'=>7, 'r_cols'=>'All');\n\t\t\t$type = $tt;\n\t\t\t$csv_type = 'claim';\n\t\t} elseif ($tt == 'f837') {\n\t\t\t// expect CLM01 for trace value\n\t\t\t$search = array('s_val'=>$trace, 's_col'=>2, 'r_cols'=>'All');\n\t\t\t$type = $tt;\n\t\t\t$csv_type = 'claim';\n\t\t}\n\t} elseif ($ft == 'f271') {\n\t\t// trace benefit to benefit req\n\t\tif ($tt == 'f270') {\n\t\t\t$search = array('s_val'=>$trace, 's_col'=>2, 'r_cols'=>'All');\n\t\t\t$type = $tt;\n\t\t\t$csv_type = 'claim';\n\t\t}\n\t} elseif ($ft == 'f278') {\n\t\t// trace auth to auth req\n\t\t$search = array('s_val'=>$trace, 's_col'=>2, 'r_cols'=>'All');\n\t\t$type = 'f278';\n\t\t$csv_type = 'claim';\n\t}  else {\n\t\tcsv_edihist_log('csv_file_by_trace: incorrect file type '.$file_type);\n\t\treturn $fn;\n\t}\n\t//\n\tif ($type && $csv_type && $search) {\n\t\t$result = csv_search_record($type, $csv_type, $search, false);\n\t\tif (is_array($result) && count($result)) {\n\t\t\tif ($ft == 'f278') {\n\t\t\t\tforeach($result as $r) {\n\t\t\t\t\tif ($r[6] == 'Rsp' || $r[6] == 'Reply') {\n\t\t\t\t\t\t$fn = $result[0][5];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} elseif ($csv_type == 'claim') {\n\t\t\t\t$fn = $result[0][5];\n\t\t\t} else {\n\t\t\t\t$fn = $result[0][1];\n\t\t\t}\n\t\t} else {\n\t\t\tcsv_edihist_log(\"csv_file_by_trace: search failed $type csv $csv_type for trace $trace $from_type $to_type\");\n\t\t}\n\t} else {\n\t\tcsv_edihist_log(\"csv_file_by_trace: error type $type csv $csv_type for trace $trace $from_type $to_type\");\n\t}\n\treturn $fn;\n}\n\n/**\n * list claim records with Denied or Reject status in  given file\n *\n * @param string\n * @param string\n *\n * @return array\n */\nfunction csv_denied_by_file($filetype, $filename, $trace='') {\n\t//\n\t$ret_ar = array();\n\t$ft = csv_file_type($filetype);\n\tif (strpos('|f997|f271|f277|f835', $ft)) {\n\t\t$param = csv_parameters($ft);\n\t\t$csv_file = $param['claims_csv'];\n\t} else {\n\t\tcsv_edihist_log(\"csv_errors_by_file: incorrect file type $filetype\");\n\t\treturn $ret_ar;\n\t}\n\t//\n\tcsv_edihist_log(\"csv_errors_by_file: $ft searching $filename with trace $trace\");\n\t//\n\tif (($fh1 = fopen($csv_file, \"r\")) !== false) {\n\t\tif ($ft == 'f835') {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, \",\")) !== false) {\n\t\t\t\t// check filename, then status\n\t\t\t\tif ($trace) {\n\t\t\t\t\tif ($data[4] == $trace) {\n\t\t\t\t\t\tif (!in_array($data[3], array('1', '2', '3', '19', '20', '21')) ) { $ret_ar[] = $data; }\n\t\t\t\t\t}\n\t\t\t\t} elseif ($data[5] == $filename) {\n\t\t\t\t\tif (!in_array($data[3], array('1', '2', '3', '19', '20', '21')) ) { $ret_ar[] = $data; }\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t} elseif ($ft == 'f277') {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, \",\")) !== false) {\n\t\t\t\tif ($data[5] == $filename) {\n\t\t\t\t\tif ( !strpos('|A1|A2|A5', substr($data[3], 0, 2))) {\n\t\t\t\t\t\t$ret_ar[] = $data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} elseif (strpos('|f997|f999|f271', $ft)) {\n\t\t\twhile (($data = fgetcsv($fh1, 1024, \",\")) !== false) {\n\t\t\t\tif ($data[5] == $filename) {\n\t\t\t\t\tif ($data[3] !== 'A') {\n\t\t\t\t\t\t$ret_ar[] = $data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcsv_edihist_log(\"csv_errors_by_file: file type did not match $filetype\");\n\t\t}\n\t\tfclose($fh1);\n\t}\n\t//\n\treturn $ret_ar;\n}\n\n\n/**\n* A function to try and assure the pid-encounter is correctly parsed\n*\n* assume a format of pid-encounter, since that is sent in the OpenEMR x12 837\n*\n* @param string $pid_enctr   the value from element CLM01\n* return array               array('pid' => $pid, 'enctr' => $enc)\n*/\nfunction csv_pid_enctr_parse( $pid_enctr ) {\n\t// evaluate the patient account field\n\t//\n\tif (!$pid_enctr || !is_string($pid_enctr) ) {\n\t\tcsv_edihist_log(\"csv_pid_enctr_parse: invalid argument\");\n\t\treturn false;\n\t}\n\t$pval = trim($pid_enctr);\n\tif ( strpos($pval, '-') ) {\n\t\t$pid = substr($pval, 0, strpos($pval, '-'));\n\t\t$enc = substr($pval, strpos($pval, '-')+1);\n\t} elseif ( ctype_digit($pval) ) {\n\t\tif ( preg_match('/(19|20)\\d{2}[01]\\d{1}[0-3]\\d{1}/', $pval) ) {\n\t\t\t$enc = $pval;\n\t\t} else {\n\t\t\t$enc = ( strlen($pval) ) >= ENCOUNTER_MIN_DIGIT_LENGTH ? $pval : '';\n\t\t\t$pid = '';\n\t\t}\n\t} elseif (\tpreg_match('/\\D/', $pval, $match2, PREG_OFFSET_CAPTURE) ) {\n\t\t$inv_split = (count($match2)) ? preg_split('/\\D/', $pval, 2, PREG_SPLIT_NO_EMPTY) : false;\n\t\tif ($inv_split) {\n\t\t\t$pid = $inv_split[0];\n\t\t\t$enc = $inv_split[1];\n\t\t}\n\t} else {\n\t\t$enc = ( strlen($pval) ) >= ENCOUNTER_MIN_DIGIT_LENGTH ? $pval : '';\n\t\t$pid = '';\n\t}\n\treturn array('pid' => $pid, 'enctr' => $enc);\n}\n", "<?php\n/**\n* Function to check and/or sanitize things for security such as\n* directories names, file names, etc.\n *\n * @package OpenEMR\n * @link    http://www.open-emr.org\n * @author  Brady Miller <brady.g.miller@gmail.com>\n * @author  Roberto Vasquez <robertogagliotta@gmail.com>\n * @author  Shachar Zilbershlag <shaharzi@matrix.co.il>\n * @copyright Copyright (c) 2012-2017 Brady Miller <brady.g.miller@gmail.com>\n * @license https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3\n */\n\n\n// If the label contains any illegal characters, then the script will die.\nfunction check_file_dir_name($label) {\n  if (empty($label) || preg_match('/[^A-Za-z0-9_.-]/', $label)) {\n    error_log(\"ERROR: The following variable contains invalid characters:\" . $label);\n    die(xlt(\"ERROR: The following variable contains invalid characters\").\": \". attr($label));\n  }\n}\n\n// Convert all illegal characters to _\nfunction convert_safe_file_dir_name($label) {\n  return preg_replace('/[^A-Za-z0-9_.-]/','_',$label);\n}\n\n//Basename functionality for nonenglish languages (without this, basename function ommits nonenglish characters).\nfunction basename_international($path){\n  $parts = preg_split('~[\\\\\\\\/]~', $path);\n  foreach ($parts as $key => $value){\n    $encoded = urlencode($value);\n    $parts[$key] = $encoded;\n  }\n  $encoded_path = implode(\"/\", $parts);\n  $encoded_file_name = basename($encoded_path);\n  $decoded_file_name = urldecode($encoded_file_name);\n\n  return $decoded_file_name;\n}\n\n\n/**\n * This function detects a MIME type for a file and check if it in the white list of the allowed mime types.\n * @param string $file - file location.\n * @param array|null $whiteList - array of mime types that allowed to upload.\n */\n// Regarding the variable below. In the case of multiple file upload the isWhiteList function will run multiple\n// times, therefore, storing the white list in the variable below to prevent multiple requests from database.\n$white_list = null;\nfunction isWhiteFile($file){\n    global $white_list;\n    if(is_null($white_list)){\n        $white_list = array();\n        $lres = sqlStatement(\"SELECT option_id FROM list_options WHERE list_id = 'files_white_list' AND activity = 1\");\n        while ($lrow = sqlFetchArray($lres)) {\n            $white_list[] = $lrow['option_id'];\n        }\n    }\n\n    $mimetype  = mime_content_type($file);\n    if(in_array($mimetype, $white_list)){\n        return true;\n    } else {\n        $splitMimeType = explode('/', $mimetype);\n        $categoryType = $splitMimeType[0];\n        if(in_array($categoryType. '/*',  $white_list))return true;\n    }\n    return false;\n}\n\n?>\n"], "filenames": ["library/edihistory/edih_csv_inc.php", "library/sanitize.inc.php"], "buggy_code_start_loc": [136, 5], "buggy_code_end_loc": [136, 28], "fixing_code_start_loc": [137, 5], "fixing_code_end_loc": [138, 22], "type": "CWE-116", "message": "The csv_log_html function in library/edihistory/edih_csv_inc.php in OpenEMR 5.0.0 and prior allows attackers to bypass intended access restrictions via a crafted name.", "other": {"cve": {"id": "CVE-2017-12064", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-01T05:29:00.210", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The csv_log_html function in library/edihistory/edih_csv_inc.php in OpenEMR 5.0.0 and prior allows attackers to bypass intended access restrictions via a crafted name."}, {"lang": "es", "value": "La funci\u00f3n csv_log_html en library/edihistory/edih_csv_inc.php en OpenEMR 5.0.0 y anteriores permite a los atacantes evadir las restricciones de acceso mediante un nombre manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-116"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:open-emr:openemr:5.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "2EBA5191-1CC6-45DE-920C-7EB87822E303"}]}]}], "references": [{"url": "https://github.com/openemr/openemr/commit/b8963a5ca483211ed8de71f18227a0e66a2582ad", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openemr/openemr/commit/b8963a5ca483211ed8de71f18227a0e66a2582ad"}}