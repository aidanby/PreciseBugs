{"buggy_code": ["# Natural Language Toolkit: Interface to MaltParser\n#\n# Author: Dan Garrette <dhgarrette@gmail.com>\n# Contributor: Liling Tan, Mustufain, osamamukhtar11\n#\n# Copyright (C) 2001-2021 NLTK Project\n# URL: <https://www.nltk.org/>\n# For license information, see LICENSE.TXT\n\nimport inspect\nimport os\nimport subprocess\nimport sys\nimport tempfile\n\nfrom nltk.data import ZipFilePathPointer\nfrom nltk.internals import find_dir, find_file, find_jars_within_path\nfrom nltk.parse.api import ParserI\nfrom nltk.parse.dependencygraph import DependencyGraph\nfrom nltk.parse.util import taggedsents_to_conll\n\n\ndef malt_regex_tagger():\n    from nltk.tag import RegexpTagger\n\n    _tagger = RegexpTagger(\n        [\n            (r\"\\.$\", \".\"),\n            (r\"\\,$\", \",\"),\n            (r\"\\?$\", \"?\"),  # fullstop, comma, Qmark\n            (r\"\\($\", \"(\"),\n            (r\"\\)$\", \")\"),  # round brackets\n            (r\"\\[$\", \"[\"),\n            (r\"\\]$\", \"]\"),  # square brackets\n            (r\"^-?[0-9]+(.[0-9]+)?$\", \"CD\"),  # cardinal numbers\n            (r\"(The|the|A|a|An|an)$\", \"DT\"),  # articles\n            (r\"(He|he|She|she|It|it|I|me|Me|You|you)$\", \"PRP\"),  # pronouns\n            (r\"(His|his|Her|her|Its|its)$\", \"PRP$\"),  # possessive\n            (r\"(my|Your|your|Yours|yours)$\", \"PRP$\"),  # possessive\n            (r\"(on|On|in|In|at|At|since|Since)$\", \"IN\"),  # time prepopsitions\n            (r\"(for|For|ago|Ago|before|Before)$\", \"IN\"),  # time prepopsitions\n            (r\"(till|Till|until|Until)$\", \"IN\"),  # time prepopsitions\n            (r\"(by|By|beside|Beside)$\", \"IN\"),  # space prepopsitions\n            (r\"(under|Under|below|Below)$\", \"IN\"),  # space prepopsitions\n            (r\"(over|Over|above|Above)$\", \"IN\"),  # space prepopsitions\n            (r\"(across|Across|through|Through)$\", \"IN\"),  # space prepopsitions\n            (r\"(into|Into|towards|Towards)$\", \"IN\"),  # space prepopsitions\n            (r\"(onto|Onto|from|From)$\", \"IN\"),  # space prepopsitions\n            (r\".*able$\", \"JJ\"),  # adjectives\n            (r\".*ness$\", \"NN\"),  # nouns formed from adjectives\n            (r\".*ly$\", \"RB\"),  # adverbs\n            (r\".*s$\", \"NNS\"),  # plural nouns\n            (r\".*ing$\", \"VBG\"),  # gerunds\n            (r\".*ed$\", \"VBD\"),  # past tense verbs\n            (r\".*\", \"NN\"),  # nouns (default)\n        ]\n    )\n    return _tagger.tag\n\n\ndef find_maltparser(parser_dirname):\n    \"\"\"\n    A module to find MaltParser .jar file and its dependencies.\n    \"\"\"\n    if os.path.exists(parser_dirname):  # If a full path is given.\n        _malt_dir = parser_dirname\n    else:  # Try to find path to maltparser directory in environment variables.\n        _malt_dir = find_dir(parser_dirname, env_vars=(\"MALT_PARSER\",))\n    # Checks that that the found directory contains all the necessary .jar\n    malt_dependencies = [\"\", \"\", \"\"]\n    _malt_jars = set(find_jars_within_path(_malt_dir))\n    _jars = {os.path.split(jar)[1] for jar in _malt_jars}\n    malt_dependencies = {\"log4j.jar\", \"libsvm.jar\", \"liblinear-1.8.jar\"}\n\n    assert malt_dependencies.issubset(_jars)\n    assert any(\n        filter(lambda i: i.startswith(\"maltparser-\") and i.endswith(\".jar\"), _jars)\n    )\n    return list(_malt_jars)\n\n\ndef find_malt_model(model_filename):\n    \"\"\"\n    A module to find pre-trained MaltParser model.\n    \"\"\"\n    if model_filename is None:\n        return \"malt_temp.mco\"\n    elif os.path.exists(model_filename):  # If a full path is given.\n        return model_filename\n    else:  # Try to find path to malt model in environment variables.\n        return find_file(model_filename, env_vars=(\"MALT_MODEL\",), verbose=False)\n\n\nclass MaltParser(ParserI):\n    \"\"\"\n    A class for dependency parsing with MaltParser. The input is the paths to:\n    - (optionally) a maltparser directory\n    - (optionally) the path to a pre-trained MaltParser .mco model file\n    - (optionally) the tagger to use for POS tagging before parsing\n    - (optionally) additional Java arguments\n\n    Example:\n        >>> from nltk.parse import malt\n        >>> # With MALT_PARSER and MALT_MODEL environment set.\n        >>> mp = malt.MaltParser(model_filename='engmalt.linear-1.7.mco') # doctest: +SKIP\n        >>> mp.parse_one('I shot an elephant in my pajamas .'.split()).tree() # doctest: +SKIP\n        (shot I (elephant an) (in (pajamas my)) .)\n        >>> # Without MALT_PARSER and MALT_MODEL environment.\n        >>> mp = malt.MaltParser('/home/user/maltparser-1.9.2/', '/home/user/engmalt.linear-1.7.mco') # doctest: +SKIP\n        >>> mp.parse_one('I shot an elephant in my pajamas .'.split()).tree() # doctest: +SKIP\n        (shot I (elephant an) (in (pajamas my)) .)\n    \"\"\"\n\n    def __init__(\n        self,\n        parser_dirname=\"\",\n        model_filename=None,\n        tagger=None,\n        additional_java_args=None,\n    ):\n        \"\"\"\n        An interface for parsing with the Malt Parser.\n\n        :param parser_dirname: The path to the maltparser directory that\n            contains the maltparser-1.x.jar\n        :type parser_dirname: str\n        :param model_filename: The name of the pre-trained model with .mco file\n            extension. If provided, training will not be required.\n            (see http://www.maltparser.org/mco/mco.html and\n            see http://www.patful.com/chalk/node/185)\n        :type model_filename: str\n        :param tagger: The tagger used to POS tag the raw string before\n            formatting to CONLL format. It should behave like `nltk.pos_tag`\n        :type tagger: function\n        :param additional_java_args: This is the additional Java arguments that\n            one can use when calling Maltparser, usually this is the heapsize\n            limits, e.g. `additional_java_args=['-Xmx1024m']`\n            (see https://goo.gl/mpDBvQ)\n        :type additional_java_args: list\n        \"\"\"\n\n        # Find all the necessary jar files for MaltParser.\n        self.malt_jars = find_maltparser(parser_dirname)\n        # Initialize additional java arguments.\n        self.additional_java_args = (\n            additional_java_args if additional_java_args is not None else []\n        )\n        # Initialize model.\n        self.model = find_malt_model(model_filename)\n        self._trained = self.model != \"malt_temp.mco\"\n        # Set the working_dir parameters i.e. `-w` from MaltParser's option.\n        self.working_dir = tempfile.gettempdir()\n        # Initialize POS tagger.\n        self.tagger = tagger if tagger is not None else malt_regex_tagger()\n\n    def parse_tagged_sents(self, sentences, verbose=False, top_relation_label=\"null\"):\n        \"\"\"\n        Use MaltParser to parse multiple POS tagged sentences. Takes multiple\n        sentences where each sentence is a list of (word, tag) tuples.\n        The sentences must have already been tokenized and tagged.\n\n        :param sentences: Input sentences to parse\n        :type sentence: list(list(tuple(str, str)))\n        :return: iter(iter(``DependencyGraph``)) the dependency graph\n            representation of each sentence\n        \"\"\"\n        if not self._trained:\n            raise Exception(\"Parser has not been trained. Call train() first.\")\n\n        with tempfile.NamedTemporaryFile(\n            prefix=\"malt_input.conll.\", dir=self.working_dir, mode=\"w\", delete=False\n        ) as input_file:\n            with tempfile.NamedTemporaryFile(\n                prefix=\"malt_output.conll.\",\n                dir=self.working_dir,\n                mode=\"w\",\n                delete=False,\n            ) as output_file:\n                # Convert list of sentences to CONLL format.\n                for line in taggedsents_to_conll(sentences):\n                    input_file.write(str(line))\n                input_file.close()\n\n                # Generate command to run maltparser.\n                cmd = self.generate_malt_command(\n                    input_file.name, output_file.name, mode=\"parse\"\n                )\n\n                # This is a maltparser quirk, it needs to be run\n                # where the model file is. otherwise it goes into an awkward\n                # missing .jars or strange -w working_dir problem.\n                _current_path = os.getcwd()  # Remembers the current path.\n                try:  # Change to modelfile path\n                    os.chdir(os.path.split(self.model)[0])\n                except:\n                    pass\n                ret = self._execute(cmd, verbose)  # Run command.\n                os.chdir(_current_path)  # Change back to current path.\n\n                if ret != 0:\n                    raise Exception(\n                        \"MaltParser parsing (%s) failed with exit \"\n                        \"code %d\" % (\" \".join(cmd), ret)\n                    )\n\n                # Must return iter(iter(Tree))\n                with open(output_file.name) as infile:\n                    for tree_str in infile.read().split(\"\\n\\n\"):\n                        yield (\n                            iter(\n                                [\n                                    DependencyGraph(\n                                        tree_str, top_relation_label=top_relation_label\n                                    )\n                                ]\n                            )\n                        )\n\n        os.remove(input_file.name)\n        os.remove(output_file.name)\n\n    def parse_sents(self, sentences, verbose=False, top_relation_label=\"null\"):\n        \"\"\"\n        Use MaltParser to parse multiple sentences.\n        Takes a list of sentences, where each sentence is a list of words.\n        Each sentence will be automatically tagged with this\n        MaltParser instance's tagger.\n\n        :param sentences: Input sentences to parse\n        :type sentence: list(list(str))\n        :return: iter(DependencyGraph)\n        \"\"\"\n        tagged_sentences = (self.tagger(sentence) for sentence in sentences)\n        return self.parse_tagged_sents(\n            tagged_sentences, verbose, top_relation_label=top_relation_label\n        )\n\n    def generate_malt_command(self, inputfilename, outputfilename=None, mode=None):\n        \"\"\"\n        This function generates the maltparser command use at the terminal.\n\n        :param inputfilename: path to the input file\n        :type inputfilename: str\n        :param outputfilename: path to the output file\n        :type outputfilename: str\n        \"\"\"\n\n        cmd = [\"java\"]\n        cmd += self.additional_java_args  # Adds additional java arguments\n        # Joins classpaths with \";\" if on Windows and on Linux/Mac use \":\"\n        classpaths_separator = \";\" if sys.platform.startswith(\"win\") else \":\"\n        cmd += [\n            \"-cp\",\n            classpaths_separator.join(self.malt_jars),\n        ]  # Adds classpaths for jars\n        cmd += [\"org.maltparser.Malt\"]  # Adds the main function.\n\n        # Adds the model file.\n        if os.path.exists(self.model):  # when parsing\n            cmd += [\"-c\", os.path.split(self.model)[-1]]\n        else:  # when learning\n            cmd += [\"-c\", self.model]\n\n        cmd += [\"-i\", inputfilename]\n        if mode == \"parse\":\n            cmd += [\"-o\", outputfilename]\n        cmd += [\"-m\", mode]  # mode use to generate parses.\n        return cmd\n\n    @staticmethod\n    def _execute(cmd, verbose=False):\n        output = None if verbose else subprocess.PIPE\n        p = subprocess.Popen(cmd, stdout=output, stderr=output)\n        return p.wait()\n\n    def train(self, depgraphs, verbose=False):\n        \"\"\"\n        Train MaltParser from a list of ``DependencyGraph`` objects\n\n        :param depgraphs: list of ``DependencyGraph`` objects for training input data\n        :type depgraphs: DependencyGraph\n        \"\"\"\n\n        # Write the conll_str to malt_train.conll file in /tmp/\n        with tempfile.NamedTemporaryFile(\n            prefix=\"malt_train.conll.\", dir=self.working_dir, mode=\"w\", delete=False\n        ) as input_file:\n            input_str = \"\\n\".join(dg.to_conll(10) for dg in depgraphs)\n            input_file.write(str(input_str))\n        # Trains the model with the malt_train.conll\n        self.train_from_file(input_file.name, verbose=verbose)\n        # Removes the malt_train.conll once training finishes.\n        os.remove(input_file.name)\n\n    def train_from_file(self, conll_file, verbose=False):\n        \"\"\"\n        Train MaltParser from a file\n        :param conll_file: str for the filename of the training input data\n        :type conll_file: str\n        \"\"\"\n\n        # If conll_file is a ZipFilePathPointer,\n        # then we need to do some extra massaging\n        if isinstance(conll_file, ZipFilePathPointer):\n            with tempfile.NamedTemporaryFile(\n                prefix=\"malt_train.conll.\", dir=self.working_dir, mode=\"w\", delete=False\n            ) as input_file:\n                with conll_file.open() as conll_input_file:\n                    conll_str = conll_input_file.read()\n                    input_file.write(str(conll_str))\n                return self.train_from_file(input_file.name, verbose=verbose)\n\n        # Generate command to run maltparser.\n        cmd = self.generate_malt_command(conll_file, mode=\"learn\")\n        ret = self._execute(cmd, verbose)\n        if ret != 0:\n            raise Exception(\n                \"MaltParser training (%s) failed with exit \"\n                \"code %d\" % (\" \".join(cmd), ret)\n            )\n        self._trained = True\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    A demonstration function to show how NLTK users can use the malt parser API.\n\n    >>> from nltk import pos_tag\n    >>> assert 'MALT_PARSER' in os.environ, str(\n    ... \"Please set MALT_PARSER in your global environment, e.g.:\\n\"\n    ... \"$ export MALT_PARSER='/home/user/maltparser-1.9.2/'\")\n    >>>\n    >>> assert 'MALT_MODEL' in os.environ, str(\n    ... \"Please set MALT_MODEL in your global environment, e.g.:\\n\"\n    ... \"$ export MALT_MODEL='/home/user/engmalt.linear-1.7.mco'\")\n    >>>\n    >>> _dg1_str = str(\"1    John    _    NNP   _    _    2    SUBJ    _    _\\n\"\n    ...             \"2    sees    _    VB    _    _    0    ROOT    _    _\\n\"\n    ...             \"3    a       _    DT    _    _    4    SPEC    _    _\\n\"\n    ...             \"4    dog     _    NN    _    _    2    OBJ     _    _\\n\"\n    ...             \"5    .     _    .    _    _    2    PUNCT     _    _\\n\")\n    >>>\n    >>>\n    >>> _dg2_str  = str(\"1    John    _    NNP   _    _    2    SUBJ    _    _\\n\"\n    ...             \"2    walks   _    VB    _    _    0    ROOT    _    _\\n\"\n    ...             \"3    .     _    .    _    _    2    PUNCT     _    _\\n\")\n    >>> dg1 = DependencyGraph(_dg1_str)\n    >>> dg2 = DependencyGraph(_dg2_str)\n    >>> # Initialize a MaltParser object\n    >>> mp = MaltParser()\n    >>>\n    >>> # Trains a model.\n    >>> mp.train([dg1,dg2], verbose=False)\n    >>> sent1 = ['John','sees','Mary', '.']\n    >>> sent2 = ['John', 'walks', 'a', 'dog', '.']\n    >>>\n    >>> # Parse a single sentence.\n    >>> parsed_sent1 = mp.parse_one(sent1)\n    >>> parsed_sent2 = mp.parse_one(sent2)\n    >>> print(parsed_sent1.tree())\n    (sees John Mary .)\n    >>> print(parsed_sent2.tree())\n    (walks John (dog a) .)\n    >>>\n    >>> # Parsing multiple sentences.\n    >>> sentences = [sent1,sent2]\n    >>> parsed_sents = mp.parse_sents(sentences)\n    >>> print(next(next(parsed_sents)).tree())\n    (sees John Mary .)\n    >>> print(next(next(parsed_sents)).tree())\n    (walks John (dog a) .)\n    >>>\n    >>> # Initialize a MaltParser object with an English pre-trained model.\n    >>> parser_dirname = 'maltparser-1.9.2'\n    >>> model_name = 'engmalt.linear-1.7.mco'\n    >>> mp = MaltParser(parser_dirname=parser_dirname, model_filename=model_name, tagger=pos_tag)\n    >>> sent1 = 'I shot an elephant in my pajamas .'.split()\n    >>> sent2 = 'Time flies like banana .'.split()\n    >>> # Parse a single sentence.\n    >>> print(mp.parse_one(sent1).tree())\n    (shot I (elephant an) (in (pajamas my)) .)\n    # Parsing multiple sentences\n    >>> sentences = [sent1,sent2]\n    >>> parsed_sents = mp.parse_sents(sentences)\n    >>> print(next(next(parsed_sents)).tree())\n    (shot I (elephant an) (in (pajamas my)) .)\n    >>> print(next(next(parsed_sents)).tree())\n    (flies Time (like banana) .)\n    \"\"\"\n\n    import doctest\n\n    doctest.testmod()\n", "# Natural Language Toolkit: Glue Semantics\n#\n# Author: Dan Garrette <dhgarrette@gmail.com>\n#\n# Copyright (C) 2001-2021 NLTK Project\n# URL: <https://www.nltk.org/>\n# For license information, see LICENSE.TXT\n\nimport os\nfrom itertools import chain\n\nimport nltk\nfrom nltk.internals import Counter\nfrom nltk.sem import drt, linearlogic\nfrom nltk.sem.logic import (\n    AbstractVariableExpression,\n    Expression,\n    LambdaExpression,\n    Variable,\n    VariableExpression,\n)\nfrom nltk.tag import BigramTagger, RegexpTagger, TrigramTagger, UnigramTagger\n\nSPEC_SEMTYPES = {\n    \"a\": \"ex_quant\",\n    \"an\": \"ex_quant\",\n    \"every\": \"univ_quant\",\n    \"the\": \"def_art\",\n    \"no\": \"no_quant\",\n    \"default\": \"ex_quant\",\n}\n\nOPTIONAL_RELATIONSHIPS = [\"nmod\", \"vmod\", \"punct\"]\n\n\nclass GlueFormula:\n    def __init__(self, meaning, glue, indices=None):\n        if not indices:\n            indices = set()\n\n        if isinstance(meaning, str):\n            self.meaning = Expression.fromstring(meaning)\n        elif isinstance(meaning, Expression):\n            self.meaning = meaning\n        else:\n            raise RuntimeError(\n                \"Meaning term neither string or expression: %s, %s\"\n                % (meaning, meaning.__class__)\n            )\n\n        if isinstance(glue, str):\n            self.glue = linearlogic.LinearLogicParser().parse(glue)\n        elif isinstance(glue, linearlogic.Expression):\n            self.glue = glue\n        else:\n            raise RuntimeError(\n                \"Glue term neither string or expression: %s, %s\"\n                % (glue, glue.__class__)\n            )\n\n        self.indices = indices\n\n    def applyto(self, arg):\n        \"\"\"self = (\\\\x.(walk x), (subj -o f))\n        arg  = (john        ,  subj)\n        returns ((walk john),          f)\n        \"\"\"\n        if self.indices & arg.indices:  # if the sets are NOT disjoint\n            raise linearlogic.LinearLogicApplicationException(\n                f\"'{self}' applied to '{arg}'.  Indices are not disjoint.\"\n            )\n        else:  # if the sets ARE disjoint\n            return_indices = self.indices | arg.indices\n\n        try:\n            return_glue = linearlogic.ApplicationExpression(\n                self.glue, arg.glue, arg.indices\n            )\n        except linearlogic.LinearLogicApplicationException as e:\n            raise linearlogic.LinearLogicApplicationException(\n                f\"'{self.simplify()}' applied to '{arg.simplify()}'\"\n            ) from e\n\n        arg_meaning_abstracted = arg.meaning\n        if return_indices:\n            for dep in self.glue.simplify().antecedent.dependencies[\n                ::-1\n            ]:  # if self.glue is (A -o B), dep is in A.dependencies\n                arg_meaning_abstracted = self.make_LambdaExpression(\n                    Variable(\"v%s\" % dep), arg_meaning_abstracted\n                )\n        return_meaning = self.meaning.applyto(arg_meaning_abstracted)\n\n        return self.__class__(return_meaning, return_glue, return_indices)\n\n    def make_VariableExpression(self, name):\n        return VariableExpression(name)\n\n    def make_LambdaExpression(self, variable, term):\n        return LambdaExpression(variable, term)\n\n    def lambda_abstract(self, other):\n        assert isinstance(other, GlueFormula)\n        assert isinstance(other.meaning, AbstractVariableExpression)\n        return self.__class__(\n            self.make_LambdaExpression(other.meaning.variable, self.meaning),\n            linearlogic.ImpExpression(other.glue, self.glue),\n        )\n\n    def compile(self, counter=None):\n        \"\"\"From Iddo Lev's PhD Dissertation p108-109\"\"\"\n        if not counter:\n            counter = Counter()\n        (compiled_glue, new_forms) = self.glue.simplify().compile_pos(\n            counter, self.__class__\n        )\n        return new_forms + [\n            self.__class__(self.meaning, compiled_glue, {counter.get()})\n        ]\n\n    def simplify(self):\n        return self.__class__(\n            self.meaning.simplify(), self.glue.simplify(), self.indices\n        )\n\n    def __eq__(self, other):\n        return (\n            self.__class__ == other.__class__\n            and self.meaning == other.meaning\n            and self.glue == other.glue\n        )\n\n    def __ne__(self, other):\n        return not self == other\n\n    # sorting for use in doctests which must be deterministic\n    def __lt__(self, other):\n        return str(self) < str(other)\n\n    def __str__(self):\n        assert isinstance(self.indices, set)\n        accum = f\"{self.meaning} : {self.glue}\"\n        if self.indices:\n            accum += (\n                \" : {\" + \", \".join(str(index) for index in sorted(self.indices)) + \"}\"\n            )\n        return accum\n\n    def __repr__(self):\n        return \"%s\" % self\n\n\nclass GlueDict(dict):\n    def __init__(self, filename, encoding=None):\n        self.filename = filename\n        self.file_encoding = encoding\n        self.read_file()\n\n    def read_file(self, empty_first=True):\n        if empty_first:\n            self.clear()\n\n        try:\n            contents = nltk.data.load(\n                self.filename, format=\"text\", encoding=self.file_encoding\n            )\n            # TODO: the above can't handle zip files, but this should anyway be fixed in nltk.data.load()\n        except LookupError as e:\n            try:\n                contents = nltk.data.load(\n                    \"file:\" + self.filename, format=\"text\", encoding=self.file_encoding\n                )\n            except LookupError:\n                raise e\n        lines = contents.splitlines()\n\n        for line in lines:  # example: 'n : (\\\\x.(<word> x), (v-or))'\n            #     lambdacalc -^  linear logic -^\n            line = line.strip()  # remove trailing newline\n            if not len(line):\n                continue  # skip empty lines\n            if line[0] == \"#\":\n                continue  # skip commented out lines\n\n            parts = line.split(\n                \" : \", 2\n            )  # ['verb', '(\\\\x.(<word> x), ( subj -o f ))', '[subj]']\n\n            glue_formulas = []\n            paren_count = 0\n            tuple_start = 0\n            tuple_comma = 0\n\n            relationships = None\n\n            if len(parts) > 1:\n                for (i, c) in enumerate(parts[1]):\n                    if c == \"(\":\n                        if paren_count == 0:  # if it's the first '(' of a tuple\n                            tuple_start = i + 1  # then save the index\n                        paren_count += 1\n                    elif c == \")\":\n                        paren_count -= 1\n                        if paren_count == 0:  # if it's the last ')' of a tuple\n                            meaning_term = parts[1][\n                                tuple_start:tuple_comma\n                            ]  # '\\\\x.(<word> x)'\n                            glue_term = parts[1][tuple_comma + 1 : i]  # '(v-r)'\n                            glue_formulas.append(\n                                [meaning_term, glue_term]\n                            )  # add the GlueFormula to the list\n                    elif c == \",\":\n                        if (\n                            paren_count == 1\n                        ):  # if it's a comma separating the parts of the tuple\n                            tuple_comma = i  # then save the index\n                    elif c == \"#\":  # skip comments at the ends of lines\n                        if (\n                            paren_count != 0\n                        ):  # if the line hasn't parsed correctly so far\n                            raise RuntimeError(\n                                \"Formula syntax is incorrect for entry \" + line\n                            )\n                        break  # break to the next line\n\n            if len(parts) > 2:  # if there is a relationship entry at the end\n                rel_start = parts[2].index(\"[\") + 1\n                rel_end = parts[2].index(\"]\")\n                if rel_start == rel_end:\n                    relationships = frozenset()\n                else:\n                    relationships = frozenset(\n                        r.strip() for r in parts[2][rel_start:rel_end].split(\",\")\n                    )\n\n            try:\n                start_inheritance = parts[0].index(\"(\")\n                end_inheritance = parts[0].index(\")\")\n                sem = parts[0][:start_inheritance].strip()\n                supertype = parts[0][start_inheritance + 1 : end_inheritance]\n            except:\n                sem = parts[0].strip()\n                supertype = None\n\n            if sem not in self:\n                self[sem] = {}\n\n            if (\n                relationships is None\n            ):  # if not specified for a specific relationship set\n                # add all relationship entries for parents\n                if supertype:\n                    for rels in self[supertype]:\n                        if rels not in self[sem]:\n                            self[sem][rels] = []\n                        glue = self[supertype][rels]\n                        self[sem][rels].extend(glue)\n                        self[sem][rels].extend(\n                            glue_formulas\n                        )  # add the glue formulas to every rel entry\n                else:\n                    if None not in self[sem]:\n                        self[sem][None] = []\n                    self[sem][None].extend(\n                        glue_formulas\n                    )  # add the glue formulas to every rel entry\n            else:\n                if relationships not in self[sem]:\n                    self[sem][relationships] = []\n                if supertype:\n                    self[sem][relationships].extend(self[supertype][relationships])\n                self[sem][relationships].extend(\n                    glue_formulas\n                )  # add the glue entry to the dictionary\n\n    def __str__(self):\n        accum = \"\"\n        for pos in self:\n            str_pos = \"%s\" % pos\n            for relset in self[pos]:\n                i = 1\n                for gf in self[pos][relset]:\n                    if i == 1:\n                        accum += str_pos + \": \"\n                    else:\n                        accum += \" \" * (len(str_pos) + 2)\n                    accum += \"%s\" % gf\n                    if relset and i == len(self[pos][relset]):\n                        accum += \" : %s\" % relset\n                    accum += \"\\n\"\n                    i += 1\n        return accum\n\n    def to_glueformula_list(self, depgraph, node=None, counter=None, verbose=False):\n        if node is None:\n            # TODO: should it be depgraph.root? Is this code tested?\n            top = depgraph.nodes[0]\n            depList = list(chain.from_iterable(top[\"deps\"].values()))\n            root = depgraph.nodes[depList[0]]\n\n            return self.to_glueformula_list(depgraph, root, Counter(), verbose)\n\n        glueformulas = self.lookup(node, depgraph, counter)\n        for dep_idx in chain.from_iterable(node[\"deps\"].values()):\n            dep = depgraph.nodes[dep_idx]\n            glueformulas.extend(\n                self.to_glueformula_list(depgraph, dep, counter, verbose)\n            )\n        return glueformulas\n\n    def lookup(self, node, depgraph, counter):\n        semtype_names = self.get_semtypes(node)\n\n        semtype = None\n        for name in semtype_names:\n            if name in self:\n                semtype = self[name]\n                break\n        if semtype is None:\n            # raise KeyError, \"There is no GlueDict entry for sem type '%s' (for '%s')\" % (sem, word)\n            return []\n\n        self.add_missing_dependencies(node, depgraph)\n\n        lookup = self._lookup_semtype_option(semtype, node, depgraph)\n\n        if not len(lookup):\n            raise KeyError(\n                \"There is no GlueDict entry for sem type of '%s' \"\n                \"with tag '%s', and rel '%s'\" % (node[\"word\"], node[\"tag\"], node[\"rel\"])\n            )\n\n        return self.get_glueformulas_from_semtype_entry(\n            lookup, node[\"word\"], node, depgraph, counter\n        )\n\n    def add_missing_dependencies(self, node, depgraph):\n        rel = node[\"rel\"].lower()\n\n        if rel == \"main\":\n            headnode = depgraph.nodes[node[\"head\"]]\n            subj = self.lookup_unique(\"subj\", headnode, depgraph)\n            relation = subj[\"rel\"]\n            node[\"deps\"].setdefault(relation, [])\n            node[\"deps\"][relation].append(subj[\"address\"])\n            # node['deps'].append(subj['address'])\n\n    def _lookup_semtype_option(self, semtype, node, depgraph):\n        relationships = frozenset(\n            depgraph.nodes[dep][\"rel\"].lower()\n            for dep in chain.from_iterable(node[\"deps\"].values())\n            if depgraph.nodes[dep][\"rel\"].lower() not in OPTIONAL_RELATIONSHIPS\n        )\n\n        try:\n            lookup = semtype[relationships]\n        except KeyError:\n            # An exact match is not found, so find the best match where\n            # 'best' is defined as the glue entry whose relationship set has the\n            # most relations of any possible relationship set that is a subset\n            # of the actual depgraph\n            best_match = frozenset()\n            for relset_option in set(semtype) - {None}:\n                if (\n                    len(relset_option) > len(best_match)\n                    and relset_option < relationships\n                ):\n                    best_match = relset_option\n            if not best_match:\n                if None in semtype:\n                    best_match = None\n                else:\n                    return None\n            lookup = semtype[best_match]\n\n        return lookup\n\n    def get_semtypes(self, node):\n        \"\"\"\n        Based on the node, return a list of plausible semtypes in order of\n        plausibility.\n        \"\"\"\n        rel = node[\"rel\"].lower()\n        word = node[\"word\"].lower()\n\n        if rel == \"spec\":\n            if word in SPEC_SEMTYPES:\n                return [SPEC_SEMTYPES[word]]\n            else:\n                return [SPEC_SEMTYPES[\"default\"]]\n        elif rel in [\"nmod\", \"vmod\"]:\n            return [node[\"tag\"], rel]\n        else:\n            return [node[\"tag\"]]\n\n    def get_glueformulas_from_semtype_entry(\n        self, lookup, word, node, depgraph, counter\n    ):\n        glueformulas = []\n\n        glueFormulaFactory = self.get_GlueFormula_factory()\n        for meaning, glue in lookup:\n            gf = glueFormulaFactory(self.get_meaning_formula(meaning, word), glue)\n            if not len(glueformulas):\n                gf.word = word\n            else:\n                gf.word = f\"{word}{len(glueformulas) + 1}\"\n\n            gf.glue = self.initialize_labels(gf.glue, node, depgraph, counter.get())\n\n            glueformulas.append(gf)\n        return glueformulas\n\n    def get_meaning_formula(self, generic, word):\n        \"\"\"\n        :param generic: A meaning formula string containing the\n            parameter \"<word>\"\n        :param word: The actual word to be replace \"<word>\"\n        \"\"\"\n        word = word.replace(\".\", \"\")\n        return generic.replace(\"<word>\", word)\n\n    def initialize_labels(self, expr, node, depgraph, unique_index):\n        if isinstance(expr, linearlogic.AtomicExpression):\n            name = self.find_label_name(expr.name.lower(), node, depgraph, unique_index)\n            if name[0].isupper():\n                return linearlogic.VariableExpression(name)\n            else:\n                return linearlogic.ConstantExpression(name)\n        else:\n            return linearlogic.ImpExpression(\n                self.initialize_labels(expr.antecedent, node, depgraph, unique_index),\n                self.initialize_labels(expr.consequent, node, depgraph, unique_index),\n            )\n\n    def find_label_name(self, name, node, depgraph, unique_index):\n        try:\n            dot = name.index(\".\")\n\n            before_dot = name[:dot]\n            after_dot = name[dot + 1 :]\n            if before_dot == \"super\":\n                return self.find_label_name(\n                    after_dot, depgraph.nodes[node[\"head\"]], depgraph, unique_index\n                )\n            else:\n                return self.find_label_name(\n                    after_dot,\n                    self.lookup_unique(before_dot, node, depgraph),\n                    depgraph,\n                    unique_index,\n                )\n        except ValueError:\n            lbl = self.get_label(node)\n            if name == \"f\":\n                return lbl\n            elif name == \"v\":\n                return \"%sv\" % lbl\n            elif name == \"r\":\n                return \"%sr\" % lbl\n            elif name == \"super\":\n                return self.get_label(depgraph.nodes[node[\"head\"]])\n            elif name == \"var\":\n                return f\"{lbl.upper()}{unique_index}\"\n            elif name == \"a\":\n                return self.get_label(self.lookup_unique(\"conja\", node, depgraph))\n            elif name == \"b\":\n                return self.get_label(self.lookup_unique(\"conjb\", node, depgraph))\n            else:\n                return self.get_label(self.lookup_unique(name, node, depgraph))\n\n    def get_label(self, node):\n        \"\"\"\n        Pick an alphabetic character as identifier for an entity in the model.\n\n        :param value: where to index into the list of characters\n        :type value: int\n        \"\"\"\n        value = node[\"address\"]\n\n        letter = [\n            \"f\",\n            \"g\",\n            \"h\",\n            \"i\",\n            \"j\",\n            \"k\",\n            \"l\",\n            \"m\",\n            \"n\",\n            \"o\",\n            \"p\",\n            \"q\",\n            \"r\",\n            \"s\",\n            \"t\",\n            \"u\",\n            \"v\",\n            \"w\",\n            \"x\",\n            \"y\",\n            \"z\",\n            \"a\",\n            \"b\",\n            \"c\",\n            \"d\",\n            \"e\",\n        ][value - 1]\n        num = int(value) // 26\n        if num > 0:\n            return letter + str(num)\n        else:\n            return letter\n\n    def lookup_unique(self, rel, node, depgraph):\n        \"\"\"\n        Lookup 'key'. There should be exactly one item in the associated relation.\n        \"\"\"\n        deps = [\n            depgraph.nodes[dep]\n            for dep in chain.from_iterable(node[\"deps\"].values())\n            if depgraph.nodes[dep][\"rel\"].lower() == rel.lower()\n        ]\n\n        if len(deps) == 0:\n            raise KeyError(\n                \"'{}' doesn't contain a feature '{}'\".format(node[\"word\"], rel)\n            )\n        elif len(deps) > 1:\n            raise KeyError(\n                \"'{}' should only have one feature '{}'\".format(node[\"word\"], rel)\n            )\n        else:\n            return deps[0]\n\n    def get_GlueFormula_factory(self):\n        return GlueFormula\n\n\nclass Glue:\n    def __init__(\n        self, semtype_file=None, remove_duplicates=False, depparser=None, verbose=False\n    ):\n        self.verbose = verbose\n        self.remove_duplicates = remove_duplicates\n        self.depparser = depparser\n\n        from nltk import Prover9\n\n        self.prover = Prover9()\n\n        if semtype_file:\n            self.semtype_file = semtype_file\n        else:\n            self.semtype_file = os.path.join(\n                \"grammars\", \"sample_grammars\", \"glue.semtype\"\n            )\n\n    def train_depparser(self, depgraphs=None):\n        if depgraphs:\n            self.depparser.train(depgraphs)\n        else:\n            self.depparser.train_from_file(\n                nltk.data.find(\n                    os.path.join(\"grammars\", \"sample_grammars\", \"glue_train.conll\")\n                )\n            )\n\n    def parse_to_meaning(self, sentence):\n        readings = []\n        for agenda in self.parse_to_compiled(sentence):\n            readings.extend(self.get_readings(agenda))\n        return readings\n\n    def get_readings(self, agenda):\n        readings = []\n        agenda_length = len(agenda)\n        atomics = dict()\n        nonatomics = dict()\n        while agenda:  # is not empty\n            cur = agenda.pop()\n            glue_simp = cur.glue.simplify()\n            if isinstance(\n                glue_simp, linearlogic.ImpExpression\n            ):  # if cur.glue is non-atomic\n                for key in atomics:\n                    try:\n                        if isinstance(cur.glue, linearlogic.ApplicationExpression):\n                            bindings = cur.glue.bindings\n                        else:\n                            bindings = linearlogic.BindingDict()\n                        glue_simp.antecedent.unify(key, bindings)\n                        for atomic in atomics[key]:\n                            if not (\n                                cur.indices & atomic.indices\n                            ):  # if the sets of indices are disjoint\n                                try:\n                                    agenda.append(cur.applyto(atomic))\n                                except linearlogic.LinearLogicApplicationException:\n                                    pass\n                    except linearlogic.UnificationException:\n                        pass\n                try:\n                    nonatomics[glue_simp.antecedent].append(cur)\n                except KeyError:\n                    nonatomics[glue_simp.antecedent] = [cur]\n\n            else:  # else cur.glue is atomic\n                for key in nonatomics:\n                    for nonatomic in nonatomics[key]:\n                        try:\n                            if isinstance(\n                                nonatomic.glue, linearlogic.ApplicationExpression\n                            ):\n                                bindings = nonatomic.glue.bindings\n                            else:\n                                bindings = linearlogic.BindingDict()\n                            glue_simp.unify(key, bindings)\n                            if not (\n                                cur.indices & nonatomic.indices\n                            ):  # if the sets of indices are disjoint\n                                try:\n                                    agenda.append(nonatomic.applyto(cur))\n                                except linearlogic.LinearLogicApplicationException:\n                                    pass\n                        except linearlogic.UnificationException:\n                            pass\n                try:\n                    atomics[glue_simp].append(cur)\n                except KeyError:\n                    atomics[glue_simp] = [cur]\n\n        for entry in atomics:\n            for gf in atomics[entry]:\n                if len(gf.indices) == agenda_length:\n                    self._add_to_reading_list(gf, readings)\n        for entry in nonatomics:\n            for gf in nonatomics[entry]:\n                if len(gf.indices) == agenda_length:\n                    self._add_to_reading_list(gf, readings)\n        return readings\n\n    def _add_to_reading_list(self, glueformula, reading_list):\n        add_reading = True\n        if self.remove_duplicates:\n            for reading in reading_list:\n                try:\n                    if reading.equiv(glueformula.meaning, self.prover):\n                        add_reading = False\n                        break\n                except Exception as e:\n                    # if there is an exception, the syntax of the formula\n                    # may not be understandable by the prover, so don't\n                    # throw out the reading.\n                    print(\"Error when checking logical equality of statements\", e)\n\n        if add_reading:\n            reading_list.append(glueformula.meaning)\n\n    def parse_to_compiled(self, sentence):\n        gfls = [self.depgraph_to_glue(dg) for dg in self.dep_parse(sentence)]\n        return [self.gfl_to_compiled(gfl) for gfl in gfls]\n\n    def dep_parse(self, sentence):\n        \"\"\"\n        Return a dependency graph for the sentence.\n\n        :param sentence: the sentence to be parsed\n        :type sentence: list(str)\n        :rtype: DependencyGraph\n        \"\"\"\n\n        # Lazy-initialize the depparser\n        if self.depparser is None:\n            from nltk.parse import MaltParser\n\n            self.depparser = MaltParser(tagger=self.get_pos_tagger())\n        if not self.depparser._trained:\n            self.train_depparser()\n        return self.depparser.parse(sentence, verbose=self.verbose)\n\n    def depgraph_to_glue(self, depgraph):\n        return self.get_glue_dict().to_glueformula_list(depgraph)\n\n    def get_glue_dict(self):\n        return GlueDict(self.semtype_file)\n\n    def gfl_to_compiled(self, gfl):\n        index_counter = Counter()\n        return_list = []\n        for gf in gfl:\n            return_list.extend(gf.compile(index_counter))\n\n        if self.verbose:\n            print(\"Compiled Glue Premises:\")\n            for cgf in return_list:\n                print(cgf)\n\n        return return_list\n\n    def get_pos_tagger(self):\n        from nltk.corpus import brown\n\n        regexp_tagger = RegexpTagger(\n            [\n                (r\"^-?[0-9]+(.[0-9]+)?$\", \"CD\"),  # cardinal numbers\n                (r\"(The|the|A|a|An|an)$\", \"AT\"),  # articles\n                (r\".*able$\", \"JJ\"),  # adjectives\n                (r\".*ness$\", \"NN\"),  # nouns formed from adjectives\n                (r\".*ly$\", \"RB\"),  # adverbs\n                (r\".*s$\", \"NNS\"),  # plural nouns\n                (r\".*ing$\", \"VBG\"),  # gerunds\n                (r\".*ed$\", \"VBD\"),  # past tense verbs\n                (r\".*\", \"NN\"),  # nouns (default)\n            ]\n        )\n        brown_train = brown.tagged_sents(categories=\"news\")\n        unigram_tagger = UnigramTagger(brown_train, backoff=regexp_tagger)\n        bigram_tagger = BigramTagger(brown_train, backoff=unigram_tagger)\n        trigram_tagger = TrigramTagger(brown_train, backoff=bigram_tagger)\n\n        # Override particular words\n        main_tagger = RegexpTagger(\n            [(r\"(A|a|An|an)$\", \"ex_quant\"), (r\"(Every|every|All|all)$\", \"univ_quant\")],\n            backoff=trigram_tagger,\n        )\n\n        return main_tagger\n\n\nclass DrtGlueFormula(GlueFormula):\n    def __init__(self, meaning, glue, indices=None):\n        if not indices:\n            indices = set()\n\n        if isinstance(meaning, str):\n            self.meaning = drt.DrtExpression.fromstring(meaning)\n        elif isinstance(meaning, drt.DrtExpression):\n            self.meaning = meaning\n        else:\n            raise RuntimeError(\n                \"Meaning term neither string or expression: %s, %s\"\n                % (meaning, meaning.__class__)\n            )\n\n        if isinstance(glue, str):\n            self.glue = linearlogic.LinearLogicParser().parse(glue)\n        elif isinstance(glue, linearlogic.Expression):\n            self.glue = glue\n        else:\n            raise RuntimeError(\n                \"Glue term neither string or expression: %s, %s\"\n                % (glue, glue.__class__)\n            )\n\n        self.indices = indices\n\n    def make_VariableExpression(self, name):\n        return drt.DrtVariableExpression(name)\n\n    def make_LambdaExpression(self, variable, term):\n        return drt.DrtLambdaExpression(variable, term)\n\n\nclass DrtGlueDict(GlueDict):\n    def get_GlueFormula_factory(self):\n        return DrtGlueFormula\n\n\nclass DrtGlue(Glue):\n    def __init__(\n        self, semtype_file=None, remove_duplicates=False, depparser=None, verbose=False\n    ):\n        if not semtype_file:\n            semtype_file = os.path.join(\n                \"grammars\", \"sample_grammars\", \"drt_glue.semtype\"\n            )\n        Glue.__init__(self, semtype_file, remove_duplicates, depparser, verbose)\n\n    def get_glue_dict(self):\n        return DrtGlueDict(self.semtype_file)\n\n\ndef demo(show_example=-1):\n    from nltk.parse import MaltParser\n\n    examples = [\n        \"David sees Mary\",\n        \"David eats a sandwich\",\n        \"every man chases a dog\",\n        \"every man believes a dog sleeps\",\n        \"John gives David a sandwich\",\n        \"John chases himself\",\n    ]\n    #                'John persuades David to order a pizza',\n    #                'John tries to go',\n    #                'John tries to find a unicorn',\n    #                'John seems to vanish',\n    #                'a unicorn seems to approach',\n    #                'every big cat leaves',\n    #                'every gray cat leaves',\n    #                'every big gray cat leaves',\n    #                'a former senator leaves',\n\n    print(\"============== DEMO ==============\")\n\n    tagger = RegexpTagger(\n        [\n            (\"^(David|Mary|John)$\", \"NNP\"),\n            (\n                \"^(sees|eats|chases|believes|gives|sleeps|chases|persuades|tries|seems|leaves)$\",\n                \"VB\",\n            ),\n            (\"^(go|order|vanish|find|approach)$\", \"VB\"),\n            (\"^(a)$\", \"ex_quant\"),\n            (\"^(every)$\", \"univ_quant\"),\n            (\"^(sandwich|man|dog|pizza|unicorn|cat|senator)$\", \"NN\"),\n            (\"^(big|gray|former)$\", \"JJ\"),\n            (\"^(him|himself)$\", \"PRP\"),\n        ]\n    )\n\n    depparser = MaltParser(tagger=tagger)\n    glue = Glue(depparser=depparser, verbose=False)\n\n    for (i, sentence) in enumerate(examples):\n        if i == show_example or show_example == -1:\n            print(f\"[[[Example {i}]]]  {sentence}\")\n            for reading in glue.parse_to_meaning(sentence.split()):\n                print(reading.simplify())\n            print(\"\")\n\n\nif __name__ == \"__main__\":\n    demo()\n", "# Natural Language Toolkit: Transformation-based learning\n#\n# Copyright (C) 2001-2021 NLTK Project\n# Author: Marcus Uneson <marcus.uneson@gmail.com>\n#   based on previous (nltk2) version by\n#   Christopher Maloof, Edward Loper, Steven Bird\n# URL: <https://www.nltk.org/>\n# For license information, see  LICENSE.TXT\n\nfrom collections import Counter, defaultdict\n\nfrom nltk import jsontags\nfrom nltk.tag import TaggerI\nfrom nltk.tbl import Feature, Template\n\n######################################################################\n# Brill Templates\n######################################################################\n\n\n@jsontags.register_tag\nclass Word(Feature):\n    \"\"\"\n    Feature which examines the text (word) of nearby tokens.\n    \"\"\"\n\n    json_tag = \"nltk.tag.brill.Word\"\n\n    @staticmethod\n    def extract_property(tokens, index):\n        \"\"\"@return: The given token's text.\"\"\"\n        return tokens[index][0]\n\n\n@jsontags.register_tag\nclass Pos(Feature):\n    \"\"\"\n    Feature which examines the tags of nearby tokens.\n    \"\"\"\n\n    json_tag = \"nltk.tag.brill.Pos\"\n\n    @staticmethod\n    def extract_property(tokens, index):\n        \"\"\"@return: The given token's tag.\"\"\"\n        return tokens[index][1]\n\n\ndef nltkdemo18():\n    \"\"\"\n    Return 18 templates, from the original nltk demo, in multi-feature syntax\n    \"\"\"\n    return [\n        Template(Pos([-1])),\n        Template(Pos([1])),\n        Template(Pos([-2])),\n        Template(Pos([2])),\n        Template(Pos([-2, -1])),\n        Template(Pos([1, 2])),\n        Template(Pos([-3, -2, -1])),\n        Template(Pos([1, 2, 3])),\n        Template(Pos([-1]), Pos([1])),\n        Template(Word([-1])),\n        Template(Word([1])),\n        Template(Word([-2])),\n        Template(Word([2])),\n        Template(Word([-2, -1])),\n        Template(Word([1, 2])),\n        Template(Word([-3, -2, -1])),\n        Template(Word([1, 2, 3])),\n        Template(Word([-1]), Word([1])),\n    ]\n\n\ndef nltkdemo18plus():\n    \"\"\"\n    Return 18 templates, from the original nltk demo, and additionally a few\n    multi-feature ones (the motivation is easy comparison with nltkdemo18)\n    \"\"\"\n    return nltkdemo18() + [\n        Template(Word([-1]), Pos([1])),\n        Template(Pos([-1]), Word([1])),\n        Template(Word([-1]), Word([0]), Pos([1])),\n        Template(Pos([-1]), Word([0]), Word([1])),\n        Template(Pos([-1]), Word([0]), Pos([1])),\n    ]\n\n\ndef fntbl37():\n    \"\"\"\n    Return 37 templates taken from the postagging task of the\n    fntbl distribution https://www.cs.jhu.edu/~rflorian/fntbl/\n    (37 is after excluding a handful which do not condition on Pos[0];\n    fntbl can do that but the current nltk implementation cannot.)\n    \"\"\"\n    return [\n        Template(Word([0]), Word([1]), Word([2])),\n        Template(Word([-1]), Word([0]), Word([1])),\n        Template(Word([0]), Word([-1])),\n        Template(Word([0]), Word([1])),\n        Template(Word([0]), Word([2])),\n        Template(Word([0]), Word([-2])),\n        Template(Word([1, 2])),\n        Template(Word([-2, -1])),\n        Template(Word([1, 2, 3])),\n        Template(Word([-3, -2, -1])),\n        Template(Word([0]), Pos([2])),\n        Template(Word([0]), Pos([-2])),\n        Template(Word([0]), Pos([1])),\n        Template(Word([0]), Pos([-1])),\n        Template(Word([0])),\n        Template(Word([-2])),\n        Template(Word([2])),\n        Template(Word([1])),\n        Template(Word([-1])),\n        Template(Pos([-1]), Pos([1])),\n        Template(Pos([1]), Pos([2])),\n        Template(Pos([-1]), Pos([-2])),\n        Template(Pos([1])),\n        Template(Pos([-1])),\n        Template(Pos([-2])),\n        Template(Pos([2])),\n        Template(Pos([1, 2, 3])),\n        Template(Pos([1, 2])),\n        Template(Pos([-3, -2, -1])),\n        Template(Pos([-2, -1])),\n        Template(Pos([1]), Word([0]), Word([1])),\n        Template(Pos([1]), Word([0]), Word([-1])),\n        Template(Pos([-1]), Word([-1]), Word([0])),\n        Template(Pos([-1]), Word([0]), Word([1])),\n        Template(Pos([-2]), Pos([-1])),\n        Template(Pos([1]), Pos([2])),\n        Template(Pos([1]), Pos([2]), Word([1])),\n    ]\n\n\ndef brill24():\n    \"\"\"\n    Return 24 templates of the seminal TBL paper, Brill (1995)\n    \"\"\"\n    return [\n        Template(Pos([-1])),\n        Template(Pos([1])),\n        Template(Pos([-2])),\n        Template(Pos([2])),\n        Template(Pos([-2, -1])),\n        Template(Pos([1, 2])),\n        Template(Pos([-3, -2, -1])),\n        Template(Pos([1, 2, 3])),\n        Template(Pos([-1]), Pos([1])),\n        Template(Pos([-2]), Pos([-1])),\n        Template(Pos([1]), Pos([2])),\n        Template(Word([-1])),\n        Template(Word([1])),\n        Template(Word([-2])),\n        Template(Word([2])),\n        Template(Word([-2, -1])),\n        Template(Word([1, 2])),\n        Template(Word([-1, 0])),\n        Template(Word([0, 1])),\n        Template(Word([0])),\n        Template(Word([-1]), Pos([-1])),\n        Template(Word([1]), Pos([1])),\n        Template(Word([0]), Word([-1]), Pos([-1])),\n        Template(Word([0]), Word([1]), Pos([1])),\n    ]\n\n\ndef describe_template_sets():\n    \"\"\"\n    Print the available template sets in this demo, with a short description\"\n    \"\"\"\n    import inspect\n    import sys\n\n    # a bit of magic to get all functions in this module\n    templatesets = inspect.getmembers(sys.modules[__name__], inspect.isfunction)\n    for (name, obj) in templatesets:\n        if name == \"describe_template_sets\":\n            continue\n        print(name, obj.__doc__, \"\\n\")\n\n\n######################################################################\n# The Brill Tagger\n######################################################################\n\n\n@jsontags.register_tag\nclass BrillTagger(TaggerI):\n    \"\"\"\n    Brill's transformational rule-based tagger.  Brill taggers use an\n    initial tagger (such as ``tag.DefaultTagger``) to assign an initial\n    tag sequence to a text; and then apply an ordered list of\n    transformational rules to correct the tags of individual tokens.\n    These transformation rules are specified by the ``TagRule``\n    interface.\n\n    Brill taggers can be created directly, from an initial tagger and\n    a list of transformational rules; but more often, Brill taggers\n    are created by learning rules from a training corpus, using one\n    of the TaggerTrainers available.\n    \"\"\"\n\n    json_tag = \"nltk.tag.BrillTagger\"\n\n    def __init__(self, initial_tagger, rules, training_stats=None):\n        \"\"\"\n        :param initial_tagger: The initial tagger\n        :type initial_tagger: TaggerI\n\n        :param rules: An ordered list of transformation rules that\n            should be used to correct the initial tagging.\n        :type rules: list(TagRule)\n\n        :param training_stats: A dictionary of statistics collected\n            during training, for possible later use\n        :type training_stats: dict\n\n        \"\"\"\n        self._initial_tagger = initial_tagger\n        self._rules = tuple(rules)\n        self._training_stats = training_stats\n\n    def encode_json_obj(self):\n        return self._initial_tagger, self._rules, self._training_stats\n\n    @classmethod\n    def decode_json_obj(cls, obj):\n        _initial_tagger, _rules, _training_stats = obj\n        return cls(_initial_tagger, _rules, _training_stats)\n\n    def rules(self):\n        \"\"\"\n        Return the ordered list of  transformation rules that this tagger has learnt\n\n        :return: the ordered list of transformation rules that correct the initial tagging\n        :rtype: list of Rules\n        \"\"\"\n        return self._rules\n\n    def train_stats(self, statistic=None):\n        \"\"\"\n        Return a named statistic collected during training, or a dictionary of all\n        available statistics if no name given\n\n        :param statistic: name of statistic\n        :type statistic: str\n        :return: some statistic collected during training of this tagger\n        :rtype: any (but usually a number)\n        \"\"\"\n        if statistic is None:\n            return self._training_stats\n        else:\n            return self._training_stats.get(statistic)\n\n    def tag(self, tokens):\n        # Inherit documentation from TaggerI\n\n        # Run the initial tagger.\n        tagged_tokens = self._initial_tagger.tag(tokens)\n\n        # Create a dictionary that maps each tag to a list of the\n        # indices of tokens that have that tag.\n        tag_to_positions = defaultdict(set)\n        for i, (token, tag) in enumerate(tagged_tokens):\n            tag_to_positions[tag].add(i)\n\n        # Apply each rule, in order.  Only try to apply rules at\n        # positions that have the desired original tag.\n        for rule in self._rules:\n            # Find the positions where it might apply\n            positions = tag_to_positions.get(rule.original_tag, [])\n            # Apply the rule at those positions.\n            changed = rule.apply(tagged_tokens, positions)\n            # Update tag_to_positions with the positions of tags that\n            # were modified.\n            for i in changed:\n                tag_to_positions[rule.original_tag].remove(i)\n                tag_to_positions[rule.replacement_tag].add(i)\n\n        return tagged_tokens\n\n    def print_template_statistics(self, test_stats=None, printunused=True):\n        \"\"\"\n        Print a list of all templates, ranked according to efficiency.\n\n        If test_stats is available, the templates are ranked according to their\n        relative contribution (summed for all rules created from a given template,\n        weighted by score) to the performance on the test set. If no test_stats, then\n        statistics collected during training are used instead. There is also\n        an unweighted measure (just counting the rules). This is less informative,\n        though, as many low-score rules will appear towards end of training.\n\n        :param test_stats: dictionary of statistics collected during testing\n        :type test_stats: dict of str -> any (but usually numbers)\n        :param printunused: if True, print a list of all unused templates\n        :type printunused: bool\n        :return: None\n        :rtype: None\n        \"\"\"\n        tids = [r.templateid for r in self._rules]\n        train_stats = self.train_stats()\n\n        trainscores = train_stats[\"rulescores\"]\n        assert len(trainscores) == len(\n            tids\n        ), \"corrupt statistics: \" \"{} train scores for {} rules\".format(\n            trainscores, tids\n        )\n        template_counts = Counter(tids)\n        weighted_traincounts = Counter()\n        for (tid, score) in zip(tids, trainscores):\n            weighted_traincounts[tid] += score\n        tottrainscores = sum(trainscores)\n\n        # det_tplsort() is for deterministic sorting;\n        # the otherwise convenient Counter.most_common() unfortunately\n        # does not break ties deterministically\n        # between python versions and will break cross-version tests\n        def det_tplsort(tpl_value):\n            return (tpl_value[1], repr(tpl_value[0]))\n\n        def print_train_stats():\n            print(\n                \"TEMPLATE STATISTICS (TRAIN)  {} templates, {} rules)\".format(\n                    len(template_counts), len(tids)\n                )\n            )\n            print(\n                \"TRAIN ({tokencount:7d} tokens) initial {initialerrors:5d} {initialacc:.4f} \"\n                \"final: {finalerrors:5d} {finalacc:.4f} \".format(**train_stats)\n            )\n            head = \"#ID | Score (train) |  #Rules     | Template\"\n            print(head, \"\\n\", \"-\" * len(head), sep=\"\")\n            train_tplscores = sorted(\n                weighted_traincounts.items(), key=det_tplsort, reverse=True\n            )\n            for (tid, trainscore) in train_tplscores:\n                s = \"{} | {:5d}   {:5.3f} |{:4d}   {:.3f} | {}\".format(\n                    tid,\n                    trainscore,\n                    trainscore / tottrainscores,\n                    template_counts[tid],\n                    template_counts[tid] / len(tids),\n                    Template.ALLTEMPLATES[int(tid)],\n                )\n                print(s)\n\n        def print_testtrain_stats():\n            testscores = test_stats[\"rulescores\"]\n            print(\n                \"TEMPLATE STATISTICS (TEST AND TRAIN) ({} templates, {} rules)\".format(\n                    len(template_counts), len(tids)\n                )\n            )\n            print(\n                \"TEST  ({tokencount:7d} tokens) initial {initialerrors:5d} {initialacc:.4f} \"\n                \"final: {finalerrors:5d} {finalacc:.4f} \".format(**test_stats)\n            )\n            print(\n                \"TRAIN ({tokencount:7d} tokens) initial {initialerrors:5d} {initialacc:.4f} \"\n                \"final: {finalerrors:5d} {finalacc:.4f} \".format(**train_stats)\n            )\n            weighted_testcounts = Counter()\n            for (tid, score) in zip(tids, testscores):\n                weighted_testcounts[tid] += score\n            tottestscores = sum(testscores)\n            head = \"#ID | Score (test) | Score (train) |  #Rules     | Template\"\n            print(head, \"\\n\", \"-\" * len(head), sep=\"\")\n            test_tplscores = sorted(\n                weighted_testcounts.items(), key=det_tplsort, reverse=True\n            )\n            for (tid, testscore) in test_tplscores:\n                s = \"{:s} |{:5d}  {:6.3f} |  {:4d}   {:.3f} |{:4d}   {:.3f} | {:s}\".format(\n                    tid,\n                    testscore,\n                    testscore / tottestscores,\n                    weighted_traincounts[tid],\n                    weighted_traincounts[tid] / tottrainscores,\n                    template_counts[tid],\n                    template_counts[tid] / len(tids),\n                    Template.ALLTEMPLATES[int(tid)],\n                )\n                print(s)\n\n        def print_unused_templates():\n            usedtpls = {int(tid) for tid in tids}\n            unused = [\n                (tid, tpl)\n                for (tid, tpl) in enumerate(Template.ALLTEMPLATES)\n                if tid not in usedtpls\n            ]\n            print(f\"UNUSED TEMPLATES ({len(unused)})\")\n\n            for (tid, tpl) in unused:\n                print(f\"{tid:03d} {str(tpl):s}\")\n\n        if test_stats is None:\n            print_train_stats()\n        else:\n            print_testtrain_stats()\n        print()\n        if printunused:\n            print_unused_templates()\n        print()\n\n    def batch_tag_incremental(self, sequences, gold):\n        \"\"\"\n        Tags by applying each rule to the entire corpus (rather than all rules to a\n        single sequence). The point is to collect statistics on the test set for\n        individual rules.\n\n        NOTE: This is inefficient (does not build any index, so will traverse the entire\n        corpus N times for N rules) -- usually you would not care about statistics for\n        individual rules and thus use batch_tag() instead\n\n        :param sequences: lists of token sequences (sentences, in some applications) to be tagged\n        :type sequences: list of list of strings\n        :param gold: the gold standard\n        :type gold: list of list of strings\n        :returns: tuple of (tagged_sequences, ordered list of rule scores (one for each rule))\n        \"\"\"\n\n        def counterrors(xs):\n            return sum(t[1] != g[1] for pair in zip(xs, gold) for (t, g) in zip(*pair))\n\n        testing_stats = {}\n        testing_stats[\"tokencount\"] = sum(len(t) for t in sequences)\n        testing_stats[\"sequencecount\"] = len(sequences)\n        tagged_tokenses = [self._initial_tagger.tag(tokens) for tokens in sequences]\n        testing_stats[\"initialerrors\"] = counterrors(tagged_tokenses)\n        testing_stats[\"initialacc\"] = (\n            1 - testing_stats[\"initialerrors\"] / testing_stats[\"tokencount\"]\n        )\n        # Apply each rule to the entire corpus, in order\n        errors = [testing_stats[\"initialerrors\"]]\n        for rule in self._rules:\n            for tagged_tokens in tagged_tokenses:\n                rule.apply(tagged_tokens)\n            errors.append(counterrors(tagged_tokenses))\n        testing_stats[\"rulescores\"] = [\n            err0 - err1 for (err0, err1) in zip(errors, errors[1:])\n        ]\n        testing_stats[\"finalerrors\"] = errors[-1]\n        testing_stats[\"finalacc\"] = (\n            1 - testing_stats[\"finalerrors\"] / testing_stats[\"tokencount\"]\n        )\n        return (tagged_tokenses, testing_stats)\n", "# Natural Language Toolkit: Transformation-based learning\n#\n# Copyright (C) 2001-2013 NLTK Project\n# Author: Marcus Uneson <marcus.uneson@gmail.com>\n#   based on previous (nltk2) version by\n#   Christopher Maloof, Edward Loper, Steven Bird\n# URL: <https://www.nltk.org/>\n# For license information, see  LICENSE.TXT\n\nimport bisect\nimport textwrap\nfrom collections import defaultdict\n\nfrom nltk.tag import BrillTagger, untag\n\n######################################################################\n#  Brill Tagger Trainer\n######################################################################\n\n\nclass BrillTaggerTrainer:\n    \"\"\"\n    A trainer for tbl taggers.\n    \"\"\"\n\n    def __init__(\n        self, initial_tagger, templates, trace=0, deterministic=None, ruleformat=\"str\"\n    ):\n        \"\"\"\n        Construct a Brill tagger from a baseline tagger and a\n        set of templates\n\n        :param initial_tagger: the baseline tagger\n        :type initial_tagger: Tagger\n        :param templates: templates to be used in training\n        :type templates: list of Templates\n        :param trace: verbosity level\n        :type trace: int\n        :param deterministic: if True, adjudicate ties deterministically\n        :type deterministic: bool\n        :param ruleformat: format of reported Rules\n        :type ruleformat: str\n        :return: An untrained BrillTagger\n        :rtype: BrillTagger\n        \"\"\"\n\n        if deterministic is None:\n            deterministic = trace > 0\n        self._initial_tagger = initial_tagger\n        self._templates = templates\n        self._trace = trace\n        self._deterministic = deterministic\n        self._ruleformat = ruleformat\n\n        self._tag_positions = None\n        \"\"\"Mapping from tags to lists of positions that use that tag.\"\"\"\n\n        self._rules_by_position = None\n        \"\"\"Mapping from positions to the set of rules that are known\n           to occur at that position.  Position is (sentnum, wordnum).\n           Initially, this will only contain positions where each rule\n           applies in a helpful way; but when we examine a rule, we'll\n           extend this list to also include positions where each rule\n           applies in a harmful or neutral way.\"\"\"\n\n        self._positions_by_rule = None\n        \"\"\"Mapping from rule to position to effect, specifying the\n           effect that each rule has on the overall score, at each\n           position.  Position is (sentnum, wordnum); and effect is\n           -1, 0, or 1.  As with _rules_by_position, this mapping starts\n           out only containing rules with positive effects; but when\n           we examine a rule, we'll extend this mapping to include\n           the positions where the rule is harmful or neutral.\"\"\"\n\n        self._rules_by_score = None\n        \"\"\"Mapping from scores to the set of rules whose effect on the\n           overall score is upper bounded by that score.  Invariant:\n           rulesByScore[s] will contain r iff the sum of\n           _positions_by_rule[r] is s.\"\"\"\n\n        self._rule_scores = None\n        \"\"\"Mapping from rules to upper bounds on their effects on the\n           overall score.  This is the inverse mapping to _rules_by_score.\n           Invariant: ruleScores[r] = sum(_positions_by_rule[r])\"\"\"\n\n        self._first_unknown_position = None\n        \"\"\"Mapping from rules to the first position where we're unsure\n           if the rule applies.  This records the next position we\n           need to check to see if the rule messed anything up.\"\"\"\n\n    # Training\n\n    def train(self, train_sents, max_rules=200, min_score=2, min_acc=None):\n        \"\"\"\n        Trains the Brill tagger on the corpus *train_sents*,\n        producing at most *max_rules* transformations, each of which\n        reduces the net number of errors in the corpus by at least\n        *min_score*, and each of which has accuracy not lower than\n        *min_acc*.\n\n        >>> # Relevant imports\n        >>> from nltk.tbl.template import Template\n        >>> from nltk.tag.brill import Pos, Word\n        >>> from nltk.tag import untag, RegexpTagger, BrillTaggerTrainer\n\n        >>> # Load some data\n        >>> from nltk.corpus import treebank\n        >>> training_data = treebank.tagged_sents()[:100]\n        >>> baseline_data = treebank.tagged_sents()[100:200]\n        >>> gold_data = treebank.tagged_sents()[200:300]\n        >>> testing_data = [untag(s) for s in gold_data]\n\n        >>> backoff = RegexpTagger([\n        ... (r'^-?[0-9]+(.[0-9]+)?$', 'CD'),   # cardinal numbers\n        ... (r'(The|the|A|a|An|an)$', 'AT'),   # articles\n        ... (r'.*able$', 'JJ'),                # adjectives\n        ... (r'.*ness$', 'NN'),                # nouns formed from adjectives\n        ... (r'.*ly$', 'RB'),                  # adverbs\n        ... (r'.*s$', 'NNS'),                  # plural nouns\n        ... (r'.*ing$', 'VBG'),                # gerunds\n        ... (r'.*ed$', 'VBD'),                 # past tense verbs\n        ... (r'.*', 'NN')                      # nouns (default)\n        ... ])\n\n        >>> baseline = backoff #see NOTE1\n\n        >>> baseline.evaluate(gold_data) #doctest: +ELLIPSIS\n        0.2450142...\n\n        >>> # Set up templates\n        >>> Template._cleartemplates() #clear any templates created in earlier tests\n        >>> templates = [Template(Pos([-1])), Template(Pos([-1]), Word([0]))]\n\n        >>> # Construct a BrillTaggerTrainer\n        >>> tt = BrillTaggerTrainer(baseline, templates, trace=3)\n\n        >>> tagger1 = tt.train(training_data, max_rules=10)\n        TBL train (fast) (seqs: 100; tokens: 2417; tpls: 2; min score: 2; min acc: None)\n        Finding initial useful rules...\n            Found 845 useful rules.\n        <BLANKLINE>\n                   B      |\n           S   F   r   O  |        Score = Fixed - Broken\n           c   i   o   t  |  R     Fixed = num tags changed incorrect -> correct\n           o   x   k   h  |  u     Broken = num tags changed correct -> incorrect\n           r   e   e   e  |  l     Other = num tags changed incorrect -> incorrect\n           e   d   n   r  |  e\n        ------------------+-------------------------------------------------------\n         132 132   0   0  | AT->DT if Pos:NN@[-1]\n          85  85   0   0  | NN->, if Pos:NN@[-1] & Word:,@[0]\n          69  69   0   0  | NN->. if Pos:NN@[-1] & Word:.@[0]\n          51  51   0   0  | NN->IN if Pos:NN@[-1] & Word:of@[0]\n          47  63  16 161  | NN->IN if Pos:NNS@[-1]\n          33  33   0   0  | NN->TO if Pos:NN@[-1] & Word:to@[0]\n          26  26   0   0  | IN->. if Pos:NNS@[-1] & Word:.@[0]\n          24  24   0   0  | IN->, if Pos:NNS@[-1] & Word:,@[0]\n          22  27   5  24  | NN->-NONE- if Pos:VBD@[-1]\n          17  17   0   0  | NN->CC if Pos:NN@[-1] & Word:and@[0]\n\n        >>> tagger1.rules()[1:3]\n        (Rule('001', 'NN', ',', [(Pos([-1]),'NN'), (Word([0]),',')]), Rule('001', 'NN', '.', [(Pos([-1]),'NN'), (Word([0]),'.')]))\n\n        >>> train_stats = tagger1.train_stats()\n        >>> [train_stats[stat] for stat in ['initialerrors', 'finalerrors', 'rulescores']]\n        [1775, 1269, [132, 85, 69, 51, 47, 33, 26, 24, 22, 17]]\n\n        >>> tagger1.print_template_statistics(printunused=False)\n        TEMPLATE STATISTICS (TRAIN)  2 templates, 10 rules)\n        TRAIN (   2417 tokens) initial  1775 0.2656 final:  1269 0.4750\n        #ID | Score (train) |  #Rules     | Template\n        --------------------------------------------\n        001 |   305   0.603 |   7   0.700 | Template(Pos([-1]),Word([0]))\n        000 |   201   0.397 |   3   0.300 | Template(Pos([-1]))\n        <BLANKLINE>\n        <BLANKLINE>\n\n        >>> tagger1.evaluate(gold_data) # doctest: +ELLIPSIS\n        0.43996...\n\n        >>> tagged, test_stats = tagger1.batch_tag_incremental(testing_data, gold_data)\n\n        >>> tagged[33][12:] == [('foreign', 'IN'), ('debt', 'NN'), ('of', 'IN'), ('$', 'NN'), ('64', 'CD'),\n        ... ('billion', 'NN'), ('*U*', 'NN'), ('--', 'NN'), ('the', 'DT'), ('third-highest', 'NN'), ('in', 'NN'),\n        ... ('the', 'DT'), ('developing', 'VBG'), ('world', 'NN'), ('.', '.')]\n        True\n\n        >>> [test_stats[stat] for stat in ['initialerrors', 'finalerrors', 'rulescores']]\n        [1855, 1376, [100, 85, 67, 58, 27, 36, 27, 16, 31, 32]]\n\n        >>> # A high-accuracy tagger\n        >>> tagger2 = tt.train(training_data, max_rules=10, min_acc=0.99)\n        TBL train (fast) (seqs: 100; tokens: 2417; tpls: 2; min score: 2; min acc: 0.99)\n        Finding initial useful rules...\n            Found 845 useful rules.\n        <BLANKLINE>\n                   B      |\n           S   F   r   O  |        Score = Fixed - Broken\n           c   i   o   t  |  R     Fixed = num tags changed incorrect -> correct\n           o   x   k   h  |  u     Broken = num tags changed correct -> incorrect\n           r   e   e   e  |  l     Other = num tags changed incorrect -> incorrect\n           e   d   n   r  |  e\n        ------------------+-------------------------------------------------------\n         132 132   0   0  | AT->DT if Pos:NN@[-1]\n          85  85   0   0  | NN->, if Pos:NN@[-1] & Word:,@[0]\n          69  69   0   0  | NN->. if Pos:NN@[-1] & Word:.@[0]\n          51  51   0   0  | NN->IN if Pos:NN@[-1] & Word:of@[0]\n          36  36   0   0  | NN->TO if Pos:NN@[-1] & Word:to@[0]\n          26  26   0   0  | NN->. if Pos:NNS@[-1] & Word:.@[0]\n          24  24   0   0  | NN->, if Pos:NNS@[-1] & Word:,@[0]\n          19  19   0   6  | NN->VB if Pos:TO@[-1]\n          18  18   0   0  | CD->-NONE- if Pos:NN@[-1] & Word:0@[0]\n          18  18   0   0  | NN->CC if Pos:NN@[-1] & Word:and@[0]\n\n        >>> tagger2.evaluate(gold_data)  # doctest: +ELLIPSIS\n        0.44159544...\n        >>> tagger2.rules()[2:4]\n        (Rule('001', 'NN', '.', [(Pos([-1]),'NN'), (Word([0]),'.')]), Rule('001', 'NN', 'IN', [(Pos([-1]),'NN'), (Word([0]),'of')]))\n\n        # NOTE1: (!!FIXME) A far better baseline uses nltk.tag.UnigramTagger,\n        # with a RegexpTagger only as backoff. For instance,\n        # >>> baseline = UnigramTagger(baseline_data, backoff=backoff)\n        # However, as of Nov 2013, nltk.tag.UnigramTagger does not yield consistent results\n        # between python versions. The simplistic backoff above is a workaround to make doctests\n        # get consistent input.\n\n        :param train_sents: training data\n        :type train_sents: list(list(tuple))\n        :param max_rules: output at most max_rules rules\n        :type max_rules: int\n        :param min_score: stop training when no rules better than min_score can be found\n        :type min_score: int\n        :param min_acc: discard any rule with lower accuracy than min_acc\n        :type min_acc: float or None\n        :return: the learned tagger\n        :rtype: BrillTagger\n        \"\"\"\n        # FIXME: several tests are a bit too dependent on tracing format\n        # FIXME: tests in trainer.fast and trainer.brillorig are exact duplicates\n\n        # Basic idea: Keep track of the rules that apply at each position.\n        # And keep track of the positions to which each rule applies.\n\n        # Create a new copy of the training corpus, and run the\n        # initial tagger on it.  We will progressively update this\n        # test corpus to look more like the training corpus.\n        test_sents = [\n            list(self._initial_tagger.tag(untag(sent))) for sent in train_sents\n        ]\n\n        # Collect some statistics on the training process\n        trainstats = {}\n        trainstats[\"min_acc\"] = min_acc\n        trainstats[\"min_score\"] = min_score\n        trainstats[\"tokencount\"] = sum(len(t) for t in test_sents)\n        trainstats[\"sequencecount\"] = len(test_sents)\n        trainstats[\"templatecount\"] = len(self._templates)\n        trainstats[\"rulescores\"] = []\n        trainstats[\"initialerrors\"] = sum(\n            tag[1] != truth[1]\n            for paired in zip(test_sents, train_sents)\n            for (tag, truth) in zip(*paired)\n        )\n        trainstats[\"initialacc\"] = (\n            1 - trainstats[\"initialerrors\"] / trainstats[\"tokencount\"]\n        )\n        if self._trace > 0:\n            print(\n                \"TBL train (fast) (seqs: {sequencecount}; tokens: {tokencount}; \"\n                \"tpls: {templatecount}; min score: {min_score}; min acc: {min_acc})\".format(\n                    **trainstats\n                )\n            )\n\n        # Initialize our mappings.  This will find any errors made\n        # by the initial tagger, and use those to generate repair\n        # rules, which are added to the rule mappings.\n        if self._trace:\n            print(\"Finding initial useful rules...\")\n        self._init_mappings(test_sents, train_sents)\n        if self._trace:\n            print(f\"    Found {len(self._rule_scores)} useful rules.\")\n\n        # Let the user know what we're up to.\n        if self._trace > 2:\n            self._trace_header()\n        elif self._trace == 1:\n            print(\"Selecting rules...\")\n\n        # Repeatedly select the best rule, and add it to `rules`.\n        rules = []\n        try:\n            while len(rules) < max_rules:\n                # Find the best rule, and add it to our rule list.\n                rule = self._best_rule(train_sents, test_sents, min_score, min_acc)\n                if rule:\n                    rules.append(rule)\n                    score = self._rule_scores[rule]\n                    trainstats[\"rulescores\"].append(score)\n                else:\n                    break  # No more good rules left!\n\n                # Report the rule that we found.\n                if self._trace > 1:\n                    self._trace_rule(rule)\n\n                # Apply the new rule at the relevant sites\n                self._apply_rule(rule, test_sents)\n\n                # Update _tag_positions[rule.original_tag] and\n                # _tag_positions[rule.replacement_tag] for the affected\n                # positions (i.e., self._positions_by_rule[rule]).\n                self._update_tag_positions(rule)\n\n                # Update rules that were affected by the change.\n                self._update_rules(rule, train_sents, test_sents)\n\n        # The user can cancel training manually:\n        except KeyboardInterrupt:\n            print(f\"Training stopped manually -- {len(rules)} rules found\")\n\n        # Discard our tag position mapping & rule mappings.\n        self._clean()\n        trainstats[\"finalerrors\"] = trainstats[\"initialerrors\"] - sum(\n            trainstats[\"rulescores\"]\n        )\n        trainstats[\"finalacc\"] = (\n            1 - trainstats[\"finalerrors\"] / trainstats[\"tokencount\"]\n        )\n        # Create and return a tagger from the rules we found.\n        return BrillTagger(self._initial_tagger, rules, trainstats)\n\n    def _init_mappings(self, test_sents, train_sents):\n        \"\"\"\n        Initialize the tag position mapping & the rule related\n        mappings.  For each error in test_sents, find new rules that\n        would correct them, and add them to the rule mappings.\n        \"\"\"\n        self._tag_positions = defaultdict(list)\n        self._rules_by_position = defaultdict(set)\n        self._positions_by_rule = defaultdict(dict)\n        self._rules_by_score = defaultdict(set)\n        self._rule_scores = defaultdict(int)\n        self._first_unknown_position = defaultdict(int)\n        # Scan through the corpus, initializing the tag_positions\n        # mapping and all the rule-related mappings.\n        for sentnum, sent in enumerate(test_sents):\n            for wordnum, (word, tag) in enumerate(sent):\n\n                # Initialize tag_positions\n                self._tag_positions[tag].append((sentnum, wordnum))\n\n                # If it's an error token, update the rule-related mappings.\n                correct_tag = train_sents[sentnum][wordnum][1]\n                if tag != correct_tag:\n                    for rule in self._find_rules(sent, wordnum, correct_tag):\n                        self._update_rule_applies(rule, sentnum, wordnum, train_sents)\n\n    def _clean(self):\n        self._tag_positions = None\n        self._rules_by_position = None\n        self._positions_by_rule = None\n        self._rules_by_score = None\n        self._rule_scores = None\n        self._first_unknown_position = None\n\n    def _find_rules(self, sent, wordnum, new_tag):\n        \"\"\"\n        Use the templates to find rules that apply at index *wordnum*\n        in the sentence *sent* and generate the tag *new_tag*.\n        \"\"\"\n        for template in self._templates:\n            yield from template.applicable_rules(sent, wordnum, new_tag)\n\n    def _update_rule_applies(self, rule, sentnum, wordnum, train_sents):\n        \"\"\"\n        Update the rule data tables to reflect the fact that\n        *rule* applies at the position *(sentnum, wordnum)*.\n        \"\"\"\n        pos = sentnum, wordnum\n\n        # If the rule is already known to apply here, ignore.\n        # (This only happens if the position's tag hasn't changed.)\n        if pos in self._positions_by_rule[rule]:\n            return\n\n        # Update self._positions_by_rule.\n        correct_tag = train_sents[sentnum][wordnum][1]\n        if rule.replacement_tag == correct_tag:\n            self._positions_by_rule[rule][pos] = 1\n        elif rule.original_tag == correct_tag:\n            self._positions_by_rule[rule][pos] = -1\n        else:  # was wrong, remains wrong\n            self._positions_by_rule[rule][pos] = 0\n\n        # Update _rules_by_position\n        self._rules_by_position[pos].add(rule)\n\n        # Update _rule_scores.\n        old_score = self._rule_scores[rule]\n        self._rule_scores[rule] += self._positions_by_rule[rule][pos]\n\n        # Update _rules_by_score.\n        self._rules_by_score[old_score].discard(rule)\n        self._rules_by_score[self._rule_scores[rule]].add(rule)\n\n    def _update_rule_not_applies(self, rule, sentnum, wordnum):\n        \"\"\"\n        Update the rule data tables to reflect the fact that *rule*\n        does not apply at the position *(sentnum, wordnum)*.\n        \"\"\"\n        pos = sentnum, wordnum\n\n        # Update _rule_scores.\n        old_score = self._rule_scores[rule]\n        self._rule_scores[rule] -= self._positions_by_rule[rule][pos]\n\n        # Update _rules_by_score.\n        self._rules_by_score[old_score].discard(rule)\n        self._rules_by_score[self._rule_scores[rule]].add(rule)\n\n        # Update _positions_by_rule\n        del self._positions_by_rule[rule][pos]\n        self._rules_by_position[pos].remove(rule)\n\n        # Optional addition: if the rule now applies nowhere, delete\n        # all its dictionary entries.\n\n    def _best_rule(self, train_sents, test_sents, min_score, min_acc):\n        \"\"\"\n        Find the next best rule.  This is done by repeatedly taking a\n        rule with the highest score and stepping through the corpus to\n        see where it applies.  When it makes an error (decreasing its\n        score) it's bumped down, and we try a new rule with the\n        highest score.  When we find a rule which has the highest\n        score *and* which has been tested against the entire corpus, we\n        can conclude that it's the next best rule.\n        \"\"\"\n        for max_score in sorted(self._rules_by_score.keys(), reverse=True):\n            if len(self._rules_by_score) == 0:\n                return None\n            if max_score < min_score or max_score <= 0:\n                return None\n            best_rules = list(self._rules_by_score[max_score])\n            if self._deterministic:\n                best_rules.sort(key=repr)\n            for rule in best_rules:\n                positions = self._tag_positions[rule.original_tag]\n\n                unk = self._first_unknown_position.get(rule, (0, -1))\n                start = bisect.bisect_left(positions, unk)\n\n                for i in range(start, len(positions)):\n                    sentnum, wordnum = positions[i]\n                    if rule.applies(test_sents[sentnum], wordnum):\n                        self._update_rule_applies(rule, sentnum, wordnum, train_sents)\n                        if self._rule_scores[rule] < max_score:\n                            self._first_unknown_position[rule] = (sentnum, wordnum + 1)\n                            break  # The update demoted the rule.\n\n                if self._rule_scores[rule] == max_score:\n                    self._first_unknown_position[rule] = (len(train_sents) + 1, 0)\n                    # optimization: if no min_acc threshold given, don't bother computing accuracy\n                    if min_acc is None:\n                        return rule\n                    else:\n                        changes = self._positions_by_rule[rule].values()\n                        num_fixed = len([c for c in changes if c == 1])\n                        num_broken = len([c for c in changes if c == -1])\n                        # acc here is fixed/(fixed+broken); could also be\n                        # fixed/(fixed+broken+other) == num_fixed/len(changes)\n                        acc = num_fixed / (num_fixed + num_broken)\n                        if acc >= min_acc:\n                            return rule\n                        # else: rule too inaccurate, discard and try next\n\n            # We demoted (or skipped due to < min_acc, if that was given)\n            # all the rules with score==max_score.\n\n            assert min_acc is not None or not self._rules_by_score[max_score]\n            if not self._rules_by_score[max_score]:\n                del self._rules_by_score[max_score]\n\n    def _apply_rule(self, rule, test_sents):\n        \"\"\"\n        Update *test_sents* by applying *rule* everywhere where its\n        conditions are met.\n        \"\"\"\n        update_positions = set(self._positions_by_rule[rule])\n        new_tag = rule.replacement_tag\n\n        if self._trace > 3:\n            self._trace_apply(len(update_positions))\n\n        # Update test_sents.\n        for (sentnum, wordnum) in update_positions:\n            text = test_sents[sentnum][wordnum][0]\n            test_sents[sentnum][wordnum] = (text, new_tag)\n\n    def _update_tag_positions(self, rule):\n        \"\"\"\n        Update _tag_positions to reflect the changes to tags that are\n        made by *rule*.\n        \"\"\"\n        # Update the tag index.\n        for pos in self._positions_by_rule[rule]:\n            # Delete the old tag.\n            old_tag_positions = self._tag_positions[rule.original_tag]\n            old_index = bisect.bisect_left(old_tag_positions, pos)\n            del old_tag_positions[old_index]\n            # Insert the new tag.\n            new_tag_positions = self._tag_positions[rule.replacement_tag]\n            bisect.insort_left(new_tag_positions, pos)\n\n    def _update_rules(self, rule, train_sents, test_sents):\n        \"\"\"\n        Check if we should add or remove any rules from consideration,\n        given the changes made by *rule*.\n        \"\"\"\n        # Collect a list of all positions that might be affected.\n        neighbors = set()\n        for sentnum, wordnum in self._positions_by_rule[rule]:\n            for template in self._templates:\n                n = template.get_neighborhood(test_sents[sentnum], wordnum)\n                neighbors.update([(sentnum, i) for i in n])\n\n        # Update the rules at each position.\n        num_obsolete = num_new = num_unseen = 0\n        for sentnum, wordnum in neighbors:\n            test_sent = test_sents[sentnum]\n            correct_tag = train_sents[sentnum][wordnum][1]\n\n            # Check if the change causes any rule at this position to\n            # stop matching; if so, then update our rule mappings\n            # accordingly.\n            old_rules = set(self._rules_by_position[sentnum, wordnum])\n            for old_rule in old_rules:\n                if not old_rule.applies(test_sent, wordnum):\n                    num_obsolete += 1\n                    self._update_rule_not_applies(old_rule, sentnum, wordnum)\n\n            # Check if the change causes our templates to propose any\n            # new rules for this position.\n            for template in self._templates:\n                for new_rule in template.applicable_rules(\n                    test_sent, wordnum, correct_tag\n                ):\n                    if new_rule not in old_rules:\n                        num_new += 1\n                        if new_rule not in self._rule_scores:\n                            num_unseen += 1\n                        old_rules.add(new_rule)\n                        self._update_rule_applies(\n                            new_rule, sentnum, wordnum, train_sents\n                        )\n\n            # We may have caused other rules to match here, that are\n            # not proposed by our templates -- in particular, rules\n            # that are harmful or neutral.  We therefore need to\n            # update any rule whose first_unknown_position is past\n            # this rule.\n            for new_rule, pos in self._first_unknown_position.items():\n                if pos > (sentnum, wordnum):\n                    if new_rule not in old_rules:\n                        num_new += 1\n                        if new_rule.applies(test_sent, wordnum):\n                            self._update_rule_applies(\n                                new_rule, sentnum, wordnum, train_sents\n                            )\n\n        if self._trace > 3:\n            self._trace_update_rules(num_obsolete, num_new, num_unseen)\n\n    # Tracing\n\n    def _trace_header(self):\n        print(\n            \"\"\"\n           B      |\n   S   F   r   O  |        Score = Fixed - Broken\n   c   i   o   t  |  R     Fixed = num tags changed incorrect -> correct\n   o   x   k   h  |  u     Broken = num tags changed correct -> incorrect\n   r   e   e   e  |  l     Other = num tags changed incorrect -> incorrect\n   e   d   n   r  |  e\n------------------+-------------------------------------------------------\n        \"\"\".rstrip()\n        )\n\n    def _trace_rule(self, rule):\n        assert self._rule_scores[rule] == sum(self._positions_by_rule[rule].values())\n\n        changes = self._positions_by_rule[rule].values()\n        num_fixed = len([c for c in changes if c == 1])\n        num_broken = len([c for c in changes if c == -1])\n        num_other = len([c for c in changes if c == 0])\n        score = self._rule_scores[rule]\n\n        rulestr = rule.format(self._ruleformat)\n        if self._trace > 2:\n            print(\n                \"{:4d}{:4d}{:4d}{:4d}  |\".format(\n                    score, num_fixed, num_broken, num_other\n                ),\n                end=\" \",\n            )\n            print(\n                textwrap.fill(\n                    rulestr,\n                    initial_indent=\" \" * 20,\n                    width=79,\n                    subsequent_indent=\" \" * 18 + \"|   \",\n                ).strip()\n            )\n        else:\n            print(rulestr)\n\n    def _trace_apply(self, num_updates):\n        prefix = \" \" * 18 + \"|\"\n        print(prefix)\n        print(prefix, f\"Applying rule to {num_updates} positions.\")\n\n    def _trace_update_rules(self, num_obsolete, num_new, num_unseen):\n        prefix = \" \" * 18 + \"|\"\n        print(prefix, \"Updated rule tables:\")\n        print(prefix, (f\"  - {num_obsolete} rule applications removed\"))\n        print(\n            prefix,\n            (f\"  - {num_new} rule applications added ({num_unseen} novel)\"),\n        )\n        print(prefix)\n", "# Natural Language Toolkit: Sequential Backoff Taggers\n#\n# Copyright (C) 2001-2021 NLTK Project\n# Author: Edward Loper <edloper@gmail.com>\n#         Steven Bird <stevenbird1@gmail.com> (minor additions)\n#         Tiago Tresoldi <tresoldi@users.sf.net> (original affix tagger)\n# URL: <https://www.nltk.org/>\n# For license information, see LICENSE.TXT\n\n\"\"\"\nClasses for tagging sentences sequentially, left to right.  The\nabstract base class SequentialBackoffTagger serves as the base\nclass for all the taggers in this module.  Tagging of individual words\nis performed by the method ``choose_tag()``, which is defined by\nsubclasses of SequentialBackoffTagger.  If a tagger is unable to\ndetermine a tag for the specified token, then its backoff tagger is\nconsulted instead.  Any SequentialBackoffTagger may serve as a\nbackoff tagger for any other SequentialBackoffTagger.\n\"\"\"\nimport ast\nimport re\nfrom abc import abstractmethod\nfrom typing import List, Optional, Tuple\n\nfrom nltk import jsontags\nfrom nltk.classify import NaiveBayesClassifier\nfrom nltk.probability import ConditionalFreqDist\nfrom nltk.tag.api import FeaturesetTaggerI, TaggerI\n\n\n######################################################################\n# Abstract Base Classes\n######################################################################\nclass SequentialBackoffTagger(TaggerI):\n    \"\"\"\n    An abstract base class for taggers that tags words sequentially,\n    left to right.  Tagging of individual words is performed by the\n    ``choose_tag()`` method, which should be defined by subclasses.  If\n    a tagger is unable to determine a tag for the specified token,\n    then its backoff tagger is consulted.\n\n    :ivar _taggers: A list of all the taggers that should be tried to\n        tag a token (i.e., self and its backoff taggers).\n    \"\"\"\n\n    def __init__(self, backoff=None):\n        if backoff is None:\n            self._taggers = [self]\n        else:\n            self._taggers = [self] + backoff._taggers\n\n    @property\n    def backoff(self):\n        \"\"\"The backoff tagger for this tagger.\"\"\"\n        return self._taggers[1] if len(self._taggers) > 1 else None\n\n    def tag(self, tokens):\n        # docs inherited from TaggerI\n        tags = []\n        for i in range(len(tokens)):\n            tags.append(self.tag_one(tokens, i, tags))\n        return list(zip(tokens, tags))\n\n    def tag_one(self, tokens, index, history):\n        \"\"\"\n        Determine an appropriate tag for the specified token, and\n        return that tag.  If this tagger is unable to determine a tag\n        for the specified token, then its backoff tagger is consulted.\n\n        :rtype: str\n        :type tokens: list\n        :param tokens: The list of words that are being tagged.\n        :type index: int\n        :param index: The index of the word whose tag should be\n            returned.\n        :type history: list(str)\n        :param history: A list of the tags for all words before *index*.\n        \"\"\"\n        tag = None\n        for tagger in self._taggers:\n            tag = tagger.choose_tag(tokens, index, history)\n            if tag is not None:\n                break\n        return tag\n\n    @abstractmethod\n    def choose_tag(self, tokens, index, history):\n        \"\"\"\n        Decide which tag should be used for the specified token, and\n        return that tag.  If this tagger is unable to determine a tag\n        for the specified token, return None -- do not consult\n        the backoff tagger.  This method should be overridden by\n        subclasses of SequentialBackoffTagger.\n\n        :rtype: str\n        :type tokens: list\n        :param tokens: The list of words that are being tagged.\n        :type index: int\n        :param index: The index of the word whose tag should be\n            returned.\n        :type history: list(str)\n        :param history: A list of the tags for all words before *index*.\n        \"\"\"\n\n\nclass ContextTagger(SequentialBackoffTagger):\n    \"\"\"\n    An abstract base class for sequential backoff taggers that choose\n    a tag for a token based on the value of its \"context\".  Different\n    subclasses are used to define different contexts.\n\n    A ContextTagger chooses the tag for a token by calculating the\n    token's context, and looking up the corresponding tag in a table.\n    This table can be constructed manually; or it can be automatically\n    constructed based on a training corpus, using the ``_train()``\n    factory method.\n\n    :ivar _context_to_tag: Dictionary mapping contexts to tags.\n    \"\"\"\n\n    def __init__(self, context_to_tag, backoff=None):\n        \"\"\"\n        :param context_to_tag: A dictionary mapping contexts to tags.\n        :param backoff: The backoff tagger that should be used for this tagger.\n        \"\"\"\n        super().__init__(backoff)\n        self._context_to_tag = context_to_tag if context_to_tag else {}\n\n    @abstractmethod\n    def context(self, tokens, index, history):\n        \"\"\"\n        :return: the context that should be used to look up the tag\n            for the specified token; or None if the specified token\n            should not be handled by this tagger.\n        :rtype: (hashable)\n        \"\"\"\n\n    def choose_tag(self, tokens, index, history):\n        context = self.context(tokens, index, history)\n        return self._context_to_tag.get(context)\n\n    def size(self):\n        \"\"\"\n        :return: The number of entries in the table used by this\n            tagger to map from contexts to tags.\n        \"\"\"\n        return len(self._context_to_tag)\n\n    def __repr__(self):\n        return f\"<{self.__class__.__name__}: size={self.size()}>\"\n\n    def _train(self, tagged_corpus, cutoff=0, verbose=False):\n        \"\"\"\n        Initialize this ContextTagger's ``_context_to_tag`` table\n        based on the given training data.  In particular, for each\n        context ``c`` in the training data, set\n        ``_context_to_tag[c]`` to the most frequent tag for that\n        context.  However, exclude any contexts that are already\n        tagged perfectly by the backoff tagger(s).\n\n        The old value of ``self._context_to_tag`` (if any) is discarded.\n\n        :param tagged_corpus: A tagged corpus.  Each item should be\n            a list of (word, tag tuples.\n        :param cutoff: If the most likely tag for a context occurs\n            fewer than cutoff times, then exclude it from the\n            context-to-tag table for the new tagger.\n        \"\"\"\n\n        token_count = hit_count = 0\n\n        # A context is considered 'useful' if it's not already tagged\n        # perfectly by the backoff tagger.\n        useful_contexts = set()\n\n        # Count how many times each tag occurs in each context.\n        fd = ConditionalFreqDist()\n        for sentence in tagged_corpus:\n            tokens, tags = zip(*sentence)\n            for index, (token, tag) in enumerate(sentence):\n                # Record the event.\n                token_count += 1\n                context = self.context(tokens, index, tags[:index])\n                if context is None:\n                    continue\n                fd[context][tag] += 1\n                # If the backoff got it wrong, this context is useful:\n                if self.backoff is None or tag != self.backoff.tag_one(\n                    tokens, index, tags[:index]\n                ):\n                    useful_contexts.add(context)\n\n        # Build the context_to_tag table -- for each context, figure\n        # out what the most likely tag is.  Only include contexts that\n        # we've seen at least `cutoff` times.\n        for context in useful_contexts:\n            best_tag = fd[context].max()\n            hits = fd[context][best_tag]\n            if hits > cutoff:\n                self._context_to_tag[context] = best_tag\n                hit_count += hits\n\n        # Display some stats, if requested.\n        if verbose:\n            size = len(self._context_to_tag)\n            backoff = 100 - (hit_count * 100.0) / token_count\n            pruning = 100 - (size * 100.0) / len(fd.conditions())\n            print(\"[Trained Unigram tagger:\", end=\" \")\n            print(\n                \"size={}, backoff={:.2f}%, pruning={:.2f}%]\".format(\n                    size, backoff, pruning\n                )\n            )\n\n\n######################################################################\n# Tagger Classes\n######################################################################\n\n\n@jsontags.register_tag\nclass DefaultTagger(SequentialBackoffTagger):\n    \"\"\"\n    A tagger that assigns the same tag to every token.\n\n        >>> from nltk.tag import DefaultTagger\n        >>> default_tagger = DefaultTagger('NN')\n        >>> list(default_tagger.tag('This is a test'.split()))\n        [('This', 'NN'), ('is', 'NN'), ('a', 'NN'), ('test', 'NN')]\n\n    This tagger is recommended as a backoff tagger, in cases where\n    a more powerful tagger is unable to assign a tag to the word\n    (e.g. because the word was not seen during training).\n\n    :param tag: The tag to assign to each token\n    :type tag: str\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.DefaultTagger\"\n\n    def __init__(self, tag):\n        self._tag = tag\n        super().__init__(None)\n\n    def encode_json_obj(self):\n        return self._tag\n\n    @classmethod\n    def decode_json_obj(cls, obj):\n        tag = obj\n        return cls(tag)\n\n    def choose_tag(self, tokens, index, history):\n        return self._tag  # ignore token and history\n\n    def __repr__(self):\n        return f\"<DefaultTagger: tag={self._tag}>\"\n\n\n@jsontags.register_tag\nclass NgramTagger(ContextTagger):\n    \"\"\"\n    A tagger that chooses a token's tag based on its word string and\n    on the preceding n word's tags.  In particular, a tuple\n    (tags[i-n:i-1], words[i]) is looked up in a table, and the\n    corresponding tag is returned.  N-gram taggers are typically\n    trained on a tagged corpus.\n\n    Train a new NgramTagger using the given training data or\n    the supplied model.  In particular, construct a new tagger\n    whose table maps from each context (tag[i-n:i-1], word[i])\n    to the most frequent tag for that context.  But exclude any\n    contexts that are already tagged perfectly by the backoff\n    tagger.\n\n    :param train: A tagged corpus consisting of a list of tagged\n        sentences, where each sentence is a list of (word, tag) tuples.\n    :param backoff: A backoff tagger, to be used by the new\n        tagger if it encounters an unknown context.\n    :param cutoff: If the most likely tag for a context occurs\n        fewer than *cutoff* times, then exclude it from the\n        context-to-tag table for the new tagger.\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.NgramTagger\"\n\n    def __init__(\n        self, n, train=None, model=None, backoff=None, cutoff=0, verbose=False\n    ):\n        self._n = n\n        self._check_params(train, model)\n\n        super().__init__(model, backoff)\n\n        if train:\n            self._train(train, cutoff, verbose)\n\n    def encode_json_obj(self):\n        _context_to_tag = {repr(k): v for k, v in self._context_to_tag.items()}\n        if \"NgramTagger\" in self.__class__.__name__:\n            return self._n, _context_to_tag, self.backoff\n        else:\n            return _context_to_tag, self.backoff\n\n    @classmethod\n    def decode_json_obj(cls, obj):\n        try:\n            _n, _context_to_tag, backoff = obj\n        except ValueError:\n            _context_to_tag, backoff = obj\n\n        if not _context_to_tag:\n            return backoff\n\n        _context_to_tag = {ast.literal_eval(k): v for k, v in _context_to_tag.items()}\n\n        if \"NgramTagger\" in cls.__name__:\n            return cls(_n, model=_context_to_tag, backoff=backoff)\n        else:\n            return cls(model=_context_to_tag, backoff=backoff)\n\n    def context(self, tokens, index, history):\n        tag_context = tuple(history[max(0, index - self._n + 1) : index])\n        return tag_context, tokens[index]\n\n\n@jsontags.register_tag\nclass UnigramTagger(NgramTagger):\n    \"\"\"\n    Unigram Tagger\n\n    The UnigramTagger finds the most likely tag for each word in a training\n    corpus, and then uses that information to assign tags to new tokens.\n\n        >>> from nltk.corpus import brown\n        >>> from nltk.tag import UnigramTagger\n        >>> test_sent = brown.sents(categories='news')[0]\n        >>> unigram_tagger = UnigramTagger(brown.tagged_sents(categories='news')[:500])\n        >>> for tok, tag in unigram_tagger.tag(test_sent):\n        ...     print(\"({}, {}), \".format(tok, tag))\n        (The, AT), (Fulton, NP-TL), (County, NN-TL), (Grand, JJ-TL),\n        (Jury, NN-TL), (said, VBD), (Friday, NR), (an, AT),\n        (investigation, NN), (of, IN), (Atlanta's, NP$), (recent, JJ),\n        (primary, NN), (election, NN), (produced, VBD), (``, ``),\n        (no, AT), (evidence, NN), ('', ''), (that, CS), (any, DTI),\n        (irregularities, NNS), (took, VBD), (place, NN), (., .),\n\n    :param train: The corpus of training data, a list of tagged sentences\n    :type train: list(list(tuple(str, str)))\n    :param model: The tagger model\n    :type model: dict\n    :param backoff: Another tagger which this tagger will consult when it is\n        unable to tag a word\n    :type backoff: TaggerI\n    :param cutoff: The number of instances of training data the tagger must see\n        in order not to use the backoff tagger\n    :type cutoff: int\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.UnigramTagger\"\n\n    def __init__(self, train=None, model=None, backoff=None, cutoff=0, verbose=False):\n        super().__init__(1, train, model, backoff, cutoff, verbose)\n\n    def context(self, tokens, index, history):\n        return tokens[index]\n\n\n@jsontags.register_tag\nclass BigramTagger(NgramTagger):\n    \"\"\"\n    A tagger that chooses a token's tag based its word string and on\n    the preceding words' tag.  In particular, a tuple consisting\n    of the previous tag and the word is looked up in a table, and\n    the corresponding tag is returned.\n\n    :param train: The corpus of training data, a list of tagged sentences\n    :type train: list(list(tuple(str, str)))\n    :param model: The tagger model\n    :type model: dict\n    :param backoff: Another tagger which this tagger will consult when it is\n        unable to tag a word\n    :type backoff: TaggerI\n    :param cutoff: The number of instances of training data the tagger must see\n        in order not to use the backoff tagger\n    :type cutoff: int\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.BigramTagger\"\n\n    def __init__(self, train=None, model=None, backoff=None, cutoff=0, verbose=False):\n        super().__init__(2, train, model, backoff, cutoff, verbose)\n\n\n@jsontags.register_tag\nclass TrigramTagger(NgramTagger):\n    \"\"\"\n    A tagger that chooses a token's tag based its word string and on\n    the preceding two words' tags.  In particular, a tuple consisting\n    of the previous two tags and the word is looked up in a table, and\n    the corresponding tag is returned.\n\n    :param train: The corpus of training data, a list of tagged sentences\n    :type train: list(list(tuple(str, str)))\n    :param model: The tagger model\n    :type model: dict\n    :param backoff: Another tagger which this tagger will consult when it is\n        unable to tag a word\n    :type backoff: TaggerI\n    :param cutoff: The number of instances of training data the tagger must see\n        in order not to use the backoff tagger\n    :type cutoff: int\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.TrigramTagger\"\n\n    def __init__(self, train=None, model=None, backoff=None, cutoff=0, verbose=False):\n        super().__init__(3, train, model, backoff, cutoff, verbose)\n\n\n@jsontags.register_tag\nclass AffixTagger(ContextTagger):\n    \"\"\"\n    A tagger that chooses a token's tag based on a leading or trailing\n    substring of its word string.  (It is important to note that these\n    substrings are not necessarily \"true\" morphological affixes).  In\n    particular, a fixed-length substring of the word is looked up in a\n    table, and the corresponding tag is returned.  Affix taggers are\n    typically constructed by training them on a tagged corpus.\n\n    Construct a new affix tagger.\n\n    :param affix_length: The length of the affixes that should be\n        considered during training and tagging.  Use negative\n        numbers for suffixes.\n    :param min_stem_length: Any words whose length is less than\n        min_stem_length+abs(affix_length) will be assigned a\n        tag of None by this tagger.\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.AffixTagger\"\n\n    def __init__(\n        self,\n        train=None,\n        model=None,\n        affix_length=-3,\n        min_stem_length=2,\n        backoff=None,\n        cutoff=0,\n        verbose=False,\n    ):\n\n        self._check_params(train, model)\n\n        super().__init__(model, backoff)\n\n        self._affix_length = affix_length\n        self._min_word_length = min_stem_length + abs(affix_length)\n\n        if train:\n            self._train(train, cutoff, verbose)\n\n    def encode_json_obj(self):\n        return (\n            self._affix_length,\n            self._min_word_length,\n            self._context_to_tag,\n            self.backoff,\n        )\n\n    @classmethod\n    def decode_json_obj(cls, obj):\n        _affix_length, _min_word_length, _context_to_tag, backoff = obj\n        return cls(\n            affix_length=_affix_length,\n            min_stem_length=_min_word_length - abs(_affix_length),\n            model=_context_to_tag,\n            backoff=backoff,\n        )\n\n    def context(self, tokens, index, history):\n        token = tokens[index]\n        if len(token) < self._min_word_length:\n            return None\n        elif self._affix_length > 0:\n            return token[: self._affix_length]\n        else:\n            return token[self._affix_length :]\n\n\n@jsontags.register_tag\nclass RegexpTagger(SequentialBackoffTagger):\n    \"\"\"\n    Regular Expression Tagger\n\n    The RegexpTagger assigns tags to tokens by comparing their\n    word strings to a series of regular expressions.  The following tagger\n    uses word suffixes to make guesses about the correct Brown Corpus part\n    of speech tag:\n\n        >>> from nltk.corpus import brown\n        >>> from nltk.tag import RegexpTagger\n        >>> test_sent = brown.sents(categories='news')[0]\n        >>> regexp_tagger = RegexpTagger(\n        ...     [(r'^-?[0-9]+(.[0-9]+)?$', 'CD'),   # cardinal numbers\n        ...      (r'(The|the|A|a|An|an)$', 'AT'),   # articles\n        ...      (r'.*able$', 'JJ'),                # adjectives\n        ...      (r'.*ness$', 'NN'),                # nouns formed from adjectives\n        ...      (r'.*ly$', 'RB'),                  # adverbs\n        ...      (r'.*s$', 'NNS'),                  # plural nouns\n        ...      (r'.*ing$', 'VBG'),                # gerunds\n        ...      (r'.*ed$', 'VBD'),                 # past tense verbs\n        ...      (r'.*', 'NN')                      # nouns (default)\n        ... ])\n        >>> regexp_tagger\n        <Regexp Tagger: size=9>\n        >>> regexp_tagger.tag(test_sent)\n        [('The', 'AT'), ('Fulton', 'NN'), ('County', 'NN'), ('Grand', 'NN'), ('Jury', 'NN'),\n        ('said', 'NN'), ('Friday', 'NN'), ('an', 'AT'), ('investigation', 'NN'), ('of', 'NN'),\n        (\"Atlanta's\", 'NNS'), ('recent', 'NN'), ('primary', 'NN'), ('election', 'NN'),\n        ('produced', 'VBD'), ('``', 'NN'), ('no', 'NN'), ('evidence', 'NN'), (\"''\", 'NN'),\n        ('that', 'NN'), ('any', 'NN'), ('irregularities', 'NNS'), ('took', 'NN'),\n        ('place', 'NN'), ('.', 'NN')]\n\n    :type regexps: list(tuple(str, str))\n    :param regexps: A list of ``(regexp, tag)`` pairs, each of\n        which indicates that a word matching ``regexp`` should\n        be tagged with ``tag``.  The pairs will be evaluated in\n        order.  If none of the regexps match a word, then the\n        optional backoff tagger is invoked, else it is\n        assigned the tag None.\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.RegexpTagger\"\n\n    def __init__(\n        self, regexps: List[Tuple[str, str]], backoff: Optional[TaggerI] = None\n    ):\n        super().__init__(backoff)\n        self._regexps = []\n        for regexp, tag in regexps:\n            try:\n                self._regexps.append((re.compile(regexp), tag))\n            except Exception as e:\n                raise Exception(\n                    f\"Invalid RegexpTagger regexp: {e}\\n- regexp: {regexp!r}\\n- tag: {tag!r}\"\n                ) from e\n\n    def encode_json_obj(self):\n        return [(regexp.pattern, tag) for regexp, tag in self._regexps], self.backoff\n\n    @classmethod\n    def decode_json_obj(cls, obj):\n        regexps, backoff = obj\n        return cls(regexps, backoff)\n\n    def choose_tag(self, tokens, index, history):\n        for regexp, tag in self._regexps:\n            if re.match(regexp, tokens[index]):\n                return tag\n        return None\n\n    def __repr__(self):\n        return f\"<Regexp Tagger: size={len(self._regexps)}>\"\n\n\nclass ClassifierBasedTagger(SequentialBackoffTagger, FeaturesetTaggerI):\n    \"\"\"\n    A sequential tagger that uses a classifier to choose the tag for\n    each token in a sentence.  The featureset input for the classifier\n    is generated by a feature detector function::\n\n        feature_detector(tokens, index, history) -> featureset\n\n    Where tokens is the list of unlabeled tokens in the sentence;\n    index is the index of the token for which feature detection\n    should be performed; and history is list of the tags for all\n    tokens before index.\n\n    Construct a new classifier-based sequential tagger.\n\n    :param feature_detector: A function used to generate the\n        featureset input for the classifier::\n        feature_detector(tokens, index, history) -> featureset\n\n    :param train: A tagged corpus consisting of a list of tagged\n        sentences, where each sentence is a list of (word, tag) tuples.\n\n    :param backoff: A backoff tagger, to be used by the new tagger\n        if it encounters an unknown context.\n\n    :param classifier_builder: A function used to train a new\n        classifier based on the data in *train*.  It should take\n        one argument, a list of labeled featuresets (i.e.,\n        (featureset, label) tuples).\n\n    :param classifier: The classifier that should be used by the\n        tagger.  This is only useful if you want to manually\n        construct the classifier; normally, you would use *train*\n        instead.\n\n    :param backoff: A backoff tagger, used if this tagger is\n        unable to determine a tag for a given token.\n\n    :param cutoff_prob: If specified, then this tagger will fall\n        back on its backoff tagger if the probability of the most\n        likely tag is less than *cutoff_prob*.\n    \"\"\"\n\n    def __init__(\n        self,\n        feature_detector=None,\n        train=None,\n        classifier_builder=NaiveBayesClassifier.train,\n        classifier=None,\n        backoff=None,\n        cutoff_prob=None,\n        verbose=False,\n    ):\n        self._check_params(train, classifier)\n\n        super().__init__(backoff)\n\n        if (train and classifier) or (not train and not classifier):\n            raise ValueError(\n                \"Must specify either training data or \" \"trained classifier.\"\n            )\n\n        if feature_detector is not None:\n            self._feature_detector = feature_detector\n            # The feature detector function, used to generate a featureset\n            # or each token: feature_detector(tokens, index, history) -> featureset\n\n        self._cutoff_prob = cutoff_prob\n        \"\"\"Cutoff probability for tagging -- if the probability of the\n           most likely tag is less than this, then use backoff.\"\"\"\n\n        self._classifier = classifier\n        \"\"\"The classifier used to choose a tag for each token.\"\"\"\n\n        if train:\n            self._train(train, classifier_builder, verbose)\n\n    def choose_tag(self, tokens, index, history):\n        # Use our feature detector to get the featureset.\n        featureset = self.feature_detector(tokens, index, history)\n\n        # Use the classifier to pick a tag.  If a cutoff probability\n        # was specified, then check that the tag's probability is\n        # higher than that cutoff first; otherwise, return None.\n        if self._cutoff_prob is None:\n            return self._classifier.classify(featureset)\n\n        pdist = self._classifier.prob_classify(featureset)\n        tag = pdist.max()\n        return tag if pdist.prob(tag) >= self._cutoff_prob else None\n\n    def _train(self, tagged_corpus, classifier_builder, verbose):\n        \"\"\"\n        Build a new classifier, based on the given training data\n        *tagged_corpus*.\n        \"\"\"\n\n        classifier_corpus = []\n        if verbose:\n            print(\"Constructing training corpus for classifier.\")\n\n        for sentence in tagged_corpus:\n            history = []\n            untagged_sentence, tags = zip(*sentence)\n            for index in range(len(sentence)):\n                featureset = self.feature_detector(untagged_sentence, index, history)\n                classifier_corpus.append((featureset, tags[index]))\n                history.append(tags[index])\n\n        if verbose:\n            print(f\"Training classifier ({len(classifier_corpus)} instances)\")\n        self._classifier = classifier_builder(classifier_corpus)\n\n    def __repr__(self):\n        return f\"<ClassifierBasedTagger: {self._classifier}>\"\n\n    def feature_detector(self, tokens, index, history):\n        \"\"\"\n        Return the feature detector that this tagger uses to generate\n        featuresets for its classifier.  The feature detector is a\n        function with the signature::\n\n          feature_detector(tokens, index, history) -> featureset\n\n        See ``classifier()``\n        \"\"\"\n        return self._feature_detector(tokens, index, history)\n\n    def classifier(self):\n        \"\"\"\n        Return the classifier that this tagger uses to choose a tag\n        for each word in a sentence.  The input for this classifier is\n        generated using this tagger's feature detector.\n        See ``feature_detector()``\n        \"\"\"\n        return self._classifier\n\n\nclass ClassifierBasedPOSTagger(ClassifierBasedTagger):\n    \"\"\"\n    A classifier based part of speech tagger.\n    \"\"\"\n\n    def feature_detector(self, tokens, index, history):\n        word = tokens[index]\n        if index == 0:\n            prevword = prevprevword = None\n            prevtag = prevprevtag = None\n        elif index == 1:\n            prevword = tokens[index - 1].lower()\n            prevprevword = None\n            prevtag = history[index - 1]\n            prevprevtag = None\n        else:\n            prevword = tokens[index - 1].lower()\n            prevprevword = tokens[index - 2].lower()\n            prevtag = history[index - 1]\n            prevprevtag = history[index - 2]\n\n        if re.match(r\"[0-9]+(\\.[0-9]*)?|[0-9]*\\.[0-9]+$\", word):\n            shape = \"number\"\n        elif re.match(r\"\\W+$\", word):\n            shape = \"punct\"\n        elif re.match(\"[A-Z][a-z]+$\", word):\n            shape = \"upcase\"\n        elif re.match(\"[a-z]+$\", word):\n            shape = \"downcase\"\n        elif re.match(r\"\\w+$\", word):\n            shape = \"mixedcase\"\n        else:\n            shape = \"other\"\n\n        features = {\n            \"prevtag\": prevtag,\n            \"prevprevtag\": prevprevtag,\n            \"word\": word,\n            \"word.lower\": word.lower(),\n            \"suffix3\": word.lower()[-3:],\n            \"suffix2\": word.lower()[-2:],\n            \"suffix1\": word.lower()[-1:],\n            \"prevprevword\": prevprevword,\n            \"prevword\": prevword,\n            \"prevtag+word\": f\"{prevtag}+{word.lower()}\",\n            \"prevprevtag+word\": f\"{prevprevtag}+{word.lower()}\",\n            \"prevword+word\": f\"{prevword}+{word.lower()}\",\n            \"shape\": shape,\n        }\n        return features\n", "# Natural Language Toolkit: Transformation-based learning\n#\n# Copyright (C) 2001-2021 NLTK Project\n# Author: Marcus Uneson <marcus.uneson@gmail.com>\n#   based on previous (nltk2) version by\n#   Christopher Maloof, Edward Loper, Steven Bird\n# URL: <https://www.nltk.org/>\n# For license information, see  LICENSE.TXT\n\nimport os\nimport pickle\nimport random\nimport time\n\nfrom nltk.corpus import treebank\nfrom nltk.tag import BrillTaggerTrainer, RegexpTagger, UnigramTagger\nfrom nltk.tag.brill import Pos, Word\nfrom nltk.tbl import Template, error_list\n\n\ndef demo():\n    \"\"\"\n    Run a demo with defaults. See source comments for details,\n    or docstrings of any of the more specific demo_* functions.\n    \"\"\"\n    postag()\n\n\ndef demo_repr_rule_format():\n    \"\"\"\n    Exemplify repr(Rule) (see also str(Rule) and Rule.format(\"verbose\"))\n    \"\"\"\n    postag(ruleformat=\"repr\")\n\n\ndef demo_str_rule_format():\n    \"\"\"\n    Exemplify repr(Rule) (see also str(Rule) and Rule.format(\"verbose\"))\n    \"\"\"\n    postag(ruleformat=\"str\")\n\n\ndef demo_verbose_rule_format():\n    \"\"\"\n    Exemplify Rule.format(\"verbose\")\n    \"\"\"\n    postag(ruleformat=\"verbose\")\n\n\ndef demo_multiposition_feature():\n    \"\"\"\n    The feature/s of a template takes a list of positions\n    relative to the current word where the feature should be\n    looked for, conceptually joined by logical OR. For instance,\n    Pos([-1, 1]), given a value V, will hold whenever V is found\n    one step to the left and/or one step to the right.\n\n    For contiguous ranges, a 2-arg form giving inclusive end\n    points can also be used: Pos(-3, -1) is the same as the arg\n    below.\n    \"\"\"\n    postag(templates=[Template(Pos([-3, -2, -1]))])\n\n\ndef demo_multifeature_template():\n    \"\"\"\n    Templates can have more than a single feature.\n    \"\"\"\n    postag(templates=[Template(Word([0]), Pos([-2, -1]))])\n\n\ndef demo_template_statistics():\n    \"\"\"\n    Show aggregate statistics per template. Little used templates are\n    candidates for deletion, much used templates may possibly be refined.\n\n    Deleting unused templates is mostly about saving time and/or space:\n    training is basically O(T) in the number of templates T\n    (also in terms of memory usage, which often will be the limiting factor).\n    \"\"\"\n    postag(incremental_stats=True, template_stats=True)\n\n\ndef demo_generated_templates():\n    \"\"\"\n    Template.expand and Feature.expand are class methods facilitating\n    generating large amounts of templates. See their documentation for\n    details.\n\n    Note: training with 500 templates can easily fill all available\n    even on relatively small corpora\n    \"\"\"\n    wordtpls = Word.expand([-1, 0, 1], [1, 2], excludezero=False)\n    tagtpls = Pos.expand([-2, -1, 0, 1], [1, 2], excludezero=True)\n    templates = list(Template.expand([wordtpls, tagtpls], combinations=(1, 3)))\n    print(\n        \"Generated {} templates for transformation-based learning\".format(\n            len(templates)\n        )\n    )\n    postag(templates=templates, incremental_stats=True, template_stats=True)\n\n\ndef demo_learning_curve():\n    \"\"\"\n    Plot a learning curve -- the contribution on tagging accuracy of\n    the individual rules.\n    Note: requires matplotlib\n    \"\"\"\n    postag(\n        incremental_stats=True,\n        separate_baseline_data=True,\n        learning_curve_output=\"learningcurve.png\",\n    )\n\n\ndef demo_error_analysis():\n    \"\"\"\n    Writes a file with context for each erroneous word after tagging testing data\n    \"\"\"\n    postag(error_output=\"errors.txt\")\n\n\ndef demo_serialize_tagger():\n    \"\"\"\n    Serializes the learned tagger to a file in pickle format; reloads it\n    and validates the process.\n    \"\"\"\n    postag(serialize_output=\"tagger.pcl\")\n\n\ndef demo_high_accuracy_rules():\n    \"\"\"\n    Discard rules with low accuracy. This may hurt performance a bit,\n    but will often produce rules which are more interesting read to a human.\n    \"\"\"\n    postag(num_sents=3000, min_acc=0.96, min_score=10)\n\n\ndef postag(\n    templates=None,\n    tagged_data=None,\n    num_sents=1000,\n    max_rules=300,\n    min_score=3,\n    min_acc=None,\n    train=0.8,\n    trace=3,\n    randomize=False,\n    ruleformat=\"str\",\n    incremental_stats=False,\n    template_stats=False,\n    error_output=None,\n    serialize_output=None,\n    learning_curve_output=None,\n    learning_curve_take=300,\n    baseline_backoff_tagger=None,\n    separate_baseline_data=False,\n    cache_baseline_tagger=None,\n):\n    \"\"\"\n    Brill Tagger Demonstration\n    :param templates: how many sentences of training and testing data to use\n    :type templates: list of Template\n\n    :param tagged_data: maximum number of rule instances to create\n    :type tagged_data: C{int}\n\n    :param num_sents: how many sentences of training and testing data to use\n    :type num_sents: C{int}\n\n    :param max_rules: maximum number of rule instances to create\n    :type max_rules: C{int}\n\n    :param min_score: the minimum score for a rule in order for it to be considered\n    :type min_score: C{int}\n\n    :param min_acc: the minimum score for a rule in order for it to be considered\n    :type min_acc: C{float}\n\n    :param train: the fraction of the the corpus to be used for training (1=all)\n    :type train: C{float}\n\n    :param trace: the level of diagnostic tracing output to produce (0-4)\n    :type trace: C{int}\n\n    :param randomize: whether the training data should be a random subset of the corpus\n    :type randomize: C{bool}\n\n    :param ruleformat: rule output format, one of \"str\", \"repr\", \"verbose\"\n    :type ruleformat: C{str}\n\n    :param incremental_stats: if true, will tag incrementally and collect stats for each rule (rather slow)\n    :type incremental_stats: C{bool}\n\n    :param template_stats: if true, will print per-template statistics collected in training and (optionally) testing\n    :type template_stats: C{bool}\n\n    :param error_output: the file where errors will be saved\n    :type error_output: C{string}\n\n    :param serialize_output: the file where the learned tbl tagger will be saved\n    :type serialize_output: C{string}\n\n    :param learning_curve_output: filename of plot of learning curve(s) (train and also test, if available)\n    :type learning_curve_output: C{string}\n\n    :param learning_curve_take: how many rules plotted\n    :type learning_curve_take: C{int}\n\n    :param baseline_backoff_tagger: the file where rules will be saved\n    :type baseline_backoff_tagger: tagger\n\n    :param separate_baseline_data: use a fraction of the training data exclusively for training baseline\n    :type separate_baseline_data: C{bool}\n\n    :param cache_baseline_tagger: cache baseline tagger to this file (only interesting as a temporary workaround to get\n                                  deterministic output from the baseline unigram tagger between python versions)\n    :type cache_baseline_tagger: C{string}\n\n\n    Note on separate_baseline_data: if True, reuse training data both for baseline and rule learner. This\n    is fast and fine for a demo, but is likely to generalize worse on unseen data.\n    Also cannot be sensibly used for learning curves on training data (the baseline will be artificially high).\n    \"\"\"\n\n    # defaults\n    baseline_backoff_tagger = baseline_backoff_tagger or REGEXP_TAGGER\n    if templates is None:\n        from nltk.tag.brill import brill24, describe_template_sets\n\n        # some pre-built template sets taken from typical systems or publications are\n        # available. Print a list with describe_template_sets()\n        # for instance:\n        templates = brill24()\n    (training_data, baseline_data, gold_data, testing_data) = _demo_prepare_data(\n        tagged_data, train, num_sents, randomize, separate_baseline_data\n    )\n\n    # creating (or reloading from cache) a baseline tagger (unigram tagger)\n    # this is just a mechanism for getting deterministic output from the baseline between\n    # python versions\n    if cache_baseline_tagger:\n        if not os.path.exists(cache_baseline_tagger):\n            baseline_tagger = UnigramTagger(\n                baseline_data, backoff=baseline_backoff_tagger\n            )\n            with open(cache_baseline_tagger, \"w\") as print_rules:\n                pickle.dump(baseline_tagger, print_rules)\n            print(\n                \"Trained baseline tagger, pickled it to {}\".format(\n                    cache_baseline_tagger\n                )\n            )\n        with open(cache_baseline_tagger) as print_rules:\n            baseline_tagger = pickle.load(print_rules)\n            print(f\"Reloaded pickled tagger from {cache_baseline_tagger}\")\n    else:\n        baseline_tagger = UnigramTagger(baseline_data, backoff=baseline_backoff_tagger)\n        print(\"Trained baseline tagger\")\n    if gold_data:\n        print(\n            \"    Accuracy on test set: {:0.4f}\".format(\n                baseline_tagger.evaluate(gold_data)\n            )\n        )\n\n    # creating a Brill tagger\n    tbrill = time.time()\n    trainer = BrillTaggerTrainer(\n        baseline_tagger, templates, trace, ruleformat=ruleformat\n    )\n    print(\"Training tbl tagger...\")\n    brill_tagger = trainer.train(training_data, max_rules, min_score, min_acc)\n    print(f\"Trained tbl tagger in {time.time() - tbrill:0.2f} seconds\")\n    if gold_data:\n        print(\"    Accuracy on test set: %.4f\" % brill_tagger.evaluate(gold_data))\n\n    # printing the learned rules, if learned silently\n    if trace == 1:\n        print(\"\\nLearned rules: \")\n        for (ruleno, rule) in enumerate(brill_tagger.rules(), 1):\n            print(f\"{ruleno:4d} {rule.format(ruleformat):s}\")\n\n    # printing template statistics (optionally including comparison with the training data)\n    # note: if not separate_baseline_data, then baseline accuracy will be artificially high\n    if incremental_stats:\n        print(\n            \"Incrementally tagging the test data, collecting individual rule statistics\"\n        )\n        (taggedtest, teststats) = brill_tagger.batch_tag_incremental(\n            testing_data, gold_data\n        )\n        print(\"    Rule statistics collected\")\n        if not separate_baseline_data:\n            print(\n                \"WARNING: train_stats asked for separate_baseline_data=True; the baseline \"\n                \"will be artificially high\"\n            )\n        trainstats = brill_tagger.train_stats()\n        if template_stats:\n            brill_tagger.print_template_statistics(teststats)\n        if learning_curve_output:\n            _demo_plot(\n                learning_curve_output, teststats, trainstats, take=learning_curve_take\n            )\n            print(f\"Wrote plot of learning curve to {learning_curve_output}\")\n    else:\n        print(\"Tagging the test data\")\n        taggedtest = brill_tagger.tag_sents(testing_data)\n        if template_stats:\n            brill_tagger.print_template_statistics()\n\n    # writing error analysis to file\n    if error_output is not None:\n        with open(error_output, \"w\") as f:\n            f.write(\"Errors for Brill Tagger %r\\n\\n\" % serialize_output)\n            f.write(\"\\n\".join(error_list(gold_data, taggedtest)).encode(\"utf-8\") + \"\\n\")\n        print(f\"Wrote tagger errors including context to {error_output}\")\n\n    # serializing the tagger to a pickle file and reloading (just to see it works)\n    if serialize_output is not None:\n        taggedtest = brill_tagger.tag_sents(testing_data)\n        with open(serialize_output, \"w\") as print_rules:\n            pickle.dump(brill_tagger, print_rules)\n        print(f\"Wrote pickled tagger to {serialize_output}\")\n        with open(serialize_output) as print_rules:\n            brill_tagger_reloaded = pickle.load(print_rules)\n        print(f\"Reloaded pickled tagger from {serialize_output}\")\n        taggedtest_reloaded = brill_tagger.tag_sents(testing_data)\n        if taggedtest == taggedtest_reloaded:\n            print(\"Reloaded tagger tried on test set, results identical\")\n        else:\n            print(\"PROBLEM: Reloaded tagger gave different results on test set\")\n\n\ndef _demo_prepare_data(\n    tagged_data, train, num_sents, randomize, separate_baseline_data\n):\n    # train is the proportion of data used in training; the rest is reserved\n    # for testing.\n    if tagged_data is None:\n        print(\"Loading tagged data from treebank... \")\n        tagged_data = treebank.tagged_sents()\n    if num_sents is None or len(tagged_data) <= num_sents:\n        num_sents = len(tagged_data)\n    if randomize:\n        random.seed(len(tagged_data))\n        random.shuffle(tagged_data)\n    cutoff = int(num_sents * train)\n    training_data = tagged_data[:cutoff]\n    gold_data = tagged_data[cutoff:num_sents]\n    testing_data = [[t[0] for t in sent] for sent in gold_data]\n    if not separate_baseline_data:\n        baseline_data = training_data\n    else:\n        bl_cutoff = len(training_data) // 3\n        (baseline_data, training_data) = (\n            training_data[:bl_cutoff],\n            training_data[bl_cutoff:],\n        )\n    (trainseqs, traintokens) = corpus_size(training_data)\n    (testseqs, testtokens) = corpus_size(testing_data)\n    (bltrainseqs, bltraintokens) = corpus_size(baseline_data)\n    print(f\"Read testing data ({testseqs:d} sents/{testtokens:d} wds)\")\n    print(f\"Read training data ({trainseqs:d} sents/{traintokens:d} wds)\")\n    print(\n        \"Read baseline data ({:d} sents/{:d} wds) {:s}\".format(\n            bltrainseqs,\n            bltraintokens,\n            \"\" if separate_baseline_data else \"[reused the training set]\",\n        )\n    )\n    return (training_data, baseline_data, gold_data, testing_data)\n\n\ndef _demo_plot(learning_curve_output, teststats, trainstats=None, take=None):\n    testcurve = [teststats[\"initialerrors\"]]\n    for rulescore in teststats[\"rulescores\"]:\n        testcurve.append(testcurve[-1] - rulescore)\n    testcurve = [1 - x / teststats[\"tokencount\"] for x in testcurve[:take]]\n\n    traincurve = [trainstats[\"initialerrors\"]]\n    for rulescore in trainstats[\"rulescores\"]:\n        traincurve.append(traincurve[-1] - rulescore)\n    traincurve = [1 - x / trainstats[\"tokencount\"] for x in traincurve[:take]]\n\n    import matplotlib.pyplot as plt\n\n    r = list(range(len(testcurve)))\n    plt.plot(r, testcurve, r, traincurve)\n    plt.axis([None, None, None, 1.0])\n    plt.savefig(learning_curve_output)\n\n\nNN_CD_TAGGER = RegexpTagger([(r\"^-?[0-9]+(.[0-9]+)?$\", \"CD\"), (r\".*\", \"NN\")])\n\nREGEXP_TAGGER = RegexpTagger(\n    [\n        (r\"^-?[0-9]+(.[0-9]+)?$\", \"CD\"),  # cardinal numbers\n        (r\"(The|the|A|a|An|an)$\", \"AT\"),  # articles\n        (r\".*able$\", \"JJ\"),  # adjectives\n        (r\".*ness$\", \"NN\"),  # nouns formed from adjectives\n        (r\".*ly$\", \"RB\"),  # adverbs\n        (r\".*s$\", \"NNS\"),  # plural nouns\n        (r\".*ing$\", \"VBG\"),  # gerunds\n        (r\".*ed$\", \"VBD\"),  # past tense verbs\n        (r\".*\", \"NN\"),  # nouns (default)\n    ]\n)\n\n\ndef corpus_size(seqs):\n    return (len(seqs), sum(len(x) for x in seqs))\n\n\nif __name__ == \"__main__\":\n    demo_learning_curve()\n"], "fixing_code": ["# Natural Language Toolkit: Interface to MaltParser\n#\n# Author: Dan Garrette <dhgarrette@gmail.com>\n# Contributor: Liling Tan, Mustufain, osamamukhtar11\n#\n# Copyright (C) 2001-2021 NLTK Project\n# URL: <https://www.nltk.org/>\n# For license information, see LICENSE.TXT\n\nimport inspect\nimport os\nimport subprocess\nimport sys\nimport tempfile\n\nfrom nltk.data import ZipFilePathPointer\nfrom nltk.internals import find_dir, find_file, find_jars_within_path\nfrom nltk.parse.api import ParserI\nfrom nltk.parse.dependencygraph import DependencyGraph\nfrom nltk.parse.util import taggedsents_to_conll\n\n\ndef malt_regex_tagger():\n    from nltk.tag import RegexpTagger\n\n    _tagger = RegexpTagger(\n        [\n            (r\"\\.$\", \".\"),\n            (r\"\\,$\", \",\"),\n            (r\"\\?$\", \"?\"),  # fullstop, comma, Qmark\n            (r\"\\($\", \"(\"),\n            (r\"\\)$\", \")\"),  # round brackets\n            (r\"\\[$\", \"[\"),\n            (r\"\\]$\", \"]\"),  # square brackets\n            (r\"^-?[0-9]+(\\.[0-9]+)?$\", \"CD\"),  # cardinal numbers\n            (r\"(The|the|A|a|An|an)$\", \"DT\"),  # articles\n            (r\"(He|he|She|she|It|it|I|me|Me|You|you)$\", \"PRP\"),  # pronouns\n            (r\"(His|his|Her|her|Its|its)$\", \"PRP$\"),  # possessive\n            (r\"(my|Your|your|Yours|yours)$\", \"PRP$\"),  # possessive\n            (r\"(on|On|in|In|at|At|since|Since)$\", \"IN\"),  # time prepopsitions\n            (r\"(for|For|ago|Ago|before|Before)$\", \"IN\"),  # time prepopsitions\n            (r\"(till|Till|until|Until)$\", \"IN\"),  # time prepopsitions\n            (r\"(by|By|beside|Beside)$\", \"IN\"),  # space prepopsitions\n            (r\"(under|Under|below|Below)$\", \"IN\"),  # space prepopsitions\n            (r\"(over|Over|above|Above)$\", \"IN\"),  # space prepopsitions\n            (r\"(across|Across|through|Through)$\", \"IN\"),  # space prepopsitions\n            (r\"(into|Into|towards|Towards)$\", \"IN\"),  # space prepopsitions\n            (r\"(onto|Onto|from|From)$\", \"IN\"),  # space prepopsitions\n            (r\".*able$\", \"JJ\"),  # adjectives\n            (r\".*ness$\", \"NN\"),  # nouns formed from adjectives\n            (r\".*ly$\", \"RB\"),  # adverbs\n            (r\".*s$\", \"NNS\"),  # plural nouns\n            (r\".*ing$\", \"VBG\"),  # gerunds\n            (r\".*ed$\", \"VBD\"),  # past tense verbs\n            (r\".*\", \"NN\"),  # nouns (default)\n        ]\n    )\n    return _tagger.tag\n\n\ndef find_maltparser(parser_dirname):\n    \"\"\"\n    A module to find MaltParser .jar file and its dependencies.\n    \"\"\"\n    if os.path.exists(parser_dirname):  # If a full path is given.\n        _malt_dir = parser_dirname\n    else:  # Try to find path to maltparser directory in environment variables.\n        _malt_dir = find_dir(parser_dirname, env_vars=(\"MALT_PARSER\",))\n    # Checks that that the found directory contains all the necessary .jar\n    malt_dependencies = [\"\", \"\", \"\"]\n    _malt_jars = set(find_jars_within_path(_malt_dir))\n    _jars = {os.path.split(jar)[1] for jar in _malt_jars}\n    malt_dependencies = {\"log4j.jar\", \"libsvm.jar\", \"liblinear-1.8.jar\"}\n\n    assert malt_dependencies.issubset(_jars)\n    assert any(\n        filter(lambda i: i.startswith(\"maltparser-\") and i.endswith(\".jar\"), _jars)\n    )\n    return list(_malt_jars)\n\n\ndef find_malt_model(model_filename):\n    \"\"\"\n    A module to find pre-trained MaltParser model.\n    \"\"\"\n    if model_filename is None:\n        return \"malt_temp.mco\"\n    elif os.path.exists(model_filename):  # If a full path is given.\n        return model_filename\n    else:  # Try to find path to malt model in environment variables.\n        return find_file(model_filename, env_vars=(\"MALT_MODEL\",), verbose=False)\n\n\nclass MaltParser(ParserI):\n    \"\"\"\n    A class for dependency parsing with MaltParser. The input is the paths to:\n    - (optionally) a maltparser directory\n    - (optionally) the path to a pre-trained MaltParser .mco model file\n    - (optionally) the tagger to use for POS tagging before parsing\n    - (optionally) additional Java arguments\n\n    Example:\n        >>> from nltk.parse import malt\n        >>> # With MALT_PARSER and MALT_MODEL environment set.\n        >>> mp = malt.MaltParser(model_filename='engmalt.linear-1.7.mco') # doctest: +SKIP\n        >>> mp.parse_one('I shot an elephant in my pajamas .'.split()).tree() # doctest: +SKIP\n        (shot I (elephant an) (in (pajamas my)) .)\n        >>> # Without MALT_PARSER and MALT_MODEL environment.\n        >>> mp = malt.MaltParser('/home/user/maltparser-1.9.2/', '/home/user/engmalt.linear-1.7.mco') # doctest: +SKIP\n        >>> mp.parse_one('I shot an elephant in my pajamas .'.split()).tree() # doctest: +SKIP\n        (shot I (elephant an) (in (pajamas my)) .)\n    \"\"\"\n\n    def __init__(\n        self,\n        parser_dirname=\"\",\n        model_filename=None,\n        tagger=None,\n        additional_java_args=None,\n    ):\n        \"\"\"\n        An interface for parsing with the Malt Parser.\n\n        :param parser_dirname: The path to the maltparser directory that\n            contains the maltparser-1.x.jar\n        :type parser_dirname: str\n        :param model_filename: The name of the pre-trained model with .mco file\n            extension. If provided, training will not be required.\n            (see http://www.maltparser.org/mco/mco.html and\n            see http://www.patful.com/chalk/node/185)\n        :type model_filename: str\n        :param tagger: The tagger used to POS tag the raw string before\n            formatting to CONLL format. It should behave like `nltk.pos_tag`\n        :type tagger: function\n        :param additional_java_args: This is the additional Java arguments that\n            one can use when calling Maltparser, usually this is the heapsize\n            limits, e.g. `additional_java_args=['-Xmx1024m']`\n            (see https://goo.gl/mpDBvQ)\n        :type additional_java_args: list\n        \"\"\"\n\n        # Find all the necessary jar files for MaltParser.\n        self.malt_jars = find_maltparser(parser_dirname)\n        # Initialize additional java arguments.\n        self.additional_java_args = (\n            additional_java_args if additional_java_args is not None else []\n        )\n        # Initialize model.\n        self.model = find_malt_model(model_filename)\n        self._trained = self.model != \"malt_temp.mco\"\n        # Set the working_dir parameters i.e. `-w` from MaltParser's option.\n        self.working_dir = tempfile.gettempdir()\n        # Initialize POS tagger.\n        self.tagger = tagger if tagger is not None else malt_regex_tagger()\n\n    def parse_tagged_sents(self, sentences, verbose=False, top_relation_label=\"null\"):\n        \"\"\"\n        Use MaltParser to parse multiple POS tagged sentences. Takes multiple\n        sentences where each sentence is a list of (word, tag) tuples.\n        The sentences must have already been tokenized and tagged.\n\n        :param sentences: Input sentences to parse\n        :type sentence: list(list(tuple(str, str)))\n        :return: iter(iter(``DependencyGraph``)) the dependency graph\n            representation of each sentence\n        \"\"\"\n        if not self._trained:\n            raise Exception(\"Parser has not been trained. Call train() first.\")\n\n        with tempfile.NamedTemporaryFile(\n            prefix=\"malt_input.conll.\", dir=self.working_dir, mode=\"w\", delete=False\n        ) as input_file:\n            with tempfile.NamedTemporaryFile(\n                prefix=\"malt_output.conll.\",\n                dir=self.working_dir,\n                mode=\"w\",\n                delete=False,\n            ) as output_file:\n                # Convert list of sentences to CONLL format.\n                for line in taggedsents_to_conll(sentences):\n                    input_file.write(str(line))\n                input_file.close()\n\n                # Generate command to run maltparser.\n                cmd = self.generate_malt_command(\n                    input_file.name, output_file.name, mode=\"parse\"\n                )\n\n                # This is a maltparser quirk, it needs to be run\n                # where the model file is. otherwise it goes into an awkward\n                # missing .jars or strange -w working_dir problem.\n                _current_path = os.getcwd()  # Remembers the current path.\n                try:  # Change to modelfile path\n                    os.chdir(os.path.split(self.model)[0])\n                except:\n                    pass\n                ret = self._execute(cmd, verbose)  # Run command.\n                os.chdir(_current_path)  # Change back to current path.\n\n                if ret != 0:\n                    raise Exception(\n                        \"MaltParser parsing (%s) failed with exit \"\n                        \"code %d\" % (\" \".join(cmd), ret)\n                    )\n\n                # Must return iter(iter(Tree))\n                with open(output_file.name) as infile:\n                    for tree_str in infile.read().split(\"\\n\\n\"):\n                        yield (\n                            iter(\n                                [\n                                    DependencyGraph(\n                                        tree_str, top_relation_label=top_relation_label\n                                    )\n                                ]\n                            )\n                        )\n\n        os.remove(input_file.name)\n        os.remove(output_file.name)\n\n    def parse_sents(self, sentences, verbose=False, top_relation_label=\"null\"):\n        \"\"\"\n        Use MaltParser to parse multiple sentences.\n        Takes a list of sentences, where each sentence is a list of words.\n        Each sentence will be automatically tagged with this\n        MaltParser instance's tagger.\n\n        :param sentences: Input sentences to parse\n        :type sentence: list(list(str))\n        :return: iter(DependencyGraph)\n        \"\"\"\n        tagged_sentences = (self.tagger(sentence) for sentence in sentences)\n        return self.parse_tagged_sents(\n            tagged_sentences, verbose, top_relation_label=top_relation_label\n        )\n\n    def generate_malt_command(self, inputfilename, outputfilename=None, mode=None):\n        \"\"\"\n        This function generates the maltparser command use at the terminal.\n\n        :param inputfilename: path to the input file\n        :type inputfilename: str\n        :param outputfilename: path to the output file\n        :type outputfilename: str\n        \"\"\"\n\n        cmd = [\"java\"]\n        cmd += self.additional_java_args  # Adds additional java arguments\n        # Joins classpaths with \";\" if on Windows and on Linux/Mac use \":\"\n        classpaths_separator = \";\" if sys.platform.startswith(\"win\") else \":\"\n        cmd += [\n            \"-cp\",\n            classpaths_separator.join(self.malt_jars),\n        ]  # Adds classpaths for jars\n        cmd += [\"org.maltparser.Malt\"]  # Adds the main function.\n\n        # Adds the model file.\n        if os.path.exists(self.model):  # when parsing\n            cmd += [\"-c\", os.path.split(self.model)[-1]]\n        else:  # when learning\n            cmd += [\"-c\", self.model]\n\n        cmd += [\"-i\", inputfilename]\n        if mode == \"parse\":\n            cmd += [\"-o\", outputfilename]\n        cmd += [\"-m\", mode]  # mode use to generate parses.\n        return cmd\n\n    @staticmethod\n    def _execute(cmd, verbose=False):\n        output = None if verbose else subprocess.PIPE\n        p = subprocess.Popen(cmd, stdout=output, stderr=output)\n        return p.wait()\n\n    def train(self, depgraphs, verbose=False):\n        \"\"\"\n        Train MaltParser from a list of ``DependencyGraph`` objects\n\n        :param depgraphs: list of ``DependencyGraph`` objects for training input data\n        :type depgraphs: DependencyGraph\n        \"\"\"\n\n        # Write the conll_str to malt_train.conll file in /tmp/\n        with tempfile.NamedTemporaryFile(\n            prefix=\"malt_train.conll.\", dir=self.working_dir, mode=\"w\", delete=False\n        ) as input_file:\n            input_str = \"\\n\".join(dg.to_conll(10) for dg in depgraphs)\n            input_file.write(str(input_str))\n        # Trains the model with the malt_train.conll\n        self.train_from_file(input_file.name, verbose=verbose)\n        # Removes the malt_train.conll once training finishes.\n        os.remove(input_file.name)\n\n    def train_from_file(self, conll_file, verbose=False):\n        \"\"\"\n        Train MaltParser from a file\n        :param conll_file: str for the filename of the training input data\n        :type conll_file: str\n        \"\"\"\n\n        # If conll_file is a ZipFilePathPointer,\n        # then we need to do some extra massaging\n        if isinstance(conll_file, ZipFilePathPointer):\n            with tempfile.NamedTemporaryFile(\n                prefix=\"malt_train.conll.\", dir=self.working_dir, mode=\"w\", delete=False\n            ) as input_file:\n                with conll_file.open() as conll_input_file:\n                    conll_str = conll_input_file.read()\n                    input_file.write(str(conll_str))\n                return self.train_from_file(input_file.name, verbose=verbose)\n\n        # Generate command to run maltparser.\n        cmd = self.generate_malt_command(conll_file, mode=\"learn\")\n        ret = self._execute(cmd, verbose)\n        if ret != 0:\n            raise Exception(\n                \"MaltParser training (%s) failed with exit \"\n                \"code %d\" % (\" \".join(cmd), ret)\n            )\n        self._trained = True\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    A demonstration function to show how NLTK users can use the malt parser API.\n\n    >>> from nltk import pos_tag\n    >>> assert 'MALT_PARSER' in os.environ, str(\n    ... \"Please set MALT_PARSER in your global environment, e.g.:\\n\"\n    ... \"$ export MALT_PARSER='/home/user/maltparser-1.9.2/'\")\n    >>>\n    >>> assert 'MALT_MODEL' in os.environ, str(\n    ... \"Please set MALT_MODEL in your global environment, e.g.:\\n\"\n    ... \"$ export MALT_MODEL='/home/user/engmalt.linear-1.7.mco'\")\n    >>>\n    >>> _dg1_str = str(\"1    John    _    NNP   _    _    2    SUBJ    _    _\\n\"\n    ...             \"2    sees    _    VB    _    _    0    ROOT    _    _\\n\"\n    ...             \"3    a       _    DT    _    _    4    SPEC    _    _\\n\"\n    ...             \"4    dog     _    NN    _    _    2    OBJ     _    _\\n\"\n    ...             \"5    .     _    .    _    _    2    PUNCT     _    _\\n\")\n    >>>\n    >>>\n    >>> _dg2_str  = str(\"1    John    _    NNP   _    _    2    SUBJ    _    _\\n\"\n    ...             \"2    walks   _    VB    _    _    0    ROOT    _    _\\n\"\n    ...             \"3    .     _    .    _    _    2    PUNCT     _    _\\n\")\n    >>> dg1 = DependencyGraph(_dg1_str)\n    >>> dg2 = DependencyGraph(_dg2_str)\n    >>> # Initialize a MaltParser object\n    >>> mp = MaltParser()\n    >>>\n    >>> # Trains a model.\n    >>> mp.train([dg1,dg2], verbose=False)\n    >>> sent1 = ['John','sees','Mary', '.']\n    >>> sent2 = ['John', 'walks', 'a', 'dog', '.']\n    >>>\n    >>> # Parse a single sentence.\n    >>> parsed_sent1 = mp.parse_one(sent1)\n    >>> parsed_sent2 = mp.parse_one(sent2)\n    >>> print(parsed_sent1.tree())\n    (sees John Mary .)\n    >>> print(parsed_sent2.tree())\n    (walks John (dog a) .)\n    >>>\n    >>> # Parsing multiple sentences.\n    >>> sentences = [sent1,sent2]\n    >>> parsed_sents = mp.parse_sents(sentences)\n    >>> print(next(next(parsed_sents)).tree())\n    (sees John Mary .)\n    >>> print(next(next(parsed_sents)).tree())\n    (walks John (dog a) .)\n    >>>\n    >>> # Initialize a MaltParser object with an English pre-trained model.\n    >>> parser_dirname = 'maltparser-1.9.2'\n    >>> model_name = 'engmalt.linear-1.7.mco'\n    >>> mp = MaltParser(parser_dirname=parser_dirname, model_filename=model_name, tagger=pos_tag)\n    >>> sent1 = 'I shot an elephant in my pajamas .'.split()\n    >>> sent2 = 'Time flies like banana .'.split()\n    >>> # Parse a single sentence.\n    >>> print(mp.parse_one(sent1).tree())\n    (shot I (elephant an) (in (pajamas my)) .)\n    # Parsing multiple sentences\n    >>> sentences = [sent1,sent2]\n    >>> parsed_sents = mp.parse_sents(sentences)\n    >>> print(next(next(parsed_sents)).tree())\n    (shot I (elephant an) (in (pajamas my)) .)\n    >>> print(next(next(parsed_sents)).tree())\n    (flies Time (like banana) .)\n    \"\"\"\n\n    import doctest\n\n    doctest.testmod()\n", "# Natural Language Toolkit: Glue Semantics\n#\n# Author: Dan Garrette <dhgarrette@gmail.com>\n#\n# Copyright (C) 2001-2021 NLTK Project\n# URL: <https://www.nltk.org/>\n# For license information, see LICENSE.TXT\n\nimport os\nfrom itertools import chain\n\nimport nltk\nfrom nltk.internals import Counter\nfrom nltk.sem import drt, linearlogic\nfrom nltk.sem.logic import (\n    AbstractVariableExpression,\n    Expression,\n    LambdaExpression,\n    Variable,\n    VariableExpression,\n)\nfrom nltk.tag import BigramTagger, RegexpTagger, TrigramTagger, UnigramTagger\n\nSPEC_SEMTYPES = {\n    \"a\": \"ex_quant\",\n    \"an\": \"ex_quant\",\n    \"every\": \"univ_quant\",\n    \"the\": \"def_art\",\n    \"no\": \"no_quant\",\n    \"default\": \"ex_quant\",\n}\n\nOPTIONAL_RELATIONSHIPS = [\"nmod\", \"vmod\", \"punct\"]\n\n\nclass GlueFormula:\n    def __init__(self, meaning, glue, indices=None):\n        if not indices:\n            indices = set()\n\n        if isinstance(meaning, str):\n            self.meaning = Expression.fromstring(meaning)\n        elif isinstance(meaning, Expression):\n            self.meaning = meaning\n        else:\n            raise RuntimeError(\n                \"Meaning term neither string or expression: %s, %s\"\n                % (meaning, meaning.__class__)\n            )\n\n        if isinstance(glue, str):\n            self.glue = linearlogic.LinearLogicParser().parse(glue)\n        elif isinstance(glue, linearlogic.Expression):\n            self.glue = glue\n        else:\n            raise RuntimeError(\n                \"Glue term neither string or expression: %s, %s\"\n                % (glue, glue.__class__)\n            )\n\n        self.indices = indices\n\n    def applyto(self, arg):\n        \"\"\"self = (\\\\x.(walk x), (subj -o f))\n        arg  = (john        ,  subj)\n        returns ((walk john),          f)\n        \"\"\"\n        if self.indices & arg.indices:  # if the sets are NOT disjoint\n            raise linearlogic.LinearLogicApplicationException(\n                f\"'{self}' applied to '{arg}'.  Indices are not disjoint.\"\n            )\n        else:  # if the sets ARE disjoint\n            return_indices = self.indices | arg.indices\n\n        try:\n            return_glue = linearlogic.ApplicationExpression(\n                self.glue, arg.glue, arg.indices\n            )\n        except linearlogic.LinearLogicApplicationException as e:\n            raise linearlogic.LinearLogicApplicationException(\n                f\"'{self.simplify()}' applied to '{arg.simplify()}'\"\n            ) from e\n\n        arg_meaning_abstracted = arg.meaning\n        if return_indices:\n            for dep in self.glue.simplify().antecedent.dependencies[\n                ::-1\n            ]:  # if self.glue is (A -o B), dep is in A.dependencies\n                arg_meaning_abstracted = self.make_LambdaExpression(\n                    Variable(\"v%s\" % dep), arg_meaning_abstracted\n                )\n        return_meaning = self.meaning.applyto(arg_meaning_abstracted)\n\n        return self.__class__(return_meaning, return_glue, return_indices)\n\n    def make_VariableExpression(self, name):\n        return VariableExpression(name)\n\n    def make_LambdaExpression(self, variable, term):\n        return LambdaExpression(variable, term)\n\n    def lambda_abstract(self, other):\n        assert isinstance(other, GlueFormula)\n        assert isinstance(other.meaning, AbstractVariableExpression)\n        return self.__class__(\n            self.make_LambdaExpression(other.meaning.variable, self.meaning),\n            linearlogic.ImpExpression(other.glue, self.glue),\n        )\n\n    def compile(self, counter=None):\n        \"\"\"From Iddo Lev's PhD Dissertation p108-109\"\"\"\n        if not counter:\n            counter = Counter()\n        (compiled_glue, new_forms) = self.glue.simplify().compile_pos(\n            counter, self.__class__\n        )\n        return new_forms + [\n            self.__class__(self.meaning, compiled_glue, {counter.get()})\n        ]\n\n    def simplify(self):\n        return self.__class__(\n            self.meaning.simplify(), self.glue.simplify(), self.indices\n        )\n\n    def __eq__(self, other):\n        return (\n            self.__class__ == other.__class__\n            and self.meaning == other.meaning\n            and self.glue == other.glue\n        )\n\n    def __ne__(self, other):\n        return not self == other\n\n    # sorting for use in doctests which must be deterministic\n    def __lt__(self, other):\n        return str(self) < str(other)\n\n    def __str__(self):\n        assert isinstance(self.indices, set)\n        accum = f\"{self.meaning} : {self.glue}\"\n        if self.indices:\n            accum += (\n                \" : {\" + \", \".join(str(index) for index in sorted(self.indices)) + \"}\"\n            )\n        return accum\n\n    def __repr__(self):\n        return \"%s\" % self\n\n\nclass GlueDict(dict):\n    def __init__(self, filename, encoding=None):\n        self.filename = filename\n        self.file_encoding = encoding\n        self.read_file()\n\n    def read_file(self, empty_first=True):\n        if empty_first:\n            self.clear()\n\n        try:\n            contents = nltk.data.load(\n                self.filename, format=\"text\", encoding=self.file_encoding\n            )\n            # TODO: the above can't handle zip files, but this should anyway be fixed in nltk.data.load()\n        except LookupError as e:\n            try:\n                contents = nltk.data.load(\n                    \"file:\" + self.filename, format=\"text\", encoding=self.file_encoding\n                )\n            except LookupError:\n                raise e\n        lines = contents.splitlines()\n\n        for line in lines:  # example: 'n : (\\\\x.(<word> x), (v-or))'\n            #     lambdacalc -^  linear logic -^\n            line = line.strip()  # remove trailing newline\n            if not len(line):\n                continue  # skip empty lines\n            if line[0] == \"#\":\n                continue  # skip commented out lines\n\n            parts = line.split(\n                \" : \", 2\n            )  # ['verb', '(\\\\x.(<word> x), ( subj -o f ))', '[subj]']\n\n            glue_formulas = []\n            paren_count = 0\n            tuple_start = 0\n            tuple_comma = 0\n\n            relationships = None\n\n            if len(parts) > 1:\n                for (i, c) in enumerate(parts[1]):\n                    if c == \"(\":\n                        if paren_count == 0:  # if it's the first '(' of a tuple\n                            tuple_start = i + 1  # then save the index\n                        paren_count += 1\n                    elif c == \")\":\n                        paren_count -= 1\n                        if paren_count == 0:  # if it's the last ')' of a tuple\n                            meaning_term = parts[1][\n                                tuple_start:tuple_comma\n                            ]  # '\\\\x.(<word> x)'\n                            glue_term = parts[1][tuple_comma + 1 : i]  # '(v-r)'\n                            glue_formulas.append(\n                                [meaning_term, glue_term]\n                            )  # add the GlueFormula to the list\n                    elif c == \",\":\n                        if (\n                            paren_count == 1\n                        ):  # if it's a comma separating the parts of the tuple\n                            tuple_comma = i  # then save the index\n                    elif c == \"#\":  # skip comments at the ends of lines\n                        if (\n                            paren_count != 0\n                        ):  # if the line hasn't parsed correctly so far\n                            raise RuntimeError(\n                                \"Formula syntax is incorrect for entry \" + line\n                            )\n                        break  # break to the next line\n\n            if len(parts) > 2:  # if there is a relationship entry at the end\n                rel_start = parts[2].index(\"[\") + 1\n                rel_end = parts[2].index(\"]\")\n                if rel_start == rel_end:\n                    relationships = frozenset()\n                else:\n                    relationships = frozenset(\n                        r.strip() for r in parts[2][rel_start:rel_end].split(\",\")\n                    )\n\n            try:\n                start_inheritance = parts[0].index(\"(\")\n                end_inheritance = parts[0].index(\")\")\n                sem = parts[0][:start_inheritance].strip()\n                supertype = parts[0][start_inheritance + 1 : end_inheritance]\n            except:\n                sem = parts[0].strip()\n                supertype = None\n\n            if sem not in self:\n                self[sem] = {}\n\n            if (\n                relationships is None\n            ):  # if not specified for a specific relationship set\n                # add all relationship entries for parents\n                if supertype:\n                    for rels in self[supertype]:\n                        if rels not in self[sem]:\n                            self[sem][rels] = []\n                        glue = self[supertype][rels]\n                        self[sem][rels].extend(glue)\n                        self[sem][rels].extend(\n                            glue_formulas\n                        )  # add the glue formulas to every rel entry\n                else:\n                    if None not in self[sem]:\n                        self[sem][None] = []\n                    self[sem][None].extend(\n                        glue_formulas\n                    )  # add the glue formulas to every rel entry\n            else:\n                if relationships not in self[sem]:\n                    self[sem][relationships] = []\n                if supertype:\n                    self[sem][relationships].extend(self[supertype][relationships])\n                self[sem][relationships].extend(\n                    glue_formulas\n                )  # add the glue entry to the dictionary\n\n    def __str__(self):\n        accum = \"\"\n        for pos in self:\n            str_pos = \"%s\" % pos\n            for relset in self[pos]:\n                i = 1\n                for gf in self[pos][relset]:\n                    if i == 1:\n                        accum += str_pos + \": \"\n                    else:\n                        accum += \" \" * (len(str_pos) + 2)\n                    accum += \"%s\" % gf\n                    if relset and i == len(self[pos][relset]):\n                        accum += \" : %s\" % relset\n                    accum += \"\\n\"\n                    i += 1\n        return accum\n\n    def to_glueformula_list(self, depgraph, node=None, counter=None, verbose=False):\n        if node is None:\n            # TODO: should it be depgraph.root? Is this code tested?\n            top = depgraph.nodes[0]\n            depList = list(chain.from_iterable(top[\"deps\"].values()))\n            root = depgraph.nodes[depList[0]]\n\n            return self.to_glueformula_list(depgraph, root, Counter(), verbose)\n\n        glueformulas = self.lookup(node, depgraph, counter)\n        for dep_idx in chain.from_iterable(node[\"deps\"].values()):\n            dep = depgraph.nodes[dep_idx]\n            glueformulas.extend(\n                self.to_glueformula_list(depgraph, dep, counter, verbose)\n            )\n        return glueformulas\n\n    def lookup(self, node, depgraph, counter):\n        semtype_names = self.get_semtypes(node)\n\n        semtype = None\n        for name in semtype_names:\n            if name in self:\n                semtype = self[name]\n                break\n        if semtype is None:\n            # raise KeyError, \"There is no GlueDict entry for sem type '%s' (for '%s')\" % (sem, word)\n            return []\n\n        self.add_missing_dependencies(node, depgraph)\n\n        lookup = self._lookup_semtype_option(semtype, node, depgraph)\n\n        if not len(lookup):\n            raise KeyError(\n                \"There is no GlueDict entry for sem type of '%s' \"\n                \"with tag '%s', and rel '%s'\" % (node[\"word\"], node[\"tag\"], node[\"rel\"])\n            )\n\n        return self.get_glueformulas_from_semtype_entry(\n            lookup, node[\"word\"], node, depgraph, counter\n        )\n\n    def add_missing_dependencies(self, node, depgraph):\n        rel = node[\"rel\"].lower()\n\n        if rel == \"main\":\n            headnode = depgraph.nodes[node[\"head\"]]\n            subj = self.lookup_unique(\"subj\", headnode, depgraph)\n            relation = subj[\"rel\"]\n            node[\"deps\"].setdefault(relation, [])\n            node[\"deps\"][relation].append(subj[\"address\"])\n            # node['deps'].append(subj['address'])\n\n    def _lookup_semtype_option(self, semtype, node, depgraph):\n        relationships = frozenset(\n            depgraph.nodes[dep][\"rel\"].lower()\n            for dep in chain.from_iterable(node[\"deps\"].values())\n            if depgraph.nodes[dep][\"rel\"].lower() not in OPTIONAL_RELATIONSHIPS\n        )\n\n        try:\n            lookup = semtype[relationships]\n        except KeyError:\n            # An exact match is not found, so find the best match where\n            # 'best' is defined as the glue entry whose relationship set has the\n            # most relations of any possible relationship set that is a subset\n            # of the actual depgraph\n            best_match = frozenset()\n            for relset_option in set(semtype) - {None}:\n                if (\n                    len(relset_option) > len(best_match)\n                    and relset_option < relationships\n                ):\n                    best_match = relset_option\n            if not best_match:\n                if None in semtype:\n                    best_match = None\n                else:\n                    return None\n            lookup = semtype[best_match]\n\n        return lookup\n\n    def get_semtypes(self, node):\n        \"\"\"\n        Based on the node, return a list of plausible semtypes in order of\n        plausibility.\n        \"\"\"\n        rel = node[\"rel\"].lower()\n        word = node[\"word\"].lower()\n\n        if rel == \"spec\":\n            if word in SPEC_SEMTYPES:\n                return [SPEC_SEMTYPES[word]]\n            else:\n                return [SPEC_SEMTYPES[\"default\"]]\n        elif rel in [\"nmod\", \"vmod\"]:\n            return [node[\"tag\"], rel]\n        else:\n            return [node[\"tag\"]]\n\n    def get_glueformulas_from_semtype_entry(\n        self, lookup, word, node, depgraph, counter\n    ):\n        glueformulas = []\n\n        glueFormulaFactory = self.get_GlueFormula_factory()\n        for meaning, glue in lookup:\n            gf = glueFormulaFactory(self.get_meaning_formula(meaning, word), glue)\n            if not len(glueformulas):\n                gf.word = word\n            else:\n                gf.word = f\"{word}{len(glueformulas) + 1}\"\n\n            gf.glue = self.initialize_labels(gf.glue, node, depgraph, counter.get())\n\n            glueformulas.append(gf)\n        return glueformulas\n\n    def get_meaning_formula(self, generic, word):\n        \"\"\"\n        :param generic: A meaning formula string containing the\n            parameter \"<word>\"\n        :param word: The actual word to be replace \"<word>\"\n        \"\"\"\n        word = word.replace(\".\", \"\")\n        return generic.replace(\"<word>\", word)\n\n    def initialize_labels(self, expr, node, depgraph, unique_index):\n        if isinstance(expr, linearlogic.AtomicExpression):\n            name = self.find_label_name(expr.name.lower(), node, depgraph, unique_index)\n            if name[0].isupper():\n                return linearlogic.VariableExpression(name)\n            else:\n                return linearlogic.ConstantExpression(name)\n        else:\n            return linearlogic.ImpExpression(\n                self.initialize_labels(expr.antecedent, node, depgraph, unique_index),\n                self.initialize_labels(expr.consequent, node, depgraph, unique_index),\n            )\n\n    def find_label_name(self, name, node, depgraph, unique_index):\n        try:\n            dot = name.index(\".\")\n\n            before_dot = name[:dot]\n            after_dot = name[dot + 1 :]\n            if before_dot == \"super\":\n                return self.find_label_name(\n                    after_dot, depgraph.nodes[node[\"head\"]], depgraph, unique_index\n                )\n            else:\n                return self.find_label_name(\n                    after_dot,\n                    self.lookup_unique(before_dot, node, depgraph),\n                    depgraph,\n                    unique_index,\n                )\n        except ValueError:\n            lbl = self.get_label(node)\n            if name == \"f\":\n                return lbl\n            elif name == \"v\":\n                return \"%sv\" % lbl\n            elif name == \"r\":\n                return \"%sr\" % lbl\n            elif name == \"super\":\n                return self.get_label(depgraph.nodes[node[\"head\"]])\n            elif name == \"var\":\n                return f\"{lbl.upper()}{unique_index}\"\n            elif name == \"a\":\n                return self.get_label(self.lookup_unique(\"conja\", node, depgraph))\n            elif name == \"b\":\n                return self.get_label(self.lookup_unique(\"conjb\", node, depgraph))\n            else:\n                return self.get_label(self.lookup_unique(name, node, depgraph))\n\n    def get_label(self, node):\n        \"\"\"\n        Pick an alphabetic character as identifier for an entity in the model.\n\n        :param value: where to index into the list of characters\n        :type value: int\n        \"\"\"\n        value = node[\"address\"]\n\n        letter = [\n            \"f\",\n            \"g\",\n            \"h\",\n            \"i\",\n            \"j\",\n            \"k\",\n            \"l\",\n            \"m\",\n            \"n\",\n            \"o\",\n            \"p\",\n            \"q\",\n            \"r\",\n            \"s\",\n            \"t\",\n            \"u\",\n            \"v\",\n            \"w\",\n            \"x\",\n            \"y\",\n            \"z\",\n            \"a\",\n            \"b\",\n            \"c\",\n            \"d\",\n            \"e\",\n        ][value - 1]\n        num = int(value) // 26\n        if num > 0:\n            return letter + str(num)\n        else:\n            return letter\n\n    def lookup_unique(self, rel, node, depgraph):\n        \"\"\"\n        Lookup 'key'. There should be exactly one item in the associated relation.\n        \"\"\"\n        deps = [\n            depgraph.nodes[dep]\n            for dep in chain.from_iterable(node[\"deps\"].values())\n            if depgraph.nodes[dep][\"rel\"].lower() == rel.lower()\n        ]\n\n        if len(deps) == 0:\n            raise KeyError(\n                \"'{}' doesn't contain a feature '{}'\".format(node[\"word\"], rel)\n            )\n        elif len(deps) > 1:\n            raise KeyError(\n                \"'{}' should only have one feature '{}'\".format(node[\"word\"], rel)\n            )\n        else:\n            return deps[0]\n\n    def get_GlueFormula_factory(self):\n        return GlueFormula\n\n\nclass Glue:\n    def __init__(\n        self, semtype_file=None, remove_duplicates=False, depparser=None, verbose=False\n    ):\n        self.verbose = verbose\n        self.remove_duplicates = remove_duplicates\n        self.depparser = depparser\n\n        from nltk import Prover9\n\n        self.prover = Prover9()\n\n        if semtype_file:\n            self.semtype_file = semtype_file\n        else:\n            self.semtype_file = os.path.join(\n                \"grammars\", \"sample_grammars\", \"glue.semtype\"\n            )\n\n    def train_depparser(self, depgraphs=None):\n        if depgraphs:\n            self.depparser.train(depgraphs)\n        else:\n            self.depparser.train_from_file(\n                nltk.data.find(\n                    os.path.join(\"grammars\", \"sample_grammars\", \"glue_train.conll\")\n                )\n            )\n\n    def parse_to_meaning(self, sentence):\n        readings = []\n        for agenda in self.parse_to_compiled(sentence):\n            readings.extend(self.get_readings(agenda))\n        return readings\n\n    def get_readings(self, agenda):\n        readings = []\n        agenda_length = len(agenda)\n        atomics = dict()\n        nonatomics = dict()\n        while agenda:  # is not empty\n            cur = agenda.pop()\n            glue_simp = cur.glue.simplify()\n            if isinstance(\n                glue_simp, linearlogic.ImpExpression\n            ):  # if cur.glue is non-atomic\n                for key in atomics:\n                    try:\n                        if isinstance(cur.glue, linearlogic.ApplicationExpression):\n                            bindings = cur.glue.bindings\n                        else:\n                            bindings = linearlogic.BindingDict()\n                        glue_simp.antecedent.unify(key, bindings)\n                        for atomic in atomics[key]:\n                            if not (\n                                cur.indices & atomic.indices\n                            ):  # if the sets of indices are disjoint\n                                try:\n                                    agenda.append(cur.applyto(atomic))\n                                except linearlogic.LinearLogicApplicationException:\n                                    pass\n                    except linearlogic.UnificationException:\n                        pass\n                try:\n                    nonatomics[glue_simp.antecedent].append(cur)\n                except KeyError:\n                    nonatomics[glue_simp.antecedent] = [cur]\n\n            else:  # else cur.glue is atomic\n                for key in nonatomics:\n                    for nonatomic in nonatomics[key]:\n                        try:\n                            if isinstance(\n                                nonatomic.glue, linearlogic.ApplicationExpression\n                            ):\n                                bindings = nonatomic.glue.bindings\n                            else:\n                                bindings = linearlogic.BindingDict()\n                            glue_simp.unify(key, bindings)\n                            if not (\n                                cur.indices & nonatomic.indices\n                            ):  # if the sets of indices are disjoint\n                                try:\n                                    agenda.append(nonatomic.applyto(cur))\n                                except linearlogic.LinearLogicApplicationException:\n                                    pass\n                        except linearlogic.UnificationException:\n                            pass\n                try:\n                    atomics[glue_simp].append(cur)\n                except KeyError:\n                    atomics[glue_simp] = [cur]\n\n        for entry in atomics:\n            for gf in atomics[entry]:\n                if len(gf.indices) == agenda_length:\n                    self._add_to_reading_list(gf, readings)\n        for entry in nonatomics:\n            for gf in nonatomics[entry]:\n                if len(gf.indices) == agenda_length:\n                    self._add_to_reading_list(gf, readings)\n        return readings\n\n    def _add_to_reading_list(self, glueformula, reading_list):\n        add_reading = True\n        if self.remove_duplicates:\n            for reading in reading_list:\n                try:\n                    if reading.equiv(glueformula.meaning, self.prover):\n                        add_reading = False\n                        break\n                except Exception as e:\n                    # if there is an exception, the syntax of the formula\n                    # may not be understandable by the prover, so don't\n                    # throw out the reading.\n                    print(\"Error when checking logical equality of statements\", e)\n\n        if add_reading:\n            reading_list.append(glueformula.meaning)\n\n    def parse_to_compiled(self, sentence):\n        gfls = [self.depgraph_to_glue(dg) for dg in self.dep_parse(sentence)]\n        return [self.gfl_to_compiled(gfl) for gfl in gfls]\n\n    def dep_parse(self, sentence):\n        \"\"\"\n        Return a dependency graph for the sentence.\n\n        :param sentence: the sentence to be parsed\n        :type sentence: list(str)\n        :rtype: DependencyGraph\n        \"\"\"\n\n        # Lazy-initialize the depparser\n        if self.depparser is None:\n            from nltk.parse import MaltParser\n\n            self.depparser = MaltParser(tagger=self.get_pos_tagger())\n        if not self.depparser._trained:\n            self.train_depparser()\n        return self.depparser.parse(sentence, verbose=self.verbose)\n\n    def depgraph_to_glue(self, depgraph):\n        return self.get_glue_dict().to_glueformula_list(depgraph)\n\n    def get_glue_dict(self):\n        return GlueDict(self.semtype_file)\n\n    def gfl_to_compiled(self, gfl):\n        index_counter = Counter()\n        return_list = []\n        for gf in gfl:\n            return_list.extend(gf.compile(index_counter))\n\n        if self.verbose:\n            print(\"Compiled Glue Premises:\")\n            for cgf in return_list:\n                print(cgf)\n\n        return return_list\n\n    def get_pos_tagger(self):\n        from nltk.corpus import brown\n\n        regexp_tagger = RegexpTagger(\n            [\n                (r\"^-?[0-9]+(\\.[0-9]+)?$\", \"CD\"),  # cardinal numbers\n                (r\"(The|the|A|a|An|an)$\", \"AT\"),  # articles\n                (r\".*able$\", \"JJ\"),  # adjectives\n                (r\".*ness$\", \"NN\"),  # nouns formed from adjectives\n                (r\".*ly$\", \"RB\"),  # adverbs\n                (r\".*s$\", \"NNS\"),  # plural nouns\n                (r\".*ing$\", \"VBG\"),  # gerunds\n                (r\".*ed$\", \"VBD\"),  # past tense verbs\n                (r\".*\", \"NN\"),  # nouns (default)\n            ]\n        )\n        brown_train = brown.tagged_sents(categories=\"news\")\n        unigram_tagger = UnigramTagger(brown_train, backoff=regexp_tagger)\n        bigram_tagger = BigramTagger(brown_train, backoff=unigram_tagger)\n        trigram_tagger = TrigramTagger(brown_train, backoff=bigram_tagger)\n\n        # Override particular words\n        main_tagger = RegexpTagger(\n            [(r\"(A|a|An|an)$\", \"ex_quant\"), (r\"(Every|every|All|all)$\", \"univ_quant\")],\n            backoff=trigram_tagger,\n        )\n\n        return main_tagger\n\n\nclass DrtGlueFormula(GlueFormula):\n    def __init__(self, meaning, glue, indices=None):\n        if not indices:\n            indices = set()\n\n        if isinstance(meaning, str):\n            self.meaning = drt.DrtExpression.fromstring(meaning)\n        elif isinstance(meaning, drt.DrtExpression):\n            self.meaning = meaning\n        else:\n            raise RuntimeError(\n                \"Meaning term neither string or expression: %s, %s\"\n                % (meaning, meaning.__class__)\n            )\n\n        if isinstance(glue, str):\n            self.glue = linearlogic.LinearLogicParser().parse(glue)\n        elif isinstance(glue, linearlogic.Expression):\n            self.glue = glue\n        else:\n            raise RuntimeError(\n                \"Glue term neither string or expression: %s, %s\"\n                % (glue, glue.__class__)\n            )\n\n        self.indices = indices\n\n    def make_VariableExpression(self, name):\n        return drt.DrtVariableExpression(name)\n\n    def make_LambdaExpression(self, variable, term):\n        return drt.DrtLambdaExpression(variable, term)\n\n\nclass DrtGlueDict(GlueDict):\n    def get_GlueFormula_factory(self):\n        return DrtGlueFormula\n\n\nclass DrtGlue(Glue):\n    def __init__(\n        self, semtype_file=None, remove_duplicates=False, depparser=None, verbose=False\n    ):\n        if not semtype_file:\n            semtype_file = os.path.join(\n                \"grammars\", \"sample_grammars\", \"drt_glue.semtype\"\n            )\n        Glue.__init__(self, semtype_file, remove_duplicates, depparser, verbose)\n\n    def get_glue_dict(self):\n        return DrtGlueDict(self.semtype_file)\n\n\ndef demo(show_example=-1):\n    from nltk.parse import MaltParser\n\n    examples = [\n        \"David sees Mary\",\n        \"David eats a sandwich\",\n        \"every man chases a dog\",\n        \"every man believes a dog sleeps\",\n        \"John gives David a sandwich\",\n        \"John chases himself\",\n    ]\n    #                'John persuades David to order a pizza',\n    #                'John tries to go',\n    #                'John tries to find a unicorn',\n    #                'John seems to vanish',\n    #                'a unicorn seems to approach',\n    #                'every big cat leaves',\n    #                'every gray cat leaves',\n    #                'every big gray cat leaves',\n    #                'a former senator leaves',\n\n    print(\"============== DEMO ==============\")\n\n    tagger = RegexpTagger(\n        [\n            (\"^(David|Mary|John)$\", \"NNP\"),\n            (\n                \"^(sees|eats|chases|believes|gives|sleeps|chases|persuades|tries|seems|leaves)$\",\n                \"VB\",\n            ),\n            (\"^(go|order|vanish|find|approach)$\", \"VB\"),\n            (\"^(a)$\", \"ex_quant\"),\n            (\"^(every)$\", \"univ_quant\"),\n            (\"^(sandwich|man|dog|pizza|unicorn|cat|senator)$\", \"NN\"),\n            (\"^(big|gray|former)$\", \"JJ\"),\n            (\"^(him|himself)$\", \"PRP\"),\n        ]\n    )\n\n    depparser = MaltParser(tagger=tagger)\n    glue = Glue(depparser=depparser, verbose=False)\n\n    for (i, sentence) in enumerate(examples):\n        if i == show_example or show_example == -1:\n            print(f\"[[[Example {i}]]]  {sentence}\")\n            for reading in glue.parse_to_meaning(sentence.split()):\n                print(reading.simplify())\n            print(\"\")\n\n\nif __name__ == \"__main__\":\n    demo()\n", "# Natural Language Toolkit: Transformation-based learning\n#\n# Copyright (C) 2001-2021 NLTK Project\n# Author: Marcus Uneson <marcus.uneson@gmail.com>\n#   based on previous (nltk2) version by\n#   Christopher Maloof, Edward Loper, Steven Bird\n# URL: <https://www.nltk.org/>\n# For license information, see  LICENSE.TXT\n\nfrom collections import Counter, defaultdict\n\nfrom nltk import jsontags\nfrom nltk.tag import TaggerI\nfrom nltk.tbl import Feature, Template\n\n######################################################################\n# Brill Templates\n######################################################################\n\n\n@jsontags.register_tag\nclass Word(Feature):\n    \"\"\"\n    Feature which examines the text (word) of nearby tokens.\n    \"\"\"\n\n    json_tag = \"nltk.tag.brill.Word\"\n\n    @staticmethod\n    def extract_property(tokens, index):\n        \"\"\"@return: The given token's text.\"\"\"\n        return tokens[index][0]\n\n\n@jsontags.register_tag\nclass Pos(Feature):\n    \"\"\"\n    Feature which examines the tags of nearby tokens.\n    \"\"\"\n\n    json_tag = \"nltk.tag.brill.Pos\"\n\n    @staticmethod\n    def extract_property(tokens, index):\n        \"\"\"@return: The given token's tag.\"\"\"\n        return tokens[index][1]\n\n\ndef nltkdemo18():\n    \"\"\"\n    Return 18 templates, from the original nltk demo, in multi-feature syntax\n    \"\"\"\n    return [\n        Template(Pos([-1])),\n        Template(Pos([1])),\n        Template(Pos([-2])),\n        Template(Pos([2])),\n        Template(Pos([-2, -1])),\n        Template(Pos([1, 2])),\n        Template(Pos([-3, -2, -1])),\n        Template(Pos([1, 2, 3])),\n        Template(Pos([-1]), Pos([1])),\n        Template(Word([-1])),\n        Template(Word([1])),\n        Template(Word([-2])),\n        Template(Word([2])),\n        Template(Word([-2, -1])),\n        Template(Word([1, 2])),\n        Template(Word([-3, -2, -1])),\n        Template(Word([1, 2, 3])),\n        Template(Word([-1]), Word([1])),\n    ]\n\n\ndef nltkdemo18plus():\n    \"\"\"\n    Return 18 templates, from the original nltk demo, and additionally a few\n    multi-feature ones (the motivation is easy comparison with nltkdemo18)\n    \"\"\"\n    return nltkdemo18() + [\n        Template(Word([-1]), Pos([1])),\n        Template(Pos([-1]), Word([1])),\n        Template(Word([-1]), Word([0]), Pos([1])),\n        Template(Pos([-1]), Word([0]), Word([1])),\n        Template(Pos([-1]), Word([0]), Pos([1])),\n    ]\n\n\ndef fntbl37():\n    \"\"\"\n    Return 37 templates taken from the postagging task of the\n    fntbl distribution https://www.cs.jhu.edu/~rflorian/fntbl/\n    (37 is after excluding a handful which do not condition on Pos[0];\n    fntbl can do that but the current nltk implementation cannot.)\n    \"\"\"\n    return [\n        Template(Word([0]), Word([1]), Word([2])),\n        Template(Word([-1]), Word([0]), Word([1])),\n        Template(Word([0]), Word([-1])),\n        Template(Word([0]), Word([1])),\n        Template(Word([0]), Word([2])),\n        Template(Word([0]), Word([-2])),\n        Template(Word([1, 2])),\n        Template(Word([-2, -1])),\n        Template(Word([1, 2, 3])),\n        Template(Word([-3, -2, -1])),\n        Template(Word([0]), Pos([2])),\n        Template(Word([0]), Pos([-2])),\n        Template(Word([0]), Pos([1])),\n        Template(Word([0]), Pos([-1])),\n        Template(Word([0])),\n        Template(Word([-2])),\n        Template(Word([2])),\n        Template(Word([1])),\n        Template(Word([-1])),\n        Template(Pos([-1]), Pos([1])),\n        Template(Pos([1]), Pos([2])),\n        Template(Pos([-1]), Pos([-2])),\n        Template(Pos([1])),\n        Template(Pos([-1])),\n        Template(Pos([-2])),\n        Template(Pos([2])),\n        Template(Pos([1, 2, 3])),\n        Template(Pos([1, 2])),\n        Template(Pos([-3, -2, -1])),\n        Template(Pos([-2, -1])),\n        Template(Pos([1]), Word([0]), Word([1])),\n        Template(Pos([1]), Word([0]), Word([-1])),\n        Template(Pos([-1]), Word([-1]), Word([0])),\n        Template(Pos([-1]), Word([0]), Word([1])),\n        Template(Pos([-2]), Pos([-1])),\n        Template(Pos([1]), Pos([2])),\n        Template(Pos([1]), Pos([2]), Word([1])),\n    ]\n\n\ndef brill24():\n    \"\"\"\n    Return 24 templates of the seminal TBL paper, Brill (1995)\n    \"\"\"\n    return [\n        Template(Pos([-1])),\n        Template(Pos([1])),\n        Template(Pos([-2])),\n        Template(Pos([2])),\n        Template(Pos([-2, -1])),\n        Template(Pos([1, 2])),\n        Template(Pos([-3, -2, -1])),\n        Template(Pos([1, 2, 3])),\n        Template(Pos([-1]), Pos([1])),\n        Template(Pos([-2]), Pos([-1])),\n        Template(Pos([1]), Pos([2])),\n        Template(Word([-1])),\n        Template(Word([1])),\n        Template(Word([-2])),\n        Template(Word([2])),\n        Template(Word([-2, -1])),\n        Template(Word([1, 2])),\n        Template(Word([-1, 0])),\n        Template(Word([0, 1])),\n        Template(Word([0])),\n        Template(Word([-1]), Pos([-1])),\n        Template(Word([1]), Pos([1])),\n        Template(Word([0]), Word([-1]), Pos([-1])),\n        Template(Word([0]), Word([1]), Pos([1])),\n    ]\n\n\ndef describe_template_sets():\n    \"\"\"\n    Print the available template sets in this demo, with a short description\"\n    \"\"\"\n    import inspect\n    import sys\n\n    # a bit of magic to get all functions in this module\n    templatesets = inspect.getmembers(sys.modules[__name__], inspect.isfunction)\n    for (name, obj) in templatesets:\n        if name == \"describe_template_sets\":\n            continue\n        print(name, obj.__doc__, \"\\n\")\n\n\n######################################################################\n# The Brill Tagger\n######################################################################\n\n\n@jsontags.register_tag\nclass BrillTagger(TaggerI):\n    \"\"\"\n    Brill's transformational rule-based tagger.  Brill taggers use an\n    initial tagger (such as ``tag.DefaultTagger``) to assign an initial\n    tag sequence to a text; and then apply an ordered list of\n    transformational rules to correct the tags of individual tokens.\n    These transformation rules are specified by the ``TagRule``\n    interface.\n\n    Brill taggers can be created directly, from an initial tagger and\n    a list of transformational rules; but more often, Brill taggers\n    are created by learning rules from a training corpus, using one\n    of the TaggerTrainers available.\n    \"\"\"\n\n    json_tag = \"nltk.tag.BrillTagger\"\n\n    def __init__(self, initial_tagger, rules, training_stats=None):\n        \"\"\"\n        :param initial_tagger: The initial tagger\n        :type initial_tagger: TaggerI\n\n        :param rules: An ordered list of transformation rules that\n            should be used to correct the initial tagging.\n        :type rules: list(TagRule)\n\n        :param training_stats: A dictionary of statistics collected\n            during training, for possible later use\n        :type training_stats: dict\n\n        \"\"\"\n        self._initial_tagger = initial_tagger\n        self._rules = tuple(rules)\n        self._training_stats = training_stats\n\n    def encode_json_obj(self):\n        return self._initial_tagger, self._rules, self._training_stats\n\n    @classmethod\n    def decode_json_obj(cls, obj):\n        _initial_tagger, _rules, _training_stats = obj\n        return cls(_initial_tagger, _rules, _training_stats)\n\n    def rules(self):\n        \"\"\"\n        Return the ordered list of  transformation rules that this tagger has learnt\n\n        :return: the ordered list of transformation rules that correct the initial tagging\n        :rtype: list of Rules\n        \"\"\"\n        return self._rules\n\n    def train_stats(self, statistic=None):\n        \"\"\"\n        Return a named statistic collected during training, or a dictionary of all\n        available statistics if no name given\n\n        :param statistic: name of statistic\n        :type statistic: str\n        :return: some statistic collected during training of this tagger\n        :rtype: any (but usually a number)\n        \"\"\"\n        if statistic is None:\n            return self._training_stats\n        else:\n            return self._training_stats.get(statistic)\n\n    def tag(self, tokens):\n        # Inherit documentation from TaggerI\n\n        # Run the initial tagger.\n        tagged_tokens = self._initial_tagger.tag(tokens)\n\n        # Create a dictionary that maps each tag to a list of the\n        # indices of tokens that have that tag.\n        tag_to_positions = defaultdict(set)\n        for i, (token, tag) in enumerate(tagged_tokens):\n            tag_to_positions[tag].add(i)\n\n        # Apply each rule, in order.  Only try to apply rules at\n        # positions that have the desired original tag.\n        for rule in self._rules:\n            # Find the positions where it might apply\n            positions = tag_to_positions.get(rule.original_tag, [])\n            # Apply the rule at those positions.\n            changed = rule.apply(tagged_tokens, positions)\n            # Update tag_to_positions with the positions of tags that\n            # were modified.\n            for i in changed:\n                tag_to_positions[rule.original_tag].remove(i)\n                tag_to_positions[rule.replacement_tag].add(i)\n\n        return tagged_tokens\n\n    def print_template_statistics(self, test_stats=None, printunused=True):\n        \"\"\"\n        Print a list of all templates, ranked according to efficiency.\n\n        If test_stats is available, the templates are ranked according to their\n        relative contribution (summed for all rules created from a given template,\n        weighted by score) to the performance on the test set. If no test_stats, then\n        statistics collected during training are used instead. There is also\n        an unweighted measure (just counting the rules). This is less informative,\n        though, as many low-score rules will appear towards end of training.\n\n        :param test_stats: dictionary of statistics collected during testing\n        :type test_stats: dict of str -> any (but usually numbers)\n        :param printunused: if True, print a list of all unused templates\n        :type printunused: bool\n        :return: None\n        :rtype: None\n        \"\"\"\n        tids = [r.templateid for r in self._rules]\n        train_stats = self.train_stats()\n\n        trainscores = train_stats[\"rulescores\"]\n        assert len(trainscores) == len(\n            tids\n        ), \"corrupt statistics: \" \"{} train scores for {} rules\".format(\n            trainscores, tids\n        )\n        template_counts = Counter(tids)\n        weighted_traincounts = Counter()\n        for (tid, score) in zip(tids, trainscores):\n            weighted_traincounts[tid] += score\n        tottrainscores = sum(trainscores)\n\n        # det_tplsort() is for deterministic sorting;\n        # the otherwise convenient Counter.most_common() unfortunately\n        # does not break ties deterministically\n        # between python versions and will break cross-version tests\n        def det_tplsort(tpl_value):\n            return (tpl_value[1], repr(tpl_value[0]))\n\n        def print_train_stats():\n            print(\n                \"TEMPLATE STATISTICS (TRAIN)  {} templates, {} rules)\".format(\n                    len(template_counts), len(tids)\n                )\n            )\n            print(\n                \"TRAIN ({tokencount:7d} tokens) initial {initialerrors:5d} {initialacc:.4f} \"\n                \"final: {finalerrors:5d} {finalacc:.4f}\".format(**train_stats)\n            )\n            head = \"#ID | Score (train) |  #Rules     | Template\"\n            print(head, \"\\n\", \"-\" * len(head), sep=\"\")\n            train_tplscores = sorted(\n                weighted_traincounts.items(), key=det_tplsort, reverse=True\n            )\n            for (tid, trainscore) in train_tplscores:\n                s = \"{} | {:5d}   {:5.3f} |{:4d}   {:.3f} | {}\".format(\n                    tid,\n                    trainscore,\n                    trainscore / tottrainscores,\n                    template_counts[tid],\n                    template_counts[tid] / len(tids),\n                    Template.ALLTEMPLATES[int(tid)],\n                )\n                print(s)\n\n        def print_testtrain_stats():\n            testscores = test_stats[\"rulescores\"]\n            print(\n                \"TEMPLATE STATISTICS (TEST AND TRAIN) ({} templates, {} rules)\".format(\n                    len(template_counts), len(tids)\n                )\n            )\n            print(\n                \"TEST  ({tokencount:7d} tokens) initial {initialerrors:5d} {initialacc:.4f} \"\n                \"final: {finalerrors:5d} {finalacc:.4f} \".format(**test_stats)\n            )\n            print(\n                \"TRAIN ({tokencount:7d} tokens) initial {initialerrors:5d} {initialacc:.4f} \"\n                \"final: {finalerrors:5d} {finalacc:.4f} \".format(**train_stats)\n            )\n            weighted_testcounts = Counter()\n            for (tid, score) in zip(tids, testscores):\n                weighted_testcounts[tid] += score\n            tottestscores = sum(testscores)\n            head = \"#ID | Score (test) | Score (train) |  #Rules     | Template\"\n            print(head, \"\\n\", \"-\" * len(head), sep=\"\")\n            test_tplscores = sorted(\n                weighted_testcounts.items(), key=det_tplsort, reverse=True\n            )\n            for (tid, testscore) in test_tplscores:\n                s = \"{:s} |{:5d}  {:6.3f} |  {:4d}   {:.3f} |{:4d}   {:.3f} | {:s}\".format(\n                    tid,\n                    testscore,\n                    testscore / tottestscores,\n                    weighted_traincounts[tid],\n                    weighted_traincounts[tid] / tottrainscores,\n                    template_counts[tid],\n                    template_counts[tid] / len(tids),\n                    Template.ALLTEMPLATES[int(tid)],\n                )\n                print(s)\n\n        def print_unused_templates():\n            usedtpls = {int(tid) for tid in tids}\n            unused = [\n                (tid, tpl)\n                for (tid, tpl) in enumerate(Template.ALLTEMPLATES)\n                if tid not in usedtpls\n            ]\n            print(f\"UNUSED TEMPLATES ({len(unused)})\")\n\n            for (tid, tpl) in unused:\n                print(f\"{tid:03d} {str(tpl):s}\")\n\n        if test_stats is None:\n            print_train_stats()\n        else:\n            print_testtrain_stats()\n        print()\n        if printunused:\n            print_unused_templates()\n        print()\n\n    def batch_tag_incremental(self, sequences, gold):\n        \"\"\"\n        Tags by applying each rule to the entire corpus (rather than all rules to a\n        single sequence). The point is to collect statistics on the test set for\n        individual rules.\n\n        NOTE: This is inefficient (does not build any index, so will traverse the entire\n        corpus N times for N rules) -- usually you would not care about statistics for\n        individual rules and thus use batch_tag() instead\n\n        :param sequences: lists of token sequences (sentences, in some applications) to be tagged\n        :type sequences: list of list of strings\n        :param gold: the gold standard\n        :type gold: list of list of strings\n        :returns: tuple of (tagged_sequences, ordered list of rule scores (one for each rule))\n        \"\"\"\n\n        def counterrors(xs):\n            return sum(t[1] != g[1] for pair in zip(xs, gold) for (t, g) in zip(*pair))\n\n        testing_stats = {}\n        testing_stats[\"tokencount\"] = sum(len(t) for t in sequences)\n        testing_stats[\"sequencecount\"] = len(sequences)\n        tagged_tokenses = [self._initial_tagger.tag(tokens) for tokens in sequences]\n        testing_stats[\"initialerrors\"] = counterrors(tagged_tokenses)\n        testing_stats[\"initialacc\"] = (\n            1 - testing_stats[\"initialerrors\"] / testing_stats[\"tokencount\"]\n        )\n        # Apply each rule to the entire corpus, in order\n        errors = [testing_stats[\"initialerrors\"]]\n        for rule in self._rules:\n            for tagged_tokens in tagged_tokenses:\n                rule.apply(tagged_tokens)\n            errors.append(counterrors(tagged_tokenses))\n        testing_stats[\"rulescores\"] = [\n            err0 - err1 for (err0, err1) in zip(errors, errors[1:])\n        ]\n        testing_stats[\"finalerrors\"] = errors[-1]\n        testing_stats[\"finalacc\"] = (\n            1 - testing_stats[\"finalerrors\"] / testing_stats[\"tokencount\"]\n        )\n        return (tagged_tokenses, testing_stats)\n", "# Natural Language Toolkit: Transformation-based learning\n#\n# Copyright (C) 2001-2013 NLTK Project\n# Author: Marcus Uneson <marcus.uneson@gmail.com>\n#   based on previous (nltk2) version by\n#   Christopher Maloof, Edward Loper, Steven Bird\n# URL: <https://www.nltk.org/>\n# For license information, see  LICENSE.TXT\n\nimport bisect\nimport textwrap\nfrom collections import defaultdict\n\nfrom nltk.tag import BrillTagger, untag\n\n######################################################################\n#  Brill Tagger Trainer\n######################################################################\n\n\nclass BrillTaggerTrainer:\n    \"\"\"\n    A trainer for tbl taggers.\n    \"\"\"\n\n    def __init__(\n        self, initial_tagger, templates, trace=0, deterministic=None, ruleformat=\"str\"\n    ):\n        \"\"\"\n        Construct a Brill tagger from a baseline tagger and a\n        set of templates\n\n        :param initial_tagger: the baseline tagger\n        :type initial_tagger: Tagger\n        :param templates: templates to be used in training\n        :type templates: list of Templates\n        :param trace: verbosity level\n        :type trace: int\n        :param deterministic: if True, adjudicate ties deterministically\n        :type deterministic: bool\n        :param ruleformat: format of reported Rules\n        :type ruleformat: str\n        :return: An untrained BrillTagger\n        :rtype: BrillTagger\n        \"\"\"\n\n        if deterministic is None:\n            deterministic = trace > 0\n        self._initial_tagger = initial_tagger\n        self._templates = templates\n        self._trace = trace\n        self._deterministic = deterministic\n        self._ruleformat = ruleformat\n\n        self._tag_positions = None\n        \"\"\"Mapping from tags to lists of positions that use that tag.\"\"\"\n\n        self._rules_by_position = None\n        \"\"\"Mapping from positions to the set of rules that are known\n           to occur at that position.  Position is (sentnum, wordnum).\n           Initially, this will only contain positions where each rule\n           applies in a helpful way; but when we examine a rule, we'll\n           extend this list to also include positions where each rule\n           applies in a harmful or neutral way.\"\"\"\n\n        self._positions_by_rule = None\n        \"\"\"Mapping from rule to position to effect, specifying the\n           effect that each rule has on the overall score, at each\n           position.  Position is (sentnum, wordnum); and effect is\n           -1, 0, or 1.  As with _rules_by_position, this mapping starts\n           out only containing rules with positive effects; but when\n           we examine a rule, we'll extend this mapping to include\n           the positions where the rule is harmful or neutral.\"\"\"\n\n        self._rules_by_score = None\n        \"\"\"Mapping from scores to the set of rules whose effect on the\n           overall score is upper bounded by that score.  Invariant:\n           rulesByScore[s] will contain r iff the sum of\n           _positions_by_rule[r] is s.\"\"\"\n\n        self._rule_scores = None\n        \"\"\"Mapping from rules to upper bounds on their effects on the\n           overall score.  This is the inverse mapping to _rules_by_score.\n           Invariant: ruleScores[r] = sum(_positions_by_rule[r])\"\"\"\n\n        self._first_unknown_position = None\n        \"\"\"Mapping from rules to the first position where we're unsure\n           if the rule applies.  This records the next position we\n           need to check to see if the rule messed anything up.\"\"\"\n\n    # Training\n\n    def train(self, train_sents, max_rules=200, min_score=2, min_acc=None):\n        r\"\"\"\n        Trains the Brill tagger on the corpus *train_sents*,\n        producing at most *max_rules* transformations, each of which\n        reduces the net number of errors in the corpus by at least\n        *min_score*, and each of which has accuracy not lower than\n        *min_acc*.\n\n        >>> # Relevant imports\n        >>> from nltk.tbl.template import Template\n        >>> from nltk.tag.brill import Pos, Word\n        >>> from nltk.tag import untag, RegexpTagger, BrillTaggerTrainer\n\n        >>> # Load some data\n        >>> from nltk.corpus import treebank\n        >>> training_data = treebank.tagged_sents()[:100]\n        >>> baseline_data = treebank.tagged_sents()[100:200]\n        >>> gold_data = treebank.tagged_sents()[200:300]\n        >>> testing_data = [untag(s) for s in gold_data]\n\n        >>> backoff = RegexpTagger([\n        ... (r'^-?[0-9]+(\\.[0-9]+)?$', 'CD'),  # cardinal numbers\n        ... (r'(The|the|A|a|An|an)$', 'AT'),   # articles\n        ... (r'.*able$', 'JJ'),                # adjectives\n        ... (r'.*ness$', 'NN'),                # nouns formed from adjectives\n        ... (r'.*ly$', 'RB'),                  # adverbs\n        ... (r'.*s$', 'NNS'),                  # plural nouns\n        ... (r'.*ing$', 'VBG'),                # gerunds\n        ... (r'.*ed$', 'VBD'),                 # past tense verbs\n        ... (r'.*', 'NN')                      # nouns (default)\n        ... ])\n\n        >>> baseline = backoff #see NOTE1\n\n        >>> baseline.evaluate(gold_data) #doctest: +ELLIPSIS\n        0.2433862...\n\n        >>> # Set up templates\n        >>> Template._cleartemplates() #clear any templates created in earlier tests\n        >>> templates = [Template(Pos([-1])), Template(Pos([-1]), Word([0]))]\n\n        >>> # Construct a BrillTaggerTrainer\n        >>> tt = BrillTaggerTrainer(baseline, templates, trace=3)\n\n        >>> tagger1 = tt.train(training_data, max_rules=10)\n        TBL train (fast) (seqs: 100; tokens: 2417; tpls: 2; min score: 2; min acc: None)\n        Finding initial useful rules...\n            Found 847 useful rules.\n        <BLANKLINE>\n                   B      |\n           S   F   r   O  |        Score = Fixed - Broken\n           c   i   o   t  |  R     Fixed = num tags changed incorrect -> correct\n           o   x   k   h  |  u     Broken = num tags changed correct -> incorrect\n           r   e   e   e  |  l     Other = num tags changed incorrect -> incorrect\n           e   d   n   r  |  e\n        ------------------+-------------------------------------------------------\n         132 132   0   0  | AT->DT if Pos:NN@[-1]\n          85  85   0   0  | NN->, if Pos:NN@[-1] & Word:,@[0]\n          69  69   0   0  | NN->. if Pos:NN@[-1] & Word:.@[0]\n          51  51   0   0  | NN->IN if Pos:NN@[-1] & Word:of@[0]\n          47  63  16 162  | NN->IN if Pos:NNS@[-1]\n          33  33   0   0  | NN->TO if Pos:NN@[-1] & Word:to@[0]\n          26  26   0   0  | IN->. if Pos:NNS@[-1] & Word:.@[0]\n          24  24   0   0  | IN->, if Pos:NNS@[-1] & Word:,@[0]\n          22  27   5  24  | NN->-NONE- if Pos:VBD@[-1]\n          17  17   0   0  | NN->CC if Pos:NN@[-1] & Word:and@[0]\n\n        >>> tagger1.rules()[1:3]\n        (Rule('001', 'NN', ',', [(Pos([-1]),'NN'), (Word([0]),',')]), Rule('001', 'NN', '.', [(Pos([-1]),'NN'), (Word([0]),'.')]))\n\n        >>> train_stats = tagger1.train_stats()\n        >>> [train_stats[stat] for stat in ['initialerrors', 'finalerrors', 'rulescores']]\n        [1776, 1270, [132, 85, 69, 51, 47, 33, 26, 24, 22, 17]]\n\n        >>> tagger1.print_template_statistics(printunused=False)\n        TEMPLATE STATISTICS (TRAIN)  2 templates, 10 rules)\n        TRAIN (   2417 tokens) initial  1776 0.2652 final:  1270 0.4746\n        #ID | Score (train) |  #Rules     | Template\n        --------------------------------------------\n        001 |   305   0.603 |   7   0.700 | Template(Pos([-1]),Word([0]))\n        000 |   201   0.397 |   3   0.300 | Template(Pos([-1]))\n        <BLANKLINE>\n        <BLANKLINE>\n\n        >>> tagger1.evaluate(gold_data) # doctest: +ELLIPSIS\n        0.43833...\n\n        >>> tagged, test_stats = tagger1.batch_tag_incremental(testing_data, gold_data)\n\n        >>> tagged[33][12:] == [('foreign', 'IN'), ('debt', 'NN'), ('of', 'IN'), ('$', 'NN'), ('64', 'CD'),\n        ... ('billion', 'NN'), ('*U*', 'NN'), ('--', 'NN'), ('the', 'DT'), ('third-highest', 'NN'), ('in', 'NN'),\n        ... ('the', 'DT'), ('developing', 'VBG'), ('world', 'NN'), ('.', '.')]\n        True\n\n        >>> [test_stats[stat] for stat in ['initialerrors', 'finalerrors', 'rulescores']]\n        [1859, 1380, [100, 85, 67, 58, 27, 36, 27, 16, 31, 32]]\n\n        >>> # A high-accuracy tagger\n        >>> tagger2 = tt.train(training_data, max_rules=10, min_acc=0.99)\n        TBL train (fast) (seqs: 100; tokens: 2417; tpls: 2; min score: 2; min acc: 0.99)\n        Finding initial useful rules...\n            Found 847 useful rules.\n        <BLANKLINE>\n                   B      |\n           S   F   r   O  |        Score = Fixed - Broken\n           c   i   o   t  |  R     Fixed = num tags changed incorrect -> correct\n           o   x   k   h  |  u     Broken = num tags changed correct -> incorrect\n           r   e   e   e  |  l     Other = num tags changed incorrect -> incorrect\n           e   d   n   r  |  e\n        ------------------+-------------------------------------------------------\n         132 132   0   0  | AT->DT if Pos:NN@[-1]\n          85  85   0   0  | NN->, if Pos:NN@[-1] & Word:,@[0]\n          69  69   0   0  | NN->. if Pos:NN@[-1] & Word:.@[0]\n          51  51   0   0  | NN->IN if Pos:NN@[-1] & Word:of@[0]\n          36  36   0   0  | NN->TO if Pos:NN@[-1] & Word:to@[0]\n          26  26   0   0  | NN->. if Pos:NNS@[-1] & Word:.@[0]\n          24  24   0   0  | NN->, if Pos:NNS@[-1] & Word:,@[0]\n          19  19   0   6  | NN->VB if Pos:TO@[-1]\n          18  18   0   0  | CD->-NONE- if Pos:NN@[-1] & Word:0@[0]\n          18  18   0   0  | NN->CC if Pos:NN@[-1] & Word:and@[0]\n\n        >>> tagger2.evaluate(gold_data)  # doctest: +ELLIPSIS\n        0.43996743...\n        >>> tagger2.rules()[2:4]\n        (Rule('001', 'NN', '.', [(Pos([-1]),'NN'), (Word([0]),'.')]), Rule('001', 'NN', 'IN', [(Pos([-1]),'NN'), (Word([0]),'of')]))\n\n        # NOTE1: (!!FIXME) A far better baseline uses nltk.tag.UnigramTagger,\n        # with a RegexpTagger only as backoff. For instance,\n        # >>> baseline = UnigramTagger(baseline_data, backoff=backoff)\n        # However, as of Nov 2013, nltk.tag.UnigramTagger does not yield consistent results\n        # between python versions. The simplistic backoff above is a workaround to make doctests\n        # get consistent input.\n\n        :param train_sents: training data\n        :type train_sents: list(list(tuple))\n        :param max_rules: output at most max_rules rules\n        :type max_rules: int\n        :param min_score: stop training when no rules better than min_score can be found\n        :type min_score: int\n        :param min_acc: discard any rule with lower accuracy than min_acc\n        :type min_acc: float or None\n        :return: the learned tagger\n        :rtype: BrillTagger\n        \"\"\"\n        # FIXME: several tests are a bit too dependent on tracing format\n        # FIXME: tests in trainer.fast and trainer.brillorig are exact duplicates\n\n        # Basic idea: Keep track of the rules that apply at each position.\n        # And keep track of the positions to which each rule applies.\n\n        # Create a new copy of the training corpus, and run the\n        # initial tagger on it.  We will progressively update this\n        # test corpus to look more like the training corpus.\n        test_sents = [\n            list(self._initial_tagger.tag(untag(sent))) for sent in train_sents\n        ]\n\n        # Collect some statistics on the training process\n        trainstats = {}\n        trainstats[\"min_acc\"] = min_acc\n        trainstats[\"min_score\"] = min_score\n        trainstats[\"tokencount\"] = sum(len(t) for t in test_sents)\n        trainstats[\"sequencecount\"] = len(test_sents)\n        trainstats[\"templatecount\"] = len(self._templates)\n        trainstats[\"rulescores\"] = []\n        trainstats[\"initialerrors\"] = sum(\n            tag[1] != truth[1]\n            for paired in zip(test_sents, train_sents)\n            for (tag, truth) in zip(*paired)\n        )\n        trainstats[\"initialacc\"] = (\n            1 - trainstats[\"initialerrors\"] / trainstats[\"tokencount\"]\n        )\n        if self._trace > 0:\n            print(\n                \"TBL train (fast) (seqs: {sequencecount}; tokens: {tokencount}; \"\n                \"tpls: {templatecount}; min score: {min_score}; min acc: {min_acc})\".format(\n                    **trainstats\n                )\n            )\n\n        # Initialize our mappings.  This will find any errors made\n        # by the initial tagger, and use those to generate repair\n        # rules, which are added to the rule mappings.\n        if self._trace:\n            print(\"Finding initial useful rules...\")\n        self._init_mappings(test_sents, train_sents)\n        if self._trace:\n            print(f\"    Found {len(self._rule_scores)} useful rules.\")\n\n        # Let the user know what we're up to.\n        if self._trace > 2:\n            self._trace_header()\n        elif self._trace == 1:\n            print(\"Selecting rules...\")\n\n        # Repeatedly select the best rule, and add it to `rules`.\n        rules = []\n        try:\n            while len(rules) < max_rules:\n                # Find the best rule, and add it to our rule list.\n                rule = self._best_rule(train_sents, test_sents, min_score, min_acc)\n                if rule:\n                    rules.append(rule)\n                    score = self._rule_scores[rule]\n                    trainstats[\"rulescores\"].append(score)\n                else:\n                    break  # No more good rules left!\n\n                # Report the rule that we found.\n                if self._trace > 1:\n                    self._trace_rule(rule)\n\n                # Apply the new rule at the relevant sites\n                self._apply_rule(rule, test_sents)\n\n                # Update _tag_positions[rule.original_tag] and\n                # _tag_positions[rule.replacement_tag] for the affected\n                # positions (i.e., self._positions_by_rule[rule]).\n                self._update_tag_positions(rule)\n\n                # Update rules that were affected by the change.\n                self._update_rules(rule, train_sents, test_sents)\n\n        # The user can cancel training manually:\n        except KeyboardInterrupt:\n            print(f\"Training stopped manually -- {len(rules)} rules found\")\n\n        # Discard our tag position mapping & rule mappings.\n        self._clean()\n        trainstats[\"finalerrors\"] = trainstats[\"initialerrors\"] - sum(\n            trainstats[\"rulescores\"]\n        )\n        trainstats[\"finalacc\"] = (\n            1 - trainstats[\"finalerrors\"] / trainstats[\"tokencount\"]\n        )\n        # Create and return a tagger from the rules we found.\n        return BrillTagger(self._initial_tagger, rules, trainstats)\n\n    def _init_mappings(self, test_sents, train_sents):\n        \"\"\"\n        Initialize the tag position mapping & the rule related\n        mappings.  For each error in test_sents, find new rules that\n        would correct them, and add them to the rule mappings.\n        \"\"\"\n        self._tag_positions = defaultdict(list)\n        self._rules_by_position = defaultdict(set)\n        self._positions_by_rule = defaultdict(dict)\n        self._rules_by_score = defaultdict(set)\n        self._rule_scores = defaultdict(int)\n        self._first_unknown_position = defaultdict(int)\n        # Scan through the corpus, initializing the tag_positions\n        # mapping and all the rule-related mappings.\n        for sentnum, sent in enumerate(test_sents):\n            for wordnum, (word, tag) in enumerate(sent):\n\n                # Initialize tag_positions\n                self._tag_positions[tag].append((sentnum, wordnum))\n\n                # If it's an error token, update the rule-related mappings.\n                correct_tag = train_sents[sentnum][wordnum][1]\n                if tag != correct_tag:\n                    for rule in self._find_rules(sent, wordnum, correct_tag):\n                        self._update_rule_applies(rule, sentnum, wordnum, train_sents)\n\n    def _clean(self):\n        self._tag_positions = None\n        self._rules_by_position = None\n        self._positions_by_rule = None\n        self._rules_by_score = None\n        self._rule_scores = None\n        self._first_unknown_position = None\n\n    def _find_rules(self, sent, wordnum, new_tag):\n        \"\"\"\n        Use the templates to find rules that apply at index *wordnum*\n        in the sentence *sent* and generate the tag *new_tag*.\n        \"\"\"\n        for template in self._templates:\n            yield from template.applicable_rules(sent, wordnum, new_tag)\n\n    def _update_rule_applies(self, rule, sentnum, wordnum, train_sents):\n        \"\"\"\n        Update the rule data tables to reflect the fact that\n        *rule* applies at the position *(sentnum, wordnum)*.\n        \"\"\"\n        pos = sentnum, wordnum\n\n        # If the rule is already known to apply here, ignore.\n        # (This only happens if the position's tag hasn't changed.)\n        if pos in self._positions_by_rule[rule]:\n            return\n\n        # Update self._positions_by_rule.\n        correct_tag = train_sents[sentnum][wordnum][1]\n        if rule.replacement_tag == correct_tag:\n            self._positions_by_rule[rule][pos] = 1\n        elif rule.original_tag == correct_tag:\n            self._positions_by_rule[rule][pos] = -1\n        else:  # was wrong, remains wrong\n            self._positions_by_rule[rule][pos] = 0\n\n        # Update _rules_by_position\n        self._rules_by_position[pos].add(rule)\n\n        # Update _rule_scores.\n        old_score = self._rule_scores[rule]\n        self._rule_scores[rule] += self._positions_by_rule[rule][pos]\n\n        # Update _rules_by_score.\n        self._rules_by_score[old_score].discard(rule)\n        self._rules_by_score[self._rule_scores[rule]].add(rule)\n\n    def _update_rule_not_applies(self, rule, sentnum, wordnum):\n        \"\"\"\n        Update the rule data tables to reflect the fact that *rule*\n        does not apply at the position *(sentnum, wordnum)*.\n        \"\"\"\n        pos = sentnum, wordnum\n\n        # Update _rule_scores.\n        old_score = self._rule_scores[rule]\n        self._rule_scores[rule] -= self._positions_by_rule[rule][pos]\n\n        # Update _rules_by_score.\n        self._rules_by_score[old_score].discard(rule)\n        self._rules_by_score[self._rule_scores[rule]].add(rule)\n\n        # Update _positions_by_rule\n        del self._positions_by_rule[rule][pos]\n        self._rules_by_position[pos].remove(rule)\n\n        # Optional addition: if the rule now applies nowhere, delete\n        # all its dictionary entries.\n\n    def _best_rule(self, train_sents, test_sents, min_score, min_acc):\n        \"\"\"\n        Find the next best rule.  This is done by repeatedly taking a\n        rule with the highest score and stepping through the corpus to\n        see where it applies.  When it makes an error (decreasing its\n        score) it's bumped down, and we try a new rule with the\n        highest score.  When we find a rule which has the highest\n        score *and* which has been tested against the entire corpus, we\n        can conclude that it's the next best rule.\n        \"\"\"\n        for max_score in sorted(self._rules_by_score.keys(), reverse=True):\n            if len(self._rules_by_score) == 0:\n                return None\n            if max_score < min_score or max_score <= 0:\n                return None\n            best_rules = list(self._rules_by_score[max_score])\n            if self._deterministic:\n                best_rules.sort(key=repr)\n            for rule in best_rules:\n                positions = self._tag_positions[rule.original_tag]\n\n                unk = self._first_unknown_position.get(rule, (0, -1))\n                start = bisect.bisect_left(positions, unk)\n\n                for i in range(start, len(positions)):\n                    sentnum, wordnum = positions[i]\n                    if rule.applies(test_sents[sentnum], wordnum):\n                        self._update_rule_applies(rule, sentnum, wordnum, train_sents)\n                        if self._rule_scores[rule] < max_score:\n                            self._first_unknown_position[rule] = (sentnum, wordnum + 1)\n                            break  # The update demoted the rule.\n\n                if self._rule_scores[rule] == max_score:\n                    self._first_unknown_position[rule] = (len(train_sents) + 1, 0)\n                    # optimization: if no min_acc threshold given, don't bother computing accuracy\n                    if min_acc is None:\n                        return rule\n                    else:\n                        changes = self._positions_by_rule[rule].values()\n                        num_fixed = len([c for c in changes if c == 1])\n                        num_broken = len([c for c in changes if c == -1])\n                        # acc here is fixed/(fixed+broken); could also be\n                        # fixed/(fixed+broken+other) == num_fixed/len(changes)\n                        acc = num_fixed / (num_fixed + num_broken)\n                        if acc >= min_acc:\n                            return rule\n                        # else: rule too inaccurate, discard and try next\n\n            # We demoted (or skipped due to < min_acc, if that was given)\n            # all the rules with score==max_score.\n\n            assert min_acc is not None or not self._rules_by_score[max_score]\n            if not self._rules_by_score[max_score]:\n                del self._rules_by_score[max_score]\n\n    def _apply_rule(self, rule, test_sents):\n        \"\"\"\n        Update *test_sents* by applying *rule* everywhere where its\n        conditions are met.\n        \"\"\"\n        update_positions = set(self._positions_by_rule[rule])\n        new_tag = rule.replacement_tag\n\n        if self._trace > 3:\n            self._trace_apply(len(update_positions))\n\n        # Update test_sents.\n        for (sentnum, wordnum) in update_positions:\n            text = test_sents[sentnum][wordnum][0]\n            test_sents[sentnum][wordnum] = (text, new_tag)\n\n    def _update_tag_positions(self, rule):\n        \"\"\"\n        Update _tag_positions to reflect the changes to tags that are\n        made by *rule*.\n        \"\"\"\n        # Update the tag index.\n        for pos in self._positions_by_rule[rule]:\n            # Delete the old tag.\n            old_tag_positions = self._tag_positions[rule.original_tag]\n            old_index = bisect.bisect_left(old_tag_positions, pos)\n            del old_tag_positions[old_index]\n            # Insert the new tag.\n            new_tag_positions = self._tag_positions[rule.replacement_tag]\n            bisect.insort_left(new_tag_positions, pos)\n\n    def _update_rules(self, rule, train_sents, test_sents):\n        \"\"\"\n        Check if we should add or remove any rules from consideration,\n        given the changes made by *rule*.\n        \"\"\"\n        # Collect a list of all positions that might be affected.\n        neighbors = set()\n        for sentnum, wordnum in self._positions_by_rule[rule]:\n            for template in self._templates:\n                n = template.get_neighborhood(test_sents[sentnum], wordnum)\n                neighbors.update([(sentnum, i) for i in n])\n\n        # Update the rules at each position.\n        num_obsolete = num_new = num_unseen = 0\n        for sentnum, wordnum in neighbors:\n            test_sent = test_sents[sentnum]\n            correct_tag = train_sents[sentnum][wordnum][1]\n\n            # Check if the change causes any rule at this position to\n            # stop matching; if so, then update our rule mappings\n            # accordingly.\n            old_rules = set(self._rules_by_position[sentnum, wordnum])\n            for old_rule in old_rules:\n                if not old_rule.applies(test_sent, wordnum):\n                    num_obsolete += 1\n                    self._update_rule_not_applies(old_rule, sentnum, wordnum)\n\n            # Check if the change causes our templates to propose any\n            # new rules for this position.\n            for template in self._templates:\n                for new_rule in template.applicable_rules(\n                    test_sent, wordnum, correct_tag\n                ):\n                    if new_rule not in old_rules:\n                        num_new += 1\n                        if new_rule not in self._rule_scores:\n                            num_unseen += 1\n                        old_rules.add(new_rule)\n                        self._update_rule_applies(\n                            new_rule, sentnum, wordnum, train_sents\n                        )\n\n            # We may have caused other rules to match here, that are\n            # not proposed by our templates -- in particular, rules\n            # that are harmful or neutral.  We therefore need to\n            # update any rule whose first_unknown_position is past\n            # this rule.\n            for new_rule, pos in self._first_unknown_position.items():\n                if pos > (sentnum, wordnum):\n                    if new_rule not in old_rules:\n                        num_new += 1\n                        if new_rule.applies(test_sent, wordnum):\n                            self._update_rule_applies(\n                                new_rule, sentnum, wordnum, train_sents\n                            )\n\n        if self._trace > 3:\n            self._trace_update_rules(num_obsolete, num_new, num_unseen)\n\n    # Tracing\n\n    def _trace_header(self):\n        print(\n            \"\"\"\n           B      |\n   S   F   r   O  |        Score = Fixed - Broken\n   c   i   o   t  |  R     Fixed = num tags changed incorrect -> correct\n   o   x   k   h  |  u     Broken = num tags changed correct -> incorrect\n   r   e   e   e  |  l     Other = num tags changed incorrect -> incorrect\n   e   d   n   r  |  e\n------------------+-------------------------------------------------------\n        \"\"\".rstrip()\n        )\n\n    def _trace_rule(self, rule):\n        assert self._rule_scores[rule] == sum(self._positions_by_rule[rule].values())\n\n        changes = self._positions_by_rule[rule].values()\n        num_fixed = len([c for c in changes if c == 1])\n        num_broken = len([c for c in changes if c == -1])\n        num_other = len([c for c in changes if c == 0])\n        score = self._rule_scores[rule]\n\n        rulestr = rule.format(self._ruleformat)\n        if self._trace > 2:\n            print(\n                \"{:4d}{:4d}{:4d}{:4d}  |\".format(\n                    score, num_fixed, num_broken, num_other\n                ),\n                end=\" \",\n            )\n            print(\n                textwrap.fill(\n                    rulestr,\n                    initial_indent=\" \" * 20,\n                    width=79,\n                    subsequent_indent=\" \" * 18 + \"|   \",\n                ).strip()\n            )\n        else:\n            print(rulestr)\n\n    def _trace_apply(self, num_updates):\n        prefix = \" \" * 18 + \"|\"\n        print(prefix)\n        print(prefix, f\"Applying rule to {num_updates} positions.\")\n\n    def _trace_update_rules(self, num_obsolete, num_new, num_unseen):\n        prefix = \" \" * 18 + \"|\"\n        print(prefix, \"Updated rule tables:\")\n        print(prefix, (f\"  - {num_obsolete} rule applications removed\"))\n        print(\n            prefix,\n            (f\"  - {num_new} rule applications added ({num_unseen} novel)\"),\n        )\n        print(prefix)\n", "# Natural Language Toolkit: Sequential Backoff Taggers\n#\n# Copyright (C) 2001-2021 NLTK Project\n# Author: Edward Loper <edloper@gmail.com>\n#         Steven Bird <stevenbird1@gmail.com> (minor additions)\n#         Tiago Tresoldi <tresoldi@users.sf.net> (original affix tagger)\n# URL: <https://www.nltk.org/>\n# For license information, see LICENSE.TXT\n\n\"\"\"\nClasses for tagging sentences sequentially, left to right.  The\nabstract base class SequentialBackoffTagger serves as the base\nclass for all the taggers in this module.  Tagging of individual words\nis performed by the method ``choose_tag()``, which is defined by\nsubclasses of SequentialBackoffTagger.  If a tagger is unable to\ndetermine a tag for the specified token, then its backoff tagger is\nconsulted instead.  Any SequentialBackoffTagger may serve as a\nbackoff tagger for any other SequentialBackoffTagger.\n\"\"\"\nimport ast\nimport re\nfrom abc import abstractmethod\nfrom typing import List, Optional, Tuple\n\nfrom nltk import jsontags\nfrom nltk.classify import NaiveBayesClassifier\nfrom nltk.probability import ConditionalFreqDist\nfrom nltk.tag.api import FeaturesetTaggerI, TaggerI\n\n\n######################################################################\n# Abstract Base Classes\n######################################################################\nclass SequentialBackoffTagger(TaggerI):\n    \"\"\"\n    An abstract base class for taggers that tags words sequentially,\n    left to right.  Tagging of individual words is performed by the\n    ``choose_tag()`` method, which should be defined by subclasses.  If\n    a tagger is unable to determine a tag for the specified token,\n    then its backoff tagger is consulted.\n\n    :ivar _taggers: A list of all the taggers that should be tried to\n        tag a token (i.e., self and its backoff taggers).\n    \"\"\"\n\n    def __init__(self, backoff=None):\n        if backoff is None:\n            self._taggers = [self]\n        else:\n            self._taggers = [self] + backoff._taggers\n\n    @property\n    def backoff(self):\n        \"\"\"The backoff tagger for this tagger.\"\"\"\n        return self._taggers[1] if len(self._taggers) > 1 else None\n\n    def tag(self, tokens):\n        # docs inherited from TaggerI\n        tags = []\n        for i in range(len(tokens)):\n            tags.append(self.tag_one(tokens, i, tags))\n        return list(zip(tokens, tags))\n\n    def tag_one(self, tokens, index, history):\n        \"\"\"\n        Determine an appropriate tag for the specified token, and\n        return that tag.  If this tagger is unable to determine a tag\n        for the specified token, then its backoff tagger is consulted.\n\n        :rtype: str\n        :type tokens: list\n        :param tokens: The list of words that are being tagged.\n        :type index: int\n        :param index: The index of the word whose tag should be\n            returned.\n        :type history: list(str)\n        :param history: A list of the tags for all words before *index*.\n        \"\"\"\n        tag = None\n        for tagger in self._taggers:\n            tag = tagger.choose_tag(tokens, index, history)\n            if tag is not None:\n                break\n        return tag\n\n    @abstractmethod\n    def choose_tag(self, tokens, index, history):\n        \"\"\"\n        Decide which tag should be used for the specified token, and\n        return that tag.  If this tagger is unable to determine a tag\n        for the specified token, return None -- do not consult\n        the backoff tagger.  This method should be overridden by\n        subclasses of SequentialBackoffTagger.\n\n        :rtype: str\n        :type tokens: list\n        :param tokens: The list of words that are being tagged.\n        :type index: int\n        :param index: The index of the word whose tag should be\n            returned.\n        :type history: list(str)\n        :param history: A list of the tags for all words before *index*.\n        \"\"\"\n\n\nclass ContextTagger(SequentialBackoffTagger):\n    \"\"\"\n    An abstract base class for sequential backoff taggers that choose\n    a tag for a token based on the value of its \"context\".  Different\n    subclasses are used to define different contexts.\n\n    A ContextTagger chooses the tag for a token by calculating the\n    token's context, and looking up the corresponding tag in a table.\n    This table can be constructed manually; or it can be automatically\n    constructed based on a training corpus, using the ``_train()``\n    factory method.\n\n    :ivar _context_to_tag: Dictionary mapping contexts to tags.\n    \"\"\"\n\n    def __init__(self, context_to_tag, backoff=None):\n        \"\"\"\n        :param context_to_tag: A dictionary mapping contexts to tags.\n        :param backoff: The backoff tagger that should be used for this tagger.\n        \"\"\"\n        super().__init__(backoff)\n        self._context_to_tag = context_to_tag if context_to_tag else {}\n\n    @abstractmethod\n    def context(self, tokens, index, history):\n        \"\"\"\n        :return: the context that should be used to look up the tag\n            for the specified token; or None if the specified token\n            should not be handled by this tagger.\n        :rtype: (hashable)\n        \"\"\"\n\n    def choose_tag(self, tokens, index, history):\n        context = self.context(tokens, index, history)\n        return self._context_to_tag.get(context)\n\n    def size(self):\n        \"\"\"\n        :return: The number of entries in the table used by this\n            tagger to map from contexts to tags.\n        \"\"\"\n        return len(self._context_to_tag)\n\n    def __repr__(self):\n        return f\"<{self.__class__.__name__}: size={self.size()}>\"\n\n    def _train(self, tagged_corpus, cutoff=0, verbose=False):\n        \"\"\"\n        Initialize this ContextTagger's ``_context_to_tag`` table\n        based on the given training data.  In particular, for each\n        context ``c`` in the training data, set\n        ``_context_to_tag[c]`` to the most frequent tag for that\n        context.  However, exclude any contexts that are already\n        tagged perfectly by the backoff tagger(s).\n\n        The old value of ``self._context_to_tag`` (if any) is discarded.\n\n        :param tagged_corpus: A tagged corpus.  Each item should be\n            a list of (word, tag tuples.\n        :param cutoff: If the most likely tag for a context occurs\n            fewer than cutoff times, then exclude it from the\n            context-to-tag table for the new tagger.\n        \"\"\"\n\n        token_count = hit_count = 0\n\n        # A context is considered 'useful' if it's not already tagged\n        # perfectly by the backoff tagger.\n        useful_contexts = set()\n\n        # Count how many times each tag occurs in each context.\n        fd = ConditionalFreqDist()\n        for sentence in tagged_corpus:\n            tokens, tags = zip(*sentence)\n            for index, (token, tag) in enumerate(sentence):\n                # Record the event.\n                token_count += 1\n                context = self.context(tokens, index, tags[:index])\n                if context is None:\n                    continue\n                fd[context][tag] += 1\n                # If the backoff got it wrong, this context is useful:\n                if self.backoff is None or tag != self.backoff.tag_one(\n                    tokens, index, tags[:index]\n                ):\n                    useful_contexts.add(context)\n\n        # Build the context_to_tag table -- for each context, figure\n        # out what the most likely tag is.  Only include contexts that\n        # we've seen at least `cutoff` times.\n        for context in useful_contexts:\n            best_tag = fd[context].max()\n            hits = fd[context][best_tag]\n            if hits > cutoff:\n                self._context_to_tag[context] = best_tag\n                hit_count += hits\n\n        # Display some stats, if requested.\n        if verbose:\n            size = len(self._context_to_tag)\n            backoff = 100 - (hit_count * 100.0) / token_count\n            pruning = 100 - (size * 100.0) / len(fd.conditions())\n            print(\"[Trained Unigram tagger:\", end=\" \")\n            print(\n                \"size={}, backoff={:.2f}%, pruning={:.2f}%]\".format(\n                    size, backoff, pruning\n                )\n            )\n\n\n######################################################################\n# Tagger Classes\n######################################################################\n\n\n@jsontags.register_tag\nclass DefaultTagger(SequentialBackoffTagger):\n    \"\"\"\n    A tagger that assigns the same tag to every token.\n\n        >>> from nltk.tag import DefaultTagger\n        >>> default_tagger = DefaultTagger('NN')\n        >>> list(default_tagger.tag('This is a test'.split()))\n        [('This', 'NN'), ('is', 'NN'), ('a', 'NN'), ('test', 'NN')]\n\n    This tagger is recommended as a backoff tagger, in cases where\n    a more powerful tagger is unable to assign a tag to the word\n    (e.g. because the word was not seen during training).\n\n    :param tag: The tag to assign to each token\n    :type tag: str\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.DefaultTagger\"\n\n    def __init__(self, tag):\n        self._tag = tag\n        super().__init__(None)\n\n    def encode_json_obj(self):\n        return self._tag\n\n    @classmethod\n    def decode_json_obj(cls, obj):\n        tag = obj\n        return cls(tag)\n\n    def choose_tag(self, tokens, index, history):\n        return self._tag  # ignore token and history\n\n    def __repr__(self):\n        return f\"<DefaultTagger: tag={self._tag}>\"\n\n\n@jsontags.register_tag\nclass NgramTagger(ContextTagger):\n    \"\"\"\n    A tagger that chooses a token's tag based on its word string and\n    on the preceding n word's tags.  In particular, a tuple\n    (tags[i-n:i-1], words[i]) is looked up in a table, and the\n    corresponding tag is returned.  N-gram taggers are typically\n    trained on a tagged corpus.\n\n    Train a new NgramTagger using the given training data or\n    the supplied model.  In particular, construct a new tagger\n    whose table maps from each context (tag[i-n:i-1], word[i])\n    to the most frequent tag for that context.  But exclude any\n    contexts that are already tagged perfectly by the backoff\n    tagger.\n\n    :param train: A tagged corpus consisting of a list of tagged\n        sentences, where each sentence is a list of (word, tag) tuples.\n    :param backoff: A backoff tagger, to be used by the new\n        tagger if it encounters an unknown context.\n    :param cutoff: If the most likely tag for a context occurs\n        fewer than *cutoff* times, then exclude it from the\n        context-to-tag table for the new tagger.\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.NgramTagger\"\n\n    def __init__(\n        self, n, train=None, model=None, backoff=None, cutoff=0, verbose=False\n    ):\n        self._n = n\n        self._check_params(train, model)\n\n        super().__init__(model, backoff)\n\n        if train:\n            self._train(train, cutoff, verbose)\n\n    def encode_json_obj(self):\n        _context_to_tag = {repr(k): v for k, v in self._context_to_tag.items()}\n        if \"NgramTagger\" in self.__class__.__name__:\n            return self._n, _context_to_tag, self.backoff\n        else:\n            return _context_to_tag, self.backoff\n\n    @classmethod\n    def decode_json_obj(cls, obj):\n        try:\n            _n, _context_to_tag, backoff = obj\n        except ValueError:\n            _context_to_tag, backoff = obj\n\n        if not _context_to_tag:\n            return backoff\n\n        _context_to_tag = {ast.literal_eval(k): v for k, v in _context_to_tag.items()}\n\n        if \"NgramTagger\" in cls.__name__:\n            return cls(_n, model=_context_to_tag, backoff=backoff)\n        else:\n            return cls(model=_context_to_tag, backoff=backoff)\n\n    def context(self, tokens, index, history):\n        tag_context = tuple(history[max(0, index - self._n + 1) : index])\n        return tag_context, tokens[index]\n\n\n@jsontags.register_tag\nclass UnigramTagger(NgramTagger):\n    \"\"\"\n    Unigram Tagger\n\n    The UnigramTagger finds the most likely tag for each word in a training\n    corpus, and then uses that information to assign tags to new tokens.\n\n        >>> from nltk.corpus import brown\n        >>> from nltk.tag import UnigramTagger\n        >>> test_sent = brown.sents(categories='news')[0]\n        >>> unigram_tagger = UnigramTagger(brown.tagged_sents(categories='news')[:500])\n        >>> for tok, tag in unigram_tagger.tag(test_sent):\n        ...     print(\"({}, {}), \".format(tok, tag)) # doctest: +NORMALIZE_WHITESPACE\n        (The, AT), (Fulton, NP-TL), (County, NN-TL), (Grand, JJ-TL),\n        (Jury, NN-TL), (said, VBD), (Friday, NR), (an, AT),\n        (investigation, NN), (of, IN), (Atlanta's, NP$), (recent, JJ),\n        (primary, NN), (election, NN), (produced, VBD), (``, ``),\n        (no, AT), (evidence, NN), ('', ''), (that, CS), (any, DTI),\n        (irregularities, NNS), (took, VBD), (place, NN), (., .),\n\n    :param train: The corpus of training data, a list of tagged sentences\n    :type train: list(list(tuple(str, str)))\n    :param model: The tagger model\n    :type model: dict\n    :param backoff: Another tagger which this tagger will consult when it is\n        unable to tag a word\n    :type backoff: TaggerI\n    :param cutoff: The number of instances of training data the tagger must see\n        in order not to use the backoff tagger\n    :type cutoff: int\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.UnigramTagger\"\n\n    def __init__(self, train=None, model=None, backoff=None, cutoff=0, verbose=False):\n        super().__init__(1, train, model, backoff, cutoff, verbose)\n\n    def context(self, tokens, index, history):\n        return tokens[index]\n\n\n@jsontags.register_tag\nclass BigramTagger(NgramTagger):\n    \"\"\"\n    A tagger that chooses a token's tag based its word string and on\n    the preceding words' tag.  In particular, a tuple consisting\n    of the previous tag and the word is looked up in a table, and\n    the corresponding tag is returned.\n\n    :param train: The corpus of training data, a list of tagged sentences\n    :type train: list(list(tuple(str, str)))\n    :param model: The tagger model\n    :type model: dict\n    :param backoff: Another tagger which this tagger will consult when it is\n        unable to tag a word\n    :type backoff: TaggerI\n    :param cutoff: The number of instances of training data the tagger must see\n        in order not to use the backoff tagger\n    :type cutoff: int\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.BigramTagger\"\n\n    def __init__(self, train=None, model=None, backoff=None, cutoff=0, verbose=False):\n        super().__init__(2, train, model, backoff, cutoff, verbose)\n\n\n@jsontags.register_tag\nclass TrigramTagger(NgramTagger):\n    \"\"\"\n    A tagger that chooses a token's tag based its word string and on\n    the preceding two words' tags.  In particular, a tuple consisting\n    of the previous two tags and the word is looked up in a table, and\n    the corresponding tag is returned.\n\n    :param train: The corpus of training data, a list of tagged sentences\n    :type train: list(list(tuple(str, str)))\n    :param model: The tagger model\n    :type model: dict\n    :param backoff: Another tagger which this tagger will consult when it is\n        unable to tag a word\n    :type backoff: TaggerI\n    :param cutoff: The number of instances of training data the tagger must see\n        in order not to use the backoff tagger\n    :type cutoff: int\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.TrigramTagger\"\n\n    def __init__(self, train=None, model=None, backoff=None, cutoff=0, verbose=False):\n        super().__init__(3, train, model, backoff, cutoff, verbose)\n\n\n@jsontags.register_tag\nclass AffixTagger(ContextTagger):\n    \"\"\"\n    A tagger that chooses a token's tag based on a leading or trailing\n    substring of its word string.  (It is important to note that these\n    substrings are not necessarily \"true\" morphological affixes).  In\n    particular, a fixed-length substring of the word is looked up in a\n    table, and the corresponding tag is returned.  Affix taggers are\n    typically constructed by training them on a tagged corpus.\n\n    Construct a new affix tagger.\n\n    :param affix_length: The length of the affixes that should be\n        considered during training and tagging.  Use negative\n        numbers for suffixes.\n    :param min_stem_length: Any words whose length is less than\n        min_stem_length+abs(affix_length) will be assigned a\n        tag of None by this tagger.\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.AffixTagger\"\n\n    def __init__(\n        self,\n        train=None,\n        model=None,\n        affix_length=-3,\n        min_stem_length=2,\n        backoff=None,\n        cutoff=0,\n        verbose=False,\n    ):\n\n        self._check_params(train, model)\n\n        super().__init__(model, backoff)\n\n        self._affix_length = affix_length\n        self._min_word_length = min_stem_length + abs(affix_length)\n\n        if train:\n            self._train(train, cutoff, verbose)\n\n    def encode_json_obj(self):\n        return (\n            self._affix_length,\n            self._min_word_length,\n            self._context_to_tag,\n            self.backoff,\n        )\n\n    @classmethod\n    def decode_json_obj(cls, obj):\n        _affix_length, _min_word_length, _context_to_tag, backoff = obj\n        return cls(\n            affix_length=_affix_length,\n            min_stem_length=_min_word_length - abs(_affix_length),\n            model=_context_to_tag,\n            backoff=backoff,\n        )\n\n    def context(self, tokens, index, history):\n        token = tokens[index]\n        if len(token) < self._min_word_length:\n            return None\n        elif self._affix_length > 0:\n            return token[: self._affix_length]\n        else:\n            return token[self._affix_length :]\n\n\n@jsontags.register_tag\nclass RegexpTagger(SequentialBackoffTagger):\n    r\"\"\"\n    Regular Expression Tagger\n\n    The RegexpTagger assigns tags to tokens by comparing their\n    word strings to a series of regular expressions.  The following tagger\n    uses word suffixes to make guesses about the correct Brown Corpus part\n    of speech tag:\n\n        >>> from nltk.corpus import brown\n        >>> from nltk.tag import RegexpTagger\n        >>> test_sent = brown.sents(categories='news')[0]\n        >>> regexp_tagger = RegexpTagger(\n        ...     [(r'^-?[0-9]+(\\.[0-9]+)?$', 'CD'),  # cardinal numbers\n        ...      (r'(The|the|A|a|An|an)$', 'AT'),   # articles\n        ...      (r'.*able$', 'JJ'),                # adjectives\n        ...      (r'.*ness$', 'NN'),                # nouns formed from adjectives\n        ...      (r'.*ly$', 'RB'),                  # adverbs\n        ...      (r'.*s$', 'NNS'),                  # plural nouns\n        ...      (r'.*ing$', 'VBG'),                # gerunds\n        ...      (r'.*ed$', 'VBD'),                 # past tense verbs\n        ...      (r'.*', 'NN')                      # nouns (default)\n        ... ])\n        >>> regexp_tagger\n        <Regexp Tagger: size=9>\n        >>> regexp_tagger.tag(test_sent) # doctest: +NORMALIZE_WHITESPACE\n        [('The', 'AT'), ('Fulton', 'NN'), ('County', 'NN'), ('Grand', 'NN'), ('Jury', 'NN'),\n        ('said', 'NN'), ('Friday', 'NN'), ('an', 'AT'), ('investigation', 'NN'), ('of', 'NN'),\n        (\"Atlanta's\", 'NNS'), ('recent', 'NN'), ('primary', 'NN'), ('election', 'NN'),\n        ('produced', 'VBD'), ('``', 'NN'), ('no', 'NN'), ('evidence', 'NN'), (\"''\", 'NN'),\n        ('that', 'NN'), ('any', 'NN'), ('irregularities', 'NNS'), ('took', 'NN'),\n        ('place', 'NN'), ('.', 'NN')]\n\n    :type regexps: list(tuple(str, str))\n    :param regexps: A list of ``(regexp, tag)`` pairs, each of\n        which indicates that a word matching ``regexp`` should\n        be tagged with ``tag``.  The pairs will be evaluated in\n        order.  If none of the regexps match a word, then the\n        optional backoff tagger is invoked, else it is\n        assigned the tag None.\n    \"\"\"\n\n    json_tag = \"nltk.tag.sequential.RegexpTagger\"\n\n    def __init__(\n        self, regexps: List[Tuple[str, str]], backoff: Optional[TaggerI] = None\n    ):\n        super().__init__(backoff)\n        self._regexps = []\n        for regexp, tag in regexps:\n            try:\n                self._regexps.append((re.compile(regexp), tag))\n            except Exception as e:\n                raise Exception(\n                    f\"Invalid RegexpTagger regexp: {e}\\n- regexp: {regexp!r}\\n- tag: {tag!r}\"\n                ) from e\n\n    def encode_json_obj(self):\n        return [(regexp.pattern, tag) for regexp, tag in self._regexps], self.backoff\n\n    @classmethod\n    def decode_json_obj(cls, obj):\n        regexps, backoff = obj\n        return cls(regexps, backoff)\n\n    def choose_tag(self, tokens, index, history):\n        for regexp, tag in self._regexps:\n            if re.match(regexp, tokens[index]):\n                return tag\n        return None\n\n    def __repr__(self):\n        return f\"<Regexp Tagger: size={len(self._regexps)}>\"\n\n\nclass ClassifierBasedTagger(SequentialBackoffTagger, FeaturesetTaggerI):\n    \"\"\"\n    A sequential tagger that uses a classifier to choose the tag for\n    each token in a sentence.  The featureset input for the classifier\n    is generated by a feature detector function::\n\n        feature_detector(tokens, index, history) -> featureset\n\n    Where tokens is the list of unlabeled tokens in the sentence;\n    index is the index of the token for which feature detection\n    should be performed; and history is list of the tags for all\n    tokens before index.\n\n    Construct a new classifier-based sequential tagger.\n\n    :param feature_detector: A function used to generate the\n        featureset input for the classifier::\n        feature_detector(tokens, index, history) -> featureset\n\n    :param train: A tagged corpus consisting of a list of tagged\n        sentences, where each sentence is a list of (word, tag) tuples.\n\n    :param backoff: A backoff tagger, to be used by the new tagger\n        if it encounters an unknown context.\n\n    :param classifier_builder: A function used to train a new\n        classifier based on the data in *train*.  It should take\n        one argument, a list of labeled featuresets (i.e.,\n        (featureset, label) tuples).\n\n    :param classifier: The classifier that should be used by the\n        tagger.  This is only useful if you want to manually\n        construct the classifier; normally, you would use *train*\n        instead.\n\n    :param backoff: A backoff tagger, used if this tagger is\n        unable to determine a tag for a given token.\n\n    :param cutoff_prob: If specified, then this tagger will fall\n        back on its backoff tagger if the probability of the most\n        likely tag is less than *cutoff_prob*.\n    \"\"\"\n\n    def __init__(\n        self,\n        feature_detector=None,\n        train=None,\n        classifier_builder=NaiveBayesClassifier.train,\n        classifier=None,\n        backoff=None,\n        cutoff_prob=None,\n        verbose=False,\n    ):\n        self._check_params(train, classifier)\n\n        super().__init__(backoff)\n\n        if (train and classifier) or (not train and not classifier):\n            raise ValueError(\n                \"Must specify either training data or \" \"trained classifier.\"\n            )\n\n        if feature_detector is not None:\n            self._feature_detector = feature_detector\n            # The feature detector function, used to generate a featureset\n            # or each token: feature_detector(tokens, index, history) -> featureset\n\n        self._cutoff_prob = cutoff_prob\n        \"\"\"Cutoff probability for tagging -- if the probability of the\n           most likely tag is less than this, then use backoff.\"\"\"\n\n        self._classifier = classifier\n        \"\"\"The classifier used to choose a tag for each token.\"\"\"\n\n        if train:\n            self._train(train, classifier_builder, verbose)\n\n    def choose_tag(self, tokens, index, history):\n        # Use our feature detector to get the featureset.\n        featureset = self.feature_detector(tokens, index, history)\n\n        # Use the classifier to pick a tag.  If a cutoff probability\n        # was specified, then check that the tag's probability is\n        # higher than that cutoff first; otherwise, return None.\n        if self._cutoff_prob is None:\n            return self._classifier.classify(featureset)\n\n        pdist = self._classifier.prob_classify(featureset)\n        tag = pdist.max()\n        return tag if pdist.prob(tag) >= self._cutoff_prob else None\n\n    def _train(self, tagged_corpus, classifier_builder, verbose):\n        \"\"\"\n        Build a new classifier, based on the given training data\n        *tagged_corpus*.\n        \"\"\"\n\n        classifier_corpus = []\n        if verbose:\n            print(\"Constructing training corpus for classifier.\")\n\n        for sentence in tagged_corpus:\n            history = []\n            untagged_sentence, tags = zip(*sentence)\n            for index in range(len(sentence)):\n                featureset = self.feature_detector(untagged_sentence, index, history)\n                classifier_corpus.append((featureset, tags[index]))\n                history.append(tags[index])\n\n        if verbose:\n            print(f\"Training classifier ({len(classifier_corpus)} instances)\")\n        self._classifier = classifier_builder(classifier_corpus)\n\n    def __repr__(self):\n        return f\"<ClassifierBasedTagger: {self._classifier}>\"\n\n    def feature_detector(self, tokens, index, history):\n        \"\"\"\n        Return the feature detector that this tagger uses to generate\n        featuresets for its classifier.  The feature detector is a\n        function with the signature::\n\n          feature_detector(tokens, index, history) -> featureset\n\n        See ``classifier()``\n        \"\"\"\n        return self._feature_detector(tokens, index, history)\n\n    def classifier(self):\n        \"\"\"\n        Return the classifier that this tagger uses to choose a tag\n        for each word in a sentence.  The input for this classifier is\n        generated using this tagger's feature detector.\n        See ``feature_detector()``\n        \"\"\"\n        return self._classifier\n\n\nclass ClassifierBasedPOSTagger(ClassifierBasedTagger):\n    \"\"\"\n    A classifier based part of speech tagger.\n    \"\"\"\n\n    def feature_detector(self, tokens, index, history):\n        word = tokens[index]\n        if index == 0:\n            prevword = prevprevword = None\n            prevtag = prevprevtag = None\n        elif index == 1:\n            prevword = tokens[index - 1].lower()\n            prevprevword = None\n            prevtag = history[index - 1]\n            prevprevtag = None\n        else:\n            prevword = tokens[index - 1].lower()\n            prevprevword = tokens[index - 2].lower()\n            prevtag = history[index - 1]\n            prevprevtag = history[index - 2]\n\n        if re.match(r\"[0-9]+(\\.[0-9]*)?|[0-9]*\\.[0-9]+$\", word):\n            shape = \"number\"\n        elif re.match(r\"\\W+$\", word):\n            shape = \"punct\"\n        elif re.match(\"[A-Z][a-z]+$\", word):\n            shape = \"upcase\"\n        elif re.match(\"[a-z]+$\", word):\n            shape = \"downcase\"\n        elif re.match(r\"\\w+$\", word):\n            shape = \"mixedcase\"\n        else:\n            shape = \"other\"\n\n        features = {\n            \"prevtag\": prevtag,\n            \"prevprevtag\": prevprevtag,\n            \"word\": word,\n            \"word.lower\": word.lower(),\n            \"suffix3\": word.lower()[-3:],\n            \"suffix2\": word.lower()[-2:],\n            \"suffix1\": word.lower()[-1:],\n            \"prevprevword\": prevprevword,\n            \"prevword\": prevword,\n            \"prevtag+word\": f\"{prevtag}+{word.lower()}\",\n            \"prevprevtag+word\": f\"{prevprevtag}+{word.lower()}\",\n            \"prevword+word\": f\"{prevword}+{word.lower()}\",\n            \"shape\": shape,\n        }\n        return features\n", "# Natural Language Toolkit: Transformation-based learning\n#\n# Copyright (C) 2001-2021 NLTK Project\n# Author: Marcus Uneson <marcus.uneson@gmail.com>\n#   based on previous (nltk2) version by\n#   Christopher Maloof, Edward Loper, Steven Bird\n# URL: <https://www.nltk.org/>\n# For license information, see  LICENSE.TXT\n\nimport os\nimport pickle\nimport random\nimport time\n\nfrom nltk.corpus import treebank\nfrom nltk.tag import BrillTaggerTrainer, RegexpTagger, UnigramTagger\nfrom nltk.tag.brill import Pos, Word\nfrom nltk.tbl import Template, error_list\n\n\ndef demo():\n    \"\"\"\n    Run a demo with defaults. See source comments for details,\n    or docstrings of any of the more specific demo_* functions.\n    \"\"\"\n    postag()\n\n\ndef demo_repr_rule_format():\n    \"\"\"\n    Exemplify repr(Rule) (see also str(Rule) and Rule.format(\"verbose\"))\n    \"\"\"\n    postag(ruleformat=\"repr\")\n\n\ndef demo_str_rule_format():\n    \"\"\"\n    Exemplify repr(Rule) (see also str(Rule) and Rule.format(\"verbose\"))\n    \"\"\"\n    postag(ruleformat=\"str\")\n\n\ndef demo_verbose_rule_format():\n    \"\"\"\n    Exemplify Rule.format(\"verbose\")\n    \"\"\"\n    postag(ruleformat=\"verbose\")\n\n\ndef demo_multiposition_feature():\n    \"\"\"\n    The feature/s of a template takes a list of positions\n    relative to the current word where the feature should be\n    looked for, conceptually joined by logical OR. For instance,\n    Pos([-1, 1]), given a value V, will hold whenever V is found\n    one step to the left and/or one step to the right.\n\n    For contiguous ranges, a 2-arg form giving inclusive end\n    points can also be used: Pos(-3, -1) is the same as the arg\n    below.\n    \"\"\"\n    postag(templates=[Template(Pos([-3, -2, -1]))])\n\n\ndef demo_multifeature_template():\n    \"\"\"\n    Templates can have more than a single feature.\n    \"\"\"\n    postag(templates=[Template(Word([0]), Pos([-2, -1]))])\n\n\ndef demo_template_statistics():\n    \"\"\"\n    Show aggregate statistics per template. Little used templates are\n    candidates for deletion, much used templates may possibly be refined.\n\n    Deleting unused templates is mostly about saving time and/or space:\n    training is basically O(T) in the number of templates T\n    (also in terms of memory usage, which often will be the limiting factor).\n    \"\"\"\n    postag(incremental_stats=True, template_stats=True)\n\n\ndef demo_generated_templates():\n    \"\"\"\n    Template.expand and Feature.expand are class methods facilitating\n    generating large amounts of templates. See their documentation for\n    details.\n\n    Note: training with 500 templates can easily fill all available\n    even on relatively small corpora\n    \"\"\"\n    wordtpls = Word.expand([-1, 0, 1], [1, 2], excludezero=False)\n    tagtpls = Pos.expand([-2, -1, 0, 1], [1, 2], excludezero=True)\n    templates = list(Template.expand([wordtpls, tagtpls], combinations=(1, 3)))\n    print(\n        \"Generated {} templates for transformation-based learning\".format(\n            len(templates)\n        )\n    )\n    postag(templates=templates, incremental_stats=True, template_stats=True)\n\n\ndef demo_learning_curve():\n    \"\"\"\n    Plot a learning curve -- the contribution on tagging accuracy of\n    the individual rules.\n    Note: requires matplotlib\n    \"\"\"\n    postag(\n        incremental_stats=True,\n        separate_baseline_data=True,\n        learning_curve_output=\"learningcurve.png\",\n    )\n\n\ndef demo_error_analysis():\n    \"\"\"\n    Writes a file with context for each erroneous word after tagging testing data\n    \"\"\"\n    postag(error_output=\"errors.txt\")\n\n\ndef demo_serialize_tagger():\n    \"\"\"\n    Serializes the learned tagger to a file in pickle format; reloads it\n    and validates the process.\n    \"\"\"\n    postag(serialize_output=\"tagger.pcl\")\n\n\ndef demo_high_accuracy_rules():\n    \"\"\"\n    Discard rules with low accuracy. This may hurt performance a bit,\n    but will often produce rules which are more interesting read to a human.\n    \"\"\"\n    postag(num_sents=3000, min_acc=0.96, min_score=10)\n\n\ndef postag(\n    templates=None,\n    tagged_data=None,\n    num_sents=1000,\n    max_rules=300,\n    min_score=3,\n    min_acc=None,\n    train=0.8,\n    trace=3,\n    randomize=False,\n    ruleformat=\"str\",\n    incremental_stats=False,\n    template_stats=False,\n    error_output=None,\n    serialize_output=None,\n    learning_curve_output=None,\n    learning_curve_take=300,\n    baseline_backoff_tagger=None,\n    separate_baseline_data=False,\n    cache_baseline_tagger=None,\n):\n    \"\"\"\n    Brill Tagger Demonstration\n    :param templates: how many sentences of training and testing data to use\n    :type templates: list of Template\n\n    :param tagged_data: maximum number of rule instances to create\n    :type tagged_data: C{int}\n\n    :param num_sents: how many sentences of training and testing data to use\n    :type num_sents: C{int}\n\n    :param max_rules: maximum number of rule instances to create\n    :type max_rules: C{int}\n\n    :param min_score: the minimum score for a rule in order for it to be considered\n    :type min_score: C{int}\n\n    :param min_acc: the minimum score for a rule in order for it to be considered\n    :type min_acc: C{float}\n\n    :param train: the fraction of the the corpus to be used for training (1=all)\n    :type train: C{float}\n\n    :param trace: the level of diagnostic tracing output to produce (0-4)\n    :type trace: C{int}\n\n    :param randomize: whether the training data should be a random subset of the corpus\n    :type randomize: C{bool}\n\n    :param ruleformat: rule output format, one of \"str\", \"repr\", \"verbose\"\n    :type ruleformat: C{str}\n\n    :param incremental_stats: if true, will tag incrementally and collect stats for each rule (rather slow)\n    :type incremental_stats: C{bool}\n\n    :param template_stats: if true, will print per-template statistics collected in training and (optionally) testing\n    :type template_stats: C{bool}\n\n    :param error_output: the file where errors will be saved\n    :type error_output: C{string}\n\n    :param serialize_output: the file where the learned tbl tagger will be saved\n    :type serialize_output: C{string}\n\n    :param learning_curve_output: filename of plot of learning curve(s) (train and also test, if available)\n    :type learning_curve_output: C{string}\n\n    :param learning_curve_take: how many rules plotted\n    :type learning_curve_take: C{int}\n\n    :param baseline_backoff_tagger: the file where rules will be saved\n    :type baseline_backoff_tagger: tagger\n\n    :param separate_baseline_data: use a fraction of the training data exclusively for training baseline\n    :type separate_baseline_data: C{bool}\n\n    :param cache_baseline_tagger: cache baseline tagger to this file (only interesting as a temporary workaround to get\n                                  deterministic output from the baseline unigram tagger between python versions)\n    :type cache_baseline_tagger: C{string}\n\n\n    Note on separate_baseline_data: if True, reuse training data both for baseline and rule learner. This\n    is fast and fine for a demo, but is likely to generalize worse on unseen data.\n    Also cannot be sensibly used for learning curves on training data (the baseline will be artificially high).\n    \"\"\"\n\n    # defaults\n    baseline_backoff_tagger = baseline_backoff_tagger or REGEXP_TAGGER\n    if templates is None:\n        from nltk.tag.brill import brill24, describe_template_sets\n\n        # some pre-built template sets taken from typical systems or publications are\n        # available. Print a list with describe_template_sets()\n        # for instance:\n        templates = brill24()\n    (training_data, baseline_data, gold_data, testing_data) = _demo_prepare_data(\n        tagged_data, train, num_sents, randomize, separate_baseline_data\n    )\n\n    # creating (or reloading from cache) a baseline tagger (unigram tagger)\n    # this is just a mechanism for getting deterministic output from the baseline between\n    # python versions\n    if cache_baseline_tagger:\n        if not os.path.exists(cache_baseline_tagger):\n            baseline_tagger = UnigramTagger(\n                baseline_data, backoff=baseline_backoff_tagger\n            )\n            with open(cache_baseline_tagger, \"w\") as print_rules:\n                pickle.dump(baseline_tagger, print_rules)\n            print(\n                \"Trained baseline tagger, pickled it to {}\".format(\n                    cache_baseline_tagger\n                )\n            )\n        with open(cache_baseline_tagger) as print_rules:\n            baseline_tagger = pickle.load(print_rules)\n            print(f\"Reloaded pickled tagger from {cache_baseline_tagger}\")\n    else:\n        baseline_tagger = UnigramTagger(baseline_data, backoff=baseline_backoff_tagger)\n        print(\"Trained baseline tagger\")\n    if gold_data:\n        print(\n            \"    Accuracy on test set: {:0.4f}\".format(\n                baseline_tagger.evaluate(gold_data)\n            )\n        )\n\n    # creating a Brill tagger\n    tbrill = time.time()\n    trainer = BrillTaggerTrainer(\n        baseline_tagger, templates, trace, ruleformat=ruleformat\n    )\n    print(\"Training tbl tagger...\")\n    brill_tagger = trainer.train(training_data, max_rules, min_score, min_acc)\n    print(f\"Trained tbl tagger in {time.time() - tbrill:0.2f} seconds\")\n    if gold_data:\n        print(\"    Accuracy on test set: %.4f\" % brill_tagger.evaluate(gold_data))\n\n    # printing the learned rules, if learned silently\n    if trace == 1:\n        print(\"\\nLearned rules: \")\n        for (ruleno, rule) in enumerate(brill_tagger.rules(), 1):\n            print(f\"{ruleno:4d} {rule.format(ruleformat):s}\")\n\n    # printing template statistics (optionally including comparison with the training data)\n    # note: if not separate_baseline_data, then baseline accuracy will be artificially high\n    if incremental_stats:\n        print(\n            \"Incrementally tagging the test data, collecting individual rule statistics\"\n        )\n        (taggedtest, teststats) = brill_tagger.batch_tag_incremental(\n            testing_data, gold_data\n        )\n        print(\"    Rule statistics collected\")\n        if not separate_baseline_data:\n            print(\n                \"WARNING: train_stats asked for separate_baseline_data=True; the baseline \"\n                \"will be artificially high\"\n            )\n        trainstats = brill_tagger.train_stats()\n        if template_stats:\n            brill_tagger.print_template_statistics(teststats)\n        if learning_curve_output:\n            _demo_plot(\n                learning_curve_output, teststats, trainstats, take=learning_curve_take\n            )\n            print(f\"Wrote plot of learning curve to {learning_curve_output}\")\n    else:\n        print(\"Tagging the test data\")\n        taggedtest = brill_tagger.tag_sents(testing_data)\n        if template_stats:\n            brill_tagger.print_template_statistics()\n\n    # writing error analysis to file\n    if error_output is not None:\n        with open(error_output, \"w\") as f:\n            f.write(\"Errors for Brill Tagger %r\\n\\n\" % serialize_output)\n            f.write(\"\\n\".join(error_list(gold_data, taggedtest)).encode(\"utf-8\") + \"\\n\")\n        print(f\"Wrote tagger errors including context to {error_output}\")\n\n    # serializing the tagger to a pickle file and reloading (just to see it works)\n    if serialize_output is not None:\n        taggedtest = brill_tagger.tag_sents(testing_data)\n        with open(serialize_output, \"w\") as print_rules:\n            pickle.dump(brill_tagger, print_rules)\n        print(f\"Wrote pickled tagger to {serialize_output}\")\n        with open(serialize_output) as print_rules:\n            brill_tagger_reloaded = pickle.load(print_rules)\n        print(f\"Reloaded pickled tagger from {serialize_output}\")\n        taggedtest_reloaded = brill_tagger.tag_sents(testing_data)\n        if taggedtest == taggedtest_reloaded:\n            print(\"Reloaded tagger tried on test set, results identical\")\n        else:\n            print(\"PROBLEM: Reloaded tagger gave different results on test set\")\n\n\ndef _demo_prepare_data(\n    tagged_data, train, num_sents, randomize, separate_baseline_data\n):\n    # train is the proportion of data used in training; the rest is reserved\n    # for testing.\n    if tagged_data is None:\n        print(\"Loading tagged data from treebank... \")\n        tagged_data = treebank.tagged_sents()\n    if num_sents is None or len(tagged_data) <= num_sents:\n        num_sents = len(tagged_data)\n    if randomize:\n        random.seed(len(tagged_data))\n        random.shuffle(tagged_data)\n    cutoff = int(num_sents * train)\n    training_data = tagged_data[:cutoff]\n    gold_data = tagged_data[cutoff:num_sents]\n    testing_data = [[t[0] for t in sent] for sent in gold_data]\n    if not separate_baseline_data:\n        baseline_data = training_data\n    else:\n        bl_cutoff = len(training_data) // 3\n        (baseline_data, training_data) = (\n            training_data[:bl_cutoff],\n            training_data[bl_cutoff:],\n        )\n    (trainseqs, traintokens) = corpus_size(training_data)\n    (testseqs, testtokens) = corpus_size(testing_data)\n    (bltrainseqs, bltraintokens) = corpus_size(baseline_data)\n    print(f\"Read testing data ({testseqs:d} sents/{testtokens:d} wds)\")\n    print(f\"Read training data ({trainseqs:d} sents/{traintokens:d} wds)\")\n    print(\n        \"Read baseline data ({:d} sents/{:d} wds) {:s}\".format(\n            bltrainseqs,\n            bltraintokens,\n            \"\" if separate_baseline_data else \"[reused the training set]\",\n        )\n    )\n    return (training_data, baseline_data, gold_data, testing_data)\n\n\ndef _demo_plot(learning_curve_output, teststats, trainstats=None, take=None):\n    testcurve = [teststats[\"initialerrors\"]]\n    for rulescore in teststats[\"rulescores\"]:\n        testcurve.append(testcurve[-1] - rulescore)\n    testcurve = [1 - x / teststats[\"tokencount\"] for x in testcurve[:take]]\n\n    traincurve = [trainstats[\"initialerrors\"]]\n    for rulescore in trainstats[\"rulescores\"]:\n        traincurve.append(traincurve[-1] - rulescore)\n    traincurve = [1 - x / trainstats[\"tokencount\"] for x in traincurve[:take]]\n\n    import matplotlib.pyplot as plt\n\n    r = list(range(len(testcurve)))\n    plt.plot(r, testcurve, r, traincurve)\n    plt.axis([None, None, None, 1.0])\n    plt.savefig(learning_curve_output)\n\n\nNN_CD_TAGGER = RegexpTagger([(r\"^-?[0-9]+(\\.[0-9]+)?$\", \"CD\"), (r\".*\", \"NN\")])\n\nREGEXP_TAGGER = RegexpTagger(\n    [\n        (r\"^-?[0-9]+(\\.[0-9]+)?$\", \"CD\"),  # cardinal numbers\n        (r\"(The|the|A|a|An|an)$\", \"AT\"),  # articles\n        (r\".*able$\", \"JJ\"),  # adjectives\n        (r\".*ness$\", \"NN\"),  # nouns formed from adjectives\n        (r\".*ly$\", \"RB\"),  # adverbs\n        (r\".*s$\", \"NNS\"),  # plural nouns\n        (r\".*ing$\", \"VBG\"),  # gerunds\n        (r\".*ed$\", \"VBD\"),  # past tense verbs\n        (r\".*\", \"NN\"),  # nouns (default)\n    ]\n)\n\n\ndef corpus_size(seqs):\n    return (len(seqs), sum(len(x) for x in seqs))\n\n\nif __name__ == \"__main__\":\n    demo_learning_curve()\n"], "filenames": ["nltk/parse/malt.py", "nltk/sem/glue.py", "nltk/tag/brill.py", "nltk/tag/brill_trainer.py", "nltk/tag/sequential.py", "nltk/tbl/demo.py"], "buggy_code_start_loc": [35, 706, 332, 94, 340, 396], "buggy_code_end_loc": [36, 707, 333, 216, 519, 401], "fixing_code_start_loc": [35, 706, 332, 94, 340, 396], "fixing_code_end_loc": [36, 707, 333, 216, 519, 401], "type": "CWE-1333", "message": "nltk is vulnerable to Inefficient Regular Expression Complexity", "other": {"cve": {"id": "CVE-2021-3842", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-04T15:15:07.833", "lastModified": "2022-01-12T21:15:39.057", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "nltk is vulnerable to Inefficient Regular Expression Complexity"}, {"lang": "es", "value": "nltk es vulnerable a una Complejidad de Expresi\u00f3n Regular Ineficiente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nltk:nltk:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.6.6", "matchCriteriaId": "3BCA0BD1-C000-418A-8D81-59C5335FB3DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/nltk/nltk/commit/2a50a3edc9d35f57ae42a921c621edc160877f4d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/761a761e-2be2-430a-8d92-6f74ffe9866a", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nltk/nltk/commit/2a50a3edc9d35f57ae42a921c621edc160877f4d"}}