{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011 Instituto Nokia de Tecnologia\n *\n * Authors:\n *    Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\n *    Lauro Ramos Venancio <lauro.venancio@openbossa.org>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <net/tcp_states.h>\n#include <linux/nfc.h>\n#include <linux/export.h>\n\n#include \"nfc.h\"\n\nstatic struct nfc_sock_list raw_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(raw_sk_list.lock)\n};\n\nstatic void nfc_sock_link(struct nfc_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_add_node(sk, &l->head);\n\twrite_unlock(&l->lock);\n}\n\nstatic void nfc_sock_unlink(struct nfc_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_del_node_init(sk);\n\twrite_unlock(&l->lock);\n}\n\nstatic void rawsock_write_queue_purge(struct sock *sk)\n{\n\tpr_debug(\"sk=%p\\n\", sk);\n\n\tspin_lock_bh(&sk->sk_write_queue.lock);\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\tspin_unlock_bh(&sk->sk_write_queue.lock);\n}\n\nstatic void rawsock_report_error(struct sock *sk, int err)\n{\n\tpr_debug(\"sk=%p err=%d\\n\", sk, err);\n\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsk->sk_err = -err;\n\tsk->sk_error_report(sk);\n\n\trawsock_write_queue_purge(sk);\n}\n\nstatic int rawsock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tpr_debug(\"sock=%p sk=%p\\n\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_unlink(&raw_sk_list, sk);\n\n\tsock_orphan(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int rawsock_connect(struct socket *sock, struct sockaddr *_addr,\n\t\t\t   int len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_nfc *addr = (struct sockaddr_nfc *)_addr;\n\tstruct nfc_dev *dev;\n\tint rc = 0;\n\n\tpr_debug(\"sock=%p sk=%p flags=%d\\n\", sock, sk, flags);\n\n\tif (!addr || len < sizeof(struct sockaddr_nfc) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"addr dev_idx=%u target_idx=%u protocol=%u\\n\",\n\t\t addr->dev_idx, addr->target_idx, addr->nfc_protocol);\n\n\tlock_sock(sk);\n\n\tif (sock->state == SS_CONNECTED) {\n\t\trc = -EISCONN;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(addr->dev_idx);\n\tif (!dev) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (addr->target_idx > dev->target_next_idx - 1 ||\n\t    addr->target_idx < dev->target_next_idx - dev->n_targets) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\trc = nfc_activate_target(dev, addr->target_idx, addr->nfc_protocol);\n\tif (rc)\n\t\tgoto put_dev;\n\n\tnfc_rawsock(sk)->dev = dev;\n\tnfc_rawsock(sk)->target_idx = addr->target_idx;\n\tsock->state = SS_CONNECTED;\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk->sk_state_change(sk);\n\n\trelease_sock(sk);\n\treturn 0;\n\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int rawsock_add_header(struct sk_buff *skb)\n{\n\t*(u8 *)skb_push(skb, NFC_HEADER_SIZE) = 0;\n\n\treturn 0;\n}\n\nstatic void rawsock_data_exchange_complete(void *context, struct sk_buff *skb,\n\t\t\t\t\t   int err)\n{\n\tstruct sock *sk = (struct sock *) context;\n\n\tBUG_ON(in_irq());\n\n\tpr_debug(\"sk=%p err=%d\\n\", sk, err);\n\n\tif (err)\n\t\tgoto error;\n\n\terr = rawsock_add_header(skb);\n\tif (err)\n\t\tgoto error_skb;\n\n\terr = sock_queue_rcv_skb(sk, skb);\n\tif (err)\n\t\tgoto error_skb;\n\n\tspin_lock_bh(&sk->sk_write_queue.lock);\n\tif (!skb_queue_empty(&sk->sk_write_queue))\n\t\tschedule_work(&nfc_rawsock(sk)->tx_work);\n\telse\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\tspin_unlock_bh(&sk->sk_write_queue.lock);\n\n\tsock_put(sk);\n\treturn;\n\nerror_skb:\n\tkfree_skb(skb);\n\nerror:\n\trawsock_report_error(sk, err);\n\tsock_put(sk);\n}\n\nstatic void rawsock_tx_work(struct work_struct *work)\n{\n\tstruct sock *sk = to_rawsock_sk(work);\n\tstruct nfc_dev *dev = nfc_rawsock(sk)->dev;\n\tu32 target_idx = nfc_rawsock(sk)->target_idx;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tpr_debug(\"sk=%p target_idx=%u\\n\", sk, target_idx);\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\trawsock_write_queue_purge(sk);\n\t\treturn;\n\t}\n\n\tskb = skb_dequeue(&sk->sk_write_queue);\n\n\tsock_hold(sk);\n\trc = nfc_data_exchange(dev, target_idx, skb,\n\t\t\t       rawsock_data_exchange_complete, sk);\n\tif (rc) {\n\t\trawsock_report_error(sk, rc);\n\t\tsock_put(sk);\n\t}\n}\n\nstatic int rawsock_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_dev *dev = nfc_rawsock(sk)->dev;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tpr_debug(\"sock=%p sk=%p len=%zu\\n\", sock, sk, len);\n\n\tif (msg->msg_namelen)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sock->state != SS_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\tskb = nfc_alloc_send_skb(dev, sk, msg->msg_flags, len, &rc);\n\tif (skb == NULL)\n\t\treturn rc;\n\n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\treturn rc;\n\t}\n\n\tspin_lock_bh(&sk->sk_write_queue.lock);\n\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\tif (!nfc_rawsock(sk)->tx_work_scheduled) {\n\t\tschedule_work(&nfc_rawsock(sk)->tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = true;\n\t}\n\tspin_unlock_bh(&sk->sk_write_queue.lock);\n\n\treturn len;\n}\n\nstatic int rawsock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t   int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint rc;\n\n\tpr_debug(\"sock=%p sk=%p len=%zu flags=%d\\n\", sock, sk, len, flags);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &rc);\n\tif (!skb)\n\t\treturn rc;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\trc = skb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn rc ? : copied;\n}\n\nstatic const struct proto_ops rawsock_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.release        = rawsock_release,\n\t.bind           = sock_no_bind,\n\t.connect        = rawsock_connect,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = sock_no_accept,\n\t.getname        = sock_no_getname,\n\t.poll           = datagram_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = sock_no_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.sendmsg        = rawsock_sendmsg,\n\t.recvmsg        = rawsock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic const struct proto_ops rawsock_raw_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.release        = rawsock_release,\n\t.bind           = sock_no_bind,\n\t.connect        = sock_no_connect,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = sock_no_accept,\n\t.getname        = sock_no_getname,\n\t.poll           = datagram_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = sock_no_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.sendmsg        = sock_no_sendmsg,\n\t.recvmsg        = rawsock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic void rawsock_destruct(struct sock *sk)\n{\n\tpr_debug(\"sk=%p\\n\", sk);\n\n\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\tnfc_deactivate_target(nfc_rawsock(sk)->dev,\n\t\t\t\t      nfc_rawsock(sk)->target_idx,\n\t\t\t\t      NFC_TARGET_MODE_IDLE);\n\t\tnfc_put_device(nfc_rawsock(sk)->dev);\n\t}\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC raw socket %p\\n\", sk);\n\t\treturn;\n\t}\n}\n\nstatic int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\n\treturn 0;\n}\n\nvoid nfc_send_to_raw_sock(struct nfc_dev *dev, struct sk_buff *skb,\n\t\t\t  u8 payload_type, u8 direction)\n{\n\tstruct sk_buff *skb_copy = NULL, *nskb;\n\tstruct sock *sk;\n\tu8 *data;\n\n\tread_lock(&raw_sk_list.lock);\n\n\tsk_for_each(sk, &raw_sk_list.head) {\n\t\tif (!skb_copy) {\n\t\t\tskb_copy = __pskb_copy_fclone(skb, NFC_RAW_HEADER_SIZE,\n\t\t\t\t\t\t      GFP_ATOMIC, true);\n\t\t\tif (!skb_copy)\n\t\t\t\tcontinue;\n\n\t\t\tdata = skb_push(skb_copy, NFC_RAW_HEADER_SIZE);\n\n\t\t\tdata[0] = dev ? dev->idx : 0xFF;\n\t\t\tdata[1] = direction & 0x01;\n\t\t\tdata[1] |= (payload_type << 1);\n\t\t}\n\n\t\tnskb = skb_clone(skb_copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tread_unlock(&raw_sk_list.lock);\n\n\tkfree_skb(skb_copy);\n}\nEXPORT_SYMBOL(nfc_send_to_raw_sock);\n\nstatic struct proto rawsock_proto = {\n\t.name     = \"NFC_RAW\",\n\t.owner    = THIS_MODULE,\n\t.obj_size = sizeof(struct nfc_rawsock),\n};\n\nstatic const struct nfc_protocol rawsock_nfc_proto = {\n\t.id\t  = NFC_SOCKPROTO_RAW,\n\t.proto    = &rawsock_proto,\n\t.owner    = THIS_MODULE,\n\t.create   = rawsock_create\n};\n\nint __init rawsock_init(void)\n{\n\tint rc;\n\n\trc = nfc_proto_register(&rawsock_nfc_proto);\n\n\treturn rc;\n}\n\nvoid rawsock_exit(void)\n{\n\tnfc_proto_unregister(&rawsock_nfc_proto);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011 Instituto Nokia de Tecnologia\n *\n * Authors:\n *    Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\n *    Lauro Ramos Venancio <lauro.venancio@openbossa.org>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <net/tcp_states.h>\n#include <linux/nfc.h>\n#include <linux/export.h>\n\n#include \"nfc.h\"\n\nstatic struct nfc_sock_list raw_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(raw_sk_list.lock)\n};\n\nstatic void nfc_sock_link(struct nfc_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_add_node(sk, &l->head);\n\twrite_unlock(&l->lock);\n}\n\nstatic void nfc_sock_unlink(struct nfc_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_del_node_init(sk);\n\twrite_unlock(&l->lock);\n}\n\nstatic void rawsock_write_queue_purge(struct sock *sk)\n{\n\tpr_debug(\"sk=%p\\n\", sk);\n\n\tspin_lock_bh(&sk->sk_write_queue.lock);\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\tspin_unlock_bh(&sk->sk_write_queue.lock);\n}\n\nstatic void rawsock_report_error(struct sock *sk, int err)\n{\n\tpr_debug(\"sk=%p err=%d\\n\", sk, err);\n\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsk->sk_err = -err;\n\tsk->sk_error_report(sk);\n\n\trawsock_write_queue_purge(sk);\n}\n\nstatic int rawsock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tpr_debug(\"sock=%p sk=%p\\n\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_unlink(&raw_sk_list, sk);\n\n\tsock_orphan(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int rawsock_connect(struct socket *sock, struct sockaddr *_addr,\n\t\t\t   int len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_nfc *addr = (struct sockaddr_nfc *)_addr;\n\tstruct nfc_dev *dev;\n\tint rc = 0;\n\n\tpr_debug(\"sock=%p sk=%p flags=%d\\n\", sock, sk, flags);\n\n\tif (!addr || len < sizeof(struct sockaddr_nfc) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"addr dev_idx=%u target_idx=%u protocol=%u\\n\",\n\t\t addr->dev_idx, addr->target_idx, addr->nfc_protocol);\n\n\tlock_sock(sk);\n\n\tif (sock->state == SS_CONNECTED) {\n\t\trc = -EISCONN;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(addr->dev_idx);\n\tif (!dev) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (addr->target_idx > dev->target_next_idx - 1 ||\n\t    addr->target_idx < dev->target_next_idx - dev->n_targets) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\trc = nfc_activate_target(dev, addr->target_idx, addr->nfc_protocol);\n\tif (rc)\n\t\tgoto put_dev;\n\n\tnfc_rawsock(sk)->dev = dev;\n\tnfc_rawsock(sk)->target_idx = addr->target_idx;\n\tsock->state = SS_CONNECTED;\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk->sk_state_change(sk);\n\n\trelease_sock(sk);\n\treturn 0;\n\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int rawsock_add_header(struct sk_buff *skb)\n{\n\t*(u8 *)skb_push(skb, NFC_HEADER_SIZE) = 0;\n\n\treturn 0;\n}\n\nstatic void rawsock_data_exchange_complete(void *context, struct sk_buff *skb,\n\t\t\t\t\t   int err)\n{\n\tstruct sock *sk = (struct sock *) context;\n\n\tBUG_ON(in_irq());\n\n\tpr_debug(\"sk=%p err=%d\\n\", sk, err);\n\n\tif (err)\n\t\tgoto error;\n\n\terr = rawsock_add_header(skb);\n\tif (err)\n\t\tgoto error_skb;\n\n\terr = sock_queue_rcv_skb(sk, skb);\n\tif (err)\n\t\tgoto error_skb;\n\n\tspin_lock_bh(&sk->sk_write_queue.lock);\n\tif (!skb_queue_empty(&sk->sk_write_queue))\n\t\tschedule_work(&nfc_rawsock(sk)->tx_work);\n\telse\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\tspin_unlock_bh(&sk->sk_write_queue.lock);\n\n\tsock_put(sk);\n\treturn;\n\nerror_skb:\n\tkfree_skb(skb);\n\nerror:\n\trawsock_report_error(sk, err);\n\tsock_put(sk);\n}\n\nstatic void rawsock_tx_work(struct work_struct *work)\n{\n\tstruct sock *sk = to_rawsock_sk(work);\n\tstruct nfc_dev *dev = nfc_rawsock(sk)->dev;\n\tu32 target_idx = nfc_rawsock(sk)->target_idx;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tpr_debug(\"sk=%p target_idx=%u\\n\", sk, target_idx);\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\trawsock_write_queue_purge(sk);\n\t\treturn;\n\t}\n\n\tskb = skb_dequeue(&sk->sk_write_queue);\n\n\tsock_hold(sk);\n\trc = nfc_data_exchange(dev, target_idx, skb,\n\t\t\t       rawsock_data_exchange_complete, sk);\n\tif (rc) {\n\t\trawsock_report_error(sk, rc);\n\t\tsock_put(sk);\n\t}\n}\n\nstatic int rawsock_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_dev *dev = nfc_rawsock(sk)->dev;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tpr_debug(\"sock=%p sk=%p len=%zu\\n\", sock, sk, len);\n\n\tif (msg->msg_namelen)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sock->state != SS_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\tskb = nfc_alloc_send_skb(dev, sk, msg->msg_flags, len, &rc);\n\tif (skb == NULL)\n\t\treturn rc;\n\n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\treturn rc;\n\t}\n\n\tspin_lock_bh(&sk->sk_write_queue.lock);\n\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\tif (!nfc_rawsock(sk)->tx_work_scheduled) {\n\t\tschedule_work(&nfc_rawsock(sk)->tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = true;\n\t}\n\tspin_unlock_bh(&sk->sk_write_queue.lock);\n\n\treturn len;\n}\n\nstatic int rawsock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t   int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint rc;\n\n\tpr_debug(\"sock=%p sk=%p len=%zu flags=%d\\n\", sock, sk, len, flags);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &rc);\n\tif (!skb)\n\t\treturn rc;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\trc = skb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn rc ? : copied;\n}\n\nstatic const struct proto_ops rawsock_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.release        = rawsock_release,\n\t.bind           = sock_no_bind,\n\t.connect        = rawsock_connect,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = sock_no_accept,\n\t.getname        = sock_no_getname,\n\t.poll           = datagram_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = sock_no_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.sendmsg        = rawsock_sendmsg,\n\t.recvmsg        = rawsock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic const struct proto_ops rawsock_raw_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.release        = rawsock_release,\n\t.bind           = sock_no_bind,\n\t.connect        = sock_no_connect,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = sock_no_accept,\n\t.getname        = sock_no_getname,\n\t.poll           = datagram_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = sock_no_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.sendmsg        = sock_no_sendmsg,\n\t.recvmsg        = rawsock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic void rawsock_destruct(struct sock *sk)\n{\n\tpr_debug(\"sk=%p\\n\", sk);\n\n\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\tnfc_deactivate_target(nfc_rawsock(sk)->dev,\n\t\t\t\t      nfc_rawsock(sk)->target_idx,\n\t\t\t\t      NFC_TARGET_MODE_IDLE);\n\t\tnfc_put_device(nfc_rawsock(sk)->dev);\n\t}\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC raw socket %p\\n\", sk);\n\t\treturn;\n\t}\n}\n\nstatic int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &rawsock_raw_ops;\n\t} else {\n\t\tsock->ops = &rawsock_ops;\n\t}\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\n\treturn 0;\n}\n\nvoid nfc_send_to_raw_sock(struct nfc_dev *dev, struct sk_buff *skb,\n\t\t\t  u8 payload_type, u8 direction)\n{\n\tstruct sk_buff *skb_copy = NULL, *nskb;\n\tstruct sock *sk;\n\tu8 *data;\n\n\tread_lock(&raw_sk_list.lock);\n\n\tsk_for_each(sk, &raw_sk_list.head) {\n\t\tif (!skb_copy) {\n\t\t\tskb_copy = __pskb_copy_fclone(skb, NFC_RAW_HEADER_SIZE,\n\t\t\t\t\t\t      GFP_ATOMIC, true);\n\t\t\tif (!skb_copy)\n\t\t\t\tcontinue;\n\n\t\t\tdata = skb_push(skb_copy, NFC_RAW_HEADER_SIZE);\n\n\t\t\tdata[0] = dev ? dev->idx : 0xFF;\n\t\t\tdata[1] = direction & 0x01;\n\t\t\tdata[1] |= (payload_type << 1);\n\t\t}\n\n\t\tnskb = skb_clone(skb_copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tread_unlock(&raw_sk_list.lock);\n\n\tkfree_skb(skb_copy);\n}\nEXPORT_SYMBOL(nfc_send_to_raw_sock);\n\nstatic struct proto rawsock_proto = {\n\t.name     = \"NFC_RAW\",\n\t.owner    = THIS_MODULE,\n\t.obj_size = sizeof(struct nfc_rawsock),\n};\n\nstatic const struct nfc_protocol rawsock_nfc_proto = {\n\t.id\t  = NFC_SOCKPROTO_RAW,\n\t.proto    = &rawsock_proto,\n\t.owner    = THIS_MODULE,\n\t.create   = rawsock_create\n};\n\nint __init rawsock_init(void)\n{\n\tint rc;\n\n\trc = nfc_proto_register(&rawsock_nfc_proto);\n\n\treturn rc;\n}\n\nvoid rawsock_exit(void)\n{\n\tnfc_proto_unregister(&rawsock_nfc_proto);\n}\n"], "filenames": ["net/nfc/rawsock.c"], "buggy_code_start_loc": [331], "buggy_code_end_loc": [334], "fixing_code_start_loc": [331], "fixing_code_end_loc": [338], "type": "CWE-276", "message": "A missing CAP_NET_RAW check in NFC socket creation in net/nfc/rawsock.c in the Linux kernel before 5.8.2 could be used by local attackers to create raw sockets, bypassing security mechanisms, aka CID-26896f01467a.", "other": {"cve": {"id": "CVE-2020-26088", "sourceIdentifier": "cve@mitre.org", "published": "2020-09-24T15:15:15.267", "lastModified": "2022-04-27T18:48:30.770", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A missing CAP_NET_RAW check in NFC socket creation in net/nfc/rawsock.c in the Linux kernel before 5.8.2 could be used by local attackers to create raw sockets, bypassing security mechanisms, aka CID-26896f01467a."}, {"lang": "es", "value": "Una falta de comprobaci\u00f3n de CAP_NET_RAW en la creaci\u00f3n de sockets NFC en el archivo net/nfc/rawsock.c en el Kernel de Linux versiones anteriores a 5.8.2, podr\u00eda ser usada por unos atacantes locales para crear sockets sin procesar, omitiendo los mecanismos de seguridad, tambi\u00e9n se conoce como CID-26896f01467a."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.8.2", "matchCriteriaId": "4B1FEE1B-9D81-4384-9BCD-1105FF355D94"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00001.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00021.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.8.2", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/26896f01467a28651f7a536143fe5ac8449d4041", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/09/msg00025.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00032.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00034.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4578-1/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/26896f01467a28651f7a536143fe5ac8449d4041"}}