{"buggy_code": ["/*\n * checkpath.c\n * Checks for the existance of a file or directory and creates it\n * if necessary. It can also correct its ownership.\n */\n\n/*\n * Copyright (c) 2007-2015 The OpenRC Authors.\n * See the Authors file at the top-level directory of this distribution and\n * https://github.com/OpenRC/openrc/blob/master/AUTHORS\n *\n * This file is part of OpenRC. It is subject to the license terms in\n * the LICENSE file found in the top-level directory of this\n * distribution and at https://github.com/OpenRC/openrc/blob/master/LICENSE\n * This file may not be copied, modified, propagated, or distributed\n *    except according to the terms contained in the LICENSE file.\n */\n\n#define _GNU_SOURCE\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <grp.h>\n#include <libgen.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"einfo.h\"\n#include \"rc.h\"\n#include \"rc-misc.h\"\n#include \"rc-selinux.h\"\n#include \"_usage.h\"\n\ntypedef enum {\n\tinode_unknown = 0,\n\tinode_file = 1,\n\tinode_dir = 2,\n\tinode_fifo = 3,\n} inode_t;\n\nconst char *applet = NULL;\nconst char *extraopts =\"path1 [path2] [...]\";\nconst char *getoptstring = \"dDfFpm:o:sW\" getoptstring_COMMON;\nconst struct option longopts[] = {\n\t{ \"directory\",          0, NULL, 'd'},\n\t{ \"directory-truncate\", 0, NULL, 'D'},\n\t{ \"file\",               0, NULL, 'f'},\n\t{ \"file-truncate\",      0, NULL, 'F'},\n\t{ \"pipe\",               0, NULL, 'p'},\n\t{ \"mode\",               1, NULL, 'm'},\n\t{ \"owner\",              1, NULL, 'o'},\n\t{ \"symlinks\",           0, NULL, 's'},\n\t{ \"writable\",           0, NULL, 'W'},\n\tlongopts_COMMON\n};\nconst char * const longopts_help[] = {\n\t\"Create a directory if not exists\",\n\t\"Create/empty directory\",\n\t\"Create a file if not exists\",\n\t\"Truncate file\",\n\t\"Create a named pipe (FIFO) if not exists\",\n\t\"Mode to check\",\n\t\"Owner to check (user:group)\",\n\t\"follow symbolic links (irrelivent on linux)\",\n\t\"Check whether the path is writable or not\",\n\tlongopts_help_COMMON\n};\nconst char *usagestring = NULL;\n\nstatic int get_dirfd(char *path, bool symlinks)\n{\n\tchar *ch;\n\tchar *item;\n\tchar *linkpath = NULL;\n\tchar *path_dupe;\n\tchar *str;\n\tint components = 0;\n\tint dirfd;\n\tint flags = 0;\n\tint new_dirfd;\n\tstruct stat st;\n\tssize_t linksize;\n\n\tif (!path || *path != '/')\n\t\teerrorx(\"%s: empty or relative path\", applet);\n\tdirfd = openat(dirfd, \"/\", O_RDONLY);\n\tif (dirfd == -1)\n\t\teerrorx(\"%s: unable to open the root directory: %s\",\n\t\t\t\tapplet, strerror(errno));\n\tpath_dupe = xstrdup(path);\n\tch = path_dupe;\n\twhile (*ch) {\n\t\tif (*ch == '/')\n\t\t\tcomponents++;\n\t\tch++;\n\t}\n\titem = strtok(path_dupe, \"/\");\n#ifdef O_PATH\n\tflags |= O_PATH;\n#endif\n\tif (!symlinks)\n\t\tflags |= O_NOFOLLOW;\n\tflags |= O_RDONLY;\n\twhile (dirfd > 0 && item && components > 1) {\n\t\tstr = xstrdup(linkpath ? linkpath : item);\n\t\tnew_dirfd = openat(dirfd, str, flags);\n\t\tif (new_dirfd == -1)\n\t\t\teerrorx(\"%s: %s: could not open %s: %s\", applet, path, str,\n\t\t\t\t\tstrerror(errno));\n\t\tif (fstat(new_dirfd, &st) == -1)\n\t\t\teerrorx(\"%s: %s: unable to stat %s: %s\", applet, path, item,\n\t\t\t\t\tstrerror(errno));\n\t\tif (S_ISLNK(st.st_mode) ) {\n\t\t\tif (st.st_uid != 0)\n\t\t\t\teerrorx(\"%s: %s: symbolic link %s not owned by root\",\n\t\t\t\t\t\tapplet, path, str);\n\t\t\tlinksize = st.st_size+1;\n\t\t\tif (linkpath)\n\t\t\t\tfree(linkpath);\n\t\t\tlinkpath = xmalloc(linksize);\n\t\t\tmemset(linkpath, 0, linksize);\n\t\t\tif (readlinkat(new_dirfd, \"\", linkpath, linksize) != st.st_size)\n\t\t\t\teerrorx(\"%s: symbolic link destination changed\", applet);\n\t\t\t/*\n\t\t\t * now follow the symlink.\n\t\t\t */\n\t\t\tclose(new_dirfd);\n\t\t} else {\n\t\t\tclose(dirfd);\n\t\t\tdirfd = new_dirfd;\n\t\t\tfree(linkpath);\n\t\t\tlinkpath = NULL;\n\t\t\titem = strtok(NULL, \"/\");\n\t\t\tcomponents--;\n\t\t}\n\t}\n\tfree(path_dupe);\n\tif (linkpath) {\n\t\tfree(linkpath);\n\t\tlinkpath = NULL;\n\t}\n\treturn dirfd;\n}\n\nstatic int do_check(char *path, uid_t uid, gid_t gid, mode_t mode,\n\tinode_t type, bool trunc, bool chowner, bool symlinks, bool selinux_on)\n{\n\tstruct stat st;\n\tchar *name = NULL;\n\tint dirfd;\n\tint fd;\n\tint flags;\n\tint r;\n\tint readfd;\n\tint readflags;\n\tint u;\n\n\tmemset(&st, 0, sizeof(st));\n\tflags = O_CREAT|O_NDELAY|O_WRONLY|O_NOCTTY;\n\treadflags = O_NDELAY|O_NOCTTY|O_RDONLY;\n#ifdef O_CLOEXEC\n\tflags |= O_CLOEXEC;\n\treadflags |= O_CLOEXEC;\n#endif\n#ifdef O_NOFOLLOW\n\tflags |= O_NOFOLLOW;\n\treadflags |= O_NOFOLLOW;\n#endif\n\tif (trunc)\n\t\tflags |= O_TRUNC;\n\txasprintf(&name, \"%s\", basename_c(path));\n\tdirfd = get_dirfd(path, symlinks);\n\treadfd = openat(dirfd, name, readflags);\n\tif (readfd == -1 || (type == inode_file && trunc)) {\n\t\tif (type == inode_file) {\n\t\t\teinfo(\"%s: creating file\", path);\n\t\t\tif (!mode) /* 664 */\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH;\n\t\t\tu = umask(0);\n\t\t\tfd = openat(dirfd, name, flags, mode);\n\t\t\tumask(u);\n\t\t\tif (fd == -1) {\n\t\t\t\teerror(\"%s: open: %s\", applet, strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (readfd != -1 && trunc)\n\t\t\t\tclose(readfd);\n\t\t\treadfd = fd;\n\t\t} else if (type == inode_dir) {\n\t\t\teinfo(\"%s: creating directory\", path);\n\t\t\tif (!mode) /* 775 */\n\t\t\t\tmode = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH;\n\t\t\tu = umask(0);\n\t\t\t/* We do not recursively create parents */\n\t\t\tr = mkdirat(dirfd, name, mode);\n\t\t\tumask(u);\n\t\t\tif (r == -1 && errno != EEXIST) {\n\t\t\t\teerror(\"%s: mkdirat: %s\", applet,\n\t\t\t\t    strerror (errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treadfd = openat(dirfd, name, readflags);\n\t\t\tif (readfd == -1) {\n\t\t\t\teerror(\"%s: unable to open directory: %s\", applet,\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (type == inode_fifo) {\n\t\t\teinfo(\"%s: creating fifo\", path);\n\t\t\tif (!mode) /* 600 */\n\t\t\t\tmode = S_IRUSR | S_IWUSR;\n\t\t\tu = umask(0);\n\t\t\tr = mkfifo(path, mode);\n\t\t\tumask(u);\n\t\t\tif (r == -1 && errno != EEXIST) {\n\t\t\t\teerror(\"%s: mkfifo: %s\", applet,\n\t\t\t\t    strerror (errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treadfd = openat(dirfd, name, readflags);\n\t\t\tif (readfd == -1) {\n\t\t\t\teerror(\"%s: unable to open fifo: %s\", applet,\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (fstat(readfd, &st) != -1) {\n\t\tif (type != inode_dir && S_ISDIR(st.st_mode)) {\n\t\t\teerror(\"%s: is a directory\", path);\n\t\t\tclose(readfd);\n\t\t\treturn 1;\n\t\t}\n\t\tif (type != inode_file && S_ISREG(st.st_mode)) {\n\t\t\teerror(\"%s: is a file\", path);\n\t\t\tclose(readfd);\n\t\t\treturn 1;\n\t\t}\n\t\tif (type != inode_fifo && S_ISFIFO(st.st_mode)) {\n\t\t\teerror(\"%s: is a fifo\", path);\n\t\t\tclose(readfd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (mode && (st.st_mode & 0777) != mode) {\n\t\t\tif ((type != inode_dir) && (st.st_nlink > 1)) {\n\t\t\t\teerror(\"%s: chmod: Too many hard links to %s\", applet, path);\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\teerror(\"%s: chmod: %s %s\", applet, path, \" is a symbolic link\");\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\teinfo(\"%s: correcting mode\", path);\n\t\t\tif (fchmod(readfd, mode)) {\n\t\t\t\teerror(\"%s: chmod: %s\", applet, strerror(errno));\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (chowner && (st.st_uid != uid || st.st_gid != gid)) {\n\t\t\tif ((type != inode_dir) && (st.st_nlink > 1)) {\n\t\t\t\teerror(\"%s: chown: %s %s\", applet, \"Too many hard links to\", path);\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\teerror(\"%s: chown: %s %s\", applet, path, \" is a symbolic link\");\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\teinfo(\"%s: correcting owner\", path);\n\t\t\tif (fchown(readfd, uid, gid)) {\n\t\t\t\teerror(\"%s: chown: %s\", applet, strerror(errno));\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (selinux_on)\n\t\t\tselinux_util_label(path);\n\t} else {\n\t\teerror(\"fstat: %s: %s\", path, strerror(errno));\n\t\tclose(readfd);\n\t\treturn -1;\n\t}\n\tclose(readfd);\n\n\treturn 0;\n}\n\nstatic int parse_owner(struct passwd **user, struct group **group,\n\tconst char *owner)\n{\n\tchar *u = xstrdup (owner);\n\tchar *g = strchr (u, ':');\n\tint id = 0;\n\tint retval = 0;\n\n\tif (g)\n\t\t*g++ = '\\0';\n\n\tif (user && *u) {\n\t\tif (sscanf(u, \"%d\", &id) == 1)\n\t\t\t*user = getpwuid((uid_t) id);\n\t\telse\n\t\t\t*user = getpwnam(u);\n\t\tif (*user == NULL)\n\t\t\tretval = -1;\n\t}\n\n\tif (group && g && *g) {\n\t\tif (sscanf(g, \"%d\", &id) == 1)\n\t\t\t*group = getgrgid((gid_t) id);\n\t\telse\n\t\t\t*group = getgrnam(g);\n\t\tif (*group == NULL)\n\t\t\tretval = -1;\n\t}\n\n\tfree(u);\n\treturn retval;\n}\n\nint main(int argc, char **argv)\n{\n\tint opt;\n\tuid_t uid = geteuid();\n\tgid_t gid = getgid();\n\tmode_t mode = 0;\n\tstruct passwd *pw = NULL;\n\tstruct group *gr = NULL;\n\tinode_t type = inode_unknown;\n\tint retval = EXIT_SUCCESS;\n\tbool trunc = false;\n\tbool chowner = false;\n\tbool symlinks = false;\n\tbool writable = false;\n\tbool selinux_on = false;\n\n\tapplet = basename_c(argv[0]);\n\twhile ((opt = getopt_long(argc, argv, getoptstring,\n\t\t    longopts, (int *) 0)) != -1)\n\t{\n\t\tswitch (opt) {\n\t\tcase 'D':\n\t\t\ttrunc = true;\n\t\t\t/* falls through */\n\t\tcase 'd':\n\t\t\ttype = inode_dir;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttrunc = true;\n\t\t\t/* falls through */\n\t\tcase 'f':\n\t\t\ttype = inode_file;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttype = inode_fifo;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (parse_mode(&mode, optarg) != 0)\n\t\t\t\teerrorx(\"%s: invalid mode `%s'\",\n\t\t\t\t    applet, optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tchowner = true;\n\t\t\tif (parse_owner(&pw, &gr, optarg) != 0)\n\t\t\t\teerrorx(\"%s: owner `%s' not found\",\n\t\t\t\t    applet, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n#ifndef O_PATH\n\t\t\tsymlinks = true;\n#endif\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twritable = true;\n\t\t\tbreak;\n\n\t\tcase_RC_COMMON_GETOPT\n\t\t}\n\t}\n\n\tif (optind >= argc)\n\t\tusage(EXIT_FAILURE);\n\n\tif (writable && type != inode_unknown)\n\t\teerrorx(\"%s: -W cannot be specified along with -d, -f or -p\", applet);\n\n\tif (pw) {\n\t\tuid = pw->pw_uid;\n\t\tgid = pw->pw_gid;\n\t}\n\tif (gr)\n\t\tgid = gr->gr_gid;\n\n\tif (selinux_util_open() == 1)\n\t\tselinux_on = true;\n\n\twhile (optind < argc) {\n\t\tif (writable)\n\t\t\texit(!is_writable(argv[optind]));\n\t\tif (do_check(argv[optind], uid, gid, mode, type, trunc, chowner,\n\t\t\t\t\tsymlinks, selinux_on))\n\t\t\tretval = EXIT_FAILURE;\n\t\toptind++;\n\t}\n\n\tif (selinux_on)\n\t\tselinux_util_close();\n\n\treturn retval;\n}\n"], "fixing_code": ["/*\n * checkpath.c\n * Checks for the existance of a file or directory and creates it\n * if necessary. It can also correct its ownership.\n */\n\n/*\n * Copyright (c) 2007-2015 The OpenRC Authors.\n * See the Authors file at the top-level directory of this distribution and\n * https://github.com/OpenRC/openrc/blob/master/AUTHORS\n *\n * This file is part of OpenRC. It is subject to the license terms in\n * the LICENSE file found in the top-level directory of this\n * distribution and at https://github.com/OpenRC/openrc/blob/master/LICENSE\n * This file may not be copied, modified, propagated, or distributed\n *    except according to the terms contained in the LICENSE file.\n */\n\n#define _GNU_SOURCE\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <grp.h>\n#include <libgen.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"einfo.h\"\n#include \"rc.h\"\n#include \"rc-misc.h\"\n#include \"rc-selinux.h\"\n#include \"_usage.h\"\n\ntypedef enum {\n\tinode_unknown = 0,\n\tinode_file = 1,\n\tinode_dir = 2,\n\tinode_fifo = 3,\n} inode_t;\n\nconst char *applet = NULL;\nconst char *extraopts =\"path1 [path2] [...]\";\nconst char *getoptstring = \"dDfFpm:o:sW\" getoptstring_COMMON;\nconst struct option longopts[] = {\n\t{ \"directory\",          0, NULL, 'd'},\n\t{ \"directory-truncate\", 0, NULL, 'D'},\n\t{ \"file\",               0, NULL, 'f'},\n\t{ \"file-truncate\",      0, NULL, 'F'},\n\t{ \"pipe\",               0, NULL, 'p'},\n\t{ \"mode\",               1, NULL, 'm'},\n\t{ \"owner\",              1, NULL, 'o'},\n\t{ \"symlinks\",           0, NULL, 's'},\n\t{ \"writable\",           0, NULL, 'W'},\n\tlongopts_COMMON\n};\nconst char * const longopts_help[] = {\n\t\"Create a directory if not exists\",\n\t\"Create/empty directory\",\n\t\"Create a file if not exists\",\n\t\"Truncate file\",\n\t\"Create a named pipe (FIFO) if not exists\",\n\t\"Mode to check\",\n\t\"Owner to check (user:group)\",\n\t\"follow symbolic links (irrelivent on linux)\",\n\t\"Check whether the path is writable or not\",\n\tlongopts_help_COMMON\n};\nconst char *usagestring = NULL;\n\nstatic int get_dirfd(char *path, bool symlinks)\n{\n\tchar *ch;\n\tchar *item;\n\tchar *linkpath = NULL;\n\tchar *path_dupe;\n\tchar *str;\n\tint components = 0;\n\tint dirfd;\n\tint flags = 0;\n\tint new_dirfd;\n\tstruct stat st;\n\tssize_t linksize;\n\n\tif (!path || *path != '/')\n\t\teerrorx(\"%s: empty or relative path\", applet);\n\tdirfd = openat(dirfd, \"/\", O_RDONLY);\n\tif (dirfd == -1)\n\t\teerrorx(\"%s: unable to open the root directory: %s\",\n\t\t\t\tapplet, strerror(errno));\n\tch = path;\n\twhile (*ch) {\n\t\tif (*ch == '/')\n\t\t\tcomponents++;\n\t\tch++;\n\t}\n\tpath_dupe = xstrdup(path);\n\titem = strtok(path_dupe, \"/\");\n#ifdef O_PATH\n\tflags |= O_PATH;\n#endif\n\tif (!symlinks)\n\t\tflags |= O_NOFOLLOW;\n\tflags |= O_RDONLY;\n\twhile (dirfd > 0 && item && components > 1) {\n\t\tstr = xstrdup(linkpath ? linkpath : item);\n\t\tnew_dirfd = openat(dirfd, str, flags);\n\t\tif (new_dirfd == -1)\n\t\t\teerrorx(\"%s: %s: could not open %s: %s\", applet, path, str,\n\t\t\t\t\tstrerror(errno));\n\t\tif (fstat(new_dirfd, &st) == -1)\n\t\t\teerrorx(\"%s: %s: unable to stat %s: %s\", applet, path, item,\n\t\t\t\t\tstrerror(errno));\n\t\tif (S_ISLNK(st.st_mode) ) {\n\t\t\tif (st.st_uid != 0)\n\t\t\t\teerrorx(\"%s: %s: symbolic link %s not owned by root\",\n\t\t\t\t\t\tapplet, path, str);\n\t\t\tlinksize = st.st_size+1;\n\t\t\tif (linkpath)\n\t\t\t\tfree(linkpath);\n\t\t\tlinkpath = xmalloc(linksize);\n\t\t\tmemset(linkpath, 0, linksize);\n\t\t\tif (readlinkat(new_dirfd, \"\", linkpath, linksize) != st.st_size)\n\t\t\t\teerrorx(\"%s: symbolic link destination changed\", applet);\n\t\t\t/*\n\t\t\t * now follow the symlink.\n\t\t\t */\n\t\t\tclose(new_dirfd);\n\t\t} else {\n\t\t\tclose(dirfd);\n\t\t\tdirfd = new_dirfd;\n\t\t\tfree(linkpath);\n\t\t\tlinkpath = NULL;\n\t\t}\n\t\titem = strtok(NULL, \"/\");\n\t\tcomponents--;\n\t}\n\tfree(path_dupe);\n\tfree(linkpath);\n\treturn dirfd;\n}\n\nstatic char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path));\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;\n\t\tch2++;\n\t\tif (!*(ch-1))\n\t\t\tbreak;\n\t\twhile (*(ch - 1) == '/' && *ch == '/')\n\t\t\tch++;\n\t}\n\t/* get rid of trailing / characters */\n\twhile ((ch = strrchr(str, '/'))) {\n\t\tif (ch == str)\n\t\t\tbreak;\n\t\tif (!*(ch+1))\n\t\t\t*ch = 0;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn str;\n}\n\nstatic int do_check(char *path, uid_t uid, gid_t gid, mode_t mode,\n\tinode_t type, bool trunc, bool chowner, bool symlinks, bool selinux_on)\n{\n\tstruct stat st;\n\tchar *name = NULL;\n\tint dirfd;\n\tint fd;\n\tint flags;\n\tint r;\n\tint readfd;\n\tint readflags;\n\tint u;\n\n\tmemset(&st, 0, sizeof(st));\n\tflags = O_CREAT|O_NDELAY|O_WRONLY|O_NOCTTY;\n\treadflags = O_NDELAY|O_NOCTTY|O_RDONLY;\n#ifdef O_CLOEXEC\n\tflags |= O_CLOEXEC;\n\treadflags |= O_CLOEXEC;\n#endif\n#ifdef O_NOFOLLOW\n\tflags |= O_NOFOLLOW;\n\treadflags |= O_NOFOLLOW;\n#endif\n\tif (trunc)\n\t\tflags |= O_TRUNC;\n\txasprintf(&name, \"%s\", basename_c(path));\n\tdirfd = get_dirfd(path, symlinks);\n\treadfd = openat(dirfd, name, readflags);\n\tif (readfd == -1 || (type == inode_file && trunc)) {\n\t\tif (type == inode_file) {\n\t\t\teinfo(\"%s: creating file\", path);\n\t\t\tif (!mode) /* 664 */\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH;\n\t\t\tu = umask(0);\n\t\t\tfd = openat(dirfd, name, flags, mode);\n\t\t\tumask(u);\n\t\t\tif (fd == -1) {\n\t\t\t\teerror(\"%s: open: %s\", applet, strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (readfd != -1 && trunc)\n\t\t\t\tclose(readfd);\n\t\t\treadfd = fd;\n\t\t} else if (type == inode_dir) {\n\t\t\teinfo(\"%s: creating directory\", path);\n\t\t\tif (!mode) /* 775 */\n\t\t\t\tmode = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH;\n\t\t\tu = umask(0);\n\t\t\t/* We do not recursively create parents */\n\t\t\tr = mkdirat(dirfd, name, mode);\n\t\t\tumask(u);\n\t\t\tif (r == -1 && errno != EEXIST) {\n\t\t\t\teerror(\"%s: mkdirat: %s\", applet,\n\t\t\t\t    strerror (errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treadfd = openat(dirfd, name, readflags);\n\t\t\tif (readfd == -1) {\n\t\t\t\teerror(\"%s: unable to open directory: %s\", applet,\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (type == inode_fifo) {\n\t\t\teinfo(\"%s: creating fifo\", path);\n\t\t\tif (!mode) /* 600 */\n\t\t\t\tmode = S_IRUSR | S_IWUSR;\n\t\t\tu = umask(0);\n\t\t\tr = mkfifo(path, mode);\n\t\t\tumask(u);\n\t\t\tif (r == -1 && errno != EEXIST) {\n\t\t\t\teerror(\"%s: mkfifo: %s\", applet,\n\t\t\t\t    strerror (errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treadfd = openat(dirfd, name, readflags);\n\t\t\tif (readfd == -1) {\n\t\t\t\teerror(\"%s: unable to open fifo: %s\", applet,\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (fstat(readfd, &st) != -1) {\n\t\tif (type != inode_dir && S_ISDIR(st.st_mode)) {\n\t\t\teerror(\"%s: is a directory\", path);\n\t\t\tclose(readfd);\n\t\t\treturn 1;\n\t\t}\n\t\tif (type != inode_file && S_ISREG(st.st_mode)) {\n\t\t\teerror(\"%s: is a file\", path);\n\t\t\tclose(readfd);\n\t\t\treturn 1;\n\t\t}\n\t\tif (type != inode_fifo && S_ISFIFO(st.st_mode)) {\n\t\t\teerror(\"%s: is a fifo\", path);\n\t\t\tclose(readfd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (mode && (st.st_mode & 0777) != mode) {\n\t\t\tif ((type != inode_dir) && (st.st_nlink > 1)) {\n\t\t\t\teerror(\"%s: chmod: Too many hard links to %s\", applet, path);\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\teerror(\"%s: chmod: %s %s\", applet, path, \" is a symbolic link\");\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\teinfo(\"%s: correcting mode\", path);\n\t\t\tif (fchmod(readfd, mode)) {\n\t\t\t\teerror(\"%s: chmod: %s\", applet, strerror(errno));\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (chowner && (st.st_uid != uid || st.st_gid != gid)) {\n\t\t\tif ((type != inode_dir) && (st.st_nlink > 1)) {\n\t\t\t\teerror(\"%s: chown: %s %s\", applet, \"Too many hard links to\", path);\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\teerror(\"%s: chown: %s %s\", applet, path, \" is a symbolic link\");\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\teinfo(\"%s: correcting owner\", path);\n\t\t\tif (fchown(readfd, uid, gid)) {\n\t\t\t\teerror(\"%s: chown: %s\", applet, strerror(errno));\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (selinux_on)\n\t\t\tselinux_util_label(path);\n\t} else {\n\t\teerror(\"fstat: %s: %s\", path, strerror(errno));\n\t\tclose(readfd);\n\t\treturn -1;\n\t}\n\tclose(readfd);\n\n\treturn 0;\n}\n\nstatic int parse_owner(struct passwd **user, struct group **group,\n\tconst char *owner)\n{\n\tchar *u = xstrdup (owner);\n\tchar *g = strchr (u, ':');\n\tint id = 0;\n\tint retval = 0;\n\n\tif (g)\n\t\t*g++ = '\\0';\n\n\tif (user && *u) {\n\t\tif (sscanf(u, \"%d\", &id) == 1)\n\t\t\t*user = getpwuid((uid_t) id);\n\t\telse\n\t\t\t*user = getpwnam(u);\n\t\tif (*user == NULL)\n\t\t\tretval = -1;\n\t}\n\n\tif (group && g && *g) {\n\t\tif (sscanf(g, \"%d\", &id) == 1)\n\t\t\t*group = getgrgid((gid_t) id);\n\t\telse\n\t\t\t*group = getgrnam(g);\n\t\tif (*group == NULL)\n\t\t\tretval = -1;\n\t}\n\n\tfree(u);\n\treturn retval;\n}\n\nint main(int argc, char **argv)\n{\n\tint opt;\n\tuid_t uid = geteuid();\n\tgid_t gid = getgid();\n\tmode_t mode = 0;\n\tstruct passwd *pw = NULL;\n\tstruct group *gr = NULL;\n\tinode_t type = inode_unknown;\n\tint retval = EXIT_SUCCESS;\n\tbool trunc = false;\n\tbool chowner = false;\n\tbool symlinks = false;\n\tbool writable = false;\n\tbool selinux_on = false;\n\tchar *path = NULL;\n\n\tapplet = basename_c(argv[0]);\n\twhile ((opt = getopt_long(argc, argv, getoptstring,\n\t\t    longopts, (int *) 0)) != -1)\n\t{\n\t\tswitch (opt) {\n\t\tcase 'D':\n\t\t\ttrunc = true;\n\t\t\t/* falls through */\n\t\tcase 'd':\n\t\t\ttype = inode_dir;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttrunc = true;\n\t\t\t/* falls through */\n\t\tcase 'f':\n\t\t\ttype = inode_file;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttype = inode_fifo;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (parse_mode(&mode, optarg) != 0)\n\t\t\t\teerrorx(\"%s: invalid mode `%s'\",\n\t\t\t\t    applet, optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tchowner = true;\n\t\t\tif (parse_owner(&pw, &gr, optarg) != 0)\n\t\t\t\teerrorx(\"%s: owner `%s' not found\",\n\t\t\t\t    applet, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n#ifndef O_PATH\n\t\t\tsymlinks = true;\n#endif\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twritable = true;\n\t\t\tbreak;\n\n\t\tcase_RC_COMMON_GETOPT\n\t\t}\n\t}\n\n\tif (optind >= argc)\n\t\tusage(EXIT_FAILURE);\n\n\tif (writable && type != inode_unknown)\n\t\teerrorx(\"%s: -W cannot be specified along with -d, -f or -p\", applet);\n\n\tif (pw) {\n\t\tuid = pw->pw_uid;\n\t\tgid = pw->pw_gid;\n\t}\n\tif (gr)\n\t\tgid = gr->gr_gid;\n\n\tif (selinux_util_open() == 1)\n\t\tselinux_on = true;\n\n\twhile (optind < argc) {\n\t\tpath = clean_path(argv[optind]);\n\t\tif (writable)\n\t\t\texit(!is_writable(path));\n\t\tif (do_check(path, uid, gid, mode, type, trunc, chowner,\n\t\t\t\t\tsymlinks, selinux_on))\n\t\t\tretval = EXIT_FAILURE;\n\t\toptind++;\n\t\tfree(path);\n\t}\n\n\tif (selinux_on)\n\t\tselinux_util_close();\n\n\treturn retval;\n}\n"], "filenames": ["src/rc/checkpath.c"], "buggy_code_start_loc": [96], "buggy_code_end_loc": [415], "fixing_code_start_loc": [96], "fixing_code_end_loc": [445], "type": "NVD-CWE-Other", "message": "checkpath in OpenRC before 0.44.7 uses the direct output of strlen() to allocate strings, which does not account for the '\\0' byte at the end of the string. This results in memory corruption. CVE-2021-42341 was introduced in git commit 63db2d99e730547339d1bdd28e8437999c380cae, which was introduced as part of OpenRC 0.44.0 development.", "other": {"cve": {"id": "CVE-2021-42341", "sourceIdentifier": "cve@mitre.org", "published": "2021-10-14T05:15:07.787", "lastModified": "2021-10-20T19:03:41.107", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "checkpath in OpenRC before 0.44.7 uses the direct output of strlen() to allocate strings, which does not account for the '\\0' byte at the end of the string. This results in memory corruption. CVE-2021-42341 was introduced in git commit 63db2d99e730547339d1bdd28e8437999c380cae, which was introduced as part of OpenRC 0.44.0 development."}, {"lang": "es", "value": "checkpath en OpenRC versiones anteriores a 0.44.7, usa la salida directa de la funci\u00f3n strlen() para asignar cadenas, que no tiene en cuenta el byte \"\\0\" al final de la cadena. Esto resulta en una corrupci\u00f3n de memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openrc_project:openrc:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.44.0", "versionEndExcluding": "0.44.7", "matchCriteriaId": "E580D8E0-D048-44A9-A0CF-BE5EF3147AEF"}]}]}], "references": [{"url": "https://bugs.gentoo.org/816900", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenRC/openrc/commit/63db2d99e730547339d1bdd28e8437999c380cae", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenRC/openrc/commit/bb8334104baf4d5a4a442a8647fb9204738f2204", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenRC/openrc/issues/418", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenRC/openrc/issues/459", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenRC/openrc/pull/462", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenRC/openrc/commit/63db2d99e730547339d1bdd28e8437999c380cae"}}