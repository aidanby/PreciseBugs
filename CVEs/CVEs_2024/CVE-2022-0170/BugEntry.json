{"buggy_code": ["import express from 'express'\nimport { body, param, query } from 'express-validator'\nimport { MUserAccountUrl } from '@server/types/models'\nimport { UserRight } from '../../../../shared'\nimport { HttpStatusCode } from '../../../../shared/models/http/http-error-codes'\nimport { exists, isBooleanValid, isIdValid, toBooleanOrNull } from '../../../helpers/custom-validators/misc'\nimport { isValidVideoCommentText } from '../../../helpers/custom-validators/video-comments'\nimport { logger } from '../../../helpers/logger'\nimport { AcceptResult, isLocalVideoCommentReplyAccepted, isLocalVideoThreadAccepted } from '../../../lib/moderation'\nimport { Hooks } from '../../../lib/plugins/hooks'\nimport { MCommentOwnerVideoReply, MVideo, MVideoFullLight } from '../../../types/models/video'\nimport { areValidationErrors, doesVideoCommentExist, doesVideoCommentThreadExist, doesVideoExist, isValidVideoIdParam } from '../shared'\n\nconst listVideoCommentsValidator = [\n  query('isLocal')\n  .optional()\n  .customSanitizer(toBooleanOrNull)\n  .custom(isBooleanValid)\n  .withMessage('Should have a valid is local boolean'),\n\n  query('search')\n    .optional()\n    .custom(exists).withMessage('Should have a valid search'),\n\n  query('searchAccount')\n    .optional()\n    .custom(exists).withMessage('Should have a valid account search'),\n\n  query('searchVideo')\n    .optional()\n    .custom(exists).withMessage('Should have a valid video search'),\n\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoCommentsValidator parameters.', { parameters: req.query })\n\n    if (areValidationErrors(req, res)) return\n\n    return next()\n  }\n]\n\nconst listVideoCommentThreadsValidator = [\n  isValidVideoIdParam('videoId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoCommentThreads parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'only-video')) return\n\n    return next()\n  }\n]\n\nconst listVideoThreadCommentsValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('threadId')\n    .custom(isIdValid).not().isEmpty().withMessage('Should have a valid threadId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoThreadComments parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'only-video')) return\n    if (!await doesVideoCommentThreadExist(req.params.threadId, res.locals.onlyVideo, res)) return\n\n    return next()\n  }\n]\n\nconst addVideoCommentThreadValidator = [\n  isValidVideoIdParam('videoId'),\n\n  body('text')\n    .custom(isValidVideoCommentText).not().isEmpty().withMessage('Should have a valid comment text'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking addVideoCommentThread parameters.', { parameters: req.params, body: req.body })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!isVideoCommentsEnabled(res.locals.videoAll, res)) return\n    if (!await isVideoCommentAccepted(req, res, res.locals.videoAll, false)) return\n\n    return next()\n  }\n]\n\nconst addVideoCommentReplyValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId').custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  body('text').custom(isValidVideoCommentText).not().isEmpty().withMessage('Should have a valid comment text'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking addVideoCommentReply parameters.', { parameters: req.params, body: req.body })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!isVideoCommentsEnabled(res.locals.videoAll, res)) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoAll, res)) return\n    if (!await isVideoCommentAccepted(req, res, res.locals.videoAll, true)) return\n\n    return next()\n  }\n]\n\nconst videoCommentGetValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId')\n    .custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videoCommentGetValidator parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'id')) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoId, res)) return\n\n    return next()\n  }\n]\n\nconst removeVideoCommentValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId').custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking removeVideoCommentValidator parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoAll, res)) return\n\n    // Check if the user who did the request is able to delete the video\n    if (!checkUserCanDeleteVideoComment(res.locals.oauth.token.User, res.locals.videoCommentFull, res)) return\n\n    return next()\n  }\n]\n\n// ---------------------------------------------------------------------------\n\nexport {\n  listVideoCommentThreadsValidator,\n  listVideoThreadCommentsValidator,\n  addVideoCommentThreadValidator,\n  listVideoCommentsValidator,\n  addVideoCommentReplyValidator,\n  videoCommentGetValidator,\n  removeVideoCommentValidator\n}\n\n// ---------------------------------------------------------------------------\n\nfunction isVideoCommentsEnabled (video: MVideo, res: express.Response) {\n  if (video.commentsEnabled !== true) {\n    res.fail({\n      status: HttpStatusCode.CONFLICT_409,\n      message: 'Video comments are disabled for this video.'\n    })\n    return false\n  }\n\n  return true\n}\n\nfunction checkUserCanDeleteVideoComment (user: MUserAccountUrl, videoComment: MCommentOwnerVideoReply, res: express.Response) {\n  if (videoComment.isDeleted()) {\n    res.fail({\n      status: HttpStatusCode.CONFLICT_409,\n      message: 'This comment is already deleted'\n    })\n    return false\n  }\n\n  const userAccount = user.Account\n\n  if (\n    user.hasRight(UserRight.REMOVE_ANY_VIDEO_COMMENT) === false && // Not a moderator\n    videoComment.accountId !== userAccount.id && // Not the comment owner\n    videoComment.Video.VideoChannel.accountId !== userAccount.id // Not the video owner\n  ) {\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: 'Cannot remove video comment of another user'\n    })\n    return false\n  }\n\n  return true\n}\n\nasync function isVideoCommentAccepted (req: express.Request, res: express.Response, video: MVideoFullLight, isReply: boolean) {\n  const acceptParameters = {\n    video,\n    commentBody: req.body,\n    user: res.locals.oauth.token.User\n  }\n\n  let acceptedResult: AcceptResult\n\n  if (isReply) {\n    const acceptReplyParameters = Object.assign(acceptParameters, { parentComment: res.locals.videoCommentFull })\n\n    acceptedResult = await Hooks.wrapFun(\n      isLocalVideoCommentReplyAccepted,\n      acceptReplyParameters,\n      'filter:api.video-comment-reply.create.accept.result'\n    )\n  } else {\n    acceptedResult = await Hooks.wrapFun(\n      isLocalVideoThreadAccepted,\n      acceptParameters,\n      'filter:api.video-thread.create.accept.result'\n    )\n  }\n\n  if (!acceptedResult || acceptedResult.accepted !== true) {\n    logger.info('Refused local comment.', { acceptedResult, acceptParameters })\n\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: acceptedResult?.errorMessage || 'Refused local comment'\n    })\n    return false\n  }\n\n  return true\n}\n", "/* eslint-disable @typescript-eslint/no-unused-expressions,@typescript-eslint/require-await */\n\nimport 'mocha'\nimport * as chai from 'chai'\nimport {\n  checkBadCountPagination,\n  checkBadSortPagination,\n  checkBadStartPagination,\n  cleanupTests,\n  createSingleServer,\n  makeDeleteRequest,\n  makeGetRequest,\n  makePostBodyRequest,\n  PeerTubeServer,\n  setAccessTokensToServers\n} from '@shared/extra-utils'\nimport { HttpStatusCode, VideoCreateResult } from '@shared/models'\n\nconst expect = chai.expect\n\ndescribe('Test video comments API validator', function () {\n  let pathThread: string\n  let pathComment: string\n  let server: PeerTubeServer\n  let video: VideoCreateResult\n  let userAccessToken: string\n  let userAccessToken2: string\n  let commentId: number\n\n  // ---------------------------------------------------------------\n\n  before(async function () {\n    this.timeout(30000)\n\n    server = await createSingleServer(1)\n\n    await setAccessTokensToServers([ server ])\n\n    {\n      video = await server.videos.upload({ attributes: {} })\n      pathThread = '/api/v1/videos/' + video.uuid + '/comment-threads'\n    }\n\n    {\n      const created = await server.comments.createThread({ videoId: video.uuid, text: 'coucou' })\n      commentId = created.id\n      pathComment = '/api/v1/videos/' + video.uuid + '/comments/' + commentId\n    }\n\n    {\n      const user = { username: 'user1', password: 'my super password' }\n      await server.users.create({ username: user.username, password: user.password })\n      userAccessToken = await server.login.getAccessToken(user)\n    }\n\n    {\n      const user = { username: 'user2', password: 'my super password' }\n      await server.users.create({ username: user.username, password: user.password })\n      userAccessToken2 = await server.login.getAccessToken(user)\n    }\n  })\n\n  describe('When listing video comment threads', function () {\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads',\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n  })\n\n  describe('When listing comments of a thread', function () {\n    it('Should fail with an incorrect video', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads/' + commentId,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with an incorrect thread id', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + video.shortUUID + '/comment-threads/156',\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should success with the correct params', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + video.shortUUID + '/comment-threads/' + commentId,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When adding a video thread', function () {\n\n    it('Should fail with a non authenticated user', async function () {\n      const fields = {\n        text: 'text'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: 'none',\n        fields,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a short comment', async function () {\n      const fields = {\n        text: ''\n      }\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long comment', async function () {\n      const fields = {\n        text: 'h'.repeat(10001)\n      }\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads'\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When adding a comment to a thread', function () {\n    it('Should fail with a non authenticated user', async function () {\n      const fields = {\n        text: 'text'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathComment,\n        token: 'none',\n        fields,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a short comment', async function () {\n      const fields = {\n        text: ''\n      }\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long comment', async function () {\n      const fields = {\n        text: 'h'.repeat(10001)\n      }\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comments/' + commentId\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with an incorrect comment', async function () {\n      const path = '/api/v1/videos/' + video.uuid + '/comments/124'\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathComment,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When removing video comments', function () {\n    it('Should fail with a non authenticated user', async function () {\n      await makeDeleteRequest({ url: server.url, path: pathComment, token: 'none', expectedStatus: HttpStatusCode.UNAUTHORIZED_401 })\n    })\n\n    it('Should fail with another user', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: pathComment,\n        token: userAccessToken,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comments/' + commentId\n      await makeDeleteRequest({ url: server.url, path, token: server.accessToken, expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Should fail with an incorrect comment', async function () {\n      const path = '/api/v1/videos/' + video.uuid + '/comments/124'\n      await makeDeleteRequest({ url: server.url, path, token: server.accessToken, expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Should succeed with the same user', async function () {\n      let commentToDelete: number\n\n      {\n        const created = await server.comments.createThread({ videoId: video.uuid, token: userAccessToken, text: 'hello' })\n        commentToDelete = created.id\n      }\n\n      const path = '/api/v1/videos/' + video.uuid + '/comments/' + commentToDelete\n\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken2, expectedStatus: HttpStatusCode.FORBIDDEN_403 })\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken, expectedStatus: HttpStatusCode.NO_CONTENT_204 })\n    })\n\n    it('Should succeed with the owner of the video', async function () {\n      let commentToDelete: number\n      let anotherVideoUUID: string\n\n      {\n        const { uuid } = await server.videos.upload({ token: userAccessToken, attributes: { name: 'video' } })\n        anotherVideoUUID = uuid\n      }\n\n      {\n        const created = await server.comments.createThread({ videoId: anotherVideoUUID, text: 'hello' })\n        commentToDelete = created.id\n      }\n\n      const path = '/api/v1/videos/' + anotherVideoUUID + '/comments/' + commentToDelete\n\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken2, expectedStatus: HttpStatusCode.FORBIDDEN_403 })\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken, expectedStatus: HttpStatusCode.NO_CONTENT_204 })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: pathComment,\n        token: server.accessToken,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  describe('When a video has comments disabled', function () {\n    before(async function () {\n      video = await server.videos.upload({ attributes: { commentsEnabled: false } })\n      pathThread = '/api/v1/videos/' + video.uuid + '/comment-threads'\n    })\n\n    it('Should return an empty thread list', async function () {\n      const res = await makeGetRequest({\n        url: server.url,\n        path: pathThread,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n      expect(res.body.total).to.equal(0)\n      expect(res.body.data).to.have.lengthOf(0)\n    })\n\n    it('Should return an thread comments list')\n\n    it('Should return conflict on thread add', async function () {\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.CONFLICT_409\n      })\n    })\n\n    it('Should return conflict on comment thread add')\n  })\n\n  describe('When listing admin comments threads', function () {\n    const path = '/api/v1/videos/comments'\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a non authenticated user', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with a non admin user', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        token: userAccessToken,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should succeed with the correct params', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        query: {\n          isLocal: false,\n          search: 'toto',\n          searchAccount: 'toto',\n          searchVideo: 'toto'\n        },\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  after(async function () {\n    await cleanupTests([ server ])\n  })\n})\n"], "fixing_code": ["import express from 'express'\nimport { body, param, query } from 'express-validator'\nimport { MUserAccountUrl } from '@server/types/models'\nimport { UserRight } from '../../../../shared'\nimport { HttpStatusCode } from '../../../../shared/models/http/http-error-codes'\nimport { exists, isBooleanValid, isIdValid, toBooleanOrNull } from '../../../helpers/custom-validators/misc'\nimport { isValidVideoCommentText } from '../../../helpers/custom-validators/video-comments'\nimport { logger } from '../../../helpers/logger'\nimport { AcceptResult, isLocalVideoCommentReplyAccepted, isLocalVideoThreadAccepted } from '../../../lib/moderation'\nimport { Hooks } from '../../../lib/plugins/hooks'\nimport { MCommentOwnerVideoReply, MVideo, MVideoFullLight } from '../../../types/models/video'\nimport {\n  areValidationErrors,\n  checkCanSeeVideoIfPrivate,\n  doesVideoCommentExist,\n  doesVideoCommentThreadExist,\n  doesVideoExist,\n  isValidVideoIdParam\n} from '../shared'\n\nconst listVideoCommentsValidator = [\n  query('isLocal')\n  .optional()\n  .customSanitizer(toBooleanOrNull)\n  .custom(isBooleanValid)\n  .withMessage('Should have a valid is local boolean'),\n\n  query('search')\n    .optional()\n    .custom(exists).withMessage('Should have a valid search'),\n\n  query('searchAccount')\n    .optional()\n    .custom(exists).withMessage('Should have a valid account search'),\n\n  query('searchVideo')\n    .optional()\n    .custom(exists).withMessage('Should have a valid video search'),\n\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoCommentsValidator parameters.', { parameters: req.query })\n\n    if (areValidationErrors(req, res)) return\n\n    return next()\n  }\n]\n\nconst listVideoCommentThreadsValidator = [\n  isValidVideoIdParam('videoId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoCommentThreads parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'only-video')) return\n\n    if (!await checkCanSeeVideoIfPrivate(req, res, res.locals.onlyVideo)) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'Cannot list comments of private/internal/blocklisted video'\n      })\n    }\n\n    return next()\n  }\n]\n\nconst listVideoThreadCommentsValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('threadId')\n    .custom(isIdValid).not().isEmpty().withMessage('Should have a valid threadId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoThreadComments parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'only-video')) return\n    if (!await doesVideoCommentThreadExist(req.params.threadId, res.locals.onlyVideo, res)) return\n\n    if (!await checkCanSeeVideoIfPrivate(req, res, res.locals.onlyVideo)) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'Cannot list threads of private/internal/blocklisted video'\n      })\n    }\n\n    return next()\n  }\n]\n\nconst addVideoCommentThreadValidator = [\n  isValidVideoIdParam('videoId'),\n\n  body('text')\n    .custom(isValidVideoCommentText).not().isEmpty().withMessage('Should have a valid comment text'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking addVideoCommentThread parameters.', { parameters: req.params, body: req.body })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!isVideoCommentsEnabled(res.locals.videoAll, res)) return\n    if (!await isVideoCommentAccepted(req, res, res.locals.videoAll, false)) return\n\n    return next()\n  }\n]\n\nconst addVideoCommentReplyValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId').custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  body('text').custom(isValidVideoCommentText).not().isEmpty().withMessage('Should have a valid comment text'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking addVideoCommentReply parameters.', { parameters: req.params, body: req.body })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!isVideoCommentsEnabled(res.locals.videoAll, res)) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoAll, res)) return\n    if (!await isVideoCommentAccepted(req, res, res.locals.videoAll, true)) return\n\n    return next()\n  }\n]\n\nconst videoCommentGetValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId')\n    .custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videoCommentGetValidator parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'id')) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoId, res)) return\n\n    return next()\n  }\n]\n\nconst removeVideoCommentValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId').custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking removeVideoCommentValidator parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoAll, res)) return\n\n    // Check if the user who did the request is able to delete the video\n    if (!checkUserCanDeleteVideoComment(res.locals.oauth.token.User, res.locals.videoCommentFull, res)) return\n\n    return next()\n  }\n]\n\n// ---------------------------------------------------------------------------\n\nexport {\n  listVideoCommentThreadsValidator,\n  listVideoThreadCommentsValidator,\n  addVideoCommentThreadValidator,\n  listVideoCommentsValidator,\n  addVideoCommentReplyValidator,\n  videoCommentGetValidator,\n  removeVideoCommentValidator\n}\n\n// ---------------------------------------------------------------------------\n\nfunction isVideoCommentsEnabled (video: MVideo, res: express.Response) {\n  if (video.commentsEnabled !== true) {\n    res.fail({\n      status: HttpStatusCode.CONFLICT_409,\n      message: 'Video comments are disabled for this video.'\n    })\n    return false\n  }\n\n  return true\n}\n\nfunction checkUserCanDeleteVideoComment (user: MUserAccountUrl, videoComment: MCommentOwnerVideoReply, res: express.Response) {\n  if (videoComment.isDeleted()) {\n    res.fail({\n      status: HttpStatusCode.CONFLICT_409,\n      message: 'This comment is already deleted'\n    })\n    return false\n  }\n\n  const userAccount = user.Account\n\n  if (\n    user.hasRight(UserRight.REMOVE_ANY_VIDEO_COMMENT) === false && // Not a moderator\n    videoComment.accountId !== userAccount.id && // Not the comment owner\n    videoComment.Video.VideoChannel.accountId !== userAccount.id // Not the video owner\n  ) {\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: 'Cannot remove video comment of another user'\n    })\n    return false\n  }\n\n  return true\n}\n\nasync function isVideoCommentAccepted (req: express.Request, res: express.Response, video: MVideoFullLight, isReply: boolean) {\n  const acceptParameters = {\n    video,\n    commentBody: req.body,\n    user: res.locals.oauth.token.User\n  }\n\n  let acceptedResult: AcceptResult\n\n  if (isReply) {\n    const acceptReplyParameters = Object.assign(acceptParameters, { parentComment: res.locals.videoCommentFull })\n\n    acceptedResult = await Hooks.wrapFun(\n      isLocalVideoCommentReplyAccepted,\n      acceptReplyParameters,\n      'filter:api.video-comment-reply.create.accept.result'\n    )\n  } else {\n    acceptedResult = await Hooks.wrapFun(\n      isLocalVideoThreadAccepted,\n      acceptParameters,\n      'filter:api.video-thread.create.accept.result'\n    )\n  }\n\n  if (!acceptedResult || acceptedResult.accepted !== true) {\n    logger.info('Refused local comment.', { acceptedResult, acceptParameters })\n\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: acceptedResult?.errorMessage || 'Refused local comment'\n    })\n    return false\n  }\n\n  return true\n}\n", "/* eslint-disable @typescript-eslint/no-unused-expressions,@typescript-eslint/require-await */\n\nimport 'mocha'\nimport * as chai from 'chai'\nimport {\n  checkBadCountPagination,\n  checkBadSortPagination,\n  checkBadStartPagination,\n  cleanupTests,\n  createSingleServer,\n  makeDeleteRequest,\n  makeGetRequest,\n  makePostBodyRequest,\n  PeerTubeServer,\n  setAccessTokensToServers\n} from '@shared/extra-utils'\nimport { HttpStatusCode, VideoCreateResult, VideoPrivacy } from '@shared/models'\n\nconst expect = chai.expect\n\ndescribe('Test video comments API validator', function () {\n  let pathThread: string\n  let pathComment: string\n  let server: PeerTubeServer\n  let video: VideoCreateResult\n  let userAccessToken: string\n  let userAccessToken2: string\n  let commentId: number\n  let privateCommentId: number\n  let privateVideo: VideoCreateResult\n\n  // ---------------------------------------------------------------\n\n  before(async function () {\n    this.timeout(30000)\n\n    server = await createSingleServer(1)\n\n    await setAccessTokensToServers([ server ])\n\n    {\n      video = await server.videos.upload({ attributes: {} })\n      pathThread = '/api/v1/videos/' + video.uuid + '/comment-threads'\n    }\n\n    {\n      privateVideo = await server.videos.upload({ attributes: { privacy: VideoPrivacy.PRIVATE } })\n    }\n\n    {\n      const created = await server.comments.createThread({ videoId: video.uuid, text: 'coucou' })\n      commentId = created.id\n      pathComment = '/api/v1/videos/' + video.uuid + '/comments/' + commentId\n    }\n\n    {\n      const created = await server.comments.createThread({ videoId: privateVideo.uuid, text: 'coucou' })\n      privateCommentId = created.id\n    }\n\n    {\n      const user = { username: 'user1', password: 'my super password' }\n      await server.users.create({ username: user.username, password: user.password })\n      userAccessToken = await server.login.getAccessToken(user)\n    }\n\n    {\n      const user = { username: 'user2', password: 'my super password' }\n      await server.users.create({ username: user.username, password: user.password })\n      userAccessToken2 = await server.login.getAccessToken(user)\n    }\n  })\n\n  describe('When listing video comment threads', function () {\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads',\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a private video without token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads',\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with another user token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: userAccessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads',\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should succeed with the correct params', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: server.accessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads',\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When listing comments of a thread', function () {\n    it('Should fail with an incorrect video', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads/' + commentId,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with an incorrect thread id', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + video.shortUUID + '/comment-threads/156',\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a private video without token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads/' + privateCommentId,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with another user token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: userAccessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads/' + privateCommentId,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should success with the correct params', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: server.accessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads/' + privateCommentId,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + video.shortUUID + '/comment-threads/' + commentId,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When adding a video thread', function () {\n\n    it('Should fail with a non authenticated user', async function () {\n      const fields = {\n        text: 'text'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: 'none',\n        fields,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a short comment', async function () {\n      const fields = {\n        text: ''\n      }\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long comment', async function () {\n      const fields = {\n        text: 'h'.repeat(10001)\n      }\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads'\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When adding a comment to a thread', function () {\n    it('Should fail with a non authenticated user', async function () {\n      const fields = {\n        text: 'text'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathComment,\n        token: 'none',\n        fields,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a short comment', async function () {\n      const fields = {\n        text: ''\n      }\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long comment', async function () {\n      const fields = {\n        text: 'h'.repeat(10001)\n      }\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comments/' + commentId\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with an incorrect comment', async function () {\n      const path = '/api/v1/videos/' + video.uuid + '/comments/124'\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathComment,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When removing video comments', function () {\n    it('Should fail with a non authenticated user', async function () {\n      await makeDeleteRequest({ url: server.url, path: pathComment, token: 'none', expectedStatus: HttpStatusCode.UNAUTHORIZED_401 })\n    })\n\n    it('Should fail with another user', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: pathComment,\n        token: userAccessToken,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comments/' + commentId\n      await makeDeleteRequest({ url: server.url, path, token: server.accessToken, expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Should fail with an incorrect comment', async function () {\n      const path = '/api/v1/videos/' + video.uuid + '/comments/124'\n      await makeDeleteRequest({ url: server.url, path, token: server.accessToken, expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Should succeed with the same user', async function () {\n      let commentToDelete: number\n\n      {\n        const created = await server.comments.createThread({ videoId: video.uuid, token: userAccessToken, text: 'hello' })\n        commentToDelete = created.id\n      }\n\n      const path = '/api/v1/videos/' + video.uuid + '/comments/' + commentToDelete\n\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken2, expectedStatus: HttpStatusCode.FORBIDDEN_403 })\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken, expectedStatus: HttpStatusCode.NO_CONTENT_204 })\n    })\n\n    it('Should succeed with the owner of the video', async function () {\n      let commentToDelete: number\n      let anotherVideoUUID: string\n\n      {\n        const { uuid } = await server.videos.upload({ token: userAccessToken, attributes: { name: 'video' } })\n        anotherVideoUUID = uuid\n      }\n\n      {\n        const created = await server.comments.createThread({ videoId: anotherVideoUUID, text: 'hello' })\n        commentToDelete = created.id\n      }\n\n      const path = '/api/v1/videos/' + anotherVideoUUID + '/comments/' + commentToDelete\n\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken2, expectedStatus: HttpStatusCode.FORBIDDEN_403 })\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken, expectedStatus: HttpStatusCode.NO_CONTENT_204 })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: pathComment,\n        token: server.accessToken,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  describe('When a video has comments disabled', function () {\n    before(async function () {\n      video = await server.videos.upload({ attributes: { commentsEnabled: false } })\n      pathThread = '/api/v1/videos/' + video.uuid + '/comment-threads'\n    })\n\n    it('Should return an empty thread list', async function () {\n      const res = await makeGetRequest({\n        url: server.url,\n        path: pathThread,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n      expect(res.body.total).to.equal(0)\n      expect(res.body.data).to.have.lengthOf(0)\n    })\n\n    it('Should return an thread comments list')\n\n    it('Should return conflict on thread add', async function () {\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.CONFLICT_409\n      })\n    })\n\n    it('Should return conflict on comment thread add')\n  })\n\n  describe('When listing admin comments threads', function () {\n    const path = '/api/v1/videos/comments'\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a non authenticated user', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with a non admin user', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        token: userAccessToken,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should succeed with the correct params', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        query: {\n          isLocal: false,\n          search: 'toto',\n          searchAccount: 'toto',\n          searchVideo: 'toto'\n        },\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  after(async function () {\n    await cleanupTests([ server ])\n  })\n})\n"], "filenames": ["server/middlewares/validators/videos/video-comments.ts", "server/tests/api/check-params/video-comments.ts"], "buggy_code_start_loc": [12, 17], "buggy_code_end_loc": [66, 102], "fixing_code_start_loc": [12, 17], "fixing_code_end_loc": [88, 164], "type": "CWE-284", "message": "peertube is vulnerable to Improper Access Control", "other": {"cve": {"id": "CVE-2022-0170", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-11T16:15:07.860", "lastModified": "2022-01-19T19:31:56.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "peertube is vulnerable to Improper Access Control"}, {"lang": "es", "value": "peertube es vulnerable a un Control de Acceso Inapropiado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:framasoft:peertube:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.0.0", "matchCriteriaId": "9612EB04-5E64-485B-B1BB-5420EB0BF1C4"}]}]}], "references": [{"url": "https://github.com/chocobozzz/peertube/commit/84c8d9866890f479faf0168c29be5eb7816ccc8e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/f2a003fc-b911-43b6-81ec-f856cdfeaefc", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/chocobozzz/peertube/commit/84c8d9866890f479faf0168c29be5eb7816ccc8e"}}