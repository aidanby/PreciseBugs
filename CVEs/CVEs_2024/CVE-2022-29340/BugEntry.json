{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//Add this funct to handle incomplete files...\n//bytesExpected is 0 most of the time. If the file is incomplete, bytesExpected\n//is the number of bytes missing to parse the box...\nGF_Err gf_isom_parse_root_box(GF_Box **outBox, GF_BitStream *bs, u32 *box_type, u64 *bytesExpected, Bool progressive_mode)\n{\n\tGF_Err ret;\n\tu64 start;\n\tstart = gf_bs_get_position(bs);\n\tret = gf_isom_box_parse_ex(outBox, bs, 0, GF_TRUE, 0);\n\tif (ret == GF_ISOM_INCOMPLETE_FILE) {\n\t\tif (!*outBox) {\n\t\t\t// We could not even read the box size, we at least need 8 bytes\n\t\t\t*bytesExpected = 8;\n\t\t\tif (box_type) *box_type = 0;\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box - start \"LLU\"\\n\", start));\n\t\t}\n\t\telse {\n\t\t\tu32 type = (*outBox)->type;\n\t\t\tif (type==GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\ttype = ((GF_UnknownBox *) (*outBox))->original_4cc;\n\n\t\t\t*bytesExpected = (*outBox)->size;\n\t\t\tif (box_type) *box_type = (*outBox)->type;\n\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box %s - start \"LLU\" size \"LLU\"\\n\", gf_4cc_to_str(type), start, (*outBox)->size));\n\t\t\tgf_isom_box_del(*outBox);\n\t\t\t*outBox = NULL;\n\t\t}\n\t\tgf_bs_seek(bs, start);\n\t}\n\treturn ret;\n}\n\nu32 gf_isom_solve_uuid_box(u8 *UUID)\n{\n\tu32 i;\n\tchar strUUID[33], strChar[3];\n\tstrUUID[0] = 0;\n\tstrUUID[32] = 0;\n\tfor (i=0; i<16; i++) {\n\t\tsnprintf(strChar, 3, \"%02X\", (unsigned char) UUID[i]);\n\t\tstrcat(strUUID, strChar);\n\t}\n\tif (!strnicmp(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TENC;\n\tif (!strnicmp(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32))\n\t\treturn GF_ISOM_BOX_UUID_MSSM;\n\tif (!strnicmp(strUUID, \"D4807EF2CA3946958E5426CB9E46A79F\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFRF;\n\tif (!strnicmp(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFXD;\n\tif (!strnicmp(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSEC;\n\tif (!strnicmp(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSSH;\n\n\treturn 0;\n}\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs);\n\nu64 unused_bytes = 0;\n\n#define GF_SKIP_BOX 10\n\nGF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\t\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t\treturn GF_SKIP_BOX;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//if parent size is given, make sure box fits within parent\n\tif (parent_size && (parent_size<size)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t\tunused_bytes += to_skip;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_parse(GF_Box **outBox, GF_BitStream *bs)\n{\n\treturn gf_isom_box_parse_ex(outBox, bs, 0, GF_FALSE, 0);\n}\n\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\n\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\n\nvoid gf_isom_box_array_reset_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del_parent(child_boxes, a);\n\t}\n\tgf_list_reset(boxlist);\n}\nvoid gf_isom_box_array_del_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tif (!boxlist) return;\n\tgf_isom_box_array_reset_parent(child_boxes, boxlist);\n\tgf_list_del(boxlist);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_EXPORT\nGF_Err gf_isom_box_write_header(GF_Box *ptr, GF_BitStream *bs)\n{\n\tu64 start;\n\tif (! bs || !ptr) return GF_BAD_PARAM;\n\tif (!ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tstart = gf_bs_get_position(bs);\n\tif (ptr->size > 0xFFFFFFFF) {\n\t\tgf_bs_write_u32(bs, 1);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->size);\n\t}\n\tgf_bs_write_u32(bs, ptr->type);\n\tif (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tBool conv_uuid = GF_TRUE;\n\t\tGF_UUIDBox *uuidb = (GF_UUIDBox *)ptr;\n\t\tchar strUUID[32];\n\n\t\tswitch (uuidb->internal_4cc) {\n\t\tcase GF_ISOM_BOX_UUID_TENC:\n\t\t\tmemcpy(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSEC:\n\t\t\tmemcpy(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_MSSM:\n\t\t\tmemcpy(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSSH:\n\t\t\tmemcpy(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_TFXD:\n\t\t\tmemcpy(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconv_uuid = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (conv_uuid) {\n\t\t\tchar uuid[16];\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tchar t[3];\n\t\t\t\tt[2] = 0;\n\t\t\t\tt[0] = strUUID[2*i];\n\t\t\t\tt[1] = strUUID[2*i+1];\n\t\t\t\tuuid[i] = (u8) strtol(t, NULL, 16);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, uuid, 16);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, uuidb->uuid, 16);\n\t\t}\n\t}\n\tif (ptr->size > 0xFFFFFFFF)\n\t\tgf_bs_write_u64(bs, ptr->size);\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Written Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(ptr->type), ptr->size, start));\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FullBox *ptr = (GF_FullBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_write(GF_Box *parent, GF_List *list, GF_BitStream *bs)\n{\n\tu32 count, i;\n\tGF_Err e;\n\tif (!list) return GF_OK;\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_write(a, bs);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s writing box %s\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_size(GF_Box *parent, GF_List *list)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tif (! list) return GF_OK;\n\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_size(a);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s computing box %s size\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tparent->size += a->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box * unkn_box_new();\nvoid unkn_box_del(GF_Box *);\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_size(GF_Box *s);\nGF_Err unkn_box_dump(GF_Box *a, FILE * trace);\n\n//definition of boxes new/del/read/write/size. For now still exported since some files other than box_funcs.c call them\n//this should be fixed by only using gf_isom_box_new\n\n#define ISOM_BOX_IMPL_DECL(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\n\n#define ISOM_BOX_IMPL_DECL_CHILD(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\\\n\t\tGF_Err a_name##_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\\\n\n\nISOM_BOX_IMPL_DECL(reftype)\nISOM_BOX_IMPL_DECL(ireftype)\nISOM_BOX_IMPL_DECL(free)\nISOM_BOX_IMPL_DECL(wide)\nISOM_BOX_IMPL_DECL(mdat)\nISOM_BOX_IMPL_DECL_CHILD(moov)\nISOM_BOX_IMPL_DECL(mvhd)\nISOM_BOX_IMPL_DECL(mdhd)\nISOM_BOX_IMPL_DECL(vmhd)\nISOM_BOX_IMPL_DECL(smhd)\nISOM_BOX_IMPL_DECL(hmhd)\nISOM_BOX_IMPL_DECL(nmhd)\nISOM_BOX_IMPL_DECL_CHILD(stbl)\nISOM_BOX_IMPL_DECL_CHILD(dinf)\nISOM_BOX_IMPL_DECL(url)\nISOM_BOX_IMPL_DECL(urn)\nISOM_BOX_IMPL_DECL(cprt)\nISOM_BOX_IMPL_DECL(kind)\nISOM_BOX_IMPL_DECL(chpl)\nISOM_BOX_IMPL_DECL(hdlr)\nISOM_BOX_IMPL_DECL(iods)\nISOM_BOX_IMPL_DECL_CHILD(trak)\nISOM_BOX_IMPL_DECL_CHILD(mp4s)\nISOM_BOX_IMPL_DECL_CHILD(audio_sample_entry)\nISOM_BOX_IMPL_DECL(gen_sample_entry)\nISOM_BOX_IMPL_DECL_CHILD(edts)\nISOM_BOX_IMPL_DECL_CHILD(udta)\nISOM_BOX_IMPL_DECL(dref)\nISOM_BOX_IMPL_DECL_CHILD(stsd)\nISOM_BOX_IMPL_DECL(stts)\nISOM_BOX_IMPL_DECL(ctts)\nISOM_BOX_IMPL_DECL(stsh)\nISOM_BOX_IMPL_DECL(elst)\nISOM_BOX_IMPL_DECL(stsc)\nISOM_BOX_IMPL_DECL(stsz)\nISOM_BOX_IMPL_DECL(stco)\nISOM_BOX_IMPL_DECL(stss)\nISOM_BOX_IMPL_DECL(stdp)\nISOM_BOX_IMPL_DECL(sdtp)\nISOM_BOX_IMPL_DECL(co64)\nISOM_BOX_IMPL_DECL(esds)\nISOM_BOX_IMPL_DECL_CHILD(minf)\nISOM_BOX_IMPL_DECL(tkhd)\nISOM_BOX_IMPL_DECL(tref)\nISOM_BOX_IMPL_DECL_CHILD(mdia)\nISOM_BOX_IMPL_DECL_CHILD(mfra)\nISOM_BOX_IMPL_DECL(tfra)\nISOM_BOX_IMPL_DECL(mfro)\nISOM_BOX_IMPL_DECL(uuid)\nISOM_BOX_IMPL_DECL(void)\nISOM_BOX_IMPL_DECL(gnrm)\nISOM_BOX_IMPL_DECL(gnrv)\nISOM_BOX_IMPL_DECL(gnra)\nISOM_BOX_IMPL_DECL(pdin)\nISOM_BOX_IMPL_DECL(def_parent)\nISOM_BOX_IMPL_DECL(def_parent_full)\nISOM_BOX_IMPL_DECL(csgp)\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nISOM_BOX_IMPL_DECL_CHILD(hinf)\nISOM_BOX_IMPL_DECL(trpy)\nISOM_BOX_IMPL_DECL(totl)\nISOM_BOX_IMPL_DECL(nump)\nISOM_BOX_IMPL_DECL(npck)\nISOM_BOX_IMPL_DECL(tpyl)\nISOM_BOX_IMPL_DECL(tpay)\nISOM_BOX_IMPL_DECL(maxr)\nISOM_BOX_IMPL_DECL(dmed)\nISOM_BOX_IMPL_DECL(dimm)\nISOM_BOX_IMPL_DECL(drep)\nISOM_BOX_IMPL_DECL(tmin)\nISOM_BOX_IMPL_DECL(tmax)\nISOM_BOX_IMPL_DECL(pmax)\nISOM_BOX_IMPL_DECL(dmax)\nISOM_BOX_IMPL_DECL(payt)\nISOM_BOX_IMPL_DECL(name)\nISOM_BOX_IMPL_DECL(rely)\nISOM_BOX_IMPL_DECL(snro)\nISOM_BOX_IMPL_DECL(tims)\nISOM_BOX_IMPL_DECL(tsro)\nISOM_BOX_IMPL_DECL(ghnt)\nISOM_BOX_IMPL_DECL_CHILD(hnti)\nISOM_BOX_IMPL_DECL(sdp)\nISOM_BOX_IMPL_DECL(rtpo)\nISOM_BOX_IMPL_DECL(tssy)\nISOM_BOX_IMPL_DECL(rssr)\nISOM_BOX_IMPL_DECL_CHILD(srpp)\nISOM_BOX_IMPL_DECL(rtp_hnti)\n\n#endif\n\nISOM_BOX_IMPL_DECL(ftyp)\nISOM_BOX_IMPL_DECL(padb)\nISOM_BOX_IMPL_DECL(gppc)\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL_CHILD(mvex)\nISOM_BOX_IMPL_DECL(trex)\nISOM_BOX_IMPL_DECL_CHILD(moof)\nISOM_BOX_IMPL_DECL(mfhd)\nISOM_BOX_IMPL_DECL_CHILD(traf)\nISOM_BOX_IMPL_DECL(tfhd)\nISOM_BOX_IMPL_DECL(trun)\nISOM_BOX_IMPL_DECL(styp)\nISOM_BOX_IMPL_DECL(mehd)\n/*smooth streaming timing*/\nISOM_BOX_IMPL_DECL(tfxd)\nISOM_BOX_IMPL_DECL(tfrf)\n\n#endif\n\n/*avc ext*/\nISOM_BOX_IMPL_DECL(avcc)\nISOM_BOX_IMPL_DECL_CHILD(video_sample_entry)\nISOM_BOX_IMPL_DECL(m4ds)\nISOM_BOX_IMPL_DECL(btrt)\nISOM_BOX_IMPL_DECL(mehd)\n\n/*3GPP streaming text*/\nISOM_BOX_IMPL_DECL(ftab)\nISOM_BOX_IMPL_DECL_CHILD(tx3g)\nISOM_BOX_IMPL_DECL(text)\nISOM_BOX_IMPL_DECL(styl)\nISOM_BOX_IMPL_DECL(hlit)\nISOM_BOX_IMPL_DECL(hclr)\nISOM_BOX_IMPL_DECL(krok)\nISOM_BOX_IMPL_DECL(dlay)\nISOM_BOX_IMPL_DECL(href)\nISOM_BOX_IMPL_DECL(tbox)\nISOM_BOX_IMPL_DECL(blnk)\nISOM_BOX_IMPL_DECL(twrp)\n\n\n#ifndef GPAC_DISABLE_VTT\n\n/*WebVTT boxes*/\nISOM_BOX_IMPL_DECL(boxstring);\nISOM_BOX_IMPL_DECL_CHILD(vtcu)\nISOM_BOX_IMPL_DECL(vtte)\nISOM_BOX_IMPL_DECL_CHILD(wvtt)\n\n#endif //GPAC_DISABLE_VTT\n\n/* Items functions */\nISOM_BOX_IMPL_DECL_CHILD(meta)\nISOM_BOX_IMPL_DECL(xml)\nISOM_BOX_IMPL_DECL(bxml)\nISOM_BOX_IMPL_DECL(iloc)\nISOM_BOX_IMPL_DECL(pitm)\nISOM_BOX_IMPL_DECL_CHILD(ipro)\nISOM_BOX_IMPL_DECL(infe)\nISOM_BOX_IMPL_DECL_CHILD(iinf)\nISOM_BOX_IMPL_DECL_CHILD(iref)\nISOM_BOX_IMPL_DECL_CHILD(sinf)\nISOM_BOX_IMPL_DECL(frma)\nISOM_BOX_IMPL_DECL(schm)\nISOM_BOX_IMPL_DECL_CHILD(schi)\nISOM_BOX_IMPL_DECL(enca)\nISOM_BOX_IMPL_DECL(encs)\nISOM_BOX_IMPL_DECL(encv)\nISOM_BOX_IMPL_DECL(resv)\n\n\n/** ISMACryp functions **/\nISOM_BOX_IMPL_DECL(iKMS)\nISOM_BOX_IMPL_DECL(iSFM)\nISOM_BOX_IMPL_DECL(iSLT)\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n/* Adobe extensions */\nISOM_BOX_IMPL_DECL(abst)\nISOM_BOX_IMPL_DECL(afra)\nISOM_BOX_IMPL_DECL(asrt)\nISOM_BOX_IMPL_DECL(afrt)\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\n/* Apple extensions */\nISOM_BOX_IMPL_DECL(ilst)\nISOM_BOX_IMPL_DECL(ilst_item)\nISOM_BOX_IMPL_DECL(databox)\nISOM_BOX_IMPL_DECL(gmin)\nISOM_BOX_IMPL_DECL(alis)\nISOM_BOX_IMPL_DECL(clef)\n\n/*OMA extensions*/\nISOM_BOX_IMPL_DECL(ohdr)\nISOM_BOX_IMPL_DECL(grpi)\nISOM_BOX_IMPL_DECL(mdri)\nISOM_BOX_IMPL_DECL(odtt)\nISOM_BOX_IMPL_DECL(odrb)\nISOM_BOX_IMPL_DECL(odkm)\n\n\nISOM_BOX_IMPL_DECL(pasp)\nISOM_BOX_IMPL_DECL(clap)\nISOM_BOX_IMPL_DECL_CHILD(metx)\nISOM_BOX_IMPL_DECL(txtc)\nISOM_BOX_IMPL_DECL(tsel)\nISOM_BOX_IMPL_DECL(dimC)\nISOM_BOX_IMPL_DECL_CHILD(dims)\nISOM_BOX_IMPL_DECL(diST)\nISOM_BOX_IMPL_DECL(ac3)\nISOM_BOX_IMPL_DECL(ec3)\nISOM_BOX_IMPL_DECL(dac3)\nISOM_BOX_IMPL_DECL(dec3)\nISOM_BOX_IMPL_DECL(dmlp)\nISOM_BOX_IMPL_DECL(lsrc)\nISOM_BOX_IMPL_DECL_CHILD(lsr1)\nISOM_BOX_IMPL_DECL(mvcg)\nISOM_BOX_IMPL_DECL(vwid)\n\nISOM_BOX_IMPL_DECL(subs)\n\nISOM_BOX_IMPL_DECL(tmcd)\nISOM_BOX_IMPL_DECL(tcmi)\nISOM_BOX_IMPL_DECL(fiel)\nISOM_BOX_IMPL_DECL(gama)\nISOM_BOX_IMPL_DECL(chrm)\nISOM_BOX_IMPL_DECL(chan)\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL(sidx)\nISOM_BOX_IMPL_DECL(ssix)\nISOM_BOX_IMPL_DECL(leva)\nISOM_BOX_IMPL_DECL(pcrb)\nISOM_BOX_IMPL_DECL(tfdt)\nISOM_BOX_IMPL_DECL(emsg)\n\n#endif\n\nISOM_BOX_IMPL_DECL(rvcc)\nISOM_BOX_IMPL_DECL(sbgp)\nISOM_BOX_IMPL_DECL(sgpd)\nISOM_BOX_IMPL_DECL(saiz)\nISOM_BOX_IMPL_DECL(saio)\n\nISOM_BOX_IMPL_DECL(pssh)\n\nISOM_BOX_IMPL_DECL(tenc)\nISOM_BOX_IMPL_DECL(piff_tenc)\nISOM_BOX_IMPL_DECL(piff_psec)\nISOM_BOX_IMPL_DECL(piff_pssh)\nISOM_BOX_IMPL_DECL(senc)\nISOM_BOX_IMPL_DECL(cslg)\nISOM_BOX_IMPL_DECL(ccst)\nISOM_BOX_IMPL_DECL(auxi)\nISOM_BOX_IMPL_DECL(hvcc)\nISOM_BOX_IMPL_DECL(av1c)\nISOM_BOX_IMPL_DECL(dOps)\nISOM_BOX_IMPL_DECL(prft)\nISOM_BOX_IMPL_DECL(vvcc)\nISOM_BOX_IMPL_DECL(vvnc)\n\n//VPx\nISOM_BOX_IMPL_DECL(vpcc)\nISOM_BOX_IMPL_DECL(SmDm)\nISOM_BOX_IMPL_DECL(CoLL)\n\nISOM_BOX_IMPL_DECL(trep)\n\n//FEC\nISOM_BOX_IMPL_DECL_CHILD(fiin)\nISOM_BOX_IMPL_DECL_CHILD(paen)\nISOM_BOX_IMPL_DECL(fpar)\nISOM_BOX_IMPL_DECL(fecr)\nISOM_BOX_IMPL_DECL(segr)\nISOM_BOX_IMPL_DECL(gitn)\nISOM_BOX_IMPL_DECL_CHILD(fdsa)\nISOM_BOX_IMPL_DECL(fdpa)\nISOM_BOX_IMPL_DECL(extr)\n\n\n/*\n\tAdobe's protection boxes\n*/\nISOM_BOX_IMPL_DECL_CHILD(adkm)\nISOM_BOX_IMPL_DECL_CHILD(ahdr)\nISOM_BOX_IMPL_DECL_CHILD(aprm)\nISOM_BOX_IMPL_DECL(aeib)\nISOM_BOX_IMPL_DECL_CHILD(akey)\nISOM_BOX_IMPL_DECL(flxs)\nISOM_BOX_IMPL_DECL(adaf)\n\n/* Image File Format declarations */\nISOM_BOX_IMPL_DECL(ispe)\nISOM_BOX_IMPL_DECL(colr)\nISOM_BOX_IMPL_DECL(pixi)\nISOM_BOX_IMPL_DECL(rloc)\nISOM_BOX_IMPL_DECL(irot)\nISOM_BOX_IMPL_DECL(imir)\nISOM_BOX_IMPL_DECL(ipco)\nISOM_BOX_IMPL_DECL_CHILD(iprp)\nISOM_BOX_IMPL_DECL(ipma)\nISOM_BOX_IMPL_DECL_CHILD(trgr)\nISOM_BOX_IMPL_DECL(trgt)\nISOM_BOX_IMPL_DECL(ienc)\nISOM_BOX_IMPL_DECL(iaux)\n\n/* MIAF declarations */\nISOM_BOX_IMPL_DECL(clli)\nISOM_BOX_IMPL_DECL(mdcv)\n\n/* AVIF declarations */\nISOM_BOX_IMPL_DECL(a1lx)\nISOM_BOX_IMPL_DECL(a1op)\n\nISOM_BOX_IMPL_DECL(grpl)\n\nISOM_BOX_IMPL_DECL_CHILD(strk)\nISOM_BOX_IMPL_DECL(stri)\nISOM_BOX_IMPL_DECL(stsg)\nISOM_BOX_IMPL_DECL(elng)\nISOM_BOX_IMPL_DECL(stvi)\nISOM_BOX_IMPL_DECL(auxc)\nISOM_BOX_IMPL_DECL(oinf)\nISOM_BOX_IMPL_DECL(tols)\n\nISOM_BOX_IMPL_DECL(trik)\nISOM_BOX_IMPL_DECL(bloc)\nISOM_BOX_IMPL_DECL(ainf)\nISOM_BOX_IMPL_DECL(mhac)\nISOM_BOX_IMPL_DECL(mhap)\n\nISOM_BOX_IMPL_DECL(grptype)\n\nISOM_BOX_IMPL_DECL_CHILD(jp2h)\nISOM_BOX_IMPL_DECL(ihdr)\nISOM_BOX_IMPL_DECL(load)\n\n/* Dolby Vision */\nISOM_BOX_IMPL_DECL(dvcC)\nISOM_BOX_IMPL_DECL(dvvC)\nISOM_BOX_IMPL_DECL(dvhe)\nISOM_BOX_IMPL_DECL(dfla)\n\nISOM_BOX_IMPL_DECL(pcmC)\nISOM_BOX_IMPL_DECL(chnl)\n\nISOM_BOX_IMPL_DECL(xtra)\n\nISOM_BOX_IMPL_DECL(st3d)\nISOM_BOX_IMPL_DECL(svhd)\nISOM_BOX_IMPL_DECL(prhd)\nISOM_BOX_IMPL_DECL(proj_type)\n//ISOM_BOX_IMPL_DECL(mesh)\n\n\n#define BOX_DEFINE(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE}\n\n#define BOX_DEFINE_CHILD(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define BOX_DEFINE_S(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE }\n\n#define BOX_DEFINE_S_CHILD(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_CHILD(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE_FLAGS(__type, b_rad, __par, __max_v, flags) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_FLAGS_S(__type, b_rad, __par, __max_v, flags, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S_CHILD(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define TREF_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 0, 0, __par, __spec, GF_FALSE }\n\n#define TRGT_DEFINE(__type, b_rad, __par, __4cc, max_version, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1+max_version, 0, __par, __spec, GF_FALSE }\n\n#define SGPD_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1, 0, __par, __spec, GF_FALSE }\n\n#define ITUNES_TAG(_val) \\\n\tBOX_DEFINE_S( _val, ilst_item, \"ilst data\", \"apple\")\n\nstatic struct box_registry_entry {\n\tu32 box_4cc;\n\tGF_Box * (*new_fn)();\n\tvoid (*del_fn)(GF_Box *a);\n\tGF_Err (*read_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*write_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*size_fn)(GF_Box *a);\n\tGF_Err (*dump_fn)(GF_Box *a, FILE *trace);\n\tu32 alt_4cc;//used for sample grouping type and track / item reference types\n\tu8 max_version_plus_one;\n\tu32 flags;\n\tconst char *parents_4cc;\n\tconst char *spec;\n\tBool disabled;\n\tGF_Err (*add_rem_fn)(GF_Box *par, GF_Box *b, Bool is_remove);\n} box_registry [] =\n{\n\t//DO NOT MOVE THE FIRST ENTRY\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UNKNOWN, unkn, \"unknown\", \"unknown\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UUID, uuid, \"unknown\", \"unknown\"),\n\n\t//all track reference types\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_META, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HINT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_FONT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HIND, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VDEP, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VPLX, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SUBT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_THUMB, \"p12\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OD, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_DECODE, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OCR, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_IPI, \"p14\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_BASE, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCAL, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TBAS, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SABT, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OREF, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADDA, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADRC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_AVCP, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWTO, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWFR, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CHAP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TMCD, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CDEP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCPT, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SSRC, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_LYRA, \"apple\"),\n\n\t//all item reference types\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_TBAS, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_FDEL, \"p12\"),\n\n\t//all sample group descriptions\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ROLL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_PROL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RAP, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SEIG, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_OINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TRIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_NALM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TELE, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RASH, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ALST, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SAP, \"p12\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVLL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVSS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_DTRT, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_MVIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCNM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_STSA, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSAS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SYNC, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSCL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_VIPR, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LBLI, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SPOR, \"p15\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_3GAG, \"3gpp\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVCB, \"3gpp\"),\n\n\t//internal boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRM, gnrm, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRV, gnrv, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRA, gnra, \"stsd\", \"unknown\"),\n\n\t//all track group types\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_MSRC, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_STER, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_CSTG, 0, \"p15\" ),\n\n\t//part12 boxes\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FREE, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SKIP, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MDAT, mdat, \"file\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_IDAT, mdat, \"meta\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOV, moov, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MVHD, mvhd, \"moov\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MDHD, mdhd, \"mdia\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_VMHD, vmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SMHD, smhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HMHD, hmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_NMHD, nmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STHD, nmhd, \"minf\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STBL, stbl, \"minf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_DINF, dinf, \"minf meta\"),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URL, url, \"dref\", 0, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URN, urn, \"dref\", 0, 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CPRT, cprt, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_KIND, kind, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HDLR, hdlr, \"mdia meta minf\", 0),\t//minf container is OK in QT ...\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAK, trak, \"moov\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_EDTS, edts, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_UDTA, udta, \"moov trak moof traf\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_DREF, dref, \"dinf\", 0),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STSD, stsd, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STTS, stts, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CTTS, ctts, \"stbl\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CSLG, cslg, \"stbl trep\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSH, stsh, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELST, elst, \"edts\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSC, stsc, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSZ, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STZ2, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STCO, stco, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSS, stss, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STDP, stdp, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SDTP, sdtp, \"stbl traf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CO64, co64, \"stbl\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MINF, minf, \"mdia\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TKHD, tkhd, \"trak\", 1, 0x000001 | 0x000002 | 0x000004 | 0x000008),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TREF, tref, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MDIA, mdia, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MFRA, mfra, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFRO, mfro, \"mfra\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFRA, tfra, \"mfra\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELNG, elng, \"mdia\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PDIN, pdin, \"file\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SBGP, sbgp, \"stbl traf\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", 2),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CSGP, csgp, \"stbl traf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 1),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_SUBS, subs, \"stbl traf\", 0, 7), //warning flags are not used as a bit mask but as an enum!!\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRGR, trgr, \"trak\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FTYP, ftyp, \"file otyp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_OTYP, def_parent, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PADB, padb, \"stbl\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_BTRT, btrt, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PASP, pasp, \"video_sample_entry ipco\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CLAP, clap, \"video_sample_entry ipco\"),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_META, meta, \"file moov trak moof traf udta\", 0),\t//apple uses meta in moov->udta\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_XML, xml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_BXML, bxml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ILOC, iloc, \"meta\", 2),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PITM, pitm, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IPRO, ipro, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_INFE, infe, \"iinf\", 3),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IINF, iinf, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IREF, iref, \"meta\", 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SINF, sinf, \"ipro sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RINF, sinf, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FRMA, frma, \"sinf rinf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SCHM, schm, \"sinf rinf\", 0, 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SCHI, schi, \"sinf rinf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCA, audio_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCV, video_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_RESV, video_sample_entry, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TSEL, tsel, \"udta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STRK, strk, \"udta\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STRI, stri, \"strk\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STRD, def_parent, \"strk\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSG, stsg, \"strd\", 0),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCS, mp4s, \"stsd\"),\n\t//THIS HAS TO BE FIXED, not extensible\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCT, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCM, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCF, mp4s, \"stsd\"),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METX, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STVI, stvi, \"schi\", 0),\n\n\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, \"audio_sample_entry\", 0),\n\n\t//FEC\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FIIN, fiin, \"meta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_PAEN, paen, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FPAR, fpar, \"paen\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FECR, fecr, \"paen\", 1),\n\t//fire uses the same box syntax as fecr\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FIRE, fecr, \"paen\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SEGR, segr, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_GITN, gitn, \"fiin\", 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FDSA, fdsa, \"fdp_sample\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDPA, fdpa, \"fdsa\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_EXTR, extr, \"fdsa\"),\n#endif\n\n\t//full boxes todo\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ASSP, assp, 1),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_MERE, assp, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_SRAT, srat, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_DMIX, dmix, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_TLOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ALOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URI, uri, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URII, urii, 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTCP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HNTI, hnti, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SDP, sdp, \"hnti\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HINF, hinf, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TRPY, trpy, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NUMP, nump, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPYL, tpyl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TOTL, totl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NPCK, npck, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPAY, tpay, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MAXR, maxr, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMED, dmed, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DIMM, dimm, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DREP, drep, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMIN, tmin, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMAX, tmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PMAX, pmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMAX, dmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PAYT, payt, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP, rtp_hnti, \"hnti\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTPO, rtpo, \"rtp_packet\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RELY, rely, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TIMS, tims, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSRO, tsro, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SNRO, snro, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NAME, name, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSSY, tssy, \"rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RSSR, rssr, \"rrtp\"),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SRPP, srpp, \"srtp\", 0),\n\n#endif\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MVEX, mvex, \"moov\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MEHD, mehd, \"mvex\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREX, trex, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_LEVA, leva, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREP, trep, \"mvex\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOF, moof, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFHD, mfhd, \"moof\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAF, traf, \"moof\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TFHD, tfhd, \"traf\", 0, 0x000001|0x000002|0x000008|0x000010|0x000020|0x010000|0x020000),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TRUN, trun, \"traf\", 0, 0x000001|0x000004|0x000100|0x000200|0x000400|0x000800),\n#ifdef GF_ENABLE_CTRN\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_CTRN, trun, \"traf\", 0, 0),\n#endif\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFDT, tfdt, \"traf\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STYP, ftyp, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PRFT, prft, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SIDX, sidx, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SSIX, ssix, \"file\", 0),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCRB, pcrb, \"file\", \"dash\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EMSG, emsg, \"file\", 1, \"dash\"),\n#endif\n\n\n\t//part14 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IODS, iods, \"moov\", 0, \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4S, mp4s, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4V, video_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4A, audio_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_M4DS, m4ds, \"sample_entry\", \"p14\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ESDS, esds, \"mp4a mp4s mp4v encv enca encs resv wave\", 0, \"p14\"),\n\n\t//part 15 boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AVCC, avcc, \"avc1 avc2 avc3 avc4 encv resv ipco dva1 dvav\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVCC, avcc, \"avc1 avc2 avc3 avc4 svc1 svc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MVCC, avcc, \"avc1 avc2 avc3 avc4 mvc1 mvc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HVCC, hvcc, \"hvc1 hev1 hvc2 hev2 encv resv ipco dvh1 dvhe\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LHVC, hvcc, \"hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv ipco\", \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VVCC, vvcc, \"vvc1 vvi1 encv resv ipco dvhe\", 0, \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VVNC, vvnc, \"vvs1 encv resv ipco dvhe\", 0, \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC3, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC4, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_SVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHE1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVT1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVI1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVS1, video_sample_entry, \"stsd\", \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCI, def_parent_full, \"minf\", 0, \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCG, mvcg, \"mvci\", 0, \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VWID, vwid, \"video_sample_entry\", 0, \"p15\"),\n\n\t//mpegh 3D audio boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAC, mhac, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAP, mhap, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_FPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCMC, pcmC, \"ipcm fpcm\", 0, \"23003_5\"),\n\n\t//AV1 in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_AV01, video_sample_entry, \"stsd\", \"av1\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_AV1C, av1c, \"av01 encv resv ipco dav1\", \"av1\"),\n\n\t// VP8-9 boxes\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_VPCC, vpcc, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP08, video_sample_entry, \"stsd\", \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP09, video_sample_entry, \"stsd\", \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_SMDM, SmDm, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_COLL, CoLL, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\n\t//Opus in ISOBMFF boxes\n#ifndef GPAC_DISABLE_OGG\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_OPUS, audio_sample_entry, \"stsd\", \"Opus\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DOPS, dOps, \"Opus wave enca\", \"Opus\"),\n#endif\n\n\t//part20 boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LSR1, lsr1, \"stsd\", \"p20\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LSRC, lsrc, \"lsr1\", \"p20\"),\n\n\t//part30 boxes\n#ifndef GPAC_DISABLE_TTXT\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STXT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TXTC, txtc, \"stxt mett sbtt\", 0),\n\t//we allow mime in any sample entry, not restricted in the spec ...\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MIME, txtc, \"sample_entry\", 0),\n#ifndef GPAC_DISABLE_VTT\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_WVTT, wvtt, \"stsd\", \"p30\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VTCC_CUE, vtcu, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTE, vtte, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTC_CONFIG, boxstring, \"wvtt\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CTIM, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IDEN, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STTG, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PAYL, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTA, boxstring, \"vttc\", \"p30\"),\n#endif\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STPP, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SBTT, metx, \"stsd\"),\n#endif\n\n\t//Image File Format\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPRP, iprp, \"meta\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IPCO, ipco, \"iprp\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISPE, ispe, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"video_sample_entry ipco encv resv\", \"iff\"),\n\t//defined as a secondary box for now to avoid conflicts with master hashes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"jp2h\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PIXI, pixi, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RLOC, rloc, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IROT, irot, \"ipco\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IMIR, imir, \"ipco\", \"iff\"),\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_IPMA, ipma, \"iprp\", 1, 1, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPL, grpl, \"meta\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CCST, ccst, \"sample_entry\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXI, auxi, \"sample_entry\", 0, \"iff\"),\n\tTRGT_DEFINE(GF_ISOM_BOX_TYPE_GRPT, grptype, \"grpl\", GF_ISOM_BOX_TYPE_ALTR, 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXC, auxc, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OINF, oinf, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TOLS, tols, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IENC, ienc, \"ipco\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IAUX, iaux, \"ipco\", 0, \"cenc\"),\n\n\t//MIAF\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_CLLI, clli, \"video_sample_entry ipco encv resv\", \"p12\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MDCV, mdcv, \"video_sample_entry ipco encv resv\", \"p12\"),\n\n\t//AVIF\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_A1LX, a1lx, \"ipco\", \"avif\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_A1OP, a1op, \"ipco\", \"avif\"),\n\n\t//other MPEG boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RVCC, rvcc, \"avc1 avc2 avc3 avc4 svc1 svc2 hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv\", \"rvc\"),\n\n\t//3GPP boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR_WB, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_QCELP, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_EVRC, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_SMV, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_H263, video_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAMR, gppc, \"samr sawb enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DEVC, gppc, \"sevc enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DQCP, gppc, \"sqcp enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DSMV, gppc, \"ssmv enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_D263, gppc, \"s263 encv\", \"3gpp\"),\n\t//3gpp timed text\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_TX3G, tx3g, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TEXT, text, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FTAB, ftab, \"tx3g text enct\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STYL, styl, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HLIT, hlit, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HCLR, hclr, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_KROK, krok, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DLAY, dlay, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HREF, href, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TBOX, tbox, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLNK, blnk, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TWRP, twrp, \"text_sample\", \"3gpp\"),\n\t//3GPP dims\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_DIMS, dims, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIMC, dimC, \"dims encs\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIST, diST, \"dims\", \"3gpp\"),\n\n\n\t//CENC boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PSSH, pssh, \"moov moof meta\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TENC, tenc, \"schi\", 1, \"cenc\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SENC, senc, \"trak traf\", \"cenc\"),\n\n\t// ISMA 1.1 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IKMS, iKMS, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISFM, iSFM, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISLT, iSLT, \"schi\", 0, \"isma\"),\n\n\t//OMA boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODKM, odkm, \"schi\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OHDR, ohdr, \"odkm\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPI, grpi, \"ohdr\", 0, \"oma\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MDRI, mdri, \"file\", \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODTT, odtt, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODRB, odrb, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODAF, iSFM, \"schi\", 0, \"oma\"),\n\n\t//apple boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP3, audio_sample_entry, \"stsd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CHPL, chpl, \"udta\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VOID, void, \"\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_WIDE, wide, \"*\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ILST, ilst, \"meta\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DATA, databox, \"ilst *\", 0, \"apple\"),\n\n\tITUNES_TAG(GF_ISOM_ITUNE_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_GROUP),\n\tITUNES_TAG(GF_ISOM_ITUNE_WRITER),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMMENT),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE_USER),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE),\n\tITUNES_TAG(GF_ISOM_ITUNE_CREATED),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACKNUMBER),\n\tITUNES_TAG(GF_ISOM_ITUNE_DISK),\n\tITUNES_TAG(GF_ISOM_ITUNE_TEMPO),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPILATION),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SEASON),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE_NUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_NETWORK),\n\tITUNES_TAG(GF_ISOM_ITUNE_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LONG_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LYRICS),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALB_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_COVER_ART),\n\tITUNES_TAG(GF_ISOM_ITUNE_COPYRIGHT),\n\tITUNES_TAG(GF_ISOM_ITUNE_TOOL),\n\tITUNES_TAG(GF_ISOM_ITUNE_ENCODER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PURCHASE_DATE),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST_URL),\n\tITUNES_TAG(GF_ISOM_ITUNE_KEYWORDS),\n\tITUNES_TAG(GF_ISOM_ITUNE_CATEGORY),\n\tITUNES_TAG(GF_ISOM_ITUNE_HD_VIDEO),\n\tITUNES_TAG(GF_ISOM_ITUNE_MEDIA_TYPE),\n\tITUNES_TAG(GF_ISOM_ITUNE_RATING),\n\tITUNES_TAG(GF_ISOM_ITUNE_GAPLESS),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACK),\n\tITUNES_TAG(GF_ISOM_ITUNE_CONDUCTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_ART_DIRECTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_ARRANGER),\n\tITUNES_TAG(GF_ISOM_ITUNE_LYRICIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_COPY_ACK),\n\tITUNES_TAG(GF_ISOM_ITUNE_SONG_DESC),\n\tITUNES_TAG(GF_ISOM_ITUNE_DIRECTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_EQ_PRESET),\n\tITUNES_TAG(GF_ISOM_ITUNE_LINER_NOTES),\n\tITUNES_TAG(GF_ISOM_ITUNE_REC_COMPANY),\n\tITUNES_TAG(GF_ISOM_ITUNE_ORIG_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_PHONO_RIGHTS),\n\tITUNES_TAG(GF_ISOM_ITUNE_PRODUCER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PERFORMER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PUBLISHER),\n\tITUNES_TAG(GF_ISOM_ITUNE_SOUND_ENG),\n\tITUNES_TAG(GF_ISOM_ITUNE_SOLOIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_CREDITS),\n\tITUNES_TAG(GF_ISOM_ITUNE_THANKS),\n\tITUNES_TAG(GF_ISOM_ITUNE_ONLINE),\n\tITUNES_TAG(GF_ISOM_ITUNE_EXEC_PRODUCER),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_iTunesSpecificInfo, ilst_item, \"ilst data\", \"apple\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_GMHD, def_parent, \"minf\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_LOAD, load, \"trak\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_TAPT, def_parent, \"trak\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_GMIN, gmin, \"gmhd\", 0, \"apple\"),\n\tFBOX_DEFINE_FLAGS_S( GF_QT_BOX_TYPE_ALIS, alis, \"dref\", 0, 1, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CLEF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_PROF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_ENOF, clef, \"tapt\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_WAVE, def_parent, \"audio_sample_entry\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CHAN, chan, \"audio_sample_entry\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FRMA, frma, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TERMINATOR, unkn, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_ENDA, chrm, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, def_parent, \"gmhd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_NAME, unkn, \"tmcd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_TCMI, tcmi, \"tmcd\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FIEL, fiel, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_GAMA, gama, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_CHRM, chrm, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_SUBTYPE_TEXT, unkn, \"gmhd\", \"apple\"),\n\n\t//QT and prores sample entry types\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, tmcd, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_SUBTYPE_C608, gen_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCH, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCO, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCS, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCN, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4X, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4H, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_AUD, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_TWOS, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_SOWT, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL64, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN24, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ULAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ALAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IMA_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_DVCA, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC2, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QCELP, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_kMP3, audio_sample_entry, \"stsd\", \"apple\"),\n\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_VID, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUYV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_UYVY, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUVA444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_16, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_I420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IYUV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YV12, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YVYU, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RGBA, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ABGR, video_sample_entry, \"stsd\", \"apple\"),\n\t\n\t\n\t//dolby boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_EC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAC3, dac3, \"ac-3 wave enca\", \"dolby\"),\n\t{GF_ISOM_BOX_TYPE_DEC3, dec3_box_new, dac3_box_del, dac3_box_read, dac3_box_write, dac3_box_size, dac3_box_dump, 0, 0, 0, \"ec-3 wave enca\", \"dolby\" },\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DVCC, dvcC, \"dvav dva1 dvhe dvh1 dav1 avc1 avc2 avc3 avc4 hev1 hvc1 av01 encv resv\", \"DolbyVision\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DVVC, dvvC, \"dvav dva1 dvhe dvh1 dav1 avc1 avc2 avc3 avc4 hev1 hvc1 av01 encv resv\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVHE, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVH1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVA1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVAV, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DAV1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MLPA, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DMLP, dmlp, \"mlpa enca\", \"dolby\"),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HVCE, hvcc, \"hvc1 hev1 hvc2 hev2 encv resv ipco dvh1 dvhe\", \"DolbyVision\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AVCE, avcc, \"avc1 avc2 avc3 avc4 encv resv ipco dva1 dvav\", \"DolbyVision\"),\n\n\n\t//Adobe boxes\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ABST, abst, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRA, afra, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ASRT, asrt, \"abst\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRT, afrt, \"abst\", 0, \"adobe\"),\n#endif\n\t/*Adobe's protection boxes*/\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_ADKM, adkm, \"schi\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AHDR, ahdr, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ADAF, adaf, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_APRM, aprm, \"ahdr\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AEIB, aeib, \"aprm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AKEY, akey, \"aprm\", 0, \"adobe\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FLXS, flxs, \"akey\", \"adobe\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TRIK, trik, \"traf\", 0, \"dece\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLOC, bloc, \"file\", 0, \"dece\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_AINF, ainf, \"moov\", 0, 0x000001, \"dece\"),\n\n\n\t//internally handled UUID for smooth - the code points are only used during creation and assigned to UUIDBox->internal4CC\n\t//the box type is still \"uuid\", and the factory is used to read/write/size/dump the code\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TENC, piff_tenc, \"schi\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSEC, piff_psec, \"trak traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSSH, piff_pssh, \"moov moof\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFXD, tfxd, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, tfrf, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_MSSM, uuid, \"file\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, uuid, \"traf\", \"smooth\"),\n\n\n\t//J2K boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_MJP2, video_sample_entry, \"stsd\", \"j2k\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2H, jp2h, \"mjp2 encv\", \"j2k\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_IHDR, ihdr, \"jp2h\", \"j2k\"),\n\n\t/* Image tracks */\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JPEG, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2K, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_PNG, video_sample_entry, \"stsd\", \"apple\"),\n\n\n\t//flac in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_FLAC, audio_sample_entry, \"stsd\", \"Flac\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DFLA, dfla, \"fLaC enca\", 0, \"Flac\"),\n\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_XTRA, xtra, \"udta\", \"WMA\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ST3D, st3d, \"video_sample_entry\", 0, \"youtube\"),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SV3D, def_parent, \"video_sample_entry\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVHD, svhd, \"sv3d\", 0, \"youtube\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PROJ, def_parent, \"sv3d\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PRHD, prhd, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CBMP, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EQUI, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MESH, proj_type, \"proj\", 0, \"youtube\"),\n\n/*\n\tGF_ISOM_BOX_TYPE_CBMP\t= GF_4CC( 'c', 'b', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_EQUI\t= GF_4CC( 'e', 'q', 'u', 'i' ),\n\tGF_ISOM_BOX_TYPE_MSHP\t= GF_4CC( 'm', 's', 'h', 'p' ),\n\tGF_ISOM_BOX_TYPE_MESH\t= GF_4CC( 'm', 'e', 's', 'h' ),\n*/\n\n};\n\nBool gf_box_valid_in_parent(GF_Box *a, const char *parent_4cc)\n{\n\tif (!a || !a->registry || !a->registry->parents_4cc) return GF_FALSE;\n\tif (strstr(a->registry->parents_4cc, parent_4cc) != NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_num_supported_boxes()\n{\n\treturn sizeof(box_registry) / sizeof(struct box_registry_entry);\n}\n\nvoid gf_isom_registry_disable(u32 boxCode, Bool disable)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tfor (i=1; i<count; i++) {\n\t\tif (box_registry[i].box_4cc==boxCode) {\n\t\t\tbox_registry[i].disabled = disable;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic u32 get_box_reg_idx(u32 boxCode, u32 parent_type, u32 start_from)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tconst char *parent_name = parent_type ? gf_4cc_to_str(parent_type) : NULL;\n\n\tif (!start_from) start_from = 1;\n\n\tfor (i=start_from; i<count; i++) {\n\t\tu32 start_par_from;\n\t\tif (box_registry[i].box_4cc != boxCode)\n\t\t\tcontinue;\n\n\t\tif (!parent_type)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, parent_name) != NULL)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, \"*\") != NULL)\n\t\t\treturn i;\n\n\t\tif (strstr(box_registry[i].parents_4cc, \"sample_entry\") == NULL)\n\t\t\tcontinue;\n\n\t\t/*parent is a sample entry, check if the parent_type matches a sample entry box (eg its parent must be stsd)*/\n\n\t\tif (parent_type==GF_QT_SUBTYPE_RAW)\n\t\t\treturn i;\n\n\t\tstart_par_from = 0;\n\t\twhile (parent_type) {\n\t\t\t//locate parent registry\n\t\t\tu32 j = get_box_reg_idx(parent_type, 0, start_par_from);\n\t\t\tif (!j) break;\n\t\t\t//if parent registry has \"stsd\" as parent, this is a sample entry\n\t\t\tif (box_registry[j].parents_4cc && (strstr(box_registry[j].parents_4cc, \"stsd\") != NULL))\n\t\t\t\treturn i;\n\t\t\tstart_par_from = j+1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_Box *gf_isom_box_new_ex(u32 boxType, u32 parentType, Bool skip_logs, Bool is_root_box)\n{\n\tGF_Box *a;\n\ts32 idx = get_box_reg_idx(boxType, parentType, 0);\n\tif (idx==0) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (!skip_logs && (boxType != GF_ISOM_BOX_TYPE_UNKNOWN) && (boxType != GF_ISOM_BOX_TYPE_UUID)) {\n\t\t\tswitch (parentType) {\n\t\t\tcase GF_ISOM_BOX_TYPE_ILST:\n\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tcase GF_ISOM_BOX_TYPE_iTunesSpecificInfo:\n\t\t\tcase GF_QT_BOX_TYPE_WAVE:\n\t\t\t\tbreak;\n\t\t\t//some sample descritions are handled as generic ones but we know them, don't warn\n\t\t\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\t\t\tif (boxType==GF_ISOM_SUBTYPE_FFV1) break;\n\t\t\t\t//fallthrough\n\t\t\tdefault:\n\t\t\t\tif (boxType==GF_ISOM_BOX_TYPE_GDAT) break;\n\n\t\t\t\tif (is_root_box) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown top-level box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t} else if (parentType) {\n\t\t\t\t\tchar szName[GF_4CC_MSIZE];\n\t\t\t\t\tstrcpy(szName, gf_4cc_to_str(parentType));\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s in parent %s\\n\", gf_4cc_to_str(boxType), szName));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n        if (boxType==GF_ISOM_BOX_TYPE_UUID) {\n            a = uuid_box_new();\n            if (a) a->registry = &box_registry[1];\n        } else {\n            a = unkn_box_new();\n            if (a) {\n            \t((GF_UnknownBox *)a)->original_4cc = boxType;\n            \ta->registry = &box_registry[0];\n\t\t\t}\n        }\n\t\treturn a;\n\t}\n\ta = box_registry[idx].new_fn();\n\n\tif (a) {\n\t\tif (a->type!=GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\t((GF_UnknownBox *)a)->original_4cc = boxType;\n\t\t\t} else {\n\t\t\t\ta->type = boxType;\n\t\t\t}\n\t\t}\n\t\ta->registry = &box_registry[idx];\n\n\t\tif ((a->type==GF_ISOM_BOX_TYPE_COLR) && (parentType==GF_ISOM_BOX_TYPE_JP2H)) {\n\t\t\t((GF_ColourInformationBox *)a)->is_jp2 = GF_TRUE;\n\t\t}\n\n\t}\n\treturn a;\n}\n\nGF_EXPORT\nGF_Box *gf_isom_box_new(u32 boxType)\n{\n\treturn gf_isom_box_new_ex(boxType, 0, 0, GF_FALSE);\n}\n\nGF_Err gf_isom_box_array_read(GF_Box *parent, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 parent_type = parent->type;\n\tGF_Box *a = NULL;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (parent->size>=8) {\n\t\te = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE, skip_logs ? 0 : parent->size);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn (e==GF_SKIP_BOX) ? GF_OK : e;\n\t\t}\n\t\t//sub box parsing aborted with no error\n\t\tif (!a) return GF_OK;\n\n\t\tif (parent->size < a->size) {\n\t\t\tif (!skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is larger than container box\\n\", gf_4cc_to_str(a->type)));\n\t\t\t}\n\t\t\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tparent->size = 0;\n\t\t} else {\n\t\t\tparent->size -= a->size;\n\t\t}\n\n\t\t//check container validity\n\t\tif (strlen(a->registry->parents_4cc)) {\n\t\t\tBool parent_OK = GF_FALSE;\n\t\t\tconst char *parent_code = gf_4cc_to_str(parent->type);\n\t\t\tif (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\tparent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );\n\t\t\tif (strstr(a->registry->parents_4cc, parent_code) != NULL) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else if (!strcmp(a->registry->parents_4cc, \"*\") || strstr(a->registry->parents_4cc, \"* \") || strstr(a->registry->parents_4cc, \" *\")) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else {\n\t\t\t\t//parent must be a sample entry\n\t\t\t\tif (strstr(a->registry->parents_4cc, \"sample_entry\") !=\tNULL) {\n\t\t\t\t\t//parent is in an stsd\n\t\t\t\t\tif (strstr(parent->registry->parents_4cc, \"stsd\") != NULL) {\n\t\t\t\t\t\tif (strstr(a->registry->parents_4cc, \"video_sample_entry\") !=\tNULL) {\n\t\t\t\t\t\t\tif (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;\n\t\t\t}\n\t\t\tif (! parent_OK && !skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is invalid in container %s\\n\", gf_4cc_to_str(a->type), parent_code));\n\t\t\t}\n\t\t}\n\n\t\t//always register boxes\n\t\tif (!parent->child_boxes) {\n\t\t\tparent->child_boxes = gf_list_new();\n\t\t\tif (!parent->child_boxes) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(parent->child_boxes, a);\n\t\tif (e) return e;\n\n\t\tif (parent->registry->add_rem_fn) {\n\t\t\te = parent->registry->add_rem_fn(parent, a, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tif (e == GF_ISOM_INVALID_MEDIA) return GF_OK;\n\t\t\t\t//if the box is no longer present, consider it destroyed\n\t\t\t\tif (gf_list_find(parent->child_boxes, a) >=0) {\n\t\t\t\t\tgf_isom_box_del_parent(&parent->child_boxes, a);\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\n\n\nGF_Err gf_isom_box_read(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->read_fn(a, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_box_write_listing(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Write invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->write_fn(a, bs);\n}\n\n\nvoid gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\n\t//happens when partially cloning boxes \n\tif (cur_pos < 0) return;\n\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;\n}\n\nvoid gf_isom_check_position_list(GF_Box *s, GF_List *childlist, u32 *pos)\n{\n\tu32 i, count;\n\tif (!s || (s->internal_flags & GF_ISOM_ORDER_FREEZE))\n\t\treturn;\n\tcount = gf_list_count(childlist);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *child = gf_list_get(childlist, i);\n\t\tgf_isom_check_position(s, child, pos);\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\t\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;\n}\n\nstatic GF_Err gf_isom_box_size_listing(GF_Box *a)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Size invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->size = 8;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\ta->size += 16;\n\t}\n\t//the large size is handled during write, cause at this stage we don't know the size\n\tif (a->registry->max_version_plus_one) {\n\t\ta->size += 4;\n\t}\n\treturn a->registry->size_fn(a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_size(GF_Box *a)\n{\n\tGF_Err e;\n\tif (!a) return GF_BAD_PARAM;\n\tif (a->registry->disabled) {\n\t\ta->size = 0;\n\t\treturn GF_OK;\n\t}\n\te = gf_isom_box_size_listing(a);\n\tif (e) return e;\n\t//box size set to 0 (not even a header), abort traversal\n\tif (!a->size) return GF_OK;\n\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_size(a, a->child_boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs)\n{\n\tif (ptr->registry->max_version_plus_one) {\n\t\tGF_FullBox *self = (GF_FullBox *) ptr;\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tself->version = gf_bs_read_u8(bs);\n\t\tself->flags = gf_bs_read_u24(bs);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_dump_supported_box(u32 idx, FILE * trace)\n{\n\tu32 i;\n\tu32 nb_versions=0;\n\tGF_Err e;\n\n\tif (box_registry[idx].max_version_plus_one) {\n\t\tnb_versions = box_registry[idx].max_version_plus_one - 1;\n\t}\n\tfor (i = 0; i <= nb_versions; i++) {\n\t\tGF_Box *a = box_registry[idx].new_fn();\n\t\tif (!a) return GF_OUT_OF_MEM;\n\n\t\ta->registry = &box_registry[idx];\n\n\t\tif (box_registry[idx].alt_4cc) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_REFT)\n\t\t\t\t((GF_TrackReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_REFI)\n\t\t\t\t((GF_ItemReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_TRGT)\n\t\t\t\t((GF_TrackGroupTypeBox*)a)->group_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_SGPD)\n\t\t\t\t((GF_SampleGroupDescriptionBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_GRPT)\n\t\t\t\t((GF_EntityToGroupTypeBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t}\n\t\tif (box_registry[idx].max_version_plus_one) {\n\t\t\t((GF_FullBox *)a)->version = i;\n\t\t}\n\t\tif (box_registry[idx].flags) {\n\t\t\tu32 flag_mask=1;\n\t\t\tu32 flags = box_registry[idx].flags;\n\t\t\t((GF_FullBox *)a)->flags = 0;\n\t\t\te = gf_isom_box_dump(a, trace);\n\n\t\t\t//we dump all flags individually and this for all version, in order to simplify the XSLT processing\n\t\t\twhile (!e) {\n\t\t\t\tu32 flag = flags & flag_mask;\n\t\t\t\tflag_mask <<= 1;\n\t\t\t\tif (flag) {\n\t\t\t\t\t((GF_FullBox *)a)->flags = flag;\n\t\t\t\t\te = gf_isom_box_dump(a, trace);\n\t\t\t\t}\n\t\t\t\tif (flag_mask > flags) break;\n\t\t\t\tif (flag_mask == 0x80000000) break;\n\t\t\t}\n\n\t\t} else {\n\t\t\te = gf_isom_box_dump(a, trace);\n\t\t}\n\n\t\tgf_isom_box_del(a);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nu32 gf_isom_get_supported_box_type(u32 idx)\n{\n\treturn box_registry[idx].box_4cc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\nGF_Err gf_isom_box_dump_start(GF_Box *a, const char *name, FILE * trace)\n{\n\tgf_fprintf(trace, \"<%s \", name);\n\tif (a->size > 0xFFFFFFFF) {\n\t\tgf_fprintf(trace, \"LargeSize=\\\"\"LLU\"\\\" \", a->size);\n\t} else {\n\t\tgf_fprintf(trace, \"Size=\\\"%u\\\" \", (u32) a->size);\n\t}\n\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(((GF_UnknownBox*)a)->original_4cc));\n\t} else {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(a->type));\n\t}\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tgf_fprintf(trace, \"UUID=\\\"{\");\n\t\tfor (i=0; i<16; i++) {\n\t\t\tgf_fprintf(trace, \"%02X\", (unsigned char) ((GF_UUIDBox*)a)->uuid[i]);\n\t\t\tif ((i<15) && (i%4)==3) gf_fprintf(trace, \"-\");\n\t\t}\n\t\tgf_fprintf(trace, \"}\\\" \");\n\t}\n\n\tif (a->registry->max_version_plus_one) {\n\t\tgf_fprintf(trace, \"Version=\\\"%d\\\" Flags=\\\"%d\\\" \", ((GF_FullBox*)a)->version,((GF_FullBox*)a)->flags);\n\t}\n\tgf_fprintf(trace, \"Specification=\\\"%s\\\" \", a->registry->spec);\n\n\t//don't write containers in test mode, that would require rewriting hashes whenever spec changes\n\tif (!gf_sys_is_test_mode()) {\n\t\tgf_fprintf(trace, \"Container=\\\"%s\\\" \", a->registry->parents_4cc);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace)\n{\n\tGF_Box *a = (GF_Box *) ptr;\n\n\tif (!a) {\n\t\tgf_fprintf(trace, \"<!--ERROR: NULL Box Found-->\\n\");\n\t\treturn GF_OK;\n\t}\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] trying to dump box %s not registered\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->registry->dump_fn(a, trace);\n\treturn GF_OK;\n}\n\nvoid gf_isom_box_dump_done(const char *name, GF_Box *ptr, FILE *trace)\n{\n\tif (ptr && ptr->child_boxes) {\n\t\tgf_isom_box_array_dump(ptr->child_boxes, trace);\n\t}\n\tif (name)\n\t\tgf_fprintf(trace, \"</%s>\\n\", name);\n}\n\nBool gf_isom_box_is_file_level(GF_Box *s)\n{\n\tif (!s || !s->registry) return GF_FALSE;\n\tif (strstr(s->registry->parents_4cc, \"file\")!= NULL) return GF_TRUE;\n\tif (strstr(s->registry->parents_4cc, \"*\")!= NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n#endif\n\n\nGF_Box *gf_isom_box_find_child(GF_List *children, u32 code)\n{\n\tu32 i, count;\n\tif (!children) return NULL;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c->type==code) return c;\n\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tif (((GF_UnknownBox*)c)->original_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (((GF_UUIDBox*)c)->internal_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nBool gf_isom_box_check_unique(GF_List *children, GF_Box *a)\n{\n\tu32 i, count;\n\tif (!children) return GF_TRUE;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c==a) continue;\n\t\tif (c->type==a->type) return GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\nvoid gf_isom_box_del_parent(GF_List **child_boxes, GF_Box*b)\n{\n\tif (child_boxes) {\n\t\tgf_list_del_item(*child_boxes, b);\n\t\tif (!gf_list_count(*child_boxes)) {\n\t\t\tgf_list_del(*child_boxes);\n\t\t\t*child_boxes = NULL;\n\t\t}\n\t}\n\tgf_isom_box_del(b);\n}\n\nvoid gf_isom_box_remove_from_parent(GF_Box *parent_box, GF_Box *box)\n{\n\tif (parent_box && parent_box->registry && parent_box->registry->add_rem_fn) {\n\t\tparent_box->registry->add_rem_fn(parent_box, box, GF_TRUE);\n\t}\n}\n\nGF_Box *gf_isom_box_new_parent(GF_List **parent, u32 code)\n{\n\tGF_Box *b = gf_isom_box_new(code);\n\tif (!b) return NULL;\n\tif (! (*parent) ) (*parent)  = gf_list_new();\n\tgf_list_add(*parent, b);\n\treturn b;\n}\n\nvoid gf_isom_box_freeze_order(GF_Box *box)\n{\n\tu32 i=0;\n\tGF_Box *child;\n\tif (!box) return;\n\tbox->internal_flags |= GF_ISOM_ORDER_FREEZE;\n\n\twhile ((child = gf_list_enum(box->child_boxes, &i))) {\n\t\tgf_isom_box_freeze_order(child);\n\t}\n\n}\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/network.h>\n#include <gpac/thread.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n/**************************************************************\n\t\tSome Local functions for movie creation\n**************************************************************/\nGF_Err gf_isom_parse_root_box(GF_Box **outBox, GF_BitStream *bs, u32 *boxType, u64 *bytesExpected, Bool progressive_mode);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err MergeFragment(GF_MovieFragmentBox *moof, GF_ISOFile *mov)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tu64 MaxDur;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrackBox *trak;\n\tu64 base_data_offset;\n\n\tMaxDur = 0;\n\n\t//we shall have a MOOV and its MVEX BEFORE any MOOF\n\tif (!mov->moov || !mov->moov->mvex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: %s not received before merging fragment\\n\", mov->moov ? \"mvex\" : \"moov\" ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//and all fragments should be continous but:\n\t//- dash with dependent representations may likely give R1(moofSN 1, 3, 5, 7) plus R2(moofSN 2, 4, 6, 8)\n\t//- smooth muxed in a single file may end up with V(1),A(1), V(2),A(2) ...\n\t//we do not throw an error if not as we may still want to be able to concatenate dependent representations in DASH and\n\tif (mov->NextMoofNumber && moof->mfhd && (mov->NextMoofNumber >= moof->mfhd->sequence_number)) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] wrong sequence number: got %d but last one was %d\\n\", moof->mfhd->sequence_number, mov->NextMoofNumber));\n\t}\n\n\tbase_data_offset = mov->current_top_box_start;\n\tif (moof->compressed_diff)\n\t\tbase_data_offset -= moof->compressed_diff;\n\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(moof->TrackList, &i))) {\n\t\tu32 prev_sample_count;\n\t\tif (!traf->tfhd) {\n\t\t\ttrak = NULL;\n\t\t\ttraf->trex = NULL;\n\t\t} else if (mov->is_smooth) {\n\t\t\ttrak = gf_list_get(mov->moov->trackList, 0);\n\t\t\ttraf->trex = (GF_TrackExtendsBox*)gf_list_get(mov->moov->mvex->TrackExList, 0);\n\t\t\tassert(traf->trex);\n\t\t\ttraf->trex->trackID = trak->Header->trackID = traf->tfhd->trackID;\n\t\t} else {\n\t\t\ttrak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\tj=0;\n\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) break;\n\t\t\t\ttraf->trex = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (!trak || !traf->trex) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: Cannot find fragment track with ID %d\\n\", traf->tfhd ? traf->tfhd->trackID : 0));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tprev_sample_count = trak->Media->information->sampleTable->SampleSize ? trak->Media->information->sampleTable->SampleSize->sampleCount : 0;\n\t\te = MergeTrack(trak, traf, moof, mov->current_top_box_start, moof->compressed_diff, &base_data_offset);\n\t\tif (e) return e;\n\t\ttrak->first_traf_merged = GF_TRUE;\n\n\t\ttrak->present_in_scalable_segment = 1;\n\n\t\t//update trak duration\n\t\tSetTrackDuration(trak);\n\t\tif (trak->Header->duration > MaxDur)\n\t\t\tMaxDur = trak->Header->duration;\n\n\t\t//we have PSSH per moov, internally remap as a sample group of type PSSH\n\t\tif (gf_list_count(moof->PSSHs)) {\n\t\t\tu8 *pssh_data;\n\t\t\tu32 pssh_len;\n\t\t\tu32 j, k, nb_pssh = gf_list_count(moof->PSSHs);\n\t\t\tGF_BitStream *pssh_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(pssh_bs, nb_pssh);\n\t\t\tfor (j=0; j<nb_pssh; j++) {\n\t\t\t\tGF_ProtectionSystemHeaderBox *pssh = gf_list_get(moof->PSSHs, j);\n\t\t\t\tgf_bs_write_data(pssh_bs, pssh->SystemID, 16);\n\t\t\t\tgf_bs_write_u32(pssh_bs, pssh->version);\n\t\t\t\tif (pssh->version) {\n\t\t\t\t\tgf_bs_write_u32(pssh_bs, pssh->KID_count);\n\t\t\t\t\tfor (k=0; k<pssh->KID_count; k++) {\n\t\t\t\t\t\tgf_bs_write_data(pssh_bs, pssh->KIDs[k], 16);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_u32(pssh_bs, pssh->private_data_size);\n\t\t\t\tgf_bs_write_data(pssh_bs, pssh->private_data, pssh->private_data_size);\n\t\t\t}\n\t\t\tgf_bs_get_content(pssh_bs, &pssh_data, &pssh_len);\n\t\t\tgf_bs_del(pssh_bs);\n\n\t\t\tgf_isom_set_sample_group_description_internal(mov, gf_list_find(mov->moov->trackList, trak)+1, 1+prev_sample_count, GF_4CC('P','S','S','H'), 0, pssh_data, pssh_len, GF_FALSE);\n\t\t\tgf_free(pssh_data);\n\t\t}\n\n\n\t\t//we have emsg, internally remap as a sample group of type EMSG\n\t\tif (gf_list_count(mov->emsgs)) {\n\t\t\tu8 *emsg_data;\n\t\t\tu32 emsg_len;\n\t\t\tu32 j, nb_emsg = gf_list_count(mov->emsgs);\n\t\t\tGF_BitStream *emsg_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tfor (j=0; j<nb_emsg; j++) {\n\t\t\t\tGF_Box *emsg = gf_list_get(mov->emsgs, j);\n\t\t\t\tgf_isom_box_write(emsg, emsg_bs);\n\t\t\t}\n\t\t\tgf_bs_get_content(emsg_bs, &emsg_data, &emsg_len);\n\t\t\tgf_bs_del(emsg_bs);\n\n\t\t\tgf_isom_set_sample_group_description_internal(mov, gf_list_find(mov->moov->trackList, trak)+1, 1+prev_sample_count, GF_4CC('E','M','S','G'), 0, emsg_data, emsg_len, GF_FALSE);\n\t\t\tgf_free(emsg_data);\n\t\t}\n\t}\n\tif (mov->emsgs) {\n\t\tgf_isom_box_array_del(mov->emsgs);\n\t\tmov->emsgs = NULL;\n\t}\n\n\tif (moof->child_boxes) {\n\t\tGF_Box *a;\n\t\ti = 0;\n\t\twhile ((a = (GF_Box *)gf_list_enum(moof->child_boxes, &i))) {\n\t\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(&mov->moov->child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\t\tif (!pssh) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->SystemID, ((GF_ProtectionSystemHeaderBox *)a)->SystemID, 16);\n\t\t\t\tif (((GF_ProtectionSystemHeaderBox *)a)->KIDs && ((GF_ProtectionSystemHeaderBox *)a)->KID_count > 0) {\n\t\t\t\t\tpssh->KID_count = ((GF_ProtectionSystemHeaderBox *)a)->KID_count;\n\t\t\t\t\tpssh->KIDs = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));\n\t\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tmemmove(pssh->KIDs, ((GF_ProtectionSystemHeaderBox *)a)->KIDs, pssh->KID_count*sizeof(bin128));\n\t\t\t\t}\n\t\t\t\tpssh->private_data_size = ((GF_ProtectionSystemHeaderBox *)a)->private_data_size;\n\t\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->private_data, ((GF_ProtectionSystemHeaderBox *)a)->private_data, pssh->private_data_size);\n\t\t\t\tpssh->moof_defined = 1;\n\t\t\t\tmov->has_pssh_moof = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tmov->NextMoofNumber = moof->mfhd ? moof->mfhd->sequence_number : 0;\n\t//update movie duration\n\tif (mov->moov->mvhd->duration < MaxDur) mov->moov->mvhd->duration = MaxDur;\n\treturn GF_OK;\n}\n\nstatic void FixTrackID(GF_ISOFile *mov)\n{\n\tif (!mov->moov) return;\n\n\tif (gf_list_count(mov->moov->trackList) == 1 && gf_list_count(mov->moof->TrackList) == 1) {\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox*)gf_list_get(mov->moof->TrackList, 0);\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(mov->moov->trackList, 0);\n\t\tif (!traf->tfhd || !trak->Header) return;\n\t\tif ((traf->tfhd->trackID != trak->Header->trackID)) {\n\t\t\tif (!mov->is_smooth) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: trackID of MOOF/TRAF(%u) is not the same as MOOV/TRAK(%u). Trying to fix.\\n\", traf->tfhd->trackID, trak->Header->trackID));\n\t\t\t} else {\n\t\t\t\ttrak->Header->trackID = traf->tfhd->trackID;\n\t\t\t}\n\t\t\ttraf->tfhd->trackID = trak->Header->trackID;\n\t\t}\n\t}\n}\n\nstatic void FixSDTPInTRAF(GF_MovieFragmentBox *moof)\n{\n\tu32 k;\n\tif (!moof)\n\t\treturn;\n\n\tfor (k = 0; k < gf_list_count(moof->TrackList); k++) {\n\t\tGF_TrackFragmentBox *traf = gf_list_get(moof->TrackList, k);\n\t\tif (traf->sdtp) {\n\t\t\tGF_TrackFragmentRunBox *trun;\n\t\t\tu32 j = 0, sample_index = 0;\n\n\t\t\tif (traf->sdtp->sampleCount == gf_list_count(traf->TrackRuns)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TRAF box of track id=%u contains a SDTP. Converting to TRUN sample flags.\\n\", traf->tfhd->trackID));\n\t\t\t}\n\n\t\t\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &j))) {\n\t\t\t\tu32 i;\n\t\t\t\ttrun->flags |= GF_ISOM_TRUN_FLAGS;\n\t\t\t\tfor (i=0; i<trun->nb_samples; i++) {\n\t\t\t\t\tGF_TrunEntry *entry = &trun->samples[i];\n\t\t\t\t\tconst u8 info = traf->sdtp->sample_info[sample_index];\n\t\t\t\t\tentry->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(info >> 6, info >> 4, info >> 2, info);\n\t\t\t\t\tsample_index++;\n\t\t\t\t\tif (sample_index > traf->sdtp->sampleCount) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: TRAF box of track id=%u contained an inconsistent SDTP.\\n\", traf->tfhd->trackID));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sample_index < traf->sdtp->sampleCount) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: TRAF box of track id=%u list less samples than SDTP.\\n\", traf->tfhd->trackID));\n\t\t\t}\n\t\t\tgf_isom_box_del_parent(&traf->child_boxes, (GF_Box*)traf->sdtp);\n\t\t\ttraf->sdtp = NULL;\n\t\t}\n\t}\n}\n\nvoid gf_isom_push_mdat_end(GF_ISOFile *mov, u64 mdat_end)\n{\n\tu32 i, count;\n\tif (!mov || !mov->moov) return;\n\n\tcount = gf_list_count(mov->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_TrafToSampleMap *traf_map;\n\t\tGF_TrackBox *trak = gf_list_get(mov->moov->trackList, i);\n\t\tif (!trak->Media->information->sampleTable->traf_map) continue;\n\n\t\ttraf_map = trak->Media->information->sampleTable->traf_map;\n\t\tfor (j=traf_map->nb_entries; j>0; j--) {\n\t\t\tif (!traf_map->frag_starts[j-1].mdat_end) {\n\t\t\t\ttraf_map->frag_starts[j-1].mdat_end = mdat_end;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifdef GF_ENABLE_CTRN\nstatic void gf_isom_setup_traf_inheritance(GF_ISOFile *mov)\n{\n\tu32 i, count;\n\tif (!mov->moov->mvex)\n\t\treturn;\n\tcount = gf_list_count(mov->moov->trackList);\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 refTrackNum=0;\n\t\tgf_isom_get_reference(mov, i+1, GF_ISOM_REF_TRIN, 1, &refTrackNum);\n\t\tif (refTrackNum) {\n\t\t\tGF_ISOTrackID tkid = gf_isom_get_track_id(mov, i+1);\n\t\t\tGF_ISOTrackID reftkid = gf_isom_get_track_id(mov, refTrackNum);\n\t\t\tGF_TrackExtendsBox *trex = GetTrex(mov->moov, tkid);\n\t\t\tif (trex) trex->inherit_from_traf_id = reftkid;\n\t\t}\n\t}\n}\n#endif\n\n#endif\n\n//for now we only use regular sample to group internally (except when dumping), not the pattern version\n//we unrill the pattern and replace the compact version with a regular one\nstatic void convert_compact_sample_groups(GF_List *child_boxes, GF_List *sampleGroups)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(sampleGroups); i++) {\n\t\tu32 j;\n\t\tGF_SampleGroupBox *sbgp;\n\t\tGF_CompactSampleGroupBox *csgp = gf_list_get(sampleGroups, i);\n\t\tif (csgp->type != GF_ISOM_BOX_TYPE_CSGP) continue;\n\n\t\tgf_list_rem(sampleGroups, i);\n\t\tgf_list_del_item(child_boxes, csgp);\n\n\t\tsbgp = (GF_SampleGroupBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SBGP);\n\t\tgf_list_insert(sampleGroups, sbgp, i);\n\t\tgf_list_add(child_boxes, sbgp);\n\t\ti--;\n\n\t\tsbgp->grouping_type = csgp->grouping_type;\n\t\tif (csgp->grouping_type_parameter) {\n\t\t\tsbgp->grouping_type_parameter = csgp->grouping_type_parameter;\n\t\t\tsbgp->version = 1;\n\t\t}\n\t\tsbgp->entry_count = 0;\n\t\tfor (j=0; j<csgp->pattern_count; j++) {\n\t\t\tu32 k=0;\n\t\t\tu32 nb_samples = csgp->patterns[j].sample_count;\n\t\t\t//unroll the pattern\n\t\t\twhile (nb_samples) {\n\t\t\t\tu32 nb_same_index=1;\n\t\t\t\tif (csgp->patterns[j].length<=k)\n\t\t\t\t\tbreak;\n\t\t\t\tu32 sg_idx = csgp->patterns[j].sample_group_description_indices[k];\n\t\t\t\twhile (nb_same_index+k<csgp->patterns[j].length) {\n\t\t\t\t\tif (csgp->patterns[j].sample_group_description_indices[k+nb_same_index] != sg_idx)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tnb_same_index++;\n\t\t\t\t}\n\t\t\t\tsbgp->sample_entries = gf_realloc(sbgp->sample_entries, sizeof(GF_SampleGroupEntry) * (sbgp->entry_count+1));\n\t\t\t\tif (nb_same_index>nb_samples)\n\t\t\t\t\tnb_same_index = nb_samples;\n\n\t\t\t\tsbgp->sample_entries[sbgp->entry_count].sample_count = nb_same_index;\n\t\t\t\tsbgp->sample_entries[sbgp->entry_count].group_description_index = sg_idx;\n\t\t\t\tnb_samples -= nb_same_index;\n\t\t\t\tsbgp->entry_count++;\n\t\t\t\tk+= nb_same_index;\n\t\t\t\tif (k==csgp->patterns[j].length)\n\t\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t\tgf_isom_box_del((GF_Box*)csgp);\n\t}\n}\n\n\nstatic GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Box *a;\n\tu64 totSize, mdat_end=0;\n\tGF_Err e = GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (mov->single_moof_mode && mov->single_moof_state == 2) {\n\t\treturn e;\n\t}\n\n\t/*restart from where we stopped last*/\n\ttotSize = mov->current_top_box_start;\n\tif (mov->bytes_removed) {\n\t\tassert(totSize >= mov->bytes_removed);\n\t\ttotSize -= mov->bytes_removed;\n\t}\n\tgf_bs_seek(mov->movieFileMap->bs, totSize);\n#endif\n\n\n\t/*while we have some data, parse our boxes*/\n\twhile (gf_bs_available(mov->movieFileMap->bs)) {\n\t\t*bytesMissing = 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Parsing a top-level box at position %d\\n\", mov->current_top_box_start));\n#endif\n\n\t\te = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);\n\n\t\tif (e >= 0) {\n\n\t\t} else if (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t\t/*our mdat is uncomplete, only valid for READ ONLY files...*/\n\t\t\tif (mov->openMode != GF_ISOM_OPEN_READ) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete MDAT while file is not read-only\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete file while reading for dump - aborting parsing\\n\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn e;\n\t\t} else {\n\t\t\treturn e;\n\t\t}\n\n\t\tswitch (a->type) {\n\t\t/*MOOV box*/\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tif (mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate MOOV detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->moov = (GF_MovieBox *)a;\n\t\t\tmov->original_moov_offset = mov->current_top_box_start;\n\t\t\t/*set our pointer to the movie*/\n\t\t\tmov->moov->mov = mov;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->moov->mvex) mov->moov->mvex->mov = mov;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tgf_isom_setup_traf_inheritance(mov);\n\t\t\t}\n#endif\n\n#endif\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\n\t\t\ttotSize += a->size;\n\n            if (!mov->moov->mvhd) {\n                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n                return GF_ISOM_INVALID_FILE;\n            }\n\n            if (mov->meta) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\n\t\t\t//dump senc info in dump mode\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\n\t\t\t\t\tif (trak->sample_encryption) {\n\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\t\t\t\t\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n            if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                gf_isom_push_mdat_end(mov, mdat_end);\n                mdat_end=0;\n            }\n\t\t\tbreak;\n\n\t\t/*META box*/\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tif (mov->meta) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate META detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->meta = (GF_MetaBox *)a;\n\t\t\tmov->original_meta_offset = mov->current_top_box_start;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\tbreak;\n\n\t\t/*we only keep the MDAT in READ for dump purposes*/\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tif (!mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->emsgs) {\n\t\t\t\tgf_isom_box_array_del(mov->emsgs);\n\t\t\t\tmov->emsgs = NULL;\n\t\t\t}\n#endif\n\n\t\t\tif (mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t\t\tif (!mov->mdat) {\n\t\t\t\t\tmov->mdat = (GF_MediaDataBox *) a;\n\t\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\telse if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);\n#endif\n\t\t\t\telse gf_isom_box_del(a); //in other modes we don't care\n\n\n\t\t\t\tif (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                    mdat_end = gf_bs_get_position(mov->movieFileMap->bs);\n                    if (mov->moov) {\n                        gf_isom_push_mdat_end(mov, mdat_end);\n                        mdat_end=0;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if we don't have any MDAT yet, create one (edit-write mode)\n\t\t\tWe only work with one mdat, but we're puting it at the place\n\t\t\tof the first mdat found when opening a file for editing*/\n\t\t\telse if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\tif (e) {\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->brand) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'ftyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->brand = (GF_FileTypeBox *)a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_OTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->otyp) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'otyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tmov->otyp = (GF_Box *)a;\n\t\t\t\ttotSize += a->size;\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\tGF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);\n\t\t\t\tif (brand) {\n\t\t\t\t\ts32 pos;\n\t\t\t\t\tgf_list_del_item(a->child_boxes, brand);\n\t\t\t\t\tpos = gf_list_del_item(mov->TopBoxes, mov->brand);\n\t\t\t\t\tgf_isom_box_del((GF_Box *) mov->brand);\n\t\t\t\t\tmov->brand = brand;\n\t\t\t\t\tif (pos<0) pos=0;\n\t\t\t\t\tgf_list_insert(mov->TopBoxes, brand, pos);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t/*ONE AND ONLY ONE PDIN*/\n\t\t\tif (mov->pdin) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'pdin'' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->pdin = (GF_ProgressiveDownloadBox *) a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\t{\n\t\t\tu32 brand = ((GF_FileTypeBox *)a)->majorBrand;\n\t\t\tswitch (brand) {\n\t\t\tcase GF_ISOM_BRAND_SISX:\n\t\t\tcase GF_ISOM_BRAND_RISX:\n\t\t\tcase GF_ISOM_BRAND_SSSS:\n\t\t\t\tmov->is_index_segment = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*fall-through*/\n\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\t\tif (mov->moov && !mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)\n\t\t\t) {\n\t\t\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t\t\tif (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);\n\t\t\t\t\tmov->root_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\t\tmov->sidx_start_offset = mov->current_top_box_start;\n\t\t\t\t\tmov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);\n\n\t\t\t\t}\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_STYP) {\n\t\t\t\t\tmov->styp_start_offset = mov->current_top_box_start;\n\n\t\t\t\t\tif (mov->seg_styp) gf_isom_box_del(mov->seg_styp);\n\t\t\t\t\tmov->seg_styp = a;\n\t\t\t\t} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t\t\tif (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);\n\t\t\t\t\tmov->seg_ssix = a;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t\tgf_isom_push_mdat_end(mov, mov->current_top_box_start);\n\t\t\t} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {\n\t\t\t\tif (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);\n\t\t\t\tmov->main_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\tmov->main_sidx_end_pos = mov->current_top_box_start + a->size;\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n\t\t\t//no support for inplace rewrite for fragmented files\n\t\t\tgf_isom_disable_inplace_rewrite(mov);\n\t\t\tif (!mov->moov) {\n\t\t\t\tGF_LOG(mov->moof ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\\n\"));\n\t\t\t}\n\t\t\tif (mov->single_moof_mode) {\n\t\t\t\tmov->single_moof_state++;\n\t\t\t\tif (mov->single_moof_state > 1) {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t\t((GF_MovieFragmentBox *)a)->mov = mov;\n\n\t\t\ttotSize += a->size;\n\t\t\tmov->moof = (GF_MovieFragmentBox *) a;\n\n\t\t\t/*some smooth streaming streams contain a SDTP under the TRAF: this is incorrect, convert it*/\n\t\t\tFixTrackID(mov);\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tFixSDTPInTRAF(mov->moof);\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\tif (traf->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*read & debug: store at root level*/\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tgf_list_add(mov->TopBoxes, a);\n\t\t\t\t/*also update pointers to trex for debug*/\n\t\t\t\tif (mov->moov) {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tu32 j=0;\n\t\t\t\t\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\t\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) {\n\t\t\t\t\t\t\t\t\tif (!traf->trex->track) traf->trex->track = trak;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttraf->trex = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we should only parse senc/psec when no saiz/saio is present, otherwise we fetch the info directly\n\t\t\t\t\t\tif (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tif (trak) {\n\t\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\t\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->sample_encryption) {\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {\n\t\t\t\tmov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;\n\t\t\t\tmov->moof = NULL;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\t/*merge all info*/\n\t\t\t\te = MergeFragment((GF_MovieFragmentBox *)a, mov);\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\t//done with moov\n\t\t\tif (mov->root_sidx) {\n\t\t\t\tgf_isom_box_del((GF_Box *) mov->root_sidx);\n\t\t\t\tmov->root_sidx = NULL;\n\t\t\t}\n\t\t\tif (mov->root_ssix) {\n\t\t\t\tgf_isom_box_del(mov->seg_ssix);\n\t\t\t\tmov->root_ssix = NULL;\n\t\t\t}\n\t\t\tif (mov->seg_styp) {\n\t\t\t\tgf_isom_box_del(mov->seg_styp);\n\t\t\t\tmov->seg_styp = NULL;\n\t\t\t}\n\t\t\tmov->sidx_start_offset = 0;\n\t\t\tmov->sidx_end_offset = 0;\n\t\t\tmov->styp_start_offset = 0;\n\t\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t{\n\t\t\tGF_UnknownBox *box = (GF_UnknownBox*)a;\n\t\t\tif (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {\n\t\t\t\tu8 *c = (u8 *) box->data;\n\t\t\t\tif ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))\n\t\t\t\t\tmov->is_jp2 = 1;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PRFT:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\t//keep the last one read\n\t\t\t\tif (mov->last_producer_ref_time)\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\telse\n\t\t\t\t\tmov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t//fallthrough\n\t\tcase GF_ISOM_BOX_TYPE_EMSG:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tif (!mov->emsgs) mov->emsgs = gf_list_new();\n\t\t\t\tgf_list_add(mov->emsgs, a);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_MFRA:\n\t\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\t\t//only keep for dump mode, otherwise we ignore these boxes and we don't want to carry them over in non-fragmented file\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\ttotSize += a->size;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*remember where we left, in case we append an entire number of movie fragments*/\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n#endif\n\t}\n\n\t/*we need at least moov or meta*/\n\tif (!mov->moov && !mov->meta\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t        && !mov->moof && !mov->is_index_segment\n#endif\n\t   ) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\t/*we MUST have movie header*/\n\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\tif (mov->moov && !mov->moov->mvhd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MVHD in MOOV!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t/*we MUST have meta handler*/\n\t\tif (mov->meta && !mov->meta->handler) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing handler in META!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tif (mov->moov) {\n\t\t/*set the default interleaving time*/\n\t\tmov->interleavingTime = mov->moov->mvhd->timeScale;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*in edit mode with successfully loaded fragments, delete all fragment signaling since\n\t\tfile is no longer fragmented*/\n\t\tif ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);\n\t\t\tmov->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t}\n\n\t//create a default mdat if none was found\n\tif (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\tif (e) return e;\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn GF_OK;\n}\n\nextern u64 unused_bytes;\n\nGF_Err gf_isom_parse_movie_boxes(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Err e;\n\tGF_Blob *blob = NULL;\n\n\t//if associated file is a blob, lock blob before parsing !\n\tif (mov->movieFileMap && ((mov->movieFileMap->type == GF_ISOM_DATA_MEM) || (mov->movieFileMap->type == GF_ISOM_DATA_FILE))) {\n\t\tblob = ((GF_FileDataMap *)mov->movieFileMap)->blob;\n\t}\n\n\tif (blob)\n\t\tgf_mx_p(blob->mx);\n\n\tunused_bytes = 0;\n\te = gf_isom_parse_movie_boxes_internal(mov, boxType, bytesMissing, progressive_mode);\n\n\tif (blob)\n\t\tgf_mx_v(blob->mx);\n\treturn e;\n\n}\n\nGF_ISOFile *gf_isom_new_movie()\n{\n\tGF_ISOFile *mov = (GF_ISOFile*)gf_malloc(sizeof(GF_ISOFile));\n\tif (mov == NULL) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\treturn NULL;\n\t}\n\tmemset(mov, 0, sizeof(GF_ISOFile));\n\n\t/*init the boxes*/\n\tmov->TopBoxes = gf_list_new();\n\tif (!mov->TopBoxes) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\tgf_free(mov);\n\t\treturn NULL;\n\t}\n\n\t/*default storage mode is flat*/\n\tmov->storageMode = GF_ISOM_STORE_FLAT;\n\tmov->es_id_default_sync = -1;\n\treturn mov;\n}\n\n//Create and parse the movie for READ - EDIT only\nGF_ISOFile *gf_isom_open_file(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_Err e;\n\tu64 bytes;\n\tGF_ISOFile *mov = gf_isom_new_movie();\n\tif (!mov || !fileName) return NULL;\n\n\tmov->fileName = gf_strdup(fileName);\n\tmov->openMode = OpenMode;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (OpenMode==GF_ISOM_OPEN_READ_DUMP)\n\t\tmov->store_traf_map = GF_TRUE;\n#endif\n\n\tif ( (OpenMode == GF_ISOM_OPEN_READ) || (OpenMode == GF_ISOM_OPEN_READ_DUMP) || (OpenMode == GF_ISOM_OPEN_READ_EDIT) ) {\n\t\tif (OpenMode == GF_ISOM_OPEN_READ_EDIT) {\n\t\t\tmov->openMode = GF_ISOM_OPEN_READ_EDIT;\n\n\t\t\t// create a memory edit map in case we add samples, typically during import\n\t\t\te = gf_isom_datamap_new(NULL, tmp_dir, GF_ISOM_DATA_MAP_WRITE, & mov->editFileMap);\n\t\t\tif (e) {\n\t\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\t\tgf_isom_delete_movie(mov);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tmov->openMode = GF_ISOM_OPEN_READ;\n\t\t}\n\t\tmov->es_id_default_sync = -1;\n\t\t//for open, we do it the regular way and let the GF_DataMap assign the appropriate struct\n\t\t//this can be FILE (the only one supported...) as well as remote\n\t\t//(HTTP, ...),not suported yet\n\t\t//the bitstream IS PART OF the GF_DataMap\n\t\t//as this is read-only, use a FileMapping. this is the only place where\n\t\t//we use file mapping\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &mov->movieFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (OpenMode == GF_ISOM_OPEN_READ_DUMP) {\n\t\t\tmov->FragmentsFlags |= GF_ISOM_FRAG_READ_DEBUG;\n\t\t}\n\t} else {\n\n#ifdef GPAC_DISABLE_ISOM_WRITE\n\t\t//not allowed for READ_ONLY lib\n\t\tgf_isom_delete_movie(mov);\n\t\tgf_isom_set_last_error(NULL, GF_ISOM_INVALID_MODE);\n\t\treturn NULL;\n\n#else\n\n\t\t//set a default output name for edited file\n\t\tmov->finalName = (char*)gf_malloc(strlen(fileName) + 5);\n\t\tif (!mov->finalName) {\n\t\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcpy(mov->finalName, \"out_\");\n\t\tstrcat(mov->finalName, fileName);\n\n\t\t//open the original file with edit tag\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_EDIT, &mov->movieFileMap);\n\t\t//if the file doesn't exist, we assume it's wanted and create one from scratch\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\t//and create a temp fileName for the edit\n\t\te = gf_isom_datamap_new(\"_gpac_isobmff_tmp_edit\", tmp_dir, GF_ISOM_DATA_MAP_WRITE, & mov->editFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmov->es_id_default_sync = -1;\n\n#endif\n\t}\n\n\t//OK, let's parse the movie...\n\tmov->LastError = gf_isom_parse_movie_boxes(mov, NULL, &bytes, 0);\n\n#if 0\n\tif (!mov->LastError && (OpenMode == GF_ISOM_OPEN_CAT_FRAGMENTS)) {\n\t\tgf_isom_datamap_del(mov->movieFileMap);\n\t\t/*reopen the movie file map in cat mode*/\n\t\tmov->LastError = gf_isom_datamap_new(fileName, tmp_dir, GF_ISOM_DATA_MAP_CAT, & mov->movieFileMap);\n\t}\n#endif\n\n\tif (mov->LastError) {\n\t\tgf_isom_set_last_error(NULL, mov->LastError);\n\t\tgf_isom_delete_movie(mov);\n\t\treturn NULL;\n\t}\n\n\tmov->nb_box_init_seg = gf_list_count(mov->TopBoxes);\n\treturn mov;\n}\n\nGF_Err gf_isom_set_write_callback(GF_ISOFile *mov,\n \t\t\tGF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size),\n\t\t\tGF_Err (*on_block_patch)(void *usr_data, u8 *block, u32 block_size, u64 block_offset, Bool is_insert),\n \t\t\tvoid *usr_data,\n \t\t\tu32 block_size)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->finalName && !strcmp(mov->finalName, \"_gpac_isobmff_redirect\")) {}\n\telse if (mov->fileName && !strcmp(mov->fileName, \"_gpac_isobmff_redirect\")) {}\n\telse return GF_BAD_PARAM;\n\tmov->on_block_out = on_block_out;\n\tmov->on_block_patch = on_block_patch;\n\tmov->on_block_out_usr_data = usr_data;\n\tmov->on_block_out_block_size = block_size;\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n\nu64 gf_isom_get_mp4time()\n{\n\tu32 calctime, msec;\n\tu64 ret;\n\tgf_utc_time_since_1970(&calctime, &msec);\n\tcalctime += GF_ISOM_MAC_TIME_OFFSET;\n\tret = calctime;\n\treturn ret;\n}\n\nvoid gf_isom_delete_movie(GF_ISOFile *mov)\n{\n\tif (!mov) return;\n\n\t//these are our two main files\n\tif (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->editFileMap) {\n\t\tgf_isom_datamap_del(mov->editFileMap);\n\t}\n\tif (mov->finalName) gf_free(mov->finalName);\n#endif\n\n\tgf_isom_box_array_del(mov->TopBoxes);\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_box_array_del(mov->moof_list);\n\tif (mov->mfra)\n\t\tgf_isom_box_del((GF_Box*)mov->mfra);\n\tif (mov->sidx_pts_store)\n\t\tgf_free(mov->sidx_pts_store);\n\tif (mov->sidx_pts_next_store)\n\t\tgf_free(mov->sidx_pts_next_store);\n\n\tif (mov->main_sidx)\n\t\tgf_isom_box_del((GF_Box*)mov->main_sidx);\n\n\tif (mov->block_buffer)\n\t\tgf_free(mov->block_buffer);\n#endif\n\tif (mov->last_producer_ref_time)\n\t\tgf_isom_box_del((GF_Box *) mov->last_producer_ref_time);\n\tif (mov->fileName) gf_free(mov->fileName);\n\tgf_free(mov);\n}\n\nGF_TrackBox *gf_isom_get_track_from_id(GF_MovieBox *moov, GF_ISOTrackID trackID)\n{\n\tu32 i, count;\n\tif (!moov || !trackID) return NULL;\n\n\tcount = gf_list_count(moov->trackList);\n\tfor (i = 0; i<count; i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(moov->trackList, i);\n\t\tif (trak->Header->trackID == trackID) return trak;\n\t}\n\treturn NULL;\n}\n\nGF_TrackBox *gf_isom_get_track_from_original_id(GF_MovieBox *moov, u32 originalID, u32 originalFile)\n{\n\tu32 i, count;\n\tif (!moov || !originalID) return NULL;\n\n\tcount = gf_list_count(moov->trackList);\n\tfor (i = 0; i<count; i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(moov->trackList, i);\n\t\tif ((trak->originalFile == originalFile) && (trak->originalID == originalID)) return trak;\n\t}\n\treturn NULL;\n}\n\nGF_TrackBox *gf_isom_get_track_from_file(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return NULL;\n\ttrak = gf_isom_get_track(movie->moov, trackNumber);\n\tif (!trak) movie->LastError = GF_BAD_PARAM;\n\treturn trak;\n}\n\n\n//WARNING: MOVIETIME IS EXPRESSED IN MEDIA TS\nGF_Err GetMediaTime(GF_TrackBox *trak, Bool force_non_empty, u64 movieTime, u64 *MediaTime, s64 *SegmentStartTime, s64 *MediaOffset, u8 *useEdit, u64 *next_edit_start_plus_one)\n{\n#if 0\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber;\n\tu64 firstDTS;\n#endif\n\tu32 i, count;\n\tBool last_is_empty = 0;\n\tu64 time, lastSampleTime;\n\ts64 mtime;\n\tGF_EdtsEntry *ent;\n\tDouble scale_ts;\n\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\tif (next_edit_start_plus_one) *next_edit_start_plus_one = 0;\n\t*useEdit = 1;\n\t*MediaTime = 0;\n\t//no segment yet...\n\t*SegmentStartTime = -1;\n\t*MediaOffset = -1;\n\tif (!trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale || !stbl->SampleSize) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//no samples...\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tlastSampleTime = 0;\n\t} else {\n\t\tlastSampleTime = trak->Media->mediaHeader->duration;\n\t}\n\n\t//No edits, 1 to 1 mapping\n\tif (! trak->editBox || !trak->editBox->editList) {\n\t\t*MediaTime = movieTime;\n\t\t//check this is in our media time line\n\t\tif ((*MediaTime > lastSampleTime)\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t        && !trak->moov->mov->moof\n#endif\n\t\t   ) {\n\t\t\t*MediaTime = lastSampleTime;\n\t\t}\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\t//browse the edit list and get the time\n\tscale_ts = trak->Media->mediaHeader->timeScale;\n\tscale_ts /= trak->moov->mvhd->timeScale;\n\n\ttime = 0;\n\tent = NULL;\n\tcount=gf_list_count(trak->editBox->editList->entryList);\n\tfor (i=0; i<count; i++) {\n\t\tent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, i);\n\t\tif ( (time + ent->segmentDuration) * scale_ts > movieTime) {\n\t\t\tif (!force_non_empty || (ent->mediaTime >= 0)) {\n\t\t\t\tif (next_edit_start_plus_one) *next_edit_start_plus_one = 1 + (u64) ((time + ent->segmentDuration) * scale_ts);\n\t\t\t\tgoto ent_found;\n\t\t\t}\n\t\t}\n\t\ttime += ent->segmentDuration;\n\t\tlast_is_empty = ent->segmentDuration ? 0 : 1;\n\t}\n\n\tif (last_is_empty) {\n\t\tent = (GF_EdtsEntry *)gf_list_last(trak->editBox->editList->entryList);\n\t\tif (ent->mediaRate == 0x10000) {\n\t\t\t*MediaTime = movieTime + ent->mediaTime;\n\t\t} else {\n\t\t\tent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, 0);\n\t\t\tif (ent->mediaRate == -0x10000) {\n\t\t\t\tu64 dur = (u64) (ent->segmentDuration * scale_ts);\n\t\t\t\t*MediaTime = (movieTime > dur) ? (movieTime-dur) : 0;\n\t\t\t}\n\t\t}\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\n\n\t//we had nothing in the list (strange file but compliant...)\n\t//return the 1 to 1 mapped vale of the last media sample\n\tif (!ent) {\n\t\t*MediaTime = movieTime;\n\t\t//check this is in our media time line\n\t\tif (*MediaTime > lastSampleTime) *MediaTime = lastSampleTime;\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\t//request for a bigger time that what we can give: return the last sample (undefined behavior...)\n\t*MediaTime = lastSampleTime;\n\treturn GF_OK;\n\nent_found:\n\t//OK, we found our entry, set the SegmentTime\n\t*SegmentStartTime = time;\n\n\t//we request an empty list, there's no media here...\n\tif (ent->mediaTime < 0) {\n\t\t*MediaTime = 0;\n\t\treturn GF_OK;\n\t}\n\t//we request a dwell edit\n\tif (! ent->mediaRate) {\n\t\t*MediaTime = ent->mediaTime;\n\t\t//no media offset\n\t\t*MediaOffset = 0;\n\t\t*useEdit = 2;\n\t\treturn GF_OK;\n\t}\n\n\t/*WARNING: this can be \"-1\" when doing searchForward mode (to prevent jumping to next entry)*/\n\tmtime = ent->mediaTime + movieTime - (time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale);\n\tif (mtime<0) mtime = 0;\n\t*MediaTime = (u64) mtime;\n\t*MediaOffset = ent->mediaTime;\n\n#if 0\n\t//\n\t//Sanity check: is the requested time valid ? This is to cope with wrong EditLists\n\t//we have the translated time, but we need to make sure we have a sample at this time ...\n\t//we have to find a COMPOSITION time\n\te = stbl_findEntryForTime(stbl, (u32) *MediaTime, 1, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//first case: our time is after the last sample DTS (it's a broken editList somehow)\n\t//set the media time to the last sample\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t*MediaTime = lastSampleTime;\n\t\treturn GF_OK;\n\t}\n\t//get the appropriated sample\n\tif (!sampleNumber) sampleNumber = prevSampleNumber;\n\n\tstbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\tCTS = 0;\n\tif (stbl->CompositionOffset) stbl_GetSampleCTS(stbl->CompositionOffset, sampleNumber, &CTS);\n\n\t//now get the entry sample (the entry time gives the CTS, and we need the DTS\n\te = stbl_findEntryForTime(stbl, (u32) ent->mediaTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//oops, the mediaTime indicates a sample that is not in our media !\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t*MediaTime = lastSampleTime;\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!sampleNumber) sampleNumber = prevSampleNumber;\n\n\tstbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &firstDTS);\n\n\t//and store the \"time offset\" of the desired sample in this segment\n\t//this is weird, used to rebuild the timeStamp when reading from the track, not the\n\t//media ...\n\t*MediaOffset = firstDTS;\n#endif\n\treturn GF_OK;\n}\n\nGF_Err GetNextMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime)\n{\n\tu32 i;\n\tu64 time;\n\tGF_EdtsEntry *ent;\n\n\t*OutMovieTime = 0;\n\tif (! trak->editBox || !trak->editBox->editList) return GF_BAD_PARAM;\n\n\ttime = 0;\n\tent = NULL;\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\tif (gf_timestamp_greater_or_equal(time, trak->moov->mvhd->timeScale, movieTime, trak->Media->mediaHeader->timeScale)) {\n\t\t\t/*skip empty edits*/\n\t\t\tif (ent->mediaTime >= 0) {\n\t\t\t\t*OutMovieTime = time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale;\n\t\t\t\tif (*OutMovieTime>0) *OutMovieTime -= 1;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\ttime += ent->segmentDuration;\n\t}\n\t//request for a bigger time that what we can give: return the last sample (undefined behavior...)\n\t*OutMovieTime = trak->moov->mvhd->duration;\n\treturn GF_EOS;\n}\n\nGF_Err GetPrevMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime)\n{\n\tu32 i;\n\tu64 time;\n\tGF_EdtsEntry *ent;\n\n\t*OutMovieTime = 0;\n\tif (! trak->editBox || !trak->editBox->editList) return GF_BAD_PARAM;\n\n\ttime = 0;\n\tent = NULL;\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\tif (ent->mediaTime == -1) {\n\t\t\tif ( gf_timestamp_greater_or_equal(time + ent->segmentDuration, trak->moov->mvhd->timeScale, movieTime, trak->Media->mediaHeader->timeScale)) {\n\t\t\t\t*OutMovieTime = gf_timestamp_rescale(time, trak->moov->mvhd->timeScale, trak->Media->mediaHeader->timeScale);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/*get the first entry whose end is greater than or equal to the desired time*/\n\t\ttime += ent->segmentDuration;\n\t\tif (gf_timestamp_greater_or_equal(time, trak->moov->mvhd->timeScale, movieTime, trak->Media->mediaHeader->timeScale)) {\n\t\t\t*OutMovieTime = time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t*OutMovieTime = 0;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_insert_moov(GF_ISOFile *file)\n{\n\tGF_MovieHeaderBox *mvhd;\n\tif (file->moov) return GF_OK;\n\n\t//OK, create our boxes (mvhd, iods, ...)\n\tfile->moov = (GF_MovieBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOV);\n\tif (!file->moov) return GF_OUT_OF_MEM;\n\tfile->moov->mov = file;\n\t//Header SetUp\n\tmvhd = (GF_MovieHeaderBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVHD);\n\tif (!mvhd) return GF_OUT_OF_MEM;\n\n\tif (gf_sys_is_test_mode() ) {\n\t\tmvhd->creationTime = mvhd->modificationTime = 0;\n\t} else {\n\t\tu64 now = gf_isom_get_mp4time();\n\t\tmvhd->creationTime = now;\n\t\tif (!file->keep_utc)\n\t\t\tmvhd->modificationTime = now;\n\t}\n\n\tmvhd->nextTrackID = 1;\n\t//600 is our default movie TimeScale\n\tmvhd->timeScale = 600;\n\n\tfile->interleavingTime = mvhd->timeScale;\n\tmoov_on_child_box((GF_Box*)file->moov, (GF_Box *)mvhd, GF_FALSE);\n\tgf_list_add(file->TopBoxes, file->moov);\n\treturn GF_OK;\n}\n\n//Create the movie for WRITE only\nGF_ISOFile *gf_isom_create_movie(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_Err e;\n\n\tGF_ISOFile *mov = gf_isom_new_movie();\n\tif (!mov) return NULL;\n\tmov->openMode = OpenMode;\n\t//then set up our movie\n\n\t//in WRITE, the input dataMap is ALWAYS NULL\n\tmov->movieFileMap = NULL;\n\n\t//but we have the edit one\n\tif (OpenMode == GF_ISOM_OPEN_WRITE) {\n\t\tconst char *ext;\n\t\t//THIS IS NOT A TEMP FILE, WRITE mode is used for \"live capture\"\n\t\t//this file will be the final file...\n\t\tmov->fileName = fileName ? gf_strdup(fileName) : NULL;\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_WRITE, &mov->editFileMap);\n\t\tif (e) goto err_exit;\n\n\t\t/*brand is set to ISOM or QT by default - it may be touched until sample data is added to track*/\n\t\text = gf_file_ext_start(fileName);\n\t\tif (ext && (!strnicmp(ext, \".mov\", 4) || !strnicmp(ext, \".qt\", 3))) {\n\t\t\tgf_isom_set_brand_info((GF_ISOFile *) mov, GF_ISOM_BRAND_QT, 512);\n\t\t} else {\n\t\t\tgf_isom_set_brand_info((GF_ISOFile *) mov, GF_ISOM_BRAND_ISOM, 1);\n\t\t}\n\t} else {\n\t\t//we are in EDIT mode but we are creating the file -> temp file\n\t\tmov->finalName = fileName ? gf_strdup(fileName) : NULL;\n\t\te = gf_isom_datamap_new(\"_gpac_isobmff_tmp_edit\", tmp_dir, GF_ISOM_DATA_MAP_WRITE, &mov->editFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\t//brand is set to ISOM by default\n\t\tgf_isom_set_brand_info( (GF_ISOFile *) mov, GF_ISOM_BRAND_ISOM, 1);\n\t}\n\n\t//create an MDAT\n\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\tif (!mov->mdat) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\tgf_isom_delete_movie(mov);\n\t\treturn NULL;\n\t}\n\tgf_list_add(mov->TopBoxes, mov->mdat);\n\n\t//default behavior is capture mode, no interleaving (eg, no rewrite of mdat)\n\tmov->storageMode = GF_ISOM_STORE_FLAT;\n\treturn mov;\n\nerr_exit:\n\tgf_isom_set_last_error(NULL, e);\n\tif (mov) gf_isom_delete_movie(mov);\n\treturn NULL;\n}\n\nGF_EdtsEntry *CreateEditEntry(u64 EditDuration, u64 MediaTime, u32 MediaRate, u8 EditMode)\n{\n\tGF_EdtsEntry *ent;\n\n\tent = (GF_EdtsEntry*)gf_malloc(sizeof(GF_EdtsEntry));\n\tif (!ent) return NULL;\n\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = MediaRate;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\tent->segmentDuration = EditDuration;\n\treturn ent;\n}\n\nGF_Err gf_isom_add_subsample_info(GF_SubSampleInformationBox *sub_samples, u32 sampleNumber, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count, last_sample;\n\tGF_SubSampleInfoEntry *pSamp;\n\tGF_SubSampleEntry *pSubSamp;\n\n\tpSamp = NULL;\n\tlast_sample = 0;\n\tcount = gf_list_count(sub_samples->Samples);\n\tfor (i=0; i<count; i++) {\n\t\tpSamp = (GF_SubSampleInfoEntry*) gf_list_get(sub_samples->Samples, i);\n\t\t/*TODO - do we need to support insertion of subsample info ?*/\n\t\tif (last_sample + pSamp->sample_delta > sampleNumber) return GF_NOT_SUPPORTED;\n\t\tif (last_sample + pSamp->sample_delta == sampleNumber) break;\n\t\tlast_sample += pSamp->sample_delta;\n\t\tpSamp = NULL;\n\t}\n\n\tif (!pSamp) {\n\t\tGF_SAFEALLOC(pSamp, GF_SubSampleInfoEntry);\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tif (!pSamp->SubSamples ) {\n\t\t\tgf_free(pSamp);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tpSamp->sample_delta = sampleNumber - last_sample;\n\t\tgf_list_add(sub_samples->Samples, pSamp);\n\t}\n\n\tif ((subSampleSize>0xFFFF) && !sub_samples->version) {\n\t\tsub_samples->version = 1;\n\t}\n\t/*remove last subsample info*/\n\tif (!subSampleSize) {\n\t\tpSubSamp = gf_list_last(pSamp->SubSamples);\n\t\tgf_list_rem_last(pSamp->SubSamples);\n\t\tgf_free(pSubSamp);\n\t\tif (!gf_list_count(pSamp->SubSamples)) {\n\t\t\tgf_list_del_item(sub_samples->Samples, pSamp);\n\t\t\tgf_list_del(pSamp->SubSamples);\n\t\t\tgf_free(pSamp);\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t/*add subsample*/\n\tGF_SAFEALLOC(pSubSamp, GF_SubSampleEntry);\n\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\tpSubSamp->subsample_size = subSampleSize;\n\tpSubSamp->subsample_priority = priority;\n\tpSubSamp->reserved = reserved;\n\tpSubSamp->discardable = discardable;\n\treturn gf_list_add(pSamp->SubSamples, pSubSamp);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#if 0 //unused\nu32 gf_isom_sample_get_subsamples_count(GF_ISOFile *movie, u32 track)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!track) return 0;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return 0;\n\treturn gf_list_count(trak->Media->information->sampleTable->sub_samples);\n}\n#endif\n\nBool gf_isom_get_subsample_types(GF_ISOFile *movie, u32 track, u32 subs_index, u32 *flags)\n{\n\tGF_SubSampleInformationBox *sub_samples=NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\n\tif (!track || !subs_index) return GF_FALSE;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return GF_FALSE;\n\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, subs_index-1);\n\tif (!sub_samples) return GF_FALSE;\n\t*flags = sub_samples->flags;\n\treturn GF_TRUE;\n}\n\nu32 gf_isom_sample_get_subsample_entry(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, GF_SubSampleInfoEntry **sub_sample)\n{\n\tu32 i, count, last_sample;\n\tGF_SubSampleInformationBox *sub_samples=NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (sub_sample) *sub_sample = NULL;\n\tif (!track) return 0;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\t\tif (sub_samples->flags==flags) break;\n\t\tsub_samples = NULL;\n\t}\n\tif (!sub_samples) return 0;\n\n\tlast_sample = 0;\n\tcount = gf_list_count(sub_samples->Samples);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry *) gf_list_get(sub_samples->Samples, i);\n\t\tif (last_sample + pSamp->sample_delta == sampleNumber) {\n\t\t\tif (sub_sample) *sub_sample = pSamp;\n\t\t\treturn gf_list_count(pSamp->SubSamples);\n\t\t}\n\t\tlast_sample += pSamp->sample_delta;\n\t}\n\treturn 0;\n}\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//Add this funct to handle incomplete files...\n//bytesExpected is 0 most of the time. If the file is incomplete, bytesExpected\n//is the number of bytes missing to parse the box...\nGF_Err gf_isom_parse_root_box(GF_Box **outBox, GF_BitStream *bs, u32 *box_type, u64 *bytesExpected, Bool progressive_mode)\n{\n\tGF_Err ret;\n\tu64 start;\n\tstart = gf_bs_get_position(bs);\n\tret = gf_isom_box_parse_ex(outBox, bs, 0, GF_TRUE, 0);\n\tif (ret == GF_ISOM_INCOMPLETE_FILE) {\n\t\tif (!*outBox) {\n\t\t\t// We could not even read the box size, we at least need 8 bytes\n\t\t\t*bytesExpected = 8;\n\t\t\tif (box_type) *box_type = 0;\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box - start \"LLU\"\\n\", start));\n\t\t}\n\t\telse {\n\t\t\tu32 type = (*outBox)->type;\n\t\t\tif (type==GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\ttype = ((GF_UnknownBox *) (*outBox))->original_4cc;\n\n\t\t\t*bytesExpected = (*outBox)->size;\n\t\t\tif (box_type) *box_type = (*outBox)->type;\n\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box %s - start \"LLU\" size \"LLU\"\\n\", gf_4cc_to_str(type), start, (*outBox)->size));\n\t\t\tgf_isom_box_del(*outBox);\n\t\t\t*outBox = NULL;\n\t\t}\n\t\tgf_bs_seek(bs, start);\n\t}\n\treturn ret;\n}\n\nu32 gf_isom_solve_uuid_box(u8 *UUID)\n{\n\tu32 i;\n\tchar strUUID[33], strChar[3];\n\tstrUUID[0] = 0;\n\tstrUUID[32] = 0;\n\tfor (i=0; i<16; i++) {\n\t\tsnprintf(strChar, 3, \"%02X\", (unsigned char) UUID[i]);\n\t\tstrcat(strUUID, strChar);\n\t}\n\tif (!strnicmp(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TENC;\n\tif (!strnicmp(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32))\n\t\treturn GF_ISOM_BOX_UUID_MSSM;\n\tif (!strnicmp(strUUID, \"D4807EF2CA3946958E5426CB9E46A79F\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFRF;\n\tif (!strnicmp(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFXD;\n\tif (!strnicmp(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSEC;\n\tif (!strnicmp(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSSH;\n\n\treturn 0;\n}\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs);\n\nu64 unused_bytes = 0;\n\n#define GF_SKIP_BOX 10\n\nGF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\t\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t\treturn GF_SKIP_BOX;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//if parent size is given, make sure box fits within parent\n\tif (parent_size && (parent_size<size)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\t\tif (is_root_box && (e==GF_SKIP_BOX))\n\t\t\te = GF_ISOM_INVALID_FILE;\n\n\t\tif (!skip_logs && (e!=GF_SKIP_BOX)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t\tunused_bytes += to_skip;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_parse(GF_Box **outBox, GF_BitStream *bs)\n{\n\treturn gf_isom_box_parse_ex(outBox, bs, 0, GF_FALSE, 0);\n}\n\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\n\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\n\nvoid gf_isom_box_array_reset_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del_parent(child_boxes, a);\n\t}\n\tgf_list_reset(boxlist);\n}\nvoid gf_isom_box_array_del_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tif (!boxlist) return;\n\tgf_isom_box_array_reset_parent(child_boxes, boxlist);\n\tgf_list_del(boxlist);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_EXPORT\nGF_Err gf_isom_box_write_header(GF_Box *ptr, GF_BitStream *bs)\n{\n\tu64 start;\n\tif (! bs || !ptr) return GF_BAD_PARAM;\n\tif (!ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tstart = gf_bs_get_position(bs);\n\tif (ptr->size > 0xFFFFFFFF) {\n\t\tgf_bs_write_u32(bs, 1);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->size);\n\t}\n\tgf_bs_write_u32(bs, ptr->type);\n\tif (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tBool conv_uuid = GF_TRUE;\n\t\tGF_UUIDBox *uuidb = (GF_UUIDBox *)ptr;\n\t\tchar strUUID[32];\n\n\t\tswitch (uuidb->internal_4cc) {\n\t\tcase GF_ISOM_BOX_UUID_TENC:\n\t\t\tmemcpy(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSEC:\n\t\t\tmemcpy(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_MSSM:\n\t\t\tmemcpy(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSSH:\n\t\t\tmemcpy(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_TFXD:\n\t\t\tmemcpy(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconv_uuid = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (conv_uuid) {\n\t\t\tchar uuid[16];\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tchar t[3];\n\t\t\t\tt[2] = 0;\n\t\t\t\tt[0] = strUUID[2*i];\n\t\t\t\tt[1] = strUUID[2*i+1];\n\t\t\t\tuuid[i] = (u8) strtol(t, NULL, 16);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, uuid, 16);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, uuidb->uuid, 16);\n\t\t}\n\t}\n\tif (ptr->size > 0xFFFFFFFF)\n\t\tgf_bs_write_u64(bs, ptr->size);\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Written Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(ptr->type), ptr->size, start));\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FullBox *ptr = (GF_FullBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_write(GF_Box *parent, GF_List *list, GF_BitStream *bs)\n{\n\tu32 count, i;\n\tGF_Err e;\n\tif (!list) return GF_OK;\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_write(a, bs);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s writing box %s\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_size(GF_Box *parent, GF_List *list)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tif (! list) return GF_OK;\n\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_size(a);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s computing box %s size\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tparent->size += a->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box * unkn_box_new();\nvoid unkn_box_del(GF_Box *);\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_size(GF_Box *s);\nGF_Err unkn_box_dump(GF_Box *a, FILE * trace);\n\n//definition of boxes new/del/read/write/size. For now still exported since some files other than box_funcs.c call them\n//this should be fixed by only using gf_isom_box_new\n\n#define ISOM_BOX_IMPL_DECL(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\n\n#define ISOM_BOX_IMPL_DECL_CHILD(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\\\n\t\tGF_Err a_name##_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\\\n\n\nISOM_BOX_IMPL_DECL(reftype)\nISOM_BOX_IMPL_DECL(ireftype)\nISOM_BOX_IMPL_DECL(free)\nISOM_BOX_IMPL_DECL(wide)\nISOM_BOX_IMPL_DECL(mdat)\nISOM_BOX_IMPL_DECL_CHILD(moov)\nISOM_BOX_IMPL_DECL(mvhd)\nISOM_BOX_IMPL_DECL(mdhd)\nISOM_BOX_IMPL_DECL(vmhd)\nISOM_BOX_IMPL_DECL(smhd)\nISOM_BOX_IMPL_DECL(hmhd)\nISOM_BOX_IMPL_DECL(nmhd)\nISOM_BOX_IMPL_DECL_CHILD(stbl)\nISOM_BOX_IMPL_DECL_CHILD(dinf)\nISOM_BOX_IMPL_DECL(url)\nISOM_BOX_IMPL_DECL(urn)\nISOM_BOX_IMPL_DECL(cprt)\nISOM_BOX_IMPL_DECL(kind)\nISOM_BOX_IMPL_DECL(chpl)\nISOM_BOX_IMPL_DECL(hdlr)\nISOM_BOX_IMPL_DECL(iods)\nISOM_BOX_IMPL_DECL_CHILD(trak)\nISOM_BOX_IMPL_DECL_CHILD(mp4s)\nISOM_BOX_IMPL_DECL_CHILD(audio_sample_entry)\nISOM_BOX_IMPL_DECL(gen_sample_entry)\nISOM_BOX_IMPL_DECL_CHILD(edts)\nISOM_BOX_IMPL_DECL_CHILD(udta)\nISOM_BOX_IMPL_DECL(dref)\nISOM_BOX_IMPL_DECL_CHILD(stsd)\nISOM_BOX_IMPL_DECL(stts)\nISOM_BOX_IMPL_DECL(ctts)\nISOM_BOX_IMPL_DECL(stsh)\nISOM_BOX_IMPL_DECL(elst)\nISOM_BOX_IMPL_DECL(stsc)\nISOM_BOX_IMPL_DECL(stsz)\nISOM_BOX_IMPL_DECL(stco)\nISOM_BOX_IMPL_DECL(stss)\nISOM_BOX_IMPL_DECL(stdp)\nISOM_BOX_IMPL_DECL(sdtp)\nISOM_BOX_IMPL_DECL(co64)\nISOM_BOX_IMPL_DECL(esds)\nISOM_BOX_IMPL_DECL_CHILD(minf)\nISOM_BOX_IMPL_DECL(tkhd)\nISOM_BOX_IMPL_DECL(tref)\nISOM_BOX_IMPL_DECL_CHILD(mdia)\nISOM_BOX_IMPL_DECL_CHILD(mfra)\nISOM_BOX_IMPL_DECL(tfra)\nISOM_BOX_IMPL_DECL(mfro)\nISOM_BOX_IMPL_DECL(uuid)\nISOM_BOX_IMPL_DECL(void)\nISOM_BOX_IMPL_DECL(gnrm)\nISOM_BOX_IMPL_DECL(gnrv)\nISOM_BOX_IMPL_DECL(gnra)\nISOM_BOX_IMPL_DECL(pdin)\nISOM_BOX_IMPL_DECL(def_parent)\nISOM_BOX_IMPL_DECL(def_parent_full)\nISOM_BOX_IMPL_DECL(csgp)\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nISOM_BOX_IMPL_DECL_CHILD(hinf)\nISOM_BOX_IMPL_DECL(trpy)\nISOM_BOX_IMPL_DECL(totl)\nISOM_BOX_IMPL_DECL(nump)\nISOM_BOX_IMPL_DECL(npck)\nISOM_BOX_IMPL_DECL(tpyl)\nISOM_BOX_IMPL_DECL(tpay)\nISOM_BOX_IMPL_DECL(maxr)\nISOM_BOX_IMPL_DECL(dmed)\nISOM_BOX_IMPL_DECL(dimm)\nISOM_BOX_IMPL_DECL(drep)\nISOM_BOX_IMPL_DECL(tmin)\nISOM_BOX_IMPL_DECL(tmax)\nISOM_BOX_IMPL_DECL(pmax)\nISOM_BOX_IMPL_DECL(dmax)\nISOM_BOX_IMPL_DECL(payt)\nISOM_BOX_IMPL_DECL(name)\nISOM_BOX_IMPL_DECL(rely)\nISOM_BOX_IMPL_DECL(snro)\nISOM_BOX_IMPL_DECL(tims)\nISOM_BOX_IMPL_DECL(tsro)\nISOM_BOX_IMPL_DECL(ghnt)\nISOM_BOX_IMPL_DECL_CHILD(hnti)\nISOM_BOX_IMPL_DECL(sdp)\nISOM_BOX_IMPL_DECL(rtpo)\nISOM_BOX_IMPL_DECL(tssy)\nISOM_BOX_IMPL_DECL(rssr)\nISOM_BOX_IMPL_DECL_CHILD(srpp)\nISOM_BOX_IMPL_DECL(rtp_hnti)\n\n#endif\n\nISOM_BOX_IMPL_DECL(ftyp)\nISOM_BOX_IMPL_DECL(padb)\nISOM_BOX_IMPL_DECL(gppc)\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL_CHILD(mvex)\nISOM_BOX_IMPL_DECL(trex)\nISOM_BOX_IMPL_DECL_CHILD(moof)\nISOM_BOX_IMPL_DECL(mfhd)\nISOM_BOX_IMPL_DECL_CHILD(traf)\nISOM_BOX_IMPL_DECL(tfhd)\nISOM_BOX_IMPL_DECL(trun)\nISOM_BOX_IMPL_DECL(styp)\nISOM_BOX_IMPL_DECL(mehd)\n/*smooth streaming timing*/\nISOM_BOX_IMPL_DECL(tfxd)\nISOM_BOX_IMPL_DECL(tfrf)\n\n#endif\n\n/*avc ext*/\nISOM_BOX_IMPL_DECL(avcc)\nISOM_BOX_IMPL_DECL_CHILD(video_sample_entry)\nISOM_BOX_IMPL_DECL(m4ds)\nISOM_BOX_IMPL_DECL(btrt)\nISOM_BOX_IMPL_DECL(mehd)\n\n/*3GPP streaming text*/\nISOM_BOX_IMPL_DECL(ftab)\nISOM_BOX_IMPL_DECL_CHILD(tx3g)\nISOM_BOX_IMPL_DECL(text)\nISOM_BOX_IMPL_DECL(styl)\nISOM_BOX_IMPL_DECL(hlit)\nISOM_BOX_IMPL_DECL(hclr)\nISOM_BOX_IMPL_DECL(krok)\nISOM_BOX_IMPL_DECL(dlay)\nISOM_BOX_IMPL_DECL(href)\nISOM_BOX_IMPL_DECL(tbox)\nISOM_BOX_IMPL_DECL(blnk)\nISOM_BOX_IMPL_DECL(twrp)\n\n\n#ifndef GPAC_DISABLE_VTT\n\n/*WebVTT boxes*/\nISOM_BOX_IMPL_DECL(boxstring);\nISOM_BOX_IMPL_DECL_CHILD(vtcu)\nISOM_BOX_IMPL_DECL(vtte)\nISOM_BOX_IMPL_DECL_CHILD(wvtt)\n\n#endif //GPAC_DISABLE_VTT\n\n/* Items functions */\nISOM_BOX_IMPL_DECL_CHILD(meta)\nISOM_BOX_IMPL_DECL(xml)\nISOM_BOX_IMPL_DECL(bxml)\nISOM_BOX_IMPL_DECL(iloc)\nISOM_BOX_IMPL_DECL(pitm)\nISOM_BOX_IMPL_DECL_CHILD(ipro)\nISOM_BOX_IMPL_DECL(infe)\nISOM_BOX_IMPL_DECL_CHILD(iinf)\nISOM_BOX_IMPL_DECL_CHILD(iref)\nISOM_BOX_IMPL_DECL_CHILD(sinf)\nISOM_BOX_IMPL_DECL(frma)\nISOM_BOX_IMPL_DECL(schm)\nISOM_BOX_IMPL_DECL_CHILD(schi)\nISOM_BOX_IMPL_DECL(enca)\nISOM_BOX_IMPL_DECL(encs)\nISOM_BOX_IMPL_DECL(encv)\nISOM_BOX_IMPL_DECL(resv)\n\n\n/** ISMACryp functions **/\nISOM_BOX_IMPL_DECL(iKMS)\nISOM_BOX_IMPL_DECL(iSFM)\nISOM_BOX_IMPL_DECL(iSLT)\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n/* Adobe extensions */\nISOM_BOX_IMPL_DECL(abst)\nISOM_BOX_IMPL_DECL(afra)\nISOM_BOX_IMPL_DECL(asrt)\nISOM_BOX_IMPL_DECL(afrt)\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\n/* Apple extensions */\nISOM_BOX_IMPL_DECL(ilst)\nISOM_BOX_IMPL_DECL(ilst_item)\nISOM_BOX_IMPL_DECL(databox)\nISOM_BOX_IMPL_DECL(gmin)\nISOM_BOX_IMPL_DECL(alis)\nISOM_BOX_IMPL_DECL(clef)\n\n/*OMA extensions*/\nISOM_BOX_IMPL_DECL(ohdr)\nISOM_BOX_IMPL_DECL(grpi)\nISOM_BOX_IMPL_DECL(mdri)\nISOM_BOX_IMPL_DECL(odtt)\nISOM_BOX_IMPL_DECL(odrb)\nISOM_BOX_IMPL_DECL(odkm)\n\n\nISOM_BOX_IMPL_DECL(pasp)\nISOM_BOX_IMPL_DECL(clap)\nISOM_BOX_IMPL_DECL_CHILD(metx)\nISOM_BOX_IMPL_DECL(txtc)\nISOM_BOX_IMPL_DECL(tsel)\nISOM_BOX_IMPL_DECL(dimC)\nISOM_BOX_IMPL_DECL_CHILD(dims)\nISOM_BOX_IMPL_DECL(diST)\nISOM_BOX_IMPL_DECL(ac3)\nISOM_BOX_IMPL_DECL(ec3)\nISOM_BOX_IMPL_DECL(dac3)\nISOM_BOX_IMPL_DECL(dec3)\nISOM_BOX_IMPL_DECL(dmlp)\nISOM_BOX_IMPL_DECL(lsrc)\nISOM_BOX_IMPL_DECL_CHILD(lsr1)\nISOM_BOX_IMPL_DECL(mvcg)\nISOM_BOX_IMPL_DECL(vwid)\n\nISOM_BOX_IMPL_DECL(subs)\n\nISOM_BOX_IMPL_DECL(tmcd)\nISOM_BOX_IMPL_DECL(tcmi)\nISOM_BOX_IMPL_DECL(fiel)\nISOM_BOX_IMPL_DECL(gama)\nISOM_BOX_IMPL_DECL(chrm)\nISOM_BOX_IMPL_DECL(chan)\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL(sidx)\nISOM_BOX_IMPL_DECL(ssix)\nISOM_BOX_IMPL_DECL(leva)\nISOM_BOX_IMPL_DECL(pcrb)\nISOM_BOX_IMPL_DECL(tfdt)\nISOM_BOX_IMPL_DECL(emsg)\n\n#endif\n\nISOM_BOX_IMPL_DECL(rvcc)\nISOM_BOX_IMPL_DECL(sbgp)\nISOM_BOX_IMPL_DECL(sgpd)\nISOM_BOX_IMPL_DECL(saiz)\nISOM_BOX_IMPL_DECL(saio)\n\nISOM_BOX_IMPL_DECL(pssh)\n\nISOM_BOX_IMPL_DECL(tenc)\nISOM_BOX_IMPL_DECL(piff_tenc)\nISOM_BOX_IMPL_DECL(piff_psec)\nISOM_BOX_IMPL_DECL(piff_pssh)\nISOM_BOX_IMPL_DECL(senc)\nISOM_BOX_IMPL_DECL(cslg)\nISOM_BOX_IMPL_DECL(ccst)\nISOM_BOX_IMPL_DECL(auxi)\nISOM_BOX_IMPL_DECL(hvcc)\nISOM_BOX_IMPL_DECL(av1c)\nISOM_BOX_IMPL_DECL(dOps)\nISOM_BOX_IMPL_DECL(prft)\nISOM_BOX_IMPL_DECL(vvcc)\nISOM_BOX_IMPL_DECL(vvnc)\n\n//VPx\nISOM_BOX_IMPL_DECL(vpcc)\nISOM_BOX_IMPL_DECL(SmDm)\nISOM_BOX_IMPL_DECL(CoLL)\n\nISOM_BOX_IMPL_DECL(trep)\n\n//FEC\nISOM_BOX_IMPL_DECL_CHILD(fiin)\nISOM_BOX_IMPL_DECL_CHILD(paen)\nISOM_BOX_IMPL_DECL(fpar)\nISOM_BOX_IMPL_DECL(fecr)\nISOM_BOX_IMPL_DECL(segr)\nISOM_BOX_IMPL_DECL(gitn)\nISOM_BOX_IMPL_DECL_CHILD(fdsa)\nISOM_BOX_IMPL_DECL(fdpa)\nISOM_BOX_IMPL_DECL(extr)\n\n\n/*\n\tAdobe's protection boxes\n*/\nISOM_BOX_IMPL_DECL_CHILD(adkm)\nISOM_BOX_IMPL_DECL_CHILD(ahdr)\nISOM_BOX_IMPL_DECL_CHILD(aprm)\nISOM_BOX_IMPL_DECL(aeib)\nISOM_BOX_IMPL_DECL_CHILD(akey)\nISOM_BOX_IMPL_DECL(flxs)\nISOM_BOX_IMPL_DECL(adaf)\n\n/* Image File Format declarations */\nISOM_BOX_IMPL_DECL(ispe)\nISOM_BOX_IMPL_DECL(colr)\nISOM_BOX_IMPL_DECL(pixi)\nISOM_BOX_IMPL_DECL(rloc)\nISOM_BOX_IMPL_DECL(irot)\nISOM_BOX_IMPL_DECL(imir)\nISOM_BOX_IMPL_DECL(ipco)\nISOM_BOX_IMPL_DECL_CHILD(iprp)\nISOM_BOX_IMPL_DECL(ipma)\nISOM_BOX_IMPL_DECL_CHILD(trgr)\nISOM_BOX_IMPL_DECL(trgt)\nISOM_BOX_IMPL_DECL(ienc)\nISOM_BOX_IMPL_DECL(iaux)\n\n/* MIAF declarations */\nISOM_BOX_IMPL_DECL(clli)\nISOM_BOX_IMPL_DECL(mdcv)\n\n/* AVIF declarations */\nISOM_BOX_IMPL_DECL(a1lx)\nISOM_BOX_IMPL_DECL(a1op)\n\nISOM_BOX_IMPL_DECL(grpl)\n\nISOM_BOX_IMPL_DECL_CHILD(strk)\nISOM_BOX_IMPL_DECL(stri)\nISOM_BOX_IMPL_DECL(stsg)\nISOM_BOX_IMPL_DECL(elng)\nISOM_BOX_IMPL_DECL(stvi)\nISOM_BOX_IMPL_DECL(auxc)\nISOM_BOX_IMPL_DECL(oinf)\nISOM_BOX_IMPL_DECL(tols)\n\nISOM_BOX_IMPL_DECL(trik)\nISOM_BOX_IMPL_DECL(bloc)\nISOM_BOX_IMPL_DECL(ainf)\nISOM_BOX_IMPL_DECL(mhac)\nISOM_BOX_IMPL_DECL(mhap)\n\nISOM_BOX_IMPL_DECL(grptype)\n\nISOM_BOX_IMPL_DECL_CHILD(jp2h)\nISOM_BOX_IMPL_DECL(ihdr)\nISOM_BOX_IMPL_DECL(load)\n\n/* Dolby Vision */\nISOM_BOX_IMPL_DECL(dvcC)\nISOM_BOX_IMPL_DECL(dvvC)\nISOM_BOX_IMPL_DECL(dvhe)\nISOM_BOX_IMPL_DECL(dfla)\n\nISOM_BOX_IMPL_DECL(pcmC)\nISOM_BOX_IMPL_DECL(chnl)\n\nISOM_BOX_IMPL_DECL(xtra)\n\nISOM_BOX_IMPL_DECL(st3d)\nISOM_BOX_IMPL_DECL(svhd)\nISOM_BOX_IMPL_DECL(prhd)\nISOM_BOX_IMPL_DECL(proj_type)\n//ISOM_BOX_IMPL_DECL(mesh)\n\n\n#define BOX_DEFINE(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE}\n\n#define BOX_DEFINE_CHILD(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define BOX_DEFINE_S(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE }\n\n#define BOX_DEFINE_S_CHILD(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_CHILD(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE_FLAGS(__type, b_rad, __par, __max_v, flags) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_FLAGS_S(__type, b_rad, __par, __max_v, flags, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S_CHILD(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define TREF_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 0, 0, __par, __spec, GF_FALSE }\n\n#define TRGT_DEFINE(__type, b_rad, __par, __4cc, max_version, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1+max_version, 0, __par, __spec, GF_FALSE }\n\n#define SGPD_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1, 0, __par, __spec, GF_FALSE }\n\n#define ITUNES_TAG(_val) \\\n\tBOX_DEFINE_S( _val, ilst_item, \"ilst data\", \"apple\")\n\nstatic struct box_registry_entry {\n\tu32 box_4cc;\n\tGF_Box * (*new_fn)();\n\tvoid (*del_fn)(GF_Box *a);\n\tGF_Err (*read_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*write_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*size_fn)(GF_Box *a);\n\tGF_Err (*dump_fn)(GF_Box *a, FILE *trace);\n\tu32 alt_4cc;//used for sample grouping type and track / item reference types\n\tu8 max_version_plus_one;\n\tu32 flags;\n\tconst char *parents_4cc;\n\tconst char *spec;\n\tBool disabled;\n\tGF_Err (*add_rem_fn)(GF_Box *par, GF_Box *b, Bool is_remove);\n} box_registry [] =\n{\n\t//DO NOT MOVE THE FIRST ENTRY\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UNKNOWN, unkn, \"unknown\", \"unknown\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UUID, uuid, \"unknown\", \"unknown\"),\n\n\t//all track reference types\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_META, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HINT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_FONT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HIND, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VDEP, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VPLX, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SUBT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_THUMB, \"p12\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OD, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_DECODE, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OCR, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_IPI, \"p14\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_BASE, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCAL, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TBAS, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SABT, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OREF, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADDA, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADRC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_AVCP, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWTO, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWFR, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CHAP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TMCD, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CDEP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCPT, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SSRC, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_LYRA, \"apple\"),\n\n\t//all item reference types\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_TBAS, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_FDEL, \"p12\"),\n\n\t//all sample group descriptions\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ROLL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_PROL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RAP, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SEIG, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_OINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TRIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_NALM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TELE, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RASH, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ALST, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SAP, \"p12\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVLL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVSS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_DTRT, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_MVIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCNM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_STSA, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSAS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SYNC, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSCL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_VIPR, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LBLI, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SPOR, \"p15\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_3GAG, \"3gpp\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVCB, \"3gpp\"),\n\n\t//internal boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRM, gnrm, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRV, gnrv, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRA, gnra, \"stsd\", \"unknown\"),\n\n\t//all track group types\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_MSRC, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_STER, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_CSTG, 0, \"p15\" ),\n\n\t//part12 boxes\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FREE, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SKIP, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MDAT, mdat, \"file\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_IDAT, mdat, \"meta\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOV, moov, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MVHD, mvhd, \"moov\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MDHD, mdhd, \"mdia\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_VMHD, vmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SMHD, smhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HMHD, hmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_NMHD, nmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STHD, nmhd, \"minf\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STBL, stbl, \"minf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_DINF, dinf, \"minf meta\"),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URL, url, \"dref\", 0, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URN, urn, \"dref\", 0, 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CPRT, cprt, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_KIND, kind, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HDLR, hdlr, \"mdia meta minf\", 0),\t//minf container is OK in QT ...\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAK, trak, \"moov\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_EDTS, edts, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_UDTA, udta, \"moov trak moof traf\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_DREF, dref, \"dinf\", 0),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STSD, stsd, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STTS, stts, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CTTS, ctts, \"stbl\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CSLG, cslg, \"stbl trep\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSH, stsh, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELST, elst, \"edts\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSC, stsc, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSZ, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STZ2, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STCO, stco, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSS, stss, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STDP, stdp, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SDTP, sdtp, \"stbl traf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CO64, co64, \"stbl\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MINF, minf, \"mdia\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TKHD, tkhd, \"trak\", 1, 0x000001 | 0x000002 | 0x000004 | 0x000008),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TREF, tref, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MDIA, mdia, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MFRA, mfra, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFRO, mfro, \"mfra\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFRA, tfra, \"mfra\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELNG, elng, \"mdia\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PDIN, pdin, \"file\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SBGP, sbgp, \"stbl traf\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", 2),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CSGP, csgp, \"stbl traf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 1),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_SUBS, subs, \"stbl traf\", 0, 7), //warning flags are not used as a bit mask but as an enum!!\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRGR, trgr, \"trak\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FTYP, ftyp, \"file otyp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_OTYP, def_parent, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PADB, padb, \"stbl\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_BTRT, btrt, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PASP, pasp, \"video_sample_entry ipco\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CLAP, clap, \"video_sample_entry ipco\"),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_META, meta, \"file moov trak moof traf udta\", 0),\t//apple uses meta in moov->udta\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_XML, xml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_BXML, bxml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ILOC, iloc, \"meta\", 2),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PITM, pitm, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IPRO, ipro, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_INFE, infe, \"iinf\", 3),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IINF, iinf, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IREF, iref, \"meta\", 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SINF, sinf, \"ipro sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RINF, sinf, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FRMA, frma, \"sinf rinf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SCHM, schm, \"sinf rinf\", 0, 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SCHI, schi, \"sinf rinf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCA, audio_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCV, video_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_RESV, video_sample_entry, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TSEL, tsel, \"udta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STRK, strk, \"udta\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STRI, stri, \"strk\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STRD, def_parent, \"strk\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSG, stsg, \"strd\", 0),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCS, mp4s, \"stsd\"),\n\t//THIS HAS TO BE FIXED, not extensible\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCT, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCM, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCF, mp4s, \"stsd\"),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METX, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STVI, stvi, \"schi\", 0),\n\n\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, \"audio_sample_entry\", 0),\n\n\t//FEC\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FIIN, fiin, \"meta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_PAEN, paen, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FPAR, fpar, \"paen\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FECR, fecr, \"paen\", 1),\n\t//fire uses the same box syntax as fecr\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FIRE, fecr, \"paen\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SEGR, segr, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_GITN, gitn, \"fiin\", 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FDSA, fdsa, \"fdp_sample\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDPA, fdpa, \"fdsa\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_EXTR, extr, \"fdsa\"),\n#endif\n\n\t//full boxes todo\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ASSP, assp, 1),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_MERE, assp, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_SRAT, srat, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_DMIX, dmix, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_TLOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ALOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URI, uri, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URII, urii, 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTCP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HNTI, hnti, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SDP, sdp, \"hnti\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HINF, hinf, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TRPY, trpy, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NUMP, nump, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPYL, tpyl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TOTL, totl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NPCK, npck, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPAY, tpay, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MAXR, maxr, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMED, dmed, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DIMM, dimm, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DREP, drep, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMIN, tmin, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMAX, tmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PMAX, pmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMAX, dmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PAYT, payt, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP, rtp_hnti, \"hnti\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTPO, rtpo, \"rtp_packet\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RELY, rely, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TIMS, tims, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSRO, tsro, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SNRO, snro, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NAME, name, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSSY, tssy, \"rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RSSR, rssr, \"rrtp\"),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SRPP, srpp, \"srtp\", 0),\n\n#endif\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MVEX, mvex, \"moov\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MEHD, mehd, \"mvex\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREX, trex, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_LEVA, leva, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREP, trep, \"mvex\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOF, moof, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFHD, mfhd, \"moof\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAF, traf, \"moof\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TFHD, tfhd, \"traf\", 0, 0x000001|0x000002|0x000008|0x000010|0x000020|0x010000|0x020000),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TRUN, trun, \"traf\", 0, 0x000001|0x000004|0x000100|0x000200|0x000400|0x000800),\n#ifdef GF_ENABLE_CTRN\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_CTRN, trun, \"traf\", 0, 0),\n#endif\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFDT, tfdt, \"traf\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STYP, ftyp, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PRFT, prft, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SIDX, sidx, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SSIX, ssix, \"file\", 0),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCRB, pcrb, \"file\", \"dash\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EMSG, emsg, \"file\", 1, \"dash\"),\n#endif\n\n\n\t//part14 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IODS, iods, \"moov\", 0, \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4S, mp4s, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4V, video_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4A, audio_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_M4DS, m4ds, \"sample_entry\", \"p14\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ESDS, esds, \"mp4a mp4s mp4v encv enca encs resv wave\", 0, \"p14\"),\n\n\t//part 15 boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AVCC, avcc, \"avc1 avc2 avc3 avc4 encv resv ipco dva1 dvav\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVCC, avcc, \"avc1 avc2 avc3 avc4 svc1 svc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MVCC, avcc, \"avc1 avc2 avc3 avc4 mvc1 mvc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HVCC, hvcc, \"hvc1 hev1 hvc2 hev2 encv resv ipco dvh1 dvhe\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LHVC, hvcc, \"hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv ipco\", \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VVCC, vvcc, \"vvc1 vvi1 encv resv ipco dvhe\", 0, \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VVNC, vvnc, \"vvs1 encv resv ipco dvhe\", 0, \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC3, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC4, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_SVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHE1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVT1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVI1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVS1, video_sample_entry, \"stsd\", \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCI, def_parent_full, \"minf\", 0, \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCG, mvcg, \"mvci\", 0, \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VWID, vwid, \"video_sample_entry\", 0, \"p15\"),\n\n\t//mpegh 3D audio boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAC, mhac, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAP, mhap, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_FPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCMC, pcmC, \"ipcm fpcm\", 0, \"23003_5\"),\n\n\t//AV1 in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_AV01, video_sample_entry, \"stsd\", \"av1\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_AV1C, av1c, \"av01 encv resv ipco dav1\", \"av1\"),\n\n\t// VP8-9 boxes\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_VPCC, vpcc, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP08, video_sample_entry, \"stsd\", \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP09, video_sample_entry, \"stsd\", \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_SMDM, SmDm, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_COLL, CoLL, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\n\t//Opus in ISOBMFF boxes\n#ifndef GPAC_DISABLE_OGG\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_OPUS, audio_sample_entry, \"stsd\", \"Opus\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DOPS, dOps, \"Opus wave enca\", \"Opus\"),\n#endif\n\n\t//part20 boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LSR1, lsr1, \"stsd\", \"p20\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LSRC, lsrc, \"lsr1\", \"p20\"),\n\n\t//part30 boxes\n#ifndef GPAC_DISABLE_TTXT\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STXT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TXTC, txtc, \"stxt mett sbtt\", 0),\n\t//we allow mime in any sample entry, not restricted in the spec ...\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MIME, txtc, \"sample_entry\", 0),\n#ifndef GPAC_DISABLE_VTT\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_WVTT, wvtt, \"stsd\", \"p30\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VTCC_CUE, vtcu, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTE, vtte, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTC_CONFIG, boxstring, \"wvtt\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CTIM, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IDEN, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STTG, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PAYL, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTA, boxstring, \"vttc\", \"p30\"),\n#endif\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STPP, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SBTT, metx, \"stsd\"),\n#endif\n\n\t//Image File Format\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPRP, iprp, \"meta\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IPCO, ipco, \"iprp\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISPE, ispe, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"video_sample_entry ipco encv resv\", \"iff\"),\n\t//defined as a secondary box for now to avoid conflicts with master hashes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"jp2h\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PIXI, pixi, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RLOC, rloc, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IROT, irot, \"ipco\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IMIR, imir, \"ipco\", \"iff\"),\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_IPMA, ipma, \"iprp\", 1, 1, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPL, grpl, \"meta\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CCST, ccst, \"sample_entry\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXI, auxi, \"sample_entry\", 0, \"iff\"),\n\tTRGT_DEFINE(GF_ISOM_BOX_TYPE_GRPT, grptype, \"grpl\", GF_ISOM_BOX_TYPE_ALTR, 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXC, auxc, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OINF, oinf, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TOLS, tols, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IENC, ienc, \"ipco\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IAUX, iaux, \"ipco\", 0, \"cenc\"),\n\n\t//MIAF\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_CLLI, clli, \"video_sample_entry ipco encv resv\", \"p12\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MDCV, mdcv, \"video_sample_entry ipco encv resv\", \"p12\"),\n\n\t//AVIF\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_A1LX, a1lx, \"ipco\", \"avif\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_A1OP, a1op, \"ipco\", \"avif\"),\n\n\t//other MPEG boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RVCC, rvcc, \"avc1 avc2 avc3 avc4 svc1 svc2 hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv\", \"rvc\"),\n\n\t//3GPP boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR_WB, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_QCELP, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_EVRC, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_SMV, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_H263, video_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAMR, gppc, \"samr sawb enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DEVC, gppc, \"sevc enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DQCP, gppc, \"sqcp enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DSMV, gppc, \"ssmv enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_D263, gppc, \"s263 encv\", \"3gpp\"),\n\t//3gpp timed text\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_TX3G, tx3g, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TEXT, text, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FTAB, ftab, \"tx3g text enct\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STYL, styl, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HLIT, hlit, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HCLR, hclr, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_KROK, krok, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DLAY, dlay, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HREF, href, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TBOX, tbox, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLNK, blnk, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TWRP, twrp, \"text_sample\", \"3gpp\"),\n\t//3GPP dims\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_DIMS, dims, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIMC, dimC, \"dims encs\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIST, diST, \"dims\", \"3gpp\"),\n\n\n\t//CENC boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PSSH, pssh, \"moov moof meta\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TENC, tenc, \"schi\", 1, \"cenc\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SENC, senc, \"trak traf\", \"cenc\"),\n\n\t// ISMA 1.1 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IKMS, iKMS, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISFM, iSFM, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISLT, iSLT, \"schi\", 0, \"isma\"),\n\n\t//OMA boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODKM, odkm, \"schi\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OHDR, ohdr, \"odkm\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPI, grpi, \"ohdr\", 0, \"oma\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MDRI, mdri, \"file\", \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODTT, odtt, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODRB, odrb, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODAF, iSFM, \"schi\", 0, \"oma\"),\n\n\t//apple boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP3, audio_sample_entry, \"stsd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CHPL, chpl, \"udta\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VOID, void, \"\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_WIDE, wide, \"*\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ILST, ilst, \"meta\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DATA, databox, \"ilst *\", 0, \"apple\"),\n\n\tITUNES_TAG(GF_ISOM_ITUNE_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_GROUP),\n\tITUNES_TAG(GF_ISOM_ITUNE_WRITER),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMMENT),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE_USER),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE),\n\tITUNES_TAG(GF_ISOM_ITUNE_CREATED),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACKNUMBER),\n\tITUNES_TAG(GF_ISOM_ITUNE_DISK),\n\tITUNES_TAG(GF_ISOM_ITUNE_TEMPO),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPILATION),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SEASON),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE_NUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_NETWORK),\n\tITUNES_TAG(GF_ISOM_ITUNE_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LONG_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LYRICS),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALB_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_COVER_ART),\n\tITUNES_TAG(GF_ISOM_ITUNE_COPYRIGHT),\n\tITUNES_TAG(GF_ISOM_ITUNE_TOOL),\n\tITUNES_TAG(GF_ISOM_ITUNE_ENCODER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PURCHASE_DATE),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST_URL),\n\tITUNES_TAG(GF_ISOM_ITUNE_KEYWORDS),\n\tITUNES_TAG(GF_ISOM_ITUNE_CATEGORY),\n\tITUNES_TAG(GF_ISOM_ITUNE_HD_VIDEO),\n\tITUNES_TAG(GF_ISOM_ITUNE_MEDIA_TYPE),\n\tITUNES_TAG(GF_ISOM_ITUNE_RATING),\n\tITUNES_TAG(GF_ISOM_ITUNE_GAPLESS),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACK),\n\tITUNES_TAG(GF_ISOM_ITUNE_CONDUCTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_ART_DIRECTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_ARRANGER),\n\tITUNES_TAG(GF_ISOM_ITUNE_LYRICIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_COPY_ACK),\n\tITUNES_TAG(GF_ISOM_ITUNE_SONG_DESC),\n\tITUNES_TAG(GF_ISOM_ITUNE_DIRECTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_EQ_PRESET),\n\tITUNES_TAG(GF_ISOM_ITUNE_LINER_NOTES),\n\tITUNES_TAG(GF_ISOM_ITUNE_REC_COMPANY),\n\tITUNES_TAG(GF_ISOM_ITUNE_ORIG_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_PHONO_RIGHTS),\n\tITUNES_TAG(GF_ISOM_ITUNE_PRODUCER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PERFORMER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PUBLISHER),\n\tITUNES_TAG(GF_ISOM_ITUNE_SOUND_ENG),\n\tITUNES_TAG(GF_ISOM_ITUNE_SOLOIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_CREDITS),\n\tITUNES_TAG(GF_ISOM_ITUNE_THANKS),\n\tITUNES_TAG(GF_ISOM_ITUNE_ONLINE),\n\tITUNES_TAG(GF_ISOM_ITUNE_EXEC_PRODUCER),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_iTunesSpecificInfo, ilst_item, \"ilst data\", \"apple\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_GMHD, def_parent, \"minf\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_LOAD, load, \"trak\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_TAPT, def_parent, \"trak\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_GMIN, gmin, \"gmhd\", 0, \"apple\"),\n\tFBOX_DEFINE_FLAGS_S( GF_QT_BOX_TYPE_ALIS, alis, \"dref\", 0, 1, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CLEF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_PROF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_ENOF, clef, \"tapt\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_WAVE, def_parent, \"audio_sample_entry\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CHAN, chan, \"audio_sample_entry\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FRMA, frma, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TERMINATOR, unkn, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_ENDA, chrm, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, def_parent, \"gmhd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_NAME, unkn, \"tmcd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_TCMI, tcmi, \"tmcd\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FIEL, fiel, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_GAMA, gama, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_CHRM, chrm, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_SUBTYPE_TEXT, unkn, \"gmhd\", \"apple\"),\n\n\t//QT and prores sample entry types\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, tmcd, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_SUBTYPE_C608, gen_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCH, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCO, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCS, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCN, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4X, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4H, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_AUD, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_TWOS, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_SOWT, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL64, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN24, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ULAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ALAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IMA_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_DVCA, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC2, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QCELP, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_kMP3, audio_sample_entry, \"stsd\", \"apple\"),\n\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_VID, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUYV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_UYVY, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUVA444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_16, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_I420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IYUV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YV12, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YVYU, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RGBA, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ABGR, video_sample_entry, \"stsd\", \"apple\"),\n\t\n\t\n\t//dolby boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_EC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAC3, dac3, \"ac-3 wave enca\", \"dolby\"),\n\t{GF_ISOM_BOX_TYPE_DEC3, dec3_box_new, dac3_box_del, dac3_box_read, dac3_box_write, dac3_box_size, dac3_box_dump, 0, 0, 0, \"ec-3 wave enca\", \"dolby\" },\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DVCC, dvcC, \"dvav dva1 dvhe dvh1 dav1 avc1 avc2 avc3 avc4 hev1 hvc1 av01 encv resv\", \"DolbyVision\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DVVC, dvvC, \"dvav dva1 dvhe dvh1 dav1 avc1 avc2 avc3 avc4 hev1 hvc1 av01 encv resv\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVHE, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVH1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVA1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVAV, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DAV1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MLPA, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DMLP, dmlp, \"mlpa enca\", \"dolby\"),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HVCE, hvcc, \"hvc1 hev1 hvc2 hev2 encv resv ipco dvh1 dvhe\", \"DolbyVision\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AVCE, avcc, \"avc1 avc2 avc3 avc4 encv resv ipco dva1 dvav\", \"DolbyVision\"),\n\n\n\t//Adobe boxes\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ABST, abst, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRA, afra, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ASRT, asrt, \"abst\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRT, afrt, \"abst\", 0, \"adobe\"),\n#endif\n\t/*Adobe's protection boxes*/\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_ADKM, adkm, \"schi\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AHDR, ahdr, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ADAF, adaf, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_APRM, aprm, \"ahdr\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AEIB, aeib, \"aprm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AKEY, akey, \"aprm\", 0, \"adobe\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FLXS, flxs, \"akey\", \"adobe\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TRIK, trik, \"traf\", 0, \"dece\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLOC, bloc, \"file\", 0, \"dece\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_AINF, ainf, \"moov\", 0, 0x000001, \"dece\"),\n\n\n\t//internally handled UUID for smooth - the code points are only used during creation and assigned to UUIDBox->internal4CC\n\t//the box type is still \"uuid\", and the factory is used to read/write/size/dump the code\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TENC, piff_tenc, \"schi\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSEC, piff_psec, \"trak traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSSH, piff_pssh, \"moov moof\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFXD, tfxd, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, tfrf, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_MSSM, uuid, \"file\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, uuid, \"traf\", \"smooth\"),\n\n\n\t//J2K boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_MJP2, video_sample_entry, \"stsd\", \"j2k\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2H, jp2h, \"mjp2 encv\", \"j2k\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_IHDR, ihdr, \"jp2h\", \"j2k\"),\n\n\t/* Image tracks */\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JPEG, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2K, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_PNG, video_sample_entry, \"stsd\", \"apple\"),\n\n\n\t//flac in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_FLAC, audio_sample_entry, \"stsd\", \"Flac\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DFLA, dfla, \"fLaC enca\", 0, \"Flac\"),\n\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_XTRA, xtra, \"udta\", \"WMA\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ST3D, st3d, \"video_sample_entry\", 0, \"youtube\"),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SV3D, def_parent, \"video_sample_entry\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVHD, svhd, \"sv3d\", 0, \"youtube\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PROJ, def_parent, \"sv3d\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PRHD, prhd, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CBMP, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EQUI, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MESH, proj_type, \"proj\", 0, \"youtube\"),\n\n/*\n\tGF_ISOM_BOX_TYPE_CBMP\t= GF_4CC( 'c', 'b', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_EQUI\t= GF_4CC( 'e', 'q', 'u', 'i' ),\n\tGF_ISOM_BOX_TYPE_MSHP\t= GF_4CC( 'm', 's', 'h', 'p' ),\n\tGF_ISOM_BOX_TYPE_MESH\t= GF_4CC( 'm', 'e', 's', 'h' ),\n*/\n\n};\n\nBool gf_box_valid_in_parent(GF_Box *a, const char *parent_4cc)\n{\n\tif (!a || !a->registry || !a->registry->parents_4cc) return GF_FALSE;\n\tif (strstr(a->registry->parents_4cc, parent_4cc) != NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_num_supported_boxes()\n{\n\treturn sizeof(box_registry) / sizeof(struct box_registry_entry);\n}\n\nvoid gf_isom_registry_disable(u32 boxCode, Bool disable)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tfor (i=1; i<count; i++) {\n\t\tif (box_registry[i].box_4cc==boxCode) {\n\t\t\tbox_registry[i].disabled = disable;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic u32 get_box_reg_idx(u32 boxCode, u32 parent_type, u32 start_from)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tconst char *parent_name = parent_type ? gf_4cc_to_str(parent_type) : NULL;\n\n\tif (!start_from) start_from = 1;\n\n\tfor (i=start_from; i<count; i++) {\n\t\tu32 start_par_from;\n\t\tif (box_registry[i].box_4cc != boxCode)\n\t\t\tcontinue;\n\n\t\tif (!parent_type)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, parent_name) != NULL)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, \"*\") != NULL)\n\t\t\treturn i;\n\n\t\tif (strstr(box_registry[i].parents_4cc, \"sample_entry\") == NULL)\n\t\t\tcontinue;\n\n\t\t/*parent is a sample entry, check if the parent_type matches a sample entry box (eg its parent must be stsd)*/\n\n\t\tif (parent_type==GF_QT_SUBTYPE_RAW)\n\t\t\treturn i;\n\n\t\tstart_par_from = 0;\n\t\twhile (parent_type) {\n\t\t\t//locate parent registry\n\t\t\tu32 j = get_box_reg_idx(parent_type, 0, start_par_from);\n\t\t\tif (!j) break;\n\t\t\t//if parent registry has \"stsd\" as parent, this is a sample entry\n\t\t\tif (box_registry[j].parents_4cc && (strstr(box_registry[j].parents_4cc, \"stsd\") != NULL))\n\t\t\t\treturn i;\n\t\t\tstart_par_from = j+1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_Box *gf_isom_box_new_ex(u32 boxType, u32 parentType, Bool skip_logs, Bool is_root_box)\n{\n\tGF_Box *a;\n\ts32 idx = get_box_reg_idx(boxType, parentType, 0);\n\tif (idx==0) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (!skip_logs && (boxType != GF_ISOM_BOX_TYPE_UNKNOWN) && (boxType != GF_ISOM_BOX_TYPE_UUID)) {\n\t\t\tswitch (parentType) {\n\t\t\tcase GF_ISOM_BOX_TYPE_ILST:\n\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tcase GF_ISOM_BOX_TYPE_iTunesSpecificInfo:\n\t\t\tcase GF_QT_BOX_TYPE_WAVE:\n\t\t\t\tbreak;\n\t\t\t//some sample descritions are handled as generic ones but we know them, don't warn\n\t\t\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\t\t\tif (boxType==GF_ISOM_SUBTYPE_FFV1) break;\n\t\t\t\t//fallthrough\n\t\t\tdefault:\n\t\t\t\tif (boxType==GF_ISOM_BOX_TYPE_GDAT) break;\n\n\t\t\t\tif (is_root_box) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown top-level box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t} else if (parentType) {\n\t\t\t\t\tchar szName[GF_4CC_MSIZE];\n\t\t\t\t\tstrcpy(szName, gf_4cc_to_str(parentType));\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s in parent %s\\n\", gf_4cc_to_str(boxType), szName));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n        if (boxType==GF_ISOM_BOX_TYPE_UUID) {\n            a = uuid_box_new();\n            if (a) a->registry = &box_registry[1];\n        } else {\n            a = unkn_box_new();\n            if (a) {\n            \t((GF_UnknownBox *)a)->original_4cc = boxType;\n            \ta->registry = &box_registry[0];\n\t\t\t}\n        }\n\t\treturn a;\n\t}\n\ta = box_registry[idx].new_fn();\n\n\tif (a) {\n\t\tif (a->type!=GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\t((GF_UnknownBox *)a)->original_4cc = boxType;\n\t\t\t} else {\n\t\t\t\ta->type = boxType;\n\t\t\t}\n\t\t}\n\t\ta->registry = &box_registry[idx];\n\n\t\tif ((a->type==GF_ISOM_BOX_TYPE_COLR) && (parentType==GF_ISOM_BOX_TYPE_JP2H)) {\n\t\t\t((GF_ColourInformationBox *)a)->is_jp2 = GF_TRUE;\n\t\t}\n\n\t}\n\treturn a;\n}\n\nGF_EXPORT\nGF_Box *gf_isom_box_new(u32 boxType)\n{\n\treturn gf_isom_box_new_ex(boxType, 0, 0, GF_FALSE);\n}\n\nGF_Err gf_isom_box_array_read(GF_Box *parent, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 parent_type = parent->type;\n\tGF_Box *a = NULL;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (parent->size>=8) {\n\t\te = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE, skip_logs ? 0 : parent->size);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn (e==GF_SKIP_BOX) ? GF_OK : e;\n\t\t}\n\t\t//sub box parsing aborted with no error\n\t\tif (!a) return GF_OK;\n\n\t\tif (parent->size < a->size) {\n\t\t\tif (!skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is larger than container box\\n\", gf_4cc_to_str(a->type)));\n\t\t\t}\n\t\t\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tparent->size = 0;\n\t\t} else {\n\t\t\tparent->size -= a->size;\n\t\t}\n\n\t\t//check container validity\n\t\tif (strlen(a->registry->parents_4cc)) {\n\t\t\tBool parent_OK = GF_FALSE;\n\t\t\tconst char *parent_code = gf_4cc_to_str(parent->type);\n\t\t\tif (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\tparent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );\n\t\t\tif (strstr(a->registry->parents_4cc, parent_code) != NULL) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else if (!strcmp(a->registry->parents_4cc, \"*\") || strstr(a->registry->parents_4cc, \"* \") || strstr(a->registry->parents_4cc, \" *\")) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else {\n\t\t\t\t//parent must be a sample entry\n\t\t\t\tif (strstr(a->registry->parents_4cc, \"sample_entry\") !=\tNULL) {\n\t\t\t\t\t//parent is in an stsd\n\t\t\t\t\tif (strstr(parent->registry->parents_4cc, \"stsd\") != NULL) {\n\t\t\t\t\t\tif (strstr(a->registry->parents_4cc, \"video_sample_entry\") !=\tNULL) {\n\t\t\t\t\t\t\tif (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;\n\t\t\t}\n\t\t\tif (! parent_OK && !skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is invalid in container %s\\n\", gf_4cc_to_str(a->type), parent_code));\n\t\t\t}\n\t\t}\n\n\t\t//always register boxes\n\t\tif (!parent->child_boxes) {\n\t\t\tparent->child_boxes = gf_list_new();\n\t\t\tif (!parent->child_boxes) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(parent->child_boxes, a);\n\t\tif (e) return e;\n\n\t\tif (parent->registry->add_rem_fn) {\n\t\t\te = parent->registry->add_rem_fn(parent, a, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tif (e == GF_ISOM_INVALID_MEDIA) return GF_OK;\n\t\t\t\t//if the box is no longer present, consider it destroyed\n\t\t\t\tif (gf_list_find(parent->child_boxes, a) >=0) {\n\t\t\t\t\tgf_isom_box_del_parent(&parent->child_boxes, a);\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\n\n\nGF_Err gf_isom_box_read(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->read_fn(a, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_box_write_listing(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Write invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->write_fn(a, bs);\n}\n\n\nvoid gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\n\t//happens when partially cloning boxes \n\tif (cur_pos < 0) return;\n\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;\n}\n\nvoid gf_isom_check_position_list(GF_Box *s, GF_List *childlist, u32 *pos)\n{\n\tu32 i, count;\n\tif (!s || (s->internal_flags & GF_ISOM_ORDER_FREEZE))\n\t\treturn;\n\tcount = gf_list_count(childlist);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *child = gf_list_get(childlist, i);\n\t\tgf_isom_check_position(s, child, pos);\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\t\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;\n}\n\nstatic GF_Err gf_isom_box_size_listing(GF_Box *a)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Size invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->size = 8;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\ta->size += 16;\n\t}\n\t//the large size is handled during write, cause at this stage we don't know the size\n\tif (a->registry->max_version_plus_one) {\n\t\ta->size += 4;\n\t}\n\treturn a->registry->size_fn(a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_size(GF_Box *a)\n{\n\tGF_Err e;\n\tif (!a) return GF_BAD_PARAM;\n\tif (a->registry->disabled) {\n\t\ta->size = 0;\n\t\treturn GF_OK;\n\t}\n\te = gf_isom_box_size_listing(a);\n\tif (e) return e;\n\t//box size set to 0 (not even a header), abort traversal\n\tif (!a->size) return GF_OK;\n\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_size(a, a->child_boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs)\n{\n\tif (ptr->registry->max_version_plus_one) {\n\t\tGF_FullBox *self = (GF_FullBox *) ptr;\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tself->version = gf_bs_read_u8(bs);\n\t\tself->flags = gf_bs_read_u24(bs);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_dump_supported_box(u32 idx, FILE * trace)\n{\n\tu32 i;\n\tu32 nb_versions=0;\n\tGF_Err e;\n\n\tif (box_registry[idx].max_version_plus_one) {\n\t\tnb_versions = box_registry[idx].max_version_plus_one - 1;\n\t}\n\tfor (i = 0; i <= nb_versions; i++) {\n\t\tGF_Box *a = box_registry[idx].new_fn();\n\t\tif (!a) return GF_OUT_OF_MEM;\n\n\t\ta->registry = &box_registry[idx];\n\n\t\tif (box_registry[idx].alt_4cc) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_REFT)\n\t\t\t\t((GF_TrackReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_REFI)\n\t\t\t\t((GF_ItemReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_TRGT)\n\t\t\t\t((GF_TrackGroupTypeBox*)a)->group_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_SGPD)\n\t\t\t\t((GF_SampleGroupDescriptionBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_GRPT)\n\t\t\t\t((GF_EntityToGroupTypeBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t}\n\t\tif (box_registry[idx].max_version_plus_one) {\n\t\t\t((GF_FullBox *)a)->version = i;\n\t\t}\n\t\tif (box_registry[idx].flags) {\n\t\t\tu32 flag_mask=1;\n\t\t\tu32 flags = box_registry[idx].flags;\n\t\t\t((GF_FullBox *)a)->flags = 0;\n\t\t\te = gf_isom_box_dump(a, trace);\n\n\t\t\t//we dump all flags individually and this for all version, in order to simplify the XSLT processing\n\t\t\twhile (!e) {\n\t\t\t\tu32 flag = flags & flag_mask;\n\t\t\t\tflag_mask <<= 1;\n\t\t\t\tif (flag) {\n\t\t\t\t\t((GF_FullBox *)a)->flags = flag;\n\t\t\t\t\te = gf_isom_box_dump(a, trace);\n\t\t\t\t}\n\t\t\t\tif (flag_mask > flags) break;\n\t\t\t\tif (flag_mask == 0x80000000) break;\n\t\t\t}\n\n\t\t} else {\n\t\t\te = gf_isom_box_dump(a, trace);\n\t\t}\n\n\t\tgf_isom_box_del(a);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nu32 gf_isom_get_supported_box_type(u32 idx)\n{\n\treturn box_registry[idx].box_4cc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\nGF_Err gf_isom_box_dump_start(GF_Box *a, const char *name, FILE * trace)\n{\n\tgf_fprintf(trace, \"<%s \", name);\n\tif (a->size > 0xFFFFFFFF) {\n\t\tgf_fprintf(trace, \"LargeSize=\\\"\"LLU\"\\\" \", a->size);\n\t} else {\n\t\tgf_fprintf(trace, \"Size=\\\"%u\\\" \", (u32) a->size);\n\t}\n\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(((GF_UnknownBox*)a)->original_4cc));\n\t} else {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(a->type));\n\t}\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tgf_fprintf(trace, \"UUID=\\\"{\");\n\t\tfor (i=0; i<16; i++) {\n\t\t\tgf_fprintf(trace, \"%02X\", (unsigned char) ((GF_UUIDBox*)a)->uuid[i]);\n\t\t\tif ((i<15) && (i%4)==3) gf_fprintf(trace, \"-\");\n\t\t}\n\t\tgf_fprintf(trace, \"}\\\" \");\n\t}\n\n\tif (a->registry->max_version_plus_one) {\n\t\tgf_fprintf(trace, \"Version=\\\"%d\\\" Flags=\\\"%d\\\" \", ((GF_FullBox*)a)->version,((GF_FullBox*)a)->flags);\n\t}\n\tgf_fprintf(trace, \"Specification=\\\"%s\\\" \", a->registry->spec);\n\n\t//don't write containers in test mode, that would require rewriting hashes whenever spec changes\n\tif (!gf_sys_is_test_mode()) {\n\t\tgf_fprintf(trace, \"Container=\\\"%s\\\" \", a->registry->parents_4cc);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace)\n{\n\tGF_Box *a = (GF_Box *) ptr;\n\n\tif (!a) {\n\t\tgf_fprintf(trace, \"<!--ERROR: NULL Box Found-->\\n\");\n\t\treturn GF_OK;\n\t}\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] trying to dump box %s not registered\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->registry->dump_fn(a, trace);\n\treturn GF_OK;\n}\n\nvoid gf_isom_box_dump_done(const char *name, GF_Box *ptr, FILE *trace)\n{\n\tif (ptr && ptr->child_boxes) {\n\t\tgf_isom_box_array_dump(ptr->child_boxes, trace);\n\t}\n\tif (name)\n\t\tgf_fprintf(trace, \"</%s>\\n\", name);\n}\n\nBool gf_isom_box_is_file_level(GF_Box *s)\n{\n\tif (!s || !s->registry) return GF_FALSE;\n\tif (strstr(s->registry->parents_4cc, \"file\")!= NULL) return GF_TRUE;\n\tif (strstr(s->registry->parents_4cc, \"*\")!= NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n#endif\n\n\nGF_Box *gf_isom_box_find_child(GF_List *children, u32 code)\n{\n\tu32 i, count;\n\tif (!children) return NULL;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c->type==code) return c;\n\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tif (((GF_UnknownBox*)c)->original_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (((GF_UUIDBox*)c)->internal_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nBool gf_isom_box_check_unique(GF_List *children, GF_Box *a)\n{\n\tu32 i, count;\n\tif (!children) return GF_TRUE;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c==a) continue;\n\t\tif (c->type==a->type) return GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\nvoid gf_isom_box_del_parent(GF_List **child_boxes, GF_Box*b)\n{\n\tif (child_boxes) {\n\t\tgf_list_del_item(*child_boxes, b);\n\t\tif (!gf_list_count(*child_boxes)) {\n\t\t\tgf_list_del(*child_boxes);\n\t\t\t*child_boxes = NULL;\n\t\t}\n\t}\n\tgf_isom_box_del(b);\n}\n\nvoid gf_isom_box_remove_from_parent(GF_Box *parent_box, GF_Box *box)\n{\n\tif (parent_box && parent_box->registry && parent_box->registry->add_rem_fn) {\n\t\tparent_box->registry->add_rem_fn(parent_box, box, GF_TRUE);\n\t}\n}\n\nGF_Box *gf_isom_box_new_parent(GF_List **parent, u32 code)\n{\n\tGF_Box *b = gf_isom_box_new(code);\n\tif (!b) return NULL;\n\tif (! (*parent) ) (*parent)  = gf_list_new();\n\tgf_list_add(*parent, b);\n\treturn b;\n}\n\nvoid gf_isom_box_freeze_order(GF_Box *box)\n{\n\tu32 i=0;\n\tGF_Box *child;\n\tif (!box) return;\n\tbox->internal_flags |= GF_ISOM_ORDER_FREEZE;\n\n\twhile ((child = gf_list_enum(box->child_boxes, &i))) {\n\t\tgf_isom_box_freeze_order(child);\n\t}\n\n}\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/network.h>\n#include <gpac/thread.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n/**************************************************************\n\t\tSome Local functions for movie creation\n**************************************************************/\nGF_Err gf_isom_parse_root_box(GF_Box **outBox, GF_BitStream *bs, u32 *boxType, u64 *bytesExpected, Bool progressive_mode);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err MergeFragment(GF_MovieFragmentBox *moof, GF_ISOFile *mov)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tu64 MaxDur;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrackBox *trak;\n\tu64 base_data_offset;\n\n\tMaxDur = 0;\n\n\t//we shall have a MOOV and its MVEX BEFORE any MOOF\n\tif (!mov->moov || !mov->moov->mvex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: %s not received before merging fragment\\n\", mov->moov ? \"mvex\" : \"moov\" ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//and all fragments should be continous but:\n\t//- dash with dependent representations may likely give R1(moofSN 1, 3, 5, 7) plus R2(moofSN 2, 4, 6, 8)\n\t//- smooth muxed in a single file may end up with V(1),A(1), V(2),A(2) ...\n\t//we do not throw an error if not as we may still want to be able to concatenate dependent representations in DASH and\n\tif (mov->NextMoofNumber && moof->mfhd && (mov->NextMoofNumber >= moof->mfhd->sequence_number)) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] wrong sequence number: got %d but last one was %d\\n\", moof->mfhd->sequence_number, mov->NextMoofNumber));\n\t}\n\n\tbase_data_offset = mov->current_top_box_start;\n\tif (moof->compressed_diff)\n\t\tbase_data_offset -= moof->compressed_diff;\n\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(moof->TrackList, &i))) {\n\t\tu32 prev_sample_count;\n\t\tif (!traf->tfhd) {\n\t\t\ttrak = NULL;\n\t\t\ttraf->trex = NULL;\n\t\t} else if (mov->is_smooth) {\n\t\t\ttrak = gf_list_get(mov->moov->trackList, 0);\n\t\t\ttraf->trex = (GF_TrackExtendsBox*)gf_list_get(mov->moov->mvex->TrackExList, 0);\n\t\t\tassert(traf->trex);\n\t\t\ttraf->trex->trackID = trak->Header->trackID = traf->tfhd->trackID;\n\t\t} else {\n\t\t\ttrak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\tj=0;\n\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) break;\n\t\t\t\ttraf->trex = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (!trak || !traf->trex) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: Cannot find fragment track with ID %d\\n\", traf->tfhd ? traf->tfhd->trackID : 0));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tprev_sample_count = trak->Media->information->sampleTable->SampleSize ? trak->Media->information->sampleTable->SampleSize->sampleCount : 0;\n\t\te = MergeTrack(trak, traf, moof, mov->current_top_box_start, moof->compressed_diff, &base_data_offset);\n\t\tif (e) return e;\n\t\ttrak->first_traf_merged = GF_TRUE;\n\n\t\ttrak->present_in_scalable_segment = 1;\n\n\t\t//update trak duration\n\t\tSetTrackDuration(trak);\n\t\tif (trak->Header->duration > MaxDur)\n\t\t\tMaxDur = trak->Header->duration;\n\n\t\t//we have PSSH per moov, internally remap as a sample group of type PSSH\n\t\tif (gf_list_count(moof->PSSHs)) {\n\t\t\tu8 *pssh_data;\n\t\t\tu32 pssh_len;\n\t\t\tu32 j, k, nb_pssh = gf_list_count(moof->PSSHs);\n\t\t\tGF_BitStream *pssh_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(pssh_bs, nb_pssh);\n\t\t\tfor (j=0; j<nb_pssh; j++) {\n\t\t\t\tGF_ProtectionSystemHeaderBox *pssh = gf_list_get(moof->PSSHs, j);\n\t\t\t\tgf_bs_write_data(pssh_bs, pssh->SystemID, 16);\n\t\t\t\tgf_bs_write_u32(pssh_bs, pssh->version);\n\t\t\t\tif (pssh->version) {\n\t\t\t\t\tgf_bs_write_u32(pssh_bs, pssh->KID_count);\n\t\t\t\t\tfor (k=0; k<pssh->KID_count; k++) {\n\t\t\t\t\t\tgf_bs_write_data(pssh_bs, pssh->KIDs[k], 16);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_u32(pssh_bs, pssh->private_data_size);\n\t\t\t\tgf_bs_write_data(pssh_bs, pssh->private_data, pssh->private_data_size);\n\t\t\t}\n\t\t\tgf_bs_get_content(pssh_bs, &pssh_data, &pssh_len);\n\t\t\tgf_bs_del(pssh_bs);\n\n\t\t\tgf_isom_set_sample_group_description_internal(mov, gf_list_find(mov->moov->trackList, trak)+1, 1+prev_sample_count, GF_4CC('P','S','S','H'), 0, pssh_data, pssh_len, GF_FALSE);\n\t\t\tgf_free(pssh_data);\n\t\t}\n\n\n\t\t//we have emsg, internally remap as a sample group of type EMSG\n\t\tif (gf_list_count(mov->emsgs)) {\n\t\t\tu8 *emsg_data;\n\t\t\tu32 emsg_len;\n\t\t\tu32 j, nb_emsg = gf_list_count(mov->emsgs);\n\t\t\tGF_BitStream *emsg_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tfor (j=0; j<nb_emsg; j++) {\n\t\t\t\tGF_Box *emsg = gf_list_get(mov->emsgs, j);\n\t\t\t\tgf_isom_box_write(emsg, emsg_bs);\n\t\t\t}\n\t\t\tgf_bs_get_content(emsg_bs, &emsg_data, &emsg_len);\n\t\t\tgf_bs_del(emsg_bs);\n\n\t\t\tgf_isom_set_sample_group_description_internal(mov, gf_list_find(mov->moov->trackList, trak)+1, 1+prev_sample_count, GF_4CC('E','M','S','G'), 0, emsg_data, emsg_len, GF_FALSE);\n\t\t\tgf_free(emsg_data);\n\t\t}\n\t}\n\tif (mov->emsgs) {\n\t\tgf_isom_box_array_del(mov->emsgs);\n\t\tmov->emsgs = NULL;\n\t}\n\n\tif (moof->child_boxes) {\n\t\tGF_Box *a;\n\t\ti = 0;\n\t\twhile ((a = (GF_Box *)gf_list_enum(moof->child_boxes, &i))) {\n\t\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(&mov->moov->child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\t\tif (!pssh) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->SystemID, ((GF_ProtectionSystemHeaderBox *)a)->SystemID, 16);\n\t\t\t\tif (((GF_ProtectionSystemHeaderBox *)a)->KIDs && ((GF_ProtectionSystemHeaderBox *)a)->KID_count > 0) {\n\t\t\t\t\tpssh->KID_count = ((GF_ProtectionSystemHeaderBox *)a)->KID_count;\n\t\t\t\t\tpssh->KIDs = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));\n\t\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tmemmove(pssh->KIDs, ((GF_ProtectionSystemHeaderBox *)a)->KIDs, pssh->KID_count*sizeof(bin128));\n\t\t\t\t}\n\t\t\t\tpssh->private_data_size = ((GF_ProtectionSystemHeaderBox *)a)->private_data_size;\n\t\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->private_data, ((GF_ProtectionSystemHeaderBox *)a)->private_data, pssh->private_data_size);\n\t\t\t\tpssh->moof_defined = 1;\n\t\t\t\tmov->has_pssh_moof = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tmov->NextMoofNumber = moof->mfhd ? moof->mfhd->sequence_number : 0;\n\t//update movie duration\n\tif (mov->moov->mvhd->duration < MaxDur) mov->moov->mvhd->duration = MaxDur;\n\treturn GF_OK;\n}\n\nstatic void FixTrackID(GF_ISOFile *mov)\n{\n\tif (!mov->moov) return;\n\n\tif (gf_list_count(mov->moov->trackList) == 1 && gf_list_count(mov->moof->TrackList) == 1) {\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox*)gf_list_get(mov->moof->TrackList, 0);\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(mov->moov->trackList, 0);\n\t\tif (!traf->tfhd || !trak->Header) return;\n\t\tif ((traf->tfhd->trackID != trak->Header->trackID)) {\n\t\t\tif (!mov->is_smooth) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: trackID of MOOF/TRAF(%u) is not the same as MOOV/TRAK(%u). Trying to fix.\\n\", traf->tfhd->trackID, trak->Header->trackID));\n\t\t\t} else {\n\t\t\t\ttrak->Header->trackID = traf->tfhd->trackID;\n\t\t\t}\n\t\t\ttraf->tfhd->trackID = trak->Header->trackID;\n\t\t}\n\t}\n}\n\nstatic void FixSDTPInTRAF(GF_MovieFragmentBox *moof)\n{\n\tu32 k;\n\tif (!moof)\n\t\treturn;\n\n\tfor (k = 0; k < gf_list_count(moof->TrackList); k++) {\n\t\tGF_TrackFragmentBox *traf = gf_list_get(moof->TrackList, k);\n\t\tif (traf->sdtp) {\n\t\t\tGF_TrackFragmentRunBox *trun;\n\t\t\tu32 j = 0, sample_index = 0;\n\n\t\t\tif (traf->sdtp->sampleCount == gf_list_count(traf->TrackRuns)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TRAF box of track id=%u contains a SDTP. Converting to TRUN sample flags.\\n\", traf->tfhd->trackID));\n\t\t\t}\n\n\t\t\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &j))) {\n\t\t\t\tu32 i;\n\t\t\t\ttrun->flags |= GF_ISOM_TRUN_FLAGS;\n\t\t\t\tfor (i=0; i<trun->nb_samples; i++) {\n\t\t\t\t\tGF_TrunEntry *entry = &trun->samples[i];\n\t\t\t\t\tconst u8 info = traf->sdtp->sample_info[sample_index];\n\t\t\t\t\tentry->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(info >> 6, info >> 4, info >> 2, info);\n\t\t\t\t\tsample_index++;\n\t\t\t\t\tif (sample_index > traf->sdtp->sampleCount) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: TRAF box of track id=%u contained an inconsistent SDTP.\\n\", traf->tfhd->trackID));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sample_index < traf->sdtp->sampleCount) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: TRAF box of track id=%u list less samples than SDTP.\\n\", traf->tfhd->trackID));\n\t\t\t}\n\t\t\tgf_isom_box_del_parent(&traf->child_boxes, (GF_Box*)traf->sdtp);\n\t\t\ttraf->sdtp = NULL;\n\t\t}\n\t}\n}\n\nvoid gf_isom_push_mdat_end(GF_ISOFile *mov, u64 mdat_end)\n{\n\tu32 i, count;\n\tif (!mov || !mov->moov) return;\n\n\tcount = gf_list_count(mov->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_TrafToSampleMap *traf_map;\n\t\tGF_TrackBox *trak = gf_list_get(mov->moov->trackList, i);\n\t\tif (!trak->Media->information->sampleTable->traf_map) continue;\n\n\t\ttraf_map = trak->Media->information->sampleTable->traf_map;\n\t\tfor (j=traf_map->nb_entries; j>0; j--) {\n\t\t\tif (!traf_map->frag_starts[j-1].mdat_end) {\n\t\t\t\ttraf_map->frag_starts[j-1].mdat_end = mdat_end;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifdef GF_ENABLE_CTRN\nstatic void gf_isom_setup_traf_inheritance(GF_ISOFile *mov)\n{\n\tu32 i, count;\n\tif (!mov->moov->mvex)\n\t\treturn;\n\tcount = gf_list_count(mov->moov->trackList);\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 refTrackNum=0;\n\t\tgf_isom_get_reference(mov, i+1, GF_ISOM_REF_TRIN, 1, &refTrackNum);\n\t\tif (refTrackNum) {\n\t\t\tGF_ISOTrackID tkid = gf_isom_get_track_id(mov, i+1);\n\t\t\tGF_ISOTrackID reftkid = gf_isom_get_track_id(mov, refTrackNum);\n\t\t\tGF_TrackExtendsBox *trex = GetTrex(mov->moov, tkid);\n\t\t\tif (trex) trex->inherit_from_traf_id = reftkid;\n\t\t}\n\t}\n}\n#endif\n\n#endif\n\n//for now we only use regular sample to group internally (except when dumping), not the pattern version\n//we unrill the pattern and replace the compact version with a regular one\nstatic void convert_compact_sample_groups(GF_List *child_boxes, GF_List *sampleGroups)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(sampleGroups); i++) {\n\t\tu32 j;\n\t\tGF_SampleGroupBox *sbgp;\n\t\tGF_CompactSampleGroupBox *csgp = gf_list_get(sampleGroups, i);\n\t\tif (csgp->type != GF_ISOM_BOX_TYPE_CSGP) continue;\n\n\t\tgf_list_rem(sampleGroups, i);\n\t\tgf_list_del_item(child_boxes, csgp);\n\n\t\tsbgp = (GF_SampleGroupBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SBGP);\n\t\tgf_list_insert(sampleGroups, sbgp, i);\n\t\tgf_list_add(child_boxes, sbgp);\n\t\ti--;\n\n\t\tsbgp->grouping_type = csgp->grouping_type;\n\t\tif (csgp->grouping_type_parameter) {\n\t\t\tsbgp->grouping_type_parameter = csgp->grouping_type_parameter;\n\t\t\tsbgp->version = 1;\n\t\t}\n\t\tsbgp->entry_count = 0;\n\t\tfor (j=0; j<csgp->pattern_count; j++) {\n\t\t\tu32 k=0;\n\t\t\tu32 nb_samples = csgp->patterns[j].sample_count;\n\t\t\t//unroll the pattern\n\t\t\twhile (nb_samples) {\n\t\t\t\tu32 nb_same_index=1;\n\t\t\t\tif (csgp->patterns[j].length<=k)\n\t\t\t\t\tbreak;\n\t\t\t\tu32 sg_idx = csgp->patterns[j].sample_group_description_indices[k];\n\t\t\t\twhile (nb_same_index+k<csgp->patterns[j].length) {\n\t\t\t\t\tif (csgp->patterns[j].sample_group_description_indices[k+nb_same_index] != sg_idx)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tnb_same_index++;\n\t\t\t\t}\n\t\t\t\tsbgp->sample_entries = gf_realloc(sbgp->sample_entries, sizeof(GF_SampleGroupEntry) * (sbgp->entry_count+1));\n\t\t\t\tif (nb_same_index>nb_samples)\n\t\t\t\t\tnb_same_index = nb_samples;\n\n\t\t\t\tsbgp->sample_entries[sbgp->entry_count].sample_count = nb_same_index;\n\t\t\t\tsbgp->sample_entries[sbgp->entry_count].group_description_index = sg_idx;\n\t\t\t\tnb_samples -= nb_same_index;\n\t\t\t\tsbgp->entry_count++;\n\t\t\t\tk+= nb_same_index;\n\t\t\t\tif (k==csgp->patterns[j].length)\n\t\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t\tgf_isom_box_del((GF_Box*)csgp);\n\t}\n}\n\n\nstatic GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Box *a;\n\tu64 totSize, mdat_end=0;\n\tGF_Err e = GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (mov->single_moof_mode && mov->single_moof_state == 2) {\n\t\treturn e;\n\t}\n\n\t/*restart from where we stopped last*/\n\ttotSize = mov->current_top_box_start;\n\tif (mov->bytes_removed) {\n\t\tassert(totSize >= mov->bytes_removed);\n\t\ttotSize -= mov->bytes_removed;\n\t}\n\tgf_bs_seek(mov->movieFileMap->bs, totSize);\n#endif\n\n\n\t/*while we have some data, parse our boxes*/\n\twhile (gf_bs_available(mov->movieFileMap->bs)) {\n\t\t*bytesMissing = 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Parsing a top-level box at position %d\\n\", mov->current_top_box_start));\n#endif\n\n\t\te = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);\n\n\t\tif (e >= 0) {\n\t\t\t//safety check, should never happen\n\t\t\tif (!a) return GF_ISOM_INVALID_FILE;\n\t\t} else if (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t\t/*our mdat is uncomplete, only valid for READ ONLY files...*/\n\t\t\tif (mov->openMode != GF_ISOM_OPEN_READ) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete MDAT while file is not read-only\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete file while reading for dump - aborting parsing\\n\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn e;\n\t\t} else {\n\t\t\treturn e;\n\t\t}\n\n\t\tswitch (a->type) {\n\t\t/*MOOV box*/\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tif (mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate MOOV detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->moov = (GF_MovieBox *)a;\n\t\t\tmov->original_moov_offset = mov->current_top_box_start;\n\t\t\t/*set our pointer to the movie*/\n\t\t\tmov->moov->mov = mov;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->moov->mvex) mov->moov->mvex->mov = mov;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tgf_isom_setup_traf_inheritance(mov);\n\t\t\t}\n#endif\n\n#endif\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\n\t\t\ttotSize += a->size;\n\n            if (!mov->moov->mvhd) {\n                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n                return GF_ISOM_INVALID_FILE;\n            }\n\n            if (mov->meta) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\n\t\t\t//dump senc info in dump mode\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\n\t\t\t\t\tif (trak->sample_encryption) {\n\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\t\t\t\t\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n            if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                gf_isom_push_mdat_end(mov, mdat_end);\n                mdat_end=0;\n            }\n\t\t\tbreak;\n\n\t\t/*META box*/\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tif (mov->meta) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate META detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->meta = (GF_MetaBox *)a;\n\t\t\tmov->original_meta_offset = mov->current_top_box_start;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\tbreak;\n\n\t\t/*we only keep the MDAT in READ for dump purposes*/\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tif (!mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->emsgs) {\n\t\t\t\tgf_isom_box_array_del(mov->emsgs);\n\t\t\t\tmov->emsgs = NULL;\n\t\t\t}\n#endif\n\n\t\t\tif (mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t\t\tif (!mov->mdat) {\n\t\t\t\t\tmov->mdat = (GF_MediaDataBox *) a;\n\t\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\telse if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);\n#endif\n\t\t\t\telse gf_isom_box_del(a); //in other modes we don't care\n\n\n\t\t\t\tif (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                    mdat_end = gf_bs_get_position(mov->movieFileMap->bs);\n                    if (mov->moov) {\n                        gf_isom_push_mdat_end(mov, mdat_end);\n                        mdat_end=0;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if we don't have any MDAT yet, create one (edit-write mode)\n\t\t\tWe only work with one mdat, but we're puting it at the place\n\t\t\tof the first mdat found when opening a file for editing*/\n\t\t\telse if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\tif (e) {\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->brand) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'ftyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->brand = (GF_FileTypeBox *)a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_OTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->otyp) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'otyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tmov->otyp = (GF_Box *)a;\n\t\t\t\ttotSize += a->size;\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\tGF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);\n\t\t\t\tif (brand) {\n\t\t\t\t\ts32 pos;\n\t\t\t\t\tgf_list_del_item(a->child_boxes, brand);\n\t\t\t\t\tpos = gf_list_del_item(mov->TopBoxes, mov->brand);\n\t\t\t\t\tgf_isom_box_del((GF_Box *) mov->brand);\n\t\t\t\t\tmov->brand = brand;\n\t\t\t\t\tif (pos<0) pos=0;\n\t\t\t\t\tgf_list_insert(mov->TopBoxes, brand, pos);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t/*ONE AND ONLY ONE PDIN*/\n\t\t\tif (mov->pdin) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'pdin'' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->pdin = (GF_ProgressiveDownloadBox *) a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\t{\n\t\t\tu32 brand = ((GF_FileTypeBox *)a)->majorBrand;\n\t\t\tswitch (brand) {\n\t\t\tcase GF_ISOM_BRAND_SISX:\n\t\t\tcase GF_ISOM_BRAND_RISX:\n\t\t\tcase GF_ISOM_BRAND_SSSS:\n\t\t\t\tmov->is_index_segment = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*fall-through*/\n\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\t\tif (mov->moov && !mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)\n\t\t\t) {\n\t\t\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t\t\tif (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);\n\t\t\t\t\tmov->root_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\t\tmov->sidx_start_offset = mov->current_top_box_start;\n\t\t\t\t\tmov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);\n\n\t\t\t\t}\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_STYP) {\n\t\t\t\t\tmov->styp_start_offset = mov->current_top_box_start;\n\n\t\t\t\t\tif (mov->seg_styp) gf_isom_box_del(mov->seg_styp);\n\t\t\t\t\tmov->seg_styp = a;\n\t\t\t\t} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t\t\tif (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);\n\t\t\t\t\tmov->seg_ssix = a;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t\tgf_isom_push_mdat_end(mov, mov->current_top_box_start);\n\t\t\t} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {\n\t\t\t\tif (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);\n\t\t\t\tmov->main_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\tmov->main_sidx_end_pos = mov->current_top_box_start + a->size;\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n\t\t\t//no support for inplace rewrite for fragmented files\n\t\t\tgf_isom_disable_inplace_rewrite(mov);\n\t\t\tif (!mov->moov) {\n\t\t\t\tGF_LOG(mov->moof ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\\n\"));\n\t\t\t}\n\t\t\tif (mov->single_moof_mode) {\n\t\t\t\tmov->single_moof_state++;\n\t\t\t\tif (mov->single_moof_state > 1) {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t\t((GF_MovieFragmentBox *)a)->mov = mov;\n\n\t\t\ttotSize += a->size;\n\t\t\tmov->moof = (GF_MovieFragmentBox *) a;\n\n\t\t\t/*some smooth streaming streams contain a SDTP under the TRAF: this is incorrect, convert it*/\n\t\t\tFixTrackID(mov);\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tFixSDTPInTRAF(mov->moof);\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\tif (traf->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*read & debug: store at root level*/\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tgf_list_add(mov->TopBoxes, a);\n\t\t\t\t/*also update pointers to trex for debug*/\n\t\t\t\tif (mov->moov) {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tu32 j=0;\n\t\t\t\t\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\t\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) {\n\t\t\t\t\t\t\t\t\tif (!traf->trex->track) traf->trex->track = trak;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttraf->trex = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we should only parse senc/psec when no saiz/saio is present, otherwise we fetch the info directly\n\t\t\t\t\t\tif (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tif (trak) {\n\t\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\t\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->sample_encryption) {\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {\n\t\t\t\tmov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;\n\t\t\t\tmov->moof = NULL;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\t/*merge all info*/\n\t\t\t\te = MergeFragment((GF_MovieFragmentBox *)a, mov);\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\t//done with moov\n\t\t\tif (mov->root_sidx) {\n\t\t\t\tgf_isom_box_del((GF_Box *) mov->root_sidx);\n\t\t\t\tmov->root_sidx = NULL;\n\t\t\t}\n\t\t\tif (mov->root_ssix) {\n\t\t\t\tgf_isom_box_del(mov->seg_ssix);\n\t\t\t\tmov->root_ssix = NULL;\n\t\t\t}\n\t\t\tif (mov->seg_styp) {\n\t\t\t\tgf_isom_box_del(mov->seg_styp);\n\t\t\t\tmov->seg_styp = NULL;\n\t\t\t}\n\t\t\tmov->sidx_start_offset = 0;\n\t\t\tmov->sidx_end_offset = 0;\n\t\t\tmov->styp_start_offset = 0;\n\t\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t{\n\t\t\tGF_UnknownBox *box = (GF_UnknownBox*)a;\n\t\t\tif (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {\n\t\t\t\tu8 *c = (u8 *) box->data;\n\t\t\t\tif ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))\n\t\t\t\t\tmov->is_jp2 = 1;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PRFT:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\t//keep the last one read\n\t\t\t\tif (mov->last_producer_ref_time)\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\telse\n\t\t\t\t\tmov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t//fallthrough\n\t\tcase GF_ISOM_BOX_TYPE_EMSG:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tif (!mov->emsgs) mov->emsgs = gf_list_new();\n\t\t\t\tgf_list_add(mov->emsgs, a);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_MFRA:\n\t\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\t\t//only keep for dump mode, otherwise we ignore these boxes and we don't want to carry them over in non-fragmented file\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\ttotSize += a->size;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*remember where we left, in case we append an entire number of movie fragments*/\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n#endif\n\t}\n\n\t/*we need at least moov or meta*/\n\tif (!mov->moov && !mov->meta\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t        && !mov->moof && !mov->is_index_segment\n#endif\n\t   ) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\t/*we MUST have movie header*/\n\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\tif (mov->moov && !mov->moov->mvhd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MVHD in MOOV!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t/*we MUST have meta handler*/\n\t\tif (mov->meta && !mov->meta->handler) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing handler in META!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tif (mov->moov) {\n\t\t/*set the default interleaving time*/\n\t\tmov->interleavingTime = mov->moov->mvhd->timeScale;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*in edit mode with successfully loaded fragments, delete all fragment signaling since\n\t\tfile is no longer fragmented*/\n\t\tif ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);\n\t\t\tmov->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t}\n\n\t//create a default mdat if none was found\n\tif (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\tif (e) return e;\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn GF_OK;\n}\n\nextern u64 unused_bytes;\n\nGF_Err gf_isom_parse_movie_boxes(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Err e;\n\tGF_Blob *blob = NULL;\n\n\t//if associated file is a blob, lock blob before parsing !\n\tif (mov->movieFileMap && ((mov->movieFileMap->type == GF_ISOM_DATA_MEM) || (mov->movieFileMap->type == GF_ISOM_DATA_FILE))) {\n\t\tblob = ((GF_FileDataMap *)mov->movieFileMap)->blob;\n\t}\n\n\tif (blob)\n\t\tgf_mx_p(blob->mx);\n\n\tunused_bytes = 0;\n\te = gf_isom_parse_movie_boxes_internal(mov, boxType, bytesMissing, progressive_mode);\n\n\tif (blob)\n\t\tgf_mx_v(blob->mx);\n\treturn e;\n\n}\n\nGF_ISOFile *gf_isom_new_movie()\n{\n\tGF_ISOFile *mov = (GF_ISOFile*)gf_malloc(sizeof(GF_ISOFile));\n\tif (mov == NULL) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\treturn NULL;\n\t}\n\tmemset(mov, 0, sizeof(GF_ISOFile));\n\n\t/*init the boxes*/\n\tmov->TopBoxes = gf_list_new();\n\tif (!mov->TopBoxes) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\tgf_free(mov);\n\t\treturn NULL;\n\t}\n\n\t/*default storage mode is flat*/\n\tmov->storageMode = GF_ISOM_STORE_FLAT;\n\tmov->es_id_default_sync = -1;\n\treturn mov;\n}\n\n//Create and parse the movie for READ - EDIT only\nGF_ISOFile *gf_isom_open_file(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_Err e;\n\tu64 bytes;\n\tGF_ISOFile *mov = gf_isom_new_movie();\n\tif (!mov || !fileName) return NULL;\n\n\tmov->fileName = gf_strdup(fileName);\n\tmov->openMode = OpenMode;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (OpenMode==GF_ISOM_OPEN_READ_DUMP)\n\t\tmov->store_traf_map = GF_TRUE;\n#endif\n\n\tif ( (OpenMode == GF_ISOM_OPEN_READ) || (OpenMode == GF_ISOM_OPEN_READ_DUMP) || (OpenMode == GF_ISOM_OPEN_READ_EDIT) ) {\n\t\tif (OpenMode == GF_ISOM_OPEN_READ_EDIT) {\n\t\t\tmov->openMode = GF_ISOM_OPEN_READ_EDIT;\n\n\t\t\t// create a memory edit map in case we add samples, typically during import\n\t\t\te = gf_isom_datamap_new(NULL, tmp_dir, GF_ISOM_DATA_MAP_WRITE, & mov->editFileMap);\n\t\t\tif (e) {\n\t\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\t\tgf_isom_delete_movie(mov);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tmov->openMode = GF_ISOM_OPEN_READ;\n\t\t}\n\t\tmov->es_id_default_sync = -1;\n\t\t//for open, we do it the regular way and let the GF_DataMap assign the appropriate struct\n\t\t//this can be FILE (the only one supported...) as well as remote\n\t\t//(HTTP, ...),not suported yet\n\t\t//the bitstream IS PART OF the GF_DataMap\n\t\t//as this is read-only, use a FileMapping. this is the only place where\n\t\t//we use file mapping\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &mov->movieFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (OpenMode == GF_ISOM_OPEN_READ_DUMP) {\n\t\t\tmov->FragmentsFlags |= GF_ISOM_FRAG_READ_DEBUG;\n\t\t}\n\t} else {\n\n#ifdef GPAC_DISABLE_ISOM_WRITE\n\t\t//not allowed for READ_ONLY lib\n\t\tgf_isom_delete_movie(mov);\n\t\tgf_isom_set_last_error(NULL, GF_ISOM_INVALID_MODE);\n\t\treturn NULL;\n\n#else\n\n\t\t//set a default output name for edited file\n\t\tmov->finalName = (char*)gf_malloc(strlen(fileName) + 5);\n\t\tif (!mov->finalName) {\n\t\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcpy(mov->finalName, \"out_\");\n\t\tstrcat(mov->finalName, fileName);\n\n\t\t//open the original file with edit tag\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_EDIT, &mov->movieFileMap);\n\t\t//if the file doesn't exist, we assume it's wanted and create one from scratch\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\t//and create a temp fileName for the edit\n\t\te = gf_isom_datamap_new(\"_gpac_isobmff_tmp_edit\", tmp_dir, GF_ISOM_DATA_MAP_WRITE, & mov->editFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmov->es_id_default_sync = -1;\n\n#endif\n\t}\n\n\t//OK, let's parse the movie...\n\tmov->LastError = gf_isom_parse_movie_boxes(mov, NULL, &bytes, 0);\n\n#if 0\n\tif (!mov->LastError && (OpenMode == GF_ISOM_OPEN_CAT_FRAGMENTS)) {\n\t\tgf_isom_datamap_del(mov->movieFileMap);\n\t\t/*reopen the movie file map in cat mode*/\n\t\tmov->LastError = gf_isom_datamap_new(fileName, tmp_dir, GF_ISOM_DATA_MAP_CAT, & mov->movieFileMap);\n\t}\n#endif\n\n\tif (mov->LastError) {\n\t\tgf_isom_set_last_error(NULL, mov->LastError);\n\t\tgf_isom_delete_movie(mov);\n\t\treturn NULL;\n\t}\n\n\tmov->nb_box_init_seg = gf_list_count(mov->TopBoxes);\n\treturn mov;\n}\n\nGF_Err gf_isom_set_write_callback(GF_ISOFile *mov,\n \t\t\tGF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size),\n\t\t\tGF_Err (*on_block_patch)(void *usr_data, u8 *block, u32 block_size, u64 block_offset, Bool is_insert),\n \t\t\tvoid *usr_data,\n \t\t\tu32 block_size)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->finalName && !strcmp(mov->finalName, \"_gpac_isobmff_redirect\")) {}\n\telse if (mov->fileName && !strcmp(mov->fileName, \"_gpac_isobmff_redirect\")) {}\n\telse return GF_BAD_PARAM;\n\tmov->on_block_out = on_block_out;\n\tmov->on_block_patch = on_block_patch;\n\tmov->on_block_out_usr_data = usr_data;\n\tmov->on_block_out_block_size = block_size;\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n\nu64 gf_isom_get_mp4time()\n{\n\tu32 calctime, msec;\n\tu64 ret;\n\tgf_utc_time_since_1970(&calctime, &msec);\n\tcalctime += GF_ISOM_MAC_TIME_OFFSET;\n\tret = calctime;\n\treturn ret;\n}\n\nvoid gf_isom_delete_movie(GF_ISOFile *mov)\n{\n\tif (!mov) return;\n\n\t//these are our two main files\n\tif (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->editFileMap) {\n\t\tgf_isom_datamap_del(mov->editFileMap);\n\t}\n\tif (mov->finalName) gf_free(mov->finalName);\n#endif\n\n\tgf_isom_box_array_del(mov->TopBoxes);\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_box_array_del(mov->moof_list);\n\tif (mov->mfra)\n\t\tgf_isom_box_del((GF_Box*)mov->mfra);\n\tif (mov->sidx_pts_store)\n\t\tgf_free(mov->sidx_pts_store);\n\tif (mov->sidx_pts_next_store)\n\t\tgf_free(mov->sidx_pts_next_store);\n\n\tif (mov->main_sidx)\n\t\tgf_isom_box_del((GF_Box*)mov->main_sidx);\n\n\tif (mov->block_buffer)\n\t\tgf_free(mov->block_buffer);\n#endif\n\tif (mov->last_producer_ref_time)\n\t\tgf_isom_box_del((GF_Box *) mov->last_producer_ref_time);\n\tif (mov->fileName) gf_free(mov->fileName);\n\tgf_free(mov);\n}\n\nGF_TrackBox *gf_isom_get_track_from_id(GF_MovieBox *moov, GF_ISOTrackID trackID)\n{\n\tu32 i, count;\n\tif (!moov || !trackID) return NULL;\n\n\tcount = gf_list_count(moov->trackList);\n\tfor (i = 0; i<count; i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(moov->trackList, i);\n\t\tif (trak->Header->trackID == trackID) return trak;\n\t}\n\treturn NULL;\n}\n\nGF_TrackBox *gf_isom_get_track_from_original_id(GF_MovieBox *moov, u32 originalID, u32 originalFile)\n{\n\tu32 i, count;\n\tif (!moov || !originalID) return NULL;\n\n\tcount = gf_list_count(moov->trackList);\n\tfor (i = 0; i<count; i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(moov->trackList, i);\n\t\tif ((trak->originalFile == originalFile) && (trak->originalID == originalID)) return trak;\n\t}\n\treturn NULL;\n}\n\nGF_TrackBox *gf_isom_get_track_from_file(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return NULL;\n\ttrak = gf_isom_get_track(movie->moov, trackNumber);\n\tif (!trak) movie->LastError = GF_BAD_PARAM;\n\treturn trak;\n}\n\n\n//WARNING: MOVIETIME IS EXPRESSED IN MEDIA TS\nGF_Err GetMediaTime(GF_TrackBox *trak, Bool force_non_empty, u64 movieTime, u64 *MediaTime, s64 *SegmentStartTime, s64 *MediaOffset, u8 *useEdit, u64 *next_edit_start_plus_one)\n{\n#if 0\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber;\n\tu64 firstDTS;\n#endif\n\tu32 i, count;\n\tBool last_is_empty = 0;\n\tu64 time, lastSampleTime;\n\ts64 mtime;\n\tGF_EdtsEntry *ent;\n\tDouble scale_ts;\n\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\tif (next_edit_start_plus_one) *next_edit_start_plus_one = 0;\n\t*useEdit = 1;\n\t*MediaTime = 0;\n\t//no segment yet...\n\t*SegmentStartTime = -1;\n\t*MediaOffset = -1;\n\tif (!trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale || !stbl->SampleSize) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//no samples...\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tlastSampleTime = 0;\n\t} else {\n\t\tlastSampleTime = trak->Media->mediaHeader->duration;\n\t}\n\n\t//No edits, 1 to 1 mapping\n\tif (! trak->editBox || !trak->editBox->editList) {\n\t\t*MediaTime = movieTime;\n\t\t//check this is in our media time line\n\t\tif ((*MediaTime > lastSampleTime)\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t        && !trak->moov->mov->moof\n#endif\n\t\t   ) {\n\t\t\t*MediaTime = lastSampleTime;\n\t\t}\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\t//browse the edit list and get the time\n\tscale_ts = trak->Media->mediaHeader->timeScale;\n\tscale_ts /= trak->moov->mvhd->timeScale;\n\n\ttime = 0;\n\tent = NULL;\n\tcount=gf_list_count(trak->editBox->editList->entryList);\n\tfor (i=0; i<count; i++) {\n\t\tent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, i);\n\t\tif ( (time + ent->segmentDuration) * scale_ts > movieTime) {\n\t\t\tif (!force_non_empty || (ent->mediaTime >= 0)) {\n\t\t\t\tif (next_edit_start_plus_one) *next_edit_start_plus_one = 1 + (u64) ((time + ent->segmentDuration) * scale_ts);\n\t\t\t\tgoto ent_found;\n\t\t\t}\n\t\t}\n\t\ttime += ent->segmentDuration;\n\t\tlast_is_empty = ent->segmentDuration ? 0 : 1;\n\t}\n\n\tif (last_is_empty) {\n\t\tent = (GF_EdtsEntry *)gf_list_last(trak->editBox->editList->entryList);\n\t\tif (ent->mediaRate == 0x10000) {\n\t\t\t*MediaTime = movieTime + ent->mediaTime;\n\t\t} else {\n\t\t\tent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, 0);\n\t\t\tif (ent->mediaRate == -0x10000) {\n\t\t\t\tu64 dur = (u64) (ent->segmentDuration * scale_ts);\n\t\t\t\t*MediaTime = (movieTime > dur) ? (movieTime-dur) : 0;\n\t\t\t}\n\t\t}\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\n\n\t//we had nothing in the list (strange file but compliant...)\n\t//return the 1 to 1 mapped vale of the last media sample\n\tif (!ent) {\n\t\t*MediaTime = movieTime;\n\t\t//check this is in our media time line\n\t\tif (*MediaTime > lastSampleTime) *MediaTime = lastSampleTime;\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\t//request for a bigger time that what we can give: return the last sample (undefined behavior...)\n\t*MediaTime = lastSampleTime;\n\treturn GF_OK;\n\nent_found:\n\t//OK, we found our entry, set the SegmentTime\n\t*SegmentStartTime = time;\n\n\t//we request an empty list, there's no media here...\n\tif (ent->mediaTime < 0) {\n\t\t*MediaTime = 0;\n\t\treturn GF_OK;\n\t}\n\t//we request a dwell edit\n\tif (! ent->mediaRate) {\n\t\t*MediaTime = ent->mediaTime;\n\t\t//no media offset\n\t\t*MediaOffset = 0;\n\t\t*useEdit = 2;\n\t\treturn GF_OK;\n\t}\n\n\t/*WARNING: this can be \"-1\" when doing searchForward mode (to prevent jumping to next entry)*/\n\tmtime = ent->mediaTime + movieTime - (time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale);\n\tif (mtime<0) mtime = 0;\n\t*MediaTime = (u64) mtime;\n\t*MediaOffset = ent->mediaTime;\n\n#if 0\n\t//\n\t//Sanity check: is the requested time valid ? This is to cope with wrong EditLists\n\t//we have the translated time, but we need to make sure we have a sample at this time ...\n\t//we have to find a COMPOSITION time\n\te = stbl_findEntryForTime(stbl, (u32) *MediaTime, 1, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//first case: our time is after the last sample DTS (it's a broken editList somehow)\n\t//set the media time to the last sample\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t*MediaTime = lastSampleTime;\n\t\treturn GF_OK;\n\t}\n\t//get the appropriated sample\n\tif (!sampleNumber) sampleNumber = prevSampleNumber;\n\n\tstbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\tCTS = 0;\n\tif (stbl->CompositionOffset) stbl_GetSampleCTS(stbl->CompositionOffset, sampleNumber, &CTS);\n\n\t//now get the entry sample (the entry time gives the CTS, and we need the DTS\n\te = stbl_findEntryForTime(stbl, (u32) ent->mediaTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//oops, the mediaTime indicates a sample that is not in our media !\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t*MediaTime = lastSampleTime;\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!sampleNumber) sampleNumber = prevSampleNumber;\n\n\tstbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &firstDTS);\n\n\t//and store the \"time offset\" of the desired sample in this segment\n\t//this is weird, used to rebuild the timeStamp when reading from the track, not the\n\t//media ...\n\t*MediaOffset = firstDTS;\n#endif\n\treturn GF_OK;\n}\n\nGF_Err GetNextMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime)\n{\n\tu32 i;\n\tu64 time;\n\tGF_EdtsEntry *ent;\n\n\t*OutMovieTime = 0;\n\tif (! trak->editBox || !trak->editBox->editList) return GF_BAD_PARAM;\n\n\ttime = 0;\n\tent = NULL;\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\tif (gf_timestamp_greater_or_equal(time, trak->moov->mvhd->timeScale, movieTime, trak->Media->mediaHeader->timeScale)) {\n\t\t\t/*skip empty edits*/\n\t\t\tif (ent->mediaTime >= 0) {\n\t\t\t\t*OutMovieTime = time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale;\n\t\t\t\tif (*OutMovieTime>0) *OutMovieTime -= 1;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\ttime += ent->segmentDuration;\n\t}\n\t//request for a bigger time that what we can give: return the last sample (undefined behavior...)\n\t*OutMovieTime = trak->moov->mvhd->duration;\n\treturn GF_EOS;\n}\n\nGF_Err GetPrevMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime)\n{\n\tu32 i;\n\tu64 time;\n\tGF_EdtsEntry *ent;\n\n\t*OutMovieTime = 0;\n\tif (! trak->editBox || !trak->editBox->editList) return GF_BAD_PARAM;\n\n\ttime = 0;\n\tent = NULL;\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\tif (ent->mediaTime == -1) {\n\t\t\tif ( gf_timestamp_greater_or_equal(time + ent->segmentDuration, trak->moov->mvhd->timeScale, movieTime, trak->Media->mediaHeader->timeScale)) {\n\t\t\t\t*OutMovieTime = gf_timestamp_rescale(time, trak->moov->mvhd->timeScale, trak->Media->mediaHeader->timeScale);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/*get the first entry whose end is greater than or equal to the desired time*/\n\t\ttime += ent->segmentDuration;\n\t\tif (gf_timestamp_greater_or_equal(time, trak->moov->mvhd->timeScale, movieTime, trak->Media->mediaHeader->timeScale)) {\n\t\t\t*OutMovieTime = time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t*OutMovieTime = 0;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_insert_moov(GF_ISOFile *file)\n{\n\tGF_MovieHeaderBox *mvhd;\n\tif (file->moov) return GF_OK;\n\n\t//OK, create our boxes (mvhd, iods, ...)\n\tfile->moov = (GF_MovieBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOV);\n\tif (!file->moov) return GF_OUT_OF_MEM;\n\tfile->moov->mov = file;\n\t//Header SetUp\n\tmvhd = (GF_MovieHeaderBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVHD);\n\tif (!mvhd) return GF_OUT_OF_MEM;\n\n\tif (gf_sys_is_test_mode() ) {\n\t\tmvhd->creationTime = mvhd->modificationTime = 0;\n\t} else {\n\t\tu64 now = gf_isom_get_mp4time();\n\t\tmvhd->creationTime = now;\n\t\tif (!file->keep_utc)\n\t\t\tmvhd->modificationTime = now;\n\t}\n\n\tmvhd->nextTrackID = 1;\n\t//600 is our default movie TimeScale\n\tmvhd->timeScale = 600;\n\n\tfile->interleavingTime = mvhd->timeScale;\n\tmoov_on_child_box((GF_Box*)file->moov, (GF_Box *)mvhd, GF_FALSE);\n\tgf_list_add(file->TopBoxes, file->moov);\n\treturn GF_OK;\n}\n\n//Create the movie for WRITE only\nGF_ISOFile *gf_isom_create_movie(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_Err e;\n\n\tGF_ISOFile *mov = gf_isom_new_movie();\n\tif (!mov) return NULL;\n\tmov->openMode = OpenMode;\n\t//then set up our movie\n\n\t//in WRITE, the input dataMap is ALWAYS NULL\n\tmov->movieFileMap = NULL;\n\n\t//but we have the edit one\n\tif (OpenMode == GF_ISOM_OPEN_WRITE) {\n\t\tconst char *ext;\n\t\t//THIS IS NOT A TEMP FILE, WRITE mode is used for \"live capture\"\n\t\t//this file will be the final file...\n\t\tmov->fileName = fileName ? gf_strdup(fileName) : NULL;\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_WRITE, &mov->editFileMap);\n\t\tif (e) goto err_exit;\n\n\t\t/*brand is set to ISOM or QT by default - it may be touched until sample data is added to track*/\n\t\text = gf_file_ext_start(fileName);\n\t\tif (ext && (!strnicmp(ext, \".mov\", 4) || !strnicmp(ext, \".qt\", 3))) {\n\t\t\tgf_isom_set_brand_info((GF_ISOFile *) mov, GF_ISOM_BRAND_QT, 512);\n\t\t} else {\n\t\t\tgf_isom_set_brand_info((GF_ISOFile *) mov, GF_ISOM_BRAND_ISOM, 1);\n\t\t}\n\t} else {\n\t\t//we are in EDIT mode but we are creating the file -> temp file\n\t\tmov->finalName = fileName ? gf_strdup(fileName) : NULL;\n\t\te = gf_isom_datamap_new(\"_gpac_isobmff_tmp_edit\", tmp_dir, GF_ISOM_DATA_MAP_WRITE, &mov->editFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\t//brand is set to ISOM by default\n\t\tgf_isom_set_brand_info( (GF_ISOFile *) mov, GF_ISOM_BRAND_ISOM, 1);\n\t}\n\n\t//create an MDAT\n\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\tif (!mov->mdat) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\tgf_isom_delete_movie(mov);\n\t\treturn NULL;\n\t}\n\tgf_list_add(mov->TopBoxes, mov->mdat);\n\n\t//default behavior is capture mode, no interleaving (eg, no rewrite of mdat)\n\tmov->storageMode = GF_ISOM_STORE_FLAT;\n\treturn mov;\n\nerr_exit:\n\tgf_isom_set_last_error(NULL, e);\n\tif (mov) gf_isom_delete_movie(mov);\n\treturn NULL;\n}\n\nGF_EdtsEntry *CreateEditEntry(u64 EditDuration, u64 MediaTime, u32 MediaRate, u8 EditMode)\n{\n\tGF_EdtsEntry *ent;\n\n\tent = (GF_EdtsEntry*)gf_malloc(sizeof(GF_EdtsEntry));\n\tif (!ent) return NULL;\n\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = MediaRate;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\tent->segmentDuration = EditDuration;\n\treturn ent;\n}\n\nGF_Err gf_isom_add_subsample_info(GF_SubSampleInformationBox *sub_samples, u32 sampleNumber, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count, last_sample;\n\tGF_SubSampleInfoEntry *pSamp;\n\tGF_SubSampleEntry *pSubSamp;\n\n\tpSamp = NULL;\n\tlast_sample = 0;\n\tcount = gf_list_count(sub_samples->Samples);\n\tfor (i=0; i<count; i++) {\n\t\tpSamp = (GF_SubSampleInfoEntry*) gf_list_get(sub_samples->Samples, i);\n\t\t/*TODO - do we need to support insertion of subsample info ?*/\n\t\tif (last_sample + pSamp->sample_delta > sampleNumber) return GF_NOT_SUPPORTED;\n\t\tif (last_sample + pSamp->sample_delta == sampleNumber) break;\n\t\tlast_sample += pSamp->sample_delta;\n\t\tpSamp = NULL;\n\t}\n\n\tif (!pSamp) {\n\t\tGF_SAFEALLOC(pSamp, GF_SubSampleInfoEntry);\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tif (!pSamp->SubSamples ) {\n\t\t\tgf_free(pSamp);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tpSamp->sample_delta = sampleNumber - last_sample;\n\t\tgf_list_add(sub_samples->Samples, pSamp);\n\t}\n\n\tif ((subSampleSize>0xFFFF) && !sub_samples->version) {\n\t\tsub_samples->version = 1;\n\t}\n\t/*remove last subsample info*/\n\tif (!subSampleSize) {\n\t\tpSubSamp = gf_list_last(pSamp->SubSamples);\n\t\tgf_list_rem_last(pSamp->SubSamples);\n\t\tgf_free(pSubSamp);\n\t\tif (!gf_list_count(pSamp->SubSamples)) {\n\t\t\tgf_list_del_item(sub_samples->Samples, pSamp);\n\t\t\tgf_list_del(pSamp->SubSamples);\n\t\t\tgf_free(pSamp);\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t/*add subsample*/\n\tGF_SAFEALLOC(pSubSamp, GF_SubSampleEntry);\n\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\tpSubSamp->subsample_size = subSampleSize;\n\tpSubSamp->subsample_priority = priority;\n\tpSubSamp->reserved = reserved;\n\tpSubSamp->discardable = discardable;\n\treturn gf_list_add(pSamp->SubSamples, pSubSamp);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#if 0 //unused\nu32 gf_isom_sample_get_subsamples_count(GF_ISOFile *movie, u32 track)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!track) return 0;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return 0;\n\treturn gf_list_count(trak->Media->information->sampleTable->sub_samples);\n}\n#endif\n\nBool gf_isom_get_subsample_types(GF_ISOFile *movie, u32 track, u32 subs_index, u32 *flags)\n{\n\tGF_SubSampleInformationBox *sub_samples=NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\n\tif (!track || !subs_index) return GF_FALSE;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return GF_FALSE;\n\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, subs_index-1);\n\tif (!sub_samples) return GF_FALSE;\n\t*flags = sub_samples->flags;\n\treturn GF_TRUE;\n}\n\nu32 gf_isom_sample_get_subsample_entry(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, GF_SubSampleInfoEntry **sub_sample)\n{\n\tu32 i, count, last_sample;\n\tGF_SubSampleInformationBox *sub_samples=NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (sub_sample) *sub_sample = NULL;\n\tif (!track) return 0;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\t\tif (sub_samples->flags==flags) break;\n\t\tsub_samples = NULL;\n\t}\n\tif (!sub_samples) return 0;\n\n\tlast_sample = 0;\n\tcount = gf_list_count(sub_samples->Samples);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry *) gf_list_get(sub_samples->Samples, i);\n\t\tif (last_sample + pSamp->sample_delta == sampleNumber) {\n\t\t\tif (sub_sample) *sub_sample = pSamp;\n\t\t\treturn gf_list_count(pSamp->SubSamples);\n\t\t}\n\t\tlast_sample += pSamp->sample_delta;\n\t}\n\treturn 0;\n}\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/box_funcs.c", "src/isomedia/isom_intern.c"], "buggy_code_start_loc": [313, 376], "buggy_code_end_loc": [315, 377], "fixing_code_start_loc": [313, 376], "fixing_code_end_loc": [317, 378], "type": "CWE-476", "message": "GPAC 2.1-DEV-rev87-g053aae8-master. has a Null Pointer Dereference vulnerability in gf_isom_parse_movie_boxes_internal due to improper return value handling of GF_SKIP_BOX, which causes a Denial of Service. This vulnerability was fixed in commit 37592ad.", "other": {"cve": {"id": "CVE-2022-29340", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-05T13:15:07.967", "lastModified": "2022-05-13T18:28:46.020", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GPAC 2.1-DEV-rev87-g053aae8-master. has a Null Pointer Dereference vulnerability in gf_isom_parse_movie_boxes_internal due to improper return value handling of GF_SKIP_BOX, which causes a Denial of Service. This vulnerability was fixed in commit 37592ad."}, {"lang": "es", "value": "GPAC versi\u00f3n 2.1-DEV-rev87-g053aae8-master. presenta una vulnerabilidad de Desreferencia de Puntero Null en gf_isom_parse_movie_boxes_internal debido a un manejo inapropiado del valor de retorno de GF_SKIP_BOX, que causa una Denegaci\u00f3n de Servicio. Esta vulnerabilidad fue corregida en el commit 37592ad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-04-12", "matchCriteriaId": "A97931ED-0014-4D2C-969E-5B41DDFF9DD2"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/37592ad86c6ca934d34740012213e467acc4a3b0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/2163", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/37592ad86c6ca934d34740012213e467acc4a3b0"}}