{"buggy_code": ["<?php\n/*!\n * Medoo database framework\n * https://medoo.in\n * Version 1.7.3\n *\n * Copyright 2019, Angel Lai\n * Released under the MIT license\n */\n\nnamespace Medoo;\n\nuse PDO;\nuse Exception;\nuse PDOException;\nuse InvalidArgumentException;\n\nclass Raw {\n\tpublic $map;\n\tpublic $value;\n}\n\nclass Medoo\n{\n\tpublic $pdo;\n\n\tprotected $type;\n\n\tprotected $prefix;\n\n\tprotected $statement;\n\n\tprotected $dsn;\n\n\tprotected $logs = [];\n\n\tprotected $logging = false;\n\n\tprotected $debug_mode = false;\n\n\tprotected $guid = 0;\n\n\tpublic function __construct(array $options)\n\t{\n\t\tif (isset($options[ 'database_type' ]))\n\t\t{\n\t\t\t$this->type = strtolower($options[ 'database_type' ]);\n\n\t\t\tif ($this->type === 'mariadb')\n\t\t\t{\n\t\t\t\t$this->type = 'mysql';\n\t\t\t}\n\t\t}\n\n\t\tif (isset($options[ 'prefix' ]))\n\t\t{\n\t\t\t$this->prefix = $options[ 'prefix' ];\n\t\t}\n\n\t\tif (isset($options[ 'logging' ]) && is_bool($options[ 'logging' ]))\n\t\t{\n\t\t\t$this->logging = $options[ 'logging' ];\n\t\t}\n\n\t\t$option = isset($options[ 'option' ]) ? $options[ 'option' ] : [];\n\t\t$commands = (isset($options[ 'command' ]) && is_array($options[ 'command' ])) ? $options[ 'command' ] : [];\n\n\t\tswitch ($this->type)\n\t\t{\n\t\t\tcase 'mysql':\n\t\t\t\t// Make MySQL using standard quoted identifier\n\t\t\t\t$commands[] = 'SET SQL_MODE=ANSI_QUOTES';\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'mssql':\n\t\t\t\t// Keep MSSQL QUOTED_IDENTIFIER is ON for standard quoting\n\t\t\t\t$commands[] = 'SET QUOTED_IDENTIFIER ON';\n\n\t\t\t\t// Make ANSI_NULLS is ON for NULL value\n\t\t\t\t$commands[] = 'SET ANSI_NULLS ON';\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (isset($options[ 'pdo' ]))\n\t\t{\n\t\t\tif (!$options[ 'pdo' ] instanceof PDO)\n\t\t\t{\n\t\t\t\tthrow new InvalidArgumentException('Invalid PDO object supplied');\n\t\t\t}\n\n\t\t\t$this->pdo = $options[ 'pdo' ];\n\n\t\t\tforeach ($commands as $value)\n\t\t\t{\n\t\t\t\t$this->pdo->exec($value);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (isset($options[ 'dsn' ]))\n\t\t{\n\t\t\tif (is_array($options[ 'dsn' ]) && isset($options[ 'dsn' ][ 'driver' ]))\n\t\t\t{\n\t\t\t\t$attr = $options[ 'dsn' ];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new InvalidArgumentException('Invalid DSN option supplied');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (\n\t\t\t\tisset($options[ 'port' ]) &&\n\t\t\t\tis_int($options[ 'port' ] * 1)\n\t\t\t)\n\t\t\t{\n\t\t\t\t$port = $options[ 'port' ];\n\t\t\t}\n\n\t\t\t$is_port = isset($port);\n\n\t\t\tswitch ($this->type)\n\t\t\t{\n\t\t\t\tcase 'mysql':\n\t\t\t\t\t$attr = [\n\t\t\t\t\t\t'driver' => 'mysql',\n\t\t\t\t\t\t'dbname' => $options[ 'database_name' ]\n\t\t\t\t\t];\n\n\t\t\t\t\tif (isset($options[ 'socket' ]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr[ 'unix_socket' ] = $options[ 'socket' ];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr[ 'host' ] = $options[ 'server' ];\n\n\t\t\t\t\t\tif ($is_port)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$attr[ 'port' ] = $port;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'pgsql':\n\t\t\t\t\t$attr = [\n\t\t\t\t\t\t'driver' => 'pgsql',\n\t\t\t\t\t\t'host' => $options[ 'server' ],\n\t\t\t\t\t\t'dbname' => $options[ 'database_name' ]\n\t\t\t\t\t];\n\n\t\t\t\t\tif ($is_port)\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr[ 'port' ] = $port;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'sybase':\n\t\t\t\t\t$attr = [\n\t\t\t\t\t\t'driver' => 'dblib',\n\t\t\t\t\t\t'host' => $options[ 'server' ],\n\t\t\t\t\t\t'dbname' => $options[ 'database_name' ]\n\t\t\t\t\t];\n\n\t\t\t\t\tif ($is_port)\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr[ 'port' ] = $port;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'oracle':\n\t\t\t\t\t$attr = [\n\t\t\t\t\t\t'driver' => 'oci',\n\t\t\t\t\t\t'dbname' => $options[ 'server' ] ?\n\t\t\t\t\t\t\t'//' . $options[ 'server' ] . ($is_port ? ':' . $port : ':1521') . '/' . $options[ 'database_name' ] :\n\t\t\t\t\t\t\t$options[ 'database_name' ]\n\t\t\t\t\t];\n\n\t\t\t\t\tif (isset($options[ 'charset' ]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr[ 'charset' ] = $options[ 'charset' ];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mssql':\n\t\t\t\t\tif (isset($options[ 'driver' ]) && $options[ 'driver' ] === 'dblib')\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr = [\n\t\t\t\t\t\t\t'driver' => 'dblib',\n\t\t\t\t\t\t\t'host' => $options[ 'server' ] . ($is_port ? ':' . $port : ''),\n\t\t\t\t\t\t\t'dbname' => $options[ 'database_name' ]\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\tif (isset($options[ 'appname' ]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$attr[ 'appname' ] = $options[ 'appname' ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isset($options[ 'charset' ]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$attr[ 'charset' ] = $options[ 'charset' ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr = [\n\t\t\t\t\t\t\t'driver' => 'sqlsrv',\n\t\t\t\t\t\t\t'Server' => $options[ 'server' ] . ($is_port ? ',' . $port : ''),\n\t\t\t\t\t\t\t'Database' => $options[ 'database_name' ]\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\tif (isset($options[ 'appname' ]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$attr[ 'APP' ] = $options[ 'appname' ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$config = [\n\t\t\t\t\t\t\t'ApplicationIntent',\n\t\t\t\t\t\t\t'AttachDBFileName',\n\t\t\t\t\t\t\t'Authentication',\n\t\t\t\t\t\t\t'ColumnEncryption',\n\t\t\t\t\t\t\t'ConnectionPooling',\n\t\t\t\t\t\t\t'Encrypt',\n\t\t\t\t\t\t\t'Failover_Partner',\n\t\t\t\t\t\t\t'KeyStoreAuthentication',\n\t\t\t\t\t\t\t'KeyStorePrincipalId',\n\t\t\t\t\t\t\t'KeyStoreSecret',\n\t\t\t\t\t\t\t'LoginTimeout',\n\t\t\t\t\t\t\t'MultipleActiveResultSets',\n\t\t\t\t\t\t\t'MultiSubnetFailover',\n\t\t\t\t\t\t\t'Scrollable',\n\t\t\t\t\t\t\t'TraceFile',\n\t\t\t\t\t\t\t'TraceOn',\n\t\t\t\t\t\t\t'TransactionIsolation',\n\t\t\t\t\t\t\t'TransparentNetworkIPResolution',\n\t\t\t\t\t\t\t'TrustServerCertificate',\n\t\t\t\t\t\t\t'WSID',\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\tforeach ($config as $value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$keyname = strtolower(preg_replace(['/([a-z\\d])([A-Z])/', '/([^_])([A-Z][a-z])/'], '$1_$2', $value));\n\n\t\t\t\t\t\t\tif (isset($options[ $keyname ]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$attr[ $value ] = $options[ $keyname ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'sqlite':\n\t\t\t\t\t$attr = [\n\t\t\t\t\t\t'driver' => 'sqlite',\n\t\t\t\t\t\t$options[ 'database_file' ]\n\t\t\t\t\t];\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!isset($attr))\n\t\t{\n\t\t\tthrow new InvalidArgumentException('Incorrect connection options');\n\t\t}\n\n\t\t$driver = $attr[ 'driver' ];\n\n\t\tif (!in_array($driver, PDO::getAvailableDrivers()))\n\t\t{\n\t\t\tthrow new InvalidArgumentException(\"Unsupported PDO driver: {$driver}\");\n\t\t}\n\n\t\tunset($attr[ 'driver' ]);\n\n\t\t$stack = [];\n\n\t\tforeach ($attr as $key => $value)\n\t\t{\n\t\t\t$stack[] = is_int($key) ? $value : $key . '=' . $value;\n\t\t}\n\n\t\t$dsn = $driver . ':' . implode(';', $stack);\n\n\t\tif (\n\t\t\tin_array($this->type, ['mysql', 'pgsql', 'sybase', 'mssql']) &&\n\t\t\tisset($options[ 'charset' ])\n\t\t)\n\t\t{\n\t\t\t$commands[] = \"SET NAMES '{$options[ 'charset' ]}'\" . (\n\t\t\t\t$this->type === 'mysql' && isset($options[ 'collation' ]) ?\n\t\t\t\t\" COLLATE '{$options[ 'collation' ]}'\" : ''\n\t\t\t);\n\t\t}\n\n\t\t$this->dsn = $dsn;\n\n\t\ttry {\n\t\t\t$this->pdo = new PDO(\n\t\t\t\t$dsn,\n\t\t\t\tisset($options[ 'username' ]) ? $options[ 'username' ] : null,\n\t\t\t\tisset($options[ 'password' ]) ? $options[ 'password' ] : null,\n\t\t\t\t$option\n\t\t\t);\n\n\t\t\tforeach ($commands as $value)\n\t\t\t{\n\t\t\t\t$this->pdo->exec($value);\n\t\t\t}\n\t\t}\n\t\tcatch (PDOException $e) {\n\t\t\tthrow new PDOException($e->getMessage());\n\t\t}\n\t}\n\n\tpublic function query($query, $map = [])\n\t{\n\t\t$raw = $this->raw($query, $map);\n\n\t\t$query = $this->buildRaw($raw, $map);\n\n\t\treturn $this->exec($query, $map);\n\t}\n\n\tpublic function exec($query, $map = [])\n\t{\n\t\tif ($this->debug_mode)\n\t\t{\n\t\t\techo $this->generate($query, $map);\n\n\t\t\t$this->debug_mode = false;\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ($this->logging)\n\t\t{\n\t\t\t$this->logs[] = [$query, $map];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$this->logs = [[$query, $map]];\n\t\t}\n\n\t\t$statement = $this->pdo->prepare($query);\n\n\t\tif ($statement)\n\t\t{\n\t\t\tforeach ($map as $key => $value)\n\t\t\t{\n\t\t\t\t$statement->bindValue($key, $value[ 0 ], $value[ 1 ]);\n\t\t\t}\n\n\t\t\tif ($statement->execute())\n\t\t\t{\n\t\t\t\t$this->statement = $statement;\n\n\t\t\t\treturn $statement;\n\t\t\t}\n\t\t}\n\n\t\t$this->statement = null;\n\n\t\treturn false;\n\t}\n\n\tprotected function generate($query, $map)\n\t{\n\t\t$identifier = [\n\t\t\t'mysql' => '`$1`',\n\t\t\t'mssql' => '[$1]'\n\t\t];\n\n\t\t$query = preg_replace(\n\t\t\t'/\"([a-zA-Z0-9_]+)\"/i',\n\t\t\tisset($identifier[ $this->type ]) ?  $identifier[ $this->type ] : '\"$1\"',\n\t\t\t$query\n\t\t);\n\n\t\tforeach ($map as $key => $value)\n\t\t{\n\t\t\tif ($value[ 1 ] === PDO::PARAM_STR)\n\t\t\t{\n\t\t\t\t$replace = $this->quote($value[ 0 ]);\n\t\t\t}\n\t\t\telseif ($value[ 1 ] === PDO::PARAM_NULL)\n\t\t\t{\n\t\t\t\t$replace = 'NULL';\n\t\t\t}\n\t\t\telseif ($value[ 1 ] === PDO::PARAM_LOB)\n\t\t\t{\n\t\t\t\t$replace = '{LOB_DATA}';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$replace = $value[ 0 ];\n\t\t\t}\n\n\t\t\t$query = str_replace($key, $replace, $query);\n\t\t}\n\n\t\treturn $query;\n\t}\n\n\tpublic static function raw($string, $map = [])\n\t{\n\t\t$raw = new Raw();\n\n\t\t$raw->map = $map;\n\t\t$raw->value = $string;\n\n\t\treturn $raw;\n\t}\n\n\tprotected function isRaw($object)\n\t{\n\t\treturn $object instanceof Raw;\n\t}\n\n\tprotected function buildRaw($raw, &$map)\n\t{\n\t\tif (!$this->isRaw($raw))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t$query = preg_replace_callback(\n\t\t\t'/((FROM|TABLE|INTO|UPDATE)\\s*)?\\<([a-zA-Z0-9_\\.]+)\\>/i',\n\t\t\tfunction ($matches)\n\t\t\t{\n\t\t\t\tif (!empty($matches[ 2 ]))\n\t\t\t\t{\n\t\t\t\t\treturn $matches[ 2 ] . ' ' . $this->tableQuote($matches[ 3 ]);\n\t\t\t\t}\n\n\t\t\t\treturn $this->columnQuote($matches[ 3 ]);\n\t\t\t},\n\t\t\t$raw->value);\n\n\t\t$raw_map = $raw->map;\n\n\t\tif (!empty($raw_map))\n\t\t{\n\t\t\tforeach ($raw_map as $key => $value)\n\t\t\t{\n\t\t\t\t$map[ $key ] = $this->typeMap($value, gettype($value));\n\t\t\t}\n\t\t}\n\n\t\treturn $query;\n\t}\n\n\tpublic function quote($string)\n\t{\n\t\treturn $this->pdo->quote($string);\n\t}\n\n\tprotected function tableQuote($table)\n\t{\n\t\treturn '\"' . $this->prefix . $table . '\"';\n\t}\n\n\tprotected function mapKey()\n\t{\n\t\treturn ':MeDoO_' . $this->guid++ . '_mEdOo';\n\t}\n\n\tprotected function typeMap($value, $type)\n\t{\n\t\t$map = [\n\t\t\t'NULL' => PDO::PARAM_NULL,\n\t\t\t'integer' => PDO::PARAM_INT,\n\t\t\t'double' => PDO::PARAM_STR,\n\t\t\t'boolean' => PDO::PARAM_BOOL,\n\t\t\t'string' => PDO::PARAM_STR,\n\t\t\t'object' => PDO::PARAM_STR,\n\t\t\t'resource' => PDO::PARAM_LOB\n\t\t];\n\n\t\tif ($type === 'boolean')\n\t\t{\n\t\t\t$value = ($value ? '1' : '0');\n\t\t}\n\t\telseif ($type === 'NULL')\n\t\t{\n\t\t\t$value = null;\n\t\t}\n\n\t\treturn [$value, $map[ $type ]];\n\t}\n\n\tprotected function columnQuote($string)\n\t{\n\t\tif (strpos($string, '.') !== false)\n\t\t{\n\t\t\treturn '\"' . $this->prefix . str_replace('.', '\".\"', $string) . '\"';\n\t\t}\n\n\t\treturn '\"' . $string . '\"';\n\t}\n\n\tprotected function columnPush(&$columns, &$map, $root, $is_join = false)\n\t{\n\t\tif ($columns === '*')\n\t\t{\n\t\t\treturn $columns;\n\t\t}\n\n\t\t$stack = [];\n\n\t\tif (is_string($columns))\n\t\t{\n\t\t\t$columns = [$columns];\n\t\t}\n\n\t\tforeach ($columns as $key => $value)\n\t\t{\n\t\t\tif (!is_int($key) && is_array($value) && $root && count(array_keys($columns)) === 1)\n\t\t\t{\n\t\t\t\t$stack[] = $this->columnQuote($key);\n\n\t\t\t\t$stack[] = $this->columnPush($value, $map, false, $is_join);\n\t\t\t}\n\t\t\telseif (is_array($value))\n\t\t\t{\n\t\t\t\t$stack[] = $this->columnPush($value, $map, false, $is_join);\n\t\t\t}\n\t\t\telseif (!is_int($key) && $raw = $this->buildRaw($value, $map))\n\t\t\t{\n\t\t\t\tpreg_match('/(?<column>[a-zA-Z0-9_\\.]+)(\\s*\\[(?<type>(String|Bool|Int|Number))\\])?/i', $key, $match);\n\n\t\t\t\t$stack[] = $raw . ' AS ' . $this->columnQuote($match[ 'column' ]);\n\t\t\t}\n\t\t\telseif (is_int($key) && is_string($value))\n\t\t\t{\n\t\t\t\tif ($is_join && strpos($value, '*') !== false)\n\t\t\t\t{\n\t\t\t\t\tthrow new InvalidArgumentException('Cannot use table.* to select all columns while joining table');\n\t\t\t\t}\n\n\t\t\t\tpreg_match('/(?<column>[a-zA-Z0-9_\\.]+)(?:\\s*\\((?<alias>[a-zA-Z0-9_]+)\\))?(?:\\s*\\[(?<type>(?:String|Bool|Int|Number|Object|JSON))\\])?/i', $value, $match);\n\n\t\t\t\tif (!empty($match[ 'alias' ]))\n\t\t\t\t{\n\t\t\t\t\t$stack[] = $this->columnQuote($match[ 'column' ]) . ' AS ' . $this->columnQuote($match[ 'alias' ]);\n\n\t\t\t\t\t$columns[ $key ] = $match[ 'alias' ];\n\n\t\t\t\t\tif (!empty($match[ 'type' ]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$columns[ $key ] .= ' [' . $match[ 'type' ] . ']';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$stack[] = $this->columnQuote($match[ 'column' ]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn implode(',', $stack);\n\t}\n\n\tprotected function arrayQuote($array)\n\t{\n\t\t$stack = [];\n\n\t\tforeach ($array as $value)\n\t\t{\n\t\t\t$stack[] = is_int($value) ? $value : $this->pdo->quote($value);\n\t\t}\n\n\t\treturn implode(',', $stack);\n\t}\n\n\tprotected function innerConjunct($data, $map, $conjunctor, $outer_conjunctor)\n\t{\n\t\t$stack = [];\n\n\t\tforeach ($data as $value)\n\t\t{\n\t\t\t$stack[] = '(' . $this->dataImplode($value, $map, $conjunctor) . ')';\n\t\t}\n\n\t\treturn implode($outer_conjunctor . ' ', $stack);\n\t}\n\n\tprotected function dataImplode($data, &$map, $conjunctor)\n\t{\n\t\t$stack = [];\n\n\t\tforeach ($data as $key => $value)\n\t\t{\n\t\t\t$type = gettype($value);\n\n\t\t\tif (\n\t\t\t\t$type === 'array' &&\n\t\t\t\tpreg_match(\"/^(AND|OR)(\\s+#.*)?$/\", $key, $relation_match)\n\t\t\t)\n\t\t\t{\n\t\t\t\t$relationship = $relation_match[ 1 ];\n\n\t\t\t\t$stack[] = $value !== array_keys(array_keys($value)) ?\n\t\t\t\t\t'(' . $this->dataImplode($value, $map, ' ' . $relationship) . ')' :\n\t\t\t\t\t'(' . $this->innerConjunct($value, $map, ' ' . $relationship, $conjunctor) . ')';\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$map_key = $this->mapKey();\n\n\t\t\tif (\n\t\t\t\tis_int($key) &&\n\t\t\t\tpreg_match('/([a-zA-Z0-9_\\.]+)\\[(?<operator>\\>\\=?|\\<\\=?|\\!?\\=)\\]([a-zA-Z0-9_\\.]+)/i', $value, $match)\n\t\t\t)\n\t\t\t{\n\t\t\t\t$stack[] = $this->columnQuote($match[ 1 ]) . ' ' . $match[ 'operator' ] . ' ' . $this->columnQuote($match[ 3 ]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpreg_match('/([a-zA-Z0-9_\\.]+)(\\[(?<operator>\\>\\=?|\\<\\=?|\\!|\\<\\>|\\>\\<|\\!?~|REGEXP)\\])?/i', $key, $match);\n\t\t\t\t$column = $this->columnQuote($match[ 1 ]);\n\n\t\t\t\tif (isset($match[ 'operator' ]))\n\t\t\t\t{\n\t\t\t\t\t$operator = $match[ 'operator' ];\n\n\t\t\t\t\tif (in_array($operator, ['>', '>=', '<', '<=']))\n\t\t\t\t\t{\n\t\t\t\t\t\t$condition = $column . ' ' . $operator . ' ';\n\n\t\t\t\t\t\tif (is_numeric($value))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$condition .= $map_key;\n\t\t\t\t\t\t\t$map[ $map_key ] = [$value, is_float($value) ? PDO::PARAM_STR : PDO::PARAM_INT];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif ($raw = $this->buildRaw($value, $map))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$condition .= $raw;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$condition .= $map_key;\n\t\t\t\t\t\t\t$map[ $map_key ] = [$value, PDO::PARAM_STR];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$stack[] = $condition;\n\t\t\t\t\t}\n\t\t\t\t\telseif ($operator === '!')\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch ($type)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'NULL':\n\t\t\t\t\t\t\t\t$stack[] = $column . ' IS NOT NULL';\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'array':\n\t\t\t\t\t\t\t\t$placeholders = [];\n\n\t\t\t\t\t\t\t\tforeach ($value as $index => $item)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$stack_key = $map_key . $index . '_i';\n\n\t\t\t\t\t\t\t\t\t$placeholders[] = $stack_key;\n\t\t\t\t\t\t\t\t\t$map[ $stack_key ] = $this->typeMap($item, gettype($item));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t$stack[] = $column . ' NOT IN (' . implode(', ', $placeholders) . ')';\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\t\tif ($raw = $this->buildRaw($value, $map))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$stack[] = $column . ' != ' . $raw;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\t\tcase 'double':\n\t\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\t\t$stack[] = $column . ' != ' . $map_key;\n\t\t\t\t\t\t\t\t$map[ $map_key ] = $this->typeMap($value, $type);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telseif ($operator === '~' || $operator === '!~')\n\t\t\t\t\t{\n\t\t\t\t\t\tif ($type !== 'array')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$value = [ $value ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$connector = ' OR ';\n\t\t\t\t\t\t$data = array_values($value);\n\n\t\t\t\t\t\tif (is_array($data[ 0 ]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (isset($value[ 'AND' ]) || isset($value[ 'OR' ]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$connector = ' ' . array_keys($value)[ 0 ] . ' ';\n\t\t\t\t\t\t\t\t$value = $data[ 0 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$like_clauses = [];\n\n\t\t\t\t\t\tforeach ($value as $index => $item)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$item = strval($item);\n\n\t\t\t\t\t\t\tif (!preg_match('/(\\[.+\\]|_|%.+|.+%)/', $item))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$item = '%' . $item . '%';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$like_clauses[] = $column . ($operator === '!~' ? ' NOT' : '') . ' LIKE ' . $map_key . 'L' . $index;\n\t\t\t\t\t\t\t$map[ $map_key . 'L' . $index ] = [$item, PDO::PARAM_STR];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$stack[] = '(' . implode($connector, $like_clauses) . ')';\n\t\t\t\t\t}\n\t\t\t\t\telseif ($operator === '<>' || $operator === '><')\n\t\t\t\t\t{\n\t\t\t\t\t\tif ($type === 'array')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ($operator === '><')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$column .= ' NOT';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$stack[] = '(' . $column . ' BETWEEN ' . $map_key . 'a AND ' . $map_key . 'b)';\n\n\t\t\t\t\t\t\t$data_type = (is_numeric($value[ 0 ]) && is_numeric($value[ 1 ])) ? PDO::PARAM_INT : PDO::PARAM_STR;\n\n\t\t\t\t\t\t\t$map[ $map_key . 'a' ] = [$value[ 0 ], $data_type];\n\t\t\t\t\t\t\t$map[ $map_key . 'b' ] = [$value[ 1 ], $data_type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telseif ($operator === 'REGEXP')\n\t\t\t\t\t{\n\t\t\t\t\t\t$stack[] = $column . ' REGEXP ' . $map_key;\n\t\t\t\t\t\t$map[ $map_key ] = [$value, PDO::PARAM_STR];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch ($type)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'NULL':\n\t\t\t\t\t\t\t$stack[] = $column . ' IS NULL';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'array':\n\t\t\t\t\t\t\t$placeholders = [];\n\n\t\t\t\t\t\t\tforeach ($value as $index => $item)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$stack_key = $map_key . $index . '_i';\n\n\t\t\t\t\t\t\t\t$placeholders[] = $stack_key;\n\t\t\t\t\t\t\t\t$map[ $stack_key ] = $this->typeMap($item, gettype($item));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$stack[] = $column . ' IN (' . implode(', ', $placeholders) . ')';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\tif ($raw = $this->buildRaw($value, $map))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$stack[] = $column . ' = ' . $raw;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tcase 'double':\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\t$stack[] = $column . ' = ' . $map_key;\n\t\t\t\t\t\t\t$map[ $map_key ] = $this->typeMap($value, $type);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn implode($conjunctor . ' ', $stack);\n\t}\n\n\tprotected function whereClause($where, &$map)\n\t{\n\t\t$where_clause = '';\n\n\t\tif (is_array($where))\n\t\t{\n\t\t\t$where_keys = array_keys($where);\n\n\t\t\t$conditions = array_diff_key($where, array_flip(\n\t\t\t\t['GROUP', 'ORDER', 'HAVING', 'LIMIT', 'LIKE', 'MATCH']\n\t\t\t));\n\n\t\t\tif (!empty($conditions))\n\t\t\t{\n\t\t\t\t$where_clause = ' WHERE ' . $this->dataImplode($conditions, $map, ' AND');\n\t\t\t}\n\n\t\t\tif (isset($where[ 'MATCH' ]) && $this->type === 'mysql')\n\t\t\t{\n\t\t\t\t$MATCH = $where[ 'MATCH' ];\n\n\t\t\t\tif (is_array($MATCH) && isset($MATCH[ 'columns' ], $MATCH[ 'keyword' ]))\n\t\t\t\t{\n\t\t\t\t\t$mode = '';\n\n\t\t\t\t\t$mode_array = [\n\t\t\t\t\t\t'natural' => 'IN NATURAL LANGUAGE MODE',\n\t\t\t\t\t\t'natural+query' => 'IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION',\n\t\t\t\t\t\t'boolean' => 'IN BOOLEAN MODE',\n\t\t\t\t\t\t'query' => 'WITH QUERY EXPANSION'\n\t\t\t\t\t];\n\n\t\t\t\t\tif (isset($MATCH[ 'mode' ], $mode_array[ $MATCH[ 'mode' ] ]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$mode = ' ' . $mode_array[ $MATCH[ 'mode' ] ];\n\t\t\t\t\t}\n\n\t\t\t\t\t$columns = implode(', ', array_map([$this, 'columnQuote'], $MATCH[ 'columns' ]));\n\t\t\t\t\t$map_key = $this->mapKey();\n\t\t\t\t\t$map[ $map_key ] = [$MATCH[ 'keyword' ], PDO::PARAM_STR];\n\n\t\t\t\t\t$where_clause .= ($where_clause !== '' ? ' AND ' : ' WHERE') . ' MATCH (' . $columns . ') AGAINST (' . $map_key . $mode . ')';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isset($where[ 'GROUP' ]))\n\t\t\t{\n\t\t\t\t$GROUP = $where[ 'GROUP' ];\n\n\t\t\t\tif (is_array($GROUP))\n\t\t\t\t{\n\t\t\t\t\t$stack = [];\n\n\t\t\t\t\tforeach ($GROUP as $column => $value)\n\t\t\t\t\t{\n\t\t\t\t\t\t$stack[] = $this->columnQuote($value);\n\t\t\t\t\t}\n\n\t\t\t\t\t$where_clause .= ' GROUP BY ' . implode(',', $stack);\n\t\t\t\t}\n\t\t\t\telseif ($raw = $this->buildRaw($GROUP, $map))\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' GROUP BY ' . $raw;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' GROUP BY ' . $this->columnQuote($GROUP);\n\t\t\t\t}\n\n\t\t\t\tif (isset($where[ 'HAVING' ]))\n\t\t\t\t{\n\t\t\t\t\tif ($raw = $this->buildRaw($where[ 'HAVING' ], $map))\n\t\t\t\t\t{\n\t\t\t\t\t\t$where_clause .= ' HAVING ' . $raw;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$where_clause .= ' HAVING ' . $this->dataImplode($where[ 'HAVING' ], $map, ' AND');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isset($where[ 'ORDER' ]))\n\t\t\t{\n\t\t\t\t$ORDER = $where[ 'ORDER' ];\n\n\t\t\t\tif (is_array($ORDER))\n\t\t\t\t{\n\t\t\t\t\t$stack = [];\n\n\t\t\t\t\tforeach ($ORDER as $column => $value)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (is_array($value))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$stack[] = 'FIELD(' . $this->columnQuote($column) . ', ' . $this->arrayQuote($value) . ')';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif ($value === 'ASC' || $value === 'DESC')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$stack[] = $this->columnQuote($column) . ' ' . $value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif (is_int($column))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$stack[] = $this->columnQuote($value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$where_clause .= ' ORDER BY ' . implode(',', $stack);\n\t\t\t\t}\n\t\t\t\telseif ($raw = $this->buildRaw($ORDER, $map))\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' ORDER BY ' . $raw;\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' ORDER BY ' . $this->columnQuote($ORDER);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tisset($where[ 'LIMIT' ]) &&\n\t\t\t\t\tin_array($this->type, ['oracle', 'mssql'])\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t$LIMIT = $where[ 'LIMIT' ];\n\n\t\t\t\t\tif (is_numeric($LIMIT))\n\t\t\t\t\t{\n\t\t\t\t\t\t$LIMIT = [0, $LIMIT];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (\n\t\t\t\t\t\tis_array($LIMIT) &&\n\t\t\t\t\t\tis_numeric($LIMIT[ 0 ]) &&\n\t\t\t\t\t\tis_numeric($LIMIT[ 1 ])\n\t\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\t$where_clause .= ' OFFSET ' . $LIMIT[ 0 ] . ' ROWS FETCH NEXT ' . $LIMIT[ 1 ] . ' ROWS ONLY';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isset($where[ 'LIMIT' ]) && !in_array($this->type, ['oracle', 'mssql']))\n\t\t\t{\n\t\t\t\t$LIMIT = $where[ 'LIMIT' ];\n\n\t\t\t\tif (is_numeric($LIMIT))\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' LIMIT ' . $LIMIT;\n\t\t\t\t}\n\t\t\t\telseif (\n\t\t\t\t\tis_array($LIMIT) &&\n\t\t\t\t\tis_numeric($LIMIT[ 0 ]) &&\n\t\t\t\t\tis_numeric($LIMIT[ 1 ])\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' LIMIT ' . $LIMIT[ 1 ] . ' OFFSET ' . $LIMIT[ 0 ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telseif ($raw = $this->buildRaw($where, $map))\n\t\t{\n\t\t\t$where_clause .= ' ' . $raw;\n\t\t}\n\n\t\treturn $where_clause;\n\t}\n\n\tprotected function selectContext($table, &$map, $join, &$columns = null, $where = null, $column_fn = null)\n\t{\n\t\tpreg_match('/(?<table>[a-zA-Z0-9_]+)\\s*\\((?<alias>[a-zA-Z0-9_]+)\\)/i', $table, $table_match);\n\n\t\tif (isset($table_match[ 'table' ], $table_match[ 'alias' ]))\n\t\t{\n\t\t\t$table = $this->tableQuote($table_match[ 'table' ]);\n\n\t\t\t$table_query = $table . ' AS ' . $this->tableQuote($table_match[ 'alias' ]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$table = $this->tableQuote($table);\n\n\t\t\t$table_query = $table;\n\t\t}\n\n\t\t$is_join = false;\n\t\t$join_key = is_array($join) ? array_keys($join) : null;\n\n\t\tif (\n\t\t\tisset($join_key[ 0 ]) &&\n\t\t\tstrpos($join_key[ 0 ], '[') === 0\n\t\t)\n\t\t{\n\t\t\t$is_join = true;\n\t\t\t$table_query .= ' ' . $this->buildJoin($table, $join);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (is_null($columns))\n\t\t\t{\n\t\t\t\tif (\n\t\t\t\t\t!is_null($where) ||\n\t\t\t\t\t(is_array($join) && isset($column_fn))\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t$where = $join;\n\t\t\t\t\t$columns = null;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$where = null;\n\t\t\t\t\t$columns = $join;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$where = $columns;\n\t\t\t\t$columns = $join;\n\t\t\t}\n\t\t}\n\n\t\tif (isset($column_fn))\n\t\t{\n\t\t\tif ($column_fn === 1)\n\t\t\t{\n\t\t\t\t$column = '1';\n\n\t\t\t\tif (is_null($where))\n\t\t\t\t{\n\t\t\t\t\t$where = $columns;\n\t\t\t\t}\n\t\t\t}\n\t\t\telseif ($raw = $this->buildRaw($column_fn, $map))\n\t\t\t{\n\t\t\t\t$column = $raw;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (empty($columns) || $this->isRaw($columns))\n\t\t\t\t{\n\t\t\t\t\t$columns = '*';\n\t\t\t\t\t$where = $join;\n\t\t\t\t}\n\n\t\t\t\t$column = $column_fn . '(' . $this->columnPush($columns, $map, true) . ')';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$column = $this->columnPush($columns, $map, true, $is_join);\n\t\t}\n\n\t\treturn 'SELECT ' . $column . ' FROM ' . $table_query . $this->whereClause($where, $map);\n\t}\n\n\tprotected function buildJoin($table, $join)\n\t{\n\t\t$table_join = [];\n\n\t\t$join_array = [\n\t\t\t'>' => 'LEFT',\n\t\t\t'<' => 'RIGHT',\n\t\t\t'<>' => 'FULL',\n\t\t\t'><' => 'INNER'\n\t\t];\n\n\t\tforeach($join as $sub_table => $relation)\n\t\t{\n\t\t\tpreg_match('/(\\[(?<join>\\<\\>?|\\>\\<?)\\])?(?<table>[a-zA-Z0-9_]+)\\s?(\\((?<alias>[a-zA-Z0-9_]+)\\))?/', $sub_table, $match);\n\n\t\t\tif ($match[ 'join' ] !== '' && $match[ 'table' ] !== '')\n\t\t\t{\n\t\t\t\tif (is_string($relation))\n\t\t\t\t{\n\t\t\t\t\t$relation = 'USING (\"' . $relation . '\")';\n\t\t\t\t}\n\n\t\t\t\tif (is_array($relation))\n\t\t\t\t{\n\t\t\t\t\t// For ['column1', 'column2']\n\t\t\t\t\tif (isset($relation[ 0 ]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$relation = 'USING (\"' . implode('\", \"', $relation) . '\")';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$joins = [];\n\n\t\t\t\t\t\tforeach ($relation as $key => $value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$joins[] = (\n\t\t\t\t\t\t\t\tstrpos($key, '.') > 0 ?\n\t\t\t\t\t\t\t\t\t// For ['tableB.column' => 'column']\n\t\t\t\t\t\t\t\t\t$this->columnQuote($key) :\n\n\t\t\t\t\t\t\t\t\t// For ['column1' => 'column2']\n\t\t\t\t\t\t\t\t\t$table . '.\"' . $key . '\"'\n\t\t\t\t\t\t\t) .\n\t\t\t\t\t\t\t' = ' .\n\t\t\t\t\t\t\t$this->tableQuote(isset($match[ 'alias' ]) ? $match[ 'alias' ] : $match[ 'table' ]) . '.\"' . $value . '\"';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$relation = 'ON ' . implode(' AND ', $joins);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$table_name = $this->tableQuote($match[ 'table' ]) . ' ';\n\n\t\t\t\tif (isset($match[ 'alias' ]))\n\t\t\t\t{\n\t\t\t\t\t$table_name .= 'AS ' . $this->tableQuote($match[ 'alias' ]) . ' ';\n\t\t\t\t}\n\n\t\t\t\t$table_join[] = $join_array[ $match[ 'join' ] ] . ' JOIN ' . $table_name . $relation;\n\t\t\t}\n\t\t}\n\n\t\treturn implode(' ', $table_join);\n\t}\n\n\tprotected function columnMap($columns, &$stack, $root)\n\t{\n\t\tif ($columns === '*')\n\t\t{\n\t\t\treturn $stack;\n\t\t}\n\n\t\tforeach ($columns as $key => $value)\n\t\t{\n\t\t\tif (is_int($key))\n\t\t\t{\n\t\t\t\tpreg_match('/([a-zA-Z0-9_]+\\.)?(?<column>[a-zA-Z0-9_]+)(?:\\s*\\((?<alias>[a-zA-Z0-9_]+)\\))?(?:\\s*\\[(?<type>(?:String|Bool|Int|Number|Object|JSON))\\])?/i', $value, $key_match);\n\n\t\t\t\t$column_key = !empty($key_match[ 'alias' ]) ?\n\t\t\t\t\t$key_match[ 'alias' ] :\n\t\t\t\t\t$key_match[ 'column' ];\n\n\t\t\t\tif (isset($key_match[ 'type' ]))\n\t\t\t\t{\n\t\t\t\t\t$stack[ $value ] = [$column_key, $key_match[ 'type' ]];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$stack[ $value ] = [$column_key, 'String'];\n\t\t\t\t}\n\t\t\t}\n\t\t\telseif ($this->isRaw($value))\n\t\t\t{\n\t\t\t\tpreg_match('/([a-zA-Z0-9_]+\\.)?(?<column>[a-zA-Z0-9_]+)(\\s*\\[(?<type>(String|Bool|Int|Number))\\])?/i', $key, $key_match);\n\n\t\t\t\t$column_key = $key_match[ 'column' ];\n\n\t\t\t\tif (isset($key_match[ 'type' ]))\n\t\t\t\t{\n\t\t\t\t\t$stack[ $key ] = [$column_key, $key_match[ 'type' ]];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$stack[ $key ] = [$column_key, 'String'];\n\t\t\t\t}\n\t\t\t}\n\t\t\telseif (!is_int($key) && is_array($value))\n\t\t\t{\n\t\t\t\tif ($root && count(array_keys($columns)) === 1)\n\t\t\t\t{\n\t\t\t\t\t$stack[ $key ] = [$key, 'String'];\n\t\t\t\t}\n\n\t\t\t\t$this->columnMap($value, $stack, false);\n\t\t\t}\n\t\t}\n\n\t\treturn $stack;\n\t}\n\n\tprotected function dataMap($data, $columns, $column_map, &$stack, $root, &$result)\n\t{\n\t\tif ($root)\n\t\t{\n\t\t\t$columns_key = array_keys($columns);\n\n\t\t\tif (count($columns_key) === 1 && is_array($columns[$columns_key[0]]))\n\t\t\t{\n\t\t\t\t$index_key = array_keys($columns)[0];\n\t\t\t\t$data_key = preg_replace(\"/^[a-zA-Z0-9_]+\\./i\", \"\", $index_key);\n\n\t\t\t\t$current_stack = [];\n\n\t\t\t\tforeach ($data as $item)\n\t\t\t\t{\n\t\t\t\t\t$this->dataMap($data, $columns[ $index_key ], $column_map, $current_stack, false, $result);\n\n\t\t\t\t\t$index = $data[ $data_key ];\n\n\t\t\t\t\t$result[ $index ] = $current_stack;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$current_stack = [];\n\t\t\t\t\n\t\t\t\t$this->dataMap($data, $columns, $column_map, $current_stack, false, $result);\n\n\t\t\t\t$result[] = $current_stack;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tforeach ($columns as $key => $value)\n\t\t{\n\t\t\t$isRaw = $this->isRaw($value);\n\n\t\t\tif (is_int($key) || $isRaw)\n\t\t\t{\n\t\t\t\t$map = $column_map[ $isRaw ? $key : $value ];\n\n\t\t\t\t$column_key = $map[ 0 ];\n\n\t\t\t\t$item = $data[ $column_key ];\n\n\t\t\t\tif (isset($map[ 1 ]))\n\t\t\t\t{\n\t\t\t\t\tif ($isRaw && in_array($map[ 1 ], ['Object', 'JSON']))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_null($item))\n\t\t\t\t\t{\n\t\t\t\t\t\t$stack[ $column_key ] = null;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ($map[ 1 ])\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'Number':\n\t\t\t\t\t\t\t$stack[ $column_key ] = (double) $item;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Int':\n\t\t\t\t\t\t\t$stack[ $column_key ] = (int) $item;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Bool':\n\t\t\t\t\t\t\t$stack[ $column_key ] = (bool) $item;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\t\t$stack[ $column_key ] = unserialize($item);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'JSON':\n\t\t\t\t\t\t\t$stack[ $column_key ] = json_decode($item, true);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'String':\n\t\t\t\t\t\t\t$stack[ $column_key ] = $item;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$stack[ $column_key ] = $item;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$current_stack = [];\n\n\t\t\t\t$this->dataMap($data, $value, $column_map, $current_stack, false, $result);\n\n\t\t\t\t$stack[ $key ] = $current_stack;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function create($table, $columns, $options = null)\n\t{\n\t\t$stack = [];\n\n\t\t$tableName = $this->prefix . $table;\n\n\t\tforeach ($columns as $name => $definition)\n\t\t{\n\t\t\tif (is_int($name))\n\t\t\t{\n\t\t\t\t$stack[] = preg_replace('/\\<([a-zA-Z0-9_]+)\\>/i', '\"$1\"', $definition);\n\t\t\t}\n\t\t\telseif (is_array($definition))\n\t\t\t{\n\t\t\t\t$stack[] = $name . ' ' . implode(' ', $definition);\n\t\t\t}\n\t\t\telseif (is_string($definition))\n\t\t\t{\n\t\t\t\t$stack[] = $name . ' ' . $this->query($definition);\n\t\t\t}\n\t\t}\n\n\t\t$table_option = '';\n\n\t\tif (is_array($options))\n\t\t{\n\t\t\t$option_stack = [];\n\n\t\t\tforeach ($options as $key => $value)\n\t\t\t{\n\t\t\t\tif (is_string($value) || is_int($value))\n\t\t\t\t{\n\t\t\t\t\t$option_stack[] = \"$key = $value\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$table_option = ' ' . implode(', ', $option_stack);\n\t\t}\n\t\telseif (is_string($options))\n\t\t{\n\t\t\t$table_option = ' ' . $options;\n\t\t}\n\n\t\treturn $this->exec(\"CREATE TABLE IF NOT EXISTS $tableName (\" . implode(', ', $stack) . \")$table_option\");\n\t}\n\n\tpublic function drop($table)\n\t{\n\t\t$tableName = $this->prefix . $table;\n\n\t\treturn $this->exec(\"DROP TABLE IF EXISTS $tableName\");\n\t}\n\n\tpublic function select($table, $join, $columns = null, $where = null)\n\t{\n\t\t$map = [];\n\t\t$result = [];\n\t\t$column_map = [];\n\n\t\t$index = 0;\n\n\t\t$column = $where === null ? $join : $columns;\n\n\t\t$is_single = (is_string($column) && $column !== '*');\n\n\t\t$query = $this->exec($this->selectContext($table, $map, $join, $columns, $where), $map);\n\n\t\t$this->columnMap($columns, $column_map, true);\n\n\t\tif (!$query)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ($columns === '*')\n\t\t{\n\t\t\treturn $query->fetchAll(PDO::FETCH_ASSOC);\n\t\t}\n\n\t\tif ($is_single)\n\t\t{\n\t\t\treturn $query->fetchAll(PDO::FETCH_COLUMN);\n\t\t}\n\n\t\twhile ($data = $query->fetch(PDO::FETCH_ASSOC))\n\t\t{\n\t\t\t$current_stack = [];\n\n\t\t\t$this->dataMap($data, $columns, $column_map, $current_stack, true, $result);\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\tpublic function insert($table, $datas)\n\t{\n\t\t$stack = [];\n\t\t$columns = [];\n\t\t$fields = [];\n\t\t$map = [];\n\n\t\tif (!isset($datas[ 0 ]))\n\t\t{\n\t\t\t$datas = [$datas];\n\t\t}\n\n\t\tforeach ($datas as $data)\n\t\t{\n\t\t\tforeach ($data as $key => $value)\n\t\t\t{\n\t\t\t\t$columns[] = $key;\n\t\t\t}\n\t\t}\n\n\t\t$columns = array_unique($columns);\n\n\t\tforeach ($datas as $data)\n\t\t{\n\t\t\t$values = [];\n\n\t\t\tforeach ($columns as $key)\n\t\t\t{\n\t\t\t\tif ($raw = $this->buildRaw($data[ $key ], $map))\n\t\t\t\t{\n\t\t\t\t\t$values[] = $raw;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$map_key = $this->mapKey();\n\n\t\t\t\t$values[] = $map_key;\n\n\t\t\t\tif (!isset($data[ $key ]))\n\t\t\t\t{\n\t\t\t\t\t$map[ $map_key ] = [null, PDO::PARAM_NULL];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$value = $data[ $key ];\n\n\t\t\t\t\t$type = gettype($value);\n\n\t\t\t\t\tswitch ($type)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'array':\n\t\t\t\t\t\t\t$map[ $map_key ] = [\n\t\t\t\t\t\t\t\tstrpos($key, '[JSON]') === strlen($key) - 6 ?\n\t\t\t\t\t\t\t\t\tjson_encode($value) :\n\t\t\t\t\t\t\t\t\tserialize($value),\n\t\t\t\t\t\t\t\tPDO::PARAM_STR\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\t$value = serialize($value);\n\n\t\t\t\t\t\tcase 'NULL':\n\t\t\t\t\t\tcase 'resource':\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tcase 'double':\n\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\t$map[ $map_key ] = $this->typeMap($value, $type);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$stack[] = '(' . implode(', ', $values) . ')';\n\t\t}\n\n\t\tforeach ($columns as $key)\n\t\t{\n\t\t\t$fields[] = $this->columnQuote(preg_replace(\"/(\\s*\\[JSON\\]$)/i\", '', $key));\n\t\t}\n\n\t\treturn $this->exec('INSERT INTO ' . $this->tableQuote($table) . ' (' . implode(', ', $fields) . ') VALUES ' . implode(', ', $stack), $map);\n\t}\n\n\tpublic function update($table, $data, $where = null)\n\t{\n\t\t$fields = [];\n\t\t$map = [];\n\n\t\tforeach ($data as $key => $value)\n\t\t{\n\t\t\t$column = $this->columnQuote(preg_replace(\"/(\\s*\\[(JSON|\\+|\\-|\\*|\\/)\\]$)/i\", '', $key));\n\n\t\t\tif ($raw = $this->buildRaw($value, $map))\n\t\t\t{\n\t\t\t\t$fields[] = $column . ' = ' . $raw;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$map_key = $this->mapKey();\n\n\t\t\tpreg_match('/(?<column>[a-zA-Z0-9_]+)(\\[(?<operator>\\+|\\-|\\*|\\/)\\])?/i', $key, $match);\n\n\t\t\tif (isset($match[ 'operator' ]))\n\t\t\t{\n\t\t\t\tif (is_numeric($value))\n\t\t\t\t{\n\t\t\t\t\t$fields[] = $column . ' = ' . $column . ' ' . $match[ 'operator' ] . ' ' . $value;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$fields[] = $column . ' = ' . $map_key;\n\n\t\t\t\t$type = gettype($value);\n\n\t\t\t\tswitch ($type)\n\t\t\t\t{\n\t\t\t\t\tcase 'array':\n\t\t\t\t\t\t$map[ $map_key ] = [\n\t\t\t\t\t\t\tstrpos($key, '[JSON]') === strlen($key) - 6 ?\n\t\t\t\t\t\t\t\tjson_encode($value) :\n\t\t\t\t\t\t\t\tserialize($value),\n\t\t\t\t\t\t\tPDO::PARAM_STR\n\t\t\t\t\t\t];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t$value = serialize($value);\n\n\t\t\t\t\tcase 'NULL':\n\t\t\t\t\tcase 'resource':\n\t\t\t\t\tcase 'boolean':\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\tcase 'double':\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t$map[ $map_key ] = $this->typeMap($value, $type);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $this->exec('UPDATE ' . $this->tableQuote($table) . ' SET ' . implode(', ', $fields) . $this->whereClause($where, $map), $map);\n\t}\n\n\tpublic function delete($table, $where)\n\t{\n\t\t$map = [];\n\n\t\treturn $this->exec('DELETE FROM ' . $this->tableQuote($table) . $this->whereClause($where, $map), $map);\n\t}\n\n\tpublic function replace($table, $columns, $where = null)\n\t{\n\t\tif (!is_array($columns) || empty($columns))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t$map = [];\n\t\t$stack = [];\n\n\t\tforeach ($columns as $column => $replacements)\n\t\t{\n\t\t\tif (is_array($replacements))\n\t\t\t{\n\t\t\t\tforeach ($replacements as $old => $new)\n\t\t\t\t{\n\t\t\t\t\t$map_key = $this->mapKey();\n\n\t\t\t\t\t$stack[] = $this->columnQuote($column) . ' = REPLACE(' . $this->columnQuote($column) . ', ' . $map_key . 'a, ' . $map_key . 'b)';\n\n\t\t\t\t\t$map[ $map_key . 'a' ] = [$old, PDO::PARAM_STR];\n\t\t\t\t\t$map[ $map_key . 'b' ] = [$new, PDO::PARAM_STR];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!empty($stack))\n\t\t{\n\t\t\treturn $this->exec('UPDATE ' . $this->tableQuote($table) . ' SET ' . implode(', ', $stack) . $this->whereClause($where, $map), $map);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic function get($table, $join = null, $columns = null, $where = null)\n\t{\n\t\t$map = [];\n\t\t$result = [];\n\t\t$column_map = [];\n\t\t$current_stack = [];\n\n\t\tif ($where === null)\n\t\t{\n\t\t\t$column = $join;\n\t\t\tunset($columns[ 'LIMIT' ]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$column = $columns;\n\t\t\tunset($where[ 'LIMIT' ]);\n\t\t}\n\n\t\t$is_single = (is_string($column) && $column !== '*');\n\n\t\t$query = $this->exec($this->selectContext($table, $map, $join, $columns, $where) . ' LIMIT 1', $map);\n\n\t\tif ($query)\n\t\t{\n\t\t\t$data = $query->fetchAll(PDO::FETCH_ASSOC);\n\n\t\t\tif (isset($data[ 0 ]))\n\t\t\t{\n\t\t\t\tif ($column === '*')\n\t\t\t\t{\n\t\t\t\t\treturn $data[ 0 ];\n\t\t\t\t}\n\n\t\t\t\t$this->columnMap($columns, $column_map, true);\n\n\t\t\t\t$this->dataMap($data[ 0 ], $columns, $column_map, $current_stack, true, $result);\n\n\t\t\t\tif ($is_single)\n\t\t\t\t{\n\t\t\t\t\treturn $result[ 0 ][ $column_map[ $column ][ 0 ] ];\n\t\t\t\t}\n\n\t\t\t\treturn $result[ 0 ];\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function has($table, $join, $where = null)\n\t{\n\t\t$map = [];\n\t\t$column = null;\n\n\t\tif ($this->type === 'mssql')\n\t\t{\n\t\t\t$query = $this->exec($this->selectContext($table, $map, $join, $column, $where, Medoo::raw('TOP 1 1')), $map);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$query = $this->exec('SELECT EXISTS(' . $this->selectContext($table, $map, $join, $column, $where, 1) . ')', $map);\n\t\t}\n\n\t\tif ($query)\n\t\t{\n\t\t\t$result = $query->fetchColumn();\n\n\t\t\treturn $result === '1' || $result === 1 || $result === true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic function rand($table, $join = null, $columns = null, $where = null)\n\t{\n\t\t$type = $this->type;\n\n\t\t$order = 'RANDOM()';\n\n\t\tif ($type === 'mysql')\n\t\t{\n\t\t\t$order = 'RAND()';\n\t\t}\n\t\telseif ($type === 'mssql')\n\t\t{\n\t\t\t$order = 'NEWID()';\n\t\t}\n\n\t\t$order_raw = $this->raw($order);\n\n\t\tif ($where === null)\n\t\t{\n\t\t\tif ($columns === null)\n\t\t\t{\n\t\t\t\t$columns = [\n\t\t\t\t\t'ORDER'  => $order_raw\n\t\t\t\t];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$column = $join;\n\t\t\t\tunset($columns[ 'ORDER' ]);\n\n\t\t\t\t$columns[ 'ORDER' ] = $order_raw;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunset($where[ 'ORDER' ]);\n\n\t\t\t$where[ 'ORDER' ] = $order_raw;\n\t\t}\n\n\t\treturn $this->select($table, $join, $columns, $where);\n\t}\n\n\tprivate function aggregate($type, $table, $join = null, $column = null, $where = null)\n\t{\n\t\t$map = [];\n\n\t\t$query = $this->exec($this->selectContext($table, $map, $join, $column, $where, strtoupper($type)), $map);\n\n\t\tif ($query)\n\t\t{\n\t\t\t$number = $query->fetchColumn();\n\n\t\t\treturn is_numeric($number) ? $number + 0 : $number;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic function count($table, $join = null, $column = null, $where = null)\n\t{\n\t\treturn $this->aggregate('count', $table, $join, $column, $where);\n\t}\n\n\tpublic function avg($table, $join, $column = null, $where = null)\n\t{\n\t\treturn $this->aggregate('avg', $table, $join, $column, $where);\n\t}\n\n\tpublic function max($table, $join, $column = null, $where = null)\n\t{\n\t\treturn $this->aggregate('max', $table, $join, $column, $where);\n\t}\n\n\tpublic function min($table, $join, $column = null, $where = null)\n\t{\n\t\treturn $this->aggregate('min', $table, $join, $column, $where);\n\t}\n\n\tpublic function sum($table, $join, $column = null, $where = null)\n\t{\n\t\treturn $this->aggregate('sum', $table, $join, $column, $where);\n\t}\n\n\tpublic function action($actions)\n\t{\n\t\tif (is_callable($actions))\n\t\t{\n\t\t\t$this->pdo->beginTransaction();\n\n\t\t\ttry {\n\t\t\t\t$result = $actions($this);\n\n\t\t\t\tif ($result === false)\n\t\t\t\t{\n\t\t\t\t\t$this->pdo->rollBack();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$this->pdo->commit();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\t$this->pdo->rollBack();\n\n\t\t\t\tthrow $e;\n\t\t\t}\n\n\t\t\treturn $result;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic function id()\n\t{\n\t\tif ($this->statement == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\t$type = $this->type;\n\n\t\tif ($type === 'oracle')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\telseif ($type === 'pgsql')\n\t\t{\n\t\t\treturn $this->pdo->query('SELECT LASTVAL()')->fetchColumn();\n\t\t}\n\n\t\t$lastId = $this->pdo->lastInsertId();\n\n\t\tif ($lastId != \"0\" && $lastId != \"\")\n\t\t{\n\t\t\treturn $lastId;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic function debug()\n\t{\n\t\t$this->debug_mode = true;\n\n\t\treturn $this;\n\t}\n\n\tpublic function error()\n\t{\n\t\treturn $this->statement ? $this->statement->errorInfo() : null;\n\t}\n\n\tpublic function last()\n\t{\n\t\t$log = end($this->logs);\n\n\t\treturn $this->generate($log[ 0 ], $log[ 1 ]);\n\t}\n\n\tpublic function log()\n\t{\n\t\treturn array_map(function ($log)\n\t\t\t{\n\t\t\t\treturn $this->generate($log[ 0 ], $log[ 1 ]);\n\t\t\t},\n\t\t\t$this->logs\n\t\t);\n\t}\n\n\tpublic function info()\n\t{\n\t\t$output = [\n\t\t\t'server' => 'SERVER_INFO',\n\t\t\t'driver' => 'DRIVER_NAME',\n\t\t\t'client' => 'CLIENT_VERSION',\n\t\t\t'version' => 'SERVER_VERSION',\n\t\t\t'connection' => 'CONNECTION_STATUS'\n\t\t];\n\n\t\tforeach ($output as $key => $value)\n\t\t{\n\t\t\t$output[ $key ] = @$this->pdo->getAttribute(constant('PDO::ATTR_' . $value));\n\t\t}\n\n\t\t$output[ 'dsn' ] = $this->dsn;\n\n\t\treturn $output;\n\t}\n}"], "fixing_code": ["<?php\n/*!\n * Medoo database framework\n * https://medoo.in\n * Version 1.7.3\n *\n * Copyright 2019, Angel Lai\n * Released under the MIT license\n */\n\nnamespace Medoo;\n\nuse PDO;\nuse Exception;\nuse PDOException;\nuse InvalidArgumentException;\n\nclass Raw {\n\tpublic $map;\n\tpublic $value;\n}\n\nclass Medoo\n{\n\tpublic $pdo;\n\n\tprotected $type;\n\n\tprotected $prefix;\n\n\tprotected $statement;\n\n\tprotected $dsn;\n\n\tprotected $logs = [];\n\n\tprotected $logging = false;\n\n\tprotected $debug_mode = false;\n\n\tprotected $guid = 0;\n\n\tpublic function __construct(array $options)\n\t{\n\t\tif (isset($options[ 'database_type' ]))\n\t\t{\n\t\t\t$this->type = strtolower($options[ 'database_type' ]);\n\n\t\t\tif ($this->type === 'mariadb')\n\t\t\t{\n\t\t\t\t$this->type = 'mysql';\n\t\t\t}\n\t\t}\n\n\t\tif (isset($options[ 'prefix' ]))\n\t\t{\n\t\t\t$this->prefix = $options[ 'prefix' ];\n\t\t}\n\n\t\tif (isset($options[ 'logging' ]) && is_bool($options[ 'logging' ]))\n\t\t{\n\t\t\t$this->logging = $options[ 'logging' ];\n\t\t}\n\n\t\t$option = isset($options[ 'option' ]) ? $options[ 'option' ] : [];\n\t\t$commands = (isset($options[ 'command' ]) && is_array($options[ 'command' ])) ? $options[ 'command' ] : [];\n\n\t\tswitch ($this->type)\n\t\t{\n\t\t\tcase 'mysql':\n\t\t\t\t// Make MySQL using standard quoted identifier\n\t\t\t\t$commands[] = 'SET SQL_MODE=ANSI_QUOTES';\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'mssql':\n\t\t\t\t// Keep MSSQL QUOTED_IDENTIFIER is ON for standard quoting\n\t\t\t\t$commands[] = 'SET QUOTED_IDENTIFIER ON';\n\n\t\t\t\t// Make ANSI_NULLS is ON for NULL value\n\t\t\t\t$commands[] = 'SET ANSI_NULLS ON';\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (isset($options[ 'pdo' ]))\n\t\t{\n\t\t\tif (!$options[ 'pdo' ] instanceof PDO)\n\t\t\t{\n\t\t\t\tthrow new InvalidArgumentException('Invalid PDO object supplied');\n\t\t\t}\n\n\t\t\t$this->pdo = $options[ 'pdo' ];\n\n\t\t\tforeach ($commands as $value)\n\t\t\t{\n\t\t\t\t$this->pdo->exec($value);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (isset($options[ 'dsn' ]))\n\t\t{\n\t\t\tif (is_array($options[ 'dsn' ]) && isset($options[ 'dsn' ][ 'driver' ]))\n\t\t\t{\n\t\t\t\t$attr = $options[ 'dsn' ];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new InvalidArgumentException('Invalid DSN option supplied');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (\n\t\t\t\tisset($options[ 'port' ]) &&\n\t\t\t\tis_int($options[ 'port' ] * 1)\n\t\t\t)\n\t\t\t{\n\t\t\t\t$port = $options[ 'port' ];\n\t\t\t}\n\n\t\t\t$is_port = isset($port);\n\n\t\t\tswitch ($this->type)\n\t\t\t{\n\t\t\t\tcase 'mysql':\n\t\t\t\t\t$attr = [\n\t\t\t\t\t\t'driver' => 'mysql',\n\t\t\t\t\t\t'dbname' => $options[ 'database_name' ]\n\t\t\t\t\t];\n\n\t\t\t\t\tif (isset($options[ 'socket' ]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr[ 'unix_socket' ] = $options[ 'socket' ];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr[ 'host' ] = $options[ 'server' ];\n\n\t\t\t\t\t\tif ($is_port)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$attr[ 'port' ] = $port;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'pgsql':\n\t\t\t\t\t$attr = [\n\t\t\t\t\t\t'driver' => 'pgsql',\n\t\t\t\t\t\t'host' => $options[ 'server' ],\n\t\t\t\t\t\t'dbname' => $options[ 'database_name' ]\n\t\t\t\t\t];\n\n\t\t\t\t\tif ($is_port)\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr[ 'port' ] = $port;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'sybase':\n\t\t\t\t\t$attr = [\n\t\t\t\t\t\t'driver' => 'dblib',\n\t\t\t\t\t\t'host' => $options[ 'server' ],\n\t\t\t\t\t\t'dbname' => $options[ 'database_name' ]\n\t\t\t\t\t];\n\n\t\t\t\t\tif ($is_port)\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr[ 'port' ] = $port;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'oracle':\n\t\t\t\t\t$attr = [\n\t\t\t\t\t\t'driver' => 'oci',\n\t\t\t\t\t\t'dbname' => $options[ 'server' ] ?\n\t\t\t\t\t\t\t'//' . $options[ 'server' ] . ($is_port ? ':' . $port : ':1521') . '/' . $options[ 'database_name' ] :\n\t\t\t\t\t\t\t$options[ 'database_name' ]\n\t\t\t\t\t];\n\n\t\t\t\t\tif (isset($options[ 'charset' ]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr[ 'charset' ] = $options[ 'charset' ];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mssql':\n\t\t\t\t\tif (isset($options[ 'driver' ]) && $options[ 'driver' ] === 'dblib')\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr = [\n\t\t\t\t\t\t\t'driver' => 'dblib',\n\t\t\t\t\t\t\t'host' => $options[ 'server' ] . ($is_port ? ':' . $port : ''),\n\t\t\t\t\t\t\t'dbname' => $options[ 'database_name' ]\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\tif (isset($options[ 'appname' ]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$attr[ 'appname' ] = $options[ 'appname' ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isset($options[ 'charset' ]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$attr[ 'charset' ] = $options[ 'charset' ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$attr = [\n\t\t\t\t\t\t\t'driver' => 'sqlsrv',\n\t\t\t\t\t\t\t'Server' => $options[ 'server' ] . ($is_port ? ',' . $port : ''),\n\t\t\t\t\t\t\t'Database' => $options[ 'database_name' ]\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\tif (isset($options[ 'appname' ]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$attr[ 'APP' ] = $options[ 'appname' ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$config = [\n\t\t\t\t\t\t\t'ApplicationIntent',\n\t\t\t\t\t\t\t'AttachDBFileName',\n\t\t\t\t\t\t\t'Authentication',\n\t\t\t\t\t\t\t'ColumnEncryption',\n\t\t\t\t\t\t\t'ConnectionPooling',\n\t\t\t\t\t\t\t'Encrypt',\n\t\t\t\t\t\t\t'Failover_Partner',\n\t\t\t\t\t\t\t'KeyStoreAuthentication',\n\t\t\t\t\t\t\t'KeyStorePrincipalId',\n\t\t\t\t\t\t\t'KeyStoreSecret',\n\t\t\t\t\t\t\t'LoginTimeout',\n\t\t\t\t\t\t\t'MultipleActiveResultSets',\n\t\t\t\t\t\t\t'MultiSubnetFailover',\n\t\t\t\t\t\t\t'Scrollable',\n\t\t\t\t\t\t\t'TraceFile',\n\t\t\t\t\t\t\t'TraceOn',\n\t\t\t\t\t\t\t'TransactionIsolation',\n\t\t\t\t\t\t\t'TransparentNetworkIPResolution',\n\t\t\t\t\t\t\t'TrustServerCertificate',\n\t\t\t\t\t\t\t'WSID',\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\tforeach ($config as $value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$keyname = strtolower(preg_replace(['/([a-z\\d])([A-Z])/', '/([^_])([A-Z][a-z])/'], '$1_$2', $value));\n\n\t\t\t\t\t\t\tif (isset($options[ $keyname ]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$attr[ $value ] = $options[ $keyname ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'sqlite':\n\t\t\t\t\t$attr = [\n\t\t\t\t\t\t'driver' => 'sqlite',\n\t\t\t\t\t\t$options[ 'database_file' ]\n\t\t\t\t\t];\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!isset($attr))\n\t\t{\n\t\t\tthrow new InvalidArgumentException('Incorrect connection options');\n\t\t}\n\n\t\t$driver = $attr[ 'driver' ];\n\n\t\tif (!in_array($driver, PDO::getAvailableDrivers()))\n\t\t{\n\t\t\tthrow new InvalidArgumentException(\"Unsupported PDO driver: {$driver}\");\n\t\t}\n\n\t\tunset($attr[ 'driver' ]);\n\n\t\t$stack = [];\n\n\t\tforeach ($attr as $key => $value)\n\t\t{\n\t\t\t$stack[] = is_int($key) ? $value : $key . '=' . $value;\n\t\t}\n\n\t\t$dsn = $driver . ':' . implode(';', $stack);\n\n\t\tif (\n\t\t\tin_array($this->type, ['mysql', 'pgsql', 'sybase', 'mssql']) &&\n\t\t\tisset($options[ 'charset' ])\n\t\t)\n\t\t{\n\t\t\t$commands[] = \"SET NAMES '{$options[ 'charset' ]}'\" . (\n\t\t\t\t$this->type === 'mysql' && isset($options[ 'collation' ]) ?\n\t\t\t\t\" COLLATE '{$options[ 'collation' ]}'\" : ''\n\t\t\t);\n\t\t}\n\n\t\t$this->dsn = $dsn;\n\n\t\ttry {\n\t\t\t$this->pdo = new PDO(\n\t\t\t\t$dsn,\n\t\t\t\tisset($options[ 'username' ]) ? $options[ 'username' ] : null,\n\t\t\t\tisset($options[ 'password' ]) ? $options[ 'password' ] : null,\n\t\t\t\t$option\n\t\t\t);\n\n\t\t\tforeach ($commands as $value)\n\t\t\t{\n\t\t\t\t$this->pdo->exec($value);\n\t\t\t}\n\t\t}\n\t\tcatch (PDOException $e) {\n\t\t\tthrow new PDOException($e->getMessage());\n\t\t}\n\t}\n\n\tpublic function query($query, $map = [])\n\t{\n\t\t$raw = $this->raw($query, $map);\n\n\t\t$query = $this->buildRaw($raw, $map);\n\n\t\treturn $this->exec($query, $map);\n\t}\n\n\tpublic function exec($query, $map = [])\n\t{\n\t\tif ($this->debug_mode)\n\t\t{\n\t\t\techo $this->generate($query, $map);\n\n\t\t\t$this->debug_mode = false;\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ($this->logging)\n\t\t{\n\t\t\t$this->logs[] = [$query, $map];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$this->logs = [[$query, $map]];\n\t\t}\n\n\t\t$statement = $this->pdo->prepare($query);\n\n\t\tif ($statement)\n\t\t{\n\t\t\tforeach ($map as $key => $value)\n\t\t\t{\n\t\t\t\t$statement->bindValue($key, $value[ 0 ], $value[ 1 ]);\n\t\t\t}\n\n\t\t\tif ($statement->execute())\n\t\t\t{\n\t\t\t\t$this->statement = $statement;\n\n\t\t\t\treturn $statement;\n\t\t\t}\n\t\t}\n\n\t\t$this->statement = null;\n\n\t\treturn false;\n\t}\n\n\tprotected function generate($query, $map)\n\t{\n\t\t$identifier = [\n\t\t\t'mysql' => '`$1`',\n\t\t\t'mssql' => '[$1]'\n\t\t];\n\n\t\t$query = preg_replace(\n\t\t\t'/\"([a-zA-Z0-9_]+)\"/i',\n\t\t\tisset($identifier[ $this->type ]) ?  $identifier[ $this->type ] : '\"$1\"',\n\t\t\t$query\n\t\t);\n\n\t\tforeach ($map as $key => $value)\n\t\t{\n\t\t\tif ($value[ 1 ] === PDO::PARAM_STR)\n\t\t\t{\n\t\t\t\t$replace = $this->quote($value[ 0 ]);\n\t\t\t}\n\t\t\telseif ($value[ 1 ] === PDO::PARAM_NULL)\n\t\t\t{\n\t\t\t\t$replace = 'NULL';\n\t\t\t}\n\t\t\telseif ($value[ 1 ] === PDO::PARAM_LOB)\n\t\t\t{\n\t\t\t\t$replace = '{LOB_DATA}';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$replace = $value[ 0 ];\n\t\t\t}\n\n\t\t\t$query = str_replace($key, $replace, $query);\n\t\t}\n\n\t\treturn $query;\n\t}\n\n\tpublic static function raw($string, $map = [])\n\t{\n\t\t$raw = new Raw();\n\n\t\t$raw->map = $map;\n\t\t$raw->value = $string;\n\n\t\treturn $raw;\n\t}\n\n\tprotected function isRaw($object)\n\t{\n\t\treturn $object instanceof Raw;\n\t}\n\n\tprotected function buildRaw($raw, &$map)\n\t{\n\t\tif (!$this->isRaw($raw))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t$query = preg_replace_callback(\n\t\t\t'/((FROM|TABLE|INTO|UPDATE)\\s*)?\\<([a-zA-Z0-9_\\.]+)\\>/i',\n\t\t\tfunction ($matches)\n\t\t\t{\n\t\t\t\tif (!empty($matches[ 2 ]))\n\t\t\t\t{\n\t\t\t\t\treturn $matches[ 2 ] . ' ' . $this->tableQuote($matches[ 3 ]);\n\t\t\t\t}\n\n\t\t\t\treturn $this->columnQuote($matches[ 3 ]);\n\t\t\t},\n\t\t\t$raw->value);\n\n\t\t$raw_map = $raw->map;\n\n\t\tif (!empty($raw_map))\n\t\t{\n\t\t\tforeach ($raw_map as $key => $value)\n\t\t\t{\n\t\t\t\t$map[ $key ] = $this->typeMap($value, gettype($value));\n\t\t\t}\n\t\t}\n\n\t\treturn $query;\n\t}\n\n\tpublic function quote($string)\n\t{\n\t\treturn $this->pdo->quote($string);\n\t}\n\n\tprotected function tableQuote($table)\n\t{\n\t\treturn '\"' . $this->prefix . $table . '\"';\n\t}\n\n\tprotected function mapKey()\n\t{\n\t\treturn ':MeDoO_' . $this->guid++ . '_mEdOo';\n\t}\n\n\tprotected function typeMap($value, $type)\n\t{\n\t\t$map = [\n\t\t\t'NULL' => PDO::PARAM_NULL,\n\t\t\t'integer' => PDO::PARAM_INT,\n\t\t\t'double' => PDO::PARAM_STR,\n\t\t\t'boolean' => PDO::PARAM_BOOL,\n\t\t\t'string' => PDO::PARAM_STR,\n\t\t\t'object' => PDO::PARAM_STR,\n\t\t\t'resource' => PDO::PARAM_LOB\n\t\t];\n\n\t\tif ($type === 'boolean')\n\t\t{\n\t\t\t$value = ($value ? '1' : '0');\n\t\t}\n\t\telseif ($type === 'NULL')\n\t\t{\n\t\t\t$value = null;\n\t\t}\n\n\t\treturn [$value, $map[ $type ]];\n\t}\n\n\tprotected function columnQuote($string)\n\t{\n\t\tif (!preg_match('/^[a-zA-Z0-9]+(\\.?[a-zA-Z0-9]+)?$/i', $string))\n\t\t{\n\t\t\tthrow new InvalidArgumentException(\"Incorrect column name \\\"$string\\\"\");\n\t\t}\n\n\t\tif (strpos($string, '.') !== false)\n\t\t{\n\t\t\treturn '\"' . $this->prefix . str_replace('.', '\".\"', $string) . '\"';\n\t\t}\n\n\t\treturn '\"' . $string . '\"';\n\t}\n\n\tprotected function columnPush(&$columns, &$map, $root, $is_join = false)\n\t{\n\t\tif ($columns === '*')\n\t\t{\n\t\t\treturn $columns;\n\t\t}\n\n\t\t$stack = [];\n\n\t\tif (is_string($columns))\n\t\t{\n\t\t\t$columns = [$columns];\n\t\t}\n\n\t\tforeach ($columns as $key => $value)\n\t\t{\n\t\t\tif (!is_int($key) && is_array($value) && $root && count(array_keys($columns)) === 1)\n\t\t\t{\n\t\t\t\t$stack[] = $this->columnQuote($key);\n\n\t\t\t\t$stack[] = $this->columnPush($value, $map, false, $is_join);\n\t\t\t}\n\t\t\telseif (is_array($value))\n\t\t\t{\n\t\t\t\t$stack[] = $this->columnPush($value, $map, false, $is_join);\n\t\t\t}\n\t\t\telseif (!is_int($key) && $raw = $this->buildRaw($value, $map))\n\t\t\t{\n\t\t\t\tpreg_match('/(?<column>[a-zA-Z0-9_\\.]+)(\\s*\\[(?<type>(String|Bool|Int|Number))\\])?/i', $key, $match);\n\n\t\t\t\t$stack[] = $raw . ' AS ' . $this->columnQuote($match[ 'column' ]);\n\t\t\t}\n\t\t\telseif (is_int($key) && is_string($value))\n\t\t\t{\n\t\t\t\tif ($is_join && strpos($value, '*') !== false)\n\t\t\t\t{\n\t\t\t\t\tthrow new InvalidArgumentException('Cannot use table.* to select all columns while joining table');\n\t\t\t\t}\n\n\t\t\t\tpreg_match('/(?<column>[a-zA-Z0-9_\\.]+)(?:\\s*\\((?<alias>[a-zA-Z0-9_]+)\\))?(?:\\s*\\[(?<type>(?:String|Bool|Int|Number|Object|JSON))\\])?/i', $value, $match);\n\n\t\t\t\tif (!empty($match[ 'alias' ]))\n\t\t\t\t{\n\t\t\t\t\t$stack[] = $this->columnQuote($match[ 'column' ]) . ' AS ' . $this->columnQuote($match[ 'alias' ]);\n\n\t\t\t\t\t$columns[ $key ] = $match[ 'alias' ];\n\n\t\t\t\t\tif (!empty($match[ 'type' ]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$columns[ $key ] .= ' [' . $match[ 'type' ] . ']';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$stack[] = $this->columnQuote($match[ 'column' ]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn implode(',', $stack);\n\t}\n\n\tprotected function arrayQuote($array)\n\t{\n\t\t$stack = [];\n\n\t\tforeach ($array as $value)\n\t\t{\n\t\t\t$stack[] = is_int($value) ? $value : $this->pdo->quote($value);\n\t\t}\n\n\t\treturn implode(',', $stack);\n\t}\n\n\tprotected function innerConjunct($data, $map, $conjunctor, $outer_conjunctor)\n\t{\n\t\t$stack = [];\n\n\t\tforeach ($data as $value)\n\t\t{\n\t\t\t$stack[] = '(' . $this->dataImplode($value, $map, $conjunctor) . ')';\n\t\t}\n\n\t\treturn implode($outer_conjunctor . ' ', $stack);\n\t}\n\n\tprotected function dataImplode($data, &$map, $conjunctor)\n\t{\n\t\t$stack = [];\n\n\t\tforeach ($data as $key => $value)\n\t\t{\n\t\t\t$type = gettype($value);\n\n\t\t\tif (\n\t\t\t\t$type === 'array' &&\n\t\t\t\tpreg_match(\"/^(AND|OR)(\\s+#.*)?$/\", $key, $relation_match)\n\t\t\t)\n\t\t\t{\n\t\t\t\t$relationship = $relation_match[ 1 ];\n\n\t\t\t\t$stack[] = $value !== array_keys(array_keys($value)) ?\n\t\t\t\t\t'(' . $this->dataImplode($value, $map, ' ' . $relationship) . ')' :\n\t\t\t\t\t'(' . $this->innerConjunct($value, $map, ' ' . $relationship, $conjunctor) . ')';\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$map_key = $this->mapKey();\n\n\t\t\tif (\n\t\t\t\tis_int($key) &&\n\t\t\t\tpreg_match('/([a-zA-Z0-9_\\.]+)\\[(?<operator>\\>\\=?|\\<\\=?|\\!?\\=)\\]([a-zA-Z0-9_\\.]+)/i', $value, $match)\n\t\t\t)\n\t\t\t{\n\t\t\t\t$stack[] = $this->columnQuote($match[ 1 ]) . ' ' . $match[ 'operator' ] . ' ' . $this->columnQuote($match[ 3 ]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpreg_match('/([a-zA-Z0-9_\\.]+)(\\[(?<operator>\\>\\=?|\\<\\=?|\\!|\\<\\>|\\>\\<|\\!?~|REGEXP)\\])?/i', $key, $match);\n\t\t\t\t$column = $this->columnQuote($match[ 1 ]);\n\n\t\t\t\tif (isset($match[ 'operator' ]))\n\t\t\t\t{\n\t\t\t\t\t$operator = $match[ 'operator' ];\n\n\t\t\t\t\tif (in_array($operator, ['>', '>=', '<', '<=']))\n\t\t\t\t\t{\n\t\t\t\t\t\t$condition = $column . ' ' . $operator . ' ';\n\n\t\t\t\t\t\tif (is_numeric($value))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$condition .= $map_key;\n\t\t\t\t\t\t\t$map[ $map_key ] = [$value, is_float($value) ? PDO::PARAM_STR : PDO::PARAM_INT];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif ($raw = $this->buildRaw($value, $map))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$condition .= $raw;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$condition .= $map_key;\n\t\t\t\t\t\t\t$map[ $map_key ] = [$value, PDO::PARAM_STR];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$stack[] = $condition;\n\t\t\t\t\t}\n\t\t\t\t\telseif ($operator === '!')\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch ($type)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'NULL':\n\t\t\t\t\t\t\t\t$stack[] = $column . ' IS NOT NULL';\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'array':\n\t\t\t\t\t\t\t\t$placeholders = [];\n\n\t\t\t\t\t\t\t\tforeach ($value as $index => $item)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$stack_key = $map_key . $index . '_i';\n\n\t\t\t\t\t\t\t\t\t$placeholders[] = $stack_key;\n\t\t\t\t\t\t\t\t\t$map[ $stack_key ] = $this->typeMap($item, gettype($item));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t$stack[] = $column . ' NOT IN (' . implode(', ', $placeholders) . ')';\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\t\tif ($raw = $this->buildRaw($value, $map))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$stack[] = $column . ' != ' . $raw;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\t\tcase 'double':\n\t\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\t\t$stack[] = $column . ' != ' . $map_key;\n\t\t\t\t\t\t\t\t$map[ $map_key ] = $this->typeMap($value, $type);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telseif ($operator === '~' || $operator === '!~')\n\t\t\t\t\t{\n\t\t\t\t\t\tif ($type !== 'array')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$value = [ $value ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$connector = ' OR ';\n\t\t\t\t\t\t$data = array_values($value);\n\n\t\t\t\t\t\tif (is_array($data[ 0 ]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (isset($value[ 'AND' ]) || isset($value[ 'OR' ]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$connector = ' ' . array_keys($value)[ 0 ] . ' ';\n\t\t\t\t\t\t\t\t$value = $data[ 0 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$like_clauses = [];\n\n\t\t\t\t\t\tforeach ($value as $index => $item)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$item = strval($item);\n\n\t\t\t\t\t\t\tif (!preg_match('/(\\[.+\\]|_|%.+|.+%)/', $item))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$item = '%' . $item . '%';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$like_clauses[] = $column . ($operator === '!~' ? ' NOT' : '') . ' LIKE ' . $map_key . 'L' . $index;\n\t\t\t\t\t\t\t$map[ $map_key . 'L' . $index ] = [$item, PDO::PARAM_STR];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$stack[] = '(' . implode($connector, $like_clauses) . ')';\n\t\t\t\t\t}\n\t\t\t\t\telseif ($operator === '<>' || $operator === '><')\n\t\t\t\t\t{\n\t\t\t\t\t\tif ($type === 'array')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ($operator === '><')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$column .= ' NOT';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$stack[] = '(' . $column . ' BETWEEN ' . $map_key . 'a AND ' . $map_key . 'b)';\n\n\t\t\t\t\t\t\t$data_type = (is_numeric($value[ 0 ]) && is_numeric($value[ 1 ])) ? PDO::PARAM_INT : PDO::PARAM_STR;\n\n\t\t\t\t\t\t\t$map[ $map_key . 'a' ] = [$value[ 0 ], $data_type];\n\t\t\t\t\t\t\t$map[ $map_key . 'b' ] = [$value[ 1 ], $data_type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telseif ($operator === 'REGEXP')\n\t\t\t\t\t{\n\t\t\t\t\t\t$stack[] = $column . ' REGEXP ' . $map_key;\n\t\t\t\t\t\t$map[ $map_key ] = [$value, PDO::PARAM_STR];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch ($type)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'NULL':\n\t\t\t\t\t\t\t$stack[] = $column . ' IS NULL';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'array':\n\t\t\t\t\t\t\t$placeholders = [];\n\n\t\t\t\t\t\t\tforeach ($value as $index => $item)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$stack_key = $map_key . $index . '_i';\n\n\t\t\t\t\t\t\t\t$placeholders[] = $stack_key;\n\t\t\t\t\t\t\t\t$map[ $stack_key ] = $this->typeMap($item, gettype($item));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$stack[] = $column . ' IN (' . implode(', ', $placeholders) . ')';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\tif ($raw = $this->buildRaw($value, $map))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$stack[] = $column . ' = ' . $raw;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tcase 'double':\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\t$stack[] = $column . ' = ' . $map_key;\n\t\t\t\t\t\t\t$map[ $map_key ] = $this->typeMap($value, $type);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn implode($conjunctor . ' ', $stack);\n\t}\n\n\tprotected function whereClause($where, &$map)\n\t{\n\t\t$where_clause = '';\n\n\t\tif (is_array($where))\n\t\t{\n\t\t\t$where_keys = array_keys($where);\n\n\t\t\t$conditions = array_diff_key($where, array_flip(\n\t\t\t\t['GROUP', 'ORDER', 'HAVING', 'LIMIT', 'LIKE', 'MATCH']\n\t\t\t));\n\n\t\t\tif (!empty($conditions))\n\t\t\t{\n\t\t\t\t$where_clause = ' WHERE ' . $this->dataImplode($conditions, $map, ' AND');\n\t\t\t}\n\n\t\t\tif (isset($where[ 'MATCH' ]) && $this->type === 'mysql')\n\t\t\t{\n\t\t\t\t$MATCH = $where[ 'MATCH' ];\n\n\t\t\t\tif (is_array($MATCH) && isset($MATCH[ 'columns' ], $MATCH[ 'keyword' ]))\n\t\t\t\t{\n\t\t\t\t\t$mode = '';\n\n\t\t\t\t\t$mode_array = [\n\t\t\t\t\t\t'natural' => 'IN NATURAL LANGUAGE MODE',\n\t\t\t\t\t\t'natural+query' => 'IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION',\n\t\t\t\t\t\t'boolean' => 'IN BOOLEAN MODE',\n\t\t\t\t\t\t'query' => 'WITH QUERY EXPANSION'\n\t\t\t\t\t];\n\n\t\t\t\t\tif (isset($MATCH[ 'mode' ], $mode_array[ $MATCH[ 'mode' ] ]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$mode = ' ' . $mode_array[ $MATCH[ 'mode' ] ];\n\t\t\t\t\t}\n\n\t\t\t\t\t$columns = implode(', ', array_map([$this, 'columnQuote'], $MATCH[ 'columns' ]));\n\t\t\t\t\t$map_key = $this->mapKey();\n\t\t\t\t\t$map[ $map_key ] = [$MATCH[ 'keyword' ], PDO::PARAM_STR];\n\n\t\t\t\t\t$where_clause .= ($where_clause !== '' ? ' AND ' : ' WHERE') . ' MATCH (' . $columns . ') AGAINST (' . $map_key . $mode . ')';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isset($where[ 'GROUP' ]))\n\t\t\t{\n\t\t\t\t$GROUP = $where[ 'GROUP' ];\n\n\t\t\t\tif (is_array($GROUP))\n\t\t\t\t{\n\t\t\t\t\t$stack = [];\n\n\t\t\t\t\tforeach ($GROUP as $column => $value)\n\t\t\t\t\t{\n\t\t\t\t\t\t$stack[] = $this->columnQuote($value);\n\t\t\t\t\t}\n\n\t\t\t\t\t$where_clause .= ' GROUP BY ' . implode(',', $stack);\n\t\t\t\t}\n\t\t\t\telseif ($raw = $this->buildRaw($GROUP, $map))\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' GROUP BY ' . $raw;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' GROUP BY ' . $this->columnQuote($GROUP);\n\t\t\t\t}\n\n\t\t\t\tif (isset($where[ 'HAVING' ]))\n\t\t\t\t{\n\t\t\t\t\tif ($raw = $this->buildRaw($where[ 'HAVING' ], $map))\n\t\t\t\t\t{\n\t\t\t\t\t\t$where_clause .= ' HAVING ' . $raw;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$where_clause .= ' HAVING ' . $this->dataImplode($where[ 'HAVING' ], $map, ' AND');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isset($where[ 'ORDER' ]))\n\t\t\t{\n\t\t\t\t$ORDER = $where[ 'ORDER' ];\n\n\t\t\t\tif (is_array($ORDER))\n\t\t\t\t{\n\t\t\t\t\t$stack = [];\n\n\t\t\t\t\tforeach ($ORDER as $column => $value)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (is_array($value))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$stack[] = 'FIELD(' . $this->columnQuote($column) . ', ' . $this->arrayQuote($value) . ')';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif ($value === 'ASC' || $value === 'DESC')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$stack[] = $this->columnQuote($column) . ' ' . $value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif (is_int($column))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$stack[] = $this->columnQuote($value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$where_clause .= ' ORDER BY ' . implode(',', $stack);\n\t\t\t\t}\n\t\t\t\telseif ($raw = $this->buildRaw($ORDER, $map))\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' ORDER BY ' . $raw;\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' ORDER BY ' . $this->columnQuote($ORDER);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tisset($where[ 'LIMIT' ]) &&\n\t\t\t\t\tin_array($this->type, ['oracle', 'mssql'])\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t$LIMIT = $where[ 'LIMIT' ];\n\n\t\t\t\t\tif (is_numeric($LIMIT))\n\t\t\t\t\t{\n\t\t\t\t\t\t$LIMIT = [0, $LIMIT];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (\n\t\t\t\t\t\tis_array($LIMIT) &&\n\t\t\t\t\t\tis_numeric($LIMIT[ 0 ]) &&\n\t\t\t\t\t\tis_numeric($LIMIT[ 1 ])\n\t\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\t$where_clause .= ' OFFSET ' . $LIMIT[ 0 ] . ' ROWS FETCH NEXT ' . $LIMIT[ 1 ] . ' ROWS ONLY';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isset($where[ 'LIMIT' ]) && !in_array($this->type, ['oracle', 'mssql']))\n\t\t\t{\n\t\t\t\t$LIMIT = $where[ 'LIMIT' ];\n\n\t\t\t\tif (is_numeric($LIMIT))\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' LIMIT ' . $LIMIT;\n\t\t\t\t}\n\t\t\t\telseif (\n\t\t\t\t\tis_array($LIMIT) &&\n\t\t\t\t\tis_numeric($LIMIT[ 0 ]) &&\n\t\t\t\t\tis_numeric($LIMIT[ 1 ])\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t$where_clause .= ' LIMIT ' . $LIMIT[ 1 ] . ' OFFSET ' . $LIMIT[ 0 ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telseif ($raw = $this->buildRaw($where, $map))\n\t\t{\n\t\t\t$where_clause .= ' ' . $raw;\n\t\t}\n\n\t\treturn $where_clause;\n\t}\n\n\tprotected function selectContext($table, &$map, $join, &$columns = null, $where = null, $column_fn = null)\n\t{\n\t\tpreg_match('/(?<table>[a-zA-Z0-9_]+)\\s*\\((?<alias>[a-zA-Z0-9_]+)\\)/i', $table, $table_match);\n\n\t\tif (isset($table_match[ 'table' ], $table_match[ 'alias' ]))\n\t\t{\n\t\t\t$table = $this->tableQuote($table_match[ 'table' ]);\n\n\t\t\t$table_query = $table . ' AS ' . $this->tableQuote($table_match[ 'alias' ]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$table = $this->tableQuote($table);\n\n\t\t\t$table_query = $table;\n\t\t}\n\n\t\t$is_join = false;\n\t\t$join_key = is_array($join) ? array_keys($join) : null;\n\n\t\tif (\n\t\t\tisset($join_key[ 0 ]) &&\n\t\t\tstrpos($join_key[ 0 ], '[') === 0\n\t\t)\n\t\t{\n\t\t\t$is_join = true;\n\t\t\t$table_query .= ' ' . $this->buildJoin($table, $join);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (is_null($columns))\n\t\t\t{\n\t\t\t\tif (\n\t\t\t\t\t!is_null($where) ||\n\t\t\t\t\t(is_array($join) && isset($column_fn))\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t$where = $join;\n\t\t\t\t\t$columns = null;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$where = null;\n\t\t\t\t\t$columns = $join;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$where = $columns;\n\t\t\t\t$columns = $join;\n\t\t\t}\n\t\t}\n\n\t\tif (isset($column_fn))\n\t\t{\n\t\t\tif ($column_fn === 1)\n\t\t\t{\n\t\t\t\t$column = '1';\n\n\t\t\t\tif (is_null($where))\n\t\t\t\t{\n\t\t\t\t\t$where = $columns;\n\t\t\t\t}\n\t\t\t}\n\t\t\telseif ($raw = $this->buildRaw($column_fn, $map))\n\t\t\t{\n\t\t\t\t$column = $raw;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (empty($columns) || $this->isRaw($columns))\n\t\t\t\t{\n\t\t\t\t\t$columns = '*';\n\t\t\t\t\t$where = $join;\n\t\t\t\t}\n\n\t\t\t\t$column = $column_fn . '(' . $this->columnPush($columns, $map, true) . ')';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$column = $this->columnPush($columns, $map, true, $is_join);\n\t\t}\n\n\t\treturn 'SELECT ' . $column . ' FROM ' . $table_query . $this->whereClause($where, $map);\n\t}\n\n\tprotected function buildJoin($table, $join)\n\t{\n\t\t$table_join = [];\n\n\t\t$join_array = [\n\t\t\t'>' => 'LEFT',\n\t\t\t'<' => 'RIGHT',\n\t\t\t'<>' => 'FULL',\n\t\t\t'><' => 'INNER'\n\t\t];\n\n\t\tforeach($join as $sub_table => $relation)\n\t\t{\n\t\t\tpreg_match('/(\\[(?<join>\\<\\>?|\\>\\<?)\\])?(?<table>[a-zA-Z0-9_]+)\\s?(\\((?<alias>[a-zA-Z0-9_]+)\\))?/', $sub_table, $match);\n\n\t\t\tif ($match[ 'join' ] !== '' && $match[ 'table' ] !== '')\n\t\t\t{\n\t\t\t\tif (is_string($relation))\n\t\t\t\t{\n\t\t\t\t\t$relation = 'USING (\"' . $relation . '\")';\n\t\t\t\t}\n\n\t\t\t\tif (is_array($relation))\n\t\t\t\t{\n\t\t\t\t\t// For ['column1', 'column2']\n\t\t\t\t\tif (isset($relation[ 0 ]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$relation = 'USING (\"' . implode('\", \"', $relation) . '\")';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$joins = [];\n\n\t\t\t\t\t\tforeach ($relation as $key => $value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$joins[] = (\n\t\t\t\t\t\t\t\tstrpos($key, '.') > 0 ?\n\t\t\t\t\t\t\t\t\t// For ['tableB.column' => 'column']\n\t\t\t\t\t\t\t\t\t$this->columnQuote($key) :\n\n\t\t\t\t\t\t\t\t\t// For ['column1' => 'column2']\n\t\t\t\t\t\t\t\t\t$table . '.\"' . $key . '\"'\n\t\t\t\t\t\t\t) .\n\t\t\t\t\t\t\t' = ' .\n\t\t\t\t\t\t\t$this->tableQuote(isset($match[ 'alias' ]) ? $match[ 'alias' ] : $match[ 'table' ]) . '.\"' . $value . '\"';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$relation = 'ON ' . implode(' AND ', $joins);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$table_name = $this->tableQuote($match[ 'table' ]) . ' ';\n\n\t\t\t\tif (isset($match[ 'alias' ]))\n\t\t\t\t{\n\t\t\t\t\t$table_name .= 'AS ' . $this->tableQuote($match[ 'alias' ]) . ' ';\n\t\t\t\t}\n\n\t\t\t\t$table_join[] = $join_array[ $match[ 'join' ] ] . ' JOIN ' . $table_name . $relation;\n\t\t\t}\n\t\t}\n\n\t\treturn implode(' ', $table_join);\n\t}\n\n\tprotected function columnMap($columns, &$stack, $root)\n\t{\n\t\tif ($columns === '*')\n\t\t{\n\t\t\treturn $stack;\n\t\t}\n\n\t\tforeach ($columns as $key => $value)\n\t\t{\n\t\t\tif (is_int($key))\n\t\t\t{\n\t\t\t\tpreg_match('/([a-zA-Z0-9_]+\\.)?(?<column>[a-zA-Z0-9_]+)(?:\\s*\\((?<alias>[a-zA-Z0-9_]+)\\))?(?:\\s*\\[(?<type>(?:String|Bool|Int|Number|Object|JSON))\\])?/i', $value, $key_match);\n\n\t\t\t\t$column_key = !empty($key_match[ 'alias' ]) ?\n\t\t\t\t\t$key_match[ 'alias' ] :\n\t\t\t\t\t$key_match[ 'column' ];\n\n\t\t\t\tif (isset($key_match[ 'type' ]))\n\t\t\t\t{\n\t\t\t\t\t$stack[ $value ] = [$column_key, $key_match[ 'type' ]];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$stack[ $value ] = [$column_key, 'String'];\n\t\t\t\t}\n\t\t\t}\n\t\t\telseif ($this->isRaw($value))\n\t\t\t{\n\t\t\t\tpreg_match('/([a-zA-Z0-9_]+\\.)?(?<column>[a-zA-Z0-9_]+)(\\s*\\[(?<type>(String|Bool|Int|Number))\\])?/i', $key, $key_match);\n\n\t\t\t\t$column_key = $key_match[ 'column' ];\n\n\t\t\t\tif (isset($key_match[ 'type' ]))\n\t\t\t\t{\n\t\t\t\t\t$stack[ $key ] = [$column_key, $key_match[ 'type' ]];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$stack[ $key ] = [$column_key, 'String'];\n\t\t\t\t}\n\t\t\t}\n\t\t\telseif (!is_int($key) && is_array($value))\n\t\t\t{\n\t\t\t\tif ($root && count(array_keys($columns)) === 1)\n\t\t\t\t{\n\t\t\t\t\t$stack[ $key ] = [$key, 'String'];\n\t\t\t\t}\n\n\t\t\t\t$this->columnMap($value, $stack, false);\n\t\t\t}\n\t\t}\n\n\t\treturn $stack;\n\t}\n\n\tprotected function dataMap($data, $columns, $column_map, &$stack, $root, &$result)\n\t{\n\t\tif ($root)\n\t\t{\n\t\t\t$columns_key = array_keys($columns);\n\n\t\t\tif (count($columns_key) === 1 && is_array($columns[$columns_key[0]]))\n\t\t\t{\n\t\t\t\t$index_key = array_keys($columns)[0];\n\t\t\t\t$data_key = preg_replace(\"/^[a-zA-Z0-9_]+\\./i\", \"\", $index_key);\n\n\t\t\t\t$current_stack = [];\n\n\t\t\t\tforeach ($data as $item)\n\t\t\t\t{\n\t\t\t\t\t$this->dataMap($data, $columns[ $index_key ], $column_map, $current_stack, false, $result);\n\n\t\t\t\t\t$index = $data[ $data_key ];\n\n\t\t\t\t\t$result[ $index ] = $current_stack;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$current_stack = [];\n\t\t\t\t\n\t\t\t\t$this->dataMap($data, $columns, $column_map, $current_stack, false, $result);\n\n\t\t\t\t$result[] = $current_stack;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tforeach ($columns as $key => $value)\n\t\t{\n\t\t\t$isRaw = $this->isRaw($value);\n\n\t\t\tif (is_int($key) || $isRaw)\n\t\t\t{\n\t\t\t\t$map = $column_map[ $isRaw ? $key : $value ];\n\n\t\t\t\t$column_key = $map[ 0 ];\n\n\t\t\t\t$item = $data[ $column_key ];\n\n\t\t\t\tif (isset($map[ 1 ]))\n\t\t\t\t{\n\t\t\t\t\tif ($isRaw && in_array($map[ 1 ], ['Object', 'JSON']))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_null($item))\n\t\t\t\t\t{\n\t\t\t\t\t\t$stack[ $column_key ] = null;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ($map[ 1 ])\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'Number':\n\t\t\t\t\t\t\t$stack[ $column_key ] = (double) $item;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Int':\n\t\t\t\t\t\t\t$stack[ $column_key ] = (int) $item;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Bool':\n\t\t\t\t\t\t\t$stack[ $column_key ] = (bool) $item;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\t\t$stack[ $column_key ] = unserialize($item);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'JSON':\n\t\t\t\t\t\t\t$stack[ $column_key ] = json_decode($item, true);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'String':\n\t\t\t\t\t\t\t$stack[ $column_key ] = $item;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$stack[ $column_key ] = $item;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$current_stack = [];\n\n\t\t\t\t$this->dataMap($data, $value, $column_map, $current_stack, false, $result);\n\n\t\t\t\t$stack[ $key ] = $current_stack;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function create($table, $columns, $options = null)\n\t{\n\t\t$stack = [];\n\n\t\t$tableName = $this->prefix . $table;\n\n\t\tforeach ($columns as $name => $definition)\n\t\t{\n\t\t\tif (is_int($name))\n\t\t\t{\n\t\t\t\t$stack[] = preg_replace('/\\<([a-zA-Z0-9_]+)\\>/i', '\"$1\"', $definition);\n\t\t\t}\n\t\t\telseif (is_array($definition))\n\t\t\t{\n\t\t\t\t$stack[] = $name . ' ' . implode(' ', $definition);\n\t\t\t}\n\t\t\telseif (is_string($definition))\n\t\t\t{\n\t\t\t\t$stack[] = $name . ' ' . $this->query($definition);\n\t\t\t}\n\t\t}\n\n\t\t$table_option = '';\n\n\t\tif (is_array($options))\n\t\t{\n\t\t\t$option_stack = [];\n\n\t\t\tforeach ($options as $key => $value)\n\t\t\t{\n\t\t\t\tif (is_string($value) || is_int($value))\n\t\t\t\t{\n\t\t\t\t\t$option_stack[] = \"$key = $value\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$table_option = ' ' . implode(', ', $option_stack);\n\t\t}\n\t\telseif (is_string($options))\n\t\t{\n\t\t\t$table_option = ' ' . $options;\n\t\t}\n\n\t\treturn $this->exec(\"CREATE TABLE IF NOT EXISTS $tableName (\" . implode(', ', $stack) . \")$table_option\");\n\t}\n\n\tpublic function drop($table)\n\t{\n\t\t$tableName = $this->prefix . $table;\n\n\t\treturn $this->exec(\"DROP TABLE IF EXISTS $tableName\");\n\t}\n\n\tpublic function select($table, $join, $columns = null, $where = null)\n\t{\n\t\t$map = [];\n\t\t$result = [];\n\t\t$column_map = [];\n\n\t\t$index = 0;\n\n\t\t$column = $where === null ? $join : $columns;\n\n\t\t$is_single = (is_string($column) && $column !== '*');\n\n\t\t$query = $this->exec($this->selectContext($table, $map, $join, $columns, $where), $map);\n\n\t\t$this->columnMap($columns, $column_map, true);\n\n\t\tif (!$query)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ($columns === '*')\n\t\t{\n\t\t\treturn $query->fetchAll(PDO::FETCH_ASSOC);\n\t\t}\n\n\t\tif ($is_single)\n\t\t{\n\t\t\treturn $query->fetchAll(PDO::FETCH_COLUMN);\n\t\t}\n\n\t\twhile ($data = $query->fetch(PDO::FETCH_ASSOC))\n\t\t{\n\t\t\t$current_stack = [];\n\n\t\t\t$this->dataMap($data, $columns, $column_map, $current_stack, true, $result);\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\tpublic function insert($table, $datas)\n\t{\n\t\t$stack = [];\n\t\t$columns = [];\n\t\t$fields = [];\n\t\t$map = [];\n\n\t\tif (!isset($datas[ 0 ]))\n\t\t{\n\t\t\t$datas = [$datas];\n\t\t}\n\n\t\tforeach ($datas as $data)\n\t\t{\n\t\t\tforeach ($data as $key => $value)\n\t\t\t{\n\t\t\t\t$columns[] = $key;\n\t\t\t}\n\t\t}\n\n\t\t$columns = array_unique($columns);\n\n\t\tforeach ($datas as $data)\n\t\t{\n\t\t\t$values = [];\n\n\t\t\tforeach ($columns as $key)\n\t\t\t{\n\t\t\t\tif ($raw = $this->buildRaw($data[ $key ], $map))\n\t\t\t\t{\n\t\t\t\t\t$values[] = $raw;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$map_key = $this->mapKey();\n\n\t\t\t\t$values[] = $map_key;\n\n\t\t\t\tif (!isset($data[ $key ]))\n\t\t\t\t{\n\t\t\t\t\t$map[ $map_key ] = [null, PDO::PARAM_NULL];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$value = $data[ $key ];\n\n\t\t\t\t\t$type = gettype($value);\n\n\t\t\t\t\tswitch ($type)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'array':\n\t\t\t\t\t\t\t$map[ $map_key ] = [\n\t\t\t\t\t\t\t\tstrpos($key, '[JSON]') === strlen($key) - 6 ?\n\t\t\t\t\t\t\t\t\tjson_encode($value) :\n\t\t\t\t\t\t\t\t\tserialize($value),\n\t\t\t\t\t\t\t\tPDO::PARAM_STR\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\t$value = serialize($value);\n\n\t\t\t\t\t\tcase 'NULL':\n\t\t\t\t\t\tcase 'resource':\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tcase 'double':\n\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\t$map[ $map_key ] = $this->typeMap($value, $type);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$stack[] = '(' . implode(', ', $values) . ')';\n\t\t}\n\n\t\tforeach ($columns as $key)\n\t\t{\n\t\t\t$fields[] = $this->columnQuote(preg_replace(\"/(\\s*\\[JSON\\]$)/i\", '', $key));\n\t\t}\n\n\t\treturn $this->exec('INSERT INTO ' . $this->tableQuote($table) . ' (' . implode(', ', $fields) . ') VALUES ' . implode(', ', $stack), $map);\n\t}\n\n\tpublic function update($table, $data, $where = null)\n\t{\n\t\t$fields = [];\n\t\t$map = [];\n\n\t\tforeach ($data as $key => $value)\n\t\t{\n\t\t\t$column = $this->columnQuote(preg_replace(\"/(\\s*\\[(JSON|\\+|\\-|\\*|\\/)\\]$)/i\", '', $key));\n\n\t\t\tif ($raw = $this->buildRaw($value, $map))\n\t\t\t{\n\t\t\t\t$fields[] = $column . ' = ' . $raw;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$map_key = $this->mapKey();\n\n\t\t\tpreg_match('/(?<column>[a-zA-Z0-9_]+)(\\[(?<operator>\\+|\\-|\\*|\\/)\\])?/i', $key, $match);\n\n\t\t\tif (isset($match[ 'operator' ]))\n\t\t\t{\n\t\t\t\tif (is_numeric($value))\n\t\t\t\t{\n\t\t\t\t\t$fields[] = $column . ' = ' . $column . ' ' . $match[ 'operator' ] . ' ' . $value;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$fields[] = $column . ' = ' . $map_key;\n\n\t\t\t\t$type = gettype($value);\n\n\t\t\t\tswitch ($type)\n\t\t\t\t{\n\t\t\t\t\tcase 'array':\n\t\t\t\t\t\t$map[ $map_key ] = [\n\t\t\t\t\t\t\tstrpos($key, '[JSON]') === strlen($key) - 6 ?\n\t\t\t\t\t\t\t\tjson_encode($value) :\n\t\t\t\t\t\t\t\tserialize($value),\n\t\t\t\t\t\t\tPDO::PARAM_STR\n\t\t\t\t\t\t];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t$value = serialize($value);\n\n\t\t\t\t\tcase 'NULL':\n\t\t\t\t\tcase 'resource':\n\t\t\t\t\tcase 'boolean':\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\tcase 'double':\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t$map[ $map_key ] = $this->typeMap($value, $type);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $this->exec('UPDATE ' . $this->tableQuote($table) . ' SET ' . implode(', ', $fields) . $this->whereClause($where, $map), $map);\n\t}\n\n\tpublic function delete($table, $where)\n\t{\n\t\t$map = [];\n\n\t\treturn $this->exec('DELETE FROM ' . $this->tableQuote($table) . $this->whereClause($where, $map), $map);\n\t}\n\n\tpublic function replace($table, $columns, $where = null)\n\t{\n\t\tif (!is_array($columns) || empty($columns))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t$map = [];\n\t\t$stack = [];\n\n\t\tforeach ($columns as $column => $replacements)\n\t\t{\n\t\t\tif (is_array($replacements))\n\t\t\t{\n\t\t\t\tforeach ($replacements as $old => $new)\n\t\t\t\t{\n\t\t\t\t\t$map_key = $this->mapKey();\n\n\t\t\t\t\t$stack[] = $this->columnQuote($column) . ' = REPLACE(' . $this->columnQuote($column) . ', ' . $map_key . 'a, ' . $map_key . 'b)';\n\n\t\t\t\t\t$map[ $map_key . 'a' ] = [$old, PDO::PARAM_STR];\n\t\t\t\t\t$map[ $map_key . 'b' ] = [$new, PDO::PARAM_STR];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!empty($stack))\n\t\t{\n\t\t\treturn $this->exec('UPDATE ' . $this->tableQuote($table) . ' SET ' . implode(', ', $stack) . $this->whereClause($where, $map), $map);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic function get($table, $join = null, $columns = null, $where = null)\n\t{\n\t\t$map = [];\n\t\t$result = [];\n\t\t$column_map = [];\n\t\t$current_stack = [];\n\n\t\tif ($where === null)\n\t\t{\n\t\t\t$column = $join;\n\t\t\tunset($columns[ 'LIMIT' ]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$column = $columns;\n\t\t\tunset($where[ 'LIMIT' ]);\n\t\t}\n\n\t\t$is_single = (is_string($column) && $column !== '*');\n\n\t\t$query = $this->exec($this->selectContext($table, $map, $join, $columns, $where) . ' LIMIT 1', $map);\n\n\t\tif ($query)\n\t\t{\n\t\t\t$data = $query->fetchAll(PDO::FETCH_ASSOC);\n\n\t\t\tif (isset($data[ 0 ]))\n\t\t\t{\n\t\t\t\tif ($column === '*')\n\t\t\t\t{\n\t\t\t\t\treturn $data[ 0 ];\n\t\t\t\t}\n\n\t\t\t\t$this->columnMap($columns, $column_map, true);\n\n\t\t\t\t$this->dataMap($data[ 0 ], $columns, $column_map, $current_stack, true, $result);\n\n\t\t\t\tif ($is_single)\n\t\t\t\t{\n\t\t\t\t\treturn $result[ 0 ][ $column_map[ $column ][ 0 ] ];\n\t\t\t\t}\n\n\t\t\t\treturn $result[ 0 ];\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function has($table, $join, $where = null)\n\t{\n\t\t$map = [];\n\t\t$column = null;\n\n\t\tif ($this->type === 'mssql')\n\t\t{\n\t\t\t$query = $this->exec($this->selectContext($table, $map, $join, $column, $where, Medoo::raw('TOP 1 1')), $map);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$query = $this->exec('SELECT EXISTS(' . $this->selectContext($table, $map, $join, $column, $where, 1) . ')', $map);\n\t\t}\n\n\t\tif ($query)\n\t\t{\n\t\t\t$result = $query->fetchColumn();\n\n\t\t\treturn $result === '1' || $result === 1 || $result === true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic function rand($table, $join = null, $columns = null, $where = null)\n\t{\n\t\t$type = $this->type;\n\n\t\t$order = 'RANDOM()';\n\n\t\tif ($type === 'mysql')\n\t\t{\n\t\t\t$order = 'RAND()';\n\t\t}\n\t\telseif ($type === 'mssql')\n\t\t{\n\t\t\t$order = 'NEWID()';\n\t\t}\n\n\t\t$order_raw = $this->raw($order);\n\n\t\tif ($where === null)\n\t\t{\n\t\t\tif ($columns === null)\n\t\t\t{\n\t\t\t\t$columns = [\n\t\t\t\t\t'ORDER'  => $order_raw\n\t\t\t\t];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$column = $join;\n\t\t\t\tunset($columns[ 'ORDER' ]);\n\n\t\t\t\t$columns[ 'ORDER' ] = $order_raw;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunset($where[ 'ORDER' ]);\n\n\t\t\t$where[ 'ORDER' ] = $order_raw;\n\t\t}\n\n\t\treturn $this->select($table, $join, $columns, $where);\n\t}\n\n\tprivate function aggregate($type, $table, $join = null, $column = null, $where = null)\n\t{\n\t\t$map = [];\n\n\t\t$query = $this->exec($this->selectContext($table, $map, $join, $column, $where, strtoupper($type)), $map);\n\n\t\tif ($query)\n\t\t{\n\t\t\t$number = $query->fetchColumn();\n\n\t\t\treturn is_numeric($number) ? $number + 0 : $number;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic function count($table, $join = null, $column = null, $where = null)\n\t{\n\t\treturn $this->aggregate('count', $table, $join, $column, $where);\n\t}\n\n\tpublic function avg($table, $join, $column = null, $where = null)\n\t{\n\t\treturn $this->aggregate('avg', $table, $join, $column, $where);\n\t}\n\n\tpublic function max($table, $join, $column = null, $where = null)\n\t{\n\t\treturn $this->aggregate('max', $table, $join, $column, $where);\n\t}\n\n\tpublic function min($table, $join, $column = null, $where = null)\n\t{\n\t\treturn $this->aggregate('min', $table, $join, $column, $where);\n\t}\n\n\tpublic function sum($table, $join, $column = null, $where = null)\n\t{\n\t\treturn $this->aggregate('sum', $table, $join, $column, $where);\n\t}\n\n\tpublic function action($actions)\n\t{\n\t\tif (is_callable($actions))\n\t\t{\n\t\t\t$this->pdo->beginTransaction();\n\n\t\t\ttry {\n\t\t\t\t$result = $actions($this);\n\n\t\t\t\tif ($result === false)\n\t\t\t\t{\n\t\t\t\t\t$this->pdo->rollBack();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$this->pdo->commit();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\t$this->pdo->rollBack();\n\n\t\t\t\tthrow $e;\n\t\t\t}\n\n\t\t\treturn $result;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic function id()\n\t{\n\t\tif ($this->statement == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\t$type = $this->type;\n\n\t\tif ($type === 'oracle')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\telseif ($type === 'pgsql')\n\t\t{\n\t\t\treturn $this->pdo->query('SELECT LASTVAL()')->fetchColumn();\n\t\t}\n\n\t\t$lastId = $this->pdo->lastInsertId();\n\n\t\tif ($lastId != \"0\" && $lastId != \"\")\n\t\t{\n\t\t\treturn $lastId;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic function debug()\n\t{\n\t\t$this->debug_mode = true;\n\n\t\treturn $this;\n\t}\n\n\tpublic function error()\n\t{\n\t\treturn $this->statement ? $this->statement->errorInfo() : null;\n\t}\n\n\tpublic function last()\n\t{\n\t\t$log = end($this->logs);\n\n\t\treturn $this->generate($log[ 0 ], $log[ 1 ]);\n\t}\n\n\tpublic function log()\n\t{\n\t\treturn array_map(function ($log)\n\t\t\t{\n\t\t\t\treturn $this->generate($log[ 0 ], $log[ 1 ]);\n\t\t\t},\n\t\t\t$this->logs\n\t\t);\n\t}\n\n\tpublic function info()\n\t{\n\t\t$output = [\n\t\t\t'server' => 'SERVER_INFO',\n\t\t\t'driver' => 'DRIVER_NAME',\n\t\t\t'client' => 'CLIENT_VERSION',\n\t\t\t'version' => 'SERVER_VERSION',\n\t\t\t'connection' => 'CONNECTION_STATUS'\n\t\t];\n\n\t\tforeach ($output as $key => $value)\n\t\t{\n\t\t\t$output[ $key ] = @$this->pdo->getAttribute(constant('PDO::ATTR_' . $value));\n\t\t}\n\n\t\t$output[ 'dsn' ] = $this->dsn;\n\n\t\treturn $output;\n\t}\n}"], "filenames": ["src/Medoo.php"], "buggy_code_start_loc": [502], "buggy_code_end_loc": [502], "fixing_code_start_loc": [503], "fixing_code_end_loc": [508], "type": "CWE-89", "message": "columnQuote in medoo before 1.7.5 allows remote attackers to perform a SQL Injection due to improper escaping.", "other": {"cve": {"id": "CVE-2019-10762", "sourceIdentifier": "report@snyk.io", "published": "2019-10-30T22:15:10.747", "lastModified": "2019-11-01T14:12:49.090", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "columnQuote in medoo before 1.7.5 allows remote attackers to perform a SQL Injection due to improper escaping."}, {"lang": "es", "value": "columnQuote en medoo versiones anteriores a 1.7.5, permite a atacantes remotos realizar una inyecci\u00f3n SQL debido a un escape inapropiado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:medoo:medoo:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.5", "matchCriteriaId": "A6653FEA-EBCA-4478-9D93-BE3BAF7F8924"}]}]}], "references": [{"url": "https://github.com/catfan/Medoo/commit/659864b393961bf224bba1efc03b7dcbed7de533", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-PHP-CATFANMEDOO-474562", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/catfan/Medoo/commit/659864b393961bf224bba1efc03b7dcbed7de533"}}