{"buggy_code": ["<?php\n/**\n * Simple custom tag extension to render information from the Meetup API.\n *\n * PHP version 5\n *\n * @ingroup Extensions\n * @author  Geoff Baskwill <me@geoffbaskwill.ca>\n * @version 0.1\n * @link    https://github.com/glb/mediawiki-tag-extension-meetup\n * @license https://opensource.org/licenses/MIT MIT\n */\n\n/**\n * Protect against register_globals vulnerabilities.\n * This line must be present before any global variable is referenced.\n */\nif( !defined( 'MEDIAWIKI' ) ) {\n\techo( \"This is an extension to the MediaWiki package and cannot be run standalone.\\n\" );\n\tdie( -1 );\n}\n\n// Extension credits that will show up on Special:Version\n$wgExtensionCredits['parserhook'][] = array(\n\t'path' => __FILE__,\n\t'name' => 'Meetup',\n\t'version' => '0.1',\n\t'author' => 'Geoff Baskwill',\n\t'url' => 'https://github.com/glb/mediawiki-tag-extension-meetup',\n\t'descriptionmsg' => 'meetup-desc', // Message key in i18n file.\n\t'description' => 'Adds <code>&lt;meetup&gt;</code> tag for including Meetup information in pages',\n);\n\n/**\n * Simple custom tag extension to render information from the Meetup API.\n *\n * This class is based on the sample tag extension documented at\n * https://www.mediawiki.org/wiki/Manual:Tag_extensions\n *\n * Special thanks to the Magic:NoCache hook for the special magic\n * required to disable caching so that the page always uses fresh\n * data from the API.\n *\n * https://phabricator.wikimedia.org/diffusion/EMNC/browse/master/MagicNoCache.hooks.php\n *\n * @ingroup Extensions\n * @author  Geoff Baskwill <me@geoffbaskwill.ca>\n * @link    https://github.com/glb/mediawiki-tag-extension-meetup\n * @license https://opensource.org/licenses/MIT MIT\n */\nclass Meetup\n{\n\t/**\n\t * Register our custom render callback with the parser.\n\t *\n\t * @param Parser $parser The Parser object that the function should\n\t *                       register its hook with.\n\t *\n\t * @return true\n\t */\n\tpublic static function init( $parser )\n\t{\n\t\t// When the parser sees the <meetup> tag, it executes renderTag\n\t\t$parser->setHook( 'meetup', array( 'Meetup', 'renderTag') );\n\t\treturn true;\n\t}\n\n\t/**\n\t * Render <meetup> tag.\n\t *\n\t * This function renders a custom <meetup group=\"{group ID}\" /> tag,\n\t * reaching out to the meetup.com API to get details of upcoming and past\n\t * meetups.\n\t *\n\t * @param string  $input  The content of the tag (ignored as we don't render it).\n\t * @param array   $param  The array of parameters passed to the tag.\n\t * @param Parser  $parser The Parser -- needed to turn off caching\n\t * @param PPFrame $frame  ignored\n\t *\n\t * @global OutputPage $wgOut The OutputPage -- we need it to turn off\n\t *                           caching for this page.\n\t * @global array      $wgAction The action being performed -- we need it to\n\t *                              control whether we turn off caching.\n\t *\n\t * @return string content to be displayed\n\t */\n\tpublic static function renderTag( $input, $param = array(), $parser = null, $frame = false) {\n\t\tglobal $wgOut, $wgAction;\n\n\t\t$wgOut->addModules( 'ext.meetup.base' );\n\n\t\tif ( !in_array($wgAction, ['submit', 'edit']) ) {\n\t\t\t$parser->disableCache();\n\t\t\t$wgOut->enableClientCache(false);\n\t\t}\n\n\t\t// This isn't particularly great if the wiki is set up with a CSP that\n\t\t// disallows inline CSS. A better solution would move the CSS to a\n\t\t// resource.\n\n//\t\t$ret = '<style>' .\n//\t\t       '.meetup-description { font-weight: lighter; display: block; }' .\n//\t\t       '.meetup-venue { font-style: italic; display: block; }' .\n//\t\t       'li.event { margin-bottom: 1em; }' .\n//\t\t       '</style>';\n\n\t\t$ret .= Html::rawElement( 'h2', array(), wfMessage('meetup-header')->parse() );\n\n\t\t$group = $param['group'];\n\n\t\tif ( $group === false || $group == \"\" ||  $group == \"{groupID}\" ) {\n\t\t\t$ret .= Html::rawElement( 'p', array(),\n\t\t\t\twfMessage( 'meetup-missing-group-info' )->parse()\n\t\t\t);\n\t\t\treturn $ret;\n\t\t}\n\n\t\t// Ensure that the user-provided input (group ID) is encoded for the\n\t\t// context it will be used in -- which is always a URL\n\t\t$group = urlencode($group);\n\n\t\t$ret .= Html::rawElement( 'a', array(\n\t\t\t\t'target' => '_blank',\n\t\t\t\t'rel' => 'nofollow',\n\t\t\t\t'class' => 'external text meetup-badge',\n\t\t\t\t'href' => wfMessage( 'meetup-group-ui-url', $group )->plain(),\n\t\t\t), wfMessage( 'meetup-group-link-text')->parse() );\n\n\t\t$ret .= Meetup::_getAndRenderEvents(\n\t\t\t$group, 'upcoming', 5, 'false',\n\t\t\t'meetup-upcoming-events-header',\n\t\t\t'meetup-all-upcoming-events',\n\t\t\t'meetup-no-events-scheduled'\n\t\t);\n\n\t\t$ret .= Meetup::_getAndRenderEvents(\n\t\t\t$group, 'past', 5, 'true',\n\t\t\t'meetup-past-events-header',\n\t\t\t'meetup-all-past-events',\n\t\t\t'meetup-no-past-events'\n\t\t);\n\n\t\treturn $ret;\n\t}\n\n\t/**\n\t * Retrieve events from the meetup.com API and render them.\n\t *\n\t * This function retrieves the desired number of events from the API\n\t * and renders the event details in a list.\n\t *\n\t * @param string $group          The meetup.com group ID.\n\t * @param string $status         The type of events (past, upcoming, ...)\n\t *                               to retrieve and render.\n\t * @param int\t $count          The number of events to render.\n\t * @param string $desc           'true' to order events in descending order,\n\t *                               'false' otherwise.\n\t * @param string $header_message The message (see i18n/*.json) to render as\n\t *                               the header for this section.\n\t * @param string $link_message   The message (see i18n/*.json) to render as\n\t *                               the \"see all\" link for this section.\n\t * @param string $empty_message  The message (see i18n/*.json) to render if\n\t *                               there are no events for this section.\n\t *\n\t * @return string content to be displayed\n\t */\n\tprivate static function _getAndRenderEvents( $group, $status, $count,\n\t\t$desc, $header_message, $link_message, $empty_message\n\t) {\n\t\t$url = sprintf( '%s/%s/events' .\n\t\t\t\t'?sign=true&photo-host=public&page=%d&status=%s&desc=%s',\n\t\t\twfMessage( 'meetup-api-base-url' )->plain(),\n\t\t\t$group,\n\t\t\t$count,\n\t\t\t$status,\n\t\t\t$desc\n\t\t);\n\n\t\twfDebugLog( 'meetup', 'Retrieving events from API URL ' . $url );\n\n\t\t$response = @file_get_contents( $url );\n\t\tif ( $response === false ) {\n\t\t\twfDebugLog( 'meetup', 'Unable to retrieve events.' );\n\t\t\treturn \"\";\n\t\t}\n\n\t\t$events = json_decode( $response, true );\n\n\t\t$ret .= Html::rawElement( 'h3', array(), wfMessage( $header_message )->parse() );\n\n\t\tif (count($events) > 0 ) {\n\t\t\t$ret .= '<ul>';\n\t\t\tforeach ( $events as $event ) {\n\t\t\t\t// First get rid of all the tags and then escape any remaining\n\t\t\t\t// special characters in the description.\n\t\t\t\t$description = htmlspecialchars(\n\t\t\t\t\tpreg_replace(\n\t\t\t\t\t\t'/<.*?>/', '',\n\t\t\t\t\t\t$event['description']\n\t\t\t\t\t),\n\t\t\t\t\tENT_COMPAT | ENT_HTML401,\n\t\t\t\t\tini_get( \"default_charset\" ), false\n\t\t\t\t);\n\n\t\t\t\t// Then get rid of newlines; they make the formatting in the\n\t\t\t\t// wiki go bad.\n\t\t\t\t$description = preg_replace( '/\\n+/', ' ', $description );\n\n\t\t\t\t// Then cut to a max of 400 characters; if there are more then\n\t\t\t\t// add a link to the event.\n\t\t\t\t$description = preg_replace(\n\t\t\t\t\t'/(.{400})(.+)/',\n\t\t\t\t\t'\\1 ' . Html::rawElement( 'a', array(\n\t\t\t\t\t\t'target' => '_blank',\n\t\t\t\t\t\t'rel' => 'nofollow',\n\t\t\t\t\t\t'class' => 'external text',\n\t\t\t\t\t\t'href' => $event['link'],\n\t\t\t\t\t), wfMessage( 'meetup-read-more' )->parse() ),\n\t\t\t\t\t$description\n\t\t\t\t);\n\n\t\t\t\t$ret .= Html::rawElement( 'li', array(\n\t\t\t\t\t\t'class' => 'event',\n\t\t\t\t\t), Html::rawElement( 'a', array(\n\t\t\t\t\t\t'target' => '_blank',\n\t\t\t\t\t\t'rel' => 'nofollow',\n\t\t\t\t\t\t'class' => 'external text',\n\t\t\t\t\t\t'href' => $event['link']\n\t\t\t\t\t), sprintf( '%s (%s): %s',\n\t\t\t\t\t\tdate( 'M j, Y', $event['time']/1000 ),\n\t\t\t\t\t\thtmlspecialchars( $event['local_time'] ),\n\t\t\t\t\t\thtmlspecialchars( $event['name'] ) )\n\t\t\t\t\t) . Html::rawElement( 'span', array(\n\t\t\t\t\t\t'class' => 'meetup-venue',\n\t\t\t\t\t), sprintf( '%s, %s \u00b7 %s, %s',\n\t\t\t\t\t\thtmlspecialchars( $event['venue']['name'] ),\n\t\t\t\t\t\thtmlspecialchars( $event['venue']['address_1'] ),\n\t\t\t\t\t\thtmlspecialchars( $event['venue']['city'] ),\n\t\t\t\t\t\thtmlspecialchars( $event['venue']['state'] ) )\n\t\t\t\t\t) . Html::rawElement( 'span', array(\n\t\t\t\t\t\t'class' => 'meetup-description',\n\t\t\t\t\t), $description ) // user-provided input has already been\n\t\t\t\t);                       // escaped using htmlspecialchars\n\t\t\t}\n\t\t\t$ret .= '</ul>';\n\n\t\t\t$ret .= Html::rawElement( 'a', array(\n\t\t\t\t\t'target' => '_blank',\n\t\t\t\t\t'rel' => 'nofollow',\n\t\t\t\t\t'class' => 'external text',\n\t\t\t\t\t'href' => wfMessage(\n\t\t\t\t\t\t'meetup-events-ui-url', $group, $status\n\t\t\t\t\t)->plain(),\n\t\t\t\t), wfMessage( $link_message )->parse() );\n\t\t} else {\n\t\t\t$ret .= wfMessage( $empty_message )->parse();\n\t\t}\n\n\t\treturn $ret;\n\t}\n\n}\n\n?>\n", "{\n  \"name\": \"Meetup\",\n  \"author\": \"Geoff Baskwill\",\n  \"license-name\": \"MIT\",\n  \"url\": \"https://example.org\",\n  \"descriptionmsg\": \"meetup-desc\",\n  \"type\": \"parserhook\",\n  \"MessagesDirs\": {\n    \"Meetup\": [\n      \"i18n\"\n    ]\n  },\n  \"Hooks\": {\n    \"ParserFirstCallInit\": [\n      \"Meetup::init\"\n    ]\n  },\n  \"AutoloadClasses\": {\n    \"Meetup\": \"Meetup.class.php\"\n  },\n  \"ResourceModules\": {\n    \"ext.meetup.base\": {\n      \"styles\": [\n        \"modules/ext.Meetup.base.css\"\n      ]\n    }\n  },\n  \"ResourceFileModulePaths\": {\n    \"localBasePath\": \"\",\n    \"remoteExtPath\": \"Meetup\"\n  },\n  \"version\": \"0.1\",\n  \"manifest_version\": 1\n}\n"], "fixing_code": ["<?php\n/**\n * Simple custom tag extension to render information from the Meetup API.\n *\n * PHP version 5\n *\n * @ingroup Extensions\n * @author  Geoff Baskwill <me@geoffbaskwill.ca>\n * @version 0.1\n * @link    https://github.com/glb/mediawiki-tag-extension-meetup\n * @license https://opensource.org/licenses/MIT MIT\n */\n\n/**\n * Protect against register_globals vulnerabilities.\n * This line must be present before any global variable is referenced.\n */\nif( !defined( 'MEDIAWIKI' ) ) {\n\techo( \"This is an extension to the MediaWiki package and cannot be run standalone.\\n\" );\n\tdie( -1 );\n}\n\n// Extension credits that will show up on Special:Version\n$wgExtensionCredits['parserhook'][] = array(\n\t'path' => __FILE__,\n\t'name' => 'Meetup',\n\t'version' => '0.1',\n\t'author' => 'Geoff Baskwill',\n\t'url' => 'https://github.com/glb/mediawiki-tag-extension-meetup',\n\t'descriptionmsg' => 'meetup-desc', // Message key in i18n file.\n\t'description' => 'Adds <code>&lt;meetup&gt;</code> tag for including Meetup information in pages',\n);\n\n/**\n * Simple custom tag extension to render information from the Meetup API.\n *\n * This class is based on the sample tag extension documented at\n * https://www.mediawiki.org/wiki/Manual:Tag_extensions\n *\n * Special thanks to the Magic:NoCache hook for the special magic\n * required to disable caching so that the page always uses fresh\n * data from the API.\n *\n * https://phabricator.wikimedia.org/diffusion/EMNC/browse/master/MagicNoCache.hooks.php\n *\n * @ingroup Extensions\n * @author  Geoff Baskwill <me@geoffbaskwill.ca>\n * @link    https://github.com/glb/mediawiki-tag-extension-meetup\n * @license https://opensource.org/licenses/MIT MIT\n */\nclass Meetup\n{\n\t/**\n\t * Register our custom render callback with the parser.\n\t *\n\t * @param Parser $parser The Parser object that the function should\n\t *                       register its hook with.\n\t *\n\t * @return true\n\t */\n\tpublic static function init( $parser )\n\t{\n\t\t// When the parser sees the <meetup> tag, it executes renderTag\n\t\t$parser->setHook( 'meetup', array( 'Meetup', 'renderTag') );\n\t\treturn true;\n\t}\n\n\t/**\n\t * Render <meetup> tag.\n\t *\n\t * This function renders a custom <meetup group=\"{group ID}\" /> tag,\n\t * reaching out to the meetup.com API to get details of upcoming and past\n\t * meetups.\n\t *\n\t * @param string  $input  The content of the tag (ignored as we don't render it).\n\t * @param array   $param  The array of parameters passed to the tag.\n\t * @param Parser  $parser The Parser -- needed to turn off caching\n\t * @param PPFrame $frame  ignored\n\t *\n\t * @global OutputPage $wgOut The OutputPage -- we need it to turn off\n\t *                           caching for this page.\n\t * @global array      $wgAction The action being performed -- we need it to\n\t *                              control whether we turn off caching.\n\t *\n\t * @return string content to be displayed\n\t */\n\tpublic static function renderTag( $input, $param = array(), $parser = null, $frame = false) {\n\t\tglobal $wgOut, $wgAction;\n\n\t\t$wgOut->addModules( 'ext.meetup.base' );\n\n\t\tif ( !in_array($wgAction, ['submit', 'edit']) ) {\n\t\t\t$parser->disableCache();\n\t\t\t$wgOut->enableClientCache(false);\n\t\t}\n\n\t\t// This isn't particularly great if the wiki is set up with a CSP that\n\t\t// disallows inline CSS. A better solution would move the CSS to a\n\t\t// resource.\n\n//\t\t$ret = '<style>' .\n//\t\t       '.meetup-description { font-weight: lighter; display: block; }' .\n//\t\t       '.meetup-venue { font-style: italic; display: block; }' .\n//\t\t       'li.event { margin-bottom: 1em; }' .\n//\t\t       '</style>';\n\n\t\t$ret .= Html::rawElement( 'h2', array(), wfMessage('meetup-header')->parse() );\n\n\t\t$group = $param['group'];\n\n\t\tif ( $group === false || $group == \"\" ||  $group == \"{groupID}\" ) {\n\t\t\t$ret .= Html::rawElement( 'p', array(),\n\t\t\t\twfMessage( 'meetup-missing-group-info' )->parse()\n\t\t\t);\n\t\t\treturn $ret;\n\t\t}\n\n\t\t// Ensure that the user-provided input (group ID) is encoded for the\n\t\t// context it will be used in -- which is always a URL\n\t\t$group = urlencode($group);\n\n\t\t$ret .= Html::rawElement( 'a', array(\n\t\t\t\t'rel' => 'nofollow noopener noreferrer',\n\t\t\t\t'class' => 'external text meetup-badge',\n\t\t\t\t'href' => wfMessage( 'meetup-group-ui-url', $group )->plain(),\n\t\t\t), wfMessage( 'meetup-group-link-text')->parse() );\n\n\t\t$ret .= Meetup::_getAndRenderEvents(\n\t\t\t$group, 'upcoming', 5, 'false',\n\t\t\t'meetup-upcoming-events-header',\n\t\t\t'meetup-all-upcoming-events',\n\t\t\t'meetup-no-events-scheduled'\n\t\t);\n\n\t\t$ret .= Meetup::_getAndRenderEvents(\n\t\t\t$group, 'past', 5, 'true',\n\t\t\t'meetup-past-events-header',\n\t\t\t'meetup-all-past-events',\n\t\t\t'meetup-no-past-events'\n\t\t);\n\n\t\treturn $ret;\n\t}\n\n\t/**\n\t * Retrieve events from the meetup.com API and render them.\n\t *\n\t * This function retrieves the desired number of events from the API\n\t * and renders the event details in a list.\n\t *\n\t * @param string $group          The meetup.com group ID.\n\t * @param string $status         The type of events (past, upcoming, ...)\n\t *                               to retrieve and render.\n\t * @param int\t $count          The number of events to render.\n\t * @param string $desc           'true' to order events in descending order,\n\t *                               'false' otherwise.\n\t * @param string $header_message The message (see i18n/*.json) to render as\n\t *                               the header for this section.\n\t * @param string $link_message   The message (see i18n/*.json) to render as\n\t *                               the \"see all\" link for this section.\n\t * @param string $empty_message  The message (see i18n/*.json) to render if\n\t *                               there are no events for this section.\n\t *\n\t * @return string content to be displayed\n\t */\n\tprivate static function _getAndRenderEvents( $group, $status, $count,\n\t\t$desc, $header_message, $link_message, $empty_message\n\t) {\n\t\t$url = sprintf( '%s/%s/events' .\n\t\t\t\t'?sign=true&photo-host=public&page=%d&status=%s&desc=%s',\n\t\t\twfMessage( 'meetup-api-base-url' )->plain(),\n\t\t\t$group,\n\t\t\t$count,\n\t\t\t$status,\n\t\t\t$desc\n\t\t);\n\n\t\twfDebugLog( 'meetup', 'Retrieving events from API URL ' . $url );\n\n\t\t$response = @file_get_contents( $url );\n\t\tif ( $response === false ) {\n\t\t\twfDebugLog( 'meetup', 'Unable to retrieve events.' );\n\t\t\treturn \"\";\n\t\t}\n\n\t\t$events = json_decode( $response, true );\n\n\t\t$ret .= Html::rawElement( 'h3', array(), wfMessage( $header_message )->parse() );\n\n\t\tif (count($events) > 0 ) {\n\t\t\t$ret .= '<ul>';\n\t\t\tforeach ( $events as $event ) {\n\t\t\t\t// First get rid of all the tags and then escape any remaining\n\t\t\t\t// special characters in the description.\n\t\t\t\t$description = htmlspecialchars(\n\t\t\t\t\tpreg_replace(\n\t\t\t\t\t\t'/<.*?>/', '',\n\t\t\t\t\t\t$event['description']\n\t\t\t\t\t),\n\t\t\t\t\tENT_COMPAT | ENT_HTML401,\n\t\t\t\t\tini_get( \"default_charset\" ), false\n\t\t\t\t);\n\n\t\t\t\t// Then get rid of newlines; they make the formatting in the\n\t\t\t\t// wiki go bad.\n\t\t\t\t$description = preg_replace( '/\\n+/', ' ', $description );\n\n\t\t\t\t// Then cut to a max of 400 characters; if there are more then\n\t\t\t\t// add a link to the event.\n\t\t\t\t$description = preg_replace(\n\t\t\t\t\t'/(.{400})(.+)/',\n\t\t\t\t\t'\\1 ' . Html::rawElement( 'a', array(\n\t\t\t\t\t\t'rel' => 'nofollow noopener noreferrer',\n\t\t\t\t\t\t'class' => 'external text',\n\t\t\t\t\t\t'href' => $event['link'],\n\t\t\t\t\t), wfMessage( 'meetup-read-more' )->parse() ),\n\t\t\t\t\t$description\n\t\t\t\t);\n\n\t\t\t\t$ret .= Html::rawElement( 'li', array(\n\t\t\t\t\t\t'class' => 'event',\n\t\t\t\t\t), Html::rawElement( 'a', array(\n\t\t\t\t\t\t'rel' => 'nofollow noopener noreferrer',\n\t\t\t\t\t\t'class' => 'external text',\n\t\t\t\t\t\t'href' => $event['link']\n\t\t\t\t\t), sprintf( '%s (%s): %s',\n\t\t\t\t\t\tdate( 'M j, Y', $event['time']/1000 ),\n\t\t\t\t\t\thtmlspecialchars( $event['local_time'] ),\n\t\t\t\t\t\thtmlspecialchars( $event['name'] ) )\n\t\t\t\t\t) . Html::rawElement( 'span', array(\n\t\t\t\t\t\t'class' => 'meetup-venue',\n\t\t\t\t\t), sprintf( '%s, %s \u00b7 %s, %s',\n\t\t\t\t\t\thtmlspecialchars( $event['venue']['name'] ),\n\t\t\t\t\t\thtmlspecialchars( $event['venue']['address_1'] ),\n\t\t\t\t\t\thtmlspecialchars( $event['venue']['city'] ),\n\t\t\t\t\t\thtmlspecialchars( $event['venue']['state'] ) )\n\t\t\t\t\t) . Html::rawElement( 'span', array(\n\t\t\t\t\t\t'class' => 'meetup-description',\n\t\t\t\t\t), $description ) // user-provided input has already been\n\t\t\t\t);                       // escaped using htmlspecialchars\n\t\t\t}\n\t\t\t$ret .= '</ul>';\n\n\t\t\t$ret .= Html::rawElement( 'a', array(\n\t\t\t\t\t'rel' => 'nofollow noopener noreferrer',\n\t\t\t\t\t'class' => 'external text',\n\t\t\t\t\t'href' => wfMessage(\n\t\t\t\t\t\t'meetup-events-ui-url', $group, $status\n\t\t\t\t\t)->plain(),\n\t\t\t\t), wfMessage( $link_message )->parse() );\n\t\t} else {\n\t\t\t$ret .= wfMessage( $empty_message )->parse();\n\t\t}\n\n\t\treturn $ret;\n\t}\n\n}\n\n?>\n", "{\n  \"name\": \"Meetup\",\n  \"author\": \"Geoff Baskwill\",\n  \"license-name\": \"MIT\",\n  \"url\": \"https://example.org\",\n  \"descriptionmsg\": \"meetup-desc\",\n  \"type\": \"parserhook\",\n  \"MessagesDirs\": {\n    \"Meetup\": [\n      \"i18n\"\n    ]\n  },\n  \"Hooks\": {\n    \"ParserFirstCallInit\": [\n      \"Meetup::init\"\n    ]\n  },\n  \"AutoloadClasses\": {\n    \"Meetup\": \"Meetup.class.php\"\n  },\n  \"ResourceModules\": {\n    \"ext.meetup.base\": {\n      \"styles\": [\n        \"modules/ext.Meetup.base.css\"\n      ]\n    }\n  },\n  \"ResourceFileModulePaths\": {\n    \"localBasePath\": \"\",\n    \"remoteExtPath\": \"Meetup\"\n  },\n  \"version\": \"0.2\",\n  \"manifest_version\": 1\n}\n"], "filenames": ["Meetup/Meetup.class.php", "Meetup/extension.json"], "buggy_code_start_loc": [123, 32], "buggy_code_end_loc": [250, 33], "fixing_code_start_loc": [123, 32], "fixing_code_end_loc": [246, 33], "type": "NVD-CWE-noinfo", "message": "A vulnerability was found in glb Meetup Tag Extension 0.1 on MediaWiki. It has been rated as problematic. This issue affects some unknown processing of the component Link Attribute Handler. The manipulation leads to use of web link to untrusted target with window.opener access. Upgrading to version 0.2 is able to address this issue. The identifier of the patch is 850c726d6bbfe0bf270801fbb92a30babea4155c. It is recommended to upgrade the affected component. The identifier VDB-238157 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2018-25089", "sourceIdentifier": "cna@vuldb.com", "published": "2023-08-28T13:15:09.100", "lastModified": "2024-02-29T01:23:14.960", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability was found in glb Meetup Tag Extension 0.1 on MediaWiki. It has been rated as problematic. This issue affects some unknown processing of the component Link Attribute Handler. The manipulation leads to use of web link to untrusted target with window.opener access. Upgrading to version 0.2 is able to address this issue. The identifier of the patch is 850c726d6bbfe0bf270801fbb92a30babea4155c. It is recommended to upgrade the affected component. The identifier VDB-238157 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.7}, "baseSeverity": "LOW", "exploitabilityScore": 5.1, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1022"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:glb:meetup_tag:0.1:*:*:*:*:mediawiki:*:*", "matchCriteriaId": "4DAAE57B-A3A8-4EC1-AAD6-F778F80D71A9"}]}]}], "references": [{"url": "https://github.com/glb/mediawiki-tag-extension-meetup/commit/850c726d6bbfe0bf270801fbb92a30babea4155c", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/glb/mediawiki-tag-extension-meetup/releases/tag/v0.2", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.238157", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.238157", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/glb/mediawiki-tag-extension-meetup/commit/850c726d6bbfe0bf270801fbb92a30babea4155c"}}