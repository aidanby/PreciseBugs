{"buggy_code": ["'use strict';\n\nconst validator = require('validator');\nconst winston = require('winston');\n\nconst db = require('../database');\nconst user = require('../user');\nconst groups = require('../groups');\nconst meta = require('../meta');\nconst flags = require('../flags');\nconst privileges = require('../privileges');\nconst notifications = require('../notifications');\nconst plugins = require('../plugins');\nconst events = require('../events');\nconst translator = require('../translator');\nconst sockets = require('../socket.io');\n\nconst usersAPI = module.exports;\n\nusersAPI.create = async function (caller, data) {\n\tif (!data) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\tconst uid = await user.create(data);\n\treturn await user.getUserData(uid);\n};\n\nusersAPI.update = async function (caller, data) {\n\tif (!caller.uid) {\n\t\tthrow new Error('[[error:invalid-uid]]');\n\t}\n\n\tif (!data || !data.uid) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst oldUserData = await user.getUserFields(data.uid, ['email', 'username']);\n\tif (!oldUserData || !oldUserData.username) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst [isAdminOrGlobalMod, canEdit] = await Promise.all([\n\t\tuser.isAdminOrGlobalMod(caller.uid),\n\t\tprivileges.users.canEdit(caller.uid, data.uid),\n\t]);\n\n\t// Changing own email/username requires password confirmation\n\tif (data.hasOwnProperty('email') || data.hasOwnProperty('username')) {\n\t\tawait isPrivilegedOrSelfAndPasswordMatch(caller, data);\n\t}\n\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tif (!isAdminOrGlobalMod && meta.config['username:disableEdit']) {\n\t\tdata.username = oldUserData.username;\n\t}\n\n\tif (!isAdminOrGlobalMod && meta.config['email:disableEdit']) {\n\t\tdata.email = oldUserData.email;\n\t}\n\n\tawait user.updateProfile(caller.uid, data);\n\tconst userData = await user.getUserData(data.uid);\n\n\tif (userData.username !== oldUserData.username) {\n\t\tawait events.log({\n\t\t\ttype: 'username-change',\n\t\t\tuid: caller.uid,\n\t\t\ttargetUid: data.uid,\n\t\t\tip: caller.ip,\n\t\t\toldUsername: oldUserData.username,\n\t\t\tnewUsername: userData.username,\n\t\t});\n\t}\n\treturn userData;\n};\n\nusersAPI.delete = async function (caller, { uid, password }) {\n\tawait processDeletion({ uid: uid, method: 'delete', password, caller });\n};\n\nusersAPI.deleteContent = async function (caller, { uid, password }) {\n\tawait processDeletion({ uid, method: 'deleteContent', password, caller });\n};\n\nusersAPI.deleteAccount = async function (caller, { uid, password }) {\n\tawait processDeletion({ uid, method: 'deleteAccount', password, caller });\n};\n\nusersAPI.deleteMany = async function (caller, data) {\n\tif (await canDeleteUids(data.uids)) {\n\t\tawait Promise.all(data.uids.map(uid => processDeletion({ uid, method: 'delete', caller })));\n\t}\n};\n\nusersAPI.updateSettings = async function (caller, data) {\n\tif (!caller.uid || !data || !data.settings) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst canEdit = await privileges.users.canEdit(caller.uid, data.uid);\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tlet defaults = await user.getSettings(0);\n\tdefaults = {\n\t\tpostsPerPage: defaults.postsPerPage,\n\t\ttopicsPerPage: defaults.topicsPerPage,\n\t\tuserLang: defaults.userLang,\n\t\tacpLang: defaults.acpLang,\n\t};\n\t// load raw settings without parsing values to booleans\n\tconst current = await db.getObject(`user:${data.uid}:settings`);\n\tconst payload = { ...defaults, ...current, ...data.settings };\n\tdelete payload.uid;\n\n\treturn await user.saveSettings(data.uid, payload);\n};\n\nusersAPI.changePassword = async function (caller, data) {\n\tawait user.changePassword(caller.uid, Object.assign(data, { ip: caller.ip }));\n\tawait events.log({\n\t\ttype: 'password-change',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t});\n};\n\nusersAPI.follow = async function (caller, data) {\n\tawait user.follow(caller.uid, data.uid);\n\tplugins.hooks.fire('action:user.follow', {\n\t\tfromUid: caller.uid,\n\t\ttoUid: data.uid,\n\t});\n\n\tconst userData = await user.getUserFields(caller.uid, ['username', 'userslug']);\n\tconst { displayname } = userData;\n\n\tconst notifObj = await notifications.create({\n\t\ttype: 'follow',\n\t\tbodyShort: `[[notifications:user_started_following_you, ${displayname}]]`,\n\t\tnid: `follow:${data.uid}:uid:${caller.uid}`,\n\t\tfrom: caller.uid,\n\t\tpath: `/uid/${data.uid}/followers`,\n\t\tmergeId: 'notifications:user_started_following_you',\n\t});\n\tif (!notifObj) {\n\t\treturn;\n\t}\n\tnotifObj.user = userData;\n\tawait notifications.push(notifObj, [data.uid]);\n};\n\nusersAPI.unfollow = async function (caller, data) {\n\tawait user.unfollow(caller.uid, data.uid);\n\tplugins.hooks.fire('action:user.unfollow', {\n\t\tfromUid: caller.uid,\n\t\ttoUid: data.uid,\n\t});\n};\n\nusersAPI.ban = async function (caller, data) {\n\tif (!await privileges.users.hasBanPrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t} else if (await user.isAdministrator(data.uid)) {\n\t\tthrow new Error('[[error:cant-ban-other-admins]]');\n\t}\n\n\tconst banData = await user.bans.ban(data.uid, data.until, data.reason);\n\tawait db.setObjectField(`uid:${data.uid}:ban:${banData.timestamp}`, 'fromUid', caller.uid);\n\n\tif (!data.reason) {\n\t\tdata.reason = await translator.translate('[[user:info.banned-no-reason]]');\n\t}\n\n\tsockets.in(`uid_${data.uid}`).emit('event:banned', {\n\t\tuntil: data.until,\n\t\treason: validator.escape(String(data.reason || '')),\n\t});\n\n\tawait flags.resolveFlag('user', data.uid, caller.uid);\n\tawait flags.resolveUserPostFlags(data.uid, caller.uid);\n\tawait events.log({\n\t\ttype: 'user-ban',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t\treason: data.reason || undefined,\n\t});\n\tplugins.hooks.fire('action:user.banned', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t\tuntil: data.until > 0 ? data.until : undefined,\n\t\treason: data.reason || undefined,\n\t});\n\tconst canLoginIfBanned = await user.bans.canLoginIfBanned(data.uid);\n\tif (!canLoginIfBanned) {\n\t\tawait user.auth.revokeAllSessions(data.uid);\n\t}\n};\n\nusersAPI.unban = async function (caller, data) {\n\tif (!await privileges.users.hasBanPrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tawait user.bans.unban(data.uid);\n\n\tsockets.in(`uid_${data.uid}`).emit('event:unbanned');\n\n\tawait events.log({\n\t\ttype: 'user-unban',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t});\n\tplugins.hooks.fire('action:user.unbanned', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t});\n};\n\nusersAPI.mute = async function (caller, data) {\n\tif (!await privileges.users.hasMutePrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t} else if (await user.isAdministrator(data.uid)) {\n\t\tthrow new Error('[[error:cant-mute-other-admins]]');\n\t}\n\tconst reason = data.reason || '[[user:info.muted-no-reason]]';\n\tawait db.setObject(`user:${data.uid}`, {\n\t\tmutedUntil: data.until,\n\t\tmutedReason: reason,\n\t});\n\tconst now = Date.now();\n\tconst muteKey = `uid:${data.uid}:mute:${now}`;\n\tconst muteData = {\n\t\tfromUid: caller.uid,\n\t\tuid: data.uid,\n\t\ttimestamp: now,\n\t\texpire: data.until,\n\t};\n\tif (data.reason) {\n\t\tmuteData.reason = reason;\n\t}\n\tawait db.sortedSetAdd(`uid:${data.uid}:mutes:timestamp`, now, muteKey);\n\tawait db.setObject(muteKey, muteData);\n\tawait events.log({\n\t\ttype: 'user-mute',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t\treason: data.reason || undefined,\n\t});\n\tplugins.hooks.fire('action:user.muted', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t\tuntil: data.until > 0 ? data.until : undefined,\n\t\treason: data.reason || undefined,\n\t});\n};\n\nusersAPI.unmute = async function (caller, data) {\n\tif (!await privileges.users.hasMutePrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tawait db.deleteObjectFields(`user:${data.uid}`, ['mutedUntil', 'mutedReason']);\n\n\tawait events.log({\n\t\ttype: 'user-unmute',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t});\n\tplugins.hooks.fire('action:user.unmuted', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t});\n};\n\nasync function isPrivilegedOrSelfAndPasswordMatch(caller, data) {\n\tconst { uid } = caller;\n\tconst isSelf = parseInt(uid, 10) === parseInt(data.uid, 10);\n\tconst canEdit = await privileges.users.canEdit(uid, data.uid);\n\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\tconst [hasPassword, passwordMatch] = await Promise.all([\n\t\tuser.hasPassword(data.uid),\n\t\tdata.password ? user.isPasswordCorrect(data.uid, data.password, caller.ip) : false,\n\t]);\n\n\tif (isSelf && hasPassword && !passwordMatch) {\n\t\tthrow new Error('[[error:invalid-password]]');\n\t}\n}\n\nasync function processDeletion({ uid, method, password, caller }) {\n\tconst isTargetAdmin = await user.isAdministrator(uid);\n\tconst isSelf = parseInt(uid, 10) === parseInt(caller.uid, 10);\n\tconst hasAdminPrivilege = await privileges.admin.can('admin:users', caller.uid);\n\n\tif (isSelf && meta.config.allowAccountDelete !== 1) {\n\t\tthrow new Error('[[error:account-deletion-disabled]]');\n\t} else if (!isSelf && !hasAdminPrivilege) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t} else if (isTargetAdmin) {\n\t\tthrow new Error('[[error:cant-delete-admin]');\n\t}\n\n\t// Privilege checks -- only deleteAccount is available for non-admins\n\tif (!hasAdminPrivilege && ['delete', 'deleteContent'].includes(method)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\t// Self-deletions require a password\n\tconst hasPassword = await user.hasPassword(uid);\n\tif (isSelf && hasPassword) {\n\t\tconst ok = await user.isPasswordCorrect(uid, password, caller.ip);\n\t\tif (!ok) {\n\t\t\tthrow new Error('[[error:invalid-password]]');\n\t\t}\n\t}\n\n\tawait flags.resolveFlag('user', uid, caller.uid);\n\n\tlet userData;\n\tif (method === 'deleteAccount') {\n\t\tuserData = await user[method](uid);\n\t} else {\n\t\tuserData = await user[method](caller.uid, uid);\n\t}\n\tuserData = userData || {};\n\n\tsockets.server.sockets.emit('event:user_status_change', { uid: caller.uid, status: 'offline' });\n\n\tplugins.hooks.fire('action:user.delete', {\n\t\tcallerUid: caller.uid,\n\t\tuid: uid,\n\t\tip: caller.ip,\n\t\tuser: userData,\n\t});\n\n\tawait events.log({\n\t\ttype: `user-${method}`,\n\t\tuid: caller.uid,\n\t\ttargetUid: uid,\n\t\tip: caller.ip,\n\t\tusername: userData.username,\n\t\temail: userData.email,\n\t});\n}\n\nasync function canDeleteUids(uids) {\n\tif (!Array.isArray(uids)) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\tconst isMembers = await groups.isMembers(uids, 'administrators');\n\tif (isMembers.includes(true)) {\n\t\tthrow new Error('[[error:cant-delete-other-admins]]');\n\t}\n\n\treturn true;\n}\n\nusersAPI.search = async function (caller, data) {\n\tif (!data) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\tconst [allowed, isPrivileged] = await Promise.all([\n\t\tprivileges.global.can('search:users', caller.uid),\n\t\tuser.isPrivileged(caller.uid),\n\t]);\n\tlet filters = data.filters || [];\n\tfilters = Array.isArray(filters) ? filters : [filters];\n\tif (!allowed ||\n\t\t((\n\t\t\tdata.searchBy === 'ip' ||\n\t\t\tdata.searchBy === 'email' ||\n\t\t\tfilters.includes('banned') ||\n\t\t\tfilters.includes('flagged')\n\t\t) && !isPrivileged)\n\t) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\treturn await user.search({\n\t\tquery: data.query,\n\t\tsearchBy: data.searchBy || 'username',\n\t\tpage: data.page || 1,\n\t\tsortBy: data.sortBy || 'lastonline',\n\t\tfilters: filters,\n\t});\n};\n\nusersAPI.changePicture = async (caller, data) => {\n\tif (!data) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst { type, url } = data;\n\tlet picture = '';\n\n\tawait user.checkMinReputation(caller.uid, data.uid, 'min:rep:profile-picture');\n\tconst canEdit = await privileges.users.canEdit(caller.uid, data.uid);\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tif (type === 'default') {\n\t\tpicture = '';\n\t} else if (type === 'uploaded') {\n\t\tpicture = await user.getUserField(data.uid, 'uploadedpicture');\n\t} else if (type === 'external' && url) {\n\t\tpicture = validator.escape(url);\n\t} else {\n\t\tconst returnData = await plugins.hooks.fire('filter:user.getPicture', {\n\t\t\tuid: caller.uid,\n\t\t\ttype: type,\n\t\t\tpicture: undefined,\n\t\t});\n\t\tpicture = returnData && returnData.picture;\n\t}\n\n\tconst validBackgrounds = await user.getIconBackgrounds(caller.uid);\n\tif (!validBackgrounds.includes(data.bgColor)) {\n\t\tdata.bgColor = validBackgrounds[0];\n\t}\n\n\tawait user.updateProfile(caller.uid, {\n\t\tuid: data.uid,\n\t\tpicture: picture,\n\t\t'icon:bgColor': data.bgColor,\n\t}, ['picture', 'icon:bgColor']);\n};\n\nusersAPI.generateExport = async (caller, { uid, type }) => {\n\tconst count = await db.incrObjectField('locks', `export:${uid}${type}`);\n\tif (count > 1) {\n\t\tthrow new Error('[[error:already-exporting]]');\n\t}\n\n\tconst child = require('child_process').fork(`./src/user/jobs/export-${type}.js`, [], {\n\t\tenv: process.env,\n\t});\n\tchild.send({ uid });\n\tchild.on('error', async (err) => {\n\t\twinston.error(err.stack);\n\t\tawait db.deleteObjectField('locks', `export:${uid}${type}`);\n\t});\n\tchild.on('exit', async () => {\n\t\tawait db.deleteObjectField('locks', `export:${uid}${type}`);\n\t\tconst userData = await user.getUserFields(uid, ['username', 'userslug']);\n\t\tconst { displayname } = userData;\n\t\tconst n = await notifications.create({\n\t\t\tbodyShort: `[[notifications:${type}-exported, ${displayname}]]`,\n\t\t\tpath: `/api/user/${userData.userslug}/export/${type}`,\n\t\t\tnid: `${type}:export:${uid}`,\n\t\t\tfrom: uid,\n\t\t});\n\t\tawait notifications.push(n, [caller.uid]);\n\t\tawait events.log({\n\t\t\ttype: `export:${type}`,\n\t\t\tuid: caller.uid,\n\t\t\ttargetUid: uid,\n\t\t\tip: caller.ip,\n\t\t});\n\t});\n};\n", "'use strict';\n\nconst user = require('../../user');\nconst privileges = require('../../privileges');\nconst plugins = require('../../plugins');\n\nconst sockets = require('..');\nconst api = require('../../api');\n\nmodule.exports = function (SocketUser) {\n\tSocketUser.updateCover = async function (socket, data) {\n\t\tif (!socket.uid) {\n\t\t\tthrow new Error('[[error:no-privileges]]');\n\t\t}\n\t\tawait user.isAdminOrGlobalModOrSelf(socket.uid, data.uid);\n\t\tawait user.checkMinReputation(socket.uid, data.uid, 'min:rep:cover-picture');\n\t\treturn await user.updateCoverPicture(data);\n\t};\n\n\tSocketUser.uploadCroppedPicture = async function (socket, data) {\n\t\tif (!socket.uid || !(await privileges.users.canEdit(socket.uid, data.uid))) {\n\t\t\tthrow new Error('[[error:no-privileges]]');\n\t\t}\n\n\t\tawait user.checkMinReputation(socket.uid, data.uid, 'min:rep:profile-picture');\n\t\tdata.callerUid = socket.uid;\n\t\treturn await user.uploadCroppedPicture(data);\n\t};\n\n\tSocketUser.removeCover = async function (socket, data) {\n\t\tif (!socket.uid) {\n\t\t\tthrow new Error('[[error:no-privileges]]');\n\t\t}\n\t\tawait user.isAdminOrGlobalModOrSelf(socket.uid, data.uid);\n\t\tconst userData = await user.getUserFields(data.uid, ['cover:url']);\n\t\t// 'keepAllUserImages' is ignored, since there is explicit user intent\n\t\tawait user.removeCoverPicture(data);\n\t\tplugins.hooks.fire('action:user.removeCoverPicture', {\n\t\t\tcallerUid: socket.uid,\n\t\t\tuid: data.uid,\n\t\t\tuser: userData,\n\t\t});\n\t};\n\n\tSocketUser.toggleBlock = async function (socket, data) {\n\t\tconst isBlocked = await user.blocks.is(data.blockeeUid, data.blockerUid);\n\t\tawait user.blocks.can(socket.uid, data.blockerUid, data.blockeeUid, isBlocked ? 'unblock' : 'block');\n\t\tawait user.blocks[isBlocked ? 'remove' : 'add'](data.blockeeUid, data.blockerUid);\n\t\treturn !isBlocked;\n\t};\n\n\tSocketUser.exportProfile = async function (socket, data) {\n\t\tawait doExport(socket, data, 'profile');\n\t};\n\n\tSocketUser.exportPosts = async function (socket, data) {\n\t\tawait doExport(socket, data, 'posts');\n\t};\n\n\tSocketUser.exportUploads = async function (socket, data) {\n\t\tawait doExport(socket, data, 'uploads');\n\t};\n\n\tasync function doExport(socket, data, type) {\n\t\tsockets.warnDeprecated(socket, 'POST /api/v3/users/:uid/exports/:type');\n\n\t\tif (!socket.uid) {\n\t\t\tthrow new Error('[[error:invalid-uid]]');\n\t\t}\n\n\t\tif (!data || parseInt(data.uid, 10) <= 0) {\n\t\t\tthrow new Error('[[error:invalid-data]]');\n\t\t}\n\n\t\tawait user.isAdminOrSelf(socket.uid, data.uid);\n\n\t\tapi.users.generateExport(socket, { type, ...data });\n\t}\n};\n"], "fixing_code": ["'use strict';\n\nconst validator = require('validator');\nconst winston = require('winston');\n\nconst db = require('../database');\nconst user = require('../user');\nconst groups = require('../groups');\nconst meta = require('../meta');\nconst flags = require('../flags');\nconst privileges = require('../privileges');\nconst notifications = require('../notifications');\nconst plugins = require('../plugins');\nconst events = require('../events');\nconst translator = require('../translator');\nconst sockets = require('../socket.io');\n\nconst usersAPI = module.exports;\n\nusersAPI.create = async function (caller, data) {\n\tif (!data) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\tconst uid = await user.create(data);\n\treturn await user.getUserData(uid);\n};\n\nusersAPI.update = async function (caller, data) {\n\tif (!caller.uid) {\n\t\tthrow new Error('[[error:invalid-uid]]');\n\t}\n\n\tif (!data || !data.uid) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst oldUserData = await user.getUserFields(data.uid, ['email', 'username']);\n\tif (!oldUserData || !oldUserData.username) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst [isAdminOrGlobalMod, canEdit] = await Promise.all([\n\t\tuser.isAdminOrGlobalMod(caller.uid),\n\t\tprivileges.users.canEdit(caller.uid, data.uid),\n\t]);\n\n\t// Changing own email/username requires password confirmation\n\tif (data.hasOwnProperty('email') || data.hasOwnProperty('username')) {\n\t\tawait isPrivilegedOrSelfAndPasswordMatch(caller, data);\n\t}\n\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tif (!isAdminOrGlobalMod && meta.config['username:disableEdit']) {\n\t\tdata.username = oldUserData.username;\n\t}\n\n\tif (!isAdminOrGlobalMod && meta.config['email:disableEdit']) {\n\t\tdata.email = oldUserData.email;\n\t}\n\n\tawait user.updateProfile(caller.uid, data);\n\tconst userData = await user.getUserData(data.uid);\n\n\tif (userData.username !== oldUserData.username) {\n\t\tawait events.log({\n\t\t\ttype: 'username-change',\n\t\t\tuid: caller.uid,\n\t\t\ttargetUid: data.uid,\n\t\t\tip: caller.ip,\n\t\t\toldUsername: oldUserData.username,\n\t\t\tnewUsername: userData.username,\n\t\t});\n\t}\n\treturn userData;\n};\n\nusersAPI.delete = async function (caller, { uid, password }) {\n\tawait processDeletion({ uid: uid, method: 'delete', password, caller });\n};\n\nusersAPI.deleteContent = async function (caller, { uid, password }) {\n\tawait processDeletion({ uid, method: 'deleteContent', password, caller });\n};\n\nusersAPI.deleteAccount = async function (caller, { uid, password }) {\n\tawait processDeletion({ uid, method: 'deleteAccount', password, caller });\n};\n\nusersAPI.deleteMany = async function (caller, data) {\n\tif (await canDeleteUids(data.uids)) {\n\t\tawait Promise.all(data.uids.map(uid => processDeletion({ uid, method: 'delete', caller })));\n\t}\n};\n\nusersAPI.updateSettings = async function (caller, data) {\n\tif (!caller.uid || !data || !data.settings) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst canEdit = await privileges.users.canEdit(caller.uid, data.uid);\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tlet defaults = await user.getSettings(0);\n\tdefaults = {\n\t\tpostsPerPage: defaults.postsPerPage,\n\t\ttopicsPerPage: defaults.topicsPerPage,\n\t\tuserLang: defaults.userLang,\n\t\tacpLang: defaults.acpLang,\n\t};\n\t// load raw settings without parsing values to booleans\n\tconst current = await db.getObject(`user:${data.uid}:settings`);\n\tconst payload = { ...defaults, ...current, ...data.settings };\n\tdelete payload.uid;\n\n\treturn await user.saveSettings(data.uid, payload);\n};\n\nusersAPI.changePassword = async function (caller, data) {\n\tawait user.changePassword(caller.uid, Object.assign(data, { ip: caller.ip }));\n\tawait events.log({\n\t\ttype: 'password-change',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t});\n};\n\nusersAPI.follow = async function (caller, data) {\n\tawait user.follow(caller.uid, data.uid);\n\tplugins.hooks.fire('action:user.follow', {\n\t\tfromUid: caller.uid,\n\t\ttoUid: data.uid,\n\t});\n\n\tconst userData = await user.getUserFields(caller.uid, ['username', 'userslug']);\n\tconst { displayname } = userData;\n\n\tconst notifObj = await notifications.create({\n\t\ttype: 'follow',\n\t\tbodyShort: `[[notifications:user_started_following_you, ${displayname}]]`,\n\t\tnid: `follow:${data.uid}:uid:${caller.uid}`,\n\t\tfrom: caller.uid,\n\t\tpath: `/uid/${data.uid}/followers`,\n\t\tmergeId: 'notifications:user_started_following_you',\n\t});\n\tif (!notifObj) {\n\t\treturn;\n\t}\n\tnotifObj.user = userData;\n\tawait notifications.push(notifObj, [data.uid]);\n};\n\nusersAPI.unfollow = async function (caller, data) {\n\tawait user.unfollow(caller.uid, data.uid);\n\tplugins.hooks.fire('action:user.unfollow', {\n\t\tfromUid: caller.uid,\n\t\ttoUid: data.uid,\n\t});\n};\n\nusersAPI.ban = async function (caller, data) {\n\tif (!await privileges.users.hasBanPrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t} else if (await user.isAdministrator(data.uid)) {\n\t\tthrow new Error('[[error:cant-ban-other-admins]]');\n\t}\n\n\tconst banData = await user.bans.ban(data.uid, data.until, data.reason);\n\tawait db.setObjectField(`uid:${data.uid}:ban:${banData.timestamp}`, 'fromUid', caller.uid);\n\n\tif (!data.reason) {\n\t\tdata.reason = await translator.translate('[[user:info.banned-no-reason]]');\n\t}\n\n\tsockets.in(`uid_${data.uid}`).emit('event:banned', {\n\t\tuntil: data.until,\n\t\treason: validator.escape(String(data.reason || '')),\n\t});\n\n\tawait flags.resolveFlag('user', data.uid, caller.uid);\n\tawait flags.resolveUserPostFlags(data.uid, caller.uid);\n\tawait events.log({\n\t\ttype: 'user-ban',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t\treason: data.reason || undefined,\n\t});\n\tplugins.hooks.fire('action:user.banned', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t\tuntil: data.until > 0 ? data.until : undefined,\n\t\treason: data.reason || undefined,\n\t});\n\tconst canLoginIfBanned = await user.bans.canLoginIfBanned(data.uid);\n\tif (!canLoginIfBanned) {\n\t\tawait user.auth.revokeAllSessions(data.uid);\n\t}\n};\n\nusersAPI.unban = async function (caller, data) {\n\tif (!await privileges.users.hasBanPrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tawait user.bans.unban(data.uid);\n\n\tsockets.in(`uid_${data.uid}`).emit('event:unbanned');\n\n\tawait events.log({\n\t\ttype: 'user-unban',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t});\n\tplugins.hooks.fire('action:user.unbanned', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t});\n};\n\nusersAPI.mute = async function (caller, data) {\n\tif (!await privileges.users.hasMutePrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t} else if (await user.isAdministrator(data.uid)) {\n\t\tthrow new Error('[[error:cant-mute-other-admins]]');\n\t}\n\tconst reason = data.reason || '[[user:info.muted-no-reason]]';\n\tawait db.setObject(`user:${data.uid}`, {\n\t\tmutedUntil: data.until,\n\t\tmutedReason: reason,\n\t});\n\tconst now = Date.now();\n\tconst muteKey = `uid:${data.uid}:mute:${now}`;\n\tconst muteData = {\n\t\tfromUid: caller.uid,\n\t\tuid: data.uid,\n\t\ttimestamp: now,\n\t\texpire: data.until,\n\t};\n\tif (data.reason) {\n\t\tmuteData.reason = reason;\n\t}\n\tawait db.sortedSetAdd(`uid:${data.uid}:mutes:timestamp`, now, muteKey);\n\tawait db.setObject(muteKey, muteData);\n\tawait events.log({\n\t\ttype: 'user-mute',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t\treason: data.reason || undefined,\n\t});\n\tplugins.hooks.fire('action:user.muted', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t\tuntil: data.until > 0 ? data.until : undefined,\n\t\treason: data.reason || undefined,\n\t});\n};\n\nusersAPI.unmute = async function (caller, data) {\n\tif (!await privileges.users.hasMutePrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tawait db.deleteObjectFields(`user:${data.uid}`, ['mutedUntil', 'mutedReason']);\n\n\tawait events.log({\n\t\ttype: 'user-unmute',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t});\n\tplugins.hooks.fire('action:user.unmuted', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t});\n};\n\nasync function isPrivilegedOrSelfAndPasswordMatch(caller, data) {\n\tconst { uid } = caller;\n\tconst isSelf = parseInt(uid, 10) === parseInt(data.uid, 10);\n\tconst canEdit = await privileges.users.canEdit(uid, data.uid);\n\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\tconst [hasPassword, passwordMatch] = await Promise.all([\n\t\tuser.hasPassword(data.uid),\n\t\tdata.password ? user.isPasswordCorrect(data.uid, data.password, caller.ip) : false,\n\t]);\n\n\tif (isSelf && hasPassword && !passwordMatch) {\n\t\tthrow new Error('[[error:invalid-password]]');\n\t}\n}\n\nasync function processDeletion({ uid, method, password, caller }) {\n\tconst isTargetAdmin = await user.isAdministrator(uid);\n\tconst isSelf = parseInt(uid, 10) === parseInt(caller.uid, 10);\n\tconst hasAdminPrivilege = await privileges.admin.can('admin:users', caller.uid);\n\n\tif (isSelf && meta.config.allowAccountDelete !== 1) {\n\t\tthrow new Error('[[error:account-deletion-disabled]]');\n\t} else if (!isSelf && !hasAdminPrivilege) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t} else if (isTargetAdmin) {\n\t\tthrow new Error('[[error:cant-delete-admin]');\n\t}\n\n\t// Privilege checks -- only deleteAccount is available for non-admins\n\tif (!hasAdminPrivilege && ['delete', 'deleteContent'].includes(method)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\t// Self-deletions require a password\n\tconst hasPassword = await user.hasPassword(uid);\n\tif (isSelf && hasPassword) {\n\t\tconst ok = await user.isPasswordCorrect(uid, password, caller.ip);\n\t\tif (!ok) {\n\t\t\tthrow new Error('[[error:invalid-password]]');\n\t\t}\n\t}\n\n\tawait flags.resolveFlag('user', uid, caller.uid);\n\n\tlet userData;\n\tif (method === 'deleteAccount') {\n\t\tuserData = await user[method](uid);\n\t} else {\n\t\tuserData = await user[method](caller.uid, uid);\n\t}\n\tuserData = userData || {};\n\n\tsockets.server.sockets.emit('event:user_status_change', { uid: caller.uid, status: 'offline' });\n\n\tplugins.hooks.fire('action:user.delete', {\n\t\tcallerUid: caller.uid,\n\t\tuid: uid,\n\t\tip: caller.ip,\n\t\tuser: userData,\n\t});\n\n\tawait events.log({\n\t\ttype: `user-${method}`,\n\t\tuid: caller.uid,\n\t\ttargetUid: uid,\n\t\tip: caller.ip,\n\t\tusername: userData.username,\n\t\temail: userData.email,\n\t});\n}\n\nasync function canDeleteUids(uids) {\n\tif (!Array.isArray(uids)) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\tconst isMembers = await groups.isMembers(uids, 'administrators');\n\tif (isMembers.includes(true)) {\n\t\tthrow new Error('[[error:cant-delete-other-admins]]');\n\t}\n\n\treturn true;\n}\n\nusersAPI.search = async function (caller, data) {\n\tif (!data) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\tconst [allowed, isPrivileged] = await Promise.all([\n\t\tprivileges.global.can('search:users', caller.uid),\n\t\tuser.isPrivileged(caller.uid),\n\t]);\n\tlet filters = data.filters || [];\n\tfilters = Array.isArray(filters) ? filters : [filters];\n\tif (!allowed ||\n\t\t((\n\t\t\tdata.searchBy === 'ip' ||\n\t\t\tdata.searchBy === 'email' ||\n\t\t\tfilters.includes('banned') ||\n\t\t\tfilters.includes('flagged')\n\t\t) && !isPrivileged)\n\t) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\treturn await user.search({\n\t\tquery: data.query,\n\t\tsearchBy: data.searchBy || 'username',\n\t\tpage: data.page || 1,\n\t\tsortBy: data.sortBy || 'lastonline',\n\t\tfilters: filters,\n\t});\n};\n\nusersAPI.changePicture = async (caller, data) => {\n\tif (!data) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst { type, url } = data;\n\tlet picture = '';\n\n\tawait user.checkMinReputation(caller.uid, data.uid, 'min:rep:profile-picture');\n\tconst canEdit = await privileges.users.canEdit(caller.uid, data.uid);\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tif (type === 'default') {\n\t\tpicture = '';\n\t} else if (type === 'uploaded') {\n\t\tpicture = await user.getUserField(data.uid, 'uploadedpicture');\n\t} else if (type === 'external' && url) {\n\t\tpicture = validator.escape(url);\n\t} else {\n\t\tconst returnData = await plugins.hooks.fire('filter:user.getPicture', {\n\t\t\tuid: caller.uid,\n\t\t\ttype: type,\n\t\t\tpicture: undefined,\n\t\t});\n\t\tpicture = returnData && returnData.picture;\n\t}\n\n\tconst validBackgrounds = await user.getIconBackgrounds(caller.uid);\n\tif (!validBackgrounds.includes(data.bgColor)) {\n\t\tdata.bgColor = validBackgrounds[0];\n\t}\n\n\tawait user.updateProfile(caller.uid, {\n\t\tuid: data.uid,\n\t\tpicture: picture,\n\t\t'icon:bgColor': data.bgColor,\n\t}, ['picture', 'icon:bgColor']);\n};\n\nusersAPI.generateExport = async (caller, { uid, type }) => {\n\tconst validTypes = ['profile', 'posts', 'uploads'];\n\tif (!validTypes.includes(type)) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\tconst count = await db.incrObjectField('locks', `export:${uid}${type}`);\n\tif (count > 1) {\n\t\tthrow new Error('[[error:already-exporting]]');\n\t}\n\n\tconst child = require('child_process').fork(`./src/user/jobs/export-${type}.js`, [], {\n\t\tenv: process.env,\n\t});\n\tchild.send({ uid });\n\tchild.on('error', async (err) => {\n\t\twinston.error(err.stack);\n\t\tawait db.deleteObjectField('locks', `export:${uid}${type}`);\n\t});\n\tchild.on('exit', async () => {\n\t\tawait db.deleteObjectField('locks', `export:${uid}${type}`);\n\t\tconst userData = await user.getUserFields(uid, ['username', 'userslug']);\n\t\tconst { displayname } = userData;\n\t\tconst n = await notifications.create({\n\t\t\tbodyShort: `[[notifications:${type}-exported, ${displayname}]]`,\n\t\t\tpath: `/api/user/${userData.userslug}/export/${type}`,\n\t\t\tnid: `${type}:export:${uid}`,\n\t\t\tfrom: uid,\n\t\t});\n\t\tawait notifications.push(n, [caller.uid]);\n\t\tawait events.log({\n\t\t\ttype: `export:${type}`,\n\t\t\tuid: caller.uid,\n\t\t\ttargetUid: uid,\n\t\t\tip: caller.ip,\n\t\t});\n\t});\n};\n", "'use strict';\n\nconst user = require('../../user');\nconst privileges = require('../../privileges');\nconst plugins = require('../../plugins');\n\nconst sockets = require('..');\nconst api = require('../../api');\n\nmodule.exports = function (SocketUser) {\n\tSocketUser.updateCover = async function (socket, data) {\n\t\tif (!socket.uid) {\n\t\t\tthrow new Error('[[error:no-privileges]]');\n\t\t}\n\t\tawait user.isAdminOrGlobalModOrSelf(socket.uid, data.uid);\n\t\tawait user.checkMinReputation(socket.uid, data.uid, 'min:rep:cover-picture');\n\t\treturn await user.updateCoverPicture(data);\n\t};\n\n\tSocketUser.uploadCroppedPicture = async function (socket, data) {\n\t\tif (!socket.uid || !(await privileges.users.canEdit(socket.uid, data.uid))) {\n\t\t\tthrow new Error('[[error:no-privileges]]');\n\t\t}\n\n\t\tawait user.checkMinReputation(socket.uid, data.uid, 'min:rep:profile-picture');\n\t\tdata.callerUid = socket.uid;\n\t\treturn await user.uploadCroppedPicture(data);\n\t};\n\n\tSocketUser.removeCover = async function (socket, data) {\n\t\tif (!socket.uid) {\n\t\t\tthrow new Error('[[error:no-privileges]]');\n\t\t}\n\t\tawait user.isAdminOrGlobalModOrSelf(socket.uid, data.uid);\n\t\tconst userData = await user.getUserFields(data.uid, ['cover:url']);\n\t\t// 'keepAllUserImages' is ignored, since there is explicit user intent\n\t\tawait user.removeCoverPicture(data);\n\t\tplugins.hooks.fire('action:user.removeCoverPicture', {\n\t\t\tcallerUid: socket.uid,\n\t\t\tuid: data.uid,\n\t\t\tuser: userData,\n\t\t});\n\t};\n\n\tSocketUser.toggleBlock = async function (socket, data) {\n\t\tconst isBlocked = await user.blocks.is(data.blockeeUid, data.blockerUid);\n\t\tawait user.blocks.can(socket.uid, data.blockerUid, data.blockeeUid, isBlocked ? 'unblock' : 'block');\n\t\tawait user.blocks[isBlocked ? 'remove' : 'add'](data.blockeeUid, data.blockerUid);\n\t\treturn !isBlocked;\n\t};\n\n\tSocketUser.exportProfile = async function (socket, data) {\n\t\tawait doExport(socket, data, 'profile');\n\t};\n\n\tSocketUser.exportPosts = async function (socket, data) {\n\t\tawait doExport(socket, data, 'posts');\n\t};\n\n\tSocketUser.exportUploads = async function (socket, data) {\n\t\tawait doExport(socket, data, 'uploads');\n\t};\n\n\tasync function doExport(socket, data, type) {\n\t\tsockets.warnDeprecated(socket, 'POST /api/v3/users/:uid/exports/:type');\n\n\t\tif (!socket.uid) {\n\t\t\tthrow new Error('[[error:invalid-uid]]');\n\t\t}\n\n\t\tif (!data || parseInt(data.uid, 10) <= 0) {\n\t\t\tthrow new Error('[[error:invalid-data]]');\n\t\t}\n\n\t\tawait user.isAdminOrSelf(socket.uid, data.uid);\n\n\t\tapi.users.generateExport(socket, { type, uid: data.uid });\n\t}\n};\n"], "filenames": ["src/api/users.js", "src/socket.io/user/profile.js"], "buggy_code_start_loc": [445, 77], "buggy_code_end_loc": [445, 78], "fixing_code_start_loc": [446, 77], "fixing_code_end_loc": [450, 78], "type": "CWE-22", "message": "NodeBB is Node.js based forum software. Starting in version 2.5.0 and prior to version 2.8.7, due to the use of the object destructuring assignment syntax in the user export code path, combined with a path traversal vulnerability, a specially crafted payload could invoke the user export logic to arbitrarily execute javascript files on the local disk. This issue is patched in version 2.8.7. As a workaround, site maintainers can cherry pick the fix into their codebase to patch the exploit.", "other": {"cve": {"id": "CVE-2023-26045", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-24T22:15:10.033", "lastModified": "2023-08-31T19:15:08.797", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "NodeBB is Node.js based forum software. Starting in version 2.5.0 and prior to version 2.8.7, due to the use of the object destructuring assignment syntax in the user export code path, combined with a path traversal vulnerability, a specially crafted payload could invoke the user export logic to arbitrarily execute javascript files on the local disk. This issue is patched in version 2.8.7. As a workaround, site maintainers can cherry pick the fix into their codebase to patch the exploit."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodebb:nodebb:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "2.5.0", "versionEndExcluding": "2.8.7", "matchCriteriaId": "1227286D-9A80-4D3B-AC16-D52EE964A13E"}]}]}], "references": [{"url": "https://github.com/NodeBB/NodeBB/commit/ec58700f6dff8e5b4af1544f6205ec362b593092", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/NodeBB/NodeBB/security/advisories/GHSA-vh2g-6c4x-5hmp", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230831-0004/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/NodeBB/NodeBB/commit/ec58700f6dff8e5b4af1544f6205ec362b593092"}}