{"buggy_code": ["# frozen_string_literal: true\nmodule Excon\n  class Connection\n    include Utils\n\n    attr_reader :data\n\n    def connection\n      Excon.display_warning('Excon::Connection#connection is deprecated use Excon::Connection#data instead.')\n      @data\n    end\n    def connection=(new_params)\n      Excon.display_warning('Excon::Connection#connection= is deprecated. Use of this method may cause unexpected results.')\n      @data = new_params\n    end\n\n    def params\n      Excon.display_warning('Excon::Connection#params is deprecated use Excon::Connection#data instead.')\n      @data\n    end\n    def params=(new_params)\n      Excon.display_warning('Excon::Connection#params= is deprecated. Use of this method may cause unexpected results.')\n      @data = new_params\n    end\n\n    def proxy\n      Excon.display_warning('Excon::Connection#proxy is deprecated use Excon::Connection#data[:proxy] instead.')\n      @data[:proxy]\n    end\n    def proxy=(new_proxy)\n      Excon.display_warning('Excon::Connection#proxy= is deprecated. Use of this method may cause unexpected results.')\n      @data[:proxy] = new_proxy\n    end\n\n    def logger\n      if @data[:instrumentor] && @data[:instrumentor].respond_to?(:logger)\n        @data[:instrumentor].logger\n      end\n    end\n    def logger=(logger)\n      @data[:instrumentor] = Excon::LoggingInstrumentor\n      @data[:logger] = logger\n    end\n\n    # Initializes a new Connection instance\n    # @param [Hash<Symbol, >] params One or more optional params\n    # @option params [String] :body Default text to be sent over a socket. Only used if :body absent in Connection#request params\n    # @option params [Hash<Symbol, String>] :headers The default headers to supply in a request. Only used if params[:headers] is not supplied to Connection#request\n    # @option params [String] :host The destination host's reachable DNS name or IP, in the form of a String. IPv6 addresses must be wrapped (e.g. [::1]).  See URI#host.\n    # @option params [String] :hostname Same as host, but usable for socket connections. IPv6 addresses must not be wrapped (e.g. ::1).  See URI#hostname.\n    # @option params [String] :path Default path; appears after 'scheme://host:port/'. Only used if params[:path] is not supplied to Connection#request\n    # @option params [Fixnum] :port The port on which to connect, to the destination host\n    # @option params [Hash]   :query Default query; appended to the 'scheme://host:port/path/' in the form of '?key=value'. Will only be used if params[:query] is not supplied to Connection#request\n    # @option params [String] :scheme The protocol; 'https' causes OpenSSL to be used\n    # @option params [String] :socket The path to the unix socket (required for 'unix://' connections)\n    # @option params [String] :ciphers Only use the specified SSL/TLS cipher suites; use OpenSSL cipher spec format e.g. 'HIGH:!aNULL:!3DES' or 'AES256-SHA:DES-CBC3-SHA'\n    # @option params [String] :proxy Proxy server; e.g. 'http://myproxy.com:8888'\n    # @option params [Fixnum] :retry_limit Set how many times we'll retry a failed request.  (Default 4)\n    # @option params [Fixnum] :retry_interval Set how long to wait between retries. (Default 0)\n    # @option params [Class] :instrumentor Responds to #instrument as in ActiveSupport::Notifications\n    # @option params [String] :instrumentor_name Name prefix for #instrument events.  Defaults to 'excon'\n    def initialize(params = {})\n      @data = Excon.defaults.dup\n      # merge does not deep-dup, so make sure headers is not the original\n      @data[:headers] = @data[:headers].dup\n\n      # the same goes for :middlewares\n      @data[:middlewares] = @data[:middlewares].dup\n\n      @data.merge!(params)\n      validate_params(:connection, @data, @data[:middlewares])\n\n      if @data.key?(:host) && !@data.key?(:hostname)\n        Excon.display_warning('hostname is missing! For IPv6 support, provide both host and hostname: Excon::Connection#new(:host => uri.host, :hostname => uri.hostname, ...).')\n        @data[:hostname] = @data[:host]\n      end\n\n      setup_proxy\n\n      if  ENV.has_key?('EXCON_STANDARD_INSTRUMENTOR')\n        @data[:instrumentor] = Excon::StandardInstrumentor\n      end\n\n      if @data[:debug] || ENV.has_key?('EXCON_DEBUG')\n        @data[:debug_request] = @data[:debug_response] = true\n        @data[:instrumentor] = Excon::StandardInstrumentor\n      end\n\n      if @data[:scheme] == UNIX\n        if @data[:host]\n          raise ArgumentError, \"The `:host` parameter should not be set for `unix://` connections.\\n\" +\n                               \"When supplying a `unix://` URI, it should start with `unix:/` or `unix:///`.\"\n        elsif !@data[:socket]\n          raise ArgumentError, 'You must provide a `:socket` for `unix://` connections'\n        else\n          @socket_key = \"#{@data[:scheme]}://#{@data[:socket]}\"\n        end\n      else\n        @socket_key = \"#{@data[:scheme]}://#{@data[:host]}#{port_string(@data)}\"\n      end\n      reset\n    end\n\n    def error_call(datum)\n      if datum[:error]\n        raise(datum[:error])\n      end\n    end\n\n    def request_call(datum)\n      begin\n        if datum.has_key?(:response)\n          # we already have data from a middleware, so bail\n          return datum\n        else\n          socket.data = datum\n          # start with \"METHOD /path\"\n          request = datum[:method].to_s.upcase + ' '\n          if datum[:proxy] && datum[:scheme] != HTTPS\n            request << datum[:scheme] << '://' << datum[:host] << port_string(datum)\n          end\n          request << datum[:path]\n\n          # add query to path, if there is one\n          request << query_string(datum)\n\n          # finish first line with \"HTTP/1.1\\r\\n\"\n          request << HTTP_1_1\n\n          if datum.has_key?(:request_block)\n            datum[:headers]['Transfer-Encoding'] = 'chunked'\n          else\n            body = datum[:body].is_a?(String) ? StringIO.new(datum[:body]) : datum[:body]\n\n            # The HTTP spec isn't clear on it, but specifically, GET requests don't usually send bodies;\n            # if they don't, sending Content-Length:0 can cause issues.\n            unless datum[:method].to_s.casecmp('GET') == 0 && body.nil?\n              unless datum[:headers].has_key?('Content-Length')\n                datum[:headers]['Content-Length'] = detect_content_length(body)\n              end\n            end\n          end\n\n          # add headers to request\n          datum[:headers].each do |key, values|\n            if key.to_s.match(/[\\r\\n]/)\n              raise Excon::Errors::InvalidHeaderKey.new(key.to_s.inspect + ' contains forbidden \"\\r\" or \"\\n\"')\n            end\n            [values].flatten.each do |value|\n              if value.to_s.match(/[\\r\\n]/)\n                raise Excon::Errors::InvalidHeaderValue.new(value.to_s.inspect + ' contains forbidden \"\\r\" or \"\\n\"')\n              end\n              request << key.to_s << ': ' << value.to_s << CR_NL\n            end\n          end\n\n          # add additional \"\\r\\n\" to indicate end of headers\n          request << CR_NL\n\n          if datum.has_key?(:request_block)\n            socket.write(request) # write out request + headers\n            while true # write out body with chunked encoding\n              chunk = datum[:request_block].call\n              binary_encode(chunk)\n              if chunk.length > 0\n                socket.write(chunk.length.to_s(16) << CR_NL << chunk << CR_NL)\n              else\n                socket.write(String.new(\"0#{CR_NL}#{CR_NL}\"))\n                break\n              end\n            end\n          elsif body.nil?\n            socket.write(request) # write out request + headers\n          else # write out body\n            if body.respond_to?(:binmode) && !body.is_a?(StringIO)\n              body.binmode\n            end\n            if body.respond_to?(:rewind)\n              body.rewind  rescue nil\n            end\n\n            # if request + headers is less than chunk size, fill with body\n            binary_encode(request)\n            chunk = body.read([datum[:chunk_size] - request.length, 0].max)\n            if chunk\n              binary_encode(chunk)\n              socket.write(request << chunk)\n            else\n              socket.write(request) # write out request + headers\n            end\n\n            while chunk = body.read(datum[:chunk_size])\n              socket.write(chunk)\n            end\n          end\n        end\n      rescue => error\n        case error\n        when Excon::Errors::InvalidHeaderKey, Excon::Errors::InvalidHeaderValue, Excon::Errors::StubNotFound, Excon::Errors::Timeout\n          raise(error)\n        else\n          raise_socket_error(error)\n        end\n      end\n\n      datum\n    end\n\n    def response_call(datum)\n      # ensure response_block is yielded to and body is empty from middlewares\n      if datum.has_key?(:response_block) && !(datum[:response][:body].nil? || datum[:response][:body].empty?)\n        response_body = datum[:response][:body].dup\n        datum[:response][:body] = ''\n        content_length = remaining = response_body.bytesize\n        while remaining > 0\n          datum[:response_block].call(response_body.slice!(0, [datum[:chunk_size], remaining].min), [remaining - datum[:chunk_size], 0].max, content_length)\n          remaining -= datum[:chunk_size]\n        end\n      end\n      datum\n    end\n\n    # Sends the supplied request to the destination host.\n    # @yield [chunk] @see Response#self.parse\n    # @param [Hash<Symbol, >] params One or more optional params, override defaults set in Connection.new\n    # @option params [String] :body text to be sent over a socket\n    # @option params [Hash<Symbol, String>] :headers The default headers to supply in a request\n    # @option params [String] :path appears after 'scheme://host:port/'\n    # @option params [Hash]   :query appended to the 'scheme://host:port/path/' in the form of '?key=value'\n    def request(params={}, &block)\n      # @data has defaults, merge in new params to override\n      datum = @data.merge(params)\n      datum[:headers] = @data[:headers].merge(datum[:headers] || {})\n\n      validate_params(:request, params, datum[:middlewares])\n      # If the user passed in new middleware, we want to validate that the original connection parameters\n      # are still valid with the provided middleware.\n      if params[:middlewares]\n        validate_params(:connection, @data, datum[:middlewares])\n      end\n\n      if datum[:user] || datum[:password]\n        user, pass = Utils.unescape_uri(datum[:user].to_s), Utils.unescape_uri(datum[:password].to_s)\n        datum[:headers]['Authorization'] ||= 'Basic ' + [\"#{user}:#{pass}\"].pack('m').delete(Excon::CR_NL)\n      end\n\n      if datum[:scheme] == UNIX\n        datum[:headers]['Host']   ||= ''\n      else\n        datum[:headers]['Host']   ||= datum[:host] + port_string(datum)\n      end\n\n      # if path is empty or doesn't start with '/', insert one\n      unless datum[:path][0, 1] == '/'\n        datum[:path] = datum[:path].dup.insert(0, '/')\n      end\n\n      if block_given?\n        Excon.display_warning('Excon requests with a block are deprecated, pass :response_block instead.')\n        datum[:response_block] = block\n      end\n\n      datum[:connection] = self\n\n      datum[:stack] = datum[:middlewares].map do |middleware|\n        lambda {|stack| middleware.new(stack)}\n      end.reverse.inject(self) do |middlewares, middleware|\n        middleware.call(middlewares)\n      end\n      datum = datum[:stack].request_call(datum)\n\n      unless datum[:pipeline]\n        datum = response(datum)\n\n        if datum[:persistent]\n          if key = datum[:response][:headers].keys.detect {|k| k.casecmp('Connection') == 0 }\n            if datum[:response][:headers][key].casecmp('close') == 0\n              reset\n            end\n          end\n        else\n          reset\n        end\n\n        Excon::Response.new(datum[:response])\n      else\n        datum\n      end\n    rescue => error\n      reset\n\n      # If we didn't get far enough to initialize datum and the middleware stack, just raise\n      raise error if !datum\n\n      datum[:error] = error\n      if datum[:stack]\n        datum[:stack].error_call(datum)\n      else\n        raise error\n      end\n    end\n\n    # Sends the supplied requests to the destination host using pipelining.\n    # @param pipeline_params [Array<Hash>] An array of one or more optional params, override defaults set in Connection.new, see #request for details\n    def requests(pipeline_params)\n      pipeline_params.each {|params| params.merge!(:pipeline => true, :persistent => true) }\n      pipeline_params.last.merge!(:persistent => @data[:persistent])\n\n      responses = pipeline_params.map do |params|\n        request(params)\n      end.map do |datum|\n        Excon::Response.new(response(datum)[:response])\n      end\n\n      if @data[:persistent]\n        if key = responses.last[:headers].keys.detect {|k| k.casecmp('Connection') == 0 }\n          if responses.last[:headers][key].casecmp('close') == 0\n            reset\n          end\n        end\n      else\n        reset\n      end\n\n      responses\n    end\n\n    # Sends the supplied requests to the destination host using pipelining in\n    # batches of @limit [Numeric] requests. This is your soft file descriptor\n    # limit by default, typically 256.\n    # @param pipeline_params [Array<Hash>] An array of one or more optional params, override defaults set in Connection.new, see #request for details\n    def batch_requests(pipeline_params, limit = nil)\n      limit ||= Process.respond_to?(:getrlimit) ? Process.getrlimit(:NOFILE).first : 256\n      responses = []\n\n      pipeline_params.each_slice(limit) do |params|\n        responses.concat(requests(params))\n      end\n\n      responses\n    end\n\n    def reset\n      if old_socket = sockets.delete(@socket_key)\n        old_socket.close rescue nil\n      end\n    end\n\n    # Generate HTTP request verb methods\n    Excon::HTTP_VERBS.each do |method|\n      class_eval <<-DEF, __FILE__, __LINE__ + 1\n        def #{method}(params={}, &block)\n          request(params.merge!(:method => :#{method}), &block)\n        end\n      DEF\n    end\n\n    def retry_limit=(new_retry_limit)\n      Excon.display_warning('Excon::Connection#retry_limit= is deprecated, pass :retry_limit to the initializer.')\n      @data[:retry_limit] = new_retry_limit\n    end\n\n    def retry_limit\n      Excon.display_warning('Excon::Connection#retry_limit is deprecated, use Excon::Connection#data[:retry_limit].')\n      @data[:retry_limit] ||= DEFAULT_RETRY_LIMIT\n    end\n\n    def inspect\n      vars = instance_variables.inject({}) do |accum, var|\n        accum.merge!(var.to_sym => instance_variable_get(var))\n      end\n      vars[:'@data'] = Utils.redact(vars[:'@data'])\n      inspection = '#<Excon::Connection:'\n      inspection += (object_id << 1).to_s(16)\n      vars.each do |key, value|\n        inspection += \" #{key}=#{value.inspect}\"\n      end\n      inspection += '>'\n      inspection\n    end\n\n    def valid_request_keys(middlewares)\n      valid_middleware_keys(middlewares) + Excon::VALID_REQUEST_KEYS\n    end\n\n    private\n\n    def detect_content_length(body)\n      if body.respond_to?(:size)\n        # IO object: File, Tempfile, StringIO, etc.\n        body.size\n      elsif body.respond_to?(:stat)\n        # for 1.8.7 where file does not have size\n        body.stat.size\n      else\n        0\n      end\n    end\n\n    def valid_middleware_keys(middlewares)\n      middlewares.flat_map do |middleware|\n        if middleware.respond_to?(:valid_parameter_keys)\n          middleware.valid_parameter_keys\n        else\n          Excon.display_warning(\n            \"Excon middleware #{middleware} does not define #valid_parameter_keys\"\n          )\n          []\n        end\n      end\n    end\n\n    def validate_params(validation, params, middlewares)\n      valid_keys = case validation\n      when :connection\n        valid_middleware_keys(middlewares) + Excon::VALID_CONNECTION_KEYS\n      when :request\n        valid_request_keys(middlewares)\n      else\n        raise ArgumentError.new(\"Invalid validation type '#{validation}'\")\n      end\n\n      invalid_keys = params.keys - valid_keys\n      unless invalid_keys.empty?\n        Excon.display_warning(\"Invalid Excon #{validation} keys: #{invalid_keys.map(&:inspect).join(', ')}\")\n\n        if validation == :request\n          deprecated_keys = invalid_keys & Excon::DEPRECATED_VALID_REQUEST_KEYS.keys\n          mw_msg = deprecated_keys.map do |k|\n            \"#{k}: #{Excon::DEPRECATED_VALID_REQUEST_KEYS[k]}\"\n          end.join(', ')\n          Excon.display_warning(\n            \"The following request keys are only valid with the associated middleware: #{mw_msg}\"\n          )\n        end\n      end\n    end\n\n    def response(datum={})\n      datum[:stack].response_call(datum)\n    rescue => error\n      case error\n      when Excon::Errors::HTTPStatusError, Excon::Errors::Timeout, Excon::Errors::TooManyRedirects\n        raise(error)\n      else\n        raise_socket_error(error)\n      end\n    end\n\n    def socket\n      unix_proxy = @data[:proxy] ? @data[:proxy][:scheme] == UNIX : false\n      sockets[@socket_key] ||= if @data[:scheme] == UNIX || unix_proxy\n        Excon::UnixSocket.new(@data)\n      elsif @data[:ssl_uri_schemes].include?(@data[:scheme])\n        Excon::SSLSocket.new(@data)\n      else\n        Excon::Socket.new(@data)\n      end\n    end\n\n    def sockets\n      @_excon_sockets ||= {}\n\n      if @data[:thread_safe_sockets]\n        # In a multi-threaded world, if the same connection is used by multiple\n        # threads at the same time to connect to the same destination, they may\n        # stomp on each other's sockets.  This ensures every thread gets their\n        # own socket cache, within the context of a single connection.\n        @_excon_sockets[Thread.current.object_id] ||= {}\n      else\n        @_excon_sockets\n      end\n    end\n\n    def raise_socket_error(error)\n      if error.message =~ /certificate verify failed/\n        raise(Excon::Errors::CertificateError.new(error))\n      else\n        raise(Excon::Errors::SocketError.new(error))\n      end\n    end\n\n    def setup_proxy\n      if @data[:disable_proxy]\n        if @data[:proxy]\n          raise ArgumentError, \"`:disable_proxy` parameter and `:proxy` parameter cannot both be set at the same time.\"\n        end\n        return\n      end\n\n      unless @data[:scheme] == UNIX\n        if no_proxy_env = ENV[\"no_proxy\"] || ENV[\"NO_PROXY\"]\n          no_proxy_list = no_proxy_env.scan(/\\*?\\.?([^\\s,:]+)(?::(\\d+))?/i).map { |s| [s[0], s[1]] }\n        end\n\n        unless no_proxy_env && no_proxy_list.index { |h| /(^|\\.)#{h[0]}$/.match(@data[:host]) && (h[1].nil? || h[1].to_i == @data[:port]) }\n          if @data[:scheme] == HTTPS && (ENV.has_key?('https_proxy') || ENV.has_key?('HTTPS_PROXY'))\n            @data[:proxy] = ENV['https_proxy'] || ENV['HTTPS_PROXY']\n          elsif (ENV.has_key?('http_proxy') || ENV.has_key?('HTTP_PROXY'))\n            @data[:proxy] = ENV['http_proxy'] || ENV['HTTP_PROXY']\n          end\n        end\n\n        case @data[:proxy]\n        when nil\n          @data.delete(:proxy)\n        when ''\n          @data.delete(:proxy)\n        when Hash\n          # no processing needed\n        when String, URI\n          uri = @data[:proxy].is_a?(String) ? URI.parse(@data[:proxy]) : @data[:proxy]\n          @data[:proxy] = {\n            :host       => uri.host,\n            :hostname   => uri.hostname,\n            # path is only sensible for a Unix socket proxy\n            :path       => uri.scheme == UNIX ? uri.path : nil,\n            :port       => uri.port,\n            :scheme     => uri.scheme,\n          }\n          if uri.password\n            @data[:proxy][:password] = uri.password\n          end\n          if uri.user\n            @data[:proxy][:user] = uri.user\n          end\n          if @data[:proxy][:scheme] == UNIX\n            if @data[:proxy][:host]\n              raise ArgumentError, \"The `:host` parameter should not be set for `unix://` proxies.\\n\" +\n                                   \"When supplying a `unix://` URI, it should start with `unix:/` or `unix:///`.\"\n            end\n          else\n            unless uri.host && uri.port && uri.scheme\n              raise Excon::Errors::ProxyParse, \"Proxy is invalid\"\n            end\n          end\n        else\n          raise Excon::Errors::ProxyParse, \"Proxy is invalid\"\n        end\n\n        if @data.has_key?(:proxy) && @data[:scheme] == 'http'\n          @data[:headers]['Proxy-Connection'] ||= 'Keep-Alive'\n          # https credentials happen in handshake\n          if @data[:proxy].has_key?(:user) || @data[:proxy].has_key?(:password)\n            user, pass = Utils.unescape_form(@data[:proxy][:user].to_s), Utils.unescape_form(@data[:proxy][:password].to_s)\n            auth = [\"#{user}:#{pass}\"].pack('m').delete(Excon::CR_NL)\n            @data[:headers]['Proxy-Authorization'] = 'Basic ' + auth\n          end\n        end\n      end\n    end\n  end\nend\n", "Shindo.tests('Excon Connection') do\n  env_init\n\n  with_rackup('basic.ru') do\n    tests('#socket connects, sets data[:remote_ip]').returns('127.0.0.1') do\n      connection = Excon::Connection.new(\n        :host             => '127.0.0.1',\n        :hostname         => '127.0.0.1',\n        :nonblock         => false,\n        :port             => 9292,\n        :scheme           => 'http',\n        :ssl_verify_peer  => false\n      )\n      connection.send(:socket) # creates/connects socket\n      connection.data[:remote_ip]\n    end\n  end\n\n  tests(\"inspect redaction\") do\n    cases = [\n      ['user & pass', 'http://user1:pass1@foo.com/', 'Basic dXNlcjE6cGFzczE='],\n      ['email & pass', 'http://foo%40bar.com:pass1@foo.com/', 'Basic Zm9vQGJhci5jb206cGFzczE='],\n      ['user no pass', 'http://three_user@foo.com/', 'Basic dGhyZWVfdXNlcjo='],\n      ['pass no user', 'http://:derppass@foo.com/', 'Basic OmRlcnBwYXNz']\n    ]\n    cases.each do |desc,url,auth_header|\n      conn = Excon.new(url, :proxy => url)\n\n      test(\"authorization/proxy-authorization headers concealed for #{desc}\") do\n        !conn.inspect.include?(auth_header)\n      end\n\n      if conn.data[:password]\n        test(\"password param concealed for #{desc}\") do\n          !conn.inspect.include?(conn.data[:password])\n        end\n\n        test(\"password param not mutated for #{desc}\") do\n          conn.data[:password] == URI.parse(url).password\n        end\n      end\n\n      if conn.data[:proxy] && conn.data[:proxy][:password]\n        test(\"proxy password param concealed for proxy: #{desc}\") do\n          !conn.inspect.include?(conn.data[:proxy][:password])\n        end\n\n        test(\"proxy password param not mutated for proxy: #{desc}\") do\n          conn.data[:proxy][:password] == URI.parse(url).password\n        end\n      end\n    end\n  end\n\n  env_restore\nend\n", "require 'sinatra'\nrequire 'json'\nrequire File.join(File.dirname(__FILE__), 'webrick_patch')\n\nclass Basic < Sinatra::Base\n  set :environment, :production\n  enable :dump_errors\n\n  get('/content-length/:value') do |value|\n    headers(\"Custom\" => \"Foo: bar\")\n    'x' * value.to_i\n  end\n\n  get('/headers') do\n    content_type :json\n    request.env.select{|key, _| key.start_with? 'HTTP_'}.to_json\n  end\n\n  post('/body-sink') do\n    request.body.read.size.to_s\n  end\n\n  post('/echo') do\n    echo\n  end\n\n  put('/echo') do\n    echo\n  end\n\n  get('/echo dirty') do\n    echo\n  end\n\n  private\n\n  def echo\n    request.body.read\n  end\n\nend\n"], "fixing_code": ["# frozen_string_literal: true\nmodule Excon\n  class Connection\n    include Utils\n\n    attr_reader :data\n\n    def connection\n      Excon.display_warning('Excon::Connection#connection is deprecated use Excon::Connection#data instead.')\n      @data\n    end\n    def connection=(new_params)\n      Excon.display_warning('Excon::Connection#connection= is deprecated. Use of this method may cause unexpected results.')\n      @data = new_params\n    end\n\n    def params\n      Excon.display_warning('Excon::Connection#params is deprecated use Excon::Connection#data instead.')\n      @data\n    end\n    def params=(new_params)\n      Excon.display_warning('Excon::Connection#params= is deprecated. Use of this method may cause unexpected results.')\n      @data = new_params\n    end\n\n    def proxy\n      Excon.display_warning('Excon::Connection#proxy is deprecated use Excon::Connection#data[:proxy] instead.')\n      @data[:proxy]\n    end\n    def proxy=(new_proxy)\n      Excon.display_warning('Excon::Connection#proxy= is deprecated. Use of this method may cause unexpected results.')\n      @data[:proxy] = new_proxy\n    end\n\n    def logger\n      if @data[:instrumentor] && @data[:instrumentor].respond_to?(:logger)\n        @data[:instrumentor].logger\n      end\n    end\n    def logger=(logger)\n      @data[:instrumentor] = Excon::LoggingInstrumentor\n      @data[:logger] = logger\n    end\n\n    # Initializes a new Connection instance\n    # @param [Hash<Symbol, >] params One or more optional params\n    # @option params [String] :body Default text to be sent over a socket. Only used if :body absent in Connection#request params\n    # @option params [Hash<Symbol, String>] :headers The default headers to supply in a request. Only used if params[:headers] is not supplied to Connection#request\n    # @option params [String] :host The destination host's reachable DNS name or IP, in the form of a String. IPv6 addresses must be wrapped (e.g. [::1]).  See URI#host.\n    # @option params [String] :hostname Same as host, but usable for socket connections. IPv6 addresses must not be wrapped (e.g. ::1).  See URI#hostname.\n    # @option params [String] :path Default path; appears after 'scheme://host:port/'. Only used if params[:path] is not supplied to Connection#request\n    # @option params [Fixnum] :port The port on which to connect, to the destination host\n    # @option params [Hash]   :query Default query; appended to the 'scheme://host:port/path/' in the form of '?key=value'. Will only be used if params[:query] is not supplied to Connection#request\n    # @option params [String] :scheme The protocol; 'https' causes OpenSSL to be used\n    # @option params [String] :socket The path to the unix socket (required for 'unix://' connections)\n    # @option params [String] :ciphers Only use the specified SSL/TLS cipher suites; use OpenSSL cipher spec format e.g. 'HIGH:!aNULL:!3DES' or 'AES256-SHA:DES-CBC3-SHA'\n    # @option params [String] :proxy Proxy server; e.g. 'http://myproxy.com:8888'\n    # @option params [Fixnum] :retry_limit Set how many times we'll retry a failed request.  (Default 4)\n    # @option params [Fixnum] :retry_interval Set how long to wait between retries. (Default 0)\n    # @option params [Class] :instrumentor Responds to #instrument as in ActiveSupport::Notifications\n    # @option params [String] :instrumentor_name Name prefix for #instrument events.  Defaults to 'excon'\n    def initialize(params = {})\n      @data = Excon.defaults.dup\n      # merge does not deep-dup, so make sure headers is not the original\n      @data[:headers] = @data[:headers].dup\n\n      # the same goes for :middlewares\n      @data[:middlewares] = @data[:middlewares].dup\n\n      @data.merge!(params)\n      validate_params(:connection, @data, @data[:middlewares])\n\n      if @data.key?(:host) && !@data.key?(:hostname)\n        Excon.display_warning('hostname is missing! For IPv6 support, provide both host and hostname: Excon::Connection#new(:host => uri.host, :hostname => uri.hostname, ...).')\n        @data[:hostname] = @data[:host]\n      end\n\n      setup_proxy\n\n      if  ENV.has_key?('EXCON_STANDARD_INSTRUMENTOR')\n        @data[:instrumentor] = Excon::StandardInstrumentor\n      end\n\n      if @data[:debug] || ENV.has_key?('EXCON_DEBUG')\n        @data[:debug_request] = @data[:debug_response] = true\n        @data[:instrumentor] = Excon::StandardInstrumentor\n      end\n\n      if @data[:scheme] == UNIX\n        if @data[:host]\n          raise ArgumentError, \"The `:host` parameter should not be set for `unix://` connections.\\n\" +\n                               \"When supplying a `unix://` URI, it should start with `unix:/` or `unix:///`.\"\n        elsif !@data[:socket]\n          raise ArgumentError, 'You must provide a `:socket` for `unix://` connections'\n        else\n          @socket_key = \"#{@data[:scheme]}://#{@data[:socket]}\"\n        end\n      else\n        @socket_key = \"#{@data[:scheme]}://#{@data[:host]}#{port_string(@data)}\"\n      end\n      reset\n    end\n\n    def error_call(datum)\n      if datum[:error]\n        raise(datum[:error])\n      end\n    end\n\n    def request_call(datum)\n      begin\n        if datum.has_key?(:response)\n          # we already have data from a middleware, so bail\n          return datum\n        else\n          socket.data = datum\n          # start with \"METHOD /path\"\n          request = datum[:method].to_s.upcase + ' '\n          if datum[:proxy] && datum[:scheme] != HTTPS\n            request << datum[:scheme] << '://' << datum[:host] << port_string(datum)\n          end\n          request << datum[:path]\n\n          # add query to path, if there is one\n          request << query_string(datum)\n\n          # finish first line with \"HTTP/1.1\\r\\n\"\n          request << HTTP_1_1\n\n          if datum.has_key?(:request_block)\n            datum[:headers]['Transfer-Encoding'] = 'chunked'\n          else\n            body = datum[:body].is_a?(String) ? StringIO.new(datum[:body]) : datum[:body]\n\n            # The HTTP spec isn't clear on it, but specifically, GET requests don't usually send bodies;\n            # if they don't, sending Content-Length:0 can cause issues.\n            unless datum[:method].to_s.casecmp('GET') == 0 && body.nil?\n              unless datum[:headers].has_key?('Content-Length')\n                datum[:headers]['Content-Length'] = detect_content_length(body)\n              end\n            end\n          end\n\n          # add headers to request\n          datum[:headers].each do |key, values|\n            if key.to_s.match(/[\\r\\n]/)\n              raise Excon::Errors::InvalidHeaderKey.new(key.to_s.inspect + ' contains forbidden \"\\r\" or \"\\n\"')\n            end\n            [values].flatten.each do |value|\n              if value.to_s.match(/[\\r\\n]/)\n                raise Excon::Errors::InvalidHeaderValue.new(value.to_s.inspect + ' contains forbidden \"\\r\" or \"\\n\"')\n              end\n              request << key.to_s << ': ' << value.to_s << CR_NL\n            end\n          end\n\n          # add additional \"\\r\\n\" to indicate end of headers\n          request << CR_NL\n\n          if datum.has_key?(:request_block)\n            socket.write(request) # write out request + headers\n            while true # write out body with chunked encoding\n              chunk = datum[:request_block].call\n              binary_encode(chunk)\n              if chunk.length > 0\n                socket.write(chunk.length.to_s(16) << CR_NL << chunk << CR_NL)\n              else\n                socket.write(String.new(\"0#{CR_NL}#{CR_NL}\"))\n                break\n              end\n            end\n          elsif body.nil?\n            socket.write(request) # write out request + headers\n          else # write out body\n            if body.respond_to?(:binmode) && !body.is_a?(StringIO)\n              body.binmode\n            end\n            if body.respond_to?(:rewind)\n              body.rewind  rescue nil\n            end\n\n            # if request + headers is less than chunk size, fill with body\n            binary_encode(request)\n            chunk = body.read([datum[:chunk_size] - request.length, 0].max)\n            if chunk\n              binary_encode(chunk)\n              socket.write(request << chunk)\n            else\n              socket.write(request) # write out request + headers\n            end\n\n            while chunk = body.read(datum[:chunk_size])\n              socket.write(chunk)\n            end\n          end\n        end\n      rescue => error\n        case error\n        when Excon::Errors::InvalidHeaderKey, Excon::Errors::InvalidHeaderValue, Excon::Errors::StubNotFound, Excon::Errors::Timeout\n          raise(error)\n        else\n          raise_socket_error(error)\n        end\n      end\n\n      datum\n    end\n\n    def response_call(datum)\n      # ensure response_block is yielded to and body is empty from middlewares\n      if datum.has_key?(:response_block) && !(datum[:response][:body].nil? || datum[:response][:body].empty?)\n        response_body = datum[:response][:body].dup\n        datum[:response][:body] = ''\n        content_length = remaining = response_body.bytesize\n        while remaining > 0\n          datum[:response_block].call(response_body.slice!(0, [datum[:chunk_size], remaining].min), [remaining - datum[:chunk_size], 0].max, content_length)\n          remaining -= datum[:chunk_size]\n        end\n      end\n      datum\n    end\n\n    # Sends the supplied request to the destination host.\n    # @yield [chunk] @see Response#self.parse\n    # @param [Hash<Symbol, >] params One or more optional params, override defaults set in Connection.new\n    # @option params [String] :body text to be sent over a socket\n    # @option params [Hash<Symbol, String>] :headers The default headers to supply in a request\n    # @option params [String] :path appears after 'scheme://host:port/'\n    # @option params [Hash]   :query appended to the 'scheme://host:port/path/' in the form of '?key=value'\n    def request(params={}, &block)\n      # @data has defaults, merge in new params to override\n      datum = @data.merge(params)\n      datum[:headers] = @data[:headers].merge(datum[:headers] || {})\n\n      validate_params(:request, params, datum[:middlewares])\n      # If the user passed in new middleware, we want to validate that the original connection parameters\n      # are still valid with the provided middleware.\n      if params[:middlewares]\n        validate_params(:connection, @data, datum[:middlewares])\n      end\n\n      if datum[:user] || datum[:password]\n        user, pass = Utils.unescape_uri(datum[:user].to_s), Utils.unescape_uri(datum[:password].to_s)\n        datum[:headers]['Authorization'] ||= 'Basic ' + [\"#{user}:#{pass}\"].pack('m').delete(Excon::CR_NL)\n      end\n\n      if datum[:scheme] == UNIX\n        datum[:headers]['Host']   ||= ''\n      else\n        datum[:headers]['Host']   ||= datum[:host] + port_string(datum)\n      end\n\n      # if path is empty or doesn't start with '/', insert one\n      unless datum[:path][0, 1] == '/'\n        datum[:path] = datum[:path].dup.insert(0, '/')\n      end\n\n      if block_given?\n        Excon.display_warning('Excon requests with a block are deprecated, pass :response_block instead.')\n        datum[:response_block] = block\n      end\n\n      datum[:connection] = self\n\n      # cleanup data left behind on persistent connection after interrupt\n      if datum[:persistent] && !@persistent_socket_reusable\n        reset\n      end\n\n      datum[:stack] = datum[:middlewares].map do |middleware|\n        lambda {|stack| middleware.new(stack)}\n      end.reverse.inject(self) do |middlewares, middleware|\n        middleware.call(middlewares)\n      end\n      datum = datum[:stack].request_call(datum)\n\n      unless datum[:pipeline]\n        @persistent_socket_reusable = false\n        datum = response(datum)\n        @persistent_socket_reusable = true\n\n        if datum[:persistent]\n          if key = datum[:response][:headers].keys.detect {|k| k.casecmp('Connection') == 0 }\n            if datum[:response][:headers][key].casecmp('close') == 0\n              reset\n            end\n          end\n        else\n          reset\n        end\n\n        Excon::Response.new(datum[:response])\n      else\n        datum\n      end\n    rescue => error\n      reset\n\n      # If we didn't get far enough to initialize datum and the middleware stack, just raise\n      raise error if !datum\n\n      datum[:error] = error\n      if datum[:stack]\n        datum[:stack].error_call(datum)\n      else\n        raise error\n      end\n    end\n\n    # Sends the supplied requests to the destination host using pipelining.\n    # @param pipeline_params [Array<Hash>] An array of one or more optional params, override defaults set in Connection.new, see #request for details\n    def requests(pipeline_params)\n      pipeline_params.each {|params| params.merge!(:pipeline => true, :persistent => true) }\n      pipeline_params.last.merge!(:persistent => @data[:persistent])\n\n      responses = pipeline_params.map do |params|\n        request(params)\n      end.map do |datum|\n        Excon::Response.new(response(datum)[:response])\n      end\n\n      if @data[:persistent]\n        if key = responses.last[:headers].keys.detect {|k| k.casecmp('Connection') == 0 }\n          if responses.last[:headers][key].casecmp('close') == 0\n            reset\n          end\n        end\n      else\n        reset\n      end\n\n      responses\n    end\n\n    # Sends the supplied requests to the destination host using pipelining in\n    # batches of @limit [Numeric] requests. This is your soft file descriptor\n    # limit by default, typically 256.\n    # @param pipeline_params [Array<Hash>] An array of one or more optional params, override defaults set in Connection.new, see #request for details\n    def batch_requests(pipeline_params, limit = nil)\n      limit ||= Process.respond_to?(:getrlimit) ? Process.getrlimit(:NOFILE).first : 256\n      responses = []\n\n      pipeline_params.each_slice(limit) do |params|\n        responses.concat(requests(params))\n      end\n\n      responses\n    end\n\n    def reset\n      if old_socket = sockets.delete(@socket_key)\n        old_socket.close rescue nil\n      end\n      @persistent_socket_reusable = true\n    end\n\n    # Generate HTTP request verb methods\n    Excon::HTTP_VERBS.each do |method|\n      class_eval <<-DEF, __FILE__, __LINE__ + 1\n        def #{method}(params={}, &block)\n          request(params.merge!(:method => :#{method}), &block)\n        end\n      DEF\n    end\n\n    def retry_limit=(new_retry_limit)\n      Excon.display_warning('Excon::Connection#retry_limit= is deprecated, pass :retry_limit to the initializer.')\n      @data[:retry_limit] = new_retry_limit\n    end\n\n    def retry_limit\n      Excon.display_warning('Excon::Connection#retry_limit is deprecated, use Excon::Connection#data[:retry_limit].')\n      @data[:retry_limit] ||= DEFAULT_RETRY_LIMIT\n    end\n\n    def inspect\n      vars = instance_variables.inject({}) do |accum, var|\n        accum.merge!(var.to_sym => instance_variable_get(var))\n      end\n      vars[:'@data'] = Utils.redact(vars[:'@data'])\n      inspection = '#<Excon::Connection:'\n      inspection += (object_id << 1).to_s(16)\n      vars.each do |key, value|\n        inspection += \" #{key}=#{value.inspect}\"\n      end\n      inspection += '>'\n      inspection\n    end\n\n    def valid_request_keys(middlewares)\n      valid_middleware_keys(middlewares) + Excon::VALID_REQUEST_KEYS\n    end\n\n    private\n\n    def detect_content_length(body)\n      if body.respond_to?(:size)\n        # IO object: File, Tempfile, StringIO, etc.\n        body.size\n      elsif body.respond_to?(:stat)\n        # for 1.8.7 where file does not have size\n        body.stat.size\n      else\n        0\n      end\n    end\n\n    def valid_middleware_keys(middlewares)\n      middlewares.flat_map do |middleware|\n        if middleware.respond_to?(:valid_parameter_keys)\n          middleware.valid_parameter_keys\n        else\n          Excon.display_warning(\n            \"Excon middleware #{middleware} does not define #valid_parameter_keys\"\n          )\n          []\n        end\n      end\n    end\n\n    def validate_params(validation, params, middlewares)\n      valid_keys = case validation\n      when :connection\n        valid_middleware_keys(middlewares) + Excon::VALID_CONNECTION_KEYS\n      when :request\n        valid_request_keys(middlewares)\n      else\n        raise ArgumentError.new(\"Invalid validation type '#{validation}'\")\n      end\n\n      invalid_keys = params.keys - valid_keys\n      unless invalid_keys.empty?\n        Excon.display_warning(\"Invalid Excon #{validation} keys: #{invalid_keys.map(&:inspect).join(', ')}\")\n\n        if validation == :request\n          deprecated_keys = invalid_keys & Excon::DEPRECATED_VALID_REQUEST_KEYS.keys\n          mw_msg = deprecated_keys.map do |k|\n            \"#{k}: #{Excon::DEPRECATED_VALID_REQUEST_KEYS[k]}\"\n          end.join(', ')\n          Excon.display_warning(\n            \"The following request keys are only valid with the associated middleware: #{mw_msg}\"\n          )\n        end\n      end\n    end\n\n    def response(datum={})\n      datum[:stack].response_call(datum)\n    rescue => error\n      case error\n      when Excon::Errors::HTTPStatusError, Excon::Errors::Timeout, Excon::Errors::TooManyRedirects\n        raise(error)\n      else\n        raise_socket_error(error)\n      end\n    end\n\n    def socket\n      unix_proxy = @data[:proxy] ? @data[:proxy][:scheme] == UNIX : false\n      sockets[@socket_key] ||= if @data[:scheme] == UNIX || unix_proxy\n        Excon::UnixSocket.new(@data)\n      elsif @data[:ssl_uri_schemes].include?(@data[:scheme])\n        Excon::SSLSocket.new(@data)\n      else\n        Excon::Socket.new(@data)\n      end\n    end\n\n    def sockets\n      @_excon_sockets ||= {}\n\n      if @data[:thread_safe_sockets]\n        # In a multi-threaded world, if the same connection is used by multiple\n        # threads at the same time to connect to the same destination, they may\n        # stomp on each other's sockets.  This ensures every thread gets their\n        # own socket cache, within the context of a single connection.\n        @_excon_sockets[Thread.current.object_id] ||= {}\n      else\n        @_excon_sockets\n      end\n    end\n\n    def raise_socket_error(error)\n      if error.message =~ /certificate verify failed/\n        raise(Excon::Errors::CertificateError.new(error))\n      else\n        raise(Excon::Errors::SocketError.new(error))\n      end\n    end\n\n    def setup_proxy\n      if @data[:disable_proxy]\n        if @data[:proxy]\n          raise ArgumentError, \"`:disable_proxy` parameter and `:proxy` parameter cannot both be set at the same time.\"\n        end\n        return\n      end\n\n      unless @data[:scheme] == UNIX\n        if no_proxy_env = ENV[\"no_proxy\"] || ENV[\"NO_PROXY\"]\n          no_proxy_list = no_proxy_env.scan(/\\*?\\.?([^\\s,:]+)(?::(\\d+))?/i).map { |s| [s[0], s[1]] }\n        end\n\n        unless no_proxy_env && no_proxy_list.index { |h| /(^|\\.)#{h[0]}$/.match(@data[:host]) && (h[1].nil? || h[1].to_i == @data[:port]) }\n          if @data[:scheme] == HTTPS && (ENV.has_key?('https_proxy') || ENV.has_key?('HTTPS_PROXY'))\n            @data[:proxy] = ENV['https_proxy'] || ENV['HTTPS_PROXY']\n          elsif (ENV.has_key?('http_proxy') || ENV.has_key?('HTTP_PROXY'))\n            @data[:proxy] = ENV['http_proxy'] || ENV['HTTP_PROXY']\n          end\n        end\n\n        case @data[:proxy]\n        when nil\n          @data.delete(:proxy)\n        when ''\n          @data.delete(:proxy)\n        when Hash\n          # no processing needed\n        when String, URI\n          uri = @data[:proxy].is_a?(String) ? URI.parse(@data[:proxy]) : @data[:proxy]\n          @data[:proxy] = {\n            :host       => uri.host,\n            :hostname   => uri.hostname,\n            # path is only sensible for a Unix socket proxy\n            :path       => uri.scheme == UNIX ? uri.path : nil,\n            :port       => uri.port,\n            :scheme     => uri.scheme,\n          }\n          if uri.password\n            @data[:proxy][:password] = uri.password\n          end\n          if uri.user\n            @data[:proxy][:user] = uri.user\n          end\n          if @data[:proxy][:scheme] == UNIX\n            if @data[:proxy][:host]\n              raise ArgumentError, \"The `:host` parameter should not be set for `unix://` proxies.\\n\" +\n                                   \"When supplying a `unix://` URI, it should start with `unix:/` or `unix:///`.\"\n            end\n          else\n            unless uri.host && uri.port && uri.scheme\n              raise Excon::Errors::ProxyParse, \"Proxy is invalid\"\n            end\n          end\n        else\n          raise Excon::Errors::ProxyParse, \"Proxy is invalid\"\n        end\n\n        if @data.has_key?(:proxy) && @data[:scheme] == 'http'\n          @data[:headers]['Proxy-Connection'] ||= 'Keep-Alive'\n          # https credentials happen in handshake\n          if @data[:proxy].has_key?(:user) || @data[:proxy].has_key?(:password)\n            user, pass = Utils.unescape_form(@data[:proxy][:user].to_s), Utils.unescape_form(@data[:proxy][:password].to_s)\n            auth = [\"#{user}:#{pass}\"].pack('m').delete(Excon::CR_NL)\n            @data[:headers]['Proxy-Authorization'] = 'Basic ' + auth\n          end\n        end\n      end\n    end\n  end\nend\n", "Shindo.tests('Excon Connection') do\n  env_init\n\n  with_rackup('basic.ru') do\n    tests('#socket connects, sets data[:remote_ip]').returns('127.0.0.1') do\n      connection = Excon::Connection.new(\n        :host             => '127.0.0.1',\n        :hostname         => '127.0.0.1',\n        :nonblock         => false,\n        :port             => 9292,\n        :scheme           => 'http',\n        :ssl_verify_peer  => false\n      )\n      connection.send(:socket) # creates/connects socket\n      connection.data[:remote_ip]\n    end\n\n    tests(\"persistent connections\") do\n      connection = Excon.new('http://127.0.0.1:9292', persistent: true)\n\n      response_body = connection.request(path: '/foo', method: 'get').body\n      test(\"successful uninterrupted request\") do\n        connection.request(path: '/foo', method: 'get').body == 'foo'\n      end\n\n      begin\n        # simulate an interrupted connection which leaves data behind\n        Timeout::timeout(0.0000000001) do\n          connection.request(path: '/foo', method: 'get')\n        end\n      rescue Timeout::Error\n        nil\n      end\n\n      test(\"resets connection after interrupt\") do\n        response = connection.request(path: '/bar', method: 'get')\n        response.body == 'bar'\n      end\n    end\n  end\n\n  tests(\"inspect redaction\") do\n    cases = [\n      ['user & pass', 'http://user1:pass1@foo.com/', 'Basic dXNlcjE6cGFzczE='],\n      ['email & pass', 'http://foo%40bar.com:pass1@foo.com/', 'Basic Zm9vQGJhci5jb206cGFzczE='],\n      ['user no pass', 'http://three_user@foo.com/', 'Basic dGhyZWVfdXNlcjo='],\n      ['pass no user', 'http://:derppass@foo.com/', 'Basic OmRlcnBwYXNz']\n    ]\n    cases.each do |desc,url,auth_header|\n      conn = Excon.new(url, :proxy => url)\n\n      test(\"authorization/proxy-authorization headers concealed for #{desc}\") do\n        !conn.inspect.include?(auth_header)\n      end\n\n      if conn.data[:password]\n        test(\"password param concealed for #{desc}\") do\n          !conn.inspect.include?(conn.data[:password])\n        end\n\n        test(\"password param not mutated for #{desc}\") do\n          conn.data[:password] == URI.parse(url).password\n        end\n      end\n\n      if conn.data[:proxy] && conn.data[:proxy][:password]\n        test(\"proxy password param concealed for proxy: #{desc}\") do\n          !conn.inspect.include?(conn.data[:proxy][:password])\n        end\n\n        test(\"proxy password param not mutated for proxy: #{desc}\") do\n          conn.data[:proxy][:password] == URI.parse(url).password\n        end\n      end\n    end\n  end\n\n  env_restore\nend\n", "require 'sinatra'\nrequire 'json'\nrequire File.join(File.dirname(__FILE__), 'webrick_patch')\n\nclass Basic < Sinatra::Base\n  set :environment, :production\n  enable :dump_errors\n\n  get('/content-length/:value') do |value|\n    headers(\"Custom\" => \"Foo: bar\")\n    'x' * value.to_i\n  end\n\n  get('/headers') do\n    content_type :json\n    request.env.select{|key, _| key.start_with? 'HTTP_'}.to_json\n  end\n\n  post('/body-sink') do\n    request.body.read.size.to_s\n  end\n\n  post('/echo') do\n    echo\n  end\n\n  put('/echo') do\n    echo\n  end\n\n  get('/echo dirty') do\n    echo\n  end\n\n  get('/foo') do\n    'foo'\n  end\n\n  get('/bar') do\n    'bar'\n  end\n\n  private\n\n  def echo\n    request.body.read\n  end\n\nend\n"], "filenames": ["lib/excon/connection.rb", "tests/connection_tests.rb", "tests/rackups/basic.rb"], "buggy_code_start_loc": [264, 15, 34], "buggy_code_end_loc": [346, 15, 34], "fixing_code_start_loc": [265, 16, 35], "fixing_code_end_loc": [355, 39, 43], "type": "CWE-362", "message": "In RubyGem excon before 0.71.0, there was a race condition around persistent connections, where a connection which is interrupted (such as by a timeout) would leave data on the socket. Subsequent requests would then read this data, returning content from the previous response. The race condition window appears to be short, and it would be difficult to purposefully exploit this.", "other": {"cve": {"id": "CVE-2019-16779", "sourceIdentifier": "security-advisories@github.com", "published": "2019-12-16T20:15:15.540", "lastModified": "2021-10-28T13:38:57.010", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In RubyGem excon before 0.71.0, there was a race condition around persistent connections, where a connection which is interrupted (such as by a timeout) would leave data on the socket. Subsequent requests would then read this data, returning content from the previous response. The race condition window appears to be short, and it would be difficult to purposefully exploit this."}, {"lang": "es", "value": "En RubyGem excon versiones anteriores a 0.71.0, se present\u00f3 una condici\u00f3n de carrera alrededor de conexiones persistentes, donde una conexi\u00f3n que es interrumpida (tal y como, mediante un tiempo de espera) dejar\u00eda datos en el socket. Las peticiones posteriores entonces leer\u00edan estos datos y devolver\u00edan el contenido de la respuesta anterior. La ventana de condici\u00f3n de carrera parece ser corta, y ser\u00eda dif\u00edcil explotar esto a prop\u00f3sito."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-664"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:excon_project:excon:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.71.0", "matchCriteriaId": "FF974810-A91D-44C6-8F47-1B7803641178"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:backports_sle:15.0:sp1:*:*:*:*:*:*", "matchCriteriaId": "40513095-7E6E-46B3-B604-C926F1BA3568"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00021.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00062.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/excon/excon/commit/ccb57d7a422f020dc74f1de4e8fb505ab46d8a29", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/excon/excon/security/advisories/GHSA-q58g-455p-8vw9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/01/msg00015.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/excon/excon/commit/ccb57d7a422f020dc74f1de4e8fb505ab46d8a29"}}