{"buggy_code": ["/* NSString+Utilities.m - this file is part of SOGo\n *\n * Copyright (C) 2006-2022 Inverse inc.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; see the file COPYING.  If not, write to\n * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n\n#import <EOControl/EOQualifier.h>\n\n#import <NGExtensions/NSDictionary+misc.h>\n#import <NGExtensions/NSObject+Logs.h>\n#import <NGExtensions/NGBase64Coding.h>\n\n#import <NGMime/NGMimeHeaderFieldGenerator.h>\n#import <SBJson/SBJsonParser.h>\n\n#import \"NSArray+Utilities.h\"\n#import \"NSDictionary+URL.h\"\n\n#import \"NSString+Utilities.h\"\n\nstatic NSMutableCharacterSet *urlNonEndingChars = nil;\nstatic NSMutableCharacterSet *urlAfterEndingChars = nil;\nstatic NSMutableCharacterSet *schemaStartChars = nil;\nstatic NSMutableCharacterSet *emailStartChars = nil;\n\nstatic NSMutableCharacterSet *jsonEscapingChars = NULL;\nstatic NSString **cssEscapingStrings = NULL;\nstatic unichar *cssEscapingCharacters = NULL;\nstatic int cssEscapingCount;\n\n@implementation NSString (SOGoURLExtension)\n\n- (NSString *) composeURLWithAction: (NSString *) action\n                         parameters: (NSDictionary *) urlParameters\n                            andHash: (BOOL) useHash\n{\n  NSMutableString *completeURL;\n\n  completeURL = [NSMutableString new];\n  [completeURL autorelease];\n\n  [completeURL appendString: [self urlWithoutParameters]];\n  if (![completeURL hasSuffix: @\"/\"])\n    [completeURL appendString: @\"/\"];\n  [completeURL appendString: action];\n  if (urlParameters)\n    [completeURL appendString: [urlParameters asURLParameters]];\n  if (useHash)\n    [completeURL appendString: @\"#\"];\n\n  return completeURL;\n}\n\n- (NSString *) hostlessURL\n{\n  NSString *newURL;\n  NSRange hostR, locationR;\n\n  if ([self hasPrefix: @\"/\"])\n    {\n      newURL = [self copy];\n      [newURL autorelease];\n    }\n  else\n    {\n      hostR = [self rangeOfString: @\"://\"];\n      locationR = [[self substringFromIndex: (hostR.location + hostR.length)] rangeOfString: @\"/\"];\n      newURL = [self substringFromIndex: (hostR.location + hostR.length + locationR.location)];\n    }\n\n  return newURL;\n}\n\n- (NSString *) urlWithoutParameters;\n{\n  NSRange r;\n  NSString *newUrl;\n\n  r = [self rangeOfString:@\"?\" options: NSBackwardsSearch];\n  if (r.length > 0)\n    newUrl = [self substringToIndex: NSMaxRange (r) - 1];\n  else\n    newUrl = self;\n\n  return newUrl;\n}\n\n- (NSRange) _rangeOfURLInRange: (NSRange) refRange\n               withPrefixChars: (NSCharacterSet *) startChars\n{\n  int start, length;\n  NSRange workRange;\n\n  start = refRange.location;\n  if (start > 0)\n    start--; // Start with the character before the refRange\n  while (start > -1\n         && [startChars characterIsMember:\n                   [self characterAtIndex: start]])\n    start--;\n  start++;\n\n  length = [self length];\n  // In [UIxMailPartTextViewer flatContentAsString], we first escape HTML entities and then\n  // add URLs. Therefore, the brackets (inequality signs <>) have been encoded at this point.\n  if (length > (start + 4)\n      && [[self substringWithRange: NSMakeRange (start, 4)] compare: @\"&lt;\"] == NSOrderedSame)\n    start += 4;\n\n  length -= start;\n  workRange = [self rangeOfCharacterFromSet: urlAfterEndingChars\n                                    options: NSLiteralSearch range: NSMakeRange (start, length)];\n  if (workRange.location != NSNotFound)\n    length = workRange.location - start;\n  while\n    (length > 0\n     && [urlNonEndingChars characterIsMember:\n                      [self characterAtIndex: (start + length - 1)]])\n    length--;\n\n  // Remove trailing \">\"\n  if (([self length] >= start + length + 1)\n      && [[self substringWithRange: NSMakeRange (start, length + 1)] hasSuffix: @\"&gt;\"])\n    length -= 3;\n\n  return NSMakeRange (start, length);\n}\n\n- (void) _handleURLs: (NSMutableString *) selfCopy\n         textToMatch: (NSString *) match\n      urlPrefixChars: (NSCharacterSet *) startChars\n              prefix: (NSString *) prefix\n            inRanges: (NSMutableArray *) ranges\n{\n  NSEnumerator *enumRanges;\n  NSMutableArray *newRanges;\n  NSRange matchRange, currentUrlRange, rest;\n  NSRange *rangePtr;\n  NSString *urlText, *newUrlText;\n  unsigned int length, matchLength, offset;\n\n  newRanges = [NSMutableArray array];\n  matchLength = [match length];\n\n  matchRange = [selfCopy rangeOfString: match];\n  while (matchRange.location != NSNotFound)\n    {\n      currentUrlRange = [selfCopy _rangeOfURLInRange: matchRange\n                                     withPrefixChars: startChars];\n      if (![ranges hasRangeIntersection: currentUrlRange])\n        if (currentUrlRange.length > matchLength)\n          [newRanges addNonNSObject: &currentUrlRange\n                           withSize: sizeof (NSRange)\n                               copy: YES];\n      rest.location = NSMaxRange (currentUrlRange);\n      length = [selfCopy length];\n      rest.length = length - rest.location;\n      matchRange = [selfCopy rangeOfString: match\n                                   options: 0 range: rest];\n    }\n\n  // Make the substitutions, keep track of the new offset\n  offset = 0;\n  enumRanges = [newRanges objectEnumerator];\n  while ((rangePtr = [[enumRanges nextObject] pointerValue]))\n    {\n      rangePtr->location += offset;\n      urlText = [selfCopy substringFromRange: *rangePtr];\n      newUrlText = [NSString stringWithFormat: @\"<a rel=\\\"noopener\\\" href=\\\"%@%@\\\">%@</a>\",\n                          ([urlText hasPrefix: prefix]? @\"\" : prefix),\n                             urlText, urlText];\n      [selfCopy replaceCharactersInRange: *rangePtr\n                              withString: newUrlText];\n      offset += ([newUrlText length] - [urlText length]);\n\n      // Add range for further substitutions\n      currentUrlRange = NSMakeRange (rangePtr->location, [newUrlText length]);\n      [ranges addNonNSObject: &currentUrlRange\n                    withSize: sizeof (NSRange)\n                        copy: YES];\n    }\n  [newRanges freeNonNSObjects];\n}\n\n- (NSString *) stringByDetectingURLs\n{\n  NSMutableString *selfCopy;\n  NSMutableArray *ranges;\n\n  if (!urlNonEndingChars)\n    {\n      urlNonEndingChars = [NSMutableCharacterSet new];\n      [urlNonEndingChars addCharactersInString: @\"=,.:;&()>\\t \\r\\n\"];\n    }\n  if (!urlAfterEndingChars)\n    {\n      urlAfterEndingChars = [NSMutableCharacterSet new];\n      [urlAfterEndingChars addCharactersInString: @\"()[]\\t \\r\\n\"];\n    }\n  if (!schemaStartChars)\n    {\n      schemaStartChars = [NSMutableCharacterSet new];\n      [schemaStartChars addCharactersInString: @\"abcdefghijklmnopqrstuvwxyz\"\n                        @\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"];\n    }\n  if (!emailStartChars)\n    {\n      emailStartChars = [NSMutableCharacterSet new];\n      [emailStartChars addCharactersInString: @\"abcdefghijklmnopqrstuvwxyz\"\n                       @\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                       @\"01234567890\"\n                       @\"!#$%&'*+-/=?^`{|}~.\"];\n    }\n\n  ranges = [NSMutableArray array];\n  selfCopy = [NSMutableString stringWithString: self];\n  [self _handleURLs: selfCopy\n        textToMatch: @\"://\"\n     urlPrefixChars: schemaStartChars\n             prefix: @\"\"\n           inRanges: ranges];\n  [self _handleURLs: selfCopy\n        textToMatch: @\"@\"\n     urlPrefixChars: emailStartChars\n             prefix: @\"mailto:\"\n           inRanges: ranges];\n  [ranges freeNonNSObjects];\n\n  return selfCopy;\n}\n\n- (NSString *) asSafeJSString\n{\n  NSRange esc;\n\n  if (!jsonEscapingChars)\n    {\n      jsonEscapingChars = [[NSMutableCharacterSet characterSetWithRange: NSMakeRange(0,32)] retain];\n      [jsonEscapingChars addCharactersInString: @\"\\\"\\\\\"];\n    }\n\n  esc = [self rangeOfCharacterFromSet: jsonEscapingChars];\n  if (!esc.length)\n    {\n      // No special chars\n      return self;\n    }\n  else\n    {\n      NSMutableString *representation;\n      NSUInteger length, i;\n      unichar uc;\n\n      representation = [NSMutableString string];\n\n      length = [self length];\n      for (i = 0; i < length; i++)\n        {\n          uc = [self characterAtIndex:i];\n          switch (uc)\n            {\n            case '\"':   [representation appendString:@\"\\\\\\\"\"];  break;\n            case '\\\\':  [representation appendString:@\"\\\\\\\\\"];  break;\n            case '\\t':  [representation appendString:@\"\\\\t\"];   break;\n            case '\\n':  [representation appendString:@\"\\\\n\"];   break;\n            case '\\r':  [representation appendString:@\"\\\\r\"];   break;\n            case '\\b':  [representation appendString:@\"\\\\b\"];   break;\n            case '\\f':  [representation appendString:@\"\\\\f\"];   break;\n            default:\n              if (uc < 0x20)\n                [representation appendFormat:@\"\\\\u%04x\", uc];\n              else\n                [representation appendFormat: @\"%C\", uc];\n              break;\n            }\n        }\n      return representation;\n    }\n}\n\n- (NSString *) doubleQuotedString\n{\n  return [NSString stringWithFormat: @\"\\\"%@\\\"\", [self asSafeJSString]];\n}\n\n//\n// See http://www.hackcraft.net/xmlUnicode/\n//\n// XML1.0 and XML1.1 allow different characters in different contexts,\n// but for the most part I will only describe the XML1.0 usage, XML1.1\n// usage is analogous.  The first definition that is relevant here is\n// that of a Char: [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] |\n// [#xE000-#xFFFD] | [#x10000-#x10FFFF] /* any Unicode character,\n// excluding the surrogate blocks, FFFE, and FFFF. */\n//\n// This defines which characters can be used in an XML1.0 document. It\n// is clearly very liberal, banning only some of the control\n// characters and the noncharacters U+FFFE and U+FFFF.  Indeed it is\n// somewhat too liberal in my view since it allows other noncharacters\n// (the code points from U+FDD0 to U+FDEF inclusive and the last 2\n// code points in each plane, from U+1FFFE & U+1FFFF through to\n// U+10FFFE & U+10FFFF, are noncharacters) but the production quoted\n// above allows them.\n//\n- (NSString *) safeString\n{\n  NSData *data;\n  NSString *s;\n\n  const wchar_t *buf;\n  wchar_t *start, c;\n  int len, i, j;\n\n  data = [self dataUsingEncoding: NSUTF32LittleEndianStringEncoding];\n  len = [data length];\n  buf = [data bytes];\n  start = (wchar_t *)calloc(len, sizeof(wchar_t));\n\n  for (i = 0, j = 0; i < len/4; i++)\n    {\n      c = buf[i];\n\n      if (c == 0x0 ||\n          c == 0x9 ||\n          c == 0xA ||\n          (c >= 0x20 && c < 0x300) || // Skip combining diacritical marks\n          (c > 0x36F && c < 0xD7FF) ||\n          (c >= 0xE000 && c < 0xFE00) || // Skip variation selectors\n          (c > 0xFE0F && c <= 0xFFFD) ||\n          (c >= (wchar_t)0x10000 && c <= (wchar_t)0x10FFFF))\n        {\n          start[j] = c;\n          j++;\n        }\n    }\n\n  s = [[NSString alloc] initWithBytesNoCopy: start  length: j*sizeof(wchar_t)  encoding: NSUTF32LittleEndianStringEncoding  freeWhenDone: YES];\n\n  return AUTORELEASE(s);\n}\n\n- (NSString *) safeStringByEscapingXMLString\n{\n  return [self safeStringByEscapingXMLString: NO];\n}\n//\n// This is a copy from NSString+XMLEscaping.m from SOPE.\n// The difference here is that we use wchar_t instead of unichar.\n// This is needed to get the rigth numeric character reference.\n// e.g. SMILING FACE WITH OPEN MOUTH\n//      ok: wchar_t -> &#128515;   wrong:  unichar -> &#55357; &#56835;\n//\n// We avoid naming it like the one in SOPE since if the ActiveSync\n// bundle is loaded, it'll overwrite the one provided by SOPE.\n//\n- (NSString *) safeStringByEscapingXMLString: (BOOL) encodeCR\n{\n  NSData *data;\n\n  register unsigned i, len, j;\n  register wchar_t *buf;\n  const wchar_t *chars;\n  unsigned escapeCount;\n\n  if ([self length] == 0) return @\"\";\n\n  data = [self dataUsingEncoding: NSUTF32LittleEndianStringEncoding];\n  chars = [data bytes];\n  len = [data length]/4;\n\n  /* check for characters to escape ... */\n  for (i = 0, escapeCount = 0; i < len; i++)\n    {\n      switch (chars[i]) {\n      case '&': case '\"': case '<': case '>': case '\\r':\n        escapeCount++;\n        break;\n      default:\n        if (chars[i] < 0x20 || chars[i] > 127)\n          escapeCount++;\n        break;\n      }\n    }\n\n  /* nothing to escape ... */\n  if (escapeCount == 0 )\n    return [[self copy] autorelease];\n\n  buf = calloc((len + 5) + (escapeCount * 16), sizeof(wchar_t));\n  for (i = 0, j = 0; i < len; i++)\n    {\n      switch (chars[i])\n        {\n          /* escape special chars */\n        case '&':\n          buf[j] = '&'; j++; buf[j] = 'a'; j++; buf[j] = 'm'; j++;\n          buf[j] = 'p'; j++; buf[j] = ';'; j++;\n          break;\n        case '\"':\n          buf[j] = '&'; j++; buf[j] = 'q'; j++; buf[j] = 'u'; j++;\n          buf[j] = 'o'; j++; buf[j] = 't'; j++; buf[j] = ';'; j++;\n          break;\n        case '<':\n          buf[j] = '&'; j++; buf[j] = 'l'; j++; buf[j] = 't'; j++;\n          buf[j] = ';'; j++;\n          break;\n        case '>':\n          buf[j] = '&'; j++; buf[j] = 'g'; j++; buf[j] = 't'; j++;\n          buf[j] = ';'; j++;\n          break;\n        case '\\r':\n          if (encodeCR) // falls back to default if we don't encode\n            {\n              buf[j] = '&'; j++; buf[j] = '#'; j++; buf[j] = '1'; j++;\n              buf[j] = '3'; j++; buf[j] = ';'; j++;\n              break;\n            }\n        default:\n          /* escape big chars */\n          if (chars[i] > 127)\n            {\n              unsigned char nbuf[32];\n              unsigned int k;\n\n              sprintf((char *)nbuf, \"&#%i;\", (int)chars[i]);\n              for (k = 0; nbuf[k] != '\\0'; k++)\n                {\n                  buf[j] = nbuf[k];\n                  j++;\n                }\n            }\n          else if (chars[i] == 0x9 || chars[i] == 0xA || chars[i] == 0xD || chars[i] >= 0x20)\n            { // ignore any unsupported control character\n              /* nothing to escape */\n              buf[j] = chars[i];\n              j++;\n            }\n          break;\n        }\n    }\n\n  self = [[NSString alloc] initWithBytesNoCopy: buf\n                                        length: (j*sizeof(wchar_t))\n                                      encoding: NSUTF32LittleEndianStringEncoding\n                                  freeWhenDone: YES];\n  return [self autorelease];\n}\n\n- (NSString *) jsonRepresentation\n{\n  NSString *cleanedString;\n\n  // Escape double quotes and remove control characters\n  cleanedString = [[self safeString] doubleQuotedString];\n  return cleanedString;\n}\n\n- (void) _setupCSSEscaping\n{\n  NSArray *strings, *characters;\n  int count;\n\n  strings = [NSArray arrayWithObjects: @\"_U_\", @\"_D_\", @\"_H_\", @\"_A_\", @\"_S_\",\n                     @\"_C_\", @\"_SC_\",\n                     @\"_CO_\", @\"_SP_\", @\"_SQ_\", @\"_DQ_\",\n                     @\"_LP_\", @\"_RP_\", @\"_LS_\", @\"_RS_\", @\"_LC_\", @\"_RC_\",\n                     @\"_AM_\", @\"_P_\", @\"_DS_\", nil];\n  [strings retain];\n  cssEscapingStrings = [strings asPointersOfObjects];\n\n  characters = [NSArray arrayWithObjects: @\"_\", @\".\", @\"#\", @\"@\", @\"*\",\n                        @\":\", @\";\",\n                        @\",\", @\" \", @\"'\", @\"\\\"\",\n                        @\"(\", @\")\", @\"[\", @\"]\", @\"{\", @\"}\",\n                        @\"&\", @\"+\", @\"$\", nil];\n  cssEscapingCount = [strings count];\n  cssEscapingCharacters = NSZoneMalloc (NULL,\n                                        (cssEscapingCount + 1)\n                                        * sizeof (unichar));\n  for (count = 0; count < cssEscapingCount; count++)\n    *(cssEscapingCharacters + count) = [[characters objectAtIndex: count] characterAtIndex: 0];\n  *(cssEscapingCharacters + cssEscapingCount) = 0;\n}\n\n- (int) _cssCharacterIndex: (unichar) character\n{\n  int idx, count;\n\n  idx = -1;\n  for (count = 0; idx == -1 && count < cssEscapingCount; count++)\n    if (*(cssEscapingCharacters + count) == character)\n      idx = count;\n\n  return idx;\n}\n\n- (NSString *) asCSSIdentifier\n{\n  NSCharacterSet *numericSet;\n  NSMutableString *cssIdentifier;\n  unichar currentChar;\n  int count, max, idx;\n\n  if (!cssEscapingStrings)\n    [self _setupCSSEscaping];\n\n  cssIdentifier = [NSMutableString string];\n  numericSet = [NSCharacterSet decimalDigitCharacterSet];\n  max = [self length];\n\n  if (max > 0)\n    {\n      if ([numericSet characterIsMember: [self characterAtIndex: 0]])\n        // A CSS identifier can't start with a digit; we add an underscore\n        [cssIdentifier appendString: @\"_\"];\n      for (count = 0; count < max; count++)\n        {\n          currentChar = [self characterAtIndex: count];\n          idx = [self _cssCharacterIndex: currentChar];\n          if (idx > -1)\n            [cssIdentifier appendString: cssEscapingStrings[idx]];\n          else\n            [cssIdentifier appendFormat: @\"%C\", currentChar];\n        }\n    }\n\n  return cssIdentifier;\n}\n\n- (int) _cssStringIndex: (NSString *) string\n{\n  int idx, count;\n\n  idx = -1;\n  for (count = 0; idx == -1 && count < cssEscapingCount; count++)\n    if ([string hasPrefix: *(cssEscapingStrings + count)])\n      idx = count;\n\n  return idx;\n}\n\n- (NSString *) fromCSSIdentifier\n{\n  NSCharacterSet *numericSet;\n  NSMutableString *newString;\n  NSString *currentString;\n  int count, length, max, idx;\n  unichar currentChar;\n\n  if (!cssEscapingStrings)\n    [self _setupCSSEscaping];\n\n  numericSet = [NSCharacterSet decimalDigitCharacterSet];\n  newString = [NSMutableString string];\n  max = [self length];\n  count = 0;\n\n  if (max > 0\n      && [self characterAtIndex: 0] == '_'\n      && [numericSet characterIsMember: [self characterAtIndex: 1]])\n    {\n      /* If the identifier starts with an underscore followed by a digit,\n         we remove the underscore */\n      count = 1;\n    }\n\n  for (; count < max - 2; count++)\n    {\n      currentChar = [self characterAtIndex: count];\n      if (currentChar == '_')\n        {\n          /* The difficulty here is that most escaping strings are 3 chars\n             long except one. Therefore we must juggle a little bit with the\n             lengths in order to avoid an overflow exception. */\n          length = 4;\n          if (count + length > max)\n            length = max - count;\n          currentString = [self substringFromRange: NSMakeRange (count, length)];\n          idx = [self _cssStringIndex: currentString];\n          if (idx > -1)\n            {\n              [newString appendFormat: @\"%C\", cssEscapingCharacters[idx]];\n              count += [cssEscapingStrings[idx] length] - 1;\n            }\n          else\n            [newString appendFormat: @\"%C\", currentChar];\n        }\n      else\n        [newString appendFormat: @\"%C\", currentChar];\n    }\n  currentString = [self substringFromRange: NSMakeRange (count, max - count)];\n  [newString appendString: currentString];\n\n  return newString;\n}\n\n- (NSString *) pureEMailAddress\n{\n  NSString *pureAddress;\n  NSRange delimiter;\n\n  delimiter = [self rangeOfString: @\"<\"];\n  if (delimiter.location == NSNotFound)\n    pureAddress = self;\n  else\n    {\n      pureAddress = [self substringFromIndex: NSMaxRange (delimiter)];\n      delimiter = [pureAddress rangeOfString: @\">\"];\n      if (delimiter.location != NSNotFound)\n\tpureAddress = [pureAddress substringToIndex: delimiter.location];\n    }\n\n  return pureAddress;\n}\n\n- (NSString *) asQPSubjectString: (NSString *) encoding\n{\n  return [NGMimeHeaderFieldGenerator encodeQuotedPrintableText: self];\n}\n\n- (BOOL) caseInsensitiveMatches: (NSString *) match\n{\n  EOQualifier *sq;\n  NSString *format;\n\n  format = [NSString stringWithFormat:\n\t\t       @\"(description isCaseInsensitiveLike: '%@')\",\n\t\t     match];\n  sq = [EOQualifier qualifierWithQualifierFormat: format];\n\n  return [(id<EOQualifierEvaluation>)sq evaluateWithObject: self];\n}\n\n//\n// To decompose the DN extracted from a SSL certificate\n// using the XN_FLAG_SEP_MULTILINE flag.\n//\n- (NSArray *) componentsFromMultilineDN\n{\n  NSArray *pair;\n  NSEnumerator *componentsEnum, *rdnComponentsEnum;\n  NSMutableArray *components;\n  NSString *component, *pairString;\n\n  components = [NSMutableArray array];\n  componentsEnum = [[self componentsSeparatedByString: @\"\\n\"] objectEnumerator];\n  while (( component = [componentsEnum nextObject] ))\n    {\n      rdnComponentsEnum = [[component componentsSeparatedByString: @\" + \"] objectEnumerator];\n      while (( pairString = [rdnComponentsEnum nextObject] ))\n        {\n          pair = [pairString componentsSeparatedByString: @\"=\"];\n          if ([pair count] == 2)\n            [components addObject: [NSArray arrayWithObjects:\n                                         [pair objectAtIndex: 0],\n                                         [pair objectAtIndex: 1], nil]];\n        }\n    }\n\n  return components;\n}\n\n#if LIB_FOUNDATION_LIBRARY\n- (BOOL) boolValue\n{\n  return !([self isEqualToString: @\"0\"]\n\t   || [self isEqualToString: @\"NO\"]);\n}\n#endif\n\n- (int) timeValue\n{\n  int \t\ttime;\n  NSInteger \ti;\n\n  if ([self length] > 0)\n    {\n      i = [self rangeOfString: @\":\"].location;\n      if (i == NSNotFound)\n\ttime = [self intValue];\n      else\n\ttime = [[self substringToIndex: i] intValue];\n    }\n  else\n    time = -1;\n\n  return time;\n}\n\n- (BOOL) isJSONString\n{\n  NSDictionary *jsonData;\n\n#warning this method is a quick and dirty way of detecting the file-format\n  jsonData = [self objectFromJSONString];\n\n  return (jsonData != nil);\n}\n\n- (id) objectFromJSONString\n{\n  SBJsonParser *parser;\n  NSArray *object;\n  NSError *error;\n  NSString *unescaped, *json;\n\n  object = nil;\n\n  if ([self length] > 0)\n    {\n      parser = [SBJsonParser new];\n      [parser autorelease];\n      error = nil;\n\n      /* Parse it this way so we can parse simple values, like \"null\" */\n      json = [NSString stringWithFormat: @\"[%@]\", self];\n      object = [parser objectWithString: json\n                                  error: &error];\n      if (error)\n        {\n          [self errorWithFormat: @\"json parser: %@,\"\n                @\" attempting once more after unescaping...\", error];\n          unescaped = [json stringByReplacingString: @\"\\\\\\\\\"\n                                         withString: @\"\\\\\"];\n          object = [parser objectWithString: unescaped\n                                      error: &error];\n          if (error)\n            {\n              [self errorWithFormat: @\"total failure. Original string is: %@\", self];\n              object = nil;\n            }\n          else\n            [self logWithFormat: @\"initial object deserialized successfully!\"];\n        }\n    }\n\n  return [object objectAtIndex: 0];\n}\n\n- (NSString *) asSafeSQLString\n{\n  return [[self stringByReplacingString: @\"\\\\\" withString: @\"\\\\\\\\\"]\n           stringByReplacingString: @\"'\" withString: @\"\\\\'\"];\n}\n\n- (NSString *) asSafeSQLLikeString\n{\n  return [[self asSafeSQLString] stringByReplacingString: @\"\\%\" withString: @\"\\\\%\"];\n}\n\n- (NSUInteger) countOccurrencesOfString: (NSString *) substring\n{\n  NSRange matchRange, substrRange;\n  BOOL done = NO;\n  NSUInteger selfLen, substrLen, count = 0;\n\n  selfLen = [self length];\n  substrLen = [substring length];\n\n  matchRange = NSMakeRange (0, selfLen);\n  while (!done && matchRange.length > 0)\n    {\n      substrRange = [self rangeOfString: substring options: 0 range: matchRange];\n      if (substrRange.location == NSNotFound)\n        done = YES;\n      else\n        {\n          count++;\n          matchRange.location = substrRange.location + 1;\n          if (matchRange.location + substrLen > selfLen)\n            done = YES;\n          else\n            matchRange.length = selfLen - matchRange.location;\n        }\n    }\n\n  return count;\n}\n\n- (NSString *) stringByReplacingPrefix: (NSString *) oldPrefix\n                            withPrefix: (NSString *) newPrefix\n{\n  NSUInteger oldPrefixLength;\n  NSString *newString;\n\n  if (![self hasPrefix: oldPrefix])\n    [NSException raise: NSInvalidArgumentException\n                format: @\"string does not have the specified prefix\"];\n\n  oldPrefixLength = [oldPrefix length];\n  newString = [NSString stringWithFormat: @\"%@%@\",\n                        newPrefix,\n                [self substringFromIndex: oldPrefixLength]];\n\n  return newString;\n}\n\n- (NSString *) encryptWithKey: (NSString *) theKey\n{\n  NSMutableData *encryptedPassword;\n  NSMutableString *key;\n  NSString *result;\n  NSUInteger i, passLength, theKeyLength, keyLength;\n  unichar p, k, e;\n\n  if ([theKey length] > 0)\n    {\n      // The length of the key must be greater (or equal) than\n      // the length of the password\n      key = [NSMutableString string];\n      keyLength = 0;\n\n      passLength = [self length];\n      theKeyLength = [theKey length];\n      while (keyLength < passLength)\n        {\n          [key appendString: theKey];\n          keyLength += theKeyLength;\n        }\n\n      encryptedPassword = [NSMutableData data];\n      for (i = 0; i < passLength; i++)\n        {\n          p = [self characterAtIndex: i];\n          k = [key characterAtIndex: i];\n          e = p ^ k;\n          [encryptedPassword appendBytes: (void *)&e length: 2];\n        }\n\n      result = [encryptedPassword stringByEncodingBase64];\n    }\n  else\n    result = nil;\n\n  return result;\n}\n\n- (NSString *) decryptWithKey: (NSString *) theKey\n{\n  NSMutableString *result;\n  NSMutableString *key;\n  NSData *decoded;\n  unichar *decryptedPassword;\n  NSUInteger i, theKeyLength, keyLength, decodedLength;\n  unichar p, k;\n\n  if ([theKey length] > 0)\n    {\n      decoded = [self dataByDecodingBase64];\n      decryptedPassword = (unichar *)[decoded bytes];\n\n      // The length of the key must be greater (or equal) than\n      // the length of the password\n      key = [NSMutableString string];\n      keyLength = 0;\n      decodedLength = ([decoded length] / 2); /* 1 unichar = 2 bytes/char */\n      theKeyLength = [theKey length];\n\n      while (keyLength < decodedLength)\n        {\n          [key appendString: theKey];\n          keyLength += theKeyLength;\n        }\n\n      result = [NSMutableString string];\n      for (i = 0; i < decodedLength; i++)\n        {\n          k = [key characterAtIndex: i];\n          p = decryptedPassword[i] ^ k;\n          [result appendFormat: @\"%C\", p];\n        }\n    }\n  else\n    result = nil;\n\n  return result;\n}\n\n/**\n * Get the safe string avoiding HTML injection\n * @param stripHTMLCode Remove all HTML code from content\n * @return A safe string\n */\n- (NSString *) stringWithoutHTMLInjection: (BOOL)stripHTMLCode\n{\n  NSString *result, *text;\n  NSScanner *theScanner;\n  NSError *error;\n\n  text = nil;\n  error = nil;\n  result = [NSString stringWithString: self];\n\n  if (stripHTMLCode) {\n    // Author : https://www.codercrunch.com/question/1251681838/how-remove-html-tags-string-ios\n    theScanner = [NSScanner scannerWithString: result];\n    while ([theScanner isAtEnd] == NO) {\n      // find start of tag\n      [theScanner scanUpToString: @\"<\" intoString: NULL];\n      // find end of tag\n      [theScanner scanUpToString: @\">\" intoString: &text];\n      // replace the found tag with a space\n      //(you can filter multi-spaces out later if you wish)\n      result = [result stringByReplacingOccurrencesOfString:\n              [NSString stringWithFormat: @\"%@>\", text]\n              withString: @\" \"];\n    } \n  } else {\n    // Clean XSS\n    // Examples of injection : https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html#xss-locator-polygot\n\n    // NSRegularExpression is not implemented in old GNUStep versions (ubuntu trusty)\n    if (NSClassFromString(@\"NSRegularExpression\")) {\n      NSRegularExpression *regex = nil;\n\n      // Remove javascript:\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"j[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*a[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*v[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*a[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*s[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*c[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*p[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*t[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*:\"\n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"\"];\n\n      // Remove vbscript:\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"v[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*b[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*s[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*p[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*t[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*:\"\n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"\"];\n\n      // Remove livescript:\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"l[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*v[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*e[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*s[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*c[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*p[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*t[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*:\"\n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"\"];\n\n      // Remove <script\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"<[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*s[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*c[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*p[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*t\" \n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"<scr***\"];\n\n      // Remove </script\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"<[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*/[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*s[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*c[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*p[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*t\" \n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"</scr***\"];\n\n      // Remove <iframe\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"<[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*f[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*a[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*m[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*e\" \n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"<ifr***\"];\n\n      // Remove onload\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"onload=\" \n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"onl***=\"];\n\n      // Remove onmouseover\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"onmouseover=\" \n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"onmouseo***=\"];\n    }\n  }  \n  \n  return result;\n}\n\n@end\n"], "fixing_code": ["/* NSString+Utilities.m - this file is part of SOGo\n *\n * Copyright (C) 2006-2022 Inverse inc.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; see the file COPYING.  If not, write to\n * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n\n#import <EOControl/EOQualifier.h>\n\n#import <NGExtensions/NSDictionary+misc.h>\n#import <NGExtensions/NSObject+Logs.h>\n#import <NGExtensions/NGBase64Coding.h>\n\n#import <NGMime/NGMimeHeaderFieldGenerator.h>\n#import <SBJson/SBJsonParser.h>\n\n#import \"NSArray+Utilities.h\"\n#import \"NSDictionary+URL.h\"\n\n#import \"NSString+Utilities.h\"\n\nstatic NSMutableCharacterSet *urlNonEndingChars = nil;\nstatic NSMutableCharacterSet *urlAfterEndingChars = nil;\nstatic NSMutableCharacterSet *schemaStartChars = nil;\nstatic NSMutableCharacterSet *emailStartChars = nil;\n\nstatic NSMutableCharacterSet *jsonEscapingChars = NULL;\nstatic NSString **cssEscapingStrings = NULL;\nstatic unichar *cssEscapingCharacters = NULL;\nstatic int cssEscapingCount;\n\n@implementation NSString (SOGoURLExtension)\n\n- (NSString *) composeURLWithAction: (NSString *) action\n                         parameters: (NSDictionary *) urlParameters\n                            andHash: (BOOL) useHash\n{\n  NSMutableString *completeURL;\n\n  completeURL = [NSMutableString new];\n  [completeURL autorelease];\n\n  [completeURL appendString: [self urlWithoutParameters]];\n  if (![completeURL hasSuffix: @\"/\"])\n    [completeURL appendString: @\"/\"];\n  [completeURL appendString: action];\n  if (urlParameters)\n    [completeURL appendString: [urlParameters asURLParameters]];\n  if (useHash)\n    [completeURL appendString: @\"#\"];\n\n  return completeURL;\n}\n\n- (NSString *) hostlessURL\n{\n  NSString *newURL;\n  NSRange hostR, locationR;\n\n  if ([self hasPrefix: @\"/\"])\n    {\n      newURL = [self copy];\n      [newURL autorelease];\n    }\n  else\n    {\n      hostR = [self rangeOfString: @\"://\"];\n      locationR = [[self substringFromIndex: (hostR.location + hostR.length)] rangeOfString: @\"/\"];\n      newURL = [self substringFromIndex: (hostR.location + hostR.length + locationR.location)];\n    }\n\n  return newURL;\n}\n\n- (NSString *) urlWithoutParameters;\n{\n  NSRange r;\n  NSString *newUrl;\n\n  r = [self rangeOfString:@\"?\" options: NSBackwardsSearch];\n  if (r.length > 0)\n    newUrl = [self substringToIndex: NSMaxRange (r) - 1];\n  else\n    newUrl = self;\n\n  return newUrl;\n}\n\n- (NSRange) _rangeOfURLInRange: (NSRange) refRange\n               withPrefixChars: (NSCharacterSet *) startChars\n{\n  int start, length;\n  NSRange workRange;\n\n  start = refRange.location;\n  if (start > 0)\n    start--; // Start with the character before the refRange\n  while (start > -1\n         && [startChars characterIsMember:\n                   [self characterAtIndex: start]])\n    start--;\n  start++;\n\n  length = [self length];\n  // In [UIxMailPartTextViewer flatContentAsString], we first escape HTML entities and then\n  // add URLs. Therefore, the brackets (inequality signs <>) have been encoded at this point.\n  if (length > (start + 4)\n      && [[self substringWithRange: NSMakeRange (start, 4)] compare: @\"&lt;\"] == NSOrderedSame)\n    start += 4;\n\n  length -= start;\n  workRange = [self rangeOfCharacterFromSet: urlAfterEndingChars\n                                    options: NSLiteralSearch range: NSMakeRange (start, length)];\n  if (workRange.location != NSNotFound)\n    length = workRange.location - start;\n  while\n    (length > 0\n     && [urlNonEndingChars characterIsMember:\n                      [self characterAtIndex: (start + length - 1)]])\n    length--;\n\n  // Remove trailing \">\"\n  if (([self length] >= start + length + 1)\n      && [[self substringWithRange: NSMakeRange (start, length + 1)] hasSuffix: @\"&gt;\"])\n    length -= 3;\n\n  return NSMakeRange (start, length);\n}\n\n- (void) _handleURLs: (NSMutableString *) selfCopy\n         textToMatch: (NSString *) match\n      urlPrefixChars: (NSCharacterSet *) startChars\n              prefix: (NSString *) prefix\n            inRanges: (NSMutableArray *) ranges\n{\n  NSEnumerator *enumRanges;\n  NSMutableArray *newRanges;\n  NSRange matchRange, currentUrlRange, rest;\n  NSRange *rangePtr;\n  NSString *urlText, *newUrlText;\n  unsigned int length, matchLength, offset;\n\n  newRanges = [NSMutableArray array];\n  matchLength = [match length];\n\n  matchRange = [selfCopy rangeOfString: match];\n  while (matchRange.location != NSNotFound)\n    {\n      currentUrlRange = [selfCopy _rangeOfURLInRange: matchRange\n                                     withPrefixChars: startChars];\n      if (![ranges hasRangeIntersection: currentUrlRange])\n        if (currentUrlRange.length > matchLength)\n          [newRanges addNonNSObject: &currentUrlRange\n                           withSize: sizeof (NSRange)\n                               copy: YES];\n      rest.location = NSMaxRange (currentUrlRange);\n      length = [selfCopy length];\n      rest.length = length - rest.location;\n      matchRange = [selfCopy rangeOfString: match\n                                   options: 0 range: rest];\n    }\n\n  // Make the substitutions, keep track of the new offset\n  offset = 0;\n  enumRanges = [newRanges objectEnumerator];\n  while ((rangePtr = [[enumRanges nextObject] pointerValue]))\n    {\n      rangePtr->location += offset;\n      urlText = [selfCopy substringFromRange: *rangePtr];\n      newUrlText = [NSString stringWithFormat: @\"<a rel=\\\"noopener\\\" href=\\\"%@%@\\\">%@</a>\",\n                          ([urlText hasPrefix: prefix]? @\"\" : prefix),\n                             urlText, urlText];\n      [selfCopy replaceCharactersInRange: *rangePtr\n                              withString: newUrlText];\n      offset += ([newUrlText length] - [urlText length]);\n\n      // Add range for further substitutions\n      currentUrlRange = NSMakeRange (rangePtr->location, [newUrlText length]);\n      [ranges addNonNSObject: &currentUrlRange\n                    withSize: sizeof (NSRange)\n                        copy: YES];\n    }\n  [newRanges freeNonNSObjects];\n}\n\n- (NSString *) stringByDetectingURLs\n{\n  NSMutableString *selfCopy;\n  NSMutableArray *ranges;\n\n  if (!urlNonEndingChars)\n    {\n      urlNonEndingChars = [NSMutableCharacterSet new];\n      [urlNonEndingChars addCharactersInString: @\"=,.:;&()>\\t \\r\\n\"];\n    }\n  if (!urlAfterEndingChars)\n    {\n      urlAfterEndingChars = [NSMutableCharacterSet new];\n      [urlAfterEndingChars addCharactersInString: @\"()[]\\t \\r\\n\"];\n    }\n  if (!schemaStartChars)\n    {\n      schemaStartChars = [NSMutableCharacterSet new];\n      [schemaStartChars addCharactersInString: @\"abcdefghijklmnopqrstuvwxyz\"\n                        @\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"];\n    }\n  if (!emailStartChars)\n    {\n      emailStartChars = [NSMutableCharacterSet new];\n      [emailStartChars addCharactersInString: @\"abcdefghijklmnopqrstuvwxyz\"\n                       @\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                       @\"01234567890\"\n                       @\"!#$%&'*+-/=?^`{|}~.\"];\n    }\n\n  ranges = [NSMutableArray array];\n  selfCopy = [NSMutableString stringWithString: self];\n  [self _handleURLs: selfCopy\n        textToMatch: @\"://\"\n     urlPrefixChars: schemaStartChars\n             prefix: @\"\"\n           inRanges: ranges];\n  [self _handleURLs: selfCopy\n        textToMatch: @\"@\"\n     urlPrefixChars: emailStartChars\n             prefix: @\"mailto:\"\n           inRanges: ranges];\n  [ranges freeNonNSObjects];\n\n  return selfCopy;\n}\n\n- (NSString *) asSafeJSString\n{\n  NSRange esc;\n\n  if (!jsonEscapingChars)\n    {\n      jsonEscapingChars = [[NSMutableCharacterSet characterSetWithRange: NSMakeRange(0,32)] retain];\n      [jsonEscapingChars addCharactersInString: @\"\\\"\\\\\"];\n    }\n\n  esc = [self rangeOfCharacterFromSet: jsonEscapingChars];\n  if (!esc.length)\n    {\n      // No special chars\n      return self;\n    }\n  else\n    {\n      NSMutableString *representation;\n      NSUInteger length, i;\n      unichar uc;\n\n      representation = [NSMutableString string];\n\n      length = [self length];\n      for (i = 0; i < length; i++)\n        {\n          uc = [self characterAtIndex:i];\n          switch (uc)\n            {\n            case '\"':   [representation appendString:@\"\\\\\\\"\"];  break;\n            case '\\\\':  [representation appendString:@\"\\\\\\\\\"];  break;\n            case '\\t':  [representation appendString:@\"\\\\t\"];   break;\n            case '\\n':  [representation appendString:@\"\\\\n\"];   break;\n            case '\\r':  [representation appendString:@\"\\\\r\"];   break;\n            case '\\b':  [representation appendString:@\"\\\\b\"];   break;\n            case '\\f':  [representation appendString:@\"\\\\f\"];   break;\n            default:\n              if (uc < 0x20)\n                [representation appendFormat:@\"\\\\u%04x\", uc];\n              else\n                [representation appendFormat: @\"%C\", uc];\n              break;\n            }\n        }\n      return representation;\n    }\n}\n\n- (NSString *) doubleQuotedString\n{\n  return [NSString stringWithFormat: @\"\\\"%@\\\"\", [self asSafeJSString]];\n}\n\n//\n// See http://www.hackcraft.net/xmlUnicode/\n//\n// XML1.0 and XML1.1 allow different characters in different contexts,\n// but for the most part I will only describe the XML1.0 usage, XML1.1\n// usage is analogous.  The first definition that is relevant here is\n// that of a Char: [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] |\n// [#xE000-#xFFFD] | [#x10000-#x10FFFF] /* any Unicode character,\n// excluding the surrogate blocks, FFFE, and FFFF. */\n//\n// This defines which characters can be used in an XML1.0 document. It\n// is clearly very liberal, banning only some of the control\n// characters and the noncharacters U+FFFE and U+FFFF.  Indeed it is\n// somewhat too liberal in my view since it allows other noncharacters\n// (the code points from U+FDD0 to U+FDEF inclusive and the last 2\n// code points in each plane, from U+1FFFE & U+1FFFF through to\n// U+10FFFE & U+10FFFF, are noncharacters) but the production quoted\n// above allows them.\n//\n- (NSString *) safeString\n{\n  NSData *data;\n  NSString *s;\n\n  const wchar_t *buf;\n  wchar_t *start, c;\n  int len, i, j;\n\n  data = [self dataUsingEncoding: NSUTF32LittleEndianStringEncoding];\n  len = [data length];\n  buf = [data bytes];\n  start = (wchar_t *)calloc(len, sizeof(wchar_t));\n\n  for (i = 0, j = 0; i < len/4; i++)\n    {\n      c = buf[i];\n\n      if (c == 0x0 ||\n          c == 0x9 ||\n          c == 0xA ||\n          (c >= 0x20 && c < 0x300) || // Skip combining diacritical marks\n          (c > 0x36F && c < 0xD7FF) ||\n          (c >= 0xE000 && c < 0xFE00) || // Skip variation selectors\n          (c > 0xFE0F && c <= 0xFFFD) ||\n          (c >= (wchar_t)0x10000 && c <= (wchar_t)0x10FFFF))\n        {\n          start[j] = c;\n          j++;\n        }\n    }\n\n  s = [[NSString alloc] initWithBytesNoCopy: start  length: j*sizeof(wchar_t)  encoding: NSUTF32LittleEndianStringEncoding  freeWhenDone: YES];\n\n  return AUTORELEASE(s);\n}\n\n- (NSString *) safeStringByEscapingXMLString\n{\n  return [self safeStringByEscapingXMLString: NO];\n}\n//\n// This is a copy from NSString+XMLEscaping.m from SOPE.\n// The difference here is that we use wchar_t instead of unichar.\n// This is needed to get the rigth numeric character reference.\n// e.g. SMILING FACE WITH OPEN MOUTH\n//      ok: wchar_t -> &#128515;   wrong:  unichar -> &#55357; &#56835;\n//\n// We avoid naming it like the one in SOPE since if the ActiveSync\n// bundle is loaded, it'll overwrite the one provided by SOPE.\n//\n- (NSString *) safeStringByEscapingXMLString: (BOOL) encodeCR\n{\n  NSData *data;\n\n  register unsigned i, len, j;\n  register wchar_t *buf;\n  const wchar_t *chars;\n  unsigned escapeCount;\n\n  if ([self length] == 0) return @\"\";\n\n  data = [self dataUsingEncoding: NSUTF32LittleEndianStringEncoding];\n  chars = [data bytes];\n  len = [data length]/4;\n\n  /* check for characters to escape ... */\n  for (i = 0, escapeCount = 0; i < len; i++)\n    {\n      switch (chars[i]) {\n      case '&': case '\"': case '<': case '>': case '\\r':\n        escapeCount++;\n        break;\n      default:\n        if (chars[i] < 0x20 || chars[i] > 127)\n          escapeCount++;\n        break;\n      }\n    }\n\n  /* nothing to escape ... */\n  if (escapeCount == 0 )\n    return [[self copy] autorelease];\n\n  buf = calloc((len + 5) + (escapeCount * 16), sizeof(wchar_t));\n  for (i = 0, j = 0; i < len; i++)\n    {\n      switch (chars[i])\n        {\n          /* escape special chars */\n        case '&':\n          buf[j] = '&'; j++; buf[j] = 'a'; j++; buf[j] = 'm'; j++;\n          buf[j] = 'p'; j++; buf[j] = ';'; j++;\n          break;\n        case '\"':\n          buf[j] = '&'; j++; buf[j] = 'q'; j++; buf[j] = 'u'; j++;\n          buf[j] = 'o'; j++; buf[j] = 't'; j++; buf[j] = ';'; j++;\n          break;\n        case '<':\n          buf[j] = '&'; j++; buf[j] = 'l'; j++; buf[j] = 't'; j++;\n          buf[j] = ';'; j++;\n          break;\n        case '>':\n          buf[j] = '&'; j++; buf[j] = 'g'; j++; buf[j] = 't'; j++;\n          buf[j] = ';'; j++;\n          break;\n        case '\\r':\n          if (encodeCR) // falls back to default if we don't encode\n            {\n              buf[j] = '&'; j++; buf[j] = '#'; j++; buf[j] = '1'; j++;\n              buf[j] = '3'; j++; buf[j] = ';'; j++;\n              break;\n            }\n        default:\n          /* escape big chars */\n          if (chars[i] > 127)\n            {\n              unsigned char nbuf[32];\n              unsigned int k;\n\n              sprintf((char *)nbuf, \"&#%i;\", (int)chars[i]);\n              for (k = 0; nbuf[k] != '\\0'; k++)\n                {\n                  buf[j] = nbuf[k];\n                  j++;\n                }\n            }\n          else if (chars[i] == 0x9 || chars[i] == 0xA || chars[i] == 0xD || chars[i] >= 0x20)\n            { // ignore any unsupported control character\n              /* nothing to escape */\n              buf[j] = chars[i];\n              j++;\n            }\n          break;\n        }\n    }\n\n  self = [[NSString alloc] initWithBytesNoCopy: buf\n                                        length: (j*sizeof(wchar_t))\n                                      encoding: NSUTF32LittleEndianStringEncoding\n                                  freeWhenDone: YES];\n  return [self autorelease];\n}\n\n- (NSString *) jsonRepresentation\n{\n  NSString *cleanedString;\n\n  // Escape double quotes and remove control characters\n  cleanedString = [[self safeString] doubleQuotedString];\n  return cleanedString;\n}\n\n- (void) _setupCSSEscaping\n{\n  NSArray *strings, *characters;\n  int count;\n\n  strings = [NSArray arrayWithObjects: @\"_U_\", @\"_D_\", @\"_H_\", @\"_A_\", @\"_S_\",\n                     @\"_C_\", @\"_SC_\",\n                     @\"_CO_\", @\"_SP_\", @\"_SQ_\", @\"_DQ_\",\n                     @\"_LP_\", @\"_RP_\", @\"_LS_\", @\"_RS_\", @\"_LC_\", @\"_RC_\",\n                     @\"_AM_\", @\"_P_\", @\"_DS_\", nil];\n  [strings retain];\n  cssEscapingStrings = [strings asPointersOfObjects];\n\n  characters = [NSArray arrayWithObjects: @\"_\", @\".\", @\"#\", @\"@\", @\"*\",\n                        @\":\", @\";\",\n                        @\",\", @\" \", @\"'\", @\"\\\"\",\n                        @\"(\", @\")\", @\"[\", @\"]\", @\"{\", @\"}\",\n                        @\"&\", @\"+\", @\"$\", nil];\n  cssEscapingCount = [strings count];\n  cssEscapingCharacters = NSZoneMalloc (NULL,\n                                        (cssEscapingCount + 1)\n                                        * sizeof (unichar));\n  for (count = 0; count < cssEscapingCount; count++)\n    *(cssEscapingCharacters + count) = [[characters objectAtIndex: count] characterAtIndex: 0];\n  *(cssEscapingCharacters + cssEscapingCount) = 0;\n}\n\n- (int) _cssCharacterIndex: (unichar) character\n{\n  int idx, count;\n\n  idx = -1;\n  for (count = 0; idx == -1 && count < cssEscapingCount; count++)\n    if (*(cssEscapingCharacters + count) == character)\n      idx = count;\n\n  return idx;\n}\n\n- (NSString *) asCSSIdentifier\n{\n  NSCharacterSet *numericSet;\n  NSMutableString *cssIdentifier;\n  unichar currentChar;\n  int count, max, idx;\n\n  if (!cssEscapingStrings)\n    [self _setupCSSEscaping];\n\n  cssIdentifier = [NSMutableString string];\n  numericSet = [NSCharacterSet decimalDigitCharacterSet];\n  max = [self length];\n\n  if (max > 0)\n    {\n      if ([numericSet characterIsMember: [self characterAtIndex: 0]])\n        // A CSS identifier can't start with a digit; we add an underscore\n        [cssIdentifier appendString: @\"_\"];\n      for (count = 0; count < max; count++)\n        {\n          currentChar = [self characterAtIndex: count];\n          idx = [self _cssCharacterIndex: currentChar];\n          if (idx > -1)\n            [cssIdentifier appendString: cssEscapingStrings[idx]];\n          else\n            [cssIdentifier appendFormat: @\"%C\", currentChar];\n        }\n    }\n\n  return cssIdentifier;\n}\n\n- (int) _cssStringIndex: (NSString *) string\n{\n  int idx, count;\n\n  idx = -1;\n  for (count = 0; idx == -1 && count < cssEscapingCount; count++)\n    if ([string hasPrefix: *(cssEscapingStrings + count)])\n      idx = count;\n\n  return idx;\n}\n\n- (NSString *) fromCSSIdentifier\n{\n  NSCharacterSet *numericSet;\n  NSMutableString *newString;\n  NSString *currentString;\n  int count, length, max, idx;\n  unichar currentChar;\n\n  if (!cssEscapingStrings)\n    [self _setupCSSEscaping];\n\n  numericSet = [NSCharacterSet decimalDigitCharacterSet];\n  newString = [NSMutableString string];\n  max = [self length];\n  count = 0;\n\n  if (max > 0\n      && [self characterAtIndex: 0] == '_'\n      && [numericSet characterIsMember: [self characterAtIndex: 1]])\n    {\n      /* If the identifier starts with an underscore followed by a digit,\n         we remove the underscore */\n      count = 1;\n    }\n\n  for (; count < max - 2; count++)\n    {\n      currentChar = [self characterAtIndex: count];\n      if (currentChar == '_')\n        {\n          /* The difficulty here is that most escaping strings are 3 chars\n             long except one. Therefore we must juggle a little bit with the\n             lengths in order to avoid an overflow exception. */\n          length = 4;\n          if (count + length > max)\n            length = max - count;\n          currentString = [self substringFromRange: NSMakeRange (count, length)];\n          idx = [self _cssStringIndex: currentString];\n          if (idx > -1)\n            {\n              [newString appendFormat: @\"%C\", cssEscapingCharacters[idx]];\n              count += [cssEscapingStrings[idx] length] - 1;\n            }\n          else\n            [newString appendFormat: @\"%C\", currentChar];\n        }\n      else\n        [newString appendFormat: @\"%C\", currentChar];\n    }\n  currentString = [self substringFromRange: NSMakeRange (count, max - count)];\n  [newString appendString: currentString];\n\n  return newString;\n}\n\n- (NSString *) pureEMailAddress\n{\n  NSString *pureAddress;\n  NSRange delimiter;\n\n  delimiter = [self rangeOfString: @\"<\"];\n  if (delimiter.location == NSNotFound)\n    pureAddress = self;\n  else\n    {\n      pureAddress = [self substringFromIndex: NSMaxRange (delimiter)];\n      delimiter = [pureAddress rangeOfString: @\">\"];\n      if (delimiter.location != NSNotFound)\n\tpureAddress = [pureAddress substringToIndex: delimiter.location];\n    }\n\n  return pureAddress;\n}\n\n- (NSString *) asQPSubjectString: (NSString *) encoding\n{\n  return [NGMimeHeaderFieldGenerator encodeQuotedPrintableText: self];\n}\n\n- (BOOL) caseInsensitiveMatches: (NSString *) match\n{\n  EOQualifier *sq;\n  NSString *format;\n\n  format = [NSString stringWithFormat:\n\t\t       @\"(description isCaseInsensitiveLike: '%@')\",\n\t\t     match];\n  sq = [EOQualifier qualifierWithQualifierFormat: format];\n\n  return [(id<EOQualifierEvaluation>)sq evaluateWithObject: self];\n}\n\n//\n// To decompose the DN extracted from a SSL certificate\n// using the XN_FLAG_SEP_MULTILINE flag.\n//\n- (NSArray *) componentsFromMultilineDN\n{\n  NSArray *pair;\n  NSEnumerator *componentsEnum, *rdnComponentsEnum;\n  NSMutableArray *components;\n  NSString *component, *pairString;\n\n  components = [NSMutableArray array];\n  componentsEnum = [[self componentsSeparatedByString: @\"\\n\"] objectEnumerator];\n  while (( component = [componentsEnum nextObject] ))\n    {\n      rdnComponentsEnum = [[component componentsSeparatedByString: @\" + \"] objectEnumerator];\n      while (( pairString = [rdnComponentsEnum nextObject] ))\n        {\n          pair = [pairString componentsSeparatedByString: @\"=\"];\n          if ([pair count] == 2)\n            [components addObject: [NSArray arrayWithObjects:\n                                         [pair objectAtIndex: 0],\n                                         [pair objectAtIndex: 1], nil]];\n        }\n    }\n\n  return components;\n}\n\n#if LIB_FOUNDATION_LIBRARY\n- (BOOL) boolValue\n{\n  return !([self isEqualToString: @\"0\"]\n\t   || [self isEqualToString: @\"NO\"]);\n}\n#endif\n\n- (int) timeValue\n{\n  int \t\ttime;\n  NSInteger \ti;\n\n  if ([self length] > 0)\n    {\n      i = [self rangeOfString: @\":\"].location;\n      if (i == NSNotFound)\n\ttime = [self intValue];\n      else\n\ttime = [[self substringToIndex: i] intValue];\n    }\n  else\n    time = -1;\n\n  return time;\n}\n\n- (BOOL) isJSONString\n{\n  NSDictionary *jsonData;\n\n#warning this method is a quick and dirty way of detecting the file-format\n  jsonData = [self objectFromJSONString];\n\n  return (jsonData != nil);\n}\n\n- (id) objectFromJSONString\n{\n  SBJsonParser *parser;\n  NSArray *object;\n  NSError *error;\n  NSString *unescaped, *json;\n\n  object = nil;\n\n  if ([self length] > 0)\n    {\n      parser = [SBJsonParser new];\n      [parser autorelease];\n      error = nil;\n\n      /* Parse it this way so we can parse simple values, like \"null\" */\n      json = [NSString stringWithFormat: @\"[%@]\", self];\n      object = [parser objectWithString: json\n                                  error: &error];\n      if (error)\n        {\n          [self errorWithFormat: @\"json parser: %@,\"\n                @\" attempting once more after unescaping...\", error];\n          unescaped = [json stringByReplacingString: @\"\\\\\\\\\"\n                                         withString: @\"\\\\\"];\n          object = [parser objectWithString: unescaped\n                                      error: &error];\n          if (error)\n            {\n              [self errorWithFormat: @\"total failure. Original string is: %@\", self];\n              object = nil;\n            }\n          else\n            [self logWithFormat: @\"initial object deserialized successfully!\"];\n        }\n    }\n\n  return [object objectAtIndex: 0];\n}\n\n- (NSString *) asSafeSQLString\n{\n  return [[self stringByReplacingString: @\"\\\\\" withString: @\"\\\\\\\\\"]\n           stringByReplacingString: @\"'\" withString: @\"\\\\'\"];\n}\n\n- (NSString *) asSafeSQLLikeString\n{\n  return [[self asSafeSQLString] stringByReplacingString: @\"\\%\" withString: @\"\\\\%\"];\n}\n\n- (NSUInteger) countOccurrencesOfString: (NSString *) substring\n{\n  NSRange matchRange, substrRange;\n  BOOL done = NO;\n  NSUInteger selfLen, substrLen, count = 0;\n\n  selfLen = [self length];\n  substrLen = [substring length];\n\n  matchRange = NSMakeRange (0, selfLen);\n  while (!done && matchRange.length > 0)\n    {\n      substrRange = [self rangeOfString: substring options: 0 range: matchRange];\n      if (substrRange.location == NSNotFound)\n        done = YES;\n      else\n        {\n          count++;\n          matchRange.location = substrRange.location + 1;\n          if (matchRange.location + substrLen > selfLen)\n            done = YES;\n          else\n            matchRange.length = selfLen - matchRange.location;\n        }\n    }\n\n  return count;\n}\n\n- (NSString *) stringByReplacingPrefix: (NSString *) oldPrefix\n                            withPrefix: (NSString *) newPrefix\n{\n  NSUInteger oldPrefixLength;\n  NSString *newString;\n\n  if (![self hasPrefix: oldPrefix])\n    [NSException raise: NSInvalidArgumentException\n                format: @\"string does not have the specified prefix\"];\n\n  oldPrefixLength = [oldPrefix length];\n  newString = [NSString stringWithFormat: @\"%@%@\",\n                        newPrefix,\n                [self substringFromIndex: oldPrefixLength]];\n\n  return newString;\n}\n\n- (NSString *) encryptWithKey: (NSString *) theKey\n{\n  NSMutableData *encryptedPassword;\n  NSMutableString *key;\n  NSString *result;\n  NSUInteger i, passLength, theKeyLength, keyLength;\n  unichar p, k, e;\n\n  if ([theKey length] > 0)\n    {\n      // The length of the key must be greater (or equal) than\n      // the length of the password\n      key = [NSMutableString string];\n      keyLength = 0;\n\n      passLength = [self length];\n      theKeyLength = [theKey length];\n      while (keyLength < passLength)\n        {\n          [key appendString: theKey];\n          keyLength += theKeyLength;\n        }\n\n      encryptedPassword = [NSMutableData data];\n      for (i = 0; i < passLength; i++)\n        {\n          p = [self characterAtIndex: i];\n          k = [key characterAtIndex: i];\n          e = p ^ k;\n          [encryptedPassword appendBytes: (void *)&e length: 2];\n        }\n\n      result = [encryptedPassword stringByEncodingBase64];\n    }\n  else\n    result = nil;\n\n  return result;\n}\n\n- (NSString *) decryptWithKey: (NSString *) theKey\n{\n  NSMutableString *result;\n  NSMutableString *key;\n  NSData *decoded;\n  unichar *decryptedPassword;\n  NSUInteger i, theKeyLength, keyLength, decodedLength;\n  unichar p, k;\n\n  if ([theKey length] > 0)\n    {\n      decoded = [self dataByDecodingBase64];\n      decryptedPassword = (unichar *)[decoded bytes];\n\n      // The length of the key must be greater (or equal) than\n      // the length of the password\n      key = [NSMutableString string];\n      keyLength = 0;\n      decodedLength = ([decoded length] / 2); /* 1 unichar = 2 bytes/char */\n      theKeyLength = [theKey length];\n\n      while (keyLength < decodedLength)\n        {\n          [key appendString: theKey];\n          keyLength += theKeyLength;\n        }\n\n      result = [NSMutableString string];\n      for (i = 0; i < decodedLength; i++)\n        {\n          k = [key characterAtIndex: i];\n          p = decryptedPassword[i] ^ k;\n          [result appendFormat: @\"%C\", p];\n        }\n    }\n  else\n    result = nil;\n\n  return result;\n}\n\n/**\n * Get the safe string avoiding HTML injection\n * @param stripHTMLCode Remove all HTML code from content\n * @return A safe string\n */\n- (NSString *) stringWithoutHTMLInjection: (BOOL)stripHTMLCode\n{\n  // NSRegularExpression is not implemented in old GNUStep versions (ubuntu trusty)\n  if (NSClassFromString(@\"NSRegularExpression\")) {\n    NSString *result, *text;\n    NSScanner *theScanner;\n    NSError *error;\n    NSUInteger numberOfMatches;\n    NSRegularExpression *regex;\n\n    text = nil;\n    error = nil;\n    result = [NSString stringWithString: self];\n    regex = nil;\n\n    if (stripHTMLCode) {\n      // Author : https://www.codercrunch.com/question/1251681838/how-remove-html-tags-string-ios\n      theScanner = [NSScanner scannerWithString: result];\n      while ([theScanner isAtEnd] == NO) {\n        // find start of tag\n        [theScanner scanUpToString: @\"<\" intoString: NULL];\n        // find end of tag\n        [theScanner scanUpToString: @\">\" intoString: &text];\n        \n        // Check that text is not <xxx@xx.net\n        regex = [NSRegularExpression regularExpressionWithPattern:@\"^<[a-zA-Z.\\\\-_]+@[a-zA-Z.\\\\-_]+.[a-zA-Z]+$\"\n                                    options: NSRegularExpressionCaseInsensitive error:&error];\n        numberOfMatches = 0;\n        \n        if (text && !error) {\n          numberOfMatches = [regex numberOfMatchesInString: text \n                                                      options:0 \n                                                      range:NSMakeRange(0, [text length])];\n          if (0 == numberOfMatches) {\n            // replace the found tag with a space\n            //(you can filter multi-spaces out later if you wish)\n            result = [result stringByReplacingOccurrencesOfString:\n                    [NSString stringWithFormat: @\"%@>\", text]\n                    withString: @\" \"];\n          }\n        }\n      } \n    } else {\n      // Clean XSS\n      // Examples of injection : https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html#xss-locator-polygot\n\n      // Remove javascript:\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"j[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*a[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*v[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*a[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*s[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*c[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*p[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*t[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*:\"\n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"\"];\n\n      // Remove vbscript:\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"v[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*b[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*s[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*p[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*t[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*:\"\n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"\"];\n\n      // Remove livescript:\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"l[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*v[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*e[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*s[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*c[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*p[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*t[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*:\"\n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"\"];\n\n      // Remove <script\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"<[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*s[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*c[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*p[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*t\" \n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"<scr***\"];\n\n      // Remove </script\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"<[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*/[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*s[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*c[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*p[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*t\" \n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"</scr***\"];\n\n      // Remove <iframe\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"<[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*i[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*f[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*r[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*a[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*m[\\\\s\\\\u200B&#x09;&#x0A;&#x0D;\\\\\\\\0]*e\" \n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"<ifr***\"];\n\n      // Remove onload\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"onload=\" \n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"onl***=\"];\n\n      // Remove onmouseover\n      regex = [NSRegularExpression regularExpressionWithPattern:@\"onmouseover=\" \n                                  options: NSRegularExpressionCaseInsensitive error:&error];\n      result = [regex stringByReplacingMatchesInString:result options:0 range:NSMakeRange(0, [result length]) withTemplate:@\"onmouseo***=\"];\n    }  \n    \n    return result;\n  } else {\n    return self;\n  }\n}\n\n@end\n"], "filenames": ["SoObjects/SOGo/NSString+Utilities.m"], "buggy_code_start_loc": [901], "buggy_code_end_loc": [974], "fixing_code_start_loc": [901], "fixing_code_end_loc": [990], "type": "CWE-707", "message": "A vulnerability was found in Alinto SOGo up to 5.7.1. It has been classified as problematic. This affects an unknown part of the file SoObjects/SOGo/NSString+Utilities.m of the component Folder/Mail Handler. The manipulation leads to cross site scripting. It is possible to initiate the attack remotely. Upgrading to version 5.8.0 is able to address this issue. The name of the patch is 1e0f5f00890f751e84d67be4f139dd7f00faa5f3. It is recommended to upgrade the affected component. The identifier VDB-215961 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4558", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-16T17:15:08.873", "lastModified": "2022-12-22T13:37:54.840", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Alinto SOGo up to 5.7.1. It has been classified as problematic. This affects an unknown part of the file SoObjects/SOGo/NSString+Utilities.m of the component Folder/Mail Handler. The manipulation leads to cross site scripting. It is possible to initiate the attack remotely. Upgrading to version 5.8.0 is able to address this issue. The name of the patch is 1e0f5f00890f751e84d67be4f139dd7f00faa5f3. It is recommended to upgrade the affected component. The identifier VDB-215961 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-707"}, {"lang": "en", "value": "CWE-74"}, {"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:alinto:sogo:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.8.0", "matchCriteriaId": "BA321919-1C9F-445A-A486-59848483F5EE"}]}]}], "references": [{"url": "https://github.com/Alinto/sogo/commit/1e0f5f00890f751e84d67be4f139dd7f00faa5f3", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Alinto/sogo/releases/tag/SOGo-5.8.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.215961", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Alinto/sogo/commit/1e0f5f00890f751e84d67be4f139dd7f00faa5f3"}}