{"buggy_code": ["// Socket class - implements BaseSocket for INET domain sockets\n\n// For all support, instructions and copyright go to:\n// http://e2guardian.org/\n// Released under the GPL v2, with the OpenSSL exception described in the README file.\n\n// INCLUDES\n#ifdef HAVE_CONFIG_H\n#include \"e2config.h\"\n#endif\n\n#include \"Socket.hpp\"\n\n#include <string.h>\n#include <syslog.h>\n#include <csignal>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <pwd.h>\n#include <stdexcept>\n#include <cerrno>\n#include <unistd.h>\n#include <netinet/tcp.h>\n\n#ifdef __SSLMITM\n#include \"openssl/x509v3.h\"\n#include \"openssl/asn1.h\"\n#include \"openssl/ssl.h\"\n#include \"openssl/err.h\"\n#include \"String.hpp\"\n#include \"CertificateAuthority.hpp\"\n#endif\n\n#ifdef __SSLMITM\nextern bool reloadconfig;\n\n#ifndef X509_V_FLAG_TRUSTED_FIRST\n#warning \"openssl X509_V_FLAG_TRUSTED_FIRST not available, certificate chain creation will be unreliable and will fail on some sites\"\n#warning \"To fix install a later version of openssl\"\n#define X509_V_FLAG_TRUSTED_FIRST 0\n#endif\n#endif\n\nextern thread_local std::string thread_id;\n\n// IMPLEMENTATION\n//\n// destructor\nSocket::~Socket() {\n    close();\n}\n\n// constructor - create an INET socket & clear address structs\nSocket::Socket() {\n    sck = socket(AF_INET, SOCK_STREAM, 0);\n    if (sck < 0) {\n        s_errno = errno;\n    } else {\n        memset(&my_adr, 0, sizeof my_adr);\n        memset(&peer_adr, 0, sizeof peer_adr);\n        my_adr.sin_family = AF_INET;\n        peer_adr.sin_family = AF_INET;\n        peer_adr_length = sizeof(struct sockaddr_in);\n        int f = 1;\n\n        if (sck > 0)\n            setsockopt(sck, IPPROTO_TCP, TCP_NODELAY, &f, sizeof(int));\n\n        my_port = 0;\n        chunkError = false;\n\n#ifdef __SSLMITM\n        ssl = NULL;\n        ctx = NULL;\n        isssl = false;\n        issslserver = false;\n#else\n        isssl = false;\n#endif\n    }\n}\n\n// create socket from pre-existing FD (address structs will be invalid!)\nSocket::Socket(int fd)\n        : BaseSocket(fd) {\n    memset(&my_adr, 0, sizeof my_adr);\n    memset(&peer_adr, 0, sizeof peer_adr);\n    my_adr.sin_family = AF_INET;\n    peer_adr.sin_family = AF_INET;\n    peer_adr_length = sizeof(struct sockaddr_in);\n    int f = 1;\n\n    int res = setsockopt(sck, IPPROTO_TCP, TCP_NODELAY, &f, sizeof(int));\n    if (res < 0) s_errno = errno;\n    my_port = 0;\n    chunkError = false;\n\n#ifdef __SSLMITM\n    ssl = NULL;\n    ctx = NULL;\n    isssl = false;\n    issslserver = false;\n#else\n    isssl = false;\n#endif\n}\n\n// create socket from pre-existing FD, storing local & remote IPs\nSocket::Socket(int newfd, struct sockaddr_in myip, struct sockaddr_in peerip)\n        : BaseSocket(newfd) {\n    memset(&my_adr, 0, sizeof my_adr); // ***\n    memset(&peer_adr, 0, sizeof peer_adr); // ***\n    my_adr.sin_family = AF_INET; // *** Fix suggested by\n    peer_adr.sin_family = AF_INET; // *** Christopher Weimann\n    my_adr = myip;\n    peer_adr = peerip;\n    peer_adr_length = sizeof(struct sockaddr_in);\n    int f = 1;\n\n    int res = setsockopt(sck, IPPROTO_TCP, TCP_NODELAY, &f, sizeof(int));\n    if (res < 0) s_errno = errno;\n    my_port = 0;\n    chunkError = false;\n\n#ifdef __SSLMITM\n    ssl = NULL;\n    ctx = NULL;\n    isssl = false;\n    issslserver = false;\n#else\n    isssl = false;\n#endif\n}\n\n// find the ip to which the client has connected\nstd::string Socket::getLocalIP() {\n    char res[INET_ADDRSTRLEN];\n    return inet_ntop(AF_INET,&my_adr.sin_addr, res, sizeof(res));\n}\n\n// find the ip of the client connecting to us\nstd::string Socket::getPeerIP() {\n    char res[INET_ADDRSTRLEN];\n    return inet_ntop(AF_INET,&peer_adr.sin_addr, res, sizeof(res));\n}\n\n// find the port of the client connecting to us\nint Socket::getPeerSourcePort() {\n    return ntohs(peer_adr.sin_port);\n}\n\nint Socket::getPort() {\n    return my_port;\n}\n\nvoid Socket::setPort(int port) {\n    my_port = port;\n}\n\n// return the address of the client connecting to us\nunsigned long int Socket::getPeerSourceAddr() {\n    return (unsigned long int) ntohl(peer_adr.sin_addr.s_addr);\n}\n\n// close connection & wipe address structs\nvoid Socket::reset() {\n#ifdef __SSLMITM\n    if (isssl) {\n        stopSsl();\n    }\n#endif //__SSLMITM\n    this->baseReset();\n\n    sck = socket(AF_INET, SOCK_STREAM, 0);\n    if (sck < 0) {\n        s_errno = errno;\n        return;\n    }\n\n    memset(&my_adr, 0, sizeof my_adr);\n    memset(&peer_adr, 0, sizeof peer_adr);\n    my_adr.sin_family = AF_INET;\n    peer_adr.sin_family = AF_INET;\n    peer_adr_length = sizeof(struct sockaddr_in);\n    infds[0].fd = sck;\n    outfds[0].fd = sck;\n\n    chunkError = false;\n    chunk_to_read = 0;\n\n}\n\n// connect to given IP & port (following default constructor)\nint Socket::connect(const std::string &ip, int port) {\n    reset();   // do it anyway as we need sck to be allocated\n\n    if (sck < 0) // socket creation error\n    {\n        return -1;\n    }\n\n    int len = sizeof my_adr;\n    peer_adr.sin_port = htons(port);\n    inet_aton(ip.c_str(), &peer_adr.sin_addr);\n    my_port = port;\n    // make non-blocking for connect only so that we can timeout connect\n    fcntl(sck, F_SETFL, O_NONBLOCK);\n    s_errno = 0;\n    errno = 0;\n    int ret = ::connect(sck, (struct sockaddr *) &peer_adr, len);\n    if (ret < 0 && errno == EINPROGRESS) ret = 0;\n    else s_errno = errno;\n    if (ret == 0) {\n        int rc = poll(outfds, 1, timeout);\n        if (rc == 0) {\n            timedout = true;\n            ret = -1;\n        } else if (rc < 0) {\n            s_errno = errno;\n            ret = -1;\n        } else {  // ret == 1\n            int so_error;\n            socklen_t len = sizeof so_error;\n            getsockopt(sck, SOL_SOCKET, SO_ERROR, &so_error, &len);\n            if (so_error != 0) {\n                sockerr = true;\n                s_errno = so_error;\n                ret = -1;\n            } else {\n                ret = 0;\n            }\n        }\n    }\n    fcntl(sck, F_SETFL, 0);  // make blocking again\n    if (ret < 0) close();\n    return ret;\n}\n\n// bind socket to given port\nint Socket::bind(int port) {\n    int len = sizeof my_adr;\n    int i = 1;\n\n    setsockopt(sck, SOL_SOCKET, SO_REUSEADDR, &i, sizeof(i));\n\n    my_adr.sin_port = htons(port);\n    my_port = port;\n\n    return ::bind(sck, (struct sockaddr *) &my_adr, len);\n}\n\n// bind socket to given port & IP\nint Socket::bind(const std::string &ip, int port) {\n    int len = sizeof my_adr;\n    int i = 1;\n\n    setsockopt(sck, SOL_SOCKET, SO_REUSEADDR, &i, sizeof(i));\n\n    my_adr.sin_port = htons(port);\n    my_adr.sin_addr.s_addr = inet_addr(ip.c_str());\n    my_port = port;\n\n    return ::bind(sck, (struct sockaddr *) &my_adr, len);\n}\n\n// accept incoming connections & return new Socket\nSocket *Socket::accept() {\n    peer_adr_length = sizeof(struct sockaddr_in);\n    s_errno = 0;\n    errno = 0;\n//    int newfd = this->baseAccept((struct sockaddr *)&peer_adr, &peer_adr_length);\n    int newfd = ::accept(sck, (struct sockaddr *) &peer_adr, &peer_adr_length);\n\n    if (newfd > 0) {\n        Socket *s = new Socket(newfd, my_adr, peer_adr);\n        s->setPort(my_port);\n        return s;\n    } else {\n        s_errno = errno;\n        return NULL;\n    }\n}\n\n#ifdef __SSLMITM\n//use this socket as an ssl client\nint Socket::startSslClient(const std::string &certificate_path, String hostname)\n{\n    if (isssl) {\n        stopSsl();\n    }\n\n    ERR_clear_error();\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    ctx = SSL_CTX_new(SSLv23_client_method());\n#else\n    ctx = SSL_CTX_new(TLS_client_method());\n#endif\n\n    if (ctx == NULL) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Error ssl context is null (check that openssl has been inited)\" << std::endl;\n#endif\n        log_ssl_errors(\"Error ssl context is null for %s\", hostname.c_str());\n        return -1;\n    }\n\n    //set the timeout for the ssl session\n    if (SSL_CTX_set_timeout(ctx, 130l) < 1) {\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -1;\n    }\n\n    //load certs\n    ERR_clear_error();\n    if (certificate_path.length()) {\n        if (!SSL_CTX_load_verify_locations(ctx, NULL, certificate_path.c_str())) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load certificates from %s\", certificate_path.c_str());\n            //tidy up\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n            return -2;\n        }\n    } else if (!SSL_CTX_set_default_verify_paths(ctx)) //use default if no certPpath given\n    {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load default certificates for %s\", hostname.c_str());\n        //tidy up\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -2;\n    }\n\n    // add validation params\n    ERR_clear_error();\n    X509_VERIFY_PARAM *x509_param = X509_VERIFY_PARAM_new();\n    if (!x509_param) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        //X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!X509_VERIFY_PARAM_set_flags(x509_param, X509_V_FLAG_TRUSTED_FIRST)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!SSL_CTX_set1_param(ctx, x509_param)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    X509_VERIFY_PARAM_free(x509_param);     // try not freeing this as SSL_CTX_free seems to be ring to free it\n\n    //hand socket over to ssl lib\n    ERR_clear_error();\n    ssl = SSL_new(ctx);\n    SSL_set_options(ssl, SSL_OP_ALL);\n    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\n    SSL_set_connect_state(ssl);\n\n    //fcntl(this->getFD() ,F_SETFL, O_NONBLOCK); // blocking mode used currently\n    SSL_set_fd(ssl, this->getFD());\n    SSL_set_tlsext_host_name(ssl, hostname.c_str());\n\n    //make io non blocking as select wont tell us if we can do a read without blocking\n    //BIO_set_nbio(SSL_get_rbio(ssl),1l);  // blocking mode used currently\n    //BIO_set_nbio(SSL_get_wbio(ssl),1l); // blocking mode used currently\n    ERR_clear_error();\n    int rc = SSL_connect(ssl);\n    if (rc < 0) {\n        log_ssl_errors(\"ssl_connect failed to %s\", hostname.c_str());\n#ifdef NETDEBUG\n        std::cout << thread_id << \"ssl_connect failed with error \" << SSL_get_error(ssl, rc) << std::endl;\n#endif\n        // tidy up\n        SSL_free(ssl);\n        ssl = NULL;\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -3;\n    }\n\n    //should be safer to do this last as nothing will ever try to use a ssl socket that isnt fully setup\n    isssl = true;\n    issslserver = false;\n    return 0;\n}\n\nbool Socket::isSsl()\n{\n    return isssl;\n}\n\nbool Socket::isSslServer()\n{\n    return issslserver;\n}\n\n//shuts down the current ssl connection\nvoid Socket::stopSsl()\n{\n#ifdef NETDEBUG\n    std::cout << thread_id << \"ssl stopping\" << std::endl;\n#endif\n    if(!isssl) return;\n\n    isssl = false;\n\n    if (ssl != NULL) {\n        if (issslserver) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"this is a server connection\" << std::endl;\n            if (SSL_get_shutdown(ssl) & SSL_SENT_SHUTDOWN) {\n                std::cout << thread_id << \"SSL_SENT_SHUTDOWN IS SET\" << std::endl;\n            }\n            if (SSL_get_shutdown(ssl) & SSL_RECEIVED_SHUTDOWN) {\n                std::cout << thread_id << \"SSL_RECEIVED_SHUTDOWN IS SET\" << std::endl;\n            }\n            std::cout << thread_id << \"calling 1st ssl shutdown\" << std::endl;\n#endif\n            if (!SSL_shutdown(ssl)) {\n#ifdef NETDEBUG\n                std::cout << thread_id << \"need to call SSL shutdown again\" << std::endl;\n                if (SSL_get_shutdown(ssl) & SSL_SENT_SHUTDOWN) {\n                    std::cout << thread_id << \"SSL_SENT_SHUTDOWN IS SET\" << std::endl;\n                }\n                if (SSL_get_shutdown(ssl) & SSL_RECEIVED_SHUTDOWN) {\n                    std::cout << thread_id << \"SSL_RECEIVED_SHUTDOWN IS SET\" << std::endl;\n                }\n                std::cout << thread_id << \"Discarding extra data from client\" << std::endl;\n#endif\n\n                shutdown(SSL_get_fd(ssl), SHUT_WR);\n                char junk[1024];\n                readFromSocket(junk, sizeof(junk), 0, 5);\n#ifdef NETDEBUG\n                std::cout << thread_id << \"done\" << std::endl;\n#endif\n            }\n        } else {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"this is a client connection\" << std::endl;\n            if (SSL_get_shutdown(ssl) & SSL_SENT_SHUTDOWN) {\n                std::cout << thread_id << \"SSL_SENT_SHUTDOWN IS SET\" << std::endl;\n            }\n            if (SSL_get_shutdown(ssl) & SSL_RECEIVED_SHUTDOWN) {\n                std::cout << thread_id << \"SSL_RECEIVED_SHUTDOWN IS SET\" << std::endl;\n            }\n            std::cout << thread_id << \"calling ssl shutdown\" << std::endl;\n#endif\n            SSL_shutdown(ssl);\n#ifdef NETDEBUG\n            std::cout << thread_id << \"done\" << std::endl;\n#endif\n        }\n    }\n\n    cleanSsl();\n\n}\n\nvoid Socket::cleanSsl() {  // called when failure in ssl set up functions and from stopSsl\n    if (ssl != NULL) {\n        SSL_free(ssl);\n        ssl = NULL;\n    }\n    if (ctx != NULL ) {\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n    }\n    issslserver = false;\n    isssl = false;\n}\n\n//check that everything in this certificate is correct appart from the hostname\nlong Socket::checkCertValid(String &hostname)\n{\n    //check we have a certificate\n    X509 *peerCert = SSL_get_peer_certificate(ssl);\n    if (peerCert == NULL) {\n        return -1;\n    }\n    X509_free(peerCert);\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n#else\n// section for openssl1.1\nX509_VERIFY_PARAM *param;\nparam = X509_VERIFY_PARAM_new() ;\nX509_VERIFY_PARAM_set1_host(param,hostname.c_str(), hostname.length());\nSSL_CTX_set1_param(ctx,param);\nX509_VERIFY_PARAM_free(param);\n#endif\n    return SSL_get_verify_result(ssl);\n}\n\n//check the common name and altnames of a certificate against hostname\nint Socket::checkCertHostname(const std::string &_hostname)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    String hostname = _hostname;\n\n    X509 *peercertificate = SSL_get_peer_certificate(ssl);\n    if (peercertificate == NULL) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"unable to get certificate for \" << hostname << std::endl;\n#endif\n        return -1;\n    }\n    //force to lower case as domain names are not case sensetive\n    hostname.toLower();\n\n#ifdef NETDEBUG\n    std::cout << thread_id << \"checking certificate\" << hostname << std::endl;\n    std::cout << thread_id << \"Checking hostname against subjectAltNames\" << std::endl;\n#endif\n\n\n    bool matched = false;\n    bool hasaltname = false;\n\n    //check the altname extension for additional valid names\n    STACK_OF(GENERAL_NAME) *gens = NULL;\n    gens = (STACK_OF(GENERAL_NAME) *)X509_get_ext_d2i(peercertificate, NID_subject_alt_name, 0, 0);\n    int r = sk_GENERAL_NAME_num(gens);\n    for (int i = 0; i < r; ++i) {\n        const GENERAL_NAME *gn = sk_GENERAL_NAME_value(gens, i);\n\n        //if its not a dns entry we really dont care about it\n        if (gn->type != GEN_DNS) {\n            continue;\n        }\n\n        //only mark hasaltname as true if it has a DNS altname\n        hasaltname = true;\n\n        //an ASN1_IA5STRING is a define of an ASN1_STRING so we can do it this way\n        unsigned char *nameutf8;\n        int len = ASN1_STRING_to_UTF8(&nameutf8, gn->d.ia5);\n        if (len < 0) {\n            break;\n        }\n\n        String altname = std::string((char *)nameutf8, len);\n        OPENSSL_free(nameutf8);\n\n        //force to lower case as domain names are not case sensetive\n        altname.toLower();\n\n#ifdef NETDEBUG\n        std::cout << thread_id << \"checking against alt name \" << altname << std::endl;\n#endif\n\n        if (hostname.compare(altname) == 0) {\n            matched = true;\n            break;\n        } else if (altname.contains(\"*\")) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"Wildcard certificate is in use\" << std::endl;\n#endif\n            String  anend;\n            anend = altname.after(\"*\"); // need to keep the \".\"\n            if (hostname.endsWith(anend)) {\n                bool part_match = true;\n                String anstart = altname.before(\"*\");\n                String t = hostname.before(anend.c_str());\n                if( anstart.length() > 0) {             // if something before * we must also match this\n                  if( hostname.startsWith(anstart)) {\n                    t = t.after(anstart.c_str());\n                  } else {\n                      part_match = false;    // even though after * matches, no match on before * - so cannot match\n                   }\n                 }\n                 //    t now contains what is matched by the '*\"  - this must not contain a '.'\n                 if (part_match && !t.contains(\".\")) {\n                   matched = true;\n                   break;\n                }\n            }\n        }\n    }\n    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n\n    if (matched) {\n        X509_free(peercertificate);\n        return 0;\n    } else if (hasaltname) {\n        X509_free(peercertificate);\n        return -1;\n    }\n\n#ifdef NETDEBUG\n    std::cout << thread_id << \"checking hostname against the following common names\" << std::endl;\n#endif\n\n    X509_NAME *name = X509_get_subject_name(peercertificate);\n\n    int current_entry = -1;\n    while (1) {\n\n        //get the common name from the certificate\n        current_entry = X509_NAME_get_index_by_NID(name, NID_commonName, current_entry);\n        if (current_entry == -1) {\n            //if we've run out of common names then move on to altnames\n            break;\n        }\n\n        //X509_NAME_get_entry result must not be freed\n        X509_NAME_ENTRY *entry = X509_NAME_get_entry(name, current_entry);\n\n        ASN1_STRING *asn1name = X509_NAME_ENTRY_get_data(entry);\n\n        unsigned char *nameutf8;\n        int len = ASN1_STRING_to_UTF8(&nameutf8, asn1name);\n        if (len < 0) {\n            break;\n        }\n        String commonname = std::string((char *)nameutf8, len);\n\n        OPENSSL_free(nameutf8);\n\n        //force to lower case as domain names are not case sensetive\n        commonname.toLower();\n\n#ifdef NETDEBUG\n        std::cout << thread_id << \"checking against common name \" << commonname << std::endl;\n#endif\n\n        //compare the hostname to the common name\n        if (hostname.compare(commonname) == 0) {\n            matched = true;\n            break;\n        }\n        //see if its a wildcard certificate\n        else if (commonname.startsWith(\"*.\")) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"Wildcard certificate is in use\" << std::endl;\n#endif\n            commonname = commonname.after(\"*\"); // need to keep the \".\"\n\n            if (hostname.endsWith(commonname)) {\n                matched = true;\n                break;\n            }\n        }\n    }\n\n    if (matched) {\n        X509_free(peercertificate);\n        return 0;\n    }\n#else  // is openssl v1.1 or above\n    return 0;    //TODO\n#endif\n    return -1;\n}\n\nvoid Socket::close()\n{\n    if (isssl) {\n        stopSsl();\n    }\n    BaseSocket::close();\n}\n#endif //__SSLMITM\n\n#ifdef __SSLMITM\n//use this socket as an ssl server\nint Socket::startSslServer(X509 *x, EVP_PKEY *privKey, std::string &set_cipher_list)\n{\n\n    if (isssl) {\n        stopSsl();\n    }\n\n    // set ssl to NULL\n    ssl = NULL;\n\n    //setup the ssl server ctx\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    ctx = SSL_CTX_new(SSLv23_server_method());\n#else\n    ctx = SSL_CTX_new(TLS_server_method());\n#endif\n\n    if (ctx == NULL) {\n#ifdef NETDEBUG\n        //syslog(LOG_ERR, \"error creating ssl context\\n\");\n        std::cout << thread_id << \"Error ssl context is null (check that openssl has been inited)\" << std::endl;\n#endif\n        return -1;\n    }\n\n    //set the timeout to match firefox\n    if (SSL_CTX_set_timeout(ctx, 130l) < 1) {\n        cleanSsl();\n        return -1;\n    }\n\n    //set the ctx to use the certificate\n    if (SSL_CTX_use_certificate(ctx, x) < 1) {\n#ifdef NETDEBUG\n        //syslog(LOG_ERR, \"error creating ssl context\\n\");\n        std::cout << thread_id << \"Error using certificate\" << std::endl;\n#endif\n        cleanSsl();\n        return -1;\n    }\n\n    if (set_cipher_list.length() > 0)\n        SSL_CTX_set_cipher_list(ctx, set_cipher_list.c_str());\n\n    //set the ctx to use the private key\n    if (SSL_CTX_use_PrivateKey(ctx, privKey) < 1) {\n#ifdef NETDEBUG\n        //syslog(LOG_ERR, \"error creating ssl context\\n\");\n        std::cout << thread_id << \"Error using private key\" << std::endl;\n#endif\n        cleanSsl();\n        return -1;\n    }\n\n    //setup the ssl session\n    ERR_clear_error();\n    ssl = SSL_new(ctx);\n    SSL_set_options(ssl, SSL_OP_ALL);\n    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\n    SSL_set_accept_state(ssl);\n\n    ERR_clear_error();\n    if(!SSL_set_fd(ssl, this->getFD())) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Error setting ssl fd connection\" << std::endl;\n#endif\n        log_ssl_errors(\"ssl_set_fd failed to client %s\", \"\");\n        cleanSsl();\n        return -1;\n    };\n\n    //make io non blocking as select wont tell us if we can do a read without blocking\n\n    ERR_clear_error();\n    if (SSL_accept(ssl) < 0) {\n#ifdef NETDEBUG\n        //syslog(LOG_ERR, \"error creating ssl context\\n\");\n        std::cout << thread_id << \"Error accepting ssl connection\" << std::endl;\n#endif\n        log_ssl_errors(\"ssl_accept failed to client %s\", \"\");\n        cleanSsl();\n        return -1;\n    }\n\n    ERR_clear_error();\n    if (SSL_do_handshake(ssl) < 0) {\n#ifdef NETDEBUG\n        //syslog(LOG_ERR, \"error creating ssl context\\n\");\n        std::cout << thread_id << \"Error doing ssl handshake\" << std::endl;\n#endif\n        log_ssl_errors(\"ssl_handshake failed to client %s\", \"\");\n        cleanSsl();\n        return -1;\n    }\n    isssl = true;\n    issslserver = true;\n    return 0;\n}\n\n//modify all of these to use SSL_write(ssl,buf,len) and SSL_read(ssl,buf,buflen)\n\n//have to replace checkforinput as the ssl session will constantly generate traffic even if theres no real data\n// non-blocking check to see if there is data waiting on socket\nbool Socket::checkForInput()\n{\n    if (!isssl) {\n        return BaseSocket::checkForInput();\n    }\n#ifdef NETDEBUG\n    std::cout << thread_id << \"checking for input on ssl connection (non blocking)\" << std::endl;\n#endif\n    if ((bufflen - buffstart) > 0) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"found input on ssl connection\" << std::endl;\n#endif\n        return true;\n    }\n\n    if (!BaseSocket::checkForInput())\n        return false;\n\n    //see if we can do an ssl read of 1 byte\n//    char buf[1];\n\n    //int rc = SSL_peek(ssl, buf, 1);\n    int rc = SSL_pending(ssl);\n\n    if (rc < 1) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"no pending data on ssl connection SSL_pending \" << rc << std::endl;\n#endif\n        return false;\n    }\n\n#ifdef NETDEBUG\n    std::cout << thread_id << \"found data on ssl connection\" << std::endl;\n#endif\n\n    return true;\n}\n\nbool Socket::bcheckForInput(int timeout)\n{\n    if (!isssl) {\n        return BaseSocket::bcheckForInput(timeout);\n    }\n    return true;\n}\n\n\nbool Socket::readyForOutput()\n{\n    //if (!isssl) {\n        return BaseSocket::readyForOutput();\n    //}\n\n    //cant do this on a blocking ssl socket as far as i can work out\n\n    //return true;\n}\n\nbool Socket::breadyForOutput(int timeout)\n{\n    //if (!isssl) {\n        return BaseSocket::breadyForOutput(timeout);\n    //}\n    //return true;\n}\n\n\n// read a line from the socket, can be told to break on config reloads\nint Socket::getLine(char *buff, int size, int timeout, bool honour_reloadconfig, bool *chopped, bool *truncated)\n{\ntry {\n    if (!isssl) {\n        return BaseSocket::getLine(buff, size, timeout, honour_reloadconfig, chopped, truncated);\n    }\n\n    // first, return what's left from the previous buffer read, if anything\n    int i = 0;\n    if ((bufflen - buffstart) > 0) {\n        /*#ifdef NETDEBUG\n        std::cout << thread_id << \"data already in buffer; bufflen: \" << bufflen << \" buffstart: \" << buffstart << std::endl;\n#endif*/\n        int tocopy = size - 1;\n        if ((bufflen - buffstart) < tocopy)\n            tocopy = bufflen - buffstart;\n        char *result = (char *)memccpy(buff, buffer + buffstart, '\\n', tocopy);\n        if (result != NULL) {\n            // indicate that a newline was chopped off, if desired\n            if (chopped)\n                *chopped = true;\n            *(--result) = '\\0';\n            buffstart += (result - buff) + 1;\n            return result - buff;\n        } else {\n            i += tocopy;\n            buffstart += tocopy;\n        }\n    }\n    while (i < (size - 1)) {\n        buffstart = 0;\n        bufflen = 0;\n //       try {\n //            checkForInput(timeout, honour_reloadconfig);\n //       } catch (std::exception &e) {\n//            throw std::runtime_error(std::string(\"Can't read from socket: \") + strerror(errno)); // on error\n //       }\n//        if( bcheckSForInput(timeout))\n            bufflen = SSL_read(ssl, buffer, 4096);\n#ifdef NETDEBUG\n//std::cout << thread_id << \"read into buffer; bufflen: \" << bufflen <<std::endl;\n#endif\n        if (bufflen < 0) {\n  //          if (errno == EINTR ) {\n   //             continue;\n    //        }\n            std::cout << thread_id << \"SSL_read failed with error \" << SSL_get_error(ssl, bufflen) << std::endl;\n            log_ssl_errors(\"ssl_read failed %s\", \"\");\n            return -1;\n//            throw std::runtime_error(std::string(\"Can't read from ssl socket\")); //strerror(errno));  // on error\n        }\n        //if socket closed...\n        if (bufflen == 0) {\n            buff[i] = '\\0'; // ...terminate string & return what read\n            if (truncated)\n                *truncated = true;\n            return i;\n        }\n        int tocopy = bufflen;\n        if ((i + bufflen) > (size - 1))\n            tocopy = (size - 1) - i;\n        char *result = (char *)memccpy(buff + i, buffer, '\\n', tocopy);\n        if (result != NULL) {\n            // indicate that a newline was chopped off, if desired\n            if (chopped)\n                *chopped = true;\n            *(--result) = '\\0';\n            buffstart += (result - (buff + i)) + 1;\n            return i + (result - (buff + i));\n        }\n        i += tocopy;\n    }\n    // oh dear - buffer end reached before we found a newline\n    buff[i] = '\\0';\n    if (truncated)\n        *truncated = true;\n    return i;\n    } catch (...) {\n    return -1;    }\n}\n\n// write line to socket\nbool Socket::writeString(const char *line) //throw(std::exception)\n{\n    int l = strlen(line);\n    return writeToSocket(line, l, 0, timeout);\n}\n\n// write line to socket\nbool Socket::writeString(std::string line)\n{\n    int l = line.length();\n    return writeToSocket(line.c_str(), l, 0, timeout);\n}\n\n// write data to socket - can be told not to do an initial readyForOutput, and to break on config reloads\nbool Socket::writeToSocket(const char *buff, int len, unsigned int flags, int timeout, bool check_first, bool honour_reloadconfig)\n{\n    if (len == 0)   // nothing to write\n        return true;\n    if (!isssl) {\n        return BaseSocket::writeToSocket(buff, len, flags, timeout, check_first, honour_reloadconfig);\n    }\n\n    int actuallysent = 0;\n    int sent;\n    while (actuallysent < len) {\n       if (check_first) {\n    //        try {\n                if(!breadyForOutput(timeout))\n                   return false;\n     //       } catch (std::exception &e) {\n      //          return false;\n       //     }\n        }\n        ERR_clear_error();\n        sent = SSL_write(ssl, buff + actuallysent, len - actuallysent);\n        if (sent < 0) {\n    //        if (errno == EINTR ) {\n    //            continue; // was interupted by signal so restart\n    //        }\n            s_errno = errno;\n            String serr(s_errno);\n            log_ssl_errors(\"ssl_write failed - error \",serr.c_str());\n            return false;\n        }\n        if (sent == 0) {\n            ishup = true;\n            return false; // other end is closed\n        }\n        actuallysent += sent;\n    }\n    return true;\n}\n\n// read a specified expected amount and return what actually read\nint Socket::readFromSocketn(char *buff, int len, unsigned int flags, int timeout)\n{\n    return readFromSocket(buff, len, flags, timeout, true, false);\n\n\n#ifdef NODEF\n    if (!isssl) {\n        return BaseSocket::readFromSocketn(buff, len, flags, timeout);\n    }\n\n    int cnt, rc;\n    cnt = len;\n\n    // first, return what's left from the previous buffer read, if anything\n    if ((bufflen - buffstart) > 0) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Socket::readFromSocketn: data already in buffer; bufflen: \" << bufflen << \" buffstart: \" << buffstart << std::endl;\n#endif\n        int tocopy = len;\n        if ((bufflen - buffstart) < len)\n            tocopy = bufflen - buffstart;\n        memcpy(buff, buffer + buffstart, tocopy);\n        cnt -= tocopy;\n        buffstart += tocopy;\n        buff += tocopy;\n        if (cnt == 0)\n            return len;\n    }\n\n    while (cnt > 0) {\n    //    try {\n            //bcheckSForInput(timeout);        //  this may be wrong - why is data not being read into socket buffer????\n    //    } catch (std::exception &e) {\n     //       return -1;\n     //   }\n        ERR_clear_error();\n        rc = SSL_read(ssl, buff, cnt);\n#ifdef NETDEBUG\n        std::cout << thread_id << \"ssl read said: \" << rc << std::endl;\n#endif\n\n        if (rc < 0) {\n       //     if (errno == EINTR) {\n         //       continue;\n           // }\n            log_ssl_errors(\"ssl_read failed %s\", \"\");\n           s_errno = errno;\n            return -1;\n        }\n        if (rc == 0) { // eof\n             ishup = true;\n            return len - cnt;\n        }\n        buff += rc;\n        cnt -= rc;\n    }\n    return len;\n#endif\n}\n\n// read what's available and return error status - can be told not to do an initial checkForInput, and to break on reloads\nint Socket::readFromSocket(char *buff, int len, unsigned int flags, int timeout, bool check_first, bool honour_reloadconfig)\n{\n    if (len == 0)  // nothing to read\n         return 0;\n    if (!isssl) {\n        return BaseSocket::readFromSocket(buff, len, flags, timeout, check_first, honour_reloadconfig);\n    }\n\n    // first, return what's left from the previous buffer read, if anything\n    int cnt = len;\n    int tocopy = 0;\n    if ((bufflen - buffstart) > 0) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Socket::readFromSocket: data already in buffer; bufflen: \" << bufflen << \" buffstart: \" << buffstart << std::endl;\n#endif\n        tocopy = len;\n        if ((bufflen - buffstart) < len)\n            tocopy = bufflen - buffstart;\n        memcpy(buff, buffer + buffstart, tocopy);\n        cnt -= tocopy;\n        buffstart += tocopy;\n        buff += tocopy;\n        if (cnt == 0)\n            return len;\n    }\n\n    int rc;\n    while (cnt > 0) {\n    //if (check_first) {\n          //if(!bcheckSForInput(timeout))\n            //return -1;\n   //}\n//    while (true)\n        bool inbuffer;\n        ERR_clear_error();\n        if(true) {   //   was if (cnt > 4095)\n            inbuffer = false;\n           rc = SSL_read(ssl, buff, cnt);        //  data larger than SSL buffer so ok to read directly into output buffer\n        } else {\n            inbuffer = true;\n           rc = SSL_read(ssl, buffer, 4096);   // read into socket buffer to flush SSL buffer\n        }\n\n        if (rc < 0) {\n            s_errno = errno;\n            log_ssl_errors(\"ssl_read failed %s\", \"\");\n#ifdef NETDEBUG\n        std::cout << thread_id << \"ssl_read failed\" << s_errno << \" failed to read \" << cnt << \" bytes\" << std::endl;\n#endif\n            rc = 0;\n        }\n        if (rc == 0) { // eof\n             ishup = true;\n             return len - cnt;\n             }\n\n        if (inbuffer) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Inbuffer SSL read to return \" << cnt << \" bytes\" << std::endl;\n#endif\n\n           buffstart = 0;\n           bufflen = rc;\n           if ((bufflen - buffstart) > 0) {\n              tocopy = cnt;\n              if ((bufflen - buffstart) < cnt)\n              tocopy = bufflen - buffstart;\n              memcpy(buff, buffer + buffstart, tocopy);\n              cnt -= tocopy;\n              buffstart += tocopy;\n              buff += tocopy;\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Inbuffer SSL read to returned \" << tocopy << \" bytes\" << std::endl;\n#endif\n           }\n         } else {\n        buff += rc;\n        cnt -= rc;\n         }\n //       break;\n    }\n\n//    return rc + tocopy;\n      return len;\n}\n\n#endif //__SSLMITM\n\nvoid Socket::resetChunk() {\n    chunk_to_read = 0;\n    chunked_trailer = \"\";\n    ieof = false;\n}\n\nbool Socket::writeChunk( char *buffout, int len, int timeout){\n    std::stringstream stm;\n    stm << std::hex << len;\n    std::string hexs (stm.str());\n    //int lw;\n    hexs += \"\\r\\n\";\n#ifdef NETDEBUG\n    std::cerr << thread_id << \"writeChunk  size=\" << hexs << std::endl;\n#endif\n    if(writeString(hexs.c_str()) && writeToSocket(buffout,len,0,timeout) && writeString(\"\\r\\n\"))\n        return true;\n    return false;\n};\n\nbool Socket::writeChunkTrailer( String &trailer) {\n    std::string hexs (\"0\\r\\n\");\n#ifdef CHUNKDEBUG\n    std::cerr << thread_id << \"writeChunk  size=\" << hexs << std::endl;\n#endif\n    if(writeString(hexs.c_str()) && writeToSocket(trailer.c_str(),trailer.length(),0,timeout) && writeString(\"\\r\\n\"))\n        return true;\n    return false;\n};\n\nint Socket::readChunk( char *buffin, int maxlen, int timeout){\n    if (chunk_to_read == 0)     // need to read chunk size\n    {\n        char size[40];\n        ieof = false;\n        int len = getLine(size, 38, timeout);\n        if (len < 2) {   // min valid length is 2 i.e.  \"0\\r\"\n            chunkError = true;\n            return -1;\n        }\n#ifdef CHUNKDEBUG\n        std::cerr << thread_id << \"readChunk  size=\" << size << std::endl;\n#endif\n        String l = size;\n        l.chop();\n        String t = l.before(\";\");\n        if (t.length() > 0) {\n            if (l.endsWith(\"; ieof\")) {\n                ieof = true;\n            }\n            l = t;\n        }\n        chunk_to_read = l.hexToInteger();\n#ifdef CHUNKDEBUG\n        std::cerr << thread_id << \"readChunk  chunk_to_read =\" << chunk_to_read << std::endl;\n#endif\n    }\n\n    int clen = chunk_to_read;\n    if (clen > maxlen) {\n        clen = maxlen;\n    }\n    int rc = 0;\n#ifdef CHUNKDEBUG\n    std::cerr << thread_id << \"readChunk  max_read =\" << clen << std::endl;\n#endif\n\n    if(clen == 0) {\n        chunked_trailer = \"\";\n        char trailer[32000];\n        int len = 3;\n        while( len > 2) {\n            len = getLine(trailer, 31900, timeout);\n            if (len > 2) {\n                chunked_trailer += trailer;\n                chunked_trailer += \"\\n\";\n            }\n        }\n        return 0;\n    }\n\n    if (clen > 0) {\n        rc = readFromSocketn(buffin, clen, 0, timeout);\n#ifdef CHUNKDEBUG\n        std::cerr << thread_id << \"readChunk  read \" << rc << std::endl;\n#endif\n        if (rc < 0) {\n            chunkError = true;\n            return -1;\n        }\n        chunk_to_read -= rc;\n    }\n    if (chunk_to_read > 0)    // there is more to read in this chunk - so do not check for trailing \\r\\n\n        return rc;\n    char ts[2];\n    int len = readFromSocketn(ts, 2, 0, timeout);\n    if (len == 2 && ts[0] == '\\r' && ts[1] == '\\n') {\n        return rc;\n    } else {\n        chunkError = true;\n#ifdef CHUNKDEBUG\n        std::cerr << thread_id << \"readChunk - tail in error\" << std::endl;\n#endif\n        return -1;\n    }\n}\n\nint Socket::loopChunk(int timeout)    // reads chunks and sends back until 0 len chunk or timeout\n{\n    char buff[32000];\n    int tot_size = 0;\n    int csize = 1;\n    while (csize > 0) {\n        csize = readChunk(buff,32000, timeout);\n        if (csize == 0)     // end chunk\n        {\n            if (!writeChunkTrailer(chunked_trailer))\n            {\n#ifdef CHUNKDEBUG\n                std::cerr << thread_id << \"loopChunk - error in writing chunk trailer\" << std::endl;\n#endif\n                return -1;\n\n            };\n#ifdef CHUNKDEBUG\n            std::cerr << thread_id << \"loopChunk  tot_size=\" << tot_size << std::endl;\n#endif\n            return tot_size;\n        }\n        if (!(csize > 0 && writeChunk(buff,csize,timeout))) {\n#ifdef CHUNKDEBUG\n            std::cerr << thread_id << \"loopChunk - error\" << std::endl;\n#endif\n            return -1;\n        }\n        tot_size += csize;\n    }\n    return -1;  // should never get here!\n}\n\n\nint Socket::drainChunk(int timeout)    // reads chunks until 0 len chunk or timeout\n{\n    char buff[32000];\n    int tot_size = 0;\n    int csize = 1;\n    while (csize > 0) {\n        csize = readChunk(buff,32000, timeout);\n        if (!(csize > -1 )) {\n#ifdef CHUNKDEBUG\n            std::cerr << thread_id << \"drainChunk - error\" << std::endl;\n#endif\n            return -1;\n        }\n        tot_size += csize;\n    }\n#ifdef CHUNKDEBUG\n    std::cerr << thread_id << \"drainChunk  tot_size=\" << tot_size << std::endl;\n#endif\n    return tot_size;\n}\n\nbool Socket::getIeof() {\n    return ieof;\n}\n"], "fixing_code": ["// Socket class - implements BaseSocket for INET domain sockets\n\n// For all support, instructions and copyright go to:\n// http://e2guardian.org/\n// Released under the GPL v2, with the OpenSSL exception described in the README file.\n\n// INCLUDES\n#ifdef HAVE_CONFIG_H\n#include \"e2config.h\"\n#endif\n\n#include \"Socket.hpp\"\n\n#include <string.h>\n#include <syslog.h>\n#include <csignal>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <pwd.h>\n#include <stdexcept>\n#include <cerrno>\n#include <unistd.h>\n#include <netinet/tcp.h>\n\n#ifdef __SSLMITM\n#include \"openssl/x509v3.h\"\n#include \"openssl/asn1.h\"\n#include \"openssl/ssl.h\"\n#include \"openssl/err.h\"\n#include \"String.hpp\"\n#include \"CertificateAuthority.hpp\"\n#endif\n\n#ifdef __SSLMITM\nextern bool reloadconfig;\n\n#ifndef X509_V_FLAG_TRUSTED_FIRST\n#warning \"openssl X509_V_FLAG_TRUSTED_FIRST not available, certificate chain creation will be unreliable and will fail on some sites\"\n#warning \"To fix install a later version of openssl\"\n#define X509_V_FLAG_TRUSTED_FIRST 0\n#endif\n#endif\n\nextern thread_local std::string thread_id;\n\n// IMPLEMENTATION\n//\n// destructor\nSocket::~Socket() {\n    close();\n}\n\n// constructor - create an INET socket & clear address structs\nSocket::Socket() {\n    sck = socket(AF_INET, SOCK_STREAM, 0);\n    if (sck < 0) {\n        s_errno = errno;\n    } else {\n        memset(&my_adr, 0, sizeof my_adr);\n        memset(&peer_adr, 0, sizeof peer_adr);\n        my_adr.sin_family = AF_INET;\n        peer_adr.sin_family = AF_INET;\n        peer_adr_length = sizeof(struct sockaddr_in);\n        int f = 1;\n\n        if (sck > 0)\n            setsockopt(sck, IPPROTO_TCP, TCP_NODELAY, &f, sizeof(int));\n\n        my_port = 0;\n        chunkError = false;\n\n#ifdef __SSLMITM\n        ssl = NULL;\n        ctx = NULL;\n        isssl = false;\n        issslserver = false;\n#else\n        isssl = false;\n#endif\n    }\n}\n\n// create socket from pre-existing FD (address structs will be invalid!)\nSocket::Socket(int fd)\n        : BaseSocket(fd) {\n    memset(&my_adr, 0, sizeof my_adr);\n    memset(&peer_adr, 0, sizeof peer_adr);\n    my_adr.sin_family = AF_INET;\n    peer_adr.sin_family = AF_INET;\n    peer_adr_length = sizeof(struct sockaddr_in);\n    int f = 1;\n\n    int res = setsockopt(sck, IPPROTO_TCP, TCP_NODELAY, &f, sizeof(int));\n    if (res < 0) s_errno = errno;\n    my_port = 0;\n    chunkError = false;\n\n#ifdef __SSLMITM\n    ssl = NULL;\n    ctx = NULL;\n    isssl = false;\n    issslserver = false;\n#else\n    isssl = false;\n#endif\n}\n\n// create socket from pre-existing FD, storing local & remote IPs\nSocket::Socket(int newfd, struct sockaddr_in myip, struct sockaddr_in peerip)\n        : BaseSocket(newfd) {\n    memset(&my_adr, 0, sizeof my_adr); // ***\n    memset(&peer_adr, 0, sizeof peer_adr); // ***\n    my_adr.sin_family = AF_INET; // *** Fix suggested by\n    peer_adr.sin_family = AF_INET; // *** Christopher Weimann\n    my_adr = myip;\n    peer_adr = peerip;\n    peer_adr_length = sizeof(struct sockaddr_in);\n    int f = 1;\n\n    int res = setsockopt(sck, IPPROTO_TCP, TCP_NODELAY, &f, sizeof(int));\n    if (res < 0) s_errno = errno;\n    my_port = 0;\n    chunkError = false;\n\n#ifdef __SSLMITM\n    ssl = NULL;\n    ctx = NULL;\n    isssl = false;\n    issslserver = false;\n#else\n    isssl = false;\n#endif\n}\n\n// find the ip to which the client has connected\nstd::string Socket::getLocalIP() {\n    char res[INET_ADDRSTRLEN];\n    return inet_ntop(AF_INET,&my_adr.sin_addr, res, sizeof(res));\n}\n\n// find the ip of the client connecting to us\nstd::string Socket::getPeerIP() {\n    char res[INET_ADDRSTRLEN];\n    return inet_ntop(AF_INET,&peer_adr.sin_addr, res, sizeof(res));\n}\n\n// find the port of the client connecting to us\nint Socket::getPeerSourcePort() {\n    return ntohs(peer_adr.sin_port);\n}\n\nint Socket::getPort() {\n    return my_port;\n}\n\nvoid Socket::setPort(int port) {\n    my_port = port;\n}\n\n// return the address of the client connecting to us\nunsigned long int Socket::getPeerSourceAddr() {\n    return (unsigned long int) ntohl(peer_adr.sin_addr.s_addr);\n}\n\n// close connection & wipe address structs\nvoid Socket::reset() {\n#ifdef __SSLMITM\n    if (isssl) {\n        stopSsl();\n    }\n#endif //__SSLMITM\n    this->baseReset();\n\n    sck = socket(AF_INET, SOCK_STREAM, 0);\n    if (sck < 0) {\n        s_errno = errno;\n        return;\n    }\n\n    memset(&my_adr, 0, sizeof my_adr);\n    memset(&peer_adr, 0, sizeof peer_adr);\n    my_adr.sin_family = AF_INET;\n    peer_adr.sin_family = AF_INET;\n    peer_adr_length = sizeof(struct sockaddr_in);\n    infds[0].fd = sck;\n    outfds[0].fd = sck;\n\n    chunkError = false;\n    chunk_to_read = 0;\n\n}\n\n// connect to given IP & port (following default constructor)\nint Socket::connect(const std::string &ip, int port) {\n    reset();   // do it anyway as we need sck to be allocated\n\n    if (sck < 0) // socket creation error\n    {\n        return -1;\n    }\n\n    int len = sizeof my_adr;\n    peer_adr.sin_port = htons(port);\n    inet_aton(ip.c_str(), &peer_adr.sin_addr);\n    my_port = port;\n    // make non-blocking for connect only so that we can timeout connect\n    fcntl(sck, F_SETFL, O_NONBLOCK);\n    s_errno = 0;\n    errno = 0;\n    int ret = ::connect(sck, (struct sockaddr *) &peer_adr, len);\n    if (ret < 0 && errno == EINPROGRESS) ret = 0;\n    else s_errno = errno;\n    if (ret == 0) {\n        int rc = poll(outfds, 1, timeout);\n        if (rc == 0) {\n            timedout = true;\n            ret = -1;\n        } else if (rc < 0) {\n            s_errno = errno;\n            ret = -1;\n        } else {  // ret == 1\n            int so_error;\n            socklen_t len = sizeof so_error;\n            getsockopt(sck, SOL_SOCKET, SO_ERROR, &so_error, &len);\n            if (so_error != 0) {\n                sockerr = true;\n                s_errno = so_error;\n                ret = -1;\n            } else {\n                ret = 0;\n            }\n        }\n    }\n    fcntl(sck, F_SETFL, 0);  // make blocking again\n    if (ret < 0) close();\n    return ret;\n}\n\n// bind socket to given port\nint Socket::bind(int port) {\n    int len = sizeof my_adr;\n    int i = 1;\n\n    setsockopt(sck, SOL_SOCKET, SO_REUSEADDR, &i, sizeof(i));\n\n    my_adr.sin_port = htons(port);\n    my_port = port;\n\n    return ::bind(sck, (struct sockaddr *) &my_adr, len);\n}\n\n// bind socket to given port & IP\nint Socket::bind(const std::string &ip, int port) {\n    int len = sizeof my_adr;\n    int i = 1;\n\n    setsockopt(sck, SOL_SOCKET, SO_REUSEADDR, &i, sizeof(i));\n\n    my_adr.sin_port = htons(port);\n    my_adr.sin_addr.s_addr = inet_addr(ip.c_str());\n    my_port = port;\n\n    return ::bind(sck, (struct sockaddr *) &my_adr, len);\n}\n\n// accept incoming connections & return new Socket\nSocket *Socket::accept() {\n    peer_adr_length = sizeof(struct sockaddr_in);\n    s_errno = 0;\n    errno = 0;\n//    int newfd = this->baseAccept((struct sockaddr *)&peer_adr, &peer_adr_length);\n    int newfd = ::accept(sck, (struct sockaddr *) &peer_adr, &peer_adr_length);\n\n    if (newfd > 0) {\n        Socket *s = new Socket(newfd, my_adr, peer_adr);\n        s->setPort(my_port);\n        return s;\n    } else {\n        s_errno = errno;\n        return NULL;\n    }\n}\n\n#ifdef __SSLMITM\n//use this socket as an ssl client\nint Socket::startSslClient(const std::string &certificate_path, String hostname)\n{\n    if (isssl) {\n        stopSsl();\n    }\n\n    ERR_clear_error();\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    ctx = SSL_CTX_new(SSLv23_client_method());\n#else\n    ctx = SSL_CTX_new(TLS_client_method());\n#endif\n\n    if (ctx == NULL) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Error ssl context is null (check that openssl has been inited)\" << std::endl;\n#endif\n        log_ssl_errors(\"Error ssl context is null for %s\", hostname.c_str());\n        return -1;\n    }\n\n    //set the timeout for the ssl session\n    if (SSL_CTX_set_timeout(ctx, 130l) < 1) {\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -1;\n    }\n\n    //load certs\n    ERR_clear_error();\n    if (certificate_path.length()) {\n        if (!SSL_CTX_load_verify_locations(ctx, NULL, certificate_path.c_str())) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load certificates from %s\", certificate_path.c_str());\n            //tidy up\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n            return -2;\n        }\n    } else if (!SSL_CTX_set_default_verify_paths(ctx)) //use default if no certPpath given\n    {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load default certificates for %s\", hostname.c_str());\n        //tidy up\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -2;\n    }\n\n    // add validation params\n    ERR_clear_error();\n    X509_VERIFY_PARAM *x509_param = X509_VERIFY_PARAM_new();\n    if (!x509_param) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        //X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!X509_VERIFY_PARAM_set_flags(x509_param, X509_V_FLAG_TRUSTED_FIRST)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!SSL_CTX_set1_param(ctx, x509_param)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    X509_VERIFY_PARAM_free(x509_param);     // try not freeing this as SSL_CTX_free seems to be ring to free it\n\n    //hand socket over to ssl lib\n    ERR_clear_error();\n    ssl = SSL_new(ctx);\n    SSL_set_options(ssl, SSL_OP_ALL);\n    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\n    SSL_set_connect_state(ssl);\n\n    //fcntl(this->getFD() ,F_SETFL, O_NONBLOCK); // blocking mode used currently\n    SSL_set_fd(ssl, this->getFD());\n    SSL_set_tlsext_host_name(ssl, hostname.c_str());\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n#else\n  X509_VERIFY_PARAM_set1_host(SSL_get0_param(ssl),hostname.c_str(),0);\n#endif\n\n    //make io non blocking as select wont tell us if we can do a read without blocking\n    //BIO_set_nbio(SSL_get_rbio(ssl),1l);  // blocking mode used currently\n    //BIO_set_nbio(SSL_get_wbio(ssl),1l); // blocking mode used currently\n    ERR_clear_error();\n    int rc = SSL_connect(ssl);\n    if (rc < 0) {\n        log_ssl_errors(\"ssl_connect failed to %s\", hostname.c_str());\n#ifdef NETDEBUG\n        std::cout << thread_id << \"ssl_connect failed with error \" << SSL_get_error(ssl, rc) << std::endl;\n#endif\n        // tidy up\n        SSL_free(ssl);\n        ssl = NULL;\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -3;\n    }\n\n    //should be safer to do this last as nothing will ever try to use a ssl socket that isnt fully setup\n    isssl = true;\n    issslserver = false;\n    return 0;\n}\n\nbool Socket::isSsl()\n{\n    return isssl;\n}\n\nbool Socket::isSslServer()\n{\n    return issslserver;\n}\n\n//shuts down the current ssl connection\nvoid Socket::stopSsl()\n{\n#ifdef NETDEBUG\n    std::cout << thread_id << \"ssl stopping\" << std::endl;\n#endif\n    if(!isssl) return;\n\n    isssl = false;\n\n    if (ssl != NULL) {\n        if (issslserver) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"this is a server connection\" << std::endl;\n            if (SSL_get_shutdown(ssl) & SSL_SENT_SHUTDOWN) {\n                std::cout << thread_id << \"SSL_SENT_SHUTDOWN IS SET\" << std::endl;\n            }\n            if (SSL_get_shutdown(ssl) & SSL_RECEIVED_SHUTDOWN) {\n                std::cout << thread_id << \"SSL_RECEIVED_SHUTDOWN IS SET\" << std::endl;\n            }\n            std::cout << thread_id << \"calling 1st ssl shutdown\" << std::endl;\n#endif\n            if (!SSL_shutdown(ssl)) {\n#ifdef NETDEBUG\n                std::cout << thread_id << \"need to call SSL shutdown again\" << std::endl;\n                if (SSL_get_shutdown(ssl) & SSL_SENT_SHUTDOWN) {\n                    std::cout << thread_id << \"SSL_SENT_SHUTDOWN IS SET\" << std::endl;\n                }\n                if (SSL_get_shutdown(ssl) & SSL_RECEIVED_SHUTDOWN) {\n                    std::cout << thread_id << \"SSL_RECEIVED_SHUTDOWN IS SET\" << std::endl;\n                }\n                std::cout << thread_id << \"Discarding extra data from client\" << std::endl;\n#endif\n\n                shutdown(SSL_get_fd(ssl), SHUT_WR);\n                char junk[1024];\n                readFromSocket(junk, sizeof(junk), 0, 5);\n#ifdef NETDEBUG\n                std::cout << thread_id << \"done\" << std::endl;\n#endif\n            }\n        } else {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"this is a client connection\" << std::endl;\n            if (SSL_get_shutdown(ssl) & SSL_SENT_SHUTDOWN) {\n                std::cout << thread_id << \"SSL_SENT_SHUTDOWN IS SET\" << std::endl;\n            }\n            if (SSL_get_shutdown(ssl) & SSL_RECEIVED_SHUTDOWN) {\n                std::cout << thread_id << \"SSL_RECEIVED_SHUTDOWN IS SET\" << std::endl;\n            }\n            std::cout << thread_id << \"calling ssl shutdown\" << std::endl;\n#endif\n            SSL_shutdown(ssl);\n#ifdef NETDEBUG\n            std::cout << thread_id << \"done\" << std::endl;\n#endif\n        }\n    }\n\n    cleanSsl();\n\n}\n\nvoid Socket::cleanSsl() {  // called when failure in ssl set up functions and from stopSsl\n    if (ssl != NULL) {\n        SSL_free(ssl);\n        ssl = NULL;\n    }\n    if (ctx != NULL ) {\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n    }\n    issslserver = false;\n    isssl = false;\n}\n\n//check that everything in this certificate is correct appart from the hostname\nlong Socket::checkCertValid(String &hostname)\n{\n    //check we have a certificate\n    X509 *peerCert = SSL_get_peer_certificate(ssl);\n    if (peerCert == NULL) {\n        return -1;\n    }\n    X509_free(peerCert);\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n#else\n// section for openssl1.1\nX509_VERIFY_PARAM *param;\nparam = X509_VERIFY_PARAM_new() ;\nX509_VERIFY_PARAM_set1_host(param,hostname.c_str(), hostname.length());\nSSL_CTX_set1_param(ctx,param);\nX509_VERIFY_PARAM_free(param);\n#endif\n    return SSL_get_verify_result(ssl);\n}\n\n//check the common name and altnames of a certificate against hostname\nint Socket::checkCertHostname(const std::string &_hostname)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    String hostname = _hostname;\n\n    X509 *peercertificate = SSL_get_peer_certificate(ssl);\n    if (peercertificate == NULL) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"unable to get certificate for \" << hostname << std::endl;\n#endif\n        return -1;\n    }\n    //force to lower case as domain names are not case sensetive\n    hostname.toLower();\n\n#ifdef NETDEBUG\n    std::cout << thread_id << \"checking certificate\" << hostname << std::endl;\n    std::cout << thread_id << \"Checking hostname against subjectAltNames\" << std::endl;\n#endif\n\n\n    bool matched = false;\n    bool hasaltname = false;\n\n    //check the altname extension for additional valid names\n    STACK_OF(GENERAL_NAME) *gens = NULL;\n    gens = (STACK_OF(GENERAL_NAME) *)X509_get_ext_d2i(peercertificate, NID_subject_alt_name, 0, 0);\n    int r = sk_GENERAL_NAME_num(gens);\n    for (int i = 0; i < r; ++i) {\n        const GENERAL_NAME *gn = sk_GENERAL_NAME_value(gens, i);\n\n        //if its not a dns entry we really dont care about it\n        if (gn->type != GEN_DNS) {\n            continue;\n        }\n\n        //only mark hasaltname as true if it has a DNS altname\n        hasaltname = true;\n\n        //an ASN1_IA5STRING is a define of an ASN1_STRING so we can do it this way\n        unsigned char *nameutf8;\n        int len = ASN1_STRING_to_UTF8(&nameutf8, gn->d.ia5);\n        if (len < 0) {\n            break;\n        }\n\n        String altname = std::string((char *)nameutf8, len);\n        OPENSSL_free(nameutf8);\n\n        //force to lower case as domain names are not case sensetive\n        altname.toLower();\n\n#ifdef NETDEBUG\n        std::cout << thread_id << \"checking against alt name \" << altname << std::endl;\n#endif\n\n        if (hostname.compare(altname) == 0) {\n            matched = true;\n            break;\n        } else if (altname.contains(\"*\")) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"Wildcard certificate is in use\" << std::endl;\n#endif\n            String  anend;\n            anend = altname.after(\"*\"); // need to keep the \".\"\n            if (hostname.endsWith(anend)) {\n                bool part_match = true;\n                String anstart = altname.before(\"*\");\n                String t = hostname.before(anend.c_str());\n                if( anstart.length() > 0) {             // if something before * we must also match this\n                  if( hostname.startsWith(anstart)) {\n                    t = t.after(anstart.c_str());\n                  } else {\n                      part_match = false;    // even though after * matches, no match on before * - so cannot match\n                   }\n                 }\n                 //    t now contains what is matched by the '*\"  - this must not contain a '.'\n                 if (part_match && !t.contains(\".\")) {\n                   matched = true;\n                   break;\n                }\n            }\n        }\n    }\n    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n\n    if (matched) {\n        X509_free(peercertificate);\n        return 0;\n    } else if (hasaltname) {\n        X509_free(peercertificate);\n        return -1;\n    }\n\n#ifdef NETDEBUG\n    std::cout << thread_id << \"checking hostname against the following common names\" << std::endl;\n#endif\n\n    X509_NAME *name = X509_get_subject_name(peercertificate);\n\n    int current_entry = -1;\n    while (1) {\n\n        //get the common name from the certificate\n        current_entry = X509_NAME_get_index_by_NID(name, NID_commonName, current_entry);\n        if (current_entry == -1) {\n            //if we've run out of common names then move on to altnames\n            break;\n        }\n\n        //X509_NAME_get_entry result must not be freed\n        X509_NAME_ENTRY *entry = X509_NAME_get_entry(name, current_entry);\n\n        ASN1_STRING *asn1name = X509_NAME_ENTRY_get_data(entry);\n\n        unsigned char *nameutf8;\n        int len = ASN1_STRING_to_UTF8(&nameutf8, asn1name);\n        if (len < 0) {\n            break;\n        }\n        String commonname = std::string((char *)nameutf8, len);\n\n        OPENSSL_free(nameutf8);\n\n        //force to lower case as domain names are not case sensetive\n        commonname.toLower();\n\n#ifdef NETDEBUG\n        std::cout << thread_id << \"checking against common name \" << commonname << std::endl;\n#endif\n\n        //compare the hostname to the common name\n        if (hostname.compare(commonname) == 0) {\n            matched = true;\n            break;\n        }\n        //see if its a wildcard certificate\n        else if (commonname.startsWith(\"*.\")) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"Wildcard certificate is in use\" << std::endl;\n#endif\n            commonname = commonname.after(\"*\"); // need to keep the \".\"\n\n            if (hostname.endsWith(commonname)) {\n                matched = true;\n                break;\n            }\n        }\n    }\n\n    if (matched) {\n        X509_free(peercertificate);\n        return 0;\n    }\n#else  // is openssl v1.1 or above\n    return 0;    //TODO\n#endif\n    return -1;\n}\n\nvoid Socket::close()\n{\n    if (isssl) {\n        stopSsl();\n    }\n    BaseSocket::close();\n}\n#endif //__SSLMITM\n\n#ifdef __SSLMITM\n//use this socket as an ssl server\nint Socket::startSslServer(X509 *x, EVP_PKEY *privKey, std::string &set_cipher_list)\n{\n\n    if (isssl) {\n        stopSsl();\n    }\n\n    // set ssl to NULL\n    ssl = NULL;\n\n    //setup the ssl server ctx\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    ctx = SSL_CTX_new(SSLv23_server_method());\n#else\n    ctx = SSL_CTX_new(TLS_server_method());\n#endif\n\n    if (ctx == NULL) {\n#ifdef NETDEBUG\n        //syslog(LOG_ERR, \"error creating ssl context\\n\");\n        std::cout << thread_id << \"Error ssl context is null (check that openssl has been inited)\" << std::endl;\n#endif\n        return -1;\n    }\n\n    //set the timeout to match firefox\n    if (SSL_CTX_set_timeout(ctx, 130l) < 1) {\n        cleanSsl();\n        return -1;\n    }\n\n    //set the ctx to use the certificate\n    if (SSL_CTX_use_certificate(ctx, x) < 1) {\n#ifdef NETDEBUG\n        //syslog(LOG_ERR, \"error creating ssl context\\n\");\n        std::cout << thread_id << \"Error using certificate\" << std::endl;\n#endif\n        cleanSsl();\n        return -1;\n    }\n\n    if (set_cipher_list.length() > 0)\n        SSL_CTX_set_cipher_list(ctx, set_cipher_list.c_str());\n\n    //set the ctx to use the private key\n    if (SSL_CTX_use_PrivateKey(ctx, privKey) < 1) {\n#ifdef NETDEBUG\n        //syslog(LOG_ERR, \"error creating ssl context\\n\");\n        std::cout << thread_id << \"Error using private key\" << std::endl;\n#endif\n        cleanSsl();\n        return -1;\n    }\n\n    //setup the ssl session\n    ERR_clear_error();\n    ssl = SSL_new(ctx);\n    SSL_set_options(ssl, SSL_OP_ALL);\n    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\n    SSL_set_accept_state(ssl);\n\n    ERR_clear_error();\n    if(!SSL_set_fd(ssl, this->getFD())) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Error setting ssl fd connection\" << std::endl;\n#endif\n        log_ssl_errors(\"ssl_set_fd failed to client %s\", \"\");\n        cleanSsl();\n        return -1;\n    };\n\n    //make io non blocking as select wont tell us if we can do a read without blocking\n\n    ERR_clear_error();\n    if (SSL_accept(ssl) < 0) {\n#ifdef NETDEBUG\n        //syslog(LOG_ERR, \"error creating ssl context\\n\");\n        std::cout << thread_id << \"Error accepting ssl connection\" << std::endl;\n#endif\n        log_ssl_errors(\"ssl_accept failed to client %s\", \"\");\n        cleanSsl();\n        return -1;\n    }\n\n    ERR_clear_error();\n    if (SSL_do_handshake(ssl) < 0) {\n#ifdef NETDEBUG\n        //syslog(LOG_ERR, \"error creating ssl context\\n\");\n        std::cout << thread_id << \"Error doing ssl handshake\" << std::endl;\n#endif\n        log_ssl_errors(\"ssl_handshake failed to client %s\", \"\");\n        cleanSsl();\n        return -1;\n    }\n    isssl = true;\n    issslserver = true;\n    return 0;\n}\n\n//modify all of these to use SSL_write(ssl,buf,len) and SSL_read(ssl,buf,buflen)\n\n//have to replace checkforinput as the ssl session will constantly generate traffic even if theres no real data\n// non-blocking check to see if there is data waiting on socket\nbool Socket::checkForInput()\n{\n    if (!isssl) {\n        return BaseSocket::checkForInput();\n    }\n#ifdef NETDEBUG\n    std::cout << thread_id << \"checking for input on ssl connection (non blocking)\" << std::endl;\n#endif\n    if ((bufflen - buffstart) > 0) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"found input on ssl connection\" << std::endl;\n#endif\n        return true;\n    }\n\n    if (!BaseSocket::checkForInput())\n        return false;\n\n    //see if we can do an ssl read of 1 byte\n//    char buf[1];\n\n    //int rc = SSL_peek(ssl, buf, 1);\n    int rc = SSL_pending(ssl);\n\n    if (rc < 1) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"no pending data on ssl connection SSL_pending \" << rc << std::endl;\n#endif\n        return false;\n    }\n\n#ifdef NETDEBUG\n    std::cout << thread_id << \"found data on ssl connection\" << std::endl;\n#endif\n\n    return true;\n}\n\nbool Socket::bcheckForInput(int timeout)\n{\n    if (!isssl) {\n        return BaseSocket::bcheckForInput(timeout);\n    }\n    return true;\n}\n\n\nbool Socket::readyForOutput()\n{\n    //if (!isssl) {\n        return BaseSocket::readyForOutput();\n    //}\n\n    //cant do this on a blocking ssl socket as far as i can work out\n\n    //return true;\n}\n\nbool Socket::breadyForOutput(int timeout)\n{\n    //if (!isssl) {\n        return BaseSocket::breadyForOutput(timeout);\n    //}\n    //return true;\n}\n\n\n// read a line from the socket, can be told to break on config reloads\nint Socket::getLine(char *buff, int size, int timeout, bool honour_reloadconfig, bool *chopped, bool *truncated)\n{\ntry {\n    if (!isssl) {\n        return BaseSocket::getLine(buff, size, timeout, honour_reloadconfig, chopped, truncated);\n    }\n\n    // first, return what's left from the previous buffer read, if anything\n    int i = 0;\n    if ((bufflen - buffstart) > 0) {\n        /*#ifdef NETDEBUG\n        std::cout << thread_id << \"data already in buffer; bufflen: \" << bufflen << \" buffstart: \" << buffstart << std::endl;\n#endif*/\n        int tocopy = size - 1;\n        if ((bufflen - buffstart) < tocopy)\n            tocopy = bufflen - buffstart;\n        char *result = (char *)memccpy(buff, buffer + buffstart, '\\n', tocopy);\n        if (result != NULL) {\n            // indicate that a newline was chopped off, if desired\n            if (chopped)\n                *chopped = true;\n            *(--result) = '\\0';\n            buffstart += (result - buff) + 1;\n            return result - buff;\n        } else {\n            i += tocopy;\n            buffstart += tocopy;\n        }\n    }\n    while (i < (size - 1)) {\n        buffstart = 0;\n        bufflen = 0;\n //       try {\n //            checkForInput(timeout, honour_reloadconfig);\n //       } catch (std::exception &e) {\n//            throw std::runtime_error(std::string(\"Can't read from socket: \") + strerror(errno)); // on error\n //       }\n//        if( bcheckSForInput(timeout))\n            bufflen = SSL_read(ssl, buffer, 4096);\n#ifdef NETDEBUG\n//std::cout << thread_id << \"read into buffer; bufflen: \" << bufflen <<std::endl;\n#endif\n        if (bufflen < 0) {\n  //          if (errno == EINTR ) {\n   //             continue;\n    //        }\n            std::cout << thread_id << \"SSL_read failed with error \" << SSL_get_error(ssl, bufflen) << std::endl;\n            log_ssl_errors(\"ssl_read failed %s\", \"\");\n            return -1;\n//            throw std::runtime_error(std::string(\"Can't read from ssl socket\")); //strerror(errno));  // on error\n        }\n        //if socket closed...\n        if (bufflen == 0) {\n            buff[i] = '\\0'; // ...terminate string & return what read\n            if (truncated)\n                *truncated = true;\n            return i;\n        }\n        int tocopy = bufflen;\n        if ((i + bufflen) > (size - 1))\n            tocopy = (size - 1) - i;\n        char *result = (char *)memccpy(buff + i, buffer, '\\n', tocopy);\n        if (result != NULL) {\n            // indicate that a newline was chopped off, if desired\n            if (chopped)\n                *chopped = true;\n            *(--result) = '\\0';\n            buffstart += (result - (buff + i)) + 1;\n            return i + (result - (buff + i));\n        }\n        i += tocopy;\n    }\n    // oh dear - buffer end reached before we found a newline\n    buff[i] = '\\0';\n    if (truncated)\n        *truncated = true;\n    return i;\n    } catch (...) {\n    return -1;    }\n}\n\n// write line to socket\nbool Socket::writeString(const char *line) //throw(std::exception)\n{\n    int l = strlen(line);\n    return writeToSocket(line, l, 0, timeout);\n}\n\n// write line to socket\nbool Socket::writeString(std::string line)\n{\n    int l = line.length();\n    return writeToSocket(line.c_str(), l, 0, timeout);\n}\n\n// write data to socket - can be told not to do an initial readyForOutput, and to break on config reloads\nbool Socket::writeToSocket(const char *buff, int len, unsigned int flags, int timeout, bool check_first, bool honour_reloadconfig)\n{\n    if (len == 0)   // nothing to write\n        return true;\n    if (!isssl) {\n        return BaseSocket::writeToSocket(buff, len, flags, timeout, check_first, honour_reloadconfig);\n    }\n\n    int actuallysent = 0;\n    int sent;\n    while (actuallysent < len) {\n       if (check_first) {\n    //        try {\n                if(!breadyForOutput(timeout))\n                   return false;\n     //       } catch (std::exception &e) {\n      //          return false;\n       //     }\n        }\n        ERR_clear_error();\n        sent = SSL_write(ssl, buff + actuallysent, len - actuallysent);\n        if (sent < 0) {\n    //        if (errno == EINTR ) {\n    //            continue; // was interupted by signal so restart\n    //        }\n            s_errno = errno;\n            String serr(s_errno);\n            log_ssl_errors(\"ssl_write failed - error \",serr.c_str());\n            return false;\n        }\n        if (sent == 0) {\n            ishup = true;\n            return false; // other end is closed\n        }\n        actuallysent += sent;\n    }\n    return true;\n}\n\n// read a specified expected amount and return what actually read\nint Socket::readFromSocketn(char *buff, int len, unsigned int flags, int timeout)\n{\n    return readFromSocket(buff, len, flags, timeout, true, false);\n\n\n#ifdef NODEF\n    if (!isssl) {\n        return BaseSocket::readFromSocketn(buff, len, flags, timeout);\n    }\n\n    int cnt, rc;\n    cnt = len;\n\n    // first, return what's left from the previous buffer read, if anything\n    if ((bufflen - buffstart) > 0) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Socket::readFromSocketn: data already in buffer; bufflen: \" << bufflen << \" buffstart: \" << buffstart << std::endl;\n#endif\n        int tocopy = len;\n        if ((bufflen - buffstart) < len)\n            tocopy = bufflen - buffstart;\n        memcpy(buff, buffer + buffstart, tocopy);\n        cnt -= tocopy;\n        buffstart += tocopy;\n        buff += tocopy;\n        if (cnt == 0)\n            return len;\n    }\n\n    while (cnt > 0) {\n    //    try {\n            //bcheckSForInput(timeout);        //  this may be wrong - why is data not being read into socket buffer????\n    //    } catch (std::exception &e) {\n     //       return -1;\n     //   }\n        ERR_clear_error();\n        rc = SSL_read(ssl, buff, cnt);\n#ifdef NETDEBUG\n        std::cout << thread_id << \"ssl read said: \" << rc << std::endl;\n#endif\n\n        if (rc < 0) {\n       //     if (errno == EINTR) {\n         //       continue;\n           // }\n            log_ssl_errors(\"ssl_read failed %s\", \"\");\n           s_errno = errno;\n            return -1;\n        }\n        if (rc == 0) { // eof\n             ishup = true;\n            return len - cnt;\n        }\n        buff += rc;\n        cnt -= rc;\n    }\n    return len;\n#endif\n}\n\n// read what's available and return error status - can be told not to do an initial checkForInput, and to break on reloads\nint Socket::readFromSocket(char *buff, int len, unsigned int flags, int timeout, bool check_first, bool honour_reloadconfig)\n{\n    if (len == 0)  // nothing to read\n         return 0;\n    if (!isssl) {\n        return BaseSocket::readFromSocket(buff, len, flags, timeout, check_first, honour_reloadconfig);\n    }\n\n    // first, return what's left from the previous buffer read, if anything\n    int cnt = len;\n    int tocopy = 0;\n    if ((bufflen - buffstart) > 0) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Socket::readFromSocket: data already in buffer; bufflen: \" << bufflen << \" buffstart: \" << buffstart << std::endl;\n#endif\n        tocopy = len;\n        if ((bufflen - buffstart) < len)\n            tocopy = bufflen - buffstart;\n        memcpy(buff, buffer + buffstart, tocopy);\n        cnt -= tocopy;\n        buffstart += tocopy;\n        buff += tocopy;\n        if (cnt == 0)\n            return len;\n    }\n\n    int rc;\n    while (cnt > 0) {\n    //if (check_first) {\n          //if(!bcheckSForInput(timeout))\n            //return -1;\n   //}\n//    while (true)\n        bool inbuffer;\n        ERR_clear_error();\n        if(true) {   //   was if (cnt > 4095)\n            inbuffer = false;\n           rc = SSL_read(ssl, buff, cnt);        //  data larger than SSL buffer so ok to read directly into output buffer\n        } else {\n            inbuffer = true;\n           rc = SSL_read(ssl, buffer, 4096);   // read into socket buffer to flush SSL buffer\n        }\n\n        if (rc < 0) {\n            s_errno = errno;\n            log_ssl_errors(\"ssl_read failed %s\", \"\");\n#ifdef NETDEBUG\n        std::cout << thread_id << \"ssl_read failed\" << s_errno << \" failed to read \" << cnt << \" bytes\" << std::endl;\n#endif\n            rc = 0;\n        }\n        if (rc == 0) { // eof\n             ishup = true;\n             return len - cnt;\n             }\n\n        if (inbuffer) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Inbuffer SSL read to return \" << cnt << \" bytes\" << std::endl;\n#endif\n\n           buffstart = 0;\n           bufflen = rc;\n           if ((bufflen - buffstart) > 0) {\n              tocopy = cnt;\n              if ((bufflen - buffstart) < cnt)\n              tocopy = bufflen - buffstart;\n              memcpy(buff, buffer + buffstart, tocopy);\n              cnt -= tocopy;\n              buffstart += tocopy;\n              buff += tocopy;\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Inbuffer SSL read to returned \" << tocopy << \" bytes\" << std::endl;\n#endif\n           }\n         } else {\n        buff += rc;\n        cnt -= rc;\n         }\n //       break;\n    }\n\n//    return rc + tocopy;\n      return len;\n}\n\n#endif //__SSLMITM\n\nvoid Socket::resetChunk() {\n    chunk_to_read = 0;\n    chunked_trailer = \"\";\n    ieof = false;\n}\n\nbool Socket::writeChunk( char *buffout, int len, int timeout){\n    std::stringstream stm;\n    stm << std::hex << len;\n    std::string hexs (stm.str());\n    //int lw;\n    hexs += \"\\r\\n\";\n#ifdef NETDEBUG\n    std::cerr << thread_id << \"writeChunk  size=\" << hexs << std::endl;\n#endif\n    if(writeString(hexs.c_str()) && writeToSocket(buffout,len,0,timeout) && writeString(\"\\r\\n\"))\n        return true;\n    return false;\n};\n\nbool Socket::writeChunkTrailer( String &trailer) {\n    std::string hexs (\"0\\r\\n\");\n#ifdef CHUNKDEBUG\n    std::cerr << thread_id << \"writeChunk  size=\" << hexs << std::endl;\n#endif\n    if(writeString(hexs.c_str()) && writeToSocket(trailer.c_str(),trailer.length(),0,timeout) && writeString(\"\\r\\n\"))\n        return true;\n    return false;\n};\n\nint Socket::readChunk( char *buffin, int maxlen, int timeout){\n    if (chunk_to_read == 0)     // need to read chunk size\n    {\n        char size[40];\n        ieof = false;\n        int len = getLine(size, 38, timeout);\n        if (len < 2) {   // min valid length is 2 i.e.  \"0\\r\"\n            chunkError = true;\n            return -1;\n        }\n#ifdef CHUNKDEBUG\n        std::cerr << thread_id << \"readChunk  size=\" << size << std::endl;\n#endif\n        String l = size;\n        l.chop();\n        String t = l.before(\";\");\n        if (t.length() > 0) {\n            if (l.endsWith(\"; ieof\")) {\n                ieof = true;\n            }\n            l = t;\n        }\n        chunk_to_read = l.hexToInteger();\n#ifdef CHUNKDEBUG\n        std::cerr << thread_id << \"readChunk  chunk_to_read =\" << chunk_to_read << std::endl;\n#endif\n    }\n\n    int clen = chunk_to_read;\n    if (clen > maxlen) {\n        clen = maxlen;\n    }\n    int rc = 0;\n#ifdef CHUNKDEBUG\n    std::cerr << thread_id << \"readChunk  max_read =\" << clen << std::endl;\n#endif\n\n    if(clen == 0) {\n        chunked_trailer = \"\";\n        char trailer[32000];\n        int len = 3;\n        while( len > 2) {\n            len = getLine(trailer, 31900, timeout);\n            if (len > 2) {\n                chunked_trailer += trailer;\n                chunked_trailer += \"\\n\";\n            }\n        }\n        return 0;\n    }\n\n    if (clen > 0) {\n        rc = readFromSocketn(buffin, clen, 0, timeout);\n#ifdef CHUNKDEBUG\n        std::cerr << thread_id << \"readChunk  read \" << rc << std::endl;\n#endif\n        if (rc < 0) {\n            chunkError = true;\n            return -1;\n        }\n        chunk_to_read -= rc;\n    }\n    if (chunk_to_read > 0)    // there is more to read in this chunk - so do not check for trailing \\r\\n\n        return rc;\n    char ts[2];\n    int len = readFromSocketn(ts, 2, 0, timeout);\n    if (len == 2 && ts[0] == '\\r' && ts[1] == '\\n') {\n        return rc;\n    } else {\n        chunkError = true;\n#ifdef CHUNKDEBUG\n        std::cerr << thread_id << \"readChunk - tail in error\" << std::endl;\n#endif\n        return -1;\n    }\n}\n\nint Socket::loopChunk(int timeout)    // reads chunks and sends back until 0 len chunk or timeout\n{\n    char buff[32000];\n    int tot_size = 0;\n    int csize = 1;\n    while (csize > 0) {\n        csize = readChunk(buff,32000, timeout);\n        if (csize == 0)     // end chunk\n        {\n            if (!writeChunkTrailer(chunked_trailer))\n            {\n#ifdef CHUNKDEBUG\n                std::cerr << thread_id << \"loopChunk - error in writing chunk trailer\" << std::endl;\n#endif\n                return -1;\n\n            };\n#ifdef CHUNKDEBUG\n            std::cerr << thread_id << \"loopChunk  tot_size=\" << tot_size << std::endl;\n#endif\n            return tot_size;\n        }\n        if (!(csize > 0 && writeChunk(buff,csize,timeout))) {\n#ifdef CHUNKDEBUG\n            std::cerr << thread_id << \"loopChunk - error\" << std::endl;\n#endif\n            return -1;\n        }\n        tot_size += csize;\n    }\n    return -1;  // should never get here!\n}\n\n\nint Socket::drainChunk(int timeout)    // reads chunks until 0 len chunk or timeout\n{\n    char buff[32000];\n    int tot_size = 0;\n    int csize = 1;\n    while (csize > 0) {\n        csize = readChunk(buff,32000, timeout);\n        if (!(csize > -1 )) {\n#ifdef CHUNKDEBUG\n            std::cerr << thread_id << \"drainChunk - error\" << std::endl;\n#endif\n            return -1;\n        }\n        tot_size += csize;\n    }\n#ifdef CHUNKDEBUG\n    std::cerr << thread_id << \"drainChunk  tot_size=\" << tot_size << std::endl;\n#endif\n    return tot_size;\n}\n\nbool Socket::getIeof() {\n    return ieof;\n}\n"], "filenames": ["src/Socket.cpp"], "buggy_code_start_loc": [379], "buggy_code_end_loc": [379], "fixing_code_start_loc": [380], "fixing_code_end_loc": [384], "type": "CWE-295", "message": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "other": {"cve": {"id": "CVE-2021-44273", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-23T12:15:07.387", "lastModified": "2022-01-11T17:50:05.910", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks."}, {"lang": "es", "value": "e2guardian versiones v5.4.x versiones anteriores a v5.4.3r incluy\u00e9ndola, est\u00e1 afectado por la falta de comprobaci\u00f3n de certificados SSL en el motor SSL MITM. En modo aut\u00f3nomo (es decir, actuando como proxy o proxy transparente), con SSL MITM habilitado, e2guardian, si est\u00e1 construido con OpenSSL versi\u00f3n v1.1.x, no comprueba los nombres de host en los certificados de los servidores web a los que son conectados, y por lo tanto es vulnerable a los ataques de tipo MITM"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:e2bn:e2guardian:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4.0", "versionEndIncluding": "5.4.3r", "matchCriteriaId": "3215FB43-3E00-4B8F-B56A-15E689EB7464"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/12/23/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/e2guardian/e2guardian/issues/707", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2"}}