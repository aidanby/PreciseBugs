{"buggy_code": ["/*********************************************************************\n * PicoTCP-NG \n * Copyright (c) 2020 Daniele Lacamera <root@danielinux.net>\n *\n * This file also includes code from:\n * PicoTCP\n * Copyright (c) 2012-2017 Altran Intelligent Systems\n * Authors: Daniele Lacamera, Philippe Mariman\n * SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only\n *\n * PicoTCP-NG is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) version 3.\n *\n * PicoTCP-NG is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n *\n *\n *********************************************************************/\n#include \"pico_tcp.h\"\n#include \"pico_config.h\"\n#include \"pico_eth.h\"\n#include \"pico_socket.h\"\n#include \"pico_stack.h\"\n#include \"pico_socket.h\"\n#include \"pico_socket_tcp.h\"\n#include \"pico_queue.h\"\n#include \"pico_tree.h\"\n#include \"pico_jobs.h\"\n\n#define TCP_IS_STATE(s, st) ((s->state & PICO_SOCKET_STATE_TCP) == st)\n#define TCP_SOCK(s) ((struct pico_socket_tcp *)s)\n#define SEQN(f) ((f) ? (long_be(((struct pico_tcp_hdr *)((f)->transport_hdr))->seq)) : 0)\n#define ACKN(f) ((f) ? (long_be(((struct pico_tcp_hdr *)((f)->transport_hdr))->ack)) : 0)\n\n#define TCP_TIME (pico_time)(PICO_TIME_MS())\n\n#define PICO_TCP_RTO_MIN (70)\n#define PICO_TCP_RTO_MAX (120000)\n#define PICO_TCP_IW          2\n#define PICO_TCP_SYN_TO  2000u\n#define PICO_TCP_ZOMBIE_TO 30000\n\n#define PICO_TCP_MAX_RETRANS         10\n#define PICO_TCP_MAX_CONNECT_RETRIES 3\n\n#define PICO_TCP_LOOKAHEAD      0x00\n#define PICO_TCP_FIRST_DUPACK   0x01\n#define PICO_TCP_SECOND_DUPACK  0x02\n#define PICO_TCP_RECOVER        0x03\n#define PICO_TCP_BLACKOUT       0x04\n#define PICO_TCP_UNREACHABLE    0x05\n#define PICO_TCP_WINDOW_FULL    0x06\n\n#define ONE_GIGABYTE ((uint32_t)(1024UL * 1024UL * 1024UL))\n\n/* check if tcp connection is \"idle\" according to Nagle (RFC 896) */\n#define IS_TCP_IDLE(t)          ((t->in_flight == 0) && (t->tcpq_out.size == 0))\n/* check if the hold queue contains data (again Nagle) */\n#define IS_TCP_HOLDQ_EMPTY(t)   (t->tcpq_hold.size == 0)\n\n#define IS_INPUT_QUEUE(q)  (q->pool.compare == input_segment_compare)\n#define TCP_INPUT_OVERHEAD (sizeof(struct tcp_input_segment) + sizeof(struct pico_tree_node))\n\n\n#ifdef PICO_SUPPORT_TCP\n#ifdef DEBUG_TCP_GENERAL\n#define tcp_dbg              dbg\n#else\n#define tcp_dbg(...)         do {} while(0)\n#endif\n\n#ifdef DEBUG_TCP_NAGLE\n#define tcp_dbg_nagle        dbg\n#else\n#define tcp_dbg_nagle(...)   do {} while(0)\n#endif\n\n#ifdef DEBUG_TCP_OPTIONS\n#define tcp_dbg_options      dbg\n#else\n#define tcp_dbg_options(...) do {} while(0)\n#endif\n\n#ifdef PICO_SUPPORT_MUTEX\nstatic void *Mutex = NULL;\n#endif\n\n\n\n/* Input segment, used to keep only needed data, not the full frame */\nstruct tcp_input_segment\n{\n    uint32_t seq;\n    /* Pointer to payload */\n    unsigned char *payload;\n    uint16_t payload_len;\n};\n\n/* Function to compare input segments */\nstatic int input_segment_compare(void *ka, void *kb)\n{\n    struct tcp_input_segment *a = ka, *b = kb;\n    return pico_seq_compare(a->seq, b->seq);\n}\n\nstatic struct tcp_input_segment *segment_from_frame(struct pico_frame *f)\n{\n    struct tcp_input_segment *seg;\n\n    if (!f->payload_len)\n        return NULL;\n\n    seg = PICO_ZALLOC(sizeof(struct tcp_input_segment));\n    if (!seg)\n        return NULL;\n\n    seg->payload = PICO_ZALLOC(f->payload_len);\n    if(!seg->payload)\n    {\n        PICO_FREE(seg);\n        return NULL;\n    }\n\n    seg->seq = SEQN(f);\n    seg->payload_len = f->payload_len;\n    memcpy(seg->payload, f->payload, seg->payload_len);\n    return seg;\n}\n\nstatic int segment_compare(void *ka, void *kb)\n{\n    struct pico_frame *a = ka, *b = kb;\n    return pico_seq_compare(SEQN(a), SEQN(b));\n}\n\nstruct pico_tcp_queue\n{\n    struct pico_tree pool;\n    uint32_t max_size;\n    uint32_t size;\n    uint32_t frames;\n};\n\nstatic void tcp_discard_all_segments(struct pico_tcp_queue *tq);\nstatic void *peek_segment(struct pico_tcp_queue *tq, uint32_t seq)\n{\n    if(!IS_INPUT_QUEUE(tq))\n    {\n        struct pico_tcp_hdr H;\n        struct pico_frame f = {\n            0\n        };\n        f.transport_hdr = (uint8_t *) (&H);\n        H.seq = long_be(seq);\n\n        return pico_tree_findKey(&tq->pool, &f);\n    }\n    else\n    {\n        struct tcp_input_segment dummy = {\n            0\n        };\n        dummy.seq = seq;\n\n        return pico_tree_findKey(&tq->pool, &dummy);\n    }\n\n}\n\nstatic void *first_segment(struct pico_tcp_queue *tq)\n{\n    return pico_tree_first(&tq->pool);\n}\n\nstatic void *next_segment(struct pico_tcp_queue *tq, void *cur)\n{\n    if (!cur)\n        return NULL;\n\n    if(IS_INPUT_QUEUE(tq))\n    {\n        return peek_segment(tq, ((struct tcp_input_segment *)cur)->seq + ((struct tcp_input_segment *)cur)->payload_len);\n    }\n    else\n    {\n        return peek_segment(tq, SEQN((struct pico_frame *)cur) + ((struct pico_frame *)cur)->payload_len);\n    }\n}\n\nstatic uint16_t enqueue_segment_len(struct pico_tcp_queue *tq, void *f)\n{\n    if (IS_INPUT_QUEUE(tq)) {\n        return ((struct tcp_input_segment *)f)->payload_len;\n    } else {\n        return (uint16_t)(((struct pico_frame *)f)->buffer_len);\n    }\n}\n\n\nstatic int32_t do_enqueue_segment(struct pico_tcp_queue *tq, void *f, uint16_t payload_len)\n{\n    int32_t ret = -1;\n    PICOTCP_MUTEX_LOCK(Mutex);\n    if ((tq->size + payload_len) > tq->max_size)\n    {\n        ret = 0;\n        goto out;\n    }\n\n    if (pico_tree_insert(&tq->pool, f) != 0)\n    {\n        ret = 0;\n        goto out;\n    }\n\n    tq->size += (uint16_t)payload_len;\n    if (payload_len > 0)\n        tq->frames++;\n\n    ret = (int32_t)payload_len;\n\nout:\n    PICOTCP_MUTEX_UNLOCK(Mutex);\n    return ret;\n}\n\nstatic int32_t pico_enqueue_segment(struct pico_tcp_queue *tq, void *f)\n{\n    uint16_t payload_len;\n\n    if (!f)\n        return -1;\n\n    payload_len = enqueue_segment_len(tq, f);\n\n\n    if (payload_len == 0) {\n        tcp_dbg(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! TRIED TO ENQUEUE INVALID SEGMENT!\\n\");\n        return -1;\n    }\n\n    return do_enqueue_segment(tq, f, payload_len);\n}\n\nstatic void pico_discard_segment(struct pico_tcp_queue *tq, void *f)\n{\n    void *f1;\n    uint16_t payload_len = (uint16_t)((IS_INPUT_QUEUE(tq)) ?\n                                      (((struct tcp_input_segment *)f)->payload_len) :\n                                      (((struct pico_frame *)f)->buffer_len));\n    PICOTCP_MUTEX_LOCK(Mutex);\n    f1 = pico_tree_delete(&tq->pool, f);\n    if (f1) {\n        tq->size -= (uint16_t)payload_len;\n        if (payload_len > 0)\n            tq->frames--;\n    }\n\n    if(f1 && IS_INPUT_QUEUE(tq))\n    {\n        struct tcp_input_segment *inp = f1;\n        PICO_FREE(inp->payload);\n        PICO_FREE(inp);\n    }\n    else\n        pico_frame_discard(f);\n\n    PICOTCP_MUTEX_UNLOCK(Mutex);\n}\n\n/* Structure for TCP socket */\nstruct tcp_sack_block {\n    uint32_t left;\n    uint32_t right;\n    struct tcp_sack_block *next;\n};\n\nstruct pico_socket_tcp {\n    struct pico_socket sock;\n\n    /* Tree/queues */\n    struct pico_tcp_queue tcpq_in;  /* updated the input queue to hold input segments not the full frame. */\n    struct pico_tcp_queue tcpq_out;\n    struct pico_tcp_queue tcpq_hold; /* buffer to hold delayed frames according to Nagle */\n\n    /* tcp_output */\n    uint32_t snd_nxt;\n    uint32_t snd_last;\n    uint32_t snd_old_ack;\n    uint32_t snd_retry;\n    uint32_t snd_last_out;\n\n    /* congestion control */\n    uint32_t avg_rtt;\n    uint32_t rttvar;\n    uint32_t rto;\n    uint32_t in_flight;\n    uint32_t retrans_tmr;\n    pico_time retrans_tmr_due;\n    uint16_t cwnd_counter;\n    uint16_t cwnd;\n    uint16_t ssthresh;\n    uint16_t recv_wnd;\n    uint16_t recv_wnd_scale;\n\n    /* tcp_input */\n    uint32_t rcv_nxt;\n    uint32_t rcv_ackd;\n    uint32_t rcv_processed;\n    uint16_t wnd;\n    uint16_t wnd_scale;\n    uint16_t remote_closed;\n\n    /* options */\n    uint32_t ts_nxt;\n    uint16_t mss;\n    uint8_t sack_ok;\n    uint8_t ts_ok;\n    uint8_t mss_ok;\n    uint8_t scale_ok;\n    struct tcp_sack_block *sacks;\n    uint32_t linger_timeout;\n\n    /* Transmission */\n    uint8_t x_mode;\n    uint8_t dupacks;\n    uint8_t backoff;\n    uint8_t localZeroWindow;\n\n    /* Keepalive */\n    uint32_t keepalive_tmr;\n    pico_time ack_timestamp;\n    uint32_t ka_time;\n    uint32_t ka_intvl;\n    uint32_t ka_probes;\n    uint32_t ka_retries_count;\n\n    /* FIN timer */\n    uint32_t fin_tmr;\n};\n\n/* If Nagle enabled, this function can make 1 new segment from smaller segments in hold queue */\nstatic struct pico_frame *pico_hold_segment_make(struct pico_socket_tcp *t);\n\n/* checks if tcpq_in is empty */\nint pico_tcp_queue_in_is_empty(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n\n    if (t->tcpq_in.frames == 0)\n        return 1;\n    else\n        return 0;\n}\n\n/* checks tcpq_in size */\nint pico_tcp_queue_in_size(struct pico_socket *s)\n{\n    struct tcp_input_segment *f;\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    if (!t)\n        return -1;\n    f = first_segment(&t->tcpq_in);\n    if (!f)\n        return 0;\n    return f->payload_len;\n}\n\n/* Useful for getting rid of the beginning of the buffer (read() op) */\nstatic int release_until(struct pico_tcp_queue *q, uint32_t seq)\n{\n    void *head = first_segment(q);\n    int ret = 0;\n    int32_t seq_result = 0;\n\n    if (!head)\n        return ret;\n\n    do {\n        void *cur = head;\n\n        if (IS_INPUT_QUEUE(q))\n            seq_result = pico_seq_compare(((struct tcp_input_segment *)head)->seq + ((struct tcp_input_segment *)head)->payload_len, seq);\n        else\n            seq_result = pico_seq_compare(SEQN((struct pico_frame *)head) + ((struct pico_frame *)head)->payload_len, seq);\n\n        if (seq_result <= 0)\n        {\n            head = next_segment(q, cur);\n            /* tcp_dbg(\"Releasing %08x, len: %d\\n\", SEQN((struct pico_frame *)head), ((struct pico_frame *)head)->payload_len); */\n            pico_discard_segment(q, cur);\n            ret++;\n        } else {\n            break;\n        }\n    } while (head);\n\n    return ret;\n}\n\nstatic int release_all_until(struct pico_tcp_queue *q, uint32_t seq, pico_time *timestamp)\n{\n    void *f = NULL;\n    struct pico_tree_node *idx, *temp;\n    int seq_result;\n    int ret = 0;\n    *timestamp = 0;\n\n    pico_tree_foreach_safe(idx, &q->pool, temp)\n    {\n        f = idx->keyValue;\n\n        if (IS_INPUT_QUEUE(q))\n            seq_result = pico_seq_compare(((struct tcp_input_segment *)f)->seq + ((struct tcp_input_segment *)f)->payload_len, seq);\n        else\n            seq_result = pico_seq_compare(SEQN((struct pico_frame *)f) + ((struct pico_frame *)f)->payload_len, seq);\n\n        if (seq_result <= 0) {\n            tcp_dbg(\"Releasing %p\\n\", f);\n            if ((seq_result == 0) && !IS_INPUT_QUEUE(q))\n                *timestamp = ((struct pico_frame *)f)->timestamp;\n\n            pico_discard_segment(q, f);\n            ret++;\n        } else {\n            return ret;\n        }\n    }\n    return ret;\n}\n\n\n/* API calls */\n\nuint16_t pico_tcp_checksum_ipv4(struct pico_frame *f)\n{\n    struct pico_ipv4_hdr *hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    struct pico_tcp_hdr *tcp_hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    struct pico_socket *s = f->sock;\n    struct pico_ipv4_pseudo_hdr pseudo;\n\n    if (s) {\n        /* Case of outgoing frame */\n        /* dbg(\"TCP CRC: on outgoing frame\\n\"); */\n        pseudo.src.addr = s->local_addr.ip4.addr;\n        pseudo.dst.addr = s->remote_addr.ip4.addr;\n    } else {\n        /* Case of incoming frame */\n        /* dbg(\"TCP CRC: on incoming frame\\n\"); */\n        pseudo.src.addr = hdr->src.addr;\n        pseudo.dst.addr = hdr->dst.addr;\n    }\n\n    pseudo.zeros = 0;\n    pseudo.proto = PICO_PROTO_TCP;\n    pseudo.len = (uint16_t)short_be(f->transport_len);\n\n    return pico_dualbuffer_checksum(&pseudo, sizeof(struct pico_ipv4_pseudo_hdr), tcp_hdr, f->transport_len);\n}\n\n#ifdef PICO_SUPPORT_IPV6\nuint16_t pico_tcp_checksum_ipv6(struct pico_frame *f)\n{\n    struct pico_ipv6_hdr *ipv6_hdr = (struct pico_ipv6_hdr *)f->net_hdr;\n    struct pico_tcp_hdr *tcp_hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    struct pico_ipv6_pseudo_hdr pseudo;\n    struct pico_socket *s = f->sock;\n\n    /* XXX If the IPv6 packet contains a Routing header, the Destination\n     *     Address used in the pseudo-header is that of the final destination */\n    if (s) {\n        /* Case of outgoing frame */\n        pseudo.src = s->local_addr.ip6;\n        pseudo.dst = s->remote_addr.ip6;\n    } else {\n        /* Case of incoming frame */\n        pseudo.src = ipv6_hdr->src;\n        pseudo.dst = ipv6_hdr->dst;\n    }\n\n    pseudo.zero[0] = 0;\n    pseudo.zero[1] = 0;\n    pseudo.zero[2] = 0;\n    pseudo.len = long_be(f->transport_len);\n    pseudo.nxthdr = PICO_PROTO_TCP;\n\n    return pico_dualbuffer_checksum(&pseudo, sizeof(struct pico_ipv6_pseudo_hdr), tcp_hdr, f->transport_len);\n}\n#endif\n\n#ifdef PICO_SUPPORT_IPV4\nstatic inline int checksum_is_ipv4(struct pico_frame *f)\n{\n    return (IS_IPV4(f) || (f->sock && (f->sock->net == &pico_proto_ipv4)));\n}\n#endif\n\n#ifdef PICO_SUPPORT_IPV6\nstatic inline int checksum_is_ipv6(struct pico_frame *f)\n{\n    return ((IS_IPV6(f)) || (f->sock && (f->sock->net == &pico_proto_ipv6)));\n}\n#endif\n\nuint16_t pico_tcp_checksum(struct pico_frame *f)\n{\n    (void)f;\n\n    #ifdef PICO_SUPPORT_IPV4\n    if (checksum_is_ipv4(f))\n        return pico_tcp_checksum_ipv4(f);\n\n    #endif\n\n    #ifdef PICO_SUPPORT_IPV6\n    if (checksum_is_ipv6(f))\n        return pico_tcp_checksum_ipv6(f);\n\n    #endif\n    return 0xffff;\n}\n\nstatic void tcp_send_fin(struct pico_socket_tcp *t);\nstatic int pico_tcp_process_out(struct pico_stack *S, struct pico_protocol *self, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr;\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    IGNORE_PARAMETER(S);\n    IGNORE_PARAMETER(self);\n    hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    f->sock->timestamp = TCP_TIME;\n    if (f->payload_len > 0) {\n        tcp_dbg(\"Process out: sending %p (%d bytes)\\n\", f, f->payload_len);\n    } else {\n        tcp_dbg(\"Sending empty packet\\n\");\n    }\n\n    if (f->payload_len > 0) {\n        if (pico_seq_compare(SEQN(f) + f->payload_len, t->snd_nxt) > 0) {\n            t->snd_nxt = SEQN(f) + f->payload_len;\n            tcp_dbg(\"%s: snd_nxt is now %08x\\n\", __FUNCTION__, t->snd_nxt);\n        }\n    } else if (hdr->flags == PICO_TCP_ACK) { /* pure ack */\n        /* hdr->seq = long_be(t->snd_nxt);   / * XXX disabled this to not to mess with seq nrs of ACKs anymore * / */\n    } else {\n        tcp_dbg(\"%s: non-pure ACK with len=0, fl:%04x\\n\", __FUNCTION__, hdr->flags);\n    }\n\n    pico_network_send(f);\n    return 0;\n}\n\nint pico_tcp_push(struct pico_stack *S, struct pico_protocol *self, struct pico_frame *data);\n\n/* Interface: protocol definition */\nstruct pico_protocol pico_proto_tcp = {\n    .name = \"tcp\",\n    .proto_number = PICO_PROTO_TCP,\n    .layer = PICO_LAYER_TRANSPORT,\n    .process_in = pico_transport_process_in,\n    .process_out = pico_tcp_process_out,\n    .push = pico_tcp_push,\n};\n\nstatic uint32_t pico_paws(void)\n{\n    static uint32_t _paws = 0;\n    _paws = pico_rand();\n    return long_be(_paws);\n}\n\nstatic inline void tcp_add_sack_option(struct pico_socket_tcp *ts, struct pico_frame *f, uint16_t flags, uint32_t *ii)\n{\n    if (flags & PICO_TCP_ACK) {\n        struct tcp_sack_block *sb;\n        uint32_t len_off;\n\n        if (ts->sack_ok && ts->sacks) {\n            f->start[(*ii)++] = PICO_TCP_OPTION_SACK;\n            len_off = *ii;\n            f->start[(*ii)++] = PICO_TCPOPTLEN_SACK;\n            while(ts->sacks) {\n                sb = ts->sacks;\n                ts->sacks = sb->next;\n                memcpy(f->start + *ii, sb, 2 * sizeof(uint32_t));\n                *ii += (2 * (uint32_t)sizeof(uint32_t));\n                f->start[len_off] = (uint8_t)(f->start[len_off] + (2 * sizeof(uint32_t)));\n                PICO_FREE(sb);\n            }\n        }\n    }\n}\n\nstatic void tcp_add_options(struct pico_socket_tcp *ts, struct pico_frame *f, uint16_t flags, uint16_t optsiz)\n{\n    uint32_t tsval = long_be((uint32_t)TCP_TIME);\n    uint32_t tsecr = long_be(ts->ts_nxt);\n    uint32_t i = 0;\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n\n    memset(f->start, PICO_TCP_OPTION_NOOP, optsiz); /* fill blanks with noop */\n\n    if (flags & PICO_TCP_SYN) {\n        f->start[i++] = PICO_TCP_OPTION_MSS;\n        f->start[i++] = PICO_TCPOPTLEN_MSS;\n        f->start[i++] = (uint8_t)((ts->mss >> 8) & 0xFF);\n        f->start[i++] = (uint8_t)(ts->mss & 0xFF);\n        f->start[i++] = PICO_TCP_OPTION_SACK_OK;\n        f->start[i++] = PICO_TCPOPTLEN_SACK_OK;\n    }\n\n    f->start[i++] = PICO_TCP_OPTION_WS;\n    f->start[i++] = PICO_TCPOPTLEN_WS;\n    f->start[i++] = (uint8_t)(ts->wnd_scale);\n\n    if ((flags & PICO_TCP_SYN) || ts->ts_ok) {\n        f->start[i++] = PICO_TCP_OPTION_TIMESTAMP;\n        f->start[i++] = PICO_TCPOPTLEN_TIMESTAMP;\n        memcpy(f->start + i, &tsval, 4);\n        i += 4;\n        memcpy(f->start + i, &tsecr, 4);\n        i += 4;\n    }\n\n    tcp_add_sack_option(ts, f, flags, &i);\n\n    if (i < optsiz)\n        f->start[ optsiz - 1 ] = PICO_TCP_OPTION_END;\n}\n\nstatic uint16_t tcp_options_size_frame(struct pico_frame *f)\n{\n    uint16_t size = 0;\n\n    /* Always update window scale. */\n    size = (uint16_t)(size + PICO_TCPOPTLEN_WS);\n    if (f->transport_flags_saved)\n        size = (uint16_t)(size + PICO_TCPOPTLEN_TIMESTAMP);\n\n    size = (uint16_t)(size + PICO_TCPOPTLEN_END);\n    size = (uint16_t)(((uint16_t)(size + 3u) >> 2u) << 2u);\n    return size;\n}\n\nstatic void tcp_add_options_frame(struct pico_socket_tcp *ts, struct pico_frame *f)\n{\n    uint32_t tsval = long_be((uint32_t)TCP_TIME);\n    uint32_t tsecr = long_be(ts->ts_nxt);\n    uint32_t i = 0;\n    uint16_t optsiz = tcp_options_size_frame(f);\n\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n\n    memset(f->start, PICO_TCP_OPTION_NOOP, optsiz); /* fill blanks with noop */\n\n\n    f->start[i++] = PICO_TCP_OPTION_WS;\n    f->start[i++] = PICO_TCPOPTLEN_WS;\n    f->start[i++] = (uint8_t)(ts->wnd_scale);\n\n    if (f->transport_flags_saved) {\n        f->start[i++] = PICO_TCP_OPTION_TIMESTAMP;\n        f->start[i++] = PICO_TCPOPTLEN_TIMESTAMP;\n        memcpy(f->start + i, &tsval, 4);\n        i += 4;\n        memcpy(f->start + i, &tsecr, 4);\n        i += 4;\n    }\n\n    if (i < optsiz)\n        f->start[ optsiz - 1 ] = PICO_TCP_OPTION_END;\n}\n\nstatic void tcp_send_ack(struct pico_socket_tcp *t);\n#define tcp_send_windowUpdate(t) (tcp_send_ack(t))\n\nstatic inline void tcp_set_space_check_winupdate(struct pico_socket_tcp *t, int32_t space, uint32_t shift)\n{\n    if (((uint32_t)space != t->wnd) || (shift != t->wnd_scale) || ((space - t->wnd) > (int32_t)((uint32_t)space >> 2u))) {\n        t->wnd = (uint16_t)space;\n        t->wnd_scale = (uint16_t)shift;\n\n        if(t->wnd == 0) /* mark the entering to zero window state */\n            t->localZeroWindow = 1u;\n        else if(t->localZeroWindow)\n        {\n            t->localZeroWindow = 0u;\n            tcp_send_windowUpdate(t);\n        }\n    }\n}\n\nstatic void tcp_set_space(struct pico_socket_tcp *t)\n{\n    int32_t space;\n    uint32_t shift = 0;\n\n    if (t->tcpq_in.max_size == 0) {\n        space = ONE_GIGABYTE;\n    } else {\n        space = (int32_t)(t->tcpq_in.max_size - t->tcpq_in.size);\n    }\n\n    if (space < 0)\n        space = 0;\n\n    while(space > 0xFFFF) {\n        space = (int32_t)(((uint32_t)space >> 1u));\n        shift++;\n    }\n    tcp_set_space_check_winupdate(t, space, shift);\n}\n\n/* Return 32-bit aligned option size */\nstatic uint16_t tcp_options_size(struct pico_socket_tcp *t, uint16_t flags)\n{\n    uint16_t size = 0;\n    struct tcp_sack_block *sb = t->sacks;\n\n    if (flags & PICO_TCP_SYN) { /* Full options */\n        size = PICO_TCPOPTLEN_MSS + PICO_TCP_OPTION_SACK_OK + PICO_TCPOPTLEN_WS + PICO_TCPOPTLEN_TIMESTAMP;\n    } else {\n\n        /* Always update window scale. */\n        size = (uint16_t)(size + PICO_TCPOPTLEN_WS);\n\n        if (t->ts_ok)\n            size = (uint16_t)(size + PICO_TCPOPTLEN_TIMESTAMP);\n\n        size = (uint16_t)(size + PICO_TCPOPTLEN_END);\n    }\n\n    if ((flags & PICO_TCP_ACK) && (t->sack_ok && sb)) {\n        size = (uint16_t)(size + 2);\n        while(sb) {\n            size = (uint16_t)(size + (2 * sizeof(uint32_t)));\n            sb = sb->next;\n        }\n    }\n\n    size = (uint16_t)(((size + 3u) >> 2u) << 2u);\n    return size;\n}\n\nuint16_t pico_tcp_overhead(struct pico_socket *s)\n{\n    if (!s)\n        return 0;\n\n    return (uint16_t)(PICO_SIZE_TCPHDR + tcp_options_size((struct pico_socket_tcp *)s, (uint16_t)0)); /* hdr + Options size for data pkt */\n\n}\n\nstatic inline int tcp_sack_marker(struct pico_frame *f, uint32_t start, uint32_t end, uint16_t *count)\n{\n    int cmp;\n    cmp = pico_seq_compare(SEQN(f), start);\n    if (cmp > 0)\n        return 0;\n\n    if (cmp == 0) {\n        cmp = pico_seq_compare(SEQN(f) + f->payload_len, end);\n        if (cmp > 0) {\n            tcp_dbg(\"Invalid SACK: ignoring.\\n\");\n        }\n\n        tcp_dbg(\"Marking (by SACK) segment %08x BLK:[%08x::%08x]\\n\", SEQN(f), start, end);\n        f->flags |= PICO_FRAME_FLAG_SACKED;\n        (*count)++;\n    }\n\n    return cmp;\n}\n\nstatic void tcp_process_sack(struct pico_socket_tcp *t, uint32_t start, uint32_t end)\n{\n    struct pico_frame *f;\n    struct pico_tree_node *index, *temp;\n    uint16_t count = 0;\n\n    pico_tree_foreach_safe(index, &t->tcpq_out.pool, temp){\n        f = index->keyValue;\n        if (tcp_sack_marker(f, start, end, &count) == 0)\n            goto done;\n    }\n\ndone:\n    if (t->x_mode > PICO_TCP_LOOKAHEAD) {\n        if (t->in_flight > (count))\n            t->in_flight -= (count);\n        else\n            t->in_flight = 0;\n    }\n}\n\ninline static void tcp_add_header(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    f->timestamp = TCP_TIME;\n    tcp_add_options(t, f, 0, (uint16_t)(f->transport_len - f->payload_len - (uint16_t)PICO_SIZE_TCPHDR));\n    hdr->rwnd = short_be(t->wnd);\n    hdr->flags |= PICO_TCP_PSH | PICO_TCP_ACK;\n    hdr->ack = long_be(t->rcv_nxt);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n}\n\nstatic void tcp_rcv_sack(struct pico_socket_tcp *t, uint8_t *opt, int len)\n{\n    uint32_t start, end;\n    int i = 0;\n    if (len % 8) {\n        tcp_dbg(\"SACK: Invalid len.\\n\");\n        return;\n    }\n\n    while (i < len) {\n        start = long_from(opt + i);\n        i += 4;\n        end = long_from(opt + i);\n        i += 4;\n        tcp_process_sack(t, long_be(start), long_be(end));\n    }\n}\n\nstatic int tcpopt_len_check(uint32_t *idx, uint8_t len, uint8_t expected)\n{\n    if (len != expected) {\n        if (len < 2)\n            return -1;\n        *idx = *idx + len - 2;\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic inline void tcp_parse_option_ws(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_WS) < 0)\n        return;\n\n    t->recv_wnd_scale = opt[(*idx)++];\n    tcp_dbg_options(\"TCP Window scale: received %d\\n\", t->recv_wnd_scale);\n\n}\n\nstatic inline void tcp_parse_option_sack_ok(struct pico_socket_tcp *t, struct pico_frame *f, uint8_t len, uint32_t *idx)\n{\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_SACK_OK) < 0)\n        return;\n\n    if(((struct pico_tcp_hdr *)(f->transport_hdr))->flags & PICO_TCP_SYN )\n        t->sack_ok = 1;\n}\n\nstatic inline void tcp_parse_option_mss(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    uint16_t mss;\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_MSS) < 0)\n        return;\n\n    t->mss_ok = 1;\n    mss = short_from(opt + *idx);\n    *idx += (uint32_t)sizeof(uint16_t);\n    if (t->mss > short_be(mss))\n        t->mss = short_be(mss);\n}\n\nstatic inline void tcp_parse_option_timestamp(struct pico_socket_tcp *t, struct pico_frame *f, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    uint32_t tsval, tsecr;\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_TIMESTAMP) < 0)\n        return;\n\n    t->ts_ok = 1;\n    tsval = long_from(opt + *idx);\n    *idx += (uint32_t)sizeof(uint32_t);\n    tsecr = long_from(opt + *idx);\n    f->timestamp = long_be(tsecr);\n    *idx += (uint32_t)sizeof(uint32_t);\n    t->ts_nxt = long_be(tsval);\n}\n\nstatic int tcp_parse_options(struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n    uint32_t i = 0;\n    f->timestamp = 0;\n    while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n        uint8_t type =  opt[i++];\n        uint8_t len;\n        if(i < (f->transport_len - PICO_SIZE_TCPHDR) && (type > 1))\n            len =  opt[i++];\n        else\n            len = 1;\n\n        if (f->payload && ((opt + i) > f->payload))\n            break;\n\n        if (len == 0) {\n            return -1;\n        }\n\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", type, len);\n        switch (type) {\n        case PICO_TCP_OPTION_NOOP:\n        case PICO_TCP_OPTION_END:\n            break;\n        case PICO_TCP_OPTION_WS:\n            tcp_parse_option_ws(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK_OK:\n            tcp_parse_option_sack_ok(t, f, len, &i);\n            break;\n        case PICO_TCP_OPTION_MSS:\n            tcp_parse_option_mss(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_TIMESTAMP:\n            tcp_parse_option_timestamp(t, f, len, opt, &i);\n            break;\n\n        case PICO_TCP_OPTION_SACK:\n            tcp_rcv_sack(t, opt + i, len - 2);\n            i = i + len - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", type);\n            i = i + len - 2;\n        }\n    }\n    return 0;\n}\n\nstatic inline void tcp_send_add_tcpflags(struct pico_socket_tcp *ts, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    if (ts->rcv_nxt != 0) {\n        if ((ts->rcv_ackd == 0) || (pico_seq_compare(ts->rcv_ackd, ts->rcv_nxt) != 0) || (hdr->flags & PICO_TCP_ACK)) {\n            hdr->flags |= PICO_TCP_ACK;\n            hdr->ack = long_be(ts->rcv_nxt);\n            ts->rcv_ackd = ts->rcv_nxt;\n        }\n    }\n\n    if (hdr->flags & PICO_TCP_SYN) {\n        ts->snd_nxt++;\n    }\n\n    if (f->payload_len > 0) {\n        hdr->flags |= PICO_TCP_PSH | PICO_TCP_ACK;\n        hdr->ack = long_be(ts->rcv_nxt);\n        ts->rcv_ackd = ts->rcv_nxt;\n    }\n}\n\nstatic inline int tcp_send_try_enqueue(struct pico_socket_tcp *ts, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    struct pico_frame *cpy;\n    (void)hdr;\n\n    /* TCP: ENQUEUE to PROTO ( Transmit ) */\n    cpy = pico_frame_copy(f);\n    if (!cpy) {\n        pico_err = PICO_ERR_ENOMEM;\n        return -1;\n    }\n\n    if ((pico_enqueue(&ts->sock.stack->q_tcp.out, cpy) > 0)) {\n        if (f->payload_len > 0) {\n            ts->in_flight++;\n            ts->snd_nxt += f->payload_len; /* update next pointer here to prevent sending same segment twice when called twice in same tick */\n        }\n\n        tcp_dbg(\"DBG> [tcp output] state: %02x --> local port:%u remote port: %u seq: %08x ack: %08x flags: %02x = t_len: %u, hdr: %u payload: %d\\n\",\n                TCPSTATE(&ts->sock) >> 8, short_be(hdr->trans.sport), short_be(hdr->trans.dport), SEQN(f), ACKN(f), hdr->flags, f->transport_len, (hdr->len & 0xf0) >> 2, f->payload_len );\n    } else {\n        pico_frame_discard(cpy);\n    }\n\n    return 0;\n\n}\n\nstatic int tcp_send(struct pico_socket_tcp *ts, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n    if (!hdr->seq)\n        hdr->seq = long_be(ts->snd_nxt);\n\n    tcp_send_add_tcpflags(ts, f);\n\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n    hdr->rwnd = short_be(ts->wnd);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n\n    return tcp_send_try_enqueue(ts, f);\n\n}\n\n/* #define PICO_TCP_SUPPORT_SOCKET_STATS */\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\nstatic void sock_stats(uint32_t when, void *arg)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)arg;\n    tcp_dbg(\"STATISTIC> [%lu] socket state: %02x --> local port:%d remote port: %d queue size: %d snd_una: %08x snd_nxt: %08x cwnd: %d\\n\",\n            when, t->sock.state, short_be(t->sock.local_port), short_be(t->sock.remote_port), t->tcpq_out.size, SEQN((struct pico_frame *)first_segment(&t->tcpq_out)), t->snd_nxt, t->cwnd);\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n    }\n}\n#endif\n\nstatic void tcp_send_probe(struct pico_socket_tcp *t);\n\nstatic void pico_tcp_keepalive(pico_time now, void *arg)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)arg;\n    if (((t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED)  && (t->ka_time > 0)) {\n        if (t->ka_time < (now - t->ack_timestamp)) {\n            if (t->ka_retries_count == 0) {\n                /* First probe */\n                tcp_send_probe(t);\n                t->ka_retries_count++;\n            }\n\n            if (t->ka_retries_count > t->ka_probes) {\n                if (t->sock.wakeup)\n                {\n                    pico_err = PICO_ERR_ECONNRESET;\n                    t->sock.wakeup(PICO_SOCK_EV_ERR, &t->sock);\n                }\n            }\n\n            if (((t->ka_retries_count * (pico_time)t->ka_intvl) + t->ka_time) < (now - t->ack_timestamp)) {\n                /* Next probe */\n                tcp_send_probe(t);\n                t->ka_retries_count++;\n            }\n        } else {\n            t->ka_retries_count = 0;\n        }\n    }\n\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        if (t->sock.wakeup)\n            t->sock.wakeup(PICO_SOCK_EV_ERR, &t->sock);\n    }\n}\n\nstatic inline void rto_set(struct pico_socket_tcp *t, uint32_t rto)\n{\n    if (rto < PICO_TCP_RTO_MIN)\n        rto = PICO_TCP_RTO_MIN;\n\n    if (rto > PICO_TCP_RTO_MAX)\n        rto = PICO_TCP_RTO_MAX;\n\n    t->rto = rto;\n}\n\n\nstruct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family)\n{\n    struct pico_socket_tcp *t = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!t)\n        return NULL;\n\n    t->sock.stack = S;\n    t->sock.timestamp = TCP_TIME;\n    pico_socket_set_family(&t->sock, family);\n    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);\n    t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n    t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n    t->tcpq_in.pool.compare = input_segment_compare;\n    t->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_hold.max_size = 2u * t->mss;\n    rto_set(t, PICO_TCP_RTO_MIN);\n\n    /* Uncomment next line and disable Nagle by default */\n    t->sock.opt_flags |= (1 << PICO_SOCKET_OPT_TCPNODELAY);\n\n    /* Uncomment next line and Nagle is enabled by default */\n    /* t->sock.opt_flags &= (uint16_t) ~(1 << PICO_SOCKET_OPT_TCPNODELAY); */\n\n    /* Set default linger for the socket */\n    t->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n#endif\n\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n    tcp_set_space(t);\n    return &t->sock;\n}\n\nstatic uint32_t tcp_read_finish(struct pico_socket *s, uint32_t tot_rd_len)\n{\n    struct pico_socket_tcp *t = TCP_SOCK(s);\n    tcp_set_space(t);\n    if (t->tcpq_in.size == 0) {\n        s->ev_pending &= (uint16_t)(~PICO_SOCK_EV_RD);\n    }\n\n    if (t->remote_closed) {\n        s->ev_pending |= (uint16_t)(PICO_SOCK_EV_CLOSE);\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_CLOSE_WAIT;\n        /* set SHUT_REMOTE */\n        s->state |= PICO_SOCKET_STATE_SHUT_REMOTE;\n        if (s->wakeup) {\n            s->wakeup(PICO_SOCK_EV_CLOSE, s);\n        }\n    }\n\n    return tot_rd_len;\n}\n\nstatic inline uint32_t tcp_read_in_frame_len(struct tcp_input_segment *f, int32_t in_frame_off, uint32_t tot_rd_len, uint32_t read_op_len)\n{\n    uint32_t in_frame_len = 0;\n    if (in_frame_off > 0)\n    {\n        if ((uint32_t)in_frame_off > f->payload_len) {\n            tcp_dbg(\"FATAL TCP ERR: in_frame_off > f->payload_len\\n\");\n        }\n\n        in_frame_len = f->payload_len - (uint32_t)in_frame_off;\n    } else { /* in_frame_off == 0 */\n        in_frame_len = f->payload_len;\n    }\n\n    if ((in_frame_len + tot_rd_len) > (uint32_t)read_op_len) {\n        in_frame_len = read_op_len - tot_rd_len;\n    }\n\n    return in_frame_len;\n\n}\n\nstatic inline void tcp_read_check_segment_done(struct pico_socket_tcp *t, struct tcp_input_segment *f, uint32_t in_frame_len)\n{\n    if ((in_frame_len == 0u) || (in_frame_len == (uint32_t)f->payload_len)) {\n        pico_discard_segment(&t->tcpq_in, f);\n    }\n}\n\nuint32_t pico_tcp_read(struct pico_socket *s, void *buf, uint32_t len)\n{\n    struct pico_socket_tcp *t = TCP_SOCK(s);\n    struct tcp_input_segment *f;\n    int32_t in_frame_off;\n    uint32_t in_frame_len;\n    uint32_t tot_rd_len = 0;\n\n    while (tot_rd_len < len) {\n        /* To be sure we don't have garbage at the beginning */\n        release_until(&t->tcpq_in, t->rcv_processed);\n        f = first_segment(&t->tcpq_in);\n        if (!f)\n            return tcp_read_finish(s, tot_rd_len);\n\n        in_frame_off = pico_seq_compare(t->rcv_processed, f->seq);\n        /* Check for hole at the beginning of data, awaiting retransmissions. */\n        if (in_frame_off < 0) {\n            tcp_dbg(\"TCP> read hole beginning of data, %08x - %08x. rcv_nxt is %08x\\n\", t->rcv_processed, f->seq, t->rcv_nxt);\n            return tcp_read_finish(s, tot_rd_len);\n        }\n\n        in_frame_len = tcp_read_in_frame_len(f, in_frame_off, tot_rd_len, len);\n\n\n        memcpy((uint8_t *)buf + tot_rd_len, f->payload + in_frame_off, in_frame_len);\n        tot_rd_len += in_frame_len;\n        t->rcv_processed += in_frame_len;\n\n        tcp_read_check_segment_done(t, f, in_frame_len);\n\n    }\n    return tcp_read_finish(s, tot_rd_len);\n}\n\nint pico_tcp_initconn(struct pico_socket *s);\nstatic void initconn_retry(pico_time when, void *arg)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)arg;\n    IGNORE_PARAMETER(when);\n    if (TCPSTATE(&t->sock) != PICO_SOCKET_STATE_TCP_ESTABLISHED)\n    {\n        if (t->backoff > PICO_TCP_MAX_CONNECT_RETRIES) {\n            tcp_dbg(\"TCP> Connection timeout. \\n\");\n            if (t->sock.wakeup)\n            {\n                pico_err = PICO_ERR_ECONNREFUSED;\n                t->sock.wakeup(PICO_SOCK_EV_ERR, &t->sock);\n            }\n\n            pico_socket_del(&t->sock);\n            return;\n        }\n\n        tcp_dbg(\"TCP> SYN retry %d...\\n\", t->backoff);\n        t->backoff++;\n        pico_tcp_initconn(&t->sock);\n    } else {\n        tcp_dbg(\"TCP> Connection is already established: no retry needed. good.\\n\");\n    }\n}\n\nint pico_tcp_initconn(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *syn;\n    struct pico_tcp_hdr *hdr;\n    uint16_t mtu, opt_len = tcp_options_size(ts, PICO_TCP_SYN);\n\n    syn = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!syn)\n        return -1;\n\n    hdr = (struct pico_tcp_hdr *) syn->transport_hdr;\n\n    if (!ts->snd_nxt)\n        ts->snd_nxt = long_be(pico_paws());\n\n    ts->snd_last = ts->snd_nxt;\n    ts->cwnd = PICO_TCP_IW;\n    mtu = (uint16_t)pico_socket_get_mss(s);\n    ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n    syn->sock = s;\n    hdr->seq = long_be(ts->snd_nxt);\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN;\n    tcp_set_space(ts);\n    hdr->rwnd = short_be(ts->wnd);\n    tcp_add_options(ts, syn, PICO_TCP_SYN, opt_len);\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(syn));\n\n    /* TCP: ENQUEUE to PROTO ( SYN ) */\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(ts->sock.local_port), short_be(ts->sock.remote_port), syn->buffer_len);\n    ts->retrans_tmr = pico_timer_add(s->stack, PICO_TCP_SYN_TO << ts->backoff, initconn_retry, ts);\n    if (!ts->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(syn);\n        return -1;\n    }\n    pico_enqueue(&s->stack->q_tcp.out, syn);\n    return 0;\n}\n\nstatic int tcp_send_synack(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *synack;\n    struct pico_tcp_hdr *hdr;\n    uint16_t opt_len = tcp_options_size(ts, PICO_TCP_SYN | PICO_TCP_ACK);\n\n    synack = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!synack)\n        return -1;\n\n    hdr = (struct pico_tcp_hdr *) synack->transport_hdr;\n\n    synack->sock = s;\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN | PICO_TCP_ACK;\n    hdr->rwnd = short_be(ts->wnd);\n    hdr->seq = long_be(ts->snd_nxt);\n    ts->rcv_processed = long_be(hdr->seq);\n    ts->snd_last = ts->snd_nxt;\n    tcp_set_space(ts);\n    tcp_add_options(ts, synack, hdr->flags, opt_len);\n    synack->payload_len = 0;\n    synack->timestamp = TCP_TIME;\n    tcp_send(ts, synack);\n    pico_frame_discard(synack);\n    return 0;\n}\n\nstatic void tcp_send_empty(struct pico_socket_tcp *t, uint16_t flags, int is_keepalive)\n{\n    struct pico_frame *f;\n    struct pico_tcp_hdr *hdr;\n    uint16_t opt_len = tcp_options_size(t, flags);\n    f = t->sock.net->alloc(t->sock.stack, t->sock.net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!f) {\n        return;\n    }\n\n    f->sock = &t->sock;\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = (uint8_t)flags;\n    hdr->rwnd = short_be(t->wnd);\n    tcp_set_space(t);\n    tcp_add_options(t, f, flags, opt_len);\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n    hdr->seq = long_be(t->snd_nxt);\n    if ((flags & PICO_TCP_ACK) != 0) {\n        hdr->ack = long_be(t->rcv_nxt);\n    }\n\n    if (is_keepalive)\n        hdr->seq = long_be(t->snd_nxt - 1);\n\n    t->rcv_ackd = t->rcv_nxt;\n\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n    hdr->rwnd = short_be(t->wnd);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n\n    /* TCP: ENQUEUE to PROTO */\n    pico_enqueue(&t->sock.stack->q_tcp.out, f);\n}\n\nstatic void tcp_send_ack(struct pico_socket_tcp *t)\n{\n    tcp_send_empty(t, PICO_TCP_ACK, 0);\n}\n\nstatic void tcp_send_probe(struct pico_socket_tcp *t)\n{\n    /* tcp_dbg(\"Sending probe\\n\"); */\n    tcp_send_empty(t, PICO_TCP_PSHACK, 1);\n}\n\nstatic int tcp_do_send_rst(struct pico_socket *s, uint32_t seq)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    uint16_t opt_len = tcp_options_size(t, PICO_TCP_RST);\n    struct pico_frame *f;\n    struct pico_tcp_hdr *hdr;\n    f = t->sock.net->alloc(s->stack, t->sock.net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!f) {\n        return -1;\n    }\n\n    f->sock = &t->sock;\n    tcp_dbg(\"TCP SEND_RST >>>>>>>>>>>>>>> START\\n\");\n\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_RST;\n    hdr->rwnd = short_be(t->wnd);\n    tcp_set_space(t);\n    tcp_add_options(t, f, PICO_TCP_RST, opt_len);\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n    hdr->seq = seq;\n    hdr->ack = long_be(t->rcv_nxt);\n    t->rcv_ackd = t->rcv_nxt;\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n    hdr->rwnd = short_be(t->wnd);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n\n    /* TCP: ENQUEUE to PROTO */\n    pico_enqueue(&t->sock.stack->q_tcp.out, f);\n    tcp_dbg(\"TCP SEND_RST >>>>>>>>>>>>>>> DONE\\n\");\n    return 0;\n}\n\nstatic int tcp_send_rst(struct pico_socket *s, struct pico_frame *fr)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    struct pico_tcp_hdr *hdr_rcv;\n    int ret;\n\n    if (fr && ((s->state & PICO_SOCKET_STATE_TCP) > PICO_SOCKET_STATE_TCP_SYN_RECV)) {\n        /* in synchronized state: send RST with seq = ack from previous segment */\n        hdr_rcv = (struct pico_tcp_hdr *) fr->transport_hdr;\n        ret = tcp_do_send_rst(s, hdr_rcv->ack);\n    } else {\n        /* non-synchronized state */\n        /* go to CLOSED here to prevent timer callback to go on after timeout */\n        (t->sock).state &= 0x00FFU;\n        (t->sock).state |= PICO_SOCKET_STATE_TCP_CLOSED;\n        ret = tcp_do_send_rst(s, long_be(t->snd_nxt));\n\n        /* Set generic socket state to CLOSED, too */\n        (t->sock).state &= 0xFF00U;\n        (t->sock).state |= PICO_SOCKET_STATE_CLOSED;\n\n        /* call EV_FIN wakeup before deleting */\n        if ((t->sock).wakeup)\n            (t->sock).wakeup(PICO_SOCK_EV_FIN, &(t->sock));\n\n        /* delete socket */\n        pico_socket_del(&t->sock);\n    }\n\n    return ret;\n}\n\nstatic inline void tcp_fill_rst_payload(struct pico_frame *fr, struct pico_frame *f)\n{\n    /* fill in IP data from original frame */\n    if (IS_IPV4(fr)) {\n        memcpy(f->net_hdr, fr->net_hdr, sizeof(struct pico_ipv4_hdr));\n        ((struct pico_ipv4_hdr *)(f->net_hdr))->dst.addr = ((struct pico_ipv4_hdr *)(fr->net_hdr))->src.addr;\n        ((struct pico_ipv4_hdr *)(f->net_hdr))->src.addr = ((struct pico_ipv4_hdr *)(fr->net_hdr))->dst.addr;\n        tcp_dbg(\"Making IPv4 reset frame...\\n\");\n\n    } else {\n        memcpy(f->net_hdr, fr->net_hdr, sizeof(struct pico_ipv6_hdr));\n        ((struct pico_ipv6_hdr *)(f->net_hdr))->dst = ((struct pico_ipv6_hdr *)(fr->net_hdr))->src;\n        ((struct pico_ipv6_hdr *)(f->net_hdr))->src = ((struct pico_ipv6_hdr *)(fr->net_hdr))->dst;\n    }\n\n    /* fill in TCP data from original frame */\n    ((struct pico_tcp_hdr *)(f->transport_hdr))->trans.dport = ((struct pico_tcp_hdr *)(fr->transport_hdr))->trans.sport;\n    ((struct pico_tcp_hdr *)(f->transport_hdr))->trans.sport = ((struct pico_tcp_hdr *)(fr->transport_hdr))->trans.dport;\n\n}\n\n\nstatic inline void tcp_fill_rst_header(struct pico_frame *fr, struct pico_tcp_hdr *hdr1, struct pico_frame *f, struct pico_tcp_hdr *hdr)\n{\n    if(!(hdr1->flags & PICO_TCP_ACK))\n        hdr->flags |= PICO_TCP_ACK;\n\n    hdr->rwnd  = 0;\n    if (((struct pico_tcp_hdr *)(fr->transport_hdr))->flags & PICO_TCP_ACK) {\n        hdr->seq = ((struct pico_tcp_hdr *)(fr->transport_hdr))->ack;\n    } else {\n        hdr->seq = 0U;\n    }\n\n    hdr->ack = 0;\n    if(!(hdr1->flags & PICO_TCP_ACK))\n        hdr->ack = long_be(long_be(((struct pico_tcp_hdr *)(fr->transport_hdr))->seq) + fr->payload_len);\n\n    hdr->crc = short_be(pico_tcp_checksum(f));\n}\n\nint pico_tcp_reply_rst(struct pico_stack *S, struct pico_frame *fr)\n{\n    struct pico_tcp_hdr *hdr, *hdr1;\n    struct pico_frame *f;\n    uint16_t size = PICO_SIZE_TCPHDR;\n\n\n    hdr1 = (struct pico_tcp_hdr *) (fr->transport_hdr);\n    if ((hdr1->flags & PICO_TCP_RST) != 0)\n        return -1;\n\n    tcp_dbg(\"TCP> sending RST ... \\n\");\n\n    f = fr->sock->net->alloc(fr->sock->stack, fr->sock->net, NULL, size);\n    if (!f) {\n        pico_err = PICO_ERR_ENOMEM;\n        return -1;\n    }\n\n    tcp_fill_rst_payload(fr, f);\n\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->len   = (uint8_t)(size << 2);\n    hdr->flags = PICO_TCP_RST;\n\n    tcp_fill_rst_header(fr, hdr1, f, hdr);\n\n    if (0) {\n#ifdef PICO_SUPPORT_IPV4\n    } else if (IS_IPV4(f)) {\n        tcp_dbg(\"Pushing IPv4 reset frame...\\n\");\n        pico_ipv4_frame_push(S, f, &(((struct pico_ipv4_hdr *)(f->net_hdr))->dst), PICO_PROTO_TCP);\n#endif\n#ifdef PICO_SUPPORT_IPV6\n    } else {\n        pico_ipv6_frame_push(S, f, NULL, &(((struct pico_ipv6_hdr *)(f->net_hdr))->dst), PICO_PROTO_TCP, 0);\n#endif\n    }\n\n\n    return 0;\n}\n\nstatic int tcp_nosync_rst(struct pico_socket *s, struct pico_frame *fr)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    struct pico_frame *f;\n    struct pico_tcp_hdr *hdr, *hdr_rcv;\n    uint16_t opt_len = tcp_options_size(t, PICO_TCP_RST | PICO_TCP_ACK);\n    hdr_rcv = (struct pico_tcp_hdr *) fr->transport_hdr;\n\n    tcp_dbg(\"TCP SEND RST (NON-SYNC) >>>>>>>>>>>>>>>>>> state %x\\n\", (s->state & PICO_SOCKET_STATE_TCP));\n    if (((s->state & PICO_SOCKET_STATE_TCP) ==  PICO_SOCKET_STATE_TCP_LISTEN)) {\n        if ((fr->flags & PICO_TCP_RST) != 0)\n            return 0;\n\n        return pico_tcp_reply_rst(s->stack, fr);\n    }\n\n    /***************************************************************************/\n    /* sending RST */\n    f = t->sock.net->alloc(t->sock.stack, t->sock.net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n\n    if (!f) {\n        return -1;\n    }\n\n\n    f->sock = &t->sock;\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_RST | PICO_TCP_ACK;\n    hdr->rwnd = short_be(t->wnd);\n    tcp_set_space(t);\n    tcp_add_options(t, f, PICO_TCP_RST | PICO_TCP_ACK, opt_len);\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n\n    /* non-synchronized state */\n    if (hdr_rcv->flags & PICO_TCP_ACK) {\n        hdr->seq = hdr_rcv->ack;\n    } else {\n        hdr->seq = 0U;\n    }\n\n    hdr->ack = long_be(SEQN(fr) + fr->payload_len);\n\n    t->rcv_ackd = t->rcv_nxt;\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n    hdr->rwnd = short_be(t->wnd);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n\n    /* TCP: ENQUEUE to PROTO */\n    pico_enqueue(&t->sock.stack->q_tcp.out, f);\n\n    /***************************************************************************/\n\n    tcp_dbg(\"TCP SEND_RST (NON_SYNC) >>>>>>>>>>>>>>> DONE, ...\\n\");\n\n    return 0;\n}\n\nstatic void tcp_deltcb(pico_time when, void *arg);\n\nstatic void tcp_linger(struct pico_socket_tcp *t)\n{\n    pico_timer_cancel(t->sock.stack, t->fin_tmr);\n    t->fin_tmr = pico_timer_add(t->sock.stack, t->linger_timeout, tcp_deltcb, t);\n    if (!t->fin_tmr) {\n        tcp_dbg(\"TCP: failed to start delete callback timer, deleting socket now\\n\");\n        tcp_deltcb((pico_time)0, t);\n    }\n}\n\nstatic void tcp_send_fin(struct pico_socket_tcp *t)\n{\n    struct pico_frame *f;\n    struct pico_tcp_hdr *hdr;\n    uint16_t opt_len = tcp_options_size(t, PICO_TCP_FIN);\n    f = t->sock.net->alloc(t->sock.stack, t->sock.net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!f) {\n        return;\n    }\n\n    f->sock = &t->sock;\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_FIN | PICO_TCP_ACK;\n    hdr->ack = long_be(t->rcv_nxt);\n    t->rcv_ackd = t->rcv_nxt;\n    hdr->rwnd = short_be(t->wnd);\n    tcp_set_space(t);\n    tcp_add_options(t, f, PICO_TCP_FIN, opt_len);\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n    hdr->seq = long_be(t->snd_nxt);\n\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n    hdr->rwnd = short_be(t->wnd);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n    /* tcp_dbg(\"SENDING FIN...\\n\"); */\n    if (t->linger_timeout > 0) {\n        pico_enqueue(&t->sock.stack->q_tcp.out, f);\n        t->snd_nxt++;\n    } else {\n        pico_frame_discard(f);\n    }\n\n    tcp_linger(t);\n}\n\nstatic void tcp_sack_prepare(struct pico_socket_tcp *t)\n{\n    struct tcp_input_segment *pkt;\n    uint32_t left = 0, right = 0;\n    struct tcp_sack_block *sb;\n    int n = 0;\n    if (t->sacks) /* previous sacks are pending */\n        return;\n\n    pkt = first_segment(&t->tcpq_in);\n    while(n < 3) {\n        if (!pkt) {\n            if(left) {\n                sb = PICO_ZALLOC(sizeof(struct tcp_sack_block));\n                if (!sb)\n                    break;\n\n                sb->left = long_be(left);\n                sb->right = long_be(right);\n                n++;\n                sb->next = t->sacks;\n                t->sacks = sb;\n                left = 0;\n                right = 0;\n            }\n\n            break;\n        }\n\n        if (pkt->seq < t->rcv_nxt) {\n            pkt = next_segment(&t->tcpq_in, pkt);\n            continue;\n        }\n\n        if (!left) {\n            left = pkt->seq;\n            right = pkt->seq + pkt->payload_len;\n            pkt = next_segment(&t->tcpq_in, pkt);\n            continue;\n        }\n\n        if(pkt->seq == right) {\n            right += pkt->payload_len;\n            pkt = next_segment(&t->tcpq_in, pkt);\n            continue;\n        } else {\n            sb = PICO_ZALLOC(sizeof(struct tcp_sack_block));\n            if (!sb)\n                break;\n\n            sb->left = long_be(left);\n            sb->right = long_be(right);\n            n++;\n            sb->next = t->sacks;\n            t->sacks = sb;\n            left = 0;\n            right = 0;\n            pkt = next_segment(&t->tcpq_in, pkt);\n        }\n    }\n}\n\nvoid pico_tcp_out_all(struct pico_stack *S, void *arg);\nstatic inline int tcp_data_in_expected(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct tcp_input_segment *nxt;\n    if (pico_seq_compare(SEQN(f), t->rcv_nxt) == 0) { /* Exactly what we expected */\n        /* Create new segment and enqueue it */\n        struct tcp_input_segment *input = segment_from_frame(f);\n        if (!input) {\n            pico_err = PICO_ERR_ENOMEM;\n            return -1;\n        }\n\n        if(pico_enqueue_segment(&t->tcpq_in, input) <= 0)\n        {\n            /* failed to enqueue, destroy segment */\n            PICO_FREE(input->payload);\n            PICO_FREE(input);\n            return -1;\n        } else {\n            t->rcv_nxt = SEQN(f) + f->payload_len;\n            nxt = peek_segment(&t->tcpq_in, t->rcv_nxt);\n            while(nxt) {\n                tcp_dbg(\"scrolling rcv_nxt...%08x\\n\", t->rcv_nxt);\n                t->rcv_nxt += nxt->payload_len;\n                nxt = peek_segment(&t->tcpq_in, t->rcv_nxt);\n            }\n            t->sock.ev_pending |= PICO_SOCK_EV_RD;\n            pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n        }\n    } else {\n        tcp_dbg(\"TCP> lo segment. Uninteresting retransmission. (exp: %x got: %x)\\n\", t->rcv_nxt, SEQN(f));\n    }\n\n    return 0;\n}\n\nstatic inline int tcp_data_in_high_segment(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    tcp_dbg(\"TCP> hi segment. Possible packet loss. I'll dupack this. (exp: %x got: %x)\\n\", t->rcv_nxt, SEQN(f));\n    if (t->sack_ok) {\n        struct tcp_input_segment *input = segment_from_frame(f);\n        if (!input) {\n            pico_err = PICO_ERR_ENOMEM;\n            return -1;\n        }\n\n        if(pico_enqueue_segment(&t->tcpq_in, input) <= 0) {\n            /* failed to enqueue, destroy segment */\n            PICO_FREE(input->payload);\n            PICO_FREE(input);\n            return -1;\n        }\n\n        tcp_sack_prepare(t);\n    }\n\n    return 0;\n}\n\nstatic inline void tcp_data_in_send_ack(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    /* In either case, ack til recv_nxt, unless received data raises a RST flag. */\n    if (((t->sock.state & PICO_SOCKET_STATE_TCP) != PICO_SOCKET_STATE_TCP_CLOSE_WAIT) &&\n        ((t->sock.state & PICO_SOCKET_STATE_TCP) != PICO_SOCKET_STATE_TCP_SYN_SENT) &&\n        ((t->sock.state & PICO_SOCKET_STATE_TCP) != PICO_SOCKET_STATE_TCP_SYN_RECV) &&\n        ((hdr->flags & PICO_TCP_RST) == 0))\n        tcp_send_ack(t);\n}\n\nstatic int tcp_data_in(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    uint16_t payload_len = (uint16_t)(f->transport_len - ((hdr->len & 0xf0u) >> 2u));\n    int ret = 0;\n    (void)hdr;\n\n    if (((hdr->len & 0xf0u) >> 2u) <= f->transport_len) {\n        if (tcp_parse_options(f) < 0)\n            return -1;\n        f->payload = f->transport_hdr + ((hdr->len & 0xf0u) >> 2u);\n        f->payload_len = payload_len;\n        tcp_dbg(\"TCP> Received segment. (exp: %x got: %x)\\n\", t->rcv_nxt, SEQN(f));\n\n        if (pico_seq_compare(SEQN(f), t->rcv_nxt) <= 0) {\n            ret = tcp_data_in_expected(t, f);\n        } else {\n            ret = tcp_data_in_high_segment(t, f);\n        }\n\n        tcp_data_in_send_ack(t, f);\n        return ret;\n    } else {\n        tcp_dbg(\"TCP: invalid data in pkt len, exp: %d, got %d\\n\", (hdr->len & 0xf0) >> 2, f->transport_len);\n        return -1;\n    }\n}\n\nstatic int tcp_ack_advance_una(struct pico_socket_tcp *t, struct pico_frame *f, pico_time *timestamp)\n{\n    int ret =  release_all_until(&t->tcpq_out, ACKN(f), timestamp);\n    if (ret > 0) {\n        t->sock.ev_pending |= PICO_SOCK_EV_WR;\n    }\n    pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n\n    return ret;\n}\n\nstatic uint16_t time_diff(pico_time a, pico_time b)\n{\n    if (a >= b)\n        return (uint16_t)(a - b);\n    else\n        return (uint16_t)(b - a);\n}\n\nstatic void tcp_rtt(struct pico_socket_tcp *t, uint32_t rtt)\n{\n\n    uint32_t avg = t->avg_rtt;\n    uint32_t rvar = t->rttvar;\n    if (!avg) {\n        /* This follows RFC2988\n         * (2.2) When the first RTT measurement R is made, the host MUST set\n         *\n         * SRTT <- R\n         * RTTVAR <- R/2\n         * RTO <- SRTT + max (G, K*RTTVAR)\n         */\n        t->avg_rtt = rtt;\n        t->rttvar = rtt >> 1;\n        rto_set(t, t->avg_rtt + (t->rttvar << 2));\n    } else {\n        int32_t var = (int32_t)t->avg_rtt - (int32_t)rtt;\n        if (var < 0)\n            var = 0 - var;\n\n        /* RFC2988, section (2.3). Alpha and beta are the ones suggested. */\n\n        /* First, evaluate a new value for the rttvar */\n        t->rttvar <<= 2;\n        t->rttvar -= rvar;\n        t->rttvar += (uint32_t)var;\n        t->rttvar >>= 2;\n\n        /* Then, calculate the new avg_rtt */\n        t->avg_rtt <<= 3;\n        t->avg_rtt -= avg;\n        t->avg_rtt += rtt;\n        t->avg_rtt >>= 3;\n\n        /* Finally, assign a new value for the RTO, as specified in the RFC, with K=4 */\n        rto_set(t, t->avg_rtt + (t->rttvar << 2));\n    }\n\n    tcp_dbg(\" -----=============== RTT CUR: %u AVG: %u RTTVAR: %u RTO: %u ======================----\\n\", rtt, t->avg_rtt, t->rttvar, t->rto);\n}\n\nstatic void tcp_congestion_control(struct pico_socket_tcp *t)\n{\n    if (t->x_mode > PICO_TCP_LOOKAHEAD)\n        return;\n\n    tcp_dbg(\"Doing congestion control\\n\");\n    if (t->cwnd < t->ssthresh) {\n        t->cwnd++;\n    } else {\n        t->cwnd_counter++;\n        if (t->cwnd_counter >= t->cwnd) {\n            t->cwnd++;\n            t->cwnd_counter = 0;\n        }\n    }\n\n    tcp_dbg(\"TCP_CWND, %lu, %u, %u, %u\\n\", TCP_TIME, t->cwnd, t->ssthresh, t->in_flight);\n}\n\nstatic void add_retransmission_timer(struct pico_socket_tcp *t, pico_time next_ts);\n\n\n/* Retransmission time out (RTO). */\n\nstatic void tcp_first_timeout(struct pico_socket_tcp *t)\n{\n    t->x_mode = PICO_TCP_BLACKOUT;\n    t->cwnd = PICO_TCP_IW;\n    t->in_flight = 0;\n}\n\nstatic int tcp_rto_xmit(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct pico_frame *cpy;\n    /* TCP: ENQUEUE to PROTO ( retransmit )*/\n    cpy = pico_frame_copy(f);\n    if (!cpy) {\n        add_retransmission_timer(t, (t->rto << t->backoff) + TCP_TIME);\n        return -1;\n    }\n\n    if (pico_enqueue(&t->sock.stack->q_tcp.out, cpy) > 0) {\n        t->snd_last_out = SEQN(cpy);\n        add_retransmission_timer(t, (t->rto << (++t->backoff)) + TCP_TIME);\n        tcp_dbg(\"TCP_CWND, %lu, %u, %u, %u\\n\", TCP_TIME, t->cwnd, t->ssthresh, t->in_flight);\n        tcp_dbg(\"Sending RTO!\\n\");\n        return 1;\n    } else {\n        tcp_dbg(\"RTO fail, retry!\\n\");\n        add_retransmission_timer(t, (t->rto << t->backoff) + TCP_TIME);\n        pico_frame_discard(cpy);\n        return 0;\n    }\n}\n\nstatic void tcp_next_zerowindow_probe(struct pico_socket_tcp *t)\n{\n    tcp_dbg(\"Sending probe!\\n\");\n    tcp_send_probe(t);\n    add_retransmission_timer(t, (t->rto << ++t->backoff) + TCP_TIME);\n}\n\nstatic int tcp_is_allowed_to_send(struct pico_socket_tcp *t)\n{\n    return t->sock.net &&\n           (\n               ((t->sock.state & 0xFF00) == PICO_SOCKET_STATE_TCP_ESTABLISHED) ||\n               ((t->sock.state & 0xFF00) == PICO_SOCKET_STATE_TCP_CLOSE_WAIT)\n           ) &&\n           ((t->backoff < PICO_TCP_MAX_RETRANS));\n}\n\nstatic inline int tcp_retrans_timeout_check_queue(struct pico_socket_tcp *t)\n{\n    struct pico_frame *f = NULL;\n    f = first_segment(&t->tcpq_out);\n    while (f) {\n        tcp_dbg(\"Checking frame in queue \\n\");\n        if (t->x_mode == PICO_TCP_WINDOW_FULL) {\n            tcp_dbg(\"TCP BLACKOUT> TIMED OUT (output) frame %08x, len= %d rto=%d Win full: %d frame flags: %04x\\n\", SEQN(f), f->payload_len, t->rto, t->x_mode == PICO_TCP_WINDOW_FULL, f->flags);\n            tcp_next_zerowindow_probe(t);\n            return -1;\n        }\n\n        if (t->x_mode != PICO_TCP_BLACKOUT)\n            tcp_first_timeout(t);\n\n        tcp_add_header(t, f);\n        if (tcp_rto_xmit(t, f) > 0) /* A segment has been rexmit'd */\n            return -1;\n\n        f = next_segment(&t->tcpq_out, f);\n    }\n    if (t->tcpq_out.size < t->tcpq_out.max_size)\n        t->sock.ev_pending |= PICO_SOCK_EV_WR;\n    pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n\n    return 0;\n\n\n\n}\n\nstatic void tcp_retrans_timeout(pico_time val, void *sock)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) sock;\n\n    t->retrans_tmr = 0;\n\n    if (t->retrans_tmr_due == 0ull) {\n        return;\n    }\n\n    if (t->retrans_tmr_due > val) {\n        /* Timer was postponed... */\n        add_retransmission_timer(t, t->retrans_tmr_due);\n        return;\n    }\n\n    pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n\n    tcp_dbg(\"TIMEOUT! backoff = %d, rto: %d\\n\", t->backoff, t->rto);\n    t->retrans_tmr_due = 0ull;\n\n    if (tcp_is_allowed_to_send(t)) {\n        if (tcp_retrans_timeout_check_queue(t) < 0)\n            return;\n    }\n    else if(t->backoff >= PICO_TCP_MAX_RETRANS &&\n            ((t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_FIN_WAIT1 ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_FIN_WAIT2 ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_TIME_WAIT ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_CLOSE_WAIT ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_LAST_ACK ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_CLOSING))\n    {\n        tcp_dbg(\"Connection timeout!\\n\");\n        /* the retransmission timer, failed to get an ack for a frame, gives up on the connection */\n        tcp_discard_all_segments(&t->tcpq_out);\n        if(t->sock.wakeup)\n            t->sock.wakeup(PICO_SOCK_EV_FIN, &t->sock);\n\n        /* delete socket */\n        pico_socket_del(&t->sock);\n        return;\n    } else {\n        tcp_dbg(\"Retransmission not allowed, rescheduling\\n\");\n    }\n}\n\nstatic void add_retransmission_timer(struct pico_socket_tcp *t, pico_time next_ts)\n{\n    struct pico_tree_node *index;\n    pico_time now = TCP_TIME;\n    pico_time val = 0;\n\n\n    if (next_ts == 0) {\n        struct pico_frame *f;\n\n        pico_tree_foreach(index, &t->tcpq_out.pool){\n            f = index->keyValue;\n            if ((next_ts == 0) || ((f->timestamp < next_ts) && (f->timestamp > 0))) {\n                next_ts = f->timestamp;\n                val = next_ts + (t->rto << t->backoff);\n            }\n        }\n    } else {\n        val = next_ts;\n    }\n\n    if ((val > 0) || (val > now)) {\n        t->retrans_tmr_due = val;\n    } else {\n        t->retrans_tmr_due = now + 1;\n    }\n\n    if (!t->retrans_tmr) {\n        t->retrans_tmr = pico_timer_add(t->sock.stack, t->retrans_tmr_due - now, tcp_retrans_timeout, t);\n        if(!t->retrans_tmr) {\n            tcp_dbg(\"TCP: Failed to start retransmission timer\\n\");\n            //TODO do something about this?\n        } else {\n            tcp_dbg(\"Next timeout in %u msec\\n\", (uint32_t) (t->retrans_tmr_due - now));\n        }\n    }\n}\n\nstatic int tcp_retrans(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct pico_frame *cpy;\n    if (f) {\n        tcp_dbg(\"TCP> RETRANS (by dupack) frame %08x, len= %d\\n\", SEQN(f), f->payload_len);\n        tcp_add_header(t, f);\n        /* TCP: ENQUEUE to PROTO ( retransmit )*/\n        cpy = pico_frame_copy(f);\n        if (!cpy) {\n            return -1;\n        }\n\n        if (pico_enqueue(&t->sock.stack->q_tcp.out, cpy) > 0) {\n            t->in_flight++;\n            t->snd_last_out = SEQN(cpy);\n        } else {\n            pico_frame_discard(cpy);\n        }\n\n        add_retransmission_timer(t, TCP_TIME + t->rto);\n        return(f->payload_len);\n    }\n\n    return 0;\n}\n\n#ifdef TCP_ACK_DBG\nstatic void tcp_ack_dbg(struct pico_socket *s, struct pico_frame *f)\n{\n    uint32_t una, nxt, ack, cur;\n    struct pico_frame *una_f = NULL, *cur_f;\n    struct pico_tree_node *idx;\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    char info[64];\n    char tmp[64];\n    ack = ACKN(f);\n    nxt = t->snd_nxt;\n    tcp_dbg(\"===================================\\n\");\n    tcp_dbg(\"Queue out (%d/%d). ACKED=%08x\\n\", t->tcpq_out.size, t->tcpq_out.max_size, ack);\n\n    pico_tree_foreach(idx, &t->tcpq_out.pool) {\n        info[0] = 0;\n        cur_f = idx->keyValue;\n        cur = SEQN(cur_f);\n        if (!una_f) {\n            una_f = cur_f;\n            una = SEQN(una_f);\n        }\n\n        if (cur == nxt) {\n            strncpy(tmp, info, strlen(info));\n            snprintf(info, 64, \"%s SND_NXT\", tmp);\n        }\n\n        if (cur == ack) {\n            strncpy(tmp, info, strlen(info));\n            snprintf(info, 64, \"%s ACK\", tmp);\n        }\n\n        if (cur == una) {\n            strncpy(tmp, info, strlen(info));\n            snprintf(info, 64, \"%s SND_UNA\", tmp);\n        }\n\n        if (cur == t->snd_last) {\n            strncpy(tmp, info, strlen(info));\n            snprintf(info, 64, \"%s SND_LAST\", tmp);\n        }\n\n        tcp_dbg(\"%08x %d%s\\n\", cur, cur_f->payload_len, info);\n\n    }\n    tcp_dbg(\"SND_NXT is %08x, snd_LAST is %08x\\n\", nxt, t->snd_last);\n    tcp_dbg(\"===================================\\n\");\n    tcp_dbg(\"\\n\\n\");\n}\n#endif\n\nstatic int tcp_ack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_frame *f_new;              /* use with Nagle to push to out queue */\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr;\n    uint32_t rtt = 0;\n    uint16_t acked = 0;\n    pico_time acked_timestamp = 0;\n    struct pico_frame *una = NULL;\n\n    if (!f || !s) {\n        pico_err = PICO_ERR_EINVAL;\n        return -1;\n    }\n\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n\n    if ((hdr->flags & PICO_TCP_ACK) == 0)\n        return -1;\n\n#ifdef TCP_ACK_DBG\n    tcp_ack_dbg(s, f);\n#endif\n\n    if (tcp_parse_options(f) < 0)\n        return -1;\n    t->recv_wnd = short_be(hdr->rwnd);\n\n    acked = (uint16_t)tcp_ack_advance_una(t, f, &acked_timestamp);\n    una = first_segment(&t->tcpq_out);\n    t->ack_timestamp = TCP_TIME;\n\n    if ((t->x_mode == PICO_TCP_BLACKOUT) ||\n        ((t->x_mode == PICO_TCP_WINDOW_FULL) && ((t->recv_wnd << t->recv_wnd_scale) > t->mss))) {\n        int prev_mode = t->x_mode;\n        tcp_dbg(\"Re-entering look-ahead...\\n\\n\\n\");\n        t->x_mode = PICO_TCP_LOOKAHEAD;\n        t->backoff = 0;\n\n        if((prev_mode == PICO_TCP_BLACKOUT) && (acked > 0) && una)\n        {\n            t->snd_nxt = SEQN(una);\n            /* restart the retrans timer */\n            if (t->retrans_tmr) {\n                t->retrans_tmr_due = 0ull;\n            }\n        }\n    }\n\n    /* One should be acked. */\n    if ((acked == 0) && (f->payload_len  == 0) && (t->in_flight > 0))\n        t->in_flight--;\n\n    if (!una || acked > 0) {\n        t->x_mode = PICO_TCP_LOOKAHEAD;\n        tcp_dbg(\"Mode: Look-ahead. In flight: %d/%d buf: %d\\n\", t->in_flight, t->cwnd, t->tcpq_out.frames);\n        t->backoff = 0;\n\n        /* Do rtt/rttvar/rto calculations */\n        /* First, try with timestamps, using the value from options */\n        if(f->timestamp != 0) {\n            rtt = time_diff(TCP_TIME, f->timestamp);\n            if (rtt)\n                tcp_rtt(t, rtt);\n        } else if(acked_timestamp) {\n            /* If no timestamps are there, use conservative estimation on the una */\n            rtt = time_diff(TCP_TIME, acked_timestamp);\n            if (rtt)\n                tcp_rtt(t, rtt);\n        }\n\n        tcp_dbg(\"TCP ACK> FRESH ACK %08x (acked %d) Queue size: %u/%u frames: %u cwnd: %u in_flight: %u snd_una: %u\\n\", ACKN(f), acked, t->tcpq_out.size, t->tcpq_out.max_size, t->tcpq_out.frames, t->cwnd, t->in_flight, SEQN(una));\n        if (acked > t->in_flight) {\n            tcp_dbg(\"WARNING: in flight < 0\\n\");\n            t->in_flight = 0;\n        } else\n            t->in_flight -= (acked);\n\n    } else if ((t->snd_old_ack == ACKN(f)) &&              /* We've just seen this ack, and... */\n               ((0 == (hdr->flags & (PICO_TCP_PSH | PICO_TCP_SYN))) &&\n                (f->payload_len == 0)) &&              /* This is a pure ack, and... */\n               (ACKN(f) != t->snd_nxt))              /* There is something in flight awaiting to be acked... */\n    {\n        /* Process incoming duplicate ack. */\n        if (t->x_mode < PICO_TCP_RECOVER) {\n            t->x_mode++;\n            tcp_dbg(\"Mode: DUPACK %d, due to PURE ACK %0x, len = %d\\n\", t->x_mode, SEQN(f), f->payload_len);\n            /* tcp_dbg(\"ACK: %x - QUEUE: %x\\n\", ACKN(f), SEQN(first_segment(&t->tcpq_out))); */\n            if (t->x_mode == PICO_TCP_RECOVER) {              /* Switching mode */\n                if (t->in_flight > PICO_TCP_IW)\n                    t->cwnd = (uint16_t)t->in_flight;\n                else\n                    t->cwnd = PICO_TCP_IW;\n\n                t->snd_retry = SEQN((struct pico_frame *)first_segment(&t->tcpq_out));\n                if (t->ssthresh > t->cwnd)\n                    t->ssthresh >>= 2;\n                else\n                    t->ssthresh = (t->cwnd >> 1);\n\n                if (t->ssthresh < 2)\n                    t->ssthresh = 2;\n            }\n        } else if (t->x_mode == PICO_TCP_RECOVER) {\n            /* tcp_dbg(\"TCP RECOVER> DUPACK! snd_una: %08x, snd_nxt: %08x, acked now: %08x\\n\", SEQN(first_segment(&t->tcpq_out)), t->snd_nxt, ACKN(f)); */\n            if (t->in_flight <= t->cwnd) {\n                struct pico_frame *nxt = peek_segment(&t->tcpq_out, t->snd_retry);\n                if (!nxt)\n                    nxt = first_segment(&t->tcpq_out);\n\n                while (nxt && (nxt->flags & PICO_FRAME_FLAG_SACKED) && (nxt != first_segment(&t->tcpq_out))) {\n                    tcp_dbg(\"Skipping %08x because it is sacked.\\n\", SEQN(nxt));\n                    nxt = next_segment(&t->tcpq_out, nxt);\n                }\n                if (nxt && (pico_seq_compare(SEQN(nxt), t->snd_nxt)) > 0)\n                    nxt = NULL;\n\n                if (nxt && (pico_seq_compare(SEQN(nxt), SEQN((struct pico_frame *)first_segment(&t->tcpq_out))) > (int)(t->recv_wnd << t->recv_wnd_scale)))\n                    nxt = NULL;\n\n                if(!nxt)\n                    nxt = first_segment(&t->tcpq_out);\n\n                if (nxt) {\n                    tcp_retrans(t, peek_segment(&t->tcpq_out, t->snd_retry));\n                    t->snd_retry = SEQN(nxt);\n                }\n            }\n\n            if (++t->cwnd_counter > 1) {\n                t->cwnd--;\n                if (t->cwnd < 2)\n                    t->cwnd = 2;\n\n                t->cwnd_counter = 0;\n            }\n        } else {\n            tcp_dbg(\"DUPACK in mode %d \\n\", t->x_mode);\n\n        }\n    }              /* End case duplicate ack detection */\n\n    /* Linux very special zero-window probe detection (see bug #107) */\n    if ((0 == (hdr->flags & (PICO_TCP_PSH | PICO_TCP_SYN))) && /* This is a pure ack, and... */\n        (ACKN(f) == t->snd_nxt) &&                           /* it's acking our snd_nxt, and... */\n        (pico_seq_compare(SEQN(f), t->rcv_nxt) < 0))             /* Has an old seq number */\n    {\n        tcp_send_ack(t);\n    }\n\n\n    /* Do congestion control */\n    tcp_congestion_control(t);\n    if ((acked > 0) && t->sock.wakeup) {\n        if (t->tcpq_out.size < t->tcpq_out.max_size)\n            t->sock.wakeup(PICO_SOCK_EV_WR, &(t->sock));\n\n        /* t->sock.ev_pending |= PICO_SOCK_EV_WR; */\n        pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n    }\n\n    /* if Nagle enabled, check if no unack'ed data and fill out queue (till window) */\n    if (IS_NAGLE_ENABLED((&(t->sock)))) {\n        while (!IS_TCP_HOLDQ_EMPTY(t) && ((t->tcpq_out.max_size - t->tcpq_out.size) >= t->mss)) {\n            tcp_dbg_nagle(\"TCP_ACK - NAGLE add new segment\\n\");\n            f_new = pico_hold_segment_make(t);\n            if (f_new == NULL)\n                break;              /* XXX corrupt !!! (or no memory) */\n\n            if (pico_enqueue_segment(&t->tcpq_out, f_new) <= 0)\n                /* handle error */\n                tcp_dbg_nagle(\"TCP_ACK - NAGLE FAILED to enqueue in out\\n\");\n        }\n    }\n\n    /* If some space was created, put a few segments out. */\n    tcp_dbg(\"TCP_CWND, %lu, %u, %u, %u\\n\", TCP_TIME, t->cwnd, t->ssthresh, t->in_flight);\n    if (t->x_mode ==  PICO_TCP_LOOKAHEAD) {\n        if ((t->cwnd >= t->in_flight) && (t->snd_nxt > t->snd_last_out)) {\n            pico_tcp_output(&t->sock, (int)t->cwnd - (int)t->in_flight);\n        }\n    }\n\n    add_retransmission_timer(t, 0);\n    t->snd_old_ack = ACKN(f);\n    return 0;\n}\n\nstatic int tcp_finwaitack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    tcp_dbg(\"RECEIVED ACK IN FIN_WAIT1\\n\");\n\n    /* acking part */\n    tcp_ack(s, f);\n\n\n    tcp_dbg(\"FIN_WAIT1: ack is %08x - snd_nxt is %08x\\n\", ACKN(f), t->snd_nxt);\n    if (ACKN(f) == (t->snd_nxt - 1u)) {\n        /* update TCP state */\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_FIN_WAIT2;\n        tcp_dbg(\"TCP> IN STATE FIN_WAIT2\\n\");\n    }\n\n    return 0;\n}\n\nstatic void tcp_deltcb(pico_time when, void *arg)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)arg;\n    IGNORE_PARAMETER(when);\n\n    /* send RST if not yet in TIME_WAIT */\n    if ((((t->sock).state & PICO_SOCKET_STATE_TCP) != PICO_SOCKET_STATE_TCP_TIME_WAIT)\n        && (((t->sock).state & PICO_SOCKET_STATE_TCP) != PICO_SOCKET_STATE_TCP_CLOSING)) {\n        tcp_dbg(\"Called deltcb in state = %04x (sending reset!)\\n\", (t->sock).state);\n        tcp_do_send_rst(&t->sock, long_be(t->snd_nxt));\n    } else {\n        tcp_dbg(\"Called deltcb in state = %04x\\n\", (t->sock).state);\n    }\n\n    /* update state */\n    (t->sock).state &= 0x00FFU;\n    (t->sock).state |= PICO_SOCKET_STATE_TCP_CLOSED;\n    (t->sock).state &= 0xFF00U;\n    (t->sock).state |= PICO_SOCKET_STATE_CLOSED;\n    /* call EV_FIN wakeup before deleting */\n    if (t->sock.wakeup) {\n        (t->sock).wakeup(PICO_SOCK_EV_FIN, &(t->sock));\n    }\n\n    /* delete socket */\n    pico_socket_del(&t->sock);\n}\n\nstatic int tcp_finwaitfin(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr  = (struct pico_tcp_hdr *) (f->transport_hdr);\n    tcp_dbg(\"TCP> received fin in FIN_WAIT2\\n\");\n    /* received FIN, increase ACK nr */\n    t->rcv_nxt = long_be(hdr->seq) + 1;\n    s->state &= 0x00FFU;\n    s->state |= PICO_SOCKET_STATE_TCP_TIME_WAIT;\n    /* set SHUT_REMOTE */\n    s->state |= PICO_SOCKET_STATE_SHUT_REMOTE;\n    if (s->wakeup)\n        s->wakeup(PICO_SOCK_EV_CLOSE, s);\n\n    if (f->payload_len > 0)              /* needed?? */\n        tcp_data_in(s, f);\n\n    /* send ACK */\n    tcp_send_ack(t);\n    /* linger */\n    tcp_linger(t);\n    return 0;\n}\n\nstatic int tcp_closing_ack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    tcp_dbg(\"TCP> received ack in CLOSING\\n\");\n    /* acking part */\n    tcp_ack(s, f);\n\n    /* update TCP state DLA TODO: Only if FIN is acked! */\n    tcp_dbg(\"CLOSING: ack is %08x - snd_nxt is %08x\\n\", ACKN(f), t->snd_nxt);\n    if (ACKN(f) == t->snd_nxt) {\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_TIME_WAIT;\n        /* set timer */\n        tcp_linger(t);\n    }\n\n    return 0;\n}\n\nstatic int tcp_lastackwait(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    tcp_dbg(\"LAST_ACK: ack is %08x - snd_nxt is %08x\\n\", ACKN(f), t->snd_nxt);\n    if (ACKN(f) == t->snd_nxt) {\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_CLOSED;\n        s->state &= 0xFF00U;\n        s->state |= PICO_SOCKET_STATE_CLOSED;\n        /* call socket wakeup with EV_FIN */\n        if (s->wakeup)\n            s->wakeup(PICO_SOCK_EV_FIN, s);\n\n        /* delete socket */\n        pico_socket_del(s);\n    }\n\n    return 0;\n}\n\nstatic int tcp_syn(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *new = NULL;\n    struct pico_tcp_hdr *hdr = NULL;\n    uint16_t mtu;\n    if(s->number_of_pending_conn >= s->max_backlog)\n        return -1;\n\n    new = (struct pico_socket_tcp *)pico_socket_clone(s);\n    hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    if (!new)\n        return -1;\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, s)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        return -1;\n    }\n#endif\n\n    new->sock.remote_port = ((struct pico_trans *)f->transport_hdr)->sport;\n#ifdef PICO_SUPPORT_IPV4\n    if (IS_IPV4(f)) {\n        new->sock.remote_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->src.addr;\n        new->sock.local_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->dst.addr;\n    }\n\n#endif\n#ifdef PICO_SUPPORT_IPV6\n    if (IS_IPV6(f)) {\n        new->sock.remote_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->src;\n        new->sock.local_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->dst;\n    }\n\n#endif\n    f->sock = &new->sock;\n    mtu = (uint16_t)pico_socket_get_mss(&new->sock);\n    new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    if (tcp_parse_options(f) < 0)\n        return -1;\n    new->sock.stack = s->stack;\n    new->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_hold.max_size = 2u * mtu;\n    new->rcv_nxt = long_be(hdr->seq) + 1;\n    new->snd_nxt = long_be(pico_paws());\n    new->snd_last = new->snd_nxt;\n    new->cwnd = PICO_TCP_IW;\n    new->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss)) >> 3u));\n    new->recv_wnd = short_be(hdr->rwnd);\n    new->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n    s->number_of_pending_conn++;\n    new->sock.parent = s;\n    new->sock.wakeup = s->wakeup;\n    rto_set(new, PICO_TCP_RTO_MIN);\n    /* Initialize timestamp values */\n    new->sock.state = PICO_SOCKET_STATE_BOUND | PICO_SOCKET_STATE_CONNECTED | PICO_SOCKET_STATE_TCP_SYN_RECV;\n    pico_socket_add(&new->sock);\n    tcp_send_synack(&new->sock);\n    tcp_dbg(\"SYNACK sent, socket added. snd_nxt is %08x\\n\", new->snd_nxt);\n    return 0;\n}\n\nstatic int tcp_synrecv_syn(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = NULL;\n    struct pico_socket_tcp *t = TCP_SOCK(s);\n    hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    if (t->rcv_nxt == long_be(hdr->seq) + 1u) {\n        /* take back our own SEQ number to its original value,\n         * so the synack retransmitted is identical to the original.\n         */\n        t->snd_nxt--;\n        tcp_send_synack(s);\n    } else {\n        tcp_send_rst(s, f);\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void tcp_set_init_point(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->rcv_processed = t->rcv_nxt;\n}\n\n\nuint16_t pico_tcp_get_socket_mss(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    if (t->mss > 0)\n        return (uint16_t)(t->mss + PICO_SIZE_TCPHDR);\n    else\n        return (uint16_t)pico_socket_get_mss(s);\n}\n\nstatic int tcp_synack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    struct pico_tcp_hdr *hdr  = (struct pico_tcp_hdr *)f->transport_hdr;\n\n    if (ACKN(f) ==  (1u + t->snd_nxt)) {\n        /* Get rid of initconn retry */\n        pico_timer_cancel(t->sock.stack, t->retrans_tmr);\n        t->retrans_tmr = 0;\n\n        t->rcv_nxt = long_be(hdr->seq);\n        t->rcv_processed = t->rcv_nxt + 1;\n        tcp_ack(s, f);\n\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_ESTABLISHED;\n        tcp_dbg(\"TCP> Established. State: %x\\n\", s->state);\n\n        if (s->wakeup)\n            s->wakeup(PICO_SOCK_EV_CONN, s);\n\n        s->ev_pending |= PICO_SOCK_EV_WR;\n        pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n\n        t->rcv_nxt++;\n        t->snd_nxt++;\n        tcp_send_ack(t);              /* return ACK */\n\n        return 0;\n\n    } else if ((hdr->flags & PICO_TCP_RST) == 0) {\n        tcp_dbg(\"TCP> Not established, RST sent.\\n\");\n        tcp_nosync_rst(s, f);\n        return 0;\n    } else {\n        /* The segment has the reset flag on: Ignore! */\n        return 0;\n    }\n}\n\nstatic int tcp_first_ack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr  = (struct pico_tcp_hdr *)f->transport_hdr;\n    tcp_dbg(\"ACK in SYN_RECV: expecting %08x got %08x\\n\", t->snd_nxt, ACKN(f));\n    if (t->snd_nxt == ACKN(f)) {\n        tcp_set_init_point(s);\n        tcp_ack(s, f);\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_ESTABLISHED;\n        tcp_dbg(\"TCP: Established. State now: %04x\\n\", s->state);\n        if( !s->parent && s->wakeup) {              /* If the socket has no parent, -> sending socket that has a sim_open */\n            tcp_dbg(\"FIRST ACK - No parent found -> sending socket\\n\");\n            s->wakeup(PICO_SOCK_EV_CONN,  s);\n        }\n\n        if (s->parent && s->parent->wakeup) {\n            tcp_dbg(\"FIRST ACK - Parent found -> listening socket\\n\");\n            s->wakeup = s->parent->wakeup;\n            s->parent->wakeup(PICO_SOCK_EV_CONN, s->parent);\n        }\n\n        s->ev_pending |= PICO_SOCK_EV_WR;\n        pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n        tcp_dbg(\"%s: snd_nxt is now %08x\\n\", __FUNCTION__, t->snd_nxt);\n        return 0;\n    } else if ((hdr->flags & PICO_TCP_RST) == 0) {\n        tcp_nosync_rst(s, f);\n        return 0;\n    } else {\n        /* The segment has the reset flag on: Ignore! */\n        return 0;\n    }\n}\n\nstatic void tcp_attempt_closewait(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr  = (struct pico_tcp_hdr *) (f->transport_hdr);\n    if (pico_seq_compare(SEQN(f), t->rcv_nxt) == 0) {\n        /* received FIN, increase ACK nr */\n        t->rcv_nxt = long_be(hdr->seq) + 1;\n        if (pico_seq_compare(SEQN(f), t->rcv_processed) == 0) {\n            if ((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED) {\n                tcp_dbg(\"Changing state to CLOSE_WAIT\\n\");\n                s->state &= 0x00FFU;\n                s->state |= PICO_SOCKET_STATE_TCP_CLOSE_WAIT;\n            }\n\n            /* set SHUT_REMOTE */\n            s->state |= PICO_SOCKET_STATE_SHUT_REMOTE;\n            tcp_dbg(\"TCP> Close-wait\\n\");\n            if (s->wakeup) {\n                s->wakeup(PICO_SOCK_EV_CLOSE, s);\n            }\n        } else {\n            t->remote_closed = 1;\n        }\n    }\n\n\n}\n\nstatic int tcp_closewait(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) (f->transport_hdr);\n\n    if (f->payload_len > 0)\n        tcp_data_in(s, f);\n\n    if (hdr->flags & PICO_TCP_ACK)\n        tcp_ack(s, f);\n\n    tcp_dbg(\"called close_wait (%p), in state %08x, f->flags: 0x%02x, hdr->flags: 0x%02x\\n\", tcp_closewait, s->state, f->flags, hdr->flags);\n    tcp_attempt_closewait(s, f);\n\n    /* Ensure that the notification given to the socket\n     * did not put us in LAST_ACK state before sending the ACK: i.e. if\n     * pico_socket_close() has been called in the socket callback, we don't need to send\n     * an ACK here.\n     *\n     */\n    if (((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_CLOSE_WAIT) ||\n        ((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED))\n    {\n        tcp_dbg(\"In closewait: Sending ack! (state is %08x)\\n\", s->state);\n        tcp_send_ack(t);\n    }\n\n    return 0;\n}\n\nstatic int tcp_rcvfin(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    IGNORE_PARAMETER(f);\n    tcp_dbg(\"TCP> Received FIN in FIN_WAIT1\\n\");\n    s->state &= 0x00FFU;\n    s->state |= PICO_SOCKET_STATE_TCP_CLOSING;\n    t->rcv_processed = t->rcv_nxt + 1;\n    t->rcv_nxt++;\n    /* send ACK */\n    tcp_send_ack(t);\n    return 0;\n}\n\nstatic int tcp_finack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    IGNORE_PARAMETER(f);\n\n    tcp_dbg(\"TCP> ENTERED finack\\n\");\n    t->rcv_nxt++;\n    /* send ACK */\n    tcp_send_ack(t);\n\n    /* call socket wakeup with EV_FIN */\n    if (s->wakeup)\n        s->wakeup(PICO_SOCK_EV_FIN, s);\n\n    s->state &= 0x00FFU;\n    s->state |= PICO_SOCKET_STATE_TCP_TIME_WAIT;\n    /* set SHUT_REMOTE */\n    s->state |= PICO_SOCKET_STATE_SHUT_REMOTE;\n\n    tcp_linger(t);\n\n    return 0;\n}\n\nstatic void tcp_force_closed(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    /* update state */\n    (t->sock).state &= 0x00FFU;\n    (t->sock).state |= PICO_SOCKET_STATE_TCP_CLOSED;\n    (t->sock).state &= 0xFF00U;\n    (t->sock).state |= PICO_SOCKET_STATE_CLOSED;\n    /* call EV_ERR wakeup before deleting */\n    if (((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED)) {\n        if ((t->sock).wakeup)\n            (t->sock).wakeup(PICO_SOCK_EV_FIN, &(t->sock));\n    } else {\n        pico_err = PICO_ERR_ECONNRESET;\n        if ((t->sock).wakeup)\n            (t->sock).wakeup(PICO_SOCK_EV_FIN, &(t->sock));\n\n        /* delete socket */\n        pico_socket_del(&t->sock);\n    }\n}\n\nstatic void tcp_wakeup_pending(struct pico_socket *s, uint16_t ev)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    if ((t->sock).wakeup)\n        (t->sock).wakeup(ev, &(t->sock));\n}\n\nstatic int tcp_rst(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) (f->transport_hdr);\n\n    tcp_dbg(\"TCP >>>>>>>>>>>>>> received RST <<<<<<<<<<<<<<<<<<<<\\n\");\n    if ((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_SYN_SENT) {\n        /* the RST is acceptable if the ACK field acknowledges the SYN */\n        if ((t->snd_nxt + 1u) == ACKN(f)) {              /* valid, got to closed state */\n            tcp_force_closed(s);\n        } else {                  /* not valid, ignore */\n            tcp_dbg(\"TCP RST> IGNORE\\n\");\n            return 0;\n        }\n    } else {              /* all other states */\n        /* all reset (RST) segments are validated by checking their SEQ-fields,\n           a reset is valid if its sequence number is in the window */\n        uint32_t this_seq = long_be(hdr->seq);\n        if ((this_seq >= t->rcv_ackd) && (this_seq <= ((uint32_t)(short_be(hdr->rwnd) << (t->wnd_scale)) + t->rcv_ackd))) {\n            tcp_force_closed(s);\n        } else {                  /* not valid, ignore */\n            tcp_dbg(\"TCP RST> IGNORE\\n\");\n            return 0;\n        }\n    }\n\n    return 0;\n}\nstatic int tcp_halfopencon(struct pico_socket *s, struct pico_frame *fr)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    IGNORE_PARAMETER(fr);\n    tcp_send_ack(t);\n    return 0;\n}\n\nstatic int tcp_closeconn(struct pico_socket *s, struct pico_frame *fr)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    struct pico_tcp_hdr *hdr  = (struct pico_tcp_hdr *) (fr->transport_hdr);\n\n    pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n    if (pico_seq_compare(SEQN(fr), t->rcv_nxt) == 0) {\n        /* received FIN, increase ACK nr */\n        t->rcv_nxt = long_be(hdr->seq) + 1;\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_CLOSE_WAIT;\n        /* set SHUT_LOCAL */\n        s->state |= PICO_SOCKET_STATE_SHUT_LOCAL;\n        pico_socket_close(s);\n        return 1;\n    }\n\n    return 0;\n}\n\nstruct tcp_action_entry {\n    uint16_t tcpstate;\n    int (*syn)(struct pico_socket *s, struct pico_frame *f);\n    int (*synack)(struct pico_socket *s, struct pico_frame *f);\n    int (*ack)(struct pico_socket *s, struct pico_frame *f);\n    int (*data)(struct pico_socket *s, struct pico_frame *f);\n    int (*fin)(struct pico_socket *s, struct pico_frame *f);\n    int (*finack)(struct pico_socket *s, struct pico_frame *f);\n    int (*rst)(struct pico_socket *s, struct pico_frame *f);\n};\n\nstatic const struct tcp_action_entry tcp_fsm[] = {\n    /* State                              syn              synack             ack                data             fin              finack           rst*/\n    { PICO_SOCKET_STATE_TCP_UNDEF,        NULL,            NULL,              NULL,              NULL,            NULL,            NULL,            NULL     },\n    { PICO_SOCKET_STATE_TCP_CLOSED,       NULL,            NULL,              NULL,              NULL,            NULL,            NULL,            NULL     },\n    { PICO_SOCKET_STATE_TCP_LISTEN,       &tcp_syn,        NULL,              NULL,              NULL,            NULL,            NULL,            NULL     },\n    { PICO_SOCKET_STATE_TCP_SYN_SENT,     NULL,            &tcp_synack,       NULL,              NULL,            NULL,            NULL,            &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_SYN_RECV,     &tcp_synrecv_syn, NULL,              &tcp_first_ack,    &tcp_data_in,    NULL,            &tcp_closeconn,  &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_ESTABLISHED,  &tcp_halfopencon, &tcp_ack,         &tcp_ack,          &tcp_data_in,    &tcp_closewait,  &tcp_closewait,  &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_CLOSE_WAIT,   NULL,            &tcp_ack,          &tcp_ack,          &tcp_send_rst,   &tcp_closewait,  &tcp_closewait,  &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_LAST_ACK,     NULL,            &tcp_ack,          &tcp_lastackwait,  &tcp_send_rst,   &tcp_send_rst,   &tcp_send_rst,   &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_FIN_WAIT1,    NULL,            &tcp_ack,          &tcp_finwaitack,   &tcp_data_in,    &tcp_rcvfin,     &tcp_finack,     &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_FIN_WAIT2,    NULL,            &tcp_ack,          &tcp_ack,          &tcp_data_in,    &tcp_finwaitfin, &tcp_finack,     &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_CLOSING,      NULL,            &tcp_ack,          &tcp_closing_ack, &tcp_send_rst,   &tcp_send_rst,   &tcp_send_rst,   &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_TIME_WAIT,    NULL,            NULL,          NULL,     &tcp_send_rst,   NULL, NULL, NULL}\n};\n\n#define MAX_VALID_FLAGS  10  /* Maximum number of valid flag combinations */\nstatic uint8_t invalid_flags(struct pico_socket *s, uint8_t flags)\n{\n    uint8_t i;\n    static const uint8_t valid_flags[PICO_SOCKET_STATE_TCP_ARRAYSIZ][MAX_VALID_FLAGS] = {\n        { /* PICO_SOCKET_STATE_TCP_UNDEF      */ 0, },\n        { /* PICO_SOCKET_STATE_TCP_CLOSED     */ 0, },\n        { /* PICO_SOCKET_STATE_TCP_LISTEN     */ PICO_TCP_SYN },\n        { /* PICO_SOCKET_STATE_TCP_SYN_SENT   */ PICO_TCP_SYNACK, PICO_TCP_RST, PICO_TCP_RSTACK},\n        { /* PICO_SOCKET_STATE_TCP_SYN_RECV   */ PICO_TCP_SYN, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_ESTABLISHED*/ PICO_TCP_SYN, PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST, PICO_TCP_RSTACK},\n        { /* PICO_SOCKET_STATE_TCP_CLOSE_WAIT */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_LAST_ACK   */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_FIN_WAIT1  */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_FIN_WAIT2  */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_CLOSING    */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_TIME_WAIT  */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n    };\n    if(!flags)\n        return 1;\n\n    for(i = 0; i < MAX_VALID_FLAGS; i++) {\n        if(valid_flags[s->state >> 8u][i] == flags)\n            return 0;\n    }\n    return 1;\n}\n\nstatic void tcp_action_call(int (*call)(struct pico_socket *s, struct pico_frame *f), struct pico_socket *s, struct pico_frame *f )\n{\n    if (call)\n        call(s, f);\n}\n\nstatic int tcp_action_by_flags(const struct tcp_action_entry *action, struct pico_socket *s, struct pico_frame *f, uint8_t flags)\n{\n    int ret = 0;\n\n    if ((flags == PICO_TCP_ACK) || (flags == (PICO_TCP_ACK | PICO_TCP_PSH))) {\n        tcp_action_call(action->ack, s, f);\n    }\n\n    if ((f->payload_len > 0 || (flags & PICO_TCP_PSH)) &&\n        !(s->state & PICO_SOCKET_STATE_CLOSED) && !TCP_IS_STATE(s, PICO_SOCKET_STATE_TCP_LISTEN))\n    {\n        ret = f->payload_len;\n        tcp_action_call(action->data, s, f);\n    }\n\n    if (flags == PICO_TCP_FIN) {\n        tcp_action_call(action->fin, s, f);\n    }\n\n    if ((flags == (PICO_TCP_FIN | PICO_TCP_ACK)) || (flags == (PICO_TCP_FIN | PICO_TCP_ACK | PICO_TCP_PSH))) {\n        tcp_action_call(action->finack, s, f);\n    }\n\n    if (flags & PICO_TCP_RST) {\n        tcp_action_call(action->rst, s, f);\n    }\n\n    return ret;\n}\n\nint pico_tcp_input(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) (f->transport_hdr);\n    int ret = 0;\n    uint8_t flags = hdr->flags;\n    const struct tcp_action_entry *action = &tcp_fsm[s->state >> 8];\n\n    f->payload = (f->transport_hdr + ((hdr->len & 0xf0u) >> 2u));\n    f->payload_len = (uint16_t)(f->transport_len - ((hdr->len & 0xf0u) >> 2u));\n\n    tcp_dbg(\"[sam] TCP> [tcp input] t_len: %u\\n\", f->transport_len);\n    tcp_dbg(\"[sam] TCP> flags = 0x%02x\\n\", hdr->flags);\n    tcp_dbg(\"[sam] TCP> s->state >> 8 = %u\\n\", s->state >> 8);\n    tcp_dbg(\"[sam] TCP> [tcp input] socket: %p state: %d <-- local port:%u remote port: %u seq: 0x%08x ack: 0x%08x flags: 0x%02x t_len: %u, hdr: %u payload: %d\\n\", s, s->state >> 8, short_be(hdr->trans.dport), short_be(hdr->trans.sport), SEQN(f), ACKN(f), hdr->flags, f->transport_len, (hdr->len & 0xf0) >> 2, f->payload_len );\n\n    if ((f->payload + f->payload_len) > (f->buffer + f->buffer_len)) {\n        tcp_dbg(\"TCP> Invalid payload len %04x\\n\", f->payload_len);\n        pico_frame_discard(f);\n        return -1;\n    }\n\n    /* This copy of the frame has the current socket as owner */\n    f->sock = s;\n    s->timestamp = TCP_TIME;\n    /* Those are not supported at this time. */\n    /* flags &= (uint8_t) ~(PICO_TCP_CWR | PICO_TCP_URG | PICO_TCP_ECN); */\n    if(invalid_flags(s, flags)) {\n        pico_tcp_reply_rst(s->stack, f);\n    }\n    else if (flags == PICO_TCP_SYN) {\n        tcp_action_call(action->syn, s, f);\n    } else if (flags == (PICO_TCP_SYN | PICO_TCP_ACK)) {\n        tcp_action_call(action->synack, s, f);\n    } else {\n        ret = tcp_action_by_flags(action, s, f, flags);\n    }\n\n    if (s->ev_pending)\n        tcp_wakeup_pending(s, s->ev_pending);\n\n/* discard: */\n    pico_frame_discard(f);\n    return ret;\n}\n\n\ninline static int checkLocalClosing(struct pico_socket *s);\ninline static int checkRemoteClosing(struct pico_socket *s);\n\nstatic struct pico_frame *tcp_split_segment(struct pico_socket_tcp *t, struct pico_frame *f, uint16_t size)\n{\n    struct pico_frame *f1, *f2;\n    uint16_t size1, size2, size_f;\n    uint16_t overhead;\n    struct pico_tcp_hdr *hdr1, *hdr2, *hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    overhead = pico_tcp_overhead(&t->sock);\n    size_f = f->payload_len;\n\n\n    if (size >= size_f)\n        return f; /* no need to split! */\n\n    size1 = size;\n    size2 = (uint16_t)(size_f - size);\n\n    f1 = pico_socket_frame_alloc(&t->sock, get_sock_dev(&t->sock), (uint16_t) (size1 + overhead));\n    f2 = pico_socket_frame_alloc(&t->sock, get_sock_dev(&t->sock), (uint16_t) (size2 + overhead));\n\n    if (!f1 || !f2) {\n        pico_err = PICO_ERR_ENOMEM;\n        return NULL;\n    }\n\n    /* Advance payload pointer to the beginning of segment data */\n    f1->payload += overhead;\n    f1->payload_len = (uint16_t)(f1->payload_len - overhead);\n    f2->payload += overhead;\n    f2->payload_len = (uint16_t)(f2->payload_len - overhead);\n\n    hdr1 = (struct pico_tcp_hdr *)f1->transport_hdr;\n    hdr2 = (struct pico_tcp_hdr *)f2->transport_hdr;\n\n    /* Copy payload */\n    memcpy(f1->payload, f->payload, size1);\n    memcpy(f2->payload, f->payload + size1, size2);\n\n    /* Copy tcp hdr */\n    memcpy(hdr1, hdr, sizeof(struct pico_tcp_hdr));\n    memcpy(hdr2, hdr, sizeof(struct pico_tcp_hdr));\n\n    /* Adjust f2's sequence number */\n    hdr2->seq = long_be(SEQN(f) + size1);\n\n    /* Add TCP options */\n    pico_tcp_flags_update(f1, &t->sock);\n    pico_tcp_flags_update(f2, &t->sock);\n    tcp_add_options_frame(t, f1);\n    tcp_add_options_frame(t, f2);\n\n    /* Get rid of the full frame */\n    pico_discard_segment(&t->tcpq_out, f);\n\n    /* Enqueue f2 for later send... */\n    if (pico_enqueue_segment(&t->tcpq_out, f2) < 0) {\n        tcp_dbg(\"Discarding invalid segment\\n\");\n        pico_frame_discard(f2);\n    }\n\n    /* Return the partial frame */\n    return f1;\n}\n\n\nint pico_tcp_output(struct pico_socket *s, int loop_score)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_frame *f, *una;\n    int sent = 0;\n    int data_sent = 0;\n    int32_t seq_diff = 0;\n\n    una = first_segment(&t->tcpq_out);\n    f = peek_segment(&t->tcpq_out, t->snd_nxt);\n\n    while((f) && (t->cwnd >= t->in_flight)) {\n        f->timestamp = TCP_TIME;\n        add_retransmission_timer(t, t->rto + TCP_TIME);\n        tcp_add_options_frame(t, f);\n        seq_diff = pico_seq_compare(SEQN(f), SEQN(una));\n        if (seq_diff < 0) {\n            tcp_dbg(\">>> FATAL: seq diff is negative!\\n\");\n            break;\n        }\n\n        /* Check if advertised window is full */\n        if ((uint32_t)seq_diff >= (uint32_t)(t->recv_wnd << t->recv_wnd_scale)) {\n            if (t->x_mode != PICO_TCP_WINDOW_FULL) {\n                tcp_dbg(\"TCP> RIGHT SIZING (rwnd: %d, frame len: %d\\n\", t->recv_wnd << t->recv_wnd_scale, f->payload_len);\n                tcp_dbg(\"In window full...\\n\");\n                t->snd_nxt = SEQN(una);\n                t->snd_retry = SEQN(una);\n                t->x_mode = PICO_TCP_WINDOW_FULL;\n            }\n\n            break;\n        }\n\n        /* Check if the advertised window is too small to receive the current frame */\n        if ((uint32_t)(seq_diff + f->payload_len) > (uint32_t)(t->recv_wnd << t->recv_wnd_scale)) {\n            f = tcp_split_segment(t, f, (uint16_t)(t->recv_wnd << t->recv_wnd_scale));\n            if (!f)\n                break;\n\n            /* Limit sending window to packets in flight (right sizing) */\n            t->cwnd = (uint16_t)t->in_flight;\n            if (t->cwnd < 1)\n                t->cwnd = 1;\n        }\n\n        tcp_dbg(\"TCP> DEQUEUED (for output) frame %08x, acks %08x len= %d, remaining frames %d\\n\", SEQN(f), ACKN(f), f->payload_len, t->tcpq_out.frames);\n        tcp_send(t, f);\n        sent++;\n        loop_score--;\n        t->snd_last_out = SEQN(f);\n        if (loop_score < 1)\n            break;\n\n        if (f->payload_len > 0) {\n            data_sent++;\n            f = next_segment(&t->tcpq_out, f);\n        } else {\n            f = NULL;\n        }\n    }\n    if ((sent > 0 && data_sent > 0)) {\n        rto_set(t, t->rto);\n    } else {\n        /* Nothing to transmit. */\n    }\n\n    if ((t->tcpq_out.frames == 0) && (s->state & PICO_SOCKET_STATE_SHUT_LOCAL)) {              /* if no more packets in queue, XXX replaced !f by tcpq check */\n        if(!checkLocalClosing(&t->sock))              /* check if local closing started and send fin */\n        {\n            checkRemoteClosing(&t->sock);              /* check if remote closing started and send fin */\n        }\n    }\n\n    return loop_score;\n}\n\nint pico_tcp_output(struct pico_socket *s, int loop_score);\nvoid pico_tcp_out_all(struct pico_stack *S, void *arg)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)arg;\n    (void)S;\n    if (t) {\n        struct pico_socket *s = &t->sock;\n        pico_tcp_output(&t->sock, (int)t->tcpq_out.frames);\n        if ((s->ev_pending) && s->wakeup) {\n            s->wakeup(s->ev_pending, s);\n            if(!s->parent)\n                s->ev_pending = 0;\n        }\n\n        if(pico_socket_sanity_check(s) < 0)\n        {\n            pico_socket_del(s);\n        }\n    }\n}\n\n/* function to make new segment from hold queue with specific size (mss) */\nstatic struct pico_frame *pico_hold_segment_make(struct pico_socket_tcp *t)\n{\n    struct pico_frame *f_temp, *f_new;\n    struct pico_socket *s = (struct pico_socket *) &t->sock;\n    struct pico_tcp_hdr *hdr;\n    uint16_t total_len = 0, total_payload_len = 0;\n    uint16_t off = 0, test = 0;\n\n    off = pico_tcp_overhead(s);\n\n    /* init with first frame in hold queue */\n    f_temp = first_segment(&t->tcpq_hold);\n    total_len = f_temp->payload_len;\n    f_temp = next_segment(&t->tcpq_hold, f_temp);\n\n    /* check till total_len <= MSS */\n    while ((f_temp != NULL) && ((total_len + f_temp->payload_len) <= t->mss)) {\n        total_len = (uint16_t)(total_len + f_temp->payload_len);\n        f_temp = next_segment(&t->tcpq_hold, f_temp);\n        if (f_temp == NULL)\n            break;\n    }\n    /* alloc new frame with payload size = off + total_len */\n    f_new = pico_socket_frame_alloc(s, get_sock_dev(s), (uint16_t)(off + total_len));\n    if (!f_new) {\n        pico_err = PICO_ERR_ENOMEM;\n        return f_new;\n    }\n\n    pico_tcp_flags_update(f_new, &t->sock);\n    hdr = (struct pico_tcp_hdr *) f_new->transport_hdr;\n    /* init new frame */\n    f_new->payload += off;\n    f_new->payload_len = (uint16_t)(f_new->payload_len - off);\n    f_new->sock = s;\n\n    f_temp = first_segment(&t->tcpq_hold);\n    hdr->seq = ((struct pico_tcp_hdr *)(f_temp->transport_hdr))->seq;              /* get sequence number of first frame */\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n\n    /* check till total_payload_len <= MSS */\n    while ((f_temp != NULL) && ((total_payload_len + f_temp->payload_len) <= t->mss)) {\n        /* cpy data and discard frame */\n        test++;\n        memcpy(f_new->payload + total_payload_len, f_temp->payload, f_temp->payload_len);\n        total_payload_len = (uint16_t)(total_payload_len + f_temp->payload_len);\n        pico_discard_segment(&t->tcpq_hold, f_temp);\n        f_temp = first_segment(&t->tcpq_hold);\n    }\n    hdr->len = (uint8_t)((f_new->payload - f_new->transport_hdr) << 2u);\n\n    tcp_dbg_nagle(\"NAGLE make - joined %d segments, len %d bytes\\n\", test, total_payload_len);\n    tcp_add_options_frame(t, f_new);\n\n    return f_new;\n}\n\n\n\nstatic int pico_tcp_push_nagle_enqueue(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    if (pico_enqueue_segment(&t->tcpq_out, f) > 0) {\n        tcp_dbg_nagle(\"TCP_PUSH - NAGLE - Pushing segment %08x, len %08x to socket %p\\n\", t->snd_last + 1, f->payload_len, t);\n        t->snd_last += f->payload_len;\n        pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n        return f->payload_len;\n    } else {\n        tcp_dbg(\"Enqueue failed.\\n\");\n        return 0;\n    }\n}\n\nstatic int pico_tcp_push_nagle_hold(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct pico_frame *f_new;\n    uint32_t total_len = 0;\n    pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n    total_len = f->payload_len + t->tcpq_hold.size;\n    if ((total_len >= t->mss) && ((t->tcpq_out.max_size - t->tcpq_out.size) >= t->mss)) {\n        /* IF enough data in hold (>mss) AND space in out queue (>mss) */\n        /* add current frame in hold and make new segment */\n        if (pico_enqueue_segment(&t->tcpq_hold, f) > 0 ) {\n            tcp_dbg_nagle(\"TCP_PUSH - NAGLE - Pushed into hold, make new (enqueued frames out %d)\\n\", t->tcpq_out.frames);\n            t->snd_last += f->payload_len;              /* XXX  WATCH OUT */\n            f_new = pico_hold_segment_make(t);\n        } else {\n            tcp_dbg_nagle(\"TCP_PUSH - NAGLE - enqueue hold failed 1\\n\");\n            return 0;\n        }\n\n        /* and put new frame in out queue */\n        if ((f_new != NULL) && (pico_enqueue_segment(&t->tcpq_out, f_new) > 0)) {\n            return f_new->payload_len;\n        } else {\n            tcp_dbg_nagle(\"TCP_PUSH - NAGLE - enqueue out failed, f_new = %p\\n\", f_new);\n            return -1;              /* XXX something seriously wrong */\n        }\n    } else {\n        /* ELSE put frame in hold queue */\n        if (pico_enqueue_segment(&t->tcpq_hold, f) > 0) {\n            tcp_dbg_nagle(\"TCP_PUSH - NAGLE - Pushed into hold (enqueued frames out %d)\\n\", t->tcpq_out.frames);\n            t->snd_last += f->payload_len;              /* XXX  WATCH OUT */\n            return f->payload_len;\n        } else {\n            pico_err = PICO_ERR_EAGAIN;\n            tcp_dbg_nagle(\"TCP_PUSH - NAGLE - enqueue hold failed 2\\n\");\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int pico_tcp_push_nagle_on(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    /* Nagle's algorithm enabled, check if ready to send, or put frame in hold queue */\n    if (IS_TCP_IDLE(t) && IS_TCP_HOLDQ_EMPTY(t))\n        return pico_tcp_push_nagle_enqueue(t, f);\n\n    return pico_tcp_push_nagle_hold(t, f);\n}\n\n\n\n/* original behavior kept when Nagle disabled;\n   Nagle algorithm added here, keeping hold frame queue instead of eg linked list of data */\nint pico_tcp_push(struct pico_stack *S, struct pico_protocol *self, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) f->sock;\n    (void)S;\n    IGNORE_PARAMETER(self);\n    pico_err = PICO_ERR_NOERR;\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n    hdr->seq = long_be(t->snd_last + 1);\n    hdr->len = (uint8_t)((f->payload - f->transport_hdr) << 2u);\n\n    if ((uint32_t)f->payload_len > (uint32_t)(t->tcpq_out.max_size - t->tcpq_out.size))\n        t->sock.ev_pending &= (uint16_t)(~PICO_SOCK_EV_WR);\n\n    /***************************************************************************/\n\n    if (!IS_NAGLE_ENABLED((&(t->sock)))) {\n        /* TCP_NODELAY enabled, original behavior */\n        if (pico_enqueue_segment(&t->tcpq_out, f) > 0) {\n            pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n            tcp_dbg_nagle(\"TCP_PUSH - NO NAGLE - Pushing segment %08x, len %08x to socket %p\\n\", t->snd_last + 1, f->payload_len, t);\n            t->snd_last += f->payload_len;\n            return f->payload_len;\n        } else {\n            tcp_dbg(\"Enqueue failed.\\n\");\n            return 0;\n        }\n    } else {\n        return pico_tcp_push_nagle_on(t, f);\n    }\n\n}\n\nstatic void tcp_discard_all_segments(struct pico_tcp_queue *tq)\n{\n    struct pico_tree_node *index = NULL, *index_safe = NULL;\n    PICOTCP_MUTEX_LOCK(Mutex);\n    pico_tree_foreach_safe(index, &tq->pool, index_safe)\n    {\n        void *f = index->keyValue;\n        if(!f)\n            break;\n\n        pico_tree_delete(&tq->pool, f);\n        if(IS_INPUT_QUEUE(tq))\n        {\n            struct tcp_input_segment *inp = (struct tcp_input_segment *)f;\n            PICO_FREE(inp->payload);\n            PICO_FREE(inp);\n        }\n        else\n            pico_frame_discard(f);\n    }\n    tq->frames = 0;\n    tq->size = 0;\n    PICOTCP_MUTEX_UNLOCK(Mutex);\n}\n\nvoid pico_tcp_cleanup_queues(struct pico_socket *sck)\n{\n    struct pico_socket_tcp *tcp = (struct pico_socket_tcp *)sck;\n    pico_timer_cancel(tcp->sock.stack, tcp->retrans_tmr);\n    pico_timer_cancel(tcp->sock.stack, tcp->keepalive_tmr);\n    pico_timer_cancel(tcp->sock.stack, tcp->fin_tmr);\n\n    tcp->retrans_tmr = 0;\n    tcp->keepalive_tmr = 0;\n    tcp->fin_tmr = 0;\n\n    tcp_discard_all_segments(&tcp->tcpq_in);\n    tcp_discard_all_segments(&tcp->tcpq_out);\n    tcp_discard_all_segments(&tcp->tcpq_hold);\n}\n\nstatic int checkLocalClosing(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    if ((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED) {\n        tcp_dbg(\"TCP> buffer empty, shutdown established ...\\n\");\n        /* send fin if queue empty and in state shut local (write) */\n        tcp_send_fin(t);\n        /* change tcp state to FIN_WAIT1 */\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_FIN_WAIT1;\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic int checkRemoteClosing(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    if ((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_CLOSE_WAIT) {\n        /* send fin if queue empty and in state shut local (write) */\n        tcp_send_fin(t);\n        /* change tcp state to LAST_ACK */\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_LAST_ACK;\n        tcp_dbg(\"TCP> STATE: LAST_ACK.\\n\");\n        return 1;\n    }\n\n    return 0;\n}\n\nvoid pico_tcp_notify_closing(struct pico_socket *sck)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)sck;\n    if(t->tcpq_out.frames == 0)\n    {\n        if(!checkLocalClosing(sck))\n            checkRemoteClosing(sck);\n    }\n}\n\n\nint pico_tcp_check_listen_close(struct pico_socket *s)\n{\n    if (TCP_IS_STATE(s, PICO_SOCKET_STATE_TCP_LISTEN)) {\n        pico_socket_del(s);\n        return 0;\n    }\n\n    return -1;\n}\n\nvoid pico_tcp_flags_update(struct pico_frame *f, struct pico_socket *s)\n{\n    f->transport_flags_saved = ((struct pico_socket_tcp *)s)->ts_ok;\n}\n\nint pico_tcp_set_bufsize_in(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->tcpq_in.max_size = value;\n    return 0;\n}\n\nint pico_tcp_set_bufsize_out(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->tcpq_out.max_size = value;\n    return 0;\n}\n\nint pico_tcp_get_bufsize_in(struct pico_socket *s, uint32_t *value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    *value = t->tcpq_in.max_size;\n    return 0;\n}\n\nint pico_tcp_get_bufsize_out(struct pico_socket *s, uint32_t *value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    *value = t->tcpq_out.max_size;\n    return 0;\n}\n\nint pico_tcp_set_keepalive_probes(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->ka_probes = value;\n    return 0;\n}\n\nint pico_tcp_set_keepalive_intvl(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->ka_intvl = value;\n    return 0;\n}\n\nint pico_tcp_set_keepalive_time(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->ka_time = value;\n    return 0;\n}\n\nint pico_tcp_set_linger(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->linger_timeout = value;\n    return 0;\n}\n\n#endif /* PICO_SUPPORT_TCP */\n", "/*********************************************************************\n * PicoTCP-NG \n * Copyright (c) 2020 Daniele Lacamera <root@danielinux.net>\n *\n * This file also includes code from:\n * PicoTCP\n * Copyright (c) 2012-2017 Altran Intelligent Systems\n * \n * SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only\n *\n * PicoTCP-NG is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) version 3.\n *\n * PicoTCP-NG is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n *\n *\n *********************************************************************/\n#ifndef INCLUDE_PICO_TCP\n#define INCLUDE_PICO_TCP\n#include \"pico_addressing.h\"\n#include \"pico_protocol.h\"\n#include \"pico_socket.h\"\n\nextern struct pico_protocol pico_proto_tcp;\n\nPACKED_STRUCT_DEF pico_tcp_hdr {\n    struct pico_trans trans;\n    uint32_t seq;\n    uint32_t ack;\n    uint8_t len;\n    uint8_t flags;\n    uint16_t rwnd;\n    uint16_t crc;\n    uint16_t urgent;\n};\n\nPACKED_STRUCT_DEF tcp_pseudo_hdr_ipv4\n{\n    struct pico_ip4 src;\n    struct pico_ip4 dst;\n    uint16_t tcp_len;\n    uint8_t res;\n    uint8_t proto;\n};\n\n#define PICO_TCPHDR_SIZE 20\n#define PICO_SIZE_TCPOPT_SYN 20\n#define PICO_SIZE_TCPHDR (uint32_t)(sizeof(struct pico_tcp_hdr))\n\n/* TCP options */\n#define PICO_TCP_OPTION_END         0x00\n#define PICO_TCPOPTLEN_END        1u\n#define PICO_TCP_OPTION_NOOP        0x01\n#define PICO_TCPOPTLEN_NOOP       1\n#define PICO_TCP_OPTION_MSS         0x02\n#define PICO_TCPOPTLEN_MSS        4\n#define PICO_TCP_OPTION_WS          0x03\n#define PICO_TCPOPTLEN_WS         3u\n#define PICO_TCP_OPTION_SACK_OK        0x04\n#define PICO_TCPOPTLEN_SACK_OK       2\n#define PICO_TCP_OPTION_SACK        0x05\n#define PICO_TCPOPTLEN_SACK       2 /* Plus the block */\n#define PICO_TCP_OPTION_TIMESTAMP   0x08\n#define PICO_TCPOPTLEN_TIMESTAMP  10u\n\n/* TCP flags */\n#define PICO_TCP_FIN 0x01u\n#define PICO_TCP_SYN 0x02u\n#define PICO_TCP_RST 0x04u\n#define PICO_TCP_PSH 0x08u\n#define PICO_TCP_ACK 0x10u\n#define PICO_TCP_URG 0x20u\n#define PICO_TCP_ECN 0x40u\n#define PICO_TCP_CWR 0x80u\n\n#define PICO_TCP_SYNACK    (PICO_TCP_SYN | PICO_TCP_ACK)\n#define PICO_TCP_PSHACK    (PICO_TCP_PSH | PICO_TCP_ACK)\n#define PICO_TCP_FINACK    (PICO_TCP_FIN | PICO_TCP_ACK)\n#define PICO_TCP_FINPSHACK (PICO_TCP_FIN | PICO_TCP_PSH | PICO_TCP_ACK)\n#define PICO_TCP_RSTACK    (PICO_TCP_RST | PICO_TCP_ACK)\n\n\nPACKED_STRUCT_DEF pico_tcp_option\n{\n    uint8_t kind;\n    uint8_t len;\n};\n\nstruct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family);\nuint32_t pico_tcp_read(struct pico_socket *s, void *buf, uint32_t len);\nint pico_tcp_initconn(struct pico_socket *s);\nint pico_tcp_input(struct pico_socket *s, struct pico_frame *f);\nuint16_t pico_tcp_checksum(struct pico_frame *f);\nuint16_t pico_tcp_checksum_ipv4(struct pico_frame *f);\n#ifdef PICO_SUPPORT_IPV6\nuint16_t pico_tcp_checksum_ipv6(struct pico_frame *f);\n#endif\nuint16_t pico_tcp_overhead(struct pico_socket *s);\nint pico_tcp_output(struct pico_socket *s, int loop_score);\nint pico_tcp_queue_in_is_empty(struct pico_socket *s);\nint pico_tcp_queue_in_size(struct pico_socket *s);\nint pico_tcp_reply_rst(struct pico_stack *S, struct pico_frame *f);\nvoid pico_tcp_cleanup_queues(struct pico_socket *sck);\nvoid pico_tcp_notify_closing(struct pico_socket *sck);\nvoid pico_tcp_flags_update(struct pico_frame *f, struct pico_socket *s);\nint pico_tcp_set_bufsize_in(struct pico_socket *s, uint32_t value);\nint pico_tcp_set_bufsize_out(struct pico_socket *s, uint32_t value);\nint pico_tcp_get_bufsize_in(struct pico_socket *s, uint32_t *value);\nint pico_tcp_get_bufsize_out(struct pico_socket *s, uint32_t *value);\nint pico_tcp_set_keepalive_probes(struct pico_socket *s, uint32_t value);\nint pico_tcp_set_keepalive_intvl(struct pico_socket *s, uint32_t value);\nint pico_tcp_set_keepalive_time(struct pico_socket *s, uint32_t value);\nint pico_tcp_set_linger(struct pico_socket *s, uint32_t value);\nuint16_t pico_tcp_get_socket_mss(struct pico_socket *s);\nint pico_tcp_check_listen_close(struct pico_socket *s);\n\n#endif\n"], "fixing_code": ["/*********************************************************************\n * PicoTCP-NG \n * Copyright (c) 2020 Daniele Lacamera <root@danielinux.net>\n *\n * This file also includes code from:\n * PicoTCP\n * Copyright (c) 2012-2017 Altran Intelligent Systems\n * Authors: Daniele Lacamera, Philippe Mariman\n * SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only\n *\n * PicoTCP-NG is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) version 3.\n *\n * PicoTCP-NG is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n *\n *\n *********************************************************************/\n#include \"pico_tcp.h\"\n#include \"pico_config.h\"\n#include \"pico_eth.h\"\n#include \"pico_socket.h\"\n#include \"pico_stack.h\"\n#include \"pico_socket.h\"\n#include \"pico_socket_tcp.h\"\n#include \"pico_queue.h\"\n#include \"pico_tree.h\"\n#include \"pico_jobs.h\"\n\n#define TCP_IS_STATE(s, st) ((s->state & PICO_SOCKET_STATE_TCP) == st)\n#define TCP_SOCK(s) ((struct pico_socket_tcp *)s)\n#define SEQN(f) ((f) ? (long_be(((struct pico_tcp_hdr *)((f)->transport_hdr))->seq)) : 0)\n#define ACKN(f) ((f) ? (long_be(((struct pico_tcp_hdr *)((f)->transport_hdr))->ack)) : 0)\n\n#define TCP_TIME (pico_time)(PICO_TIME_MS())\n\n#define PICO_TCP_RTO_MIN (70)\n#define PICO_TCP_RTO_MAX (120000)\n#define PICO_TCP_IW          2\n#define PICO_TCP_SYN_TO  2000u\n#define PICO_TCP_ZOMBIE_TO 30000\n\n#define PICO_TCP_MAX_RETRANS         10\n#define PICO_TCP_MAX_CONNECT_RETRIES 3\n\n#define PICO_TCP_LOOKAHEAD      0x00\n#define PICO_TCP_FIRST_DUPACK   0x01\n#define PICO_TCP_SECOND_DUPACK  0x02\n#define PICO_TCP_RECOVER        0x03\n#define PICO_TCP_BLACKOUT       0x04\n#define PICO_TCP_UNREACHABLE    0x05\n#define PICO_TCP_WINDOW_FULL    0x06\n\n#define ONE_GIGABYTE ((uint32_t)(1024UL * 1024UL * 1024UL))\n\n/* check if tcp connection is \"idle\" according to Nagle (RFC 896) */\n#define IS_TCP_IDLE(t)          ((t->in_flight == 0) && (t->tcpq_out.size == 0))\n/* check if the hold queue contains data (again Nagle) */\n#define IS_TCP_HOLDQ_EMPTY(t)   (t->tcpq_hold.size == 0)\n\n#define IS_INPUT_QUEUE(q)  (q->pool.compare == input_segment_compare)\n#define TCP_INPUT_OVERHEAD (sizeof(struct tcp_input_segment) + sizeof(struct pico_tree_node))\n\n\n#ifdef PICO_SUPPORT_TCP\n#ifdef DEBUG_TCP_GENERAL\n#define tcp_dbg              dbg\n#else\n#define tcp_dbg(...)         do {} while(0)\n#endif\n\n#ifdef DEBUG_TCP_NAGLE\n#define tcp_dbg_nagle        dbg\n#else\n#define tcp_dbg_nagle(...)   do {} while(0)\n#endif\n\n#ifdef DEBUG_TCP_OPTIONS\n#define tcp_dbg_options      dbg\n#else\n#define tcp_dbg_options(...) do {} while(0)\n#endif\n\n#ifdef PICO_SUPPORT_MUTEX\nstatic void *Mutex = NULL;\n#endif\n\n\n\n/* Input segment, used to keep only needed data, not the full frame */\nstruct tcp_input_segment\n{\n    uint32_t seq;\n    /* Pointer to payload */\n    unsigned char *payload;\n    uint16_t payload_len;\n};\n\n/* Function to compare input segments */\nstatic int input_segment_compare(void *ka, void *kb)\n{\n    struct tcp_input_segment *a = ka, *b = kb;\n    return pico_seq_compare(a->seq, b->seq);\n}\n\nstatic struct tcp_input_segment *segment_from_frame(struct pico_frame *f)\n{\n    struct tcp_input_segment *seg;\n\n    if (!f->payload_len)\n        return NULL;\n\n    seg = PICO_ZALLOC(sizeof(struct tcp_input_segment));\n    if (!seg)\n        return NULL;\n\n    seg->payload = PICO_ZALLOC(f->payload_len);\n    if(!seg->payload)\n    {\n        PICO_FREE(seg);\n        return NULL;\n    }\n\n    seg->seq = SEQN(f);\n    seg->payload_len = f->payload_len;\n    memcpy(seg->payload, f->payload, seg->payload_len);\n    return seg;\n}\n\nstatic int segment_compare(void *ka, void *kb)\n{\n    struct pico_frame *a = ka, *b = kb;\n    return pico_seq_compare(SEQN(a), SEQN(b));\n}\n\nstruct pico_tcp_queue\n{\n    struct pico_tree pool;\n    uint32_t max_size;\n    uint32_t size;\n    uint32_t frames;\n};\n\nstatic void tcp_discard_all_segments(struct pico_tcp_queue *tq);\nstatic void *peek_segment(struct pico_tcp_queue *tq, uint32_t seq)\n{\n    if(!IS_INPUT_QUEUE(tq))\n    {\n        struct pico_tcp_hdr H;\n        struct pico_frame f = {\n            0\n        };\n        f.transport_hdr = (uint8_t *) (&H);\n        H.seq = long_be(seq);\n\n        return pico_tree_findKey(&tq->pool, &f);\n    }\n    else\n    {\n        struct tcp_input_segment dummy = {\n            0\n        };\n        dummy.seq = seq;\n\n        return pico_tree_findKey(&tq->pool, &dummy);\n    }\n\n}\n\nstatic void *first_segment(struct pico_tcp_queue *tq)\n{\n    return pico_tree_first(&tq->pool);\n}\n\nstatic void *next_segment(struct pico_tcp_queue *tq, void *cur)\n{\n    if (!cur)\n        return NULL;\n\n    if(IS_INPUT_QUEUE(tq))\n    {\n        return peek_segment(tq, ((struct tcp_input_segment *)cur)->seq + ((struct tcp_input_segment *)cur)->payload_len);\n    }\n    else\n    {\n        return peek_segment(tq, SEQN((struct pico_frame *)cur) + ((struct pico_frame *)cur)->payload_len);\n    }\n}\n\nstatic uint16_t enqueue_segment_len(struct pico_tcp_queue *tq, void *f)\n{\n    if (IS_INPUT_QUEUE(tq)) {\n        return ((struct tcp_input_segment *)f)->payload_len;\n    } else {\n        return (uint16_t)(((struct pico_frame *)f)->buffer_len);\n    }\n}\n\n\nstatic int32_t do_enqueue_segment(struct pico_tcp_queue *tq, void *f, uint16_t payload_len)\n{\n    int32_t ret = -1;\n    PICOTCP_MUTEX_LOCK(Mutex);\n    if ((tq->size + payload_len) > tq->max_size)\n    {\n        ret = 0;\n        goto out;\n    }\n\n    if (pico_tree_insert(&tq->pool, f) != 0)\n    {\n        ret = 0;\n        goto out;\n    }\n\n    tq->size += (uint16_t)payload_len;\n    if (payload_len > 0)\n        tq->frames++;\n\n    ret = (int32_t)payload_len;\n\nout:\n    PICOTCP_MUTEX_UNLOCK(Mutex);\n    return ret;\n}\n\nstatic int32_t pico_enqueue_segment(struct pico_tcp_queue *tq, void *f)\n{\n    uint16_t payload_len;\n\n    if (!f)\n        return -1;\n\n    payload_len = enqueue_segment_len(tq, f);\n\n\n    if (payload_len == 0) {\n        tcp_dbg(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! TRIED TO ENQUEUE INVALID SEGMENT!\\n\");\n        return -1;\n    }\n\n    return do_enqueue_segment(tq, f, payload_len);\n}\n\nstatic void pico_discard_segment(struct pico_tcp_queue *tq, void *f)\n{\n    void *f1;\n    uint16_t payload_len = (uint16_t)((IS_INPUT_QUEUE(tq)) ?\n                                      (((struct tcp_input_segment *)f)->payload_len) :\n                                      (((struct pico_frame *)f)->buffer_len));\n    PICOTCP_MUTEX_LOCK(Mutex);\n    f1 = pico_tree_delete(&tq->pool, f);\n    if (f1) {\n        tq->size -= (uint16_t)payload_len;\n        if (payload_len > 0)\n            tq->frames--;\n    }\n\n    if(f1 && IS_INPUT_QUEUE(tq))\n    {\n        struct tcp_input_segment *inp = f1;\n        PICO_FREE(inp->payload);\n        PICO_FREE(inp);\n    }\n    else\n        pico_frame_discard(f);\n\n    PICOTCP_MUTEX_UNLOCK(Mutex);\n}\n\n/* Structure for TCP socket */\nstruct tcp_sack_block {\n    uint32_t left;\n    uint32_t right;\n    struct tcp_sack_block *next;\n};\n\nstruct pico_socket_tcp {\n    struct pico_socket sock;\n\n    /* Tree/queues */\n    struct pico_tcp_queue tcpq_in;  /* updated the input queue to hold input segments not the full frame. */\n    struct pico_tcp_queue tcpq_out;\n    struct pico_tcp_queue tcpq_hold; /* buffer to hold delayed frames according to Nagle */\n\n    /* tcp_output */\n    uint32_t snd_nxt;\n    uint32_t snd_last;\n    uint32_t snd_old_ack;\n    uint32_t snd_retry;\n    uint32_t snd_last_out;\n\n    /* congestion control */\n    uint32_t avg_rtt;\n    uint32_t rttvar;\n    uint32_t rto;\n    uint32_t in_flight;\n    uint32_t retrans_tmr;\n    pico_time retrans_tmr_due;\n    uint16_t cwnd_counter;\n    uint16_t cwnd;\n    uint16_t ssthresh;\n    uint16_t recv_wnd;\n    uint16_t recv_wnd_scale;\n\n    /* tcp_input */\n    uint32_t rcv_nxt;\n    uint32_t rcv_ackd;\n    uint32_t rcv_processed;\n    uint16_t wnd;\n    uint16_t wnd_scale;\n    uint16_t remote_closed;\n\n    /* options */\n    uint32_t ts_nxt;\n    uint16_t mss;\n    uint8_t sack_ok;\n    uint8_t ts_ok;\n    uint8_t mss_ok;\n    uint8_t scale_ok;\n    struct tcp_sack_block *sacks;\n    uint32_t linger_timeout;\n\n    /* Transmission */\n    uint8_t x_mode;\n    uint8_t dupacks;\n    uint8_t backoff;\n    uint8_t localZeroWindow;\n\n    /* Keepalive */\n    uint32_t keepalive_tmr;\n    pico_time ack_timestamp;\n    uint32_t ka_time;\n    uint32_t ka_intvl;\n    uint32_t ka_probes;\n    uint32_t ka_retries_count;\n\n    /* FIN timer */\n    uint32_t fin_tmr;\n};\n\n/* If Nagle enabled, this function can make 1 new segment from smaller segments in hold queue */\nstatic struct pico_frame *pico_hold_segment_make(struct pico_socket_tcp *t);\n\n/* checks if tcpq_in is empty */\nint pico_tcp_queue_in_is_empty(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n\n    if (t->tcpq_in.frames == 0)\n        return 1;\n    else\n        return 0;\n}\n\n/* checks tcpq_in size */\nint pico_tcp_queue_in_size(struct pico_socket *s)\n{\n    struct tcp_input_segment *f;\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    if (!t)\n        return -1;\n    f = first_segment(&t->tcpq_in);\n    if (!f)\n        return 0;\n    return f->payload_len;\n}\n\n/* Useful for getting rid of the beginning of the buffer (read() op) */\nstatic int release_until(struct pico_tcp_queue *q, uint32_t seq)\n{\n    void *head = first_segment(q);\n    int ret = 0;\n    int32_t seq_result = 0;\n\n    if (!head)\n        return ret;\n\n    do {\n        void *cur = head;\n\n        if (IS_INPUT_QUEUE(q))\n            seq_result = pico_seq_compare(((struct tcp_input_segment *)head)->seq + ((struct tcp_input_segment *)head)->payload_len, seq);\n        else\n            seq_result = pico_seq_compare(SEQN((struct pico_frame *)head) + ((struct pico_frame *)head)->payload_len, seq);\n\n        if (seq_result <= 0)\n        {\n            head = next_segment(q, cur);\n            /* tcp_dbg(\"Releasing %08x, len: %d\\n\", SEQN((struct pico_frame *)head), ((struct pico_frame *)head)->payload_len); */\n            pico_discard_segment(q, cur);\n            ret++;\n        } else {\n            break;\n        }\n    } while (head);\n\n    return ret;\n}\n\nstatic int release_all_until(struct pico_tcp_queue *q, uint32_t seq, pico_time *timestamp)\n{\n    void *f = NULL;\n    struct pico_tree_node *idx, *temp;\n    int seq_result;\n    int ret = 0;\n    *timestamp = 0;\n\n    pico_tree_foreach_safe(idx, &q->pool, temp)\n    {\n        f = idx->keyValue;\n\n        if (IS_INPUT_QUEUE(q))\n            seq_result = pico_seq_compare(((struct tcp_input_segment *)f)->seq + ((struct tcp_input_segment *)f)->payload_len, seq);\n        else\n            seq_result = pico_seq_compare(SEQN((struct pico_frame *)f) + ((struct pico_frame *)f)->payload_len, seq);\n\n        if (seq_result <= 0) {\n            tcp_dbg(\"Releasing %p\\n\", f);\n            if ((seq_result == 0) && !IS_INPUT_QUEUE(q))\n                *timestamp = ((struct pico_frame *)f)->timestamp;\n\n            pico_discard_segment(q, f);\n            ret++;\n        } else {\n            return ret;\n        }\n    }\n    return ret;\n}\n\n\n/* API calls */\n\nuint16_t pico_tcp_checksum_ipv4(struct pico_frame *f)\n{\n    struct pico_ipv4_hdr *hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    struct pico_tcp_hdr *tcp_hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    struct pico_socket *s = f->sock;\n    struct pico_ipv4_pseudo_hdr pseudo;\n\n    if (s) {\n        /* Case of outgoing frame */\n        /* dbg(\"TCP CRC: on outgoing frame\\n\"); */\n        pseudo.src.addr = s->local_addr.ip4.addr;\n        pseudo.dst.addr = s->remote_addr.ip4.addr;\n    } else {\n        /* Case of incoming frame */\n        /* dbg(\"TCP CRC: on incoming frame\\n\"); */\n        pseudo.src.addr = hdr->src.addr;\n        pseudo.dst.addr = hdr->dst.addr;\n    }\n\n    pseudo.zeros = 0;\n    pseudo.proto = PICO_PROTO_TCP;\n    pseudo.len = (uint16_t)short_be(f->transport_len);\n\n    return pico_dualbuffer_checksum(&pseudo, sizeof(struct pico_ipv4_pseudo_hdr), tcp_hdr, f->transport_len);\n}\n\n#ifdef PICO_SUPPORT_IPV6\nuint16_t pico_tcp_checksum_ipv6(struct pico_frame *f)\n{\n    struct pico_ipv6_hdr *ipv6_hdr = (struct pico_ipv6_hdr *)f->net_hdr;\n    struct pico_tcp_hdr *tcp_hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    struct pico_ipv6_pseudo_hdr pseudo;\n    struct pico_socket *s = f->sock;\n\n    /* XXX If the IPv6 packet contains a Routing header, the Destination\n     *     Address used in the pseudo-header is that of the final destination */\n    if (s) {\n        /* Case of outgoing frame */\n        pseudo.src = s->local_addr.ip6;\n        pseudo.dst = s->remote_addr.ip6;\n    } else {\n        /* Case of incoming frame */\n        pseudo.src = ipv6_hdr->src;\n        pseudo.dst = ipv6_hdr->dst;\n    }\n\n    pseudo.zero[0] = 0;\n    pseudo.zero[1] = 0;\n    pseudo.zero[2] = 0;\n    pseudo.len = long_be(f->transport_len);\n    pseudo.nxthdr = PICO_PROTO_TCP;\n\n    return pico_dualbuffer_checksum(&pseudo, sizeof(struct pico_ipv6_pseudo_hdr), tcp_hdr, f->transport_len);\n}\n#endif\n\n#ifdef PICO_SUPPORT_IPV4\nstatic inline int checksum_is_ipv4(struct pico_frame *f)\n{\n    return (IS_IPV4(f) || (f->sock && (f->sock->net == &pico_proto_ipv4)));\n}\n#endif\n\n#ifdef PICO_SUPPORT_IPV6\nstatic inline int checksum_is_ipv6(struct pico_frame *f)\n{\n    return ((IS_IPV6(f)) || (f->sock && (f->sock->net == &pico_proto_ipv6)));\n}\n#endif\n\nuint16_t pico_tcp_checksum(struct pico_frame *f)\n{\n    (void)f;\n\n    #ifdef PICO_SUPPORT_IPV4\n    if (checksum_is_ipv4(f))\n        return pico_tcp_checksum_ipv4(f);\n\n    #endif\n\n    #ifdef PICO_SUPPORT_IPV6\n    if (checksum_is_ipv6(f))\n        return pico_tcp_checksum_ipv6(f);\n\n    #endif\n    return 0xffff;\n}\n\nstatic void tcp_send_fin(struct pico_socket_tcp *t);\nstatic int pico_tcp_process_out(struct pico_stack *S, struct pico_protocol *self, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr;\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    IGNORE_PARAMETER(S);\n    IGNORE_PARAMETER(self);\n    hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    f->sock->timestamp = TCP_TIME;\n    if (f->payload_len > 0) {\n        tcp_dbg(\"Process out: sending %p (%d bytes)\\n\", f, f->payload_len);\n    } else {\n        tcp_dbg(\"Sending empty packet\\n\");\n    }\n\n    if (f->payload_len > 0) {\n        if (pico_seq_compare(SEQN(f) + f->payload_len, t->snd_nxt) > 0) {\n            t->snd_nxt = SEQN(f) + f->payload_len;\n            tcp_dbg(\"%s: snd_nxt is now %08x\\n\", __FUNCTION__, t->snd_nxt);\n        }\n    } else if (hdr->flags == PICO_TCP_ACK) { /* pure ack */\n        /* hdr->seq = long_be(t->snd_nxt);   / * XXX disabled this to not to mess with seq nrs of ACKs anymore * / */\n    } else {\n        tcp_dbg(\"%s: non-pure ACK with len=0, fl:%04x\\n\", __FUNCTION__, hdr->flags);\n    }\n\n    pico_network_send(f);\n    return 0;\n}\n\nint pico_tcp_push(struct pico_stack *S, struct pico_protocol *self, struct pico_frame *data);\n\n/* Interface: protocol definition */\nstruct pico_protocol pico_proto_tcp = {\n    .name = \"tcp\",\n    .proto_number = PICO_PROTO_TCP,\n    .layer = PICO_LAYER_TRANSPORT,\n    .process_in = pico_transport_process_in,\n    .process_out = pico_tcp_process_out,\n    .push = pico_tcp_push,\n};\n\nstatic uint32_t pico_paws(void)\n{\n    static uint32_t _paws = 0;\n    _paws = pico_rand();\n    return long_be(_paws);\n}\n\nstatic inline void tcp_add_sack_option(struct pico_socket_tcp *ts, struct pico_frame *f, uint16_t flags, uint32_t *ii)\n{\n    if (flags & PICO_TCP_ACK) {\n        struct tcp_sack_block *sb;\n        uint32_t len_off;\n\n        if (ts->sack_ok && ts->sacks) {\n            f->start[(*ii)++] = PICO_TCP_OPTION_SACK;\n            len_off = *ii;\n            f->start[(*ii)++] = PICO_TCPOPTLEN_SACK;\n            while(ts->sacks) {\n                sb = ts->sacks;\n                ts->sacks = sb->next;\n                memcpy(f->start + *ii, sb, 2 * sizeof(uint32_t));\n                *ii += (2 * (uint32_t)sizeof(uint32_t));\n                f->start[len_off] = (uint8_t)(f->start[len_off] + (2 * sizeof(uint32_t)));\n                PICO_FREE(sb);\n            }\n        }\n    }\n}\n\nstatic void tcp_add_options(struct pico_socket_tcp *ts, struct pico_frame *f, uint16_t flags, uint16_t optsiz)\n{\n    uint32_t tsval = long_be((uint32_t)TCP_TIME);\n    uint32_t tsecr = long_be(ts->ts_nxt);\n    uint32_t i = 0;\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n\n    memset(f->start, PICO_TCP_OPTION_NOOP, optsiz); /* fill blanks with noop */\n\n    if (flags & PICO_TCP_SYN) {\n        f->start[i++] = PICO_TCP_OPTION_MSS;\n        f->start[i++] = PICO_TCPOPTLEN_MSS;\n        f->start[i++] = (uint8_t)((ts->mss >> 8) & 0xFF);\n        f->start[i++] = (uint8_t)(ts->mss & 0xFF);\n        f->start[i++] = PICO_TCP_OPTION_SACK_OK;\n        f->start[i++] = PICO_TCPOPTLEN_SACK_OK;\n    }\n\n    f->start[i++] = PICO_TCP_OPTION_WS;\n    f->start[i++] = PICO_TCPOPTLEN_WS;\n    f->start[i++] = (uint8_t)(ts->wnd_scale);\n\n    if ((flags & PICO_TCP_SYN) || ts->ts_ok) {\n        f->start[i++] = PICO_TCP_OPTION_TIMESTAMP;\n        f->start[i++] = PICO_TCPOPTLEN_TIMESTAMP;\n        memcpy(f->start + i, &tsval, 4);\n        i += 4;\n        memcpy(f->start + i, &tsecr, 4);\n        i += 4;\n    }\n\n    tcp_add_sack_option(ts, f, flags, &i);\n\n    if (i < optsiz)\n        f->start[ optsiz - 1 ] = PICO_TCP_OPTION_END;\n}\n\nstatic uint16_t tcp_options_size_frame(struct pico_frame *f)\n{\n    uint16_t size = 0;\n\n    /* Always update window scale. */\n    size = (uint16_t)(size + PICO_TCPOPTLEN_WS);\n    if (f->transport_flags_saved)\n        size = (uint16_t)(size + PICO_TCPOPTLEN_TIMESTAMP);\n\n    size = (uint16_t)(size + PICO_TCPOPTLEN_END);\n    size = (uint16_t)(((uint16_t)(size + 3u) >> 2u) << 2u);\n    return size;\n}\n\nstatic void tcp_add_options_frame(struct pico_socket_tcp *ts, struct pico_frame *f)\n{\n    uint32_t tsval = long_be((uint32_t)TCP_TIME);\n    uint32_t tsecr = long_be(ts->ts_nxt);\n    uint32_t i = 0;\n    uint16_t optsiz = tcp_options_size_frame(f);\n\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n\n    memset(f->start, PICO_TCP_OPTION_NOOP, optsiz); /* fill blanks with noop */\n\n\n    f->start[i++] = PICO_TCP_OPTION_WS;\n    f->start[i++] = PICO_TCPOPTLEN_WS;\n    f->start[i++] = (uint8_t)(ts->wnd_scale);\n\n    if (f->transport_flags_saved) {\n        f->start[i++] = PICO_TCP_OPTION_TIMESTAMP;\n        f->start[i++] = PICO_TCPOPTLEN_TIMESTAMP;\n        memcpy(f->start + i, &tsval, 4);\n        i += 4;\n        memcpy(f->start + i, &tsecr, 4);\n        i += 4;\n    }\n\n    if (i < optsiz)\n        f->start[ optsiz - 1 ] = PICO_TCP_OPTION_END;\n}\n\nstatic void tcp_send_ack(struct pico_socket_tcp *t);\n#define tcp_send_windowUpdate(t) (tcp_send_ack(t))\n\nstatic inline void tcp_set_space_check_winupdate(struct pico_socket_tcp *t, int32_t space, uint32_t shift)\n{\n    if (((uint32_t)space != t->wnd) || (shift != t->wnd_scale) || ((space - t->wnd) > (int32_t)((uint32_t)space >> 2u))) {\n        t->wnd = (uint16_t)space;\n        t->wnd_scale = (uint16_t)shift;\n\n        if(t->wnd == 0) /* mark the entering to zero window state */\n            t->localZeroWindow = 1u;\n        else if(t->localZeroWindow)\n        {\n            t->localZeroWindow = 0u;\n            tcp_send_windowUpdate(t);\n        }\n    }\n}\n\nstatic void tcp_set_space(struct pico_socket_tcp *t)\n{\n    int32_t space;\n    uint32_t shift = 0;\n\n    if (t->tcpq_in.max_size == 0) {\n        space = ONE_GIGABYTE;\n    } else {\n        space = (int32_t)(t->tcpq_in.max_size - t->tcpq_in.size);\n    }\n\n    if (space < 0)\n        space = 0;\n\n    while(space > 0xFFFF) {\n        space = (int32_t)(((uint32_t)space >> 1u));\n        shift++;\n    }\n    tcp_set_space_check_winupdate(t, space, shift);\n}\n\n/* Return 32-bit aligned option size */\nstatic uint16_t tcp_options_size(struct pico_socket_tcp *t, uint16_t flags)\n{\n    uint16_t size = 0;\n    struct tcp_sack_block *sb = t->sacks;\n\n    if (flags & PICO_TCP_SYN) { /* Full options */\n        size = PICO_TCPOPTLEN_MSS + PICO_TCP_OPTION_SACK_OK + PICO_TCPOPTLEN_WS + PICO_TCPOPTLEN_TIMESTAMP;\n    } else {\n\n        /* Always update window scale. */\n        size = (uint16_t)(size + PICO_TCPOPTLEN_WS);\n\n        if (t->ts_ok)\n            size = (uint16_t)(size + PICO_TCPOPTLEN_TIMESTAMP);\n\n        size = (uint16_t)(size + PICO_TCPOPTLEN_END);\n    }\n\n    if ((flags & PICO_TCP_ACK) && (t->sack_ok && sb)) {\n        size = (uint16_t)(size + 2);\n        while(sb) {\n            size = (uint16_t)(size + (2 * sizeof(uint32_t)));\n            sb = sb->next;\n        }\n    }\n\n    size = (uint16_t)(((size + 3u) >> 2u) << 2u);\n    return size;\n}\n\nuint16_t pico_tcp_overhead(struct pico_socket *s)\n{\n    if (!s)\n        return 0;\n\n    return (uint16_t)(PICO_SIZE_TCPHDR + tcp_options_size((struct pico_socket_tcp *)s, (uint16_t)0)); /* hdr + Options size for data pkt */\n\n}\n\nstatic inline int tcp_sack_marker(struct pico_frame *f, uint32_t start, uint32_t end, uint16_t *count)\n{\n    int cmp;\n    cmp = pico_seq_compare(SEQN(f), start);\n    if (cmp > 0)\n        return 0;\n\n    if (cmp == 0) {\n        cmp = pico_seq_compare(SEQN(f) + f->payload_len, end);\n        if (cmp > 0) {\n            tcp_dbg(\"Invalid SACK: ignoring.\\n\");\n        }\n\n        tcp_dbg(\"Marking (by SACK) segment %08x BLK:[%08x::%08x]\\n\", SEQN(f), start, end);\n        f->flags |= PICO_FRAME_FLAG_SACKED;\n        (*count)++;\n    }\n\n    return cmp;\n}\n\nstatic void tcp_process_sack(struct pico_socket_tcp *t, uint32_t start, uint32_t end)\n{\n    struct pico_frame *f;\n    struct pico_tree_node *index, *temp;\n    uint16_t count = 0;\n\n    pico_tree_foreach_safe(index, &t->tcpq_out.pool, temp){\n        f = index->keyValue;\n        if (tcp_sack_marker(f, start, end, &count) == 0)\n            goto done;\n    }\n\ndone:\n    if (t->x_mode > PICO_TCP_LOOKAHEAD) {\n        if (t->in_flight > (count))\n            t->in_flight -= (count);\n        else\n            t->in_flight = 0;\n    }\n}\n\ninline static void tcp_add_header(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    f->timestamp = TCP_TIME;\n    tcp_add_options(t, f, 0, (uint16_t)(f->transport_len - f->payload_len - (uint16_t)PICO_SIZE_TCPHDR));\n    hdr->rwnd = short_be(t->wnd);\n    hdr->flags |= PICO_TCP_PSH | PICO_TCP_ACK;\n    hdr->ack = long_be(t->rcv_nxt);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n}\n\nstatic void tcp_rcv_sack(struct pico_socket_tcp *t, uint8_t *opt, int len)\n{\n    uint32_t start, end;\n    int i = 0;\n    if (len % 8) {\n        tcp_dbg(\"SACK: Invalid len.\\n\");\n        return;\n    }\n\n    while (i < len) {\n        start = long_from(opt + i);\n        i += 4;\n        end = long_from(opt + i);\n        i += 4;\n        tcp_process_sack(t, long_be(start), long_be(end));\n    }\n}\n\nstatic int tcpopt_len_check(uint32_t *idx, uint8_t len, uint8_t expected)\n{\n    if (len != expected) {\n        if (len < 2)\n            return -1;\n        *idx = *idx + len - 2;\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic inline void tcp_parse_option_ws(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_WS) < 0)\n        return;\n\n    t->recv_wnd_scale = opt[(*idx)++];\n    tcp_dbg_options(\"TCP Window scale: received %d\\n\", t->recv_wnd_scale);\n\n}\n\nstatic inline void tcp_parse_option_sack_ok(struct pico_socket_tcp *t, struct pico_frame *f, uint8_t len, uint32_t *idx)\n{\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_SACK_OK) < 0)\n        return;\n\n    if(((struct pico_tcp_hdr *)(f->transport_hdr))->flags & PICO_TCP_SYN )\n        t->sack_ok = 1;\n}\n\nstatic inline void tcp_parse_option_mss(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    uint16_t mss;\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_MSS) < 0)\n        return;\n\n    t->mss_ok = 1;\n    mss = short_from(opt + *idx);\n    *idx += (uint32_t)sizeof(uint16_t);\n    if (t->mss > short_be(mss))\n        t->mss = short_be(mss);\n}\n\nstatic inline void tcp_parse_option_timestamp(struct pico_socket_tcp *t, struct pico_frame *f, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    uint32_t tsval, tsecr;\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_TIMESTAMP) < 0)\n        return;\n\n    t->ts_ok = 1;\n    tsval = long_from(opt + *idx);\n    *idx += (uint32_t)sizeof(uint32_t);\n    tsecr = long_from(opt + *idx);\n    f->timestamp = long_be(tsecr);\n    *idx += (uint32_t)sizeof(uint32_t);\n    t->ts_nxt = long_be(tsval);\n}\n\nstatic int tcp_parse_options(struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n    uint32_t i = 0;\n    f->timestamp = 0;\n    while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n        uint8_t type =  opt[i++];\n        uint8_t len;\n        if(i < (f->transport_len - PICO_SIZE_TCPHDR) && (type > 1))\n            len =  opt[i++];\n        else\n            len = 1;\n\n        if (f->payload && ((opt + i) > f->payload))\n            break;\n\n        if (len == 0) {\n            return -1;\n        }\n\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", type, len);\n        switch (type) {\n        case PICO_TCP_OPTION_NOOP:\n        case PICO_TCP_OPTION_END:\n            break;\n        case PICO_TCP_OPTION_WS:\n            tcp_parse_option_ws(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK_OK:\n            tcp_parse_option_sack_ok(t, f, len, &i);\n            break;\n        case PICO_TCP_OPTION_MSS:\n            tcp_parse_option_mss(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_TIMESTAMP:\n            tcp_parse_option_timestamp(t, f, len, opt, &i);\n            break;\n\n        case PICO_TCP_OPTION_SACK:\n            tcp_rcv_sack(t, opt + i, len - 2);\n            i = i + len - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", type);\n            i = i + len - 2;\n        }\n    }\n    return 0;\n}\n\nstatic inline void tcp_send_add_tcpflags(struct pico_socket_tcp *ts, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    if (ts->rcv_nxt != 0) {\n        if ((ts->rcv_ackd == 0) || (pico_seq_compare(ts->rcv_ackd, ts->rcv_nxt) != 0) || (hdr->flags & PICO_TCP_ACK)) {\n            hdr->flags |= PICO_TCP_ACK;\n            hdr->ack = long_be(ts->rcv_nxt);\n            ts->rcv_ackd = ts->rcv_nxt;\n        }\n    }\n\n    if (hdr->flags & PICO_TCP_SYN) {\n        ts->snd_nxt++;\n    }\n\n    if (f->payload_len > 0) {\n        hdr->flags |= PICO_TCP_PSH | PICO_TCP_ACK;\n        hdr->ack = long_be(ts->rcv_nxt);\n        ts->rcv_ackd = ts->rcv_nxt;\n    }\n}\n\nstatic inline int tcp_send_try_enqueue(struct pico_socket_tcp *ts, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    struct pico_frame *cpy;\n    (void)hdr;\n\n    /* TCP: ENQUEUE to PROTO ( Transmit ) */\n    cpy = pico_frame_copy(f);\n    if (!cpy) {\n        pico_err = PICO_ERR_ENOMEM;\n        return -1;\n    }\n\n    if ((pico_enqueue(&ts->sock.stack->q_tcp.out, cpy) > 0)) {\n        if (f->payload_len > 0) {\n            ts->in_flight++;\n            ts->snd_nxt += f->payload_len; /* update next pointer here to prevent sending same segment twice when called twice in same tick */\n        }\n\n        tcp_dbg(\"DBG> [tcp output] state: %02x --> local port:%u remote port: %u seq: %08x ack: %08x flags: %02x = t_len: %u, hdr: %u payload: %d\\n\",\n                TCPSTATE(&ts->sock) >> 8, short_be(hdr->trans.sport), short_be(hdr->trans.dport), SEQN(f), ACKN(f), hdr->flags, f->transport_len, (hdr->len & 0xf0) >> 2, f->payload_len );\n    } else {\n        pico_frame_discard(cpy);\n    }\n\n    return 0;\n\n}\n\nstatic int tcp_send(struct pico_socket_tcp *ts, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n    if (!hdr->seq)\n        hdr->seq = long_be(ts->snd_nxt);\n\n    tcp_send_add_tcpflags(ts, f);\n\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n    hdr->rwnd = short_be(ts->wnd);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n\n    return tcp_send_try_enqueue(ts, f);\n\n}\n\n/* #define PICO_TCP_SUPPORT_SOCKET_STATS */\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\nstatic void sock_stats(uint32_t when, void *arg)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)arg;\n    tcp_dbg(\"STATISTIC> [%lu] socket state: %02x --> local port:%d remote port: %d queue size: %d snd_una: %08x snd_nxt: %08x cwnd: %d\\n\",\n            when, t->sock.state, short_be(t->sock.local_port), short_be(t->sock.remote_port), t->tcpq_out.size, SEQN((struct pico_frame *)first_segment(&t->tcpq_out)), t->snd_nxt, t->cwnd);\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n    }\n}\n#endif\n\nstatic void tcp_send_probe(struct pico_socket_tcp *t);\n\nstatic void pico_tcp_keepalive(pico_time now, void *arg)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)arg;\n    if (((t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED)  && (t->ka_time > 0)) {\n        if (t->ka_time < (now - t->ack_timestamp)) {\n            if (t->ka_retries_count == 0) {\n                /* First probe */\n                tcp_send_probe(t);\n                t->ka_retries_count++;\n            }\n\n            if (t->ka_retries_count > t->ka_probes) {\n                if (t->sock.wakeup)\n                {\n                    pico_err = PICO_ERR_ECONNRESET;\n                    t->sock.wakeup(PICO_SOCK_EV_ERR, &t->sock);\n                }\n            }\n\n            if (((t->ka_retries_count * (pico_time)t->ka_intvl) + t->ka_time) < (now - t->ack_timestamp)) {\n                /* Next probe */\n                tcp_send_probe(t);\n                t->ka_retries_count++;\n            }\n        } else {\n            t->ka_retries_count = 0;\n        }\n    }\n\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        if (t->sock.wakeup)\n            t->sock.wakeup(PICO_SOCK_EV_ERR, &t->sock);\n    }\n}\n\nstatic inline void rto_set(struct pico_socket_tcp *t, uint32_t rto)\n{\n    if (rto < PICO_TCP_RTO_MIN)\n        rto = PICO_TCP_RTO_MIN;\n\n    if (rto > PICO_TCP_RTO_MAX)\n        rto = PICO_TCP_RTO_MAX;\n\n    t->rto = rto;\n}\n\n\nstruct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family)\n{\n    struct pico_socket_tcp *t = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!t)\n        return NULL;\n\n    t->sock.stack = S;\n    t->sock.timestamp = TCP_TIME;\n    pico_socket_set_family(&t->sock, family);\n    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock));\n    if (t->mss > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n        t->mss -= (uint16_t)PICO_SIZE_TCPHDR;\n    else\n        t->mss = PICO_TCP_MIN_MSS;\n    t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n    t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n    t->tcpq_in.pool.compare = input_segment_compare;\n    t->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_hold.max_size = 2u * t->mss;\n    rto_set(t, PICO_TCP_RTO_MIN);\n\n    /* Uncomment next line and disable Nagle by default */\n    t->sock.opt_flags |= (1 << PICO_SOCKET_OPT_TCPNODELAY);\n\n    /* Uncomment next line and Nagle is enabled by default */\n    /* t->sock.opt_flags &= (uint16_t) ~(1 << PICO_SOCKET_OPT_TCPNODELAY); */\n\n    /* Set default linger for the socket */\n    t->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n#endif\n\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n    tcp_set_space(t);\n    return &t->sock;\n}\n\nstatic uint32_t tcp_read_finish(struct pico_socket *s, uint32_t tot_rd_len)\n{\n    struct pico_socket_tcp *t = TCP_SOCK(s);\n    tcp_set_space(t);\n    if (t->tcpq_in.size == 0) {\n        s->ev_pending &= (uint16_t)(~PICO_SOCK_EV_RD);\n    }\n\n    if (t->remote_closed) {\n        s->ev_pending |= (uint16_t)(PICO_SOCK_EV_CLOSE);\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_CLOSE_WAIT;\n        /* set SHUT_REMOTE */\n        s->state |= PICO_SOCKET_STATE_SHUT_REMOTE;\n        if (s->wakeup) {\n            s->wakeup(PICO_SOCK_EV_CLOSE, s);\n        }\n    }\n\n    return tot_rd_len;\n}\n\nstatic inline uint32_t tcp_read_in_frame_len(struct tcp_input_segment *f, int32_t in_frame_off, uint32_t tot_rd_len, uint32_t read_op_len)\n{\n    uint32_t in_frame_len = 0;\n    if (in_frame_off > 0)\n    {\n        if ((uint32_t)in_frame_off > f->payload_len) {\n            tcp_dbg(\"FATAL TCP ERR: in_frame_off > f->payload_len\\n\");\n        }\n\n        in_frame_len = f->payload_len - (uint32_t)in_frame_off;\n    } else { /* in_frame_off == 0 */\n        in_frame_len = f->payload_len;\n    }\n\n    if ((in_frame_len + tot_rd_len) > (uint32_t)read_op_len) {\n        in_frame_len = read_op_len - tot_rd_len;\n    }\n\n    return in_frame_len;\n\n}\n\nstatic inline void tcp_read_check_segment_done(struct pico_socket_tcp *t, struct tcp_input_segment *f, uint32_t in_frame_len)\n{\n    if ((in_frame_len == 0u) || (in_frame_len == (uint32_t)f->payload_len)) {\n        pico_discard_segment(&t->tcpq_in, f);\n    }\n}\n\nuint32_t pico_tcp_read(struct pico_socket *s, void *buf, uint32_t len)\n{\n    struct pico_socket_tcp *t = TCP_SOCK(s);\n    struct tcp_input_segment *f;\n    int32_t in_frame_off;\n    uint32_t in_frame_len;\n    uint32_t tot_rd_len = 0;\n\n    while (tot_rd_len < len) {\n        /* To be sure we don't have garbage at the beginning */\n        release_until(&t->tcpq_in, t->rcv_processed);\n        f = first_segment(&t->tcpq_in);\n        if (!f)\n            return tcp_read_finish(s, tot_rd_len);\n\n        in_frame_off = pico_seq_compare(t->rcv_processed, f->seq);\n        /* Check for hole at the beginning of data, awaiting retransmissions. */\n        if (in_frame_off < 0) {\n            tcp_dbg(\"TCP> read hole beginning of data, %08x - %08x. rcv_nxt is %08x\\n\", t->rcv_processed, f->seq, t->rcv_nxt);\n            return tcp_read_finish(s, tot_rd_len);\n        }\n\n        in_frame_len = tcp_read_in_frame_len(f, in_frame_off, tot_rd_len, len);\n\n\n        memcpy((uint8_t *)buf + tot_rd_len, f->payload + in_frame_off, in_frame_len);\n        tot_rd_len += in_frame_len;\n        t->rcv_processed += in_frame_len;\n\n        tcp_read_check_segment_done(t, f, in_frame_len);\n\n    }\n    return tcp_read_finish(s, tot_rd_len);\n}\n\nint pico_tcp_initconn(struct pico_socket *s);\nstatic void initconn_retry(pico_time when, void *arg)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)arg;\n    IGNORE_PARAMETER(when);\n    if (TCPSTATE(&t->sock) != PICO_SOCKET_STATE_TCP_ESTABLISHED)\n    {\n        if (t->backoff > PICO_TCP_MAX_CONNECT_RETRIES) {\n            tcp_dbg(\"TCP> Connection timeout. \\n\");\n            if (t->sock.wakeup)\n            {\n                pico_err = PICO_ERR_ECONNREFUSED;\n                t->sock.wakeup(PICO_SOCK_EV_ERR, &t->sock);\n            }\n\n            pico_socket_del(&t->sock);\n            return;\n        }\n\n        tcp_dbg(\"TCP> SYN retry %d...\\n\", t->backoff);\n        t->backoff++;\n        pico_tcp_initconn(&t->sock);\n    } else {\n        tcp_dbg(\"TCP> Connection is already established: no retry needed. good.\\n\");\n    }\n}\n\nint pico_tcp_initconn(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *syn;\n    struct pico_tcp_hdr *hdr;\n    uint16_t mtu, opt_len = tcp_options_size(ts, PICO_TCP_SYN);\n\n    syn = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!syn)\n        return -1;\n\n    hdr = (struct pico_tcp_hdr *) syn->transport_hdr;\n\n    if (!ts->snd_nxt)\n        ts->snd_nxt = long_be(pico_paws());\n\n    ts->snd_last = ts->snd_nxt;\n    ts->cwnd = PICO_TCP_IW;\n    mtu = (uint16_t)pico_socket_get_mss(s);\n    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n        ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    else\n        ts->mss = PICO_TCP_MIN_MSS;\n    ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n    syn->sock = s;\n    hdr->seq = long_be(ts->snd_nxt);\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN;\n    tcp_set_space(ts);\n    hdr->rwnd = short_be(ts->wnd);\n    tcp_add_options(ts, syn, PICO_TCP_SYN, opt_len);\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(syn));\n\n    /* TCP: ENQUEUE to PROTO ( SYN ) */\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(ts->sock.local_port), short_be(ts->sock.remote_port), syn->buffer_len);\n    ts->retrans_tmr = pico_timer_add(s->stack, PICO_TCP_SYN_TO << ts->backoff, initconn_retry, ts);\n    if (!ts->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(syn);\n        return -1;\n    }\n    pico_enqueue(&s->stack->q_tcp.out, syn);\n    return 0;\n}\n\nstatic int tcp_send_synack(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *synack;\n    struct pico_tcp_hdr *hdr;\n    uint16_t opt_len = tcp_options_size(ts, PICO_TCP_SYN | PICO_TCP_ACK);\n\n    synack = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!synack)\n        return -1;\n\n    hdr = (struct pico_tcp_hdr *) synack->transport_hdr;\n\n    synack->sock = s;\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN | PICO_TCP_ACK;\n    hdr->rwnd = short_be(ts->wnd);\n    hdr->seq = long_be(ts->snd_nxt);\n    ts->rcv_processed = long_be(hdr->seq);\n    ts->snd_last = ts->snd_nxt;\n    tcp_set_space(ts);\n    tcp_add_options(ts, synack, hdr->flags, opt_len);\n    synack->payload_len = 0;\n    synack->timestamp = TCP_TIME;\n    tcp_send(ts, synack);\n    pico_frame_discard(synack);\n    return 0;\n}\n\nstatic void tcp_send_empty(struct pico_socket_tcp *t, uint16_t flags, int is_keepalive)\n{\n    struct pico_frame *f;\n    struct pico_tcp_hdr *hdr;\n    uint16_t opt_len = tcp_options_size(t, flags);\n    f = t->sock.net->alloc(t->sock.stack, t->sock.net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!f) {\n        return;\n    }\n\n    f->sock = &t->sock;\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = (uint8_t)flags;\n    hdr->rwnd = short_be(t->wnd);\n    tcp_set_space(t);\n    tcp_add_options(t, f, flags, opt_len);\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n    hdr->seq = long_be(t->snd_nxt);\n    if ((flags & PICO_TCP_ACK) != 0) {\n        hdr->ack = long_be(t->rcv_nxt);\n    }\n\n    if (is_keepalive)\n        hdr->seq = long_be(t->snd_nxt - 1);\n\n    t->rcv_ackd = t->rcv_nxt;\n\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n    hdr->rwnd = short_be(t->wnd);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n\n    /* TCP: ENQUEUE to PROTO */\n    pico_enqueue(&t->sock.stack->q_tcp.out, f);\n}\n\nstatic void tcp_send_ack(struct pico_socket_tcp *t)\n{\n    tcp_send_empty(t, PICO_TCP_ACK, 0);\n}\n\nstatic void tcp_send_probe(struct pico_socket_tcp *t)\n{\n    /* tcp_dbg(\"Sending probe\\n\"); */\n    tcp_send_empty(t, PICO_TCP_PSHACK, 1);\n}\n\nstatic int tcp_do_send_rst(struct pico_socket *s, uint32_t seq)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    uint16_t opt_len = tcp_options_size(t, PICO_TCP_RST);\n    struct pico_frame *f;\n    struct pico_tcp_hdr *hdr;\n    f = t->sock.net->alloc(s->stack, t->sock.net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!f) {\n        return -1;\n    }\n\n    f->sock = &t->sock;\n    tcp_dbg(\"TCP SEND_RST >>>>>>>>>>>>>>> START\\n\");\n\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_RST;\n    hdr->rwnd = short_be(t->wnd);\n    tcp_set_space(t);\n    tcp_add_options(t, f, PICO_TCP_RST, opt_len);\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n    hdr->seq = seq;\n    hdr->ack = long_be(t->rcv_nxt);\n    t->rcv_ackd = t->rcv_nxt;\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n    hdr->rwnd = short_be(t->wnd);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n\n    /* TCP: ENQUEUE to PROTO */\n    pico_enqueue(&t->sock.stack->q_tcp.out, f);\n    tcp_dbg(\"TCP SEND_RST >>>>>>>>>>>>>>> DONE\\n\");\n    return 0;\n}\n\nstatic int tcp_send_rst(struct pico_socket *s, struct pico_frame *fr)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    struct pico_tcp_hdr *hdr_rcv;\n    int ret;\n\n    if (fr && ((s->state & PICO_SOCKET_STATE_TCP) > PICO_SOCKET_STATE_TCP_SYN_RECV)) {\n        /* in synchronized state: send RST with seq = ack from previous segment */\n        hdr_rcv = (struct pico_tcp_hdr *) fr->transport_hdr;\n        ret = tcp_do_send_rst(s, hdr_rcv->ack);\n    } else {\n        /* non-synchronized state */\n        /* go to CLOSED here to prevent timer callback to go on after timeout */\n        (t->sock).state &= 0x00FFU;\n        (t->sock).state |= PICO_SOCKET_STATE_TCP_CLOSED;\n        ret = tcp_do_send_rst(s, long_be(t->snd_nxt));\n\n        /* Set generic socket state to CLOSED, too */\n        (t->sock).state &= 0xFF00U;\n        (t->sock).state |= PICO_SOCKET_STATE_CLOSED;\n\n        /* call EV_FIN wakeup before deleting */\n        if ((t->sock).wakeup)\n            (t->sock).wakeup(PICO_SOCK_EV_FIN, &(t->sock));\n\n        /* delete socket */\n        pico_socket_del(&t->sock);\n    }\n\n    return ret;\n}\n\nstatic inline void tcp_fill_rst_payload(struct pico_frame *fr, struct pico_frame *f)\n{\n    /* fill in IP data from original frame */\n    if (IS_IPV4(fr)) {\n        memcpy(f->net_hdr, fr->net_hdr, sizeof(struct pico_ipv4_hdr));\n        ((struct pico_ipv4_hdr *)(f->net_hdr))->dst.addr = ((struct pico_ipv4_hdr *)(fr->net_hdr))->src.addr;\n        ((struct pico_ipv4_hdr *)(f->net_hdr))->src.addr = ((struct pico_ipv4_hdr *)(fr->net_hdr))->dst.addr;\n        tcp_dbg(\"Making IPv4 reset frame...\\n\");\n\n    } else {\n        memcpy(f->net_hdr, fr->net_hdr, sizeof(struct pico_ipv6_hdr));\n        ((struct pico_ipv6_hdr *)(f->net_hdr))->dst = ((struct pico_ipv6_hdr *)(fr->net_hdr))->src;\n        ((struct pico_ipv6_hdr *)(f->net_hdr))->src = ((struct pico_ipv6_hdr *)(fr->net_hdr))->dst;\n    }\n\n    /* fill in TCP data from original frame */\n    ((struct pico_tcp_hdr *)(f->transport_hdr))->trans.dport = ((struct pico_tcp_hdr *)(fr->transport_hdr))->trans.sport;\n    ((struct pico_tcp_hdr *)(f->transport_hdr))->trans.sport = ((struct pico_tcp_hdr *)(fr->transport_hdr))->trans.dport;\n\n}\n\n\nstatic inline void tcp_fill_rst_header(struct pico_frame *fr, struct pico_tcp_hdr *hdr1, struct pico_frame *f, struct pico_tcp_hdr *hdr)\n{\n    if(!(hdr1->flags & PICO_TCP_ACK))\n        hdr->flags |= PICO_TCP_ACK;\n\n    hdr->rwnd  = 0;\n    if (((struct pico_tcp_hdr *)(fr->transport_hdr))->flags & PICO_TCP_ACK) {\n        hdr->seq = ((struct pico_tcp_hdr *)(fr->transport_hdr))->ack;\n    } else {\n        hdr->seq = 0U;\n    }\n\n    hdr->ack = 0;\n    if(!(hdr1->flags & PICO_TCP_ACK))\n        hdr->ack = long_be(long_be(((struct pico_tcp_hdr *)(fr->transport_hdr))->seq) + fr->payload_len);\n\n    hdr->crc = short_be(pico_tcp_checksum(f));\n}\n\nint pico_tcp_reply_rst(struct pico_stack *S, struct pico_frame *fr)\n{\n    struct pico_tcp_hdr *hdr, *hdr1;\n    struct pico_frame *f;\n    uint16_t size = PICO_SIZE_TCPHDR;\n\n\n    hdr1 = (struct pico_tcp_hdr *) (fr->transport_hdr);\n    if ((hdr1->flags & PICO_TCP_RST) != 0)\n        return -1;\n\n    tcp_dbg(\"TCP> sending RST ... \\n\");\n\n    f = fr->sock->net->alloc(fr->sock->stack, fr->sock->net, NULL, size);\n    if (!f) {\n        pico_err = PICO_ERR_ENOMEM;\n        return -1;\n    }\n\n    tcp_fill_rst_payload(fr, f);\n\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->len   = (uint8_t)(size << 2);\n    hdr->flags = PICO_TCP_RST;\n\n    tcp_fill_rst_header(fr, hdr1, f, hdr);\n\n    if (0) {\n#ifdef PICO_SUPPORT_IPV4\n    } else if (IS_IPV4(f)) {\n        tcp_dbg(\"Pushing IPv4 reset frame...\\n\");\n        pico_ipv4_frame_push(S, f, &(((struct pico_ipv4_hdr *)(f->net_hdr))->dst), PICO_PROTO_TCP);\n#endif\n#ifdef PICO_SUPPORT_IPV6\n    } else {\n        pico_ipv6_frame_push(S, f, NULL, &(((struct pico_ipv6_hdr *)(f->net_hdr))->dst), PICO_PROTO_TCP, 0);\n#endif\n    }\n\n\n    return 0;\n}\n\nstatic int tcp_nosync_rst(struct pico_socket *s, struct pico_frame *fr)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    struct pico_frame *f;\n    struct pico_tcp_hdr *hdr, *hdr_rcv;\n    uint16_t opt_len = tcp_options_size(t, PICO_TCP_RST | PICO_TCP_ACK);\n    hdr_rcv = (struct pico_tcp_hdr *) fr->transport_hdr;\n\n    tcp_dbg(\"TCP SEND RST (NON-SYNC) >>>>>>>>>>>>>>>>>> state %x\\n\", (s->state & PICO_SOCKET_STATE_TCP));\n    if (((s->state & PICO_SOCKET_STATE_TCP) ==  PICO_SOCKET_STATE_TCP_LISTEN)) {\n        if ((fr->flags & PICO_TCP_RST) != 0)\n            return 0;\n\n        return pico_tcp_reply_rst(s->stack, fr);\n    }\n\n    /***************************************************************************/\n    /* sending RST */\n    f = t->sock.net->alloc(t->sock.stack, t->sock.net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n\n    if (!f) {\n        return -1;\n    }\n\n\n    f->sock = &t->sock;\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_RST | PICO_TCP_ACK;\n    hdr->rwnd = short_be(t->wnd);\n    tcp_set_space(t);\n    tcp_add_options(t, f, PICO_TCP_RST | PICO_TCP_ACK, opt_len);\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n\n    /* non-synchronized state */\n    if (hdr_rcv->flags & PICO_TCP_ACK) {\n        hdr->seq = hdr_rcv->ack;\n    } else {\n        hdr->seq = 0U;\n    }\n\n    hdr->ack = long_be(SEQN(fr) + fr->payload_len);\n\n    t->rcv_ackd = t->rcv_nxt;\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n    hdr->rwnd = short_be(t->wnd);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n\n    /* TCP: ENQUEUE to PROTO */\n    pico_enqueue(&t->sock.stack->q_tcp.out, f);\n\n    /***************************************************************************/\n\n    tcp_dbg(\"TCP SEND_RST (NON_SYNC) >>>>>>>>>>>>>>> DONE, ...\\n\");\n\n    return 0;\n}\n\nstatic void tcp_deltcb(pico_time when, void *arg);\n\nstatic void tcp_linger(struct pico_socket_tcp *t)\n{\n    pico_timer_cancel(t->sock.stack, t->fin_tmr);\n    t->fin_tmr = pico_timer_add(t->sock.stack, t->linger_timeout, tcp_deltcb, t);\n    if (!t->fin_tmr) {\n        tcp_dbg(\"TCP: failed to start delete callback timer, deleting socket now\\n\");\n        tcp_deltcb((pico_time)0, t);\n    }\n}\n\nstatic void tcp_send_fin(struct pico_socket_tcp *t)\n{\n    struct pico_frame *f;\n    struct pico_tcp_hdr *hdr;\n    uint16_t opt_len = tcp_options_size(t, PICO_TCP_FIN);\n    f = t->sock.net->alloc(t->sock.stack, t->sock.net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!f) {\n        return;\n    }\n\n    f->sock = &t->sock;\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_FIN | PICO_TCP_ACK;\n    hdr->ack = long_be(t->rcv_nxt);\n    t->rcv_ackd = t->rcv_nxt;\n    hdr->rwnd = short_be(t->wnd);\n    tcp_set_space(t);\n    tcp_add_options(t, f, PICO_TCP_FIN, opt_len);\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n    hdr->seq = long_be(t->snd_nxt);\n\n    f->start = f->transport_hdr + PICO_SIZE_TCPHDR;\n    hdr->rwnd = short_be(t->wnd);\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(f));\n    /* tcp_dbg(\"SENDING FIN...\\n\"); */\n    if (t->linger_timeout > 0) {\n        pico_enqueue(&t->sock.stack->q_tcp.out, f);\n        t->snd_nxt++;\n    } else {\n        pico_frame_discard(f);\n    }\n\n    tcp_linger(t);\n}\n\nstatic void tcp_sack_prepare(struct pico_socket_tcp *t)\n{\n    struct tcp_input_segment *pkt;\n    uint32_t left = 0, right = 0;\n    struct tcp_sack_block *sb;\n    int n = 0;\n    if (t->sacks) /* previous sacks are pending */\n        return;\n\n    pkt = first_segment(&t->tcpq_in);\n    while(n < 3) {\n        if (!pkt) {\n            if(left) {\n                sb = PICO_ZALLOC(sizeof(struct tcp_sack_block));\n                if (!sb)\n                    break;\n\n                sb->left = long_be(left);\n                sb->right = long_be(right);\n                n++;\n                sb->next = t->sacks;\n                t->sacks = sb;\n                left = 0;\n                right = 0;\n            }\n\n            break;\n        }\n\n        if (pkt->seq < t->rcv_nxt) {\n            pkt = next_segment(&t->tcpq_in, pkt);\n            continue;\n        }\n\n        if (!left) {\n            left = pkt->seq;\n            right = pkt->seq + pkt->payload_len;\n            pkt = next_segment(&t->tcpq_in, pkt);\n            continue;\n        }\n\n        if(pkt->seq == right) {\n            right += pkt->payload_len;\n            pkt = next_segment(&t->tcpq_in, pkt);\n            continue;\n        } else {\n            sb = PICO_ZALLOC(sizeof(struct tcp_sack_block));\n            if (!sb)\n                break;\n\n            sb->left = long_be(left);\n            sb->right = long_be(right);\n            n++;\n            sb->next = t->sacks;\n            t->sacks = sb;\n            left = 0;\n            right = 0;\n            pkt = next_segment(&t->tcpq_in, pkt);\n        }\n    }\n}\n\nvoid pico_tcp_out_all(struct pico_stack *S, void *arg);\nstatic inline int tcp_data_in_expected(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct tcp_input_segment *nxt;\n    if (pico_seq_compare(SEQN(f), t->rcv_nxt) == 0) { /* Exactly what we expected */\n        /* Create new segment and enqueue it */\n        struct tcp_input_segment *input = segment_from_frame(f);\n        if (!input) {\n            pico_err = PICO_ERR_ENOMEM;\n            return -1;\n        }\n\n        if(pico_enqueue_segment(&t->tcpq_in, input) <= 0)\n        {\n            /* failed to enqueue, destroy segment */\n            PICO_FREE(input->payload);\n            PICO_FREE(input);\n            return -1;\n        } else {\n            t->rcv_nxt = SEQN(f) + f->payload_len;\n            nxt = peek_segment(&t->tcpq_in, t->rcv_nxt);\n            while(nxt) {\n                tcp_dbg(\"scrolling rcv_nxt...%08x\\n\", t->rcv_nxt);\n                t->rcv_nxt += nxt->payload_len;\n                nxt = peek_segment(&t->tcpq_in, t->rcv_nxt);\n            }\n            t->sock.ev_pending |= PICO_SOCK_EV_RD;\n            pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n        }\n    } else {\n        tcp_dbg(\"TCP> lo segment. Uninteresting retransmission. (exp: %x got: %x)\\n\", t->rcv_nxt, SEQN(f));\n    }\n\n    return 0;\n}\n\nstatic inline int tcp_data_in_high_segment(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    tcp_dbg(\"TCP> hi segment. Possible packet loss. I'll dupack this. (exp: %x got: %x)\\n\", t->rcv_nxt, SEQN(f));\n    if (t->sack_ok) {\n        struct tcp_input_segment *input = segment_from_frame(f);\n        if (!input) {\n            pico_err = PICO_ERR_ENOMEM;\n            return -1;\n        }\n\n        if(pico_enqueue_segment(&t->tcpq_in, input) <= 0) {\n            /* failed to enqueue, destroy segment */\n            PICO_FREE(input->payload);\n            PICO_FREE(input);\n            return -1;\n        }\n\n        tcp_sack_prepare(t);\n    }\n\n    return 0;\n}\n\nstatic inline void tcp_data_in_send_ack(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    /* In either case, ack til recv_nxt, unless received data raises a RST flag. */\n    if (((t->sock.state & PICO_SOCKET_STATE_TCP) != PICO_SOCKET_STATE_TCP_CLOSE_WAIT) &&\n        ((t->sock.state & PICO_SOCKET_STATE_TCP) != PICO_SOCKET_STATE_TCP_SYN_SENT) &&\n        ((t->sock.state & PICO_SOCKET_STATE_TCP) != PICO_SOCKET_STATE_TCP_SYN_RECV) &&\n        ((hdr->flags & PICO_TCP_RST) == 0))\n        tcp_send_ack(t);\n}\n\nstatic int tcp_data_in(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n    uint16_t payload_len = (uint16_t)(f->transport_len - ((hdr->len & 0xf0u) >> 2u));\n    int ret = 0;\n    (void)hdr;\n\n    if (((hdr->len & 0xf0u) >> 2u) <= f->transport_len) {\n        if (tcp_parse_options(f) < 0)\n            return -1;\n        f->payload = f->transport_hdr + ((hdr->len & 0xf0u) >> 2u);\n        f->payload_len = payload_len;\n        tcp_dbg(\"TCP> Received segment. (exp: %x got: %x)\\n\", t->rcv_nxt, SEQN(f));\n\n        if (pico_seq_compare(SEQN(f), t->rcv_nxt) <= 0) {\n            ret = tcp_data_in_expected(t, f);\n        } else {\n            ret = tcp_data_in_high_segment(t, f);\n        }\n\n        tcp_data_in_send_ack(t, f);\n        return ret;\n    } else {\n        tcp_dbg(\"TCP: invalid data in pkt len, exp: %d, got %d\\n\", (hdr->len & 0xf0) >> 2, f->transport_len);\n        return -1;\n    }\n}\n\nstatic int tcp_ack_advance_una(struct pico_socket_tcp *t, struct pico_frame *f, pico_time *timestamp)\n{\n    int ret =  release_all_until(&t->tcpq_out, ACKN(f), timestamp);\n    if (ret > 0) {\n        t->sock.ev_pending |= PICO_SOCK_EV_WR;\n    }\n    pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n\n    return ret;\n}\n\nstatic uint16_t time_diff(pico_time a, pico_time b)\n{\n    if (a >= b)\n        return (uint16_t)(a - b);\n    else\n        return (uint16_t)(b - a);\n}\n\nstatic void tcp_rtt(struct pico_socket_tcp *t, uint32_t rtt)\n{\n\n    uint32_t avg = t->avg_rtt;\n    uint32_t rvar = t->rttvar;\n    if (!avg) {\n        /* This follows RFC2988\n         * (2.2) When the first RTT measurement R is made, the host MUST set\n         *\n         * SRTT <- R\n         * RTTVAR <- R/2\n         * RTO <- SRTT + max (G, K*RTTVAR)\n         */\n        t->avg_rtt = rtt;\n        t->rttvar = rtt >> 1;\n        rto_set(t, t->avg_rtt + (t->rttvar << 2));\n    } else {\n        int32_t var = (int32_t)t->avg_rtt - (int32_t)rtt;\n        if (var < 0)\n            var = 0 - var;\n\n        /* RFC2988, section (2.3). Alpha and beta are the ones suggested. */\n\n        /* First, evaluate a new value for the rttvar */\n        t->rttvar <<= 2;\n        t->rttvar -= rvar;\n        t->rttvar += (uint32_t)var;\n        t->rttvar >>= 2;\n\n        /* Then, calculate the new avg_rtt */\n        t->avg_rtt <<= 3;\n        t->avg_rtt -= avg;\n        t->avg_rtt += rtt;\n        t->avg_rtt >>= 3;\n\n        /* Finally, assign a new value for the RTO, as specified in the RFC, with K=4 */\n        rto_set(t, t->avg_rtt + (t->rttvar << 2));\n    }\n\n    tcp_dbg(\" -----=============== RTT CUR: %u AVG: %u RTTVAR: %u RTO: %u ======================----\\n\", rtt, t->avg_rtt, t->rttvar, t->rto);\n}\n\nstatic void tcp_congestion_control(struct pico_socket_tcp *t)\n{\n    if (t->x_mode > PICO_TCP_LOOKAHEAD)\n        return;\n\n    tcp_dbg(\"Doing congestion control\\n\");\n    if (t->cwnd < t->ssthresh) {\n        t->cwnd++;\n    } else {\n        t->cwnd_counter++;\n        if (t->cwnd_counter >= t->cwnd) {\n            t->cwnd++;\n            t->cwnd_counter = 0;\n        }\n    }\n\n    tcp_dbg(\"TCP_CWND, %lu, %u, %u, %u\\n\", TCP_TIME, t->cwnd, t->ssthresh, t->in_flight);\n}\n\nstatic void add_retransmission_timer(struct pico_socket_tcp *t, pico_time next_ts);\n\n\n/* Retransmission time out (RTO). */\n\nstatic void tcp_first_timeout(struct pico_socket_tcp *t)\n{\n    t->x_mode = PICO_TCP_BLACKOUT;\n    t->cwnd = PICO_TCP_IW;\n    t->in_flight = 0;\n}\n\nstatic int tcp_rto_xmit(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct pico_frame *cpy;\n    /* TCP: ENQUEUE to PROTO ( retransmit )*/\n    cpy = pico_frame_copy(f);\n    if (!cpy) {\n        add_retransmission_timer(t, (t->rto << t->backoff) + TCP_TIME);\n        return -1;\n    }\n\n    if (pico_enqueue(&t->sock.stack->q_tcp.out, cpy) > 0) {\n        t->snd_last_out = SEQN(cpy);\n        add_retransmission_timer(t, (t->rto << (++t->backoff)) + TCP_TIME);\n        tcp_dbg(\"TCP_CWND, %lu, %u, %u, %u\\n\", TCP_TIME, t->cwnd, t->ssthresh, t->in_flight);\n        tcp_dbg(\"Sending RTO!\\n\");\n        return 1;\n    } else {\n        tcp_dbg(\"RTO fail, retry!\\n\");\n        add_retransmission_timer(t, (t->rto << t->backoff) + TCP_TIME);\n        pico_frame_discard(cpy);\n        return 0;\n    }\n}\n\nstatic void tcp_next_zerowindow_probe(struct pico_socket_tcp *t)\n{\n    tcp_dbg(\"Sending probe!\\n\");\n    tcp_send_probe(t);\n    add_retransmission_timer(t, (t->rto << ++t->backoff) + TCP_TIME);\n}\n\nstatic int tcp_is_allowed_to_send(struct pico_socket_tcp *t)\n{\n    return t->sock.net &&\n           (\n               ((t->sock.state & 0xFF00) == PICO_SOCKET_STATE_TCP_ESTABLISHED) ||\n               ((t->sock.state & 0xFF00) == PICO_SOCKET_STATE_TCP_CLOSE_WAIT)\n           ) &&\n           ((t->backoff < PICO_TCP_MAX_RETRANS));\n}\n\nstatic inline int tcp_retrans_timeout_check_queue(struct pico_socket_tcp *t)\n{\n    struct pico_frame *f = NULL;\n    f = first_segment(&t->tcpq_out);\n    while (f) {\n        tcp_dbg(\"Checking frame in queue \\n\");\n        if (t->x_mode == PICO_TCP_WINDOW_FULL) {\n            tcp_dbg(\"TCP BLACKOUT> TIMED OUT (output) frame %08x, len= %d rto=%d Win full: %d frame flags: %04x\\n\", SEQN(f), f->payload_len, t->rto, t->x_mode == PICO_TCP_WINDOW_FULL, f->flags);\n            tcp_next_zerowindow_probe(t);\n            return -1;\n        }\n\n        if (t->x_mode != PICO_TCP_BLACKOUT)\n            tcp_first_timeout(t);\n\n        tcp_add_header(t, f);\n        if (tcp_rto_xmit(t, f) > 0) /* A segment has been rexmit'd */\n            return -1;\n\n        f = next_segment(&t->tcpq_out, f);\n    }\n    if (t->tcpq_out.size < t->tcpq_out.max_size)\n        t->sock.ev_pending |= PICO_SOCK_EV_WR;\n    pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n\n    return 0;\n\n\n\n}\n\nstatic void tcp_retrans_timeout(pico_time val, void *sock)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) sock;\n\n    t->retrans_tmr = 0;\n\n    if (t->retrans_tmr_due == 0ull) {\n        return;\n    }\n\n    if (t->retrans_tmr_due > val) {\n        /* Timer was postponed... */\n        add_retransmission_timer(t, t->retrans_tmr_due);\n        return;\n    }\n\n    pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n\n    tcp_dbg(\"TIMEOUT! backoff = %d, rto: %d\\n\", t->backoff, t->rto);\n    t->retrans_tmr_due = 0ull;\n\n    if (tcp_is_allowed_to_send(t)) {\n        if (tcp_retrans_timeout_check_queue(t) < 0)\n            return;\n    }\n    else if(t->backoff >= PICO_TCP_MAX_RETRANS &&\n            ((t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_FIN_WAIT1 ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_FIN_WAIT2 ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_TIME_WAIT ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_CLOSE_WAIT ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_LAST_ACK ||\n             (t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_CLOSING))\n    {\n        tcp_dbg(\"Connection timeout!\\n\");\n        /* the retransmission timer, failed to get an ack for a frame, gives up on the connection */\n        tcp_discard_all_segments(&t->tcpq_out);\n        if(t->sock.wakeup)\n            t->sock.wakeup(PICO_SOCK_EV_FIN, &t->sock);\n\n        /* delete socket */\n        pico_socket_del(&t->sock);\n        return;\n    } else {\n        tcp_dbg(\"Retransmission not allowed, rescheduling\\n\");\n    }\n}\n\nstatic void add_retransmission_timer(struct pico_socket_tcp *t, pico_time next_ts)\n{\n    struct pico_tree_node *index;\n    pico_time now = TCP_TIME;\n    pico_time val = 0;\n\n\n    if (next_ts == 0) {\n        struct pico_frame *f;\n\n        pico_tree_foreach(index, &t->tcpq_out.pool){\n            f = index->keyValue;\n            if ((next_ts == 0) || ((f->timestamp < next_ts) && (f->timestamp > 0))) {\n                next_ts = f->timestamp;\n                val = next_ts + (t->rto << t->backoff);\n            }\n        }\n    } else {\n        val = next_ts;\n    }\n\n    if ((val > 0) || (val > now)) {\n        t->retrans_tmr_due = val;\n    } else {\n        t->retrans_tmr_due = now + 1;\n    }\n\n    if (!t->retrans_tmr) {\n        t->retrans_tmr = pico_timer_add(t->sock.stack, t->retrans_tmr_due - now, tcp_retrans_timeout, t);\n        if(!t->retrans_tmr) {\n            tcp_dbg(\"TCP: Failed to start retransmission timer\\n\");\n            //TODO do something about this?\n        } else {\n            tcp_dbg(\"Next timeout in %u msec\\n\", (uint32_t) (t->retrans_tmr_due - now));\n        }\n    }\n}\n\nstatic int tcp_retrans(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct pico_frame *cpy;\n    if (f) {\n        tcp_dbg(\"TCP> RETRANS (by dupack) frame %08x, len= %d\\n\", SEQN(f), f->payload_len);\n        tcp_add_header(t, f);\n        /* TCP: ENQUEUE to PROTO ( retransmit )*/\n        cpy = pico_frame_copy(f);\n        if (!cpy) {\n            return -1;\n        }\n\n        if (pico_enqueue(&t->sock.stack->q_tcp.out, cpy) > 0) {\n            t->in_flight++;\n            t->snd_last_out = SEQN(cpy);\n        } else {\n            pico_frame_discard(cpy);\n        }\n\n        add_retransmission_timer(t, TCP_TIME + t->rto);\n        return(f->payload_len);\n    }\n\n    return 0;\n}\n\n#ifdef TCP_ACK_DBG\nstatic void tcp_ack_dbg(struct pico_socket *s, struct pico_frame *f)\n{\n    uint32_t una, nxt, ack, cur;\n    struct pico_frame *una_f = NULL, *cur_f;\n    struct pico_tree_node *idx;\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    char info[64];\n    char tmp[64];\n    ack = ACKN(f);\n    nxt = t->snd_nxt;\n    tcp_dbg(\"===================================\\n\");\n    tcp_dbg(\"Queue out (%d/%d). ACKED=%08x\\n\", t->tcpq_out.size, t->tcpq_out.max_size, ack);\n\n    pico_tree_foreach(idx, &t->tcpq_out.pool) {\n        info[0] = 0;\n        cur_f = idx->keyValue;\n        cur = SEQN(cur_f);\n        if (!una_f) {\n            una_f = cur_f;\n            una = SEQN(una_f);\n        }\n\n        if (cur == nxt) {\n            strncpy(tmp, info, strlen(info));\n            snprintf(info, 64, \"%s SND_NXT\", tmp);\n        }\n\n        if (cur == ack) {\n            strncpy(tmp, info, strlen(info));\n            snprintf(info, 64, \"%s ACK\", tmp);\n        }\n\n        if (cur == una) {\n            strncpy(tmp, info, strlen(info));\n            snprintf(info, 64, \"%s SND_UNA\", tmp);\n        }\n\n        if (cur == t->snd_last) {\n            strncpy(tmp, info, strlen(info));\n            snprintf(info, 64, \"%s SND_LAST\", tmp);\n        }\n\n        tcp_dbg(\"%08x %d%s\\n\", cur, cur_f->payload_len, info);\n\n    }\n    tcp_dbg(\"SND_NXT is %08x, snd_LAST is %08x\\n\", nxt, t->snd_last);\n    tcp_dbg(\"===================================\\n\");\n    tcp_dbg(\"\\n\\n\");\n}\n#endif\n\nstatic int tcp_ack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_frame *f_new;              /* use with Nagle to push to out queue */\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr;\n    uint32_t rtt = 0;\n    uint16_t acked = 0;\n    pico_time acked_timestamp = 0;\n    struct pico_frame *una = NULL;\n\n    if (!f || !s) {\n        pico_err = PICO_ERR_EINVAL;\n        return -1;\n    }\n\n    hdr = (struct pico_tcp_hdr *) f->transport_hdr;\n\n    if ((hdr->flags & PICO_TCP_ACK) == 0)\n        return -1;\n\n#ifdef TCP_ACK_DBG\n    tcp_ack_dbg(s, f);\n#endif\n\n    if (tcp_parse_options(f) < 0)\n        return -1;\n    t->recv_wnd = short_be(hdr->rwnd);\n\n    acked = (uint16_t)tcp_ack_advance_una(t, f, &acked_timestamp);\n    una = first_segment(&t->tcpq_out);\n    t->ack_timestamp = TCP_TIME;\n\n    if ((t->x_mode == PICO_TCP_BLACKOUT) ||\n        ((t->x_mode == PICO_TCP_WINDOW_FULL) && ((t->recv_wnd << t->recv_wnd_scale) > t->mss))) {\n        int prev_mode = t->x_mode;\n        tcp_dbg(\"Re-entering look-ahead...\\n\\n\\n\");\n        t->x_mode = PICO_TCP_LOOKAHEAD;\n        t->backoff = 0;\n\n        if((prev_mode == PICO_TCP_BLACKOUT) && (acked > 0) && una)\n        {\n            t->snd_nxt = SEQN(una);\n            /* restart the retrans timer */\n            if (t->retrans_tmr) {\n                t->retrans_tmr_due = 0ull;\n            }\n        }\n    }\n\n    /* One should be acked. */\n    if ((acked == 0) && (f->payload_len  == 0) && (t->in_flight > 0))\n        t->in_flight--;\n\n    if (!una || acked > 0) {\n        t->x_mode = PICO_TCP_LOOKAHEAD;\n        tcp_dbg(\"Mode: Look-ahead. In flight: %d/%d buf: %d\\n\", t->in_flight, t->cwnd, t->tcpq_out.frames);\n        t->backoff = 0;\n\n        /* Do rtt/rttvar/rto calculations */\n        /* First, try with timestamps, using the value from options */\n        if(f->timestamp != 0) {\n            rtt = time_diff(TCP_TIME, f->timestamp);\n            if (rtt)\n                tcp_rtt(t, rtt);\n        } else if(acked_timestamp) {\n            /* If no timestamps are there, use conservative estimation on the una */\n            rtt = time_diff(TCP_TIME, acked_timestamp);\n            if (rtt)\n                tcp_rtt(t, rtt);\n        }\n\n        tcp_dbg(\"TCP ACK> FRESH ACK %08x (acked %d) Queue size: %u/%u frames: %u cwnd: %u in_flight: %u snd_una: %u\\n\", ACKN(f), acked, t->tcpq_out.size, t->tcpq_out.max_size, t->tcpq_out.frames, t->cwnd, t->in_flight, SEQN(una));\n        if (acked > t->in_flight) {\n            tcp_dbg(\"WARNING: in flight < 0\\n\");\n            t->in_flight = 0;\n        } else\n            t->in_flight -= (acked);\n\n    } else if ((t->snd_old_ack == ACKN(f)) &&              /* We've just seen this ack, and... */\n               ((0 == (hdr->flags & (PICO_TCP_PSH | PICO_TCP_SYN))) &&\n                (f->payload_len == 0)) &&              /* This is a pure ack, and... */\n               (ACKN(f) != t->snd_nxt))              /* There is something in flight awaiting to be acked... */\n    {\n        /* Process incoming duplicate ack. */\n        if (t->x_mode < PICO_TCP_RECOVER) {\n            t->x_mode++;\n            tcp_dbg(\"Mode: DUPACK %d, due to PURE ACK %0x, len = %d\\n\", t->x_mode, SEQN(f), f->payload_len);\n            /* tcp_dbg(\"ACK: %x - QUEUE: %x\\n\", ACKN(f), SEQN(first_segment(&t->tcpq_out))); */\n            if (t->x_mode == PICO_TCP_RECOVER) {              /* Switching mode */\n                if (t->in_flight > PICO_TCP_IW)\n                    t->cwnd = (uint16_t)t->in_flight;\n                else\n                    t->cwnd = PICO_TCP_IW;\n\n                t->snd_retry = SEQN((struct pico_frame *)first_segment(&t->tcpq_out));\n                if (t->ssthresh > t->cwnd)\n                    t->ssthresh >>= 2;\n                else\n                    t->ssthresh = (t->cwnd >> 1);\n\n                if (t->ssthresh < 2)\n                    t->ssthresh = 2;\n            }\n        } else if (t->x_mode == PICO_TCP_RECOVER) {\n            /* tcp_dbg(\"TCP RECOVER> DUPACK! snd_una: %08x, snd_nxt: %08x, acked now: %08x\\n\", SEQN(first_segment(&t->tcpq_out)), t->snd_nxt, ACKN(f)); */\n            if (t->in_flight <= t->cwnd) {\n                struct pico_frame *nxt = peek_segment(&t->tcpq_out, t->snd_retry);\n                if (!nxt)\n                    nxt = first_segment(&t->tcpq_out);\n\n                while (nxt && (nxt->flags & PICO_FRAME_FLAG_SACKED) && (nxt != first_segment(&t->tcpq_out))) {\n                    tcp_dbg(\"Skipping %08x because it is sacked.\\n\", SEQN(nxt));\n                    nxt = next_segment(&t->tcpq_out, nxt);\n                }\n                if (nxt && (pico_seq_compare(SEQN(nxt), t->snd_nxt)) > 0)\n                    nxt = NULL;\n\n                if (nxt && (pico_seq_compare(SEQN(nxt), SEQN((struct pico_frame *)first_segment(&t->tcpq_out))) > (int)(t->recv_wnd << t->recv_wnd_scale)))\n                    nxt = NULL;\n\n                if(!nxt)\n                    nxt = first_segment(&t->tcpq_out);\n\n                if (nxt) {\n                    tcp_retrans(t, peek_segment(&t->tcpq_out, t->snd_retry));\n                    t->snd_retry = SEQN(nxt);\n                }\n            }\n\n            if (++t->cwnd_counter > 1) {\n                t->cwnd--;\n                if (t->cwnd < 2)\n                    t->cwnd = 2;\n\n                t->cwnd_counter = 0;\n            }\n        } else {\n            tcp_dbg(\"DUPACK in mode %d \\n\", t->x_mode);\n\n        }\n    }              /* End case duplicate ack detection */\n\n    /* Linux very special zero-window probe detection (see bug #107) */\n    if ((0 == (hdr->flags & (PICO_TCP_PSH | PICO_TCP_SYN))) && /* This is a pure ack, and... */\n        (ACKN(f) == t->snd_nxt) &&                           /* it's acking our snd_nxt, and... */\n        (pico_seq_compare(SEQN(f), t->rcv_nxt) < 0))             /* Has an old seq number */\n    {\n        tcp_send_ack(t);\n    }\n\n\n    /* Do congestion control */\n    tcp_congestion_control(t);\n    if ((acked > 0) && t->sock.wakeup) {\n        if (t->tcpq_out.size < t->tcpq_out.max_size)\n            t->sock.wakeup(PICO_SOCK_EV_WR, &(t->sock));\n\n        /* t->sock.ev_pending |= PICO_SOCK_EV_WR; */\n        pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n    }\n\n    /* if Nagle enabled, check if no unack'ed data and fill out queue (till window) */\n    if (IS_NAGLE_ENABLED((&(t->sock)))) {\n        while (!IS_TCP_HOLDQ_EMPTY(t) && ((t->tcpq_out.max_size - t->tcpq_out.size) >= t->mss)) {\n            tcp_dbg_nagle(\"TCP_ACK - NAGLE add new segment\\n\");\n            f_new = pico_hold_segment_make(t);\n            if (f_new == NULL)\n                break;              /* XXX corrupt !!! (or no memory) */\n\n            if (pico_enqueue_segment(&t->tcpq_out, f_new) <= 0)\n                /* handle error */\n                tcp_dbg_nagle(\"TCP_ACK - NAGLE FAILED to enqueue in out\\n\");\n        }\n    }\n\n    /* If some space was created, put a few segments out. */\n    tcp_dbg(\"TCP_CWND, %lu, %u, %u, %u\\n\", TCP_TIME, t->cwnd, t->ssthresh, t->in_flight);\n    if (t->x_mode ==  PICO_TCP_LOOKAHEAD) {\n        if ((t->cwnd >= t->in_flight) && (t->snd_nxt > t->snd_last_out)) {\n            pico_tcp_output(&t->sock, (int)t->cwnd - (int)t->in_flight);\n        }\n    }\n\n    add_retransmission_timer(t, 0);\n    t->snd_old_ack = ACKN(f);\n    return 0;\n}\n\nstatic int tcp_finwaitack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    tcp_dbg(\"RECEIVED ACK IN FIN_WAIT1\\n\");\n\n    /* acking part */\n    tcp_ack(s, f);\n\n\n    tcp_dbg(\"FIN_WAIT1: ack is %08x - snd_nxt is %08x\\n\", ACKN(f), t->snd_nxt);\n    if (ACKN(f) == (t->snd_nxt - 1u)) {\n        /* update TCP state */\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_FIN_WAIT2;\n        tcp_dbg(\"TCP> IN STATE FIN_WAIT2\\n\");\n    }\n\n    return 0;\n}\n\nstatic void tcp_deltcb(pico_time when, void *arg)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)arg;\n    IGNORE_PARAMETER(when);\n\n    /* send RST if not yet in TIME_WAIT */\n    if ((((t->sock).state & PICO_SOCKET_STATE_TCP) != PICO_SOCKET_STATE_TCP_TIME_WAIT)\n        && (((t->sock).state & PICO_SOCKET_STATE_TCP) != PICO_SOCKET_STATE_TCP_CLOSING)) {\n        tcp_dbg(\"Called deltcb in state = %04x (sending reset!)\\n\", (t->sock).state);\n        tcp_do_send_rst(&t->sock, long_be(t->snd_nxt));\n    } else {\n        tcp_dbg(\"Called deltcb in state = %04x\\n\", (t->sock).state);\n    }\n\n    /* update state */\n    (t->sock).state &= 0x00FFU;\n    (t->sock).state |= PICO_SOCKET_STATE_TCP_CLOSED;\n    (t->sock).state &= 0xFF00U;\n    (t->sock).state |= PICO_SOCKET_STATE_CLOSED;\n    /* call EV_FIN wakeup before deleting */\n    if (t->sock.wakeup) {\n        (t->sock).wakeup(PICO_SOCK_EV_FIN, &(t->sock));\n    }\n\n    /* delete socket */\n    pico_socket_del(&t->sock);\n}\n\nstatic int tcp_finwaitfin(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr  = (struct pico_tcp_hdr *) (f->transport_hdr);\n    tcp_dbg(\"TCP> received fin in FIN_WAIT2\\n\");\n    /* received FIN, increase ACK nr */\n    t->rcv_nxt = long_be(hdr->seq) + 1;\n    s->state &= 0x00FFU;\n    s->state |= PICO_SOCKET_STATE_TCP_TIME_WAIT;\n    /* set SHUT_REMOTE */\n    s->state |= PICO_SOCKET_STATE_SHUT_REMOTE;\n    if (s->wakeup)\n        s->wakeup(PICO_SOCK_EV_CLOSE, s);\n\n    if (f->payload_len > 0)              /* needed?? */\n        tcp_data_in(s, f);\n\n    /* send ACK */\n    tcp_send_ack(t);\n    /* linger */\n    tcp_linger(t);\n    return 0;\n}\n\nstatic int tcp_closing_ack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    tcp_dbg(\"TCP> received ack in CLOSING\\n\");\n    /* acking part */\n    tcp_ack(s, f);\n\n    /* update TCP state DLA TODO: Only if FIN is acked! */\n    tcp_dbg(\"CLOSING: ack is %08x - snd_nxt is %08x\\n\", ACKN(f), t->snd_nxt);\n    if (ACKN(f) == t->snd_nxt) {\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_TIME_WAIT;\n        /* set timer */\n        tcp_linger(t);\n    }\n\n    return 0;\n}\n\nstatic int tcp_lastackwait(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    tcp_dbg(\"LAST_ACK: ack is %08x - snd_nxt is %08x\\n\", ACKN(f), t->snd_nxt);\n    if (ACKN(f) == t->snd_nxt) {\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_CLOSED;\n        s->state &= 0xFF00U;\n        s->state |= PICO_SOCKET_STATE_CLOSED;\n        /* call socket wakeup with EV_FIN */\n        if (s->wakeup)\n            s->wakeup(PICO_SOCK_EV_FIN, s);\n\n        /* delete socket */\n        pico_socket_del(s);\n    }\n\n    return 0;\n}\n\nstatic int tcp_syn(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *new = NULL;\n    struct pico_tcp_hdr *hdr = NULL;\n    uint16_t mtu;\n    if(s->number_of_pending_conn >= s->max_backlog)\n        return -1;\n\n    new = (struct pico_socket_tcp *)pico_socket_clone(s);\n    hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    if (!new)\n        return -1;\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, s)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        return -1;\n    }\n#endif\n\n    new->sock.remote_port = ((struct pico_trans *)f->transport_hdr)->sport;\n#ifdef PICO_SUPPORT_IPV4\n    if (IS_IPV4(f)) {\n        new->sock.remote_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->src.addr;\n        new->sock.local_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->dst.addr;\n    }\n\n#endif\n#ifdef PICO_SUPPORT_IPV6\n    if (IS_IPV6(f)) {\n        new->sock.remote_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->src;\n        new->sock.local_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->dst;\n    }\n\n#endif\n    f->sock = &new->sock;\n    mtu = (uint16_t)pico_socket_get_mss(&new->sock);\n    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n        new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    else\n        new->mss = PICO_TCP_MIN_MSS;\n    if (tcp_parse_options(f) < 0)\n        return -1;\n    new->sock.stack = s->stack;\n    new->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_hold.max_size = 2u * mtu;\n    new->rcv_nxt = long_be(hdr->seq) + 1;\n    new->snd_nxt = long_be(pico_paws());\n    new->snd_last = new->snd_nxt;\n    new->cwnd = PICO_TCP_IW;\n    new->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss)) >> 3u));\n    new->recv_wnd = short_be(hdr->rwnd);\n    new->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n    s->number_of_pending_conn++;\n    new->sock.parent = s;\n    new->sock.wakeup = s->wakeup;\n    rto_set(new, PICO_TCP_RTO_MIN);\n    /* Initialize timestamp values */\n    new->sock.state = PICO_SOCKET_STATE_BOUND | PICO_SOCKET_STATE_CONNECTED | PICO_SOCKET_STATE_TCP_SYN_RECV;\n    pico_socket_add(&new->sock);\n    tcp_send_synack(&new->sock);\n    tcp_dbg(\"SYNACK sent, socket added. snd_nxt is %08x\\n\", new->snd_nxt);\n    return 0;\n}\n\nstatic int tcp_synrecv_syn(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = NULL;\n    struct pico_socket_tcp *t = TCP_SOCK(s);\n    hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    if (t->rcv_nxt == long_be(hdr->seq) + 1u) {\n        /* take back our own SEQ number to its original value,\n         * so the synack retransmitted is identical to the original.\n         */\n        t->snd_nxt--;\n        tcp_send_synack(s);\n    } else {\n        tcp_send_rst(s, f);\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void tcp_set_init_point(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->rcv_processed = t->rcv_nxt;\n}\n\n\nuint16_t pico_tcp_get_socket_mss(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    if (t->mss > 0)\n        return (uint16_t)(t->mss + PICO_SIZE_TCPHDR);\n    else\n        return (uint16_t)pico_socket_get_mss(s);\n}\n\nstatic int tcp_synack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    struct pico_tcp_hdr *hdr  = (struct pico_tcp_hdr *)f->transport_hdr;\n\n    if (ACKN(f) ==  (1u + t->snd_nxt)) {\n        /* Get rid of initconn retry */\n        pico_timer_cancel(t->sock.stack, t->retrans_tmr);\n        t->retrans_tmr = 0;\n\n        t->rcv_nxt = long_be(hdr->seq);\n        t->rcv_processed = t->rcv_nxt + 1;\n        tcp_ack(s, f);\n\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_ESTABLISHED;\n        tcp_dbg(\"TCP> Established. State: %x\\n\", s->state);\n\n        if (s->wakeup)\n            s->wakeup(PICO_SOCK_EV_CONN, s);\n\n        s->ev_pending |= PICO_SOCK_EV_WR;\n        pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n\n        t->rcv_nxt++;\n        t->snd_nxt++;\n        tcp_send_ack(t);              /* return ACK */\n\n        return 0;\n\n    } else if ((hdr->flags & PICO_TCP_RST) == 0) {\n        tcp_dbg(\"TCP> Not established, RST sent.\\n\");\n        tcp_nosync_rst(s, f);\n        return 0;\n    } else {\n        /* The segment has the reset flag on: Ignore! */\n        return 0;\n    }\n}\n\nstatic int tcp_first_ack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr  = (struct pico_tcp_hdr *)f->transport_hdr;\n    tcp_dbg(\"ACK in SYN_RECV: expecting %08x got %08x\\n\", t->snd_nxt, ACKN(f));\n    if (t->snd_nxt == ACKN(f)) {\n        tcp_set_init_point(s);\n        tcp_ack(s, f);\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_ESTABLISHED;\n        tcp_dbg(\"TCP: Established. State now: %04x\\n\", s->state);\n        if( !s->parent && s->wakeup) {              /* If the socket has no parent, -> sending socket that has a sim_open */\n            tcp_dbg(\"FIRST ACK - No parent found -> sending socket\\n\");\n            s->wakeup(PICO_SOCK_EV_CONN,  s);\n        }\n\n        if (s->parent && s->parent->wakeup) {\n            tcp_dbg(\"FIRST ACK - Parent found -> listening socket\\n\");\n            s->wakeup = s->parent->wakeup;\n            s->parent->wakeup(PICO_SOCK_EV_CONN, s->parent);\n        }\n\n        s->ev_pending |= PICO_SOCK_EV_WR;\n        pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n        tcp_dbg(\"%s: snd_nxt is now %08x\\n\", __FUNCTION__, t->snd_nxt);\n        return 0;\n    } else if ((hdr->flags & PICO_TCP_RST) == 0) {\n        tcp_nosync_rst(s, f);\n        return 0;\n    } else {\n        /* The segment has the reset flag on: Ignore! */\n        return 0;\n    }\n}\n\nstatic void tcp_attempt_closewait(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr  = (struct pico_tcp_hdr *) (f->transport_hdr);\n    if (pico_seq_compare(SEQN(f), t->rcv_nxt) == 0) {\n        /* received FIN, increase ACK nr */\n        t->rcv_nxt = long_be(hdr->seq) + 1;\n        if (pico_seq_compare(SEQN(f), t->rcv_processed) == 0) {\n            if ((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED) {\n                tcp_dbg(\"Changing state to CLOSE_WAIT\\n\");\n                s->state &= 0x00FFU;\n                s->state |= PICO_SOCKET_STATE_TCP_CLOSE_WAIT;\n            }\n\n            /* set SHUT_REMOTE */\n            s->state |= PICO_SOCKET_STATE_SHUT_REMOTE;\n            tcp_dbg(\"TCP> Close-wait\\n\");\n            if (s->wakeup) {\n                s->wakeup(PICO_SOCK_EV_CLOSE, s);\n            }\n        } else {\n            t->remote_closed = 1;\n        }\n    }\n\n\n}\n\nstatic int tcp_closewait(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) (f->transport_hdr);\n\n    if (f->payload_len > 0)\n        tcp_data_in(s, f);\n\n    if (hdr->flags & PICO_TCP_ACK)\n        tcp_ack(s, f);\n\n    tcp_dbg(\"called close_wait (%p), in state %08x, f->flags: 0x%02x, hdr->flags: 0x%02x\\n\", tcp_closewait, s->state, f->flags, hdr->flags);\n    tcp_attempt_closewait(s, f);\n\n    /* Ensure that the notification given to the socket\n     * did not put us in LAST_ACK state before sending the ACK: i.e. if\n     * pico_socket_close() has been called in the socket callback, we don't need to send\n     * an ACK here.\n     *\n     */\n    if (((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_CLOSE_WAIT) ||\n        ((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED))\n    {\n        tcp_dbg(\"In closewait: Sending ack! (state is %08x)\\n\", s->state);\n        tcp_send_ack(t);\n    }\n\n    return 0;\n}\n\nstatic int tcp_rcvfin(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    IGNORE_PARAMETER(f);\n    tcp_dbg(\"TCP> Received FIN in FIN_WAIT1\\n\");\n    s->state &= 0x00FFU;\n    s->state |= PICO_SOCKET_STATE_TCP_CLOSING;\n    t->rcv_processed = t->rcv_nxt + 1;\n    t->rcv_nxt++;\n    /* send ACK */\n    tcp_send_ack(t);\n    return 0;\n}\n\nstatic int tcp_finack(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    IGNORE_PARAMETER(f);\n\n    tcp_dbg(\"TCP> ENTERED finack\\n\");\n    t->rcv_nxt++;\n    /* send ACK */\n    tcp_send_ack(t);\n\n    /* call socket wakeup with EV_FIN */\n    if (s->wakeup)\n        s->wakeup(PICO_SOCK_EV_FIN, s);\n\n    s->state &= 0x00FFU;\n    s->state |= PICO_SOCKET_STATE_TCP_TIME_WAIT;\n    /* set SHUT_REMOTE */\n    s->state |= PICO_SOCKET_STATE_SHUT_REMOTE;\n\n    tcp_linger(t);\n\n    return 0;\n}\n\nstatic void tcp_force_closed(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    /* update state */\n    (t->sock).state &= 0x00FFU;\n    (t->sock).state |= PICO_SOCKET_STATE_TCP_CLOSED;\n    (t->sock).state &= 0xFF00U;\n    (t->sock).state |= PICO_SOCKET_STATE_CLOSED;\n    /* call EV_ERR wakeup before deleting */\n    if (((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED)) {\n        if ((t->sock).wakeup)\n            (t->sock).wakeup(PICO_SOCK_EV_FIN, &(t->sock));\n    } else {\n        pico_err = PICO_ERR_ECONNRESET;\n        if ((t->sock).wakeup)\n            (t->sock).wakeup(PICO_SOCK_EV_FIN, &(t->sock));\n\n        /* delete socket */\n        pico_socket_del(&t->sock);\n    }\n}\n\nstatic void tcp_wakeup_pending(struct pico_socket *s, uint16_t ev)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    if ((t->sock).wakeup)\n        (t->sock).wakeup(ev, &(t->sock));\n}\n\nstatic int tcp_rst(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) (f->transport_hdr);\n\n    tcp_dbg(\"TCP >>>>>>>>>>>>>> received RST <<<<<<<<<<<<<<<<<<<<\\n\");\n    if ((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_SYN_SENT) {\n        /* the RST is acceptable if the ACK field acknowledges the SYN */\n        if ((t->snd_nxt + 1u) == ACKN(f)) {              /* valid, got to closed state */\n            tcp_force_closed(s);\n        } else {                  /* not valid, ignore */\n            tcp_dbg(\"TCP RST> IGNORE\\n\");\n            return 0;\n        }\n    } else {              /* all other states */\n        /* all reset (RST) segments are validated by checking their SEQ-fields,\n           a reset is valid if its sequence number is in the window */\n        uint32_t this_seq = long_be(hdr->seq);\n        if ((this_seq >= t->rcv_ackd) && (this_seq <= ((uint32_t)(short_be(hdr->rwnd) << (t->wnd_scale)) + t->rcv_ackd))) {\n            tcp_force_closed(s);\n        } else {                  /* not valid, ignore */\n            tcp_dbg(\"TCP RST> IGNORE\\n\");\n            return 0;\n        }\n    }\n\n    return 0;\n}\nstatic int tcp_halfopencon(struct pico_socket *s, struct pico_frame *fr)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    IGNORE_PARAMETER(fr);\n    tcp_send_ack(t);\n    return 0;\n}\n\nstatic int tcp_closeconn(struct pico_socket *s, struct pico_frame *fr)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;\n    struct pico_tcp_hdr *hdr  = (struct pico_tcp_hdr *) (fr->transport_hdr);\n\n    pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n    if (pico_seq_compare(SEQN(fr), t->rcv_nxt) == 0) {\n        /* received FIN, increase ACK nr */\n        t->rcv_nxt = long_be(hdr->seq) + 1;\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_CLOSE_WAIT;\n        /* set SHUT_LOCAL */\n        s->state |= PICO_SOCKET_STATE_SHUT_LOCAL;\n        pico_socket_close(s);\n        return 1;\n    }\n\n    return 0;\n}\n\nstruct tcp_action_entry {\n    uint16_t tcpstate;\n    int (*syn)(struct pico_socket *s, struct pico_frame *f);\n    int (*synack)(struct pico_socket *s, struct pico_frame *f);\n    int (*ack)(struct pico_socket *s, struct pico_frame *f);\n    int (*data)(struct pico_socket *s, struct pico_frame *f);\n    int (*fin)(struct pico_socket *s, struct pico_frame *f);\n    int (*finack)(struct pico_socket *s, struct pico_frame *f);\n    int (*rst)(struct pico_socket *s, struct pico_frame *f);\n};\n\nstatic const struct tcp_action_entry tcp_fsm[] = {\n    /* State                              syn              synack             ack                data             fin              finack           rst*/\n    { PICO_SOCKET_STATE_TCP_UNDEF,        NULL,            NULL,              NULL,              NULL,            NULL,            NULL,            NULL     },\n    { PICO_SOCKET_STATE_TCP_CLOSED,       NULL,            NULL,              NULL,              NULL,            NULL,            NULL,            NULL     },\n    { PICO_SOCKET_STATE_TCP_LISTEN,       &tcp_syn,        NULL,              NULL,              NULL,            NULL,            NULL,            NULL     },\n    { PICO_SOCKET_STATE_TCP_SYN_SENT,     NULL,            &tcp_synack,       NULL,              NULL,            NULL,            NULL,            &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_SYN_RECV,     &tcp_synrecv_syn, NULL,              &tcp_first_ack,    &tcp_data_in,    NULL,            &tcp_closeconn,  &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_ESTABLISHED,  &tcp_halfopencon, &tcp_ack,         &tcp_ack,          &tcp_data_in,    &tcp_closewait,  &tcp_closewait,  &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_CLOSE_WAIT,   NULL,            &tcp_ack,          &tcp_ack,          &tcp_send_rst,   &tcp_closewait,  &tcp_closewait,  &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_LAST_ACK,     NULL,            &tcp_ack,          &tcp_lastackwait,  &tcp_send_rst,   &tcp_send_rst,   &tcp_send_rst,   &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_FIN_WAIT1,    NULL,            &tcp_ack,          &tcp_finwaitack,   &tcp_data_in,    &tcp_rcvfin,     &tcp_finack,     &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_FIN_WAIT2,    NULL,            &tcp_ack,          &tcp_ack,          &tcp_data_in,    &tcp_finwaitfin, &tcp_finack,     &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_CLOSING,      NULL,            &tcp_ack,          &tcp_closing_ack, &tcp_send_rst,   &tcp_send_rst,   &tcp_send_rst,   &tcp_rst },\n    { PICO_SOCKET_STATE_TCP_TIME_WAIT,    NULL,            NULL,          NULL,     &tcp_send_rst,   NULL, NULL, NULL}\n};\n\n#define MAX_VALID_FLAGS  10  /* Maximum number of valid flag combinations */\nstatic uint8_t invalid_flags(struct pico_socket *s, uint8_t flags)\n{\n    uint8_t i;\n    static const uint8_t valid_flags[PICO_SOCKET_STATE_TCP_ARRAYSIZ][MAX_VALID_FLAGS] = {\n        { /* PICO_SOCKET_STATE_TCP_UNDEF      */ 0, },\n        { /* PICO_SOCKET_STATE_TCP_CLOSED     */ 0, },\n        { /* PICO_SOCKET_STATE_TCP_LISTEN     */ PICO_TCP_SYN },\n        { /* PICO_SOCKET_STATE_TCP_SYN_SENT   */ PICO_TCP_SYNACK, PICO_TCP_RST, PICO_TCP_RSTACK},\n        { /* PICO_SOCKET_STATE_TCP_SYN_RECV   */ PICO_TCP_SYN, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_ESTABLISHED*/ PICO_TCP_SYN, PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST, PICO_TCP_RSTACK},\n        { /* PICO_SOCKET_STATE_TCP_CLOSE_WAIT */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_LAST_ACK   */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_FIN_WAIT1  */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_FIN_WAIT2  */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_CLOSING    */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n        { /* PICO_SOCKET_STATE_TCP_TIME_WAIT  */ PICO_TCP_SYNACK, PICO_TCP_ACK, PICO_TCP_PSH, PICO_TCP_PSHACK, PICO_TCP_FIN, PICO_TCP_FINACK, PICO_TCP_FINPSHACK, PICO_TCP_RST},\n    };\n    if(!flags)\n        return 1;\n\n    for(i = 0; i < MAX_VALID_FLAGS; i++) {\n        if(valid_flags[s->state >> 8u][i] == flags)\n            return 0;\n    }\n    return 1;\n}\n\nstatic void tcp_action_call(int (*call)(struct pico_socket *s, struct pico_frame *f), struct pico_socket *s, struct pico_frame *f )\n{\n    if (call)\n        call(s, f);\n}\n\nstatic int tcp_action_by_flags(const struct tcp_action_entry *action, struct pico_socket *s, struct pico_frame *f, uint8_t flags)\n{\n    int ret = 0;\n\n    if ((flags == PICO_TCP_ACK) || (flags == (PICO_TCP_ACK | PICO_TCP_PSH))) {\n        tcp_action_call(action->ack, s, f);\n    }\n\n    if ((f->payload_len > 0 || (flags & PICO_TCP_PSH)) &&\n        !(s->state & PICO_SOCKET_STATE_CLOSED) && !TCP_IS_STATE(s, PICO_SOCKET_STATE_TCP_LISTEN))\n    {\n        ret = f->payload_len;\n        tcp_action_call(action->data, s, f);\n    }\n\n    if (flags == PICO_TCP_FIN) {\n        tcp_action_call(action->fin, s, f);\n    }\n\n    if ((flags == (PICO_TCP_FIN | PICO_TCP_ACK)) || (flags == (PICO_TCP_FIN | PICO_TCP_ACK | PICO_TCP_PSH))) {\n        tcp_action_call(action->finack, s, f);\n    }\n\n    if (flags & PICO_TCP_RST) {\n        tcp_action_call(action->rst, s, f);\n    }\n\n    return ret;\n}\n\nint pico_tcp_input(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) (f->transport_hdr);\n    int ret = 0;\n    uint8_t flags = hdr->flags;\n    const struct tcp_action_entry *action = &tcp_fsm[s->state >> 8];\n\n    f->payload = (f->transport_hdr + ((hdr->len & 0xf0u) >> 2u));\n    f->payload_len = (uint16_t)(f->transport_len - ((hdr->len & 0xf0u) >> 2u));\n\n    tcp_dbg(\"[sam] TCP> [tcp input] t_len: %u\\n\", f->transport_len);\n    tcp_dbg(\"[sam] TCP> flags = 0x%02x\\n\", hdr->flags);\n    tcp_dbg(\"[sam] TCP> s->state >> 8 = %u\\n\", s->state >> 8);\n    tcp_dbg(\"[sam] TCP> [tcp input] socket: %p state: %d <-- local port:%u remote port: %u seq: 0x%08x ack: 0x%08x flags: 0x%02x t_len: %u, hdr: %u payload: %d\\n\", s, s->state >> 8, short_be(hdr->trans.dport), short_be(hdr->trans.sport), SEQN(f), ACKN(f), hdr->flags, f->transport_len, (hdr->len & 0xf0) >> 2, f->payload_len );\n\n    if ((f->payload + f->payload_len) > (f->buffer + f->buffer_len)) {\n        tcp_dbg(\"TCP> Invalid payload len %04x\\n\", f->payload_len);\n        pico_frame_discard(f);\n        return -1;\n    }\n\n    /* This copy of the frame has the current socket as owner */\n    f->sock = s;\n    s->timestamp = TCP_TIME;\n    /* Those are not supported at this time. */\n    /* flags &= (uint8_t) ~(PICO_TCP_CWR | PICO_TCP_URG | PICO_TCP_ECN); */\n    if(invalid_flags(s, flags)) {\n        pico_tcp_reply_rst(s->stack, f);\n    }\n    else if (flags == PICO_TCP_SYN) {\n        tcp_action_call(action->syn, s, f);\n    } else if (flags == (PICO_TCP_SYN | PICO_TCP_ACK)) {\n        tcp_action_call(action->synack, s, f);\n    } else {\n        ret = tcp_action_by_flags(action, s, f, flags);\n    }\n\n    if (s->ev_pending)\n        tcp_wakeup_pending(s, s->ev_pending);\n\n/* discard: */\n    pico_frame_discard(f);\n    return ret;\n}\n\n\ninline static int checkLocalClosing(struct pico_socket *s);\ninline static int checkRemoteClosing(struct pico_socket *s);\n\nstatic struct pico_frame *tcp_split_segment(struct pico_socket_tcp *t, struct pico_frame *f, uint16_t size)\n{\n    struct pico_frame *f1, *f2;\n    uint16_t size1, size2, size_f;\n    uint16_t overhead;\n    struct pico_tcp_hdr *hdr1, *hdr2, *hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    overhead = pico_tcp_overhead(&t->sock);\n    size_f = f->payload_len;\n\n\n    if (size >= size_f)\n        return f; /* no need to split! */\n\n    size1 = size;\n    size2 = (uint16_t)(size_f - size);\n\n    f1 = pico_socket_frame_alloc(&t->sock, get_sock_dev(&t->sock), (uint16_t) (size1 + overhead));\n    f2 = pico_socket_frame_alloc(&t->sock, get_sock_dev(&t->sock), (uint16_t) (size2 + overhead));\n\n    if (!f1 || !f2) {\n        pico_err = PICO_ERR_ENOMEM;\n        return NULL;\n    }\n\n    /* Advance payload pointer to the beginning of segment data */\n    f1->payload += overhead;\n    f1->payload_len = (uint16_t)(f1->payload_len - overhead);\n    f2->payload += overhead;\n    f2->payload_len = (uint16_t)(f2->payload_len - overhead);\n\n    hdr1 = (struct pico_tcp_hdr *)f1->transport_hdr;\n    hdr2 = (struct pico_tcp_hdr *)f2->transport_hdr;\n\n    /* Copy payload */\n    memcpy(f1->payload, f->payload, size1);\n    memcpy(f2->payload, f->payload + size1, size2);\n\n    /* Copy tcp hdr */\n    memcpy(hdr1, hdr, sizeof(struct pico_tcp_hdr));\n    memcpy(hdr2, hdr, sizeof(struct pico_tcp_hdr));\n\n    /* Adjust f2's sequence number */\n    hdr2->seq = long_be(SEQN(f) + size1);\n\n    /* Add TCP options */\n    pico_tcp_flags_update(f1, &t->sock);\n    pico_tcp_flags_update(f2, &t->sock);\n    tcp_add_options_frame(t, f1);\n    tcp_add_options_frame(t, f2);\n\n    /* Get rid of the full frame */\n    pico_discard_segment(&t->tcpq_out, f);\n\n    /* Enqueue f2 for later send... */\n    if (pico_enqueue_segment(&t->tcpq_out, f2) < 0) {\n        tcp_dbg(\"Discarding invalid segment\\n\");\n        pico_frame_discard(f2);\n    }\n\n    /* Return the partial frame */\n    return f1;\n}\n\n\nint pico_tcp_output(struct pico_socket *s, int loop_score)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    struct pico_frame *f, *una;\n    int sent = 0;\n    int data_sent = 0;\n    int32_t seq_diff = 0;\n\n    una = first_segment(&t->tcpq_out);\n    f = peek_segment(&t->tcpq_out, t->snd_nxt);\n\n    while((f) && (t->cwnd >= t->in_flight)) {\n        f->timestamp = TCP_TIME;\n        add_retransmission_timer(t, t->rto + TCP_TIME);\n        tcp_add_options_frame(t, f);\n        seq_diff = pico_seq_compare(SEQN(f), SEQN(una));\n        if (seq_diff < 0) {\n            tcp_dbg(\">>> FATAL: seq diff is negative!\\n\");\n            break;\n        }\n\n        /* Check if advertised window is full */\n        if ((uint32_t)seq_diff >= (uint32_t)(t->recv_wnd << t->recv_wnd_scale)) {\n            if (t->x_mode != PICO_TCP_WINDOW_FULL) {\n                tcp_dbg(\"TCP> RIGHT SIZING (rwnd: %d, frame len: %d\\n\", t->recv_wnd << t->recv_wnd_scale, f->payload_len);\n                tcp_dbg(\"In window full...\\n\");\n                t->snd_nxt = SEQN(una);\n                t->snd_retry = SEQN(una);\n                t->x_mode = PICO_TCP_WINDOW_FULL;\n            }\n\n            break;\n        }\n\n        /* Check if the advertised window is too small to receive the current frame */\n        if ((uint32_t)(seq_diff + f->payload_len) > (uint32_t)(t->recv_wnd << t->recv_wnd_scale)) {\n            f = tcp_split_segment(t, f, (uint16_t)(t->recv_wnd << t->recv_wnd_scale));\n            if (!f)\n                break;\n\n            /* Limit sending window to packets in flight (right sizing) */\n            t->cwnd = (uint16_t)t->in_flight;\n            if (t->cwnd < 1)\n                t->cwnd = 1;\n        }\n\n        tcp_dbg(\"TCP> DEQUEUED (for output) frame %08x, acks %08x len= %d, remaining frames %d\\n\", SEQN(f), ACKN(f), f->payload_len, t->tcpq_out.frames);\n        tcp_send(t, f);\n        sent++;\n        loop_score--;\n        t->snd_last_out = SEQN(f);\n        if (loop_score < 1)\n            break;\n\n        if (f->payload_len > 0) {\n            data_sent++;\n            f = next_segment(&t->tcpq_out, f);\n        } else {\n            f = NULL;\n        }\n    }\n    if ((sent > 0 && data_sent > 0)) {\n        rto_set(t, t->rto);\n    } else {\n        /* Nothing to transmit. */\n    }\n\n    if ((t->tcpq_out.frames == 0) && (s->state & PICO_SOCKET_STATE_SHUT_LOCAL)) {              /* if no more packets in queue, XXX replaced !f by tcpq check */\n        if(!checkLocalClosing(&t->sock))              /* check if local closing started and send fin */\n        {\n            checkRemoteClosing(&t->sock);              /* check if remote closing started and send fin */\n        }\n    }\n\n    return loop_score;\n}\n\nint pico_tcp_output(struct pico_socket *s, int loop_score);\nvoid pico_tcp_out_all(struct pico_stack *S, void *arg)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)arg;\n    (void)S;\n    if (t) {\n        struct pico_socket *s = &t->sock;\n        pico_tcp_output(&t->sock, (int)t->tcpq_out.frames);\n        if ((s->ev_pending) && s->wakeup) {\n            s->wakeup(s->ev_pending, s);\n            if(!s->parent)\n                s->ev_pending = 0;\n        }\n\n        if(pico_socket_sanity_check(s) < 0)\n        {\n            pico_socket_del(s);\n        }\n    }\n}\n\n/* function to make new segment from hold queue with specific size (mss) */\nstatic struct pico_frame *pico_hold_segment_make(struct pico_socket_tcp *t)\n{\n    struct pico_frame *f_temp, *f_new;\n    struct pico_socket *s = (struct pico_socket *) &t->sock;\n    struct pico_tcp_hdr *hdr;\n    uint16_t total_len = 0, total_payload_len = 0;\n    uint16_t off = 0, test = 0;\n\n    off = pico_tcp_overhead(s);\n\n    /* init with first frame in hold queue */\n    f_temp = first_segment(&t->tcpq_hold);\n    total_len = f_temp->payload_len;\n    f_temp = next_segment(&t->tcpq_hold, f_temp);\n\n    /* check till total_len <= MSS */\n    while ((f_temp != NULL) && ((total_len + f_temp->payload_len) <= t->mss)) {\n        total_len = (uint16_t)(total_len + f_temp->payload_len);\n        f_temp = next_segment(&t->tcpq_hold, f_temp);\n        if (f_temp == NULL)\n            break;\n    }\n    /* alloc new frame with payload size = off + total_len */\n    f_new = pico_socket_frame_alloc(s, get_sock_dev(s), (uint16_t)(off + total_len));\n    if (!f_new) {\n        pico_err = PICO_ERR_ENOMEM;\n        return f_new;\n    }\n\n    pico_tcp_flags_update(f_new, &t->sock);\n    hdr = (struct pico_tcp_hdr *) f_new->transport_hdr;\n    /* init new frame */\n    f_new->payload += off;\n    f_new->payload_len = (uint16_t)(f_new->payload_len - off);\n    f_new->sock = s;\n\n    f_temp = first_segment(&t->tcpq_hold);\n    hdr->seq = ((struct pico_tcp_hdr *)(f_temp->transport_hdr))->seq;              /* get sequence number of first frame */\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n\n    /* check till total_payload_len <= MSS */\n    while ((f_temp != NULL) && ((total_payload_len + f_temp->payload_len) <= t->mss)) {\n        /* cpy data and discard frame */\n        test++;\n        memcpy(f_new->payload + total_payload_len, f_temp->payload, f_temp->payload_len);\n        total_payload_len = (uint16_t)(total_payload_len + f_temp->payload_len);\n        pico_discard_segment(&t->tcpq_hold, f_temp);\n        f_temp = first_segment(&t->tcpq_hold);\n    }\n    hdr->len = (uint8_t)((f_new->payload - f_new->transport_hdr) << 2u);\n\n    tcp_dbg_nagle(\"NAGLE make - joined %d segments, len %d bytes\\n\", test, total_payload_len);\n    tcp_add_options_frame(t, f_new);\n\n    return f_new;\n}\n\n\n\nstatic int pico_tcp_push_nagle_enqueue(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    if (pico_enqueue_segment(&t->tcpq_out, f) > 0) {\n        tcp_dbg_nagle(\"TCP_PUSH - NAGLE - Pushing segment %08x, len %08x to socket %p\\n\", t->snd_last + 1, f->payload_len, t);\n        t->snd_last += f->payload_len;\n        pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n        return f->payload_len;\n    } else {\n        tcp_dbg(\"Enqueue failed.\\n\");\n        return 0;\n    }\n}\n\nstatic int pico_tcp_push_nagle_hold(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    struct pico_frame *f_new;\n    uint32_t total_len = 0;\n    pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n    total_len = f->payload_len + t->tcpq_hold.size;\n    if ((total_len >= t->mss) && ((t->tcpq_out.max_size - t->tcpq_out.size) >= t->mss)) {\n        /* IF enough data in hold (>mss) AND space in out queue (>mss) */\n        /* add current frame in hold and make new segment */\n        if (pico_enqueue_segment(&t->tcpq_hold, f) > 0 ) {\n            tcp_dbg_nagle(\"TCP_PUSH - NAGLE - Pushed into hold, make new (enqueued frames out %d)\\n\", t->tcpq_out.frames);\n            t->snd_last += f->payload_len;              /* XXX  WATCH OUT */\n            f_new = pico_hold_segment_make(t);\n        } else {\n            tcp_dbg_nagle(\"TCP_PUSH - NAGLE - enqueue hold failed 1\\n\");\n            return 0;\n        }\n\n        /* and put new frame in out queue */\n        if ((f_new != NULL) && (pico_enqueue_segment(&t->tcpq_out, f_new) > 0)) {\n            return f_new->payload_len;\n        } else {\n            tcp_dbg_nagle(\"TCP_PUSH - NAGLE - enqueue out failed, f_new = %p\\n\", f_new);\n            return -1;              /* XXX something seriously wrong */\n        }\n    } else {\n        /* ELSE put frame in hold queue */\n        if (pico_enqueue_segment(&t->tcpq_hold, f) > 0) {\n            tcp_dbg_nagle(\"TCP_PUSH - NAGLE - Pushed into hold (enqueued frames out %d)\\n\", t->tcpq_out.frames);\n            t->snd_last += f->payload_len;              /* XXX  WATCH OUT */\n            return f->payload_len;\n        } else {\n            pico_err = PICO_ERR_EAGAIN;\n            tcp_dbg_nagle(\"TCP_PUSH - NAGLE - enqueue hold failed 2\\n\");\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int pico_tcp_push_nagle_on(struct pico_socket_tcp *t, struct pico_frame *f)\n{\n    /* Nagle's algorithm enabled, check if ready to send, or put frame in hold queue */\n    if (IS_TCP_IDLE(t) && IS_TCP_HOLDQ_EMPTY(t))\n        return pico_tcp_push_nagle_enqueue(t, f);\n\n    return pico_tcp_push_nagle_hold(t, f);\n}\n\n\n\n/* original behavior kept when Nagle disabled;\n   Nagle algorithm added here, keeping hold frame queue instead of eg linked list of data */\nint pico_tcp_push(struct pico_stack *S, struct pico_protocol *self, struct pico_frame *f)\n{\n    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *) f->sock;\n    (void)S;\n    IGNORE_PARAMETER(self);\n    pico_err = PICO_ERR_NOERR;\n    hdr->trans.sport = t->sock.local_port;\n    hdr->trans.dport = t->sock.remote_port;\n    hdr->seq = long_be(t->snd_last + 1);\n    hdr->len = (uint8_t)((f->payload - f->transport_hdr) << 2u);\n\n    if ((uint32_t)f->payload_len > (uint32_t)(t->tcpq_out.max_size - t->tcpq_out.size))\n        t->sock.ev_pending &= (uint16_t)(~PICO_SOCK_EV_WR);\n\n    /***************************************************************************/\n\n    if (!IS_NAGLE_ENABLED((&(t->sock)))) {\n        /* TCP_NODELAY enabled, original behavior */\n        if (pico_enqueue_segment(&t->tcpq_out, f) > 0) {\n            pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);\n            tcp_dbg_nagle(\"TCP_PUSH - NO NAGLE - Pushing segment %08x, len %08x to socket %p\\n\", t->snd_last + 1, f->payload_len, t);\n            t->snd_last += f->payload_len;\n            return f->payload_len;\n        } else {\n            tcp_dbg(\"Enqueue failed.\\n\");\n            return 0;\n        }\n    } else {\n        return pico_tcp_push_nagle_on(t, f);\n    }\n\n}\n\nstatic void tcp_discard_all_segments(struct pico_tcp_queue *tq)\n{\n    struct pico_tree_node *index = NULL, *index_safe = NULL;\n    PICOTCP_MUTEX_LOCK(Mutex);\n    pico_tree_foreach_safe(index, &tq->pool, index_safe)\n    {\n        void *f = index->keyValue;\n        if(!f)\n            break;\n\n        pico_tree_delete(&tq->pool, f);\n        if(IS_INPUT_QUEUE(tq))\n        {\n            struct tcp_input_segment *inp = (struct tcp_input_segment *)f;\n            PICO_FREE(inp->payload);\n            PICO_FREE(inp);\n        }\n        else\n            pico_frame_discard(f);\n    }\n    tq->frames = 0;\n    tq->size = 0;\n    PICOTCP_MUTEX_UNLOCK(Mutex);\n}\n\nvoid pico_tcp_cleanup_queues(struct pico_socket *sck)\n{\n    struct pico_socket_tcp *tcp = (struct pico_socket_tcp *)sck;\n    pico_timer_cancel(tcp->sock.stack, tcp->retrans_tmr);\n    pico_timer_cancel(tcp->sock.stack, tcp->keepalive_tmr);\n    pico_timer_cancel(tcp->sock.stack, tcp->fin_tmr);\n\n    tcp->retrans_tmr = 0;\n    tcp->keepalive_tmr = 0;\n    tcp->fin_tmr = 0;\n\n    tcp_discard_all_segments(&tcp->tcpq_in);\n    tcp_discard_all_segments(&tcp->tcpq_out);\n    tcp_discard_all_segments(&tcp->tcpq_hold);\n}\n\nstatic int checkLocalClosing(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    if ((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED) {\n        tcp_dbg(\"TCP> buffer empty, shutdown established ...\\n\");\n        /* send fin if queue empty and in state shut local (write) */\n        tcp_send_fin(t);\n        /* change tcp state to FIN_WAIT1 */\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_FIN_WAIT1;\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic int checkRemoteClosing(struct pico_socket *s)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    if ((s->state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_CLOSE_WAIT) {\n        /* send fin if queue empty and in state shut local (write) */\n        tcp_send_fin(t);\n        /* change tcp state to LAST_ACK */\n        s->state &= 0x00FFU;\n        s->state |= PICO_SOCKET_STATE_TCP_LAST_ACK;\n        tcp_dbg(\"TCP> STATE: LAST_ACK.\\n\");\n        return 1;\n    }\n\n    return 0;\n}\n\nvoid pico_tcp_notify_closing(struct pico_socket *sck)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)sck;\n    if(t->tcpq_out.frames == 0)\n    {\n        if(!checkLocalClosing(sck))\n            checkRemoteClosing(sck);\n    }\n}\n\n\nint pico_tcp_check_listen_close(struct pico_socket *s)\n{\n    if (TCP_IS_STATE(s, PICO_SOCKET_STATE_TCP_LISTEN)) {\n        pico_socket_del(s);\n        return 0;\n    }\n\n    return -1;\n}\n\nvoid pico_tcp_flags_update(struct pico_frame *f, struct pico_socket *s)\n{\n    f->transport_flags_saved = ((struct pico_socket_tcp *)s)->ts_ok;\n}\n\nint pico_tcp_set_bufsize_in(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->tcpq_in.max_size = value;\n    return 0;\n}\n\nint pico_tcp_set_bufsize_out(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->tcpq_out.max_size = value;\n    return 0;\n}\n\nint pico_tcp_get_bufsize_in(struct pico_socket *s, uint32_t *value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    *value = t->tcpq_in.max_size;\n    return 0;\n}\n\nint pico_tcp_get_bufsize_out(struct pico_socket *s, uint32_t *value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    *value = t->tcpq_out.max_size;\n    return 0;\n}\n\nint pico_tcp_set_keepalive_probes(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->ka_probes = value;\n    return 0;\n}\n\nint pico_tcp_set_keepalive_intvl(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->ka_intvl = value;\n    return 0;\n}\n\nint pico_tcp_set_keepalive_time(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->ka_time = value;\n    return 0;\n}\n\nint pico_tcp_set_linger(struct pico_socket *s, uint32_t value)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)s;\n    t->linger_timeout = value;\n    return 0;\n}\n\n#endif /* PICO_SUPPORT_TCP */\n", "/*********************************************************************\n * PicoTCP-NG \n * Copyright (c) 2020 Daniele Lacamera <root@danielinux.net>\n *\n * This file also includes code from:\n * PicoTCP\n * Copyright (c) 2012-2017 Altran Intelligent Systems\n * \n * SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only\n *\n * PicoTCP-NG is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) version 3.\n *\n * PicoTCP-NG is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n *\n *\n *********************************************************************/\n#ifndef INCLUDE_PICO_TCP\n#define INCLUDE_PICO_TCP\n#include \"pico_addressing.h\"\n#include \"pico_protocol.h\"\n#include \"pico_socket.h\"\n\nextern struct pico_protocol pico_proto_tcp;\n\nPACKED_STRUCT_DEF pico_tcp_hdr {\n    struct pico_trans trans;\n    uint32_t seq;\n    uint32_t ack;\n    uint8_t len;\n    uint8_t flags;\n    uint16_t rwnd;\n    uint16_t crc;\n    uint16_t urgent;\n};\n\nPACKED_STRUCT_DEF tcp_pseudo_hdr_ipv4\n{\n    struct pico_ip4 src;\n    struct pico_ip4 dst;\n    uint16_t tcp_len;\n    uint8_t res;\n    uint8_t proto;\n};\n\n#define PICO_TCPHDR_SIZE 20\n#define PICO_SIZE_TCPOPT_SYN 20\n#define PICO_SIZE_TCPHDR (uint32_t)(sizeof(struct pico_tcp_hdr))\n#define PICO_TCP_MIN_MSS (64 - PICO_SIZE_TCPHDR)\n\n/* TCP options */\n#define PICO_TCP_OPTION_END         0x00\n#define PICO_TCPOPTLEN_END        1u\n#define PICO_TCP_OPTION_NOOP        0x01\n#define PICO_TCPOPTLEN_NOOP       1\n#define PICO_TCP_OPTION_MSS         0x02\n#define PICO_TCPOPTLEN_MSS        4\n#define PICO_TCP_OPTION_WS          0x03\n#define PICO_TCPOPTLEN_WS         3u\n#define PICO_TCP_OPTION_SACK_OK        0x04\n#define PICO_TCPOPTLEN_SACK_OK       2\n#define PICO_TCP_OPTION_SACK        0x05\n#define PICO_TCPOPTLEN_SACK       2 /* Plus the block */\n#define PICO_TCP_OPTION_TIMESTAMP   0x08\n#define PICO_TCPOPTLEN_TIMESTAMP  10u\n\n/* TCP flags */\n#define PICO_TCP_FIN 0x01u\n#define PICO_TCP_SYN 0x02u\n#define PICO_TCP_RST 0x04u\n#define PICO_TCP_PSH 0x08u\n#define PICO_TCP_ACK 0x10u\n#define PICO_TCP_URG 0x20u\n#define PICO_TCP_ECN 0x40u\n#define PICO_TCP_CWR 0x80u\n\n#define PICO_TCP_SYNACK    (PICO_TCP_SYN | PICO_TCP_ACK)\n#define PICO_TCP_PSHACK    (PICO_TCP_PSH | PICO_TCP_ACK)\n#define PICO_TCP_FINACK    (PICO_TCP_FIN | PICO_TCP_ACK)\n#define PICO_TCP_FINPSHACK (PICO_TCP_FIN | PICO_TCP_PSH | PICO_TCP_ACK)\n#define PICO_TCP_RSTACK    (PICO_TCP_RST | PICO_TCP_ACK)\n\n\nPACKED_STRUCT_DEF pico_tcp_option\n{\n    uint8_t kind;\n    uint8_t len;\n};\n\nstruct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family);\nuint32_t pico_tcp_read(struct pico_socket *s, void *buf, uint32_t len);\nint pico_tcp_initconn(struct pico_socket *s);\nint pico_tcp_input(struct pico_socket *s, struct pico_frame *f);\nuint16_t pico_tcp_checksum(struct pico_frame *f);\nuint16_t pico_tcp_checksum_ipv4(struct pico_frame *f);\n#ifdef PICO_SUPPORT_IPV6\nuint16_t pico_tcp_checksum_ipv6(struct pico_frame *f);\n#endif\nuint16_t pico_tcp_overhead(struct pico_socket *s);\nint pico_tcp_output(struct pico_socket *s, int loop_score);\nint pico_tcp_queue_in_is_empty(struct pico_socket *s);\nint pico_tcp_queue_in_size(struct pico_socket *s);\nint pico_tcp_reply_rst(struct pico_stack *S, struct pico_frame *f);\nvoid pico_tcp_cleanup_queues(struct pico_socket *sck);\nvoid pico_tcp_notify_closing(struct pico_socket *sck);\nvoid pico_tcp_flags_update(struct pico_frame *f, struct pico_socket *s);\nint pico_tcp_set_bufsize_in(struct pico_socket *s, uint32_t value);\nint pico_tcp_set_bufsize_out(struct pico_socket *s, uint32_t value);\nint pico_tcp_get_bufsize_in(struct pico_socket *s, uint32_t *value);\nint pico_tcp_get_bufsize_out(struct pico_socket *s, uint32_t *value);\nint pico_tcp_set_keepalive_probes(struct pico_socket *s, uint32_t value);\nint pico_tcp_set_keepalive_intvl(struct pico_socket *s, uint32_t value);\nint pico_tcp_set_keepalive_time(struct pico_socket *s, uint32_t value);\nint pico_tcp_set_linger(struct pico_socket *s, uint32_t value);\nuint16_t pico_tcp_get_socket_mss(struct pico_socket *s);\nint pico_tcp_check_listen_close(struct pico_socket *s);\n\n#endif\n"], "filenames": ["modules/pico_tcp.c", "modules/pico_tcp.h"], "buggy_code_start_loc": [1088, 57], "buggy_code_end_loc": [2450, 57], "fixing_code_start_loc": [1088, 58], "fixing_code_end_loc": [2460, 59], "type": "CWE-908", "message": "VirtualSquare picoTCP (aka PicoTCP-NG) through 2.1 does not have an MSS lower bound (e.g., it could be zero).", "other": {"cve": {"id": "CVE-2023-35847", "sourceIdentifier": "cve@mitre.org", "published": "2023-06-19T03:15:09.280", "lastModified": "2023-06-26T18:10:28.833", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "VirtualSquare picoTCP (aka PicoTCP-NG) through 2.1 does not have an MSS lower bound (e.g., it could be zero)."}, {"lang": "es", "value": "VirtualSquare picoTCP (tambi\u00e9n conocido como PicoTCP-NG) a trav\u00e9s de la versi\u00f3n 2.1 no tiene un l\u00edmite inferior de \"MSS\" (por ejemplo, podr\u00eda ser cero). "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:virtualsquare:picotcp:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1", "matchCriteriaId": "FF1314A4-D96F-47BB-885E-FA90BFF16E74"}]}]}], "references": [{"url": "https://github.com/virtualsquare/picotcp/commit/eaf166009e44641e6570c576ba071217f100fd99", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/virtualsquare/picotcp/commit/eaf166009e44641e6570c576ba071217f100fd99"}}