{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * net/ipv6/fib6_rules.c\tIPv6 Routing Policy Rules\n *\n * Copyright (C)2003-2006 Helsinki University of Technology\n * Copyright (C)2003-2006 USAGI/WIDE Project\n *\n * Authors\n *\tThomas Graf\t\t<tgraf@suug.ch>\n *\tVille Nuorvala\t\t<vnuorval@tcs.hut.fi>\n */\n\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n\n#include <net/fib_rules.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/netlink.h>\n\nstruct fib6_rule {\n\tstruct fib_rule\t\tcommon;\n\tstruct rt6key\t\tsrc;\n\tstruct rt6key\t\tdst;\n\tu8\t\t\ttclass;\n};\n\nstatic bool fib6_rule_matchall(const struct fib_rule *rule)\n{\n\tstruct fib6_rule *r = container_of(rule, struct fib6_rule, common);\n\n\tif (r->dst.plen || r->src.plen || r->tclass)\n\t\treturn false;\n\treturn fib_rule_matchall(rule);\n}\n\nbool fib6_rule_default(const struct fib_rule *rule)\n{\n\tif (!fib6_rule_matchall(rule) || rule->action != FR_ACT_TO_TBL ||\n\t    rule->l3mdev)\n\t\treturn false;\n\tif (rule->table != RT6_TABLE_LOCAL && rule->table != RT6_TABLE_MAIN)\n\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(fib6_rule_default);\n\nint fib6_rules_dump(struct net *net, struct notifier_block *nb)\n{\n\treturn fib_rules_dump(net, nb, AF_INET6);\n}\n\nunsigned int fib6_rules_seq_read(struct net *net)\n{\n\treturn fib_rules_seq_read(net, AF_INET6);\n}\n\n/* called with rcu lock held; no reference taken on fib6_info */\nint fib6_lookup(struct net *net, int oif, struct flowi6 *fl6,\n\t\tstruct fib6_result *res, int flags)\n{\n\tint err;\n\n\tif (net->ipv6.fib6_has_custom_rules) {\n\t\tstruct fib_lookup_arg arg = {\n\t\t\t.lookup_ptr = fib6_table_lookup,\n\t\t\t.lookup_data = &oif,\n\t\t\t.result = res,\n\t\t\t.flags = FIB_LOOKUP_NOREF,\n\t\t};\n\n\t\tl3mdev_update_flow(net, flowi6_to_flowi(fl6));\n\n\t\terr = fib_rules_lookup(net->ipv6.fib6_rules_ops,\n\t\t\t\t       flowi6_to_flowi(fl6), flags, &arg);\n\t} else {\n\t\terr = fib6_table_lookup(net, net->ipv6.fib6_local_tbl, oif,\n\t\t\t\t\tfl6, res, flags);\n\t\tif (err || res->f6i == net->ipv6.fib6_null_entry)\n\t\t\terr = fib6_table_lookup(net, net->ipv6.fib6_main_tbl,\n\t\t\t\t\t\toif, fl6, res, flags);\n\t}\n\n\treturn err;\n}\n\nstruct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tif (net->ipv6.fib6_has_custom_rules) {\n\t\tstruct fib6_result res = {};\n\t\tstruct fib_lookup_arg arg = {\n\t\t\t.lookup_ptr = lookup,\n\t\t\t.lookup_data = skb,\n\t\t\t.result = &res,\n\t\t\t.flags = FIB_LOOKUP_NOREF,\n\t\t};\n\n\t\t/* update flow if oif or iif point to device enslaved to l3mdev */\n\t\tl3mdev_update_flow(net, flowi6_to_flowi(fl6));\n\n\t\tfib_rules_lookup(net->ipv6.fib6_rules_ops,\n\t\t\t\t flowi6_to_flowi(fl6), flags, &arg);\n\n\t\tif (res.rt6)\n\t\t\treturn &res.rt6->dst;\n\t} else {\n\t\tstruct rt6_info *rt;\n\n\t\trt = lookup(net, net->ipv6.fib6_local_tbl, fl6, skb, flags);\n\t\tif (rt != net->ipv6.ip6_null_entry && rt->dst.error != -EAGAIN)\n\t\t\treturn &rt->dst;\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\t\tif (rt->dst.error != -EAGAIN)\n\t\t\treturn &rt->dst;\n\t\tip6_rt_put_flags(rt, flags);\n\t}\n\n\tif (!(flags & RT6_LOOKUP_F_DST_NOREF))\n\t\tdst_hold(&net->ipv6.ip6_null_entry->dst);\n\treturn &net->ipv6.ip6_null_entry->dst;\n}\n\nstatic int fib6_rule_saddr(struct net *net, struct fib_rule *rule, int flags,\n\t\t\t   struct flowi6 *flp6, const struct net_device *dev)\n{\n\tstruct fib6_rule *r = (struct fib6_rule *)rule;\n\n\t/* If we need to find a source address for this traffic,\n\t * we check the result if it meets requirement of the rule.\n\t */\n\tif ((rule->flags & FIB_RULE_FIND_SADDR) &&\n\t    r->src.plen && !(flags & RT6_LOOKUP_F_HAS_SADDR)) {\n\t\tstruct in6_addr saddr;\n\n\t\tif (ipv6_dev_get_saddr(net, dev, &flp6->daddr,\n\t\t\t\t       rt6_flags2srcprefs(flags), &saddr))\n\t\t\treturn -EAGAIN;\n\n\t\tif (!ipv6_prefix_equal(&saddr, &r->src.addr, r->src.plen))\n\t\t\treturn -EAGAIN;\n\n\t\tflp6->saddr = saddr;\n\t}\n\n\treturn 0;\n}\n\nstatic int fib6_rule_action_alt(struct fib_rule *rule, struct flowi *flp,\n\t\t\t\tint flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct net *net = rule->fr_net;\n\tstruct fib6_table *table;\n\tint err, *oif;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\treturn -ENETUNREACH;\n\tcase FR_ACT_PROHIBIT:\n\t\treturn -EACCES;\n\tcase FR_ACT_BLACKHOLE:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table)\n\t\treturn -EAGAIN;\n\n\toif = (int *)arg->lookup_data;\n\terr = fib6_table_lookup(net, table, *oif, flp6, res, flags);\n\tif (!err && res->f6i != net->ipv6.fib6_null_entry)\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      res->nh->fib_nh_dev);\n\telse\n\t\terr = -EAGAIN;\n\n\treturn err;\n}\n\nstatic int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = lookup(net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      ip6_dst_idev(&rt->dst)->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put_flags(rt, flags);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tif (!(flags & RT6_LOOKUP_F_DST_NOREF))\n\t\tdst_hold(&rt->dst);\nout:\n\tres->rt6 = rt;\n\treturn err;\n}\n\nstatic int fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t    int flags, struct fib_lookup_arg *arg)\n{\n\tif (arg->lookup_ptr == fib6_table_lookup)\n\t\treturn fib6_rule_action_alt(rule, flp, flags, arg);\n\n\treturn __fib6_rule_action(rule, flp, flags, arg);\n}\n\nstatic bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\n\tif (!rt)\n\t\treturn false;\n\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\n\t/* do not accept result if the route does\n\t * not meet the required prefix length\n\t */\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\n\t/* do not accept result if the route uses a device\n\t * belonging to a forbidden interface group\n\t */\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\n\treturn false;\n\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}\n\nstatic int fib6_rule_match(struct fib_rule *rule, struct flowi *fl, int flags)\n{\n\tstruct fib6_rule *r = (struct fib6_rule *) rule;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\n\tif (r->dst.plen &&\n\t    !ipv6_prefix_equal(&fl6->daddr, &r->dst.addr, r->dst.plen))\n\t\treturn 0;\n\n\t/*\n\t * If FIB_RULE_FIND_SADDR is set and we do not have a\n\t * source address for the traffic, we defer check for\n\t * source address.\n\t */\n\tif (r->src.plen) {\n\t\tif (flags & RT6_LOOKUP_F_HAS_SADDR) {\n\t\t\tif (!ipv6_prefix_equal(&fl6->saddr, &r->src.addr,\n\t\t\t\t\t       r->src.plen))\n\t\t\t\treturn 0;\n\t\t} else if (!(r->common.flags & FIB_RULE_FIND_SADDR))\n\t\t\treturn 0;\n\t}\n\n\tif (r->tclass && r->tclass != ip6_tclass(fl6->flowlabel))\n\t\treturn 0;\n\n\tif (rule->ip_proto && (rule->ip_proto != fl6->flowi6_proto))\n\t\treturn 0;\n\n\tif (fib_rule_port_range_set(&rule->sport_range) &&\n\t    !fib_rule_port_inrange(&rule->sport_range, fl6->fl6_sport))\n\t\treturn 0;\n\n\tif (fib_rule_port_range_set(&rule->dport_range) &&\n\t    !fib_rule_port_inrange(&rule->dport_range, fl6->fl6_dport))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic const struct nla_policy fib6_rule_policy[FRA_MAX+1] = {\n\tFRA_GENERIC_POLICY,\n};\n\nstatic int fib6_rule_configure(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t       struct fib_rule_hdr *frh,\n\t\t\t       struct nlattr **tb,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tint err = -EINVAL;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\n\n\tif (rule->action == FR_ACT_TO_TBL && !rule->l3mdev) {\n\t\tif (rule->table == RT6_TABLE_UNSPEC) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid table\");\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (fib6_new_table(net, rule->table) == NULL) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (frh->src_len)\n\t\trule6->src.addr = nla_get_in6_addr(tb[FRA_SRC]);\n\n\tif (frh->dst_len)\n\t\trule6->dst.addr = nla_get_in6_addr(tb[FRA_DST]);\n\n\trule6->src.plen = frh->src_len;\n\trule6->dst.plen = frh->dst_len;\n\trule6->tclass = frh->tos;\n\n\tif (fib_rule_requires_fldissect(rule))\n\t\tnet->ipv6.fib6_rules_require_fldissect++;\n\n\tnet->ipv6.fib6_has_custom_rules = true;\n\terr = 0;\nerrout:\n\treturn err;\n}\n\nstatic int fib6_rule_delete(struct fib_rule *rule)\n{\n\tstruct net *net = rule->fr_net;\n\n\tif (net->ipv6.fib6_rules_require_fldissect &&\n\t    fib_rule_requires_fldissect(rule))\n\t\tnet->ipv6.fib6_rules_require_fldissect--;\n\n\treturn 0;\n}\n\nstatic int fib6_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,\n\t\t\t     struct nlattr **tb)\n{\n\tstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\n\n\tif (frh->src_len && (rule6->src.plen != frh->src_len))\n\t\treturn 0;\n\n\tif (frh->dst_len && (rule6->dst.plen != frh->dst_len))\n\t\treturn 0;\n\n\tif (frh->tos && (rule6->tclass != frh->tos))\n\t\treturn 0;\n\n\tif (frh->src_len &&\n\t    nla_memcmp(tb[FRA_SRC], &rule6->src.addr, sizeof(struct in6_addr)))\n\t\treturn 0;\n\n\tif (frh->dst_len &&\n\t    nla_memcmp(tb[FRA_DST], &rule6->dst.addr, sizeof(struct in6_addr)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int fib6_rule_fill(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t  struct fib_rule_hdr *frh)\n{\n\tstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\n\n\tfrh->dst_len = rule6->dst.plen;\n\tfrh->src_len = rule6->src.plen;\n\tfrh->tos = rule6->tclass;\n\n\tif ((rule6->dst.plen &&\n\t     nla_put_in6_addr(skb, FRA_DST, &rule6->dst.addr)) ||\n\t    (rule6->src.plen &&\n\t     nla_put_in6_addr(skb, FRA_SRC, &rule6->src.addr)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic size_t fib6_rule_nlmsg_payload(struct fib_rule *rule)\n{\n\treturn nla_total_size(16) /* dst */\n\t       + nla_total_size(16); /* src */\n}\n\nstatic const struct fib_rules_ops __net_initconst fib6_rules_ops_template = {\n\t.family\t\t\t= AF_INET6,\n\t.rule_size\t\t= sizeof(struct fib6_rule),\n\t.addr_size\t\t= sizeof(struct in6_addr),\n\t.action\t\t\t= fib6_rule_action,\n\t.match\t\t\t= fib6_rule_match,\n\t.suppress\t\t= fib6_rule_suppress,\n\t.configure\t\t= fib6_rule_configure,\n\t.delete\t\t\t= fib6_rule_delete,\n\t.compare\t\t= fib6_rule_compare,\n\t.fill\t\t\t= fib6_rule_fill,\n\t.nlmsg_payload\t\t= fib6_rule_nlmsg_payload,\n\t.nlgroup\t\t= RTNLGRP_IPV6_RULE,\n\t.policy\t\t\t= fib6_rule_policy,\n\t.owner\t\t\t= THIS_MODULE,\n\t.fro_net\t\t= &init_net,\n};\n\nstatic int __net_init fib6_rules_net_init(struct net *net)\n{\n\tstruct fib_rules_ops *ops;\n\tint err = -ENOMEM;\n\n\tops = fib_rules_register(&fib6_rules_ops_template, net);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\terr = fib_default_rule_add(ops, 0, RT6_TABLE_LOCAL, 0);\n\tif (err)\n\t\tgoto out_fib6_rules_ops;\n\n\terr = fib_default_rule_add(ops, 0x7FFE, RT6_TABLE_MAIN, 0);\n\tif (err)\n\t\tgoto out_fib6_rules_ops;\n\n\tnet->ipv6.fib6_rules_ops = ops;\n\tnet->ipv6.fib6_rules_require_fldissect = 0;\nout:\n\treturn err;\n\nout_fib6_rules_ops:\n\tfib_rules_unregister(ops);\n\tgoto out;\n}\n\nstatic void __net_exit fib6_rules_net_exit(struct net *net)\n{\n\trtnl_lock();\n\tfib_rules_unregister(net->ipv6.fib6_rules_ops);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations fib6_rules_net_ops = {\n\t.init = fib6_rules_net_init,\n\t.exit = fib6_rules_net_exit,\n};\n\nint __init fib6_rules_init(void)\n{\n\treturn register_pernet_subsys(&fib6_rules_net_ops);\n}\n\n\nvoid fib6_rules_cleanup(void)\n{\n\tunregister_pernet_subsys(&fib6_rules_net_ops);\n}\n", "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# This test is for checking IPv4 and IPv6 FIB behavior in response to\n# different events.\n\nret=0\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\n# all tests in this script. Can be overridden with -t option\nTESTS=\"unregister down carrier nexthop ipv6_rt ipv4_rt ipv6_addr_metric ipv4_addr_metric ipv6_route_metrics ipv4_route_metrics ipv4_route_v6_gw rp_filter\"\n\nVERBOSE=0\nPAUSE_ON_FAIL=no\nPAUSE=no\nIP=\"ip -netns ns1\"\nNS_EXEC=\"ip netns exec ns1\"\n\nwhich ping6 > /dev/null 2>&1 && ping6=$(which ping6) || ping6=$(which ping)\n\nlog_test()\n{\n\tlocal rc=$1\n\tlocal expected=$2\n\tlocal msg=\"$3\"\n\n\tif [ ${rc} -eq ${expected} ]; then\n\t\tprintf \"    TEST: %-60s  [ OK ]\\n\" \"${msg}\"\n\t\tnsuccess=$((nsuccess+1))\n\telse\n\t\tret=1\n\t\tnfail=$((nfail+1))\n\t\tprintf \"    TEST: %-60s  [FAIL]\\n\" \"${msg}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\techo\n\t\t\techo \"hit enter to continue, 'q' to quit\"\n\t\t\tread a\n\t\t\t[ \"$a\" = \"q\" ] && exit 1\n\t\tfi\n\tfi\n\n\tif [ \"${PAUSE}\" = \"yes\" ]; then\n\t\techo\n\t\techo \"hit enter to continue, 'q' to quit\"\n\t\tread a\n\t\t[ \"$a\" = \"q\" ] && exit 1\n\tfi\n}\n\nsetup()\n{\n\tset -e\n\tip netns add ns1\n\tip netns set ns1 auto\n\t$IP link set dev lo up\n\tip netns exec ns1 sysctl -qw net.ipv4.ip_forward=1\n\tip netns exec ns1 sysctl -qw net.ipv6.conf.all.forwarding=1\n\n\t$IP link add dummy0 type dummy\n\t$IP link set dev dummy0 up\n\t$IP address add 198.51.100.1/24 dev dummy0\n\t$IP -6 address add 2001:db8:1::1/64 dev dummy0\n\tset +e\n\n}\n\ncleanup()\n{\n\t$IP link del dev dummy0 &> /dev/null\n\tip netns del ns1\n\tip netns del ns2 &> /dev/null\n}\n\nget_linklocal()\n{\n\tlocal dev=$1\n\tlocal addr\n\n\taddr=$($IP -6 -br addr show dev ${dev} | \\\n\tawk '{\n\t\tfor (i = 3; i <= NF; ++i) {\n\t\t\tif ($i ~ /^fe80/)\n\t\t\t\tprint $i\n\t\t}\n\t}'\n\t)\n\taddr=${addr/\\/*}\n\n\t[ -z \"$addr\" ] && return 1\n\n\techo $addr\n\n\treturn 0\n}\n\nfib_unreg_unicast_test()\n{\n\techo\n\techo \"Single path route test\"\n\n\tsetup\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link del dev dummy0\n\tset +e\n\n\techo \"    Nexthop device deleted\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch - no route\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch - no route\"\n\n\tcleanup\n}\n\nfib_unreg_multipath_test()\n{\n\n\techo\n\techo \"Multipath route test\"\n\n\tsetup\n\n\tset -e\n\t$IP link add dummy1 type dummy\n\t$IP link set dev dummy1 up\n\t$IP address add 192.0.2.1/24 dev dummy1\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy1\n\n\t$IP route add 203.0.113.0/24 \\\n\t\tnexthop via 198.51.100.2 dev dummy0 \\\n\t\tnexthop via 192.0.2.2 dev dummy1\n\t$IP -6 route add 2001:db8:3::/64 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy0 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy1\n\tset +e\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link del dev dummy0\n\tset +e\n\n\techo \"    One nexthop device deleted\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 2 \"IPv4 - multipath route removed on delete\"\n\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\t# In IPv6 we do not flush the entire multipath route.\n\tlog_test $? 0 \"IPv6 - multipath down to single path\"\n\n\tset -e\n\t$IP link del dev dummy1\n\tset +e\n\n\techo \"    Second nexthop device deleted\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 2 \"IPv6 - no route\"\n\n\tcleanup\n}\n\nfib_unreg_test()\n{\n\tfib_unreg_unicast_test\n\tfib_unreg_multipath_test\n}\n\nfib_down_unicast_test()\n{\n\techo\n\techo \"Single path, admin down\"\n\n\tsetup\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link set dev dummy0 down\n\tset +e\n\n\techo \"    Route deleted on down\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch\"\n\n\tcleanup\n}\n\nfib_down_multipath_test_do()\n{\n\tlocal down_dev=$1\n\tlocal up_dev=$2\n\n\t$IP route get fibmatch 203.0.113.1 \\\n\t\toif $down_dev &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch on down device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 \\\n\t\toif $down_dev &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch on down device\"\n\n\t$IP route get fibmatch 203.0.113.1 \\\n\t\toif $up_dev &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch on up device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 \\\n\t\toif $up_dev &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch on up device\"\n\n\t$IP route get fibmatch 203.0.113.1 | \\\n\t\tgrep $down_dev | grep -q \"dead linkdown\"\n\tlog_test $? 0 \"IPv4 flags on down device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 | \\\n\t\tgrep $down_dev | grep -q \"dead linkdown\"\n\tlog_test $? 0 \"IPv6 flags on down device\"\n\n\t$IP route get fibmatch 203.0.113.1 | \\\n\t\tgrep $up_dev | grep -q \"dead linkdown\"\n\tlog_test $? 1 \"IPv4 flags on up device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 | \\\n\t\tgrep $up_dev | grep -q \"dead linkdown\"\n\tlog_test $? 1 \"IPv6 flags on up device\"\n}\n\nfib_down_multipath_test()\n{\n\techo\n\techo \"Admin down multipath\"\n\n\tsetup\n\n\tset -e\n\t$IP link add dummy1 type dummy\n\t$IP link set dev dummy1 up\n\n\t$IP address add 192.0.2.1/24 dev dummy1\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy1\n\n\t$IP route add 203.0.113.0/24 \\\n\t\tnexthop via 198.51.100.2 dev dummy0 \\\n\t\tnexthop via 192.0.2.2 dev dummy1\n\t$IP -6 route add 2001:db8:3::/64 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy0 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy1\n\tset +e\n\n\techo \"    Verify start point\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link set dev dummy0 down\n\tset +e\n\n\techo \"    One device down, one up\"\n\tfib_down_multipath_test_do \"dummy0\" \"dummy1\"\n\n\tset -e\n\t$IP link set dev dummy0 up\n\t$IP link set dev dummy1 down\n\tset +e\n\n\techo \"    Other device down and up\"\n\tfib_down_multipath_test_do \"dummy1\" \"dummy0\"\n\n\tset -e\n\t$IP link set dev dummy0 down\n\tset +e\n\n\techo \"    Both devices down\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch\"\n\n\t$IP link del dev dummy1\n\tcleanup\n}\n\nfib_down_test()\n{\n\tfib_down_unicast_test\n\tfib_down_multipath_test\n}\n\n# Local routes should not be affected when carrier changes.\nfib_carrier_local_test()\n{\n\techo\n\techo \"Local carrier tests - single path\"\n\n\tsetup\n\n\tset -e\n\t$IP link set dev dummy0 carrier on\n\tset +e\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 - no linkdown flag\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 - no linkdown flag\"\n\n\tset -e\n\t$IP link set dev dummy0 carrier off\n\tsleep 1\n\tset +e\n\n\techo \"    Carrier off on nexthop\"\n\t$IP route get fibmatch 198.51.100.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 - linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 - linkdown flag set\"\n\n\tset -e\n\t$IP address add 192.0.2.1/24 dev dummy0\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy0\n\tset +e\n\n\techo \"    Route to local address with carrier down\"\n\t$IP route get fibmatch 192.0.2.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:2::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 192.0.2.1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:2::1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 linkdown flag set\"\n\n\tcleanup\n}\n\nfib_carrier_unicast_test()\n{\n\tret=0\n\n\techo\n\techo \"Single path route carrier test\"\n\n\tsetup\n\n\tset -e\n\t$IP link set dev dummy0 carrier on\n\tset +e\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 no linkdown flag\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 no linkdown flag\"\n\n\tset -e\n\t$IP link set dev dummy0 carrier off\n\tsleep 1\n\tset +e\n\n\techo \"    Carrier down\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv4 linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv6 linkdown flag set\"\n\n\tset -e\n\t$IP address add 192.0.2.1/24 dev dummy0\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy0\n\tset +e\n\n\techo \"    Second address added with carrier down\"\n\t$IP route get fibmatch 192.0.2.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:2::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 192.0.2.2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv4 linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:2::2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv6 linkdown flag set\"\n\n\tcleanup\n}\n\nfib_carrier_test()\n{\n\tfib_carrier_local_test\n\tfib_carrier_unicast_test\n}\n\nfib_rp_filter_test()\n{\n\techo\n\techo \"IPv4 rp_filter tests\"\n\n\tsetup\n\n\tset -e\n\t$IP link set dev lo address 52:54:00:6a:c7:5e\n\t$IP link set dummy0 address 52:54:00:6a:c7:5e\n\t$IP link add dummy1 type dummy\n\t$IP link set dummy1 address 52:54:00:6a:c7:5e\n\t$IP link set dev dummy1 up\n\t$NS_EXEC sysctl -qw net.ipv4.conf.all.rp_filter=1\n\t$NS_EXEC sysctl -qw net.ipv4.conf.all.accept_local=1\n\t$NS_EXEC sysctl -qw net.ipv4.conf.all.route_localnet=1\n\n\t$NS_EXEC tc qd add dev dummy1 parent root handle 1: fq_codel\n\t$NS_EXEC tc filter add dev dummy1 parent 1: protocol arp basic action mirred egress redirect dev lo\n\t$NS_EXEC tc filter add dev dummy1 parent 1: protocol ip basic action mirred egress redirect dev lo\n\tset +e\n\n\trun_cmd \"ip netns exec ns1 ping -I dummy1 -w1 -c1 198.51.100.1\"\n\tlog_test $? 0 \"rp_filter passes local packets\"\n\n\trun_cmd \"ip netns exec ns1 ping -I dummy1 -w1 -c1 127.0.0.1\"\n\tlog_test $? 0 \"rp_filter passes loopback packets\"\n\n\tcleanup\n}\n\n################################################################################\n# Tests on nexthop spec\n\n# run 'ip route add' with given spec\nadd_rt()\n{\n\tlocal desc=\"$1\"\n\tlocal erc=$2\n\tlocal vrf=$3\n\tlocal pfx=$4\n\tlocal gw=$5\n\tlocal dev=$6\n\tlocal cmd out rc\n\n\t[ \"$vrf\" = \"-\" ] && vrf=\"default\"\n\t[ -n \"$gw\" ] && gw=\"via $gw\"\n\t[ -n \"$dev\" ] && dev=\"dev $dev\"\n\n\tcmd=\"$IP route add vrf $vrf $pfx $gw $dev\"\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\tprintf \"\\n    COMMAND: $cmd\\n\"\n\tfi\n\n\tout=$(eval $cmd 2>&1)\n\trc=$?\n\tif [ \"$VERBOSE\" = \"1\" -a -n \"$out\" ]; then\n\t\techo \"    $out\"\n\tfi\n\tlog_test $rc $erc \"$desc\"\n}\n\nfib4_nexthop()\n{\n\techo\n\techo \"IPv4 nexthop tests\"\n\n\techo \"<<< write me >>>\"\n}\n\nfib6_nexthop()\n{\n\tlocal lldummy=$(get_linklocal dummy0)\n\tlocal llv1=$(get_linklocal dummy0)\n\n\tif [ -z \"$lldummy\" ]; then\n\t\techo \"Failed to get linklocal address for dummy0\"\n\t\treturn 1\n\tfi\n\tif [ -z \"$llv1\" ]; then\n\t\techo \"Failed to get linklocal address for veth1\"\n\t\treturn 1\n\tfi\n\n\techo\n\techo \"IPv6 nexthop tests\"\n\n\tadd_rt \"Directly connected nexthop, unicast address\" 0 \\\n\t\t- 2001:db8:101::/64 2001:db8:1::2\n\tadd_rt \"Directly connected nexthop, unicast address with device\" 0 \\\n\t\t- 2001:db8:102::/64 2001:db8:1::2 \"dummy0\"\n\tadd_rt \"Gateway is linklocal address\" 0 \\\n\t\t- 2001:db8:103::1/64 $llv1 \"veth0\"\n\n\t# fails because LL address requires a device\n\tadd_rt \"Gateway is linklocal address, no device\" 2 \\\n\t\t- 2001:db8:104::1/64 $llv1\n\n\t# local address can not be a gateway\n\tadd_rt \"Gateway can not be local unicast address\" 2 \\\n\t\t- 2001:db8:105::/64 2001:db8:1::1\n\tadd_rt \"Gateway can not be local unicast address, with device\" 2 \\\n\t\t- 2001:db8:106::/64 2001:db8:1::1 \"dummy0\"\n\tadd_rt \"Gateway can not be a local linklocal address\" 2 \\\n\t\t- 2001:db8:107::1/64 $lldummy \"dummy0\"\n\n\t# VRF tests\n\tadd_rt \"Gateway can be local address in a VRF\" 0 \\\n\t\t- 2001:db8:108::/64 2001:db8:51::2\n\tadd_rt \"Gateway can be local address in a VRF, with device\" 0 \\\n\t\t- 2001:db8:109::/64 2001:db8:51::2 \"veth0\"\n\tadd_rt \"Gateway can be local linklocal address in a VRF\" 0 \\\n\t\t- 2001:db8:110::1/64 $llv1 \"veth0\"\n\n\tadd_rt \"Redirect to VRF lookup\" 0 \\\n\t\t- 2001:db8:111::/64 \"\" \"red\"\n\n\tadd_rt \"VRF route, gateway can be local address in default VRF\" 0 \\\n\t\tred 2001:db8:112::/64 2001:db8:51::1\n\n\t# local address in same VRF fails\n\tadd_rt \"VRF route, gateway can not be a local address\" 2 \\\n\t\tred 2001:db8:113::1/64 2001:db8:2::1\n\tadd_rt \"VRF route, gateway can not be a local addr with device\" 2 \\\n\t\tred 2001:db8:114::1/64 2001:db8:2::1 \"dummy1\"\n}\n\n# Default VRF:\n#   dummy0 - 198.51.100.1/24 2001:db8:1::1/64\n#   veth0  - 192.0.2.1/24    2001:db8:51::1/64\n#\n# VRF red:\n#   dummy1 - 192.168.2.1/24 2001:db8:2::1/64\n#   veth1  - 192.0.2.2/24   2001:db8:51::2/64\n#\n#  [ dummy0   veth0 ]--[ veth1   dummy1 ]\n\nfib_nexthop_test()\n{\n\tsetup\n\n\tset -e\n\n\t$IP -4 rule add pref 32765 table local\n\t$IP -4 rule del pref 0\n\t$IP -6 rule add pref 32765 table local\n\t$IP -6 rule del pref 0\n\n\t$IP link add red type vrf table 1\n\t$IP link set red up\n\t$IP -4 route add vrf red unreachable default metric 4278198272\n\t$IP -6 route add vrf red unreachable default metric 4278198272\n\n\t$IP link add veth0 type veth peer name veth1\n\t$IP link set dev veth0 up\n\t$IP address add 192.0.2.1/24 dev veth0\n\t$IP -6 address add 2001:db8:51::1/64 dev veth0\n\n\t$IP link set dev veth1 vrf red up\n\t$IP address add 192.0.2.2/24 dev veth1\n\t$IP -6 address add 2001:db8:51::2/64 dev veth1\n\n\t$IP link add dummy1 type dummy\n\t$IP link set dev dummy1 vrf red up\n\t$IP address add 192.168.2.1/24 dev dummy1\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy1\n\tset +e\n\n\tsleep 1\n\tfib4_nexthop\n\tfib6_nexthop\n\n\t(\n\t$IP link del dev dummy1\n\t$IP link del veth0\n\t$IP link del red\n\t) 2>/dev/null\n\tcleanup\n}\n\n################################################################################\n# Tests on route add and replace\n\nrun_cmd()\n{\n\tlocal cmd=\"$1\"\n\tlocal out\n\tlocal stderr=\"2>/dev/null\"\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\tprintf \"    COMMAND: $cmd\\n\"\n\t\tstderr=\n\tfi\n\n\tout=$(eval $cmd $stderr)\n\trc=$?\n\tif [ \"$VERBOSE\" = \"1\" -a -n \"$out\" ]; then\n\t\techo \"    $out\"\n\tfi\n\n\t[ \"$VERBOSE\" = \"1\" ] && echo\n\n\treturn $rc\n}\n\ncheck_expected()\n{\n\tlocal out=\"$1\"\n\tlocal expected=\"$2\"\n\tlocal rc=0\n\n\t[ \"${out}\" = \"${expected}\" ] && return 0\n\n\tif [ -z \"${out}\" ]; then\n\t\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\t\tprintf \"\\nNo route entry found\\n\"\n\t\t\tprintf \"Expected:\\n\"\n\t\t\tprintf \"    ${expected}\\n\"\n\t\tfi\n\t\treturn 1\n\tfi\n\n\t# tricky way to convert output to 1-line without ip's\n\t# messy '\\'; this drops all extra white space\n\tout=$(echo ${out})\n\tif [ \"${out}\" != \"${expected}\" ]; then\n\t\trc=1\n\t\tif [ \"${VERBOSE}\" = \"1\" ]; then\n\t\t\tprintf \"    Unexpected route entry. Have:\\n\"\n\t\t\tprintf \"        ${out}\\n\"\n\t\t\tprintf \"    Expected:\\n\"\n\t\t\tprintf \"        ${expected}\\n\\n\"\n\t\tfi\n\tfi\n\n\treturn $rc\n}\n\n# add route for a prefix, flushing any existing routes first\n# expected to be the first step of a test\nadd_route6()\n{\n\tlocal pfx=\"$1\"\n\tlocal nh=\"$2\"\n\tlocal out\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\techo\n\t\techo \"    ##################################################\"\n\t\techo\n\tfi\n\n\trun_cmd \"$IP -6 ro flush ${pfx}\"\n\t[ $? -ne 0 ] && exit 1\n\n\tout=$($IP -6 ro ls match ${pfx})\n\tif [ -n \"$out\" ]; then\n\t\techo \"Failed to flush routes for prefix used for tests.\"\n\t\texit 1\n\tfi\n\n\trun_cmd \"$IP -6 ro add ${pfx} ${nh}\"\n\tif [ $? -ne 0 ]; then\n\t\techo \"Failed to add initial route for test.\"\n\t\texit 1\n\tfi\n}\n\n# add initial route - used in replace route tests\nadd_initial_route6()\n{\n\tadd_route6 \"2001:db8:104::/64\" \"$1\"\n}\n\ncheck_route6()\n{\n\tlocal pfx\n\tlocal expected=\"$1\"\n\tlocal out\n\tlocal rc=0\n\n\tset -- $expected\n\tpfx=$1\n\n\tout=$($IP -6 ro ls match ${pfx} | sed -e 's/ pref medium//')\n\tcheck_expected \"${out}\" \"${expected}\"\n}\n\nroute_cleanup()\n{\n\t$IP li del red 2>/dev/null\n\t$IP li del dummy1 2>/dev/null\n\t$IP li del veth1 2>/dev/null\n\t$IP li del veth3 2>/dev/null\n\n\tcleanup &> /dev/null\n}\n\nroute_setup()\n{\n\troute_cleanup\n\tsetup\n\n\t[ \"${VERBOSE}\" = \"1\" ] && set -x\n\tset -e\n\n\tip netns add ns2\n\tip netns set ns2 auto\n\tip -netns ns2 link set dev lo up\n\tip netns exec ns2 sysctl -qw net.ipv4.ip_forward=1\n\tip netns exec ns2 sysctl -qw net.ipv6.conf.all.forwarding=1\n\n\t$IP li add veth1 type veth peer name veth2\n\t$IP li add veth3 type veth peer name veth4\n\n\t$IP li set veth1 up\n\t$IP li set veth3 up\n\t$IP li set veth2 netns ns2 up\n\t$IP li set veth4 netns ns2 up\n\tip -netns ns2 li add dummy1 type dummy\n\tip -netns ns2 li set dummy1 up\n\n\t$IP -6 addr add 2001:db8:101::1/64 dev veth1 nodad\n\t$IP -6 addr add 2001:db8:103::1/64 dev veth3 nodad\n\t$IP addr add 172.16.101.1/24 dev veth1\n\t$IP addr add 172.16.103.1/24 dev veth3\n\n\tip -netns ns2 -6 addr add 2001:db8:101::2/64 dev veth2 nodad\n\tip -netns ns2 -6 addr add 2001:db8:103::2/64 dev veth4 nodad\n\tip -netns ns2 -6 addr add 2001:db8:104::1/64 dev dummy1 nodad\n\n\tip -netns ns2 addr add 172.16.101.2/24 dev veth2\n\tip -netns ns2 addr add 172.16.103.2/24 dev veth4\n\tip -netns ns2 addr add 172.16.104.1/24 dev dummy1\n\n\tset +e\n}\n\n# assumption is that basic add of a single path route works\n# otherwise just adding an address on an interface is broken\nipv6_rt_add()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv6 route add / append tests\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 via 2001:db8:103::2\"\n\tlog_test $? 2 \"Attempt to add duplicate route - gw\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 dev veth3\"\n\tlog_test $? 2 \"Attempt to add duplicate route - dev only\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add unreachable 2001:db8:104::/64\"\n\tlog_test $? 2 \"Attempt to add duplicate route - reject route\"\n\n\t# route append with same prefix adds a new route\n\t# - iproute2 sets NLM_F_CREATE | NLM_F_APPEND\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro append 2001:db8:104::/64 via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Append nexthop to existing route - gw\"\n\n\t# insert mpath directly\n\tadd_route6 \"2001:db8:104::/64\" \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Add multipath route\"\n\n\tadd_route6 \"2001:db8:104::/64\" \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\tlog_test $? 2 \"Attempt to add duplicate multipath route\"\n\n\t# insert of a second route without append but different metric\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 via 2001:db8:103::2 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 via 2001:db8:103::3 metric 256\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route add with different metrics\"\n\n\trun_cmd \"$IP -6 ro del 2001:db8:104::/64 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:103::3 dev veth3 metric 256 2001:db8:104::/64 via 2001:db8:101::2 dev veth1 metric 1024\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route delete with metric\"\n}\n\nipv6_rt_replace_single()\n{\n\t# single path with single path\n\t#\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:103::2 dev veth3 metric 1024\"\n\tlog_test $? 0 \"Single path with single path\"\n\n\t# single path with multipath\n\t#\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::3 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Single path with multipath\"\n\n\t# single path with single path using MULTIPATH attribute\n\t#\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:103::2 dev veth3 metric 1024\"\n\tlog_test $? 0 \"Single path with single path via multipath attribute\"\n\n\t# route replace fails - invalid nexthop\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 via 2001:db8:104::2\"\n\tif [ $? -eq 0 ]; then\n\t\t# previous command is expected to fail so if it returns 0\n\t\t# that means the test failed.\n\t\tlog_test 0 1 \"Invalid nexthop\"\n\telse\n\t\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:101::2 dev veth1 metric 1024\"\n\t\tlog_test $? 0 \"Invalid nexthop\"\n\tfi\n\n\t# replace non-existent route\n\t# - note use of change versus replace since ip adds NLM_F_CREATE\n\t#   for replace\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro change 2001:db8:105::/64 via 2001:db8:101::2\"\n\tlog_test $? 2 \"Single path - replace of non-existent route\"\n}\n\nipv6_rt_replace_mpath()\n{\n\t# multipath with multipath\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:103::3\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::3 dev veth1 weight 1 nexthop via 2001:db8:103::3 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath with multipath\"\n\n\t# multipath with single\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 via 2001:db8:101::3\"\n\tcheck_route6  \"2001:db8:104::/64 via 2001:db8:101::3 dev veth1 metric 1024\"\n\tlog_test $? 0 \"Multipath with single path\"\n\n\t# multipath with single\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3\"\n\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:101::3 dev veth1 metric 1024\"\n\tlog_test $? 0 \"Multipath with single path via multipath attribute\"\n\n\t# route replace fails - invalid nexthop 1\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:111::3 nexthop via 2001:db8:103::3\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid first nexthop\"\n\n\t# route replace fails - invalid nexthop 2\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:113::3\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid second nexthop\"\n\n\t# multipath non-existent route\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro change 2001:db8:105::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:103::3\"\n\tlog_test $? 2 \"Multipath - replace of non-existent route\"\n}\n\nipv6_rt_replace()\n{\n\techo\n\techo \"IPv6 route replace tests\"\n\n\tipv6_rt_replace_single\n\tipv6_rt_replace_mpath\n}\n\nipv6_route_test()\n{\n\troute_setup\n\n\tipv6_rt_add\n\tipv6_rt_replace\n\n\troute_cleanup\n}\n\nip_addr_metric_check()\n{\n\tip addr help 2>&1 | grep -q metric\n\tif [ $? -ne 0 ]; then\n\t\techo \"iproute2 command does not support metric for addresses. Skipping test\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\nipv6_addr_metric_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv6 prefix route tests\"\n\n\tip_addr_metric_check || return 1\n\n\tsetup\n\n\tset -e\n\t$IP li add dummy1 type dummy\n\t$IP li add dummy2 type dummy\n\t$IP li set dummy1 up\n\t$IP li set dummy2 up\n\n\t# default entry is metric 256\n\trun_cmd \"$IP -6 addr add dev dummy1 2001:db8:104::1/64\"\n\trun_cmd \"$IP -6 addr add dev dummy2 2001:db8:104::2/64\"\n\tset +e\n\n\tcheck_route6 \"2001:db8:104::/64 dev dummy1 proto kernel metric 256 2001:db8:104::/64 dev dummy2 proto kernel metric 256\"\n\tlog_test $? 0 \"Default metric\"\n\n\tset -e\n\trun_cmd \"$IP -6 addr flush dev dummy1\"\n\trun_cmd \"$IP -6 addr add dev dummy1 2001:db8:104::1/64 metric 257\"\n\tset +e\n\n\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 256 2001:db8:104::/64 dev dummy1 proto kernel metric 257\"\n\tlog_test $? 0 \"User specified metric on first device\"\n\n\tset -e\n\trun_cmd \"$IP -6 addr flush dev dummy2\"\n\trun_cmd \"$IP -6 addr add dev dummy2 2001:db8:104::2/64 metric 258\"\n\tset +e\n\n\tcheck_route6 \"2001:db8:104::/64 dev dummy1 proto kernel metric 257 2001:db8:104::/64 dev dummy2 proto kernel metric 258\"\n\tlog_test $? 0 \"User specified metric on second device\"\n\n\trun_cmd \"$IP -6 addr del dev dummy1 2001:db8:104::1/64 metric 257\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 258\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Delete of address on first device\"\n\n\trun_cmd \"$IP -6 addr change dev dummy2 2001:db8:104::2/64 metric 259\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Modify metric of address\"\n\n\t# verify prefix route removed on down\n\trun_cmd \"ip netns exec ns1 sysctl -qw net.ipv6.conf.all.keep_addr_on_down=1\"\n\trun_cmd \"$IP li set dev dummy2 down\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tout=$($IP -6 ro ls match 2001:db8:104::/64)\n\t\tcheck_expected \"${out}\" \"\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route removed on link down\"\n\n\t# verify prefix route re-inserted with assigned metric\n\trun_cmd \"$IP li set dev dummy2 up\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route with metric on link up\"\n\n\t$IP li del dummy1\n\t$IP li del dummy2\n\tcleanup\n}\n\nipv6_route_metrics_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv6 routes with metrics\"\n\n\troute_setup\n\n\t#\n\t# single path with metrics\n\t#\n\trun_cmd \"$IP -6 ro add 2001:db8:111::/64 via 2001:db8:101::2 mtu 1400\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6  \"2001:db8:111::/64 via 2001:db8:101::2 dev veth1 metric 1024 mtu 1400\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Single path route with mtu metric\"\n\n\n\t#\n\t# multipath via separate routes with metrics\n\t#\n\trun_cmd \"$IP -6 ro add 2001:db8:112::/64 via 2001:db8:101::2 mtu 1400\"\n\trun_cmd \"$IP -6 ro append 2001:db8:112::/64 via 2001:db8:103::2\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:112::/64 metric 1024 mtu 1400 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route via 2 single routes with mtu metric on first\"\n\n\t# second route is coalesced to first to make a multipath route.\n\t# MTU of the second path is hidden from display!\n\trun_cmd \"$IP -6 ro add 2001:db8:113::/64 via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro append 2001:db8:113::/64 via 2001:db8:103::2 mtu 1400\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:113::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route via 2 single routes with mtu metric on 2nd\"\n\n\trun_cmd \"$IP -6 ro del 2001:db8:113::/64 via 2001:db8:101::2\"\n\tif [ $? -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:113::/64 via 2001:db8:103::2 dev veth3 metric 1024 mtu 1400\"\n\t\tlog_test $? 0 \"    MTU of second leg\"\n\tfi\n\n\t#\n\t# multipath with metrics\n\t#\n\trun_cmd \"$IP -6 ro add 2001:db8:115::/64 mtu 1400 nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6  \"2001:db8:115::/64 metric 1024 mtu 1400 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route with mtu metric\"\n\n\t$IP -6 ro add 2001:db8:104::/64 via 2001:db8:101::2 mtu 1300\n\trun_cmd \"ip netns exec ns1 ${ping6} -w1 -c1 -s 1500 2001:db8:104::1\"\n\tlog_test $? 0 \"Using route with mtu metric\"\n\n\trun_cmd \"$IP -6 ro add 2001:db8:114::/64 via  2001:db8:101::2  congctl lock foo\"\n\tlog_test $? 2 \"Invalid metric (fails metric_convert)\"\n\n\troute_cleanup\n}\n\n# add route for a prefix, flushing any existing routes first\n# expected to be the first step of a test\nadd_route()\n{\n\tlocal pfx=\"$1\"\n\tlocal nh=\"$2\"\n\tlocal out\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\techo\n\t\techo \"    ##################################################\"\n\t\techo\n\tfi\n\n\trun_cmd \"$IP ro flush ${pfx}\"\n\t[ $? -ne 0 ] && exit 1\n\n\tout=$($IP ro ls match ${pfx})\n\tif [ -n \"$out\" ]; then\n\t\techo \"Failed to flush routes for prefix used for tests.\"\n\t\texit 1\n\tfi\n\n\trun_cmd \"$IP ro add ${pfx} ${nh}\"\n\tif [ $? -ne 0 ]; then\n\t\techo \"Failed to add initial route for test.\"\n\t\texit 1\n\tfi\n}\n\n# add initial route - used in replace route tests\nadd_initial_route()\n{\n\tadd_route \"172.16.104.0/24\" \"$1\"\n}\n\ncheck_route()\n{\n\tlocal pfx\n\tlocal expected=\"$1\"\n\tlocal out\n\n\tset -- $expected\n\tpfx=$1\n\t[ \"${pfx}\" = \"unreachable\" ] && pfx=$2\n\n\tout=$($IP ro ls match ${pfx})\n\tcheck_expected \"${out}\" \"${expected}\"\n}\n\n# assumption is that basic add of a single path route works\n# otherwise just adding an address on an interface is broken\nipv4_rt_add()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 route add / append tests\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 via 172.16.103.2\"\n\tlog_test $? 2 \"Attempt to add duplicate route - gw\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 dev veth3\"\n\tlog_test $? 2 \"Attempt to add duplicate route - dev only\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add unreachable 172.16.104.0/24\"\n\tlog_test $? 2 \"Attempt to add duplicate route - reject route\"\n\n\t# iproute2 prepend only sets NLM_F_CREATE\n\t# - adds a new route; does NOT convert existing route to ECMP\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro prepend 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.103.2 dev veth3 172.16.104.0/24 via 172.16.101.2 dev veth1\"\n\tlog_test $? 0 \"Add new nexthop for existing prefix\"\n\n\t# route append with same prefix adds a new route\n\t# - iproute2 sets NLM_F_CREATE | NLM_F_APPEND\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Append nexthop to existing route - gw\"\n\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 dev veth3\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 172.16.104.0/24 dev veth3 scope link\"\n\tlog_test $? 0 \"Append nexthop to existing route - dev only\"\n\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro append unreachable 172.16.104.0/24\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 unreachable 172.16.104.0/24\"\n\tlog_test $? 0 \"Append nexthop to existing route - reject route\"\n\n\trun_cmd \"$IP ro flush 172.16.104.0/24\"\n\trun_cmd \"$IP ro add unreachable 172.16.104.0/24\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"unreachable 172.16.104.0/24 172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Append nexthop to existing reject route - gw\"\n\n\trun_cmd \"$IP ro flush 172.16.104.0/24\"\n\trun_cmd \"$IP ro add unreachable 172.16.104.0/24\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 dev veth3\"\n\tcheck_route \"unreachable 172.16.104.0/24 172.16.104.0/24 dev veth3 scope link\"\n\tlog_test $? 0 \"Append nexthop to existing reject route - dev only\"\n\n\t# insert mpath directly\n\tadd_route \"172.16.104.0/24\" \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"add multipath route\"\n\n\tadd_route \"172.16.104.0/24\" \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\tlog_test $? 2 \"Attempt to add duplicate multipath route\"\n\n\t# insert of a second route without append but different metric\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 via 172.16.103.2 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\trun_cmd \"$IP ro add 172.16.104.0/24 via 172.16.103.3 metric 256\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route add with different metrics\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 172.16.104.0/24 via 172.16.103.3 dev veth3 metric 256\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route delete with metric\"\n}\n\nipv4_rt_replace_single()\n{\n\t# single path with single path\n\t#\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Single path with single path\"\n\n\t# single path with multipath\n\t#\n\tadd_initial_route \"nexthop via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3 nexthop via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 nexthop via 172.16.101.3 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Single path with multipath\"\n\n\t# single path with reject\n\t#\n\tadd_initial_route \"nexthop via 172.16.101.2\"\n\trun_cmd \"$IP ro replace unreachable 172.16.104.0/24\"\n\tcheck_route \"unreachable 172.16.104.0/24\"\n\tlog_test $? 0 \"Single path with reject route\"\n\n\t# single path with single path using MULTIPATH attribute\n\t#\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Single path with single path via multipath attribute\"\n\n\t# route replace fails - invalid nexthop\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 via 2001:db8:104::2\"\n\tif [ $? -eq 0 ]; then\n\t\t# previous command is expected to fail so if it returns 0\n\t\t# that means the test failed.\n\t\tlog_test 0 1 \"Invalid nexthop\"\n\telse\n\t\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1\"\n\t\tlog_test $? 0 \"Invalid nexthop\"\n\tfi\n\n\t# replace non-existent route\n\t# - note use of change versus replace since ip adds NLM_F_CREATE\n\t#   for replace\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro change 172.16.105.0/24 via 172.16.101.2\"\n\tlog_test $? 2 \"Single path - replace of non-existent route\"\n}\n\nipv4_rt_replace_mpath()\n{\n\t# multipath with multipath\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3 nexthop via 172.16.103.3\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.3 dev veth1 weight 1 nexthop via 172.16.103.3 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath with multipath\"\n\n\t# multipath with single\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 via 172.16.101.3\"\n\tcheck_route  \"172.16.104.0/24 via 172.16.101.3 dev veth1\"\n\tlog_test $? 0 \"Multipath with single path\"\n\n\t# multipath with single\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.3 dev veth1\"\n\tlog_test $? 0 \"Multipath with single path via multipath attribute\"\n\n\t# multipath with reject\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace unreachable 172.16.104.0/24\"\n\tcheck_route \"unreachable 172.16.104.0/24\"\n\tlog_test $? 0 \"Multipath with reject route\"\n\n\t# route replace fails - invalid nexthop 1\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.111.3 nexthop via 172.16.103.3\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid first nexthop\"\n\n\t# route replace fails - invalid nexthop 2\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3 nexthop via 172.16.113.3\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid second nexthop\"\n\n\t# multipath non-existent route\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro change 172.16.105.0/24 nexthop via 172.16.101.3 nexthop via 172.16.103.3\"\n\tlog_test $? 2 \"Multipath - replace of non-existent route\"\n}\n\nipv4_rt_replace()\n{\n\techo\n\techo \"IPv4 route replace tests\"\n\n\tipv4_rt_replace_single\n\tipv4_rt_replace_mpath\n}\n\nipv4_route_test()\n{\n\troute_setup\n\n\tipv4_rt_add\n\tipv4_rt_replace\n\n\troute_cleanup\n}\n\nipv4_addr_metric_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 prefix route tests\"\n\n\tip_addr_metric_check || return 1\n\n\tsetup\n\n\tset -e\n\t$IP li add dummy1 type dummy\n\t$IP li add dummy2 type dummy\n\t$IP li set dummy1 up\n\t$IP li set dummy2 up\n\n\t# default entry is metric 256\n\trun_cmd \"$IP addr add dev dummy1 172.16.104.1/24\"\n\trun_cmd \"$IP addr add dev dummy2 172.16.104.2/24\"\n\tset +e\n\n\tcheck_route \"172.16.104.0/24 dev dummy1 proto kernel scope link src 172.16.104.1 172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2\"\n\tlog_test $? 0 \"Default metric\"\n\n\tset -e\n\trun_cmd \"$IP addr flush dev dummy1\"\n\trun_cmd \"$IP addr add dev dummy1 172.16.104.1/24 metric 257\"\n\tset +e\n\n\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 172.16.104.0/24 dev dummy1 proto kernel scope link src 172.16.104.1 metric 257\"\n\tlog_test $? 0 \"User specified metric on first device\"\n\n\tset -e\n\trun_cmd \"$IP addr flush dev dummy2\"\n\trun_cmd \"$IP addr add dev dummy2 172.16.104.2/24 metric 258\"\n\tset +e\n\n\tcheck_route \"172.16.104.0/24 dev dummy1 proto kernel scope link src 172.16.104.1 metric 257 172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 258\"\n\tlog_test $? 0 \"User specified metric on second device\"\n\n\trun_cmd \"$IP addr del dev dummy1 172.16.104.1/24 metric 257\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 258\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Delete of address on first device\"\n\n\trun_cmd \"$IP addr change dev dummy2 172.16.104.2/24 metric 259\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Modify metric of address\"\n\n\t# verify prefix route removed on down\n\trun_cmd \"$IP li set dev dummy2 down\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tout=$($IP ro ls match 172.16.104.0/24)\n\t\tcheck_expected \"${out}\" \"\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route removed on link down\"\n\n\t# verify prefix route re-inserted with assigned metric\n\trun_cmd \"$IP li set dev dummy2 up\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route with metric on link up\"\n\n\t$IP li del dummy1\n\t$IP li del dummy2\n\tcleanup\n}\n\nipv4_route_metrics_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 route add / append tests\"\n\n\troute_setup\n\n\trun_cmd \"$IP ro add 172.16.111.0/24 via 172.16.101.2 mtu 1400\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.111.0/24 via 172.16.101.2 dev veth1 mtu 1400\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Single path route with mtu metric\"\n\n\n\trun_cmd \"$IP ro add 172.16.112.0/24 mtu 1400 nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.112.0/24 mtu 1400 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route with mtu metric\"\n\n\t$IP ro add 172.16.104.0/24 via 172.16.101.2 mtu 1300\n\trun_cmd \"ip netns exec ns1 ping -w1 -c1 -s 1500 172.16.104.1\"\n\tlog_test $? 0 \"Using route with mtu metric\"\n\n\trun_cmd \"$IP ro add 172.16.111.0/24 via 172.16.101.2 congctl lock foo\"\n\tlog_test $? 2 \"Invalid metric (fails metric_convert)\"\n\n\troute_cleanup\n}\n\nipv4_route_v6_gw_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 route with IPv6 gateway tests\"\n\n\troute_setup\n\tsleep 2\n\n\t#\n\t# single path route\n\t#\n\trun_cmd \"$IP ro add 172.16.104.0/24 via inet6 2001:db8:101::2\"\n\trc=$?\n\tlog_test $rc 0 \"Single path route with IPv6 gateway\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 via inet6 2001:db8:101::2 dev veth1\"\n\tfi\n\n\trun_cmd \"ip netns exec ns1 ping -w1 -c1 172.16.104.1\"\n\tlog_test $rc 0 \"Single path route with IPv6 gateway - ping\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 via inet6 2001:db8:101::2\"\n\trc=$?\n\tlog_test $rc 0 \"Single path route delete\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.112.0/24\"\n\tfi\n\n\t#\n\t# multipath - v6 then v4\n\t#\n\trun_cmd \"$IP ro add 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3\"\n\trc=$?\n\tlog_test $rc 0 \"Multipath route add - v6 nexthop then v4\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tfi\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1\"\n\tlog_test $? 2 \"    Multipath route delete - nexthops in wrong order\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"    Multipath route delete exact match\"\n\n\t#\n\t# multipath - v4 then v6\n\t#\n\trun_cmd \"$IP ro add 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1\"\n\trc=$?\n\tlog_test $rc 0 \"Multipath route add - v4 nexthop then v6\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 weight 1 nexthop via inet6 2001:db8:101::2 dev veth1 weight 1\"\n\tfi\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3\"\n\tlog_test $? 2 \"    Multipath route delete - nexthops in wrong order\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1\"\n\tlog_test $? 0 \"    Multipath route delete exact match\"\n\n\troute_cleanup\n}\n\n################################################################################\n# usage\n\nusage()\n{\n\tcat <<EOF\nusage: ${0##*/} OPTS\n\n        -t <test>   Test(s) to run (default: all)\n                    (options: $TESTS)\n        -p          Pause on fail\n        -P          Pause after each test before cleanup\n        -v          verbose mode (show commands and output)\nEOF\n}\n\n################################################################################\n# main\n\nwhile getopts :t:pPhv o\ndo\n\tcase $o in\n\t\tt) TESTS=$OPTARG;;\n\t\tp) PAUSE_ON_FAIL=yes;;\n\t\tP) PAUSE=yes;;\n\t\tv) VERBOSE=$(($VERBOSE + 1));;\n\t\th) usage; exit 0;;\n\t\t*) usage; exit 1;;\n\tesac\ndone\n\nPEER_CMD=\"ip netns exec ${PEER_NS}\"\n\n# make sure we don't pause twice\n[ \"${PAUSE}\" = \"yes\" ] && PAUSE_ON_FAIL=no\n\nif [ \"$(id -u)\" -ne 0 ];then\n\techo \"SKIP: Need root privileges\"\n\texit $ksft_skip;\nfi\n\nif [ ! -x \"$(command -v ip)\" ]; then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\nip route help 2>&1 | grep -q fibmatch\nif [ $? -ne 0 ]; then\n\techo \"SKIP: iproute2 too old, missing fibmatch\"\n\texit $ksft_skip\nfi\n\n# start clean\ncleanup &> /dev/null\n\nfor t in $TESTS\ndo\n\tcase $t in\n\tfib_unreg_test|unregister)\tfib_unreg_test;;\n\tfib_down_test|down)\t\tfib_down_test;;\n\tfib_carrier_test|carrier)\tfib_carrier_test;;\n\tfib_rp_filter_test|rp_filter)\tfib_rp_filter_test;;\n\tfib_nexthop_test|nexthop)\tfib_nexthop_test;;\n\tipv6_route_test|ipv6_rt)\tipv6_route_test;;\n\tipv4_route_test|ipv4_rt)\tipv4_route_test;;\n\tipv6_addr_metric)\t\tipv6_addr_metric_test;;\n\tipv4_addr_metric)\t\tipv4_addr_metric_test;;\n\tipv6_route_metrics)\t\tipv6_route_metrics_test;;\n\tipv4_route_metrics)\t\tipv4_route_metrics_test;;\n\tipv4_route_v6_gw)\t\tipv4_route_v6_gw_test;;\n\n\thelp) echo \"Test names: $TESTS\"; exit 0;;\n\tesac\ndone\n\nif [ \"$TESTS\" != \"none\" ]; then\n\tprintf \"\\nTests passed: %3d\\n\" ${nsuccess}\n\tprintf \"Tests failed: %3d\\n\"   ${nfail}\nfi\n\nexit $ret\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * net/ipv6/fib6_rules.c\tIPv6 Routing Policy Rules\n *\n * Copyright (C)2003-2006 Helsinki University of Technology\n * Copyright (C)2003-2006 USAGI/WIDE Project\n *\n * Authors\n *\tThomas Graf\t\t<tgraf@suug.ch>\n *\tVille Nuorvala\t\t<vnuorval@tcs.hut.fi>\n */\n\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n\n#include <net/fib_rules.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/netlink.h>\n\nstruct fib6_rule {\n\tstruct fib_rule\t\tcommon;\n\tstruct rt6key\t\tsrc;\n\tstruct rt6key\t\tdst;\n\tu8\t\t\ttclass;\n};\n\nstatic bool fib6_rule_matchall(const struct fib_rule *rule)\n{\n\tstruct fib6_rule *r = container_of(rule, struct fib6_rule, common);\n\n\tif (r->dst.plen || r->src.plen || r->tclass)\n\t\treturn false;\n\treturn fib_rule_matchall(rule);\n}\n\nbool fib6_rule_default(const struct fib_rule *rule)\n{\n\tif (!fib6_rule_matchall(rule) || rule->action != FR_ACT_TO_TBL ||\n\t    rule->l3mdev)\n\t\treturn false;\n\tif (rule->table != RT6_TABLE_LOCAL && rule->table != RT6_TABLE_MAIN)\n\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(fib6_rule_default);\n\nint fib6_rules_dump(struct net *net, struct notifier_block *nb)\n{\n\treturn fib_rules_dump(net, nb, AF_INET6);\n}\n\nunsigned int fib6_rules_seq_read(struct net *net)\n{\n\treturn fib_rules_seq_read(net, AF_INET6);\n}\n\n/* called with rcu lock held; no reference taken on fib6_info */\nint fib6_lookup(struct net *net, int oif, struct flowi6 *fl6,\n\t\tstruct fib6_result *res, int flags)\n{\n\tint err;\n\n\tif (net->ipv6.fib6_has_custom_rules) {\n\t\tstruct fib_lookup_arg arg = {\n\t\t\t.lookup_ptr = fib6_table_lookup,\n\t\t\t.lookup_data = &oif,\n\t\t\t.result = res,\n\t\t\t.flags = FIB_LOOKUP_NOREF,\n\t\t};\n\n\t\tl3mdev_update_flow(net, flowi6_to_flowi(fl6));\n\n\t\terr = fib_rules_lookup(net->ipv6.fib6_rules_ops,\n\t\t\t\t       flowi6_to_flowi(fl6), flags, &arg);\n\t} else {\n\t\terr = fib6_table_lookup(net, net->ipv6.fib6_local_tbl, oif,\n\t\t\t\t\tfl6, res, flags);\n\t\tif (err || res->f6i == net->ipv6.fib6_null_entry)\n\t\t\terr = fib6_table_lookup(net, net->ipv6.fib6_main_tbl,\n\t\t\t\t\t\toif, fl6, res, flags);\n\t}\n\n\treturn err;\n}\n\nstruct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tif (net->ipv6.fib6_has_custom_rules) {\n\t\tstruct fib6_result res = {};\n\t\tstruct fib_lookup_arg arg = {\n\t\t\t.lookup_ptr = lookup,\n\t\t\t.lookup_data = skb,\n\t\t\t.result = &res,\n\t\t\t.flags = FIB_LOOKUP_NOREF,\n\t\t};\n\n\t\t/* update flow if oif or iif point to device enslaved to l3mdev */\n\t\tl3mdev_update_flow(net, flowi6_to_flowi(fl6));\n\n\t\tfib_rules_lookup(net->ipv6.fib6_rules_ops,\n\t\t\t\t flowi6_to_flowi(fl6), flags, &arg);\n\n\t\tif (res.rt6)\n\t\t\treturn &res.rt6->dst;\n\t} else {\n\t\tstruct rt6_info *rt;\n\n\t\trt = lookup(net, net->ipv6.fib6_local_tbl, fl6, skb, flags);\n\t\tif (rt != net->ipv6.ip6_null_entry && rt->dst.error != -EAGAIN)\n\t\t\treturn &rt->dst;\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\t\tif (rt->dst.error != -EAGAIN)\n\t\t\treturn &rt->dst;\n\t\tip6_rt_put_flags(rt, flags);\n\t}\n\n\tif (!(flags & RT6_LOOKUP_F_DST_NOREF))\n\t\tdst_hold(&net->ipv6.ip6_null_entry->dst);\n\treturn &net->ipv6.ip6_null_entry->dst;\n}\n\nstatic int fib6_rule_saddr(struct net *net, struct fib_rule *rule, int flags,\n\t\t\t   struct flowi6 *flp6, const struct net_device *dev)\n{\n\tstruct fib6_rule *r = (struct fib6_rule *)rule;\n\n\t/* If we need to find a source address for this traffic,\n\t * we check the result if it meets requirement of the rule.\n\t */\n\tif ((rule->flags & FIB_RULE_FIND_SADDR) &&\n\t    r->src.plen && !(flags & RT6_LOOKUP_F_HAS_SADDR)) {\n\t\tstruct in6_addr saddr;\n\n\t\tif (ipv6_dev_get_saddr(net, dev, &flp6->daddr,\n\t\t\t\t       rt6_flags2srcprefs(flags), &saddr))\n\t\t\treturn -EAGAIN;\n\n\t\tif (!ipv6_prefix_equal(&saddr, &r->src.addr, r->src.plen))\n\t\t\treturn -EAGAIN;\n\n\t\tflp6->saddr = saddr;\n\t}\n\n\treturn 0;\n}\n\nstatic int fib6_rule_action_alt(struct fib_rule *rule, struct flowi *flp,\n\t\t\t\tint flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct net *net = rule->fr_net;\n\tstruct fib6_table *table;\n\tint err, *oif;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\treturn -ENETUNREACH;\n\tcase FR_ACT_PROHIBIT:\n\t\treturn -EACCES;\n\tcase FR_ACT_BLACKHOLE:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table)\n\t\treturn -EAGAIN;\n\n\toif = (int *)arg->lookup_data;\n\terr = fib6_table_lookup(net, table, *oif, flp6, res, flags);\n\tif (!err && res->f6i != net->ipv6.fib6_null_entry)\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      res->nh->fib_nh_dev);\n\telse\n\t\terr = -EAGAIN;\n\n\treturn err;\n}\n\nstatic int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = lookup(net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      ip6_dst_idev(&rt->dst)->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put_flags(rt, flags);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tif (!(flags & RT6_LOOKUP_F_DST_NOREF))\n\t\tdst_hold(&rt->dst);\nout:\n\tres->rt6 = rt;\n\treturn err;\n}\n\nstatic int fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t    int flags, struct fib_lookup_arg *arg)\n{\n\tif (arg->lookup_ptr == fib6_table_lookup)\n\t\treturn fib6_rule_action_alt(rule, flp, flags, arg);\n\n\treturn __fib6_rule_action(rule, flp, flags, arg);\n}\n\nstatic bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\n\tif (!rt)\n\t\treturn false;\n\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\n\t/* do not accept result if the route does\n\t * not meet the required prefix length\n\t */\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\n\t/* do not accept result if the route uses a device\n\t * belonging to a forbidden interface group\n\t */\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\n\treturn false;\n\nsuppress_route:\n\tif (!(arg->flags & FIB_LOOKUP_NOREF))\n\t\tip6_rt_put(rt);\n\treturn true;\n}\n\nstatic int fib6_rule_match(struct fib_rule *rule, struct flowi *fl, int flags)\n{\n\tstruct fib6_rule *r = (struct fib6_rule *) rule;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\n\tif (r->dst.plen &&\n\t    !ipv6_prefix_equal(&fl6->daddr, &r->dst.addr, r->dst.plen))\n\t\treturn 0;\n\n\t/*\n\t * If FIB_RULE_FIND_SADDR is set and we do not have a\n\t * source address for the traffic, we defer check for\n\t * source address.\n\t */\n\tif (r->src.plen) {\n\t\tif (flags & RT6_LOOKUP_F_HAS_SADDR) {\n\t\t\tif (!ipv6_prefix_equal(&fl6->saddr, &r->src.addr,\n\t\t\t\t\t       r->src.plen))\n\t\t\t\treturn 0;\n\t\t} else if (!(r->common.flags & FIB_RULE_FIND_SADDR))\n\t\t\treturn 0;\n\t}\n\n\tif (r->tclass && r->tclass != ip6_tclass(fl6->flowlabel))\n\t\treturn 0;\n\n\tif (rule->ip_proto && (rule->ip_proto != fl6->flowi6_proto))\n\t\treturn 0;\n\n\tif (fib_rule_port_range_set(&rule->sport_range) &&\n\t    !fib_rule_port_inrange(&rule->sport_range, fl6->fl6_sport))\n\t\treturn 0;\n\n\tif (fib_rule_port_range_set(&rule->dport_range) &&\n\t    !fib_rule_port_inrange(&rule->dport_range, fl6->fl6_dport))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic const struct nla_policy fib6_rule_policy[FRA_MAX+1] = {\n\tFRA_GENERIC_POLICY,\n};\n\nstatic int fib6_rule_configure(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t       struct fib_rule_hdr *frh,\n\t\t\t       struct nlattr **tb,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tint err = -EINVAL;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\n\n\tif (rule->action == FR_ACT_TO_TBL && !rule->l3mdev) {\n\t\tif (rule->table == RT6_TABLE_UNSPEC) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid table\");\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (fib6_new_table(net, rule->table) == NULL) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (frh->src_len)\n\t\trule6->src.addr = nla_get_in6_addr(tb[FRA_SRC]);\n\n\tif (frh->dst_len)\n\t\trule6->dst.addr = nla_get_in6_addr(tb[FRA_DST]);\n\n\trule6->src.plen = frh->src_len;\n\trule6->dst.plen = frh->dst_len;\n\trule6->tclass = frh->tos;\n\n\tif (fib_rule_requires_fldissect(rule))\n\t\tnet->ipv6.fib6_rules_require_fldissect++;\n\n\tnet->ipv6.fib6_has_custom_rules = true;\n\terr = 0;\nerrout:\n\treturn err;\n}\n\nstatic int fib6_rule_delete(struct fib_rule *rule)\n{\n\tstruct net *net = rule->fr_net;\n\n\tif (net->ipv6.fib6_rules_require_fldissect &&\n\t    fib_rule_requires_fldissect(rule))\n\t\tnet->ipv6.fib6_rules_require_fldissect--;\n\n\treturn 0;\n}\n\nstatic int fib6_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,\n\t\t\t     struct nlattr **tb)\n{\n\tstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\n\n\tif (frh->src_len && (rule6->src.plen != frh->src_len))\n\t\treturn 0;\n\n\tif (frh->dst_len && (rule6->dst.plen != frh->dst_len))\n\t\treturn 0;\n\n\tif (frh->tos && (rule6->tclass != frh->tos))\n\t\treturn 0;\n\n\tif (frh->src_len &&\n\t    nla_memcmp(tb[FRA_SRC], &rule6->src.addr, sizeof(struct in6_addr)))\n\t\treturn 0;\n\n\tif (frh->dst_len &&\n\t    nla_memcmp(tb[FRA_DST], &rule6->dst.addr, sizeof(struct in6_addr)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int fib6_rule_fill(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t  struct fib_rule_hdr *frh)\n{\n\tstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\n\n\tfrh->dst_len = rule6->dst.plen;\n\tfrh->src_len = rule6->src.plen;\n\tfrh->tos = rule6->tclass;\n\n\tif ((rule6->dst.plen &&\n\t     nla_put_in6_addr(skb, FRA_DST, &rule6->dst.addr)) ||\n\t    (rule6->src.plen &&\n\t     nla_put_in6_addr(skb, FRA_SRC, &rule6->src.addr)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic size_t fib6_rule_nlmsg_payload(struct fib_rule *rule)\n{\n\treturn nla_total_size(16) /* dst */\n\t       + nla_total_size(16); /* src */\n}\n\nstatic const struct fib_rules_ops __net_initconst fib6_rules_ops_template = {\n\t.family\t\t\t= AF_INET6,\n\t.rule_size\t\t= sizeof(struct fib6_rule),\n\t.addr_size\t\t= sizeof(struct in6_addr),\n\t.action\t\t\t= fib6_rule_action,\n\t.match\t\t\t= fib6_rule_match,\n\t.suppress\t\t= fib6_rule_suppress,\n\t.configure\t\t= fib6_rule_configure,\n\t.delete\t\t\t= fib6_rule_delete,\n\t.compare\t\t= fib6_rule_compare,\n\t.fill\t\t\t= fib6_rule_fill,\n\t.nlmsg_payload\t\t= fib6_rule_nlmsg_payload,\n\t.nlgroup\t\t= RTNLGRP_IPV6_RULE,\n\t.policy\t\t\t= fib6_rule_policy,\n\t.owner\t\t\t= THIS_MODULE,\n\t.fro_net\t\t= &init_net,\n};\n\nstatic int __net_init fib6_rules_net_init(struct net *net)\n{\n\tstruct fib_rules_ops *ops;\n\tint err = -ENOMEM;\n\n\tops = fib_rules_register(&fib6_rules_ops_template, net);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\terr = fib_default_rule_add(ops, 0, RT6_TABLE_LOCAL, 0);\n\tif (err)\n\t\tgoto out_fib6_rules_ops;\n\n\terr = fib_default_rule_add(ops, 0x7FFE, RT6_TABLE_MAIN, 0);\n\tif (err)\n\t\tgoto out_fib6_rules_ops;\n\n\tnet->ipv6.fib6_rules_ops = ops;\n\tnet->ipv6.fib6_rules_require_fldissect = 0;\nout:\n\treturn err;\n\nout_fib6_rules_ops:\n\tfib_rules_unregister(ops);\n\tgoto out;\n}\n\nstatic void __net_exit fib6_rules_net_exit(struct net *net)\n{\n\trtnl_lock();\n\tfib_rules_unregister(net->ipv6.fib6_rules_ops);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations fib6_rules_net_ops = {\n\t.init = fib6_rules_net_init,\n\t.exit = fib6_rules_net_exit,\n};\n\nint __init fib6_rules_init(void)\n{\n\treturn register_pernet_subsys(&fib6_rules_net_ops);\n}\n\n\nvoid fib6_rules_cleanup(void)\n{\n\tunregister_pernet_subsys(&fib6_rules_net_ops);\n}\n", "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# This test is for checking IPv4 and IPv6 FIB behavior in response to\n# different events.\n\nret=0\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\n# all tests in this script. Can be overridden with -t option\nTESTS=\"unregister down carrier nexthop suppress ipv6_rt ipv4_rt ipv6_addr_metric ipv4_addr_metric ipv6_route_metrics ipv4_route_metrics ipv4_route_v6_gw rp_filter\"\n\nVERBOSE=0\nPAUSE_ON_FAIL=no\nPAUSE=no\nIP=\"ip -netns ns1\"\nNS_EXEC=\"ip netns exec ns1\"\n\nwhich ping6 > /dev/null 2>&1 && ping6=$(which ping6) || ping6=$(which ping)\n\nlog_test()\n{\n\tlocal rc=$1\n\tlocal expected=$2\n\tlocal msg=\"$3\"\n\n\tif [ ${rc} -eq ${expected} ]; then\n\t\tprintf \"    TEST: %-60s  [ OK ]\\n\" \"${msg}\"\n\t\tnsuccess=$((nsuccess+1))\n\telse\n\t\tret=1\n\t\tnfail=$((nfail+1))\n\t\tprintf \"    TEST: %-60s  [FAIL]\\n\" \"${msg}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\techo\n\t\t\techo \"hit enter to continue, 'q' to quit\"\n\t\t\tread a\n\t\t\t[ \"$a\" = \"q\" ] && exit 1\n\t\tfi\n\tfi\n\n\tif [ \"${PAUSE}\" = \"yes\" ]; then\n\t\techo\n\t\techo \"hit enter to continue, 'q' to quit\"\n\t\tread a\n\t\t[ \"$a\" = \"q\" ] && exit 1\n\tfi\n}\n\nsetup()\n{\n\tset -e\n\tip netns add ns1\n\tip netns set ns1 auto\n\t$IP link set dev lo up\n\tip netns exec ns1 sysctl -qw net.ipv4.ip_forward=1\n\tip netns exec ns1 sysctl -qw net.ipv6.conf.all.forwarding=1\n\n\t$IP link add dummy0 type dummy\n\t$IP link set dev dummy0 up\n\t$IP address add 198.51.100.1/24 dev dummy0\n\t$IP -6 address add 2001:db8:1::1/64 dev dummy0\n\tset +e\n\n}\n\ncleanup()\n{\n\t$IP link del dev dummy0 &> /dev/null\n\tip netns del ns1\n\tip netns del ns2 &> /dev/null\n}\n\nget_linklocal()\n{\n\tlocal dev=$1\n\tlocal addr\n\n\taddr=$($IP -6 -br addr show dev ${dev} | \\\n\tawk '{\n\t\tfor (i = 3; i <= NF; ++i) {\n\t\t\tif ($i ~ /^fe80/)\n\t\t\t\tprint $i\n\t\t}\n\t}'\n\t)\n\taddr=${addr/\\/*}\n\n\t[ -z \"$addr\" ] && return 1\n\n\techo $addr\n\n\treturn 0\n}\n\nfib_unreg_unicast_test()\n{\n\techo\n\techo \"Single path route test\"\n\n\tsetup\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link del dev dummy0\n\tset +e\n\n\techo \"    Nexthop device deleted\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch - no route\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch - no route\"\n\n\tcleanup\n}\n\nfib_unreg_multipath_test()\n{\n\n\techo\n\techo \"Multipath route test\"\n\n\tsetup\n\n\tset -e\n\t$IP link add dummy1 type dummy\n\t$IP link set dev dummy1 up\n\t$IP address add 192.0.2.1/24 dev dummy1\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy1\n\n\t$IP route add 203.0.113.0/24 \\\n\t\tnexthop via 198.51.100.2 dev dummy0 \\\n\t\tnexthop via 192.0.2.2 dev dummy1\n\t$IP -6 route add 2001:db8:3::/64 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy0 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy1\n\tset +e\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link del dev dummy0\n\tset +e\n\n\techo \"    One nexthop device deleted\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 2 \"IPv4 - multipath route removed on delete\"\n\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\t# In IPv6 we do not flush the entire multipath route.\n\tlog_test $? 0 \"IPv6 - multipath down to single path\"\n\n\tset -e\n\t$IP link del dev dummy1\n\tset +e\n\n\techo \"    Second nexthop device deleted\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 2 \"IPv6 - no route\"\n\n\tcleanup\n}\n\nfib_unreg_test()\n{\n\tfib_unreg_unicast_test\n\tfib_unreg_multipath_test\n}\n\nfib_down_unicast_test()\n{\n\techo\n\techo \"Single path, admin down\"\n\n\tsetup\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link set dev dummy0 down\n\tset +e\n\n\techo \"    Route deleted on down\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch\"\n\n\tcleanup\n}\n\nfib_down_multipath_test_do()\n{\n\tlocal down_dev=$1\n\tlocal up_dev=$2\n\n\t$IP route get fibmatch 203.0.113.1 \\\n\t\toif $down_dev &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch on down device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 \\\n\t\toif $down_dev &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch on down device\"\n\n\t$IP route get fibmatch 203.0.113.1 \\\n\t\toif $up_dev &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch on up device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 \\\n\t\toif $up_dev &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch on up device\"\n\n\t$IP route get fibmatch 203.0.113.1 | \\\n\t\tgrep $down_dev | grep -q \"dead linkdown\"\n\tlog_test $? 0 \"IPv4 flags on down device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 | \\\n\t\tgrep $down_dev | grep -q \"dead linkdown\"\n\tlog_test $? 0 \"IPv6 flags on down device\"\n\n\t$IP route get fibmatch 203.0.113.1 | \\\n\t\tgrep $up_dev | grep -q \"dead linkdown\"\n\tlog_test $? 1 \"IPv4 flags on up device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 | \\\n\t\tgrep $up_dev | grep -q \"dead linkdown\"\n\tlog_test $? 1 \"IPv6 flags on up device\"\n}\n\nfib_down_multipath_test()\n{\n\techo\n\techo \"Admin down multipath\"\n\n\tsetup\n\n\tset -e\n\t$IP link add dummy1 type dummy\n\t$IP link set dev dummy1 up\n\n\t$IP address add 192.0.2.1/24 dev dummy1\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy1\n\n\t$IP route add 203.0.113.0/24 \\\n\t\tnexthop via 198.51.100.2 dev dummy0 \\\n\t\tnexthop via 192.0.2.2 dev dummy1\n\t$IP -6 route add 2001:db8:3::/64 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy0 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy1\n\tset +e\n\n\techo \"    Verify start point\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link set dev dummy0 down\n\tset +e\n\n\techo \"    One device down, one up\"\n\tfib_down_multipath_test_do \"dummy0\" \"dummy1\"\n\n\tset -e\n\t$IP link set dev dummy0 up\n\t$IP link set dev dummy1 down\n\tset +e\n\n\techo \"    Other device down and up\"\n\tfib_down_multipath_test_do \"dummy1\" \"dummy0\"\n\n\tset -e\n\t$IP link set dev dummy0 down\n\tset +e\n\n\techo \"    Both devices down\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch\"\n\n\t$IP link del dev dummy1\n\tcleanup\n}\n\nfib_down_test()\n{\n\tfib_down_unicast_test\n\tfib_down_multipath_test\n}\n\n# Local routes should not be affected when carrier changes.\nfib_carrier_local_test()\n{\n\techo\n\techo \"Local carrier tests - single path\"\n\n\tsetup\n\n\tset -e\n\t$IP link set dev dummy0 carrier on\n\tset +e\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 - no linkdown flag\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 - no linkdown flag\"\n\n\tset -e\n\t$IP link set dev dummy0 carrier off\n\tsleep 1\n\tset +e\n\n\techo \"    Carrier off on nexthop\"\n\t$IP route get fibmatch 198.51.100.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 - linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 - linkdown flag set\"\n\n\tset -e\n\t$IP address add 192.0.2.1/24 dev dummy0\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy0\n\tset +e\n\n\techo \"    Route to local address with carrier down\"\n\t$IP route get fibmatch 192.0.2.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:2::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 192.0.2.1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:2::1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 linkdown flag set\"\n\n\tcleanup\n}\n\nfib_carrier_unicast_test()\n{\n\tret=0\n\n\techo\n\techo \"Single path route carrier test\"\n\n\tsetup\n\n\tset -e\n\t$IP link set dev dummy0 carrier on\n\tset +e\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 no linkdown flag\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 no linkdown flag\"\n\n\tset -e\n\t$IP link set dev dummy0 carrier off\n\tsleep 1\n\tset +e\n\n\techo \"    Carrier down\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv4 linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv6 linkdown flag set\"\n\n\tset -e\n\t$IP address add 192.0.2.1/24 dev dummy0\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy0\n\tset +e\n\n\techo \"    Second address added with carrier down\"\n\t$IP route get fibmatch 192.0.2.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:2::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 192.0.2.2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv4 linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:2::2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv6 linkdown flag set\"\n\n\tcleanup\n}\n\nfib_carrier_test()\n{\n\tfib_carrier_local_test\n\tfib_carrier_unicast_test\n}\n\nfib_rp_filter_test()\n{\n\techo\n\techo \"IPv4 rp_filter tests\"\n\n\tsetup\n\n\tset -e\n\t$IP link set dev lo address 52:54:00:6a:c7:5e\n\t$IP link set dummy0 address 52:54:00:6a:c7:5e\n\t$IP link add dummy1 type dummy\n\t$IP link set dummy1 address 52:54:00:6a:c7:5e\n\t$IP link set dev dummy1 up\n\t$NS_EXEC sysctl -qw net.ipv4.conf.all.rp_filter=1\n\t$NS_EXEC sysctl -qw net.ipv4.conf.all.accept_local=1\n\t$NS_EXEC sysctl -qw net.ipv4.conf.all.route_localnet=1\n\n\t$NS_EXEC tc qd add dev dummy1 parent root handle 1: fq_codel\n\t$NS_EXEC tc filter add dev dummy1 parent 1: protocol arp basic action mirred egress redirect dev lo\n\t$NS_EXEC tc filter add dev dummy1 parent 1: protocol ip basic action mirred egress redirect dev lo\n\tset +e\n\n\trun_cmd \"ip netns exec ns1 ping -I dummy1 -w1 -c1 198.51.100.1\"\n\tlog_test $? 0 \"rp_filter passes local packets\"\n\n\trun_cmd \"ip netns exec ns1 ping -I dummy1 -w1 -c1 127.0.0.1\"\n\tlog_test $? 0 \"rp_filter passes loopback packets\"\n\n\tcleanup\n}\n\n################################################################################\n# Tests on nexthop spec\n\n# run 'ip route add' with given spec\nadd_rt()\n{\n\tlocal desc=\"$1\"\n\tlocal erc=$2\n\tlocal vrf=$3\n\tlocal pfx=$4\n\tlocal gw=$5\n\tlocal dev=$6\n\tlocal cmd out rc\n\n\t[ \"$vrf\" = \"-\" ] && vrf=\"default\"\n\t[ -n \"$gw\" ] && gw=\"via $gw\"\n\t[ -n \"$dev\" ] && dev=\"dev $dev\"\n\n\tcmd=\"$IP route add vrf $vrf $pfx $gw $dev\"\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\tprintf \"\\n    COMMAND: $cmd\\n\"\n\tfi\n\n\tout=$(eval $cmd 2>&1)\n\trc=$?\n\tif [ \"$VERBOSE\" = \"1\" -a -n \"$out\" ]; then\n\t\techo \"    $out\"\n\tfi\n\tlog_test $rc $erc \"$desc\"\n}\n\nfib4_nexthop()\n{\n\techo\n\techo \"IPv4 nexthop tests\"\n\n\techo \"<<< write me >>>\"\n}\n\nfib6_nexthop()\n{\n\tlocal lldummy=$(get_linklocal dummy0)\n\tlocal llv1=$(get_linklocal dummy0)\n\n\tif [ -z \"$lldummy\" ]; then\n\t\techo \"Failed to get linklocal address for dummy0\"\n\t\treturn 1\n\tfi\n\tif [ -z \"$llv1\" ]; then\n\t\techo \"Failed to get linklocal address for veth1\"\n\t\treturn 1\n\tfi\n\n\techo\n\techo \"IPv6 nexthop tests\"\n\n\tadd_rt \"Directly connected nexthop, unicast address\" 0 \\\n\t\t- 2001:db8:101::/64 2001:db8:1::2\n\tadd_rt \"Directly connected nexthop, unicast address with device\" 0 \\\n\t\t- 2001:db8:102::/64 2001:db8:1::2 \"dummy0\"\n\tadd_rt \"Gateway is linklocal address\" 0 \\\n\t\t- 2001:db8:103::1/64 $llv1 \"veth0\"\n\n\t# fails because LL address requires a device\n\tadd_rt \"Gateway is linklocal address, no device\" 2 \\\n\t\t- 2001:db8:104::1/64 $llv1\n\n\t# local address can not be a gateway\n\tadd_rt \"Gateway can not be local unicast address\" 2 \\\n\t\t- 2001:db8:105::/64 2001:db8:1::1\n\tadd_rt \"Gateway can not be local unicast address, with device\" 2 \\\n\t\t- 2001:db8:106::/64 2001:db8:1::1 \"dummy0\"\n\tadd_rt \"Gateway can not be a local linklocal address\" 2 \\\n\t\t- 2001:db8:107::1/64 $lldummy \"dummy0\"\n\n\t# VRF tests\n\tadd_rt \"Gateway can be local address in a VRF\" 0 \\\n\t\t- 2001:db8:108::/64 2001:db8:51::2\n\tadd_rt \"Gateway can be local address in a VRF, with device\" 0 \\\n\t\t- 2001:db8:109::/64 2001:db8:51::2 \"veth0\"\n\tadd_rt \"Gateway can be local linklocal address in a VRF\" 0 \\\n\t\t- 2001:db8:110::1/64 $llv1 \"veth0\"\n\n\tadd_rt \"Redirect to VRF lookup\" 0 \\\n\t\t- 2001:db8:111::/64 \"\" \"red\"\n\n\tadd_rt \"VRF route, gateway can be local address in default VRF\" 0 \\\n\t\tred 2001:db8:112::/64 2001:db8:51::1\n\n\t# local address in same VRF fails\n\tadd_rt \"VRF route, gateway can not be a local address\" 2 \\\n\t\tred 2001:db8:113::1/64 2001:db8:2::1\n\tadd_rt \"VRF route, gateway can not be a local addr with device\" 2 \\\n\t\tred 2001:db8:114::1/64 2001:db8:2::1 \"dummy1\"\n}\n\n# Default VRF:\n#   dummy0 - 198.51.100.1/24 2001:db8:1::1/64\n#   veth0  - 192.0.2.1/24    2001:db8:51::1/64\n#\n# VRF red:\n#   dummy1 - 192.168.2.1/24 2001:db8:2::1/64\n#   veth1  - 192.0.2.2/24   2001:db8:51::2/64\n#\n#  [ dummy0   veth0 ]--[ veth1   dummy1 ]\n\nfib_nexthop_test()\n{\n\tsetup\n\n\tset -e\n\n\t$IP -4 rule add pref 32765 table local\n\t$IP -4 rule del pref 0\n\t$IP -6 rule add pref 32765 table local\n\t$IP -6 rule del pref 0\n\n\t$IP link add red type vrf table 1\n\t$IP link set red up\n\t$IP -4 route add vrf red unreachable default metric 4278198272\n\t$IP -6 route add vrf red unreachable default metric 4278198272\n\n\t$IP link add veth0 type veth peer name veth1\n\t$IP link set dev veth0 up\n\t$IP address add 192.0.2.1/24 dev veth0\n\t$IP -6 address add 2001:db8:51::1/64 dev veth0\n\n\t$IP link set dev veth1 vrf red up\n\t$IP address add 192.0.2.2/24 dev veth1\n\t$IP -6 address add 2001:db8:51::2/64 dev veth1\n\n\t$IP link add dummy1 type dummy\n\t$IP link set dev dummy1 vrf red up\n\t$IP address add 192.168.2.1/24 dev dummy1\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy1\n\tset +e\n\n\tsleep 1\n\tfib4_nexthop\n\tfib6_nexthop\n\n\t(\n\t$IP link del dev dummy1\n\t$IP link del veth0\n\t$IP link del red\n\t) 2>/dev/null\n\tcleanup\n}\n\nfib_suppress_test()\n{\n\t$IP link add dummy1 type dummy\n\t$IP link set dummy1 up\n\t$IP -6 route add default dev dummy1\n\t$IP -6 rule add table main suppress_prefixlength 0\n\tping -f -c 1000 -W 1 1234::1 || true\n\t$IP -6 rule del table main suppress_prefixlength 0\n\t$IP link del dummy1\n\n\t# If we got here without crashing, we're good.\n\treturn 0\n}\n\n################################################################################\n# Tests on route add and replace\n\nrun_cmd()\n{\n\tlocal cmd=\"$1\"\n\tlocal out\n\tlocal stderr=\"2>/dev/null\"\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\tprintf \"    COMMAND: $cmd\\n\"\n\t\tstderr=\n\tfi\n\n\tout=$(eval $cmd $stderr)\n\trc=$?\n\tif [ \"$VERBOSE\" = \"1\" -a -n \"$out\" ]; then\n\t\techo \"    $out\"\n\tfi\n\n\t[ \"$VERBOSE\" = \"1\" ] && echo\n\n\treturn $rc\n}\n\ncheck_expected()\n{\n\tlocal out=\"$1\"\n\tlocal expected=\"$2\"\n\tlocal rc=0\n\n\t[ \"${out}\" = \"${expected}\" ] && return 0\n\n\tif [ -z \"${out}\" ]; then\n\t\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\t\tprintf \"\\nNo route entry found\\n\"\n\t\t\tprintf \"Expected:\\n\"\n\t\t\tprintf \"    ${expected}\\n\"\n\t\tfi\n\t\treturn 1\n\tfi\n\n\t# tricky way to convert output to 1-line without ip's\n\t# messy '\\'; this drops all extra white space\n\tout=$(echo ${out})\n\tif [ \"${out}\" != \"${expected}\" ]; then\n\t\trc=1\n\t\tif [ \"${VERBOSE}\" = \"1\" ]; then\n\t\t\tprintf \"    Unexpected route entry. Have:\\n\"\n\t\t\tprintf \"        ${out}\\n\"\n\t\t\tprintf \"    Expected:\\n\"\n\t\t\tprintf \"        ${expected}\\n\\n\"\n\t\tfi\n\tfi\n\n\treturn $rc\n}\n\n# add route for a prefix, flushing any existing routes first\n# expected to be the first step of a test\nadd_route6()\n{\n\tlocal pfx=\"$1\"\n\tlocal nh=\"$2\"\n\tlocal out\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\techo\n\t\techo \"    ##################################################\"\n\t\techo\n\tfi\n\n\trun_cmd \"$IP -6 ro flush ${pfx}\"\n\t[ $? -ne 0 ] && exit 1\n\n\tout=$($IP -6 ro ls match ${pfx})\n\tif [ -n \"$out\" ]; then\n\t\techo \"Failed to flush routes for prefix used for tests.\"\n\t\texit 1\n\tfi\n\n\trun_cmd \"$IP -6 ro add ${pfx} ${nh}\"\n\tif [ $? -ne 0 ]; then\n\t\techo \"Failed to add initial route for test.\"\n\t\texit 1\n\tfi\n}\n\n# add initial route - used in replace route tests\nadd_initial_route6()\n{\n\tadd_route6 \"2001:db8:104::/64\" \"$1\"\n}\n\ncheck_route6()\n{\n\tlocal pfx\n\tlocal expected=\"$1\"\n\tlocal out\n\tlocal rc=0\n\n\tset -- $expected\n\tpfx=$1\n\n\tout=$($IP -6 ro ls match ${pfx} | sed -e 's/ pref medium//')\n\tcheck_expected \"${out}\" \"${expected}\"\n}\n\nroute_cleanup()\n{\n\t$IP li del red 2>/dev/null\n\t$IP li del dummy1 2>/dev/null\n\t$IP li del veth1 2>/dev/null\n\t$IP li del veth3 2>/dev/null\n\n\tcleanup &> /dev/null\n}\n\nroute_setup()\n{\n\troute_cleanup\n\tsetup\n\n\t[ \"${VERBOSE}\" = \"1\" ] && set -x\n\tset -e\n\n\tip netns add ns2\n\tip netns set ns2 auto\n\tip -netns ns2 link set dev lo up\n\tip netns exec ns2 sysctl -qw net.ipv4.ip_forward=1\n\tip netns exec ns2 sysctl -qw net.ipv6.conf.all.forwarding=1\n\n\t$IP li add veth1 type veth peer name veth2\n\t$IP li add veth3 type veth peer name veth4\n\n\t$IP li set veth1 up\n\t$IP li set veth3 up\n\t$IP li set veth2 netns ns2 up\n\t$IP li set veth4 netns ns2 up\n\tip -netns ns2 li add dummy1 type dummy\n\tip -netns ns2 li set dummy1 up\n\n\t$IP -6 addr add 2001:db8:101::1/64 dev veth1 nodad\n\t$IP -6 addr add 2001:db8:103::1/64 dev veth3 nodad\n\t$IP addr add 172.16.101.1/24 dev veth1\n\t$IP addr add 172.16.103.1/24 dev veth3\n\n\tip -netns ns2 -6 addr add 2001:db8:101::2/64 dev veth2 nodad\n\tip -netns ns2 -6 addr add 2001:db8:103::2/64 dev veth4 nodad\n\tip -netns ns2 -6 addr add 2001:db8:104::1/64 dev dummy1 nodad\n\n\tip -netns ns2 addr add 172.16.101.2/24 dev veth2\n\tip -netns ns2 addr add 172.16.103.2/24 dev veth4\n\tip -netns ns2 addr add 172.16.104.1/24 dev dummy1\n\n\tset +e\n}\n\n# assumption is that basic add of a single path route works\n# otherwise just adding an address on an interface is broken\nipv6_rt_add()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv6 route add / append tests\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 via 2001:db8:103::2\"\n\tlog_test $? 2 \"Attempt to add duplicate route - gw\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 dev veth3\"\n\tlog_test $? 2 \"Attempt to add duplicate route - dev only\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add unreachable 2001:db8:104::/64\"\n\tlog_test $? 2 \"Attempt to add duplicate route - reject route\"\n\n\t# route append with same prefix adds a new route\n\t# - iproute2 sets NLM_F_CREATE | NLM_F_APPEND\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro append 2001:db8:104::/64 via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Append nexthop to existing route - gw\"\n\n\t# insert mpath directly\n\tadd_route6 \"2001:db8:104::/64\" \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Add multipath route\"\n\n\tadd_route6 \"2001:db8:104::/64\" \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\tlog_test $? 2 \"Attempt to add duplicate multipath route\"\n\n\t# insert of a second route without append but different metric\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 via 2001:db8:103::2 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 via 2001:db8:103::3 metric 256\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route add with different metrics\"\n\n\trun_cmd \"$IP -6 ro del 2001:db8:104::/64 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:103::3 dev veth3 metric 256 2001:db8:104::/64 via 2001:db8:101::2 dev veth1 metric 1024\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route delete with metric\"\n}\n\nipv6_rt_replace_single()\n{\n\t# single path with single path\n\t#\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:103::2 dev veth3 metric 1024\"\n\tlog_test $? 0 \"Single path with single path\"\n\n\t# single path with multipath\n\t#\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::3 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Single path with multipath\"\n\n\t# single path with single path using MULTIPATH attribute\n\t#\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:103::2 dev veth3 metric 1024\"\n\tlog_test $? 0 \"Single path with single path via multipath attribute\"\n\n\t# route replace fails - invalid nexthop\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 via 2001:db8:104::2\"\n\tif [ $? -eq 0 ]; then\n\t\t# previous command is expected to fail so if it returns 0\n\t\t# that means the test failed.\n\t\tlog_test 0 1 \"Invalid nexthop\"\n\telse\n\t\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:101::2 dev veth1 metric 1024\"\n\t\tlog_test $? 0 \"Invalid nexthop\"\n\tfi\n\n\t# replace non-existent route\n\t# - note use of change versus replace since ip adds NLM_F_CREATE\n\t#   for replace\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro change 2001:db8:105::/64 via 2001:db8:101::2\"\n\tlog_test $? 2 \"Single path - replace of non-existent route\"\n}\n\nipv6_rt_replace_mpath()\n{\n\t# multipath with multipath\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:103::3\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::3 dev veth1 weight 1 nexthop via 2001:db8:103::3 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath with multipath\"\n\n\t# multipath with single\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 via 2001:db8:101::3\"\n\tcheck_route6  \"2001:db8:104::/64 via 2001:db8:101::3 dev veth1 metric 1024\"\n\tlog_test $? 0 \"Multipath with single path\"\n\n\t# multipath with single\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3\"\n\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:101::3 dev veth1 metric 1024\"\n\tlog_test $? 0 \"Multipath with single path via multipath attribute\"\n\n\t# route replace fails - invalid nexthop 1\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:111::3 nexthop via 2001:db8:103::3\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid first nexthop\"\n\n\t# route replace fails - invalid nexthop 2\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:113::3\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid second nexthop\"\n\n\t# multipath non-existent route\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro change 2001:db8:105::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:103::3\"\n\tlog_test $? 2 \"Multipath - replace of non-existent route\"\n}\n\nipv6_rt_replace()\n{\n\techo\n\techo \"IPv6 route replace tests\"\n\n\tipv6_rt_replace_single\n\tipv6_rt_replace_mpath\n}\n\nipv6_route_test()\n{\n\troute_setup\n\n\tipv6_rt_add\n\tipv6_rt_replace\n\n\troute_cleanup\n}\n\nip_addr_metric_check()\n{\n\tip addr help 2>&1 | grep -q metric\n\tif [ $? -ne 0 ]; then\n\t\techo \"iproute2 command does not support metric for addresses. Skipping test\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\nipv6_addr_metric_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv6 prefix route tests\"\n\n\tip_addr_metric_check || return 1\n\n\tsetup\n\n\tset -e\n\t$IP li add dummy1 type dummy\n\t$IP li add dummy2 type dummy\n\t$IP li set dummy1 up\n\t$IP li set dummy2 up\n\n\t# default entry is metric 256\n\trun_cmd \"$IP -6 addr add dev dummy1 2001:db8:104::1/64\"\n\trun_cmd \"$IP -6 addr add dev dummy2 2001:db8:104::2/64\"\n\tset +e\n\n\tcheck_route6 \"2001:db8:104::/64 dev dummy1 proto kernel metric 256 2001:db8:104::/64 dev dummy2 proto kernel metric 256\"\n\tlog_test $? 0 \"Default metric\"\n\n\tset -e\n\trun_cmd \"$IP -6 addr flush dev dummy1\"\n\trun_cmd \"$IP -6 addr add dev dummy1 2001:db8:104::1/64 metric 257\"\n\tset +e\n\n\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 256 2001:db8:104::/64 dev dummy1 proto kernel metric 257\"\n\tlog_test $? 0 \"User specified metric on first device\"\n\n\tset -e\n\trun_cmd \"$IP -6 addr flush dev dummy2\"\n\trun_cmd \"$IP -6 addr add dev dummy2 2001:db8:104::2/64 metric 258\"\n\tset +e\n\n\tcheck_route6 \"2001:db8:104::/64 dev dummy1 proto kernel metric 257 2001:db8:104::/64 dev dummy2 proto kernel metric 258\"\n\tlog_test $? 0 \"User specified metric on second device\"\n\n\trun_cmd \"$IP -6 addr del dev dummy1 2001:db8:104::1/64 metric 257\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 258\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Delete of address on first device\"\n\n\trun_cmd \"$IP -6 addr change dev dummy2 2001:db8:104::2/64 metric 259\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Modify metric of address\"\n\n\t# verify prefix route removed on down\n\trun_cmd \"ip netns exec ns1 sysctl -qw net.ipv6.conf.all.keep_addr_on_down=1\"\n\trun_cmd \"$IP li set dev dummy2 down\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tout=$($IP -6 ro ls match 2001:db8:104::/64)\n\t\tcheck_expected \"${out}\" \"\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route removed on link down\"\n\n\t# verify prefix route re-inserted with assigned metric\n\trun_cmd \"$IP li set dev dummy2 up\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route with metric on link up\"\n\n\t$IP li del dummy1\n\t$IP li del dummy2\n\tcleanup\n}\n\nipv6_route_metrics_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv6 routes with metrics\"\n\n\troute_setup\n\n\t#\n\t# single path with metrics\n\t#\n\trun_cmd \"$IP -6 ro add 2001:db8:111::/64 via 2001:db8:101::2 mtu 1400\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6  \"2001:db8:111::/64 via 2001:db8:101::2 dev veth1 metric 1024 mtu 1400\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Single path route with mtu metric\"\n\n\n\t#\n\t# multipath via separate routes with metrics\n\t#\n\trun_cmd \"$IP -6 ro add 2001:db8:112::/64 via 2001:db8:101::2 mtu 1400\"\n\trun_cmd \"$IP -6 ro append 2001:db8:112::/64 via 2001:db8:103::2\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:112::/64 metric 1024 mtu 1400 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route via 2 single routes with mtu metric on first\"\n\n\t# second route is coalesced to first to make a multipath route.\n\t# MTU of the second path is hidden from display!\n\trun_cmd \"$IP -6 ro add 2001:db8:113::/64 via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro append 2001:db8:113::/64 via 2001:db8:103::2 mtu 1400\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:113::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route via 2 single routes with mtu metric on 2nd\"\n\n\trun_cmd \"$IP -6 ro del 2001:db8:113::/64 via 2001:db8:101::2\"\n\tif [ $? -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:113::/64 via 2001:db8:103::2 dev veth3 metric 1024 mtu 1400\"\n\t\tlog_test $? 0 \"    MTU of second leg\"\n\tfi\n\n\t#\n\t# multipath with metrics\n\t#\n\trun_cmd \"$IP -6 ro add 2001:db8:115::/64 mtu 1400 nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6  \"2001:db8:115::/64 metric 1024 mtu 1400 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route with mtu metric\"\n\n\t$IP -6 ro add 2001:db8:104::/64 via 2001:db8:101::2 mtu 1300\n\trun_cmd \"ip netns exec ns1 ${ping6} -w1 -c1 -s 1500 2001:db8:104::1\"\n\tlog_test $? 0 \"Using route with mtu metric\"\n\n\trun_cmd \"$IP -6 ro add 2001:db8:114::/64 via  2001:db8:101::2  congctl lock foo\"\n\tlog_test $? 2 \"Invalid metric (fails metric_convert)\"\n\n\troute_cleanup\n}\n\n# add route for a prefix, flushing any existing routes first\n# expected to be the first step of a test\nadd_route()\n{\n\tlocal pfx=\"$1\"\n\tlocal nh=\"$2\"\n\tlocal out\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\techo\n\t\techo \"    ##################################################\"\n\t\techo\n\tfi\n\n\trun_cmd \"$IP ro flush ${pfx}\"\n\t[ $? -ne 0 ] && exit 1\n\n\tout=$($IP ro ls match ${pfx})\n\tif [ -n \"$out\" ]; then\n\t\techo \"Failed to flush routes for prefix used for tests.\"\n\t\texit 1\n\tfi\n\n\trun_cmd \"$IP ro add ${pfx} ${nh}\"\n\tif [ $? -ne 0 ]; then\n\t\techo \"Failed to add initial route for test.\"\n\t\texit 1\n\tfi\n}\n\n# add initial route - used in replace route tests\nadd_initial_route()\n{\n\tadd_route \"172.16.104.0/24\" \"$1\"\n}\n\ncheck_route()\n{\n\tlocal pfx\n\tlocal expected=\"$1\"\n\tlocal out\n\n\tset -- $expected\n\tpfx=$1\n\t[ \"${pfx}\" = \"unreachable\" ] && pfx=$2\n\n\tout=$($IP ro ls match ${pfx})\n\tcheck_expected \"${out}\" \"${expected}\"\n}\n\n# assumption is that basic add of a single path route works\n# otherwise just adding an address on an interface is broken\nipv4_rt_add()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 route add / append tests\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 via 172.16.103.2\"\n\tlog_test $? 2 \"Attempt to add duplicate route - gw\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 dev veth3\"\n\tlog_test $? 2 \"Attempt to add duplicate route - dev only\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add unreachable 172.16.104.0/24\"\n\tlog_test $? 2 \"Attempt to add duplicate route - reject route\"\n\n\t# iproute2 prepend only sets NLM_F_CREATE\n\t# - adds a new route; does NOT convert existing route to ECMP\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro prepend 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.103.2 dev veth3 172.16.104.0/24 via 172.16.101.2 dev veth1\"\n\tlog_test $? 0 \"Add new nexthop for existing prefix\"\n\n\t# route append with same prefix adds a new route\n\t# - iproute2 sets NLM_F_CREATE | NLM_F_APPEND\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Append nexthop to existing route - gw\"\n\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 dev veth3\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 172.16.104.0/24 dev veth3 scope link\"\n\tlog_test $? 0 \"Append nexthop to existing route - dev only\"\n\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro append unreachable 172.16.104.0/24\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 unreachable 172.16.104.0/24\"\n\tlog_test $? 0 \"Append nexthop to existing route - reject route\"\n\n\trun_cmd \"$IP ro flush 172.16.104.0/24\"\n\trun_cmd \"$IP ro add unreachable 172.16.104.0/24\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"unreachable 172.16.104.0/24 172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Append nexthop to existing reject route - gw\"\n\n\trun_cmd \"$IP ro flush 172.16.104.0/24\"\n\trun_cmd \"$IP ro add unreachable 172.16.104.0/24\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 dev veth3\"\n\tcheck_route \"unreachable 172.16.104.0/24 172.16.104.0/24 dev veth3 scope link\"\n\tlog_test $? 0 \"Append nexthop to existing reject route - dev only\"\n\n\t# insert mpath directly\n\tadd_route \"172.16.104.0/24\" \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"add multipath route\"\n\n\tadd_route \"172.16.104.0/24\" \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\tlog_test $? 2 \"Attempt to add duplicate multipath route\"\n\n\t# insert of a second route without append but different metric\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 via 172.16.103.2 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\trun_cmd \"$IP ro add 172.16.104.0/24 via 172.16.103.3 metric 256\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route add with different metrics\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 172.16.104.0/24 via 172.16.103.3 dev veth3 metric 256\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route delete with metric\"\n}\n\nipv4_rt_replace_single()\n{\n\t# single path with single path\n\t#\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Single path with single path\"\n\n\t# single path with multipath\n\t#\n\tadd_initial_route \"nexthop via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3 nexthop via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 nexthop via 172.16.101.3 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Single path with multipath\"\n\n\t# single path with reject\n\t#\n\tadd_initial_route \"nexthop via 172.16.101.2\"\n\trun_cmd \"$IP ro replace unreachable 172.16.104.0/24\"\n\tcheck_route \"unreachable 172.16.104.0/24\"\n\tlog_test $? 0 \"Single path with reject route\"\n\n\t# single path with single path using MULTIPATH attribute\n\t#\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Single path with single path via multipath attribute\"\n\n\t# route replace fails - invalid nexthop\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 via 2001:db8:104::2\"\n\tif [ $? -eq 0 ]; then\n\t\t# previous command is expected to fail so if it returns 0\n\t\t# that means the test failed.\n\t\tlog_test 0 1 \"Invalid nexthop\"\n\telse\n\t\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1\"\n\t\tlog_test $? 0 \"Invalid nexthop\"\n\tfi\n\n\t# replace non-existent route\n\t# - note use of change versus replace since ip adds NLM_F_CREATE\n\t#   for replace\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro change 172.16.105.0/24 via 172.16.101.2\"\n\tlog_test $? 2 \"Single path - replace of non-existent route\"\n}\n\nipv4_rt_replace_mpath()\n{\n\t# multipath with multipath\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3 nexthop via 172.16.103.3\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.3 dev veth1 weight 1 nexthop via 172.16.103.3 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath with multipath\"\n\n\t# multipath with single\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 via 172.16.101.3\"\n\tcheck_route  \"172.16.104.0/24 via 172.16.101.3 dev veth1\"\n\tlog_test $? 0 \"Multipath with single path\"\n\n\t# multipath with single\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.3 dev veth1\"\n\tlog_test $? 0 \"Multipath with single path via multipath attribute\"\n\n\t# multipath with reject\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace unreachable 172.16.104.0/24\"\n\tcheck_route \"unreachable 172.16.104.0/24\"\n\tlog_test $? 0 \"Multipath with reject route\"\n\n\t# route replace fails - invalid nexthop 1\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.111.3 nexthop via 172.16.103.3\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid first nexthop\"\n\n\t# route replace fails - invalid nexthop 2\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3 nexthop via 172.16.113.3\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid second nexthop\"\n\n\t# multipath non-existent route\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro change 172.16.105.0/24 nexthop via 172.16.101.3 nexthop via 172.16.103.3\"\n\tlog_test $? 2 \"Multipath - replace of non-existent route\"\n}\n\nipv4_rt_replace()\n{\n\techo\n\techo \"IPv4 route replace tests\"\n\n\tipv4_rt_replace_single\n\tipv4_rt_replace_mpath\n}\n\nipv4_route_test()\n{\n\troute_setup\n\n\tipv4_rt_add\n\tipv4_rt_replace\n\n\troute_cleanup\n}\n\nipv4_addr_metric_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 prefix route tests\"\n\n\tip_addr_metric_check || return 1\n\n\tsetup\n\n\tset -e\n\t$IP li add dummy1 type dummy\n\t$IP li add dummy2 type dummy\n\t$IP li set dummy1 up\n\t$IP li set dummy2 up\n\n\t# default entry is metric 256\n\trun_cmd \"$IP addr add dev dummy1 172.16.104.1/24\"\n\trun_cmd \"$IP addr add dev dummy2 172.16.104.2/24\"\n\tset +e\n\n\tcheck_route \"172.16.104.0/24 dev dummy1 proto kernel scope link src 172.16.104.1 172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2\"\n\tlog_test $? 0 \"Default metric\"\n\n\tset -e\n\trun_cmd \"$IP addr flush dev dummy1\"\n\trun_cmd \"$IP addr add dev dummy1 172.16.104.1/24 metric 257\"\n\tset +e\n\n\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 172.16.104.0/24 dev dummy1 proto kernel scope link src 172.16.104.1 metric 257\"\n\tlog_test $? 0 \"User specified metric on first device\"\n\n\tset -e\n\trun_cmd \"$IP addr flush dev dummy2\"\n\trun_cmd \"$IP addr add dev dummy2 172.16.104.2/24 metric 258\"\n\tset +e\n\n\tcheck_route \"172.16.104.0/24 dev dummy1 proto kernel scope link src 172.16.104.1 metric 257 172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 258\"\n\tlog_test $? 0 \"User specified metric on second device\"\n\n\trun_cmd \"$IP addr del dev dummy1 172.16.104.1/24 metric 257\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 258\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Delete of address on first device\"\n\n\trun_cmd \"$IP addr change dev dummy2 172.16.104.2/24 metric 259\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Modify metric of address\"\n\n\t# verify prefix route removed on down\n\trun_cmd \"$IP li set dev dummy2 down\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tout=$($IP ro ls match 172.16.104.0/24)\n\t\tcheck_expected \"${out}\" \"\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route removed on link down\"\n\n\t# verify prefix route re-inserted with assigned metric\n\trun_cmd \"$IP li set dev dummy2 up\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route with metric on link up\"\n\n\t$IP li del dummy1\n\t$IP li del dummy2\n\tcleanup\n}\n\nipv4_route_metrics_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 route add / append tests\"\n\n\troute_setup\n\n\trun_cmd \"$IP ro add 172.16.111.0/24 via 172.16.101.2 mtu 1400\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.111.0/24 via 172.16.101.2 dev veth1 mtu 1400\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Single path route with mtu metric\"\n\n\n\trun_cmd \"$IP ro add 172.16.112.0/24 mtu 1400 nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.112.0/24 mtu 1400 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route with mtu metric\"\n\n\t$IP ro add 172.16.104.0/24 via 172.16.101.2 mtu 1300\n\trun_cmd \"ip netns exec ns1 ping -w1 -c1 -s 1500 172.16.104.1\"\n\tlog_test $? 0 \"Using route with mtu metric\"\n\n\trun_cmd \"$IP ro add 172.16.111.0/24 via 172.16.101.2 congctl lock foo\"\n\tlog_test $? 2 \"Invalid metric (fails metric_convert)\"\n\n\troute_cleanup\n}\n\nipv4_route_v6_gw_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 route with IPv6 gateway tests\"\n\n\troute_setup\n\tsleep 2\n\n\t#\n\t# single path route\n\t#\n\trun_cmd \"$IP ro add 172.16.104.0/24 via inet6 2001:db8:101::2\"\n\trc=$?\n\tlog_test $rc 0 \"Single path route with IPv6 gateway\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 via inet6 2001:db8:101::2 dev veth1\"\n\tfi\n\n\trun_cmd \"ip netns exec ns1 ping -w1 -c1 172.16.104.1\"\n\tlog_test $rc 0 \"Single path route with IPv6 gateway - ping\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 via inet6 2001:db8:101::2\"\n\trc=$?\n\tlog_test $rc 0 \"Single path route delete\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.112.0/24\"\n\tfi\n\n\t#\n\t# multipath - v6 then v4\n\t#\n\trun_cmd \"$IP ro add 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3\"\n\trc=$?\n\tlog_test $rc 0 \"Multipath route add - v6 nexthop then v4\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tfi\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1\"\n\tlog_test $? 2 \"    Multipath route delete - nexthops in wrong order\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"    Multipath route delete exact match\"\n\n\t#\n\t# multipath - v4 then v6\n\t#\n\trun_cmd \"$IP ro add 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1\"\n\trc=$?\n\tlog_test $rc 0 \"Multipath route add - v4 nexthop then v6\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 weight 1 nexthop via inet6 2001:db8:101::2 dev veth1 weight 1\"\n\tfi\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3\"\n\tlog_test $? 2 \"    Multipath route delete - nexthops in wrong order\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1\"\n\tlog_test $? 0 \"    Multipath route delete exact match\"\n\n\troute_cleanup\n}\n\n################################################################################\n# usage\n\nusage()\n{\n\tcat <<EOF\nusage: ${0##*/} OPTS\n\n        -t <test>   Test(s) to run (default: all)\n                    (options: $TESTS)\n        -p          Pause on fail\n        -P          Pause after each test before cleanup\n        -v          verbose mode (show commands and output)\nEOF\n}\n\n################################################################################\n# main\n\nwhile getopts :t:pPhv o\ndo\n\tcase $o in\n\t\tt) TESTS=$OPTARG;;\n\t\tp) PAUSE_ON_FAIL=yes;;\n\t\tP) PAUSE=yes;;\n\t\tv) VERBOSE=$(($VERBOSE + 1));;\n\t\th) usage; exit 0;;\n\t\t*) usage; exit 1;;\n\tesac\ndone\n\nPEER_CMD=\"ip netns exec ${PEER_NS}\"\n\n# make sure we don't pause twice\n[ \"${PAUSE}\" = \"yes\" ] && PAUSE_ON_FAIL=no\n\nif [ \"$(id -u)\" -ne 0 ];then\n\techo \"SKIP: Need root privileges\"\n\texit $ksft_skip;\nfi\n\nif [ ! -x \"$(command -v ip)\" ]; then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\nip route help 2>&1 | grep -q fibmatch\nif [ $? -ne 0 ]; then\n\techo \"SKIP: iproute2 too old, missing fibmatch\"\n\texit $ksft_skip\nfi\n\n# start clean\ncleanup &> /dev/null\n\nfor t in $TESTS\ndo\n\tcase $t in\n\tfib_unreg_test|unregister)\tfib_unreg_test;;\n\tfib_down_test|down)\t\tfib_down_test;;\n\tfib_carrier_test|carrier)\tfib_carrier_test;;\n\tfib_rp_filter_test|rp_filter)\tfib_rp_filter_test;;\n\tfib_nexthop_test|nexthop)\tfib_nexthop_test;;\n\tfib_suppress_test|suppress)\tfib_suppress_test;;\n\tipv6_route_test|ipv6_rt)\tipv6_route_test;;\n\tipv4_route_test|ipv4_rt)\tipv4_route_test;;\n\tipv6_addr_metric)\t\tipv6_addr_metric_test;;\n\tipv4_addr_metric)\t\tipv4_addr_metric_test;;\n\tipv6_route_metrics)\t\tipv6_route_metrics_test;;\n\tipv4_route_metrics)\t\tipv4_route_metrics_test;;\n\tipv4_route_v6_gw)\t\tipv4_route_v6_gw_test;;\n\n\thelp) echo \"Test names: $TESTS\"; exit 0;;\n\tesac\ndone\n\nif [ \"$TESTS\" != \"none\" ]; then\n\tprintf \"\\nTests passed: %3d\\n\" ${nsuccess}\n\tprintf \"Tests failed: %3d\\n\"   ${nfail}\nfi\n\nexit $ret\n"], "filenames": ["net/ipv6/fib6_rules.c", "tools/testing/selftests/net/fib_tests.sh"], "buggy_code_start_loc": [290, 12], "buggy_code_end_loc": [291, 1595], "fixing_code_start_loc": [290, 12], "fixing_code_end_loc": [292, 1611], "type": "CWE-772", "message": "In the Linux kernel before 5.3.4, a reference count usage error in the fib6_rule_suppress() function in the fib6 suppression feature of net/ipv6/fib6_rules.c, when handling the FIB_LOOKUP_NOREF flag, can be exploited by a local attacker to corrupt memory, aka CID-ca7a03c41753.", "other": {"cve": {"id": "CVE-2019-18198", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-18T22:15:14.767", "lastModified": "2023-01-20T18:48:43.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.3.4, a reference count usage error in the fib6_rule_suppress() function in the fib6 suppression feature of net/ipv6/fib6_rules.c, when handling the FIB_LOOKUP_NOREF flag, can be exploited by a local attacker to corrupt memory, aka CID-ca7a03c41753."}, {"lang": "es", "value": "En el kernel de Linux versiones anteriores a 5.3.4, un atacante local puede explotar un error de uso del conteo de referencia en la funci\u00f3n fib6_rule_suppress() en la funcionalidad de supresi\u00f3n de fib6 del archivo net/ipv6/fib6_rules.c, cuando maneja el flag FIB_LOOKUP_NOREF, para corromper la memoria , tambi\u00e9n se conoce como CID-ca7a03c41753."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.3", "versionEndExcluding": "5.3.4", "matchCriteriaId": "D84C21A7-C7A8-4CF2-80DC-CB58671C0F9F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ca7a03c4175366a92cee0ccc4fec0038c3266e26", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/ca7a03c4175366a92cee0ccc4fec0038c3266e26", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://launchpad.net/bugs/1847478", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191031-0005/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4161-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ca7a03c4175366a92cee0ccc4fec0038c3266e26"}}