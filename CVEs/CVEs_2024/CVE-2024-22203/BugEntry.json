{"buggy_code": ["import argparse\nimport base64\nimport io\nimport json\nimport os\nimport pickle\nimport urllib.parse as urlparse\nimport uuid\nfrom datetime import datetime, timedelta\nfrom functools import wraps\n\nimport waitress\nfrom app import app\nfrom app.models.config import Config\nfrom app.models.endpoint import Endpoint\nfrom app.request import Request, TorError\nfrom app.utils.bangs import resolve_bang\nfrom app.utils.misc import get_proxy_host_url\nfrom app.filter import Filter\nfrom app.utils.misc import read_config_bool, get_client_ip, get_request_url, \\\n    check_for_update\nfrom app.utils.widgets import *\nfrom app.utils.results import bold_search_terms,\\\n    add_currency_card, check_currency, get_tabs_content\nfrom app.utils.search import Search, needs_https, has_captcha\nfrom app.utils.session import valid_user_session\nfrom bs4 import BeautifulSoup as bsoup\nfrom flask import jsonify, make_response, request, redirect, render_template, \\\n    send_file, session, url_for, g\nfrom requests import exceptions\nfrom requests.models import PreparedRequest\nfrom cryptography.fernet import Fernet, InvalidToken\nfrom cryptography.exceptions import InvalidSignature\n\n# Load DDG bang json files only on init\nbang_json = json.load(open(app.config['BANG_FILE'])) or {}\n\nac_var = 'WHOOGLE_AUTOCOMPLETE'\nautocomplete_enabled = os.getenv(ac_var, '1')\n\n\ndef get_search_name(tbm):\n    for tab in app.config['HEADER_TABS'].values():\n        if tab['tbm'] == tbm:\n            return tab['name']\n\n\ndef auth_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        # do not ask password if cookies already present\n        if (\n            valid_user_session(session)\n            and 'cookies_disabled' not in request.args\n            and session['auth']\n        ):\n            return f(*args, **kwargs)\n\n        auth = request.authorization\n\n        # Skip if username/password not set\n        whoogle_user = os.getenv('WHOOGLE_USER', '')\n        whoogle_pass = os.getenv('WHOOGLE_PASS', '')\n        if (not whoogle_user or not whoogle_pass) or (\n                auth\n                and whoogle_user == auth.username\n                and whoogle_pass == auth.password):\n            session['auth'] = True\n            return f(*args, **kwargs)\n        else:\n            return make_response('Not logged in', 401, {\n                'WWW-Authenticate': 'Basic realm=\"Login Required\"'})\n\n    return decorated\n\n\ndef session_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        if not valid_user_session(session):\n            session.pop('_permanent', None)\n\n        # Note: This sets all requests to use the encryption key determined per\n        # instance on app init. This can be updated in the future to use a key\n        # that is unique for their session (session['key']) but this should use\n        # a config setting to enable the session based key. Otherwise there can\n        # be problems with searches performed by users with cookies blocked if\n        # a session based key is always used.\n        g.session_key = app.enc_key\n\n        # Clear out old sessions\n        invalid_sessions = []\n        for user_session in os.listdir(app.config['SESSION_FILE_DIR']):\n            file_path = os.path.join(\n                app.config['SESSION_FILE_DIR'],\n                user_session)\n\n            try:\n                # Ignore files that are larger than the max session file size\n                if os.path.getsize(file_path) > app.config['MAX_SESSION_SIZE']:\n                    continue\n\n                with open(file_path, 'rb') as session_file:\n                    _ = pickle.load(session_file)\n                    data = pickle.load(session_file)\n                    if isinstance(data, dict) and 'valid' in data:\n                        continue\n                    invalid_sessions.append(file_path)\n            except Exception:\n                # Broad exception handling here due to how instances installed\n                # with pip seem to have issues storing unrelated files in the\n                # same directory as sessions\n                pass\n\n        for invalid_session in invalid_sessions:\n            try:\n                os.remove(invalid_session)\n            except FileNotFoundError:\n                # Don't throw error if the invalid session has been removed\n                pass\n\n        return f(*args, **kwargs)\n\n    return decorated\n\n\n@app.before_request\ndef before_request_func():\n    global bang_json\n    session.permanent = True\n\n    # Check for latest version if needed\n    now = datetime.now()\n    if now - timedelta(hours=24) > app.config['LAST_UPDATE_CHECK']:\n        app.config['LAST_UPDATE_CHECK'] = now\n        app.config['HAS_UPDATE'] = check_for_update(\n            app.config['RELEASES_URL'],\n            app.config['VERSION_NUMBER'])\n\n    g.request_params = (\n        request.args if request.method == 'GET' else request.form\n    )\n\n    default_config = json.load(open(app.config['DEFAULT_CONFIG'])) \\\n        if os.path.exists(app.config['DEFAULT_CONFIG']) else {}\n\n    # Generate session values for user if unavailable\n    if not valid_user_session(session):\n        session['config'] = default_config\n        session['uuid'] = str(uuid.uuid4())\n        session['key'] = app.enc_key\n        session['auth'] = False\n\n    # Establish config values per user session\n    g.user_config = Config(**session['config'])\n\n    # Update user config if specified in search args\n    g.user_config = g.user_config.from_params(g.request_params)\n\n    if not g.user_config.url:\n        g.user_config.url = get_request_url(request.url_root)\n\n    g.user_request = Request(\n        request.headers.get('User-Agent'),\n        get_request_url(request.url_root),\n        config=g.user_config)\n\n    g.app_location = g.user_config.url\n\n    # Attempt to reload bangs json if not generated yet\n    if not bang_json and os.path.getsize(app.config['BANG_FILE']) > 4:\n        try:\n            bang_json = json.load(open(app.config['BANG_FILE']))\n        except json.decoder.JSONDecodeError:\n            # Ignore decoding error, can occur if file is still\n            # being written\n            pass\n\n\n@app.after_request\ndef after_request_func(resp):\n    resp.headers['X-Content-Type-Options'] = 'nosniff'\n    resp.headers['X-Frame-Options'] = 'DENY'\n\n    if os.getenv('WHOOGLE_CSP', False):\n        resp.headers['Content-Security-Policy'] = app.config['CSP']\n        if os.environ.get('HTTPS_ONLY', False):\n            resp.headers['Content-Security-Policy'] += \\\n                'upgrade-insecure-requests'\n\n    return resp\n\n\n@app.errorhandler(404)\ndef unknown_page(e):\n    app.logger.warn(e)\n    return redirect(g.app_location)\n\n\n@app.route(f'/{Endpoint.healthz}', methods=['GET'])\ndef healthz():\n    return ''\n\n\n@app.route('/', methods=['GET'])\n@app.route(f'/{Endpoint.home}', methods=['GET'])\n@auth_required\ndef index():\n    # Redirect if an error was raised\n    if 'error_message' in session and session['error_message']:\n        error_message = session['error_message']\n        session['error_message'] = ''\n        return render_template('error.html', error_message=error_message)\n\n    return render_template('index.html',\n                           has_update=app.config['HAS_UPDATE'],\n                           languages=app.config['LANGUAGES'],\n                           countries=app.config['COUNTRIES'],\n                           time_periods=app.config['TIME_PERIODS'],\n                           themes=app.config['THEMES'],\n                           autocomplete_enabled=autocomplete_enabled,\n                           translation=app.config['TRANSLATIONS'][\n                               g.user_config.get_localization_lang()\n                           ],\n                           logo=render_template(\n                               'logo.html',\n                               dark=g.user_config.dark),\n                           config_disabled=(\n                                   app.config['CONFIG_DISABLE'] or\n                                   not valid_user_session(session)),\n                           config=g.user_config,\n                           tor_available=int(os.environ.get('TOR_AVAILABLE')),\n                           version_number=app.config['VERSION_NUMBER'])\n\n\n@app.route(f'/{Endpoint.opensearch}', methods=['GET'])\ndef opensearch():\n    opensearch_url = g.app_location\n    if opensearch_url.endswith('/'):\n        opensearch_url = opensearch_url[:-1]\n\n    # Enforce https for opensearch template\n    if needs_https(opensearch_url):\n        opensearch_url = opensearch_url.replace('http://', 'https://', 1)\n\n    get_only = g.user_config.get_only or 'Chrome' in request.headers.get(\n        'User-Agent')\n\n    return render_template(\n        'opensearch.xml',\n        main_url=opensearch_url,\n        request_type='' if get_only else 'method=\"post\"',\n        search_type=request.args.get('tbm'),\n        search_name=get_search_name(request.args.get('tbm'))\n    ), 200, {'Content-Type': 'application/xml'}\n\n\n@app.route(f'/{Endpoint.search_html}', methods=['GET'])\ndef search_html():\n    search_url = g.app_location\n    if search_url.endswith('/'):\n        search_url = search_url[:-1]\n    return render_template('search.html', url=search_url)\n\n\n@app.route(f'/{Endpoint.autocomplete}', methods=['GET', 'POST'])\ndef autocomplete():\n    if os.getenv(ac_var) and not read_config_bool(ac_var):\n        return jsonify({})\n\n    q = g.request_params.get('q')\n    if not q:\n        # FF will occasionally (incorrectly) send the q field without a\n        # mimetype in the format \"b'q=<query>'\" through the request.data field\n        q = str(request.data).replace('q=', '')\n\n    # Search bangs if the query begins with \"!\", but not \"! \" (feeling lucky)\n    if q.startswith('!') and len(q) > 1 and not q.startswith('! '):\n        return jsonify([q, [bang_json[_]['suggestion'] for _ in bang_json if\n                            _.startswith(q)]])\n\n    if not q and not request.data:\n        return jsonify({'?': []})\n    elif request.data:\n        q = urlparse.unquote_plus(\n            request.data.decode('utf-8').replace('q=', ''))\n\n    # Return a list of suggestions for the query\n    #\n    # Note: If Tor is enabled, this returns nothing, as the request is\n    # almost always rejected\n    return jsonify([\n        q,\n        g.user_request.autocomplete(q) if not g.user_config.tor else []\n    ])\n\n@app.route(f'/{Endpoint.search}', methods=['GET', 'POST'])\n@session_required\n@auth_required\ndef search():\n    search_util = Search(request, g.user_config, g.session_key)\n    query = search_util.new_search_query()\n\n    bang = resolve_bang(query, bang_json)\n    if bang:\n        return redirect(bang)\n\n    # Redirect to home if invalid/blank search\n    if not query:\n        return redirect(url_for('.index'))\n\n    # Generate response and number of external elements from the page\n    try:\n        response = search_util.generate_response()\n    except TorError as e:\n        session['error_message'] = e.message + (\n            \"\\\\n\\\\nTor config is now disabled!\" if e.disable else \"\")\n        session['config']['tor'] = False if e.disable else session['config'][\n            'tor']\n        return redirect(url_for('.index'))\n\n    if search_util.feeling_lucky:\n        return redirect(response, code=303)\n\n    # If the user is attempting to translate a string, determine the correct\n    # string for formatting the lingva.ml url\n    localization_lang = g.user_config.get_localization_lang()\n    translation = app.config['TRANSLATIONS'][localization_lang]\n    translate_to = localization_lang.replace('lang_', '')\n\n    # removing st-card to only use whoogle time selector\n    soup = bsoup(response, \"html.parser\");\n    for x in soup.find_all(attrs={\"id\": \"st-card\"}):\n        x.replace_with(\"\")\n\n    response = str(soup)\n\n    # Return 503 if temporarily blocked by captcha\n    if has_captcha(str(response)):\n        app.logger.error('503 (CAPTCHA)')\n        return render_template(\n            'error.html',\n            blocked=True,\n            error_message=translation['ratelimit'],\n            translation=translation,\n            farside='https://farside.link',\n            config=g.user_config,\n            query=urlparse.unquote(query),\n            params=g.user_config.to_params(keys=['preferences'])), 503\n\n    response = bold_search_terms(response, query)\n\n    # check for widgets and add if requested\n    if search_util.widget != '':\n        html_soup = bsoup(str(response), 'html.parser')\n        if search_util.widget == 'ip':\n            response = add_ip_card(html_soup, get_client_ip(request))\n        elif search_util.widget == 'calculator' and not 'nojs' in request.args:\n            response = add_calculator_card(html_soup)\n\n    # Update tabs content\n    tabs = get_tabs_content(app.config['HEADER_TABS'],\n                            search_util.full_query,\n                            search_util.search_type,\n                            g.user_config.preferences,\n                            translation)\n\n    # Feature to display currency_card\n    # Since this is determined by more than just the\n    # query is it not defined as a standard widget\n    conversion = check_currency(str(response))\n    if conversion:\n        html_soup = bsoup(str(response), 'html.parser')\n        response = add_currency_card(html_soup, conversion)\n\n    preferences = g.user_config.preferences\n    home_url = f\"home?preferences={preferences}\" if preferences else \"home\"\n    cleanresponse = str(response).replace(\"andlt;\",\"&lt;\").replace(\"andgt;\",\"&gt;\")\n\n    return render_template(\n        'display.html',\n        has_update=app.config['HAS_UPDATE'],\n        query=urlparse.unquote(query),\n        search_type=search_util.search_type,\n        search_name=get_search_name(search_util.search_type),\n        config=g.user_config,\n        autocomplete_enabled=autocomplete_enabled,\n        lingva_url=app.config['TRANSLATE_URL'],\n        translation=translation,\n        translate_to=translate_to,\n        translate_str=query.replace(\n            'translate', ''\n        ).replace(\n            translation['translate'], ''\n        ),\n        is_translation=any(\n            _ in query.lower() for _ in [translation['translate'], 'translate']\n        ) and not search_util.search_type,  # Standard search queries only\n        response=cleanresponse,\n        version_number=app.config['VERSION_NUMBER'],\n        search_header=render_template(\n            'header.html',\n            home_url=home_url,\n            config=g.user_config,\n            translation=translation,\n            languages=app.config['LANGUAGES'],\n            countries=app.config['COUNTRIES'],\n            time_periods=app.config['TIME_PERIODS'],\n            logo=render_template('logo.html', dark=g.user_config.dark),\n            query=urlparse.unquote(query),\n            search_type=search_util.search_type,\n            mobile=g.user_request.mobile,\n            tabs=tabs)).replace(\"  \", \"\")\n\n\n@app.route(f'/{Endpoint.config}', methods=['GET', 'POST', 'PUT'])\n@session_required\n@auth_required\ndef config():\n    config_disabled = (\n            app.config['CONFIG_DISABLE'] or\n            not valid_user_session(session))\n    if request.method == 'GET':\n        return json.dumps(g.user_config.__dict__)\n    elif request.method == 'PUT' and not config_disabled:\n        if 'name' in request.args:\n            config_pkl = os.path.join(\n                app.config['CONFIG_PATH'],\n                request.args.get('name'))\n            session['config'] = (pickle.load(open(config_pkl, 'rb'))\n                                 if os.path.exists(config_pkl)\n                                 else session['config'])\n            return json.dumps(session['config'])\n        else:\n            return json.dumps({})\n    elif not config_disabled:\n        config_data = request.form.to_dict()\n        if 'url' not in config_data or not config_data['url']:\n            config_data['url'] = g.user_config.url\n\n        # Save config by name to allow a user to easily load later\n        if 'name' in request.args:\n            pickle.dump(\n                config_data,\n                open(os.path.join(\n                    app.config['CONFIG_PATH'],\n                    request.args.get('name')), 'wb'))\n\n        session['config'] = config_data\n        return redirect(config_data['url'])\n    else:\n        return redirect(url_for('.index'), code=403)\n\n\n@app.route(f'/{Endpoint.imgres}')\n@session_required\n@auth_required\ndef imgres():\n    return redirect(request.args.get('imgurl'))\n\n\n@app.route(f'/{Endpoint.element}')\n@session_required\n@auth_required\ndef element():\n    element_url = src_url = request.args.get('url')\n    if element_url.startswith('gAAAAA'):\n        try:\n            cipher_suite = Fernet(g.session_key)\n            src_url = cipher_suite.decrypt(element_url.encode()).decode()\n        except (InvalidSignature, InvalidToken) as e:\n            return render_template(\n                'error.html',\n                error_message=str(e)), 401\n\n    src_type = request.args.get('type')\n\n    try:\n        file_data = g.user_request.send(base_url=src_url).content\n        tmp_mem = io.BytesIO()\n        tmp_mem.write(file_data)\n        tmp_mem.seek(0)\n\n        return send_file(tmp_mem, mimetype=src_type)\n    except exceptions.RequestException:\n        pass\n\n    empty_gif = base64.b64decode(\n        'R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==')\n    return send_file(io.BytesIO(empty_gif), mimetype='image/gif')\n\n\n@app.route(f'/{Endpoint.window}')\n@session_required\n@auth_required\ndef window():\n    target_url = request.args.get('location')\n    if target_url.startswith('gAAAAA'):\n        cipher_suite = Fernet(g.session_key)\n        target_url = cipher_suite.decrypt(target_url.encode()).decode()\n\n    content_filter = Filter(\n        g.session_key,\n        root_url=request.url_root,\n        config=g.user_config)\n    target = urlparse.urlparse(target_url)\n    host_url = f'{target.scheme}://{target.netloc}'\n\n    get_body = g.user_request.send(base_url=target_url).text\n\n    results = bsoup(get_body, 'html.parser')\n    src_attrs = ['src', 'href', 'srcset', 'data-srcset', 'data-src']\n\n    # Parse HTML response and replace relative links w/ absolute\n    for element in results.find_all():\n        for attr in src_attrs:\n            if not element.has_attr(attr) or not element[attr].startswith('/'):\n                continue\n\n            element[attr] = host_url + element[attr]\n\n    # Replace or remove javascript sources\n    for script in results.find_all('script', {'src': True}):\n        if 'nojs' in request.args:\n            script.decompose()\n        else:\n            content_filter.update_element_src(script, 'application/javascript')\n\n    # Replace all possible image attributes\n    img_sources = ['src', 'data-src', 'data-srcset', 'srcset']\n    for img in results.find_all('img'):\n        _ = [\n            content_filter.update_element_src(img, 'image/png', attr=_)\n            for _ in img_sources if img.has_attr(_)\n        ]\n\n    # Replace all stylesheet sources\n    for link in results.find_all('link', {'href': True}):\n        content_filter.update_element_src(link, 'text/css', attr='href')\n\n    # Use anonymous view for all links on page\n    for a in results.find_all('a', {'href': True}):\n        a['href'] = f'{Endpoint.window}?location=' + a['href'] + (\n            '&nojs=1' if 'nojs' in request.args else '')\n\n    # Remove all iframes -- these are commonly used inside of <noscript> tags\n    # to enforce loading Google Analytics\n    for iframe in results.find_all('iframe'):\n        iframe.decompose()\n\n    return render_template(\n        'display.html',\n        response=results,\n        translation=app.config['TRANSLATIONS'][\n            g.user_config.get_localization_lang()\n        ]\n    )\n\n\n@app.route(f'/robots.txt')\ndef robots():\n    response = make_response(\n'''User-Agent: *\nDisallow: /''', 200)\n    response.mimetype = 'text/plain'\n    return response\n\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    return render_template('error.html', error_message=str(e)), 404\n\n\ndef run_app() -> None:\n    parser = argparse.ArgumentParser(\n        description='Whoogle Search console runner')\n    parser.add_argument(\n        '--port',\n        default=5000,\n        metavar='<port number>',\n        help='Specifies a port to run on (default 5000)')\n    parser.add_argument(\n        '--host',\n        default='127.0.0.1',\n        metavar='<ip address>',\n        help='Specifies the host address to use (default 127.0.0.1)')\n    parser.add_argument(\n        '--unix-socket',\n        default='',\n        metavar='</path/to/unix.sock>',\n        help='Listen for app on unix socket instead of host:port')\n    parser.add_argument(\n        '--debug',\n        default=False,\n        action='store_true',\n        help='Activates debug mode for the server (default False)')\n    parser.add_argument(\n        '--https-only',\n        default=False,\n        action='store_true',\n        help='Enforces HTTPS redirects for all requests')\n    parser.add_argument(\n        '--userpass',\n        default='',\n        metavar='<username:password>',\n        help='Sets a username/password basic auth combo (default None)')\n    parser.add_argument(\n        '--proxyauth',\n        default='',\n        metavar='<username:password>',\n        help='Sets a username/password for a HTTP/SOCKS proxy (default None)')\n    parser.add_argument(\n        '--proxytype',\n        default='',\n        metavar='<socks4|socks5|http>',\n        help='Sets a proxy type for all connections (default None)')\n    parser.add_argument(\n        '--proxyloc',\n        default='',\n        metavar='<location:port>',\n        help='Sets a proxy location for all connections (default None)')\n    args = parser.parse_args()\n\n    if args.userpass:\n        user_pass = args.userpass.split(':')\n        os.environ['WHOOGLE_USER'] = user_pass[0]\n        os.environ['WHOOGLE_PASS'] = user_pass[1]\n\n    if args.proxytype and args.proxyloc:\n        if args.proxyauth:\n            proxy_user_pass = args.proxyauth.split(':')\n            os.environ['WHOOGLE_PROXY_USER'] = proxy_user_pass[0]\n            os.environ['WHOOGLE_PROXY_PASS'] = proxy_user_pass[1]\n        os.environ['WHOOGLE_PROXY_TYPE'] = args.proxytype\n        os.environ['WHOOGLE_PROXY_LOC'] = args.proxyloc\n\n    if args.https_only:\n        os.environ['HTTPS_ONLY'] = '1'\n\n    if args.debug:\n        app.run(host=args.host, port=args.port, debug=args.debug)\n    elif args.unix_socket:\n        waitress.serve(app, unix_socket=args.unix_socket)\n    else:\n        waitress.serve(\n            app,\n            listen=\"{}:{}\".format(args.host, args.port),\n            url_prefix=os.environ.get('WHOOGLE_URL_PREFIX', ''))\n"], "fixing_code": ["import argparse\nimport base64\nimport io\nimport json\nimport os\nimport pickle\nimport re\nimport urllib.parse as urlparse\nimport uuid\nimport validators\nfrom datetime import datetime, timedelta\nfrom functools import wraps\n\nimport waitress\nfrom app import app\nfrom app.models.config import Config\nfrom app.models.endpoint import Endpoint\nfrom app.request import Request, TorError\nfrom app.utils.bangs import resolve_bang\nfrom app.utils.misc import get_proxy_host_url\nfrom app.filter import Filter\nfrom app.utils.misc import read_config_bool, get_client_ip, get_request_url, \\\n    check_for_update\nfrom app.utils.widgets import *\nfrom app.utils.results import bold_search_terms,\\\n    add_currency_card, check_currency, get_tabs_content\nfrom app.utils.search import Search, needs_https, has_captcha\nfrom app.utils.session import valid_user_session\nfrom bs4 import BeautifulSoup as bsoup\nfrom flask import jsonify, make_response, request, redirect, render_template, \\\n    send_file, session, url_for, g\nfrom requests import exceptions\nfrom requests.models import PreparedRequest\nfrom cryptography.fernet import Fernet, InvalidToken\nfrom cryptography.exceptions import InvalidSignature\n\n# Load DDG bang json files only on init\nbang_json = json.load(open(app.config['BANG_FILE'])) or {}\n\nac_var = 'WHOOGLE_AUTOCOMPLETE'\nautocomplete_enabled = os.getenv(ac_var, '1')\n\n\ndef get_search_name(tbm):\n    for tab in app.config['HEADER_TABS'].values():\n        if tab['tbm'] == tbm:\n            return tab['name']\n\n\ndef auth_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        # do not ask password if cookies already present\n        if (\n            valid_user_session(session)\n            and 'cookies_disabled' not in request.args\n            and session['auth']\n        ):\n            return f(*args, **kwargs)\n\n        auth = request.authorization\n\n        # Skip if username/password not set\n        whoogle_user = os.getenv('WHOOGLE_USER', '')\n        whoogle_pass = os.getenv('WHOOGLE_PASS', '')\n        if (not whoogle_user or not whoogle_pass) or (\n                auth\n                and whoogle_user == auth.username\n                and whoogle_pass == auth.password):\n            session['auth'] = True\n            return f(*args, **kwargs)\n        else:\n            return make_response('Not logged in', 401, {\n                'WWW-Authenticate': 'Basic realm=\"Login Required\"'})\n\n    return decorated\n\n\ndef session_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        if not valid_user_session(session):\n            session.pop('_permanent', None)\n\n        # Note: This sets all requests to use the encryption key determined per\n        # instance on app init. This can be updated in the future to use a key\n        # that is unique for their session (session['key']) but this should use\n        # a config setting to enable the session based key. Otherwise there can\n        # be problems with searches performed by users with cookies blocked if\n        # a session based key is always used.\n        g.session_key = app.enc_key\n\n        # Clear out old sessions\n        invalid_sessions = []\n        for user_session in os.listdir(app.config['SESSION_FILE_DIR']):\n            file_path = os.path.join(\n                app.config['SESSION_FILE_DIR'],\n                user_session)\n\n            try:\n                # Ignore files that are larger than the max session file size\n                if os.path.getsize(file_path) > app.config['MAX_SESSION_SIZE']:\n                    continue\n\n                with open(file_path, 'rb') as session_file:\n                    _ = pickle.load(session_file)\n                    data = pickle.load(session_file)\n                    if isinstance(data, dict) and 'valid' in data:\n                        continue\n                    invalid_sessions.append(file_path)\n            except Exception:\n                # Broad exception handling here due to how instances installed\n                # with pip seem to have issues storing unrelated files in the\n                # same directory as sessions\n                pass\n\n        for invalid_session in invalid_sessions:\n            try:\n                os.remove(invalid_session)\n            except FileNotFoundError:\n                # Don't throw error if the invalid session has been removed\n                pass\n\n        return f(*args, **kwargs)\n\n    return decorated\n\n\n@app.before_request\ndef before_request_func():\n    global bang_json\n    session.permanent = True\n\n    # Check for latest version if needed\n    now = datetime.now()\n    if now - timedelta(hours=24) > app.config['LAST_UPDATE_CHECK']:\n        app.config['LAST_UPDATE_CHECK'] = now\n        app.config['HAS_UPDATE'] = check_for_update(\n            app.config['RELEASES_URL'],\n            app.config['VERSION_NUMBER'])\n\n    g.request_params = (\n        request.args if request.method == 'GET' else request.form\n    )\n\n    default_config = json.load(open(app.config['DEFAULT_CONFIG'])) \\\n        if os.path.exists(app.config['DEFAULT_CONFIG']) else {}\n\n    # Generate session values for user if unavailable\n    if not valid_user_session(session):\n        session['config'] = default_config\n        session['uuid'] = str(uuid.uuid4())\n        session['key'] = app.enc_key\n        session['auth'] = False\n\n    # Establish config values per user session\n    g.user_config = Config(**session['config'])\n\n    # Update user config if specified in search args\n    g.user_config = g.user_config.from_params(g.request_params)\n\n    if not g.user_config.url:\n        g.user_config.url = get_request_url(request.url_root)\n\n    g.user_request = Request(\n        request.headers.get('User-Agent'),\n        get_request_url(request.url_root),\n        config=g.user_config)\n\n    g.app_location = g.user_config.url\n\n    # Attempt to reload bangs json if not generated yet\n    if not bang_json and os.path.getsize(app.config['BANG_FILE']) > 4:\n        try:\n            bang_json = json.load(open(app.config['BANG_FILE']))\n        except json.decoder.JSONDecodeError:\n            # Ignore decoding error, can occur if file is still\n            # being written\n            pass\n\n\n@app.after_request\ndef after_request_func(resp):\n    resp.headers['X-Content-Type-Options'] = 'nosniff'\n    resp.headers['X-Frame-Options'] = 'DENY'\n\n    if os.getenv('WHOOGLE_CSP', False):\n        resp.headers['Content-Security-Policy'] = app.config['CSP']\n        if os.environ.get('HTTPS_ONLY', False):\n            resp.headers['Content-Security-Policy'] += \\\n                'upgrade-insecure-requests'\n\n    return resp\n\n\n@app.errorhandler(404)\ndef unknown_page(e):\n    app.logger.warn(e)\n    return redirect(g.app_location)\n\n\n@app.route(f'/{Endpoint.healthz}', methods=['GET'])\ndef healthz():\n    return ''\n\n\n@app.route('/', methods=['GET'])\n@app.route(f'/{Endpoint.home}', methods=['GET'])\n@auth_required\ndef index():\n    # Redirect if an error was raised\n    if 'error_message' in session and session['error_message']:\n        error_message = session['error_message']\n        session['error_message'] = ''\n        return render_template('error.html', error_message=error_message)\n\n    return render_template('index.html',\n                           has_update=app.config['HAS_UPDATE'],\n                           languages=app.config['LANGUAGES'],\n                           countries=app.config['COUNTRIES'],\n                           time_periods=app.config['TIME_PERIODS'],\n                           themes=app.config['THEMES'],\n                           autocomplete_enabled=autocomplete_enabled,\n                           translation=app.config['TRANSLATIONS'][\n                               g.user_config.get_localization_lang()\n                           ],\n                           logo=render_template(\n                               'logo.html',\n                               dark=g.user_config.dark),\n                           config_disabled=(\n                                   app.config['CONFIG_DISABLE'] or\n                                   not valid_user_session(session)),\n                           config=g.user_config,\n                           tor_available=int(os.environ.get('TOR_AVAILABLE')),\n                           version_number=app.config['VERSION_NUMBER'])\n\n\n@app.route(f'/{Endpoint.opensearch}', methods=['GET'])\ndef opensearch():\n    opensearch_url = g.app_location\n    if opensearch_url.endswith('/'):\n        opensearch_url = opensearch_url[:-1]\n\n    # Enforce https for opensearch template\n    if needs_https(opensearch_url):\n        opensearch_url = opensearch_url.replace('http://', 'https://', 1)\n\n    get_only = g.user_config.get_only or 'Chrome' in request.headers.get(\n        'User-Agent')\n\n    return render_template(\n        'opensearch.xml',\n        main_url=opensearch_url,\n        request_type='' if get_only else 'method=\"post\"',\n        search_type=request.args.get('tbm'),\n        search_name=get_search_name(request.args.get('tbm'))\n    ), 200, {'Content-Type': 'application/xml'}\n\n\n@app.route(f'/{Endpoint.search_html}', methods=['GET'])\ndef search_html():\n    search_url = g.app_location\n    if search_url.endswith('/'):\n        search_url = search_url[:-1]\n    return render_template('search.html', url=search_url)\n\n\n@app.route(f'/{Endpoint.autocomplete}', methods=['GET', 'POST'])\ndef autocomplete():\n    if os.getenv(ac_var) and not read_config_bool(ac_var):\n        return jsonify({})\n\n    q = g.request_params.get('q')\n    if not q:\n        # FF will occasionally (incorrectly) send the q field without a\n        # mimetype in the format \"b'q=<query>'\" through the request.data field\n        q = str(request.data).replace('q=', '')\n\n    # Search bangs if the query begins with \"!\", but not \"! \" (feeling lucky)\n    if q.startswith('!') and len(q) > 1 and not q.startswith('! '):\n        return jsonify([q, [bang_json[_]['suggestion'] for _ in bang_json if\n                            _.startswith(q)]])\n\n    if not q and not request.data:\n        return jsonify({'?': []})\n    elif request.data:\n        q = urlparse.unquote_plus(\n            request.data.decode('utf-8').replace('q=', ''))\n\n    # Return a list of suggestions for the query\n    #\n    # Note: If Tor is enabled, this returns nothing, as the request is\n    # almost always rejected\n    return jsonify([\n        q,\n        g.user_request.autocomplete(q) if not g.user_config.tor else []\n    ])\n\n@app.route(f'/{Endpoint.search}', methods=['GET', 'POST'])\n@session_required\n@auth_required\ndef search():\n    search_util = Search(request, g.user_config, g.session_key)\n    query = search_util.new_search_query()\n\n    bang = resolve_bang(query, bang_json)\n    if bang:\n        return redirect(bang)\n\n    # Redirect to home if invalid/blank search\n    if not query:\n        return redirect(url_for('.index'))\n\n    # Generate response and number of external elements from the page\n    try:\n        response = search_util.generate_response()\n    except TorError as e:\n        session['error_message'] = e.message + (\n            \"\\\\n\\\\nTor config is now disabled!\" if e.disable else \"\")\n        session['config']['tor'] = False if e.disable else session['config'][\n            'tor']\n        return redirect(url_for('.index'))\n\n    if search_util.feeling_lucky:\n        return redirect(response, code=303)\n\n    # If the user is attempting to translate a string, determine the correct\n    # string for formatting the lingva.ml url\n    localization_lang = g.user_config.get_localization_lang()\n    translation = app.config['TRANSLATIONS'][localization_lang]\n    translate_to = localization_lang.replace('lang_', '')\n\n    # removing st-card to only use whoogle time selector\n    soup = bsoup(response, \"html.parser\");\n    for x in soup.find_all(attrs={\"id\": \"st-card\"}):\n        x.replace_with(\"\")\n\n    response = str(soup)\n\n    # Return 503 if temporarily blocked by captcha\n    if has_captcha(str(response)):\n        app.logger.error('503 (CAPTCHA)')\n        return render_template(\n            'error.html',\n            blocked=True,\n            error_message=translation['ratelimit'],\n            translation=translation,\n            farside='https://farside.link',\n            config=g.user_config,\n            query=urlparse.unquote(query),\n            params=g.user_config.to_params(keys=['preferences'])), 503\n\n    response = bold_search_terms(response, query)\n\n    # check for widgets and add if requested\n    if search_util.widget != '':\n        html_soup = bsoup(str(response), 'html.parser')\n        if search_util.widget == 'ip':\n            response = add_ip_card(html_soup, get_client_ip(request))\n        elif search_util.widget == 'calculator' and not 'nojs' in request.args:\n            response = add_calculator_card(html_soup)\n\n    # Update tabs content\n    tabs = get_tabs_content(app.config['HEADER_TABS'],\n                            search_util.full_query,\n                            search_util.search_type,\n                            g.user_config.preferences,\n                            translation)\n\n    # Feature to display currency_card\n    # Since this is determined by more than just the\n    # query is it not defined as a standard widget\n    conversion = check_currency(str(response))\n    if conversion:\n        html_soup = bsoup(str(response), 'html.parser')\n        response = add_currency_card(html_soup, conversion)\n\n    preferences = g.user_config.preferences\n    home_url = f\"home?preferences={preferences}\" if preferences else \"home\"\n    cleanresponse = str(response).replace(\"andlt;\",\"&lt;\").replace(\"andgt;\",\"&gt;\")\n\n    return render_template(\n        'display.html',\n        has_update=app.config['HAS_UPDATE'],\n        query=urlparse.unquote(query),\n        search_type=search_util.search_type,\n        search_name=get_search_name(search_util.search_type),\n        config=g.user_config,\n        autocomplete_enabled=autocomplete_enabled,\n        lingva_url=app.config['TRANSLATE_URL'],\n        translation=translation,\n        translate_to=translate_to,\n        translate_str=query.replace(\n            'translate', ''\n        ).replace(\n            translation['translate'], ''\n        ),\n        is_translation=any(\n            _ in query.lower() for _ in [translation['translate'], 'translate']\n        ) and not search_util.search_type,  # Standard search queries only\n        response=cleanresponse,\n        version_number=app.config['VERSION_NUMBER'],\n        search_header=render_template(\n            'header.html',\n            home_url=home_url,\n            config=g.user_config,\n            translation=translation,\n            languages=app.config['LANGUAGES'],\n            countries=app.config['COUNTRIES'],\n            time_periods=app.config['TIME_PERIODS'],\n            logo=render_template('logo.html', dark=g.user_config.dark),\n            query=urlparse.unquote(query),\n            search_type=search_util.search_type,\n            mobile=g.user_request.mobile,\n            tabs=tabs)).replace(\"  \", \"\")\n\n\n@app.route(f'/{Endpoint.config}', methods=['GET', 'POST', 'PUT'])\n@session_required\n@auth_required\ndef config():\n    config_disabled = (\n            app.config['CONFIG_DISABLE'] or\n            not valid_user_session(session))\n\n    name = ''\n    if 'name' in request.args:\n        name = os.path.normpath(request.args.get('name'))\n        if not re.match(r'^[A-Za-z0-9_.+-]+$', name):\n            return make_response('Invalid config name', 400)\n\n    if request.method == 'GET':\n        return json.dumps(g.user_config.__dict__)\n    elif request.method == 'PUT' and not config_disabled:\n        if name:\n            config_pkl = os.path.join(app.config['CONFIG_PATH'], name)\n            session['config'] = (pickle.load(open(config_pkl, 'rb'))\n                                 if os.path.exists(config_pkl)\n                                 else session['config'])\n            return json.dumps(session['config'])\n        else:\n            return json.dumps({})\n    elif not config_disabled:\n        config_data = request.form.to_dict()\n        if 'url' not in config_data or not config_data['url']:\n            config_data['url'] = g.user_config.url\n\n        # Save config by name to allow a user to easily load later\n        if 'name' in request.args:\n            pickle.dump(\n                config_data,\n                open(os.path.join(\n                    app.config['CONFIG_PATH'],\n                    name), 'wb'))\n\n        session['config'] = config_data\n        return redirect(config_data['url'])\n    else:\n        return redirect(url_for('.index'), code=403)\n\n\n@app.route(f'/{Endpoint.imgres}')\n@session_required\n@auth_required\ndef imgres():\n    return redirect(request.args.get('imgurl'))\n\n\n@app.route(f'/{Endpoint.element}')\n@session_required\n@auth_required\ndef element():\n    empty_gif = base64.b64decode(\n        'R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==')\n    element_url = src_url = request.args.get('url')\n    if element_url.startswith('gAAAAA'):\n        try:\n            cipher_suite = Fernet(g.session_key)\n            src_url = cipher_suite.decrypt(element_url.encode()).decode()\n        except (InvalidSignature, InvalidToken) as e:\n            return render_template(\n                'error.html',\n                error_message=str(e)), 401\n\n    src_type = request.args.get('type')\n\n    # Ensure requested element is from a valid domain\n    domain = urlparse.urlparse(src_url).netloc\n    if not validators.domain(domain):\n        return send_file(io.BytesIO(empty_gif), mimetype='image/gif')\n\n    try:\n        file_data = g.user_request.send(base_url=src_url).content\n        tmp_mem = io.BytesIO()\n        tmp_mem.write(file_data)\n        tmp_mem.seek(0)\n\n        return send_file(tmp_mem, mimetype=src_type)\n    except exceptions.RequestException:\n        pass\n\n    return send_file(io.BytesIO(empty_gif), mimetype='image/gif')\n\n\n@app.route(f'/{Endpoint.window}')\n@session_required\n@auth_required\ndef window():\n    target_url = request.args.get('location')\n    if target_url.startswith('gAAAAA'):\n        cipher_suite = Fernet(g.session_key)\n        target_url = cipher_suite.decrypt(target_url.encode()).decode()\n\n    content_filter = Filter(\n        g.session_key,\n        root_url=request.url_root,\n        config=g.user_config)\n    target = urlparse.urlparse(target_url)\n\n    # Ensure requested URL has a valid domain\n    if not validators.domain(target.netloc):\n        return render_template(\n            'error.html',\n            error_message='Invalid location'), 400\n\n    host_url = f'{target.scheme}://{target.netloc}'\n\n    get_body = g.user_request.send(base_url=target_url).text\n\n    results = bsoup(get_body, 'html.parser')\n    src_attrs = ['src', 'href', 'srcset', 'data-srcset', 'data-src']\n\n    # Parse HTML response and replace relative links w/ absolute\n    for element in results.find_all():\n        for attr in src_attrs:\n            if not element.has_attr(attr) or not element[attr].startswith('/'):\n                continue\n\n            element[attr] = host_url + element[attr]\n\n    # Replace or remove javascript sources\n    for script in results.find_all('script', {'src': True}):\n        if 'nojs' in request.args:\n            script.decompose()\n        else:\n            content_filter.update_element_src(script, 'application/javascript')\n\n    # Replace all possible image attributes\n    img_sources = ['src', 'data-src', 'data-srcset', 'srcset']\n    for img in results.find_all('img'):\n        _ = [\n            content_filter.update_element_src(img, 'image/png', attr=_)\n            for _ in img_sources if img.has_attr(_)\n        ]\n\n    # Replace all stylesheet sources\n    for link in results.find_all('link', {'href': True}):\n        content_filter.update_element_src(link, 'text/css', attr='href')\n\n    # Use anonymous view for all links on page\n    for a in results.find_all('a', {'href': True}):\n        a['href'] = f'{Endpoint.window}?location=' + a['href'] + (\n            '&nojs=1' if 'nojs' in request.args else '')\n\n    # Remove all iframes -- these are commonly used inside of <noscript> tags\n    # to enforce loading Google Analytics\n    for iframe in results.find_all('iframe'):\n        iframe.decompose()\n\n    return render_template(\n        'display.html',\n        response=results,\n        translation=app.config['TRANSLATIONS'][\n            g.user_config.get_localization_lang()\n        ]\n    )\n\n\n@app.route(f'/robots.txt')\ndef robots():\n    response = make_response(\n'''User-Agent: *\nDisallow: /''', 200)\n    response.mimetype = 'text/plain'\n    return response\n\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    return render_template('error.html', error_message=str(e)), 404\n\n\ndef run_app() -> None:\n    parser = argparse.ArgumentParser(\n        description='Whoogle Search console runner')\n    parser.add_argument(\n        '--port',\n        default=5000,\n        metavar='<port number>',\n        help='Specifies a port to run on (default 5000)')\n    parser.add_argument(\n        '--host',\n        default='127.0.0.1',\n        metavar='<ip address>',\n        help='Specifies the host address to use (default 127.0.0.1)')\n    parser.add_argument(\n        '--unix-socket',\n        default='',\n        metavar='</path/to/unix.sock>',\n        help='Listen for app on unix socket instead of host:port')\n    parser.add_argument(\n        '--debug',\n        default=False,\n        action='store_true',\n        help='Activates debug mode for the server (default False)')\n    parser.add_argument(\n        '--https-only',\n        default=False,\n        action='store_true',\n        help='Enforces HTTPS redirects for all requests')\n    parser.add_argument(\n        '--userpass',\n        default='',\n        metavar='<username:password>',\n        help='Sets a username/password basic auth combo (default None)')\n    parser.add_argument(\n        '--proxyauth',\n        default='',\n        metavar='<username:password>',\n        help='Sets a username/password for a HTTP/SOCKS proxy (default None)')\n    parser.add_argument(\n        '--proxytype',\n        default='',\n        metavar='<socks4|socks5|http>',\n        help='Sets a proxy type for all connections (default None)')\n    parser.add_argument(\n        '--proxyloc',\n        default='',\n        metavar='<location:port>',\n        help='Sets a proxy location for all connections (default None)')\n    args = parser.parse_args()\n\n    if args.userpass:\n        user_pass = args.userpass.split(':')\n        os.environ['WHOOGLE_USER'] = user_pass[0]\n        os.environ['WHOOGLE_PASS'] = user_pass[1]\n\n    if args.proxytype and args.proxyloc:\n        if args.proxyauth:\n            proxy_user_pass = args.proxyauth.split(':')\n            os.environ['WHOOGLE_PROXY_USER'] = proxy_user_pass[0]\n            os.environ['WHOOGLE_PROXY_PASS'] = proxy_user_pass[1]\n        os.environ['WHOOGLE_PROXY_TYPE'] = args.proxytype\n        os.environ['WHOOGLE_PROXY_LOC'] = args.proxyloc\n\n    if args.https_only:\n        os.environ['HTTPS_ONLY'] = '1'\n\n    if args.debug:\n        app.run(host=args.host, port=args.port, debug=args.debug)\n    elif args.unix_socket:\n        waitress.serve(app, unix_socket=args.unix_socket)\n    else:\n        waitress.serve(\n            app,\n            listen=\"{}:{}\".format(args.host, args.port),\n            url_prefix=os.environ.get('WHOOGLE_URL_PREFIX', ''))\n"], "filenames": ["app/routes.py"], "buggy_code_start_loc": [6], "buggy_code_end_loc": [506], "fixing_code_start_loc": [7], "fixing_code_end_loc": [526], "type": "CWE-918", "message": "Whoogle Search is a self-hosted metasearch engine. In versions prior to 0.8.4, the `element` method in `app/routes.py` does not validate the user-controlled `src_type` and `element_url` variables and passes them to the `send` method which sends a GET request on lines 339-343 in `request.py`, which leads to a server-side request forgery. This issue allows for crafting GET requests to internal and external resources on behalf of the server. For example, this issue would allow for accessing resources on the internal network that the server has access to, even though these resources may not be accessible on the internet. This issue is fixed in version 0.8.4.", "other": {"cve": {"id": "CVE-2024-22203", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-23T18:15:18.263", "lastModified": "2024-01-30T15:30:42.923", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Whoogle Search is a self-hosted metasearch engine. In versions prior to 0.8.4, the `element` method in `app/routes.py` does not validate the user-controlled `src_type` and `element_url` variables and passes them to the `send` method which sends a GET request on lines 339-343 in `request.py`, which leads to a server-side request forgery. This issue allows for crafting GET requests to internal and external resources on behalf of the server. For example, this issue would allow for accessing resources on the internal network that the server has access to, even though these resources may not be accessible on the internet. This issue is fixed in version 0.8.4."}, {"lang": "es", "value": "Whoogle Search es un metabuscador autohospedado. En versiones anteriores a la 0.8.4, el m\u00e9todo `element` en `app/routes.py` no valida las variables `src_type` y `element_url` controladas por el usuario y las pasa al m\u00e9todo `send` que env\u00eda una solicitud GET. en las l\u00edneas 339-343 en `request.py`, lo que conduce a server-side request forgery. Este problema permite elaborar solicitudes GET a recursos internos y externos en nombre del servidor. Por ejemplo, este problema permitir\u00eda acceder a recursos en la red interna a la que tiene acceso el servidor, aunque es posible que no se pueda acceder a estos recursos en Internet. Este problema se solucion\u00f3 en la versi\u00f3n 0.8.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:benbusby:whoogle_search:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.4", "matchCriteriaId": "D3DA218E-B891-4381-97E4-F0F1147E6309"}]}]}], "references": [{"url": "https://github.com/benbusby/whoogle-search/blob/92e8ede24e9277a5440d403f75877209f1269884/app/request.py#L339-L343", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/benbusby/whoogle-search/blob/92e8ede24e9277a5440d403f75877209f1269884/app/routes.py#L465-L490", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/benbusby/whoogle-search/blob/92e8ede24e9277a5440d403f75877209f1269884/app/routes.py#L466", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/benbusby/whoogle-search/blob/92e8ede24e9277a5440d403f75877209f1269884/app/routes.py#L476", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/benbusby/whoogle-search/blob/92e8ede24e9277a5440d403f75877209f1269884/app/routes.py#L479", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/benbusby/whoogle-search/commit/3a2e0b262e4a076a20416b45e6b6f23fd265aeda", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2023-186_GHSL-2023-189_benbusby_whoogle-search/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/benbusby/whoogle-search/commit/3a2e0b262e4a076a20416b45e6b6f23fd265aeda"}}