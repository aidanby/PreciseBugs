{"buggy_code": ["'use strict'\n\nconst { AsyncResource } = require('async_hooks')\nconst lru = require('tiny-lru').lru\n\nconst secureJson = require('secure-json-parse')\nconst {\n  kDefaultJsonParse,\n  kContentTypeParser,\n  kBodyLimit,\n  kRequestPayloadStream,\n  kState,\n  kTestInternals,\n  kReplyIsError,\n  kRouteContext\n} = require('./symbols')\n\nconst {\n  FST_ERR_CTP_INVALID_TYPE,\n  FST_ERR_CTP_EMPTY_TYPE,\n  FST_ERR_CTP_ALREADY_PRESENT,\n  FST_ERR_CTP_INVALID_HANDLER,\n  FST_ERR_CTP_INVALID_PARSE_TYPE,\n  FST_ERR_CTP_BODY_TOO_LARGE,\n  FST_ERR_CTP_INVALID_MEDIA_TYPE,\n  FST_ERR_CTP_INVALID_CONTENT_LENGTH,\n  FST_ERR_CTP_EMPTY_JSON_BODY\n} = require('./errors')\n\nfunction ContentTypeParser (bodyLimit, onProtoPoisoning, onConstructorPoisoning) {\n  this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning)\n  // using a map instead of a plain object to avoid prototype hijack attacks\n  this.customParsers = new Map()\n  this.customParsers.set('application/json', new Parser(true, false, bodyLimit, this[kDefaultJsonParse]))\n  this.customParsers.set('text/plain', new Parser(true, false, bodyLimit, defaultPlainTextParser))\n  this.parserList = ['application/json', 'text/plain']\n  this.parserRegExpList = []\n  this.cache = lru(100)\n}\n\nContentTypeParser.prototype.add = function (contentType, opts, parserFn) {\n  const contentTypeIsString = typeof contentType === 'string'\n\n  if (!contentTypeIsString && !(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()\n  if (contentTypeIsString && contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE()\n  if (typeof parserFn !== 'function') throw new FST_ERR_CTP_INVALID_HANDLER()\n\n  if (this.existingParser(contentType)) {\n    throw new FST_ERR_CTP_ALREADY_PRESENT(contentType)\n  }\n\n  if (opts.parseAs !== undefined) {\n    if (opts.parseAs !== 'string' && opts.parseAs !== 'buffer') {\n      throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs)\n    }\n  }\n\n  const parser = new Parser(\n    opts.parseAs === 'string',\n    opts.parseAs === 'buffer',\n    opts.bodyLimit,\n    parserFn\n  )\n\n  if (contentTypeIsString && contentType === '*') {\n    this.customParsers.set('', parser)\n  } else {\n    if (contentTypeIsString) {\n      this.parserList.unshift(contentType)\n    } else {\n      this.parserRegExpList.unshift(contentType)\n    }\n    this.customParsers.set(contentType.toString(), parser)\n  }\n}\n\nContentTypeParser.prototype.hasParser = function (contentType) {\n  return this.customParsers.has(typeof contentType === 'string' ? contentType : contentType.toString())\n}\n\nContentTypeParser.prototype.existingParser = function (contentType) {\n  if (contentType === 'application/json' && this.customParsers.has(contentType)) {\n    return this.customParsers.get(contentType).fn !== this[kDefaultJsonParse]\n  }\n  if (contentType === 'text/plain' && this.customParsers.has(contentType)) {\n    return this.customParsers.get(contentType).fn !== defaultPlainTextParser\n  }\n\n  return this.hasParser(contentType)\n}\n\nContentTypeParser.prototype.getParser = function (contentType) {\n  if (this.hasParser(contentType)) {\n    return this.customParsers.get(contentType)\n  }\n\n  const parser = this.cache.get(contentType)\n  if (parser !== undefined) return parser\n\n  // eslint-disable-next-line no-var\n  for (var i = 0; i !== this.parserList.length; ++i) {\n    const parserName = this.parserList[i]\n    if (contentType.indexOf(parserName) !== -1) {\n      const parser = this.customParsers.get(parserName)\n      this.cache.set(contentType, parser)\n      return parser\n    }\n  }\n\n  // eslint-disable-next-line no-var\n  for (var j = 0; j !== this.parserRegExpList.length; ++j) {\n    const parserRegExp = this.parserRegExpList[j]\n    if (parserRegExp.test(contentType)) {\n      const parser = this.customParsers.get(parserRegExp.toString())\n      this.cache.set(contentType, parser)\n      return parser\n    }\n  }\n\n  return this.customParsers.get('')\n}\n\nContentTypeParser.prototype.removeAll = function () {\n  this.customParsers = new Map()\n  this.parserRegExpList = []\n  this.parserList = []\n  this.cache = lru(100)\n}\n\nContentTypeParser.prototype.remove = function (contentType) {\n  if (!(typeof contentType === 'string' || contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()\n\n  this.customParsers.delete(contentType.toString())\n\n  const parsers = typeof contentType === 'string' ? this.parserList : this.parserRegExpList\n\n  const idx = parsers.findIndex(ct => ct.toString() === contentType.toString())\n\n  if (idx > -1) {\n    parsers.splice(idx, 1)\n  }\n}\n\nContentTypeParser.prototype.run = function (contentType, handler, request, reply) {\n  const parser = this.getParser(contentType)\n  const resource = new AsyncResource('content-type-parser:run', request)\n\n  if (parser === undefined) {\n    if (request.is404) {\n      handler(request, reply)\n    } else {\n      reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || undefined))\n    }\n  } else if (parser.asString === true || parser.asBuffer === true) {\n    rawBody(\n      request,\n      reply,\n      reply[kRouteContext]._parserOptions,\n      parser,\n      done\n    )\n  } else {\n    const result = parser.fn(request, request[kRequestPayloadStream], done)\n\n    if (result && typeof result.then === 'function') {\n      result.then(body => done(null, body), done)\n    }\n  }\n\n  function done (error, body) {\n    // We cannot use resource.bind() because it is broken in node v12 and v14\n    resource.runInAsyncScope(() => {\n      if (error) {\n        reply[kReplyIsError] = true\n        reply.send(error)\n      } else {\n        request.body = body\n        handler(request, reply)\n      }\n    })\n  }\n}\n\nfunction rawBody (request, reply, options, parser, done) {\n  const asString = parser.asString\n  const limit = options.limit === null ? parser.bodyLimit : options.limit\n  const contentLength = request.headers['content-length'] === undefined\n    ? NaN\n    : Number(request.headers['content-length'])\n\n  if (contentLength > limit) {\n    // We must close the connection as the client is going\n    // to send this data anyway\n    reply.header('connection', 'close')\n    reply.send(new FST_ERR_CTP_BODY_TOO_LARGE())\n    return\n  }\n\n  let receivedLength = 0\n  let body = asString === true ? '' : []\n\n  const payload = request[kRequestPayloadStream] || request.raw\n\n  if (asString === true) {\n    payload.setEncoding('utf8')\n  }\n\n  payload.on('data', onData)\n  payload.on('end', onEnd)\n  payload.on('error', onEnd)\n  payload.resume()\n\n  function onData (chunk) {\n    receivedLength += chunk.length\n\n    if ((payload.receivedEncodedLength || receivedLength) > limit) {\n      payload.removeListener('data', onData)\n      payload.removeListener('end', onEnd)\n      payload.removeListener('error', onEnd)\n      reply.send(new FST_ERR_CTP_BODY_TOO_LARGE())\n      return\n    }\n\n    if (asString === true) {\n      body += chunk\n    } else {\n      body.push(chunk)\n    }\n  }\n\n  function onEnd (err) {\n    payload.removeListener('data', onData)\n    payload.removeListener('end', onEnd)\n    payload.removeListener('error', onEnd)\n\n    if (err !== undefined) {\n      err.statusCode = 400\n      reply[kReplyIsError] = true\n      reply.code(err.statusCode).send(err)\n      return\n    }\n\n    if (asString === true) {\n      receivedLength = Buffer.byteLength(body)\n    }\n\n    if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {\n      reply.header('connection', 'close')\n      reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH())\n      return\n    }\n\n    if (asString === false) {\n      body = Buffer.concat(body)\n    }\n\n    const result = parser.fn(request, body, done)\n    if (result && typeof result.then === 'function') {\n      result.then(body => done(null, body), done)\n    }\n  }\n}\n\nfunction getDefaultJsonParser (onProtoPoisoning, onConstructorPoisoning) {\n  return defaultJsonParser\n\n  function defaultJsonParser (req, body, done) {\n    if (body === '' || body == null) {\n      return done(new FST_ERR_CTP_EMPTY_JSON_BODY(), undefined)\n    }\n    let json\n    try {\n      json = secureJson.parse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning })\n    } catch (err) {\n      err.statusCode = 400\n      return done(err, undefined)\n    }\n    done(null, json)\n  }\n}\n\nfunction defaultPlainTextParser (req, body, done) {\n  done(null, body)\n}\n\nfunction Parser (asString, asBuffer, bodyLimit, fn) {\n  this.asString = asString\n  this.asBuffer = asBuffer\n  this.bodyLimit = bodyLimit\n  this.fn = fn\n}\n\nfunction buildContentTypeParser (c) {\n  const contentTypeParser = new ContentTypeParser()\n  contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse]\n  contentTypeParser.customParsers = new Map(c.customParsers.entries())\n  contentTypeParser.parserList = c.parserList.slice()\n  return contentTypeParser\n}\n\nfunction addContentTypeParser (contentType, opts, parser) {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"addContentTypeParser\" when fastify instance is already started!')\n  }\n\n  if (typeof opts === 'function') {\n    parser = opts\n    opts = {}\n  }\n\n  if (!opts) opts = {}\n  if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit]\n\n  if (Array.isArray(contentType)) {\n    contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser))\n  } else {\n    this[kContentTypeParser].add(contentType, opts, parser)\n  }\n\n  return this\n}\n\nfunction hasContentTypeParser (contentType) {\n  return this[kContentTypeParser].hasParser(contentType)\n}\n\nfunction removeContentTypeParser (contentType) {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"removeContentTypeParser\" when fastify instance is already started!')\n  }\n\n  if (Array.isArray(contentType)) {\n    for (const type of contentType) {\n      this[kContentTypeParser].remove(type)\n    }\n  } else {\n    this[kContentTypeParser].remove(contentType)\n  }\n}\n\nfunction removeAllContentTypeParsers () {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"removeAllContentTypeParsers\" when fastify instance is already started!')\n  }\n\n  this[kContentTypeParser].removeAll()\n}\n\nmodule.exports = ContentTypeParser\nmodule.exports.helpers = {\n  buildContentTypeParser,\n  addContentTypeParser,\n  hasContentTypeParser,\n  removeContentTypeParser,\n  removeAllContentTypeParsers\n}\nmodule.exports.defaultParsers = {\n  getDefaultJsonParser,\n  defaultTextParser: defaultPlainTextParser\n}\nmodule.exports[kTestInternals] = { rawBody }\n", "{\n  \"name\": \"fastify\",\n    \"version\": \"4.10.1\",\n  \"description\": \"Fast and low overhead web framework, for Node.js\",\n  \"main\": \"fastify.js\",\n  \"type\": \"commonjs\",\n  \"types\": \"fastify.d.ts\",\n  \"scripts\": {\n    \"bench\": \"branchcmp -r 2 -g -s \\\"npm run benchmark\\\"\",\n    \"benchmark\": \"npx concurrently -k -s first \\\"node ./examples/benchmark/simple.js\\\" \\\"npx autocannon -c 100 -d 30 -p 10 localhost:3000/\\\"\",\n    \"coverage\": \"npm run unit -- --cov --coverage-report=html\",\n    \"coverage:ci\": \"npm run unit -- --cov --coverage-report=html --no-browser --no-check-coverage -R terse\",\n    \"coverage:ci-check-coverage\": \"nyc check-coverage --branches 100 --functions 100 --lines 100 --statements 100\",\n    \"license-checker\": \"license-checker --production --onlyAllow=\\\"MIT;ISC;BSD-3-Clause;BSD-2-Clause\\\"\",\n    \"lint\": \"npm run lint:standard && npm run lint:typescript && npm run lint:markdown\",\n    \"lint:fix\": \"standard --fix\",\n    \"lint:markdown\": \"markdownlint-cli2\",\n    \"lint:standard\": \"standard | snazzy\",\n    \"lint:typescript\": \"eslint -c types/.eslintrc.json types/**/*.d.ts test/types/**/*.test-d.ts\",\n    \"prepublishOnly\": \"PREPUBLISH=true tap --no-check-coverage test/build/**.test.js\",\n    \"test\": \"npm run lint && npm run unit && npm run test:typescript\",\n    \"test:ci\": \"npm run unit -- -R terse --cov --coverage-report=lcovonly && npm run test:typescript\",\n    \"test:report\": \"npm run lint && npm run unit:report && npm run test:typescript\",\n    \"test:typescript\": \"tsc test/types/import.ts && tsd\",\n    \"test:watch\": \"npm run unit -- -w --no-coverage-report -R terse\",\n    \"unit\": \"tap\",\n    \"unit:junit\": \"tap-mocha-reporter xunit < out.tap > test/junit-testresults.xml\",\n    \"unit:report\": \"tap --cov --coverage-report=html --coverage-report=cobertura | tee out.tap\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/fastify/fastify.git\"\n  },\n  \"keywords\": [\n    \"web\",\n    \"framework\",\n    \"json\",\n    \"schema\",\n    \"open\",\n    \"api\"\n  ],\n  \"author\": \"Matteo Collina <hello@matteocollina.com>\",\n  \"contributors\": [\n    {\n      \"name\": \"Tomas Della Vedova\",\n      \"url\": \"http://delved.org\",\n      \"author\": true\n    },\n    {\n      \"name\": \"Tommaso Allevi\",\n      \"email\": \"tomallevi@gmail.com\"\n    },\n    {\n      \"name\": \"Ethan Arrowood\",\n      \"url\": \"https://github.com/Ethan-Arrowood\",\n      \"email\": \"ethan.arrowood@gmail.com\"\n    },\n    {\n      \"name\": \"Dustin Deus\",\n      \"url\": \"http://starptech.de\",\n      \"email\": \"deusdustin@gmail.com\"\n    },\n    {\n      \"name\": \"Ayoub El Khattabi\",\n      \"url\": \"https://github.com/AyoubElk\",\n      \"email\": \"elkhattabi.ayoub@gmail.com\"\n    },\n    {\n      \"name\": \"Rafael Gonzaga\",\n      \"email\": \"rafael.nunu@hotmail.com\",\n      \"url\": \"https://github.com/rafaelgss\"\n    },\n    {\n      \"name\": \"Trivikram Kamat\",\n      \"url\": \"http://trivikr.github.io\",\n      \"email\": \"trivikr.dev@gmail.com\"\n    },\n    {\n      \"name\": \"Luciano Mammino\",\n      \"url\": \"https://loige.co\"\n    },\n    {\n      \"name\": \"Cemre Mengu\",\n      \"email\": \"cemremengu@gmail.com\"\n    },\n    {\n      \"name\": \"Evan Shortiss\",\n      \"email\": \"evanshortiss@gmail.com\"\n    },\n    {\n      \"name\": \"Maksim Sinik\",\n      \"url\": \"https://maksim.dev\"\n    },\n    {\n      \"name\": \"Manuel Spigolon\",\n      \"email\": \"behemoth89@gmail.com\"\n    },\n    {\n      \"name\": \"James Sumners\",\n      \"url\": \"https://james.sumners.info\"\n    },\n    {\n      \"name\": \"Denis F\u00e4cke\",\n      \"url\": \"https://github.com/SerayaEryn\"\n    },\n    {\n      \"name\": \"Igor Savin\",\n      \"email\": \"kibertoad@gmail.com\",\n      \"url\": \"https://github.com/kibertoad\"\n    },\n    {\n      \"name\": \"Vincent Le Goff\",\n      \"email\": \"vince.legoff@gmail.com\",\n      \"url\": \"https://github.com/zekth\"\n    },\n    {\n      \"name\": \"Luis Orbaiceta\",\n      \"email\": \"luisorbaiceta@gmail.com\",\n      \"url\": \"https://luisorbaiceta.com\"\n    }\n  ],\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/fastify/fastify/issues\"\n  },\n  \"homepage\": \"https://www.fastify.io/\",\n  \"devDependencies\": {\n    \"@fastify/pre-commit\": \"^2.0.2\",\n    \"@sinclair/typebox\": \"^0.25.2\",\n    \"@sinonjs/fake-timers\": \"^10.0.0\",\n    \"@types/node\": \"^18.7.18\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.37.0\",\n    \"@typescript-eslint/parser\": \"^5.37.0\",\n    \"ajv\": \"^8.11.0\",\n    \"ajv-errors\": \"^3.0.0\",\n    \"ajv-formats\": \"^2.1.1\",\n    \"ajv-i18n\": \"^4.2.0\",\n    \"ajv-merge-patch\": \"^5.0.1\",\n    \"branch-comparer\": \"^1.1.0\",\n    \"eslint\": \"^8.23.1\",\n    \"eslint-config-standard\": \"^17.0.0\",\n    \"eslint-import-resolver-node\": \"^0.3.6\",\n    \"eslint-plugin-import\": \"^2.26.0\",\n    \"eslint-plugin-n\": \"^15.2.5\",\n    \"eslint-plugin-promise\": \"^6.0.1\",\n    \"fast-json-body\": \"^1.1.0\",\n    \"fast-json-stringify\": \"^5.3.0\",\n    \"fastify-plugin\": \"^4.2.1\",\n    \"fluent-json-schema\": \"^4.0.0\",\n    \"form-data\": \"^4.0.0\",\n    \"h2url\": \"^0.2.0\",\n    \"http-errors\": \"^2.0.0\",\n    \"joi\": \"^17.6.0\",\n    \"json-schema-to-ts\": \"^2.5.5\",\n    \"JSONStream\": \"^1.3.5\",\n    \"license-checker\": \"^25.0.1\",\n    \"markdownlint-cli2\": \"^0.5.1\",\n    \"proxyquire\": \"^2.1.3\",\n    \"pump\": \"^3.0.0\",\n    \"self-cert\": \"^2.0.0\",\n    \"send\": \"^0.18.0\",\n    \"simple-get\": \"^4.0.1\",\n    \"snazzy\": \"^9.0.0\",\n    \"split2\": \"^4.1.0\",\n    \"standard\": \"^17.0.0\",\n    \"tap\": \"^16.3.0\",\n    \"tsd\": \"^0.24.1\",\n    \"typescript\": \"^4.8.3\",\n    \"undici\": \"^5.10.0\",\n    \"vary\": \"^1.1.2\",\n    \"yup\": \"^0.32.11\"\n  },\n  \"dependencies\": {\n    \"@fastify/ajv-compiler\": \"^3.3.1\",\n    \"@fastify/error\": \"^3.0.0\",\n    \"@fastify/fast-json-stringify-compiler\": \"^4.1.0\",\n    \"abstract-logging\": \"^2.0.1\",\n    \"avvio\": \"^8.2.0\",\n    \"find-my-way\": \"^7.3.0\",\n    \"light-my-request\": \"^5.6.1\",\n    \"pino\": \"^8.5.0\",\n    \"process-warning\": \"^2.0.0\",\n    \"proxy-addr\": \"^2.0.7\",\n    \"rfdc\": \"^1.3.0\",\n    \"secure-json-parse\": \"^2.5.0\",\n    \"semver\": \"^7.3.7\",\n    \"tiny-lru\": \"^10.0.0\"\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"lib/configValidator.js\",\n      \"lib/error-serializer.js\",\n      \"fastify.d.ts\",\n      \"types/*\",\n      \"test/types/*\",\n      \"test/same-shape.test.js\"\n    ]\n  },\n  \"tsd\": {\n    \"directory\": \"test/types\"\n  }\n}\n", "'use strict'\n\nconst t = require('tap')\nconst test = t.test\nconst Fastify = require('..')\nconst keys = require('../lib/symbols')\nconst { FST_ERR_CTP_ALREADY_PRESENT, FST_ERR_CTP_INVALID_TYPE, FST_ERR_CTP_INVALID_MEDIA_TYPE } = require('../lib/errors')\n\nconst first = function (req, payload, done) {}\nconst second = function (req, payload, done) {}\nconst third = function (req, payload, done) {}\n\ntest('hasContentTypeParser', t => {\n  test('should know about internal parsers', t => {\n    t.plan(4)\n\n    const fastify = Fastify()\n    fastify.ready(err => {\n      t.error(err)\n      t.ok(fastify.hasContentTypeParser('application/json'))\n      t.ok(fastify.hasContentTypeParser('text/plain'))\n      t.notOk(fastify.hasContentTypeParser('application/jsoff'))\n    })\n  })\n\n  test('should work with string and RegExp', t => {\n    t.plan(7)\n\n    const fastify = Fastify()\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n    fastify.addContentTypeParser('image/gif', first)\n\n    t.ok(fastify.hasContentTypeParser('application/json'))\n    t.ok(fastify.hasContentTypeParser(/^image\\/.*/))\n    t.ok(fastify.hasContentTypeParser(/^application\\/.+\\+xml/))\n    t.ok(fastify.hasContentTypeParser('image/gif'))\n    t.notOk(fastify.hasContentTypeParser(/^image\\/.+\\+xml/))\n    t.notOk(fastify.hasContentTypeParser('image/png'))\n    t.notOk(fastify.hasContentTypeParser('*'))\n  })\n\n  t.end()\n})\n\ntest('getParser', t => {\n  test('should return matching parser', t => {\n    t.plan(3)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, second)\n    fastify.addContentTypeParser('text/html', third)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('application/t+xml').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/png').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, third)\n  })\n\n  test('should return matching parser with caching', t => {\n    t.plan(6)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('text/html', first)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 0)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html ').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 1)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html ').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 1)\n  })\n\n  test('should prefer content type parser with string value', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser('image/gif', second)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/gif').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/png').fn, first)\n  })\n\n  test('should return parser that catches all if no other is set', t => {\n    t.plan(3)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('*', first)\n    fastify.addContentTypeParser(/^text\\/.*/, second)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/gif').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text').fn, first)\n  })\n\n  test('should return undefined if no matching parser exist', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^weirdType\\/.+/, first)\n    fastify.addContentTypeParser('application/javascript', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].getParser('application/xml'))\n    t.notOk(fastify[keys.kContentTypeParser].getParser('weirdType/'))\n  })\n\n  t.end()\n})\n\ntest('existingParser', t => {\n  test('returns always false for \"*\"', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n    fastify.addContentTypeParser('text/html', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].existingParser('*'))\n\n    fastify.addContentTypeParser('*', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].existingParser('*'))\n  })\n\n  test('let you override the default parser once', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('application/json', first)\n    fastify.addContentTypeParser('text/plain', first)\n\n    t.throws(\n      () => fastify.addContentTypeParser('application/json', first),\n      FST_ERR_CTP_ALREADY_PRESENT,\n      \"Content type parser 'application/json' already present\"\n    )\n    t.throws(\n      () => fastify.addContentTypeParser('text/plain', first),\n      FST_ERR_CTP_ALREADY_PRESENT,\n      \"Content type parser 'text/plain' already present\"\n    )\n  })\n\n  const fastify = Fastify()\n  const contentTypeParser = fastify[keys.kContentTypeParser]\n\n  fastify.addContentTypeParser(/^image\\/.*/, first)\n  fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n  fastify.addContentTypeParser('text/html', first)\n\n  t.ok(contentTypeParser.existingParser(/^image\\/.*/))\n  t.ok(contentTypeParser.existingParser('text/html'))\n  t.ok(contentTypeParser.existingParser(/^application\\/.+\\+xml/))\n  t.notOk(contentTypeParser.existingParser('application/json'))\n  t.notOk(contentTypeParser.existingParser('text/plain'))\n  t.notOk(contentTypeParser.existingParser('image/png'))\n  t.notOk(contentTypeParser.existingParser(/^application\\/.+\\+json/))\n\n  t.end()\n})\n\ntest('add', t => {\n  test('should only accept string and RegExp', t => {\n    t.plan(4)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    t.error(contentTypeParser.add('test', {}, first))\n    t.error(contentTypeParser.add(/test/, {}, first))\n    t.throws(\n      () => contentTypeParser.add({}, {}, first),\n      FST_ERR_CTP_INVALID_TYPE,\n      'The content type should be a string or a RegExp'\n    )\n    t.throws(\n      () => contentTypeParser.add(1, {}, first),\n      FST_ERR_CTP_INVALID_TYPE,\n      'The content type should be a string or a RegExp'\n    )\n  })\n\n  test('should set \"*\" as parser that catches all', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.add('*', {}, first)\n    t.equal(contentTypeParser.customParsers.get('').fn, first)\n  })\n\n  t.end()\n})\n\ntest('non-Error thrown from content parser is properly handled', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n\n  const throwable = 'test'\n  const payload = 'error'\n\n  fastify.addContentTypeParser('text/test', (request, payload, done) => {\n    done(throwable)\n  })\n\n  fastify.post('/', (req, reply) => {\n  })\n\n  fastify.setErrorHandler((err, req, res) => {\n    t.equal(err, throwable)\n\n    res.send(payload)\n  })\n\n  fastify.inject({\n    method: 'POST',\n    url: '/',\n    headers: { 'Content-Type': 'text/test' },\n    body: 'some text'\n  }, (err, res) => {\n    t.error(err)\n    t.equal(res.payload, payload)\n  })\n})\n\ntest('Error thrown 415 from content type is null and make post request to server', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n  const errMsg = new FST_ERR_CTP_INVALID_MEDIA_TYPE(undefined).message\n\n  fastify.post('/', (req, reply) => {\n  })\n\n  fastify.inject({\n    method: 'POST',\n    url: '/',\n    body: 'some text'\n  }, (err, res) => {\n    t.error(err)\n    t.equal(res.statusCode, 415)\n    t.equal(JSON.parse(res.body).message, errMsg)\n  })\n})\n\ntest('remove', t => {\n  test('should remove default parser', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove('application/json')\n\n    t.notOk(contentTypeParser.customParsers['application/json'])\n    t.notOk(contentTypeParser.parserList.find(parser => parser === 'application/json'))\n  })\n\n  test('should remove RegExp parser', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n    fastify.addContentTypeParser(/^text\\/*/, first)\n\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove(/^text\\/*/)\n\n    t.notOk(contentTypeParser.customParsers[/^text\\/*/])\n    t.notOk(contentTypeParser.parserRegExpList.find(parser => parser.toString() === /^text\\/*/.toString()))\n  })\n\n  test('should throw an error if content type is neither string nor RegExp', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    t.throws(() => fastify[keys.kContentTypeParser].remove(12), FST_ERR_CTP_INVALID_TYPE)\n  })\n\n  test('should not throw error if content type does not exist', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    t.doesNotThrow(() => fastify[keys.kContentTypeParser].remove('image/png'))\n  })\n\n  test('should not remove any content type parser if content type does not exist', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove('image/png')\n\n    t.same(contentTypeParser.customParsers.size, 2)\n  })\n\n  t.end()\n})\n\ntest('remove all should remove all existing parsers and reset cache', t => {\n  t.plan(4)\n\n  const fastify = Fastify()\n  fastify.addContentTypeParser('application/xml', first)\n  fastify.addContentTypeParser(/^image\\/.*/, first)\n\n  const contentTypeParser = fastify[keys.kContentTypeParser]\n\n  contentTypeParser.getParser('application/xml') // fill cache with one entry\n  contentTypeParser.removeAll()\n\n  t.same(contentTypeParser.cache.size, 0)\n  t.same(contentTypeParser.parserList.length, 0)\n  t.same(contentTypeParser.parserRegExpList.length, 0)\n  t.same(Object.keys(contentTypeParser.customParsers).length, 0)\n})\n\ntest('Safeguard against malicious content-type / 1', async t => {\n  const badNames = Object.getOwnPropertyNames({}.__proto__) // eslint-disable-line\n  t.plan(badNames.length)\n\n  const fastify = Fastify()\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  for (const prop of badNames) {\n    const response = await fastify.inject({\n      method: 'POST',\n      path: '/',\n      headers: {\n        'content-type': prop\n      },\n      body: ''\n    })\n\n    t.same(response.statusCode, 415)\n  }\n})\n\ntest('Safeguard against malicious content-type / 2', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  const response = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': '\\\\u0063\\\\u006fnstructor'\n    },\n    body: ''\n  })\n\n  t.same(response.statusCode, 415)\n})\n\ntest('Safeguard against malicious content-type / 3', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  const response = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': 'constructor; charset=utf-8'\n    },\n    body: ''\n  })\n\n  t.same(response.statusCode, 415)\n})\n", "'use strict'\n\nconst fs = require('fs')\nconst t = require('tap')\nconst test = t.test\nconst sget = require('simple-get').concat\nconst Fastify = require('..')\n\nconst jsonParser = require('fast-json-body')\n\nfunction plainTextParser (request, callback) {\n  let body = ''\n  request.setEncoding('utf8')\n  request.on('error', onError)\n  request.on('data', onData)\n  request.on('end', onEnd)\n  function onError (err) {\n    callback(err, null)\n  }\n  function onData (chunk) {\n    body += chunk\n  }\n  function onEnd () {\n    callback(null, body)\n  }\n}\n\nfunction getUrl (app) {\n  const { address, port } = app.server.address()\n  if (address === '::1') {\n    return `http://[${address}]:${port}`\n  } else {\n    return `http://${address}:${port}`\n  }\n}\n\nprocess.removeAllListeners('warning')\n\ntest('contentTypeParser method should exist', t => {\n  t.plan(1)\n  const fastify = Fastify()\n  t.ok(fastify.addContentTypeParser)\n})\n\ntest('contentTypeParser should add a custom parser', t => {\n  t.plan(3)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.options('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/jsoff', function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    t.teardown(() => fastify.close())\n\n    t.test('in POST', t => {\n      t.plan(3)\n\n      sget({\n        method: 'POST',\n        url: getUrl(fastify),\n        body: '{\"hello\":\"world\"}',\n        headers: {\n          'Content-Type': 'application/jsoff'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      })\n    })\n\n    t.test('in OPTIONS', t => {\n      t.plan(3)\n\n      sget({\n        method: 'OPTIONS',\n        url: getUrl(fastify),\n        body: '{\"hello\":\"world\"}',\n        headers: {\n          'Content-Type': 'application/jsoff'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      })\n    })\n  })\n})\n\ntest('contentTypeParser should handle multiple custom parsers', t => {\n  t.plan(7)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.post('/hello', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  function customParser (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  }\n\n  fastify.addContentTypeParser('application/jsoff', customParser)\n  fastify.addContentTypeParser('application/ffosj', customParser)\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n    t.teardown(() => { fastify.close() })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify) + '/hello',\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/ffosj'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n    })\n  })\n})\n\ntest('contentTypeParser should handle an array of custom contentTypes', t => {\n  t.plan(7)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.post('/hello', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  function customParser (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  }\n\n  fastify.addContentTypeParser(['application/jsoff', 'application/ffosj'], customParser)\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n    t.teardown(() => { fastify.close() })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify) + '/hello',\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/ffosj'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n    })\n  })\n})\n\ntest('contentTypeParser should handle errors', t => {\n  t.plan(3)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/jsoff', function (req, payload, done) {\n    done(new Error('kaboom!'), {})\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 500)\n      fastify.close()\n    })\n  })\n})\n\ntest('contentTypeParser should support encapsulation', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.register((instance, opts, done) => {\n    instance.addContentTypeParser('application/jsoff', () => {})\n    t.ok(instance.hasContentTypeParser('application/jsoff'))\n\n    instance.register((instance, opts, done) => {\n      instance.addContentTypeParser('application/ffosj', () => {})\n      t.ok(instance.hasContentTypeParser('application/jsoff'))\n      t.ok(instance.hasContentTypeParser('application/ffosj'))\n      done()\n    })\n\n    done()\n  })\n\n  fastify.ready(err => {\n    t.error(err)\n    t.notOk(fastify.hasContentTypeParser('application/jsoff'))\n    t.notOk(fastify.hasContentTypeParser('application/ffosj'))\n  })\n})\n\ntest('contentTypeParser should support encapsulation, second try', t => {\n  t.plan(4)\n  const fastify = Fastify()\n\n  fastify.register((instance, opts, done) => {\n    instance.post('/', (req, reply) => {\n      reply.send(req.body)\n    })\n\n    instance.addContentTypeParser('application/jsoff', function (req, payload, done) {\n      jsonParser(payload, function (err, body) {\n        done(err, body)\n      })\n    })\n\n    done()\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      fastify.close()\n    })\n  })\n})\n\ntest('contentTypeParser shouldn\\'t support request with undefined \"Content-Type\"', t => {\n  t.plan(3)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/jsoff', function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'unknown content type!',\n      headers: {\n        // 'Content-Type': undefined\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 415)\n      fastify.close()\n    })\n  })\n})\n\ntest('the content type should be a string or RegExp', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  try {\n    fastify.addContentTypeParser(null, () => {})\n    t.fail()\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_INVALID_TYPE')\n    t.equal(err.message, 'The content type should be a string or a RegExp')\n  }\n})\n\ntest('the content type cannot be an empty string', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  try {\n    fastify.addContentTypeParser('', () => {})\n    t.fail()\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_EMPTY_TYPE')\n    t.equal(err.message, 'The content type cannot be an empty string')\n  }\n})\n\ntest('the content type handler should be a function', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  try {\n    fastify.addContentTypeParser('aaa', null)\n    t.fail()\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_INVALID_HANDLER')\n    t.equal(err.message, 'The content type handler should be a function')\n  }\n})\n\ntest('catch all content type parser', t => {\n  t.plan(7)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('*', function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'hello')\n\n      sget({\n        method: 'POST',\n        url: getUrl(fastify),\n        body: 'hello',\n        headers: {\n          'Content-Type': 'very-weird-content-type'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), 'hello')\n        fastify.close()\n      })\n    })\n  })\n})\n\ntest('catch all content type parser should not interfere with other conte type parsers', t => {\n  t.plan(7)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('*', function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data)\n    })\n  })\n\n  fastify.addContentTypeParser('application/jsoff', function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n\n      sget({\n        method: 'POST',\n        url: getUrl(fastify),\n        body: 'hello',\n        headers: {\n          'Content-Type': 'very-weird-content-type'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), 'hello')\n        fastify.close()\n      })\n    })\n  })\n})\n\n// Issue 492 https://github.com/fastify/fastify/issues/492\ntest('\\'*\\' catch undefined Content-Type requests', t => {\n  t.plan(4)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.addContentTypeParser('*', function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data)\n    })\n  })\n\n  fastify.post('/', (req, res) => {\n    // Needed to avoid json stringify\n    res.type('text/plain').send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, function (err) {\n    t.error(err)\n\n    const fileStream = fs.createReadStream(__filename)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify) + '/',\n      body: fileStream\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body + '', fs.readFileSync(__filename).toString())\n    })\n  })\n})\n\ntest('cannot add custom parser after binding', t => {\n  t.plan(2)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.post('/', (req, res) => {\n    res.type('text/plain').send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, function (err) {\n    t.error(err)\n\n    try {\n      fastify.addContentTypeParser('*', () => {})\n      t.fail()\n    } catch (e) {\n      t.pass()\n    }\n  })\n})\n\ntest('Can override the default json parser', t => {\n  t.plan(5)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/json', function (req, payload, done) {\n    t.ok('called')\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '{\"hello\":\"world\"}')\n      fastify.close()\n    })\n  })\n})\n\ntest('Can override the default plain text parser', t => {\n  t.plan(5)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('text/plain', function (req, payload, done) {\n    t.ok('called')\n    plainTextParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello world',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), 'hello world')\n      fastify.close()\n    })\n  })\n})\n\ntest('Can override the default json parser in a plugin', t => {\n  t.plan(5)\n  const fastify = Fastify()\n\n  fastify.register((instance, opts, done) => {\n    instance.addContentTypeParser('application/json', function (req, payload, done) {\n      t.ok('called')\n      jsonParser(payload, function (err, body) {\n        done(err, body)\n      })\n    })\n\n    instance.post('/', (req, reply) => {\n      reply.send(req.body)\n    })\n\n    done()\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '{\"hello\":\"world\"}')\n      fastify.close()\n    })\n  })\n})\n\ntest('Can\\'t override the json parser multiple times', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  fastify.addContentTypeParser('application/json', function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  try {\n    fastify.addContentTypeParser('application/json', function (req, payload, done) {\n      t.ok('called')\n      jsonParser(payload, function (err, body) {\n        done(err, body)\n      })\n    })\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_ALREADY_PRESENT')\n    t.equal(err.message, 'Content type parser \\'application/json\\' already present.')\n  }\n})\n\ntest('Can\\'t override the plain text parser multiple times', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  fastify.addContentTypeParser('text/plain', function (req, payload, done) {\n    plainTextParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  try {\n    fastify.addContentTypeParser('text/plain', function (req, payload, done) {\n      t.ok('called')\n      plainTextParser(payload, function (err, body) {\n        done(err, body)\n      })\n    })\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_ALREADY_PRESENT')\n    t.equal(err.message, 'Content type parser \\'text/plain\\' already present.')\n  }\n})\n\ntest('Should get the body as string', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/json', { parseAs: 'string' }, function (req, body, done) {\n    t.ok('called')\n    t.ok(typeof body === 'string')\n    try {\n      const json = JSON.parse(body)\n      done(null, json)\n    } catch (err) {\n      err.statusCode = 400\n      done(err, undefined)\n    }\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '{\"hello\":\"world\"}')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should return defined body with no custom parser defined and content type = \\'text/plain\\'', t => {\n  t.plan(4)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello world',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), 'hello world')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should have typeof body object with no custom parser defined, no body defined and content type = \\'text/plain\\'', t => {\n  t.plan(4)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(typeof body, 'object')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should have typeof body object with no custom parser defined, null body and content type = \\'text/plain\\'', t => {\n  t.plan(4)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: null,\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(typeof body, 'object')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should have typeof body object with no custom parser defined, undefined body and content type = \\'text/plain\\'', t => {\n  t.plan(4)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: undefined,\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(typeof body, 'object')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should get the body as string', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('text/plain', { parseAs: 'string' }, function (req, body, done) {\n    t.ok('called')\n    t.ok(typeof body === 'string')\n    try {\n      const plainText = body\n      done(null, plainText)\n    } catch (err) {\n      err.statusCode = 400\n      done(err, undefined)\n    }\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello world',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), 'hello world')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should get the body as buffer', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/json', { parseAs: 'buffer' }, function (req, body, done) {\n    t.ok('called')\n    t.ok(body instanceof Buffer)\n    try {\n      const json = JSON.parse(body)\n      done(null, json)\n    } catch (err) {\n      err.statusCode = 400\n      done(err, undefined)\n    }\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '{\"hello\":\"world\"}')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should get the body as buffer', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('text/plain', { parseAs: 'buffer' }, function (req, body, done) {\n    t.ok('called')\n    t.ok(body instanceof Buffer)\n    try {\n      const plainText = body\n      done(null, plainText)\n    } catch (err) {\n      err.statusCode = 400\n      done(err, undefined)\n    }\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello world',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), 'hello world')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should parse empty bodies as a string', t => {\n  t.plan(9)\n  const fastify = Fastify()\n\n  fastify.addContentTypeParser('text/plain', { parseAs: 'string' }, (req, body, done) => {\n    t.equal(body, '')\n    done(null, body)\n  })\n\n  fastify.route({\n    method: ['POST', 'DELETE'],\n    url: '/',\n    handler (request, reply) {\n      reply.send(request.body)\n    }\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n    t.teardown(() => { fastify.close() })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '')\n    })\n\n    sget({\n      method: 'DELETE',\n      url: getUrl(fastify),\n      body: '',\n      headers: {\n        'Content-Type': 'text/plain',\n        'Content-Length': '0'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '')\n    })\n  })\n})\n\ntest('Should parse empty bodies as a buffer', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('text/plain', { parseAs: 'buffer' }, function (req, body, done) {\n    t.ok(body instanceof Buffer)\n    t.equal(body.length, 0)\n    done(null, body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.length, 0)\n      fastify.close()\n    })\n  })\n})\n\ntest('The charset should not interfere with the content type handling', t => {\n  t.plan(5)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/json', function (req, payload, done) {\n    t.ok('called')\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json charset=utf-8'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '{\"hello\":\"world\"}')\n      fastify.close()\n    })\n  })\n})\n\ntest('Wrong parseAs parameter', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  try {\n    fastify.addContentTypeParser('application/json', { parseAs: 'fireworks' }, () => {})\n    t.fail('should throw')\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_INVALID_PARSE_TYPE')\n    t.equal(err.message, \"The body parser can only parse your data as 'string' or 'buffer', you asked 'fireworks' which is not supported.\")\n  }\n})\n\ntest('Should allow defining the bodyLimit per parser', t => {\n  t.plan(3)\n  const fastify = Fastify()\n  t.teardown(() => fastify.close())\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser(\n    'x/foo',\n    { parseAs: 'string', bodyLimit: 5 },\n    function (req, body, done) {\n      t.fail('should not be invoked')\n      done()\n    }\n  )\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '1234567890',\n      headers: {\n        'Content-Type': 'x/foo'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.strictSame(JSON.parse(body.toString()), {\n        statusCode: 413,\n        code: 'FST_ERR_CTP_BODY_TOO_LARGE',\n        error: 'Payload Too Large',\n        message: 'Request body is too large'\n      })\n      fastify.close()\n    })\n  })\n})\n\ntest('route bodyLimit should take precedence over a custom parser bodyLimit', t => {\n  t.plan(3)\n  const fastify = Fastify()\n  t.teardown(() => fastify.close())\n\n  fastify.post('/', { bodyLimit: 5 }, (request, reply) => {\n    reply.send(request.body)\n  })\n\n  fastify.addContentTypeParser(\n    'x/foo',\n    { parseAs: 'string', bodyLimit: 100 },\n    function (req, body, done) {\n      t.fail('should not be invoked')\n      done()\n    }\n  )\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '1234567890',\n      headers: { 'Content-Type': 'x/foo' }\n    }, (err, response, body) => {\n      t.error(err)\n      t.strictSame(JSON.parse(body.toString()), {\n        statusCode: 413,\n        code: 'FST_ERR_CTP_BODY_TOO_LARGE',\n        error: 'Payload Too Large',\n        message: 'Request body is too large'\n      })\n      fastify.close()\n    })\n  })\n})\n\ntest('should be able to use default parser for extra content type', t => {\n  t.plan(4)\n  const fastify = Fastify()\n  t.teardown(() => fastify.close())\n\n  fastify.post('/', (request, reply) => {\n    reply.send(request.body)\n  })\n\n  fastify.addContentTypeParser('text/json', { parseAs: 'string' }, fastify.getDefaultJsonParser('ignore', 'ignore'))\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'text/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.strictSame(JSON.parse(body.toString()), { hello: 'world' })\n      fastify.close()\n    })\n  })\n})\n\ntest('contentTypeParser should add a custom parser with RegExp value', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.options('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser(/.*\\+json$/, function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    t.teardown(() => fastify.close())\n\n    t.test('in POST', t => {\n      t.plan(3)\n\n      sget({\n        method: 'POST',\n        url: getUrl(fastify),\n        body: '{\"hello\":\"world\"}',\n        headers: {\n          'Content-Type': 'application/vnd.test+json'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      })\n    })\n\n    t.test('in OPTIONS', t => {\n      t.plan(3)\n\n      sget({\n        method: 'OPTIONS',\n        url: getUrl(fastify),\n        body: '{\"hello\":\"world\"}',\n        headers: {\n          'Content-Type': 'weird-content-type+json'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      })\n    })\n  })\n})\n\ntest('contentTypeParser should add multiple custom parsers with RegExp values', async t => {\n  t.plan(6)\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser(/.*\\+json$/, function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.addContentTypeParser(/.*\\+xml$/, function (req, payload, done) {\n    done(null, 'xml')\n  })\n\n  fastify.addContentTypeParser(/.*\\+myExtension$/, function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data + 'myExtension')\n    })\n  })\n\n  await fastify.ready()\n\n  {\n    const response = await fastify.inject({\n      method: 'POST',\n      url: '/',\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/vnd.hello+json'\n      }\n    })\n    t.equal(response.statusCode, 200)\n    t.same(response.payload.toString(), '{\"hello\":\"world\"}')\n  }\n\n  {\n    const response = await fastify.inject({\n      method: 'POST',\n      url: '/',\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/test+xml'\n      }\n    })\n    t.equal(response.statusCode, 200)\n    t.same(response.payload.toString(), 'xml')\n  }\n\n  await fastify.inject({\n    method: 'POST',\n    path: '/',\n    payload: 'abcdefg',\n    headers: {\n      'Content-Type': 'application/+myExtension'\n    }\n  }).then((response) => {\n    t.equal(response.statusCode, 200)\n    t.same(response.payload.toString(), 'abcdefgmyExtension')\n  }).catch((err) => {\n    t.error(err)\n  })\n})\n\ntest('catch all content type parser should not interfere with content type parser', t => {\n  t.plan(10)\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('*', function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data)\n    })\n  })\n\n  fastify.addContentTypeParser(/^application\\/.*/, function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.addContentTypeParser('text/html', function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data + 'html')\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"myKey\":\"myValue\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ myKey: 'myValue' }))\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'body',\n      headers: {\n        'Content-Type': 'very-weird-content-type'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'body')\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'my text',\n      headers: {\n        'Content-Type': 'text/html'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'my texthtml')\n    })\n  })\n})\n\ntest('should prefer string content types over RegExp ones', t => {\n  t.plan(7)\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser(/^application\\/.*/, function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data)\n    })\n  })\n\n  fastify.addContentTypeParser('application/json', function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"k1\":\"myValue\", \"k2\": \"myValue\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ k1: 'myValue', k2: 'myValue' }))\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'javascript',\n      headers: {\n        'Content-Type': 'application/javascript'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'javascript')\n    })\n  })\n})\n\ntest('removeContentTypeParser should support arrays of content types to remove', t => {\n  t.plan(8)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.addContentTypeParser('application/xml', function (req, payload, done) {\n    payload.on('data', () => {})\n    payload.on('end', () => {\n      done(null, 'xml')\n    })\n  })\n\n  fastify.addContentTypeParser(/^image\\/.*/, function (req, payload, done) {\n    payload.on('data', () => {})\n    payload.on('end', () => {\n      done(null, 'image')\n    })\n  })\n\n  fastify.removeContentTypeParser([/^image\\/.*/, 'application/json'])\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '<?xml version=\"1.0\">',\n      headers: {\n        'Content-Type': 'application/xml'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'xml')\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '',\n      headers: {\n        'Content-Type': 'image/png'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 415)\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{test: \"test\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 415)\n    })\n  })\n})\n\ntest('removeContentTypeParser should support encapsulation', t => {\n  t.plan(6)\n\n  const fastify = Fastify()\n\n  fastify.addContentTypeParser('application/xml', function (req, payload, done) {\n    payload.on('data', () => {})\n    payload.on('end', () => {\n      done(null, 'xml')\n    })\n  })\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.register(function (instance, options, done) {\n    instance.removeContentTypeParser('application/xml')\n\n    instance.post('/encapsulated', (req, reply) => {\n      reply.send(req.body)\n    })\n\n    done()\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify) + '/encapsulated',\n      body: '<?xml version=\"1.0\">',\n      headers: {\n        'Content-Type': 'application/xml'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 415)\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '<?xml version=\"1.0\">',\n      headers: {\n        'Content-Type': 'application/xml'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'xml')\n      fastify.close()\n    })\n  })\n})\n\ntest('removeAllContentTypeParsers should support encapsulation', t => {\n  t.plan(6)\n\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.register(function (instance, options, done) {\n    instance.removeAllContentTypeParsers()\n\n    instance.post('/encapsulated', (req, reply) => {\n      reply.send(req.body)\n    })\n\n    done()\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify) + '/encapsulated',\n      body: '{}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 415)\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"test\":1}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(JSON.parse(body.toString()).test, 1)\n      fastify.close()\n    })\n  })\n})\n\ntest('cannot remove all content type parsers after binding', t => {\n  t.plan(2)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.listen({ port: 0 }, function (err) {\n    t.error(err)\n\n    t.throws(() => fastify.removeAllContentTypeParsers())\n  })\n})\n\ntest('cannot remove content type parsers after binding', t => {\n  t.plan(2)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.listen({ port: 0 }, function (err) {\n    t.error(err)\n\n    t.throws(() => fastify.removeContentTypeParser('application/json'))\n  })\n})\n\ntest('should be able to override the default json parser after removeAllContentTypeParsers', t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.removeAllContentTypeParsers()\n\n  fastify.addContentTypeParser('application/json', function (req, payload, done) {\n    t.ok('called')\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      fastify.close()\n    })\n  })\n})\n\ntest('should be able to override the default plain text parser after removeAllContentTypeParsers', t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.removeAllContentTypeParsers()\n\n  fastify.addContentTypeParser('text/plain', function (req, payload, done) {\n    t.ok('called')\n    plainTextParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello world',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), 'hello world')\n      fastify.close()\n    })\n  })\n})\n\ntest('should be able to add a custom content type parser after removeAllContentTypeParsers', t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.removeAllContentTypeParsers()\n\n  fastify.addContentTypeParser('application/jsoff', function (req, payload, done) {\n    t.ok('called')\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      fastify.close()\n    })\n  })\n})\n"], "fixing_code": ["'use strict'\n\nconst { AsyncResource } = require('async_hooks')\nconst lru = require('tiny-lru').lru\n// TODO: find more perforamant solution\nconst { parse: parseContentType } = require('content-type')\n\nconst secureJson = require('secure-json-parse')\nconst {\n  kDefaultJsonParse,\n  kContentTypeParser,\n  kBodyLimit,\n  kRequestPayloadStream,\n  kState,\n  kTestInternals,\n  kReplyIsError,\n  kRouteContext\n} = require('./symbols')\n\nconst {\n  FST_ERR_CTP_INVALID_TYPE,\n  FST_ERR_CTP_EMPTY_TYPE,\n  FST_ERR_CTP_ALREADY_PRESENT,\n  FST_ERR_CTP_INVALID_HANDLER,\n  FST_ERR_CTP_INVALID_PARSE_TYPE,\n  FST_ERR_CTP_BODY_TOO_LARGE,\n  FST_ERR_CTP_INVALID_MEDIA_TYPE,\n  FST_ERR_CTP_INVALID_CONTENT_LENGTH,\n  FST_ERR_CTP_EMPTY_JSON_BODY\n} = require('./errors')\n\nfunction ContentTypeParser (bodyLimit, onProtoPoisoning, onConstructorPoisoning) {\n  this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning)\n  // using a map instead of a plain object to avoid prototype hijack attacks\n  this.customParsers = new Map()\n  this.customParsers.set('application/json', new Parser(true, false, bodyLimit, this[kDefaultJsonParse]))\n  this.customParsers.set('text/plain', new Parser(true, false, bodyLimit, defaultPlainTextParser))\n  this.parserList = [new ParserListItem('application/json'), new ParserListItem('text/plain')]\n  this.parserRegExpList = []\n  this.cache = lru(100)\n}\n\nContentTypeParser.prototype.add = function (contentType, opts, parserFn) {\n  const contentTypeIsString = typeof contentType === 'string'\n\n  if (!contentTypeIsString && !(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()\n  if (contentTypeIsString && contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE()\n  if (typeof parserFn !== 'function') throw new FST_ERR_CTP_INVALID_HANDLER()\n\n  if (this.existingParser(contentType)) {\n    throw new FST_ERR_CTP_ALREADY_PRESENT(contentType)\n  }\n\n  if (opts.parseAs !== undefined) {\n    if (opts.parseAs !== 'string' && opts.parseAs !== 'buffer') {\n      throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs)\n    }\n  }\n\n  const parser = new Parser(\n    opts.parseAs === 'string',\n    opts.parseAs === 'buffer',\n    opts.bodyLimit,\n    parserFn\n  )\n\n  if (contentTypeIsString && contentType === '*') {\n    this.customParsers.set('', parser)\n  } else {\n    if (contentTypeIsString) {\n      this.parserList.unshift(new ParserListItem(contentType))\n    } else {\n      this.parserRegExpList.unshift(contentType)\n    }\n    this.customParsers.set(contentType.toString(), parser)\n  }\n}\n\nContentTypeParser.prototype.hasParser = function (contentType) {\n  return this.customParsers.has(typeof contentType === 'string' ? contentType : contentType.toString())\n}\n\nContentTypeParser.prototype.existingParser = function (contentType) {\n  if (contentType === 'application/json' && this.customParsers.has(contentType)) {\n    return this.customParsers.get(contentType).fn !== this[kDefaultJsonParse]\n  }\n  if (contentType === 'text/plain' && this.customParsers.has(contentType)) {\n    return this.customParsers.get(contentType).fn !== defaultPlainTextParser\n  }\n\n  return this.hasParser(contentType)\n}\n\nContentTypeParser.prototype.getParser = function (contentType) {\n  if (this.hasParser(contentType)) {\n    return this.customParsers.get(contentType)\n  }\n\n  const parser = this.cache.get(contentType)\n  if (parser !== undefined) return parser\n\n  const parsed = safeParseContentType(contentType)\n\n  // dummyContentType always the same object\n  // we can use === for the comparsion and return early\n  if (parsed === dummyContentType) {\n    return this.customParsers.get('')\n  }\n\n  // eslint-disable-next-line no-var\n  for (var i = 0; i !== this.parserList.length; ++i) {\n    const parserListItem = this.parserList[i]\n    if (compareContentType(parsed, parserListItem)) {\n      const parser = this.customParsers.get(parserListItem.name)\n      // we set request content-type in cache to reduce parsing of MIME type\n      this.cache.set(contentType, parser)\n      return parser\n    }\n  }\n\n  // eslint-disable-next-line no-var\n  for (var j = 0; j !== this.parserRegExpList.length; ++j) {\n    const parserRegExp = this.parserRegExpList[j]\n    if (compareRegExpContentType(contentType, parsed.type, parserRegExp)) {\n      const parser = this.customParsers.get(parserRegExp.toString())\n      // we set request content-type in cache to reduce parsing of MIME type\n      this.cache.set(contentType, parser)\n      return parser\n    }\n  }\n\n  return this.customParsers.get('')\n}\n\nContentTypeParser.prototype.removeAll = function () {\n  this.customParsers = new Map()\n  this.parserRegExpList = []\n  this.parserList = []\n  this.cache = lru(100)\n}\n\nContentTypeParser.prototype.remove = function (contentType) {\n  if (!(typeof contentType === 'string' || contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()\n\n  this.customParsers.delete(contentType.toString())\n\n  const parsers = typeof contentType === 'string' ? this.parserList : this.parserRegExpList\n\n  const idx = parsers.findIndex(ct => ct.toString() === contentType.toString())\n\n  if (idx > -1) {\n    parsers.splice(idx, 1)\n  }\n}\n\nContentTypeParser.prototype.run = function (contentType, handler, request, reply) {\n  const parser = this.getParser(contentType)\n  const resource = new AsyncResource('content-type-parser:run', request)\n\n  if (parser === undefined) {\n    if (request.is404) {\n      handler(request, reply)\n    } else {\n      reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || undefined))\n    }\n  } else if (parser.asString === true || parser.asBuffer === true) {\n    rawBody(\n      request,\n      reply,\n      reply[kRouteContext]._parserOptions,\n      parser,\n      done\n    )\n  } else {\n    const result = parser.fn(request, request[kRequestPayloadStream], done)\n\n    if (result && typeof result.then === 'function') {\n      result.then(body => done(null, body), done)\n    }\n  }\n\n  function done (error, body) {\n    // We cannot use resource.bind() because it is broken in node v12 and v14\n    resource.runInAsyncScope(() => {\n      if (error) {\n        reply[kReplyIsError] = true\n        reply.send(error)\n      } else {\n        request.body = body\n        handler(request, reply)\n      }\n    })\n  }\n}\n\nfunction rawBody (request, reply, options, parser, done) {\n  const asString = parser.asString\n  const limit = options.limit === null ? parser.bodyLimit : options.limit\n  const contentLength = request.headers['content-length'] === undefined\n    ? NaN\n    : Number(request.headers['content-length'])\n\n  if (contentLength > limit) {\n    // We must close the connection as the client is going\n    // to send this data anyway\n    reply.header('connection', 'close')\n    reply.send(new FST_ERR_CTP_BODY_TOO_LARGE())\n    return\n  }\n\n  let receivedLength = 0\n  let body = asString === true ? '' : []\n\n  const payload = request[kRequestPayloadStream] || request.raw\n\n  if (asString === true) {\n    payload.setEncoding('utf8')\n  }\n\n  payload.on('data', onData)\n  payload.on('end', onEnd)\n  payload.on('error', onEnd)\n  payload.resume()\n\n  function onData (chunk) {\n    receivedLength += chunk.length\n\n    if ((payload.receivedEncodedLength || receivedLength) > limit) {\n      payload.removeListener('data', onData)\n      payload.removeListener('end', onEnd)\n      payload.removeListener('error', onEnd)\n      reply.send(new FST_ERR_CTP_BODY_TOO_LARGE())\n      return\n    }\n\n    if (asString === true) {\n      body += chunk\n    } else {\n      body.push(chunk)\n    }\n  }\n\n  function onEnd (err) {\n    payload.removeListener('data', onData)\n    payload.removeListener('end', onEnd)\n    payload.removeListener('error', onEnd)\n\n    if (err !== undefined) {\n      err.statusCode = 400\n      reply[kReplyIsError] = true\n      reply.code(err.statusCode).send(err)\n      return\n    }\n\n    if (asString === true) {\n      receivedLength = Buffer.byteLength(body)\n    }\n\n    if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {\n      reply.header('connection', 'close')\n      reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH())\n      return\n    }\n\n    if (asString === false) {\n      body = Buffer.concat(body)\n    }\n\n    const result = parser.fn(request, body, done)\n    if (result && typeof result.then === 'function') {\n      result.then(body => done(null, body), done)\n    }\n  }\n}\n\nfunction getDefaultJsonParser (onProtoPoisoning, onConstructorPoisoning) {\n  return defaultJsonParser\n\n  function defaultJsonParser (req, body, done) {\n    if (body === '' || body == null) {\n      return done(new FST_ERR_CTP_EMPTY_JSON_BODY(), undefined)\n    }\n    let json\n    try {\n      json = secureJson.parse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning })\n    } catch (err) {\n      err.statusCode = 400\n      return done(err, undefined)\n    }\n    done(null, json)\n  }\n}\n\nfunction defaultPlainTextParser (req, body, done) {\n  done(null, body)\n}\n\nfunction Parser (asString, asBuffer, bodyLimit, fn) {\n  this.asString = asString\n  this.asBuffer = asBuffer\n  this.bodyLimit = bodyLimit\n  this.fn = fn\n}\n\nfunction buildContentTypeParser (c) {\n  const contentTypeParser = new ContentTypeParser()\n  contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse]\n  contentTypeParser.customParsers = new Map(c.customParsers.entries())\n  contentTypeParser.parserList = c.parserList.slice()\n  return contentTypeParser\n}\n\nfunction addContentTypeParser (contentType, opts, parser) {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"addContentTypeParser\" when fastify instance is already started!')\n  }\n\n  if (typeof opts === 'function') {\n    parser = opts\n    opts = {}\n  }\n\n  if (!opts) opts = {}\n  if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit]\n\n  if (Array.isArray(contentType)) {\n    contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser))\n  } else {\n    this[kContentTypeParser].add(contentType, opts, parser)\n  }\n\n  return this\n}\n\nfunction hasContentTypeParser (contentType) {\n  return this[kContentTypeParser].hasParser(contentType)\n}\n\nfunction removeContentTypeParser (contentType) {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"removeContentTypeParser\" when fastify instance is already started!')\n  }\n\n  if (Array.isArray(contentType)) {\n    for (const type of contentType) {\n      this[kContentTypeParser].remove(type)\n    }\n  } else {\n    this[kContentTypeParser].remove(contentType)\n  }\n}\n\nfunction removeAllContentTypeParsers () {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"removeAllContentTypeParsers\" when fastify instance is already started!')\n  }\n\n  this[kContentTypeParser].removeAll()\n}\n\n// dummy here to prevent repeated object creation\nconst dummyContentType = { type: '', parameters: Object.create(null) }\n\nfunction safeParseContentType (contentType) {\n  try {\n    return parseContentType(contentType)\n  } catch (err) {\n    return dummyContentType\n  }\n}\n\nfunction compareContentType (contentType, parserListItem) {\n  if (parserListItem.isEssence) {\n    // we do essence check\n    return contentType.type.indexOf(parserListItem) !== -1\n  } else {\n    // when the content-type includes parameters\n    // we do a full-text search\n    // reject essence content-type before checking parameters\n    if (contentType.type.indexOf(parserListItem.type) === -1) return false\n    for (const key of parserListItem.parameterKeys) {\n      // reject when missing parameters\n      if (!(key in contentType.parameters)) return false\n      // reject when parameters do not match\n      if (contentType.parameters[key] !== parserListItem.parameters[key]) return false\n    }\n    return true\n  }\n}\n\nfunction compareRegExpContentType (contentType, essenceMIMEType, regexp) {\n  if (regexp.source.indexOf(';') === -1) {\n    // we do essence check\n    return regexp.test(essenceMIMEType)\n  } else {\n    // when the content-type includes parameters\n    // we do a full-text match\n    return regexp.test(contentType)\n  }\n}\n\nfunction ParserListItem (contentType) {\n  this.name = contentType\n  // we pre-calculate all the needed information\n  // before content-type comparsion\n  const parsed = safeParseContentType(contentType)\n  this.type = parsed.type\n  this.parameters = parsed.parameters\n  this.parameterKeys = Object.keys(parsed.parameters)\n  this.isEssence = contentType.indexOf(';') === -1\n}\n\n// used in ContentTypeParser.remove\nParserListItem.prototype.toString = function () {\n  return this.name\n}\n\nmodule.exports = ContentTypeParser\nmodule.exports.helpers = {\n  buildContentTypeParser,\n  addContentTypeParser,\n  hasContentTypeParser,\n  removeContentTypeParser,\n  removeAllContentTypeParsers\n}\nmodule.exports.defaultParsers = {\n  getDefaultJsonParser,\n  defaultTextParser: defaultPlainTextParser\n}\nmodule.exports[kTestInternals] = { rawBody }\n", "{\n  \"name\": \"fastify\",\n    \"version\": \"4.10.1\",\n  \"description\": \"Fast and low overhead web framework, for Node.js\",\n  \"main\": \"fastify.js\",\n  \"type\": \"commonjs\",\n  \"types\": \"fastify.d.ts\",\n  \"scripts\": {\n    \"bench\": \"branchcmp -r 2 -g -s \\\"npm run benchmark\\\"\",\n    \"benchmark\": \"npx concurrently -k -s first \\\"node ./examples/benchmark/simple.js\\\" \\\"npx autocannon -c 100 -d 30 -p 10 localhost:3000/\\\"\",\n    \"coverage\": \"npm run unit -- --cov --coverage-report=html\",\n    \"coverage:ci\": \"npm run unit -- --cov --coverage-report=html --no-browser --no-check-coverage -R terse\",\n    \"coverage:ci-check-coverage\": \"nyc check-coverage --branches 100 --functions 100 --lines 100 --statements 100\",\n    \"license-checker\": \"license-checker --production --onlyAllow=\\\"MIT;ISC;BSD-3-Clause;BSD-2-Clause\\\"\",\n    \"lint\": \"npm run lint:standard && npm run lint:typescript && npm run lint:markdown\",\n    \"lint:fix\": \"standard --fix\",\n    \"lint:markdown\": \"markdownlint-cli2\",\n    \"lint:standard\": \"standard | snazzy\",\n    \"lint:typescript\": \"eslint -c types/.eslintrc.json types/**/*.d.ts test/types/**/*.test-d.ts\",\n    \"prepublishOnly\": \"PREPUBLISH=true tap --no-check-coverage test/build/**.test.js\",\n    \"test\": \"npm run lint && npm run unit && npm run test:typescript\",\n    \"test:ci\": \"npm run unit -- -R terse --cov --coverage-report=lcovonly && npm run test:typescript\",\n    \"test:report\": \"npm run lint && npm run unit:report && npm run test:typescript\",\n    \"test:typescript\": \"tsc test/types/import.ts && tsd\",\n    \"test:watch\": \"npm run unit -- -w --no-coverage-report -R terse\",\n    \"unit\": \"tap\",\n    \"unit:junit\": \"tap-mocha-reporter xunit < out.tap > test/junit-testresults.xml\",\n    \"unit:report\": \"tap --cov --coverage-report=html --coverage-report=cobertura | tee out.tap\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/fastify/fastify.git\"\n  },\n  \"keywords\": [\n    \"web\",\n    \"framework\",\n    \"json\",\n    \"schema\",\n    \"open\",\n    \"api\"\n  ],\n  \"author\": \"Matteo Collina <hello@matteocollina.com>\",\n  \"contributors\": [\n    {\n      \"name\": \"Tomas Della Vedova\",\n      \"url\": \"http://delved.org\",\n      \"author\": true\n    },\n    {\n      \"name\": \"Tommaso Allevi\",\n      \"email\": \"tomallevi@gmail.com\"\n    },\n    {\n      \"name\": \"Ethan Arrowood\",\n      \"url\": \"https://github.com/Ethan-Arrowood\",\n      \"email\": \"ethan.arrowood@gmail.com\"\n    },\n    {\n      \"name\": \"Dustin Deus\",\n      \"url\": \"http://starptech.de\",\n      \"email\": \"deusdustin@gmail.com\"\n    },\n    {\n      \"name\": \"Ayoub El Khattabi\",\n      \"url\": \"https://github.com/AyoubElk\",\n      \"email\": \"elkhattabi.ayoub@gmail.com\"\n    },\n    {\n      \"name\": \"Rafael Gonzaga\",\n      \"email\": \"rafael.nunu@hotmail.com\",\n      \"url\": \"https://github.com/rafaelgss\"\n    },\n    {\n      \"name\": \"Trivikram Kamat\",\n      \"url\": \"http://trivikr.github.io\",\n      \"email\": \"trivikr.dev@gmail.com\"\n    },\n    {\n      \"name\": \"Luciano Mammino\",\n      \"url\": \"https://loige.co\"\n    },\n    {\n      \"name\": \"Cemre Mengu\",\n      \"email\": \"cemremengu@gmail.com\"\n    },\n    {\n      \"name\": \"Evan Shortiss\",\n      \"email\": \"evanshortiss@gmail.com\"\n    },\n    {\n      \"name\": \"Maksim Sinik\",\n      \"url\": \"https://maksim.dev\"\n    },\n    {\n      \"name\": \"Manuel Spigolon\",\n      \"email\": \"behemoth89@gmail.com\"\n    },\n    {\n      \"name\": \"James Sumners\",\n      \"url\": \"https://james.sumners.info\"\n    },\n    {\n      \"name\": \"Denis F\u00e4cke\",\n      \"url\": \"https://github.com/SerayaEryn\"\n    },\n    {\n      \"name\": \"Igor Savin\",\n      \"email\": \"kibertoad@gmail.com\",\n      \"url\": \"https://github.com/kibertoad\"\n    },\n    {\n      \"name\": \"Vincent Le Goff\",\n      \"email\": \"vince.legoff@gmail.com\",\n      \"url\": \"https://github.com/zekth\"\n    },\n    {\n      \"name\": \"Luis Orbaiceta\",\n      \"email\": \"luisorbaiceta@gmail.com\",\n      \"url\": \"https://luisorbaiceta.com\"\n    }\n  ],\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/fastify/fastify/issues\"\n  },\n  \"homepage\": \"https://www.fastify.io/\",\n  \"devDependencies\": {\n    \"@fastify/pre-commit\": \"^2.0.2\",\n    \"@sinclair/typebox\": \"^0.25.2\",\n    \"@sinonjs/fake-timers\": \"^10.0.0\",\n    \"@types/node\": \"^18.7.18\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.37.0\",\n    \"@typescript-eslint/parser\": \"^5.37.0\",\n    \"ajv\": \"^8.11.0\",\n    \"ajv-errors\": \"^3.0.0\",\n    \"ajv-formats\": \"^2.1.1\",\n    \"ajv-i18n\": \"^4.2.0\",\n    \"ajv-merge-patch\": \"^5.0.1\",\n    \"branch-comparer\": \"^1.1.0\",\n    \"eslint\": \"^8.23.1\",\n    \"eslint-config-standard\": \"^17.0.0\",\n    \"eslint-import-resolver-node\": \"^0.3.6\",\n    \"eslint-plugin-import\": \"^2.26.0\",\n    \"eslint-plugin-n\": \"^15.2.5\",\n    \"eslint-plugin-promise\": \"^6.0.1\",\n    \"fast-json-body\": \"^1.1.0\",\n    \"fast-json-stringify\": \"^5.3.0\",\n    \"fastify-plugin\": \"^4.2.1\",\n    \"fluent-json-schema\": \"^4.0.0\",\n    \"form-data\": \"^4.0.0\",\n    \"h2url\": \"^0.2.0\",\n    \"http-errors\": \"^2.0.0\",\n    \"joi\": \"^17.6.0\",\n    \"json-schema-to-ts\": \"^2.5.5\",\n    \"JSONStream\": \"^1.3.5\",\n    \"license-checker\": \"^25.0.1\",\n    \"markdownlint-cli2\": \"^0.5.1\",\n    \"proxyquire\": \"^2.1.3\",\n    \"pump\": \"^3.0.0\",\n    \"self-cert\": \"^2.0.0\",\n    \"send\": \"^0.18.0\",\n    \"simple-get\": \"^4.0.1\",\n    \"snazzy\": \"^9.0.0\",\n    \"split2\": \"^4.1.0\",\n    \"standard\": \"^17.0.0\",\n    \"tap\": \"^16.3.0\",\n    \"tsd\": \"^0.24.1\",\n    \"typescript\": \"^4.8.3\",\n    \"undici\": \"^5.10.0\",\n    \"vary\": \"^1.1.2\",\n    \"yup\": \"^0.32.11\"\n  },\n  \"dependencies\": {\n    \"@fastify/ajv-compiler\": \"^3.3.1\",\n    \"@fastify/error\": \"^3.0.0\",\n    \"@fastify/fast-json-stringify-compiler\": \"^4.1.0\",\n    \"abstract-logging\": \"^2.0.1\",\n    \"avvio\": \"^8.2.0\",\n    \"content-type\": \"^1.0.4\",\n    \"find-my-way\": \"^7.3.0\",\n    \"light-my-request\": \"^5.6.1\",\n    \"pino\": \"^8.5.0\",\n    \"process-warning\": \"^2.0.0\",\n    \"proxy-addr\": \"^2.0.7\",\n    \"rfdc\": \"^1.3.0\",\n    \"secure-json-parse\": \"^2.5.0\",\n    \"semver\": \"^7.3.7\",\n    \"tiny-lru\": \"^10.0.0\"\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"lib/configValidator.js\",\n      \"lib/error-serializer.js\",\n      \"fastify.d.ts\",\n      \"types/*\",\n      \"test/types/*\",\n      \"test/same-shape.test.js\"\n    ]\n  },\n  \"tsd\": {\n    \"directory\": \"test/types\"\n  }\n}\n", "'use strict'\n\nconst t = require('tap')\nconst test = t.test\nconst Fastify = require('..')\nconst keys = require('../lib/symbols')\nconst { FST_ERR_CTP_ALREADY_PRESENT, FST_ERR_CTP_INVALID_TYPE, FST_ERR_CTP_INVALID_MEDIA_TYPE } = require('../lib/errors')\n\nconst first = function (req, payload, done) {}\nconst second = function (req, payload, done) {}\nconst third = function (req, payload, done) {}\n\ntest('hasContentTypeParser', t => {\n  test('should know about internal parsers', t => {\n    t.plan(4)\n\n    const fastify = Fastify()\n    fastify.ready(err => {\n      t.error(err)\n      t.ok(fastify.hasContentTypeParser('application/json'))\n      t.ok(fastify.hasContentTypeParser('text/plain'))\n      t.notOk(fastify.hasContentTypeParser('application/jsoff'))\n    })\n  })\n\n  test('should work with string and RegExp', t => {\n    t.plan(7)\n\n    const fastify = Fastify()\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n    fastify.addContentTypeParser('image/gif', first)\n\n    t.ok(fastify.hasContentTypeParser('application/json'))\n    t.ok(fastify.hasContentTypeParser(/^image\\/.*/))\n    t.ok(fastify.hasContentTypeParser(/^application\\/.+\\+xml/))\n    t.ok(fastify.hasContentTypeParser('image/gif'))\n    t.notOk(fastify.hasContentTypeParser(/^image\\/.+\\+xml/))\n    t.notOk(fastify.hasContentTypeParser('image/png'))\n    t.notOk(fastify.hasContentTypeParser('*'))\n  })\n\n  t.end()\n})\n\ntest('getParser', t => {\n  test('should return matching parser', t => {\n    t.plan(3)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, second)\n    fastify.addContentTypeParser('text/html', third)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('application/t+xml').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/png').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, third)\n  })\n\n  test('should return matching parser with caching', t => {\n    t.plan(6)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('text/html', first)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 0)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html ').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 1)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html ').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].cache.size, 1)\n  })\n\n  test('should prefer content type parser with string value', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser('image/gif', second)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/gif').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/png').fn, first)\n  })\n\n  test('should return parser that catches all if no other is set', t => {\n    t.plan(3)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('*', first)\n    fastify.addContentTypeParser(/^text\\/.*/, second)\n\n    t.equal(fastify[keys.kContentTypeParser].getParser('image/gif').fn, first)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text/html').fn, second)\n    t.equal(fastify[keys.kContentTypeParser].getParser('text').fn, first)\n  })\n\n  test('should return undefined if no matching parser exist', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^weirdType\\/.+/, first)\n    fastify.addContentTypeParser('application/javascript', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].getParser('application/xml'))\n    t.notOk(fastify[keys.kContentTypeParser].getParser('weirdType/'))\n  })\n\n  t.end()\n})\n\ntest('existingParser', t => {\n  test('returns always false for \"*\"', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser(/^image\\/.*/, first)\n    fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n    fastify.addContentTypeParser('text/html', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].existingParser('*'))\n\n    fastify.addContentTypeParser('*', first)\n\n    t.notOk(fastify[keys.kContentTypeParser].existingParser('*'))\n  })\n\n  test('let you override the default parser once', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n\n    fastify.addContentTypeParser('application/json', first)\n    fastify.addContentTypeParser('text/plain', first)\n\n    t.throws(\n      () => fastify.addContentTypeParser('application/json', first),\n      FST_ERR_CTP_ALREADY_PRESENT,\n      \"Content type parser 'application/json' already present\"\n    )\n    t.throws(\n      () => fastify.addContentTypeParser('text/plain', first),\n      FST_ERR_CTP_ALREADY_PRESENT,\n      \"Content type parser 'text/plain' already present\"\n    )\n  })\n\n  const fastify = Fastify()\n  const contentTypeParser = fastify[keys.kContentTypeParser]\n\n  fastify.addContentTypeParser(/^image\\/.*/, first)\n  fastify.addContentTypeParser(/^application\\/.+\\+xml/, first)\n  fastify.addContentTypeParser('text/html', first)\n\n  t.ok(contentTypeParser.existingParser(/^image\\/.*/))\n  t.ok(contentTypeParser.existingParser('text/html'))\n  t.ok(contentTypeParser.existingParser(/^application\\/.+\\+xml/))\n  t.notOk(contentTypeParser.existingParser('application/json'))\n  t.notOk(contentTypeParser.existingParser('text/plain'))\n  t.notOk(contentTypeParser.existingParser('image/png'))\n  t.notOk(contentTypeParser.existingParser(/^application\\/.+\\+json/))\n\n  t.end()\n})\n\ntest('add', t => {\n  test('should only accept string and RegExp', t => {\n    t.plan(4)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    t.error(contentTypeParser.add('test', {}, first))\n    t.error(contentTypeParser.add(/test/, {}, first))\n    t.throws(\n      () => contentTypeParser.add({}, {}, first),\n      FST_ERR_CTP_INVALID_TYPE,\n      'The content type should be a string or a RegExp'\n    )\n    t.throws(\n      () => contentTypeParser.add(1, {}, first),\n      FST_ERR_CTP_INVALID_TYPE,\n      'The content type should be a string or a RegExp'\n    )\n  })\n\n  test('should set \"*\" as parser that catches all', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.add('*', {}, first)\n    t.equal(contentTypeParser.customParsers.get('').fn, first)\n  })\n\n  t.end()\n})\n\ntest('non-Error thrown from content parser is properly handled', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n\n  const throwable = 'test'\n  const payload = 'error'\n\n  fastify.addContentTypeParser('text/test', (request, payload, done) => {\n    done(throwable)\n  })\n\n  fastify.post('/', (req, reply) => {\n  })\n\n  fastify.setErrorHandler((err, req, res) => {\n    t.equal(err, throwable)\n\n    res.send(payload)\n  })\n\n  fastify.inject({\n    method: 'POST',\n    url: '/',\n    headers: { 'Content-Type': 'text/test' },\n    body: 'some text'\n  }, (err, res) => {\n    t.error(err)\n    t.equal(res.payload, payload)\n  })\n})\n\ntest('Error thrown 415 from content type is null and make post request to server', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n  const errMsg = new FST_ERR_CTP_INVALID_MEDIA_TYPE(undefined).message\n\n  fastify.post('/', (req, reply) => {\n  })\n\n  fastify.inject({\n    method: 'POST',\n    url: '/',\n    body: 'some text'\n  }, (err, res) => {\n    t.error(err)\n    t.equal(res.statusCode, 415)\n    t.equal(JSON.parse(res.body).message, errMsg)\n  })\n})\n\ntest('remove', t => {\n  test('should remove default parser', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove('application/json')\n\n    t.notOk(contentTypeParser.customParsers['application/json'])\n    t.notOk(contentTypeParser.parserList.find(parser => parser === 'application/json'))\n  })\n\n  test('should remove RegExp parser', t => {\n    t.plan(2)\n\n    const fastify = Fastify()\n    fastify.addContentTypeParser(/^text\\/*/, first)\n\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove(/^text\\/*/)\n\n    t.notOk(contentTypeParser.customParsers[/^text\\/*/])\n    t.notOk(contentTypeParser.parserRegExpList.find(parser => parser.toString() === /^text\\/*/.toString()))\n  })\n\n  test('should throw an error if content type is neither string nor RegExp', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    t.throws(() => fastify[keys.kContentTypeParser].remove(12), FST_ERR_CTP_INVALID_TYPE)\n  })\n\n  test('should not throw error if content type does not exist', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    t.doesNotThrow(() => fastify[keys.kContentTypeParser].remove('image/png'))\n  })\n\n  test('should not remove any content type parser if content type does not exist', t => {\n    t.plan(1)\n\n    const fastify = Fastify()\n\n    const contentTypeParser = fastify[keys.kContentTypeParser]\n\n    contentTypeParser.remove('image/png')\n\n    t.same(contentTypeParser.customParsers.size, 2)\n  })\n\n  t.end()\n})\n\ntest('remove all should remove all existing parsers and reset cache', t => {\n  t.plan(4)\n\n  const fastify = Fastify()\n  fastify.addContentTypeParser('application/xml', first)\n  fastify.addContentTypeParser(/^image\\/.*/, first)\n\n  const contentTypeParser = fastify[keys.kContentTypeParser]\n\n  contentTypeParser.getParser('application/xml') // fill cache with one entry\n  contentTypeParser.removeAll()\n\n  t.same(contentTypeParser.cache.size, 0)\n  t.same(contentTypeParser.parserList.length, 0)\n  t.same(contentTypeParser.parserRegExpList.length, 0)\n  t.same(Object.keys(contentTypeParser.customParsers).length, 0)\n})\n\ntest('Safeguard against malicious content-type / 1', async t => {\n  const badNames = Object.getOwnPropertyNames({}.__proto__) // eslint-disable-line\n  t.plan(badNames.length)\n\n  const fastify = Fastify()\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  for (const prop of badNames) {\n    const response = await fastify.inject({\n      method: 'POST',\n      path: '/',\n      headers: {\n        'content-type': prop\n      },\n      body: ''\n    })\n\n    t.same(response.statusCode, 415)\n  }\n})\n\ntest('Safeguard against malicious content-type / 2', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  const response = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': '\\\\u0063\\\\u006fnstructor'\n    },\n    body: ''\n  })\n\n  t.same(response.statusCode, 415)\n})\n\ntest('Safeguard against malicious content-type / 3', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  const response = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': 'constructor; charset=utf-8'\n    },\n    body: ''\n  })\n\n  t.same(response.statusCode, 415)\n})\n\ntest('Safeguard against content-type spoofing - string', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n  fastify.removeAllContentTypeParsers()\n  fastify.addContentTypeParser('text/plain', function (request, body, done) {\n    t.pass('should be called')\n    done(null, body)\n  })\n  fastify.addContentTypeParser('application/json', function (request, body, done) {\n    t.fail('shouldn\\'t be called')\n    done(null, body)\n  })\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': 'text/plain; content-type=\"application/json\"'\n    },\n    body: ''\n  })\n})\n\ntest('Safeguard against content-type spoofing - regexp', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n  fastify.removeAllContentTypeParsers()\n  fastify.addContentTypeParser(/text\\/plain/, function (request, body, done) {\n    t.pass('should be called')\n    done(null, body)\n  })\n  fastify.addContentTypeParser(/application\\/json/, function (request, body, done) {\n    t.fail('shouldn\\'t be called')\n    done(null, body)\n  })\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': 'text/plain; content-type=\"application/json\"'\n    },\n    body: ''\n  })\n})\n\ntest('content-type match parameters - string 1', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n  fastify.removeAllContentTypeParsers()\n  fastify.addContentTypeParser('text/plain; charset=utf8', function (request, body, done) {\n    t.fail('shouldn\\'t be called')\n    done(null, body)\n  })\n  fastify.addContentTypeParser('application/json; charset=utf8', function (request, body, done) {\n    t.pass('should be called')\n    done(null, body)\n  })\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': 'application/json; charset=utf8'\n    },\n    body: ''\n  })\n})\n\ntest('content-type match parameters - string 2', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n  fastify.removeAllContentTypeParsers()\n  fastify.addContentTypeParser('application/json; charset=utf8; foo=bar', function (request, body, done) {\n    t.pass('should be called')\n    done(null, body)\n  })\n  fastify.addContentTypeParser('text/plain; charset=utf8; foo=bar', function (request, body, done) {\n    t.fail('shouldn\\'t be called')\n    done(null, body)\n  })\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': 'application/json; foo=bar; charset=utf8'\n    },\n    body: ''\n  })\n})\n\ntest('content-type match parameters - regexp', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n  fastify.removeAllContentTypeParsers()\n  fastify.addContentTypeParser(/application\\/json; charset=utf8/, function (request, body, done) {\n    t.pass('should be called')\n    done(null, body)\n  })\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': 'application/json; charset=utf8'\n    },\n    body: ''\n  })\n})\n\ntest('content-type fail when parameters not match - string 1', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n  fastify.removeAllContentTypeParsers()\n  fastify.addContentTypeParser('application/json; charset=utf8; foo=bar', function (request, body, done) {\n    t.fail('shouldn\\'t be called')\n    done(null, body)\n  })\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  const response = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': 'application/json; charset=utf8'\n    },\n    body: ''\n  })\n\n  t.same(response.statusCode, 415)\n})\n\ntest('content-type fail when parameters not match - string 2', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n  fastify.removeAllContentTypeParsers()\n  fastify.addContentTypeParser('application/json; charset=utf8; foo=bar', function (request, body, done) {\n    t.fail('shouldn\\'t be called')\n    done(null, body)\n  })\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  const response = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': 'application/json; charset=utf8; foo=baz'\n    },\n    body: ''\n  })\n\n  t.same(response.statusCode, 415)\n})\n\ntest('content-type fail when parameters not match - regexp', async t => {\n  t.plan(1)\n\n  const fastify = Fastify()\n  fastify.removeAllContentTypeParsers()\n  fastify.addContentTypeParser(/application\\/json; charset=utf8; foo=bar/, function (request, body, done) {\n    t.fail('shouldn\\'t be called')\n    done(null, body)\n  })\n\n  fastify.post('/', async () => {\n    return 'ok'\n  })\n\n  const response = await fastify.inject({\n    method: 'POST',\n    path: '/',\n    headers: {\n      'content-type': 'application/json; charset=utf8'\n    },\n    body: ''\n  })\n\n  t.same(response.statusCode, 415)\n})\n", "'use strict'\n\nconst fs = require('fs')\nconst t = require('tap')\nconst test = t.test\nconst sget = require('simple-get').concat\nconst Fastify = require('..')\n\nconst jsonParser = require('fast-json-body')\n\nfunction plainTextParser (request, callback) {\n  let body = ''\n  request.setEncoding('utf8')\n  request.on('error', onError)\n  request.on('data', onData)\n  request.on('end', onEnd)\n  function onError (err) {\n    callback(err, null)\n  }\n  function onData (chunk) {\n    body += chunk\n  }\n  function onEnd () {\n    callback(null, body)\n  }\n}\n\nfunction getUrl (app) {\n  const { address, port } = app.server.address()\n  if (address === '::1') {\n    return `http://[${address}]:${port}`\n  } else {\n    return `http://${address}:${port}`\n  }\n}\n\nprocess.removeAllListeners('warning')\n\ntest('contentTypeParser method should exist', t => {\n  t.plan(1)\n  const fastify = Fastify()\n  t.ok(fastify.addContentTypeParser)\n})\n\ntest('contentTypeParser should add a custom parser', t => {\n  t.plan(3)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.options('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/jsoff', function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    t.teardown(() => fastify.close())\n\n    t.test('in POST', t => {\n      t.plan(3)\n\n      sget({\n        method: 'POST',\n        url: getUrl(fastify),\n        body: '{\"hello\":\"world\"}',\n        headers: {\n          'Content-Type': 'application/jsoff'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      })\n    })\n\n    t.test('in OPTIONS', t => {\n      t.plan(3)\n\n      sget({\n        method: 'OPTIONS',\n        url: getUrl(fastify),\n        body: '{\"hello\":\"world\"}',\n        headers: {\n          'Content-Type': 'application/jsoff'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      })\n    })\n  })\n})\n\ntest('contentTypeParser should handle multiple custom parsers', t => {\n  t.plan(7)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.post('/hello', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  function customParser (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  }\n\n  fastify.addContentTypeParser('application/jsoff', customParser)\n  fastify.addContentTypeParser('application/ffosj', customParser)\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n    t.teardown(() => { fastify.close() })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify) + '/hello',\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/ffosj'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n    })\n  })\n})\n\ntest('contentTypeParser should handle an array of custom contentTypes', t => {\n  t.plan(7)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.post('/hello', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  function customParser (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  }\n\n  fastify.addContentTypeParser(['application/jsoff', 'application/ffosj'], customParser)\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n    t.teardown(() => { fastify.close() })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify) + '/hello',\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/ffosj'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n    })\n  })\n})\n\ntest('contentTypeParser should handle errors', t => {\n  t.plan(3)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/jsoff', function (req, payload, done) {\n    done(new Error('kaboom!'), {})\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 500)\n      fastify.close()\n    })\n  })\n})\n\ntest('contentTypeParser should support encapsulation', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.register((instance, opts, done) => {\n    instance.addContentTypeParser('application/jsoff', () => {})\n    t.ok(instance.hasContentTypeParser('application/jsoff'))\n\n    instance.register((instance, opts, done) => {\n      instance.addContentTypeParser('application/ffosj', () => {})\n      t.ok(instance.hasContentTypeParser('application/jsoff'))\n      t.ok(instance.hasContentTypeParser('application/ffosj'))\n      done()\n    })\n\n    done()\n  })\n\n  fastify.ready(err => {\n    t.error(err)\n    t.notOk(fastify.hasContentTypeParser('application/jsoff'))\n    t.notOk(fastify.hasContentTypeParser('application/ffosj'))\n  })\n})\n\ntest('contentTypeParser should support encapsulation, second try', t => {\n  t.plan(4)\n  const fastify = Fastify()\n\n  fastify.register((instance, opts, done) => {\n    instance.post('/', (req, reply) => {\n      reply.send(req.body)\n    })\n\n    instance.addContentTypeParser('application/jsoff', function (req, payload, done) {\n      jsonParser(payload, function (err, body) {\n        done(err, body)\n      })\n    })\n\n    done()\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      fastify.close()\n    })\n  })\n})\n\ntest('contentTypeParser shouldn\\'t support request with undefined \"Content-Type\"', t => {\n  t.plan(3)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/jsoff', function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'unknown content type!',\n      headers: {\n        // 'Content-Type': undefined\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 415)\n      fastify.close()\n    })\n  })\n})\n\ntest('the content type should be a string or RegExp', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  try {\n    fastify.addContentTypeParser(null, () => {})\n    t.fail()\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_INVALID_TYPE')\n    t.equal(err.message, 'The content type should be a string or a RegExp')\n  }\n})\n\ntest('the content type cannot be an empty string', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  try {\n    fastify.addContentTypeParser('', () => {})\n    t.fail()\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_EMPTY_TYPE')\n    t.equal(err.message, 'The content type cannot be an empty string')\n  }\n})\n\ntest('the content type handler should be a function', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  try {\n    fastify.addContentTypeParser('aaa', null)\n    t.fail()\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_INVALID_HANDLER')\n    t.equal(err.message, 'The content type handler should be a function')\n  }\n})\n\ntest('catch all content type parser', t => {\n  t.plan(7)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('*', function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'hello')\n\n      sget({\n        method: 'POST',\n        url: getUrl(fastify),\n        body: 'hello',\n        headers: {\n          'Content-Type': 'very-weird-content-type'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), 'hello')\n        fastify.close()\n      })\n    })\n  })\n})\n\ntest('catch all content type parser should not interfere with other conte type parsers', t => {\n  t.plan(7)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('*', function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data)\n    })\n  })\n\n  fastify.addContentTypeParser('application/jsoff', function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n\n      sget({\n        method: 'POST',\n        url: getUrl(fastify),\n        body: 'hello',\n        headers: {\n          'Content-Type': 'very-weird-content-type'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), 'hello')\n        fastify.close()\n      })\n    })\n  })\n})\n\n// Issue 492 https://github.com/fastify/fastify/issues/492\ntest('\\'*\\' catch undefined Content-Type requests', t => {\n  t.plan(4)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.addContentTypeParser('*', function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data)\n    })\n  })\n\n  fastify.post('/', (req, res) => {\n    // Needed to avoid json stringify\n    res.type('text/plain').send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, function (err) {\n    t.error(err)\n\n    const fileStream = fs.createReadStream(__filename)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify) + '/',\n      body: fileStream\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body + '', fs.readFileSync(__filename).toString())\n    })\n  })\n})\n\ntest('cannot add custom parser after binding', t => {\n  t.plan(2)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.post('/', (req, res) => {\n    res.type('text/plain').send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, function (err) {\n    t.error(err)\n\n    try {\n      fastify.addContentTypeParser('*', () => {})\n      t.fail()\n    } catch (e) {\n      t.pass()\n    }\n  })\n})\n\ntest('Can override the default json parser', t => {\n  t.plan(5)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/json', function (req, payload, done) {\n    t.ok('called')\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '{\"hello\":\"world\"}')\n      fastify.close()\n    })\n  })\n})\n\ntest('Can override the default plain text parser', t => {\n  t.plan(5)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('text/plain', function (req, payload, done) {\n    t.ok('called')\n    plainTextParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello world',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), 'hello world')\n      fastify.close()\n    })\n  })\n})\n\ntest('Can override the default json parser in a plugin', t => {\n  t.plan(5)\n  const fastify = Fastify()\n\n  fastify.register((instance, opts, done) => {\n    instance.addContentTypeParser('application/json', function (req, payload, done) {\n      t.ok('called')\n      jsonParser(payload, function (err, body) {\n        done(err, body)\n      })\n    })\n\n    instance.post('/', (req, reply) => {\n      reply.send(req.body)\n    })\n\n    done()\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '{\"hello\":\"world\"}')\n      fastify.close()\n    })\n  })\n})\n\ntest('Can\\'t override the json parser multiple times', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  fastify.addContentTypeParser('application/json', function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  try {\n    fastify.addContentTypeParser('application/json', function (req, payload, done) {\n      t.ok('called')\n      jsonParser(payload, function (err, body) {\n        done(err, body)\n      })\n    })\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_ALREADY_PRESENT')\n    t.equal(err.message, 'Content type parser \\'application/json\\' already present.')\n  }\n})\n\ntest('Can\\'t override the plain text parser multiple times', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  fastify.addContentTypeParser('text/plain', function (req, payload, done) {\n    plainTextParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  try {\n    fastify.addContentTypeParser('text/plain', function (req, payload, done) {\n      t.ok('called')\n      plainTextParser(payload, function (err, body) {\n        done(err, body)\n      })\n    })\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_ALREADY_PRESENT')\n    t.equal(err.message, 'Content type parser \\'text/plain\\' already present.')\n  }\n})\n\ntest('Should get the body as string', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/json', { parseAs: 'string' }, function (req, body, done) {\n    t.ok('called')\n    t.ok(typeof body === 'string')\n    try {\n      const json = JSON.parse(body)\n      done(null, json)\n    } catch (err) {\n      err.statusCode = 400\n      done(err, undefined)\n    }\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '{\"hello\":\"world\"}')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should return defined body with no custom parser defined and content type = \\'text/plain\\'', t => {\n  t.plan(4)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello world',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), 'hello world')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should have typeof body object with no custom parser defined, no body defined and content type = \\'text/plain\\'', t => {\n  t.plan(4)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(typeof body, 'object')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should have typeof body object with no custom parser defined, null body and content type = \\'text/plain\\'', t => {\n  t.plan(4)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: null,\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(typeof body, 'object')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should have typeof body object with no custom parser defined, undefined body and content type = \\'text/plain\\'', t => {\n  t.plan(4)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: undefined,\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(typeof body, 'object')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should get the body as string', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('text/plain', { parseAs: 'string' }, function (req, body, done) {\n    t.ok('called')\n    t.ok(typeof body === 'string')\n    try {\n      const plainText = body\n      done(null, plainText)\n    } catch (err) {\n      err.statusCode = 400\n      done(err, undefined)\n    }\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello world',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), 'hello world')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should get the body as buffer', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/json', { parseAs: 'buffer' }, function (req, body, done) {\n    t.ok('called')\n    t.ok(body instanceof Buffer)\n    try {\n      const json = JSON.parse(body)\n      done(null, json)\n    } catch (err) {\n      err.statusCode = 400\n      done(err, undefined)\n    }\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '{\"hello\":\"world\"}')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should get the body as buffer', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('text/plain', { parseAs: 'buffer' }, function (req, body, done) {\n    t.ok('called')\n    t.ok(body instanceof Buffer)\n    try {\n      const plainText = body\n      done(null, plainText)\n    } catch (err) {\n      err.statusCode = 400\n      done(err, undefined)\n    }\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello world',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), 'hello world')\n      fastify.close()\n    })\n  })\n})\n\ntest('Should parse empty bodies as a string', t => {\n  t.plan(9)\n  const fastify = Fastify()\n\n  fastify.addContentTypeParser('text/plain', { parseAs: 'string' }, (req, body, done) => {\n    t.equal(body, '')\n    done(null, body)\n  })\n\n  fastify.route({\n    method: ['POST', 'DELETE'],\n    url: '/',\n    handler (request, reply) {\n      reply.send(request.body)\n    }\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n    t.teardown(() => { fastify.close() })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '')\n    })\n\n    sget({\n      method: 'DELETE',\n      url: getUrl(fastify),\n      body: '',\n      headers: {\n        'Content-Type': 'text/plain',\n        'Content-Length': '0'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '')\n    })\n  })\n})\n\ntest('Should parse empty bodies as a buffer', t => {\n  t.plan(6)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('text/plain', { parseAs: 'buffer' }, function (req, body, done) {\n    t.ok(body instanceof Buffer)\n    t.equal(body.length, 0)\n    done(null, body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.length, 0)\n      fastify.close()\n    })\n  })\n})\n\ntest('The charset should not interfere with the content type handling', t => {\n  t.plan(5)\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('application/json', function (req, payload, done) {\n    t.ok('called')\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json; charset=utf-8'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), '{\"hello\":\"world\"}')\n      fastify.close()\n    })\n  })\n})\n\ntest('Wrong parseAs parameter', t => {\n  t.plan(2)\n  const fastify = Fastify()\n\n  try {\n    fastify.addContentTypeParser('application/json', { parseAs: 'fireworks' }, () => {})\n    t.fail('should throw')\n  } catch (err) {\n    t.equal(err.code, 'FST_ERR_CTP_INVALID_PARSE_TYPE')\n    t.equal(err.message, \"The body parser can only parse your data as 'string' or 'buffer', you asked 'fireworks' which is not supported.\")\n  }\n})\n\ntest('Should allow defining the bodyLimit per parser', t => {\n  t.plan(3)\n  const fastify = Fastify()\n  t.teardown(() => fastify.close())\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser(\n    'x/foo',\n    { parseAs: 'string', bodyLimit: 5 },\n    function (req, body, done) {\n      t.fail('should not be invoked')\n      done()\n    }\n  )\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '1234567890',\n      headers: {\n        'Content-Type': 'x/foo'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.strictSame(JSON.parse(body.toString()), {\n        statusCode: 413,\n        code: 'FST_ERR_CTP_BODY_TOO_LARGE',\n        error: 'Payload Too Large',\n        message: 'Request body is too large'\n      })\n      fastify.close()\n    })\n  })\n})\n\ntest('route bodyLimit should take precedence over a custom parser bodyLimit', t => {\n  t.plan(3)\n  const fastify = Fastify()\n  t.teardown(() => fastify.close())\n\n  fastify.post('/', { bodyLimit: 5 }, (request, reply) => {\n    reply.send(request.body)\n  })\n\n  fastify.addContentTypeParser(\n    'x/foo',\n    { parseAs: 'string', bodyLimit: 100 },\n    function (req, body, done) {\n      t.fail('should not be invoked')\n      done()\n    }\n  )\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '1234567890',\n      headers: { 'Content-Type': 'x/foo' }\n    }, (err, response, body) => {\n      t.error(err)\n      t.strictSame(JSON.parse(body.toString()), {\n        statusCode: 413,\n        code: 'FST_ERR_CTP_BODY_TOO_LARGE',\n        error: 'Payload Too Large',\n        message: 'Request body is too large'\n      })\n      fastify.close()\n    })\n  })\n})\n\ntest('should be able to use default parser for extra content type', t => {\n  t.plan(4)\n  const fastify = Fastify()\n  t.teardown(() => fastify.close())\n\n  fastify.post('/', (request, reply) => {\n    reply.send(request.body)\n  })\n\n  fastify.addContentTypeParser('text/json', { parseAs: 'string' }, fastify.getDefaultJsonParser('ignore', 'ignore'))\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'text/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.strictSame(JSON.parse(body.toString()), { hello: 'world' })\n      fastify.close()\n    })\n  })\n})\n\ntest('contentTypeParser should add a custom parser with RegExp value', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.options('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser(/.*\\+json$/, function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    t.teardown(() => fastify.close())\n\n    t.test('in POST', t => {\n      t.plan(3)\n\n      sget({\n        method: 'POST',\n        url: getUrl(fastify),\n        body: '{\"hello\":\"world\"}',\n        headers: {\n          'Content-Type': 'application/vnd.test+json'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      })\n    })\n\n    t.test('in OPTIONS', t => {\n      t.plan(3)\n\n      sget({\n        method: 'OPTIONS',\n        url: getUrl(fastify),\n        body: '{\"hello\":\"world\"}',\n        headers: {\n          'Content-Type': 'weird/content-type+json'\n        }\n      }, (err, response, body) => {\n        t.error(err)\n        t.equal(response.statusCode, 200)\n        t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      })\n    })\n  })\n})\n\ntest('contentTypeParser should add multiple custom parsers with RegExp values', async t => {\n  t.plan(6)\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser(/.*\\+json$/, function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.addContentTypeParser(/.*\\+xml$/, function (req, payload, done) {\n    done(null, 'xml')\n  })\n\n  fastify.addContentTypeParser(/.*\\+myExtension$/i, function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data + 'myExtension')\n    })\n  })\n\n  await fastify.ready()\n\n  {\n    const response = await fastify.inject({\n      method: 'POST',\n      url: '/',\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/vnd.hello+json'\n      }\n    })\n    t.equal(response.statusCode, 200)\n    t.same(response.payload.toString(), '{\"hello\":\"world\"}')\n  }\n\n  {\n    const response = await fastify.inject({\n      method: 'POST',\n      url: '/',\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/test+xml'\n      }\n    })\n    t.equal(response.statusCode, 200)\n    t.same(response.payload.toString(), 'xml')\n  }\n\n  await fastify.inject({\n    method: 'POST',\n    path: '/',\n    payload: 'abcdefg',\n    headers: {\n      'Content-Type': 'application/+myExtension'\n    }\n  }).then((response) => {\n    t.equal(response.statusCode, 200)\n    t.same(response.payload.toString(), 'abcdefgmyExtension')\n  }).catch((err) => {\n    t.error(err)\n  })\n})\n\ntest('catch all content type parser should not interfere with content type parser', t => {\n  t.plan(10)\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser('*', function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data)\n    })\n  })\n\n  fastify.addContentTypeParser(/^application\\/.*/, function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.addContentTypeParser('text/html', function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data + 'html')\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"myKey\":\"myValue\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ myKey: 'myValue' }))\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'body',\n      headers: {\n        'Content-Type': 'very-weird-content-type'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'body')\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'my text',\n      headers: {\n        'Content-Type': 'text/html'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'my texthtml')\n    })\n  })\n})\n\ntest('should prefer string content types over RegExp ones', t => {\n  t.plan(7)\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.addContentTypeParser(/^application\\/.*/, function (req, payload, done) {\n    let data = ''\n    payload.on('data', chunk => { data += chunk })\n    payload.on('end', () => {\n      done(null, data)\n    })\n  })\n\n  fastify.addContentTypeParser('application/json', function (req, payload, done) {\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"k1\":\"myValue\", \"k2\": \"myValue\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ k1: 'myValue', k2: 'myValue' }))\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'javascript',\n      headers: {\n        'Content-Type': 'application/javascript'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'javascript')\n    })\n  })\n})\n\ntest('removeContentTypeParser should support arrays of content types to remove', t => {\n  t.plan(8)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.addContentTypeParser('application/xml', function (req, payload, done) {\n    payload.on('data', () => {})\n    payload.on('end', () => {\n      done(null, 'xml')\n    })\n  })\n\n  fastify.addContentTypeParser(/^image\\/.*/, function (req, payload, done) {\n    payload.on('data', () => {})\n    payload.on('end', () => {\n      done(null, 'image')\n    })\n  })\n\n  fastify.removeContentTypeParser([/^image\\/.*/, 'application/json'])\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '<?xml version=\"1.0\">',\n      headers: {\n        'Content-Type': 'application/xml'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'xml')\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '',\n      headers: {\n        'Content-Type': 'image/png'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 415)\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{test: \"test\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 415)\n    })\n  })\n})\n\ntest('removeContentTypeParser should support encapsulation', t => {\n  t.plan(6)\n\n  const fastify = Fastify()\n\n  fastify.addContentTypeParser('application/xml', function (req, payload, done) {\n    payload.on('data', () => {})\n    payload.on('end', () => {\n      done(null, 'xml')\n    })\n  })\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.register(function (instance, options, done) {\n    instance.removeContentTypeParser('application/xml')\n\n    instance.post('/encapsulated', (req, reply) => {\n      reply.send(req.body)\n    })\n\n    done()\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify) + '/encapsulated',\n      body: '<?xml version=\"1.0\">',\n      headers: {\n        'Content-Type': 'application/xml'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 415)\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '<?xml version=\"1.0\">',\n      headers: {\n        'Content-Type': 'application/xml'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), 'xml')\n      fastify.close()\n    })\n  })\n})\n\ntest('removeAllContentTypeParsers should support encapsulation', t => {\n  t.plan(6)\n\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.register(function (instance, options, done) {\n    instance.removeAllContentTypeParsers()\n\n    instance.post('/encapsulated', (req, reply) => {\n      reply.send(req.body)\n    })\n\n    done()\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify) + '/encapsulated',\n      body: '{}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 415)\n    })\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"test\":1}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(JSON.parse(body.toString()).test, 1)\n      fastify.close()\n    })\n  })\n})\n\ntest('cannot remove all content type parsers after binding', t => {\n  t.plan(2)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.listen({ port: 0 }, function (err) {\n    t.error(err)\n\n    t.throws(() => fastify.removeAllContentTypeParsers())\n  })\n})\n\ntest('cannot remove content type parsers after binding', t => {\n  t.plan(2)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.listen({ port: 0 }, function (err) {\n    t.error(err)\n\n    t.throws(() => fastify.removeContentTypeParser('application/json'))\n  })\n})\n\ntest('should be able to override the default json parser after removeAllContentTypeParsers', t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.removeAllContentTypeParsers()\n\n  fastify.addContentTypeParser('application/json', function (req, payload, done) {\n    t.ok('called')\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      fastify.close()\n    })\n  })\n})\n\ntest('should be able to override the default plain text parser after removeAllContentTypeParsers', t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.removeAllContentTypeParsers()\n\n  fastify.addContentTypeParser('text/plain', function (req, payload, done) {\n    t.ok('called')\n    plainTextParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: 'hello world',\n      headers: {\n        'Content-Type': 'text/plain'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.equal(body.toString(), 'hello world')\n      fastify.close()\n    })\n  })\n})\n\ntest('should be able to add a custom content type parser after removeAllContentTypeParsers', t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n\n  fastify.post('/', (req, reply) => {\n    reply.send(req.body)\n  })\n\n  fastify.removeAllContentTypeParsers()\n\n  fastify.addContentTypeParser('application/jsoff', function (req, payload, done) {\n    t.ok('called')\n    jsonParser(payload, function (err, body) {\n      done(err, body)\n    })\n  })\n\n  fastify.listen({ port: 0 }, err => {\n    t.error(err)\n\n    sget({\n      method: 'POST',\n      url: getUrl(fastify),\n      body: '{\"hello\":\"world\"}',\n      headers: {\n        'Content-Type': 'application/jsoff'\n      }\n    }, (err, response, body) => {\n      t.error(err)\n      t.equal(response.statusCode, 200)\n      t.same(body.toString(), JSON.stringify({ hello: 'world' }))\n      fastify.close()\n    })\n  })\n})\n"], "filenames": ["lib/contentTypeParser.js", "package.json", "test/content-parser.test.js", "test/custom-parser.test.js"], "buggy_code_start_loc": [4, 178, 397, 1056], "buggy_code_end_loc": [348, 178, 397, 1270], "fixing_code_start_loc": [5, 179, 398, 1056], "fixing_code_end_loc": [418, 180, 612, 1270], "type": "CWE-352", "message": "Fastify is a web framework with minimal overhead and plugin architecture. The attacker can use the incorrect `Content-Type` to bypass the `Pre-Flight` checking of `fetch`. `fetch()` requests with Content-Type\u2019s essence as \"application/x-www-form-urlencoded\", \"multipart/form-data\", or \"text/plain\", could potentially be used to invoke routes that only accepts `application/json` content type, thus bypassing any CORS protection, and therefore they could lead to a Cross-Site Request Forgery attack. This issue has been patched in version 4.10.2 and 3.29.4. As a workaround, implement Cross-Site Request Forgery protection using `@fastify/csrf'.", "other": {"cve": {"id": "CVE-2022-41919", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-22T20:15:11.110", "lastModified": "2022-11-26T03:35:02.497", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Fastify is a web framework with minimal overhead and plugin architecture. The attacker can use the incorrect `Content-Type` to bypass the `Pre-Flight` checking of `fetch`. `fetch()` requests with Content-Type\u2019s essence as \"application/x-www-form-urlencoded\", \"multipart/form-data\", or \"text/plain\", could potentially be used to invoke routes that only accepts `application/json` content type, thus bypassing any CORS protection, and therefore they could lead to a Cross-Site Request Forgery attack. This issue has been patched in version 4.10.2 and 3.29.4. As a workaround, implement Cross-Site Request Forgery protection using `@fastify/csrf'."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fastify:fastify:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.29.4", "matchCriteriaId": "F1CB15D8-00EF-409B-8BE4-E1891670B7C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fastify:fastify:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.10.2", "matchCriteriaId": "B1452A5E-6C6B-45D9-B27F-75DE3D457CC4"}]}]}], "references": [{"url": "https://github.com/fastify/fastify/commit/62dde76f1f7aca76e38625fe8d983761f26e6fc9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fastify/fastify/security/advisories/GHSA-3fjj-p79j-c9hh", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/@fastify/csrf", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/fastify/fastify/commit/62dde76f1f7aca76e38625fe8d983761f26e6fc9"}}