{"buggy_code": ["/**\n * @file subscription.c  common subscription handling\n *\n * Copyright (C) 2003-2021 Lars Windolf <lars.windolf@gmx.de>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"subscription.h\"\n\n#include <math.h>\n#include <string.h>\n\n#include \"auth.h\"\n#include \"common.h\"\n#include \"conf.h\"\n#include \"db.h\"\n#include \"debug.h\"\n#include \"feedlist.h\"\n#include \"metadata.h\"\n#include \"net.h\"\n#include \"subscription_icon.h\"\n#include \"ui/auth_dialog.h\"\n#include \"ui/feed_list_view.h\"\n#include \"ui/itemview.h\"\n#include \"ui/liferea_shell.h\"\n\n/* The allowed feed protocol prefixes (see http://25hoursaday.com/draft-obasanjo-feed-URI-scheme-02.html) */\n#define FEED_PROTOCOL_PREFIX \"feed://\"\n#define FEED_PROTOCOL_PREFIX2 \"feed:\"\n\n#define ONE_MONTH_MICROSECONDS (guint64)(60*60*24*31) * (guint64)G_USEC_PER_SEC\n\nsubscriptionPtr\nsubscription_new (const gchar *source,\n                  const gchar *filter,\n                  updateOptionsPtr options)\n{\n\tsubscriptionPtr\tsubscription;\n\n\tsubscription = g_new0 (struct subscription, 1);\n\tsubscription->type = feed_get_subscription_type ();\n\tsubscription->updateOptions = options;\n\n\tif (!subscription->updateOptions)\n\t\tsubscription->updateOptions = g_new0 (struct updateOptions, 1);\n\n\tsubscription->updateState = update_state_new ();\n\tsubscription->updateInterval = -1;\n\tsubscription->defaultInterval = -1;\n\n\tif (source) {\n\t\tgboolean feedPrefix = FALSE;\n\t\tgchar *uri = g_strdup (source);\n\t\tg_strstrip (uri);\t/* strip confusing whitespaces */\n\n\t\t/* strip feed protocol prefix variant 1 */\n\t\tif (uri == strstr (uri, FEED_PROTOCOL_PREFIX)) {\n\t\t\tgchar *tmp = uri;\n\t\t\turi = g_strdup (uri + strlen (FEED_PROTOCOL_PREFIX));\n\t\t\tg_free (tmp);\n\t\t\tfeedPrefix = TRUE;\n\t\t}\n\n\t\t/* strip feed protocol prefix variant 2 */\n\t\tif (uri == strstr (uri, FEED_PROTOCOL_PREFIX2)) {\n\t\t\tgchar *tmp = uri;\n\t\t\turi = g_strdup (uri + strlen (FEED_PROTOCOL_PREFIX2));\n\t\t\tg_free (tmp);\n\t\t\tfeedPrefix = TRUE;\n\t\t}\n\n\t\t/* ensure protocol prefix (but only for feed:[//] URIs to avoid\n\t\t   breaking local file and command line subscriptions) */\n\t\tif (feedPrefix && !strstr (uri, \"://\")) {\n\t\t\tgchar *tmp = uri;\n\t\t\turi = g_strdup_printf (\"http://%s\", uri);\n\t\t\tg_free (tmp);\n\t\t}\n\n\t\tsubscription_set_source (subscription, uri);\n\t\tg_free (uri);\n\t}\n\n\tif (filter)\n\t\tsubscription_set_filter (subscription, filter);\n\n\treturn subscription;\n}\n\n/* Checks whether updating a feed makes sense. */\nstatic gboolean\nsubscription_can_be_updated (subscriptionPtr subscription)\n{\n\tif (subscription->updateJob) {\n\t\tliferea_shell_set_status_bar (_(\"Subscription \\\"%s\\\" is already being updated!\"), node_get_title (subscription->node));\n\t\treturn FALSE;\n\t}\n\n\tif (subscription->discontinued) {\n\t\tliferea_shell_set_status_bar (_(\"The subscription \\\"%s\\\" was discontinued. Liferea won't update it anymore!\"), node_get_title (subscription->node));\n\t\treturn FALSE;\n\t}\n\n\tif (!subscription_get_source (subscription)) {\n\t\tg_warning (\"Feed source is NULL! This should never happen - cannot update!\");\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nvoid\nsubscription_reset_update_counter (subscriptionPtr subscription, guint64 *now)\n{\n\tif (!subscription)\n\t\treturn;\n\n\tsubscription->updateState->lastPoll = *now;\n\tdebug2 (DEBUG_UPDATE, \"Resetting last poll counter of %s to %lld.\", subscription->source, subscription->updateState->lastPoll);\n}\n\n/**\n * Updates the error status of the given subscription\n *\n * @param subscription\tthe subscription\n * @param httpstatus\tthe new HTTP status code\n * @param filterError\tfilter error string (or NULL)\n */\nstatic void\nsubscription_update_error_status (subscriptionPtr subscription,\n                                  gint httpstatus,\n                                  gchar *filterError)\n{\n\tif (subscription->filterError)\n\t\tg_free (subscription->filterError);\n\tif (subscription->httpError)\n\t\tg_free (subscription->httpError);\n\tif (subscription->updateError)\n\t\tg_free (subscription->updateError);\n\n\tsubscription->filterError = g_strdup (filterError);\n\tsubscription->updateError = NULL;\t// FIXME: this might not be very useful!\n\tsubscription->httpError = NULL;\n\tsubscription->httpErrorCode = httpstatus;\n\n\t/* Note: the httpstatus we get here is a libsoup status code\n\t   which is either a HTTP status code or a libsoup status.\n\t   https://developer.gnome.org/libsoup/unstable/libsoup-2.4-soup-status.html\n\n\t   Therefore we know if it is between 200 an 399 all is fine.\n\n\t   Otherwise we build a message according to the libsoup doc\n\t */\n\n\tif (!((httpstatus >= 200) && (httpstatus < 400)))\n\t\tsubscription->httpError = g_strdup (network_strerror (httpstatus));\n}\n\nstatic void\nsubscription_process_update_result (const struct updateResult * const result, gpointer user_data, guint32 flags)\n{\n\tsubscriptionPtr subscription = (subscriptionPtr)user_data;\n\tnodePtr\t\tnode = subscription->node;\n\tgboolean\tprocessing = FALSE;\n\tguint\t\tcount, maxcount;\n\tgchar\t\t*statusbar;\n\n\t/* 1. preprocessing */\n\tstatusbar = g_strdup (\"\");\n\n\tg_assert (subscription->updateJob);\n\t/* update the subscription URL on permanent redirects */\n\tif ((301 == result->httpstatus || 308 == result->httpstatus) && result->source && !g_str_equal (result->source, subscription->updateJob->request->source)) {\n\t\tdebug2 (DEBUG_UPDATE, \"The URL of \\\"%s\\\" has changed permanently and was updated to \\\"%s\\\"\", node_get_title(node), result->source);\n\t\tsubscription_set_source (subscription, result->source);\n    statusbar = g_strdup_printf (_(\"The URL of \\\"%s\\\" has changed permanently and was updated\"), node_get_title(node));\n  }\n\n\t/* consider everything that prevents processing the data we got */\n\tif (result->httpstatus >= 400 || !result->data) {\n\t\t/* Default */\n\t\tsubscription->error = FETCH_ERROR_NET;\n\t\tnode->available = FALSE;\n\n\t\t/* Special handling */\n\t\tif (401 == result->httpstatus) { /* unauthorized */\n\t\t\tsubscription->error = FETCH_ERROR_AUTH;\n\t\t\tauth_dialog_new (subscription, flags);\n\t\t}\n\t\tif (410 == result->httpstatus) { /* gone */\n\t\t\tsubscription_set_discontinued (subscription, TRUE);\n\t\t\tstatusbar = g_strdup_printf (_(\"\\\"%s\\\" is discontinued. Liferea won't updated it anymore!\"), node_get_title (node));\n\t\t}\n\t} else if (304 == result->httpstatus) {\n\t\tnode->available = TRUE;\n\t\tstatusbar = g_strdup_printf (_(\"\\\"%s\\\" has not changed since last update\"), node_get_title(node));\n\t} else if (result->filterErrors) {\n\t\tnode->available = FALSE;\n\t\tsubscription->error = FETCH_ERROR_NET;\n\t} else {\n\t\tprocessing = TRUE;\n\t}\n\n\t/* Clear status bar if we are last update in progress */\n\tupdate_jobs_get_count (&count, &maxcount);\n\tif (1 >= count)\n\t\tliferea_shell_set_status_bar (statusbar);\n\telse\n\t\tliferea_shell_set_status_bar (_(\"Updating (%d / %d) ...\"), maxcount - count, maxcount);\n\tg_free (statusbar);\n\n\tsubscription_update_error_status (subscription, result->httpstatus, result->filterErrors);\n\n\tsubscription->updateJob = NULL;\n\n\t/* 2. call subscription type specific processing */\n\tif (processing)\n\t\tSUBSCRIPTION_TYPE (subscription)->process_update_result (subscription, result, flags);\n\n\t/* 3. call favicon updating only after subscription processing\n\t      to ensure we have valid baseUrl for feed nodes...\n\n\t      check creation date and update favicon if older than one month */\n\tif (g_get_real_time() > (subscription->updateState->lastFaviconPoll + ONE_MONTH_MICROSECONDS))\n\t\tsubscription_icon_update (subscription);\n\n\t/* 4. generic postprocessing */\n\tupdate_state_set_lastmodified (subscription->updateState, update_state_get_lastmodified (result->updateState));\n\tupdate_state_set_cookies (subscription->updateState, update_state_get_cookies (result->updateState));\n\tupdate_state_set_etag (subscription->updateState, update_state_get_etag (result->updateState));\n\tsubscription->updateState->lastPoll = g_get_real_time();\n\n\t// FIXME: use signal here\n\titemview_update_node_info (subscription->node);\n\titemview_update ();\n\n\tdb_subscription_update (subscription);\n\tdb_node_update (subscription->node);\n\n\tfeed_list_view_update_node (node->id);\t// FIXME: This should be dropped once the \"node-updated\" signal is consumed\n\n\tif (processing && subscription->node->newCount > 0) {\n\t\t// FIXME: use new-items signal in itemview class\n\t\tfeedlist_new_items (node->newCount);\n\t\tfeedlist_node_was_updated (node);\n\t}\n}\n\nvoid\nsubscription_update (subscriptionPtr subscription, guint flags)\n{\n\tUpdateRequest\t*request;\n\tguint64\t\tnow;\n\tguint\t\tcount, maxcount;\n\n\tif (!subscription)\n\t\treturn;\n\n\tif (subscription->updateJob)\n\t\treturn;\n\n\tdebug1 (DEBUG_UPDATE, \"Scheduling %s to be updated\", node_get_title (subscription->node));\n\n\tif (subscription_can_be_updated (subscription)) {\n\t\tnow = g_get_real_time();\n\t\tsubscription_reset_update_counter (subscription, &now);\n\n\t\trequest = update_request_new (\n\t\t\tsubscription_get_source (subscription),\n\t\t\tsubscription->updateState,\n\t\t\tsubscription->updateOptions\n\t\t);\n\n\t\tif (subscription_get_filter (subscription))\n\t\t\trequest->filtercmd = g_strdup (subscription_get_filter (subscription));\n\n\t\tif (SUBSCRIPTION_TYPE (subscription)->prepare_update_request (subscription, request))\n\t\t\tsubscription->updateJob = update_execute_request (subscription, request, subscription_process_update_result, subscription, flags);\n\t\telse\n\t\t\tg_object_unref (request);\n\n\t\tupdate_jobs_get_count (&count, &maxcount);\n\t\tif (count > 1)\n\t\t\tliferea_shell_set_status_bar (_(\"Updating (%d / %d) ...\"), maxcount - count, maxcount);\n\t\telse\n\t\t\tliferea_shell_set_status_bar (_(\"Updating '%s'...\"), node_get_title (subscription->node));\n\t}\n}\n\nvoid\nsubscription_auto_update (subscriptionPtr subscription)\n{\n\tgint\t\tinterval;\n\tguint\t\tflags = 0;\n\tguint64\tnow;\n\n\tif (!subscription)\n\t\treturn;\n\n\tinterval = subscription_get_update_interval (subscription);\n\tif (-1 == interval)\n\t\tconf_get_int_value (DEFAULT_UPDATE_INTERVAL, &interval);\n\n\tif (-2 >= interval || 0 == interval)\n\t\treturn;\t\t/* don't update this subscription */\n\n\tnow = g_get_real_time();\n\n\tif (subscription->updateState->lastPoll + (guint64)interval * (guint64)(60 * G_USEC_PER_SEC) <= now)\n\t\tsubscription_update (subscription, flags);\n}\n\nvoid\nsubscription_cancel_update (subscriptionPtr subscription)\n{\n\tif (!subscription->updateJob)\n\t\treturn;\n\n\tupdate_job_cancel_by_owner (subscription);\n\tsubscription->updateJob = NULL;\n}\n\ngint\nsubscription_get_update_interval (subscriptionPtr subscription)\n{\n\treturn subscription->updateInterval;\n}\n\nvoid\nsubscription_set_update_interval (subscriptionPtr subscription, gint interval)\n{\n\tif (0 == interval) {\n\t\tinterval = -1;\t/* This is evil, I know, but when this method\n\t\t\t\t   is called to set the update interval to 0\n\t\t\t\t   we mean \"never updating\". The updating logic\n\t\t\t\t   expects -1 for \"never updating\" and 0 for\n\t\t\t\t   updating according to the global update\n\t\t\t\t   interval... */\n\t}\n\tsubscription->updateInterval = interval;\n\tfeedlist_schedule_save ();\n}\n\nguint\nsubscription_get_default_update_interval (subscriptionPtr subscription)\n{\n\treturn subscription->defaultInterval;\n}\n\nvoid\nsubscription_set_default_update_interval (subscriptionPtr subscription, guint interval)\n{\n\tsubscription->defaultInterval = interval;\n}\n\nvoid\nsubscription_set_discontinued (subscriptionPtr subscription, gboolean newState)\n{\n\tsubscription->discontinued = newState;\n}\n\nstatic const gchar *\nsubscription_get_orig_source (subscriptionPtr subscription)\n{\n\treturn subscription->origSource;\n}\n\nconst gchar *\nsubscription_get_source (subscriptionPtr subscription)\n{\n\treturn subscription->source;\n}\n\nconst gchar *\nsubscription_get_homepage (subscriptionPtr subscription)\n{\n\treturn metadata_list_get (subscription->metadata, \"homepage\");\n}\n\nconst gchar *\nsubscription_get_filter (subscriptionPtr subscription)\n{\n\treturn subscription->filtercmd;\n}\n\nstatic void\nsubscription_set_orig_source (subscriptionPtr subscription, const gchar *source)\n{\n\tg_free (subscription->origSource);\n\tsubscription->origSource = g_strchomp (g_strdup (source));\n\tfeedlist_schedule_save ();\n}\n\nvoid\nsubscription_set_source (subscriptionPtr subscription, const gchar *source)\n{\n\tg_free (subscription->source);\n\tsubscription->source = g_strchomp (g_strdup (source));\n\tfeedlist_schedule_save ();\n\n\tupdate_state_set_cookies (subscription->updateState, NULL);\n\n\tif (NULL == subscription_get_orig_source (subscription))\n\t\tsubscription_set_orig_source (subscription, source);\n}\n\nvoid\nsubscription_set_homepage (subscriptionPtr subscription, const gchar *newHtmlUrl)\n{\n\tgchar \t*htmlUrl = NULL;\n\n\tif (newHtmlUrl) {\n\t\tif (strstr (newHtmlUrl, \"://\")) {\n\t\t\t/* absolute URI can be used directly */\n\t\t\thtmlUrl = g_strchomp (g_strdup (newHtmlUrl));\n\t\t} else {\n\t\t\t/* relative URI part needs to be expanded */\n\t\t\tgchar *tmp, *source;\n\n\t\t\tsource = g_strdup (subscription_get_source (subscription));\n\t\t\ttmp = strrchr (source, '/');\n\t\t\tif (tmp)\n\t\t\t\t*(tmp+1) = '\\0';\n\n\t\t\thtmlUrl = (gchar *)common_build_url (newHtmlUrl, source);\n\t\t\tg_free (source);\n\t\t}\n\n\t\tmetadata_list_set (&subscription->metadata, \"homepage\", htmlUrl);\n\t\tg_free (htmlUrl);\n\t}\n}\n\nvoid\nsubscription_set_filter (subscriptionPtr subscription, const gchar *filter)\n{\n\tg_free (subscription->filtercmd);\n\tsubscription->filtercmd = g_strdup (filter);\n\tfeedlist_schedule_save ();\n}\n\nvoid\nsubscription_set_auth_info (subscriptionPtr subscription,\n                            const gchar *username,\n                            const gchar *password)\n{\n\tg_assert (NULL != subscription->updateOptions);\n\n\tg_free (subscription->updateOptions->username);\n\tg_free (subscription->updateOptions->password);\n\n\tsubscription->updateOptions->username = g_strdup (username);\n\tsubscription->updateOptions->password = g_strdup (password);\n\n\tliferea_auth_info_store (subscription);\n}\n\nsubscriptionPtr\nsubscription_import (xmlNodePtr xml, gboolean trusted)\n{\n\tsubscriptionPtr\tsubscription;\n\txmlChar\t\t*source, *homepage, *filter, *intervalStr, *tmp;\n\n\tsubscription = subscription_new (NULL, NULL, NULL);\n\n\tsource = xmlGetProp (xml, BAD_CAST \"xmlUrl\");\n\tif (!source)\n\t\tsource = xmlGetProp (xml, BAD_CAST \"xmlurl\");\t/* e.g. for AmphetaDesk */\n\n\tif (source) {\n\t\tif (!trusted && source[0] == '|') {\n\t\t\t/* FIXME: Display warning dialog asking if the command\n\t\t\t   is safe? */\n\t\t\ttmp = (xmlChar *)g_strdup_printf (\"unsafe command: %s\", source);\n\t\t\txmlFree (source);\n\t\t\tsource = tmp;\n\t\t}\n\n\t\tsubscription_set_source (subscription, (gchar *)source);\n\t\txmlFree (source);\n\n\t\thomepage = xmlGetProp (xml, BAD_CAST \"htmlUrl\");\n\t\tif (homepage && xmlStrcmp (homepage, BAD_CAST \"\"))\n\t\t\tsubscription_set_homepage (subscription, (gchar *)homepage);\n\t\txmlFree (homepage);\n\n\t\tif ((filter = xmlGetProp (xml, BAD_CAST \"filtercmd\"))) {\n\t\t\tif (!trusted) {\n\t\t\t\t/* FIXME: Display warning dialog asking if the command\n\t\t\t\t   is safe? */\n\t\t\t\ttmp = (xmlChar *)g_strdup_printf (\"unsafe command: %s\", filter);\n\t\t\t\txmlFree (filter);\n\t\t\t\tfilter = tmp;\n\t\t\t}\n\n\t\t\tsubscription_set_filter (subscription, (gchar *)filter);\n\t\t\txmlFree (filter);\n\t\t}\n\n\t\tintervalStr = xmlGetProp (xml, BAD_CAST \"updateInterval\");\n\t\tsubscription_set_update_interval (subscription, common_parse_long ((gchar *)intervalStr, -1));\n\t\txmlFree (intervalStr);\n\n\t\t/* no proxy flag */\n\t\ttmp = xmlGetProp (xml, BAD_CAST \"dontUseProxy\");\n\t\tif (tmp && !xmlStrcmp (tmp, BAD_CAST \"true\"))\n\t\t\tsubscription->updateOptions->dontUseProxy = TRUE;\n\t\txmlFree (tmp);\n\n\t\t/* authentication options */\n\t\tsubscription->updateOptions->username = (gchar *)xmlGetProp (xml, BAD_CAST \"username\");\n\t\tsubscription->updateOptions->password = (gchar *)xmlGetProp (xml, BAD_CAST \"password\");\n\t}\n\n\treturn subscription;\n}\n\nvoid\nsubscription_export (subscriptionPtr subscription, xmlNodePtr xml, gboolean trusted)\n{\n\tgchar *interval = g_strdup_printf (\"%d\", subscription_get_update_interval (subscription));\n\n\txmlNewProp (xml, BAD_CAST \"xmlUrl\", BAD_CAST subscription_get_source (subscription));\n\n\tif (subscription_get_homepage (subscription))\n\t\txmlNewProp (xml, BAD_CAST\"htmlUrl\", BAD_CAST subscription_get_homepage (subscription));\n\telse\n\t\txmlNewProp (xml, BAD_CAST\"htmlUrl\", BAD_CAST \"\");\n\n\tif (subscription_get_filter (subscription))\n\t\txmlNewProp (xml, BAD_CAST\"filtercmd\", BAD_CAST subscription_get_filter (subscription));\n\n\tif(trusted) {\n\t\txmlNewProp (xml, BAD_CAST\"updateInterval\", BAD_CAST interval);\n\n\t\tif (subscription->updateOptions->dontUseProxy)\n\t\t\txmlNewProp (xml, BAD_CAST\"dontUseProxy\", BAD_CAST\"true\");\n\n\t\tif (!liferea_auth_has_active_store ()) {\n\t\t\tif (subscription->updateOptions->username)\n\t\t\t\txmlNewProp (xml, BAD_CAST\"username\", (xmlChar *)subscription->updateOptions->username);\n\t\t\tif (subscription->updateOptions->password)\n\t\t\t\txmlNewProp (xml, BAD_CAST\"password\", (xmlChar *)subscription->updateOptions->password);\n\t\t}\n\t}\n\n\tg_free (interval);\n}\n\nvoid\nsubscription_to_xml (subscriptionPtr subscription, xmlNodePtr xml)\n{\n\tgchar\t*tmp;\n\n\txmlNewTextChild (xml, NULL, BAD_CAST \"feedSource\", (xmlChar *)subscription_get_source (subscription));\n\txmlNewTextChild (xml, NULL, BAD_CAST \"feedOrigSource\", (xmlChar *)subscription_get_orig_source (subscription));\n\n\ttmp = g_strdup_printf (\"%d\", subscription_get_default_update_interval (subscription));\n\txmlNewTextChild (xml, NULL, BAD_CAST \"feedUpdateInterval\", (xmlChar *)tmp);\n\tg_free (tmp);\n\n\tif (subscription->updateError)\n\t\txmlNewTextChild (xml, NULL, BAD_CAST \"updateError\", (xmlChar *)subscription->updateError);\n\tif (subscription->httpError) {\n\t\txmlNewTextChild (xml, NULL, BAD_CAST \"httpError\", (xmlChar *)subscription->httpError);\n\n\t\ttmp = g_strdup_printf (\"%d\", subscription->httpErrorCode);\n\t\txmlNewTextChild (xml, NULL, BAD_CAST \"httpErrorCode\", (xmlChar *)tmp);\n\t\tg_free (tmp);\n\t}\n\tif (subscription->filterError)\n\t\txmlNewTextChild (xml, NULL, BAD_CAST \"filterError\", (xmlChar *)subscription->filterError);\n\n\tmetadata_add_xml_nodes (subscription->metadata, xml);\n}\n\nvoid\nsubscription_free (subscriptionPtr subscription)\n{\n\tif (!subscription)\n\t\treturn;\n\n\tg_free (subscription->updateError);\n\tg_free (subscription->filterError);\n\tg_free (subscription->httpError);\n\tg_free (subscription->source);\n\tg_free (subscription->origSource);\n\tg_free (subscription->filtercmd);\n\n\tupdate_job_cancel_by_owner (subscription);\n\tupdate_options_free (subscription->updateOptions);\n\tupdate_state_free (subscription->updateState);\n\tmetadata_list_free (subscription->metadata);\n\n\tg_free (subscription);\n}\n", "/**\n * @file update.c  generic update request and state processing\n *\n * Copyright (C) 2003-2021 Lars Windolf <lars.windolf@gmx.de>\n * Copyright (C) 2004-2006 Nathan J. Conrad <t98502@users.sourceforge.net>\n * Copyright (C) 2009 Adrian Bunk <bunk@users.sourceforge.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"update.h\"\n\n#include <libxml/parser.h>\n#include <libxslt/xslt.h>\n#include <libxslt/xsltInternals.h>\n#include <libxslt/transform.h>\n#include <libxslt/xsltutils.h>\n\n#include <unistd.h>\n#include <stdio.h>\n#if !defined (G_OS_WIN32) || defined (HAVE_SYS_WAIT_H)\n#include <sys/wait.h>\n#endif\n#include <string.h>\n\n#include \"auth_activatable.h\"\n#include \"common.h\"\n#include \"debug.h\"\n#include \"net.h\"\n#include \"plugins_engine.h\"\n#include \"xml.h\"\n#include \"ui/liferea_shell.h\"\n\n#if defined (G_OS_WIN32) && !defined (WIFEXITED) && !defined (WEXITSTATUS)\n#define WIFEXITED(x) (x != 0)\n#define WEXITSTATUS(x) (x)\n#endif\n\n/** global update job list, used for lookups when cancelling */\nstatic GSList\t*jobs = NULL;\n\nstatic GAsyncQueue *pendingHighPrioJobs = NULL;\nstatic GAsyncQueue *pendingJobs = NULL;\nstatic guint numberOfActiveJobs = 0;\n#define MAX_ACTIVE_JOBS\t5\n\n/* update state interface */\n\nupdateStatePtr\nupdate_state_new (void)\n{\n\treturn g_new0 (struct updateState, 1);\n}\n\nglong\nupdate_state_get_lastmodified (updateStatePtr state)\n{\n\treturn state->lastModified;\n}\n\nvoid\nupdate_state_set_lastmodified (updateStatePtr state, glong lastModified)\n{\n\tstate->lastModified = lastModified;\n}\n\nconst gchar *\nupdate_state_get_etag (updateStatePtr state)\n{\n\treturn state->etag;\n}\n\nvoid\nupdate_state_set_etag (updateStatePtr state, const gchar *etag)\n{\n\tg_free (state->etag);\n\tstate->etag = NULL;\n\tif (etag)\n\t\tstate->etag = g_strdup(etag);\n}\n\nvoid\nupdate_state_set_cache_maxage (updateStatePtr state, const gint maxage)\n{\n\tif (0 < maxage)\n\t\tstate->maxAgeMinutes = maxage;\n\telse\n\t\tstate->maxAgeMinutes = -1;\n}\n\ngint\nupdate_state_get_cache_maxage (updateStatePtr state)\n{\n\treturn state->maxAgeMinutes;\n}\n\nconst gchar *\nupdate_state_get_cookies (updateStatePtr state)\n{\n\treturn state->cookies;\n}\n\nvoid\nupdate_state_set_cookies (updateStatePtr state, const gchar *cookies)\n{\n\tg_free (state->cookies);\n\tstate->cookies = NULL;\n\tif (cookies)\n\t\tstate->cookies = g_strdup (cookies);\n}\n\nupdateStatePtr\nupdate_state_copy (updateStatePtr state)\n{\n\tupdateStatePtr newState;\n\n\tnewState = update_state_new ();\n\tupdate_state_set_lastmodified (newState, update_state_get_lastmodified (state));\n\tupdate_state_set_cookies (newState, update_state_get_cookies (state));\n\tupdate_state_set_etag (newState, update_state_get_etag (state));\n\n\treturn newState;\n}\n\nvoid\nupdate_state_free (updateStatePtr updateState)\n{\n\tif (!updateState)\n\t\treturn;\n\n\tg_free (updateState->cookies);\n\tg_free (updateState->etag);\n\tg_free (updateState);\n}\n\n/* update options */\n\nupdateOptionsPtr\nupdate_options_copy (updateOptionsPtr options)\n{\n\tupdateOptionsPtr newOptions;\n\tnewOptions = g_new0 (struct updateOptions, 1);\n\tnewOptions->username = g_strdup (options->username);\n\tnewOptions->password = g_strdup (options->password);\n\tnewOptions->dontUseProxy = options->dontUseProxy;\n\treturn newOptions;\n}\nvoid\nupdate_options_free (updateOptionsPtr options)\n{\n\tif (!options)\n\t\treturn;\n\n\tg_free (options->username);\n\tg_free (options->password);\n\tg_free (options);\n}\n\n/* update request object */\n\nG_DEFINE_TYPE (UpdateRequest, update_request, G_TYPE_OBJECT);\n\nstatic void\nupdate_request_finalize (GObject *obj)\n{\n\tUpdateRequest *request = UPDATE_REQUEST (obj);\n\n\tupdate_state_free (request->updateState);\n\tupdate_options_free (request->options);\n\n\tg_free (request->postdata);\n\tg_free (request->source);\n\tg_free (request->filtercmd);\n\n\tG_OBJECT_CLASS (update_request_parent_class)->finalize (obj);\n}\n\nstatic void\nupdate_request_class_init (UpdateRequestClass *klass)\n{\n\tGObjectClass *object_class = G_OBJECT_CLASS (klass);\n\tobject_class->finalize = update_request_finalize;\n}\n\nstatic void\nupdate_request_init (UpdateRequest *request)\n{\n}\n\nUpdateRequest *\nupdate_request_new (const gchar *source, updateStatePtr state, updateOptionsPtr options)\n{\n\tUpdateRequest *request = UPDATE_REQUEST (g_object_new (UPDATE_REQUEST_TYPE, NULL));\n\n\trequest->source = g_strdup (source);\n\n\tif (state)\n\t\trequest->updateState = update_state_copy (state);\n\telse\n\t\trequest->updateState = update_state_new ();\n\n\n\tif (options)\n\t\trequest->options = update_options_copy (options);\n\telse\n\t\trequest->options = g_new0 (struct updateOptions, 1);\n\n\treturn request;\n}\n\nvoid\nupdate_request_set_source(UpdateRequest *request, const gchar* source)\n{\n\tg_free (request->source);\n\trequest->source = g_strdup (source);\n}\n\nvoid\nupdate_request_set_auth_value (UpdateRequest *request, const gchar* authValue)\n{\n\tg_free (request->authValue);\n\trequest->authValue = g_strdup (authValue);\n}\n\n/* update result object */\n\nupdateResultPtr\nupdate_result_new (void)\n{\n\tupdateResultPtr\tresult;\n\n\tresult = g_new0 (struct updateResult, 1);\n\tresult->updateState = update_state_new ();\n\n\treturn result;\n}\n\nvoid\nupdate_result_free (updateResultPtr result)\n{\n\tif (!result)\n\t\treturn;\n\n\tupdate_state_free (result->updateState);\n\n\tg_free (result->data);\n\tg_free (result->source);\n\tg_free (result->contentType);\n\tg_free (result->filterErrors);\n\tg_free (result);\n}\n\n/* update job handling */\n\nstatic updateJobPtr\nupdate_job_new (gpointer owner,\n                UpdateRequest *request,\n\t\tupdate_result_cb callback,\n\t\tgpointer user_data,\n\t\tupdateFlags flags)\n{\n\tupdateJobPtr\tjob;\n\n\tjob = g_new0 (struct updateJob, 1);\n\tjob->owner = owner;\n\tjob->request = UPDATE_REQUEST (request);\n\tjob->result = update_result_new ();\n\tjob->callback = callback;\n\tjob->user_data = user_data;\n\tjob->flags = flags;\n\tjob->state = REQUEST_STATE_INITIALIZED;\n\n\tjob->cmd.fd = -1;\n\tjob->cmd.pid = 0;\n\n\treturn job;\n}\n\ngint\nupdate_job_get_state (updateJobPtr job)\n{\n\treturn job->state;\n}\n\nstatic void\nupdate_job_show_count_foreach_func (gpointer data, gpointer user_data)\n{\n\tupdateJobPtr\tjob = (updateJobPtr)data;\n\tguint\t\t*count = (guint *)user_data;\n\n\t// Count all subscription jobs (ignore HTML5 and favicon requests)\n\tif (!(job->flags & FEED_REQ_NO_FEED))\n\t\t(*count)++;\n}\n\nstatic guint maxcount = 0;\n\nvoid\nupdate_jobs_get_count (guint *count, guint *max)\n{\n\t*count = 0;\n\tg_slist_foreach (jobs, update_job_show_count_foreach_func, count);\n\n\tif (*count > maxcount)\n\t\tmaxcount = *count;\n\n\t*max = maxcount;\n}\n\nstatic void\nupdate_job_free (updateJobPtr job)\n{\n\tif (!job)\n\t\treturn;\n\n\tjobs = g_slist_remove (jobs, job);\n\n\tg_object_unref (job->request);\n\tupdate_result_free (job->result);\n\n\tif (job->cmd.fd >= 0) {\n\t\tdebug1 (DEBUG_UPDATE, \"Found an open cmd.fd %d when freeing!\", job->cmd.fd);\n\t\tclose (job->cmd.fd);\n\t}\n\tif (job->cmd.timeout_id > 0) {\n\t\tg_source_remove (job->cmd.timeout_id);\n\t}\n\tif (job->cmd.io_watch_id > 0) {\n\t\tg_source_remove (job->cmd.io_watch_id);\n\t}\n\tif (job->cmd.child_watch_id > 0) {\n\t\tg_source_remove (job->cmd.child_watch_id);\n\t}\n\tif (job->cmd.stdout_ch) {\n\t\tg_io_channel_unref (job->cmd.stdout_ch);\n\t}\n\tg_free (job);\n}\n\n/* filter idea (and some of the code) was taken from Snownews */\nstatic gchar *\nupdate_exec_filter_cmd (updateJobPtr job)\n{\n\tint\t\tfd, status;\n\tgchar\t\t*command;\n\tconst gchar\t*tmpdir = g_get_tmp_dir();\n\tchar\t\t*tmpfilename;\n\tchar\t\t*out = NULL;\n\tFILE\t\t*file, *p;\n\tsize_t\t\tsize = 0;\n\n\ttmpfilename = g_build_filename (tmpdir, \"liferea-XXXXXX\", NULL);\n\n\tfd = g_mkstemp (tmpfilename);\n\n\tif (fd == -1) {\n\t\tdebug1 (DEBUG_UPDATE, \"Error opening temp file %s to use for filtering!\", tmpfilename);\n\t\tjob->result->filterErrors = g_strdup_printf (_(\"Error opening temp file %s to use for filtering!\"), tmpfilename);\n\t\tg_free (tmpfilename);\n\t\treturn NULL;\n\t}\n\n\tfile = fdopen (fd, \"w\");\n\tfwrite (job->result->data, strlen (job->result->data), 1, file);\n\tfclose (file);\n\n\tcommand = g_strdup_printf(\"%s < %s\", job->request->filtercmd, tmpfilename);\n\tp = popen (command, \"r\");\n\tif (NULL != p) {\n\t\twhile (!feof (p) && !ferror (p)) {\n\t\t\tsize_t len;\n\t\t\tout = g_realloc (out, size + 1025);\n\t\t\tlen = fread (&out[size], 1, 1024, p);\n\t\t\tif (len > 0)\n\t\t\t\tsize += len;\n\t\t}\n\t\tstatus = pclose (p);\n\t\tif (!(WIFEXITED (status) && WEXITSTATUS (status) == 0)) {\n\t\t\tdebug2 (DEBUG_UPDATE, \"%s exited with status %d!\", command, WEXITSTATUS(status));\n\t\t\tjob->result->filterErrors = g_strdup_printf (_(\"%s exited with status %d\"), command, WEXITSTATUS(status));\n\t\t\tsize = 0;\n\t\t}\n\t\tif (out)\n\t\t\tout[size] = '\\0';\n\t} else {\n\t\tg_warning (_(\"Error: Could not open pipe \\\"%s\\\"\"), command);\n\t\tjob->result->filterErrors = g_strdup_printf (_(\"Error: Could not open pipe \\\"%s\\\"\"), command);\n\t}\n\n\t/* Clean up. */\n\tg_free (command);\n\tunlink (tmpfilename);\n\tg_free (tmpfilename);\n\treturn out;\n}\n\nstatic gchar *\nupdate_apply_xslt (updateJobPtr job)\n{\n\txsltStylesheetPtr\txslt = NULL;\n\txmlOutputBufferPtr\tbuf;\n\txmlDocPtr\t\tsrcDoc = NULL, resDoc = NULL;\n\tgchar\t\t\t*output = NULL;\n\n\tg_assert (NULL != job->result);\n\n\tdo {\n\t\tsrcDoc = xml_parse (job->result->data, job->result->size, NULL);\n\t\tif (!srcDoc) {\n\t\t\tg_warning(\"fatal: parsing request result XML source failed (%s)!\", job->request->filtercmd);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* load localization stylesheet */\n\t\txslt = xsltParseStylesheetFile ((xmlChar *)job->request->filtercmd);\n\t\tif (!xslt) {\n\t\t\tg_warning (\"fatal: could not load filter stylesheet \\\"%s\\\"!\", job->request->filtercmd);\n\t\t\tbreak;\n\t\t}\n\n\t\tresDoc = xsltApplyStylesheet (xslt, srcDoc, NULL);\n\t\tif (!resDoc) {\n\t\t\tg_warning (\"fatal: applying stylesheet \\\"%s\\\" failed!\", job->request->filtercmd);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = xmlAllocOutputBuffer (NULL);\n\t\tif (-1 == xsltSaveResultTo (buf, resDoc, xslt)) {\n\t\t\tg_warning (\"fatal: retrieving result of filter stylesheet failed (%s)!\", job->request->filtercmd);\n\t\t\tbreak;\n\t\t}\n\n#ifdef LIBXML2_NEW_BUFFER\n\t\tif (xmlOutputBufferGetSize (buf) > 0)\n\t\t\toutput = (gchar *)xmlCharStrdup ((char *)xmlOutputBufferGetContent (buf));\n#else\n\t\tif (xmlBufferLength (buf->buffer) > 0)\n\t\t\toutput = (gchar *)xmlCharStrdup ((char *)xmlBufferContent (buf->buffer));\n#endif\n\n\t\txmlOutputBufferClose (buf);\n\t} while (FALSE);\n\n\tif (srcDoc)\n\t\txmlFreeDoc (srcDoc);\n\tif (resDoc)\n\t\txmlFreeDoc (resDoc);\n\tif (xslt)\n\t\txsltFreeStylesheet (xslt);\n\n\treturn output;\n}\n\nstatic void\nupdate_apply_filter (updateJobPtr job)\n{\n\tgchar\t*filterResult;\n\n\tg_assert (NULL == job->result->filterErrors);\n\n\t/* we allow two types of filters: XSLT stylesheets and arbitrary commands */\n\tif ((strlen (job->request->filtercmd) > 4) &&\n\t    (0 == strcmp (\".xsl\", job->request->filtercmd + strlen (job->request->filtercmd) - 4)))\n\t\tfilterResult = update_apply_xslt (job);\n\telse\n\t\tfilterResult = update_exec_filter_cmd (job);\n\n\tif (filterResult) {\n\t\tg_free (job->result->data);\n\t\tjob->result->data = filterResult;\n\t\tjob->result->size = strlen(filterResult);\n\t}\n}\n\nstatic void\nupdate_exec_cmd_cb_child_watch (GPid pid, gint status, gpointer user_data)\n{\n\tupdateJobPtr\tjob = (updateJobPtr) user_data;\n\tdebug1 (DEBUG_UPDATE, \"Child process %d terminated\", job->cmd.pid);\n\n\tjob->cmd.pid = 0;\n\tif (WIFEXITED (status) && WEXITSTATUS (status) == 0) {\n\t\tjob->result->httpstatus = 200;\n\t} else if (job->result->httpstatus == 0) {\n\t\t/* If there is no more specific error code. */\n\t\tjob->result->httpstatus = 500;  /* Internal server error. */\n\t}\n\n\tjob->cmd.child_watch_id = 0;\t/* Caller will remove source. */\n\tif (job->cmd.timeout_id > 0) {\n\t\tg_source_remove (job->cmd.timeout_id);\n\t\tjob->cmd.timeout_id = 0;\n\t}\n\tif (job->cmd.io_watch_id > 0) {\n\t\tg_source_remove (job->cmd.io_watch_id);\n\t\tjob->cmd.io_watch_id = 0;\n\t}\n\tupdate_process_finished_job (job);\n}\n\n\nstatic gboolean\nupdate_exec_cmd_cb_out_watch (GIOChannel *source, GIOCondition condition, gpointer user_data)\n{\n\tupdateJobPtr\tjob = (updateJobPtr) user_data;\n\tGError\t\t*err = NULL;\n\tgboolean\tret = TRUE;\t/* Do not remove event source yet. */\n\tGIOStatus\tst;\n\tgsize\t\tnread;\n\n\tif (condition == G_IO_HUP) {\n\t\tdebug1 (DEBUG_UPDATE, \"Pipe closed, child process %d is terminating\", job->cmd.pid);\n\t\tret = FALSE;\n\n\t} else if (condition == G_IO_IN) {\n\t\twhile (TRUE) {\n\t\t\tjob->result->data = g_realloc (job->result->data, job->result->size + 1025);\n\n\t\t\tnread = 0;\n\t\t\tst = g_io_channel_read_chars (source,\n\t\t\t\tjob->result->data + job->result->size,\n\t\t\t\t1024, &nread, &err);\n\t\t\tjob->result->size += nread;\n\t\t\tjob->result->data[job->result->size] = 0;\n\n\t\t\tif (err) {\n\t\t\t\tdebug2 (DEBUG_UPDATE, \"Error %d when reading from child %d\", err->code, job->cmd.pid);\n\t\t\t\tg_error_free (err);\n\t\t\t\terr = NULL;\n\t\t\t\tret = FALSE;\t/* remove event */\n\t\t\t}\n\n\t\t\tif (nread == 0) {\n\t\t\t\t/* Finished reading */\n\t\t\t\tbreak;\n\t\t\t} else if (st == G_IO_STATUS_AGAIN) {\n\t\t\t\t/* just try again */\n\t\t\t} else if (st == G_IO_STATUS_EOF) {\n\t\t\t\t/* Pipe closed */\n\t\t\t\tret = FALSE;\n\t\t\t\tbreak;\n\t\t\t} else if (st == G_IO_STATUS_ERROR) {\n\t\t\t\tdebug1 (DEBUG_UPDATE, \"Got a G_IO_STATUS_ERROR from child %d\", job->cmd.pid);\n\t\t\t\tret = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tdebug2 (DEBUG_UPDATE, \"Unexpected condition %d for child process %d\", condition, job->cmd.pid);\n\t\tret = FALSE;\n\t}\n\n\tif (ret == FALSE) {\n\t\tclose (job->cmd.fd);\n\t\tjob->cmd.fd = -1;\n\t\tjob->cmd.io_watch_id = 0;\t/* Caller will remove source. */\n\t}\n\n\treturn ret;\n}\n\n\nstatic gboolean\nupdate_exec_cmd_cb_timeout (gpointer user_data)\n{\n\tupdateJobPtr\tjob = (updateJobPtr) user_data;\n\tdebug1 (DEBUG_UPDATE, \"Child process %d timed out, killing.\", job->cmd.pid);\n\n\t/* Kill child. Result will still be processed by update_exec_cmd_cb_child_watch */\n\tkill((pid_t) job->cmd.pid, SIGKILL);\n\tjob->cmd.timeout_id = 0;\n\tjob->result->httpstatus = 504;\t/* Gateway timeout */\n\treturn FALSE;\t/* Remove timeout source */\n}\n\nstatic int\nget_exec_timeout_ms(void)\n{\n\tconst gchar\t*val;\n\tint\ti;\n\tif ((val = g_getenv(\"LIFEREA_FEED_CMD_TIMEOUT\")) != NULL) {\n\t\tif ((i = atoi(val)) > 0) {\n\t\t\treturn 1000*i;\n\t\t}\n\t}\n\treturn 60000; /* Default timeout */\n}\n\nstatic void\nupdate_exec_cmd (updateJobPtr job)\n{\n\tgboolean\tret;\n\tgchar\t\t*cmd = (job->request->source) + 1;\n\n\t/* Previous versions ran through popen() and a lot of users may be depending\n\t * on this behavior, so we run through a shell and keep compatibility. */\n\tgchar\t\t*cmd_args[] = { \"/bin/sh\", \"-c\", cmd, NULL };\n\n\tjob->result->httpstatus = 0;\n\tdebug1 (DEBUG_UPDATE, \"executing command \\\"%s\\\"...\", cmd);\n\tret = g_spawn_async_with_pipes (NULL, cmd_args, NULL,\n\t\tG_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_STDERR_TO_DEV_NULL,\n\t\tNULL, NULL, &job->cmd.pid, NULL,\n\t\t&job->cmd.fd, NULL, NULL);\n\n\tif (!ret) {\n\t\tdebug0 (DEBUG_UPDATE, \"g_spawn_async_with_pipes failed\");\n\t\tliferea_shell_set_status_bar (_(\"Error: Could not open pipe \\\"%s\\\"\"), cmd);\n\t\tjob->result->httpstatus = 404; /* Not found */\n\t\treturn;\n\t}\n\n\tdebug1 (DEBUG_UPDATE, \"New child process launched with pid %d\", job->cmd.pid);\n\n\tjob->cmd.child_watch_id = g_child_watch_add (job->cmd.pid, (GChildWatchFunc) update_exec_cmd_cb_child_watch, job);\n\tjob->cmd.stdout_ch = g_io_channel_unix_new (job->cmd.fd);\n\tjob->cmd.io_watch_id = g_io_add_watch (job->cmd.stdout_ch, G_IO_IN | G_IO_HUP, (GIOFunc) update_exec_cmd_cb_out_watch, job);\n\n\tjob->cmd.timeout_id = g_timeout_add (get_exec_timeout_ms(), (GSourceFunc) update_exec_cmd_cb_timeout, job);\n}\n\nstatic void\nupdate_load_file (updateJobPtr job)\n{\n\tgchar *filename = job->request->source;\n\tgchar *anchor;\n\n\tif (!strncmp (filename, \"file://\",7))\n\t\tfilename += 7;\n\n\tanchor = strchr (filename, '#');\n\tif (anchor)\n\t\t*anchor = 0;\t /* strip anchors from filenames */\n\n\tif (g_file_test (filename, G_FILE_TEST_EXISTS)) {\n\t\t/* we have a file... */\n\t\tif ((!g_file_get_contents (filename, &(job->result->data), &(job->result->size), NULL)) || (job->result->data[0] == '\\0')) {\n\t\t\tjob->result->httpstatus = 403;\t/* FIXME: maybe setting request->returncode would be better */\n\t\t\tliferea_shell_set_status_bar (_(\"Error: Could not open file \\\"%s\\\"\"), filename);\n\t\t} else {\n\t\t\tjob->result->httpstatus = 200;\n\t\t\tdebug2 (DEBUG_UPDATE, \"Successfully read %d bytes from file %s.\", job->result->size, filename);\n\t\t}\n\t} else {\n\t\tliferea_shell_set_status_bar (_(\"Error: There is no file \\\"%s\\\"\"), filename);\n\t\tjob->result->httpstatus = 404;\t/* FIXME: maybe setting request->returncode would be better */\n\t}\n\n\tupdate_process_finished_job (job);\n}\n\nstatic void\nupdate_job_run (updateJobPtr job)\n{\n\t/* Here we decide on the source type and the proper execution\n\t   methods which then do anything they want with the job and\n\t   pass the processed job to update_process_finished_job()\n\t   for result dequeuing */\n\n\t/* everything starting with '|' is a local command */\n\tif (*(job->request->source) == '|') {\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n\t\tupdate_exec_cmd (job);\n\t\treturn;\n\t}\n\n\t/* if it has a protocol \"://\" prefix, but not \"file://\" it is an URI */\n\tif (strstr (job->request->source, \"://\") && strncmp (job->request->source, \"file://\", 7)) {\n\t\tnetwork_process_request (job);\n\t\treturn;\n\t}\n\n\t/* otherwise it must be a local file... */\n\t{\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized file URI: %s\", job->request->source);\n\t\tupdate_load_file (job);\n\t\treturn;\n\t}\n}\n\nstatic gboolean\nupdate_dequeue_job (gpointer user_data)\n{\n\tupdateJobPtr job;\n\n\tif (!pendingJobs)\n\t\treturn FALSE;\t/* we must be in shutdown */\n\n\tif (numberOfActiveJobs >= MAX_ACTIVE_JOBS)\n\t\treturn FALSE;\t/* we'll be called again when a job finishes */\n\n\n\tjob = (updateJobPtr)g_async_queue_try_pop(pendingHighPrioJobs);\n\n\tif (!job)\n\t\tjob = (updateJobPtr)g_async_queue_try_pop(pendingJobs);\n\n\tif(!job)\n\t\treturn FALSE;\t/* no request at the moment */\n\n\tnumberOfActiveJobs++;\n\n\tjob->state = REQUEST_STATE_PROCESSING;\n\n\tdebug1 (DEBUG_UPDATE, \"processing request (%s)\", job->request->source);\n\tif (job->callback == NULL) {\n\t\tupdate_process_finished_job (job);\n\t} else {\n\t\tupdate_job_run (job);\n\t}\n\n\treturn FALSE;\n}\n\nupdateJobPtr\nupdate_execute_request (gpointer owner,\n                        UpdateRequest *request,\n\t\t\tupdate_result_cb callback,\n\t\t\tgpointer user_data,\n\t\t\tupdateFlags flags)\n{\n\tupdateJobPtr job;\n\n\tg_assert (request->options != NULL);\n\tg_assert (request->source != NULL);\n\n\tjob = update_job_new (owner, request, callback, user_data, flags);\n\tjob->state = REQUEST_STATE_PENDING;\n\tjobs = g_slist_append (jobs, job);\n\n\tif (flags & FEED_REQ_PRIORITY_HIGH) {\n\t\tg_async_queue_push (pendingHighPrioJobs, (gpointer)job);\n\t} else {\n\t\tg_async_queue_push (pendingJobs, (gpointer)job);\n\t}\n\n\tg_idle_add (update_dequeue_job, NULL);\n\treturn job;\n}\n\nvoid\nupdate_job_cancel_by_owner (gpointer owner)\n{\n\tGSList\t*iter = jobs;\n\n\twhile (iter) {\n\t\tupdateJobPtr job = (updateJobPtr)iter->data;\n\t\tif (job->owner == owner)\n\t\t\tjob->callback = NULL;\n\t\titer = g_slist_next (iter);\n\t}\n}\n\nstatic gboolean\nupdate_process_result_idle_cb (gpointer user_data)\n{\n\tupdateJobPtr job = (updateJobPtr)user_data;\n\n\tif (job->callback)\n\t\t(job->callback) (job->result, job->user_data, job->flags);\n\n\tupdate_job_free (job);\n\n\treturn FALSE;\n}\n\nstatic void\nupdate_apply_filter_async(GTask *task, gpointer src, gpointer tdata, GCancellable *ccan)\n{\n    updateJobPtr job = tdata;\n    update_apply_filter(job);\n    g_task_return_int(task, 0);\n}\n\nstatic void\nupdate_apply_filter_finish(GObject *src, GAsyncResult *result, gpointer user_data)\n{\n    updateJobPtr job = user_data;\n    g_idle_add(update_process_result_idle_cb, job);\n}\n\nvoid\nupdate_process_finished_job (updateJobPtr job)\n{\n\tjob->state = REQUEST_STATE_DEQUEUE;\n\n\tg_assert(numberOfActiveJobs > 0);\n\tnumberOfActiveJobs--;\n\tg_idle_add (update_dequeue_job, NULL);\n\n\t/* Handling abandoned requests (e.g. after feed deletion) */\n\tif (job->callback == NULL) {\n\t\tdebug1 (DEBUG_UPDATE, \"freeing cancelled request (%s)\", job->request->source);\n\t\tupdate_job_free (job);\n\t\treturn;\n\t}\n\n\t/* Finally execute the postfilter */\n\tif (job->result->data && job->request->filtercmd) {\n                GTask *task = g_task_new(NULL, NULL, update_apply_filter_finish, job);\n                g_task_set_task_data(task, job, NULL);\n                g_task_run_in_thread(task, update_apply_filter_async);\n                g_object_unref(task);\n                return;\n        }\n\n\tg_idle_add (update_process_result_idle_cb, job);\n}\n\n\nvoid\nupdate_init (void)\n{\n\tpendingJobs = g_async_queue_new ();\n\tpendingHighPrioJobs = g_async_queue_new ();\n}\n\nvoid\nupdate_deinit (void)\n{\n\tGSList\t*iter = jobs;\n\n\t/* Cancel all jobs, to avoid async callbacks accessing the GUI */\n\twhile (iter) {\n\t\tupdateJobPtr job = (updateJobPtr)iter->data;\n\t\tjob->callback = NULL;\n\t\titer = g_slist_next (iter);\n\t}\n\n\tg_async_queue_unref (pendingJobs);\n\tg_async_queue_unref (pendingHighPrioJobs);\n\n\tg_slist_free (jobs);\n\tjobs = NULL;\n}\n", "/**\n * @file update.h  generic update request and state processing\n *\n * Copyright (C) 2003-2020 Lars Windolf <lars.windolf@gmx.de>\n * Copyright (C) 2004-2006 Nathan J. Conrad <t98502@users.sourceforge.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef _UPDATE_H\n#define _UPDATE_H\n\n#include <time.h>\n#include <glib.h>\n#include <glib-object.h>\n\n/* Update requests do represent feed updates, favicon and enclosure\n   downloads. A request can be started synchronously or asynchronously.\n   In the latter case it can be cancelled at any time. If the processing\n   of a update request is done the request callback will be triggered.\n\n   A request can have an update state assigned. This is to support\n   the different bandwidth saving methods. For caching along feeds\n   there are XML (de)serialization functions for the update state.\n\n   For proxy support and authentication an update request can have\n   update options assigned.\n\n   Finally the request system has an on/offline state. When offline\n   no new network requests are accepted. Filesystem and internal\n   requests are still processed. Currently running downloads are\n   not terminated. */\n\ntypedef enum {\n\tREQUEST_STATE_INITIALIZED = 0,\t/**< request struct newly created */\n\tREQUEST_STATE_PENDING,\t\t/**< request added to download queue */\n\tREQUEST_STATE_PROCESSING,\t/**< request currently in download */\n\tREQUEST_STATE_DEQUEUE,\t\t/**< download finished, callback processing */\n\tREQUEST_STATE_FINISHED\t\t/**< request processing finished */\n} request_state;\n\nstruct updateJob;\nstruct updateResult;\n\ntypedef guint32 updateFlags;\n\n/**\n * Generic update result processing callback type.\n * This callback must not free the result structure. It will be\n * free'd by the download system after the callback returns.\n *\n * @param result\tthe update result\n * @param user_data\tupdate processing callback data\n * @param flags\t\tupdate processing flags\n */\ntypedef void (*update_result_cb) (const struct updateResult * const result, gpointer user_data, updateFlags flags);\n\n/** defines update options to be passed to an update request */\ntypedef struct updateOptions {\n\tgchar\t\t*username;\t/**< username for HTTP auth */\n\tgchar\t\t*password;\t/**< password for HTTP auth */\n\tgboolean\tdontUseProxy;\t/**< no proxy flag */\n} *updateOptionsPtr;\n\n/** defines all state data an updatable object (e.g. a feed) needs */\ntypedef struct updateState {\n\tglong\t\tlastModified;\t\t/**< Last modified string as sent by the server */\n\tguint64  \tlastPoll;\t\t/**< time at which the feed was last updated */\n\tguint64 \tlastFaviconPoll;\t/**< time at which the feeds favicon was last updated */\n\tgchar\t\t*cookies;\t\t/**< cookies to be used */\n\tgchar\t\t*etag;\t\t\t/**< ETag sent by the server */\n\tgint\t\tmaxAgeMinutes;\t\t/**< default update interval, greatest value sourced from HTTP and XML */\n\tgint\t\tsynFrequency;\t\t/**< syn:updateFrequency */\n\tgint\t\tsynPeriod;\t\t/**< syn:updatePeriod */\n\tgint\t\ttimeToLive;\t\t/**< ttl */\n} *updateStatePtr;\n\nG_BEGIN_DECLS\n#define UPDATE_REQUEST_TYPE (update_request_get_type ())\nG_DECLARE_FINAL_TYPE (UpdateRequest, update_request, UPDATE, REQUEST, GObject)\n\nstruct _UpdateRequest {\n\tGObject\t\tparent;\n\n\tgchar \t\t*source;\t/**< Location of the source. If it starts with\n\t\t\t\t\t     '|', it is a command. If it contains \"://\",\n\t\t\t\t\t     then it is parsed as a URL, otherwise it is a\n\t\t\t\t\t     filename. */\n\tgchar           *postdata;      /**< HTTP POST request data (NULL for non-POST requests) */\n\tgchar           *authValue;     /**< Custom value for Authorization: header */\n\tupdateOptionsPtr options;\t/**< Update options for the request */\n\tgchar\t\t*filtercmd;\t/**< Command will filter output of URL */\n\tupdateStatePtr\tupdateState;\t/**< Update state of the requested object (etags, last modified...) */\n};\n\n/** structure to store results of the processing of an update request */\ntypedef struct updateResult {\n\tgchar \t\t*source;\t/**< Location of the downloaded document, in case of redirects different from\n\t\t\t\t\t     the one given along with the update request */\n\n\tint\t\thttpstatus;\t/**< HTTP status. Set to 200 for any valid command, file access, etc.... Set to 0 for unknown */\n\tgchar\t\t*data;\t\t/**< Downloaded data */\n\tsize_t\t\tsize;\t\t/**< Size of downloaded data */\n\tgchar\t\t*contentType;\t/**< Content type of received data */\n\tgchar\t\t*filterErrors;\t/**< Error messages from filter execution */\n\n\tupdateStatePtr\tupdateState;\t/**< New update state of the requested object (etags, last modified...) */\n} *updateResultPtr;\n\n/** structure to store state fo running command feeds */\ntypedef struct updateCommandState {\n\tGPid\t\tpid;\t\t/**< child PID */\n\tguint\t\ttimeout_id;\t/**< glib event source id for the timeout event */\n\tguint\t\tio_watch_id;\t/**< glib event source id for stdout */\n\tguint\t\tchild_watch_id;\t/**< glib event source id for child termination */\n\tgint\t\tfd;\t\t/**< fd for child stdout */\n\tGIOChannel\t*stdout_ch;\t/**< child stdout as a channel */\n} updateCommandState;\n\n\n/** structure describing an HTTP update job */\ntypedef struct updateJob {\n\tUpdateRequest\t\t*request;\n\tupdateResultPtr\t\tresult;\n\tgpointer\t\towner;\t\t/**< owner of this job (used for matching when cancelling) */\n\tupdate_result_cb\tcallback;\t/**< result processing callback */\n\tgpointer\t\tuser_data;\t/**< result processing user data */\n\tupdateFlags\t\tflags;\t\t/**< request and result processing flags */\n\tgint\t\t\tstate;\t\t/**< State of the job (enum request_state) */\n\tupdateCommandState\tcmd;\t\t/**< values for command feeds */\n} *updateJobPtr;\n\n/**\n * Create new update state\n */\nupdateStatePtr update_state_new (void);\n\n/**\n * Copy update state\n */\nupdateStatePtr update_state_copy (updateStatePtr state);\n\nglong update_state_get_lastmodified (updateStatePtr state);\nvoid update_state_set_lastmodified (updateStatePtr state, glong lastmodified);\n\nconst gchar * update_state_get_etag (updateStatePtr state);\nvoid update_state_set_etag (updateStatePtr state, const gchar *etag);\n\ngint update_state_get_cache_maxage (updateStatePtr state);\nvoid update_state_set_cache_maxage (updateStatePtr state, const gint maxage);\n\nconst gchar * update_state_get_cookies (updateStatePtr state);\nvoid update_state_set_cookies (updateStatePtr state, const gchar *cookies);\n\n/**\n * Frees the given update state.\n *\n * @param updateState  the update state\n */\nvoid update_state_free (updateStatePtr updateState);\n\n/**\n * Copies the given update options.\n *\n * @returns a new update options structure (to be free'd using update_options_free())\n */\nupdateOptionsPtr update_options_copy (updateOptionsPtr options);\n\n/**\n * Frees the given update options\n *\n * @param options\tthe update options\n */\nvoid update_options_free (updateOptionsPtr options);\n\n/**\n * Initialises the download subsystem.\n *\n * Must be called before gtk_init() and after thread initialization\n * as threads are used and for proper network-manager initialization.\n */\nvoid update_init (void);\n\n/**\n * Stops all update processing and frees all used memory.\n */\nvoid update_deinit (void);\n\n/**\n * Creates a new request structure.\n *\n * @oaram source\tURI to download\n * @param state\t\ta previous update state of the requested URL (or NULL)\n *                      will not be owned, but copied!\n * @param options\tupdate options to be used (or NULL)\n *\t\t\twill not be owned but copied!\n *\n * @returns a new request GObject to be passed to update_execute_request()\n */\nUpdateRequest * update_request_new (const gchar *source, updateStatePtr state, updateOptionsPtr options);\n\n/**\n * Sets the source for an updateRequest. Only use this when the source\n * is not known at update_request_new() calling time.\n *\n * @param request       the update request\n * @param source        the new source URL\n */\nvoid update_request_set_source (UpdateRequest *request, const gchar* source);\n\n/**\n * Sets a custom authorization header value.\n *\n * @param request        the update request\n * @param authValue      the authorization header value\n */\nvoid update_request_set_auth_value (UpdateRequest *request, const gchar* authValue);\n\n/**\n * Creates a new update result for the given update request.\n *\n * @returns update result (to be free'd using update_result_free())\n */\nupdateResultPtr update_result_new (void);\n\n/**\n * Free's the given update result.\n *\n * @param result\tthe result\n */\nvoid update_result_free (updateResultPtr result);\n\n/**\n * Executes the given request. The request might be\n * delayed if other requests are pending.\n *\n * @param owner\t\trequest owner (allows cancelling, can be NULL)\n * @param request\tthe request to execute\n * @param callback\tresult processing callback\n * @param user_data\tresult processing callback parameters (or NULL)\n * @param flags\t\trequest/result processing flags\n *\n * @returns the new update job\n */\nupdateJobPtr update_execute_request (gpointer owner,\n                                     UpdateRequest *request,\n                                     update_result_cb callback,\n                                     gpointer user_data,\n                                     updateFlags flags);\n\n/* Update job handling */\n\n/**\n * To be called when an update job has been executed. Triggers\n * the job specific result processing callback.\n *\n * @param job\t\tthe update job\n */\nvoid update_process_finished_job (updateJobPtr job);\n\n/**\n * Cancel all pending requests for the given owner.\n *\n * @param owner\t\tpointer passed in update_request_new()\n */\nvoid update_job_cancel_by_owner (gpointer owner);\n\n/**\n * Method to query the update state of currently processed jobs.\n *\n * @returns update job state (see enum request_state)\n */\ngint update_job_get_state (updateJobPtr job);\n\n/**\n* update_jobs_get_count:\n*\n* Query current count and max count of subscriptions in update queue\n*\n* @count:\tgint ref to pass back nr of subscriptions in update\n* @maxcount:\tgint ref to pass back max nr of subscriptions in update\n*/\nvoid update_jobs_get_count (guint *count, guint *maxcount);\n\nG_END_DECLS\n\n#endif\n"], "fixing_code": ["/**\n * @file subscription.c  common subscription handling\n *\n * Copyright (C) 2003-2021 Lars Windolf <lars.windolf@gmx.de>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"subscription.h\"\n\n#include <math.h>\n#include <string.h>\n\n#include \"auth.h\"\n#include \"common.h\"\n#include \"conf.h\"\n#include \"db.h\"\n#include \"debug.h\"\n#include \"feedlist.h\"\n#include \"metadata.h\"\n#include \"net.h\"\n#include \"subscription_icon.h\"\n#include \"ui/auth_dialog.h\"\n#include \"ui/feed_list_view.h\"\n#include \"ui/itemview.h\"\n#include \"ui/liferea_shell.h\"\n\n/* The allowed feed protocol prefixes (see http://25hoursaday.com/draft-obasanjo-feed-URI-scheme-02.html) */\n#define FEED_PROTOCOL_PREFIX \"feed://\"\n#define FEED_PROTOCOL_PREFIX2 \"feed:\"\n\n#define ONE_MONTH_MICROSECONDS (guint64)(60*60*24*31) * (guint64)G_USEC_PER_SEC\n\nsubscriptionPtr\nsubscription_new (const gchar *source,\n                  const gchar *filter,\n                  updateOptionsPtr options)\n{\n\tsubscriptionPtr\tsubscription;\n\n\tsubscription = g_new0 (struct subscription, 1);\n\tsubscription->type = feed_get_subscription_type ();\n\tsubscription->updateOptions = options;\n\n\tif (!subscription->updateOptions)\n\t\tsubscription->updateOptions = g_new0 (struct updateOptions, 1);\n\n\tsubscription->updateState = update_state_new ();\n\tsubscription->updateInterval = -1;\n\tsubscription->defaultInterval = -1;\n\n\tif (source) {\n\t\tgboolean feedPrefix = FALSE;\n\t\tgchar *uri = g_strdup (source);\n\t\tg_strstrip (uri);\t/* strip confusing whitespaces */\n\n\t\t/* strip feed protocol prefix variant 1 */\n\t\tif (uri == strstr (uri, FEED_PROTOCOL_PREFIX)) {\n\t\t\tgchar *tmp = uri;\n\t\t\turi = g_strdup (uri + strlen (FEED_PROTOCOL_PREFIX));\n\t\t\tg_free (tmp);\n\t\t\tfeedPrefix = TRUE;\n\t\t}\n\n\t\t/* strip feed protocol prefix variant 2 */\n\t\tif (uri == strstr (uri, FEED_PROTOCOL_PREFIX2)) {\n\t\t\tgchar *tmp = uri;\n\t\t\turi = g_strdup (uri + strlen (FEED_PROTOCOL_PREFIX2));\n\t\t\tg_free (tmp);\n\t\t\tfeedPrefix = TRUE;\n\t\t}\n\n\t\t/* ensure protocol prefix (but only for feed:[//] URIs to avoid\n\t\t   breaking local file and command line subscriptions) */\n\t\tif (feedPrefix && !strstr (uri, \"://\")) {\n\t\t\tgchar *tmp = uri;\n\t\t\turi = g_strdup_printf (\"http://%s\", uri);\n\t\t\tg_free (tmp);\n\t\t}\n\n\t\tsubscription_set_source (subscription, uri);\n\t\tg_free (uri);\n\t}\n\n\tif (filter)\n\t\tsubscription_set_filter (subscription, filter);\n\n\treturn subscription;\n}\n\n/* Checks whether updating a feed makes sense. */\nstatic gboolean\nsubscription_can_be_updated (subscriptionPtr subscription)\n{\n\tif (subscription->updateJob) {\n\t\tliferea_shell_set_status_bar (_(\"Subscription \\\"%s\\\" is already being updated!\"), node_get_title (subscription->node));\n\t\treturn FALSE;\n\t}\n\n\tif (subscription->discontinued) {\n\t\tliferea_shell_set_status_bar (_(\"The subscription \\\"%s\\\" was discontinued. Liferea won't update it anymore!\"), node_get_title (subscription->node));\n\t\treturn FALSE;\n\t}\n\n\tif (!subscription_get_source (subscription)) {\n\t\tg_warning (\"Feed source is NULL! This should never happen - cannot update!\");\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nvoid\nsubscription_reset_update_counter (subscriptionPtr subscription, guint64 *now)\n{\n\tif (!subscription)\n\t\treturn;\n\n\tsubscription->updateState->lastPoll = *now;\n\tdebug2 (DEBUG_UPDATE, \"Resetting last poll counter of %s to %lld.\", subscription->source, subscription->updateState->lastPoll);\n}\n\n/**\n * Updates the error status of the given subscription\n *\n * @param subscription\tthe subscription\n * @param httpstatus\tthe new HTTP status code\n * @param filterError\tfilter error string (or NULL)\n */\nstatic void\nsubscription_update_error_status (subscriptionPtr subscription,\n                                  gint httpstatus,\n                                  gchar *filterError)\n{\n\tif (subscription->filterError)\n\t\tg_free (subscription->filterError);\n\tif (subscription->httpError)\n\t\tg_free (subscription->httpError);\n\tif (subscription->updateError)\n\t\tg_free (subscription->updateError);\n\n\tsubscription->filterError = g_strdup (filterError);\n\tsubscription->updateError = NULL;\t// FIXME: this might not be very useful!\n\tsubscription->httpError = NULL;\n\tsubscription->httpErrorCode = httpstatus;\n\n\t/* Note: the httpstatus we get here is a libsoup status code\n\t   which is either a HTTP status code or a libsoup status.\n\t   https://developer.gnome.org/libsoup/unstable/libsoup-2.4-soup-status.html\n\n\t   Therefore we know if it is between 200 an 399 all is fine.\n\n\t   Otherwise we build a message according to the libsoup doc\n\t */\n\n\tif (!((httpstatus >= 200) && (httpstatus < 400)))\n\t\tsubscription->httpError = g_strdup (network_strerror (httpstatus));\n}\n\nstatic void\nsubscription_process_update_result (const struct updateResult * const result, gpointer user_data, guint32 flags)\n{\n\tsubscriptionPtr subscription = (subscriptionPtr)user_data;\n\tnodePtr\t\tnode = subscription->node;\n\tgboolean\tprocessing = FALSE;\n\tguint\t\tcount, maxcount;\n\tgchar\t\t*statusbar;\n\n\t/* 1. preprocessing */\n\tstatusbar = g_strdup (\"\");\n\n\tg_assert (subscription->updateJob);\n\t/* update the subscription URL on permanent redirects */\n\tif ((301 == result->httpstatus || 308 == result->httpstatus) && result->source && !g_str_equal (result->source, subscription->updateJob->request->source)) {\n\t\tdebug2 (DEBUG_UPDATE, \"The URL of \\\"%s\\\" has changed permanently and was updated to \\\"%s\\\"\", node_get_title(node), result->source);\n\t\tsubscription_set_source (subscription, result->source);\n    statusbar = g_strdup_printf (_(\"The URL of \\\"%s\\\" has changed permanently and was updated\"), node_get_title(node));\n  }\n\n\t/* consider everything that prevents processing the data we got */\n\tif (result->httpstatus >= 400 || !result->data) {\n\t\t/* Default */\n\t\tsubscription->error = FETCH_ERROR_NET;\n\t\tnode->available = FALSE;\n\n\t\t/* Special handling */\n\t\tif (401 == result->httpstatus) { /* unauthorized */\n\t\t\tsubscription->error = FETCH_ERROR_AUTH;\n\t\t\tauth_dialog_new (subscription, flags);\n\t\t}\n\t\tif (410 == result->httpstatus) { /* gone */\n\t\t\tsubscription_set_discontinued (subscription, TRUE);\n\t\t\tstatusbar = g_strdup_printf (_(\"\\\"%s\\\" is discontinued. Liferea won't updated it anymore!\"), node_get_title (node));\n\t\t}\n\t} else if (304 == result->httpstatus) {\n\t\tnode->available = TRUE;\n\t\tstatusbar = g_strdup_printf (_(\"\\\"%s\\\" has not changed since last update\"), node_get_title(node));\n\t} else if (result->filterErrors) {\n\t\tnode->available = FALSE;\n\t\tsubscription->error = FETCH_ERROR_NET;\n\t} else {\n\t\tprocessing = TRUE;\n\t}\n\n\t/* Clear status bar if we are last update in progress */\n\tupdate_jobs_get_count (&count, &maxcount);\n\tif (1 >= count)\n\t\tliferea_shell_set_status_bar (statusbar);\n\telse\n\t\tliferea_shell_set_status_bar (_(\"Updating (%d / %d) ...\"), maxcount - count, maxcount);\n\tg_free (statusbar);\n\n\tsubscription_update_error_status (subscription, result->httpstatus, result->filterErrors);\n\n\tsubscription->updateJob = NULL;\n\n\t/* 2. call subscription type specific processing */\n\tif (processing)\n\t\tSUBSCRIPTION_TYPE (subscription)->process_update_result (subscription, result, flags);\n\n\t/* 3. call favicon updating only after subscription processing\n\t      to ensure we have valid baseUrl for feed nodes...\n\n\t      check creation date and update favicon if older than one month */\n\tif (g_get_real_time() > (subscription->updateState->lastFaviconPoll + ONE_MONTH_MICROSECONDS))\n\t\tsubscription_icon_update (subscription);\n\n\t/* 4. generic postprocessing */\n\tupdate_state_set_lastmodified (subscription->updateState, update_state_get_lastmodified (result->updateState));\n\tupdate_state_set_cookies (subscription->updateState, update_state_get_cookies (result->updateState));\n\tupdate_state_set_etag (subscription->updateState, update_state_get_etag (result->updateState));\n\tsubscription->updateState->lastPoll = g_get_real_time();\n\n\t// FIXME: use signal here\n\titemview_update_node_info (subscription->node);\n\titemview_update ();\n\n\tdb_subscription_update (subscription);\n\tdb_node_update (subscription->node);\n\n\tfeed_list_view_update_node (node->id);\t// FIXME: This should be dropped once the \"node-updated\" signal is consumed\n\n\tif (processing && subscription->node->newCount > 0) {\n\t\t// FIXME: use new-items signal in itemview class\n\t\tfeedlist_new_items (node->newCount);\n\t\tfeedlist_node_was_updated (node);\n\t}\n}\n\nvoid\nsubscription_update (subscriptionPtr subscription, guint flags)\n{\n\tUpdateRequest\t*request;\n\tguint64\t\tnow;\n\tguint\t\tcount, maxcount;\n\n\tif (!subscription)\n\t\treturn;\n\n\tif (subscription->updateJob)\n\t\treturn;\n\n\tdebug1 (DEBUG_UPDATE, \"Scheduling %s to be updated\", node_get_title (subscription->node));\n\n\tif (subscription_can_be_updated (subscription)) {\n\t\tnow = g_get_real_time();\n\t\tsubscription_reset_update_counter (subscription, &now);\n\n\t\trequest = update_request_new (\n\t\t\tsubscription_get_source (subscription),\n\t\t\tsubscription->updateState,\n\t\t\tsubscription->updateOptions\n\t\t);\n\t\tupdate_request_allow_commands (request, TRUE);\n\n\t\tif (subscription_get_filter (subscription))\n\t\t\trequest->filtercmd = g_strdup (subscription_get_filter (subscription));\n\n\t\tif (SUBSCRIPTION_TYPE (subscription)->prepare_update_request (subscription, request))\n\t\t\tsubscription->updateJob = update_execute_request (subscription, request, subscription_process_update_result, subscription, flags);\n\t\telse\n\t\t\tg_object_unref (request);\n\n\t\tupdate_jobs_get_count (&count, &maxcount);\n\t\tif (count > 1)\n\t\t\tliferea_shell_set_status_bar (_(\"Updating (%d / %d) ...\"), maxcount - count, maxcount);\n\t\telse\n\t\t\tliferea_shell_set_status_bar (_(\"Updating '%s'...\"), node_get_title (subscription->node));\n\t}\n}\n\nvoid\nsubscription_auto_update (subscriptionPtr subscription)\n{\n\tgint\t\tinterval;\n\tguint\t\tflags = 0;\n\tguint64\tnow;\n\n\tif (!subscription)\n\t\treturn;\n\n\tinterval = subscription_get_update_interval (subscription);\n\tif (-1 == interval)\n\t\tconf_get_int_value (DEFAULT_UPDATE_INTERVAL, &interval);\n\n\tif (-2 >= interval || 0 == interval)\n\t\treturn;\t\t/* don't update this subscription */\n\n\tnow = g_get_real_time();\n\n\tif (subscription->updateState->lastPoll + (guint64)interval * (guint64)(60 * G_USEC_PER_SEC) <= now)\n\t\tsubscription_update (subscription, flags);\n}\n\nvoid\nsubscription_cancel_update (subscriptionPtr subscription)\n{\n\tif (!subscription->updateJob)\n\t\treturn;\n\n\tupdate_job_cancel_by_owner (subscription);\n\tsubscription->updateJob = NULL;\n}\n\ngint\nsubscription_get_update_interval (subscriptionPtr subscription)\n{\n\treturn subscription->updateInterval;\n}\n\nvoid\nsubscription_set_update_interval (subscriptionPtr subscription, gint interval)\n{\n\tif (0 == interval) {\n\t\tinterval = -1;\t/* This is evil, I know, but when this method\n\t\t\t\t   is called to set the update interval to 0\n\t\t\t\t   we mean \"never updating\". The updating logic\n\t\t\t\t   expects -1 for \"never updating\" and 0 for\n\t\t\t\t   updating according to the global update\n\t\t\t\t   interval... */\n\t}\n\tsubscription->updateInterval = interval;\n\tfeedlist_schedule_save ();\n}\n\nguint\nsubscription_get_default_update_interval (subscriptionPtr subscription)\n{\n\treturn subscription->defaultInterval;\n}\n\nvoid\nsubscription_set_default_update_interval (subscriptionPtr subscription, guint interval)\n{\n\tsubscription->defaultInterval = interval;\n}\n\nvoid\nsubscription_set_discontinued (subscriptionPtr subscription, gboolean newState)\n{\n\tsubscription->discontinued = newState;\n}\n\nstatic const gchar *\nsubscription_get_orig_source (subscriptionPtr subscription)\n{\n\treturn subscription->origSource;\n}\n\nconst gchar *\nsubscription_get_source (subscriptionPtr subscription)\n{\n\treturn subscription->source;\n}\n\nconst gchar *\nsubscription_get_homepage (subscriptionPtr subscription)\n{\n\treturn metadata_list_get (subscription->metadata, \"homepage\");\n}\n\nconst gchar *\nsubscription_get_filter (subscriptionPtr subscription)\n{\n\treturn subscription->filtercmd;\n}\n\nstatic void\nsubscription_set_orig_source (subscriptionPtr subscription, const gchar *source)\n{\n\tg_free (subscription->origSource);\n\tsubscription->origSource = g_strchomp (g_strdup (source));\n\tfeedlist_schedule_save ();\n}\n\nvoid\nsubscription_set_source (subscriptionPtr subscription, const gchar *source)\n{\n\tg_free (subscription->source);\n\tsubscription->source = g_strchomp (g_strdup (source));\n\tfeedlist_schedule_save ();\n\n\tupdate_state_set_cookies (subscription->updateState, NULL);\n\n\tif (NULL == subscription_get_orig_source (subscription))\n\t\tsubscription_set_orig_source (subscription, source);\n}\n\nvoid\nsubscription_set_homepage (subscriptionPtr subscription, const gchar *newHtmlUrl)\n{\n\tgchar \t*htmlUrl = NULL;\n\n\tif (newHtmlUrl) {\n\t\tif (strstr (newHtmlUrl, \"://\")) {\n\t\t\t/* absolute URI can be used directly */\n\t\t\thtmlUrl = g_strchomp (g_strdup (newHtmlUrl));\n\t\t} else {\n\t\t\t/* relative URI part needs to be expanded */\n\t\t\tgchar *tmp, *source;\n\n\t\t\tsource = g_strdup (subscription_get_source (subscription));\n\t\t\ttmp = strrchr (source, '/');\n\t\t\tif (tmp)\n\t\t\t\t*(tmp+1) = '\\0';\n\n\t\t\thtmlUrl = (gchar *)common_build_url (newHtmlUrl, source);\n\t\t\tg_free (source);\n\t\t}\n\n\t\tmetadata_list_set (&subscription->metadata, \"homepage\", htmlUrl);\n\t\tg_free (htmlUrl);\n\t}\n}\n\nvoid\nsubscription_set_filter (subscriptionPtr subscription, const gchar *filter)\n{\n\tg_free (subscription->filtercmd);\n\tsubscription->filtercmd = g_strdup (filter);\n\tfeedlist_schedule_save ();\n}\n\nvoid\nsubscription_set_auth_info (subscriptionPtr subscription,\n                            const gchar *username,\n                            const gchar *password)\n{\n\tg_assert (NULL != subscription->updateOptions);\n\n\tg_free (subscription->updateOptions->username);\n\tg_free (subscription->updateOptions->password);\n\n\tsubscription->updateOptions->username = g_strdup (username);\n\tsubscription->updateOptions->password = g_strdup (password);\n\n\tliferea_auth_info_store (subscription);\n}\n\nsubscriptionPtr\nsubscription_import (xmlNodePtr xml, gboolean trusted)\n{\n\tsubscriptionPtr\tsubscription;\n\txmlChar\t\t*source, *homepage, *filter, *intervalStr, *tmp;\n\n\tsubscription = subscription_new (NULL, NULL, NULL);\n\n\tsource = xmlGetProp (xml, BAD_CAST \"xmlUrl\");\n\tif (!source)\n\t\tsource = xmlGetProp (xml, BAD_CAST \"xmlurl\");\t/* e.g. for AmphetaDesk */\n\n\tif (source) {\n\t\tif (!trusted && source[0] == '|') {\n\t\t\t/* FIXME: Display warning dialog asking if the command\n\t\t\t   is safe? */\n\t\t\ttmp = (xmlChar *)g_strdup_printf (\"unsafe command: %s\", source);\n\t\t\txmlFree (source);\n\t\t\tsource = tmp;\n\t\t}\n\n\t\tsubscription_set_source (subscription, (gchar *)source);\n\t\txmlFree (source);\n\n\t\thomepage = xmlGetProp (xml, BAD_CAST \"htmlUrl\");\n\t\tif (homepage && xmlStrcmp (homepage, BAD_CAST \"\"))\n\t\t\tsubscription_set_homepage (subscription, (gchar *)homepage);\n\t\txmlFree (homepage);\n\n\t\tif ((filter = xmlGetProp (xml, BAD_CAST \"filtercmd\"))) {\n\t\t\tif (!trusted) {\n\t\t\t\t/* FIXME: Display warning dialog asking if the command\n\t\t\t\t   is safe? */\n\t\t\t\ttmp = (xmlChar *)g_strdup_printf (\"unsafe command: %s\", filter);\n\t\t\t\txmlFree (filter);\n\t\t\t\tfilter = tmp;\n\t\t\t}\n\n\t\t\tsubscription_set_filter (subscription, (gchar *)filter);\n\t\t\txmlFree (filter);\n\t\t}\n\n\t\tintervalStr = xmlGetProp (xml, BAD_CAST \"updateInterval\");\n\t\tsubscription_set_update_interval (subscription, common_parse_long ((gchar *)intervalStr, -1));\n\t\txmlFree (intervalStr);\n\n\t\t/* no proxy flag */\n\t\ttmp = xmlGetProp (xml, BAD_CAST \"dontUseProxy\");\n\t\tif (tmp && !xmlStrcmp (tmp, BAD_CAST \"true\"))\n\t\t\tsubscription->updateOptions->dontUseProxy = TRUE;\n\t\txmlFree (tmp);\n\n\t\t/* authentication options */\n\t\tsubscription->updateOptions->username = (gchar *)xmlGetProp (xml, BAD_CAST \"username\");\n\t\tsubscription->updateOptions->password = (gchar *)xmlGetProp (xml, BAD_CAST \"password\");\n\t}\n\n\treturn subscription;\n}\n\nvoid\nsubscription_export (subscriptionPtr subscription, xmlNodePtr xml, gboolean trusted)\n{\n\tgchar *interval = g_strdup_printf (\"%d\", subscription_get_update_interval (subscription));\n\n\txmlNewProp (xml, BAD_CAST \"xmlUrl\", BAD_CAST subscription_get_source (subscription));\n\n\tif (subscription_get_homepage (subscription))\n\t\txmlNewProp (xml, BAD_CAST\"htmlUrl\", BAD_CAST subscription_get_homepage (subscription));\n\telse\n\t\txmlNewProp (xml, BAD_CAST\"htmlUrl\", BAD_CAST \"\");\n\n\tif (subscription_get_filter (subscription))\n\t\txmlNewProp (xml, BAD_CAST\"filtercmd\", BAD_CAST subscription_get_filter (subscription));\n\n\tif(trusted) {\n\t\txmlNewProp (xml, BAD_CAST\"updateInterval\", BAD_CAST interval);\n\n\t\tif (subscription->updateOptions->dontUseProxy)\n\t\t\txmlNewProp (xml, BAD_CAST\"dontUseProxy\", BAD_CAST\"true\");\n\n\t\tif (!liferea_auth_has_active_store ()) {\n\t\t\tif (subscription->updateOptions->username)\n\t\t\t\txmlNewProp (xml, BAD_CAST\"username\", (xmlChar *)subscription->updateOptions->username);\n\t\t\tif (subscription->updateOptions->password)\n\t\t\t\txmlNewProp (xml, BAD_CAST\"password\", (xmlChar *)subscription->updateOptions->password);\n\t\t}\n\t}\n\n\tg_free (interval);\n}\n\nvoid\nsubscription_to_xml (subscriptionPtr subscription, xmlNodePtr xml)\n{\n\tgchar\t*tmp;\n\n\txmlNewTextChild (xml, NULL, BAD_CAST \"feedSource\", (xmlChar *)subscription_get_source (subscription));\n\txmlNewTextChild (xml, NULL, BAD_CAST \"feedOrigSource\", (xmlChar *)subscription_get_orig_source (subscription));\n\n\ttmp = g_strdup_printf (\"%d\", subscription_get_default_update_interval (subscription));\n\txmlNewTextChild (xml, NULL, BAD_CAST \"feedUpdateInterval\", (xmlChar *)tmp);\n\tg_free (tmp);\n\n\tif (subscription->updateError)\n\t\txmlNewTextChild (xml, NULL, BAD_CAST \"updateError\", (xmlChar *)subscription->updateError);\n\tif (subscription->httpError) {\n\t\txmlNewTextChild (xml, NULL, BAD_CAST \"httpError\", (xmlChar *)subscription->httpError);\n\n\t\ttmp = g_strdup_printf (\"%d\", subscription->httpErrorCode);\n\t\txmlNewTextChild (xml, NULL, BAD_CAST \"httpErrorCode\", (xmlChar *)tmp);\n\t\tg_free (tmp);\n\t}\n\tif (subscription->filterError)\n\t\txmlNewTextChild (xml, NULL, BAD_CAST \"filterError\", (xmlChar *)subscription->filterError);\n\n\tmetadata_add_xml_nodes (subscription->metadata, xml);\n}\n\nvoid\nsubscription_free (subscriptionPtr subscription)\n{\n\tif (!subscription)\n\t\treturn;\n\n\tg_free (subscription->updateError);\n\tg_free (subscription->filterError);\n\tg_free (subscription->httpError);\n\tg_free (subscription->source);\n\tg_free (subscription->origSource);\n\tg_free (subscription->filtercmd);\n\n\tupdate_job_cancel_by_owner (subscription);\n\tupdate_options_free (subscription->updateOptions);\n\tupdate_state_free (subscription->updateState);\n\tmetadata_list_free (subscription->metadata);\n\n\tg_free (subscription);\n}\n", "/**\n * @file update.c  generic update request and state processing\n *\n * Copyright (C) 2003-2021 Lars Windolf <lars.windolf@gmx.de>\n * Copyright (C) 2004-2006 Nathan J. Conrad <t98502@users.sourceforge.net>\n * Copyright (C) 2009 Adrian Bunk <bunk@users.sourceforge.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"update.h\"\n\n#include <libxml/parser.h>\n#include <libxslt/xslt.h>\n#include <libxslt/xsltInternals.h>\n#include <libxslt/transform.h>\n#include <libxslt/xsltutils.h>\n\n#include <unistd.h>\n#include <stdio.h>\n#if !defined (G_OS_WIN32) || defined (HAVE_SYS_WAIT_H)\n#include <sys/wait.h>\n#endif\n#include <string.h>\n\n#include \"auth_activatable.h\"\n#include \"common.h\"\n#include \"debug.h\"\n#include \"net.h\"\n#include \"plugins_engine.h\"\n#include \"xml.h\"\n#include \"ui/liferea_shell.h\"\n\n#if defined (G_OS_WIN32) && !defined (WIFEXITED) && !defined (WEXITSTATUS)\n#define WIFEXITED(x) (x != 0)\n#define WEXITSTATUS(x) (x)\n#endif\n\n/** global update job list, used for lookups when cancelling */\nstatic GSList\t*jobs = NULL;\n\nstatic GAsyncQueue *pendingHighPrioJobs = NULL;\nstatic GAsyncQueue *pendingJobs = NULL;\nstatic guint numberOfActiveJobs = 0;\n#define MAX_ACTIVE_JOBS\t5\n\n/* update state interface */\n\nupdateStatePtr\nupdate_state_new (void)\n{\n\treturn g_new0 (struct updateState, 1);\n}\n\nglong\nupdate_state_get_lastmodified (updateStatePtr state)\n{\n\treturn state->lastModified;\n}\n\nvoid\nupdate_state_set_lastmodified (updateStatePtr state, glong lastModified)\n{\n\tstate->lastModified = lastModified;\n}\n\nconst gchar *\nupdate_state_get_etag (updateStatePtr state)\n{\n\treturn state->etag;\n}\n\nvoid\nupdate_state_set_etag (updateStatePtr state, const gchar *etag)\n{\n\tg_free (state->etag);\n\tstate->etag = NULL;\n\tif (etag)\n\t\tstate->etag = g_strdup(etag);\n}\n\nvoid\nupdate_state_set_cache_maxage (updateStatePtr state, const gint maxage)\n{\n\tif (0 < maxage)\n\t\tstate->maxAgeMinutes = maxage;\n\telse\n\t\tstate->maxAgeMinutes = -1;\n}\n\ngint\nupdate_state_get_cache_maxage (updateStatePtr state)\n{\n\treturn state->maxAgeMinutes;\n}\n\nconst gchar *\nupdate_state_get_cookies (updateStatePtr state)\n{\n\treturn state->cookies;\n}\n\nvoid\nupdate_state_set_cookies (updateStatePtr state, const gchar *cookies)\n{\n\tg_free (state->cookies);\n\tstate->cookies = NULL;\n\tif (cookies)\n\t\tstate->cookies = g_strdup (cookies);\n}\n\nupdateStatePtr\nupdate_state_copy (updateStatePtr state)\n{\n\tupdateStatePtr newState;\n\n\tnewState = update_state_new ();\n\tupdate_state_set_lastmodified (newState, update_state_get_lastmodified (state));\n\tupdate_state_set_cookies (newState, update_state_get_cookies (state));\n\tupdate_state_set_etag (newState, update_state_get_etag (state));\n\n\treturn newState;\n}\n\nvoid\nupdate_state_free (updateStatePtr updateState)\n{\n\tif (!updateState)\n\t\treturn;\n\n\tg_free (updateState->cookies);\n\tg_free (updateState->etag);\n\tg_free (updateState);\n}\n\n/* update options */\n\nupdateOptionsPtr\nupdate_options_copy (updateOptionsPtr options)\n{\n\tupdateOptionsPtr newOptions;\n\tnewOptions = g_new0 (struct updateOptions, 1);\n\tnewOptions->username = g_strdup (options->username);\n\tnewOptions->password = g_strdup (options->password);\n\tnewOptions->dontUseProxy = options->dontUseProxy;\n\treturn newOptions;\n}\nvoid\nupdate_options_free (updateOptionsPtr options)\n{\n\tif (!options)\n\t\treturn;\n\n\tg_free (options->username);\n\tg_free (options->password);\n\tg_free (options);\n}\n\n/* update request object */\n\nG_DEFINE_TYPE (UpdateRequest, update_request, G_TYPE_OBJECT);\n\nstatic void\nupdate_request_finalize (GObject *obj)\n{\n\tUpdateRequest *request = UPDATE_REQUEST (obj);\n\n\tupdate_state_free (request->updateState);\n\tupdate_options_free (request->options);\n\n\tg_free (request->postdata);\n\tg_free (request->source);\n\tg_free (request->filtercmd);\n\n\tG_OBJECT_CLASS (update_request_parent_class)->finalize (obj);\n}\n\nstatic void\nupdate_request_class_init (UpdateRequestClass *klass)\n{\n\tGObjectClass *object_class = G_OBJECT_CLASS (klass);\n\tobject_class->finalize = update_request_finalize;\n}\n\nstatic void\nupdate_request_init (UpdateRequest *request)\n{\n}\n\nUpdateRequest *\nupdate_request_new (const gchar *source, updateStatePtr state, updateOptionsPtr options)\n{\n\tUpdateRequest *request = UPDATE_REQUEST (g_object_new (UPDATE_REQUEST_TYPE, NULL));\n\n\trequest->source = g_strdup (source);\n\n\tif (state)\n\t\trequest->updateState = update_state_copy (state);\n\telse\n\t\trequest->updateState = update_state_new ();\n\n\n\tif (options)\n\t\trequest->options = update_options_copy (options);\n\telse\n\t\trequest->options = g_new0 (struct updateOptions, 1);\n\n\treturn request;\n}\n\nvoid\nupdate_request_set_source(UpdateRequest *request, const gchar* source)\n{\n\tg_free (request->source);\n\trequest->source = g_strdup (source);\n}\n\nvoid\nupdate_request_set_auth_value (UpdateRequest *request, const gchar* authValue)\n{\n\tg_free (request->authValue);\n\trequest->authValue = g_strdup (authValue);\n}\n\nvoid\nupdate_request_allow_commands (UpdateRequest *request, gboolean allowCommands)\n{\n\trequest->allowCommands = allowCommands;\n}\n\n\n/* update result object */\n\nupdateResultPtr\nupdate_result_new (void)\n{\n\tupdateResultPtr\tresult;\n\n\tresult = g_new0 (struct updateResult, 1);\n\tresult->updateState = update_state_new ();\n\n\treturn result;\n}\n\nvoid\nupdate_result_free (updateResultPtr result)\n{\n\tif (!result)\n\t\treturn;\n\n\tupdate_state_free (result->updateState);\n\n\tg_free (result->data);\n\tg_free (result->source);\n\tg_free (result->contentType);\n\tg_free (result->filterErrors);\n\tg_free (result);\n}\n\n/* update job handling */\n\nstatic updateJobPtr\nupdate_job_new (gpointer owner,\n                UpdateRequest *request,\n\t\tupdate_result_cb callback,\n\t\tgpointer user_data,\n\t\tupdateFlags flags)\n{\n\tupdateJobPtr\tjob;\n\n\tjob = g_new0 (struct updateJob, 1);\n\tjob->owner = owner;\n\tjob->request = UPDATE_REQUEST (request);\n\tjob->result = update_result_new ();\n\tjob->callback = callback;\n\tjob->user_data = user_data;\n\tjob->flags = flags;\n\tjob->state = REQUEST_STATE_INITIALIZED;\n\n\tjob->cmd.fd = -1;\n\tjob->cmd.pid = 0;\n\n\treturn job;\n}\n\ngint\nupdate_job_get_state (updateJobPtr job)\n{\n\treturn job->state;\n}\n\nstatic void\nupdate_job_show_count_foreach_func (gpointer data, gpointer user_data)\n{\n\tupdateJobPtr\tjob = (updateJobPtr)data;\n\tguint\t\t*count = (guint *)user_data;\n\n\t// Count all subscription jobs (ignore HTML5 and favicon requests)\n\tif (!(job->flags & FEED_REQ_NO_FEED))\n\t\t(*count)++;\n}\n\nstatic guint maxcount = 0;\n\nvoid\nupdate_jobs_get_count (guint *count, guint *max)\n{\n\t*count = 0;\n\tg_slist_foreach (jobs, update_job_show_count_foreach_func, count);\n\n\tif (*count > maxcount)\n\t\tmaxcount = *count;\n\n\t*max = maxcount;\n}\n\nstatic void\nupdate_job_free (updateJobPtr job)\n{\n\tif (!job)\n\t\treturn;\n\n\tjobs = g_slist_remove (jobs, job);\n\n\tg_object_unref (job->request);\n\tupdate_result_free (job->result);\n\n\tif (job->cmd.fd >= 0) {\n\t\tdebug1 (DEBUG_UPDATE, \"Found an open cmd.fd %d when freeing!\", job->cmd.fd);\n\t\tclose (job->cmd.fd);\n\t}\n\tif (job->cmd.timeout_id > 0) {\n\t\tg_source_remove (job->cmd.timeout_id);\n\t}\n\tif (job->cmd.io_watch_id > 0) {\n\t\tg_source_remove (job->cmd.io_watch_id);\n\t}\n\tif (job->cmd.child_watch_id > 0) {\n\t\tg_source_remove (job->cmd.child_watch_id);\n\t}\n\tif (job->cmd.stdout_ch) {\n\t\tg_io_channel_unref (job->cmd.stdout_ch);\n\t}\n\tg_free (job);\n}\n\n/* filter idea (and some of the code) was taken from Snownews */\nstatic gchar *\nupdate_exec_filter_cmd (updateJobPtr job)\n{\n\tint\t\tfd, status;\n\tgchar\t\t*command;\n\tconst gchar\t*tmpdir = g_get_tmp_dir();\n\tchar\t\t*tmpfilename;\n\tchar\t\t*out = NULL;\n\tFILE\t\t*file, *p;\n\tsize_t\t\tsize = 0;\n\n\ttmpfilename = g_build_filename (tmpdir, \"liferea-XXXXXX\", NULL);\n\n\tfd = g_mkstemp (tmpfilename);\n\n\tif (fd == -1) {\n\t\tdebug1 (DEBUG_UPDATE, \"Error opening temp file %s to use for filtering!\", tmpfilename);\n\t\tjob->result->filterErrors = g_strdup_printf (_(\"Error opening temp file %s to use for filtering!\"), tmpfilename);\n\t\tg_free (tmpfilename);\n\t\treturn NULL;\n\t}\n\n\tfile = fdopen (fd, \"w\");\n\tfwrite (job->result->data, strlen (job->result->data), 1, file);\n\tfclose (file);\n\n\tcommand = g_strdup_printf(\"%s < %s\", job->request->filtercmd, tmpfilename);\n\tp = popen (command, \"r\");\n\tif (NULL != p) {\n\t\twhile (!feof (p) && !ferror (p)) {\n\t\t\tsize_t len;\n\t\t\tout = g_realloc (out, size + 1025);\n\t\t\tlen = fread (&out[size], 1, 1024, p);\n\t\t\tif (len > 0)\n\t\t\t\tsize += len;\n\t\t}\n\t\tstatus = pclose (p);\n\t\tif (!(WIFEXITED (status) && WEXITSTATUS (status) == 0)) {\n\t\t\tdebug2 (DEBUG_UPDATE, \"%s exited with status %d!\", command, WEXITSTATUS(status));\n\t\t\tjob->result->filterErrors = g_strdup_printf (_(\"%s exited with status %d\"), command, WEXITSTATUS(status));\n\t\t\tsize = 0;\n\t\t}\n\t\tif (out)\n\t\t\tout[size] = '\\0';\n\t} else {\n\t\tg_warning (_(\"Error: Could not open pipe \\\"%s\\\"\"), command);\n\t\tjob->result->filterErrors = g_strdup_printf (_(\"Error: Could not open pipe \\\"%s\\\"\"), command);\n\t}\n\n\t/* Clean up. */\n\tg_free (command);\n\tunlink (tmpfilename);\n\tg_free (tmpfilename);\n\treturn out;\n}\n\nstatic gchar *\nupdate_apply_xslt (updateJobPtr job)\n{\n\txsltStylesheetPtr\txslt = NULL;\n\txmlOutputBufferPtr\tbuf;\n\txmlDocPtr\t\tsrcDoc = NULL, resDoc = NULL;\n\tgchar\t\t\t*output = NULL;\n\n\tg_assert (NULL != job->result);\n\n\tdo {\n\t\tsrcDoc = xml_parse (job->result->data, job->result->size, NULL);\n\t\tif (!srcDoc) {\n\t\t\tg_warning(\"fatal: parsing request result XML source failed (%s)!\", job->request->filtercmd);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* load localization stylesheet */\n\t\txslt = xsltParseStylesheetFile ((xmlChar *)job->request->filtercmd);\n\t\tif (!xslt) {\n\t\t\tg_warning (\"fatal: could not load filter stylesheet \\\"%s\\\"!\", job->request->filtercmd);\n\t\t\tbreak;\n\t\t}\n\n\t\tresDoc = xsltApplyStylesheet (xslt, srcDoc, NULL);\n\t\tif (!resDoc) {\n\t\t\tg_warning (\"fatal: applying stylesheet \\\"%s\\\" failed!\", job->request->filtercmd);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = xmlAllocOutputBuffer (NULL);\n\t\tif (-1 == xsltSaveResultTo (buf, resDoc, xslt)) {\n\t\t\tg_warning (\"fatal: retrieving result of filter stylesheet failed (%s)!\", job->request->filtercmd);\n\t\t\tbreak;\n\t\t}\n\n#ifdef LIBXML2_NEW_BUFFER\n\t\tif (xmlOutputBufferGetSize (buf) > 0)\n\t\t\toutput = (gchar *)xmlCharStrdup ((char *)xmlOutputBufferGetContent (buf));\n#else\n\t\tif (xmlBufferLength (buf->buffer) > 0)\n\t\t\toutput = (gchar *)xmlCharStrdup ((char *)xmlBufferContent (buf->buffer));\n#endif\n\n\t\txmlOutputBufferClose (buf);\n\t} while (FALSE);\n\n\tif (srcDoc)\n\t\txmlFreeDoc (srcDoc);\n\tif (resDoc)\n\t\txmlFreeDoc (resDoc);\n\tif (xslt)\n\t\txsltFreeStylesheet (xslt);\n\n\treturn output;\n}\n\nstatic void\nupdate_apply_filter (updateJobPtr job)\n{\n\tgchar\t*filterResult;\n\n\tg_assert (NULL == job->result->filterErrors);\n\n\t/* we allow two types of filters: XSLT stylesheets and arbitrary commands */\n\tif ((strlen (job->request->filtercmd) > 4) &&\n\t    (0 == strcmp (\".xsl\", job->request->filtercmd + strlen (job->request->filtercmd) - 4)))\n\t\tfilterResult = update_apply_xslt (job);\n\telse\n\t\tfilterResult = update_exec_filter_cmd (job);\n\n\tif (filterResult) {\n\t\tg_free (job->result->data);\n\t\tjob->result->data = filterResult;\n\t\tjob->result->size = strlen(filterResult);\n\t}\n}\n\nstatic void\nupdate_exec_cmd_cb_child_watch (GPid pid, gint status, gpointer user_data)\n{\n\tupdateJobPtr\tjob = (updateJobPtr) user_data;\n\tdebug1 (DEBUG_UPDATE, \"Child process %d terminated\", job->cmd.pid);\n\n\tjob->cmd.pid = 0;\n\tif (WIFEXITED (status) && WEXITSTATUS (status) == 0) {\n\t\tjob->result->httpstatus = 200;\n\t} else if (job->result->httpstatus == 0) {\n\t\t/* If there is no more specific error code. */\n\t\tjob->result->httpstatus = 500;  /* Internal server error. */\n\t}\n\n\tjob->cmd.child_watch_id = 0;\t/* Caller will remove source. */\n\tif (job->cmd.timeout_id > 0) {\n\t\tg_source_remove (job->cmd.timeout_id);\n\t\tjob->cmd.timeout_id = 0;\n\t}\n\tif (job->cmd.io_watch_id > 0) {\n\t\tg_source_remove (job->cmd.io_watch_id);\n\t\tjob->cmd.io_watch_id = 0;\n\t}\n\tupdate_process_finished_job (job);\n}\n\n\nstatic gboolean\nupdate_exec_cmd_cb_out_watch (GIOChannel *source, GIOCondition condition, gpointer user_data)\n{\n\tupdateJobPtr\tjob = (updateJobPtr) user_data;\n\tGError\t\t*err = NULL;\n\tgboolean\tret = TRUE;\t/* Do not remove event source yet. */\n\tGIOStatus\tst;\n\tgsize\t\tnread;\n\n\tif (condition == G_IO_HUP) {\n\t\tdebug1 (DEBUG_UPDATE, \"Pipe closed, child process %d is terminating\", job->cmd.pid);\n\t\tret = FALSE;\n\n\t} else if (condition == G_IO_IN) {\n\t\twhile (TRUE) {\n\t\t\tjob->result->data = g_realloc (job->result->data, job->result->size + 1025);\n\n\t\t\tnread = 0;\n\t\t\tst = g_io_channel_read_chars (source,\n\t\t\t\tjob->result->data + job->result->size,\n\t\t\t\t1024, &nread, &err);\n\t\t\tjob->result->size += nread;\n\t\t\tjob->result->data[job->result->size] = 0;\n\n\t\t\tif (err) {\n\t\t\t\tdebug2 (DEBUG_UPDATE, \"Error %d when reading from child %d\", err->code, job->cmd.pid);\n\t\t\t\tg_error_free (err);\n\t\t\t\terr = NULL;\n\t\t\t\tret = FALSE;\t/* remove event */\n\t\t\t}\n\n\t\t\tif (nread == 0) {\n\t\t\t\t/* Finished reading */\n\t\t\t\tbreak;\n\t\t\t} else if (st == G_IO_STATUS_AGAIN) {\n\t\t\t\t/* just try again */\n\t\t\t} else if (st == G_IO_STATUS_EOF) {\n\t\t\t\t/* Pipe closed */\n\t\t\t\tret = FALSE;\n\t\t\t\tbreak;\n\t\t\t} else if (st == G_IO_STATUS_ERROR) {\n\t\t\t\tdebug1 (DEBUG_UPDATE, \"Got a G_IO_STATUS_ERROR from child %d\", job->cmd.pid);\n\t\t\t\tret = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tdebug2 (DEBUG_UPDATE, \"Unexpected condition %d for child process %d\", condition, job->cmd.pid);\n\t\tret = FALSE;\n\t}\n\n\tif (ret == FALSE) {\n\t\tclose (job->cmd.fd);\n\t\tjob->cmd.fd = -1;\n\t\tjob->cmd.io_watch_id = 0;\t/* Caller will remove source. */\n\t}\n\n\treturn ret;\n}\n\n\nstatic gboolean\nupdate_exec_cmd_cb_timeout (gpointer user_data)\n{\n\tupdateJobPtr\tjob = (updateJobPtr) user_data;\n\tdebug1 (DEBUG_UPDATE, \"Child process %d timed out, killing.\", job->cmd.pid);\n\n\t/* Kill child. Result will still be processed by update_exec_cmd_cb_child_watch */\n\tkill((pid_t) job->cmd.pid, SIGKILL);\n\tjob->cmd.timeout_id = 0;\n\tjob->result->httpstatus = 504;\t/* Gateway timeout */\n\treturn FALSE;\t/* Remove timeout source */\n}\n\nstatic int\nget_exec_timeout_ms(void)\n{\n\tconst gchar\t*val;\n\tint\ti;\n\tif ((val = g_getenv(\"LIFEREA_FEED_CMD_TIMEOUT\")) != NULL) {\n\t\tif ((i = atoi(val)) > 0) {\n\t\t\treturn 1000*i;\n\t\t}\n\t}\n\treturn 60000; /* Default timeout */\n}\n\nstatic void\nupdate_exec_cmd (updateJobPtr job)\n{\n\tgboolean\tret;\n\tgchar\t\t*cmd = (job->request->source) + 1;\n\n\t/* Previous versions ran through popen() and a lot of users may be depending\n\t * on this behavior, so we run through a shell and keep compatibility. */\n\tgchar\t\t*cmd_args[] = { \"/bin/sh\", \"-c\", cmd, NULL };\n\n\tjob->result->httpstatus = 0;\n\tdebug1 (DEBUG_UPDATE, \"executing command \\\"%s\\\"...\", cmd);\n\tret = g_spawn_async_with_pipes (NULL, cmd_args, NULL,\n\t\tG_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_STDERR_TO_DEV_NULL,\n\t\tNULL, NULL, &job->cmd.pid, NULL,\n\t\t&job->cmd.fd, NULL, NULL);\n\n\tif (!ret) {\n\t\tdebug0 (DEBUG_UPDATE, \"g_spawn_async_with_pipes failed\");\n\t\tliferea_shell_set_status_bar (_(\"Error: Could not open pipe \\\"%s\\\"\"), cmd);\n\t\tjob->result->httpstatus = 404; /* Not found */\n\t\treturn;\n\t}\n\n\tdebug1 (DEBUG_UPDATE, \"New child process launched with pid %d\", job->cmd.pid);\n\n\tjob->cmd.child_watch_id = g_child_watch_add (job->cmd.pid, (GChildWatchFunc) update_exec_cmd_cb_child_watch, job);\n\tjob->cmd.stdout_ch = g_io_channel_unix_new (job->cmd.fd);\n\tjob->cmd.io_watch_id = g_io_add_watch (job->cmd.stdout_ch, G_IO_IN | G_IO_HUP, (GIOFunc) update_exec_cmd_cb_out_watch, job);\n\n\tjob->cmd.timeout_id = g_timeout_add (get_exec_timeout_ms(), (GSourceFunc) update_exec_cmd_cb_timeout, job);\n}\n\nstatic void\nupdate_load_file (updateJobPtr job)\n{\n\tgchar *filename = job->request->source;\n\tgchar *anchor;\n\n\tif (!strncmp (filename, \"file://\",7))\n\t\tfilename += 7;\n\n\tanchor = strchr (filename, '#');\n\tif (anchor)\n\t\t*anchor = 0;\t /* strip anchors from filenames */\n\n\tif (g_file_test (filename, G_FILE_TEST_EXISTS)) {\n\t\t/* we have a file... */\n\t\tif ((!g_file_get_contents (filename, &(job->result->data), &(job->result->size), NULL)) || (job->result->data[0] == '\\0')) {\n\t\t\tjob->result->httpstatus = 403;\t/* FIXME: maybe setting request->returncode would be better */\n\t\t\tliferea_shell_set_status_bar (_(\"Error: Could not open file \\\"%s\\\"\"), filename);\n\t\t} else {\n\t\t\tjob->result->httpstatus = 200;\n\t\t\tdebug2 (DEBUG_UPDATE, \"Successfully read %d bytes from file %s.\", job->result->size, filename);\n\t\t}\n\t} else {\n\t\tliferea_shell_set_status_bar (_(\"Error: There is no file \\\"%s\\\"\"), filename);\n\t\tjob->result->httpstatus = 404;\t/* FIXME: maybe setting request->returncode would be better */\n\t}\n\n\tupdate_process_finished_job (job);\n}\n\nstatic void\nupdate_job_run (updateJobPtr job)\n{\n\t/* Here we decide on the source type and the proper execution\n\t   methods which then do anything they want with the job and\n\t   pass the processed job to update_process_finished_job()\n\t   for result dequeuing */\n\n\t/* everything starting with '|' is a local command */\n\tif (*(job->request->source) == '|') {\n\t\tif (job->request->allowCommands) {\n\t\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n\t\t\tupdate_exec_cmd (job);\n\t\t} else {\n\t\t\tdebug1 (DEBUG_UPDATE, \"Refusing to run local command from unexpected source: %s\", job->request->source);\n\t\t\tjob->result->httpstatus = 403;  /* Forbidden. */\n\t\t\tupdate_process_finished_job (job);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* if it has a protocol \"://\" prefix, but not \"file://\" it is an URI */\n\tif (strstr (job->request->source, \"://\") && strncmp (job->request->source, \"file://\", 7)) {\n\t\tnetwork_process_request (job);\n\t\treturn;\n\t}\n\n\t/* otherwise it must be a local file... */\n\t{\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized file URI: %s\", job->request->source);\n\t\tupdate_load_file (job);\n\t\treturn;\n\t}\n}\n\nstatic gboolean\nupdate_dequeue_job (gpointer user_data)\n{\n\tupdateJobPtr job;\n\n\tif (!pendingJobs)\n\t\treturn FALSE;\t/* we must be in shutdown */\n\n\tif (numberOfActiveJobs >= MAX_ACTIVE_JOBS)\n\t\treturn FALSE;\t/* we'll be called again when a job finishes */\n\n\n\tjob = (updateJobPtr)g_async_queue_try_pop(pendingHighPrioJobs);\n\n\tif (!job)\n\t\tjob = (updateJobPtr)g_async_queue_try_pop(pendingJobs);\n\n\tif(!job)\n\t\treturn FALSE;\t/* no request at the moment */\n\n\tnumberOfActiveJobs++;\n\n\tjob->state = REQUEST_STATE_PROCESSING;\n\n\tdebug1 (DEBUG_UPDATE, \"processing request (%s)\", job->request->source);\n\tif (job->callback == NULL) {\n\t\tupdate_process_finished_job (job);\n\t} else {\n\t\tupdate_job_run (job);\n\t}\n\n\treturn FALSE;\n}\n\nupdateJobPtr\nupdate_execute_request (gpointer owner,\n                        UpdateRequest *request,\n\t\t\tupdate_result_cb callback,\n\t\t\tgpointer user_data,\n\t\t\tupdateFlags flags)\n{\n\tupdateJobPtr job;\n\n\tg_assert (request->options != NULL);\n\tg_assert (request->source != NULL);\n\n\tjob = update_job_new (owner, request, callback, user_data, flags);\n\tjob->state = REQUEST_STATE_PENDING;\n\tjobs = g_slist_append (jobs, job);\n\n\tif (flags & FEED_REQ_PRIORITY_HIGH) {\n\t\tg_async_queue_push (pendingHighPrioJobs, (gpointer)job);\n\t} else {\n\t\tg_async_queue_push (pendingJobs, (gpointer)job);\n\t}\n\n\tg_idle_add (update_dequeue_job, NULL);\n\treturn job;\n}\n\nvoid\nupdate_job_cancel_by_owner (gpointer owner)\n{\n\tGSList\t*iter = jobs;\n\n\twhile (iter) {\n\t\tupdateJobPtr job = (updateJobPtr)iter->data;\n\t\tif (job->owner == owner)\n\t\t\tjob->callback = NULL;\n\t\titer = g_slist_next (iter);\n\t}\n}\n\nstatic gboolean\nupdate_process_result_idle_cb (gpointer user_data)\n{\n\tupdateJobPtr job = (updateJobPtr)user_data;\n\n\tif (job->callback)\n\t\t(job->callback) (job->result, job->user_data, job->flags);\n\n\tupdate_job_free (job);\n\n\treturn FALSE;\n}\n\nstatic void\nupdate_apply_filter_async(GTask *task, gpointer src, gpointer tdata, GCancellable *ccan)\n{\n    updateJobPtr job = tdata;\n    update_apply_filter(job);\n    g_task_return_int(task, 0);\n}\n\nstatic void\nupdate_apply_filter_finish(GObject *src, GAsyncResult *result, gpointer user_data)\n{\n    updateJobPtr job = user_data;\n    g_idle_add(update_process_result_idle_cb, job);\n}\n\nvoid\nupdate_process_finished_job (updateJobPtr job)\n{\n\tjob->state = REQUEST_STATE_DEQUEUE;\n\n\tg_assert(numberOfActiveJobs > 0);\n\tnumberOfActiveJobs--;\n\tg_idle_add (update_dequeue_job, NULL);\n\n\t/* Handling abandoned requests (e.g. after feed deletion) */\n\tif (job->callback == NULL) {\n\t\tdebug1 (DEBUG_UPDATE, \"freeing cancelled request (%s)\", job->request->source);\n\t\tupdate_job_free (job);\n\t\treturn;\n\t}\n\n\t/* Finally execute the postfilter */\n\tif (job->result->data && job->request->filtercmd) {\n                GTask *task = g_task_new(NULL, NULL, update_apply_filter_finish, job);\n                g_task_set_task_data(task, job, NULL);\n                g_task_run_in_thread(task, update_apply_filter_async);\n                g_object_unref(task);\n                return;\n        }\n\n\tg_idle_add (update_process_result_idle_cb, job);\n}\n\n\nvoid\nupdate_init (void)\n{\n\tpendingJobs = g_async_queue_new ();\n\tpendingHighPrioJobs = g_async_queue_new ();\n}\n\nvoid\nupdate_deinit (void)\n{\n\tGSList\t*iter = jobs;\n\n\t/* Cancel all jobs, to avoid async callbacks accessing the GUI */\n\twhile (iter) {\n\t\tupdateJobPtr job = (updateJobPtr)iter->data;\n\t\tjob->callback = NULL;\n\t\titer = g_slist_next (iter);\n\t}\n\n\tg_async_queue_unref (pendingJobs);\n\tg_async_queue_unref (pendingHighPrioJobs);\n\n\tg_slist_free (jobs);\n\tjobs = NULL;\n}\n", "/**\n * @file update.h  generic update request and state processing\n *\n * Copyright (C) 2003-2020 Lars Windolf <lars.windolf@gmx.de>\n * Copyright (C) 2004-2006 Nathan J. Conrad <t98502@users.sourceforge.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef _UPDATE_H\n#define _UPDATE_H\n\n#include <time.h>\n#include <glib.h>\n#include <glib-object.h>\n\n/* Update requests do represent feed updates, favicon and enclosure\n   downloads. A request can be started synchronously or asynchronously.\n   In the latter case it can be cancelled at any time. If the processing\n   of a update request is done the request callback will be triggered.\n\n   A request can have an update state assigned. This is to support\n   the different bandwidth saving methods. For caching along feeds\n   there are XML (de)serialization functions for the update state.\n\n   For proxy support and authentication an update request can have\n   update options assigned.\n\n   Finally the request system has an on/offline state. When offline\n   no new network requests are accepted. Filesystem and internal\n   requests are still processed. Currently running downloads are\n   not terminated. */\n\ntypedef enum {\n\tREQUEST_STATE_INITIALIZED = 0,\t/**< request struct newly created */\n\tREQUEST_STATE_PENDING,\t\t/**< request added to download queue */\n\tREQUEST_STATE_PROCESSING,\t/**< request currently in download */\n\tREQUEST_STATE_DEQUEUE,\t\t/**< download finished, callback processing */\n\tREQUEST_STATE_FINISHED\t\t/**< request processing finished */\n} request_state;\n\nstruct updateJob;\nstruct updateResult;\n\ntypedef guint32 updateFlags;\n\n/**\n * Generic update result processing callback type.\n * This callback must not free the result structure. It will be\n * free'd by the download system after the callback returns.\n *\n * @param result\tthe update result\n * @param user_data\tupdate processing callback data\n * @param flags\t\tupdate processing flags\n */\ntypedef void (*update_result_cb) (const struct updateResult * const result, gpointer user_data, updateFlags flags);\n\n/** defines update options to be passed to an update request */\ntypedef struct updateOptions {\n\tgchar\t\t*username;\t/**< username for HTTP auth */\n\tgchar\t\t*password;\t/**< password for HTTP auth */\n\tgboolean\tdontUseProxy;\t/**< no proxy flag */\n} *updateOptionsPtr;\n\n/** defines all state data an updatable object (e.g. a feed) needs */\ntypedef struct updateState {\n\tglong\t\tlastModified;\t\t/**< Last modified string as sent by the server */\n\tguint64  \tlastPoll;\t\t/**< time at which the feed was last updated */\n\tguint64 \tlastFaviconPoll;\t/**< time at which the feeds favicon was last updated */\n\tgchar\t\t*cookies;\t\t/**< cookies to be used */\n\tgchar\t\t*etag;\t\t\t/**< ETag sent by the server */\n\tgint\t\tmaxAgeMinutes;\t\t/**< default update interval, greatest value sourced from HTTP and XML */\n\tgint\t\tsynFrequency;\t\t/**< syn:updateFrequency */\n\tgint\t\tsynPeriod;\t\t/**< syn:updatePeriod */\n\tgint\t\ttimeToLive;\t\t/**< ttl */\n} *updateStatePtr;\n\nG_BEGIN_DECLS\n#define UPDATE_REQUEST_TYPE (update_request_get_type ())\nG_DECLARE_FINAL_TYPE (UpdateRequest, update_request, UPDATE, REQUEST, GObject)\n\nstruct _UpdateRequest {\n\tGObject\t\tparent;\n\n\tgchar \t\t*source;\t/**< Location of the source. If it starts with\n\t\t\t\t\t     '|', it is a command. If it contains \"://\",\n\t\t\t\t\t     then it is parsed as a URL, otherwise it is a\n\t\t\t\t\t     filename. */\n\tgchar           *postdata;      /**< HTTP POST request data (NULL for non-POST requests) */\n\tgchar           *authValue;     /**< Custom value for Authorization: header */\n\tupdateOptionsPtr options;\t/**< Update options for the request */\n\tgchar\t\t*filtercmd;\t/**< Command will filter output of URL */\n\tupdateStatePtr\tupdateState;\t/**< Update state of the requested object (etags, last modified...) */\n\tgboolean\tallowCommands;\t/**< Allow this requests to run commands */\n};\n\n/** structure to store results of the processing of an update request */\ntypedef struct updateResult {\n\tgchar \t\t*source;\t/**< Location of the downloaded document, in case of redirects different from\n\t\t\t\t\t     the one given along with the update request */\n\n\tint\t\thttpstatus;\t/**< HTTP status. Set to 200 for any valid command, file access, etc.... Set to 0 for unknown */\n\tgchar\t\t*data;\t\t/**< Downloaded data */\n\tsize_t\t\tsize;\t\t/**< Size of downloaded data */\n\tgchar\t\t*contentType;\t/**< Content type of received data */\n\tgchar\t\t*filterErrors;\t/**< Error messages from filter execution */\n\n\tupdateStatePtr\tupdateState;\t/**< New update state of the requested object (etags, last modified...) */\n} *updateResultPtr;\n\n/** structure to store state fo running command feeds */\ntypedef struct updateCommandState {\n\tGPid\t\tpid;\t\t/**< child PID */\n\tguint\t\ttimeout_id;\t/**< glib event source id for the timeout event */\n\tguint\t\tio_watch_id;\t/**< glib event source id for stdout */\n\tguint\t\tchild_watch_id;\t/**< glib event source id for child termination */\n\tgint\t\tfd;\t\t/**< fd for child stdout */\n\tGIOChannel\t*stdout_ch;\t/**< child stdout as a channel */\n} updateCommandState;\n\n\n/** structure describing an HTTP update job */\ntypedef struct updateJob {\n\tUpdateRequest\t\t*request;\n\tupdateResultPtr\t\tresult;\n\tgpointer\t\towner;\t\t/**< owner of this job (used for matching when cancelling) */\n\tupdate_result_cb\tcallback;\t/**< result processing callback */\n\tgpointer\t\tuser_data;\t/**< result processing user data */\n\tupdateFlags\t\tflags;\t\t/**< request and result processing flags */\n\tgint\t\t\tstate;\t\t/**< State of the job (enum request_state) */\n\tupdateCommandState\tcmd;\t\t/**< values for command feeds */\n} *updateJobPtr;\n\n/**\n * Create new update state\n */\nupdateStatePtr update_state_new (void);\n\n/**\n * Copy update state\n */\nupdateStatePtr update_state_copy (updateStatePtr state);\n\nglong update_state_get_lastmodified (updateStatePtr state);\nvoid update_state_set_lastmodified (updateStatePtr state, glong lastmodified);\n\nconst gchar * update_state_get_etag (updateStatePtr state);\nvoid update_state_set_etag (updateStatePtr state, const gchar *etag);\n\ngint update_state_get_cache_maxage (updateStatePtr state);\nvoid update_state_set_cache_maxage (updateStatePtr state, const gint maxage);\n\nconst gchar * update_state_get_cookies (updateStatePtr state);\nvoid update_state_set_cookies (updateStatePtr state, const gchar *cookies);\n\n/**\n * Frees the given update state.\n *\n * @param updateState  the update state\n */\nvoid update_state_free (updateStatePtr updateState);\n\n/**\n * Copies the given update options.\n *\n * @returns a new update options structure (to be free'd using update_options_free())\n */\nupdateOptionsPtr update_options_copy (updateOptionsPtr options);\n\n/**\n * Frees the given update options\n *\n * @param options\tthe update options\n */\nvoid update_options_free (updateOptionsPtr options);\n\n/**\n * Initialises the download subsystem.\n *\n * Must be called before gtk_init() and after thread initialization\n * as threads are used and for proper network-manager initialization.\n */\nvoid update_init (void);\n\n/**\n * Stops all update processing and frees all used memory.\n */\nvoid update_deinit (void);\n\n/**\n * Creates a new request structure.\n *\n * @oaram source\tURI to download\n * @param state\t\ta previous update state of the requested URL (or NULL)\n *                      will not be owned, but copied!\n * @param options\tupdate options to be used (or NULL)\n *\t\t\twill not be owned but copied!\n *\n * @returns a new request GObject to be passed to update_execute_request()\n */\nUpdateRequest * update_request_new (const gchar *source, updateStatePtr state, updateOptionsPtr options);\n\n/**\n * Sets the source for an updateRequest. Only use this when the source\n * is not known at update_request_new() calling time.\n *\n * @param request       the update request\n * @param source        the new source URL\n */\nvoid update_request_set_source (UpdateRequest *request, const gchar* source);\n\n/**\n * Sets a custom authorization header value.\n *\n * @param request        the update request\n * @param authValue      the authorization header value\n */\nvoid update_request_set_auth_value (UpdateRequest *request, const gchar* authValue);\n\n/**\n * Allows *this* request to run local commands.\n *\n * At first it may look this flag should be in updateOptions, but we can\n * take a safer path: feed commands are restricted to a few use cases while\n * options are propagated to downstream requests (feed enrichment, comments,\n * etc.), so it is a good idea to prevent these from running commands in the\n * local system via tricky URLs without needing to validate these options\n * everywhere (which is error-prone).\n *\n * @param request      the update request\n * @param can_run      TRUE if the request can run commands, FALSE otherwise.\n */\nvoid update_request_allow_commands (UpdateRequest *request, gboolean allowCommands);\n\n/**\n * Creates a new update result for the given update request.\n *\n * @returns update result (to be free'd using update_result_free())\n */\nupdateResultPtr update_result_new (void);\n\n/**\n * Free's the given update result.\n *\n * @param result\tthe result\n */\nvoid update_result_free (updateResultPtr result);\n\n/**\n * Executes the given request. The request might be\n * delayed if other requests are pending.\n *\n * @param owner\t\trequest owner (allows cancelling, can be NULL)\n * @param request\tthe request to execute\n * @param callback\tresult processing callback\n * @param user_data\tresult processing callback parameters (or NULL)\n * @param flags\t\trequest/result processing flags\n *\n * @returns the new update job\n */\nupdateJobPtr update_execute_request (gpointer owner,\n                                     UpdateRequest *request,\n                                     update_result_cb callback,\n                                     gpointer user_data,\n                                     updateFlags flags);\n\n/* Update job handling */\n\n/**\n * To be called when an update job has been executed. Triggers\n * the job specific result processing callback.\n *\n * @param job\t\tthe update job\n */\nvoid update_process_finished_job (updateJobPtr job);\n\n/**\n * Cancel all pending requests for the given owner.\n *\n * @param owner\t\tpointer passed in update_request_new()\n */\nvoid update_job_cancel_by_owner (gpointer owner);\n\n/**\n * Method to query the update state of currently processed jobs.\n *\n * @returns update job state (see enum request_state)\n */\ngint update_job_get_state (updateJobPtr job);\n\n/**\n* update_jobs_get_count:\n*\n* Query current count and max count of subscriptions in update queue\n*\n* @count:\tgint ref to pass back nr of subscriptions in update\n* @maxcount:\tgint ref to pass back max nr of subscriptions in update\n*/\nvoid update_jobs_get_count (guint *count, guint *maxcount);\n\nG_END_DECLS\n\n#endif\n"], "filenames": ["src/subscription.c", "src/update.c", "src/update.h"], "buggy_code_start_loc": [284, 236, 105], "buggy_code_end_loc": [284, 677, 231], "fixing_code_start_loc": [285, 237, 106], "fixing_code_end_loc": [286, 690, 248], "type": "CWE-78", "message": "A vulnerability was found in liferea. It has been rated as critical. Affected by this issue is the function update_job_run of the file src/update.c of the component Feed Enrichment. The manipulation of the argument source with the input |date &gt;/tmp/bad-item-link.txt leads to os command injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-222848.", "other": {"cve": {"id": "CVE-2023-1350", "sourceIdentifier": "cna@vuldb.com", "published": "2023-03-11T09:15:10.197", "lastModified": "2023-03-15T17:36:33.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in liferea. It has been rated as critical. Affected by this issue is the function update_job_run of the file src/update.c of the component Feed Enrichment. The manipulation of the argument source with the input |date &gt;/tmp/bad-item-link.txt leads to os command injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-222848."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:liferea_project:liferea:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.14.1", "matchCriteriaId": "A6DAF5E1-033A-45DE-AEAB-2A72AFDC7814"}]}]}], "references": [{"url": "https://github.com/lwindolf/liferea/commit/8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.222848", "source": "cna@vuldb.com", "tags": ["Permissions Required", "VDB Entry"]}, {"url": "https://vuldb.com/?id.222848", "source": "cna@vuldb.com", "tags": ["VDB Entry"]}]}, "github_commit_url": "https://github.com/lwindolf/liferea/commit/8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59"}}