{"buggy_code": ["\" Tests for various eval things.\n\nsource view_util.vim\n\nfunction s:foo() abort\n  try\n    return [] == 0\n  catch\n    return 1\n  endtry\nendfunction\n\nfunc Test_catch_return_with_error()\n  call assert_equal(1, s:foo())\nendfunc\n\nfunc Test_nocatch_restore_silent_emsg()\n  silent! try\n    throw 1\n  catch\n  endtry\n  echoerr 'wrong again'\n  call assert_equal('wrong again', ScreenLine(&lines))\nendfunc\n\nfunc Test_mkdir_p()\n  call mkdir('Xmkdir/nested', 'p')\n  call assert_true(isdirectory('Xmkdir/nested'))\n  try\n    \" Trying to make existing directories doesn't error\n    call mkdir('Xmkdir', 'p')\n    call mkdir('Xmkdir/nested', 'p')\n  catch /E739:/\n    call assert_report('mkdir(..., \"p\") failed for an existing directory')\n  endtry\n  \" 'p' doesn't suppress real errors\n  call writefile([], 'Xfile')\n  call assert_fails('call mkdir(\"Xfile\", \"p\")', 'E739:')\n  call delete('Xfile')\n  call delete('Xmkdir', 'rf')\n  call assert_equal(0, mkdir(test_null_string()))\n  call assert_fails('call mkdir([])', 'E730:')\n  call assert_fails('call mkdir(\"abc\", [], [])', 'E745:')\nendfunc\n\nfunc Test_line_continuation()\n  let array = [5,\n\t\"\\ ignore this\n\t\\ 6,\n\t\"\\ more to ignore\n\t\"\\ more moreto ignore\n\t\\ ]\n\t\"\\ and some more\n  call assert_equal([5, 6], array)\nendfunc\n\nfunc Test_E963()\n  \" These commands used to cause an internal error prior to vim 8.1.0563\n  let v_e = v:errors\n  let v_o = v:oldfiles\n  call assert_fails(\"let v:errors=''\", 'E963:')\n  call assert_equal(v_e, v:errors)\n  call assert_fails(\"let v:oldfiles=''\", 'E963:')\n  call assert_equal(v_o, v:oldfiles)\nendfunc\n\nfunc Test_for_invalid()\n  call assert_fails(\"for x in 99\", 'E1098:')\n  call assert_fails(\"for x in function('winnr')\", 'E1098:')\n  call assert_fails(\"for x in {'a': 9}\", 'E1098:')\n\n  if 0\n    /1/5/2/s/\\n\n  endif\n  redraw\nendfunc\n\nfunc Test_readfile_binary()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  setlocal ff=dos\n  silent write XReadfile_bin\n  let lines = 'XReadfile_bin'->readfile()\n  call assert_equal(['one', 'two', 'three'], lines)\n  let lines = readfile('XReadfile_bin', '', 2)\n  call assert_equal(['one', 'two'], lines)\n  let lines = readfile('XReadfile_bin', 'b')\n  call assert_equal([\"one\\r\", \"two\\r\", \"three\\r\", \"\"], lines)\n  let lines = readfile('XReadfile_bin', 'b', 2)\n  call assert_equal([\"one\\r\", \"two\\r\"], lines)\n\n  bwipe!\n  call delete('XReadfile_bin')\nendfunc\n\nfunc Test_readfile_binary_empty()\n  call writefile([], 'Xempty-file')\n  \" This used to compare uninitialized memory in Vim <= 8.2.4065\n  call assert_equal([''], readfile('Xempty-file', 'b'))\n  call delete('Xempty-file')\nendfunc\n\nfunc Test_readfile_bom()\n  call writefile([\"\\ufeffFOO\", \"FOO\\ufeffBAR\"], 'XReadfile_bom')\n  call assert_equal(['FOO', 'FOOBAR'], readfile('XReadfile_bom'))\n  call delete('XReadfile_bom')\nendfunc\n\nfunc Test_readfile_max()\n  call writefile(range(1, 4), 'XReadfile_max')\n  call assert_equal(['1', '2'], readfile('XReadfile_max', '', 2))\n  call assert_equal(['3', '4'], readfile('XReadfile_max', '', -2))\n  call delete('XReadfile_max')\nendfunc\n\nfunc Test_let_errmsg()\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\nendfunc\n\nfunc Test_string_concatenation()\n  call assert_equal('ab', 'a'.'b')\n  call assert_equal('ab', 'a' .'b')\n  call assert_equal('ab', 'a'. 'b')\n  call assert_equal('ab', 'a' . 'b')\n\n  call assert_equal('ab', 'a'..'b')\n  call assert_equal('ab', 'a' ..'b')\n  call assert_equal('ab', 'a'.. 'b')\n  call assert_equal('ab', 'a' .. 'b')\n\n  let a = 'a'\n  let b = 'b'\n  let a .= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a.=b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a ..= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a..=b\n  call assert_equal('ab', a)\n\n  if has('float')\n    let a = 'A'\n    let b = 1.234\n    call assert_equal('A1.234', a .. b)\n  endif\nendfunc\n\n\" Test fix for issue #4507\nfunc Test_skip_after_throw()\n  try\n    throw 'something'\n    let x = wincol() || &ts\n  catch /something/\n  endtry\nendfunc\n\nscriptversion 2\nfunc Test_string_concat_scriptversion2()\n  call assert_true(has('vimscript-2'))\n  let a = 'a'\n  let b = 'b'\n\n  call assert_fails('echo a . b', 'E15:')\n  call assert_fails('let a .= b', 'E985:')\n  call assert_fails('let vers = 1.2.3', 'E488:')\n\n  if has('float')\n    let f = .5\n    call assert_equal(0.5, f)\n  endif\nendfunc\n\nscriptversion 1\nfunc Test_string_concat_scriptversion1()\n  call assert_true(has('vimscript-1'))\n  let a = 'a'\n  let b = 'b'\n\n  echo a . b\n  let a .= b\n  let vers = 1.2.3\n  call assert_equal('123', vers)\n\n  if has('float')\n    call assert_fails('let f = .5', 'E15:')\n  endif\nendfunc\n\nscriptversion 3\nfunc Test_vvar_scriptversion3()\n  call assert_true(has('vimscript-3'))\n  call assert_fails('echo version', 'E121:')\n  call assert_false(exists('version'))\n  let version = 1\n  call assert_equal(1, version)\nendfunc\n\nscriptversion 2\nfunc Test_vvar_scriptversion2()\n  call assert_true(exists('version'))\n  echo version\n  call assert_fails('let version = 1', 'E46:')\n  call assert_equal(v:version, version)\n\n  call assert_equal(v:version, v:versionlong / 10000)\n  call assert_true(v:versionlong > 8011525)\nendfunc\n\nfunc Test_dict_access_scriptversion2()\n  let l:x = {'foo': 1}\n\n  call assert_false(0 && l:x.foo)\n  call assert_true(1 && l:x.foo)\nendfunc\n\nscriptversion 4\nfunc Test_vvar_scriptversion4()\n  call assert_true(has('vimscript-4'))\n  call assert_equal(17, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\n  call assert_equal(64, 0b1'00'00'00)\n  call assert_equal(1048576, 0x10'00'00)\n  call assert_equal(32768, 0o10'00'00)\n  call assert_equal(1000000, 1'000'000)\n  call assert_equal(\"1234\", execute(\"echo 1'234\")->trim())\n  call assert_equal('1  234', execute(\"echo 1''234\")->trim())\n  call assert_fails(\"echo 1'''234\", 'E115:')\nendfunc\n\nscriptversion 1\nfunc Test_vvar_scriptversion1()\n  call assert_equal(15, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\nendfunc\n\nfunc Test_scriptversion_fail()\n  call writefile(['scriptversion 9'], 'Xversionscript')\n  call assert_fails('source Xversionscript', 'E999:')\n  call delete('Xversionscript')\nendfunc\n\nfunc Test_execute_cmd_with_null()\n  call assert_fails('execute test_null_list()', 'E730:')\n  call assert_fails('execute test_null_dict()', 'E731:')\n  call assert_fails('execute test_null_blob()', 'E976:')\n  execute test_null_string()\n  call assert_fails('execute test_null_partial()', 'E729:')\n  call assert_fails('execute test_unknown()', 'E908:')\n  if has('job')\n    call assert_fails('execute test_null_job()', 'E908:')\n    call assert_fails('execute test_null_channel()', 'E908:')\n  endif\nendfunc\n\nfunc Test_number_max_min_size()\n  \" This will fail on systems without 64 bit number support or when not\n  \" configured correctly.\n  call assert_equal(64, v:numbersize)\n\n  call assert_true(v:numbermin < -9999999)\n  call assert_true(v:numbermax > 9999999)\nendfunc\n\nfunc Assert_reg(name, type, value, valuestr, expr, exprstr)\n  call assert_equal(a:type, getregtype(a:name))\n  call assert_equal(a:value, getreg(a:name))\n  call assert_equal(a:valuestr, string(getreg(a:name, 0, 1)))\n  call assert_equal(a:expr, getreg(a:name, 1))\n  call assert_equal(a:exprstr, string(getreg(a:name, 1, 1)))\nendfunc\n\nfunc Test_let_register()\n  let @\" = 'abc'\n  call Assert_reg('\"', 'v', \"abc\", \"['abc']\", \"abc\", \"['abc']\")\n  let @\" = \"abc\\n\"\n  call Assert_reg('\"', 'V', \"abc\\n\", \"['abc']\", \"abc\\n\", \"['abc']\")\n  let @\" = \"abc\\<C-m>\"\n  call Assert_reg('\"', 'V', \"abc\\r\\n\", \"['abc\\r']\", \"abc\\r\\n\", \"['abc\\r']\")\n  let @= = '\"abc\"'\n  call Assert_reg('=', 'v', \"abc\", \"['abc']\", '\"abc\"', \"['\\\"abc\\\"']\")\nendfunc\n\nfunc Assert_regput(name, result)\n  new\n  execute \"silent normal! o==\\n==\\e\\\"\" . a:name . \"P\"\n  call assert_equal(a:result, getline(2, line('$')))\n  bwipe!\nendfunc\n\nfunc Test_setreg_basic()\n  call setreg('a', 'abcA', 'c')\n  call Assert_reg('a', 'v', \"abcA\", \"['abcA']\", \"abcA\", \"['abcA']\")\n  call Assert_regput('a', ['==', '=abcA='])\n\n  call setreg('A', 'abcAc', 'c')\n  call Assert_reg('A', 'v', \"abcAabcAc\", \"['abcAabcAc']\", \"abcAabcAc\", \"['abcAabcAc']\")\n  call Assert_regput('a', ['==', '=abcAabcAc='])\n\n  call setreg('A', 'abcAl', 'l')\n  call Assert_reg('A', 'V', \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\", \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\")\n  call Assert_regput('a', ['==', 'abcAabcAcabcAl', '=='])\n\n  call setreg('A', 'abcAc2','c')\n  call Assert_reg('A', 'v', \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\", \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\")\n  call Assert_regput('a', ['==', '=abcAabcAcabcAl', 'abcAc2='])\n\n  call setreg('b', 'abcB', 'v')\n  call Assert_reg('b', 'v', \"abcB\", \"['abcB']\", \"abcB\", \"['abcB']\")\n  call Assert_regput('b', ['==', '=abcB='])\n\n  call setreg('b', 'abcBc', 'ca')\n  call Assert_reg('b', 'v', \"abcBabcBc\", \"['abcBabcBc']\", \"abcBabcBc\", \"['abcBabcBc']\")\n  call Assert_regput('b', ['==', '=abcBabcBc='])\n\n  call setreg('b', 'abcBb', 'ba')\n  call Assert_reg('b', \"\\<C-V>5\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb='])\n\n  call setreg('b', 'abcBc2','ca')\n  call Assert_reg('b', \"v\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb', 'abcBc2='])\n\n  call setreg('b', 'abcBb2','b50a')\n  call Assert_reg('b', \"\\<C-V>50\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb                                    =', ' abcBc2abcBb2'])\n\n  call setreg('c', 'abcC', 'l')\n  call Assert_reg('c', 'V', \"abcC\\n\", \"['abcC']\", \"abcC\\n\", \"['abcC']\")\n  call Assert_regput('c', ['==', 'abcC', '=='])\n\n  call setreg('C', 'abcCl', 'l')\n  call Assert_reg('C', 'V', \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\", \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\")\n  call Assert_regput('c', ['==', 'abcC', 'abcCl', '=='])\n\n  call setreg('C', 'abcCc', 'c')\n  call Assert_reg('C', 'v', \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\", \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\")\n  call Assert_regput('c', ['==', '=abcC', 'abcCl', 'abcCc='])\n\n  call setreg('d', 'abcD', 'V')\n  call Assert_reg('d', 'V', \"abcD\\n\", \"['abcD']\", \"abcD\\n\", \"['abcD']\")\n  call Assert_regput('d', ['==', 'abcD', '=='])\n\n  call setreg('D', 'abcDb', 'b')\n  call Assert_reg('d', \"\\<C-V>5\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\")\n  call Assert_regput('d', ['==', '=abcD =', ' abcDb'])\n\n  call setreg('e', 'abcE', 'b')\n  call Assert_reg('e', \"\\<C-V>4\", \"abcE\", \"['abcE']\", \"abcE\", \"['abcE']\")\n  call Assert_regput('e', ['==', '=abcE='])\n\n  call setreg('E', 'abcEb', 'b')\n  call Assert_reg('E', \"\\<C-V>5\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\")\n  call Assert_regput('e', ['==', '=abcE =', ' abcEb'])\n\n  call setreg('E', 'abcEl', 'l')\n  call Assert_reg('E', \"V\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\")\n  call Assert_regput('e', ['==', 'abcE', 'abcEb', 'abcEl', '=='])\n\n  call setreg('f', 'abcF', \"\\<C-v>\")\n  call Assert_reg('f', \"\\<C-V>4\", \"abcF\", \"['abcF']\", \"abcF\", \"['abcF']\")\n  call Assert_regput('f', ['==', '=abcF='])\n\n  call setreg('F', 'abcFc', 'c')\n  call Assert_reg('F', \"v\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\")\n  call Assert_regput('f', ['==', '=abcF', 'abcFc='])\n\n  call setreg('g', 'abcG', 'b10')\n  call Assert_reg('g', \"\\<C-V>10\", \"abcG\", \"['abcG']\", \"abcG\", \"['abcG']\")\n  call Assert_regput('g', ['==', '=abcG      ='])\n\n  call setreg('h', 'abcH', \"\\<C-v>10\")\n  call Assert_reg('h', \"\\<C-V>10\", \"abcH\", \"['abcH']\", \"abcH\", \"['abcH']\")\n  call Assert_regput('h', ['==', '=abcH      ='])\n\n  call setreg('I', 'abcI')\n  call Assert_reg('I', \"v\", \"abcI\", \"['abcI']\", \"abcI\", \"['abcI']\")\n  call Assert_regput('I', ['==', '=abcI='])\n\n  \" Appending NL with setreg()\n  call setreg('a', 'abcA2', 'c')\n  call setreg('b', 'abcB2', 'v')\n  call setreg('c', 'abcC2', 'l')\n  call setreg('d', 'abcD2', 'V')\n  call setreg('e', 'abcE2', 'b')\n  call setreg('f', 'abcF2', \"\\<C-v>\")\n  call setreg('g', 'abcG2', 'b10')\n  call setreg('h', 'abcH2', \"\\<C-v>10\")\n  call setreg('I', 'abcI2')\n\n  call setreg('A', \"\\n\")\n  call Assert_reg('A', 'V', \"abcA2\\n\", \"['abcA2']\", \"abcA2\\n\", \"['abcA2']\")\n  call Assert_regput('A', ['==', 'abcA2', '=='])\n\n  call setreg('B', \"\\n\", 'c')\n  call Assert_reg('B', 'v', \"abcB2\\n\", \"['abcB2', '']\", \"abcB2\\n\", \"['abcB2', '']\")\n  call Assert_regput('B', ['==', '=abcB2', '='])\n\n  call setreg('C', \"\\n\")\n  call Assert_reg('C', 'V', \"abcC2\\n\\n\", \"['abcC2', '']\", \"abcC2\\n\\n\", \"['abcC2', '']\")\n  call Assert_regput('C', ['==', 'abcC2', '', '=='])\n\n  call setreg('D', \"\\n\", 'l')\n  call Assert_reg('D', 'V', \"abcD2\\n\\n\", \"['abcD2', '']\", \"abcD2\\n\\n\", \"['abcD2', '']\")\n  call Assert_regput('D', ['==', 'abcD2', '', '=='])\n\n  call setreg('E', \"\\n\")\n  call Assert_reg('E', 'V', \"abcE2\\n\\n\", \"['abcE2', '']\", \"abcE2\\n\\n\", \"['abcE2', '']\")\n  call Assert_regput('E', ['==', 'abcE2', '', '=='])\n\n  call setreg('F', \"\\n\", 'b')\n  call Assert_reg('F', \"\\<C-V>0\", \"abcF2\\n\", \"['abcF2', '']\", \"abcF2\\n\", \"['abcF2', '']\")\n  call Assert_regput('F', ['==', '=abcF2=', ' '])\n\n  \" Setting lists with setreg()\n  call setreg('a', ['abcA3'], 'c')\n  call Assert_reg('a', 'v', \"abcA3\", \"['abcA3']\", \"abcA3\", \"['abcA3']\")\n  call Assert_regput('a', ['==', '=abcA3='])\n\n  call setreg('b', ['abcB3'], 'l')\n  call Assert_reg('b', 'V', \"abcB3\\n\", \"['abcB3']\", \"abcB3\\n\", \"['abcB3']\")\n  call Assert_regput('b', ['==', 'abcB3', '=='])\n\n  call setreg('c', ['abcC3'], 'b')\n  call Assert_reg('c', \"\\<C-V>5\", \"abcC3\", \"['abcC3']\", \"abcC3\", \"['abcC3']\")\n  call Assert_regput('c', ['==', '=abcC3='])\n\n  call setreg('d', ['abcD3'])\n  call Assert_reg('d', 'V', \"abcD3\\n\", \"['abcD3']\", \"abcD3\\n\", \"['abcD3']\")\n  call Assert_regput('d', ['==', 'abcD3', '=='])\n\n  call setreg('e', [1, 2, 'abc', 3])\n  call Assert_reg('e', 'V', \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\", \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\")\n  call Assert_regput('e', ['==', '1', '2', 'abc', '3', '=='])\n\n  call setreg('f', [1, 2, 3])\n  call Assert_reg('f', 'V', \"1\\n2\\n3\\n\", \"['1', '2', '3']\", \"1\\n2\\n3\\n\", \"['1', '2', '3']\")\n  call Assert_regput('f', ['==', '1', '2', '3', '=='])\n\n  \" Appending lists with setreg()\n  call setreg('A', ['abcA3c'], 'c')\n  call Assert_reg('A', 'v', \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\", \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\")\n  call Assert_regput('A', ['==', '=abcA3', 'abcA3c='])\n\n  call setreg('b', ['abcB3l'], 'la')\n  call Assert_reg('b', 'V', \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\", \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\")\n  call Assert_regput('b', ['==', 'abcB3', 'abcB3l', '=='])\n\n  call setreg('C', ['abcC3b'], 'lb')\n  call Assert_reg('C', \"\\<C-V>6\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\")\n  call Assert_regput('C', ['==', '=abcC3 =', ' abcC3b'])\n\n  call setreg('D', ['abcD32'])\n  call Assert_reg('D', 'V', \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\", \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\")\n  call Assert_regput('D', ['==', 'abcD3', 'abcD32', '=='])\n\n  call setreg('A', ['abcA32'])\n  call Assert_reg('A', 'V', \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\", \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', '=='])\n\n  call setreg('B', ['abcB3c'], 'c')\n  call Assert_reg('B', 'v', \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\", \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c='])\n\n  call setreg('C', ['abcC3l'], 'l')\n  call Assert_reg('C', 'V', \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\", \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\")\n  call Assert_regput('C', ['==', 'abcC3', 'abcC3b', 'abcC3l', '=='])\n\n  call setreg('D', ['abcD3b'], 'b')\n  call Assert_reg('D', \"\\<C-V>6\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\")\n  call Assert_regput('D', ['==', '=abcD3 =', ' abcD32', ' abcD3b'])\n\n  \" Appending lists with NL with setreg()\n  call setreg('A', [\"\\n\", 'abcA3l2'], 'l')\n  call Assert_reg('A', \"V\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', \"\\n\", 'abcA3l2', '=='])\n\n  call setreg('B', [\"\\n\", 'abcB3c2'], 'c')\n  call Assert_reg('B', \"v\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c', \"\\n\", 'abcB3c2='])\n\n  call setreg('C', [\"\\n\", 'abcC3b2'], 'b')\n  call Assert_reg('C', \"\u00167\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\")\n  call Assert_regput('C', ['==', '=abcC3  =', ' abcC3b', ' abcC3l', \" \\n\", ' abcC3b2'])\n\n  call setreg('D', [\"\\n\", 'abcD3b50'],'b50')\n  call Assert_reg('D', \"\u001650\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\")\n  call Assert_regput('D', ['==', '=abcD3                                             =', ' abcD32', ' abcD3b', \" \\n\", ' abcD3b50'])\n\n  \" Setting lists with NLs with setreg()\n  call setreg('a', ['abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\"])\n  call Assert_reg('a', \"V\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\")\n  call Assert_regput('a', ['==', 'abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\", '=='])\n\n  call setreg('b', ['abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2\"], 'c')\n  call Assert_reg('b', \"v\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\")\n  call Assert_regput('b', ['==', '=abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2=\"])\n\n  call setreg('c', ['abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\"], 'l')\n  call Assert_reg('c', \"V\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\")\n  call Assert_regput('c', ['==', 'abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\", '=='])\n\n  call setreg('d', ['abcD4b-0', \"\\n\", \"abcD4b-2\\n\", \"\\nabcD4b-3\", \"abcD4b-4\\nabcD4b-4-2\"], 'b')\n  call Assert_reg('d', \"\u001619\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\")\n  call Assert_regput('d', ['==', '=abcD4b-0           =', \" \\n\", \" abcD4b-2\\n\", \" \\nabcD4b-3\", \" abcD4b-4\\nabcD4b-4-2\"])\n\n  call setreg('e', ['abcE4b10-0', \"\\n\", \"abcE4b10-2\\n\", \"\\nabcE4b10-3\", \"abcE4b10-4\\nabcE4b10-4-2\"], 'b10')\n  call Assert_reg('e', \"\u001610\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\")\n  call Assert_regput('e', ['==', '=abcE4b10-0=', \" \\n\", \" abcE4b10-2\\n\", \" \\nabcE4b10-3\", \" abcE4b10-4\\nabcE4b10-4-2\"])\n\n  \" Search and expressions\n  call setreg('/', ['abc/'])\n  call Assert_reg('/', 'v', \"abc/\", \"['abc/']\", \"abc/\", \"['abc/']\")\n  call Assert_regput('/', ['==', '=abc/='])\n\n  call setreg('/', [\"abc/\\n\"])\n  call Assert_reg('/', 'v', \"abc/\\n\", \"['abc/\\n']\", \"abc/\\n\", \"['abc/\\n']\")\n  call Assert_regput('/', ['==', \"=abc/\\n=\"])\n\n  call setreg('=', ['\"abc/\"'])\n  call Assert_reg('=', 'v', \"abc/\", \"['abc/']\", '\"abc/\"', \"['\\\"abc/\\\"']\")\n\n  call setreg('=', [\"\\\"abc/\\n\\\"\"])\n  call Assert_reg('=', 'v', \"abc/\\n\", \"['abc/\\n']\", \"\\\"abc/\\n\\\"\", \"['\\\"abc/\\n\\\"']\")\n\n  \" System clipboard\n  if has('clipboard')\n    new | only!\n    call setline(1, ['clipboard contents', 'something else'])\n    \" Save and restore system clipboard.\n    \" If no connection to X-Server is possible, test should succeed.\n    let _clipreg = ['*', getreg('*'), getregtype('*')]\n    let _clipopt = &cb\n    let &cb='unnamed'\n    1y\n    call Assert_reg('*', 'V', \"clipboard contents\\n\", \"['clipboard contents']\", \"clipboard contents\\n\", \"['clipboard contents']\")\n    tabdo :windo :echo \"hi\"\n    2y\n    call Assert_reg('*', 'V', \"something else\\n\", \"['something else']\", \"something else\\n\", \"['something else']\")\n    let &cb=_clipopt\n    call call('setreg', _clipreg)\n    enew!\n  endif\n\n  \" Error cases\n  call assert_fails('call setreg()', 'E119:')\n  call assert_fails('call setreg(1)', 'E119:')\n  call assert_fails('call setreg(1, 2, 3, 4)', 'E118:')\n  call assert_fails('call setreg([], 2)', 'E730:')\n  call assert_fails('call setreg(1, 2, [])', 'E730:')\n  call assert_fails('call setreg(\"/\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(\"=\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(1, [\"\", \"\", [], \"\"])', 'E730:')\nendfunc\n\nfunc Test_curly_assignment()\n  let s:svar = 'svar'\n  let g:gvar = 'gvar'\n  let lname = 'gvar'\n  let gname = 'gvar'\n  let {'s:'.lname} = {'g:'.gname}\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:'.lname } = { 'g:'.gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' . lname } = { 'g:' . gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' .. lname } = { 'g:' .. gname }\n  call assert_equal('gvar', s:gvar)\n\n  unlet s:svar\n  unlet s:gvar\n  unlet g:gvar\nendfunc\n\nfunc Test_deep_recursion()\n  \" this was running out of stack\n  call assert_fails(\"exe 'if ' .. repeat('(', 1002)\", 'E1169: Expression too recursive: ((')\nendfunc\n\n\" K_SPECIAL in the modified character used be escaped, which causes\n\" double-escaping with feedkeys() or as the return value of an <expr> mapping,\n\" and doesn't match what getchar() returns,\nfunc Test_modified_char_no_escape_special()\n  nnoremap <M-\u2026> <Cmd>let g:got_m_ellipsis += 1<CR>\n  call feedkeys(\"\\<M-\u2026>\", 't')\n  call assert_equal(\"\\<M-\u2026>\", getchar())\n  let g:got_m_ellipsis = 0\n  call feedkeys(\"\\<M-\u2026>\", 'xt')\n  call assert_equal(1, g:got_m_ellipsis)\n  func Func()\n    return \"\\<M-\u2026>\"\n  endfunc\n  nmap <expr> <F2> Func()\n  call feedkeys(\"\\<F2>\", 'xt')\n  call assert_equal(2, g:got_m_ellipsis)\n  delfunc Func\n  nunmap <F2>\n  unlet g:got_m_ellipsis\n  nunmap <M-\u2026>\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * typval.c: functions that deal with a typval\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Allocate memory for a variable type-value, and make it empty (0 or NULL\n * value).\n */\n    typval_T *\nalloc_tv(void)\n{\n    return ALLOC_CLEAR_ONE(typval_T);\n}\n\n/*\n * Allocate memory for a variable type-value, and assign a string to it.\n * The string \"s\" must have been allocated, it is consumed.\n * Return NULL for out of memory, the variable otherwise.\n */\n    typval_T *\nalloc_string_tv(char_u *s)\n{\n    typval_T\t*rettv;\n\n    rettv = alloc_tv();\n    if (rettv != NULL)\n    {\n\trettv->v_type = VAR_STRING;\n\trettv->vval.v_string = s;\n    }\n    else\n\tvim_free(s);\n    return rettv;\n}\n\n/*\n * Free the memory for a variable type-value.\n */\n    void\nfree_tv(typval_T *varp)\n{\n    if (varp != NULL)\n    {\n\tswitch (varp->v_type)\n\t{\n\t    case VAR_FUNC:\n\t\tfunc_unref(varp->vval.v_string);\n\t\t// FALLTHROUGH\n\t    case VAR_STRING:\n\t\tvim_free(varp->vval.v_string);\n\t\tbreak;\n\t    case VAR_PARTIAL:\n\t\tpartial_unref(varp->vval.v_partial);\n\t\tbreak;\n\t    case VAR_BLOB:\n\t\tblob_unref(varp->vval.v_blob);\n\t\tbreak;\n\t    case VAR_LIST:\n\t\tlist_unref(varp->vval.v_list);\n\t\tbreak;\n\t    case VAR_DICT:\n\t\tdict_unref(varp->vval.v_dict);\n\t\tbreak;\n\t    case VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\tjob_unref(varp->vval.v_job);\n\t\tbreak;\n#endif\n\t    case VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\tchannel_unref(varp->vval.v_channel);\n\t\tbreak;\n#endif\n\t    case VAR_NUMBER:\n\t    case VAR_FLOAT:\n\t    case VAR_ANY:\n\t    case VAR_UNKNOWN:\n\t    case VAR_VOID:\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t    case VAR_INSTR:\n\t\tbreak;\n\t}\n\tvim_free(varp);\n    }\n}\n\n/*\n * Free the memory for a variable value and set the value to NULL or 0.\n */\n    void\nclear_tv(typval_T *varp)\n{\n    if (varp != NULL)\n    {\n\tswitch (varp->v_type)\n\t{\n\t    case VAR_FUNC:\n\t\tfunc_unref(varp->vval.v_string);\n\t\t// FALLTHROUGH\n\t    case VAR_STRING:\n\t\tVIM_CLEAR(varp->vval.v_string);\n\t\tbreak;\n\t    case VAR_PARTIAL:\n\t\tpartial_unref(varp->vval.v_partial);\n\t\tvarp->vval.v_partial = NULL;\n\t\tbreak;\n\t    case VAR_BLOB:\n\t\tblob_unref(varp->vval.v_blob);\n\t\tvarp->vval.v_blob = NULL;\n\t\tbreak;\n\t    case VAR_LIST:\n\t\tlist_unref(varp->vval.v_list);\n\t\tvarp->vval.v_list = NULL;\n\t\tbreak;\n\t    case VAR_DICT:\n\t\tdict_unref(varp->vval.v_dict);\n\t\tvarp->vval.v_dict = NULL;\n\t\tbreak;\n\t    case VAR_NUMBER:\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t\tvarp->vval.v_number = 0;\n\t\tbreak;\n\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\tvarp->vval.v_float = 0.0;\n\t\tbreak;\n#endif\n\t    case VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\tjob_unref(varp->vval.v_job);\n\t\tvarp->vval.v_job = NULL;\n#endif\n\t\tbreak;\n\t    case VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\tchannel_unref(varp->vval.v_channel);\n\t\tvarp->vval.v_channel = NULL;\n#endif\n\t\tbreak;\n\t    case VAR_INSTR:\n\t\tVIM_CLEAR(varp->vval.v_instr);\n\t\tbreak;\n\t    case VAR_UNKNOWN:\n\t    case VAR_ANY:\n\t    case VAR_VOID:\n\t\tbreak;\n\t}\n\tvarp->v_lock = 0;\n    }\n}\n\n/*\n * Set the value of a variable to NULL without freeing items.\n */\n    void\ninit_tv(typval_T *varp)\n{\n    if (varp != NULL)\n\tCLEAR_POINTER(varp);\n}\n\n    static varnumber_T\ntv_get_bool_or_number_chk(typval_T *varp, int *denote, int want_bool)\n{\n    varnumber_T\tn = 0L;\n\n    switch (varp->v_type)\n    {\n\tcase VAR_NUMBER:\n\t    if (in_vim9script() && want_bool && varp->vval.v_number != 0\n\t\t\t\t\t\t   && varp->vval.v_number != 1)\n\t    {\n\t\tsemsg(_(e_using_number_as_bool_nr), varp->vval.v_number);\n\t\tbreak;\n\t    }\n\t    return varp->vval.v_number;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    emsg(_(e_using_float_as_number));\n\t    break;\n#endif\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    emsg(_(e_using_funcref_as_number));\n\t    break;\n\tcase VAR_STRING:\n\t    if (in_vim9script())\n\t    {\n\t\temsg_using_string_as(varp, !want_bool);\n\t\tbreak;\n\t    }\n\t    if (varp->vval.v_string != NULL)\n\t\tvim_str2nr(varp->vval.v_string, NULL, NULL,\n\t\t\t\t\t    STR2NR_ALL, &n, NULL, 0, FALSE);\n\t    return n;\n\tcase VAR_LIST:\n\t    emsg(_(e_using_list_as_number));\n\t    break;\n\tcase VAR_DICT:\n\t    emsg(_(e_using_dictionary_as_number));\n\t    break;\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    if (!want_bool && in_vim9script())\n\t    {\n\t\tif (varp->v_type == VAR_BOOL)\n\t\t    emsg(_(e_using_bool_as_number));\n\t\telse\n\t\t    emsg(_(e_using_special_as_number));\n\t\tbreak;\n\t    }\n\t    return varp->vval.v_number == VVAL_TRUE ? 1 : 0;\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    emsg(_(e_using_job_as_number));\n\t    break;\n#endif\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    emsg(_(e_using_channel_as_number));\n\t    break;\n#endif\n\tcase VAR_BLOB:\n\t    emsg(_(e_using_blob_as_number));\n\t    break;\n\tcase VAR_VOID:\n\t    emsg(_(e_cannot_use_void_value));\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_INSTR:\n\t    internal_error_no_abort(\"tv_get_number(UNKNOWN)\");\n\t    break;\n    }\n    if (denote == NULL)\t\t// useful for values that must be unsigned\n\tn = -1;\n    else\n\t*denote = TRUE;\n    return n;\n}\n\n/*\n * Get the number value of a variable.\n * If it is a String variable, uses vim_str2nr().\n * For incompatible types, return 0.\n * tv_get_number_chk() is similar to tv_get_number(), but informs the\n * caller of incompatible types: it sets *denote to TRUE if \"denote\"\n * is not NULL or returns -1 otherwise.\n */\n    varnumber_T\ntv_get_number(typval_T *varp)\n{\n    int\t\terror = FALSE;\n\n    return tv_get_number_chk(varp, &error);\t// return 0L on error\n}\n\n    varnumber_T\ntv_get_number_chk(typval_T *varp, int *denote)\n{\n    return tv_get_bool_or_number_chk(varp, denote, FALSE);\n}\n\n/*\n * Get the boolean value of \"varp\".  This is like tv_get_number_chk(),\n * but in Vim9 script accepts Number (0 and 1) and Bool/Special.\n */\n    varnumber_T\ntv_get_bool(typval_T *varp)\n{\n    return tv_get_bool_or_number_chk(varp, NULL, TRUE);\n}\n\n/*\n * Get the boolean value of \"varp\".  This is like tv_get_number_chk(),\n * but in Vim9 script accepts Number and Bool.\n */\n    varnumber_T\ntv_get_bool_chk(typval_T *varp, int *denote)\n{\n    return tv_get_bool_or_number_chk(varp, denote, TRUE);\n}\n\n#if defined(FEAT_FLOAT) || defined(PROTO)\n    static float_T\ntv_get_float_chk(typval_T *varp, int *error)\n{\n    switch (varp->v_type)\n    {\n\tcase VAR_NUMBER:\n\t    return (float_T)(varp->vval.v_number);\n\tcase VAR_FLOAT:\n\t    return varp->vval.v_float;\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    emsg(_(e_using_funcref_as_float));\n\t    break;\n\tcase VAR_STRING:\n\t    emsg(_(e_using_string_as_float));\n\t    break;\n\tcase VAR_LIST:\n\t    emsg(_(e_using_list_as_float));\n\t    break;\n\tcase VAR_DICT:\n\t    emsg(_(e_using_dictionary_as_float));\n\t    break;\n\tcase VAR_BOOL:\n\t    emsg(_(e_using_boolean_value_as_float));\n\t    break;\n\tcase VAR_SPECIAL:\n\t    emsg(_(e_using_special_value_as_float));\n\t    break;\n\tcase VAR_JOB:\n# ifdef FEAT_JOB_CHANNEL\n\t    emsg(_(e_using_job_as_float));\n\t    break;\n# endif\n\tcase VAR_CHANNEL:\n# ifdef FEAT_JOB_CHANNEL\n\t    emsg(_(e_using_channel_as_float));\n\t    break;\n# endif\n\tcase VAR_BLOB:\n\t    emsg(_(e_using_blob_as_float));\n\t    break;\n\tcase VAR_VOID:\n\t    emsg(_(e_cannot_use_void_value));\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_INSTR:\n\t    internal_error_no_abort(\"tv_get_float(UNKNOWN)\");\n\t    break;\n    }\n    if (error != NULL)\n\t*error = TRUE;\n    return 0;\n}\n\n    float_T\ntv_get_float(typval_T *varp)\n{\n    return tv_get_float_chk(varp, NULL);\n}\n#endif\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is unknown\n */\n    int\ncheck_for_unknown_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_UNKNOWN)\n    {\n\tsemsg(_(e_too_many_arguments), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string.\n */\n    int\ncheck_for_string_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING)\n    {\n\tsemsg(_(e_string_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a non-empty string.\n */\n    int\ncheck_for_nonempty_string_arg(typval_T *args, int idx)\n{\n    if (check_for_string_arg(args, idx) == FAIL)\n\treturn FAIL;\n    if (args[idx].vval.v_string == NULL || *args[idx].vval.v_string == NUL)\n    {\n\tsemsg(_(e_non_empty_string_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional string argument at 'idx'\n */\n    int\ncheck_for_opt_string_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_string_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a number.\n */\n    int\ncheck_for_number_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_NUMBER)\n    {\n\tsemsg(_(e_number_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional number argument at 'idx'\n */\n    int\ncheck_for_opt_number_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_number_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a float or a number.\n */\n    int\ncheck_for_float_or_nr_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_FLOAT && args[idx].v_type != VAR_NUMBER)\n    {\n\tsemsg(_(e_float_or_number_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a bool.\n */\n    int\ncheck_for_bool_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_BOOL\n\t    && !(args[idx].v_type == VAR_NUMBER\n\t\t&& (args[idx].vval.v_number == 0\n\t\t    || args[idx].vval.v_number == 1)))\n    {\n\tsemsg(_(e_bool_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional bool argument at 'idx'.\n * Return FAIL if the type is wrong.\n */\n    int\ncheck_for_opt_bool_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type == VAR_UNKNOWN)\n\treturn OK;\n    return check_for_bool_arg(args, idx);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a blob.\n */\n    int\ncheck_for_blob_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_BLOB)\n    {\n\tsemsg(_(e_blob_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a list.\n */\n    int\ncheck_for_list_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_LIST)\n    {\n\t    semsg(_(e_list_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional list argument at 'idx'\n */\n    int\ncheck_for_opt_list_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_list_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a dict.\n */\n    int\ncheck_for_dict_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_DICT)\n    {\n\tsemsg(_(e_dict_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional dict argument at 'idx'\n */\n    int\ncheck_for_opt_dict_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_dict_arg(args, idx) != FAIL);\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a channel or a job.\n */\n    int\ncheck_for_chan_or_job_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_CHANNEL && args[idx].v_type != VAR_JOB)\n    {\n\tsemsg(_(e_chan_or_job_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is an optional channel or a\n * job.\n */\n    int\ncheck_for_opt_chan_or_job_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_chan_or_job_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a job.\n */\n    int\ncheck_for_job_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_JOB)\n    {\n\tsemsg(_(e_job_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional job argument at 'idx'.\n */\n    int\ncheck_for_opt_job_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_job_arg(args, idx) != FAIL);\n}\n#endif\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or\n * a number.\n */\n    int\ncheck_for_string_or_number_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING && args[idx].v_type != VAR_NUMBER)\n    {\n\tsemsg(_(e_string_or_number_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional string or number argument at 'idx'.\n */\n    int\ncheck_for_opt_string_or_number_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_string_or_number_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a buffer number.\n * Buffer number can be a number or a string.\n */\n    int\ncheck_for_buffer_arg(typval_T *args, int idx)\n{\n    return check_for_string_or_number_arg(args, idx);\n}\n\n/*\n * Check for an optional buffer argument at 'idx'\n */\n    int\ncheck_for_opt_buffer_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_buffer_arg(args, idx));\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a line number.\n * Line number can be a number or a string.\n */\n    int\ncheck_for_lnum_arg(typval_T *args, int idx)\n{\n    return check_for_string_or_number_arg(args, idx);\n}\n\n/*\n * Check for an optional line number argument at 'idx'\n */\n    int\ncheck_for_opt_lnum_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_lnum_arg(args, idx));\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or a blob.\n */\n    int\ncheck_for_string_or_blob_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING && args[idx].v_type != VAR_BLOB)\n    {\n\tsemsg(_(e_string_or_blob_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or a list.\n */\n    int\ncheck_for_string_or_list_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING && args[idx].v_type != VAR_LIST)\n    {\n\tsemsg(_(e_string_or_list_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string, a list or a\n * blob.\n */\n    int\ncheck_for_string_or_list_or_blob_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING\n\t    && args[idx].v_type != VAR_LIST\n\t    && args[idx].v_type != VAR_BLOB)\n    {\n\tsemsg(_(e_string_list_or_blob_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional string or list argument at 'idx'\n */\n    int\ncheck_for_opt_string_or_list_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_string_or_list_arg(args, idx));\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or a dict.\n */\n    int\ncheck_for_string_or_dict_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING && args[idx].v_type != VAR_DICT)\n    {\n\tsemsg(_(e_string_or_dict_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or a number\n * or a list.\n */\n    int\ncheck_for_string_or_number_or_list_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING\n\t    && args[idx].v_type != VAR_NUMBER\n\t    && args[idx].v_type != VAR_LIST)\n    {\n\tsemsg(_(e_string_number_or_list_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is an optional string\n * or number or a list\n */\n    int\ncheck_for_opt_string_or_number_or_list_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_string_or_number_or_list_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or a list\n * or a dict.\n */\n    int\ncheck_for_string_or_list_or_dict_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING\n\t    && args[idx].v_type != VAR_LIST\n\t    && args[idx].v_type != VAR_DICT)\n    {\n\tsemsg(_(e_string_list_or_dict_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string\n * or a function reference.\n */\n    int\ncheck_for_string_or_func_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_PARTIAL\n\t    && args[idx].v_type != VAR_FUNC\n\t    && args[idx].v_type != VAR_STRING)\n    {\n\tsemsg(_(e_string_or_function_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a list or a blob.\n */\n    int\ncheck_for_list_or_blob_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_LIST && args[idx].v_type != VAR_BLOB)\n    {\n\tsemsg(_(e_list_or_blob_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a list or dict\n */\n    int\ncheck_for_list_or_dict_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_LIST\n\t    && args[idx].v_type != VAR_DICT)\n    {\n\tsemsg(_(e_list_or_dict_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a list or dict or a\n * blob.\n */\n    int\ncheck_for_list_or_dict_or_blob_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_LIST\n\t    && args[idx].v_type != VAR_DICT\n\t    && args[idx].v_type != VAR_BLOB)\n    {\n\tsemsg(_(e_list_dict_or_blob_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a list or dict or a\n * blob or a string.\n */\n    int\ncheck_for_list_or_dict_or_blob_or_string_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_LIST\n\t    && args[idx].v_type != VAR_DICT\n\t    && args[idx].v_type != VAR_BLOB\n\t    && args[idx].v_type != VAR_STRING)\n    {\n\tsemsg(_(e_list_dict_blob_or_string_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is an optional buffer\n * number or a dict.\n */\n    int\ncheck_for_opt_buffer_or_dict_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_UNKNOWN\n\t    && args[idx].v_type != VAR_STRING\n\t    && args[idx].v_type != VAR_NUMBER\n\t    && args[idx].v_type != VAR_DICT)\n    {\n\tsemsg(_(e_string_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get the string value of a variable.\n * If it is a Number variable, the number is converted into a string.\n * tv_get_string() uses a single, static buffer.  YOU CAN ONLY USE IT ONCE!\n * tv_get_string_buf() uses a given buffer.\n * If the String variable has never been set, return an empty string.\n * Never returns NULL;\n * tv_get_string_chk() and tv_get_string_buf_chk() are similar, but return\n * NULL on error.\n */\n    char_u *\ntv_get_string(typval_T *varp)\n{\n    static char_u   mybuf[NUMBUFLEN];\n\n    return tv_get_string_buf(varp, mybuf);\n}\n\n/*\n * Like tv_get_string() but don't allow number to string conversion for Vim9.\n */\n    char_u *\ntv_get_string_strict(typval_T *varp)\n{\n    static char_u   mybuf[NUMBUFLEN];\n    char_u\t    *res =  tv_get_string_buf_chk_strict(\n\t\t\t\t\t\t varp, mybuf, in_vim9script());\n\n    return res != NULL ? res : (char_u *)\"\";\n}\n\n    char_u *\ntv_get_string_buf(typval_T *varp, char_u *buf)\n{\n    char_u\t*res = tv_get_string_buf_chk(varp, buf);\n\n    return res != NULL ? res : (char_u *)\"\";\n}\n\n/*\n * Careful: This uses a single, static buffer.  YOU CAN ONLY USE IT ONCE!\n */\n    char_u *\ntv_get_string_chk(typval_T *varp)\n{\n    static char_u   mybuf[NUMBUFLEN];\n\n    return tv_get_string_buf_chk(varp, mybuf);\n}\n\n    char_u *\ntv_get_string_buf_chk(typval_T *varp, char_u *buf)\n{\n    return tv_get_string_buf_chk_strict(varp, buf, FALSE);\n}\n\n    char_u *\ntv_get_string_buf_chk_strict(typval_T *varp, char_u *buf, int strict)\n{\n    switch (varp->v_type)\n    {\n\tcase VAR_NUMBER:\n\t    if (strict)\n\t    {\n\t\temsg(_(e_using_number_as_string));\n\t\tbreak;\n\t    }\n\t    vim_snprintf((char *)buf, NUMBUFLEN, \"%lld\",\n\t\t\t\t\t    (varnumber_T)varp->vval.v_number);\n\t    return buf;\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    emsg(_(e_using_funcref_as_string));\n\t    break;\n\tcase VAR_LIST:\n\t    emsg(_(e_using_list_as_string));\n\t    break;\n\tcase VAR_DICT:\n\t    emsg(_(e_using_dictionary_as_string));\n\t    break;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    if (strict)\n\t    {\n\t\temsg(_(e_using_float_as_string));\n\t\tbreak;\n\t    }\n\t    vim_snprintf((char *)buf, NUMBUFLEN, \"%g\", varp->vval.v_float);\n\t    return buf;\n#endif\n\tcase VAR_STRING:\n\t    if (varp->vval.v_string != NULL)\n\t\treturn varp->vval.v_string;\n\t    return (char_u *)\"\";\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    STRCPY(buf, get_var_special_name(varp->vval.v_number));\n\t    return buf;\n\tcase VAR_BLOB:\n\t    emsg(_(e_using_blob_as_string));\n\t    break;\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    if (in_vim9script())\n\t    {\n\t\tsemsg(_(e_using_invalid_value_as_string_str), \"job\");\n\t\tbreak;\n\t    }\n\t    return job_to_string_buf(varp, buf);\n#endif\n\t    break;\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    if (in_vim9script())\n\t    {\n\t\tsemsg(_(e_using_invalid_value_as_string_str), \"channel\");\n\t\tbreak;\n\t    }\n\t    return channel_to_string_buf(varp, buf);\n#endif\n\t    break;\n\tcase VAR_VOID:\n\t    emsg(_(e_cannot_use_void_value));\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_INSTR:\n\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t  vartype_name(varp->v_type));\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * Turn a typeval into a string.  Similar to tv_get_string_buf() but uses\n * string() on Dict, List, etc.\n */\n    char_u *\ntv_stringify(typval_T *varp, char_u *buf)\n{\n    if (varp->v_type == VAR_LIST\n\t    || varp->v_type == VAR_DICT\n\t    || varp->v_type == VAR_BLOB\n\t    || varp->v_type == VAR_FUNC\n\t    || varp->v_type == VAR_PARTIAL\n\t    || varp->v_type == VAR_FLOAT)\n    {\n\ttypval_T tmp;\n\n\tf_string(varp, &tmp);\n\ttv_get_string_buf(&tmp, buf);\n\tclear_tv(varp);\n\t*varp = tmp;\n\treturn tmp.vval.v_string;\n    }\n    return tv_get_string_buf(varp, buf);\n}\n\n/*\n * Return TRUE if typeval \"tv\" and its value are set to be locked (immutable).\n * Also give an error message, using \"name\" or _(\"name\") when use_gettext is\n * TRUE.\n */\n    int\ntv_check_lock(typval_T *tv, char_u *name, int use_gettext)\n{\n    int\tlock = 0;\n\n    switch (tv->v_type)\n    {\n\tcase VAR_BLOB:\n\t    if (tv->vval.v_blob != NULL)\n\t\tlock = tv->vval.v_blob->bv_lock;\n\t    break;\n\tcase VAR_LIST:\n\t    if (tv->vval.v_list != NULL)\n\t\tlock = tv->vval.v_list->lv_lock;\n\t    break;\n\tcase VAR_DICT:\n\t    if (tv->vval.v_dict != NULL)\n\t\tlock = tv->vval.v_dict->dv_lock;\n\t    break;\n\tdefault:\n\t    break;\n    }\n    return value_check_lock(tv->v_lock, name, use_gettext)\n\t\t   || (lock != 0 && value_check_lock(lock, name, use_gettext));\n}\n\n/*\n * Copy the values from typval_T \"from\" to typval_T \"to\".\n * When needed allocates string or increases reference count.\n * Does not make a copy of a list, blob or dict but copies the reference!\n * It is OK for \"from\" and \"to\" to point to the same item.  This is used to\n * make a copy later.\n */\n    void\ncopy_tv(typval_T *from, typval_T *to)\n{\n    to->v_type = from->v_type;\n    to->v_lock = 0;\n    switch (from->v_type)\n    {\n\tcase VAR_NUMBER:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    to->vval.v_number = from->vval.v_number;\n\t    break;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    to->vval.v_float = from->vval.v_float;\n\t    break;\n#endif\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    to->vval.v_job = from->vval.v_job;\n\t    if (to->vval.v_job != NULL)\n\t\t++to->vval.v_job->jv_refcount;\n\t    break;\n#endif\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    to->vval.v_channel = from->vval.v_channel;\n\t    if (to->vval.v_channel != NULL)\n\t\t++to->vval.v_channel->ch_refcount;\n\t    break;\n#endif\n\tcase VAR_INSTR:\n\t    to->vval.v_instr = from->vval.v_instr;\n\t    break;\n\n\tcase VAR_STRING:\n\tcase VAR_FUNC:\n\t    if (from->vval.v_string == NULL)\n\t\tto->vval.v_string = NULL;\n\t    else\n\t    {\n\t\tto->vval.v_string = vim_strsave(from->vval.v_string);\n\t\tif (from->v_type == VAR_FUNC)\n\t\t    func_ref(to->vval.v_string);\n\t    }\n\t    break;\n\tcase VAR_PARTIAL:\n\t    if (from->vval.v_partial == NULL)\n\t\tto->vval.v_partial = NULL;\n\t    else\n\t    {\n\t\tto->vval.v_partial = from->vval.v_partial;\n\t\t++to->vval.v_partial->pt_refcount;\n\t    }\n\t    break;\n\tcase VAR_BLOB:\n\t    if (from->vval.v_blob == NULL)\n\t\tto->vval.v_blob = NULL;\n\t    else\n\t    {\n\t\tto->vval.v_blob = from->vval.v_blob;\n\t\t++to->vval.v_blob->bv_refcount;\n\t    }\n\t    break;\n\tcase VAR_LIST:\n\t    if (from->vval.v_list == NULL)\n\t\tto->vval.v_list = NULL;\n\t    else\n\t    {\n\t\tto->vval.v_list = from->vval.v_list;\n\t\t++to->vval.v_list->lv_refcount;\n\t    }\n\t    break;\n\tcase VAR_DICT:\n\t    if (from->vval.v_dict == NULL)\n\t\tto->vval.v_dict = NULL;\n\t    else\n\t    {\n\t\tto->vval.v_dict = from->vval.v_dict;\n\t\t++to->vval.v_dict->dv_refcount;\n\t    }\n\t    break;\n\tcase VAR_VOID:\n\t    emsg(_(e_cannot_use_void_value));\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\t    internal_error_no_abort(\"copy_tv(UNKNOWN)\");\n\t    break;\n    }\n}\n\n/*\n * Compare \"tv1\" and \"tv2\".\n * Put the result in \"tv1\".  Caller should clear \"tv2\".\n */\n    int\ntypval_compare(\n    typval_T\t*tv1,\t// first operand\n    typval_T\t*tv2,\t// second operand\n    exprtype_T\ttype,   // operator\n    int\t\tic)     // ignore case\n{\n    varnumber_T\tn1, n2;\n    int\t\tres = 0;\n    int\t\ttype_is = type == EXPR_IS || type == EXPR_ISNOT;\n\n    if (type_is && tv1->v_type != tv2->v_type)\n    {\n\t// For \"is\" a different type always means FALSE, for \"notis\"\n\t// it means TRUE.\n\tn1 = (type == EXPR_ISNOT);\n    }\n    else if (((tv1->v_type == VAR_SPECIAL && tv1->vval.v_number == VVAL_NULL)\n\t\t|| (tv2->v_type == VAR_SPECIAL\n\t\t\t\t\t   && tv2->vval.v_number == VVAL_NULL))\n\t    && tv1->v_type != tv2->v_type\n\t    && (type == EXPR_EQUAL || type == EXPR_NEQUAL))\n    {\n\tn1 = typval_compare_null(tv1, tv2);\n\tif (n1 == MAYBE)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tif (type == EXPR_NEQUAL)\n\t    n1 = !n1;\n    }\n    else if (tv1->v_type == VAR_BLOB || tv2->v_type == VAR_BLOB)\n    {\n\tif (typval_compare_blob(tv1, tv2, type, &res) == FAIL)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = res;\n    }\n    else if (tv1->v_type == VAR_LIST || tv2->v_type == VAR_LIST)\n    {\n\tif (typval_compare_list(tv1, tv2, type, ic, &res) == FAIL)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = res;\n    }\n    else if (tv1->v_type == VAR_DICT || tv2->v_type == VAR_DICT)\n    {\n\tif (typval_compare_dict(tv1, tv2, type, ic, &res) == FAIL)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = res;\n    }\n    else if (tv1->v_type == VAR_FUNC || tv2->v_type == VAR_FUNC\n\t|| tv1->v_type == VAR_PARTIAL || tv2->v_type == VAR_PARTIAL)\n    {\n\tif (typval_compare_func(tv1, tv2, type, ic, &res) == FAIL)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = res;\n    }\n\n#ifdef FEAT_FLOAT\n    // If one of the two variables is a float, compare as a float.\n    // When using \"=~\" or \"!~\", always compare as string.\n    else if ((tv1->v_type == VAR_FLOAT || tv2->v_type == VAR_FLOAT)\n\t    && type != EXPR_MATCH && type != EXPR_NOMATCH)\n    {\n\tfloat_T f1, f2;\n\tint\terror = FALSE;\n\n\tf1 = tv_get_float_chk(tv1, &error);\n\tif (!error)\n\t    f2 = tv_get_float_chk(tv2, &error);\n\tif (error)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = FALSE;\n\tswitch (type)\n\t{\n\t    case EXPR_IS:\n\t    case EXPR_EQUAL:    n1 = (f1 == f2); break;\n\t    case EXPR_ISNOT:\n\t    case EXPR_NEQUAL:   n1 = (f1 != f2); break;\n\t    case EXPR_GREATER:  n1 = (f1 > f2); break;\n\t    case EXPR_GEQUAL:   n1 = (f1 >= f2); break;\n\t    case EXPR_SMALLER:  n1 = (f1 < f2); break;\n\t    case EXPR_SEQUAL:   n1 = (f1 <= f2); break;\n\t    case EXPR_UNKNOWN:\n\t    case EXPR_MATCH:\n\t    default:  break;  // avoid gcc warning\n\t}\n    }\n#endif\n\n    // If one of the two variables is a number, compare as a number.\n    // When using \"=~\" or \"!~\", always compare as string.\n    else if ((tv1->v_type == VAR_NUMBER || tv2->v_type == VAR_NUMBER)\n\t    && type != EXPR_MATCH && type != EXPR_NOMATCH)\n    {\n\tint error = FALSE;\n\n\tn1 = tv_get_number_chk(tv1, &error);\n\tif (!error)\n\t    n2 = tv_get_number_chk(tv2, &error);\n\tif (error)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tswitch (type)\n\t{\n\t    case EXPR_IS:\n\t    case EXPR_EQUAL:    n1 = (n1 == n2); break;\n\t    case EXPR_ISNOT:\n\t    case EXPR_NEQUAL:   n1 = (n1 != n2); break;\n\t    case EXPR_GREATER:  n1 = (n1 > n2); break;\n\t    case EXPR_GEQUAL:   n1 = (n1 >= n2); break;\n\t    case EXPR_SMALLER:  n1 = (n1 < n2); break;\n\t    case EXPR_SEQUAL:   n1 = (n1 <= n2); break;\n\t    case EXPR_UNKNOWN:\n\t    case EXPR_MATCH:\n\t    default:  break;  // avoid gcc warning\n\t}\n    }\n    else if (in_vim9script() && (tv1->v_type == VAR_BOOL\n\t\t\t\t    || tv2->v_type == VAR_BOOL\n\t\t\t\t    || (tv1->v_type == VAR_SPECIAL\n\t\t\t\t\t      && tv2->v_type == VAR_SPECIAL)))\n    {\n\tif (tv1->v_type != tv2->v_type)\n\t{\n\t    semsg(_(e_cannot_compare_str_with_str),\n\t\t       vartype_name(tv1->v_type), vartype_name(tv2->v_type));\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = tv1->vval.v_number;\n\tn2 = tv2->vval.v_number;\n\tswitch (type)\n\t{\n\t    case EXPR_IS:\n\t    case EXPR_EQUAL:    n1 = (n1 == n2); break;\n\t    case EXPR_ISNOT:\n\t    case EXPR_NEQUAL:   n1 = (n1 != n2); break;\n\t    default:\n\t\tsemsg(_(e_invalid_operation_for_str),\n\t\t\t\t\t\t   vartype_name(tv1->v_type));\n\t\tclear_tv(tv1);\n\t\treturn FAIL;\n\t}\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (tv1->v_type == tv2->v_type\n\t    && (tv1->v_type == VAR_CHANNEL || tv1->v_type == VAR_JOB)\n\t    && (type == EXPR_NEQUAL || type == EXPR_EQUAL))\n    {\n\tif (tv1->v_type == VAR_CHANNEL)\n\t    n1 = tv1->vval.v_channel == tv2->vval.v_channel;\n\telse\n\t    n1 = tv1->vval.v_job == tv2->vval.v_job;\n\tif (type == EXPR_NEQUAL)\n\t    n1 = !n1;\n    }\n#endif\n    else\n    {\n\tif (typval_compare_string(tv1, tv2, type, ic, &res) == FAIL)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = res;\n    }\n    clear_tv(tv1);\n    if (in_vim9script())\n    {\n\ttv1->v_type = VAR_BOOL;\n\ttv1->vval.v_number = n1 ? VVAL_TRUE : VVAL_FALSE;\n    }\n    else\n    {\n\ttv1->v_type = VAR_NUMBER;\n\ttv1->vval.v_number = n1;\n    }\n\n    return OK;\n}\n\n/*\n * Compare \"tv1\" to \"tv2\" as lists acording to \"type\" and \"ic\".\n * Put the result, false or true, in \"res\".\n * Return FAIL and give an error message when the comparison can't be done.\n */\n    int\ntypval_compare_list(\n\ttypval_T    *tv1,\n\ttypval_T    *tv2,\n\texprtype_T  type,\n\tint\t    ic,\n\tint\t    *res)\n{\n    int\t    val = 0;\n\n    if (type == EXPR_IS || type == EXPR_ISNOT)\n    {\n\tval = (tv1->v_type == tv2->v_type\n\t\t\t\t      && tv1->vval.v_list == tv2->vval.v_list);\n\tif (type == EXPR_ISNOT)\n\t    val = !val;\n    }\n    else if (tv1->v_type != tv2->v_type\n\t    || (type != EXPR_EQUAL && type != EXPR_NEQUAL))\n    {\n\tif (tv1->v_type != tv2->v_type)\n\t    emsg(_(e_can_only_compare_list_with_list));\n\telse\n\t    emsg(_(e_invalid_operation_for_list));\n\treturn FAIL;\n    }\n    else\n    {\n\tval = list_equal(tv1->vval.v_list, tv2->vval.v_list,\n\t\t\t\t\t\t\tic, FALSE);\n\tif (type == EXPR_NEQUAL)\n\t    val = !val;\n    }\n    *res = val;\n    return OK;\n}\n\n/*\n * Compare v:null with another type.  Return TRUE if the value is NULL.\n */\n    int\ntypval_compare_null(typval_T *tv1, typval_T *tv2)\n{\n    if ((tv1->v_type == VAR_SPECIAL && tv1->vval.v_number == VVAL_NULL)\n\t    || (tv2->v_type == VAR_SPECIAL && tv2->vval.v_number == VVAL_NULL))\n    {\n\ttypval_T\t*tv = tv1->v_type == VAR_SPECIAL ? tv2 : tv1;\n\n\tswitch (tv->v_type)\n\t{\n\t    case VAR_BLOB: return tv->vval.v_blob == NULL;\n#ifdef FEAT_JOB_CHANNEL\n\t    case VAR_CHANNEL: return tv->vval.v_channel == NULL;\n#endif\n\t    case VAR_DICT: return tv->vval.v_dict == NULL;\n\t    case VAR_FUNC: return tv->vval.v_string == NULL;\n#ifdef FEAT_JOB_CHANNEL\n\t    case VAR_JOB: return tv->vval.v_job == NULL;\n#endif\n\t    case VAR_LIST: return tv->vval.v_list == NULL;\n\t    case VAR_PARTIAL: return tv->vval.v_partial == NULL;\n\t    case VAR_STRING: return tv->vval.v_string == NULL;\n\n\t    case VAR_NUMBER: if (!in_vim9script())\n\t\t\t\t return tv->vval.v_number == 0;\n\t\t\t     break;\n#ifdef FEAT_FLOAT\n\t    case VAR_FLOAT: if (!in_vim9script())\n\t\t\t\t return tv->vval.v_float == 0.0;\n\t\t\t     break;\n#endif\n\t    default: break;\n\t}\n    }\n    // although comparing null with number, float or bool is not very useful\n    // we won't give an error\n    return FALSE;\n}\n\n/*\n * Compare \"tv1\" to \"tv2\" as blobs acording to \"type\".\n * Put the result, false or true, in \"res\".\n * Return FAIL and give an error message when the comparison can't be done.\n */\n    int\ntypval_compare_blob(\n\ttypval_T    *tv1,\n\ttypval_T    *tv2,\n\texprtype_T  type,\n\tint\t    *res)\n{\n    int\t    val = 0;\n\n    if (type == EXPR_IS || type == EXPR_ISNOT)\n    {\n\tval = (tv1->v_type == tv2->v_type\n\t\t\t&& tv1->vval.v_blob == tv2->vval.v_blob);\n\tif (type == EXPR_ISNOT)\n\t    val = !val;\n    }\n    else if (tv1->v_type != tv2->v_type\n\t    || (type != EXPR_EQUAL && type != EXPR_NEQUAL))\n    {\n\tif (tv1->v_type != tv2->v_type)\n\t    emsg(_(e_can_only_compare_blob_with_blob));\n\telse\n\t    emsg(_(e_invalid_operation_for_blob));\n\treturn FAIL;\n    }\n    else\n    {\n\tval = blob_equal(tv1->vval.v_blob, tv2->vval.v_blob);\n\tif (type == EXPR_NEQUAL)\n\t    val = !val;\n    }\n    *res = val;\n    return OK;\n}\n\n/*\n * Compare \"tv1\" to \"tv2\" as dictionaries acording to \"type\" and \"ic\".\n * Put the result, false or true, in \"res\".\n * Return FAIL and give an error message when the comparison can't be done.\n */\n    int\ntypval_compare_dict(\n\ttypval_T    *tv1,\n\ttypval_T    *tv2,\n\texprtype_T  type,\n\tint\t    ic,\n\tint\t    *res)\n{\n    int\t    val;\n\n    if (type == EXPR_IS || type == EXPR_ISNOT)\n    {\n\tval = (tv1->v_type == tv2->v_type\n\t\t\t&& tv1->vval.v_dict == tv2->vval.v_dict);\n\tif (type == EXPR_ISNOT)\n\t    val = !val;\n    }\n    else if (tv1->v_type != tv2->v_type\n\t\t|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))\n    {\n\tif (tv1->v_type != tv2->v_type)\n\t    emsg(_(e_can_only_compare_dictionary_with_dictionary));\n\telse\n\t    emsg(_(e_invalid_operation_for_dictionary));\n\treturn FAIL;\n    }\n    else\n    {\n\tval = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);\n\tif (type == EXPR_NEQUAL)\n\t    val = !val;\n    }\n    *res = val;\n    return OK;\n}\n\n/*\n * Compare \"tv1\" to \"tv2\" as funcrefs acording to \"type\" and \"ic\".\n * Put the result, false or true, in \"res\".\n * Return FAIL and give an error message when the comparison can't be done.\n */\n    int\ntypval_compare_func(\n\ttypval_T    *tv1,\n\ttypval_T    *tv2,\n\texprtype_T  type,\n\tint\t    ic,\n\tint\t    *res)\n{\n    int\t    val = 0;\n\n    if (type != EXPR_EQUAL && type != EXPR_NEQUAL\n\t    && type != EXPR_IS && type != EXPR_ISNOT)\n    {\n\temsg(_(e_invalid_operation_for_funcrefs));\n\treturn FAIL;\n    }\n    if ((tv1->v_type == VAR_PARTIAL && tv1->vval.v_partial == NULL)\n\t    || (tv2->v_type == VAR_PARTIAL && tv2->vval.v_partial == NULL))\n\t// When both partials are NULL, then they are equal.\n\t// Otherwise they are not equal.\n\tval = (tv1->vval.v_partial == tv2->vval.v_partial);\n    else if (type == EXPR_IS || type == EXPR_ISNOT)\n    {\n\tif (tv1->v_type == VAR_FUNC && tv2->v_type == VAR_FUNC)\n\t    // strings are considered the same if their value is\n\t    // the same\n\t    val = tv_equal(tv1, tv2, ic, FALSE);\n\telse if (tv1->v_type == VAR_PARTIAL && tv2->v_type == VAR_PARTIAL)\n\t    val = (tv1->vval.v_partial == tv2->vval.v_partial);\n\telse\n\t    val = FALSE;\n    }\n    else\n\tval = tv_equal(tv1, tv2, ic, FALSE);\n    if (type == EXPR_NEQUAL || type == EXPR_ISNOT)\n\tval = !val;\n    *res = val;\n    return OK;\n}\n\n/*\n * Compare \"tv1\" to \"tv2\" as strings according to \"type\" and \"ic\".\n * Put the result, false or true, in \"res\".\n * Return FAIL and give an error message when the comparison can't be done.\n */\n    int\ntypval_compare_string(\n\ttypval_T    *tv1,\n\ttypval_T    *tv2,\n\texprtype_T  type,\n\tint\t    ic,\n\tint\t    *res)\n{\n    int\t\ti = 0;\n    int\t\tval = FALSE;\n    char_u\t*s1, *s2;\n    char_u\tbuf1[NUMBUFLEN], buf2[NUMBUFLEN];\n\n    if (in_vim9script()\n\t  && ((tv1->v_type != VAR_STRING && tv1->v_type != VAR_SPECIAL)\n\t   || (tv2->v_type != VAR_STRING && tv2->v_type != VAR_SPECIAL)))\n    {\n\tsemsg(_(e_cannot_compare_str_with_str),\n\t\t   vartype_name(tv1->v_type), vartype_name(tv2->v_type));\n\treturn FAIL;\n    }\n    s1 = tv_get_string_buf(tv1, buf1);\n    s2 = tv_get_string_buf(tv2, buf2);\n    if (type != EXPR_MATCH && type != EXPR_NOMATCH)\n\ti = ic ? MB_STRICMP(s1, s2) : STRCMP(s1, s2);\n    switch (type)\n    {\n\tcase EXPR_IS:\t    if (in_vim9script())\n\t\t\t    {\n\t\t\t\t// Really check it is the same string, not just\n\t\t\t\t// the same value.\n\t\t\t\tval = tv1->vval.v_string == tv2->vval.v_string;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // FALLTHROUGH\n\tcase EXPR_EQUAL:    val = (i == 0); break;\n\tcase EXPR_ISNOT:    if (in_vim9script())\n\t\t\t    {\n\t\t\t\t// Really check it is not the same string, not\n\t\t\t\t// just a different value.\n\t\t\t\tval = tv1->vval.v_string != tv2->vval.v_string;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // FALLTHROUGH\n\tcase EXPR_NEQUAL:   val = (i != 0); break;\n\tcase EXPR_GREATER:  val = (i > 0); break;\n\tcase EXPR_GEQUAL:   val = (i >= 0); break;\n\tcase EXPR_SMALLER:  val = (i < 0); break;\n\tcase EXPR_SEQUAL:   val = (i <= 0); break;\n\n\tcase EXPR_MATCH:\n\tcase EXPR_NOMATCH:\n\t\tval = pattern_match(s2, s1, ic);\n\t\tif (type == EXPR_NOMATCH)\n\t\t    val = !val;\n\t\tbreak;\n\n\tdefault:  break;  // avoid gcc warning\n    }\n    *res = val;\n    return OK;\n}\n/*\n * Convert any type to a string, never give an error.\n * When \"quotes\" is TRUE add quotes to a string.\n * Returns an allocated string.\n */\n    char_u *\ntypval_tostring(typval_T *arg, int quotes)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*ret = NULL;\n\n    if (arg == NULL)\n\treturn vim_strsave((char_u *)\"(does not exist)\");\n    if (!quotes && arg->v_type == VAR_STRING)\n    {\n\tret = vim_strsave(arg->vval.v_string == NULL ? (char_u *)\"\"\n\t\t\t\t\t\t\t : arg->vval.v_string);\n    }\n    else\n    {\n\tret = tv2string(arg, &tofree, numbuf, 0);\n\t// Make a copy if we have a value but it's not in allocated memory.\n\tif (ret != NULL && tofree == NULL)\n\t    ret = vim_strsave(ret);\n    }\n    return ret;\n}\n\n/*\n * Return TRUE if typeval \"tv\" is locked: Either that value is locked itself\n * or it refers to a List or Dictionary that is locked.\n */\n    int\ntv_islocked(typval_T *tv)\n{\n    return (tv->v_lock & VAR_LOCKED)\n\t|| (tv->v_type == VAR_LIST\n\t\t&& tv->vval.v_list != NULL\n\t\t&& (tv->vval.v_list->lv_lock & VAR_LOCKED))\n\t|| (tv->v_type == VAR_DICT\n\t\t&& tv->vval.v_dict != NULL\n\t\t&& (tv->vval.v_dict->dv_lock & VAR_LOCKED));\n}\n\n    static int\nfunc_equal(\n    typval_T *tv1,\n    typval_T *tv2,\n    int\t     ic)\t    // ignore case\n{\n    char_u\t*s1, *s2;\n    dict_T\t*d1, *d2;\n    int\t\ta1, a2;\n    int\t\ti;\n\n    // empty and NULL function name considered the same\n    s1 = tv1->v_type == VAR_FUNC ? tv1->vval.v_string\n\t\t\t\t\t   : partial_name(tv1->vval.v_partial);\n    if (s1 != NULL && *s1 == NUL)\n\ts1 = NULL;\n    s2 = tv2->v_type == VAR_FUNC ? tv2->vval.v_string\n\t\t\t\t\t   : partial_name(tv2->vval.v_partial);\n    if (s2 != NULL && *s2 == NUL)\n\ts2 = NULL;\n    if (s1 == NULL || s2 == NULL)\n    {\n\tif (s1 != s2)\n\t    return FALSE;\n    }\n    else if (STRCMP(s1, s2) != 0)\n\treturn FALSE;\n\n    // empty dict and NULL dict is different\n    d1 = tv1->v_type == VAR_FUNC ? NULL : tv1->vval.v_partial->pt_dict;\n    d2 = tv2->v_type == VAR_FUNC ? NULL : tv2->vval.v_partial->pt_dict;\n    if (d1 == NULL || d2 == NULL)\n    {\n\tif (d1 != d2)\n\t    return FALSE;\n    }\n    else if (!dict_equal(d1, d2, ic, TRUE))\n\treturn FALSE;\n\n    // empty list and no list considered the same\n    a1 = tv1->v_type == VAR_FUNC ? 0 : tv1->vval.v_partial->pt_argc;\n    a2 = tv2->v_type == VAR_FUNC ? 0 : tv2->vval.v_partial->pt_argc;\n    if (a1 != a2)\n\treturn FALSE;\n    for (i = 0; i < a1; ++i)\n\tif (!tv_equal(tv1->vval.v_partial->pt_argv + i,\n\t\t      tv2->vval.v_partial->pt_argv + i, ic, TRUE))\n\t    return FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"tv1\" and \"tv2\" have the same value.\n * Compares the items just like \"==\" would compare them, but strings and\n * numbers are different.  Floats and numbers are also different.\n */\n    int\ntv_equal(\n    typval_T *tv1,\n    typval_T *tv2,\n    int\t     ic,\t    // ignore case\n    int\t     recursive)\t    // TRUE when used recursively\n{\n    char_u\tbuf1[NUMBUFLEN], buf2[NUMBUFLEN];\n    char_u\t*s1, *s2;\n    static int  recursive_cnt = 0;\t    // catch recursive loops\n    int\t\tr;\n    static int\ttv_equal_recurse_limit;\n\n    // Catch lists and dicts that have an endless loop by limiting\n    // recursiveness to a limit.  We guess they are equal then.\n    // A fixed limit has the problem of still taking an awful long time.\n    // Reduce the limit every time running into it. That should work fine for\n    // deeply linked structures that are not recursively linked and catch\n    // recursiveness quickly.\n    if (!recursive)\n\ttv_equal_recurse_limit = 1000;\n    if (recursive_cnt >= tv_equal_recurse_limit)\n    {\n\t--tv_equal_recurse_limit;\n\treturn TRUE;\n    }\n\n    // For VAR_FUNC and VAR_PARTIAL compare the function name, bound dict and\n    // arguments.\n    if ((tv1->v_type == VAR_FUNC\n\t\t|| (tv1->v_type == VAR_PARTIAL && tv1->vval.v_partial != NULL))\n\t    && (tv2->v_type == VAR_FUNC\n\t\t|| (tv2->v_type == VAR_PARTIAL && tv2->vval.v_partial != NULL)))\n    {\n\t++recursive_cnt;\n\tr = func_equal(tv1, tv2, ic);\n\t--recursive_cnt;\n\treturn r;\n    }\n\n    if (tv1->v_type != tv2->v_type\n\t    && ((tv1->v_type != VAR_BOOL && tv1->v_type != VAR_SPECIAL)\n\t\t|| (tv2->v_type != VAR_BOOL && tv2->v_type != VAR_SPECIAL)))\n\treturn FALSE;\n\n    switch (tv1->v_type)\n    {\n\tcase VAR_LIST:\n\t    ++recursive_cnt;\n\t    r = list_equal(tv1->vval.v_list, tv2->vval.v_list, ic, TRUE);\n\t    --recursive_cnt;\n\t    return r;\n\n\tcase VAR_DICT:\n\t    ++recursive_cnt;\n\t    r = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, TRUE);\n\t    --recursive_cnt;\n\t    return r;\n\n\tcase VAR_BLOB:\n\t    return blob_equal(tv1->vval.v_blob, tv2->vval.v_blob);\n\n\tcase VAR_NUMBER:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    return tv1->vval.v_number == tv2->vval.v_number;\n\n\tcase VAR_STRING:\n\t    s1 = tv_get_string_buf(tv1, buf1);\n\t    s2 = tv_get_string_buf(tv2, buf2);\n\t    return ((ic ? MB_STRICMP(s1, s2) : STRCMP(s1, s2)) == 0);\n\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    return tv1->vval.v_float == tv2->vval.v_float;\n#endif\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    return tv1->vval.v_job == tv2->vval.v_job;\n#endif\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    return tv1->vval.v_channel == tv2->vval.v_channel;\n#endif\n\tcase VAR_INSTR:\n\t    return tv1->vval.v_instr == tv2->vval.v_instr;\n\n\tcase VAR_PARTIAL:\n\t    return tv1->vval.v_partial == tv2->vval.v_partial;\n\n\tcase VAR_FUNC:\n\t    return tv1->vval.v_string == tv2->vval.v_string;\n\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    break;\n    }\n\n    // VAR_UNKNOWN can be the result of a invalid expression, let's say it\n    // does not equal anything, not even itself.\n    return FALSE;\n}\n\n/*\n * Get an option value.\n * \"arg\" points to the '&' or '+' before the option name.\n * \"arg\" is advanced to character after the option name.\n * Return OK or FAIL.\n */\n    int\neval_option(\n    char_u\t**arg,\n    typval_T\t*rettv,\t// when NULL, only check if option exists\n    int\t\tevaluate)\n{\n    char_u\t*option_end;\n    long\tnumval;\n    char_u\t*stringval;\n    getoption_T\topt_type;\n    int\t\tc;\n    int\t\tworking = (**arg == '+');    // has(\"+option\")\n    int\t\tret = OK;\n    int\t\tscope;\n\n    // Isolate the option name and find its value.\n    option_end = find_option_end(arg, &scope);\n    if (option_end == NULL)\n    {\n\tif (rettv != NULL)\n\t    semsg(_(e_option_name_missing_str), *arg);\n\treturn FAIL;\n    }\n\n    if (!evaluate)\n    {\n\t*arg = option_end;\n\treturn OK;\n    }\n\n    c = *option_end;\n    *option_end = NUL;\n    opt_type = get_option_value(*arg, &numval,\n\t\t\t       rettv == NULL ? NULL : &stringval, NULL, scope);\n\n    if (opt_type == gov_unknown)\n    {\n\tif (rettv != NULL)\n\t    semsg(_(e_unknown_option_str), *arg);\n\tret = FAIL;\n    }\n    else if (rettv != NULL)\n    {\n\trettv->v_lock = 0;\n\tif (opt_type == gov_hidden_string)\n\t{\n\t    rettv->v_type = VAR_STRING;\n\t    rettv->vval.v_string = NULL;\n\t}\n\telse if (opt_type == gov_hidden_bool || opt_type == gov_hidden_number)\n\t{\n\t    rettv->v_type = in_vim9script() && opt_type == gov_hidden_bool\n\t\t\t\t\t\t       ? VAR_BOOL : VAR_NUMBER;\n\t    rettv->vval.v_number = 0;\n\t}\n\telse if (opt_type == gov_bool || opt_type == gov_number)\n\t{\n\t    if (in_vim9script() && opt_type == gov_bool)\n\t    {\n\t\trettv->v_type = VAR_BOOL;\n\t\trettv->vval.v_number = numval ? VVAL_TRUE : VVAL_FALSE;\n\t    }\n\t    else\n\t    {\n\t\trettv->v_type = VAR_NUMBER;\n\t\trettv->vval.v_number = numval;\n\t    }\n\t}\n\telse\t\t\t\t// string option\n\t{\n\t    rettv->v_type = VAR_STRING;\n\t    rettv->vval.v_string = stringval;\n\t}\n    }\n    else if (working && (opt_type == gov_hidden_bool\n\t\t\t|| opt_type == gov_hidden_number\n\t\t\t|| opt_type == gov_hidden_string))\n\tret = FAIL;\n\n    *option_end = c;\t\t    // put back for error messages\n    *arg = option_end;\n\n    return ret;\n}\n\n/*\n * Allocate a variable for a number constant.  Also deals with \"0z\" for blob.\n * Return OK or FAIL.\n */\n    int\neval_number(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    evaluate,\n\tint\t    want_string UNUSED)\n{\n    int\t\tlen;\n    int\t\tskip_quotes = !in_old_script(4);\n#ifdef FEAT_FLOAT\n    char_u\t*p;\n    int\t\tget_float = FALSE;\n\n    // We accept a float when the format matches\n    // \"[0-9]\\+\\.[0-9]\\+\\([eE][+-]\\?[0-9]\\+\\)\\?\".  This is very\n    // strict to avoid backwards compatibility problems.\n    // With script version 2 and later the leading digit can be\n    // omitted.\n    // Don't look for a float after the \".\" operator, so that\n    // \":let vers = 1.2.3\" doesn't fail.\n    if (**arg == '.')\n\tp = *arg;\n    else\n    {\n\tp = *arg + 1;\n\tif (skip_quotes)\n\t    for (;;)\n\t    {\n\t\tif (*p == '\\'')\n\t\t    ++p;\n\t\tif (!vim_isdigit(*p))\n\t\t    break;\n\t\tp = skipdigits(p);\n\t    }\n\telse\n\t    p = skipdigits(p);\n    }\n    if (!want_string && p[0] == '.' && vim_isdigit(p[1]))\n    {\n\tget_float = TRUE;\n\tp = skipdigits(p + 2);\n\tif (*p == 'e' || *p == 'E')\n\t{\n\t    ++p;\n\t    if (*p == '-' || *p == '+')\n\t\t++p;\n\t    if (!vim_isdigit(*p))\n\t\tget_float = FALSE;\n\t    else\n\t\tp = skipdigits(p + 1);\n\t}\n\tif (ASCII_ISALPHA(*p) || *p == '.')\n\t    get_float = FALSE;\n    }\n    if (get_float)\n    {\n\tfloat_T\tf;\n\n\t*arg += string2float(*arg, &f, skip_quotes);\n\tif (evaluate)\n\t{\n\t    rettv->v_type = VAR_FLOAT;\n\t    rettv->vval.v_float = f;\n\t}\n    }\n    else\n#endif\n    if (**arg == '0' && ((*arg)[1] == 'z' || (*arg)[1] == 'Z'))\n    {\n\tchar_u  *bp;\n\tblob_T  *blob = NULL;  // init for gcc\n\n\t// Blob constant: 0z0123456789abcdef\n\tif (evaluate)\n\t    blob = blob_alloc();\n\tfor (bp = *arg + 2; vim_isxdigit(bp[0]); bp += 2)\n\t{\n\t    if (!vim_isxdigit(bp[1]))\n\t    {\n\t\tif (blob != NULL)\n\t\t{\n\t\t    emsg(_(e_blob_literal_should_have_an_even_number_of_hex_characters));\n\t\t    ga_clear(&blob->bv_ga);\n\t\t    VIM_CLEAR(blob);\n\t\t}\n\t\treturn FAIL;\n\t    }\n\t    if (blob != NULL)\n\t\tga_append(&blob->bv_ga,\n\t\t\t     (hex2nr(*bp) << 4) + hex2nr(*(bp+1)));\n\t    if (bp[2] == '.' && vim_isxdigit(bp[3]))\n\t\t++bp;\n\t}\n\tif (blob != NULL)\n\t    rettv_blob_set(rettv, blob);\n\t*arg = bp;\n    }\n    else\n    {\n\tvarnumber_T\tn;\n\n\t// decimal, hex or octal number\n\tvim_str2nr(*arg, NULL, &len, skip_quotes\n\t\t      ? STR2NR_NO_OCT + STR2NR_QUOTE\n\t\t      : STR2NR_ALL, &n, NULL, 0, TRUE);\n\tif (len == 0)\n\t{\n\t    if (evaluate)\n\t\tsemsg(_(e_invalid_expression_str), *arg);\n\t    return FAIL;\n\t}\n\t*arg += len;\n\tif (evaluate)\n\t{\n\t    rettv->v_type = VAR_NUMBER;\n\t    rettv->vval.v_number = n;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Evaluate a string constant and put the result in \"rettv\".\n * \"*arg\" points to the double quote or to after it when \"interpolate\" is TRUE.\n * When \"interpolate\" is TRUE reduce \"{{\" to \"{\", reduce \"}}\" to \"}\" and stop\n * at a single \"{\".\n * Return OK or FAIL.\n */\n    int\neval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t\textra += 5;\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}\n\n/*\n * Allocate a variable for a 'str''ing' constant.\n * When \"interpolate\" is TRUE reduce \"{{\" to \"{\" and stop at a single \"{\".\n * Return OK when a \"rettv\" was set to the string.\n * Return FAIL on error, \"rettv\" is not set.\n */\n    int\neval_lit_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*str;\n    int\t\treduce = interpolate ? -1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n\n    // Find the end of the string, skipping ''.\n    for (p = *arg + off; *p != NUL; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\'')\n\t{\n\t    if (p[1] != '\\'')\n\t\tbreak;\n\t    ++reduce;\n\t    ++p;\n\t}\n\telse if (interpolate)\n\t{\n\t    if (*p == '{')\n\t    {\n\t\tif (p[1] != '{')\n\t\t    break;\n\t\t++p;\n\t\t++reduce;\n\t    }\n\t    else if (*p == '}')\n\t    {\n\t\t++p;\n\t\tif (*p != '}')\n\t\t{\n\t\t    semsg(_(e_stray_closing_curly_str), *arg);\n\t\t    return FAIL;\n\t\t}\n\t\t++reduce;\n\t    }\n\t}\n    }\n\n    if (*p != '\\'' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_single_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing return after setting \"*arg\"\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling '' to ' reduction and\n    // any expressions.\n    str = alloc((p - *arg) - reduce);\n    if (str == NULL)\n\treturn FAIL;\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = str;\n\n    for (p = *arg + off; *p != NUL; )\n    {\n\tif (*p == '\\'')\n\t{\n\t    if (p[1] != '\\'')\n\t\tbreak;\n\t    ++p;\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{')\n\t\tbreak;\n\t    ++p;\n\t}\n\tMB_COPY_CHAR(p, str);\n    }\n    *str = NUL;\n    *arg = p + off;\n\n    return OK;\n}\n\n/*\n * Evaluate a single or double quoted string possibly containing expressions.\n * \"arg\" points to the '$'.  The result is put in \"rettv\".\n * Returns OK or FAIL.\n */\n    int\neval_interp_string(char_u **arg, typval_T *rettv, int evaluate)\n{\n    typval_T\ttv;\n    int\t\tret = OK;\n    int\t\tquote;\n    garray_T\tga;\n    char_u\t*p;\n\n    ga_init2(&ga, 1, 80);\n\n    // *arg is on the '$' character, move it to the first string character.\n    ++*arg;\n    quote = **arg;\n    ++*arg;\n\n    for (;;)\n    {\n\t// Get the string up to the matching quote or to a single '{'.\n\t// \"arg\" is advanced to either the quote or the '{'.\n\tif (quote == '\"')\n\t    ret = eval_string(arg, &tv, evaluate, TRUE);\n\telse\n\t    ret = eval_lit_string(arg, &tv, evaluate, TRUE);\n\tif (ret == FAIL)\n\t    break;\n\tif (evaluate)\n\t{\n\t    ga_concat(&ga, tv.vval.v_string);\n\t    clear_tv(&tv);\n\t}\n\n\tif (**arg != '{')\n\t{\n\t    // found terminating quote\n\t    ++*arg;\n\t    break;\n\t}\n\tp = eval_one_expr_in_str(*arg, &ga, evaluate);\n\tif (p == NULL)\n\t{\n\t    ret = FAIL;\n\t    break;\n\t}\n\t*arg = p;\n    }\n\n    rettv->v_type = VAR_STRING;\n    if (ret == FAIL || !evaluate || ga_append(&ga, NUL) == FAIL)\n    {\n\tga_clear(&ga);\n\trettv->vval.v_string = NULL;\n\treturn ret;\n    }\n\n    rettv->vval.v_string = ga.ga_data;\n    return OK;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * Puts quotes around strings, so that they can be parsed back by eval().\n * May return NULL.\n */\n    char_u *\ntv2string(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID)\n{\n    return echo_string_core(tv, tofree, numbuf, copyID, FALSE, TRUE, FALSE);\n}\n\n/*\n * Get the value of an environment variable.\n * \"arg\" is pointing to the '$'.  It is advanced to after the name.\n * If the environment variable was not set, silently assume it is empty.\n * Return FAIL if the name is invalid.\n */\n    int\neval_env_var(char_u **arg, typval_T *rettv, int evaluate)\n{\n    char_u\t*string = NULL;\n    int\t\tlen;\n    int\t\tcc;\n    char_u\t*name;\n    int\t\tmustfree = FALSE;\n\n    ++*arg;\n    name = *arg;\n    len = get_env_len(arg);\n    if (evaluate)\n    {\n\tif (len == 0)\n\t    return FAIL; // invalid empty name\n\n\tcc = name[len];\n\tname[len] = NUL;\n\t// first try vim_getenv(), fast for normal environment vars\n\tstring = vim_getenv(name, &mustfree);\n\tif (string != NULL && *string != NUL)\n\t{\n\t    if (!mustfree)\n\t\tstring = vim_strsave(string);\n\t}\n\telse\n\t{\n\t    if (mustfree)\n\t\tvim_free(string);\n\n\t    // next try expanding things like $VIM and ${HOME}\n\t    string = expand_env_save(name - 1);\n\t    if (string != NULL && *string == '$')\n\t\tVIM_CLEAR(string);\n\t}\n\tname[len] = cc;\n\n\trettv->v_type = VAR_STRING;\n\trettv->vval.v_string = string;\n\trettv->v_lock = 0;\n    }\n\n    return OK;\n}\n\n/*\n * Get the lnum from the first argument.\n * Also accepts \".\", \"$\", etc., but that only works for the current buffer.\n * Returns -1 on error.\n */\n    linenr_T\ntv_get_lnum(typval_T *argvars)\n{\n    linenr_T\tlnum = -1;\n\n    if (argvars[0].v_type != VAR_STRING || !in_vim9script())\n\tlnum = (linenr_T)tv_get_number_chk(&argvars[0], NULL);\n    if (lnum <= 0 && argvars[0].v_type != VAR_NUMBER)\n    {\n\tint\tfnum;\n\tpos_T\t*fp;\n\n\t// no valid number, try using arg like line()\n\tfp = var2fpos(&argvars[0], TRUE, &fnum, FALSE);\n\tif (fp != NULL)\n\t    lnum = fp->lnum;\n    }\n    return lnum;\n}\n\n/*\n * Get the lnum from the first argument.\n * Also accepts \"$\", then \"buf\" is used.\n * Returns 0 on error.\n */\n    linenr_T\ntv_get_lnum_buf(typval_T *argvars, buf_T *buf)\n{\n    if (argvars[0].v_type == VAR_STRING\n\t    && argvars[0].vval.v_string != NULL\n\t    && argvars[0].vval.v_string[0] == '$'\n\t    && argvars[0].vval.v_string[1] == NUL\n\t    && buf != NULL)\n\treturn buf->b_ml.ml_line_count;\n    return (linenr_T)tv_get_number_chk(&argvars[0], NULL);\n}\n\n/*\n * Get buffer by number or pattern.\n */\n    buf_T *\ntv_get_buf(typval_T *tv, int curtab_only)\n{\n    char_u\t*name = tv->vval.v_string;\n    buf_T\t*buf;\n\n    if (tv->v_type == VAR_NUMBER)\n\treturn buflist_findnr((int)tv->vval.v_number);\n    if (tv->v_type != VAR_STRING)\n\treturn NULL;\n    if (name == NULL || *name == NUL)\n\treturn curbuf;\n    if (name[0] == '$' && name[1] == NUL)\n\treturn lastbuf;\n\n    buf = buflist_find_by_name(name, curtab_only);\n\n    // If not found, try expanding the name, like done for bufexists().\n    if (buf == NULL)\n\tbuf = find_buffer(tv);\n\n    return buf;\n}\n\n/*\n * Like tv_get_buf() but give an error message is the type is wrong.\n */\n    buf_T *\ntv_get_buf_from_arg(typval_T *tv)\n{\n    buf_T *buf;\n\n    ++emsg_off;\n    buf = tv_get_buf(tv, FALSE);\n    --emsg_off;\n    if (buf == NULL\n\t    && tv->v_type != VAR_NUMBER\n\t    && tv->v_type != VAR_STRING)\n\t// issue errmsg for type error\n\t(void)tv_get_number(tv);\n    return buf;\n}\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["\" Tests for various eval things.\n\nsource view_util.vim\n\nfunction s:foo() abort\n  try\n    return [] == 0\n  catch\n    return 1\n  endtry\nendfunction\n\nfunc Test_catch_return_with_error()\n  call assert_equal(1, s:foo())\nendfunc\n\nfunc Test_nocatch_restore_silent_emsg()\n  silent! try\n    throw 1\n  catch\n  endtry\n  echoerr 'wrong again'\n  call assert_equal('wrong again', ScreenLine(&lines))\nendfunc\n\nfunc Test_mkdir_p()\n  call mkdir('Xmkdir/nested', 'p')\n  call assert_true(isdirectory('Xmkdir/nested'))\n  try\n    \" Trying to make existing directories doesn't error\n    call mkdir('Xmkdir', 'p')\n    call mkdir('Xmkdir/nested', 'p')\n  catch /E739:/\n    call assert_report('mkdir(..., \"p\") failed for an existing directory')\n  endtry\n  \" 'p' doesn't suppress real errors\n  call writefile([], 'Xfile')\n  call assert_fails('call mkdir(\"Xfile\", \"p\")', 'E739:')\n  call delete('Xfile')\n  call delete('Xmkdir', 'rf')\n  call assert_equal(0, mkdir(test_null_string()))\n  call assert_fails('call mkdir([])', 'E730:')\n  call assert_fails('call mkdir(\"abc\", [], [])', 'E745:')\nendfunc\n\nfunc Test_line_continuation()\n  let array = [5,\n\t\"\\ ignore this\n\t\\ 6,\n\t\"\\ more to ignore\n\t\"\\ more moreto ignore\n\t\\ ]\n\t\"\\ and some more\n  call assert_equal([5, 6], array)\nendfunc\n\nfunc Test_E963()\n  \" These commands used to cause an internal error prior to vim 8.1.0563\n  let v_e = v:errors\n  let v_o = v:oldfiles\n  call assert_fails(\"let v:errors=''\", 'E963:')\n  call assert_equal(v_e, v:errors)\n  call assert_fails(\"let v:oldfiles=''\", 'E963:')\n  call assert_equal(v_o, v:oldfiles)\nendfunc\n\nfunc Test_for_invalid()\n  call assert_fails(\"for x in 99\", 'E1098:')\n  call assert_fails(\"for x in function('winnr')\", 'E1098:')\n  call assert_fails(\"for x in {'a': 9}\", 'E1098:')\n\n  if 0\n    /1/5/2/s/\\n\n  endif\n  redraw\nendfunc\n\nfunc Test_readfile_binary()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  setlocal ff=dos\n  silent write XReadfile_bin\n  let lines = 'XReadfile_bin'->readfile()\n  call assert_equal(['one', 'two', 'three'], lines)\n  let lines = readfile('XReadfile_bin', '', 2)\n  call assert_equal(['one', 'two'], lines)\n  let lines = readfile('XReadfile_bin', 'b')\n  call assert_equal([\"one\\r\", \"two\\r\", \"three\\r\", \"\"], lines)\n  let lines = readfile('XReadfile_bin', 'b', 2)\n  call assert_equal([\"one\\r\", \"two\\r\"], lines)\n\n  bwipe!\n  call delete('XReadfile_bin')\nendfunc\n\nfunc Test_readfile_binary_empty()\n  call writefile([], 'Xempty-file')\n  \" This used to compare uninitialized memory in Vim <= 8.2.4065\n  call assert_equal([''], readfile('Xempty-file', 'b'))\n  call delete('Xempty-file')\nendfunc\n\nfunc Test_readfile_bom()\n  call writefile([\"\\ufeffFOO\", \"FOO\\ufeffBAR\"], 'XReadfile_bom')\n  call assert_equal(['FOO', 'FOOBAR'], readfile('XReadfile_bom'))\n  call delete('XReadfile_bom')\nendfunc\n\nfunc Test_readfile_max()\n  call writefile(range(1, 4), 'XReadfile_max')\n  call assert_equal(['1', '2'], readfile('XReadfile_max', '', 2))\n  call assert_equal(['3', '4'], readfile('XReadfile_max', '', -2))\n  call delete('XReadfile_max')\nendfunc\n\nfunc Test_let_errmsg()\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\nendfunc\n\nfunc Test_string_concatenation()\n  call assert_equal('ab', 'a'.'b')\n  call assert_equal('ab', 'a' .'b')\n  call assert_equal('ab', 'a'. 'b')\n  call assert_equal('ab', 'a' . 'b')\n\n  call assert_equal('ab', 'a'..'b')\n  call assert_equal('ab', 'a' ..'b')\n  call assert_equal('ab', 'a'.. 'b')\n  call assert_equal('ab', 'a' .. 'b')\n\n  let a = 'a'\n  let b = 'b'\n  let a .= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a.=b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a ..= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a..=b\n  call assert_equal('ab', a)\n\n  if has('float')\n    let a = 'A'\n    let b = 1.234\n    call assert_equal('A1.234', a .. b)\n  endif\nendfunc\n\n\" Test fix for issue #4507\nfunc Test_skip_after_throw()\n  try\n    throw 'something'\n    let x = wincol() || &ts\n  catch /something/\n  endtry\nendfunc\n\nscriptversion 2\nfunc Test_string_concat_scriptversion2()\n  call assert_true(has('vimscript-2'))\n  let a = 'a'\n  let b = 'b'\n\n  call assert_fails('echo a . b', 'E15:')\n  call assert_fails('let a .= b', 'E985:')\n  call assert_fails('let vers = 1.2.3', 'E488:')\n\n  if has('float')\n    let f = .5\n    call assert_equal(0.5, f)\n  endif\nendfunc\n\nscriptversion 1\nfunc Test_string_concat_scriptversion1()\n  call assert_true(has('vimscript-1'))\n  let a = 'a'\n  let b = 'b'\n\n  echo a . b\n  let a .= b\n  let vers = 1.2.3\n  call assert_equal('123', vers)\n\n  if has('float')\n    call assert_fails('let f = .5', 'E15:')\n  endif\nendfunc\n\nscriptversion 3\nfunc Test_vvar_scriptversion3()\n  call assert_true(has('vimscript-3'))\n  call assert_fails('echo version', 'E121:')\n  call assert_false(exists('version'))\n  let version = 1\n  call assert_equal(1, version)\nendfunc\n\nscriptversion 2\nfunc Test_vvar_scriptversion2()\n  call assert_true(exists('version'))\n  echo version\n  call assert_fails('let version = 1', 'E46:')\n  call assert_equal(v:version, version)\n\n  call assert_equal(v:version, v:versionlong / 10000)\n  call assert_true(v:versionlong > 8011525)\nendfunc\n\nfunc Test_dict_access_scriptversion2()\n  let l:x = {'foo': 1}\n\n  call assert_false(0 && l:x.foo)\n  call assert_true(1 && l:x.foo)\nendfunc\n\nscriptversion 4\nfunc Test_vvar_scriptversion4()\n  call assert_true(has('vimscript-4'))\n  call assert_equal(17, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\n  call assert_equal(64, 0b1'00'00'00)\n  call assert_equal(1048576, 0x10'00'00)\n  call assert_equal(32768, 0o10'00'00)\n  call assert_equal(1000000, 1'000'000)\n  call assert_equal(\"1234\", execute(\"echo 1'234\")->trim())\n  call assert_equal('1  234', execute(\"echo 1''234\")->trim())\n  call assert_fails(\"echo 1'''234\", 'E115:')\nendfunc\n\nscriptversion 1\nfunc Test_vvar_scriptversion1()\n  call assert_equal(15, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\nendfunc\n\nfunc Test_scriptversion_fail()\n  call writefile(['scriptversion 9'], 'Xversionscript')\n  call assert_fails('source Xversionscript', 'E999:')\n  call delete('Xversionscript')\nendfunc\n\nfunc Test_execute_cmd_with_null()\n  call assert_fails('execute test_null_list()', 'E730:')\n  call assert_fails('execute test_null_dict()', 'E731:')\n  call assert_fails('execute test_null_blob()', 'E976:')\n  execute test_null_string()\n  call assert_fails('execute test_null_partial()', 'E729:')\n  call assert_fails('execute test_unknown()', 'E908:')\n  if has('job')\n    call assert_fails('execute test_null_job()', 'E908:')\n    call assert_fails('execute test_null_channel()', 'E908:')\n  endif\nendfunc\n\nfunc Test_number_max_min_size()\n  \" This will fail on systems without 64 bit number support or when not\n  \" configured correctly.\n  call assert_equal(64, v:numbersize)\n\n  call assert_true(v:numbermin < -9999999)\n  call assert_true(v:numbermax > 9999999)\nendfunc\n\nfunc Assert_reg(name, type, value, valuestr, expr, exprstr)\n  call assert_equal(a:type, getregtype(a:name))\n  call assert_equal(a:value, getreg(a:name))\n  call assert_equal(a:valuestr, string(getreg(a:name, 0, 1)))\n  call assert_equal(a:expr, getreg(a:name, 1))\n  call assert_equal(a:exprstr, string(getreg(a:name, 1, 1)))\nendfunc\n\nfunc Test_let_register()\n  let @\" = 'abc'\n  call Assert_reg('\"', 'v', \"abc\", \"['abc']\", \"abc\", \"['abc']\")\n  let @\" = \"abc\\n\"\n  call Assert_reg('\"', 'V', \"abc\\n\", \"['abc']\", \"abc\\n\", \"['abc']\")\n  let @\" = \"abc\\<C-m>\"\n  call Assert_reg('\"', 'V', \"abc\\r\\n\", \"['abc\\r']\", \"abc\\r\\n\", \"['abc\\r']\")\n  let @= = '\"abc\"'\n  call Assert_reg('=', 'v', \"abc\", \"['abc']\", '\"abc\"', \"['\\\"abc\\\"']\")\nendfunc\n\nfunc Assert_regput(name, result)\n  new\n  execute \"silent normal! o==\\n==\\e\\\"\" . a:name . \"P\"\n  call assert_equal(a:result, getline(2, line('$')))\n  bwipe!\nendfunc\n\nfunc Test_setreg_basic()\n  call setreg('a', 'abcA', 'c')\n  call Assert_reg('a', 'v', \"abcA\", \"['abcA']\", \"abcA\", \"['abcA']\")\n  call Assert_regput('a', ['==', '=abcA='])\n\n  call setreg('A', 'abcAc', 'c')\n  call Assert_reg('A', 'v', \"abcAabcAc\", \"['abcAabcAc']\", \"abcAabcAc\", \"['abcAabcAc']\")\n  call Assert_regput('a', ['==', '=abcAabcAc='])\n\n  call setreg('A', 'abcAl', 'l')\n  call Assert_reg('A', 'V', \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\", \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\")\n  call Assert_regput('a', ['==', 'abcAabcAcabcAl', '=='])\n\n  call setreg('A', 'abcAc2','c')\n  call Assert_reg('A', 'v', \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\", \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\")\n  call Assert_regput('a', ['==', '=abcAabcAcabcAl', 'abcAc2='])\n\n  call setreg('b', 'abcB', 'v')\n  call Assert_reg('b', 'v', \"abcB\", \"['abcB']\", \"abcB\", \"['abcB']\")\n  call Assert_regput('b', ['==', '=abcB='])\n\n  call setreg('b', 'abcBc', 'ca')\n  call Assert_reg('b', 'v', \"abcBabcBc\", \"['abcBabcBc']\", \"abcBabcBc\", \"['abcBabcBc']\")\n  call Assert_regput('b', ['==', '=abcBabcBc='])\n\n  call setreg('b', 'abcBb', 'ba')\n  call Assert_reg('b', \"\\<C-V>5\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb='])\n\n  call setreg('b', 'abcBc2','ca')\n  call Assert_reg('b', \"v\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb', 'abcBc2='])\n\n  call setreg('b', 'abcBb2','b50a')\n  call Assert_reg('b', \"\\<C-V>50\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb                                    =', ' abcBc2abcBb2'])\n\n  call setreg('c', 'abcC', 'l')\n  call Assert_reg('c', 'V', \"abcC\\n\", \"['abcC']\", \"abcC\\n\", \"['abcC']\")\n  call Assert_regput('c', ['==', 'abcC', '=='])\n\n  call setreg('C', 'abcCl', 'l')\n  call Assert_reg('C', 'V', \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\", \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\")\n  call Assert_regput('c', ['==', 'abcC', 'abcCl', '=='])\n\n  call setreg('C', 'abcCc', 'c')\n  call Assert_reg('C', 'v', \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\", \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\")\n  call Assert_regput('c', ['==', '=abcC', 'abcCl', 'abcCc='])\n\n  call setreg('d', 'abcD', 'V')\n  call Assert_reg('d', 'V', \"abcD\\n\", \"['abcD']\", \"abcD\\n\", \"['abcD']\")\n  call Assert_regput('d', ['==', 'abcD', '=='])\n\n  call setreg('D', 'abcDb', 'b')\n  call Assert_reg('d', \"\\<C-V>5\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\")\n  call Assert_regput('d', ['==', '=abcD =', ' abcDb'])\n\n  call setreg('e', 'abcE', 'b')\n  call Assert_reg('e', \"\\<C-V>4\", \"abcE\", \"['abcE']\", \"abcE\", \"['abcE']\")\n  call Assert_regput('e', ['==', '=abcE='])\n\n  call setreg('E', 'abcEb', 'b')\n  call Assert_reg('E', \"\\<C-V>5\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\")\n  call Assert_regput('e', ['==', '=abcE =', ' abcEb'])\n\n  call setreg('E', 'abcEl', 'l')\n  call Assert_reg('E', \"V\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\")\n  call Assert_regput('e', ['==', 'abcE', 'abcEb', 'abcEl', '=='])\n\n  call setreg('f', 'abcF', \"\\<C-v>\")\n  call Assert_reg('f', \"\\<C-V>4\", \"abcF\", \"['abcF']\", \"abcF\", \"['abcF']\")\n  call Assert_regput('f', ['==', '=abcF='])\n\n  call setreg('F', 'abcFc', 'c')\n  call Assert_reg('F', \"v\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\")\n  call Assert_regput('f', ['==', '=abcF', 'abcFc='])\n\n  call setreg('g', 'abcG', 'b10')\n  call Assert_reg('g', \"\\<C-V>10\", \"abcG\", \"['abcG']\", \"abcG\", \"['abcG']\")\n  call Assert_regput('g', ['==', '=abcG      ='])\n\n  call setreg('h', 'abcH', \"\\<C-v>10\")\n  call Assert_reg('h', \"\\<C-V>10\", \"abcH\", \"['abcH']\", \"abcH\", \"['abcH']\")\n  call Assert_regput('h', ['==', '=abcH      ='])\n\n  call setreg('I', 'abcI')\n  call Assert_reg('I', \"v\", \"abcI\", \"['abcI']\", \"abcI\", \"['abcI']\")\n  call Assert_regput('I', ['==', '=abcI='])\n\n  \" Appending NL with setreg()\n  call setreg('a', 'abcA2', 'c')\n  call setreg('b', 'abcB2', 'v')\n  call setreg('c', 'abcC2', 'l')\n  call setreg('d', 'abcD2', 'V')\n  call setreg('e', 'abcE2', 'b')\n  call setreg('f', 'abcF2', \"\\<C-v>\")\n  call setreg('g', 'abcG2', 'b10')\n  call setreg('h', 'abcH2', \"\\<C-v>10\")\n  call setreg('I', 'abcI2')\n\n  call setreg('A', \"\\n\")\n  call Assert_reg('A', 'V', \"abcA2\\n\", \"['abcA2']\", \"abcA2\\n\", \"['abcA2']\")\n  call Assert_regput('A', ['==', 'abcA2', '=='])\n\n  call setreg('B', \"\\n\", 'c')\n  call Assert_reg('B', 'v', \"abcB2\\n\", \"['abcB2', '']\", \"abcB2\\n\", \"['abcB2', '']\")\n  call Assert_regput('B', ['==', '=abcB2', '='])\n\n  call setreg('C', \"\\n\")\n  call Assert_reg('C', 'V', \"abcC2\\n\\n\", \"['abcC2', '']\", \"abcC2\\n\\n\", \"['abcC2', '']\")\n  call Assert_regput('C', ['==', 'abcC2', '', '=='])\n\n  call setreg('D', \"\\n\", 'l')\n  call Assert_reg('D', 'V', \"abcD2\\n\\n\", \"['abcD2', '']\", \"abcD2\\n\\n\", \"['abcD2', '']\")\n  call Assert_regput('D', ['==', 'abcD2', '', '=='])\n\n  call setreg('E', \"\\n\")\n  call Assert_reg('E', 'V', \"abcE2\\n\\n\", \"['abcE2', '']\", \"abcE2\\n\\n\", \"['abcE2', '']\")\n  call Assert_regput('E', ['==', 'abcE2', '', '=='])\n\n  call setreg('F', \"\\n\", 'b')\n  call Assert_reg('F', \"\\<C-V>0\", \"abcF2\\n\", \"['abcF2', '']\", \"abcF2\\n\", \"['abcF2', '']\")\n  call Assert_regput('F', ['==', '=abcF2=', ' '])\n\n  \" Setting lists with setreg()\n  call setreg('a', ['abcA3'], 'c')\n  call Assert_reg('a', 'v', \"abcA3\", \"['abcA3']\", \"abcA3\", \"['abcA3']\")\n  call Assert_regput('a', ['==', '=abcA3='])\n\n  call setreg('b', ['abcB3'], 'l')\n  call Assert_reg('b', 'V', \"abcB3\\n\", \"['abcB3']\", \"abcB3\\n\", \"['abcB3']\")\n  call Assert_regput('b', ['==', 'abcB3', '=='])\n\n  call setreg('c', ['abcC3'], 'b')\n  call Assert_reg('c', \"\\<C-V>5\", \"abcC3\", \"['abcC3']\", \"abcC3\", \"['abcC3']\")\n  call Assert_regput('c', ['==', '=abcC3='])\n\n  call setreg('d', ['abcD3'])\n  call Assert_reg('d', 'V', \"abcD3\\n\", \"['abcD3']\", \"abcD3\\n\", \"['abcD3']\")\n  call Assert_regput('d', ['==', 'abcD3', '=='])\n\n  call setreg('e', [1, 2, 'abc', 3])\n  call Assert_reg('e', 'V', \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\", \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\")\n  call Assert_regput('e', ['==', '1', '2', 'abc', '3', '=='])\n\n  call setreg('f', [1, 2, 3])\n  call Assert_reg('f', 'V', \"1\\n2\\n3\\n\", \"['1', '2', '3']\", \"1\\n2\\n3\\n\", \"['1', '2', '3']\")\n  call Assert_regput('f', ['==', '1', '2', '3', '=='])\n\n  \" Appending lists with setreg()\n  call setreg('A', ['abcA3c'], 'c')\n  call Assert_reg('A', 'v', \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\", \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\")\n  call Assert_regput('A', ['==', '=abcA3', 'abcA3c='])\n\n  call setreg('b', ['abcB3l'], 'la')\n  call Assert_reg('b', 'V', \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\", \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\")\n  call Assert_regput('b', ['==', 'abcB3', 'abcB3l', '=='])\n\n  call setreg('C', ['abcC3b'], 'lb')\n  call Assert_reg('C', \"\\<C-V>6\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\")\n  call Assert_regput('C', ['==', '=abcC3 =', ' abcC3b'])\n\n  call setreg('D', ['abcD32'])\n  call Assert_reg('D', 'V', \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\", \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\")\n  call Assert_regput('D', ['==', 'abcD3', 'abcD32', '=='])\n\n  call setreg('A', ['abcA32'])\n  call Assert_reg('A', 'V', \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\", \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', '=='])\n\n  call setreg('B', ['abcB3c'], 'c')\n  call Assert_reg('B', 'v', \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\", \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c='])\n\n  call setreg('C', ['abcC3l'], 'l')\n  call Assert_reg('C', 'V', \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\", \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\")\n  call Assert_regput('C', ['==', 'abcC3', 'abcC3b', 'abcC3l', '=='])\n\n  call setreg('D', ['abcD3b'], 'b')\n  call Assert_reg('D', \"\\<C-V>6\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\")\n  call Assert_regput('D', ['==', '=abcD3 =', ' abcD32', ' abcD3b'])\n\n  \" Appending lists with NL with setreg()\n  call setreg('A', [\"\\n\", 'abcA3l2'], 'l')\n  call Assert_reg('A', \"V\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', \"\\n\", 'abcA3l2', '=='])\n\n  call setreg('B', [\"\\n\", 'abcB3c2'], 'c')\n  call Assert_reg('B', \"v\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c', \"\\n\", 'abcB3c2='])\n\n  call setreg('C', [\"\\n\", 'abcC3b2'], 'b')\n  call Assert_reg('C', \"\u00167\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\")\n  call Assert_regput('C', ['==', '=abcC3  =', ' abcC3b', ' abcC3l', \" \\n\", ' abcC3b2'])\n\n  call setreg('D', [\"\\n\", 'abcD3b50'],'b50')\n  call Assert_reg('D', \"\u001650\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\")\n  call Assert_regput('D', ['==', '=abcD3                                             =', ' abcD32', ' abcD3b', \" \\n\", ' abcD3b50'])\n\n  \" Setting lists with NLs with setreg()\n  call setreg('a', ['abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\"])\n  call Assert_reg('a', \"V\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\")\n  call Assert_regput('a', ['==', 'abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\", '=='])\n\n  call setreg('b', ['abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2\"], 'c')\n  call Assert_reg('b', \"v\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\")\n  call Assert_regput('b', ['==', '=abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2=\"])\n\n  call setreg('c', ['abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\"], 'l')\n  call Assert_reg('c', \"V\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\")\n  call Assert_regput('c', ['==', 'abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\", '=='])\n\n  call setreg('d', ['abcD4b-0', \"\\n\", \"abcD4b-2\\n\", \"\\nabcD4b-3\", \"abcD4b-4\\nabcD4b-4-2\"], 'b')\n  call Assert_reg('d', \"\u001619\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\")\n  call Assert_regput('d', ['==', '=abcD4b-0           =', \" \\n\", \" abcD4b-2\\n\", \" \\nabcD4b-3\", \" abcD4b-4\\nabcD4b-4-2\"])\n\n  call setreg('e', ['abcE4b10-0', \"\\n\", \"abcE4b10-2\\n\", \"\\nabcE4b10-3\", \"abcE4b10-4\\nabcE4b10-4-2\"], 'b10')\n  call Assert_reg('e', \"\u001610\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\")\n  call Assert_regput('e', ['==', '=abcE4b10-0=', \" \\n\", \" abcE4b10-2\\n\", \" \\nabcE4b10-3\", \" abcE4b10-4\\nabcE4b10-4-2\"])\n\n  \" Search and expressions\n  call setreg('/', ['abc/'])\n  call Assert_reg('/', 'v', \"abc/\", \"['abc/']\", \"abc/\", \"['abc/']\")\n  call Assert_regput('/', ['==', '=abc/='])\n\n  call setreg('/', [\"abc/\\n\"])\n  call Assert_reg('/', 'v', \"abc/\\n\", \"['abc/\\n']\", \"abc/\\n\", \"['abc/\\n']\")\n  call Assert_regput('/', ['==', \"=abc/\\n=\"])\n\n  call setreg('=', ['\"abc/\"'])\n  call Assert_reg('=', 'v', \"abc/\", \"['abc/']\", '\"abc/\"', \"['\\\"abc/\\\"']\")\n\n  call setreg('=', [\"\\\"abc/\\n\\\"\"])\n  call Assert_reg('=', 'v', \"abc/\\n\", \"['abc/\\n']\", \"\\\"abc/\\n\\\"\", \"['\\\"abc/\\n\\\"']\")\n\n  \" System clipboard\n  if has('clipboard')\n    new | only!\n    call setline(1, ['clipboard contents', 'something else'])\n    \" Save and restore system clipboard.\n    \" If no connection to X-Server is possible, test should succeed.\n    let _clipreg = ['*', getreg('*'), getregtype('*')]\n    let _clipopt = &cb\n    let &cb='unnamed'\n    1y\n    call Assert_reg('*', 'V', \"clipboard contents\\n\", \"['clipboard contents']\", \"clipboard contents\\n\", \"['clipboard contents']\")\n    tabdo :windo :echo \"hi\"\n    2y\n    call Assert_reg('*', 'V', \"something else\\n\", \"['something else']\", \"something else\\n\", \"['something else']\")\n    let &cb=_clipopt\n    call call('setreg', _clipreg)\n    enew!\n  endif\n\n  \" Error cases\n  call assert_fails('call setreg()', 'E119:')\n  call assert_fails('call setreg(1)', 'E119:')\n  call assert_fails('call setreg(1, 2, 3, 4)', 'E118:')\n  call assert_fails('call setreg([], 2)', 'E730:')\n  call assert_fails('call setreg(1, 2, [])', 'E730:')\n  call assert_fails('call setreg(\"/\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(\"=\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(1, [\"\", \"\", [], \"\"])', 'E730:')\nendfunc\n\nfunc Test_curly_assignment()\n  let s:svar = 'svar'\n  let g:gvar = 'gvar'\n  let lname = 'gvar'\n  let gname = 'gvar'\n  let {'s:'.lname} = {'g:'.gname}\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:'.lname } = { 'g:'.gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' . lname } = { 'g:' . gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' .. lname } = { 'g:' .. gname }\n  call assert_equal('gvar', s:gvar)\n\n  unlet s:svar\n  unlet s:gvar\n  unlet g:gvar\nendfunc\n\nfunc Test_deep_recursion()\n  \" this was running out of stack\n  call assert_fails(\"exe 'if ' .. repeat('(', 1002)\", 'E1169: Expression too recursive: ((')\nendfunc\n\n\" K_SPECIAL in the modified character used be escaped, which causes\n\" double-escaping with feedkeys() or as the return value of an <expr> mapping,\n\" and doesn't match what getchar() returns,\nfunc Test_modified_char_no_escape_special()\n  nnoremap <M-\u2026> <Cmd>let g:got_m_ellipsis += 1<CR>\n  call feedkeys(\"\\<M-\u2026>\", 't')\n  call assert_equal(\"\\<M-\u2026>\", getchar())\n  let g:got_m_ellipsis = 0\n  call feedkeys(\"\\<M-\u2026>\", 'xt')\n  call assert_equal(1, g:got_m_ellipsis)\n  func Func()\n    return \"\\<M-\u2026>\"\n  endfunc\n  nmap <expr> <F2> Func()\n  call feedkeys(\"\\<F2>\", 'xt')\n  call assert_equal(2, g:got_m_ellipsis)\n  delfunc Func\n  nunmap <F2>\n  unlet g:got_m_ellipsis\n  nunmap <M-\u2026>\nendfunc\n\nfunc Test_eval_string_in_special_key()\n  \" this was using the '{' inside <> as the start of an interpolated string\n  silent! echo 0{1-$\"\\<S--{>\u0017n|n\u00f6%\u0000\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * typval.c: functions that deal with a typval\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Allocate memory for a variable type-value, and make it empty (0 or NULL\n * value).\n */\n    typval_T *\nalloc_tv(void)\n{\n    return ALLOC_CLEAR_ONE(typval_T);\n}\n\n/*\n * Allocate memory for a variable type-value, and assign a string to it.\n * The string \"s\" must have been allocated, it is consumed.\n * Return NULL for out of memory, the variable otherwise.\n */\n    typval_T *\nalloc_string_tv(char_u *s)\n{\n    typval_T\t*rettv;\n\n    rettv = alloc_tv();\n    if (rettv != NULL)\n    {\n\trettv->v_type = VAR_STRING;\n\trettv->vval.v_string = s;\n    }\n    else\n\tvim_free(s);\n    return rettv;\n}\n\n/*\n * Free the memory for a variable type-value.\n */\n    void\nfree_tv(typval_T *varp)\n{\n    if (varp != NULL)\n    {\n\tswitch (varp->v_type)\n\t{\n\t    case VAR_FUNC:\n\t\tfunc_unref(varp->vval.v_string);\n\t\t// FALLTHROUGH\n\t    case VAR_STRING:\n\t\tvim_free(varp->vval.v_string);\n\t\tbreak;\n\t    case VAR_PARTIAL:\n\t\tpartial_unref(varp->vval.v_partial);\n\t\tbreak;\n\t    case VAR_BLOB:\n\t\tblob_unref(varp->vval.v_blob);\n\t\tbreak;\n\t    case VAR_LIST:\n\t\tlist_unref(varp->vval.v_list);\n\t\tbreak;\n\t    case VAR_DICT:\n\t\tdict_unref(varp->vval.v_dict);\n\t\tbreak;\n\t    case VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\tjob_unref(varp->vval.v_job);\n\t\tbreak;\n#endif\n\t    case VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\tchannel_unref(varp->vval.v_channel);\n\t\tbreak;\n#endif\n\t    case VAR_NUMBER:\n\t    case VAR_FLOAT:\n\t    case VAR_ANY:\n\t    case VAR_UNKNOWN:\n\t    case VAR_VOID:\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t    case VAR_INSTR:\n\t\tbreak;\n\t}\n\tvim_free(varp);\n    }\n}\n\n/*\n * Free the memory for a variable value and set the value to NULL or 0.\n */\n    void\nclear_tv(typval_T *varp)\n{\n    if (varp != NULL)\n    {\n\tswitch (varp->v_type)\n\t{\n\t    case VAR_FUNC:\n\t\tfunc_unref(varp->vval.v_string);\n\t\t// FALLTHROUGH\n\t    case VAR_STRING:\n\t\tVIM_CLEAR(varp->vval.v_string);\n\t\tbreak;\n\t    case VAR_PARTIAL:\n\t\tpartial_unref(varp->vval.v_partial);\n\t\tvarp->vval.v_partial = NULL;\n\t\tbreak;\n\t    case VAR_BLOB:\n\t\tblob_unref(varp->vval.v_blob);\n\t\tvarp->vval.v_blob = NULL;\n\t\tbreak;\n\t    case VAR_LIST:\n\t\tlist_unref(varp->vval.v_list);\n\t\tvarp->vval.v_list = NULL;\n\t\tbreak;\n\t    case VAR_DICT:\n\t\tdict_unref(varp->vval.v_dict);\n\t\tvarp->vval.v_dict = NULL;\n\t\tbreak;\n\t    case VAR_NUMBER:\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t\tvarp->vval.v_number = 0;\n\t\tbreak;\n\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\tvarp->vval.v_float = 0.0;\n\t\tbreak;\n#endif\n\t    case VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\tjob_unref(varp->vval.v_job);\n\t\tvarp->vval.v_job = NULL;\n#endif\n\t\tbreak;\n\t    case VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\tchannel_unref(varp->vval.v_channel);\n\t\tvarp->vval.v_channel = NULL;\n#endif\n\t\tbreak;\n\t    case VAR_INSTR:\n\t\tVIM_CLEAR(varp->vval.v_instr);\n\t\tbreak;\n\t    case VAR_UNKNOWN:\n\t    case VAR_ANY:\n\t    case VAR_VOID:\n\t\tbreak;\n\t}\n\tvarp->v_lock = 0;\n    }\n}\n\n/*\n * Set the value of a variable to NULL without freeing items.\n */\n    void\ninit_tv(typval_T *varp)\n{\n    if (varp != NULL)\n\tCLEAR_POINTER(varp);\n}\n\n    static varnumber_T\ntv_get_bool_or_number_chk(typval_T *varp, int *denote, int want_bool)\n{\n    varnumber_T\tn = 0L;\n\n    switch (varp->v_type)\n    {\n\tcase VAR_NUMBER:\n\t    if (in_vim9script() && want_bool && varp->vval.v_number != 0\n\t\t\t\t\t\t   && varp->vval.v_number != 1)\n\t    {\n\t\tsemsg(_(e_using_number_as_bool_nr), varp->vval.v_number);\n\t\tbreak;\n\t    }\n\t    return varp->vval.v_number;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    emsg(_(e_using_float_as_number));\n\t    break;\n#endif\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    emsg(_(e_using_funcref_as_number));\n\t    break;\n\tcase VAR_STRING:\n\t    if (in_vim9script())\n\t    {\n\t\temsg_using_string_as(varp, !want_bool);\n\t\tbreak;\n\t    }\n\t    if (varp->vval.v_string != NULL)\n\t\tvim_str2nr(varp->vval.v_string, NULL, NULL,\n\t\t\t\t\t    STR2NR_ALL, &n, NULL, 0, FALSE);\n\t    return n;\n\tcase VAR_LIST:\n\t    emsg(_(e_using_list_as_number));\n\t    break;\n\tcase VAR_DICT:\n\t    emsg(_(e_using_dictionary_as_number));\n\t    break;\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    if (!want_bool && in_vim9script())\n\t    {\n\t\tif (varp->v_type == VAR_BOOL)\n\t\t    emsg(_(e_using_bool_as_number));\n\t\telse\n\t\t    emsg(_(e_using_special_as_number));\n\t\tbreak;\n\t    }\n\t    return varp->vval.v_number == VVAL_TRUE ? 1 : 0;\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    emsg(_(e_using_job_as_number));\n\t    break;\n#endif\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    emsg(_(e_using_channel_as_number));\n\t    break;\n#endif\n\tcase VAR_BLOB:\n\t    emsg(_(e_using_blob_as_number));\n\t    break;\n\tcase VAR_VOID:\n\t    emsg(_(e_cannot_use_void_value));\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_INSTR:\n\t    internal_error_no_abort(\"tv_get_number(UNKNOWN)\");\n\t    break;\n    }\n    if (denote == NULL)\t\t// useful for values that must be unsigned\n\tn = -1;\n    else\n\t*denote = TRUE;\n    return n;\n}\n\n/*\n * Get the number value of a variable.\n * If it is a String variable, uses vim_str2nr().\n * For incompatible types, return 0.\n * tv_get_number_chk() is similar to tv_get_number(), but informs the\n * caller of incompatible types: it sets *denote to TRUE if \"denote\"\n * is not NULL or returns -1 otherwise.\n */\n    varnumber_T\ntv_get_number(typval_T *varp)\n{\n    int\t\terror = FALSE;\n\n    return tv_get_number_chk(varp, &error);\t// return 0L on error\n}\n\n    varnumber_T\ntv_get_number_chk(typval_T *varp, int *denote)\n{\n    return tv_get_bool_or_number_chk(varp, denote, FALSE);\n}\n\n/*\n * Get the boolean value of \"varp\".  This is like tv_get_number_chk(),\n * but in Vim9 script accepts Number (0 and 1) and Bool/Special.\n */\n    varnumber_T\ntv_get_bool(typval_T *varp)\n{\n    return tv_get_bool_or_number_chk(varp, NULL, TRUE);\n}\n\n/*\n * Get the boolean value of \"varp\".  This is like tv_get_number_chk(),\n * but in Vim9 script accepts Number and Bool.\n */\n    varnumber_T\ntv_get_bool_chk(typval_T *varp, int *denote)\n{\n    return tv_get_bool_or_number_chk(varp, denote, TRUE);\n}\n\n#if defined(FEAT_FLOAT) || defined(PROTO)\n    static float_T\ntv_get_float_chk(typval_T *varp, int *error)\n{\n    switch (varp->v_type)\n    {\n\tcase VAR_NUMBER:\n\t    return (float_T)(varp->vval.v_number);\n\tcase VAR_FLOAT:\n\t    return varp->vval.v_float;\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    emsg(_(e_using_funcref_as_float));\n\t    break;\n\tcase VAR_STRING:\n\t    emsg(_(e_using_string_as_float));\n\t    break;\n\tcase VAR_LIST:\n\t    emsg(_(e_using_list_as_float));\n\t    break;\n\tcase VAR_DICT:\n\t    emsg(_(e_using_dictionary_as_float));\n\t    break;\n\tcase VAR_BOOL:\n\t    emsg(_(e_using_boolean_value_as_float));\n\t    break;\n\tcase VAR_SPECIAL:\n\t    emsg(_(e_using_special_value_as_float));\n\t    break;\n\tcase VAR_JOB:\n# ifdef FEAT_JOB_CHANNEL\n\t    emsg(_(e_using_job_as_float));\n\t    break;\n# endif\n\tcase VAR_CHANNEL:\n# ifdef FEAT_JOB_CHANNEL\n\t    emsg(_(e_using_channel_as_float));\n\t    break;\n# endif\n\tcase VAR_BLOB:\n\t    emsg(_(e_using_blob_as_float));\n\t    break;\n\tcase VAR_VOID:\n\t    emsg(_(e_cannot_use_void_value));\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_INSTR:\n\t    internal_error_no_abort(\"tv_get_float(UNKNOWN)\");\n\t    break;\n    }\n    if (error != NULL)\n\t*error = TRUE;\n    return 0;\n}\n\n    float_T\ntv_get_float(typval_T *varp)\n{\n    return tv_get_float_chk(varp, NULL);\n}\n#endif\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is unknown\n */\n    int\ncheck_for_unknown_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_UNKNOWN)\n    {\n\tsemsg(_(e_too_many_arguments), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string.\n */\n    int\ncheck_for_string_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING)\n    {\n\tsemsg(_(e_string_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a non-empty string.\n */\n    int\ncheck_for_nonempty_string_arg(typval_T *args, int idx)\n{\n    if (check_for_string_arg(args, idx) == FAIL)\n\treturn FAIL;\n    if (args[idx].vval.v_string == NULL || *args[idx].vval.v_string == NUL)\n    {\n\tsemsg(_(e_non_empty_string_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional string argument at 'idx'\n */\n    int\ncheck_for_opt_string_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_string_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a number.\n */\n    int\ncheck_for_number_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_NUMBER)\n    {\n\tsemsg(_(e_number_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional number argument at 'idx'\n */\n    int\ncheck_for_opt_number_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_number_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a float or a number.\n */\n    int\ncheck_for_float_or_nr_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_FLOAT && args[idx].v_type != VAR_NUMBER)\n    {\n\tsemsg(_(e_float_or_number_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a bool.\n */\n    int\ncheck_for_bool_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_BOOL\n\t    && !(args[idx].v_type == VAR_NUMBER\n\t\t&& (args[idx].vval.v_number == 0\n\t\t    || args[idx].vval.v_number == 1)))\n    {\n\tsemsg(_(e_bool_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional bool argument at 'idx'.\n * Return FAIL if the type is wrong.\n */\n    int\ncheck_for_opt_bool_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type == VAR_UNKNOWN)\n\treturn OK;\n    return check_for_bool_arg(args, idx);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a blob.\n */\n    int\ncheck_for_blob_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_BLOB)\n    {\n\tsemsg(_(e_blob_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a list.\n */\n    int\ncheck_for_list_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_LIST)\n    {\n\t    semsg(_(e_list_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional list argument at 'idx'\n */\n    int\ncheck_for_opt_list_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_list_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a dict.\n */\n    int\ncheck_for_dict_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_DICT)\n    {\n\tsemsg(_(e_dict_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional dict argument at 'idx'\n */\n    int\ncheck_for_opt_dict_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_dict_arg(args, idx) != FAIL);\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a channel or a job.\n */\n    int\ncheck_for_chan_or_job_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_CHANNEL && args[idx].v_type != VAR_JOB)\n    {\n\tsemsg(_(e_chan_or_job_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is an optional channel or a\n * job.\n */\n    int\ncheck_for_opt_chan_or_job_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_chan_or_job_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a job.\n */\n    int\ncheck_for_job_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_JOB)\n    {\n\tsemsg(_(e_job_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional job argument at 'idx'.\n */\n    int\ncheck_for_opt_job_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_job_arg(args, idx) != FAIL);\n}\n#endif\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or\n * a number.\n */\n    int\ncheck_for_string_or_number_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING && args[idx].v_type != VAR_NUMBER)\n    {\n\tsemsg(_(e_string_or_number_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional string or number argument at 'idx'.\n */\n    int\ncheck_for_opt_string_or_number_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_string_or_number_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a buffer number.\n * Buffer number can be a number or a string.\n */\n    int\ncheck_for_buffer_arg(typval_T *args, int idx)\n{\n    return check_for_string_or_number_arg(args, idx);\n}\n\n/*\n * Check for an optional buffer argument at 'idx'\n */\n    int\ncheck_for_opt_buffer_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_buffer_arg(args, idx));\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a line number.\n * Line number can be a number or a string.\n */\n    int\ncheck_for_lnum_arg(typval_T *args, int idx)\n{\n    return check_for_string_or_number_arg(args, idx);\n}\n\n/*\n * Check for an optional line number argument at 'idx'\n */\n    int\ncheck_for_opt_lnum_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_lnum_arg(args, idx));\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or a blob.\n */\n    int\ncheck_for_string_or_blob_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING && args[idx].v_type != VAR_BLOB)\n    {\n\tsemsg(_(e_string_or_blob_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or a list.\n */\n    int\ncheck_for_string_or_list_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING && args[idx].v_type != VAR_LIST)\n    {\n\tsemsg(_(e_string_or_list_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string, a list or a\n * blob.\n */\n    int\ncheck_for_string_or_list_or_blob_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING\n\t    && args[idx].v_type != VAR_LIST\n\t    && args[idx].v_type != VAR_BLOB)\n    {\n\tsemsg(_(e_string_list_or_blob_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check for an optional string or list argument at 'idx'\n */\n    int\ncheck_for_opt_string_or_list_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_string_or_list_arg(args, idx));\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or a dict.\n */\n    int\ncheck_for_string_or_dict_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING && args[idx].v_type != VAR_DICT)\n    {\n\tsemsg(_(e_string_or_dict_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or a number\n * or a list.\n */\n    int\ncheck_for_string_or_number_or_list_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING\n\t    && args[idx].v_type != VAR_NUMBER\n\t    && args[idx].v_type != VAR_LIST)\n    {\n\tsemsg(_(e_string_number_or_list_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is an optional string\n * or number or a list\n */\n    int\ncheck_for_opt_string_or_number_or_list_arg(typval_T *args, int idx)\n{\n    return (args[idx].v_type == VAR_UNKNOWN\n\t    || check_for_string_or_number_or_list_arg(args, idx) != FAIL);\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string or a list\n * or a dict.\n */\n    int\ncheck_for_string_or_list_or_dict_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_STRING\n\t    && args[idx].v_type != VAR_LIST\n\t    && args[idx].v_type != VAR_DICT)\n    {\n\tsemsg(_(e_string_list_or_dict_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a string\n * or a function reference.\n */\n    int\ncheck_for_string_or_func_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_PARTIAL\n\t    && args[idx].v_type != VAR_FUNC\n\t    && args[idx].v_type != VAR_STRING)\n    {\n\tsemsg(_(e_string_or_function_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a list or a blob.\n */\n    int\ncheck_for_list_or_blob_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_LIST && args[idx].v_type != VAR_BLOB)\n    {\n\tsemsg(_(e_list_or_blob_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a list or dict\n */\n    int\ncheck_for_list_or_dict_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_LIST\n\t    && args[idx].v_type != VAR_DICT)\n    {\n\tsemsg(_(e_list_or_dict_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a list or dict or a\n * blob.\n */\n    int\ncheck_for_list_or_dict_or_blob_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_LIST\n\t    && args[idx].v_type != VAR_DICT\n\t    && args[idx].v_type != VAR_BLOB)\n    {\n\tsemsg(_(e_list_dict_or_blob_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is a list or dict or a\n * blob or a string.\n */\n    int\ncheck_for_list_or_dict_or_blob_or_string_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_LIST\n\t    && args[idx].v_type != VAR_DICT\n\t    && args[idx].v_type != VAR_BLOB\n\t    && args[idx].v_type != VAR_STRING)\n    {\n\tsemsg(_(e_list_dict_blob_or_string_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Give an error and return FAIL unless \"args[idx]\" is an optional buffer\n * number or a dict.\n */\n    int\ncheck_for_opt_buffer_or_dict_arg(typval_T *args, int idx)\n{\n    if (args[idx].v_type != VAR_UNKNOWN\n\t    && args[idx].v_type != VAR_STRING\n\t    && args[idx].v_type != VAR_NUMBER\n\t    && args[idx].v_type != VAR_DICT)\n    {\n\tsemsg(_(e_string_required_for_argument_nr), idx + 1);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get the string value of a variable.\n * If it is a Number variable, the number is converted into a string.\n * tv_get_string() uses a single, static buffer.  YOU CAN ONLY USE IT ONCE!\n * tv_get_string_buf() uses a given buffer.\n * If the String variable has never been set, return an empty string.\n * Never returns NULL;\n * tv_get_string_chk() and tv_get_string_buf_chk() are similar, but return\n * NULL on error.\n */\n    char_u *\ntv_get_string(typval_T *varp)\n{\n    static char_u   mybuf[NUMBUFLEN];\n\n    return tv_get_string_buf(varp, mybuf);\n}\n\n/*\n * Like tv_get_string() but don't allow number to string conversion for Vim9.\n */\n    char_u *\ntv_get_string_strict(typval_T *varp)\n{\n    static char_u   mybuf[NUMBUFLEN];\n    char_u\t    *res =  tv_get_string_buf_chk_strict(\n\t\t\t\t\t\t varp, mybuf, in_vim9script());\n\n    return res != NULL ? res : (char_u *)\"\";\n}\n\n    char_u *\ntv_get_string_buf(typval_T *varp, char_u *buf)\n{\n    char_u\t*res = tv_get_string_buf_chk(varp, buf);\n\n    return res != NULL ? res : (char_u *)\"\";\n}\n\n/*\n * Careful: This uses a single, static buffer.  YOU CAN ONLY USE IT ONCE!\n */\n    char_u *\ntv_get_string_chk(typval_T *varp)\n{\n    static char_u   mybuf[NUMBUFLEN];\n\n    return tv_get_string_buf_chk(varp, mybuf);\n}\n\n    char_u *\ntv_get_string_buf_chk(typval_T *varp, char_u *buf)\n{\n    return tv_get_string_buf_chk_strict(varp, buf, FALSE);\n}\n\n    char_u *\ntv_get_string_buf_chk_strict(typval_T *varp, char_u *buf, int strict)\n{\n    switch (varp->v_type)\n    {\n\tcase VAR_NUMBER:\n\t    if (strict)\n\t    {\n\t\temsg(_(e_using_number_as_string));\n\t\tbreak;\n\t    }\n\t    vim_snprintf((char *)buf, NUMBUFLEN, \"%lld\",\n\t\t\t\t\t    (varnumber_T)varp->vval.v_number);\n\t    return buf;\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    emsg(_(e_using_funcref_as_string));\n\t    break;\n\tcase VAR_LIST:\n\t    emsg(_(e_using_list_as_string));\n\t    break;\n\tcase VAR_DICT:\n\t    emsg(_(e_using_dictionary_as_string));\n\t    break;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    if (strict)\n\t    {\n\t\temsg(_(e_using_float_as_string));\n\t\tbreak;\n\t    }\n\t    vim_snprintf((char *)buf, NUMBUFLEN, \"%g\", varp->vval.v_float);\n\t    return buf;\n#endif\n\tcase VAR_STRING:\n\t    if (varp->vval.v_string != NULL)\n\t\treturn varp->vval.v_string;\n\t    return (char_u *)\"\";\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    STRCPY(buf, get_var_special_name(varp->vval.v_number));\n\t    return buf;\n\tcase VAR_BLOB:\n\t    emsg(_(e_using_blob_as_string));\n\t    break;\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    if (in_vim9script())\n\t    {\n\t\tsemsg(_(e_using_invalid_value_as_string_str), \"job\");\n\t\tbreak;\n\t    }\n\t    return job_to_string_buf(varp, buf);\n#endif\n\t    break;\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    if (in_vim9script())\n\t    {\n\t\tsemsg(_(e_using_invalid_value_as_string_str), \"channel\");\n\t\tbreak;\n\t    }\n\t    return channel_to_string_buf(varp, buf);\n#endif\n\t    break;\n\tcase VAR_VOID:\n\t    emsg(_(e_cannot_use_void_value));\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_INSTR:\n\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t  vartype_name(varp->v_type));\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * Turn a typeval into a string.  Similar to tv_get_string_buf() but uses\n * string() on Dict, List, etc.\n */\n    char_u *\ntv_stringify(typval_T *varp, char_u *buf)\n{\n    if (varp->v_type == VAR_LIST\n\t    || varp->v_type == VAR_DICT\n\t    || varp->v_type == VAR_BLOB\n\t    || varp->v_type == VAR_FUNC\n\t    || varp->v_type == VAR_PARTIAL\n\t    || varp->v_type == VAR_FLOAT)\n    {\n\ttypval_T tmp;\n\n\tf_string(varp, &tmp);\n\ttv_get_string_buf(&tmp, buf);\n\tclear_tv(varp);\n\t*varp = tmp;\n\treturn tmp.vval.v_string;\n    }\n    return tv_get_string_buf(varp, buf);\n}\n\n/*\n * Return TRUE if typeval \"tv\" and its value are set to be locked (immutable).\n * Also give an error message, using \"name\" or _(\"name\") when use_gettext is\n * TRUE.\n */\n    int\ntv_check_lock(typval_T *tv, char_u *name, int use_gettext)\n{\n    int\tlock = 0;\n\n    switch (tv->v_type)\n    {\n\tcase VAR_BLOB:\n\t    if (tv->vval.v_blob != NULL)\n\t\tlock = tv->vval.v_blob->bv_lock;\n\t    break;\n\tcase VAR_LIST:\n\t    if (tv->vval.v_list != NULL)\n\t\tlock = tv->vval.v_list->lv_lock;\n\t    break;\n\tcase VAR_DICT:\n\t    if (tv->vval.v_dict != NULL)\n\t\tlock = tv->vval.v_dict->dv_lock;\n\t    break;\n\tdefault:\n\t    break;\n    }\n    return value_check_lock(tv->v_lock, name, use_gettext)\n\t\t   || (lock != 0 && value_check_lock(lock, name, use_gettext));\n}\n\n/*\n * Copy the values from typval_T \"from\" to typval_T \"to\".\n * When needed allocates string or increases reference count.\n * Does not make a copy of a list, blob or dict but copies the reference!\n * It is OK for \"from\" and \"to\" to point to the same item.  This is used to\n * make a copy later.\n */\n    void\ncopy_tv(typval_T *from, typval_T *to)\n{\n    to->v_type = from->v_type;\n    to->v_lock = 0;\n    switch (from->v_type)\n    {\n\tcase VAR_NUMBER:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    to->vval.v_number = from->vval.v_number;\n\t    break;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    to->vval.v_float = from->vval.v_float;\n\t    break;\n#endif\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    to->vval.v_job = from->vval.v_job;\n\t    if (to->vval.v_job != NULL)\n\t\t++to->vval.v_job->jv_refcount;\n\t    break;\n#endif\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    to->vval.v_channel = from->vval.v_channel;\n\t    if (to->vval.v_channel != NULL)\n\t\t++to->vval.v_channel->ch_refcount;\n\t    break;\n#endif\n\tcase VAR_INSTR:\n\t    to->vval.v_instr = from->vval.v_instr;\n\t    break;\n\n\tcase VAR_STRING:\n\tcase VAR_FUNC:\n\t    if (from->vval.v_string == NULL)\n\t\tto->vval.v_string = NULL;\n\t    else\n\t    {\n\t\tto->vval.v_string = vim_strsave(from->vval.v_string);\n\t\tif (from->v_type == VAR_FUNC)\n\t\t    func_ref(to->vval.v_string);\n\t    }\n\t    break;\n\tcase VAR_PARTIAL:\n\t    if (from->vval.v_partial == NULL)\n\t\tto->vval.v_partial = NULL;\n\t    else\n\t    {\n\t\tto->vval.v_partial = from->vval.v_partial;\n\t\t++to->vval.v_partial->pt_refcount;\n\t    }\n\t    break;\n\tcase VAR_BLOB:\n\t    if (from->vval.v_blob == NULL)\n\t\tto->vval.v_blob = NULL;\n\t    else\n\t    {\n\t\tto->vval.v_blob = from->vval.v_blob;\n\t\t++to->vval.v_blob->bv_refcount;\n\t    }\n\t    break;\n\tcase VAR_LIST:\n\t    if (from->vval.v_list == NULL)\n\t\tto->vval.v_list = NULL;\n\t    else\n\t    {\n\t\tto->vval.v_list = from->vval.v_list;\n\t\t++to->vval.v_list->lv_refcount;\n\t    }\n\t    break;\n\tcase VAR_DICT:\n\t    if (from->vval.v_dict == NULL)\n\t\tto->vval.v_dict = NULL;\n\t    else\n\t    {\n\t\tto->vval.v_dict = from->vval.v_dict;\n\t\t++to->vval.v_dict->dv_refcount;\n\t    }\n\t    break;\n\tcase VAR_VOID:\n\t    emsg(_(e_cannot_use_void_value));\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\t    internal_error_no_abort(\"copy_tv(UNKNOWN)\");\n\t    break;\n    }\n}\n\n/*\n * Compare \"tv1\" and \"tv2\".\n * Put the result in \"tv1\".  Caller should clear \"tv2\".\n */\n    int\ntypval_compare(\n    typval_T\t*tv1,\t// first operand\n    typval_T\t*tv2,\t// second operand\n    exprtype_T\ttype,   // operator\n    int\t\tic)     // ignore case\n{\n    varnumber_T\tn1, n2;\n    int\t\tres = 0;\n    int\t\ttype_is = type == EXPR_IS || type == EXPR_ISNOT;\n\n    if (type_is && tv1->v_type != tv2->v_type)\n    {\n\t// For \"is\" a different type always means FALSE, for \"notis\"\n\t// it means TRUE.\n\tn1 = (type == EXPR_ISNOT);\n    }\n    else if (((tv1->v_type == VAR_SPECIAL && tv1->vval.v_number == VVAL_NULL)\n\t\t|| (tv2->v_type == VAR_SPECIAL\n\t\t\t\t\t   && tv2->vval.v_number == VVAL_NULL))\n\t    && tv1->v_type != tv2->v_type\n\t    && (type == EXPR_EQUAL || type == EXPR_NEQUAL))\n    {\n\tn1 = typval_compare_null(tv1, tv2);\n\tif (n1 == MAYBE)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tif (type == EXPR_NEQUAL)\n\t    n1 = !n1;\n    }\n    else if (tv1->v_type == VAR_BLOB || tv2->v_type == VAR_BLOB)\n    {\n\tif (typval_compare_blob(tv1, tv2, type, &res) == FAIL)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = res;\n    }\n    else if (tv1->v_type == VAR_LIST || tv2->v_type == VAR_LIST)\n    {\n\tif (typval_compare_list(tv1, tv2, type, ic, &res) == FAIL)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = res;\n    }\n    else if (tv1->v_type == VAR_DICT || tv2->v_type == VAR_DICT)\n    {\n\tif (typval_compare_dict(tv1, tv2, type, ic, &res) == FAIL)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = res;\n    }\n    else if (tv1->v_type == VAR_FUNC || tv2->v_type == VAR_FUNC\n\t|| tv1->v_type == VAR_PARTIAL || tv2->v_type == VAR_PARTIAL)\n    {\n\tif (typval_compare_func(tv1, tv2, type, ic, &res) == FAIL)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = res;\n    }\n\n#ifdef FEAT_FLOAT\n    // If one of the two variables is a float, compare as a float.\n    // When using \"=~\" or \"!~\", always compare as string.\n    else if ((tv1->v_type == VAR_FLOAT || tv2->v_type == VAR_FLOAT)\n\t    && type != EXPR_MATCH && type != EXPR_NOMATCH)\n    {\n\tfloat_T f1, f2;\n\tint\terror = FALSE;\n\n\tf1 = tv_get_float_chk(tv1, &error);\n\tif (!error)\n\t    f2 = tv_get_float_chk(tv2, &error);\n\tif (error)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = FALSE;\n\tswitch (type)\n\t{\n\t    case EXPR_IS:\n\t    case EXPR_EQUAL:    n1 = (f1 == f2); break;\n\t    case EXPR_ISNOT:\n\t    case EXPR_NEQUAL:   n1 = (f1 != f2); break;\n\t    case EXPR_GREATER:  n1 = (f1 > f2); break;\n\t    case EXPR_GEQUAL:   n1 = (f1 >= f2); break;\n\t    case EXPR_SMALLER:  n1 = (f1 < f2); break;\n\t    case EXPR_SEQUAL:   n1 = (f1 <= f2); break;\n\t    case EXPR_UNKNOWN:\n\t    case EXPR_MATCH:\n\t    default:  break;  // avoid gcc warning\n\t}\n    }\n#endif\n\n    // If one of the two variables is a number, compare as a number.\n    // When using \"=~\" or \"!~\", always compare as string.\n    else if ((tv1->v_type == VAR_NUMBER || tv2->v_type == VAR_NUMBER)\n\t    && type != EXPR_MATCH && type != EXPR_NOMATCH)\n    {\n\tint error = FALSE;\n\n\tn1 = tv_get_number_chk(tv1, &error);\n\tif (!error)\n\t    n2 = tv_get_number_chk(tv2, &error);\n\tif (error)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tswitch (type)\n\t{\n\t    case EXPR_IS:\n\t    case EXPR_EQUAL:    n1 = (n1 == n2); break;\n\t    case EXPR_ISNOT:\n\t    case EXPR_NEQUAL:   n1 = (n1 != n2); break;\n\t    case EXPR_GREATER:  n1 = (n1 > n2); break;\n\t    case EXPR_GEQUAL:   n1 = (n1 >= n2); break;\n\t    case EXPR_SMALLER:  n1 = (n1 < n2); break;\n\t    case EXPR_SEQUAL:   n1 = (n1 <= n2); break;\n\t    case EXPR_UNKNOWN:\n\t    case EXPR_MATCH:\n\t    default:  break;  // avoid gcc warning\n\t}\n    }\n    else if (in_vim9script() && (tv1->v_type == VAR_BOOL\n\t\t\t\t    || tv2->v_type == VAR_BOOL\n\t\t\t\t    || (tv1->v_type == VAR_SPECIAL\n\t\t\t\t\t      && tv2->v_type == VAR_SPECIAL)))\n    {\n\tif (tv1->v_type != tv2->v_type)\n\t{\n\t    semsg(_(e_cannot_compare_str_with_str),\n\t\t       vartype_name(tv1->v_type), vartype_name(tv2->v_type));\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = tv1->vval.v_number;\n\tn2 = tv2->vval.v_number;\n\tswitch (type)\n\t{\n\t    case EXPR_IS:\n\t    case EXPR_EQUAL:    n1 = (n1 == n2); break;\n\t    case EXPR_ISNOT:\n\t    case EXPR_NEQUAL:   n1 = (n1 != n2); break;\n\t    default:\n\t\tsemsg(_(e_invalid_operation_for_str),\n\t\t\t\t\t\t   vartype_name(tv1->v_type));\n\t\tclear_tv(tv1);\n\t\treturn FAIL;\n\t}\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (tv1->v_type == tv2->v_type\n\t    && (tv1->v_type == VAR_CHANNEL || tv1->v_type == VAR_JOB)\n\t    && (type == EXPR_NEQUAL || type == EXPR_EQUAL))\n    {\n\tif (tv1->v_type == VAR_CHANNEL)\n\t    n1 = tv1->vval.v_channel == tv2->vval.v_channel;\n\telse\n\t    n1 = tv1->vval.v_job == tv2->vval.v_job;\n\tif (type == EXPR_NEQUAL)\n\t    n1 = !n1;\n    }\n#endif\n    else\n    {\n\tif (typval_compare_string(tv1, tv2, type, ic, &res) == FAIL)\n\t{\n\t    clear_tv(tv1);\n\t    return FAIL;\n\t}\n\tn1 = res;\n    }\n    clear_tv(tv1);\n    if (in_vim9script())\n    {\n\ttv1->v_type = VAR_BOOL;\n\ttv1->vval.v_number = n1 ? VVAL_TRUE : VVAL_FALSE;\n    }\n    else\n    {\n\ttv1->v_type = VAR_NUMBER;\n\ttv1->vval.v_number = n1;\n    }\n\n    return OK;\n}\n\n/*\n * Compare \"tv1\" to \"tv2\" as lists acording to \"type\" and \"ic\".\n * Put the result, false or true, in \"res\".\n * Return FAIL and give an error message when the comparison can't be done.\n */\n    int\ntypval_compare_list(\n\ttypval_T    *tv1,\n\ttypval_T    *tv2,\n\texprtype_T  type,\n\tint\t    ic,\n\tint\t    *res)\n{\n    int\t    val = 0;\n\n    if (type == EXPR_IS || type == EXPR_ISNOT)\n    {\n\tval = (tv1->v_type == tv2->v_type\n\t\t\t\t      && tv1->vval.v_list == tv2->vval.v_list);\n\tif (type == EXPR_ISNOT)\n\t    val = !val;\n    }\n    else if (tv1->v_type != tv2->v_type\n\t    || (type != EXPR_EQUAL && type != EXPR_NEQUAL))\n    {\n\tif (tv1->v_type != tv2->v_type)\n\t    emsg(_(e_can_only_compare_list_with_list));\n\telse\n\t    emsg(_(e_invalid_operation_for_list));\n\treturn FAIL;\n    }\n    else\n    {\n\tval = list_equal(tv1->vval.v_list, tv2->vval.v_list,\n\t\t\t\t\t\t\tic, FALSE);\n\tif (type == EXPR_NEQUAL)\n\t    val = !val;\n    }\n    *res = val;\n    return OK;\n}\n\n/*\n * Compare v:null with another type.  Return TRUE if the value is NULL.\n */\n    int\ntypval_compare_null(typval_T *tv1, typval_T *tv2)\n{\n    if ((tv1->v_type == VAR_SPECIAL && tv1->vval.v_number == VVAL_NULL)\n\t    || (tv2->v_type == VAR_SPECIAL && tv2->vval.v_number == VVAL_NULL))\n    {\n\ttypval_T\t*tv = tv1->v_type == VAR_SPECIAL ? tv2 : tv1;\n\n\tswitch (tv->v_type)\n\t{\n\t    case VAR_BLOB: return tv->vval.v_blob == NULL;\n#ifdef FEAT_JOB_CHANNEL\n\t    case VAR_CHANNEL: return tv->vval.v_channel == NULL;\n#endif\n\t    case VAR_DICT: return tv->vval.v_dict == NULL;\n\t    case VAR_FUNC: return tv->vval.v_string == NULL;\n#ifdef FEAT_JOB_CHANNEL\n\t    case VAR_JOB: return tv->vval.v_job == NULL;\n#endif\n\t    case VAR_LIST: return tv->vval.v_list == NULL;\n\t    case VAR_PARTIAL: return tv->vval.v_partial == NULL;\n\t    case VAR_STRING: return tv->vval.v_string == NULL;\n\n\t    case VAR_NUMBER: if (!in_vim9script())\n\t\t\t\t return tv->vval.v_number == 0;\n\t\t\t     break;\n#ifdef FEAT_FLOAT\n\t    case VAR_FLOAT: if (!in_vim9script())\n\t\t\t\t return tv->vval.v_float == 0.0;\n\t\t\t     break;\n#endif\n\t    default: break;\n\t}\n    }\n    // although comparing null with number, float or bool is not very useful\n    // we won't give an error\n    return FALSE;\n}\n\n/*\n * Compare \"tv1\" to \"tv2\" as blobs acording to \"type\".\n * Put the result, false or true, in \"res\".\n * Return FAIL and give an error message when the comparison can't be done.\n */\n    int\ntypval_compare_blob(\n\ttypval_T    *tv1,\n\ttypval_T    *tv2,\n\texprtype_T  type,\n\tint\t    *res)\n{\n    int\t    val = 0;\n\n    if (type == EXPR_IS || type == EXPR_ISNOT)\n    {\n\tval = (tv1->v_type == tv2->v_type\n\t\t\t&& tv1->vval.v_blob == tv2->vval.v_blob);\n\tif (type == EXPR_ISNOT)\n\t    val = !val;\n    }\n    else if (tv1->v_type != tv2->v_type\n\t    || (type != EXPR_EQUAL && type != EXPR_NEQUAL))\n    {\n\tif (tv1->v_type != tv2->v_type)\n\t    emsg(_(e_can_only_compare_blob_with_blob));\n\telse\n\t    emsg(_(e_invalid_operation_for_blob));\n\treturn FAIL;\n    }\n    else\n    {\n\tval = blob_equal(tv1->vval.v_blob, tv2->vval.v_blob);\n\tif (type == EXPR_NEQUAL)\n\t    val = !val;\n    }\n    *res = val;\n    return OK;\n}\n\n/*\n * Compare \"tv1\" to \"tv2\" as dictionaries acording to \"type\" and \"ic\".\n * Put the result, false or true, in \"res\".\n * Return FAIL and give an error message when the comparison can't be done.\n */\n    int\ntypval_compare_dict(\n\ttypval_T    *tv1,\n\ttypval_T    *tv2,\n\texprtype_T  type,\n\tint\t    ic,\n\tint\t    *res)\n{\n    int\t    val;\n\n    if (type == EXPR_IS || type == EXPR_ISNOT)\n    {\n\tval = (tv1->v_type == tv2->v_type\n\t\t\t&& tv1->vval.v_dict == tv2->vval.v_dict);\n\tif (type == EXPR_ISNOT)\n\t    val = !val;\n    }\n    else if (tv1->v_type != tv2->v_type\n\t\t|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))\n    {\n\tif (tv1->v_type != tv2->v_type)\n\t    emsg(_(e_can_only_compare_dictionary_with_dictionary));\n\telse\n\t    emsg(_(e_invalid_operation_for_dictionary));\n\treturn FAIL;\n    }\n    else\n    {\n\tval = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);\n\tif (type == EXPR_NEQUAL)\n\t    val = !val;\n    }\n    *res = val;\n    return OK;\n}\n\n/*\n * Compare \"tv1\" to \"tv2\" as funcrefs acording to \"type\" and \"ic\".\n * Put the result, false or true, in \"res\".\n * Return FAIL and give an error message when the comparison can't be done.\n */\n    int\ntypval_compare_func(\n\ttypval_T    *tv1,\n\ttypval_T    *tv2,\n\texprtype_T  type,\n\tint\t    ic,\n\tint\t    *res)\n{\n    int\t    val = 0;\n\n    if (type != EXPR_EQUAL && type != EXPR_NEQUAL\n\t    && type != EXPR_IS && type != EXPR_ISNOT)\n    {\n\temsg(_(e_invalid_operation_for_funcrefs));\n\treturn FAIL;\n    }\n    if ((tv1->v_type == VAR_PARTIAL && tv1->vval.v_partial == NULL)\n\t    || (tv2->v_type == VAR_PARTIAL && tv2->vval.v_partial == NULL))\n\t// When both partials are NULL, then they are equal.\n\t// Otherwise they are not equal.\n\tval = (tv1->vval.v_partial == tv2->vval.v_partial);\n    else if (type == EXPR_IS || type == EXPR_ISNOT)\n    {\n\tif (tv1->v_type == VAR_FUNC && tv2->v_type == VAR_FUNC)\n\t    // strings are considered the same if their value is\n\t    // the same\n\t    val = tv_equal(tv1, tv2, ic, FALSE);\n\telse if (tv1->v_type == VAR_PARTIAL && tv2->v_type == VAR_PARTIAL)\n\t    val = (tv1->vval.v_partial == tv2->vval.v_partial);\n\telse\n\t    val = FALSE;\n    }\n    else\n\tval = tv_equal(tv1, tv2, ic, FALSE);\n    if (type == EXPR_NEQUAL || type == EXPR_ISNOT)\n\tval = !val;\n    *res = val;\n    return OK;\n}\n\n/*\n * Compare \"tv1\" to \"tv2\" as strings according to \"type\" and \"ic\".\n * Put the result, false or true, in \"res\".\n * Return FAIL and give an error message when the comparison can't be done.\n */\n    int\ntypval_compare_string(\n\ttypval_T    *tv1,\n\ttypval_T    *tv2,\n\texprtype_T  type,\n\tint\t    ic,\n\tint\t    *res)\n{\n    int\t\ti = 0;\n    int\t\tval = FALSE;\n    char_u\t*s1, *s2;\n    char_u\tbuf1[NUMBUFLEN], buf2[NUMBUFLEN];\n\n    if (in_vim9script()\n\t  && ((tv1->v_type != VAR_STRING && tv1->v_type != VAR_SPECIAL)\n\t   || (tv2->v_type != VAR_STRING && tv2->v_type != VAR_SPECIAL)))\n    {\n\tsemsg(_(e_cannot_compare_str_with_str),\n\t\t   vartype_name(tv1->v_type), vartype_name(tv2->v_type));\n\treturn FAIL;\n    }\n    s1 = tv_get_string_buf(tv1, buf1);\n    s2 = tv_get_string_buf(tv2, buf2);\n    if (type != EXPR_MATCH && type != EXPR_NOMATCH)\n\ti = ic ? MB_STRICMP(s1, s2) : STRCMP(s1, s2);\n    switch (type)\n    {\n\tcase EXPR_IS:\t    if (in_vim9script())\n\t\t\t    {\n\t\t\t\t// Really check it is the same string, not just\n\t\t\t\t// the same value.\n\t\t\t\tval = tv1->vval.v_string == tv2->vval.v_string;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // FALLTHROUGH\n\tcase EXPR_EQUAL:    val = (i == 0); break;\n\tcase EXPR_ISNOT:    if (in_vim9script())\n\t\t\t    {\n\t\t\t\t// Really check it is not the same string, not\n\t\t\t\t// just a different value.\n\t\t\t\tval = tv1->vval.v_string != tv2->vval.v_string;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // FALLTHROUGH\n\tcase EXPR_NEQUAL:   val = (i != 0); break;\n\tcase EXPR_GREATER:  val = (i > 0); break;\n\tcase EXPR_GEQUAL:   val = (i >= 0); break;\n\tcase EXPR_SMALLER:  val = (i < 0); break;\n\tcase EXPR_SEQUAL:   val = (i <= 0); break;\n\n\tcase EXPR_MATCH:\n\tcase EXPR_NOMATCH:\n\t\tval = pattern_match(s2, s1, ic);\n\t\tif (type == EXPR_NOMATCH)\n\t\t    val = !val;\n\t\tbreak;\n\n\tdefault:  break;  // avoid gcc warning\n    }\n    *res = val;\n    return OK;\n}\n/*\n * Convert any type to a string, never give an error.\n * When \"quotes\" is TRUE add quotes to a string.\n * Returns an allocated string.\n */\n    char_u *\ntypval_tostring(typval_T *arg, int quotes)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*ret = NULL;\n\n    if (arg == NULL)\n\treturn vim_strsave((char_u *)\"(does not exist)\");\n    if (!quotes && arg->v_type == VAR_STRING)\n    {\n\tret = vim_strsave(arg->vval.v_string == NULL ? (char_u *)\"\"\n\t\t\t\t\t\t\t : arg->vval.v_string);\n    }\n    else\n    {\n\tret = tv2string(arg, &tofree, numbuf, 0);\n\t// Make a copy if we have a value but it's not in allocated memory.\n\tif (ret != NULL && tofree == NULL)\n\t    ret = vim_strsave(ret);\n    }\n    return ret;\n}\n\n/*\n * Return TRUE if typeval \"tv\" is locked: Either that value is locked itself\n * or it refers to a List or Dictionary that is locked.\n */\n    int\ntv_islocked(typval_T *tv)\n{\n    return (tv->v_lock & VAR_LOCKED)\n\t|| (tv->v_type == VAR_LIST\n\t\t&& tv->vval.v_list != NULL\n\t\t&& (tv->vval.v_list->lv_lock & VAR_LOCKED))\n\t|| (tv->v_type == VAR_DICT\n\t\t&& tv->vval.v_dict != NULL\n\t\t&& (tv->vval.v_dict->dv_lock & VAR_LOCKED));\n}\n\n    static int\nfunc_equal(\n    typval_T *tv1,\n    typval_T *tv2,\n    int\t     ic)\t    // ignore case\n{\n    char_u\t*s1, *s2;\n    dict_T\t*d1, *d2;\n    int\t\ta1, a2;\n    int\t\ti;\n\n    // empty and NULL function name considered the same\n    s1 = tv1->v_type == VAR_FUNC ? tv1->vval.v_string\n\t\t\t\t\t   : partial_name(tv1->vval.v_partial);\n    if (s1 != NULL && *s1 == NUL)\n\ts1 = NULL;\n    s2 = tv2->v_type == VAR_FUNC ? tv2->vval.v_string\n\t\t\t\t\t   : partial_name(tv2->vval.v_partial);\n    if (s2 != NULL && *s2 == NUL)\n\ts2 = NULL;\n    if (s1 == NULL || s2 == NULL)\n    {\n\tif (s1 != s2)\n\t    return FALSE;\n    }\n    else if (STRCMP(s1, s2) != 0)\n\treturn FALSE;\n\n    // empty dict and NULL dict is different\n    d1 = tv1->v_type == VAR_FUNC ? NULL : tv1->vval.v_partial->pt_dict;\n    d2 = tv2->v_type == VAR_FUNC ? NULL : tv2->vval.v_partial->pt_dict;\n    if (d1 == NULL || d2 == NULL)\n    {\n\tif (d1 != d2)\n\t    return FALSE;\n    }\n    else if (!dict_equal(d1, d2, ic, TRUE))\n\treturn FALSE;\n\n    // empty list and no list considered the same\n    a1 = tv1->v_type == VAR_FUNC ? 0 : tv1->vval.v_partial->pt_argc;\n    a2 = tv2->v_type == VAR_FUNC ? 0 : tv2->vval.v_partial->pt_argc;\n    if (a1 != a2)\n\treturn FALSE;\n    for (i = 0; i < a1; ++i)\n\tif (!tv_equal(tv1->vval.v_partial->pt_argv + i,\n\t\t      tv2->vval.v_partial->pt_argv + i, ic, TRUE))\n\t    return FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"tv1\" and \"tv2\" have the same value.\n * Compares the items just like \"==\" would compare them, but strings and\n * numbers are different.  Floats and numbers are also different.\n */\n    int\ntv_equal(\n    typval_T *tv1,\n    typval_T *tv2,\n    int\t     ic,\t    // ignore case\n    int\t     recursive)\t    // TRUE when used recursively\n{\n    char_u\tbuf1[NUMBUFLEN], buf2[NUMBUFLEN];\n    char_u\t*s1, *s2;\n    static int  recursive_cnt = 0;\t    // catch recursive loops\n    int\t\tr;\n    static int\ttv_equal_recurse_limit;\n\n    // Catch lists and dicts that have an endless loop by limiting\n    // recursiveness to a limit.  We guess they are equal then.\n    // A fixed limit has the problem of still taking an awful long time.\n    // Reduce the limit every time running into it. That should work fine for\n    // deeply linked structures that are not recursively linked and catch\n    // recursiveness quickly.\n    if (!recursive)\n\ttv_equal_recurse_limit = 1000;\n    if (recursive_cnt >= tv_equal_recurse_limit)\n    {\n\t--tv_equal_recurse_limit;\n\treturn TRUE;\n    }\n\n    // For VAR_FUNC and VAR_PARTIAL compare the function name, bound dict and\n    // arguments.\n    if ((tv1->v_type == VAR_FUNC\n\t\t|| (tv1->v_type == VAR_PARTIAL && tv1->vval.v_partial != NULL))\n\t    && (tv2->v_type == VAR_FUNC\n\t\t|| (tv2->v_type == VAR_PARTIAL && tv2->vval.v_partial != NULL)))\n    {\n\t++recursive_cnt;\n\tr = func_equal(tv1, tv2, ic);\n\t--recursive_cnt;\n\treturn r;\n    }\n\n    if (tv1->v_type != tv2->v_type\n\t    && ((tv1->v_type != VAR_BOOL && tv1->v_type != VAR_SPECIAL)\n\t\t|| (tv2->v_type != VAR_BOOL && tv2->v_type != VAR_SPECIAL)))\n\treturn FALSE;\n\n    switch (tv1->v_type)\n    {\n\tcase VAR_LIST:\n\t    ++recursive_cnt;\n\t    r = list_equal(tv1->vval.v_list, tv2->vval.v_list, ic, TRUE);\n\t    --recursive_cnt;\n\t    return r;\n\n\tcase VAR_DICT:\n\t    ++recursive_cnt;\n\t    r = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, TRUE);\n\t    --recursive_cnt;\n\t    return r;\n\n\tcase VAR_BLOB:\n\t    return blob_equal(tv1->vval.v_blob, tv2->vval.v_blob);\n\n\tcase VAR_NUMBER:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    return tv1->vval.v_number == tv2->vval.v_number;\n\n\tcase VAR_STRING:\n\t    s1 = tv_get_string_buf(tv1, buf1);\n\t    s2 = tv_get_string_buf(tv2, buf2);\n\t    return ((ic ? MB_STRICMP(s1, s2) : STRCMP(s1, s2)) == 0);\n\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    return tv1->vval.v_float == tv2->vval.v_float;\n#endif\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    return tv1->vval.v_job == tv2->vval.v_job;\n#endif\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    return tv1->vval.v_channel == tv2->vval.v_channel;\n#endif\n\tcase VAR_INSTR:\n\t    return tv1->vval.v_instr == tv2->vval.v_instr;\n\n\tcase VAR_PARTIAL:\n\t    return tv1->vval.v_partial == tv2->vval.v_partial;\n\n\tcase VAR_FUNC:\n\t    return tv1->vval.v_string == tv2->vval.v_string;\n\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    break;\n    }\n\n    // VAR_UNKNOWN can be the result of a invalid expression, let's say it\n    // does not equal anything, not even itself.\n    return FALSE;\n}\n\n/*\n * Get an option value.\n * \"arg\" points to the '&' or '+' before the option name.\n * \"arg\" is advanced to character after the option name.\n * Return OK or FAIL.\n */\n    int\neval_option(\n    char_u\t**arg,\n    typval_T\t*rettv,\t// when NULL, only check if option exists\n    int\t\tevaluate)\n{\n    char_u\t*option_end;\n    long\tnumval;\n    char_u\t*stringval;\n    getoption_T\topt_type;\n    int\t\tc;\n    int\t\tworking = (**arg == '+');    // has(\"+option\")\n    int\t\tret = OK;\n    int\t\tscope;\n\n    // Isolate the option name and find its value.\n    option_end = find_option_end(arg, &scope);\n    if (option_end == NULL)\n    {\n\tif (rettv != NULL)\n\t    semsg(_(e_option_name_missing_str), *arg);\n\treturn FAIL;\n    }\n\n    if (!evaluate)\n    {\n\t*arg = option_end;\n\treturn OK;\n    }\n\n    c = *option_end;\n    *option_end = NUL;\n    opt_type = get_option_value(*arg, &numval,\n\t\t\t       rettv == NULL ? NULL : &stringval, NULL, scope);\n\n    if (opt_type == gov_unknown)\n    {\n\tif (rettv != NULL)\n\t    semsg(_(e_unknown_option_str), *arg);\n\tret = FAIL;\n    }\n    else if (rettv != NULL)\n    {\n\trettv->v_lock = 0;\n\tif (opt_type == gov_hidden_string)\n\t{\n\t    rettv->v_type = VAR_STRING;\n\t    rettv->vval.v_string = NULL;\n\t}\n\telse if (opt_type == gov_hidden_bool || opt_type == gov_hidden_number)\n\t{\n\t    rettv->v_type = in_vim9script() && opt_type == gov_hidden_bool\n\t\t\t\t\t\t       ? VAR_BOOL : VAR_NUMBER;\n\t    rettv->vval.v_number = 0;\n\t}\n\telse if (opt_type == gov_bool || opt_type == gov_number)\n\t{\n\t    if (in_vim9script() && opt_type == gov_bool)\n\t    {\n\t\trettv->v_type = VAR_BOOL;\n\t\trettv->vval.v_number = numval ? VVAL_TRUE : VVAL_FALSE;\n\t    }\n\t    else\n\t    {\n\t\trettv->v_type = VAR_NUMBER;\n\t\trettv->vval.v_number = numval;\n\t    }\n\t}\n\telse\t\t\t\t// string option\n\t{\n\t    rettv->v_type = VAR_STRING;\n\t    rettv->vval.v_string = stringval;\n\t}\n    }\n    else if (working && (opt_type == gov_hidden_bool\n\t\t\t|| opt_type == gov_hidden_number\n\t\t\t|| opt_type == gov_hidden_string))\n\tret = FAIL;\n\n    *option_end = c;\t\t    // put back for error messages\n    *arg = option_end;\n\n    return ret;\n}\n\n/*\n * Allocate a variable for a number constant.  Also deals with \"0z\" for blob.\n * Return OK or FAIL.\n */\n    int\neval_number(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    evaluate,\n\tint\t    want_string UNUSED)\n{\n    int\t\tlen;\n    int\t\tskip_quotes = !in_old_script(4);\n#ifdef FEAT_FLOAT\n    char_u\t*p;\n    int\t\tget_float = FALSE;\n\n    // We accept a float when the format matches\n    // \"[0-9]\\+\\.[0-9]\\+\\([eE][+-]\\?[0-9]\\+\\)\\?\".  This is very\n    // strict to avoid backwards compatibility problems.\n    // With script version 2 and later the leading digit can be\n    // omitted.\n    // Don't look for a float after the \".\" operator, so that\n    // \":let vers = 1.2.3\" doesn't fail.\n    if (**arg == '.')\n\tp = *arg;\n    else\n    {\n\tp = *arg + 1;\n\tif (skip_quotes)\n\t    for (;;)\n\t    {\n\t\tif (*p == '\\'')\n\t\t    ++p;\n\t\tif (!vim_isdigit(*p))\n\t\t    break;\n\t\tp = skipdigits(p);\n\t    }\n\telse\n\t    p = skipdigits(p);\n    }\n    if (!want_string && p[0] == '.' && vim_isdigit(p[1]))\n    {\n\tget_float = TRUE;\n\tp = skipdigits(p + 2);\n\tif (*p == 'e' || *p == 'E')\n\t{\n\t    ++p;\n\t    if (*p == '-' || *p == '+')\n\t\t++p;\n\t    if (!vim_isdigit(*p))\n\t\tget_float = FALSE;\n\t    else\n\t\tp = skipdigits(p + 1);\n\t}\n\tif (ASCII_ISALPHA(*p) || *p == '.')\n\t    get_float = FALSE;\n    }\n    if (get_float)\n    {\n\tfloat_T\tf;\n\n\t*arg += string2float(*arg, &f, skip_quotes);\n\tif (evaluate)\n\t{\n\t    rettv->v_type = VAR_FLOAT;\n\t    rettv->vval.v_float = f;\n\t}\n    }\n    else\n#endif\n    if (**arg == '0' && ((*arg)[1] == 'z' || (*arg)[1] == 'Z'))\n    {\n\tchar_u  *bp;\n\tblob_T  *blob = NULL;  // init for gcc\n\n\t// Blob constant: 0z0123456789abcdef\n\tif (evaluate)\n\t    blob = blob_alloc();\n\tfor (bp = *arg + 2; vim_isxdigit(bp[0]); bp += 2)\n\t{\n\t    if (!vim_isxdigit(bp[1]))\n\t    {\n\t\tif (blob != NULL)\n\t\t{\n\t\t    emsg(_(e_blob_literal_should_have_an_even_number_of_hex_characters));\n\t\t    ga_clear(&blob->bv_ga);\n\t\t    VIM_CLEAR(blob);\n\t\t}\n\t\treturn FAIL;\n\t    }\n\t    if (blob != NULL)\n\t\tga_append(&blob->bv_ga,\n\t\t\t     (hex2nr(*bp) << 4) + hex2nr(*(bp+1)));\n\t    if (bp[2] == '.' && vim_isxdigit(bp[3]))\n\t\t++bp;\n\t}\n\tif (blob != NULL)\n\t    rettv_blob_set(rettv, blob);\n\t*arg = bp;\n    }\n    else\n    {\n\tvarnumber_T\tn;\n\n\t// decimal, hex or octal number\n\tvim_str2nr(*arg, NULL, &len, skip_quotes\n\t\t      ? STR2NR_NO_OCT + STR2NR_QUOTE\n\t\t      : STR2NR_ALL, &n, NULL, 0, TRUE);\n\tif (len == 0)\n\t{\n\t    if (evaluate)\n\t\tsemsg(_(e_invalid_expression_str), *arg);\n\t    return FAIL;\n\t}\n\t*arg += len;\n\tif (evaluate)\n\t{\n\t    rettv->v_type = VAR_NUMBER;\n\t    rettv->vval.v_number = n;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Evaluate a string constant and put the result in \"rettv\".\n * \"*arg\" points to the double quote or to after it when \"interpolate\" is TRUE.\n * When \"interpolate\" is TRUE reduce \"{{\" to \"{\", reduce \"}}\" to \"}\" and stop\n * at a single \"{\".\n * Return OK or FAIL.\n */\n    int\neval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t    {\n\t\tint\t\tmodifiers = 0;\n\t\tint\t\tflags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\textra += 5;\n\n\t\t// Skip to the '>' to avoid using '{' inside for string\n\t\t// interpolation.\n\t\tif (p[1] != '*')\n\t\t    flags |= FSK_SIMPLIFY;\n\t\tif (find_special_key(&p, &modifiers, flags, NULL) != 0)\n\t\t    --p;  // leave \"p\" on the \">\"\n\t    }\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}\n\n/*\n * Allocate a variable for a 'str''ing' constant.\n * When \"interpolate\" is TRUE reduce \"{{\" to \"{\" and stop at a single \"{\".\n * Return OK when a \"rettv\" was set to the string.\n * Return FAIL on error, \"rettv\" is not set.\n */\n    int\neval_lit_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*str;\n    int\t\treduce = interpolate ? -1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n\n    // Find the end of the string, skipping ''.\n    for (p = *arg + off; *p != NUL; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\'')\n\t{\n\t    if (p[1] != '\\'')\n\t\tbreak;\n\t    ++reduce;\n\t    ++p;\n\t}\n\telse if (interpolate)\n\t{\n\t    if (*p == '{')\n\t    {\n\t\tif (p[1] != '{')\n\t\t    break;\n\t\t++p;\n\t\t++reduce;\n\t    }\n\t    else if (*p == '}')\n\t    {\n\t\t++p;\n\t\tif (*p != '}')\n\t\t{\n\t\t    semsg(_(e_stray_closing_curly_str), *arg);\n\t\t    return FAIL;\n\t\t}\n\t\t++reduce;\n\t    }\n\t}\n    }\n\n    if (*p != '\\'' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_single_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing return after setting \"*arg\"\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling '' to ' reduction and\n    // any expressions.\n    str = alloc((p - *arg) - reduce);\n    if (str == NULL)\n\treturn FAIL;\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = str;\n\n    for (p = *arg + off; *p != NUL; )\n    {\n\tif (*p == '\\'')\n\t{\n\t    if (p[1] != '\\'')\n\t\tbreak;\n\t    ++p;\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{')\n\t\tbreak;\n\t    ++p;\n\t}\n\tMB_COPY_CHAR(p, str);\n    }\n    *str = NUL;\n    *arg = p + off;\n\n    return OK;\n}\n\n/*\n * Evaluate a single or double quoted string possibly containing expressions.\n * \"arg\" points to the '$'.  The result is put in \"rettv\".\n * Returns OK or FAIL.\n */\n    int\neval_interp_string(char_u **arg, typval_T *rettv, int evaluate)\n{\n    typval_T\ttv;\n    int\t\tret = OK;\n    int\t\tquote;\n    garray_T\tga;\n    char_u\t*p;\n\n    ga_init2(&ga, 1, 80);\n\n    // *arg is on the '$' character, move it to the first string character.\n    ++*arg;\n    quote = **arg;\n    ++*arg;\n\n    for (;;)\n    {\n\t// Get the string up to the matching quote or to a single '{'.\n\t// \"arg\" is advanced to either the quote or the '{'.\n\tif (quote == '\"')\n\t    ret = eval_string(arg, &tv, evaluate, TRUE);\n\telse\n\t    ret = eval_lit_string(arg, &tv, evaluate, TRUE);\n\tif (ret == FAIL)\n\t    break;\n\tif (evaluate)\n\t{\n\t    ga_concat(&ga, tv.vval.v_string);\n\t    clear_tv(&tv);\n\t}\n\n\tif (**arg != '{')\n\t{\n\t    // found terminating quote\n\t    ++*arg;\n\t    break;\n\t}\n\tp = eval_one_expr_in_str(*arg, &ga, evaluate);\n\tif (p == NULL)\n\t{\n\t    ret = FAIL;\n\t    break;\n\t}\n\t*arg = p;\n    }\n\n    rettv->v_type = VAR_STRING;\n    if (ret == FAIL || !evaluate || ga_append(&ga, NUL) == FAIL)\n    {\n\tga_clear(&ga);\n\trettv->vval.v_string = NULL;\n\treturn ret;\n    }\n\n    rettv->vval.v_string = ga.ga_data;\n    return OK;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * Puts quotes around strings, so that they can be parsed back by eval().\n * May return NULL.\n */\n    char_u *\ntv2string(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID)\n{\n    return echo_string_core(tv, tofree, numbuf, copyID, FALSE, TRUE, FALSE);\n}\n\n/*\n * Get the value of an environment variable.\n * \"arg\" is pointing to the '$'.  It is advanced to after the name.\n * If the environment variable was not set, silently assume it is empty.\n * Return FAIL if the name is invalid.\n */\n    int\neval_env_var(char_u **arg, typval_T *rettv, int evaluate)\n{\n    char_u\t*string = NULL;\n    int\t\tlen;\n    int\t\tcc;\n    char_u\t*name;\n    int\t\tmustfree = FALSE;\n\n    ++*arg;\n    name = *arg;\n    len = get_env_len(arg);\n    if (evaluate)\n    {\n\tif (len == 0)\n\t    return FAIL; // invalid empty name\n\n\tcc = name[len];\n\tname[len] = NUL;\n\t// first try vim_getenv(), fast for normal environment vars\n\tstring = vim_getenv(name, &mustfree);\n\tif (string != NULL && *string != NUL)\n\t{\n\t    if (!mustfree)\n\t\tstring = vim_strsave(string);\n\t}\n\telse\n\t{\n\t    if (mustfree)\n\t\tvim_free(string);\n\n\t    // next try expanding things like $VIM and ${HOME}\n\t    string = expand_env_save(name - 1);\n\t    if (string != NULL && *string == '$')\n\t\tVIM_CLEAR(string);\n\t}\n\tname[len] = cc;\n\n\trettv->v_type = VAR_STRING;\n\trettv->vval.v_string = string;\n\trettv->v_lock = 0;\n    }\n\n    return OK;\n}\n\n/*\n * Get the lnum from the first argument.\n * Also accepts \".\", \"$\", etc., but that only works for the current buffer.\n * Returns -1 on error.\n */\n    linenr_T\ntv_get_lnum(typval_T *argvars)\n{\n    linenr_T\tlnum = -1;\n\n    if (argvars[0].v_type != VAR_STRING || !in_vim9script())\n\tlnum = (linenr_T)tv_get_number_chk(&argvars[0], NULL);\n    if (lnum <= 0 && argvars[0].v_type != VAR_NUMBER)\n    {\n\tint\tfnum;\n\tpos_T\t*fp;\n\n\t// no valid number, try using arg like line()\n\tfp = var2fpos(&argvars[0], TRUE, &fnum, FALSE);\n\tif (fp != NULL)\n\t    lnum = fp->lnum;\n    }\n    return lnum;\n}\n\n/*\n * Get the lnum from the first argument.\n * Also accepts \"$\", then \"buf\" is used.\n * Returns 0 on error.\n */\n    linenr_T\ntv_get_lnum_buf(typval_T *argvars, buf_T *buf)\n{\n    if (argvars[0].v_type == VAR_STRING\n\t    && argvars[0].vval.v_string != NULL\n\t    && argvars[0].vval.v_string[0] == '$'\n\t    && argvars[0].vval.v_string[1] == NUL\n\t    && buf != NULL)\n\treturn buf->b_ml.ml_line_count;\n    return (linenr_T)tv_get_number_chk(&argvars[0], NULL);\n}\n\n/*\n * Get buffer by number or pattern.\n */\n    buf_T *\ntv_get_buf(typval_T *tv, int curtab_only)\n{\n    char_u\t*name = tv->vval.v_string;\n    buf_T\t*buf;\n\n    if (tv->v_type == VAR_NUMBER)\n\treturn buflist_findnr((int)tv->vval.v_number);\n    if (tv->v_type != VAR_STRING)\n\treturn NULL;\n    if (name == NULL || *name == NUL)\n\treturn curbuf;\n    if (name[0] == '$' && name[1] == NUL)\n\treturn lastbuf;\n\n    buf = buflist_find_by_name(name, curtab_only);\n\n    // If not found, try expanding the name, like done for bufexists().\n    if (buf == NULL)\n\tbuf = find_buffer(tv);\n\n    return buf;\n}\n\n/*\n * Like tv_get_buf() but give an error message is the type is wrong.\n */\n    buf_T *\ntv_get_buf_from_arg(typval_T *tv)\n{\n    buf_T *buf;\n\n    ++emsg_off;\n    buf = tv_get_buf(tv, FALSE);\n    --emsg_off;\n    if (buf == NULL\n\t    && tv->v_type != VAR_NUMBER\n\t    && tv->v_type != VAR_STRING)\n\t// issue errmsg for type error\n\t(void)tv_get_number(tv);\n    return buf;\n}\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/testdir/test_eval_stuff.vim", "src/typval.c", "src/version.c"], "buggy_code_start_loc": [619, 2092, 737], "buggy_code_end_loc": [619, 2093, 737], "fixing_code_start_loc": [620, 2093, 738], "fixing_code_end_loc": [625, 2106, 740], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0102.", "other": {"cve": {"id": "CVE-2022-2580", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-01T15:15:09.443", "lastModified": "2022-08-04T23:30:38.210", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0102."}, {"lang": "es", "value": "Un Desbordamiento del B\u00fafer en la Regi\u00f3n Heap de la Memoria en el repositorio de GitHub vim/vim versiones anteriores a 9.0.0102"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0102", "matchCriteriaId": "054AD365-5E09-42DF-A235-F1ADCBC5478F"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/1e56bda9048a9625bce6e660938c834c5c15b07d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/c5f2f1d4-0441-4881-b19c-055acaa16249", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/1e56bda9048a9625bce6e660938c834c5c15b07d"}}