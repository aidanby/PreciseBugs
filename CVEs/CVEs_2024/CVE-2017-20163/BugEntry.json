{"buggy_code": ["<?php\nmb_internal_encoding('UTF-8');\n\n/**\n * class 'Session'\n * This uses static functions, but is constructed at a specific time.\n * requires tables session and sessiondata\n * cf. http://php.net/manual/en/class.sessionhandlerinterface.php\n * We are currently ignoring the following php.ini session.* configuration settings.\n * cf. http://php.net/manual/en/session.configuration.php\n */\nclass Session extends Singleton {\n\tprivate static $tom = null;            // timeout minutes\n\tprivate static $sqlsess = null;\n\tprivate static $apache_cookie = null;    // This is the session cookie or '[new session]'- used for session-only variables.\n\tprivate static $registry;\n\tprivate static $session;\n\tprivate static $cookieLife = null;\n\n\t/*\n\t * set timeout (in minutes)\n\t * this is traditionally set using a php.ini value session.gc_lifetime\n\t */\n\tpublic static function setto($tom_p = 1440, int $cookieLife = 8640000) {\n\t\tstatic::$tom = Settings::$sql->escape_string($tom_p);\n\t\tstatic::$cookieLife = $cookieLife > 0 ? time() + $cookieLife : 0;\n\t\tSettings::$sql->query(\"delete from sio_session where TIMESTAMPADD(MINUTE,\" . static::$tom . \",ts) < CURRENT_TIMESTAMP\");\n\t}\n\n\tpublic static function mutate() {\n\t\tif (isset($_COOKIE[\"xsession\"])) {\n\t\t\t$session = static::$session;\n\t\t\t$code = @$_SERVER['REMOTE_ADDR'] . @$_SERVER['SSL_SESSION_ID'] . \"_wxf9[9]Z(9.2)\";\n\t\t\t$vector = $_SERVER['SCRIPT_URI'] . \"37b807ea4118db8d\";\n\t\t\t$mutated = hash('sha256', openssl_encrypt(gzdeflate($session), \"aes-256-cbc\", $code, OPENSSL_RAW_DATA, substr($vector, 0, 16)));\n\n\t\t\tSettings::$sql->query(\"update sio_session set id='$mutated' where id='$session'\");\n\t\t\tSettings::$sql->query(\"update sio_sessiondata set sid='$mutated' where sid='$session'\");\n\t\t\tstatic::$sqlsess = $mutated;\n\t\t\tstatic::$session = $mutated;\n\t\t\tsetcookie(\"xsession\", static::$session, static::$cookieLife, '/', '', true, true); // 8640000 = 100 days\n\t\t}\n\t}\n\n\t/**\n\t * has (with no name = check for session) - otherwise, check for session variable\n\t */\n\tpublic static function has($name = null) {\n\t\t$retVal = false;\n\t\tif (!empty(static::$session)) {\n\t\t\tif (!empty($name)) {\n\t\t\t\t$registry = static::getRegistry();\n\t\t\t\t$retVal = isset($registry[$name]);\n\t\t\t} else {\n\t\t\t\t$retVal = true;\n\t\t\t}\n\t\t}\n\t\treturn $retVal;\n\t}\n\n\tpublic static function get($name = null) {\n\t\t$retVal = false;\n\t\tif (!empty(static::$session)) {\n\t\t\tif (!is_null($name)) {\n\t\t\t\t$registry = static::getRegistry();\n\t\t\t\tif (static::has($name)) {\n\t\t\t\t\t$retVal = $registry[$name];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$retVal = static::$session;\n\t\t\t}\n\t\t}\n\t\treturn $retVal;\n\t}\n\n\tpublic static function set($name = null, $val = null, $session_only = false) {\n\t\t$retVal = false;\n\t\tif (!empty(static::$session) && !is_null($name)) {\n\t\t\t$sqlnam = Settings::$sql->escape_string($name);\n\t\t\t$sonly = $session_only ? \"'\" . static::$apache_cookie . \"'\" : \"NULL\";\n\t\t\t$value = is_null($val) ? \"NULL\" : \"'\" . Settings::$sql->escape_string($val) . \"'\";\n\t\t\tSettings::$sql->query(\"replace into sio_sessiondata (sid,name,value,session) values ('\" . static::$sqlsess . \"','{$sqlnam}',{$value},{$sonly})\");\n\t\t\tstatic::$registry[$name] = $val;\n\t\t}\n\t\treturn $retVal;\n\t}\n\n\tprivate static function getRegistry() {\n\t\tif (is_null(static::$registry)) {\n\t\t\tstatic::$registry = [];\n\t\t\t$statement = Settings::$sql->prepare(\"select name,value from sio_sessiondata where sid=? and (session is NULL or session=? or session='_NEW')\");\n\t\t\tif ($statement !== false) {\n\t\t\t\t$statement->bind_param(\"ss\", static::$sqlsess, static::$apache_cookie);\n\t\t\t\t$statement->bind_result($name, $value);\n\t\t\t\t$statement->execute();\n\t\t\t\twhile ($statement->fetch()) {\n\t\t\t\t\tstatic::$registry[$name] = $value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn static::$registry;\n\t}\n\n\tpublic static function del($nam = null) {\n\t\tif (!empty(static::$session)) {\n\t\t\tif (!is_null($nam)) {\n\t\t\t\t$sqlname = Settings::$sql->escape_string($nam);\n\t\t\t\t$query = \"delete from sio_sessiondata where sid='\" . static::$sqlsess . \"' and name='\" . $sqlname . \"'\";\n\t\t\t\tSettings::$sql->query($query);\n\t\t\t\tunset(static::$registry[$nam]);\n\t\t\t} else {\n\t\t\t\tSettings::$sql->query(\"delete from sio_session where id='\" . static::$sqlsess . \"'\");\n\t\t\t\tSettings::$sql->query(\"delete from sio_sessiondata where sid='\" . static::$sqlsess . \"'\");\n\t\t\t\tstatic::resetRegistry();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * 'fresh'\n\t * Returns a boolean. Tests to see if the current session is a new session, or a recovered session..\n\t */\n\tpublic static function fresh() {\n\t\t$retval = false;\n\t\tif ((!isset($_COOKIE[\"session\"])) || (static::$session === $_COOKIE[\"session\"])) {\n\t\t\t$retval = true;\n\t\t}\n\t\treturn $retval;\n\t}\n\n\t/**\n\t * '__construct'\n\t * Set / manage the session cookie and it's correlating data-record.\n\t */\n\tprotected function __construct() {\n\t}\n\n\tpublic static function start($override = false) {\n\t\tstatic::resetRegistry();\n\t\tif (isset($_COOKIE[\"session\"])) {\n\t\t\tstatic::$apache_cookie = Settings::$sql->escape_string($_COOKIE[\"session\"]);\n\t\t} else {\n\t\t\tstatic::$apache_cookie = \"_NEW\";\n\t\t}\n\t\tif (!isset($_COOKIE[\"xsession\"]) || $override) {\n\t\t\tif (!isset($_COOKIE[\"session\"]) || $override) {\n\t\t\t\t$session_id = getenv(\"UNIQUE_ID\");\n\t\t\t\tif (!$session_id) {\n\t\t\t\t\t$session_id = sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x',\n\t\t\t\t\t  mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff),\n\t\t\t\t\t  mt_rand(0, 0x0fff) | 0x4000, mt_rand(0, 0x3fff) | 0x8000,\n\t\t\t\t\t  mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tstatic::$session = md5($session_id);\n\t\t\t} else {\n\t\t\t\tstatic::$session = $_COOKIE[\"session\"];\n\t\t\t}\n\t\t\tif (empty($_SERVER['HTTPS'])) {\n\t\t\t\tsetcookie(\"xsession\", static::$session, static::$cookieLife, '/', '', false, true);\n\t\t\t} else {\n\t\t\t\t//possibly don't need this.\n\t\t\t\tsetcookie(\"xsession\", static::$session, static::$cookieLife, '/', '', true, true);\n\t\t\t}\n\t\t} else {\n\t\t\tstatic::$session = $_COOKIE[\"xsession\"];\n\t\t}\n\t\tif (!empty(static::$session)) {\n\t\t\tstatic::$sqlsess = Settings::$sql->escape_string(static::$session);\n\t\t\tSettings::$sql->query(\"delete sio_sessiondata from sio_sessiondata left join sio_session on sid=id where id is null\");\n\t\t\tSettings::$sql->query(\"replace into sio_session set id='\" . static::$sqlsess . \"'\");\n\t\t}\n\t\tstatic::tidy_session();\n\t}\n\n\t/**\n\t * Returns the time to live in minutes for the current session\n\t *\n\t * @param int $minutes\n\t * @return int\n\t */\n\tpublic static function ttl(int $minutes = 1440): int {\n\n\t\t$session = @$_COOKIE[\"xsession\"];\n\t\t$ttl = 0;\n\t\t$seconds = $minutes * 60;\n\n\t\tif (!is_null($session)) {\n\t\t\t$statement = Settings::$sql->prepare(\"select TIMESTAMPDIFF(SECOND,NOW(),(ts + INTERVAL ? SECOND)) from sio_session where id=?\");\n\t\t\t$statement->bind_param(\"is\", $seconds, $session);\n\t\t\t$statement->execute();\n\t\t\t$statement->bind_result($ttl);\n\t\t\t$statement->fetch();\n\t\t}\n\n\t\treturn $ttl ?? 0;\n\t}\n\n\t/**\n\t * 'set cookie as found.'\n\t */\n\tprivate static function tidy_session() {\n\t\tif ((static::$apache_cookie === \"_NEW\") && isset($_COOKIE[\"session\"])) {\n\t\t\tstatic::$apache_cookie = Settings::$sql->escape_string($_COOKIE[\"session\"]);\n\t\t\tSettings::$sql->query(\"update sio_sessiondata set session='\" . static::$apache_cookie . \"' where sid='\" . static::$sqlsess . \"' and session='_NEW'\");\n\t\t}\n\t}\n\n\tprivate static function resetRegistry() {\n\t\tstatic::$registry = null;\n\t}\n\n}\n"], "fixing_code": ["<?php\nmb_internal_encoding('UTF-8');\n\n/**\n * class 'Session'\n * This uses static functions, but is constructed at a specific time.\n * requires tables session and sessiondata\n * cf. http://php.net/manual/en/class.sessionhandlerinterface.php\n * We are currently ignoring the following php.ini session.* configuration settings.\n * cf. http://php.net/manual/en/session.configuration.php\n */\nclass Session extends Singleton {\n\tprivate static $tom = null;            // timeout minutes\n\tprivate static $sqlsess = null;\n\tprivate static $apache_cookie = null;    // This is the session cookie or '[new session]'- used for session-only variables.\n\tprivate static $registry;\n\tprivate static $session;\n\tprivate static $cookieLife = null;\n\n\t/*\n\t * set timeout (in minutes)\n\t * this is traditionally set using a php.ini value session.gc_lifetime\n\t */\n\tpublic static function setto($tom_p = 1440, int $cookieLife = 8640000) {\n\t\tstatic::$tom = Settings::$sql->escape_string($tom_p);\n\t\tstatic::$cookieLife = $cookieLife > 0 ? time() + $cookieLife : 0;\n\t\tSettings::$sql->query(\"delete from sio_session where TIMESTAMPADD(MINUTE,\" . static::$tom . \",ts) < CURRENT_TIMESTAMP\");\n\t}\n\n\tpublic static function mutate() {\n\t\tif (isset($_COOKIE[\"xsession\"])) {\n\t\t\t$session = static::$session;\n\t\t\t$code = @$_SERVER['REMOTE_ADDR'] . @$_SERVER['SSL_SESSION_ID'] . \"_wxf9[9]Z(9.2)\";\n\t\t\t$vector = $_SERVER['SCRIPT_URI'] . \"37b807ea4118db8d\";\n\t\t\t$mutated = hash('sha256', openssl_encrypt(gzdeflate($session), \"aes-256-cbc\", $code, OPENSSL_RAW_DATA, substr($vector, 0, 16)));\n\t\t\t$sqlSession = Settings::$sql->escape_string($session);\n\t\t\tSettings::$sql->query(\"update sio_session set id='$mutated' where id='$sqlSession'\");\n\t\t\tSettings::$sql->query(\"update sio_sessiondata set sid='$mutated' where sid='$sqlSession'\");\n\t\t\tstatic::$sqlsess = $mutated;\n\t\t\tstatic::$session = $mutated;\n\t\t\tsetcookie(\"xsession\", static::$session, static::$cookieLife, '/', '', true, true); // 8640000 = 100 days\n\t\t}\n\t}\n\n\t/**\n\t * has (with no name = check for session) - otherwise, check for session variable\n\t */\n\tpublic static function has($name = null) {\n\t\t$retVal = false;\n\t\tif (!empty(static::$session)) {\n\t\t\tif (!empty($name)) {\n\t\t\t\t$registry = static::getRegistry();\n\t\t\t\t$retVal = isset($registry[$name]);\n\t\t\t} else {\n\t\t\t\t$retVal = true;\n\t\t\t}\n\t\t}\n\t\treturn $retVal;\n\t}\n\n\tpublic static function get($name = null) {\n\t\t$retVal = false;\n\t\tif (!empty(static::$session)) {\n\t\t\tif (!is_null($name)) {\n\t\t\t\t$registry = static::getRegistry();\n\t\t\t\tif (static::has($name)) {\n\t\t\t\t\t$retVal = $registry[$name];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$retVal = static::$session;\n\t\t\t}\n\t\t}\n\t\treturn $retVal;\n\t}\n\n\tpublic static function set($name = null, $val = null, $session_only = false) {\n\t\t$retVal = false;\n\t\tif (!empty(static::$session) && !is_null($name)) {\n\t\t\t$sqlnam = Settings::$sql->escape_string($name);\n\t\t\t$sonly = $session_only ? \"'\" . static::$apache_cookie . \"'\" : \"NULL\";\n\t\t\t$value = is_null($val) ? \"NULL\" : \"'\" . Settings::$sql->escape_string($val) . \"'\";\n\t\t\tSettings::$sql->query(\"replace into sio_sessiondata (sid,name,value,session) values ('\" . static::$sqlsess . \"','{$sqlnam}',{$value},{$sonly})\");\n\t\t\tstatic::$registry[$name] = $val;\n\t\t}\n\t\treturn $retVal;\n\t}\n\n\tprivate static function getRegistry() {\n\t\tif (is_null(static::$registry)) {\n\t\t\tstatic::$registry = [];\n\t\t\t$statement = Settings::$sql->prepare(\"select name,value from sio_sessiondata where sid=? and (session is NULL or session=? or session='_NEW')\");\n\t\t\tif ($statement !== false) {\n\t\t\t\t$statement->bind_param(\"ss\", static::$sqlsess, static::$apache_cookie);\n\t\t\t\t$statement->bind_result($name, $value);\n\t\t\t\t$statement->execute();\n\t\t\t\twhile ($statement->fetch()) {\n\t\t\t\t\tstatic::$registry[$name] = $value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn static::$registry;\n\t}\n\n\tpublic static function del($nam = null) {\n\t\tif (!empty(static::$session)) {\n\t\t\tif (!is_null($nam)) {\n\t\t\t\t$sqlname = Settings::$sql->escape_string($nam);\n\t\t\t\t$query = \"delete from sio_sessiondata where sid='\" . static::$sqlsess . \"' and name='\" . $sqlname . \"'\";\n\t\t\t\tSettings::$sql->query($query);\n\t\t\t\tunset(static::$registry[$nam]);\n\t\t\t} else {\n\t\t\t\tSettings::$sql->query(\"delete from sio_session where id='\" . static::$sqlsess . \"'\");\n\t\t\t\tSettings::$sql->query(\"delete from sio_sessiondata where sid='\" . static::$sqlsess . \"'\");\n\t\t\t\tstatic::resetRegistry();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * 'fresh'\n\t * Returns a boolean. Tests to see if the current session is a new session, or a recovered session..\n\t */\n\tpublic static function fresh() {\n\t\t$retval = false;\n\t\tif ((!isset($_COOKIE[\"session\"])) || (static::$session === $_COOKIE[\"session\"])) {\n\t\t\t$retval = true;\n\t\t}\n\t\treturn $retval;\n\t}\n\n\t/**\n\t * '__construct'\n\t * Set / manage the session cookie and it's correlating data-record.\n\t */\n\tprotected function __construct() {\n\t}\n\n\tpublic static function start($override = false) {\n\t\tstatic::resetRegistry();\n\t\tif (isset($_COOKIE[\"session\"])) {\n\t\t\tstatic::$apache_cookie = Settings::$sql->escape_string($_COOKIE[\"session\"]);\n\t\t} else {\n\t\t\tstatic::$apache_cookie = \"_NEW\";\n\t\t}\n\t\tif (!isset($_COOKIE[\"xsession\"]) || $override) {\n\t\t\tif (!isset($_COOKIE[\"session\"]) || $override) {\n\t\t\t\t$session_id = getenv(\"UNIQUE_ID\");\n\t\t\t\tif (!$session_id) {\n\t\t\t\t\t$session_id = sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x',\n\t\t\t\t\t  mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff),\n\t\t\t\t\t  mt_rand(0, 0x0fff) | 0x4000, mt_rand(0, 0x3fff) | 0x8000,\n\t\t\t\t\t  mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tstatic::$session = md5($session_id);\n\t\t\t} else {\n\t\t\t\tstatic::$session = $_COOKIE[\"session\"];\n\t\t\t}\n\t\t\tif (empty($_SERVER['HTTPS'])) {\n\t\t\t\tsetcookie(\"xsession\", static::$session, static::$cookieLife, '/', '', false, true);\n\t\t\t} else {\n\t\t\t\t//possibly don't need this.\n\t\t\t\tsetcookie(\"xsession\", static::$session, static::$cookieLife, '/', '', true, true);\n\t\t\t}\n\t\t} else {\n\t\t\tstatic::$session = $_COOKIE[\"xsession\"];\n\t\t}\n\t\tif (!empty(static::$session)) {\n\t\t\tstatic::$sqlsess = Settings::$sql->escape_string(static::$session);\n\t\t\tSettings::$sql->query(\"delete sio_sessiondata from sio_sessiondata left join sio_session on sid=id where id is null\");\n\t\t\tSettings::$sql->query(\"replace into sio_session set id='\" . static::$sqlsess . \"'\");\n\t\t}\n\t\tstatic::tidy_session();\n\t}\n\n\t/**\n\t * Returns the time to live in minutes for the current session\n\t *\n\t * @param int $minutes\n\t * @return int\n\t */\n\tpublic static function ttl(int $minutes = 1440): int {\n\n\t\t$session = @$_COOKIE[\"xsession\"];\n\t\t$ttl = 0;\n\t\t$seconds = $minutes * 60;\n\n\t\tif (!is_null($session)) {\n\t\t\t$statement = Settings::$sql->prepare(\"select TIMESTAMPDIFF(SECOND,NOW(),(ts + INTERVAL ? SECOND)) from sio_session where id=?\");\n\t\t\t$statement->bind_param(\"is\", $seconds, $session);\n\t\t\t$statement->execute();\n\t\t\t$statement->bind_result($ttl);\n\t\t\t$statement->fetch();\n\t\t}\n\n\t\treturn $ttl ?? 0;\n\t}\n\n\t/**\n\t * 'set cookie as found.'\n\t */\n\tprivate static function tidy_session() {\n\t\tif ((static::$apache_cookie === \"_NEW\") && isset($_COOKIE[\"session\"])) {\n\t\t\tstatic::$apache_cookie = Settings::$sql->escape_string($_COOKIE[\"session\"]);\n\t\t\tSettings::$sql->query(\"update sio_sessiondata set session='\" . static::$apache_cookie . \"' where sid='\" . static::$sqlsess . \"' and session='_NEW'\");\n\t\t}\n\t}\n\n\tprivate static function resetRegistry() {\n\t\tstatic::$registry = null;\n\t}\n\n}\n"], "filenames": ["src/Session.php"], "buggy_code_start_loc": [36], "buggy_code_end_loc": [39], "fixing_code_start_loc": [36], "fixing_code_end_loc": [39], "type": "CWE-89", "message": "A vulnerability has been found in Red Snapper NView and classified as critical. This vulnerability affects the function mutate of the file src/Session.php. The manipulation of the argument session leads to sql injection. The name of the patch is cbd255f55d476b29e5680f66f48c73ddb3d416a8. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217516.", "other": {"cve": {"id": "CVE-2017-20163", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-05T20:15:18.333", "lastModified": "2023-01-12T02:50:53.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in Red Snapper NView and classified as critical. This vulnerability affects the function mutate of the file src/Session.php. The manipulation of the argument session leads to sql injection. The name of the patch is cbd255f55d476b29e5680f66f48c73ddb3d416a8. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217516."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nview_project:nview:*:*:*:*:*:*:*:*", "versionEndExcluding": "2017-04-28", "matchCriteriaId": "04818C8D-7466-4B6C-A859-FC29B6275A66"}]}]}], "references": [{"url": "https://github.com/RedSnapper/NView/commit/cbd255f55d476b29e5680f66f48c73ddb3d416a8", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217516", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217516", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/RedSnapper/NView/commit/cbd255f55d476b29e5680f66f48c73ddb3d416a8"}}