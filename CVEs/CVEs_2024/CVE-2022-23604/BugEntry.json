{"buggy_code": ["\"\"\"\nDefender - Protects your community with automod features and\n           empowers the staff and users you trust with\n           advanced moderation tools\nCopyright (C) 2020-present  Twentysix (https://github.com/Twentysix26/)\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\nfrom __future__ import annotations\nfrom ...core.warden.validation import (ALLOWED_CONDITIONS, ALLOWED_ACTIONS, ALLOWED_DEBUG_ACTIONS, model_validator,\n                                       DEPRECATED)\nfrom ...core.warden import validation as models\nfrom ...enums import Rank, EmergencyMode, Action as ModAction\nfrom .enums import Action, Condition, Event, ConditionBlock, ConditionalActionBlock\nfrom .utils import has_x_or_more_emojis, REMOVE_C_EMOJIS_RE, run_user_regex, make_fuzzy_suggestion, delete_message_after\nfrom ...exceptions import InvalidRule, ExecutionError, StopExecution, MisconfigurationError\nfrom ...core import cache as df_cache\nfrom ...core.utils import get_external_invite, QuickAction, utcnow\nfrom redbot.core.utils.common_filters import INVITE_URL_RE\nfrom redbot.core.utils.chat_formatting import box\nfrom redbot.core.commands.converter import parse_timedelta\nfrom discord.ext.commands import BadArgument\nfrom string import Template\nfrom redbot.core import modlog\nfrom typing import Optional\nfrom pydantic import ValidationError\nfrom typing import TYPE_CHECKING\nfrom . import heat\nimport random\nimport yaml\nimport fnmatch\nimport discord\nimport datetime\nimport logging\nimport regex as re\n\nif TYPE_CHECKING:\n    from ...abc import MixinMeta\n\nlog = logging.getLogger(\"red.x26cogs.defender\")\n\nALLOW_ALL_MENTIONS = discord.AllowedMentions(everyone=True, roles=True, users=True)\nRULE_REQUIRED_KEYS = (\"name\", \"event\", \"rank\", \"if\", \"do\")\nRULE_FACULTATIVE_KEYS = (\"priority\", \"run-every\")\n\nMEDIA_URL_RE = re.compile(r\"\"\"(http)?s?:?(\\/\\/[^\"']*\\.(?:png|jpg|jpeg|gif|png|svg|mp4|gifv))\"\"\", re.I)\nURL_RE = re.compile(r\"\"\"https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)\"\"\", re.I)\n\nclass ConditionResult:\n    \"\"\"This is used to store the condition evaluations at runtime\n    It is designed to aid the user in debugging the rules\"\"\"\n    def __init__(self, rule_name, debug):\n        self.rule_name = rule_name\n        self.conditions = []\n        self.result = False\n        self.debug = debug\n\n    def add_condition(self, condition: Condition, result: bool):\n        if self.debug:\n            self.conditions.append((condition, result))\n\n    def add_condition_block(self, condition_block: ConditionBlock, inner_conditions: list, results: list):\n        if self.debug:\n            block = (condition_block, [])\n            for i, c in enumerate(inner_conditions):\n                block[1].append((next(iter(c)), results[i]))\n            self.conditions.append(block)\n\n    def __bool__(self):\n        return self.result\n\nclass WardenRule:\n    def __init__(self):\n        self.parse_exception = None\n        self.last_action = Action.NoOp\n        self.name = None\n        self.events = []\n        self.rank = Rank.Rank4\n        self.conditions = []\n        self.actions = {}\n        self.raw_rule = \"\"\n        self.priority = 2666\n        self.next_run = None\n        self.run_every = None\n\n    async def parse(self, rule_str, cog: MixinMeta, author=None):\n        self.raw_rule = rule_str\n\n        try:\n            rule = yaml.safe_load(rule_str)\n        except:\n            raise InvalidRule(\"Error parsing YAML. Please make sure the format \"\n                              \"is valid (a YAML validator may help)\")\n\n        if not isinstance(rule, dict):\n            raise InvalidRule(f\"This rule doesn't seem to follow the expected format.\")\n\n        if rule.get(\"name\") is None:\n            raise InvalidRule(\"Rule has no 'name' parameter.\")\n\n        self.name = rule[\"name\"].lower().replace(\" \", \"-\")\n\n        for key in rule.keys():\n            if key not in RULE_REQUIRED_KEYS and key not in RULE_FACULTATIVE_KEYS:\n                raise InvalidRule(f\"Unexpected key at root level: '{key}'.\")\n\n        for key in RULE_REQUIRED_KEYS:\n            if key not in rule.keys():\n                raise InvalidRule(f\"Missing key at root level: '{key}'.\")\n\n        if isinstance(rule[\"event\"], list):\n            try:\n                for event in rule[\"event\"]:\n                    self.events.append(Event(event))\n            except ValueError:\n                raise InvalidRule(f\"Invalid events.\")\n        else:\n            try:\n                self.events.append(Event(rule[\"event\"]))\n            except ValueError:\n                raise InvalidRule(\"Invalid event.\")\n        if not self.events:\n            raise InvalidRule(\"A least one event must be defined.\")\n\n        if Event.Periodic in self.events:\n            # cog is None when running tests\n            if cog and not await cog.config.wd_periodic_allowed():\n                raise InvalidRule(\"The creation of periodic Warden rules is currently disabled. \"\n                                  \"The bot owner must use '[p]dset warden periodicallowed' to \"\n                                  \"enable them.\")\n            if \"run-every\" not in rule.keys():\n                raise InvalidRule(\"The 'run-every' parameter is mandatory with \"\n                                  \"periodic rules.\")\n            try:\n                td = parse_timedelta(str(rule[\"run-every\"]),\n                                     maximum=datetime.timedelta(hours=24),\n                                     minimum=datetime.timedelta(minutes=5),\n                                     allowed_units=[\"hours\", \"minutes\"])\n                if td is None:\n                    raise BadArgument()\n            except BadArgument:\n                raise InvalidRule(\"The 'run-every' parameter must be between 5 minutes \"\n                                  \"and 24 hours.\")\n            else:\n                self.run_every = td\n                self.next_run = utcnow() + td\n        else:\n            if \"run-every\" in rule.keys():\n                raise InvalidRule(\"The 'periodic' event must be specified for rules with \"\n                                  \"a 'run-every' parameter.\")\n\n        try:\n            self.rank = Rank(rule[\"rank\"])\n        except:\n            raise InvalidRule(\"Invalid target rank. Must be 1-4.\")\n\n        try:\n            priority = rule[\"priority\"]\n            if not isinstance(priority, int) or priority < 1 or priority > 999:\n                raise InvalidRule(\"Priority must be a number between 1 and 999.\")\n            self.priority = priority\n        except KeyError:\n            pass\n\n        if \"if\" in rule:\n            if not isinstance(rule[\"if\"], list):\n                raise InvalidRule(\"Invalid 'if' category. Must be a list of conditions.\")\n        else:\n            raise InvalidRule(\"Rule must have at least one condition.\")\n\n        self.conditions = rule[\"if\"]\n\n        if not rule[\"if\"]:\n            raise InvalidRule(\"Rule must have at least one condition.\")\n\n        if not isinstance(rule[\"do\"], list):\n            raise InvalidRule(\"Invalid 'do' category. Must be a list of maps.\")\n\n        if not rule[\"do\"]:\n            raise InvalidRule(\"Rule must have at least one action.\")\n\n        self.actions = rule[\"do\"]\n\n        def is_condition_allowed_in_events(condition):\n            for event in self.events:\n                if not condition in ALLOWED_CONDITIONS[event]:\n                    return False\n            return True\n\n        def is_action_allowed_in_events(action):\n            for event in self.events:\n                if not action in ALLOWED_ACTIONS[event]:\n                    return False\n            return True\n\n        async def validate_condition(cond):\n            condition = parameter = None\n            for r, p in cond.items():\n                condition, parameter = r, p\n\n            try:\n                condition = Condition(condition)\n            except ValueError:\n                try:\n                    condition = ConditionBlock(condition)\n                    raise InvalidRule(f\"Invalid: `{condition.value}` can only be at root level.\")\n                except ValueError:\n                    suggestion = make_fuzzy_suggestion(condition, [c.value for c in Condition\n                                                                   if c not in DEPRECATED])\n                    raise InvalidRule(f\"Invalid condition: `{condition}`.{suggestion}\")\n\n            # Checking author prevents old rules from raising at load\n            if author and condition in DEPRECATED:\n                raise InvalidRule(f\"Condition `{condition.value}` is deprecated: check the documentation \"\n                                  \"for a supported alternative.\")\n\n            if not is_condition_allowed_in_events(condition):\n                raise InvalidRule(f\"Condition `{condition.value}` not allowed in the event(s) you have defined.\")\n\n            try:\n                model = model_validator(condition, parameter)\n            except ValidationError as e:\n                raise InvalidRule(f\"Condition `{condition.value}` invalid:\\n{box(str(e))}\")\n\n            if author:\n                try:\n                    await model._runtime_check(cog=cog, author=author, action_or_cond=condition)\n                except NotImplementedError:\n                    pass\n\n        for raw_condition in self.conditions:\n            condition = parameter = None\n\n            if not isinstance(raw_condition, dict):\n                raise InvalidRule(f\"Invalid condition: `{raw_condition}`. Expected map. Did you forget the colon?\")\n\n            for r, p in raw_condition.items():\n                condition, parameter = r, p\n\n            if len(raw_condition) != 1:\n                raise InvalidRule(f\"Invalid format in the conditions. Make sure you've got the dashes right!\")\n\n            try:\n                condition = Condition(condition)\n            except ValueError:\n                try:\n                    condition = ConditionBlock(condition)\n                except ValueError:\n                    suggestion = make_fuzzy_suggestion(condition, [c.value for c in Condition\n                                                                   if c not in DEPRECATED])\n                    raise InvalidRule(f\"Invalid condition: `{condition}`.{suggestion}\")\n\n            if isinstance(condition, ConditionBlock):\n                if parameter is None:\n                    raise InvalidRule(\"Condition blocks cannot be empty.\")\n                for p in parameter:\n                    await validate_condition(p)\n            else:\n                await validate_condition(raw_condition)\n\n        async def validate_action(action, parameter):\n            # Checking author prevents old rules from raising at load\n            if author and action in DEPRECATED:\n                raise InvalidRule(f\"Action `{action.value}` is deprecated: check the documentation \"\n                                \"for a supported alternative.\")\n\n            if not is_action_allowed_in_events(action):\n                raise InvalidRule(f\"Action `{action.value}` not allowed in the event(s) you have defined.\")\n\n            try:\n                model = model_validator(action, parameter)\n            except ValidationError as e:\n                raise InvalidRule(f\"Action `{action.value}` invalid:\\n{box(str(e))}\")\n\n            if author:\n                try:\n                    await model._runtime_check(cog=cog, author=author, action_or_cond=action)\n                except NotImplementedError:\n                    pass\n\n        # Basically a list of one-key dicts\n        # We need to preserve order of actions\n        for entry in self.actions:\n            # This will be a single loop\n            if not isinstance(entry, dict):\n                raise InvalidRule(f\"Invalid action: `{entry}`. Expected map.\")\n\n            if len(entry) != 1:\n                raise InvalidRule(f\"Invalid format in the actions. Make sure you've got the dashes right!\")\n\n            for enum, parameter in entry.items():\n                try:\n                    enum = self._get_actions_enum(enum)\n                except ValueError:\n                    suggestion = make_fuzzy_suggestion(enum, [a.value for a in Action\n                                                                if a not in DEPRECATED])\n                    raise InvalidRule(f\"Invalid action: `{enum}`.{suggestion}\")\n\n                if isinstance(enum, Action):\n                    await validate_action(enum, parameter)\n                elif isinstance(enum, Condition):\n                    await validate_condition({enum.value: parameter})\n                elif isinstance(enum, ConditionBlock):\n                    if parameter is None:\n                        raise InvalidRule(\"Condition blocks cannot be empty.\")\n                    for p in parameter:\n                        await validate_condition(p)\n                elif isinstance(enum, ConditionalActionBlock):\n                    if parameter is None:\n                        raise InvalidRule(\"Conditional action blocks cannot be empty.\")\n                    for raw_action in parameter:\n                        if not isinstance(raw_action, dict):\n                            raise InvalidRule(f\"`{enum.value}` contains a non-map. Did you forget the colon?\")\n                        for action, subparameter in raw_action.items():\n                            try:\n                                action = self._get_actions_enum(action)\n                            except ValueError:\n                                suggestion = make_fuzzy_suggestion(action, [a.value for a in Action\n                                                                            if a not in DEPRECATED])\n                                raise InvalidRule(f\"Invalid action: `{action}`.{suggestion}\")\n                            await validate_action(action, subparameter)\n\n\n    async def satisfies_conditions(self, *, rank: Rank, cog: MixinMeta, user: discord.Member=None, message: discord.Message=None,\n                                   guild: discord.Guild=None, debug=False)->ConditionResult:\n        cr = ConditionResult(rule_name=self.name, debug=debug)\n        if rank < self.rank:\n            return cr\n\n        # Due to the strict checking done during parsing we can\n        # expect to always have available the variables that we need for\n        # the different type of events and conditions\n        # Unless I fucked up somewhere, then we're in trouble!\n        if message and not user:\n            user = message.author\n\n        # For the rule's conditions to pass, every \"root level\" condition (or block of conditions)\n        # must equal to True\n        try:\n            return await self._evaluate_conditions_block(block=self.conditions, cog=cog, user=user, message=message, guild=guild,\n                                                        debug=debug)\n        except ExecutionError:\n            return cr # Ensure the rule doesn't pass if a condition errored\n\n    async def _evaluate_conditions_block(self, *, block, cog, user: discord.Member=None, message: discord.Message=None,\n                                   guild: discord.Guild=None, templates_vars=None, debug)->ConditionResult:\n        # This is used during condition processing AND action processing for conditional actions\n        cr = ConditionResult(rule_name=self.name, debug=debug)\n\n        for raw_condition in block:\n            condition = None\n            value = []\n\n            for r, v in raw_condition.items():\n                condition, value = r, v\n            try:\n                condition = ConditionBlock(condition)\n            except:\n                condition = Condition(condition)\n\n            if condition == ConditionBlock.IfAll:\n                results = await self._evaluate_conditions(value, cog=cog, user=user, message=message,\n                                                          guild=guild, templates_vars=templates_vars, debug=debug)\n                if len(results) != len(value):\n                    raise RuntimeError(\"Mismatching number of conditions and evaluations\")\n                cr.add_condition_block(condition, value, results) # type: ignore\n                cond_result = all(results)\n            elif condition == ConditionBlock.IfAny:\n                results = await self._evaluate_conditions(value, cog=cog, user=user, message=message,\n                                                          guild=guild, templates_vars=templates_vars, debug=debug)\n                if len(results) != len(value):\n                    raise RuntimeError(\"Mismatching number of conditions and evaluations\")\n                cr.add_condition_block(condition, value, results) # type: ignore\n                cond_result = any(results)\n            elif condition == ConditionBlock.IfNot:\n                results = await self._evaluate_conditions(value, cog=cog, user=user, message=message,\n                                                          guild=guild, templates_vars=templates_vars, debug=debug)\n                if len(results) != len(value):\n                    raise RuntimeError(\"Mismatching number of conditions and evaluations\")\n                cr.add_condition_block(condition, value, results) # type: ignore\n                results = [not r for r in results] # Bools are flipped\n                cond_result = all(results)\n            else:\n                results = await self._evaluate_conditions([{condition: value}], cog=cog, user=user, message=message,\n                                                          guild=guild, templates_vars=templates_vars, debug=debug)\n                if len(results) != 1:\n                    raise RuntimeError(f\"A single condition evaluation returned {len(results)} evaluations!\")\n                cr.add_condition(condition, results[0]) # type: ignore\n                cond_result = results[0]\n\n            if cond_result is False:\n                return cr # If one root condition is False there's no need to continue\n\n        cr.result = True\n        return cr\n\n    async def _evaluate_conditions(self, conditions, *, cog: MixinMeta, user: discord.Member=None, message: discord.Message=None,\n                                   guild: discord.Guild=None, templates_vars=None, debug):\n\n        if message and not user:\n            user = message.author\n        guild = guild if guild else user.guild\n        channel: discord.Channel = message.channel if message else None\n\n        if templates_vars is None:\n            templates_vars = {}\n            await populate_ctx_vars(t_vars=templates_vars,\n                                    rule=self,\n                                    cog=cog,\n                                    guild=guild,\n                                    message=message,\n                                    user=user,\n                                    channel=channel,\n                                    debug=debug)\n\n        checkers = {}\n\n        def checker(condition: Condition, suggest: Condition=None):\n            def decorator(function):\n                def wrapper(*args, **kwargs):\n                    if suggest is not None:\n                        cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Condition \"\n                                                   f\"'{condition.value}' is deprecated, use \"\n                                                   f\"'{suggest.value}' instead.\")\n                    return function(*args, **kwargs)\n                checkers[condition] = wrapper\n                return wrapper\n            return decorator\n\n        def safe_sub(string):\n            if string == discord.Embed.Empty:\n                return string\n            return Template(string).safe_substitute(templates_vars)\n\n        @checker(Condition.MessageMatchesAny)\n        async def message_matches_any(params: models.NonEmptyListStr):\n            # One match = Passed\n            content = message.content.lower()\n            for pattern in params.value:\n                if fnmatch.fnmatch(content, pattern.lower()):\n                    return True\n            return False\n\n        @checker(Condition.MessageMatchesRegex)\n        async def message_matches_regex(params: models.IsStr):\n            return await run_user_regex(\n                rule_obj=self,\n                cog=cog,\n                guild=guild,\n                regex=params.value,\n                text=message.content\n            )\n\n        @checker(Condition.UserActivityMatchesAny)\n        async def user_activity_matches_any(params: models.NonEmptyListStr):\n            to_check = []\n            for activity in user.activities:\n                if isinstance(activity, discord.BaseActivity):\n                    if activity.name is not None:\n                        to_check.append(activity.name)\n\n            for activity in to_check:\n                for pattern in params.value:\n                    if fnmatch.fnmatch(activity.lower(), pattern.lower()):\n                        return True\n\n            return False\n\n        @checker(Condition.UserStatusMatchesAny)\n        async def user_status_matches_any(params: models.NonEmptyListStr):\n            status_str = str(user.status)\n            for status in params.value:\n                if status.lower() == status_str:\n                    return True\n            return False\n\n        @checker(Condition.UserIdMatchesAny)\n        async def user_id_matches_any(params: models.NonEmptyListInt):\n            for _id in params.value:\n                if _id == user.id:\n                    return True\n            return False\n\n        @checker(Condition.UsernameMatchesAny)\n        async def username_matches_any(params: models.NonEmptyListStr):\n            # One match = Passed\n            name = user.name.lower()\n            for pattern in params.value:\n                if fnmatch.fnmatch(name, pattern.lower()):\n                    return True\n            return False\n\n        @checker(Condition.UsernameMatchesRegex)\n        async def username_matches_regex(params: models.IsStr):\n            return await run_user_regex(\n                rule_obj=self,\n                cog=cog,\n                guild=guild,\n                regex=params.value,\n                text=user.name\n            )\n\n        @checker(Condition.NicknameMatchesAny)\n        async def nickname_matches_any(params: models.NonEmptyListStr):\n            # One match = Passed\n            if not user.nick:\n                return False\n            nick = user.nick.lower()\n            for pattern in params.value:\n                if fnmatch.fnmatch(nick, pattern.lower()):\n                    return True\n            return False\n\n        @checker(Condition.NicknameMatchesRegex)\n        async def nickname_matches_regex(params: models.IsStr):\n            if not user.nick:\n                return False\n            return await run_user_regex(\n                rule_obj=self,\n                cog=cog,\n                guild=guild,\n                regex=params.value,\n                text=user.nick\n            )\n\n        @checker(Condition.ChannelMatchesAny)\n        async def channel_matches_any(params: models.NonEmptyList):\n            if channel.id in params.value:\n                return True\n            for channel_str in params.value:\n                channel_str = str(channel_str)\n                channel_obj = discord.utils.get(guild.text_channels, name=channel_str)\n                if channel_obj is not None and channel_obj == channel:\n                    return True\n            return False\n\n        @checker(Condition.CategoryMatchesAny)\n        async def category_matches_any(params: models.NonEmptyList):\n            if channel.category is None:\n                return False\n            if channel.category.id in params.value:\n                return True\n            for category_str in params.value:\n                category_str = str(category_str)\n                category_obj = discord.utils.get(guild.categories, name=category_str)\n                if category_obj is not None and category_obj == channel.category:\n                    return True\n            return False\n\n        @checker(Condition.ChannelIsPublic)\n        async def channel_is_public(params: models.IsBool):\n            everyone = guild.default_role\n            public = everyone not in channel.overwrites or channel.overwrites[everyone].read_messages in (True, None)\n            return params.value is public\n\n        @checker(Condition.UserCreatedLessThan)\n        async def user_created_less_than(params: models.UserJoinedCreated):\n            if isinstance(params.value, int):\n                if params.value == 0:\n                    return True\n                x_hours_ago = utcnow() - datetime.timedelta(hours=params.value)\n            else:\n                x_hours_ago = utcnow() - params.value # type: ignore\n\n            return user.created_at > x_hours_ago\n\n        @checker(Condition.UserIsRank)\n        async def user_is_rank(params: models.IsRank):\n            return await cog.rank_user(user) == Rank(params.value)\n\n        @checker(Condition.UserJoinedLessThan)\n        async def user_joined_less_than(params: models.UserJoinedCreated):\n            if isinstance(params.value, int):\n                if params.value == 0:\n                    return True\n                x_hours_ago = utcnow() - datetime.timedelta(hours=params.value)\n            else:\n                x_hours_ago = utcnow() - params.value # type: ignore\n\n            return user.joined_at > x_hours_ago\n\n        @checker(Condition.UserHasDefaultAvatar)\n        async def user_has_default_avatar(params: models.IsBool):\n            default_avatar_url_pattern = \"*/embed/avatars/*.png\"\n            match = fnmatch.fnmatch(str(user.avatar_url), default_avatar_url_pattern)\n            return params.value is match\n\n        @checker(Condition.InEmergencyMode)\n        async def in_emergency_mode(params: models.IsBool):\n            in_emergency = cog.is_in_emergency_mode(guild)\n            return in_emergency is params.value\n\n        @checker(Condition.MessageHasAttachment)\n        async def message_has_attachment(params: models.IsBool):\n            return bool(message.attachments) is params.value\n\n        @checker(Condition.UserHasAnyRoleIn)\n        async def user_has_any_role_in(params: models.NonEmptyList):\n            for role_id_or_name in params.value:\n                role = guild.get_role(role_id_or_name)\n                if role is None:\n                    role = discord.utils.get(guild.roles, name=role_id_or_name)\n                if role:\n                    if role in user.roles:\n                        return True\n            return False\n\n        @checker(Condition.UserHasSentLessThanMessages)\n        async def user_has_sent_less_than_messages(params: models.IsInt):\n            msg_n = await cog.get_total_recorded_messages(user)\n            return msg_n < params.value\n\n        @checker(Condition.MessageContainsInvite)\n        async def message_contains_invite(params: models.IsBool):\n            results = INVITE_URL_RE.findall(message.content)\n            if results:\n                has_invite = True\n                try:\n                    if await get_external_invite(guild, results) is None:\n                        has_invite = False\n                except MisconfigurationError as e:\n                    raise ExecutionError(str(e))\n                except Exception as e:\n                    error_text = \"Unexpected error: failed to fetch server's own invites\"\n                    log.error(error_text, exc_info=e)\n                    raise ExecutionError(error_text)\n            else:\n                has_invite = False\n            return has_invite is params.value\n\n        @checker(Condition.MessageContainsMedia)\n        async def message_contains_media(params: models.IsBool):\n            has_media = MEDIA_URL_RE.search(message.content)\n            return bool(has_media) is params.value\n\n        @checker(Condition.MessageContainsUrl)\n        async def message_contains_url(params: models.IsBool):\n            has_url = URL_RE.search(message.content)\n            return bool(has_url) is params.value\n\n        @checker(Condition.MessageContainsMTMentions)\n        async def message_contains_mt_mentions(params: models.IsInt):\n            return len(message.raw_mentions) > params.value\n\n        @checker(Condition.MessageContainsMTUniqueMentions)\n        async def message_contains_mt_unique_mentions(params: models.IsInt):\n            return len(set(message.mentions)) > params.value\n\n        @checker(Condition.MessageContainsMTRolePings)\n        async def message_contains_mt_role_pings(params: models.IsInt):\n            return len(message.role_mentions) > params.value\n\n        @checker(Condition.MessageContainsMTEmojis)\n        async def message_contains_mt_emojis(params: models.IsInt):\n            over_limit = has_x_or_more_emojis(cog.bot, guild, message.content, params.value + 1)\n            return over_limit\n\n        @checker(Condition.MessageHasMTCharacters)\n        async def message_has_mt_characters(params: models.IsInt):\n            # We're turning one custom emoji code into a single character to avoid\n            # unexpected (from a user's POV) behaviour\n            clean_content = REMOVE_C_EMOJIS_RE.sub(\"x\", message.clean_content)\n            return len(clean_content) > params.value\n\n        @checker(Condition.IsStaff)\n        async def is_staff(params: models.IsBool):\n            is_staff = await cog.bot.is_mod(user)\n            return is_staff is params.value\n\n        @checker(Condition.IsHelper)\n        async def is_helper(params: models.IsBool):\n            is_helper = await cog.is_helper(user)\n            return is_helper is params.value\n\n        @checker(Condition.UserHeatIs)\n        async def user_heat_is(params: models.IsInt):\n            return heat.get_user_heat(user, debug=debug) == params.value\n\n        @checker(Condition.ChannelHeatIs)\n        async def channel_heat_is(params: models.IsInt):\n            return heat.get_channel_heat(channel, debug=debug) == params.value\n\n        @checker(Condition.CustomHeatIs)\n        async def custom_heat_is(params: models.CheckCustomHeatpoint):\n            heat_key = Template(params.label).safe_substitute(templates_vars)\n            return heat.get_custom_heat(guild, heat_key, debug=debug) == params.points\n\n        @checker(Condition.UserHeatMoreThan)\n        async def user_heat_more_than(params: models.IsInt):\n            return heat.get_user_heat(user, debug=debug) > params.value\n\n        @checker(Condition.ChannelHeatMoreThan)\n        async def channel_heat_more_than(params: models.IsInt):\n            return heat.get_channel_heat(channel, debug=debug) > params.value\n\n        @checker(Condition.CustomHeatMoreThan)\n        async def custom_heat_more_than(params: models.CheckCustomHeatpoint):\n            heat_key = Template(params.label).safe_substitute(templates_vars)\n            return heat.get_custom_heat(guild, heat_key, debug=debug) > params.points\n\n        @checker(Condition.Compare)\n        async def compare(params: models.Compare):\n            value1 = safe_sub(params.value1)\n            value2 = safe_sub(params.value2)\n\n            if params.operator == \"==\":\n                return value1 == value2\n            elif params.operator == \"contains\":\n                return value2 in value1\n            elif params.operator == \"contains-pattern\":\n                return fnmatch.fnmatch(value1.lower(), value2.lower())\n            elif params.operator == \"!=\":\n                return value1 != value2\n\n            # Numeric operators\n            try:\n                value1, value2 = int(value1), int(value2)\n            except ValueError:\n                raise ExecutionError(f\"Could not compare {value1} with {value2}: they both need to be numbers!\")\n\n            if params.operator == \">\":\n                return value1 > value2\n            elif params.operator == \"<\":\n                return value1 < value2\n            elif params.operator == \"<=\":\n                return value1 <= value2\n            elif params.operator == \">=\":\n                return value1 >= value2\n\n        if debug:\n            for condition in Condition:\n                if condition not in checkers:\n                    raise ExecutionError(f\"{condition.value} does not have a checker.\")\n\n        bools = []\n\n        for raw_condition in conditions:\n\n            condition = value = None\n            for c, v in raw_condition.items():\n                condition, value = c, v\n\n            condition = Condition(condition)\n\n            params = model_validator(condition, value)\n            try:\n                processor_func = checkers[condition]\n            except KeyError:\n                raise ExecutionError(f\"Unhandled condition '{condition.value}'.\")\n\n            try:\n                result = await processor_func(params)\n            except ExecutionError as e:\n                if cog: # is None in unit tests\n                    cog.send_to_monitor(guild, f\"[Warden] ({self.name}): {e}\")\n                raise e\n            if result in (True, False):\n                bools.append(result)\n            else:\n                raise ExecutionError(f\"Unexpected condition evaluation result for '{condition.value}'.\")\n\n        return bools\n\n    async def do_actions(self, *, cog: MixinMeta, user: discord.Member=None, message: discord.Message=None,\n                         guild: discord.Guild=None, debug=False):\n        if message and not user:\n            user = message.author\n        guild = guild if guild else user.guild\n        channel: discord.Channel = message.channel if message else None\n\n        templates_vars = {}\n        await populate_ctx_vars(t_vars=templates_vars,\n                                rule=self,\n                                cog=cog,\n                                guild=guild,\n                                message=message,\n                                user=user,\n                                channel=channel,\n                                debug=debug)\n\n        def safe_sub(string):\n            if string == discord.Embed.Empty:\n                return string\n            return Template(string).safe_substitute(templates_vars)\n\n        #for heat_key in heat.get_custom_heat_keys(guild):\n        #    templates_vars[f\"custom_heat_{heat_key}\"] = heat.get_custom_heat(guild, heat_key)\n\n        last_sent_message: Optional[discord.Message] = None\n        last_expel_action = None\n\n        processors = {}\n\n        def processor(action: Action, suggest: Action=None):\n            def decorator(function):\n                def wrapper(*args, **kwargs):\n                    if suggest is not None:\n                        cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Action \"\n                                                   f\"'{action.value}' is deprecated, use \"\n                                                   f\"'{suggest.value}' instead.\")\n                    return function(*args, **kwargs)\n                processors[action] = wrapper\n                return wrapper\n            return decorator\n\n        @processor(Action.DeleteUserMessage)\n        async def delete_user_message(params: models.IsNone):\n            await message.delete()\n\n        @processor(Action.Dm, suggest=Action.SendMessage)\n        async def send_dm(params: models.SendMessageToUser):\n            nonlocal last_sent_message\n            user_to_dm = guild.get_member(params.id)\n            if not user_to_dm:\n                user_to_dm = discord.utils.get(guild.members, name=params.id)\n            if not user_to_dm:\n                return\n            content = Template(params.content).safe_substitute(templates_vars)\n            try:\n                last_sent_message = await user_to_dm.send(content)\n            except:\n                cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Failed to DM user \"\n                                    f\"{user_to_dm} ({user_to_dm.id})\")\n                last_sent_message = None\n\n        @processor(Action.DmUser, suggest=Action.SendMessage)\n        async def send_user_dm(params: models.IsStr):\n            nonlocal last_sent_message\n            text = Template(params.value).safe_substitute(templates_vars)\n            try:\n                last_sent_message = await user.send(text)\n            except:\n                cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Failed to DM user \"\n                                    f\"{user} ({user.id})\")\n                last_sent_message = None\n\n        @processor(Action.NotifyStaff)\n        async def notify_staff(params: models.NotifyStaff):\n            nonlocal last_sent_message\n            # Checks if only \"content\" has been passed\n            text_only = params.__fields_set__ == {\"content\"}\n\n            quick_action = None\n            if params.qa_target:\n                if params.qa_reason is None:\n                    params.qa_reason = \"\"\n\n                params.qa_target = safe_sub(params.qa_target)\n                params.qa_reason = safe_sub(params.qa_reason)\n\n                try:\n                    quick_action = QuickAction(int(params.qa_target), params.qa_reason)\n                except ValueError:\n                    raise ExecutionError(f\"{params.qa_target} is not a valid ID for a Quick Action target.\")\n\n            jump_to_msg = None\n\n            if params.jump_to_ctx_message:\n                jump_to_msg = message\n\n            if params.jump_to:\n                params.jump_to.channel_id = safe_sub(params.jump_to.channel_id)\n                params.jump_to.message_id = safe_sub(params.jump_to.message_id)\n                try:\n                    jump_to_ch = discord.utils.get(guild.text_channels, id=int(params.jump_to.channel_id))\n                except ValueError:\n                    raise ExecutionError(f\"{params.jump_to.channel_id} is not a valid channel ID for a \\\"jump to\\\" message.\")\n                if not params.jump_to.message_id.isdigit():\n                    raise ExecutionError(f\"{params.jump_to.message_id} is not a valid message ID for a \\\"jump to\\\" message.\")\n                if jump_to_ch:\n                    jump_to_msg = jump_to_ch.get_partial_message(params.jump_to.message_id)\n                else:\n                    raise ExecutionError(f\"I could not find the destination channel for the \\\"jump to\\\" message.\")\n\n            title = safe_sub(params.title) if params.title else None\n            heat_key = safe_sub(params.no_repeat_key) if params.no_repeat_key else None\n\n            fields = []\n\n            if params.fields:\n                for param in params.fields:\n                    fields.append(param.dict())\n\n            for field in fields:\n                for attr in (\"name\", \"value\"):\n                    if attr in field:\n                        field[attr] = safe_sub(field[attr])\n\n            if params.add_ctx_fields:\n                ctx_fields = []\n                if user:\n                    ctx_fields.append({\"name\": \"Username\", \"value\": f\"`{user}`\"})\n                    ctx_fields.append({\"name\": \"ID\", \"value\": f\"`{user.id}`\"})\n                if message:\n                    ctx_fields.append({\"name\": \"Channel\", \"value\": message.channel.mention})\n                fields = ctx_fields + fields\n\n            footer = None\n            if not text_only:\n                if params.footer_text is None:\n                    footer = f\"Warden rule `{self.name}`\"\n                elif params.footer_text == \"\":\n                    footer = None\n                else:\n                    footer = safe_sub(params.footer_text)\n\n            last_sent_message = await cog.send_notification(guild,\n                                                            safe_sub(params.content),\n                                                            title=title,\n                                                            ping=params.ping,\n                                                            fields=fields,\n                                                            footer=footer,\n                                                            thumbnail=safe_sub(params.thumbnail) if params.thumbnail else None,\n                                                            jump_to=jump_to_msg,\n                                                            no_repeat_for=params.no_repeat_for,\n                                                            heat_key=heat_key,\n                                                            quick_action=quick_action,\n                                                            force_text_only=text_only,\n                                                            allow_everyone_ping=params.allow_everyone_ping)\n\n        @processor(Action.NotifyStaffAndPing, suggest=Action.NotifyStaff)\n        async def notify_staff_and_ping(params: models.IsStr):\n            nonlocal last_sent_message\n            text = Template(params.value).safe_substitute(templates_vars)\n            last_sent_message = await cog.send_notification(guild, text, ping=True, allow_everyone_ping=True,\n                                                            force_text_only=True)\n\n        @processor(Action.NotifyStaffWithEmbed, suggest=Action.NotifyStaff)\n        async def notify_staff_with_embed(params: models.NotifyStaffWithEmbed):\n            nonlocal last_sent_message\n            title = Template(params.title).safe_substitute(templates_vars)\n            content = Template(params.content).safe_substitute(templates_vars)\n            last_sent_message = await cog.send_notification(guild, content,\n                                                            title=title, footer=f\"Warden rule `{self.name}`\",\n                                                            allow_everyone_ping=True)\n\n        @processor(Action.SendInChannel, suggest=Action.SendMessage)\n        async def send_in_channel(params: models.IsStr):\n            nonlocal last_sent_message\n            text = Template(params.value).safe_substitute(templates_vars)\n            last_sent_message = await channel.send(text, allowed_mentions=ALLOW_ALL_MENTIONS)\n\n        @processor(Action.SetChannelSlowmode)\n        async def set_channel_slowmode(params: models.IsTimedelta):\n            if params.value.seconds != channel.slowmode_delay:\n                await channel.edit(slowmode_delay=params.value.seconds)\n\n        @processor(Action.SendToChannel, suggest=Action.SendMessage)\n        async def send_to_channel(params: models.SendMessageToChannel):\n            nonlocal last_sent_message\n            channel_dest = guild.get_channel(params.id_or_name)\n            if not channel_dest:\n                channel_dest = discord.utils.get(guild.text_channels, name=params.id_or_name)\n            if not channel_dest:\n                raise ExecutionError(f\"Channel '{params.id_or_name}' not found.\")\n            content = Template(params.content).safe_substitute(templates_vars)\n            last_sent_message = await channel_dest.send(content, allowed_mentions=ALLOW_ALL_MENTIONS)\n\n        @processor(Action.AddRolesToUser)\n        async def add_roles_to_user(params: models.NonEmptyList):\n            to_assign = []\n            for role_id_or_name in params.value:\n                role = guild.get_role(role_id_or_name)\n                if role is None:\n                    role = discord.utils.get(guild.roles, name=role_id_or_name)\n                if role:\n                    to_assign.append(role)\n            to_assign = list(set(to_assign))\n            to_assign = [r for r in to_assign if r not in user.roles]\n            if to_assign:\n                await user.add_roles(*to_assign, reason=f\"Assigned by Warden rule '{self.name}'\")\n\n        @processor(Action.RemoveRolesFromUser)\n        async def remove_roles_from_user(params: models.NonEmptyList):\n            to_unassign = []\n            for role_id_or_name in params.value:\n                role = guild.get_role(role_id_or_name)\n                if role is None:\n                    role = discord.utils.get(guild.roles, name=role_id_or_name)\n                if role:\n                    to_unassign.append(role)\n            to_unassign = list(set(to_unassign))\n            to_unassign = [r for r in to_unassign if r in user.roles]\n            if to_unassign:\n                await user.remove_roles(*to_unassign, reason=f\"Unassigned by Warden rule '{self.name}'\")\n\n        @processor(Action.SetUserNickname)\n        async def set_user_nickname(params: models.IsStr):\n            if params.value == \"\":\n                value = None\n            else:\n                value = Template(params.value).safe_substitute(templates_vars)\n            await user.edit(nick=value, reason=f\"Changed nickname by Warden rule '{self.name}'\")\n\n        @processor(Action.BanAndDelete)\n        async def ban_and_delete(params: models.IsInt):\n            nonlocal last_expel_action\n            if user not in guild.members:\n                raise ExecutionError(f\"User {user} ({user.id}) not in the server.\")\n            reason = f\"Banned by Warden rule '{self.name}'\"\n            await guild.ban(user, delete_message_days=params.value, reason=reason)\n            last_expel_action = ModAction.Ban\n            cog.dispatch_event(\"member_remove\", user, ModAction.Ban.value, reason)\n\n        @processor(Action.Kick)\n        async def kick(params: models.IsNone):\n            nonlocal last_expel_action\n            if user not in guild.members:\n                raise ExecutionError(f\"User {user} ({user.id}) not in the server.\")\n            reason = f\"Kicked by Warden action '{self.name}'\"\n            await guild.kick(user, reason=reason)\n            last_expel_action = ModAction.Kick\n            cog.dispatch_event(\"member_remove\", user, ModAction.Kick.value, reason)\n\n        @processor(Action.Softban)\n        async def softban(params: models.IsNone):\n            nonlocal last_expel_action\n            if user not in guild.members:\n                raise ExecutionError(f\"User {user} ({user.id}) not in the server.\")\n            reason = f\"Softbanned by Warden rule '{self.name}'\"\n            await guild.ban(user, delete_message_days=1, reason=reason)\n            await guild.unban(user)\n            last_expel_action = Action.Softban\n            cog.dispatch_event(\"member_remove\", user, ModAction.Softban.value, reason)\n\n        @processor(Action.PunishUser)\n        async def punish_user(params: models.IsNone):\n            punish_role = guild.get_role(await cog.config.guild(guild).punish_role())\n            if punish_role and not cog.is_role_privileged(punish_role):\n                await user.add_roles(punish_role, reason=f\"Punished by Warden rule '{self.name}'\")\n            else:\n                cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Failed to punish user. Is the punish role \"\n                                            \"still present and with *no* privileges?\")\n\n        @processor(Action.PunishUserWithMessage)\n        async def punish_user_with_message(params: models.IsNone):\n            punish_role = guild.get_role(await cog.config.guild(guild).punish_role())\n            punish_message = await cog.config.guild(guild).punish_message()\n            if punish_role and not cog.is_role_privileged(punish_role):\n                await user.add_roles(punish_role, reason=f\"Punished by Warden rule '{self.name}'\")\n                if punish_message:\n                    await channel.send(f\"{user.mention} {punish_message}\")\n            else:\n                cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Failed to punish user. Is the punish role \"\n                                            \"still present and with *no* privileges?\")\n\n        @processor(Action.Modlog)\n        async def send_mod_log(params: models.IsStr):\n            if last_expel_action is None:\n                return\n            reason = Template(params.value).safe_substitute(templates_vars)\n            await cog.create_modlog_case(\n                cog.bot,\n                guild,\n                utcnow(),\n                last_expel_action.value,\n                user,\n                guild.me,\n                reason,\n                until=None,\n                channel=None,\n            )\n\n        @processor(Action.EnableEmergencyMode)\n        async def enable_emergency_mode(params: models.IsBool):\n            if params.value:\n                cog.emergency_mode[guild.id] = EmergencyMode(manual=True)\n            else:\n                try:\n                    del cog.emergency_mode[guild.id]\n                except KeyError:\n                    pass\n\n        @processor(Action.SendToMonitor)\n        async def send_to_monitor(params: models.IsStr):\n            value = Template(params.value).safe_substitute(templates_vars)\n            cog.send_to_monitor(guild, f\"[Warden] ({self.name}): {value}\")\n\n        @processor(Action.AddUserHeatpoint)\n        async def add_user_heatpoint(params: models.IsTimedelta):\n            heat.increase_user_heat(user, params.value, debug=debug) # type: ignore\n            templates_vars[\"user_heat\"] = heat.get_user_heat(user, debug=debug)\n\n        @processor(Action.AddUserHeatpoints)\n        async def add_user_heatpoints(params: models.AddHeatpoints):\n            for _ in range(params.points):\n                heat.increase_user_heat(user, params.delta, debug=debug) # type: ignore\n            templates_vars[\"user_heat\"] = heat.get_user_heat(user, debug=debug)\n\n        @processor(Action.AddChannelHeatpoint)\n        async def add_channel_heatpoint(params: models.IsTimedelta):\n            heat.increase_channel_heat(channel, params.value, debug=debug) # type: ignore\n            templates_vars[\"channel_heat\"] = heat.get_channel_heat(channel, debug=debug)\n\n        @processor(Action.AddChannelHeatpoints)\n        async def add_channel_heatpoints(params: models.AddHeatpoints):\n            for _ in range(params.points):\n                heat.increase_channel_heat(channel, params.delta, debug=debug) # type: ignore\n            templates_vars[\"channel_heat\"] = heat.get_channel_heat(channel, debug=debug)\n\n        @processor(Action.AddCustomHeatpoint)\n        async def add_custom_heatpoint(params: models.AddCustomHeatpoint):\n            heat_key = Template(params.label).safe_substitute(templates_vars)\n            heat.increase_custom_heat(guild, heat_key, params.delta, debug=debug) # type: ignore\n\n        @processor(Action.AddCustomHeatpoints)\n        async def add_custom_heatpoints(params: models.AddCustomHeatpoints):\n            heat_key = Template(params.label).safe_substitute(templates_vars)\n            for _ in range(params.points):\n                heat.increase_custom_heat(guild, heat_key, params.delta, debug=debug) # type: ignore\n\n        @processor(Action.EmptyUserHeat)\n        async def empty_user_heat(params: models.IsNone):\n            heat.empty_user_heat(user, debug=debug)\n\n        @processor(Action.EmptyChannelHeat)\n        async def empty_channel_heat(params: models.IsNone):\n            heat.empty_channel_heat(channel, debug=debug)\n\n        @processor(Action.EmptyCustomHeat)\n        async def empty_custom_heat(params: models.IsStr):\n            heat_key = Template(params.value).safe_substitute(templates_vars)\n            heat.empty_custom_heat(guild, heat_key, debug=debug)\n\n        @processor(Action.IssueCommand)\n        async def issue_command(params: models.IssueCommand):\n            issuer = guild.get_member(params.issue_as)\n            if issuer is None:\n                raise ExecutionError(f\"User {params.issue_as} is not in the server.\")\n            msg_obj = df_cache.get_msg_obj()\n            if msg_obj is None:\n                raise ExecutionError(f\"Failed to issue command. Sorry!\")\n\n            # User id + command in a non-message context\n            if message is None and params.destination is None:\n                notify_channel_id = await cog.config.guild(guild).notify_channel()\n                msg_obj.channel = guild.get_channel(notify_channel_id)\n                if msg_obj.channel is None:\n                    raise ExecutionError(f\"Failed to issue command. I could not find the \"\n                                         \"notification channel.\")\n            else:\n                if params.destination is None: # User id + command in a message context\n                    msg_obj.channel = message.channel\n                else: # User id + command + arbitrary destination\n                    params.destination = safe_sub(params.destination)\n                    try:\n                        msg_obj.channel = guild.get_channel(int(params.destination))\n                    except ValueError:\n                        raise ExecutionError(f\"{params.destination} is not a valid ID.\")\n                    if msg_obj.channel is None:\n                        raise ExecutionError(f\"Failed to issue command. I could not find the \"\n                                            \"notification channel.\")\n\n            msg_obj.author = issuer\n            prefix = await cog.bot.get_prefix(msg_obj)\n            msg_obj.content = prefix[0] + safe_sub(params.command)\n            cog.bot.dispatch(\"message\", msg_obj)\n\n        @processor(Action.DeleteLastMessageSentAfter)\n        async def delete_last_message_sent_after(params: models.IsTimedelta):\n            nonlocal last_sent_message\n            if last_sent_message is not None:\n                cog.loop.create_task(delete_message_after(last_sent_message, params.value.seconds))\n                last_sent_message = None\n\n        @processor(Action.SendMessage)\n        async def send_message(params: models.SendMessage):\n            nonlocal last_sent_message\n            default_values = 0\n\n            for key in params.dict():\n                if key == \"edit_message_id\":\n                    continue\n                attr = getattr(params, key)\n                if attr is None:\n                    default_values += 1\n                    setattr(params, key, discord.Embed.Empty)\n                elif isinstance(attr, str):\n                    setattr(params, key, safe_sub(attr))\n\n            is_user = False\n            if params.id.isdigit():\n                params.id = int(params.id)\n                destination = discord.utils.get(guild.text_channels, id=params.id)\n                if destination is None:\n                    destination = guild.get_member(params.id)\n                    if destination is None:\n                        cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Failed to send message, \"\n                                                    f\"I could not find the recipient.\")\n                        return\n                    else:\n                        is_user = True\n            else:\n                destination = discord.utils.get(guild.text_channels, name=params.id)\n                if destination is None:\n                    raise ExecutionError(f\"[Warden] ({self.name}): Failed to send message, \"\n                                        f\"'{params.id}' is not a valid channel name.\")\n\n            em = None\n            no_embed = default_values >= 10 # Yuck, maybe I'll think of something better\n\n            if no_embed and not params.content:\n                raise ExecutionError(f\"[Warden] ({self.name}): I have no content and \"\n                                      \"no embed to send.\")\n\n            if no_embed is False:\n                em = discord.Embed(title=params.title,\n                                description=params.description,\n                                url=params.url)\n\n                if params.author_name:\n                    em.set_author(name=params.author_name, url=params.author_url,\n                                icon_url=params.author_icon_url)\n                em.set_image(url=params.image)\n                em.set_thumbnail(url=params.thumbnail)\n                em.set_footer(text=params.footer_text, icon_url=params.footer_icon_url)\n                for field in params.fields:\n                    em.add_field(name=safe_sub(field.name),\n                                value=safe_sub(field.value),\n                                inline=field.inline)\n                if params.add_timestamp:\n                    em.timestamp = utcnow()\n\n                if params.color is True:\n                    em.color = await cog.bot.get_embed_color(destination)\n                elif not params.color:\n                    pass\n                else:\n                    em.color = discord.Colour(params.color)\n\n            mentions = discord.AllowedMentions(everyone=params.allow_mass_mentions, roles=True, users=True,\n                                               replied_user=params.ping_on_reply)\n\n            if params.edit_message_id:\n                params.edit_message_id = safe_sub(params.edit_message_id)\n\n            if isinstance(destination, discord.Member):\n                destination = destination.dm_channel if destination.dm_channel else await destination.create_dm()\n\n            reference = None\n            if params.reply_message_id:\n                params.reply_message_id = safe_sub(params.reply_message_id)\n                if params.reply_message_id.isdigit():\n                    reference = destination.get_partial_message(int(params.reply_message_id))\n\n            if not params.edit_message_id:\n                try:\n                    last_sent_message = await destination.send(params.content, embed=em, allowed_mentions=mentions,\n                                                               reference=reference)\n                except (discord.HTTPException, discord.Forbidden) as e:\n                    # A user could just have DMs disabled\n                    if is_user is False:\n                        raise ExecutionError(f\"[Warden] ({self.name}): Failed to deliver message \"\n                                            f\"to channel #{destination}. {e}\")\n            else:\n                try:\n                    partial_msg = destination.get_partial_message(int(params.edit_message_id))\n                    await partial_msg.edit(content=params.content if params.content else None,\n                                           embed=em, allowed_mentions=mentions)\n                except (discord.HTTPException, discord.Forbidden) as e:\n                    raise ExecutionError(f\"[Warden] ({self.name}): Failed to edit message \"\n                                        f\"in channel #{destination}. {e}\")\n                except ValueError:\n                    raise ExecutionError(f\"[Warden] ({self.name}): Failed to edit message. \"\n                                        f\"{params.edit_message_id} is not a valid ID\")\n\n        @processor(Action.GetUserInfo)\n        async def get_user_info(params: models.GetUserInfo):\n            params.id = safe_sub(params.id)\n            if not params.id.isdigit():\n                raise ExecutionError(f\"{params.id} is not a valid ID.\")\n\n            member = guild.get_member(int(params.id))\n            if not member:\n                raise ExecutionError(f\"Member {params.id} not found.\")\n\n            for target, attr in params.mapping.items():\n                if attr.startswith(\"_\") or \".\" in attr:\n                    raise ExecutionError(f\"You cannot access internal attributes.\")\n\n                attr = attr.lower()\n\n                if attr == \"rank\":\n                    value = await cog.rank_user(member)\n                    value = value.value\n                elif attr == \"is_staff\":\n                    value = await cog.bot.is_mod(member)\n                elif attr == \"is_helper\":\n                    value = await cog.is_helper(member)\n                elif attr == \"message_count\":\n                    value = await cog.get_total_recorded_messages(member)\n                else:\n                    value = getattr(member, attr, None)\n                    if value is None:\n                        raise ExecutionError(f\"Attribute \\\"{attr}\\\" does not exist.\")\n\n                if isinstance(value, bool):\n                    value = str(value).lower()\n                elif isinstance(value, datetime.datetime):\n                    value = value.strftime(\"%Y/%m/%d %H:%M:%S\")\n                elif isinstance(value, discord.BaseActivity):\n                    value = value.name if value.name is not None else \"none\"\n                elif isinstance(value, discord.Spotify):\n                    value = \"none\"\n                elif isinstance(value, (str, int, discord.Asset, discord.Status)):\n                    value = str(value)\n                else:\n                    raise ExecutionError(f\"Attribute \\\"{attr}\\\" not supported.\")\n\n                templates_vars[safe_sub(target)] = value\n\n        @processor(Action.Exit)\n        async def exit(params: models.IsNone):\n            raise StopExecution(\"Exiting.\")\n\n        @processor(Action.VarAssign)\n        async def assign(params: models.VarAssign):\n            if params.evaluate:\n                params.value = safe_sub(params.value)\n\n            templates_vars[safe_sub(params.var_name)] = params.value\n\n        @processor(Action.VarAssignRandom)\n        async def assign_random(params: models.VarAssignRandom):\n            choices = []\n            weights = []\n\n            if isinstance(params.choices, list):\n                choices = params.choices\n            else:\n                for k, v in params.choices.items():\n                    choices.append(k)\n                    weights.append(v)\n\n            choice = random.choices(choices, weights=weights or None, k=1)[0]\n            if params.evaluate:\n                choice = safe_sub(choice)\n\n            templates_vars[safe_sub(params.var_name)] = choice\n\n        @processor(Action.VarReplace)\n        async def var_replace(params: models.VarReplace):\n            var_name = safe_sub(params.var_name)\n            var = templates_vars.get(var_name, None)\n            if var is None:\n                raise ExecutionError(f\"Variable \\\"{var_name}\\\" does not exist.\")\n\n            to_sub = []\n\n            if isinstance(params.strings, str):\n                to_sub.append(params.strings)\n            else:\n                to_sub = params.strings\n\n            for sub in to_sub:\n                var = var.replace(sub, params.substring)\n\n            templates_vars[var_name] = var\n\n        @processor(Action.VarSplit)\n        async def var_split(params: models.VarSplit):\n            var_name = safe_sub(params.var_name)\n            var = templates_vars.get(var_name, None)\n            if var is None:\n                raise ExecutionError(f\"Variable \\\"{var_name}\\\" does not exist.\")\n\n            sequences = var.split(params.separator, maxsplit=params.max_split)\n\n            for i, var in enumerate(params.split_into):\n                try:\n                    templates_vars[var] = sequences[i]\n                except IndexError:\n                    templates_vars[var] = \"\"\n\n        @processor(Action.VarTransform)\n        async def var_transform(params: models.VarTransform):\n            var_name = safe_sub(params.var_name)\n            var = templates_vars.get(var_name, None)\n            if var is None:\n                raise ExecutionError(f\"Variable \\\"{var_name}\\\" does not exist.\")\n\n            operation = params.operation.lower()\n\n            if operation == \"capitalize\":\n                var = var.capitalize()\n            elif operation == \"lowercase\":\n                var = var.lower()\n            elif operation == \"reverse\":\n                var = var[::-1]\n            elif operation == \"uppercase\":\n                var = var.upper()\n            elif operation == \"title\":\n                var = var.title()\n\n            templates_vars[var_name] = var\n\n        @processor(Action.VarSlice)\n        async def var_slice(params: models.VarSlice):\n            var_name = safe_sub(params.var_name)\n            var = templates_vars.get(var_name, None)\n            if var is None:\n                raise ExecutionError(f\"Variable \\\"{var_name}\\\" does not exist.\")\n\n            var = var[params.index:params.end_index:params.step]\n\n            if params.slice_into:\n                templates_vars[safe_sub(params.slice_into)] = var\n            else:\n                templates_vars[var_name] = var\n\n        @processor(Action.NoOp)\n        async def no_op(params: models.IsNone):\n            pass\n\n        if debug:\n            for action in Action:\n                if action not in processors:\n                    raise ExecutionError(f\"{action.value} does not have a processor.\")\n\n        async def process_action(action, value):\n            self.last_action = action\n            if debug and action not in ALLOWED_DEBUG_ACTIONS:\n                return\n\n            params = model_validator(action, value)\n\n            try:\n                processor_func = processors[action]\n            except KeyError:\n                raise ExecutionError(f\"Unhandled action '{action.value}'.\")\n\n            await processor_func(params)\n\n\n        last_cond_action_result = None\n\n        for entry in self.actions:\n            for enum, value in entry.items():\n                enum = self._get_actions_enum(enum)\n                if isinstance(enum, Action):\n                    try:\n                        await process_action(enum, value)\n                    except StopExecution:\n                        return bool(last_expel_action)\n                elif isinstance(enum, Condition):\n                    _eval = await self._evaluate_conditions([{enum.value: value}],\n                                                            cog=cog, user=user, message=message,\n                                                            guild=guild, templates_vars=templates_vars,\n                                                            debug=debug)\n                    last_cond_action_result = _eval[0]\n                elif isinstance(enum, ConditionBlock):\n                    _eval = await self._evaluate_conditions_block(block=[{enum.value: value}],\n                                                                  cog=cog, user=user, message=message,\n                                                                  guild=guild, templates_vars=templates_vars,\n                                                                  debug=debug)\n                    last_cond_action_result = bool(_eval)\n                elif isinstance(enum, ConditionalActionBlock):\n                    is_true = enum == ConditionalActionBlock.IfTrue and last_cond_action_result is True\n                    is_false = enum == ConditionalActionBlock.IfFalse and last_cond_action_result is False\n                    if is_true or is_false:\n                        for raw_action in value:\n                            for action, subvalue in raw_action.items():\n                                action = self._get_actions_enum(action)\n                                try:\n                                    await process_action(action, subvalue)\n                                except StopExecution:\n                                    return bool(last_expel_action)\n\n        return bool(last_expel_action)\n\n    def _get_actions_enum(self, enum):\n        try:\n            enum = Action(enum)\n        except ValueError:\n            try:\n                enum = Condition(enum)\n            except ValueError:\n                try:\n                    enum = ConditionBlock(enum)\n                except ValueError:\n                    enum = ConditionalActionBlock(enum)\n\n        return enum\n\n    def __repr__(self):\n        return f\"<WardenRule '{self.name}'>\"\n\nasync def populate_ctx_vars(*, t_vars: dict, rule: WardenRule, cog, guild, message, user, channel, debug):\n    guild_icon_url = guild.icon_url_as()\n    guild_banner_url = guild.banner_url_as()\n    t_vars.update({\n        \"rule_name\": rule.name,\n        \"guild\": str(guild),\n        \"guild_id\": guild.id,\n        \"guild_icon_url\": guild_icon_url if guild_icon_url else \"\",\n        \"guild_banner_url\": guild_banner_url if guild_banner_url else \"\",\n        \"notification_channel_id\": await cog.config.guild(guild).notify_channel() if cog else 0,\n    })\n\n    if user:\n        t_vars.update({\n            \"user\": str(user),\n            \"user_name\": user.name,\n            \"user_id\": user.id,\n            \"user_mention\": user.mention,\n            \"user_nickname\": str(user.nick),\n            \"user_created_at\": user.created_at.strftime(\"%Y/%m/%d %H:%M:%S\"),\n            \"user_joined_at\": user.joined_at.strftime(\"%Y/%m/%d %H:%M:%S\"),\n            \"user_heat\": heat.get_user_heat(user, debug=debug),\n            \"user_avatar_url\": user.avatar_url\n        })\n\n    if message:\n        t_vars.update({\n            \"message\": message.content.replace(\"@\", \"@\\u200b\"),\n            \"message_clean\": message.clean_content,\n            \"message_id\": message.id,\n            \"message_created_at\": message.created_at,\n            \"message_link\": message.jump_url\n        })\n        if message.attachments:\n            attachment = message.attachments[0]\n            t_vars.update({\n                \"attachment_filename\": attachment.filename,\n                \"attachment_url\": attachment.url\n            })\n\n    if channel:\n        t_vars.update({\n            \"channel\": f\"#{channel}\",\n            \"channel_name\": channel.name,\n            \"channel_id\": channel.id,\n            \"channel_mention\": channel.mention,\n            \"channel_category\": channel.category.name if channel.category else \"None\",\n            \"channel_category_id\": channel.category.id if channel.category else \"0\",\n            \"channel_heat\": heat.get_channel_heat(channel, debug=debug),\n        })"], "fixing_code": ["\"\"\"\nDefender - Protects your community with automod features and\n           empowers the staff and users you trust with\n           advanced moderation tools\nCopyright (C) 2020-present  Twentysix (https://github.com/Twentysix26/)\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\nfrom __future__ import annotations\nfrom ...core.warden.validation import (ALLOWED_CONDITIONS, ALLOWED_ACTIONS, ALLOWED_DEBUG_ACTIONS, model_validator,\n                                       DEPRECATED)\nfrom ...core.warden import validation as models\nfrom ...enums import Rank, EmergencyMode, Action as ModAction\nfrom .enums import Action, Condition, Event, ConditionBlock, ConditionalActionBlock\nfrom .utils import has_x_or_more_emojis, REMOVE_C_EMOJIS_RE, run_user_regex, make_fuzzy_suggestion, delete_message_after\nfrom ...exceptions import InvalidRule, ExecutionError, StopExecution, MisconfigurationError\nfrom ...core import cache as df_cache\nfrom ...core.utils import get_external_invite, QuickAction, utcnow\nfrom redbot.core.utils.common_filters import INVITE_URL_RE\nfrom redbot.core.utils.chat_formatting import box\nfrom redbot.core.commands.converter import parse_timedelta\nfrom discord.ext.commands import BadArgument\nfrom string import Template\nfrom redbot.core import modlog\nfrom typing import Optional\nfrom pydantic import ValidationError\nfrom typing import TYPE_CHECKING\nfrom . import heat\nimport random\nimport yaml\nimport fnmatch\nimport discord\nimport datetime\nimport logging\nimport regex as re\n\nif TYPE_CHECKING:\n    from ...abc import MixinMeta\n\nlog = logging.getLogger(\"red.x26cogs.defender\")\n\nALLOW_ALL_MENTIONS = discord.AllowedMentions(everyone=True, roles=True, users=True)\nRULE_REQUIRED_KEYS = (\"name\", \"event\", \"rank\", \"if\", \"do\")\nRULE_FACULTATIVE_KEYS = (\"priority\", \"run-every\")\n\nMEDIA_URL_RE = re.compile(r\"\"\"(http)?s?:?(\\/\\/[^\"']*\\.(?:png|jpg|jpeg|gif|png|svg|mp4|gifv))\"\"\", re.I)\nURL_RE = re.compile(r\"\"\"https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)\"\"\", re.I)\n\nclass ConditionResult:\n    \"\"\"This is used to store the condition evaluations at runtime\n    It is designed to aid the user in debugging the rules\"\"\"\n    def __init__(self, rule_name, debug):\n        self.rule_name = rule_name\n        self.conditions = []\n        self.result = False\n        self.debug = debug\n\n    def add_condition(self, condition: Condition, result: bool):\n        if self.debug:\n            self.conditions.append((condition, result))\n\n    def add_condition_block(self, condition_block: ConditionBlock, inner_conditions: list, results: list):\n        if self.debug:\n            block = (condition_block, [])\n            for i, c in enumerate(inner_conditions):\n                block[1].append((next(iter(c)), results[i]))\n            self.conditions.append(block)\n\n    def __bool__(self):\n        return self.result\n\nclass WardenRule:\n    def __init__(self):\n        self.parse_exception = None\n        self.last_action = Action.NoOp\n        self.name = None\n        self.events = []\n        self.rank = Rank.Rank4\n        self.conditions = []\n        self.actions = {}\n        self.raw_rule = \"\"\n        self.priority = 2666\n        self.next_run = None\n        self.run_every = None\n\n    async def parse(self, rule_str, cog: MixinMeta, author=None):\n        self.raw_rule = rule_str\n\n        try:\n            rule = yaml.safe_load(rule_str)\n        except:\n            raise InvalidRule(\"Error parsing YAML. Please make sure the format \"\n                              \"is valid (a YAML validator may help)\")\n\n        if not isinstance(rule, dict):\n            raise InvalidRule(f\"This rule doesn't seem to follow the expected format.\")\n\n        if rule.get(\"name\") is None:\n            raise InvalidRule(\"Rule has no 'name' parameter.\")\n\n        self.name = rule[\"name\"].lower().replace(\" \", \"-\")\n\n        for key in rule.keys():\n            if key not in RULE_REQUIRED_KEYS and key not in RULE_FACULTATIVE_KEYS:\n                raise InvalidRule(f\"Unexpected key at root level: '{key}'.\")\n\n        for key in RULE_REQUIRED_KEYS:\n            if key not in rule.keys():\n                raise InvalidRule(f\"Missing key at root level: '{key}'.\")\n\n        if isinstance(rule[\"event\"], list):\n            try:\n                for event in rule[\"event\"]:\n                    self.events.append(Event(event))\n            except ValueError:\n                raise InvalidRule(f\"Invalid events.\")\n        else:\n            try:\n                self.events.append(Event(rule[\"event\"]))\n            except ValueError:\n                raise InvalidRule(\"Invalid event.\")\n        if not self.events:\n            raise InvalidRule(\"A least one event must be defined.\")\n\n        if Event.Periodic in self.events:\n            # cog is None when running tests\n            if cog and not await cog.config.wd_periodic_allowed():\n                raise InvalidRule(\"The creation of periodic Warden rules is currently disabled. \"\n                                  \"The bot owner must use '[p]dset warden periodicallowed' to \"\n                                  \"enable them.\")\n            if \"run-every\" not in rule.keys():\n                raise InvalidRule(\"The 'run-every' parameter is mandatory with \"\n                                  \"periodic rules.\")\n            try:\n                td = parse_timedelta(str(rule[\"run-every\"]),\n                                     maximum=datetime.timedelta(hours=24),\n                                     minimum=datetime.timedelta(minutes=5),\n                                     allowed_units=[\"hours\", \"minutes\"])\n                if td is None:\n                    raise BadArgument()\n            except BadArgument:\n                raise InvalidRule(\"The 'run-every' parameter must be between 5 minutes \"\n                                  \"and 24 hours.\")\n            else:\n                self.run_every = td\n                self.next_run = utcnow() + td\n        else:\n            if \"run-every\" in rule.keys():\n                raise InvalidRule(\"The 'periodic' event must be specified for rules with \"\n                                  \"a 'run-every' parameter.\")\n\n        try:\n            self.rank = Rank(rule[\"rank\"])\n        except:\n            raise InvalidRule(\"Invalid target rank. Must be 1-4.\")\n\n        try:\n            priority = rule[\"priority\"]\n            if not isinstance(priority, int) or priority < 1 or priority > 999:\n                raise InvalidRule(\"Priority must be a number between 1 and 999.\")\n            self.priority = priority\n        except KeyError:\n            pass\n\n        if \"if\" in rule:\n            if not isinstance(rule[\"if\"], list):\n                raise InvalidRule(\"Invalid 'if' category. Must be a list of conditions.\")\n        else:\n            raise InvalidRule(\"Rule must have at least one condition.\")\n\n        self.conditions = rule[\"if\"]\n\n        if not rule[\"if\"]:\n            raise InvalidRule(\"Rule must have at least one condition.\")\n\n        if not isinstance(rule[\"do\"], list):\n            raise InvalidRule(\"Invalid 'do' category. Must be a list of maps.\")\n\n        if not rule[\"do\"]:\n            raise InvalidRule(\"Rule must have at least one action.\")\n\n        self.actions = rule[\"do\"]\n\n        def is_condition_allowed_in_events(condition):\n            for event in self.events:\n                if not condition in ALLOWED_CONDITIONS[event]:\n                    return False\n            return True\n\n        def is_action_allowed_in_events(action):\n            for event in self.events:\n                if not action in ALLOWED_ACTIONS[event]:\n                    return False\n            return True\n\n        async def validate_condition(cond):\n            condition = parameter = None\n            for r, p in cond.items():\n                condition, parameter = r, p\n\n            try:\n                condition = Condition(condition)\n            except ValueError:\n                try:\n                    condition = ConditionBlock(condition)\n                    raise InvalidRule(f\"Invalid: `{condition.value}` can only be at root level.\")\n                except ValueError:\n                    suggestion = make_fuzzy_suggestion(condition, [c.value for c in Condition\n                                                                   if c not in DEPRECATED])\n                    raise InvalidRule(f\"Invalid condition: `{condition}`.{suggestion}\")\n\n            # Checking author prevents old rules from raising at load\n            if author and condition in DEPRECATED:\n                raise InvalidRule(f\"Condition `{condition.value}` is deprecated: check the documentation \"\n                                  \"for a supported alternative.\")\n\n            if not is_condition_allowed_in_events(condition):\n                raise InvalidRule(f\"Condition `{condition.value}` not allowed in the event(s) you have defined.\")\n\n            try:\n                model = model_validator(condition, parameter)\n            except ValidationError as e:\n                raise InvalidRule(f\"Condition `{condition.value}` invalid:\\n{box(str(e))}\")\n\n            if author:\n                try:\n                    await model._runtime_check(cog=cog, author=author, action_or_cond=condition)\n                except NotImplementedError:\n                    pass\n\n        for raw_condition in self.conditions:\n            condition = parameter = None\n\n            if not isinstance(raw_condition, dict):\n                raise InvalidRule(f\"Invalid condition: `{raw_condition}`. Expected map. Did you forget the colon?\")\n\n            for r, p in raw_condition.items():\n                condition, parameter = r, p\n\n            if len(raw_condition) != 1:\n                raise InvalidRule(f\"Invalid format in the conditions. Make sure you've got the dashes right!\")\n\n            try:\n                condition = Condition(condition)\n            except ValueError:\n                try:\n                    condition = ConditionBlock(condition)\n                except ValueError:\n                    suggestion = make_fuzzy_suggestion(condition, [c.value for c in Condition\n                                                                   if c not in DEPRECATED])\n                    raise InvalidRule(f\"Invalid condition: `{condition}`.{suggestion}\")\n\n            if isinstance(condition, ConditionBlock):\n                if parameter is None:\n                    raise InvalidRule(\"Condition blocks cannot be empty.\")\n                for p in parameter:\n                    await validate_condition(p)\n            else:\n                await validate_condition(raw_condition)\n\n        async def validate_action(action, parameter):\n            # Checking author prevents old rules from raising at load\n            if author and action in DEPRECATED:\n                raise InvalidRule(f\"Action `{action.value}` is deprecated: check the documentation \"\n                                \"for a supported alternative.\")\n\n            if not is_action_allowed_in_events(action):\n                raise InvalidRule(f\"Action `{action.value}` not allowed in the event(s) you have defined.\")\n\n            try:\n                model = model_validator(action, parameter)\n            except ValidationError as e:\n                raise InvalidRule(f\"Action `{action.value}` invalid:\\n{box(str(e))}\")\n\n            if author:\n                try:\n                    await model._runtime_check(cog=cog, author=author, action_or_cond=action)\n                except NotImplementedError:\n                    pass\n\n        # Basically a list of one-key dicts\n        # We need to preserve order of actions\n        for entry in self.actions:\n            # This will be a single loop\n            if not isinstance(entry, dict):\n                raise InvalidRule(f\"Invalid action: `{entry}`. Expected map.\")\n\n            if len(entry) != 1:\n                raise InvalidRule(f\"Invalid format in the actions. Make sure you've got the dashes right!\")\n\n            for enum, parameter in entry.items():\n                try:\n                    enum = self._get_actions_enum(enum)\n                except ValueError:\n                    suggestion = make_fuzzy_suggestion(enum, [a.value for a in Action\n                                                                if a not in DEPRECATED])\n                    raise InvalidRule(f\"Invalid action: `{enum}`.{suggestion}\")\n\n                if isinstance(enum, Action):\n                    await validate_action(enum, parameter)\n                elif isinstance(enum, Condition):\n                    await validate_condition({enum.value: parameter})\n                elif isinstance(enum, ConditionBlock):\n                    if parameter is None:\n                        raise InvalidRule(\"Condition blocks cannot be empty.\")\n                    for p in parameter:\n                        await validate_condition(p)\n                elif isinstance(enum, ConditionalActionBlock):\n                    if parameter is None:\n                        raise InvalidRule(\"Conditional action blocks cannot be empty.\")\n                    for raw_action in parameter:\n                        if not isinstance(raw_action, dict):\n                            raise InvalidRule(f\"`{enum.value}` contains a non-map. Did you forget the colon?\")\n                        for action, subparameter in raw_action.items():\n                            try:\n                                action = self._get_actions_enum(action)\n                            except ValueError:\n                                suggestion = make_fuzzy_suggestion(action, [a.value for a in Action\n                                                                            if a not in DEPRECATED])\n                                raise InvalidRule(f\"Invalid action: `{action}`.{suggestion}\")\n                            await validate_action(action, subparameter)\n\n\n    async def satisfies_conditions(self, *, rank: Rank, cog: MixinMeta, user: discord.Member=None, message: discord.Message=None,\n                                   guild: discord.Guild=None, debug=False)->ConditionResult:\n        cr = ConditionResult(rule_name=self.name, debug=debug)\n        if rank < self.rank:\n            return cr\n\n        # Due to the strict checking done during parsing we can\n        # expect to always have available the variables that we need for\n        # the different type of events and conditions\n        # Unless I fucked up somewhere, then we're in trouble!\n        if message and not user:\n            user = message.author\n\n        # For the rule's conditions to pass, every \"root level\" condition (or block of conditions)\n        # must equal to True\n        try:\n            return await self._evaluate_conditions_block(block=self.conditions, cog=cog, user=user, message=message, guild=guild,\n                                                        debug=debug)\n        except ExecutionError:\n            return cr # Ensure the rule doesn't pass if a condition errored\n\n    async def _evaluate_conditions_block(self, *, block, cog, user: discord.Member=None, message: discord.Message=None,\n                                   guild: discord.Guild=None, templates_vars=None, debug)->ConditionResult:\n        # This is used during condition processing AND action processing for conditional actions\n        cr = ConditionResult(rule_name=self.name, debug=debug)\n\n        for raw_condition in block:\n            condition = None\n            value = []\n\n            for r, v in raw_condition.items():\n                condition, value = r, v\n            try:\n                condition = ConditionBlock(condition)\n            except:\n                condition = Condition(condition)\n\n            if condition == ConditionBlock.IfAll:\n                results = await self._evaluate_conditions(value, cog=cog, user=user, message=message,\n                                                          guild=guild, templates_vars=templates_vars, debug=debug)\n                if len(results) != len(value):\n                    raise RuntimeError(\"Mismatching number of conditions and evaluations\")\n                cr.add_condition_block(condition, value, results) # type: ignore\n                cond_result = all(results)\n            elif condition == ConditionBlock.IfAny:\n                results = await self._evaluate_conditions(value, cog=cog, user=user, message=message,\n                                                          guild=guild, templates_vars=templates_vars, debug=debug)\n                if len(results) != len(value):\n                    raise RuntimeError(\"Mismatching number of conditions and evaluations\")\n                cr.add_condition_block(condition, value, results) # type: ignore\n                cond_result = any(results)\n            elif condition == ConditionBlock.IfNot:\n                results = await self._evaluate_conditions(value, cog=cog, user=user, message=message,\n                                                          guild=guild, templates_vars=templates_vars, debug=debug)\n                if len(results) != len(value):\n                    raise RuntimeError(\"Mismatching number of conditions and evaluations\")\n                cr.add_condition_block(condition, value, results) # type: ignore\n                results = [not r for r in results] # Bools are flipped\n                cond_result = all(results)\n            else:\n                results = await self._evaluate_conditions([{condition: value}], cog=cog, user=user, message=message,\n                                                          guild=guild, templates_vars=templates_vars, debug=debug)\n                if len(results) != 1:\n                    raise RuntimeError(f\"A single condition evaluation returned {len(results)} evaluations!\")\n                cr.add_condition(condition, results[0]) # type: ignore\n                cond_result = results[0]\n\n            if cond_result is False:\n                return cr # If one root condition is False there's no need to continue\n\n        cr.result = True\n        return cr\n\n    async def _evaluate_conditions(self, conditions, *, cog: MixinMeta, user: discord.Member=None, message: discord.Message=None,\n                                   guild: discord.Guild=None, templates_vars=None, debug):\n\n        if message and not user:\n            user = message.author\n        guild = guild if guild else user.guild\n        channel: discord.Channel = message.channel if message else None\n\n        if templates_vars is None:\n            templates_vars = {}\n            await populate_ctx_vars(t_vars=templates_vars,\n                                    rule=self,\n                                    cog=cog,\n                                    guild=guild,\n                                    message=message,\n                                    user=user,\n                                    channel=channel,\n                                    debug=debug)\n\n        checkers = {}\n\n        def checker(condition: Condition, suggest: Condition=None):\n            def decorator(function):\n                def wrapper(*args, **kwargs):\n                    if suggest is not None:\n                        cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Condition \"\n                                                   f\"'{condition.value}' is deprecated, use \"\n                                                   f\"'{suggest.value}' instead.\")\n                    return function(*args, **kwargs)\n                checkers[condition] = wrapper\n                return wrapper\n            return decorator\n\n        def safe_sub(string):\n            if string == discord.Embed.Empty:\n                return string\n            return Template(string).safe_substitute(templates_vars)\n\n        @checker(Condition.MessageMatchesAny)\n        async def message_matches_any(params: models.NonEmptyListStr):\n            # One match = Passed\n            content = message.content.lower()\n            for pattern in params.value:\n                if fnmatch.fnmatch(content, pattern.lower()):\n                    return True\n            return False\n\n        @checker(Condition.MessageMatchesRegex)\n        async def message_matches_regex(params: models.IsStr):\n            return await run_user_regex(\n                rule_obj=self,\n                cog=cog,\n                guild=guild,\n                regex=params.value,\n                text=message.content\n            )\n\n        @checker(Condition.UserActivityMatchesAny)\n        async def user_activity_matches_any(params: models.NonEmptyListStr):\n            to_check = []\n            for activity in user.activities:\n                if isinstance(activity, discord.BaseActivity):\n                    if activity.name is not None:\n                        to_check.append(activity.name)\n\n            for activity in to_check:\n                for pattern in params.value:\n                    if fnmatch.fnmatch(activity.lower(), pattern.lower()):\n                        return True\n\n            return False\n\n        @checker(Condition.UserStatusMatchesAny)\n        async def user_status_matches_any(params: models.NonEmptyListStr):\n            status_str = str(user.status)\n            for status in params.value:\n                if status.lower() == status_str:\n                    return True\n            return False\n\n        @checker(Condition.UserIdMatchesAny)\n        async def user_id_matches_any(params: models.NonEmptyListInt):\n            for _id in params.value:\n                if _id == user.id:\n                    return True\n            return False\n\n        @checker(Condition.UsernameMatchesAny)\n        async def username_matches_any(params: models.NonEmptyListStr):\n            # One match = Passed\n            name = user.name.lower()\n            for pattern in params.value:\n                if fnmatch.fnmatch(name, pattern.lower()):\n                    return True\n            return False\n\n        @checker(Condition.UsernameMatchesRegex)\n        async def username_matches_regex(params: models.IsStr):\n            return await run_user_regex(\n                rule_obj=self,\n                cog=cog,\n                guild=guild,\n                regex=params.value,\n                text=user.name\n            )\n\n        @checker(Condition.NicknameMatchesAny)\n        async def nickname_matches_any(params: models.NonEmptyListStr):\n            # One match = Passed\n            if not user.nick:\n                return False\n            nick = user.nick.lower()\n            for pattern in params.value:\n                if fnmatch.fnmatch(nick, pattern.lower()):\n                    return True\n            return False\n\n        @checker(Condition.NicknameMatchesRegex)\n        async def nickname_matches_regex(params: models.IsStr):\n            if not user.nick:\n                return False\n            return await run_user_regex(\n                rule_obj=self,\n                cog=cog,\n                guild=guild,\n                regex=params.value,\n                text=user.nick\n            )\n\n        @checker(Condition.ChannelMatchesAny)\n        async def channel_matches_any(params: models.NonEmptyList):\n            if channel.id in params.value:\n                return True\n            for channel_str in params.value:\n                channel_str = str(channel_str)\n                channel_obj = discord.utils.get(guild.text_channels, name=channel_str)\n                if channel_obj is not None and channel_obj == channel:\n                    return True\n            return False\n\n        @checker(Condition.CategoryMatchesAny)\n        async def category_matches_any(params: models.NonEmptyList):\n            if channel.category is None:\n                return False\n            if channel.category.id in params.value:\n                return True\n            for category_str in params.value:\n                category_str = str(category_str)\n                category_obj = discord.utils.get(guild.categories, name=category_str)\n                if category_obj is not None and category_obj == channel.category:\n                    return True\n            return False\n\n        @checker(Condition.ChannelIsPublic)\n        async def channel_is_public(params: models.IsBool):\n            everyone = guild.default_role\n            public = everyone not in channel.overwrites or channel.overwrites[everyone].read_messages in (True, None)\n            return params.value is public\n\n        @checker(Condition.UserCreatedLessThan)\n        async def user_created_less_than(params: models.UserJoinedCreated):\n            if isinstance(params.value, int):\n                if params.value == 0:\n                    return True\n                x_hours_ago = utcnow() - datetime.timedelta(hours=params.value)\n            else:\n                x_hours_ago = utcnow() - params.value # type: ignore\n\n            return user.created_at > x_hours_ago\n\n        @checker(Condition.UserIsRank)\n        async def user_is_rank(params: models.IsRank):\n            return await cog.rank_user(user) == Rank(params.value)\n\n        @checker(Condition.UserJoinedLessThan)\n        async def user_joined_less_than(params: models.UserJoinedCreated):\n            if isinstance(params.value, int):\n                if params.value == 0:\n                    return True\n                x_hours_ago = utcnow() - datetime.timedelta(hours=params.value)\n            else:\n                x_hours_ago = utcnow() - params.value # type: ignore\n\n            return user.joined_at > x_hours_ago\n\n        @checker(Condition.UserHasDefaultAvatar)\n        async def user_has_default_avatar(params: models.IsBool):\n            default_avatar_url_pattern = \"*/embed/avatars/*.png\"\n            match = fnmatch.fnmatch(str(user.avatar_url), default_avatar_url_pattern)\n            return params.value is match\n\n        @checker(Condition.InEmergencyMode)\n        async def in_emergency_mode(params: models.IsBool):\n            in_emergency = cog.is_in_emergency_mode(guild)\n            return in_emergency is params.value\n\n        @checker(Condition.MessageHasAttachment)\n        async def message_has_attachment(params: models.IsBool):\n            return bool(message.attachments) is params.value\n\n        @checker(Condition.UserHasAnyRoleIn)\n        async def user_has_any_role_in(params: models.NonEmptyList):\n            for role_id_or_name in params.value:\n                role = guild.get_role(role_id_or_name)\n                if role is None:\n                    role = discord.utils.get(guild.roles, name=role_id_or_name)\n                if role:\n                    if role in user.roles:\n                        return True\n            return False\n\n        @checker(Condition.UserHasSentLessThanMessages)\n        async def user_has_sent_less_than_messages(params: models.IsInt):\n            msg_n = await cog.get_total_recorded_messages(user)\n            return msg_n < params.value\n\n        @checker(Condition.MessageContainsInvite)\n        async def message_contains_invite(params: models.IsBool):\n            results = INVITE_URL_RE.findall(message.content)\n            if results:\n                has_invite = True\n                try:\n                    if await get_external_invite(guild, results) is None:\n                        has_invite = False\n                except MisconfigurationError as e:\n                    raise ExecutionError(str(e))\n                except Exception as e:\n                    error_text = \"Unexpected error: failed to fetch server's own invites\"\n                    log.error(error_text, exc_info=e)\n                    raise ExecutionError(error_text)\n            else:\n                has_invite = False\n            return has_invite is params.value\n\n        @checker(Condition.MessageContainsMedia)\n        async def message_contains_media(params: models.IsBool):\n            has_media = MEDIA_URL_RE.search(message.content)\n            return bool(has_media) is params.value\n\n        @checker(Condition.MessageContainsUrl)\n        async def message_contains_url(params: models.IsBool):\n            has_url = URL_RE.search(message.content)\n            return bool(has_url) is params.value\n\n        @checker(Condition.MessageContainsMTMentions)\n        async def message_contains_mt_mentions(params: models.IsInt):\n            return len(message.raw_mentions) > params.value\n\n        @checker(Condition.MessageContainsMTUniqueMentions)\n        async def message_contains_mt_unique_mentions(params: models.IsInt):\n            return len(set(message.mentions)) > params.value\n\n        @checker(Condition.MessageContainsMTRolePings)\n        async def message_contains_mt_role_pings(params: models.IsInt):\n            return len(message.role_mentions) > params.value\n\n        @checker(Condition.MessageContainsMTEmojis)\n        async def message_contains_mt_emojis(params: models.IsInt):\n            over_limit = has_x_or_more_emojis(cog.bot, guild, message.content, params.value + 1)\n            return over_limit\n\n        @checker(Condition.MessageHasMTCharacters)\n        async def message_has_mt_characters(params: models.IsInt):\n            # We're turning one custom emoji code into a single character to avoid\n            # unexpected (from a user's POV) behaviour\n            clean_content = REMOVE_C_EMOJIS_RE.sub(\"x\", message.clean_content)\n            return len(clean_content) > params.value\n\n        @checker(Condition.IsStaff)\n        async def is_staff(params: models.IsBool):\n            is_staff = await cog.bot.is_mod(user)\n            return is_staff is params.value\n\n        @checker(Condition.IsHelper)\n        async def is_helper(params: models.IsBool):\n            is_helper = await cog.is_helper(user)\n            return is_helper is params.value\n\n        @checker(Condition.UserHeatIs)\n        async def user_heat_is(params: models.IsInt):\n            return heat.get_user_heat(user, debug=debug) == params.value\n\n        @checker(Condition.ChannelHeatIs)\n        async def channel_heat_is(params: models.IsInt):\n            return heat.get_channel_heat(channel, debug=debug) == params.value\n\n        @checker(Condition.CustomHeatIs)\n        async def custom_heat_is(params: models.CheckCustomHeatpoint):\n            heat_key = Template(params.label).safe_substitute(templates_vars)\n            return heat.get_custom_heat(guild, heat_key, debug=debug) == params.points\n\n        @checker(Condition.UserHeatMoreThan)\n        async def user_heat_more_than(params: models.IsInt):\n            return heat.get_user_heat(user, debug=debug) > params.value\n\n        @checker(Condition.ChannelHeatMoreThan)\n        async def channel_heat_more_than(params: models.IsInt):\n            return heat.get_channel_heat(channel, debug=debug) > params.value\n\n        @checker(Condition.CustomHeatMoreThan)\n        async def custom_heat_more_than(params: models.CheckCustomHeatpoint):\n            heat_key = Template(params.label).safe_substitute(templates_vars)\n            return heat.get_custom_heat(guild, heat_key, debug=debug) > params.points\n\n        @checker(Condition.Compare)\n        async def compare(params: models.Compare):\n            value1 = safe_sub(params.value1)\n            value2 = safe_sub(params.value2)\n\n            if params.operator == \"==\":\n                return value1 == value2\n            elif params.operator == \"contains\":\n                return value2 in value1\n            elif params.operator == \"contains-pattern\":\n                return fnmatch.fnmatch(value1.lower(), value2.lower())\n            elif params.operator == \"!=\":\n                return value1 != value2\n\n            # Numeric operators\n            try:\n                value1, value2 = int(value1), int(value2)\n            except ValueError:\n                raise ExecutionError(f\"Could not compare {value1} with {value2}: they both need to be numbers!\")\n\n            if params.operator == \">\":\n                return value1 > value2\n            elif params.operator == \"<\":\n                return value1 < value2\n            elif params.operator == \"<=\":\n                return value1 <= value2\n            elif params.operator == \">=\":\n                return value1 >= value2\n\n        if debug:\n            for condition in Condition:\n                if condition not in checkers:\n                    raise ExecutionError(f\"{condition.value} does not have a checker.\")\n\n        bools = []\n\n        for raw_condition in conditions:\n\n            condition = value = None\n            for c, v in raw_condition.items():\n                condition, value = c, v\n\n            condition = Condition(condition)\n\n            params = model_validator(condition, value)\n            try:\n                processor_func = checkers[condition]\n            except KeyError:\n                raise ExecutionError(f\"Unhandled condition '{condition.value}'.\")\n\n            try:\n                result = await processor_func(params)\n            except ExecutionError as e:\n                if cog: # is None in unit tests\n                    cog.send_to_monitor(guild, f\"[Warden] ({self.name}): {e}\")\n                raise e\n            if result in (True, False):\n                bools.append(result)\n            else:\n                raise ExecutionError(f\"Unexpected condition evaluation result for '{condition.value}'.\")\n\n        return bools\n\n    async def do_actions(self, *, cog: MixinMeta, user: discord.Member=None, message: discord.Message=None,\n                         guild: discord.Guild=None, debug=False):\n        if message and not user:\n            user = message.author\n        guild = guild if guild else user.guild\n        channel: discord.Channel = message.channel if message else None\n\n        templates_vars = {}\n        await populate_ctx_vars(t_vars=templates_vars,\n                                rule=self,\n                                cog=cog,\n                                guild=guild,\n                                message=message,\n                                user=user,\n                                channel=channel,\n                                debug=debug)\n\n        def safe_sub(string):\n            if string == discord.Embed.Empty:\n                return string\n            return Template(string).safe_substitute(templates_vars)\n\n        #for heat_key in heat.get_custom_heat_keys(guild):\n        #    templates_vars[f\"custom_heat_{heat_key}\"] = heat.get_custom_heat(guild, heat_key)\n\n        last_sent_message: Optional[discord.Message] = None\n        last_expel_action = None\n\n        processors = {}\n\n        def processor(action: Action, suggest: Action=None):\n            def decorator(function):\n                def wrapper(*args, **kwargs):\n                    if suggest is not None:\n                        cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Action \"\n                                                   f\"'{action.value}' is deprecated, use \"\n                                                   f\"'{suggest.value}' instead.\")\n                    return function(*args, **kwargs)\n                processors[action] = wrapper\n                return wrapper\n            return decorator\n\n        @processor(Action.DeleteUserMessage)\n        async def delete_user_message(params: models.IsNone):\n            await message.delete()\n\n        @processor(Action.Dm, suggest=Action.SendMessage)\n        async def send_dm(params: models.SendMessageToUser):\n            nonlocal last_sent_message\n            user_to_dm = guild.get_member(params.id)\n            if not user_to_dm:\n                user_to_dm = discord.utils.get(guild.members, name=params.id)\n            if not user_to_dm:\n                return\n            content = Template(params.content).safe_substitute(templates_vars)\n            try:\n                last_sent_message = await user_to_dm.send(content)\n            except:\n                cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Failed to DM user \"\n                                    f\"{user_to_dm} ({user_to_dm.id})\")\n                last_sent_message = None\n\n        @processor(Action.DmUser, suggest=Action.SendMessage)\n        async def send_user_dm(params: models.IsStr):\n            nonlocal last_sent_message\n            text = Template(params.value).safe_substitute(templates_vars)\n            try:\n                last_sent_message = await user.send(text)\n            except:\n                cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Failed to DM user \"\n                                    f\"{user} ({user.id})\")\n                last_sent_message = None\n\n        @processor(Action.NotifyStaff)\n        async def notify_staff(params: models.NotifyStaff):\n            nonlocal last_sent_message\n            # Checks if only \"content\" has been passed\n            text_only = params.__fields_set__ == {\"content\"}\n\n            quick_action = None\n            if params.qa_target:\n                if params.qa_reason is None:\n                    params.qa_reason = \"\"\n\n                params.qa_target = safe_sub(params.qa_target)\n                params.qa_reason = safe_sub(params.qa_reason)\n\n                try:\n                    quick_action = QuickAction(int(params.qa_target), params.qa_reason)\n                except ValueError:\n                    raise ExecutionError(f\"{params.qa_target} is not a valid ID for a Quick Action target.\")\n\n            jump_to_msg = None\n\n            if params.jump_to_ctx_message:\n                jump_to_msg = message\n\n            if params.jump_to:\n                params.jump_to.channel_id = safe_sub(params.jump_to.channel_id)\n                params.jump_to.message_id = safe_sub(params.jump_to.message_id)\n                try:\n                    jump_to_ch = discord.utils.get(guild.text_channels, id=int(params.jump_to.channel_id))\n                except ValueError:\n                    raise ExecutionError(f\"{params.jump_to.channel_id} is not a valid channel ID for a \\\"jump to\\\" message.\")\n                if not params.jump_to.message_id.isdigit():\n                    raise ExecutionError(f\"{params.jump_to.message_id} is not a valid message ID for a \\\"jump to\\\" message.\")\n                if jump_to_ch:\n                    jump_to_msg = jump_to_ch.get_partial_message(params.jump_to.message_id)\n                else:\n                    raise ExecutionError(f\"I could not find the destination channel for the \\\"jump to\\\" message.\")\n\n            title = safe_sub(params.title) if params.title else None\n            heat_key = safe_sub(params.no_repeat_key) if params.no_repeat_key else None\n\n            fields = []\n\n            if params.fields:\n                for param in params.fields:\n                    fields.append(param.dict())\n\n            for field in fields:\n                for attr in (\"name\", \"value\"):\n                    if attr in field:\n                        field[attr] = safe_sub(field[attr])\n\n            if params.add_ctx_fields:\n                ctx_fields = []\n                if user:\n                    ctx_fields.append({\"name\": \"Username\", \"value\": f\"`{user}`\"})\n                    ctx_fields.append({\"name\": \"ID\", \"value\": f\"`{user.id}`\"})\n                if message:\n                    ctx_fields.append({\"name\": \"Channel\", \"value\": message.channel.mention})\n                fields = ctx_fields + fields\n\n            footer = None\n            if not text_only:\n                if params.footer_text is None:\n                    footer = f\"Warden rule `{self.name}`\"\n                elif params.footer_text == \"\":\n                    footer = None\n                else:\n                    footer = safe_sub(params.footer_text)\n\n            last_sent_message = await cog.send_notification(guild,\n                                                            safe_sub(params.content),\n                                                            title=title,\n                                                            ping=params.ping,\n                                                            fields=fields,\n                                                            footer=footer,\n                                                            thumbnail=safe_sub(params.thumbnail) if params.thumbnail else None,\n                                                            jump_to=jump_to_msg,\n                                                            no_repeat_for=params.no_repeat_for,\n                                                            heat_key=heat_key,\n                                                            quick_action=quick_action,\n                                                            force_text_only=text_only,\n                                                            allow_everyone_ping=params.allow_everyone_ping)\n\n        @processor(Action.NotifyStaffAndPing, suggest=Action.NotifyStaff)\n        async def notify_staff_and_ping(params: models.IsStr):\n            nonlocal last_sent_message\n            text = Template(params.value).safe_substitute(templates_vars)\n            last_sent_message = await cog.send_notification(guild, text, ping=True, allow_everyone_ping=True,\n                                                            force_text_only=True)\n\n        @processor(Action.NotifyStaffWithEmbed, suggest=Action.NotifyStaff)\n        async def notify_staff_with_embed(params: models.NotifyStaffWithEmbed):\n            nonlocal last_sent_message\n            title = Template(params.title).safe_substitute(templates_vars)\n            content = Template(params.content).safe_substitute(templates_vars)\n            last_sent_message = await cog.send_notification(guild, content,\n                                                            title=title, footer=f\"Warden rule `{self.name}`\",\n                                                            allow_everyone_ping=True)\n\n        @processor(Action.SendInChannel, suggest=Action.SendMessage)\n        async def send_in_channel(params: models.IsStr):\n            nonlocal last_sent_message\n            text = Template(params.value).safe_substitute(templates_vars)\n            last_sent_message = await channel.send(text, allowed_mentions=ALLOW_ALL_MENTIONS)\n\n        @processor(Action.SetChannelSlowmode)\n        async def set_channel_slowmode(params: models.IsTimedelta):\n            if params.value.seconds != channel.slowmode_delay:\n                await channel.edit(slowmode_delay=params.value.seconds)\n\n        @processor(Action.SendToChannel, suggest=Action.SendMessage)\n        async def send_to_channel(params: models.SendMessageToChannel):\n            nonlocal last_sent_message\n            channel_dest = guild.get_channel(params.id_or_name)\n            if not channel_dest:\n                channel_dest = discord.utils.get(guild.text_channels, name=params.id_or_name)\n            if not channel_dest:\n                raise ExecutionError(f\"Channel '{params.id_or_name}' not found.\")\n            content = Template(params.content).safe_substitute(templates_vars)\n            last_sent_message = await channel_dest.send(content, allowed_mentions=ALLOW_ALL_MENTIONS)\n\n        @processor(Action.AddRolesToUser)\n        async def add_roles_to_user(params: models.NonEmptyList):\n            to_assign = []\n            for role_id_or_name in params.value:\n                role = guild.get_role(role_id_or_name)\n                if role is None:\n                    role = discord.utils.get(guild.roles, name=role_id_or_name)\n                if role:\n                    to_assign.append(role)\n            to_assign = list(set(to_assign))\n            to_assign = [r for r in to_assign if r not in user.roles]\n            if to_assign:\n                await user.add_roles(*to_assign, reason=f\"Assigned by Warden rule '{self.name}'\")\n\n        @processor(Action.RemoveRolesFromUser)\n        async def remove_roles_from_user(params: models.NonEmptyList):\n            to_unassign = []\n            for role_id_or_name in params.value:\n                role = guild.get_role(role_id_or_name)\n                if role is None:\n                    role = discord.utils.get(guild.roles, name=role_id_or_name)\n                if role:\n                    to_unassign.append(role)\n            to_unassign = list(set(to_unassign))\n            to_unassign = [r for r in to_unassign if r in user.roles]\n            if to_unassign:\n                await user.remove_roles(*to_unassign, reason=f\"Unassigned by Warden rule '{self.name}'\")\n\n        @processor(Action.SetUserNickname)\n        async def set_user_nickname(params: models.IsStr):\n            if params.value == \"\":\n                value = None\n            else:\n                value = Template(params.value).safe_substitute(templates_vars)\n            await user.edit(nick=value, reason=f\"Changed nickname by Warden rule '{self.name}'\")\n\n        @processor(Action.BanAndDelete)\n        async def ban_and_delete(params: models.IsInt):\n            nonlocal last_expel_action\n            if user not in guild.members:\n                raise ExecutionError(f\"User {user} ({user.id}) not in the server.\")\n            reason = f\"Banned by Warden rule '{self.name}'\"\n            await guild.ban(user, delete_message_days=params.value, reason=reason)\n            last_expel_action = ModAction.Ban\n            cog.dispatch_event(\"member_remove\", user, ModAction.Ban.value, reason)\n\n        @processor(Action.Kick)\n        async def kick(params: models.IsNone):\n            nonlocal last_expel_action\n            if user not in guild.members:\n                raise ExecutionError(f\"User {user} ({user.id}) not in the server.\")\n            reason = f\"Kicked by Warden action '{self.name}'\"\n            await guild.kick(user, reason=reason)\n            last_expel_action = ModAction.Kick\n            cog.dispatch_event(\"member_remove\", user, ModAction.Kick.value, reason)\n\n        @processor(Action.Softban)\n        async def softban(params: models.IsNone):\n            nonlocal last_expel_action\n            if user not in guild.members:\n                raise ExecutionError(f\"User {user} ({user.id}) not in the server.\")\n            reason = f\"Softbanned by Warden rule '{self.name}'\"\n            await guild.ban(user, delete_message_days=1, reason=reason)\n            await guild.unban(user)\n            last_expel_action = Action.Softban\n            cog.dispatch_event(\"member_remove\", user, ModAction.Softban.value, reason)\n\n        @processor(Action.PunishUser)\n        async def punish_user(params: models.IsNone):\n            punish_role = guild.get_role(await cog.config.guild(guild).punish_role())\n            if punish_role and not cog.is_role_privileged(punish_role):\n                await user.add_roles(punish_role, reason=f\"Punished by Warden rule '{self.name}'\")\n            else:\n                cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Failed to punish user. Is the punish role \"\n                                            \"still present and with *no* privileges?\")\n\n        @processor(Action.PunishUserWithMessage)\n        async def punish_user_with_message(params: models.IsNone):\n            punish_role = guild.get_role(await cog.config.guild(guild).punish_role())\n            punish_message = await cog.config.guild(guild).punish_message()\n            if punish_role and not cog.is_role_privileged(punish_role):\n                await user.add_roles(punish_role, reason=f\"Punished by Warden rule '{self.name}'\")\n                if punish_message:\n                    await channel.send(f\"{user.mention} {punish_message}\")\n            else:\n                cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Failed to punish user. Is the punish role \"\n                                            \"still present and with *no* privileges?\")\n\n        @processor(Action.Modlog)\n        async def send_mod_log(params: models.IsStr):\n            if last_expel_action is None:\n                return\n            reason = Template(params.value).safe_substitute(templates_vars)\n            await cog.create_modlog_case(\n                cog.bot,\n                guild,\n                utcnow(),\n                last_expel_action.value,\n                user,\n                guild.me,\n                reason,\n                until=None,\n                channel=None,\n            )\n\n        @processor(Action.EnableEmergencyMode)\n        async def enable_emergency_mode(params: models.IsBool):\n            if params.value:\n                cog.emergency_mode[guild.id] = EmergencyMode(manual=True)\n            else:\n                try:\n                    del cog.emergency_mode[guild.id]\n                except KeyError:\n                    pass\n\n        @processor(Action.SendToMonitor)\n        async def send_to_monitor(params: models.IsStr):\n            value = Template(params.value).safe_substitute(templates_vars)\n            cog.send_to_monitor(guild, f\"[Warden] ({self.name}): {value}\")\n\n        @processor(Action.AddUserHeatpoint)\n        async def add_user_heatpoint(params: models.IsTimedelta):\n            heat.increase_user_heat(user, params.value, debug=debug) # type: ignore\n            templates_vars[\"user_heat\"] = heat.get_user_heat(user, debug=debug)\n\n        @processor(Action.AddUserHeatpoints)\n        async def add_user_heatpoints(params: models.AddHeatpoints):\n            for _ in range(params.points):\n                heat.increase_user_heat(user, params.delta, debug=debug) # type: ignore\n            templates_vars[\"user_heat\"] = heat.get_user_heat(user, debug=debug)\n\n        @processor(Action.AddChannelHeatpoint)\n        async def add_channel_heatpoint(params: models.IsTimedelta):\n            heat.increase_channel_heat(channel, params.value, debug=debug) # type: ignore\n            templates_vars[\"channel_heat\"] = heat.get_channel_heat(channel, debug=debug)\n\n        @processor(Action.AddChannelHeatpoints)\n        async def add_channel_heatpoints(params: models.AddHeatpoints):\n            for _ in range(params.points):\n                heat.increase_channel_heat(channel, params.delta, debug=debug) # type: ignore\n            templates_vars[\"channel_heat\"] = heat.get_channel_heat(channel, debug=debug)\n\n        @processor(Action.AddCustomHeatpoint)\n        async def add_custom_heatpoint(params: models.AddCustomHeatpoint):\n            heat_key = Template(params.label).safe_substitute(templates_vars)\n            heat.increase_custom_heat(guild, heat_key, params.delta, debug=debug) # type: ignore\n\n        @processor(Action.AddCustomHeatpoints)\n        async def add_custom_heatpoints(params: models.AddCustomHeatpoints):\n            heat_key = Template(params.label).safe_substitute(templates_vars)\n            for _ in range(params.points):\n                heat.increase_custom_heat(guild, heat_key, params.delta, debug=debug) # type: ignore\n\n        @processor(Action.EmptyUserHeat)\n        async def empty_user_heat(params: models.IsNone):\n            heat.empty_user_heat(user, debug=debug)\n\n        @processor(Action.EmptyChannelHeat)\n        async def empty_channel_heat(params: models.IsNone):\n            heat.empty_channel_heat(channel, debug=debug)\n\n        @processor(Action.EmptyCustomHeat)\n        async def empty_custom_heat(params: models.IsStr):\n            heat_key = Template(params.value).safe_substitute(templates_vars)\n            heat.empty_custom_heat(guild, heat_key, debug=debug)\n\n        @processor(Action.IssueCommand)\n        async def issue_command(params: models.IssueCommand):\n            issuer = guild.get_member(params.issue_as)\n            if issuer is None:\n                raise ExecutionError(f\"User {params.issue_as} is not in the server.\")\n            msg_obj = df_cache.get_msg_obj()\n            if msg_obj is None:\n                raise ExecutionError(f\"Failed to issue command. Sorry!\")\n\n            # User id + command in a non-message context\n            if message is None and params.destination is None:\n                notify_channel_id = await cog.config.guild(guild).notify_channel()\n                msg_obj.channel = guild.get_channel(notify_channel_id)\n                if msg_obj.channel is None:\n                    raise ExecutionError(f\"Failed to issue command. I could not find the \"\n                                         \"notification channel.\")\n            else:\n                if params.destination is None: # User id + command in a message context\n                    msg_obj.channel = message.channel\n                else: # User id + command + arbitrary destination\n                    params.destination = safe_sub(params.destination)\n                    try:\n                        msg_obj.channel = guild.get_channel(int(params.destination))\n                    except ValueError:\n                        raise ExecutionError(f\"{params.destination} is not a valid ID.\")\n                    if msg_obj.channel is None:\n                        raise ExecutionError(f\"Failed to issue command. I could not find the \"\n                                            \"notification channel.\")\n                    if msg_obj.channel.permissions_for(issuer).view_channel is False:\n                        raise ExecutionError(\"Failed to issue command. The issuer has no permissions \"\n                                             \"to view the destination channel.\")\n\n            msg_obj.author = issuer\n            prefix = await cog.bot.get_prefix(msg_obj)\n            msg_obj.content = prefix[0] + safe_sub(params.command)\n            cog.bot.dispatch(\"message\", msg_obj)\n\n        @processor(Action.DeleteLastMessageSentAfter)\n        async def delete_last_message_sent_after(params: models.IsTimedelta):\n            nonlocal last_sent_message\n            if last_sent_message is not None:\n                cog.loop.create_task(delete_message_after(last_sent_message, params.value.seconds))\n                last_sent_message = None\n\n        @processor(Action.SendMessage)\n        async def send_message(params: models.SendMessage):\n            nonlocal last_sent_message\n            default_values = 0\n\n            for key in params.dict():\n                if key == \"edit_message_id\":\n                    continue\n                attr = getattr(params, key)\n                if attr is None:\n                    default_values += 1\n                    setattr(params, key, discord.Embed.Empty)\n                elif isinstance(attr, str):\n                    setattr(params, key, safe_sub(attr))\n\n            is_user = False\n            if params.id.isdigit():\n                params.id = int(params.id)\n                destination = discord.utils.get(guild.text_channels, id=params.id)\n                if destination is None:\n                    destination = guild.get_member(params.id)\n                    if destination is None:\n                        cog.send_to_monitor(guild, f\"[Warden] ({self.name}): Failed to send message, \"\n                                                    f\"I could not find the recipient.\")\n                        return\n                    else:\n                        is_user = True\n            else:\n                destination = discord.utils.get(guild.text_channels, name=params.id)\n                if destination is None:\n                    raise ExecutionError(f\"[Warden] ({self.name}): Failed to send message, \"\n                                        f\"'{params.id}' is not a valid channel name.\")\n\n            em = None\n            no_embed = default_values >= 10 # Yuck, maybe I'll think of something better\n\n            if no_embed and not params.content:\n                raise ExecutionError(f\"[Warden] ({self.name}): I have no content and \"\n                                      \"no embed to send.\")\n\n            if no_embed is False:\n                em = discord.Embed(title=params.title,\n                                description=params.description,\n                                url=params.url)\n\n                if params.author_name:\n                    em.set_author(name=params.author_name, url=params.author_url,\n                                icon_url=params.author_icon_url)\n                em.set_image(url=params.image)\n                em.set_thumbnail(url=params.thumbnail)\n                em.set_footer(text=params.footer_text, icon_url=params.footer_icon_url)\n                for field in params.fields:\n                    em.add_field(name=safe_sub(field.name),\n                                value=safe_sub(field.value),\n                                inline=field.inline)\n                if params.add_timestamp:\n                    em.timestamp = utcnow()\n\n                if params.color is True:\n                    em.color = await cog.bot.get_embed_color(destination)\n                elif not params.color:\n                    pass\n                else:\n                    em.color = discord.Colour(params.color)\n\n            mentions = discord.AllowedMentions(everyone=params.allow_mass_mentions, roles=True, users=True,\n                                               replied_user=params.ping_on_reply)\n\n            if params.edit_message_id:\n                params.edit_message_id = safe_sub(params.edit_message_id)\n\n            if isinstance(destination, discord.Member):\n                destination = destination.dm_channel if destination.dm_channel else await destination.create_dm()\n\n            reference = None\n            if params.reply_message_id:\n                params.reply_message_id = safe_sub(params.reply_message_id)\n                if params.reply_message_id.isdigit():\n                    reference = destination.get_partial_message(int(params.reply_message_id))\n\n            if not params.edit_message_id:\n                try:\n                    last_sent_message = await destination.send(params.content, embed=em, allowed_mentions=mentions,\n                                                               reference=reference)\n                except (discord.HTTPException, discord.Forbidden) as e:\n                    # A user could just have DMs disabled\n                    if is_user is False:\n                        raise ExecutionError(f\"[Warden] ({self.name}): Failed to deliver message \"\n                                            f\"to channel #{destination}. {e}\")\n            else:\n                try:\n                    partial_msg = destination.get_partial_message(int(params.edit_message_id))\n                    await partial_msg.edit(content=params.content if params.content else None,\n                                           embed=em, allowed_mentions=mentions)\n                except (discord.HTTPException, discord.Forbidden) as e:\n                    raise ExecutionError(f\"[Warden] ({self.name}): Failed to edit message \"\n                                        f\"in channel #{destination}. {e}\")\n                except ValueError:\n                    raise ExecutionError(f\"[Warden] ({self.name}): Failed to edit message. \"\n                                        f\"{params.edit_message_id} is not a valid ID\")\n\n        @processor(Action.GetUserInfo)\n        async def get_user_info(params: models.GetUserInfo):\n            params.id = safe_sub(params.id)\n            if not params.id.isdigit():\n                raise ExecutionError(f\"{params.id} is not a valid ID.\")\n\n            member = guild.get_member(int(params.id))\n            if not member:\n                raise ExecutionError(f\"Member {params.id} not found.\")\n\n            for target, attr in params.mapping.items():\n                if attr.startswith(\"_\") or \".\" in attr:\n                    raise ExecutionError(f\"You cannot access internal attributes.\")\n\n                attr = attr.lower()\n\n                if attr == \"rank\":\n                    value = await cog.rank_user(member)\n                    value = value.value\n                elif attr == \"is_staff\":\n                    value = await cog.bot.is_mod(member)\n                elif attr == \"is_helper\":\n                    value = await cog.is_helper(member)\n                elif attr == \"message_count\":\n                    value = await cog.get_total_recorded_messages(member)\n                else:\n                    value = getattr(member, attr, None)\n                    if value is None:\n                        raise ExecutionError(f\"Attribute \\\"{attr}\\\" does not exist.\")\n\n                if isinstance(value, bool):\n                    value = str(value).lower()\n                elif isinstance(value, datetime.datetime):\n                    value = value.strftime(\"%Y/%m/%d %H:%M:%S\")\n                elif isinstance(value, discord.BaseActivity):\n                    value = value.name if value.name is not None else \"none\"\n                elif isinstance(value, discord.Spotify):\n                    value = \"none\"\n                elif isinstance(value, (str, int, discord.Asset, discord.Status)):\n                    value = str(value)\n                else:\n                    raise ExecutionError(f\"Attribute \\\"{attr}\\\" not supported.\")\n\n                templates_vars[safe_sub(target)] = value\n\n        @processor(Action.Exit)\n        async def exit(params: models.IsNone):\n            raise StopExecution(\"Exiting.\")\n\n        @processor(Action.VarAssign)\n        async def assign(params: models.VarAssign):\n            if params.evaluate:\n                params.value = safe_sub(params.value)\n\n            templates_vars[safe_sub(params.var_name)] = params.value\n\n        @processor(Action.VarAssignRandom)\n        async def assign_random(params: models.VarAssignRandom):\n            choices = []\n            weights = []\n\n            if isinstance(params.choices, list):\n                choices = params.choices\n            else:\n                for k, v in params.choices.items():\n                    choices.append(k)\n                    weights.append(v)\n\n            choice = random.choices(choices, weights=weights or None, k=1)[0]\n            if params.evaluate:\n                choice = safe_sub(choice)\n\n            templates_vars[safe_sub(params.var_name)] = choice\n\n        @processor(Action.VarReplace)\n        async def var_replace(params: models.VarReplace):\n            var_name = safe_sub(params.var_name)\n            var = templates_vars.get(var_name, None)\n            if var is None:\n                raise ExecutionError(f\"Variable \\\"{var_name}\\\" does not exist.\")\n\n            to_sub = []\n\n            if isinstance(params.strings, str):\n                to_sub.append(params.strings)\n            else:\n                to_sub = params.strings\n\n            for sub in to_sub:\n                var = var.replace(sub, params.substring)\n\n            templates_vars[var_name] = var\n\n        @processor(Action.VarSplit)\n        async def var_split(params: models.VarSplit):\n            var_name = safe_sub(params.var_name)\n            var = templates_vars.get(var_name, None)\n            if var is None:\n                raise ExecutionError(f\"Variable \\\"{var_name}\\\" does not exist.\")\n\n            sequences = var.split(params.separator, maxsplit=params.max_split)\n\n            for i, var in enumerate(params.split_into):\n                try:\n                    templates_vars[var] = sequences[i]\n                except IndexError:\n                    templates_vars[var] = \"\"\n\n        @processor(Action.VarTransform)\n        async def var_transform(params: models.VarTransform):\n            var_name = safe_sub(params.var_name)\n            var = templates_vars.get(var_name, None)\n            if var is None:\n                raise ExecutionError(f\"Variable \\\"{var_name}\\\" does not exist.\")\n\n            operation = params.operation.lower()\n\n            if operation == \"capitalize\":\n                var = var.capitalize()\n            elif operation == \"lowercase\":\n                var = var.lower()\n            elif operation == \"reverse\":\n                var = var[::-1]\n            elif operation == \"uppercase\":\n                var = var.upper()\n            elif operation == \"title\":\n                var = var.title()\n\n            templates_vars[var_name] = var\n\n        @processor(Action.VarSlice)\n        async def var_slice(params: models.VarSlice):\n            var_name = safe_sub(params.var_name)\n            var = templates_vars.get(var_name, None)\n            if var is None:\n                raise ExecutionError(f\"Variable \\\"{var_name}\\\" does not exist.\")\n\n            var = var[params.index:params.end_index:params.step]\n\n            if params.slice_into:\n                templates_vars[safe_sub(params.slice_into)] = var\n            else:\n                templates_vars[var_name] = var\n\n        @processor(Action.NoOp)\n        async def no_op(params: models.IsNone):\n            pass\n\n        if debug:\n            for action in Action:\n                if action not in processors:\n                    raise ExecutionError(f\"{action.value} does not have a processor.\")\n\n        async def process_action(action, value):\n            self.last_action = action\n            if debug and action not in ALLOWED_DEBUG_ACTIONS:\n                return\n\n            params = model_validator(action, value)\n\n            try:\n                processor_func = processors[action]\n            except KeyError:\n                raise ExecutionError(f\"Unhandled action '{action.value}'.\")\n\n            await processor_func(params)\n\n\n        last_cond_action_result = None\n\n        for entry in self.actions:\n            for enum, value in entry.items():\n                enum = self._get_actions_enum(enum)\n                if isinstance(enum, Action):\n                    try:\n                        await process_action(enum, value)\n                    except StopExecution:\n                        return bool(last_expel_action)\n                elif isinstance(enum, Condition):\n                    _eval = await self._evaluate_conditions([{enum.value: value}],\n                                                            cog=cog, user=user, message=message,\n                                                            guild=guild, templates_vars=templates_vars,\n                                                            debug=debug)\n                    last_cond_action_result = _eval[0]\n                elif isinstance(enum, ConditionBlock):\n                    _eval = await self._evaluate_conditions_block(block=[{enum.value: value}],\n                                                                  cog=cog, user=user, message=message,\n                                                                  guild=guild, templates_vars=templates_vars,\n                                                                  debug=debug)\n                    last_cond_action_result = bool(_eval)\n                elif isinstance(enum, ConditionalActionBlock):\n                    is_true = enum == ConditionalActionBlock.IfTrue and last_cond_action_result is True\n                    is_false = enum == ConditionalActionBlock.IfFalse and last_cond_action_result is False\n                    if is_true or is_false:\n                        for raw_action in value:\n                            for action, subvalue in raw_action.items():\n                                action = self._get_actions_enum(action)\n                                try:\n                                    await process_action(action, subvalue)\n                                except StopExecution:\n                                    return bool(last_expel_action)\n\n        return bool(last_expel_action)\n\n    def _get_actions_enum(self, enum):\n        try:\n            enum = Action(enum)\n        except ValueError:\n            try:\n                enum = Condition(enum)\n            except ValueError:\n                try:\n                    enum = ConditionBlock(enum)\n                except ValueError:\n                    enum = ConditionalActionBlock(enum)\n\n        return enum\n\n    def __repr__(self):\n        return f\"<WardenRule '{self.name}'>\"\n\nasync def populate_ctx_vars(*, t_vars: dict, rule: WardenRule, cog, guild, message, user, channel, debug):\n    guild_icon_url = guild.icon_url_as()\n    guild_banner_url = guild.banner_url_as()\n    t_vars.update({\n        \"rule_name\": rule.name,\n        \"guild\": str(guild),\n        \"guild_id\": guild.id,\n        \"guild_icon_url\": guild_icon_url if guild_icon_url else \"\",\n        \"guild_banner_url\": guild_banner_url if guild_banner_url else \"\",\n        \"notification_channel_id\": await cog.config.guild(guild).notify_channel() if cog else 0,\n    })\n\n    if user:\n        t_vars.update({\n            \"user\": str(user),\n            \"user_name\": user.name,\n            \"user_id\": user.id,\n            \"user_mention\": user.mention,\n            \"user_nickname\": str(user.nick),\n            \"user_created_at\": user.created_at.strftime(\"%Y/%m/%d %H:%M:%S\"),\n            \"user_joined_at\": user.joined_at.strftime(\"%Y/%m/%d %H:%M:%S\"),\n            \"user_heat\": heat.get_user_heat(user, debug=debug),\n            \"user_avatar_url\": user.avatar_url\n        })\n\n    if message:\n        t_vars.update({\n            \"message\": message.content.replace(\"@\", \"@\\u200b\"),\n            \"message_clean\": message.clean_content,\n            \"message_id\": message.id,\n            \"message_created_at\": message.created_at,\n            \"message_link\": message.jump_url\n        })\n        if message.attachments:\n            attachment = message.attachments[0]\n            t_vars.update({\n                \"attachment_filename\": attachment.filename,\n                \"attachment_url\": attachment.url\n            })\n\n    if channel:\n        t_vars.update({\n            \"channel\": f\"#{channel}\",\n            \"channel_name\": channel.name,\n            \"channel_id\": channel.id,\n            \"channel_mention\": channel.mention,\n            \"channel_category\": channel.category.name if channel.category else \"None\",\n            \"channel_category_id\": channel.category.id if channel.category else \"0\",\n            \"channel_heat\": heat.get_channel_heat(channel, debug=debug),\n        })"], "filenames": ["defender/core/warden/rule.py"], "buggy_code_start_loc": [1161], "buggy_code_end_loc": [1161], "fixing_code_start_loc": [1162], "fixing_code_end_loc": [1165], "type": "NVD-CWE-noinfo", "message": "x26-Cogs is a repository of cogs made by Twentysix for the Red Discord bot. Among these cogs is the Defender cog, a tool for Discord server moderation. A vulnerability in the Defender cog prior to version 1.10.0 allows users with admin privileges to issue commands as other users who share the same server. If a bot owner shares the same server as the attacker, it is possible for the attacker to issue bot-owner restricted commands. The issue has been patched in version 1.10.0. One may unload the Defender cog as a workaround.", "other": {"cve": {"id": "CVE-2022-23604", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-15T16:15:09.000", "lastModified": "2022-02-24T02:26:05.927", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "x26-Cogs is a repository of cogs made by Twentysix for the Red Discord bot. Among these cogs is the Defender cog, a tool for Discord server moderation. A vulnerability in the Defender cog prior to version 1.10.0 allows users with admin privileges to issue commands as other users who share the same server. If a bot owner shares the same server as the attacker, it is possible for the attacker to issue bot-owner restricted commands. The issue has been patched in version 1.10.0. One may unload the Defender cog as a workaround."}, {"lang": "es", "value": "x26-Cogs es un repositorio de cogs hecho por Twentysix para el bot Red Discord. Entre estos engranajes es encontrado el engranaje Defender, una herramienta para la moderaci\u00f3n del servidor de Discord. Una vulnerabilidad en Defender cog versiones anteriores a 1.10.0, permite a usuarios con privilegios de administrador emitir comandos como otros usuarios que comparten el mismo servidor. Si el propietario de un bot comparte el mismo servidor que el atacante, es posible que \u00e9ste emita comandos restringidos al propietario del bot. El problema ha sido parcheado en versi\u00f3n 1.10.0. Puede descargarse el engranaje Defender como medida de mitigaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:x26-cogs_project:x26-cogs:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.0", "matchCriteriaId": "0244BB5C-D961-4BD3-AB3E-7E7448F414BA"}]}]}], "references": [{"url": "https://github.com/Twentysix26/x26-Cogs/commit/72dd9323cb4c90f3a5accac7087605375d178246", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Twentysix26/x26-Cogs/releases/tag/v1.10", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/Twentysix26/x26-Cogs/security/advisories/GHSA-cfh8-v56j-5757", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Twentysix26/x26-Cogs/commit/72dd9323cb4c90f3a5accac7087605375d178246"}}