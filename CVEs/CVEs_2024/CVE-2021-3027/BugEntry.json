{"buggy_code": ["# -*- coding:Utf-8 -*-\n\n\nimport os, sys, stat, re\nimport config\n\nfrom io import open\nfrom ldap3 import Server, Connection, ALL\nfrom ldap3.utils.dn import escape_rdn\nfrom flask import request\nfrom sqlalchemy import exc\nfrom sqlalchemy.orm import sessionmaker\nfrom app import app, db\nfrom app.models_mod import user, target\nfrom . import api\nfrom .. import utilities as utils\n\n\ndef useruid(s, login):\n    \"\"\"Connect to a LDAP and check the uid matching the given field data\"\"\"\n    uid = False\n    c = Connection(s, config.LDAPACC, \n                   password=config.LDAPPASS, auto_bind=True)\n\n    if c.result[\"description\"] != \"success\":\n        app.logger.error(\"Error connecting to the LDAP with the service account\")\n        return False\n\n    # Look for the user entry.\n    if not c.search(config.LDAPBASE,\n                    \"(\" + config.LDAPFIELD + \"=\" + login + \")\") :\n        app.logger.error(\"Error: Connection to the LDAP with service account failed\")\n    else:\n        if len(c.entries) >= 1 :\n            if len(c.entries) > 1 :\n                app.logger.error(\"Error: multiple entries with this login. \"+ \\\n                          \"Trying first entry...\")\n            uid = c.entries[0].entry_dn\n        else:\n            app.logger.error(\"Error: Login not found\")\n        c.unbind()\n    \n    return uid\n\n\ndef try_ldap_login(login, password):\n    \"\"\" Connect to a LDAP directory to verify user login/passwords\"\"\"\n    result = \"Wrong login/password\"\n    s = Server(config.LDAPURI, port=config.LDAPPORT,\n               use_ssl=False, get_info=ALL)\n    # 1. connection with service account to find the user uid\n    uid = useruid(s, login)\n   \n    if uid: \n        # 2. Try to bind the user to the LDAP\n        c = Connection(s, user = uid , password = password, auto_bind = True)\n        c.open()\n        c.bind()\n        result =  c.result[\"description\"] # \"success\" if bind is ok\n        c.unbind()\n\n    return result\n\n\ndef try_login(login, password, method=\"LDAP\"):\n    if method == \"LDAP\":\n        return try_ldap_login(login, password)\n\n\n@app.route(\"/user/login\", methods=[\"POST\"])\ndef user_login():\n    \"\"\"Allow passhportd to handle login/passwords for users\"\"\"\n    # Only POST data are handled\n    if request.method != \"POST\":\n        return utils.response(\"ERROR: POST method is required \", 405)\n\n    # Simplification for the reading\n    login = request.form[\"login\"]\n    password = request.form[\"password\"]\n\n    # Check for required fields\n    if not login or not password:\n        return utils.response(\"ERROR: The login and password are required \", 417)\n    elif login != escape_rdn(login):\n        return utils.response(\"ERROR: Bad input\", 417)\n\n    # Check data validity uppon LDAP/local/whatever...\n    result = try_login(login, password)\n    if result == \"success\":\n        app.logger.info(\"Authentication ok for {}\".format(login))\n        # If the LDAP connection is ok, user can connect\n        return utils.response(\"Authorized\", 200)\n    app.logger.warning(\"Authentication error for {} => \".format(login) + str(result))\n    return utils.response(\"Refused: \" + str(result), 200)\n\n\n@app.route(\"/user/list\")\ndef user_list():\n    \"\"\"Return the user list of database\"\"\"\n    result = []\n    query = db.session.query(user.User.name).order_by(user.User.name).all()\n\n    for row in query:\n        result.append(row[0])\n\n    if not result:\n        return utils.response(\"No user in database.\", 200)\n\n    return utils.response(\"\\n\".join(result), 200)\n\n\n@app.route(\"/user/search/<pattern>\")\ndef user_search(pattern):\n    \"\"\"Return a list of users that match the given pattern\"\"\"\n    result = []\n    query  = db.session.query(user.User.name)\\\n        .filter(user.User.name.like(\"%\" + pattern + \"%\"))\\\n        .order_by(user.User.name).all()\n\n    for row in query:\n        result.append(row[0])\n\n    if not result:\n        return utils.response('No user matching the pattern \"' + pattern + \\\n                              '\" found.', 200)\n\n    return utils.response(\"\\n\".join(result), 200)\n\n\n@app.route(\"/user/show/<name>\")\ndef user_show(name):\n    \"\"\"Return all data about a user\"\"\"\n    # Check for required fields\n    if not name:\n        return utils.response(\"ERROR: The name is required \", 417)\n\n    user_data = user.User.query.filter_by(name=name).first()\n\n    if user_data is None:\n        return utils.response('ERROR: No user with the name \"' + name + \\\n                              '\" in the database.', 417)\n\n    return utils.response(user_data.__repr__(), 200)\n\n@app.route(\"/user/access/<name>\")\ndef user_access(name):\n    \"\"\"Return all the targets accessible for this user in a simple way\"\"\"\n    if not name:\n    \treturn utils.response(\"ERROR: The name is required \", 417)\n\n    user_data = user.User.query.filter_by(name=name).first()\n\n    if user_data is None:\n        return utils.response('ERROR: No user with the name \"' + name + \\\n                              '\" in the database.', 417)\n\n    return utils.response(str(user_data.accessible_target_list(\"names\")), 200)\n\n\n@app.route(\"/user/memberof/<obj>/<name>\")\ndef user_memberof(obj, name):\n    \"\"\"Return the list of obj this user is member of\"\"\"\n    # Check for required fields\n    if not name:\n        return utils.response(\"ERROR: The name is required \", 417)\n\n    user_data = user.User.query.filter_by(name=name).first()\n\n    if user_data is None:\n        return utils.response('ERROR: No user with the name \"' + name + \\\n                              '\" in the database.', 417)\n\n    return utils.response(str(user_data.memberof(obj)), 200)\n\n\ndef atoi(text):\n    return int(text) if text.isdigit() else text\n\n\ndef naturalkeys(text):\n    \"\"\" stackoverflow how-to-correctly-sort-a-string-with-a-number-inside\n        and http://nedbatchelder.com/blog/200712/human_sorting.html \n        basically sort a text list taking care of numbers \"\"\"\n    return [ atoi(c) for c in re.split('(\\d+)', text) ]\n\n\ndef uaccessible_targets(name, withid = True, returnlist = False):\n    \"\"\"Return the list of the targets that the user can access\n       with the ID or without the ID of the target\"\"\"\n    # Check for required fields\n    if not name:\n        return utils.response(\"ERROR: The name is required \", 417)\n\n    user_data = user.User.query.filter_by(name=name).first()\n\n    if user_data is None:\n        return utils.response('ERROR: No user with the name \"' + name + \\\n                              '\" in the database.', 417)\n\n    target_list = user_data.accessible_target_list()\n    formatted_target_list = []\n\n    for each_target in target_list:\n        # We show only ssh targets, other types will not be handle here\n        if each_target.show_targettype() == \"ssh\":\n            data = \"\"\n            if withid:\n                data = str(each_target.id) + \" \"\n            data = data + each_target.show_name() + \" \" + \\\n                   each_target.show_hostname() + \" \" + \\\n                   each_target.show_comment()\n            formatted_target_list.append(data)\n    if returnlist:\n        return [target.show_name() for target in target_list \n                if target.show_targettype() == \"ssh\"]\n    if withid:\n        # We need to be sorted by target ID. Not so easy cause ID are strings\n        formatted_target_list.sort(key=naturalkeys) #naturalkey is a method right above\n    return utils.response(\"\\n\".join(formatted_target_list), 200)\n\n\n@app.route(\"/user/accessible_targets/<name>\")\ndef user_accessible_targets(name, returnlist = False):\n    \"\"\"Return the list of targets that the user can access\"\"\"\n    return  uaccessible_targets(name, False, returnlist)\n\n\n@app.route(\"/user/accessible_idtargets/<name>\")\ndef user_accessible_idtargets(name, returnlist = False):\n    \"\"\"Return the list of targets that the user can access with ID\"\"\"\n    return  uaccessible_targets(name, True, returnlist)\n\n\n@app.route(\"/user/accessible_target/<username>/<targetname>\")\ndef user_accssible_target(username, targetname):\n    \"\"\" Return True if the user can access this target, else return False \"\"\"\n    # Check for required fields\n    if not username or not targetname:\n        return utils.response(\"ERROR: Username or targetname is missing \", 417)\n    \n    if targetname in user_accessible_targets(username, returnlist = True):\n        return utils.response(\"True\", 200)\n    return utils.response(\"False\", 200)\n\n\ndef check_user_form(mandatory, request):\n    \"\"\"Check the user form to test several mandatory elements\"\"\"\n    # Must be POST\n    if not utils.is_post(request):\n        return utils.response(\"ERROR: POST method is required \", 405)\n\n    form = request.form\n    # Check mandatory fields\n    if utils.miss_mandatory(mandatory, form):\n        return utils.response(\"ERROR: The name and SSH key are required \", 417)\n\n    # User can't have same username\n    if utils.name_already_taken(form[\"name\"]):\n        return utils.response(\"ERROR: The name is already taken \", 417)\n    # User name can't contain spaces\n    if form[\"name\"] != form[\"name\"].replace(\" \",\"\"):\n        return utils.response(\"ERROR: The name can't contain spaces.\", 417)\n    \n    # Check SSHkey format\n    hashkey = utils.sshkey_good_format(form[\"sshkey\"])\n    if not hashkey:\n        return utils.response(\"ERROR: The SSHkey format is not recognized\", 417)\n\n    # Check SSHkey unicity\n    if utils.sshkey_already_taken(hashkey):\n        return utils.response(\"ERROR: Another user is using this SSHkey \", 417)\n\n    return True\n\n\n@app.route(\"/user/create\", methods=[\"POST\"])\ndef user_create():\n    \"\"\"Add a user in the database\"\"\"\n    # Check if fields are OK to be imported\n    # Some fields are mandatory\n    res = check_user_form([\"name\", \"sshkey\"],\n                          request)\n    if res is not True:\n        return res\n\n    hashkey = utils.sshkey_good_format(request.form[\"sshkey\"])\n\n    if request.form.get(\"logfilesize\"):\n        u = user.User(\n            name=request.form[\"name\"],\n            sshkey=request.form[\"sshkey\"],\n            sshkeyhash= utils.sshkey_good_format(request.form[\"sshkey\"]),\n            comment=request.form[\"comment\"],\n            logfilesize=request.form.get(\"logfilesize\"))\n    else:\n        u = user.User(\n            name=request.form[\"name\"],\n            sshkey=request.form[\"sshkey\"],\n            sshkeyhash=hashkey,\n            comment=request.form[\"comment\"])\n\n    res = utils.db_add_commit(u)\n    if res is not True:\n        return res\n\n    # Add the SSH key in the file authorized_keys\n    res = utils.write_authorized_keys(request.form[\"name\"], \n                                      request.form[\"sshkey\"])\n    if res is not True:\n        return res\n\n    return utils.response('OK: \"' + request.form[\"name\"] + '\" -> created', 200)\n\n\n@app.route(\"/user/togglesuperadmin/<name>\", methods=[\"GET\"])\ndef user_togglesuperadmin(name):\n    \"\"\"Change superadmin status of this user\"\"\"\n    userobj = utils.check_user_get(request, name)\n    if not userobj:\n        return utils.response(\"ERROR: The request is not correct. \" + \\\n                \"Are you sure this user is register on passhport?\", 417)\n\n    # Toggle the superadmin flag\n    new_state = userobj.togglesuperadmin()\n\n    res = utils.db_commit()\n    if res is not True:\n        return res\n\n    return utils.response(new_state, 200)\n\n\n@app.route(\"/user/issuperadmin/<name>\", methods=[\"GET\"])\ndef user_issuperadmin(name):\n    \"\"\"Return True if the user is superadmin\"\"\"\n    userobj = utils.check_user_get(request, name)\n    if not userobj:\n        return utils.response(\"ERROR: The request is not correct. \" + \\\n                \"Are you sure this user is register on passhport?\", 417)\n\n    return utils.response(str(userobj.superadmin), 200)\n    \n\n@app.route(\"/user/generate_authorized_keys\", methods=[\"GET\"])\n@app.route(\"/user/generate/authorized_keys\", methods=[\"GET\"])\ndef generate_authorized_keys():\n    \"\"\"Return a authorized_key files with all users\"\"\"\n    query = db.session.query(user.User).order_by(user.User.name).all()\n    r = \"\"\n    \n    for userdata in query:\n        r = r + 'command=\"' + config.PYTHON_PATH + \" \" + \\\n                config.PASSHPORT_PATH + \" \" + userdata.name + \\\n                '\" ' + userdata.sshkey + \"\\n\"\n    return r\n\n\ndef update_authorized_keys(orig_name, orig_sshkey, new_name, new_sshkey):\n    \"\"\"Edit the ssh autorized_keys file\"\"\"\n    \n    warning = \"OK\"\n    \n    # Set empty fields\n    if not new_name:\n        new_name = orig_name\n    if not new_sshkey:\n        new_sshkey = orig_sshkey\n\n    # Line supposed to be in the authorized_file\n    authorized_keys_line = 'command=\"' + config.PYTHON_PATH + \\\n                           \" \" + config.PASSHPORT_PATH + \\\n                           \" \" + orig_name + '\" ' + orig_sshkey + \"\\n\"\n\n    # Edit the SSH key in the file authorized_keys\n    try:\n        with open(config.SSH_KEY_FILE, \"r+\", encoding=\"utf8\") as \\\n                  authorized_keys_file:\n            line_edited = False\n            content = authorized_keys_file.read()\n            authorized_keys_file.seek(0)\n\n            for line in content.split('\\n')[:-1]:\n                if not line_edited:\n                    if line != authorized_keys_line[:-1]:\n                        authorized_keys_file.write(line + '\\n')\n                    else:\n                        authorized_keys_file.write(\n                                'command=\"' + config.PYTHON_PATH + \\\n                                \" \" + config.PASSHPORT_PATH + \\\n                                \" \" + new_name + '\" ' + new_sshkey + \"\\n\")\n                        line_edited = True\n                else:\n                    if line == authorized_keys_line[:-1]:\n                        warning = (\"WARNING: There is more \" + \\\n                                   \"than one line with this name and sshkey \" + \\\n                                   orig_name + \" - \" + orig_sshkey + \\\n                                   \", probably added manually. \" + \\\n                                   \"You should edit it manually\")\n\n                    authorized_keys_file.write(line + '\\n')\n\n            authorized_keys_file.truncate()\n\n    except IOError:\n        warning = utils.response('ERROR: cannot write in the file \"' + \\\n                                 '\"authorized_keys\"', 500)\n\n    return warning\n\n\ndef check_user_editform(mandatory, request):\n    \"\"\"Check the user form to test several mandatory elements\"\"\"\n    # Must be POST\n    if not utils.is_post(request):\n        return utils.response(\"ERROR: POST method is required.\", 405)\n\n    form = request.form\n    # Check mandatory fields\n    if utils.miss_mandatory(mandatory, form):\n        return utils.response(\"ERROR: The name is required.\", 417)\n\n    # User must exit in database\n    if not utils.name_already_taken(form[\"name\"]):\n        return utils.response(\"ERROR: User doesn't exist.\", 417)\n\n    if form[\"new_name\"]:\n        # User can't have same username\n        if form[\"new_name\"] != form[\"new_name\"].replace(\" \",\"\"):\n            return utils.response(\"ERROR: The name can't contain spaces.\", 417)\n        if form[\"new_name\"] != form[\"name\"] and  utils.name_already_taken(form[\"new_name\"]):\n            return utils.response(\"ERROR: The name is already taken.\", 417)\n    \n    if form[\"new_sshkey\"]:\n        # Check SSHkey format\n        hashkey = utils.sshkey_good_format(form[\"new_sshkey\"])\n        if not hashkey:\n            return utils.response(\n                             \"ERROR: The SSHkey format is not recognized.\", 417)\n\n        # Check SSHkey unicity\n        userwiththiskey = utils.get_key(hashkey)\n        if userwiththiskey:\n            if userwiththiskey.name != form[\"name\"]:\n                return utils.response(\n                              \"ERROR: Another user is using this SSHkey.\", 417)\n\n    return True\n\n\n@app.route(\"/user/edit\", methods=[\"POST\"])\ndef user_edit():\n    \"\"\"Edit a user in the database\"\"\"\n    # Check if fields are OK to be imported\n    res = check_user_editform([\"name\"], request)\n    if res is not True:\n        return res\n\n    need_authorizedkey_update = False\n    form = request.form\n    usertoupdate = db.session.query(user.User.name).filter_by(\n                                                     name=form[\"name\"])\n    legacysshkey = db.session.query(user.User.sshkey).filter_by(\n                                            name=form[\"name\"]).first()[0]\n\n    # Comment\n    if form[\"new_comment\"]:\n        # This specific string allows admins to remove old comments of the user\n        if form[\"new_comment\"] == \"PASSHPORTREMOVECOMMENT\":\n            form[\"new_comment\"] = \"\"\n        usertoupdate.update({\"comment\": form[\"new_comment\"]})\n\n    # SSHkey / Hash\n    if form[\"new_sshkey\"]:\n        usertoupdate.update({\"sshkey\": form[\"new_sshkey\"]})\n        usertoupdate.update({\"sshkeyhash\": user.User.hash(form[\"new_sshkey\"])})\n        need_authorizedkey_update = True\n\n    # Username\n    if form[\"new_name\"]:\n        usertoupdate.update({\"name\": form[\"new_name\"]})\n        need_authorizedkey_update = True\n\n    # Logfilesize\n    if form.get(\"new_logfilesize\"):\n        usertoupdate.update({\"logfilesize\": form[\"new_logfilesize\"]})\n\n\n    # Edit authorized_keys to change username or sshkey or both\n    if need_authorizedkey_update:\n        res = update_authorized_keys(form[\"name\"], legacysshkey, \\\n                              form[\"new_name\"], form[\"new_sshkey\"])\n        if res != \"OK\":\n            return res\n\n    res = utils.db_commit()\n    if res is not True:\n        return res\n\n    return utils.response('OK: \"' + form[\"name\"] + '\" -> edited', 200)\n\n\n@app.route(\"/user/delete/<name>\")\ndef user_delete(name):\n    \"\"\"Delete a user in the database\n       in the authorizedkey file\n       in the associated targets\n       and in the associated groups\"\"\"\n    if not name:\n        return utils.response(\"ERROR: The name is required \", 417)\n\n    # Check if the name exists\n    query = db.session.query(user.User).filter_by(name=name).first()\n\n    if query is None:\n        return utils.response('ERROR: No user with the name \"' + name + \\\n                              '\" in the database.', 417)\n            \n    authorized_key_line = 'command=\"' + config.PYTHON_PATH + \\\n                          \" \" + config.PASSHPORT_PATH + \\\n                          \" \" + name + '\" ' + query.sshkey + \"\\n\"\n\n    # Delete the SSH key from the file authorized_keys\n    warning = \"\"\n    try:\n        with open(config.SSH_KEY_FILE, \"r+\", encoding=\"utf8\") as \\\n            authorized_keys_file:\n            line_deleted = False\n            content = authorized_keys_file.read()\n            authorized_keys_file.seek(0)\n\n            for line in content.split('\\n')[:-1]:\n                if not line_deleted:\n                    if line != authorized_key_line[:-1]:\n                        authorized_keys_file.write(line + '\\n')\n                    else:\n                        line_deleted = True\n                else:\n                    if line == authorized_key_line[:-1]:\n                        warning = (\"\\nWARNING: There is more than one line \"\n                            \"with the sshkey \" + query.sshkey + \", probably \"\n                            \"added manually. You should delete it manually\")\n\n                    authorized_keys_file.write(line + '\\n')\n\n            authorized_keys_file.truncate()\n    except IOError:\n        return utils.response('ERROR: cannot write in the file ' + \\\n                              '\"authorized_keys\"', 500)\n\n    # Delete the user from the associated targets\n    user_data = user.User.query.filter_by(name=name).first()\n \n    target_list = user_data.direct_targets()\n    for each_target in target_list:\n        each_target.rmuser(user_data)\n\n    # Delete the user form the associated usergroups\n    usergroup_list = user_data.direct_usergroups()\n    for each_usergroup in usergroup_list:\n        each_usergroup.rmuser(user_data)\n\n    # Delete the user form the associated targetgroups\n    targetgroup_list = user_data.direct_targetgroups()\n    for each_targetgroup in targetgroup_list:\n        each_targetgroup.rmuser(user_data)\n\n    # Delete the log entries\n    for lentry in user_data.logentries:\n        lentry.user.remove(lentry.user[0])\n\t\n    # Finally delet the user from the db\n    db.session.query(\n        user.User).filter(\n        user.User.name == name).delete()\n\n    try:\n        db.session.commit()\n    except exc.SQLAlchemyError as e:\n        return utils.response('ERROR: \"' + name + '\" -> ' + e.message, 409)\n\n    return utils.response('OK: \"' + name + '\" -> deleted' + warning, 200)\n\n\n@app.route(\"/user/lastlog/<name>\")\ndef user_lastlog(name):\n    \"\"\"Return the 500 last logs as json\"\"\"\n    u = utils.get_user(name)\n    if not u:\n        return \"{}\"\n    return u.get_lastlog()\n\n\n@app.route(\"/user/ismanager/<name>\", methods=[\"GET\"])\ndef user_is_manager(name):\n    \"\"\"Return True if the user is a manager of any usergroup\"\"\"\n    u = utils.check_user_get(request, name)\n    if not u:\n        return utils.response(\"ERROR: The request is not correct\", 417)\n\n    return utils.response(str(u.is_manager()), 200)\n\n\n@app.route(\"/user/generate/sshkeyhash\", methods=[\"GET\"])\ndef generate_sshkeyhash():\n    \"\"\"Re generate the sshkey hash for all users\"\"\"\n    query = db.session.query(user.User).order_by(user.User.name).all()\n    \n    for u in query:\n        u.sshkeyhash=u.hash(u.sshkey)\n\n    try:\n        db.session.commit()\n    except exc.SQLAlchemyError as e:\n        return utils.response('ERROR: \"' + name + '\" -> ' + e.message, 409)\n\n    return utils.response('OK: All sshkey hash generated', 200)\n\n   \n@app.route(\"/user/attachedto/usergroup/<name>\")\ndef user_attached_to_usergroup(name):\n    \"\"\"Return the list of the usergroups that contains this user\"\"\"\n    u = utils.check_user_get(request, name)\n    if not u:\n        return utils.response(\"ERROR: The request is not correct\", 417)\n\n    return utils.response(str(u.show_usergroup()), 200)\n    \n"], "fixing_code": ["# -*- coding:Utf-8 -*-\n\n\nimport os, sys, stat, re\nimport config\n\nfrom io import open\nfrom ldap3 import Server, Connection, ALL\nfrom ldap3.utils.dn import escape_rdn\nfrom flask import request\nfrom sqlalchemy import exc\nfrom sqlalchemy.orm import sessionmaker\nfrom app import app, db\nfrom app.models_mod import user, target\nfrom . import api\nfrom .. import utilities as utils\n\n\ndef useruid(s, login):\n    \"\"\"Connect to a LDAP and check the uid matching the given field data\"\"\"\n    uid = False\n    c = Connection(s, config.LDAPACC, \n                   password=config.LDAPPASS, auto_bind=True)\n\n    if c.result[\"description\"] != \"success\":\n        app.logger.error(\"Error connecting to the LDAP with the service account\")\n        return False\n\n    # Look for the user entry.\n    if not c.search(config.LDAPBASE,\n                    \"(\" + config.LDAPFIELD + \"=\" + escape_rdn(login) + \")\") :\n        app.logger.error(\"Error: Connection to the LDAP with service account failed\")\n    else:\n        if len(c.entries) >= 1 :\n            if len(c.entries) > 1 :\n                app.logger.error(\"Error: multiple entries with this login. \"+ \\\n                          \"Trying first entry...\")\n            uid = c.entries[0].entry_dn\n        else:\n            app.logger.error(\"Error: Login not found\")\n        c.unbind()\n    \n    return uid\n\n\ndef try_ldap_login(login, password):\n    \"\"\" Connect to a LDAP directory to verify user login/passwords\"\"\"\n    result = \"Wrong login/password\"\n    s = Server(config.LDAPURI, port=config.LDAPPORT,\n               use_ssl=False, get_info=ALL)\n    # 1. connection with service account to find the user uid\n    uid = useruid(s, escape_rdn(login))\n   \n    if uid: \n        # 2. Try to bind the user to the LDAP\n        c = Connection(s, user = uid , password = password, auto_bind = True)\n        c.open()\n        c.bind()\n        result =  c.result[\"description\"] # \"success\" if bind is ok\n        c.unbind()\n\n    return result\n\n\ndef try_login(login, password, method=\"LDAP\"):\n    if method == \"LDAP\":\n        return try_ldap_login(login, password)\n\n\n@app.route(\"/user/login\", methods=[\"POST\"])\ndef user_login():\n    \"\"\"Allow passhportd to handle login/passwords for users\"\"\"\n    # Only POST data are handled\n    if request.method != \"POST\":\n        return utils.response(\"ERROR: POST method is required \", 405)\n\n    # Simplification for the reading\n    login = request.form[\"login\"]\n    password = request.form[\"password\"]\n\n    # Check for required fields\n    if not login or not password:\n        return utils.response(\"ERROR: The login and password are required \", 417)\n    elif login != escape_rdn(login):\n        return utils.response(\"ERROR: Bad input\", 417)\n\n    # Check data validity uppon LDAP/local/whatever...\n    result = try_login(login, password)\n    if result == \"success\":\n        app.logger.info(\"Authentication ok for {}\".format(login))\n        # If the LDAP connection is ok, user can connect\n        return utils.response(\"Authorized\", 200)\n    app.logger.warning(\"Authentication error for {} => \".format(login) + str(result))\n    return utils.response(\"Refused: \" + str(result), 200)\n\n\n@app.route(\"/user/list\")\ndef user_list():\n    \"\"\"Return the user list of database\"\"\"\n    result = []\n    query = db.session.query(user.User.name).order_by(user.User.name).all()\n\n    for row in query:\n        result.append(row[0])\n\n    if not result:\n        return utils.response(\"No user in database.\", 200)\n\n    return utils.response(\"\\n\".join(result), 200)\n\n\n@app.route(\"/user/search/<pattern>\")\ndef user_search(pattern):\n    \"\"\"Return a list of users that match the given pattern\"\"\"\n    result = []\n    query  = db.session.query(user.User.name)\\\n        .filter(user.User.name.like(\"%\" + pattern + \"%\"))\\\n        .order_by(user.User.name).all()\n\n    for row in query:\n        result.append(row[0])\n\n    if not result:\n        return utils.response('No user matching the pattern \"' + pattern + \\\n                              '\" found.', 200)\n\n    return utils.response(\"\\n\".join(result), 200)\n\n\n@app.route(\"/user/show/<name>\")\ndef user_show(name):\n    \"\"\"Return all data about a user\"\"\"\n    # Check for required fields\n    if not name:\n        return utils.response(\"ERROR: The name is required \", 417)\n\n    user_data = user.User.query.filter_by(name=name).first()\n\n    if user_data is None:\n        return utils.response('ERROR: No user with the name \"' + name + \\\n                              '\" in the database.', 417)\n\n    return utils.response(user_data.__repr__(), 200)\n\n@app.route(\"/user/access/<name>\")\ndef user_access(name):\n    \"\"\"Return all the targets accessible for this user in a simple way\"\"\"\n    if not name:\n    \treturn utils.response(\"ERROR: The name is required \", 417)\n\n    user_data = user.User.query.filter_by(name=name).first()\n\n    if user_data is None:\n        return utils.response('ERROR: No user with the name \"' + name + \\\n                              '\" in the database.', 417)\n\n    return utils.response(str(user_data.accessible_target_list(\"names\")), 200)\n\n\n@app.route(\"/user/memberof/<obj>/<name>\")\ndef user_memberof(obj, name):\n    \"\"\"Return the list of obj this user is member of\"\"\"\n    # Check for required fields\n    if not name:\n        return utils.response(\"ERROR: The name is required \", 417)\n\n    user_data = user.User.query.filter_by(name=name).first()\n\n    if user_data is None:\n        return utils.response('ERROR: No user with the name \"' + name + \\\n                              '\" in the database.', 417)\n\n    return utils.response(str(user_data.memberof(obj)), 200)\n\n\ndef atoi(text):\n    return int(text) if text.isdigit() else text\n\n\ndef naturalkeys(text):\n    \"\"\" stackoverflow how-to-correctly-sort-a-string-with-a-number-inside\n        and http://nedbatchelder.com/blog/200712/human_sorting.html \n        basically sort a text list taking care of numbers \"\"\"\n    return [ atoi(c) for c in re.split('(\\d+)', text) ]\n\n\ndef uaccessible_targets(name, withid = True, returnlist = False):\n    \"\"\"Return the list of the targets that the user can access\n       with the ID or without the ID of the target\"\"\"\n    # Check for required fields\n    if not name:\n        return utils.response(\"ERROR: The name is required \", 417)\n\n    user_data = user.User.query.filter_by(name=name).first()\n\n    if user_data is None:\n        return utils.response('ERROR: No user with the name \"' + name + \\\n                              '\" in the database.', 417)\n\n    target_list = user_data.accessible_target_list()\n    formatted_target_list = []\n\n    for each_target in target_list:\n        # We show only ssh targets, other types will not be handle here\n        if each_target.show_targettype() == \"ssh\":\n            data = \"\"\n            if withid:\n                data = str(each_target.id) + \" \"\n            data = data + each_target.show_name() + \" \" + \\\n                   each_target.show_hostname() + \" \" + \\\n                   each_target.show_comment()\n            formatted_target_list.append(data)\n    if returnlist:\n        return [target.show_name() for target in target_list \n                if target.show_targettype() == \"ssh\"]\n    if withid:\n        # We need to be sorted by target ID. Not so easy cause ID are strings\n        formatted_target_list.sort(key=naturalkeys) #naturalkey is a method right above\n    return utils.response(\"\\n\".join(formatted_target_list), 200)\n\n\n@app.route(\"/user/accessible_targets/<name>\")\ndef user_accessible_targets(name, returnlist = False):\n    \"\"\"Return the list of targets that the user can access\"\"\"\n    return  uaccessible_targets(name, False, returnlist)\n\n\n@app.route(\"/user/accessible_idtargets/<name>\")\ndef user_accessible_idtargets(name, returnlist = False):\n    \"\"\"Return the list of targets that the user can access with ID\"\"\"\n    return  uaccessible_targets(name, True, returnlist)\n\n\n@app.route(\"/user/accessible_target/<username>/<targetname>\")\ndef user_accssible_target(username, targetname):\n    \"\"\" Return True if the user can access this target, else return False \"\"\"\n    # Check for required fields\n    if not username or not targetname:\n        return utils.response(\"ERROR: Username or targetname is missing \", 417)\n    \n    if targetname in user_accessible_targets(username, returnlist = True):\n        return utils.response(\"True\", 200)\n    return utils.response(\"False\", 200)\n\n\ndef check_user_form(mandatory, request):\n    \"\"\"Check the user form to test several mandatory elements\"\"\"\n    # Must be POST\n    if not utils.is_post(request):\n        return utils.response(\"ERROR: POST method is required \", 405)\n\n    form = request.form\n    # Check mandatory fields\n    if utils.miss_mandatory(mandatory, form):\n        return utils.response(\"ERROR: The name and SSH key are required \", 417)\n\n    # User can't have same username\n    if utils.name_already_taken(form[\"name\"]):\n        return utils.response(\"ERROR: The name is already taken \", 417)\n    # User name can't contain spaces\n    if form[\"name\"] != form[\"name\"].replace(\" \",\"\"):\n        return utils.response(\"ERROR: The name can't contain spaces.\", 417)\n    \n    # Check SSHkey format\n    hashkey = utils.sshkey_good_format(form[\"sshkey\"])\n    if not hashkey:\n        return utils.response(\"ERROR: The SSHkey format is not recognized\", 417)\n\n    # Check SSHkey unicity\n    if utils.sshkey_already_taken(hashkey):\n        return utils.response(\"ERROR: Another user is using this SSHkey \", 417)\n\n    return True\n\n\n@app.route(\"/user/create\", methods=[\"POST\"])\ndef user_create():\n    \"\"\"Add a user in the database\"\"\"\n    # Check if fields are OK to be imported\n    # Some fields are mandatory\n    res = check_user_form([\"name\", \"sshkey\"],\n                          request)\n    if res is not True:\n        return res\n\n    hashkey = utils.sshkey_good_format(request.form[\"sshkey\"])\n\n    if request.form.get(\"logfilesize\"):\n        u = user.User(\n            name=request.form[\"name\"],\n            sshkey=request.form[\"sshkey\"],\n            sshkeyhash= utils.sshkey_good_format(request.form[\"sshkey\"]),\n            comment=request.form[\"comment\"],\n            logfilesize=request.form.get(\"logfilesize\"))\n    else:\n        u = user.User(\n            name=request.form[\"name\"],\n            sshkey=request.form[\"sshkey\"],\n            sshkeyhash=hashkey,\n            comment=request.form[\"comment\"])\n\n    res = utils.db_add_commit(u)\n    if res is not True:\n        return res\n\n    # Add the SSH key in the file authorized_keys\n    res = utils.write_authorized_keys(request.form[\"name\"], \n                                      request.form[\"sshkey\"])\n    if res is not True:\n        return res\n\n    return utils.response('OK: \"' + request.form[\"name\"] + '\" -> created', 200)\n\n\n@app.route(\"/user/togglesuperadmin/<name>\", methods=[\"GET\"])\ndef user_togglesuperadmin(name):\n    \"\"\"Change superadmin status of this user\"\"\"\n    userobj = utils.check_user_get(request, name)\n    if not userobj:\n        return utils.response(\"ERROR: The request is not correct. \" + \\\n                \"Are you sure this user is register on passhport?\", 417)\n\n    # Toggle the superadmin flag\n    new_state = userobj.togglesuperadmin()\n\n    res = utils.db_commit()\n    if res is not True:\n        return res\n\n    return utils.response(new_state, 200)\n\n\n@app.route(\"/user/issuperadmin/<name>\", methods=[\"GET\"])\ndef user_issuperadmin(name):\n    \"\"\"Return True if the user is superadmin\"\"\"\n    userobj = utils.check_user_get(request, name)\n    if not userobj:\n        return utils.response(\"ERROR: The request is not correct. \" + \\\n                \"Are you sure this user is register on passhport?\", 417)\n\n    return utils.response(str(userobj.superadmin), 200)\n    \n\n@app.route(\"/user/generate_authorized_keys\", methods=[\"GET\"])\n@app.route(\"/user/generate/authorized_keys\", methods=[\"GET\"])\ndef generate_authorized_keys():\n    \"\"\"Return a authorized_key files with all users\"\"\"\n    query = db.session.query(user.User).order_by(user.User.name).all()\n    r = \"\"\n    \n    for userdata in query:\n        r = r + 'command=\"' + config.PYTHON_PATH + \" \" + \\\n                config.PASSHPORT_PATH + \" \" + userdata.name + \\\n                '\" ' + userdata.sshkey + \"\\n\"\n    return r\n\n\ndef update_authorized_keys(orig_name, orig_sshkey, new_name, new_sshkey):\n    \"\"\"Edit the ssh autorized_keys file\"\"\"\n    \n    warning = \"OK\"\n    \n    # Set empty fields\n    if not new_name:\n        new_name = orig_name\n    if not new_sshkey:\n        new_sshkey = orig_sshkey\n\n    # Line supposed to be in the authorized_file\n    authorized_keys_line = 'command=\"' + config.PYTHON_PATH + \\\n                           \" \" + config.PASSHPORT_PATH + \\\n                           \" \" + orig_name + '\" ' + orig_sshkey + \"\\n\"\n\n    # Edit the SSH key in the file authorized_keys\n    try:\n        with open(config.SSH_KEY_FILE, \"r+\", encoding=\"utf8\") as \\\n                  authorized_keys_file:\n            line_edited = False\n            content = authorized_keys_file.read()\n            authorized_keys_file.seek(0)\n\n            for line in content.split('\\n')[:-1]:\n                if not line_edited:\n                    if line != authorized_keys_line[:-1]:\n                        authorized_keys_file.write(line + '\\n')\n                    else:\n                        authorized_keys_file.write(\n                                'command=\"' + config.PYTHON_PATH + \\\n                                \" \" + config.PASSHPORT_PATH + \\\n                                \" \" + new_name + '\" ' + new_sshkey + \"\\n\")\n                        line_edited = True\n                else:\n                    if line == authorized_keys_line[:-1]:\n                        warning = (\"WARNING: There is more \" + \\\n                                   \"than one line with this name and sshkey \" + \\\n                                   orig_name + \" - \" + orig_sshkey + \\\n                                   \", probably added manually. \" + \\\n                                   \"You should edit it manually\")\n\n                    authorized_keys_file.write(line + '\\n')\n\n            authorized_keys_file.truncate()\n\n    except IOError:\n        warning = utils.response('ERROR: cannot write in the file \"' + \\\n                                 '\"authorized_keys\"', 500)\n\n    return warning\n\n\ndef check_user_editform(mandatory, request):\n    \"\"\"Check the user form to test several mandatory elements\"\"\"\n    # Must be POST\n    if not utils.is_post(request):\n        return utils.response(\"ERROR: POST method is required.\", 405)\n\n    form = request.form\n    # Check mandatory fields\n    if utils.miss_mandatory(mandatory, form):\n        return utils.response(\"ERROR: The name is required.\", 417)\n\n    # User must exit in database\n    if not utils.name_already_taken(form[\"name\"]):\n        return utils.response(\"ERROR: User doesn't exist.\", 417)\n\n    if form[\"new_name\"]:\n        # User can't have same username\n        if form[\"new_name\"] != form[\"new_name\"].replace(\" \",\"\"):\n            return utils.response(\"ERROR: The name can't contain spaces.\", 417)\n        if form[\"new_name\"] != form[\"name\"] and  utils.name_already_taken(form[\"new_name\"]):\n            return utils.response(\"ERROR: The name is already taken.\", 417)\n    \n    if form[\"new_sshkey\"]:\n        # Check SSHkey format\n        hashkey = utils.sshkey_good_format(form[\"new_sshkey\"])\n        if not hashkey:\n            return utils.response(\n                             \"ERROR: The SSHkey format is not recognized.\", 417)\n\n        # Check SSHkey unicity\n        userwiththiskey = utils.get_key(hashkey)\n        if userwiththiskey:\n            if userwiththiskey.name != form[\"name\"]:\n                return utils.response(\n                              \"ERROR: Another user is using this SSHkey.\", 417)\n\n    return True\n\n\n@app.route(\"/user/edit\", methods=[\"POST\"])\ndef user_edit():\n    \"\"\"Edit a user in the database\"\"\"\n    # Check if fields are OK to be imported\n    res = check_user_editform([\"name\"], request)\n    if res is not True:\n        return res\n\n    need_authorizedkey_update = False\n    form = request.form\n    usertoupdate = db.session.query(user.User.name).filter_by(\n                                                     name=form[\"name\"])\n    legacysshkey = db.session.query(user.User.sshkey).filter_by(\n                                            name=form[\"name\"]).first()[0]\n\n    # Comment\n    if form[\"new_comment\"]:\n        # This specific string allows admins to remove old comments of the user\n        if form[\"new_comment\"] == \"PASSHPORTREMOVECOMMENT\":\n            form[\"new_comment\"] = \"\"\n        usertoupdate.update({\"comment\": form[\"new_comment\"]})\n\n    # SSHkey / Hash\n    if form[\"new_sshkey\"]:\n        usertoupdate.update({\"sshkey\": form[\"new_sshkey\"]})\n        usertoupdate.update({\"sshkeyhash\": user.User.hash(form[\"new_sshkey\"])})\n        need_authorizedkey_update = True\n\n    # Username\n    if form[\"new_name\"]:\n        usertoupdate.update({\"name\": form[\"new_name\"]})\n        need_authorizedkey_update = True\n\n    # Logfilesize\n    if form.get(\"new_logfilesize\"):\n        usertoupdate.update({\"logfilesize\": form[\"new_logfilesize\"]})\n\n\n    # Edit authorized_keys to change username or sshkey or both\n    if need_authorizedkey_update:\n        res = update_authorized_keys(form[\"name\"], legacysshkey, \\\n                              form[\"new_name\"], form[\"new_sshkey\"])\n        if res != \"OK\":\n            return res\n\n    res = utils.db_commit()\n    if res is not True:\n        return res\n\n    return utils.response('OK: \"' + form[\"name\"] + '\" -> edited', 200)\n\n\n@app.route(\"/user/delete/<name>\")\ndef user_delete(name):\n    \"\"\"Delete a user in the database\n       in the authorizedkey file\n       in the associated targets\n       and in the associated groups\"\"\"\n    if not name:\n        return utils.response(\"ERROR: The name is required \", 417)\n\n    # Check if the name exists\n    query = db.session.query(user.User).filter_by(name=name).first()\n\n    if query is None:\n        return utils.response('ERROR: No user with the name \"' + name + \\\n                              '\" in the database.', 417)\n            \n    authorized_key_line = 'command=\"' + config.PYTHON_PATH + \\\n                          \" \" + config.PASSHPORT_PATH + \\\n                          \" \" + name + '\" ' + query.sshkey + \"\\n\"\n\n    # Delete the SSH key from the file authorized_keys\n    warning = \"\"\n    try:\n        with open(config.SSH_KEY_FILE, \"r+\", encoding=\"utf8\") as \\\n            authorized_keys_file:\n            line_deleted = False\n            content = authorized_keys_file.read()\n            authorized_keys_file.seek(0)\n\n            for line in content.split('\\n')[:-1]:\n                if not line_deleted:\n                    if line != authorized_key_line[:-1]:\n                        authorized_keys_file.write(line + '\\n')\n                    else:\n                        line_deleted = True\n                else:\n                    if line == authorized_key_line[:-1]:\n                        warning = (\"\\nWARNING: There is more than one line \"\n                            \"with the sshkey \" + query.sshkey + \", probably \"\n                            \"added manually. You should delete it manually\")\n\n                    authorized_keys_file.write(line + '\\n')\n\n            authorized_keys_file.truncate()\n    except IOError:\n        return utils.response('ERROR: cannot write in the file ' + \\\n                              '\"authorized_keys\"', 500)\n\n    # Delete the user from the associated targets\n    user_data = user.User.query.filter_by(name=name).first()\n \n    target_list = user_data.direct_targets()\n    for each_target in target_list:\n        each_target.rmuser(user_data)\n\n    # Delete the user form the associated usergroups\n    usergroup_list = user_data.direct_usergroups()\n    for each_usergroup in usergroup_list:\n        each_usergroup.rmuser(user_data)\n\n    # Delete the user form the associated targetgroups\n    targetgroup_list = user_data.direct_targetgroups()\n    for each_targetgroup in targetgroup_list:\n        each_targetgroup.rmuser(user_data)\n\n    # Delete the log entries\n    for lentry in user_data.logentries:\n        lentry.user.remove(lentry.user[0])\n\t\n    # Finally delet the user from the db\n    db.session.query(\n        user.User).filter(\n        user.User.name == name).delete()\n\n    try:\n        db.session.commit()\n    except exc.SQLAlchemyError as e:\n        return utils.response('ERROR: \"' + name + '\" -> ' + e.message, 409)\n\n    return utils.response('OK: \"' + name + '\" -> deleted' + warning, 200)\n\n\n@app.route(\"/user/lastlog/<name>\")\ndef user_lastlog(name):\n    \"\"\"Return the 500 last logs as json\"\"\"\n    u = utils.get_user(name)\n    if not u:\n        return \"{}\"\n    return u.get_lastlog()\n\n\n@app.route(\"/user/ismanager/<name>\", methods=[\"GET\"])\ndef user_is_manager(name):\n    \"\"\"Return True if the user is a manager of any usergroup\"\"\"\n    u = utils.check_user_get(request, name)\n    if not u:\n        return utils.response(\"ERROR: The request is not correct\", 417)\n\n    return utils.response(str(u.is_manager()), 200)\n\n\n@app.route(\"/user/generate/sshkeyhash\", methods=[\"GET\"])\ndef generate_sshkeyhash():\n    \"\"\"Re generate the sshkey hash for all users\"\"\"\n    query = db.session.query(user.User).order_by(user.User.name).all()\n    \n    for u in query:\n        u.sshkeyhash=u.hash(u.sshkey)\n\n    try:\n        db.session.commit()\n    except exc.SQLAlchemyError as e:\n        return utils.response('ERROR: \"' + name + '\" -> ' + e.message, 409)\n\n    return utils.response('OK: All sshkey hash generated', 200)\n\n   \n@app.route(\"/user/attachedto/usergroup/<name>\")\ndef user_attached_to_usergroup(name):\n    \"\"\"Return the list of the usergroups that contains this user\"\"\"\n    u = utils.check_user_get(request, name)\n    if not u:\n        return utils.response(\"ERROR: The request is not correct\", 417)\n\n    return utils.response(str(u.show_usergroup()), 200)\n    \n"], "filenames": ["passhportd/app/views_mod/user/user.py"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [53], "fixing_code_start_loc": [31], "fixing_code_end_loc": [53], "type": "CWE-74", "message": "app/views_mod/user/user.py in LibrIT PaSSHport through 2.5 is affected by LDAP Injection. There is an information leak through the crafting of special queries, escaping the provided search filter because user input gets no sanitization.", "other": {"cve": {"id": "CVE-2021-3027", "sourceIdentifier": "cve@mitre.org", "published": "2021-03-26T03:16:40.647", "lastModified": "2022-05-03T16:04:40.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "app/views_mod/user/user.py in LibrIT PaSSHport through 2.5 is affected by LDAP Injection. There is an information leak through the crafting of special queries, escaping the provided search filter because user input gets no sanitization."}, {"lang": "es", "value": "El archivo app/views_mod/user/user.py en LibrIT PaSSHport hasta versi\u00f3n 2.5, est\u00e1 afectado por una inyecci\u00f3n de LDAP. Un filtrado de informaci\u00f3n se presenta por el procesamiento de consultas especiales, escapando del filtro de b\u00fasqueda proporcionado debido a que la entrada del usuario no es saneada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:librit:passhport:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5", "matchCriteriaId": "80FB2365-DFD9-46AA-B636-FD4E4AAC0D6A"}]}]}], "references": [{"url": "https://github.com/LibrIT/passhport/commit/366b03f607729c4538e91b634ecc57c8398522a1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibrIT/passhport/pull/562", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://jorgectf.gitlab.io/disclosure/cve-2021-3027/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibrIT/passhport/commit/366b03f607729c4538e91b634ecc57c8398522a1"}}