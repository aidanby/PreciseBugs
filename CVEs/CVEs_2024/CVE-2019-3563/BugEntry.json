{"buggy_code": ["/*\n * Copyright 2017-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <wangle/codec/LineBasedFrameDecoder.h>\n\nnamespace wangle {\n\nusing folly::io::Cursor;\nusing folly::IOBuf;\nusing folly::IOBufQueue;\n\nLineBasedFrameDecoder::LineBasedFrameDecoder(uint32_t maxLength,\n                                             bool stripDelimiter,\n                                             TerminatorType terminatorType)\n    : maxLength_(maxLength)\n    , stripDelimiter_(stripDelimiter)\n    , terminatorType_(terminatorType) {}\n\nbool LineBasedFrameDecoder::decode(Context* ctx,\n                                   IOBufQueue& buf,\n                                   std::unique_ptr<IOBuf>& result,\n                                   size_t&) {\n  int64_t eol = findEndOfLine(buf);\n\n  if (!discarding_) {\n    if (eol >= 0) {\n      Cursor c(buf.front());\n      c += eol;\n      auto delimLength = c.read<char>() == '\\r' ? 2 : 1;\n      if (eol > maxLength_) {\n        buf.split(eol + delimLength);\n        fail(ctx, folly::to<std::string>(eol));\n        return false;\n      }\n\n      std::unique_ptr<folly::IOBuf> frame;\n\n      if (stripDelimiter_) {\n        frame = buf.split(eol);\n        buf.trimStart(delimLength);\n      } else {\n        frame = buf.split(eol + delimLength);\n      }\n\n      result = std::move(frame);\n      return true;\n    } else {\n      auto len = buf.chainLength();\n      if (len > maxLength_) {\n        discardedBytes_ = len;\n        buf.trimStart(len);\n        discarding_ = true;\n        fail(ctx, \"over \" + folly::to<std::string>(len));\n      }\n      return false;\n    }\n  } else {\n    if (eol >= 0) {\n      Cursor c(buf.front());\n      c += eol;\n      auto delimLength = c.read<char>() == '\\r' ? 2 : 1;\n      buf.trimStart(eol + delimLength);\n      discardedBytes_ = 0;\n      discarding_ = false;\n    } else {\n      discardedBytes_ = buf.chainLength();\n      buf.move();\n    }\n\n    return false;\n  }\n}\n\nvoid LineBasedFrameDecoder::fail(Context* ctx, std::string len) {\n  ctx->fireReadException(\n    folly::make_exception_wrapper<std::runtime_error>(\n      \"frame length\" + len +\n      \" exeeds max \" + folly::to<std::string>(maxLength_)));\n}\n\nint64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {\n  Cursor c(buf.front());\n  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {\n    auto b = c.read<char>();\n    if (b == '\\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {\n      return i;\n    } else if (terminatorType_ != TerminatorType::NEWLINE &&\n               b == '\\r' && !c.isAtEnd() && c.read<char>() == '\\n') {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n} // namespace wangle\n", "/*\n * Copyright 2017-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/portability/GTest.h>\n\n#include <wangle/codec/FixedLengthFrameDecoder.h>\n#include <wangle/codec/LengthFieldBasedFrameDecoder.h>\n#include <wangle/codec/LengthFieldPrepender.h>\n#include <wangle/codec/LineBasedFrameDecoder.h>\n#include <wangle/codec/test/CodecTestUtils.h>\n\nusing namespace folly;\nusing namespace wangle;\nusing namespace folly::io;\n\nnamespace {\nauto createZeroedBuffer(size_t size) {\n  auto ret = IOBuf::create(size);\n  ret->append(size);\n  std::memset(ret->writableData(), 0x00, size);\n  return ret;\n}\n}\n\nTEST(FixedLengthFrameDecoder, FailWhenLengthFieldEndOffset) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(FixedLengthFrameDecoder(10))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 10);\n      }))\n    .finalize();\n\n  auto buf3 = createZeroedBuffer(3);\n  auto buf11 = createZeroedBuffer(11);\n  auto buf16 = createZeroedBuffer(16);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf3));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(buf11));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  q.append(std::move(buf16));\n  pipeline->read(q);\n  EXPECT_EQ(called, 3);\n}\n\nTEST(LengthFieldFramePipeline, SimpleTest) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(test::BytesReflector())\n    .addBack(LengthFieldPrepender())\n    .addBack(LengthFieldBasedFrameDecoder())\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 2);\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(2);\n  pipeline->write(std::move(buf));\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFramePipeline, LittleEndian) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(test::BytesReflector())\n    .addBack(LengthFieldBasedFrameDecoder(4, 100, 0, 0, 4, false))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 1);\n      }))\n    .addBack(LengthFieldPrepender(4, 0, false, false))\n    .finalize();\n\n  auto buf = createZeroedBuffer(1);\n  pipeline->write(std::move(buf));\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, Simple) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder())\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 1);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(4);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint32_t)1);\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, NoStrip) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 0, 0, 0))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 3);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(2);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint16_t)1);\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, Adjustment) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 0, -2, 0))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 3);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(2);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint16_t)3); // includes frame size\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, PreHeader) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 2, 0, 0))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 5);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(4);\n  RWPrivateCursor c(bufFrame.get());\n  c.write((uint16_t)100); // header\n  c.writeBE((uint16_t)1); // frame size\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, PostHeader) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 0, 2, 0))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 5);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(4);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint16_t)1); // frame size\n  c.write((uint16_t)100); // header\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoderStrip, PrePostHeader) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 2, 2, 4))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 3);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(6);\n  RWPrivateCursor c(bufFrame.get());\n  c.write((uint16_t)100); // pre header\n  c.writeBE((uint16_t)1); // frame size\n  c.write((uint16_t)100); // post header\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, StripPrePostHeaderFrameInclHeader) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 2, -2, 4))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 3);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(6);\n  RWPrivateCursor c(bufFrame.get());\n  c.write((uint16_t)100); // pre header\n  c.writeBE((uint16_t)5); // frame size\n  c.write((uint16_t)100); // post header\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, FailTestLengthFieldEndOffset) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(4, 10, 4, -2, 4))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        ASSERT_EQ(nullptr, buf);\n        called++;\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(8);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint32_t)0); // frame size\n  c.write((uint32_t)0); // crap\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, FailTestLengthFieldFrameSize) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(4, 10, 0, 0, 4))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        ASSERT_EQ(nullptr, buf);\n        called++;\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(16);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint32_t)12); // frame size\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, FailTestLengthFieldInitialBytes) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(4, 10, 0, 0, 10))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        ASSERT_EQ(nullptr, buf);\n        called++;\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(16);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint32_t)4); // frame size\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, FailTestNotEnoughBytes) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(4, 10, 0, 0, 0))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        ASSERT_EQ(nullptr, buf);\n        called++;\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(16);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint32_t)7); // frame size - 1 byte too large (7 > 10 - 4)\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LineBasedFrameDecoder, Simple) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LineBasedFrameDecoder(10))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 3);\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(3);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  buf = createZeroedBuffer(1);\n  RWPrivateCursor c(buf.get());\n  c.write<char>('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(4);\n  RWPrivateCursor c1(buf.get());\n  c1.write(' ');\n  c1.write(' ');\n  c1.write(' ');\n\n  c1.write('\\r');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(1);\n  RWPrivateCursor c2(buf.get());\n  c2.write('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 2);\n}\n\nTEST(LineBasedFrameDecoder, SaveDelimiter) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LineBasedFrameDecoder(10, false))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 4);\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(3);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  buf = createZeroedBuffer(1);\n  RWPrivateCursor c(buf.get());\n  c.write<char>('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(3);\n  RWPrivateCursor c1(buf.get());\n  c1.write(' ');\n  c1.write(' ');\n  c1.write('\\r');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(1);\n  RWPrivateCursor c2(buf.get());\n  c2.write('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 2);\n}\n\nTEST(LineBasedFrameDecoder, Fail) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LineBasedFrameDecoder(10))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        ASSERT_EQ(nullptr, buf);\n        called++;\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(11);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(1);\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(2);\n  RWPrivateCursor c(buf.get());\n  c.write(' ');\n  c.write<char>('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(12);\n  RWPrivateCursor c2(buf.get());\n  for (int i = 0; i < 11; i++) {\n    c2.write(' ');\n  }\n  c2.write<char>('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 2);\n}\n\nTEST(LineBasedFrameDecoder, NewLineOnly) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LineBasedFrameDecoder(\n               10, true, LineBasedFrameDecoder::TerminatorType::NEWLINE))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 1);\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(2);\n  RWPrivateCursor c(buf.get());\n  c.write<char>('\\r');\n  c.write<char>('\\n');\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LineBasedFrameDecoder, CarriageNewLineOnly) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LineBasedFrameDecoder(\n              10, true, LineBasedFrameDecoder::TerminatorType::CARRIAGENEWLINE))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 1);\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(3);\n  RWPrivateCursor c(buf.get());\n  c.write<char>('\\n');\n  c.write<char>('\\r');\n  c.write<char>('\\n');\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n"], "fixing_code": ["/*\n * Copyright 2017-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <wangle/codec/LineBasedFrameDecoder.h>\n\nnamespace wangle {\n\nusing folly::io::Cursor;\nusing folly::IOBuf;\nusing folly::IOBufQueue;\n\nLineBasedFrameDecoder::LineBasedFrameDecoder(uint32_t maxLength,\n                                             bool stripDelimiter,\n                                             TerminatorType terminatorType)\n    : maxLength_(maxLength)\n    , stripDelimiter_(stripDelimiter)\n    , terminatorType_(terminatorType) {}\n\nbool LineBasedFrameDecoder::decode(Context* ctx,\n                                   IOBufQueue& buf,\n                                   std::unique_ptr<IOBuf>& result,\n                                   size_t&) {\n  int64_t eol = findEndOfLine(buf);\n\n  if (!discarding_) {\n    if (eol >= 0) {\n      Cursor c(buf.front());\n      c += eol;\n      auto delimLength = c.read<char>() == '\\r' ? 2 : 1;\n      if (eol > maxLength_) {\n        buf.split(eol + delimLength);\n        fail(ctx, folly::to<std::string>(eol));\n        return false;\n      }\n\n      std::unique_ptr<folly::IOBuf> frame;\n\n      if (stripDelimiter_) {\n        frame = buf.split(eol);\n        buf.trimStart(delimLength);\n      } else {\n        frame = buf.split(eol + delimLength);\n      }\n\n      result = std::move(frame);\n      return true;\n    } else {\n      auto len = buf.chainLength();\n      if (len > maxLength_) {\n        discardedBytes_ = len;\n        buf.trimStart(len);\n        discarding_ = true;\n        fail(ctx, \"over \" + folly::to<std::string>(len));\n      }\n      return false;\n    }\n  } else {\n    if (eol >= 0) {\n      Cursor c(buf.front());\n      c += eol;\n      auto delimLength = c.read<char>() == '\\r' ? 2 : 1;\n      buf.trimStart(eol + delimLength);\n      discardedBytes_ = 0;\n      discarding_ = false;\n    } else {\n      discardedBytes_ = buf.chainLength();\n      buf.move();\n    }\n\n    return false;\n  }\n}\n\nvoid LineBasedFrameDecoder::fail(Context* ctx, std::string len) {\n  ctx->fireReadException(\n    folly::make_exception_wrapper<std::runtime_error>(\n      \"frame length\" + len +\n      \" exeeds max \" + folly::to<std::string>(maxLength_)));\n}\n\nint64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {\n  Cursor c(buf.front());\n  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {\n    auto b = c.read<char>();\n    if (b == '\\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {\n      return i;\n    } else if (\n        terminatorType_ != TerminatorType::NEWLINE && b == '\\r' &&\n        !c.isAtEnd() && *c.peekBytes().data() == '\\n') {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n} // namespace wangle\n", "/*\n * Copyright 2017-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/portability/GTest.h>\n\n#include <wangle/codec/FixedLengthFrameDecoder.h>\n#include <wangle/codec/LengthFieldBasedFrameDecoder.h>\n#include <wangle/codec/LengthFieldPrepender.h>\n#include <wangle/codec/LineBasedFrameDecoder.h>\n#include <wangle/codec/test/CodecTestUtils.h>\n\nusing namespace folly;\nusing namespace wangle;\nusing namespace folly::io;\n\nnamespace {\nauto createZeroedBuffer(size_t size) {\n  auto ret = IOBuf::create(size);\n  ret->append(size);\n  std::memset(ret->writableData(), 0x00, size);\n  return ret;\n}\n}\n\nTEST(FixedLengthFrameDecoder, FailWhenLengthFieldEndOffset) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(FixedLengthFrameDecoder(10))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 10);\n      }))\n    .finalize();\n\n  auto buf3 = createZeroedBuffer(3);\n  auto buf11 = createZeroedBuffer(11);\n  auto buf16 = createZeroedBuffer(16);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf3));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(buf11));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  q.append(std::move(buf16));\n  pipeline->read(q);\n  EXPECT_EQ(called, 3);\n}\n\nTEST(LengthFieldFramePipeline, SimpleTest) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(test::BytesReflector())\n    .addBack(LengthFieldPrepender())\n    .addBack(LengthFieldBasedFrameDecoder())\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 2);\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(2);\n  pipeline->write(std::move(buf));\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFramePipeline, LittleEndian) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(test::BytesReflector())\n    .addBack(LengthFieldBasedFrameDecoder(4, 100, 0, 0, 4, false))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 1);\n      }))\n    .addBack(LengthFieldPrepender(4, 0, false, false))\n    .finalize();\n\n  auto buf = createZeroedBuffer(1);\n  pipeline->write(std::move(buf));\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, Simple) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder())\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 1);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(4);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint32_t)1);\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, NoStrip) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 0, 0, 0))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 3);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(2);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint16_t)1);\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, Adjustment) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 0, -2, 0))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 3);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(2);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint16_t)3); // includes frame size\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, PreHeader) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 2, 0, 0))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 5);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(4);\n  RWPrivateCursor c(bufFrame.get());\n  c.write((uint16_t)100); // header\n  c.writeBE((uint16_t)1); // frame size\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, PostHeader) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 0, 2, 0))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 5);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(4);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint16_t)1); // frame size\n  c.write((uint16_t)100); // header\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoderStrip, PrePostHeader) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 2, 2, 4))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 3);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(6);\n  RWPrivateCursor c(bufFrame.get());\n  c.write((uint16_t)100); // pre header\n  c.writeBE((uint16_t)1); // frame size\n  c.write((uint16_t)100); // post header\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, StripPrePostHeaderFrameInclHeader) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(2, 10, 2, -2, 4))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 3);\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(6);\n  RWPrivateCursor c(bufFrame.get());\n  c.write((uint16_t)100); // pre header\n  c.writeBE((uint16_t)5); // frame size\n  c.write((uint16_t)100); // post header\n  auto bufData = createZeroedBuffer(1);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  q.append(std::move(bufData));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, FailTestLengthFieldEndOffset) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(4, 10, 4, -2, 4))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        ASSERT_EQ(nullptr, buf);\n        called++;\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(8);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint32_t)0); // frame size\n  c.write((uint32_t)0); // crap\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, FailTestLengthFieldFrameSize) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(4, 10, 0, 0, 4))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        ASSERT_EQ(nullptr, buf);\n        called++;\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(16);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint32_t)12); // frame size\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, FailTestLengthFieldInitialBytes) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(4, 10, 0, 0, 10))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        ASSERT_EQ(nullptr, buf);\n        called++;\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(16);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint32_t)4); // frame size\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LengthFieldFrameDecoder, FailTestNotEnoughBytes) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LengthFieldBasedFrameDecoder(4, 10, 0, 0, 0))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        ASSERT_EQ(nullptr, buf);\n        called++;\n      }))\n    .finalize();\n\n  auto bufFrame = createZeroedBuffer(16);\n  RWPrivateCursor c(bufFrame.get());\n  c.writeBE((uint32_t)7); // frame size - 1 byte too large (7 > 10 - 4)\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n  c.write((uint32_t)0); // nothing\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(bufFrame));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LineBasedFrameDecoder, Simple) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LineBasedFrameDecoder(10))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 3);\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(3);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  buf = createZeroedBuffer(1);\n  RWPrivateCursor c(buf.get());\n  c.write<char>('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(4);\n  RWPrivateCursor c1(buf.get());\n  c1.write(' ');\n  c1.write(' ');\n  c1.write(' ');\n\n  c1.write('\\r');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(1);\n  RWPrivateCursor c2(buf.get());\n  c2.write('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 2);\n}\n\nTEST(LineBasedFrameDecoder, SaveDelimiter) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LineBasedFrameDecoder(10, false))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 4);\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(3);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  buf = createZeroedBuffer(1);\n  RWPrivateCursor c(buf.get());\n  c.write<char>('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(3);\n  RWPrivateCursor c1(buf.get());\n  c1.write(' ');\n  c1.write(' ');\n  c1.write('\\r');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(1);\n  RWPrivateCursor c2(buf.get());\n  c2.write('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 2);\n}\n\nTEST(LineBasedFrameDecoder, Fail) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LineBasedFrameDecoder(10))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        ASSERT_EQ(nullptr, buf);\n        called++;\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(11);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(1);\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(2);\n  RWPrivateCursor c(buf.get());\n  c.write(' ');\n  c.write<char>('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(12);\n  RWPrivateCursor c2(buf.get());\n  for (int i = 0; i < 11; i++) {\n    c2.write(' ');\n  }\n  c2.write<char>('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 2);\n}\n\nTEST(LineBasedFrameDecoder, NewLineOnly) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LineBasedFrameDecoder(\n               10, true, LineBasedFrameDecoder::TerminatorType::NEWLINE))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 1);\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(2);\n  RWPrivateCursor c(buf.get());\n  c.write<char>('\\r');\n  c.write<char>('\\n');\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LineBasedFrameDecoder, CarriageNewLineOnly) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LineBasedFrameDecoder(\n              10, true, LineBasedFrameDecoder::TerminatorType::CARRIAGENEWLINE))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 1);\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(3);\n  RWPrivateCursor c(buf.get());\n  c.write<char>('\\n');\n  c.write<char>('\\r');\n  c.write<char>('\\n');\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n}\n\nTEST(LineBasedFrameDecoder, CarriageOnly) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n\n  (*pipeline)\n      .addBack(LineBasedFrameDecoder(\n          10, true, LineBasedFrameDecoder::TerminatorType::CARRIAGENEWLINE))\n      .addBack(test::FrameTester([&](std::unique_ptr<IOBuf>) { FAIL(); }))\n      .finalize();\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n  q.append(IOBuf::copyBuffer(\"\\raa\"));\n  pipeline->read(q);\n}\n\nTEST(LineBasedFrameDecoder, DoubleCarriage) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n      .addBack(LineBasedFrameDecoder(\n          10, true, LineBasedFrameDecoder::TerminatorType::CARRIAGENEWLINE))\n      .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 1);\n      }))\n      .finalize();\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n  q.append(IOBuf::copyBuffer(\"\\r\\r\\na\\r\\n\"));\n  pipeline->read(q);\n  EXPECT_EQ(called, 2);\n}\n"], "filenames": ["wangle/codec/LineBasedFrameDecoder.cpp", "wangle/codec/test/CodecTest.cpp"], "buggy_code_start_loc": [100, 608], "buggy_code_end_loc": [102, 608], "fixing_code_start_loc": [100, 609], "fixing_code_end_loc": [103, 643], "type": "CWE-787", "message": "Wangle's LineBasedFrameDecoder contains logic for identifying newlines which incorrectly advances a buffer, leading to a potential underflow. This affects versions of Wangle prior to v2019.04.22.00", "other": {"cve": {"id": "CVE-2019-3563", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-04-29T16:29:01.047", "lastModified": "2020-10-16T18:08:40.307", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wangle's LineBasedFrameDecoder contains logic for identifying newlines which incorrectly advances a buffer, leading to a potential underflow. This affects versions of Wangle prior to v2019.04.22.00"}, {"lang": "es", "value": "El decodificador LineBasedFrameDecoder de Wangle contiene l\u00f3gica para identificar nuevas l\u00edneas que avanzan incorrectamente un b\u00fafer, lo que conduce a un posible desbordamiento. Esto afecta a las versiones de Wangle anteriores a la v2019.04.22.00"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-126"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:wangle:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019.04.22.00", "matchCriteriaId": "8FF82193-AF3E-42FB-90E8-671CE3F08D7E"}]}]}], "references": [{"url": "https://github.com/facebook/wangle/commit/5b3bceca875e4ea4ed9d14c20b20ce46c92c13c6", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/wangle/commit/5b3bceca875e4ea4ed9d14c20b20ce46c92c13c6"}}