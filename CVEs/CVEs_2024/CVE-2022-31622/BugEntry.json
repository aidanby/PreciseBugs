{"buggy_code": ["/******************************************************\nCopyright (c) 2011-2013 Percona LLC and/or its affiliates.\n\nCompressing datasink implementation for XtraBackup.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; version 2 of the License.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA\n\n*******************************************************/\n\n#include <mysql_version.h>\n#include <my_base.h>\n#include <quicklz.h>\n#include <zlib.h>\n#include \"common.h\"\n#include \"datasink.h\"\n\n#define COMPRESS_CHUNK_SIZE ((size_t) (xtrabackup_compress_chunk_size))\n#define MY_QLZ_COMPRESS_OVERHEAD 400\n\ntypedef struct {\n\tpthread_t\t\tid;\n\tuint\t\t\tnum;\n\tpthread_mutex_t \tctrl_mutex;\n\tpthread_cond_t\t\tctrl_cond;\n\tpthread_mutex_t\t\tdata_mutex;\n\tpthread_cond_t  \tdata_cond;\n\tmy_bool\t\t\tstarted;\n\tmy_bool\t\t\tdata_avail;\n\tmy_bool\t\t\tcancelled;\n\tconst char \t\t*from;\n\tsize_t\t\t\tfrom_len;\n\tchar\t\t\t*to;\n\tsize_t\t\t\tto_len;\n\tqlz_state_compress\tstate;\n\tulong\t\t\tadler;\n} comp_thread_ctxt_t;\n\ntypedef struct {\n\tcomp_thread_ctxt_t\t*threads;\n\tuint\t\t\tnthreads;\n} ds_compress_ctxt_t;\n\ntypedef struct {\n\tds_file_t\t\t*dest_file;\n\tds_compress_ctxt_t\t*comp_ctxt;\n\tsize_t\t\t\tbytes_processed;\n} ds_compress_file_t;\n\n/* Compression options */\nextern char\t\t*xtrabackup_compress_alg;\nextern uint\t\txtrabackup_compress_threads;\nextern ulonglong\txtrabackup_compress_chunk_size;\n\nstatic ds_ctxt_t *compress_init(const char *root);\nstatic ds_file_t *compress_open(ds_ctxt_t *ctxt, const char *path,\n\t\t\t\tMY_STAT *mystat);\nstatic int compress_write(ds_file_t *file, const uchar *buf, size_t len);\nstatic int compress_close(ds_file_t *file);\nstatic void compress_deinit(ds_ctxt_t *ctxt);\n\ndatasink_t datasink_compress = {\n\t&compress_init,\n\t&compress_open,\n\t&compress_write,\n\t&compress_close,\n\t&dummy_remove,\n\t&compress_deinit\n};\n\nstatic inline int write_uint32_le(ds_file_t *file, ulong n);\nstatic inline int write_uint64_le(ds_file_t *file, ulonglong n);\n\nstatic comp_thread_ctxt_t *create_worker_threads(uint n);\nstatic void destroy_worker_threads(comp_thread_ctxt_t *threads, uint n);\nstatic void *compress_worker_thread_func(void *arg);\n\nstatic\nds_ctxt_t *\ncompress_init(const char *root)\n{\n\tds_ctxt_t\t\t*ctxt;\n\tds_compress_ctxt_t\t*compress_ctxt;\n\tcomp_thread_ctxt_t\t*threads;\n\n\t/* Create and initialize the worker threads */\n\tthreads = create_worker_threads(xtrabackup_compress_threads);\n\tif (threads == NULL) {\n\t\tmsg(\"compress: failed to create worker threads.\");\n\t\treturn NULL;\n\t}\n\n\tctxt = (ds_ctxt_t *) my_malloc(sizeof(ds_ctxt_t) +\n\t\t\t\t       sizeof(ds_compress_ctxt_t),\n\t\t\t\t       MYF(MY_FAE));\n\n\tcompress_ctxt = (ds_compress_ctxt_t *) (ctxt + 1);\n\tcompress_ctxt->threads = threads;\n\tcompress_ctxt->nthreads = xtrabackup_compress_threads;\n\n\tctxt->ptr = compress_ctxt;\n\tctxt->root = my_strdup(root, MYF(MY_FAE));\n\n\treturn ctxt;\n}\n\nstatic\nds_file_t *\ncompress_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *mystat)\n{\n\tds_compress_ctxt_t\t*comp_ctxt;\n\tds_ctxt_t\t\t*dest_ctxt;\n \tds_file_t\t\t*dest_file;\n\tchar\t\t\tnew_name[FN_REFLEN];\n\tsize_t\t\t\tname_len;\n\tds_file_t\t\t*file;\n\tds_compress_file_t\t*comp_file;\n\n\txb_ad(ctxt->pipe_ctxt != NULL);\n\tdest_ctxt = ctxt->pipe_ctxt;\n\n\tcomp_ctxt = (ds_compress_ctxt_t *) ctxt->ptr;\n\n\t/* Append the .qp extension to the filename */\n\tfn_format(new_name, path, \"\", \".qp\", MYF(MY_APPEND_EXT));\n\n\tdest_file = ds_open(dest_ctxt, new_name, mystat);\n\tif (dest_file == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* Write the qpress archive header */\n\tif (ds_write(dest_file, \"qpress10\", 8) ||\n\t    write_uint64_le(dest_file, COMPRESS_CHUNK_SIZE)) {\n\t\tgoto err;\n\t}\n\n\t/* We are going to create a one-file \"flat\" (i.e. with no\n\tsubdirectories) archive. So strip the directory part from the path and\n\tremove the '.qp' suffix. */\n\tfn_format(new_name, path, \"\", \"\", MYF(MY_REPLACE_DIR));\n\n\t/* Write the qpress file header */\n\tname_len = strlen(new_name);\n\tif (ds_write(dest_file, \"F\", 1) ||\n\t    write_uint32_le(dest_file, (uint)name_len) ||\n\t    /* we want to write the terminating \\0 as well */\n\t    ds_write(dest_file, new_name, name_len + 1)) {\n\t\tgoto err;\n\t}\n\n\tfile = (ds_file_t *) my_malloc(sizeof(ds_file_t) +\n\t\t\t\t       sizeof(ds_compress_file_t),\n\t\t\t\t       MYF(MY_FAE));\n\tcomp_file = (ds_compress_file_t *) (file + 1);\n\tcomp_file->dest_file = dest_file;\n\tcomp_file->comp_ctxt = comp_ctxt;\n\tcomp_file->bytes_processed = 0;\n\n\tfile->ptr = comp_file;\n\tfile->path = dest_file->path;\n\n\treturn file;\n\nerr:\n\tds_close(dest_file);\n\treturn NULL;\n}\n\nstatic\nint\ncompress_write(ds_file_t *file, const uchar *buf, size_t len)\n{\n\tds_compress_file_t\t*comp_file;\n\tds_compress_ctxt_t\t*comp_ctxt;\n\tcomp_thread_ctxt_t\t*threads;\n\tcomp_thread_ctxt_t\t*thd;\n\tuint\t\t\tnthreads;\n\tuint\t\t\ti;\n\tconst char\t\t*ptr;\n\tds_file_t\t\t*dest_file;\n\n\tcomp_file = (ds_compress_file_t *) file->ptr;\n\tcomp_ctxt = comp_file->comp_ctxt;\n\tdest_file = comp_file->dest_file;\n\n\tthreads = comp_ctxt->threads;\n\tnthreads = comp_ctxt->nthreads;\n\n\tptr = (const char *) buf;\n\twhile (len > 0) {\n\t\tuint max_thread;\n\n\t\t/* Send data to worker threads for compression */\n\t\tfor (i = 0; i < nthreads; i++) {\n\t\t\tsize_t chunk_len;\n\n\t\t\tthd = threads + i;\n\n\t\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\n\t\t\tchunk_len = (len > COMPRESS_CHUNK_SIZE) ?\n\t\t\t\tCOMPRESS_CHUNK_SIZE : len;\n\t\t\tthd->from = ptr;\n\t\t\tthd->from_len = chunk_len;\n\n\t\t\tpthread_mutex_lock(&thd->data_mutex);\n\t\t\tthd->data_avail = TRUE;\n\t\t\tpthread_cond_signal(&thd->data_cond);\n\t\t\tpthread_mutex_unlock(&thd->data_mutex);\n\n\t\t\tlen -= chunk_len;\n\t\t\tif (len == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr += chunk_len;\n\t\t}\n\n\t\tmax_thread = (i < nthreads) ? i :  nthreads - 1;\n\n\t\t/* Reap and stream the compressed data */\n\t\tfor (i = 0; i <= max_thread; i++) {\n\t\t\tthd = threads + i;\n\n\t\t\tpthread_mutex_lock(&thd->data_mutex);\n\t\t\twhile (thd->data_avail == TRUE) {\n\t\t\t\tpthread_cond_wait(&thd->data_cond,\n\t\t\t\t\t\t  &thd->data_mutex);\n\t\t\t}\n\n\t\t\txb_a(threads[i].to_len > 0);\n\n\t\t\tif (ds_write(dest_file, \"NEWBNEWB\", 8) ||\n\t\t\t    write_uint64_le(dest_file,\n\t\t\t\t\t    comp_file->bytes_processed)) {\n\t\t\t\tmsg(\"compress: write to the destination stream \"\n\t\t\t\t    \"failed.\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tcomp_file->bytes_processed += threads[i].from_len;\n\n\t\t\tif (write_uint32_le(dest_file, threads[i].adler) ||\n\t\t\t    ds_write(dest_file, threads[i].to,\n\t\t\t\t\t   threads[i].to_len)) {\n\t\t\t\tmsg(\"compress: write to the destination stream \"\n\t\t\t\t    \"failed.\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tpthread_mutex_unlock(&threads[i].data_mutex);\n\t\t\tpthread_mutex_unlock(&threads[i].ctrl_mutex);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic\nint\ncompress_close(ds_file_t *file)\n{\n\tds_compress_file_t\t*comp_file;\n\tds_file_t\t\t*dest_file;\n\tint\t\t\trc;\n\n\tcomp_file = (ds_compress_file_t *) file->ptr;\n\tdest_file = comp_file->dest_file;\n\n\t/* Write the qpress file trailer */\n\tds_write(dest_file, \"ENDSENDS\", 8);\n\n\t/* Supposedly the number of written bytes should be written as a\n\t\"recovery information\" in the file trailer, but in reality qpress\n\talways writes 8 zeros here. Let's do the same */\n\n\twrite_uint64_le(dest_file, 0);\n\n\trc = ds_close(dest_file);\n\n\tmy_free(file);\n\n\treturn rc;\n}\n\nstatic\nvoid\ncompress_deinit(ds_ctxt_t *ctxt)\n{\n\tds_compress_ctxt_t \t*comp_ctxt;\n\n\txb_ad(ctxt->pipe_ctxt != NULL);\n\n\tcomp_ctxt = (ds_compress_ctxt_t *) ctxt->ptr;;\n\n\tdestroy_worker_threads(comp_ctxt->threads, comp_ctxt->nthreads);\n\n\tmy_free(ctxt->root);\n\tmy_free(ctxt);\n}\n\nstatic inline\nint\nwrite_uint32_le(ds_file_t *file, ulong n)\n{\n\tchar tmp[4];\n\n\tint4store(tmp, n);\n\treturn ds_write(file, tmp, sizeof(tmp));\n}\n\nstatic inline\nint\nwrite_uint64_le(ds_file_t *file, ulonglong n)\n{\n\tchar tmp[8];\n\n\tint8store(tmp, n);\n\treturn ds_write(file, tmp, sizeof(tmp));\n}\n\nstatic\ncomp_thread_ctxt_t *\ncreate_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\n\t\t/* Initialize the control mutex and condition var */\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Initialize and data mutex and condition var */\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* Wait for the threads to start */\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\n\treturn threads;\n\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}\n\nstatic\nvoid\ndestroy_worker_threads(comp_thread_ctxt_t *threads, uint n)\n{\n\tuint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\tpthread_mutex_lock(&thd->data_mutex);\n\t\tthreads[i].cancelled = TRUE;\n\t\tpthread_cond_signal(&thd->data_cond);\n\t\tpthread_mutex_unlock(&thd->data_mutex);\n\n\t\tpthread_join(thd->id, NULL);\n\n\t\tpthread_cond_destroy(&thd->data_cond);\n\t\tpthread_mutex_destroy(&thd->data_mutex);\n\t\tpthread_cond_destroy(&thd->ctrl_cond);\n\t\tpthread_mutex_destroy(&thd->ctrl_mutex);\n\n\t\tmy_free(thd->to);\n\t}\n\n\tmy_free(threads);\n}\n\nstatic\nvoid *\ncompress_worker_thread_func(void *arg)\n{\n\tcomp_thread_ctxt_t *thd = (comp_thread_ctxt_t *) arg;\n\n\tpthread_mutex_lock(&thd->ctrl_mutex);\n\n\tpthread_mutex_lock(&thd->data_mutex);\n\n\tthd->started = TRUE;\n\tpthread_cond_signal(&thd->ctrl_cond);\n\n\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\n\twhile (1) {\n\t\tthd->data_avail = FALSE;\n\t\tpthread_cond_signal(&thd->data_cond);\n\n\t\twhile (!thd->data_avail && !thd->cancelled) {\n\t\t\tpthread_cond_wait(&thd->data_cond, &thd->data_mutex);\n\t\t}\n\n\t\tif (thd->cancelled)\n\t\t\tbreak;\n\n\t\tthd->to_len = qlz_compress(thd->from, thd->to, thd->from_len,\n\t\t\t\t\t   &thd->state);\n\n\t\t/* qpress uses 0x00010000 as the initial value, but its own\n\t\tAdler-32 implementation treats the value differently:\n\t\t  1. higher order bits are the sum of all bytes in the sequence\n\t\t  2. lower order bits are the sum of resulting values at every\n\t\t     step.\n\t\tSo it's the other way around as compared to zlib's adler32().\n\t\tThat's why  0x00000001 is being passed here to be compatible\n\t\twith qpress implementation. */\n\n\t\tthd->adler = adler32(0x00000001, (uchar *) thd->to,\n\t\t\t\t     (uInt)thd->to_len);\n\t}\n\n\tpthread_mutex_unlock(&thd->data_mutex);\n\n\treturn NULL;\n}\n"], "fixing_code": ["/******************************************************\nCopyright (c) 2011-2013 Percona LLC and/or its affiliates.\n\nCompressing datasink implementation for XtraBackup.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; version 2 of the License.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA\n\n*******************************************************/\n\n#include <mysql_version.h>\n#include <my_base.h>\n#include <quicklz.h>\n#include <zlib.h>\n#include \"common.h\"\n#include \"datasink.h\"\n\n#define COMPRESS_CHUNK_SIZE ((size_t) (xtrabackup_compress_chunk_size))\n#define MY_QLZ_COMPRESS_OVERHEAD 400\n\ntypedef struct {\n\tpthread_t\t\tid;\n\tuint\t\t\tnum;\n\tpthread_mutex_t \tctrl_mutex;\n\tpthread_cond_t\t\tctrl_cond;\n\tpthread_mutex_t\t\tdata_mutex;\n\tpthread_cond_t  \tdata_cond;\n\tmy_bool\t\t\tstarted;\n\tmy_bool\t\t\tdata_avail;\n\tmy_bool\t\t\tcancelled;\n\tconst char \t\t*from;\n\tsize_t\t\t\tfrom_len;\n\tchar\t\t\t*to;\n\tsize_t\t\t\tto_len;\n\tqlz_state_compress\tstate;\n\tulong\t\t\tadler;\n} comp_thread_ctxt_t;\n\ntypedef struct {\n\tcomp_thread_ctxt_t\t*threads;\n\tuint\t\t\tnthreads;\n} ds_compress_ctxt_t;\n\ntypedef struct {\n\tds_file_t\t\t*dest_file;\n\tds_compress_ctxt_t\t*comp_ctxt;\n\tsize_t\t\t\tbytes_processed;\n} ds_compress_file_t;\n\n/* Compression options */\nextern char\t\t*xtrabackup_compress_alg;\nextern uint\t\txtrabackup_compress_threads;\nextern ulonglong\txtrabackup_compress_chunk_size;\n\nstatic ds_ctxt_t *compress_init(const char *root);\nstatic ds_file_t *compress_open(ds_ctxt_t *ctxt, const char *path,\n\t\t\t\tMY_STAT *mystat);\nstatic int compress_write(ds_file_t *file, const uchar *buf, size_t len);\nstatic int compress_close(ds_file_t *file);\nstatic void compress_deinit(ds_ctxt_t *ctxt);\n\ndatasink_t datasink_compress = {\n\t&compress_init,\n\t&compress_open,\n\t&compress_write,\n\t&compress_close,\n\t&dummy_remove,\n\t&compress_deinit\n};\n\nstatic inline int write_uint32_le(ds_file_t *file, ulong n);\nstatic inline int write_uint64_le(ds_file_t *file, ulonglong n);\n\nstatic comp_thread_ctxt_t *create_worker_threads(uint n);\nstatic void destroy_worker_threads(comp_thread_ctxt_t *threads, uint n);\nstatic void *compress_worker_thread_func(void *arg);\n\nstatic\nds_ctxt_t *\ncompress_init(const char *root)\n{\n\tds_ctxt_t\t\t*ctxt;\n\tds_compress_ctxt_t\t*compress_ctxt;\n\tcomp_thread_ctxt_t\t*threads;\n\n\t/* Create and initialize the worker threads */\n\tthreads = create_worker_threads(xtrabackup_compress_threads);\n\tif (threads == NULL) {\n\t\tmsg(\"compress: failed to create worker threads.\");\n\t\treturn NULL;\n\t}\n\n\tctxt = (ds_ctxt_t *) my_malloc(sizeof(ds_ctxt_t) +\n\t\t\t\t       sizeof(ds_compress_ctxt_t),\n\t\t\t\t       MYF(MY_FAE));\n\n\tcompress_ctxt = (ds_compress_ctxt_t *) (ctxt + 1);\n\tcompress_ctxt->threads = threads;\n\tcompress_ctxt->nthreads = xtrabackup_compress_threads;\n\n\tctxt->ptr = compress_ctxt;\n\tctxt->root = my_strdup(root, MYF(MY_FAE));\n\n\treturn ctxt;\n}\n\nstatic\nds_file_t *\ncompress_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *mystat)\n{\n\tds_compress_ctxt_t\t*comp_ctxt;\n\tds_ctxt_t\t\t*dest_ctxt;\n \tds_file_t\t\t*dest_file;\n\tchar\t\t\tnew_name[FN_REFLEN];\n\tsize_t\t\t\tname_len;\n\tds_file_t\t\t*file;\n\tds_compress_file_t\t*comp_file;\n\n\txb_ad(ctxt->pipe_ctxt != NULL);\n\tdest_ctxt = ctxt->pipe_ctxt;\n\n\tcomp_ctxt = (ds_compress_ctxt_t *) ctxt->ptr;\n\n\t/* Append the .qp extension to the filename */\n\tfn_format(new_name, path, \"\", \".qp\", MYF(MY_APPEND_EXT));\n\n\tdest_file = ds_open(dest_ctxt, new_name, mystat);\n\tif (dest_file == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* Write the qpress archive header */\n\tif (ds_write(dest_file, \"qpress10\", 8) ||\n\t    write_uint64_le(dest_file, COMPRESS_CHUNK_SIZE)) {\n\t\tgoto err;\n\t}\n\n\t/* We are going to create a one-file \"flat\" (i.e. with no\n\tsubdirectories) archive. So strip the directory part from the path and\n\tremove the '.qp' suffix. */\n\tfn_format(new_name, path, \"\", \"\", MYF(MY_REPLACE_DIR));\n\n\t/* Write the qpress file header */\n\tname_len = strlen(new_name);\n\tif (ds_write(dest_file, \"F\", 1) ||\n\t    write_uint32_le(dest_file, (uint)name_len) ||\n\t    /* we want to write the terminating \\0 as well */\n\t    ds_write(dest_file, new_name, name_len + 1)) {\n\t\tgoto err;\n\t}\n\n\tfile = (ds_file_t *) my_malloc(sizeof(ds_file_t) +\n\t\t\t\t       sizeof(ds_compress_file_t),\n\t\t\t\t       MYF(MY_FAE));\n\tcomp_file = (ds_compress_file_t *) (file + 1);\n\tcomp_file->dest_file = dest_file;\n\tcomp_file->comp_ctxt = comp_ctxt;\n\tcomp_file->bytes_processed = 0;\n\n\tfile->ptr = comp_file;\n\tfile->path = dest_file->path;\n\n\treturn file;\n\nerr:\n\tds_close(dest_file);\n\treturn NULL;\n}\n\nstatic\nint\ncompress_write(ds_file_t *file, const uchar *buf, size_t len)\n{\n\tds_compress_file_t\t*comp_file;\n\tds_compress_ctxt_t\t*comp_ctxt;\n\tcomp_thread_ctxt_t\t*threads;\n\tcomp_thread_ctxt_t\t*thd;\n\tuint\t\t\tnthreads;\n\tuint\t\t\ti;\n\tconst char\t\t*ptr;\n\tds_file_t\t\t*dest_file;\n\n\tcomp_file = (ds_compress_file_t *) file->ptr;\n\tcomp_ctxt = comp_file->comp_ctxt;\n\tdest_file = comp_file->dest_file;\n\n\tthreads = comp_ctxt->threads;\n\tnthreads = comp_ctxt->nthreads;\n\n\tptr = (const char *) buf;\n\twhile (len > 0) {\n\t\tuint max_thread;\n\n\t\t/* Send data to worker threads for compression */\n\t\tfor (i = 0; i < nthreads; i++) {\n\t\t\tsize_t chunk_len;\n\n\t\t\tthd = threads + i;\n\n\t\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\n\t\t\tchunk_len = (len > COMPRESS_CHUNK_SIZE) ?\n\t\t\t\tCOMPRESS_CHUNK_SIZE : len;\n\t\t\tthd->from = ptr;\n\t\t\tthd->from_len = chunk_len;\n\n\t\t\tpthread_mutex_lock(&thd->data_mutex);\n\t\t\tthd->data_avail = TRUE;\n\t\t\tpthread_cond_signal(&thd->data_cond);\n\t\t\tpthread_mutex_unlock(&thd->data_mutex);\n\n\t\t\tlen -= chunk_len;\n\t\t\tif (len == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr += chunk_len;\n\t\t}\n\n\t\tmax_thread = (i < nthreads) ? i :  nthreads - 1;\n\n\t\t/* Reap and stream the compressed data */\n\t\tfor (i = 0; i <= max_thread; i++) {\n\t\t\tthd = threads + i;\n\n\t\t\tpthread_mutex_lock(&thd->data_mutex);\n\t\t\twhile (thd->data_avail == TRUE) {\n\t\t\t\tpthread_cond_wait(&thd->data_cond,\n\t\t\t\t\t\t  &thd->data_mutex);\n\t\t\t}\n\n\t\t\txb_a(threads[i].to_len > 0);\n\n\t\t\tif (ds_write(dest_file, \"NEWBNEWB\", 8) ||\n\t\t\t    write_uint64_le(dest_file,\n\t\t\t\t\t    comp_file->bytes_processed)) {\n\t\t\t\tmsg(\"compress: write to the destination stream \"\n\t\t\t\t    \"failed.\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tcomp_file->bytes_processed += threads[i].from_len;\n\n\t\t\tif (write_uint32_le(dest_file, threads[i].adler) ||\n\t\t\t    ds_write(dest_file, threads[i].to,\n\t\t\t\t\t   threads[i].to_len)) {\n\t\t\t\tmsg(\"compress: write to the destination stream \"\n\t\t\t\t    \"failed.\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tpthread_mutex_unlock(&threads[i].data_mutex);\n\t\t\tpthread_mutex_unlock(&threads[i].ctrl_mutex);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic\nint\ncompress_close(ds_file_t *file)\n{\n\tds_compress_file_t\t*comp_file;\n\tds_file_t\t\t*dest_file;\n\tint\t\t\trc;\n\n\tcomp_file = (ds_compress_file_t *) file->ptr;\n\tdest_file = comp_file->dest_file;\n\n\t/* Write the qpress file trailer */\n\tds_write(dest_file, \"ENDSENDS\", 8);\n\n\t/* Supposedly the number of written bytes should be written as a\n\t\"recovery information\" in the file trailer, but in reality qpress\n\talways writes 8 zeros here. Let's do the same */\n\n\twrite_uint64_le(dest_file, 0);\n\n\trc = ds_close(dest_file);\n\n\tmy_free(file);\n\n\treturn rc;\n}\n\nstatic\nvoid\ncompress_deinit(ds_ctxt_t *ctxt)\n{\n\tds_compress_ctxt_t \t*comp_ctxt;\n\n\txb_ad(ctxt->pipe_ctxt != NULL);\n\n\tcomp_ctxt = (ds_compress_ctxt_t *) ctxt->ptr;;\n\n\tdestroy_worker_threads(comp_ctxt->threads, comp_ctxt->nthreads);\n\n\tmy_free(ctxt->root);\n\tmy_free(ctxt);\n}\n\nstatic inline\nint\nwrite_uint32_le(ds_file_t *file, ulong n)\n{\n\tchar tmp[4];\n\n\tint4store(tmp, n);\n\treturn ds_write(file, tmp, sizeof(tmp));\n}\n\nstatic inline\nint\nwrite_uint64_le(ds_file_t *file, ulonglong n)\n{\n\tchar tmp[8];\n\n\tint8store(tmp, n);\n\treturn ds_write(file, tmp, sizeof(tmp));\n}\n\nstatic\ncomp_thread_ctxt_t *\ncreate_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\n\t\t/* Initialize the control mutex and condition var */\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Initialize and data mutex and condition var */\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* Wait for the threads to start */\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\n\treturn threads;\n\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}\n\nstatic\nvoid\ndestroy_worker_threads(comp_thread_ctxt_t *threads, uint n)\n{\n\tuint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\tpthread_mutex_lock(&thd->data_mutex);\n\t\tthreads[i].cancelled = TRUE;\n\t\tpthread_cond_signal(&thd->data_cond);\n\t\tpthread_mutex_unlock(&thd->data_mutex);\n\n\t\tpthread_join(thd->id, NULL);\n\n\t\tpthread_cond_destroy(&thd->data_cond);\n\t\tpthread_mutex_destroy(&thd->data_mutex);\n\t\tpthread_cond_destroy(&thd->ctrl_cond);\n\t\tpthread_mutex_destroy(&thd->ctrl_mutex);\n\n\t\tmy_free(thd->to);\n\t}\n\n\tmy_free(threads);\n}\n\nstatic\nvoid *\ncompress_worker_thread_func(void *arg)\n{\n\tcomp_thread_ctxt_t *thd = (comp_thread_ctxt_t *) arg;\n\n\tpthread_mutex_lock(&thd->ctrl_mutex);\n\n\tpthread_mutex_lock(&thd->data_mutex);\n\n\tthd->started = TRUE;\n\tpthread_cond_signal(&thd->ctrl_cond);\n\n\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\n\twhile (1) {\n\t\tthd->data_avail = FALSE;\n\t\tpthread_cond_signal(&thd->data_cond);\n\n\t\twhile (!thd->data_avail && !thd->cancelled) {\n\t\t\tpthread_cond_wait(&thd->data_cond, &thd->data_mutex);\n\t\t}\n\n\t\tif (thd->cancelled)\n\t\t\tbreak;\n\n\t\tthd->to_len = qlz_compress(thd->from, thd->to, thd->from_len,\n\t\t\t\t\t   &thd->state);\n\n\t\t/* qpress uses 0x00010000 as the initial value, but its own\n\t\tAdler-32 implementation treats the value differently:\n\t\t  1. higher order bits are the sum of all bytes in the sequence\n\t\t  2. lower order bits are the sum of resulting values at every\n\t\t     step.\n\t\tSo it's the other way around as compared to zlib's adler32().\n\t\tThat's why  0x00000001 is being passed here to be compatible\n\t\twith qpress implementation. */\n\n\t\tthd->adler = adler32(0x00000001, (uchar *) thd->to,\n\t\t\t\t     (uInt)thd->to_len);\n\t}\n\n\tpthread_mutex_unlock(&thd->data_mutex);\n\n\treturn NULL;\n}\n"], "filenames": ["extra/mariabackup/ds_compress.cc"], "buggy_code_start_loc": [371], "buggy_code_end_loc": [371], "fixing_code_start_loc": [372], "fixing_code_end_loc": [373], "type": "CWE-404", "message": "MariaDB Server before 10.7 is vulnerable to Denial of Service. In extra/mariabackup/ds_compress.cc, when an error occurs (pthread_create returns a nonzero value) while executing the method create_worker_threads, the held lock is not released correctly, which allows local users to trigger a denial of service due to the deadlock.", "other": {"cve": {"id": "CVE-2022-31622", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-25T21:15:08.617", "lastModified": "2022-11-05T02:01:19.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MariaDB Server before 10.7 is vulnerable to Denial of Service. In extra/mariabackup/ds_compress.cc, when an error occurs (pthread_create returns a nonzero value) while executing the method create_worker_threads, the held lock is not released correctly, which allows local users to trigger a denial of service due to the deadlock."}, {"lang": "es", "value": "MariaDB Server versiones anteriores a 10.7, es vulnerable a una denegaci\u00f3n de servicio. En el archivo extra/mariabackup/ds_compress.cc, cuando es producido un error (pthread_create devuelve un valor distinto de cero) mientras es ejecutado el m\u00e9todo create_worker_threads, el bloqueo retenido no es liberado correctamente, lo que permite a usuarios locales desencadenar una denegaci\u00f3n de servicio debido al bloqueo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.2.42", "matchCriteriaId": "CE9ABE9C-698E-4289-9C3B-F4FBA550582D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.3.0", "versionEndExcluding": "10.3.33", "matchCriteriaId": "F8EB13E9-AFD7-4E82-A471-61201460CAC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.4.0", "versionEndExcluding": "10.4.23", "matchCriteriaId": "3EFE42EF-DB07-4DD4-A40C-6DD6A7D1E6DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.5.0", "versionEndExcluding": "10.5.14", "matchCriteriaId": "E3C63CE6-6B86-4C48-8D30-DC74CA83C5EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.6.0", "versionEndExcluding": "10.6.6", "matchCriteriaId": "09ADA35C-125F-4970-ACB7-36A9CC3516BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.7.0", "versionEndExcluding": "10.7.2", "matchCriteriaId": "E0435104-B0F9-4997-A769-36821689DF45"}]}]}], "references": [{"url": "https://github.com/MariaDB/server/commit/e1eb39a446c30b8459c39fd7f2ee1c55a36e97d2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://jira.mariadb.org/browse/MDEV-26561?filter=-2", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Permissions Required", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220707-0006/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/MariaDB/server/commit/e1eb39a446c30b8459c39fd7f2ee1c55a36e97d2"}}