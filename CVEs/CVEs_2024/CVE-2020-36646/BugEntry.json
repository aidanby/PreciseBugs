{"buggy_code": ["/*  Copyright (c) MediaArea.net SARL. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a zlib-style license that can\r\n *  be found in the License.txt file in the root of the source tree.\r\n */\r\n\r\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n//\r\n// More methods for std::(w)string\r\n//\r\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\r\n//---------------------------------------------------------------------------\r\n#include \"ZenLib/PreComp.h\"\r\n#ifdef __BORLANDC__\r\n    #pragma hdrstop\r\n#endif\r\n//---------------------------------------------------------------------------\r\n\r\n//---------------------------------------------------------------------------\r\n#include \"ZenLib/Conf_Internal.h\"\r\n//---------------------------------------------------------------------------\r\n\r\n//---------------------------------------------------------------------------\r\n#ifdef ZENLIB_USEWX\r\n    #include <wx/strconv.h>\r\n    #include <wx/datetime.h>\r\n#else //ZENLIB_USEWX\r\n    #ifdef ZENLIB_STANDARD\r\n        #undef WINDOWS\r\n    #endif\r\n    #ifdef WINDOWS\r\n        #undef __TEXT\r\n        #include <windows.h>\r\n        #include <tchar.h>\r\n    #endif\r\n#endif //ZENLIB_USEWX\r\n#ifdef __MINGW32__\r\n    #include <windows.h>\r\n#endif //__MINGW32__\r\n#include <algorithm>\r\n#include <iomanip>\r\n#include <cmath>\r\n#include <ctime>\r\n#include \"ZenLib/OS_Utils.h\"\r\n#include \"ZenLib/File.h\"\r\nusing namespace std;\r\n//---------------------------------------------------------------------------\r\n\r\nnamespace ZenLib\r\n{\r\n\r\nint16u Ztring_ISO_8859_2[96]=\r\n{\r\n    0x00A0,\r\n    0x0104,\r\n    0x02D8,\r\n    0x0141,\r\n    0x00A4,\r\n    0x013D,\r\n    0x015A,\r\n    0x00A7,\r\n    0x00A8,\r\n    0x0160,\r\n    0x015E,\r\n    0x0164,\r\n    0x0179,\r\n    0x00AD,\r\n    0x017D,\r\n    0x017B,\r\n    0x00B0,\r\n    0x0105,\r\n    0x02DB,\r\n    0x0142,\r\n    0x00B4,\r\n    0x013E,\r\n    0x015B,\r\n    0x02C7,\r\n    0x00B8,\r\n    0x0161,\r\n    0x015F,\r\n    0x0165,\r\n    0x017A,\r\n    0x02DD,\r\n    0x017E,\r\n    0x017C,\r\n    0x0154,\r\n    0x00C1,\r\n    0x00C2,\r\n    0x0102,\r\n    0x00C4,\r\n    0x0139,\r\n    0x0106,\r\n    0x00C7,\r\n    0x010C,\r\n    0x00C9,\r\n    0x0118,\r\n    0x00CB,\r\n    0x011A,\r\n    0x00CD,\r\n    0x00CE,\r\n    0x010E,\r\n    0x0110,\r\n    0x0143,\r\n    0x0147,\r\n    0x00D3,\r\n    0x00D4,\r\n    0x0150,\r\n    0x00D6,\r\n    0x00D7,\r\n    0x0158,\r\n    0x016E,\r\n    0x00DA,\r\n    0x0170,\r\n    0x00DC,\r\n    0x00DD,\r\n    0x0162,\r\n    0x00DF,\r\n    0x0155,\r\n    0x00E1,\r\n    0x00E2,\r\n    0x0103,\r\n    0x00E4,\r\n    0x013A,\r\n    0x0107,\r\n    0x00E7,\r\n    0x010D,\r\n    0x00E9,\r\n    0x0119,\r\n    0x00EB,\r\n    0x011B,\r\n    0x00ED,\r\n    0x00EE,\r\n    0x010F,\r\n    0x0111,\r\n    0x0144,\r\n    0x0148,\r\n    0x00F3,\r\n    0x00F4,\r\n    0x0151,\r\n    0x00F6,\r\n    0x00F7,\r\n    0x0159,\r\n    0x016F,\r\n    0x00FA,\r\n    0x0171,\r\n    0x00FC,\r\n    0x00FD,\r\n    0x0163,\r\n    0x02D9,\r\n};\r\n\r\n//---------------------------------------------------------------------------\r\nZtring EmptyZtring;\r\n//---------------------------------------------------------------------------\r\n\r\n//---------------------------------------------------------------------------\r\n#if defined(STREAM_MISSING)\r\n    #if defined (_UNICODE)\r\n        #if defined (MACOS) || defined (MACOSX)\r\n            #define _tnprintf swprintf\r\n        #else\r\n            #define _tnprintf snwprintf\r\n        #endif\r\n    #else\r\n        #define _tnprintf snprintf\r\n    #endif\r\n#else\r\n    typedef basic_stringstream<Char>  tStringStream;\r\n    typedef basic_istringstream<Char> tiStringStream;\r\n    typedef basic_ostringstream<Char> toStringStream;\r\n#endif\r\n//---------------------------------------------------------------------------\r\n\r\n//***************************************************************************\r\n// Operators\r\n//***************************************************************************\r\n\r\nChar &Ztring::operator() (size_type Pos)\r\n{\r\n    if (Pos>size())\r\n        resize(Pos);\r\n    return operator[] (Pos);\r\n}\r\n\r\n//***************************************************************************\r\n// Assign\r\n//***************************************************************************\r\n\r\nbool Ztring::Assign_FromFile (const Ztring &FileName)\r\n{\r\n    File F;\r\n    if (!F.Open(FileName))\r\n        return false;\r\n    int64u F_Size=F.Size_Get();\r\n    if (F_Size>((size_t)-1)-1)\r\n        return false;\r\n\r\n    //Creating buffer\r\n    int8u* Buffer=new int8u[(size_t)F_Size+1];\r\n    size_t Buffer_Offset=0;\r\n\r\n    //Reading the file\r\n    while(Buffer_Offset<F_Size)\r\n    {\r\n        size_t BytesRead=F.Read(Buffer+Buffer_Offset, (size_t)F_Size-Buffer_Offset);\r\n        if (BytesRead==0)\r\n            break; //Read is finished\r\n        Buffer_Offset+=BytesRead;\r\n    }\r\n    if (Buffer_Offset<F_Size)\r\n    {\r\n        delete[] Buffer;\r\n        return false;\r\n    }\r\n    Buffer[Buffer_Offset]='\\0';\r\n\r\n    //Filling\r\n    assign((const Char*)Buffer);\r\n    delete[] Buffer;\r\n\r\n    return true;\r\n}\r\n\r\n//***************************************************************************\r\n// Conversions\r\n//***************************************************************************\r\n\r\nZtring& Ztring::From_Unicode (const wchar_t S)\r\n{\r\n    #ifdef _UNICODE\r\n        append(1, S);\r\n    #else\r\n        From_Unicode(&S, 1);\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Unicode (const wchar_t* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    #ifdef _UNICODE\r\n        assign(S);\r\n    #else\r\n        #ifdef ZENLIB_USEWX\r\n            size_type OK=wxConvCurrent->WC2MB(NULL, S, 0);\r\n            if (OK!=0 && OK!=Error)\r\n                assign(wxConvCurrent->cWC2MB(S));\r\n        #else //ZENLIB_USEWX\r\n            #ifdef WINDOWS\r\n                int Size=WideCharToMultiByte(CP_UTF8, 0, S, -1, NULL, 0, NULL, NULL);\r\n                if (Size!=0)\r\n                {\r\n                    char* AnsiString=new char[Size+1];\r\n                    WideCharToMultiByte(CP_UTF8, 0, S, -1, AnsiString, Size, NULL, NULL);\r\n                    AnsiString[Size]='\\0';\r\n                    assign (AnsiString);\r\n                    delete[] AnsiString;\r\n                }\r\n                else\r\n                    clear();\r\n            #else //WINDOWS\r\n                size_t Size=wcstombs(NULL, S, 0);\r\n                if (Size!=0 && Size!=(size_t)-1)\r\n                {\r\n                    char* AnsiString=new char[Size+1];\r\n                    Size=wcstombs(AnsiString, S, wcslen(S));\r\n                    AnsiString[Size]='\\0';\r\n                    assign (AnsiString);\r\n                    delete[] AnsiString;\r\n                }\r\n                else\r\n                    clear();\r\n            #endif\r\n        #endif //ZENLIB_USEWX\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Unicode (const wchar_t *S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n        Length=wcslen(S+Start);\r\n    wchar_t* Temp=new wchar_t[Length+1];\r\n    wcsncpy (Temp, S+Start, Length);\r\n    Temp[Length]=__T('\\0');\r\n\r\n    From_Unicode(Temp);\r\n    delete[] Temp; //Temp=NULL;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF8 (const char* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    #ifdef ZENLIB_USEWX\r\n        size_type OK=wxConvUTF8.MB2WC(NULL, S, 0);\r\n        if (OK!=0 && OK!=Error)\r\n            #ifdef _UNICODE\r\n                assign(wxConvUTF8.cMB2WC(S).data());\r\n            #else\r\n                assign(wxConvCurrent->cWC2MB(wxConvUTF8.cMB2WC(S)));\r\n            #endif\r\n    #else //ZENLIB_USEWX\r\n        #ifdef _UNICODE\r\n            // Don't use MultiByteToWideChar(), some characters are not well decoded\r\n            clear();\r\n            const int8u* Z=(const int8u*)S;\r\n            while (*Z) //0 is end\r\n            {\r\n                //1 byte\r\n                if (*Z<0x80)\r\n                {\r\n                    operator += ((wchar_t)(*Z));\r\n                    Z++;\r\n                }\r\n                //2 bytes\r\n                else if ((*Z&0xE0)==0xC0)\r\n                {\r\n                    if ((*(Z+1)&0xC0)==0x80)\r\n                    {\r\n                        operator += ((((wchar_t)(*Z&0x1F))<<6)|(*(Z+1)&0x3F));\r\n                        Z+=2;\r\n                    }\r\n                    else\r\n                    {\r\n                        clear();\r\n                        return *this; //Bad character\r\n                    }\r\n                }\r\n                //3 bytes\r\n                else if ((*Z&0xF0)==0xE0)\r\n                {\r\n                    if ((*(Z+1)&0xC0)==0x80 && (*(Z+2)&0xC0)==0x80)\r\n                    {\r\n                        operator += ((((wchar_t)(*Z&0x0F))<<12)|((*(Z+1)&0x3F)<<6)|(*(Z+2)&0x3F));\r\n                        Z+=3;\r\n                    }\r\n                    else\r\n                    {\r\n                        clear();\r\n                        return *this; //Bad character\r\n                    }\r\n                }\r\n                //4 bytes\r\n                else if ((*Z&0xF8)==0xF0)\r\n                {\r\n                    if ((*(Z+1)&0xC0)==0x80 && (*(Z+2)&0xC0)==0x80 && (*(Z+3)&0xC0)==0x80)\r\n                    {\r\n                        #if defined(_MSC_VER)\r\n                            #pragma warning(push)\r\n                            #pragma warning(disable:4127)\r\n                        #endif //defined(_MSC_VER)\r\n                        if (sizeof(wchar_t) == 2)\r\n                        #if defined(_MSC_VER)\r\n                            #pragma warning(pop)\r\n                        #endif //defined(_MSC_VER)\r\n                        {\r\n                            int32u Value = ((((int32u)(*Z&0x0F))<<18)|((*(Z+1)&0x3F)<<12)|((*(Z+2)&0x3F)<<6)|(*(Z+3)&0x3F));\r\n                            operator += (0xD800|((Value>>10)-0x40));\r\n                            operator += (0xDC00| (Value&0x3FF));\r\n                        }\r\n                        else\r\n                            operator += ((((wchar_t)(*Z&0x0F))<<18)|((*(Z+1)&0x3F)<<12)|((*(Z+2)&0x3F)<<6)|(*(Z+3)&0x3F));\r\n                        Z+=4;\r\n                    }\r\n                    else\r\n                    {\r\n                        clear();\r\n                        return *this; //Bad character\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    clear();\r\n                    return *this; //Bad character\r\n                }\r\n            }\r\n        #else\r\n            assign(S); //Not implemented\r\n        #endif\r\n    #endif //ZENLIB_USEWX\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF8 (const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n        Length=strlen(S+Start);\r\n    char* Temp=new char[Length+1];\r\n    strncpy (Temp, S+Start, Length);\r\n    Temp[Length]='\\0';\r\n\r\n    From_UTF8(Temp);\r\n    delete[] Temp; //Temp=NULL;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF16 (const char* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n         if ((unsigned char)S[0]==(unsigned char)0xFF && (unsigned char)S[1]==(unsigned char)0xFE)\r\n        return From_UTF16LE(S+2);\r\n    else if ((unsigned char)S[0]==(unsigned char)0xFE && (unsigned char)S[1]==(unsigned char)0xFF)\r\n        return From_UTF16BE(S+2);\r\n    else if ((unsigned char)S[0]==(unsigned char)0x00 && (unsigned char)S[1]==(unsigned char)0x00)\r\n    {\r\n        clear(); //No begin!\r\n        return *this;\r\n    }\r\n    else\r\n        return From_UTF16LE(S); //Not sure, default\r\n}\r\n\r\nZtring& Ztring::From_UTF16 (const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length<2)\r\n        return *this;\r\n\r\n         if ((unsigned char)S[0]==(unsigned char)0xFF && (unsigned char)S[1]==(unsigned char)0xFE)\r\n        return From_UTF16LE(S+2, Start, Length-2);\r\n    else if ((unsigned char)S[0]==(unsigned char)0xFE && (unsigned char)S[1]==(unsigned char)0xFF)\r\n        return From_UTF16BE(S+2, Start, Length-2);\r\n    else if ((unsigned char)S[0]==(unsigned char)0x00 && (unsigned char)S[1]==(unsigned char)0x00)\r\n    {\r\n        clear(); //No begin!\r\n        return *this;\r\n    }\r\n    else\r\n        return From_UTF16LE(S, Start, Length); //Not sure, default\r\n}\r\n\r\nZtring& Ztring::From_UTF16BE (const char* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    #ifdef ZENLIB_USEWX\r\n        //clear(); return *this;\r\n        wxMBConvUTF16BE wxConvUTF16BE;\r\n        size_type OK=wxConvUTF16BE.MB2WC(NULL, S, 0);\r\n        if (OK!=0 && OK!=Error)\r\n            #ifdef _UNICODE\r\n                assign(wxConvUTF16BE.cMB2WC(S).data());\r\n            #else\r\n                assign(wxConvCurrent->cWC2MB(wxConvUTF16BE.cMB2WC(S)));\r\n            #endif\r\n    #else //ZENLIB_USEWX\r\n        #ifdef WINDOWS\r\n            clear();\r\n            const wchar_t* SW=(const wchar_t*)S;\r\n            size_t Pos=0;\r\n            while (SW[Pos]!=__T('\\0'))\r\n            {\r\n                Char Temp=(Char)(((SW[Pos]&0xFF00)>>8)+((SW[Pos]&0x00FF)<<8));\r\n                append(1, Temp);\r\n                Pos++;\r\n            }\r\n        #else //WINDOWS\r\n            clear();\r\n            while (S[0]!=0 || S[1]!=0)\r\n            {\r\n                append(1, (Char)BigEndian2int16u(S));\r\n                S+=2;\r\n            }\r\n        #endif\r\n    #endif //ZENLIB_USEWX\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF16BE (const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n    {\r\n        Length=0;\r\n        while(S[Length]!=0x0000)\r\n            Length++;\r\n    }\r\n    else\r\n        Length&=(size_t)-2; //odd number\r\n\r\n    char* Temp=new char[Length+2];\r\n    memcpy (Temp, S+Start, Length);\r\n    Temp[Length+0]=0x00;\r\n    Temp[Length+1]=0x00;\r\n    reserve(Length);\r\n    From_UTF16BE(Temp);\r\n    delete[] Temp; //Temp=NULL;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF16LE (const char* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    #ifdef ZENLIB_USEWX\r\n        //clear(); return *this;\r\n        wxMBConvUTF16LE wxConvUTF16LE;\r\n        size_type OK=wxConvUTF16LE.MB2WC(NULL, S, 0);\r\n        if (OK!=0 && OK!=Error)\r\n            #ifdef _UNICODE\r\n                assign(wxConvUTF16LE.cMB2WC(S).data());\r\n            #else\r\n                assign(wxConvCurrent->cWC2MB(wxConvUTF16LE.cMB2WC(S)));\r\n            #endif\r\n    #else //ZENLIB_USEWX\r\n        #ifdef WINDOWS\r\n            #ifdef UNICODE\r\n                const wchar_t* SW=(const wchar_t*)S;\r\n                assign(SW);\r\n            #else\r\n                clear(); //Not implemented\r\n            #endif\r\n        #else //WINDOWS\r\n            clear();\r\n            while (S[0]!=0 || S[1]!=0)\r\n            {\r\n                append(1, (Char)LittleEndian2int16u(S));\r\n                S+=2;\r\n            }\r\n        #endif\r\n    #endif //ZENLIB_USEWX\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF16LE (const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n    {\r\n        Length=0;\r\n        while(S[Length]!=0x0000)\r\n            Length+=2;\r\n    }\r\n    else\r\n        Length&=(size_t)-2; //odd number\r\n\r\n    char* Temp=new char[Length+2];\r\n    memcpy (Temp, S+Start, Length);\r\n    Temp[Length+0]=0x00;\r\n    Temp[Length+1]=0x00;\r\n    From_UTF16LE(Temp);\r\n    delete[] Temp; //Temp=NULL;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Local (const char* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    #ifdef _UNICODE\r\n        #ifdef ZENLIB_USEWX\r\n            size_type OK=wxConvCurrent->MB2WC(NULL, S, 0);\r\n            if (OK!=0 && OK!=Error)\r\n                assign(wxConvCurrent->cMB2WC(S).data());\r\n        #else //ZENLIB_USEWX\r\n            #ifdef WINDOWS\r\n                int Size=MultiByteToWideChar(CP_ACP, 0, S, -1, NULL, 0);\r\n                if (Size!=0)\r\n                {\r\n                    wchar_t* WideString=new wchar_t[Size+1];\r\n                    MultiByteToWideChar(CP_ACP, 0, S, -1, WideString, Size);\r\n                    WideString[Size]=L'\\0';\r\n                    assign (WideString);\r\n                    delete[] WideString; //WideString=NULL;\r\n                }\r\n                else\r\n                    clear();\r\n            #else //WINDOWS\r\n                size_t Size=mbsrtowcs(NULL, &S, 0, NULL);\r\n                if (Size!=0 && Size!=(size_t)-1)\r\n                {\r\n                    wchar_t* WideString=new wchar_t[Size+1];\r\n                    Size=mbsrtowcs(WideString, &S, Size, NULL);\r\n                    WideString[Size]=L'\\0';\r\n                    assign (WideString);\r\n                    delete[] WideString; //WideString=NULL;\r\n                }\r\n                else\r\n                    clear();\r\n            #endif\r\n        #endif //ZENLIB_USEWX\r\n    #else\r\n        assign(S);\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Local (const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n        Length=strlen(S+Start);\r\n    #ifdef _UNICODE\r\n        char* Temp=new char[Length+1];\r\n        strncpy (Temp, S+Start, Length);\r\n        Temp[Length]='\\0';\r\n        From_Local(Temp);\r\n        delete[] Temp; //Temp=NULL;\r\n    #else\r\n        assign(S+Start, Length);\r\n        if (find(__T('\\0'))!=std::string::npos)\r\n            resize(find(__T('\\0')));\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_ISO_8859_1(const char* S)\r\n{\r\n    size_t Length = strlen(S);\r\n    wchar_t* Temp = new wchar_t[Length +1];\r\n\r\n    for (size_t Pos=0; Pos<Length+1; Pos++)\r\n        Temp[Pos]=(wchar_t)((int8u)S[Pos]);\r\n\r\n    From_Unicode(Temp);\r\n    delete[] Temp;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_ISO_8859_1(const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n        Length=strlen(S+Start);\r\n    #ifdef _UNICODE\r\n        char* Temp = new char[Length+1];\r\n        strncpy(Temp, S +Start, Length);\r\n        Temp[Length] = '\\0';\r\n        From_ISO_8859_1(Temp);\r\n        delete[] Temp;\r\n    #else\r\n        assign(S +Start, Length);\r\n        if (find(__T('\\0')) != std::string::npos)\r\n            resize(find(__T('\\0')));\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_ISO_8859_2(const char* S)\r\n{\r\n    size_t Length = strlen(S);\r\n    wchar_t* Temp = new wchar_t[Length +1];\r\n\r\n    for (size_t Pos=0; Pos<Length+1; Pos++)\r\n    {\r\n        if ((int8u)S[Pos]>=0xA0)\r\n            Temp[Pos]=(wchar_t)Ztring_ISO_8859_2[((int8u)S[Pos])-0xA0];\r\n        else\r\n            Temp[Pos]=(wchar_t)((int8u)S[Pos]);\r\n    }\r\n\r\n    From_Unicode(Temp);\r\n    delete[] Temp;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_ISO_8859_2(const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n        Length=strlen(S+Start);\r\n    #ifdef _UNICODE\r\n        char* Temp = new char[Length+1];\r\n        strncpy(Temp, S +Start, Length);\r\n        Temp[Length] = '\\0';\r\n        From_ISO_8859_2(Temp);\r\n        delete[] Temp;\r\n    #else\r\n        assign(S +Start, Length);\r\n        if (find(__T('\\0')) != std::string::npos)\r\n            resize(find(__T('\\0')));\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_GUID (const int128u S)\r\n{\r\n    Ztring S1;\r\n    S1.From_CC1((int8u) ((S.hi&0x000000FF00000000LL)>>32)); append(S1);\r\n    S1.From_CC1((int8u) ((S.hi&0x0000FF0000000000LL)>>40)); append(S1);\r\n    S1.From_CC1((int8u) ((S.hi&0x00FF000000000000LL)>>48)); append(S1);\r\n    S1.From_CC1((int8u) ((S.hi&0xFF00000000000000LL)>>56)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC1((int8u) ((S.hi&0x0000000000FF0000LL)>>16)); append(S1);\r\n    S1.From_CC1((int8u) ((S.hi&0x00000000FF000000LL)>>24)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC1((int8u) ( S.hi&0x00000000000000FFLL     )); append(S1);\r\n    S1.From_CC1((int8u) ((S.hi&0x000000000000FF00LL)>> 8)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)((S.lo&0xFFFF000000000000LL)>>48)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)((S.lo&0x0000FFFF00000000LL)>>32)); append(S1);\r\n    S1.From_CC2((int16u)((S.lo&0x00000000FFFF0000LL)>>16)); append(S1);\r\n    S1.From_CC2((int16u)( S.lo&0x000000000000FFFFLL     )); append(S1);\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UUID (const int128u S)\r\n{\r\n    Ztring S1;\r\n    S1.From_CC2((int16u)((S.hi&0xFFFF000000000000LL)>>48)); assign(S1);\r\n    S1.From_CC2((int16u)((S.hi&0x0000FFFF00000000LL)>>32)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)((S.hi&0x00000000FFFF0000LL)>>16)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)( S.hi&0x000000000000FFFFLL     )); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)((S.lo&0xFFFF000000000000LL)>>48)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)((S.lo&0x0000FFFF00000000LL)>>32)); append(S1);\r\n    S1.From_CC2((int16u)((S.lo&0x00000000FFFF0000LL)>>16)); append(S1);\r\n    S1.From_CC2((int16u)( S.lo&0x000000000000FFFFLL     )); append(S1);\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_CC4 (const int32u S)\r\n{\r\n    clear();\r\n    for (int8s i=(4-1)*8; i>=0; i-=8)\r\n    {\r\n        int32u Value=(S&(0xFF<<i))>>i;\r\n        if (Value<0x20)\r\n        {\r\n            if (!i || (i!=24  && !(S&(0xFFFFFFFF>>(32-i)))))\r\n                return *this; // Trailing 0 are fine\r\n\r\n            // Not valid, using 0x as fallback\r\n            clear();\r\n            append(__T(\"0x\"));\r\n            append(Ztring().From_CC1((int8u)((S&0xFF000000)>>24)));\r\n            append(Ztring().From_CC1((int8u)((S&0x00FF0000)>>16)));\r\n            append(Ztring().From_CC1((int8u)((S&0x0000FF00)>> 8)));\r\n            append(Ztring().From_CC1((int8u)((S&0x000000FF)    )));\r\n            return *this;\r\n        }\r\n        append(1, (Char)(Value));\r\n    }\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_CC3 (const int32u S)\r\n{\r\n    clear();\r\n    for (int8s i=(3-1)*8; i>=0; i-=8)\r\n    {\r\n        int32u Value=(S&(0xFF<<i))>>i;\r\n        if (Value<0x20)\r\n        {\r\n            if (!i || (i!=16  && !(S&(0xFFFFFF>>(24-i)))))\r\n                return *this; // Trailing 0 are fine\r\n\r\n            // Not valid, using 0x as fallback\r\n            clear();\r\n            append(__T(\"0x\"));\r\n            append(Ztring().From_CC1((int8u)((S&0x00FF0000)>>16)));\r\n            append(Ztring().From_CC1((int8u)((S&0x0000FF00)>> 8)));\r\n            append(Ztring().From_CC1((int8u)((S&0x000000FF)    )));\r\n            return *this;\r\n        }\r\n        append(1, (Char)(Value));\r\n    }\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_CC2 (const int16u S)\r\n{\r\n    clear();\r\n    Ztring Pos1; Pos1.From_Number(S, 16);\r\n    resize(4-Pos1.size(), __T('0'));\r\n    append(Pos1);\r\n    MakeUpperCase();\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_CC1 (const int8u S)\r\n{\r\n    clear();\r\n    Ztring Pos1; Pos1.From_Number(S, 16);\r\n    resize(2-Pos1.size(), __T('0'));\r\n    append(Pos1);\r\n    MakeUpperCase();\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int8s I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _itot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%d\"):(Radix==16?__T(\"%x\"):(Radix==8?__T(\"%o\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        toStringStream Stream;\r\n        #ifdef UNICODE\r\n            Stream << setbase(Radix) << I;\r\n        #else //UNICODE\r\n            Stream << setbase(Radix) << (size_t)I; //On linux (at least), (un)signed char is detected as a char\r\n        #endif //UNICODE\r\n        assign(Stream.str());\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int8u I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _ultot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%d\"):(Radix==16?__T(\"%x\"):(Radix==8?__T(\"%o\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        if (Radix==2)\r\n        {\r\n            clear();\r\n            for (int8u Pos=0; Pos<8; Pos++)\r\n            {\r\n                if (I<(((int8u)1)<<Pos))\r\n                    break;\r\n                insert(0, 1, (I&(((int8u)1)<<Pos))?__T('1'):__T('0'));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            toStringStream Stream;\r\n            #ifdef UNICODE\r\n                Stream << setbase(Radix) << I;\r\n            #else //UNICODE\r\n                Stream << setbase(Radix) << (size_t)I; //On linux (at least), (un)signed char is detected as a char\r\n            #endif //UNICODE\r\n            assign(Stream.str());\r\n        }\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int16s I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _itot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%d\"):(Radix==16?__T(\"%x\"):(Radix==8?__T(\"%o\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setbase(Radix) << I;\r\n        assign(Stream.str());\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int16u I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _ultot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%u\"):(Radix==16?__T(\"%x\"):(Radix==8?__T(\"%o\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        if (Radix==2)\r\n        {\r\n            clear();\r\n            for (int8u Pos=0; Pos<16; Pos++)\r\n            {\r\n                if (I<(((int16u)1)<<Pos))\r\n                    break;\r\n                insert(0, 1, (I&(((int16u)1)<<Pos))?__T('1'):__T('0'));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            toStringStream Stream;\r\n            Stream << setbase(Radix) << I;\r\n            assign(Stream.str());\r\n        }\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int32s I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _itot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%ld\"):(Radix==16?__T(\"%lx\"):(Radix==8?__T(\"%lo\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setbase(Radix) << I;\r\n        assign(Stream.str());\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int32u I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _ultot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%lu\"):(Radix==16?__T(\"%lx\"):(Radix==8?__T(\"%lo\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        if (Radix==2)\r\n        {\r\n            clear();\r\n            for (int8u Pos=0; Pos<32; Pos++)\r\n            {\r\n                if (I<(((int32u)1)<<Pos))\r\n                    break;\r\n                insert(0, 1, (I&(((int32u)1)<<Pos))?__T('1'):__T('0'));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            toStringStream Stream;\r\n            Stream << setbase(Radix) << I;\r\n            assign(Stream.str());\r\n        }\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int64s I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[65];\r\n        #ifdef __MINGW32__\r\n            _i64tot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 64, Radix==10?__T(\"%lld\"):(Radix==16?__T(\"%llx\"):(Radix==8?__T(\"%llo\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setbase(Radix) << I;\r\n        assign(Stream.str());\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int64u I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[65]; C1[0] = 0;\r\n        #ifdef __MINGW32__\r\n            _ui64tot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 64, Radix==10?__T(\"%llu\"):(Radix==16?__T(\"%llx\"):(Radix==8?__T(\"%llo\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        if (Radix==2)\r\n        {\r\n            clear();\r\n            for (int8u Pos=0; Pos<32; Pos++)\r\n            {\r\n                if (I<(((int64u)1)<<Pos))\r\n                    break;\r\n                insert(0, 1, (I&(((int64u)1)<<Pos))?__T('1'):__T('0'));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            toStringStream Stream;\r\n            Stream << setbase(Radix) << I;\r\n            assign(Stream.str());\r\n        }\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int128u I, int8u Radix)\r\n{\r\n    From_Local(I.toString(Radix));\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const float32 F, int8u Precision, ztring_t Options)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        Char C1[100];\r\n        _tnprintf (C1, 99, (Ztring(__T(\"%.\"))+Ztring::ToZtring(Precision)+__T(\"f\")).c_str(), F);\r\n        assign(C1);\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setprecision(Precision) << fixed << F;\r\n        assign(Stream.str());\r\n        #if defined(__BORLANDC__)\r\n            FindAndReplace(__T(\",\"), __T(\".\")); //Borland C++ Builder 2010+Windows Seven put a comma for istringstream, but does not support comma for ostringstream\r\n        #endif\r\n    #endif\r\n\r\n    if ((Options & Ztring_NoZero && size()>0) && find(__T('.'))!=string::npos)\r\n    {\r\n        while (size()>0 && ((*this)[size()-1]==__T('0')))\r\n            resize(size()-1);\r\n        if (size()>0 && (*this)[size()-1]==__T('.'))\r\n            resize(size()-1);\r\n    }\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const float64 F, int8u Precision, ztring_t Options)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        Char C1[100];\r\n        _tnprintf (C1, 99, (Ztring(__T(\"%.\"))+Ztring::ToZtring(Precision)+__T(\"f\")).c_str(), F);\r\n        assign(C1);\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setprecision(Precision) << fixed << F;\r\n        assign(Stream.str());\r\n        #if defined(__BORLANDC__)\r\n            FindAndReplace(__T(\",\"), __T(\".\")); //Borland C++ Builder 2010+Windows Seven put a comma for istringstream, but does not support comma for ostringstream\r\n        #endif\r\n    #endif\r\n\r\n    if ((Options & Ztring_NoZero && size()>0) && find(__T('.'))!=string::npos)\r\n    {\r\n        while (size()>0 && ((*this)[size()-1]==__T('0')))\r\n            resize(size()-1);\r\n        if (size()>0 && (*this)[size()-1]==__T('.'))\r\n            resize(size()-1);\r\n    }\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const float80 F, int8u Precision, ztring_t Options)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        Char C1[100];\r\n        _tnprintf (C1, 99, (Ztring(__T(\"%.\"))+Ztring::ToZtring(Precision)+__T(\"f\")).c_str(), F);\r\n        assign(C1);\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setprecision(Precision) << fixed << F;\r\n        assign(Stream.str());\r\n        #if defined(__BORLANDC__)\r\n            FindAndReplace(__T(\",\"), __T(\".\")); //Borland C++ Builder 2010+Windows Seven put a comma for istringstream, but does not support comma for ostringstream\r\n        #endif\r\n    #endif\r\n\r\n    if ((Options & Ztring_NoZero && size()>0) && find(__T('.'))!=string::npos)\r\n    {\r\n        while (size()>0 && ((*this)[size()-1]==__T('0')))\r\n            resize(size()-1);\r\n        if (size()>0 && (*this)[size()-1]==__T('.'))\r\n            resize(size()-1);\r\n    }\r\n\r\n    return *this;\r\n}\r\n\r\n#ifdef SIZE_T_IS_LONG\r\nZtring& Ztring::From_Number (const size_t I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        Char C1[100];\r\n        _tnprintf(C1, 64, Radix==10?__T(\"%zu\"):(Radix==16?__T(\"%zx\"):(Radix==8?__T(\"%zo\"):__T(\"\"))), I);\r\n        assign(C1);\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setbase(Radix) << I;\r\n        assign(Stream.str());\r\n        #if defined(__BORLANDC__)\r\n            FindAndReplace(__T(\",\"), __T(\".\")); //Borland C++ Builder 2010+Windows Seven put a comma for istringstream, but does not support comma for ostringstream\r\n        #endif\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n#endif //SIZE_T_IS_LONG\r\n\r\nZtring& Ztring::From_BCD     (const int8u I)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        clear();\r\n        append(1, __T('0')+I/0x10);\r\n        append(1, __T('0')+I%0x10);\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << I/0x10;\r\n        Stream << I%0x10;\r\n        assign(Stream.str());\r\n    #endif\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\nZtring& Ztring::Duration_From_Milliseconds (const int64s Value_)\r\n{\r\n    int64s Value=Value_;\r\n    bool Negative=false;\r\n    if (Value<0)\r\n    {\r\n        Value=-Value;\r\n        Negative=true;\r\n    }\r\n\r\n    int64u HH=(int8u)(Value/1000/60/60);\r\n    int64u MM=Value/1000/60   -((HH*60));\r\n    int64u Stream=Value/1000      -((HH*60+MM)*60);\r\n    int64u MS=Value           -((HH*60+MM)*60+Stream)*1000;\r\n    Ztring DateT;\r\n    Ztring Date;\r\n    DateT.From_Number(HH); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(MM); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(Stream); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\".\");\r\n    DateT.From_Number(MS); if (DateT.size()<2){DateT=Ztring(__T(\"00\"))+DateT;} else if (DateT.size()<3){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    if (Negative)\r\n    {\r\n        assign(__T(\"-\"));\r\n        append(Date);\r\n    }\r\n    else\r\n        assign (Date.c_str());\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\nZtring& Ztring::Duration_From_Milliseconds (const int64u Value)\r\n{\r\n    int64u HH=(int8u)(Value/1000/60/60);\r\n    int64u MM=Value/1000/60   -((HH*60));\r\n    int64u Stream=Value/1000      -((HH*60+MM)*60);\r\n    int64u MS=Value           -((HH*60+MM)*60+Stream)*1000;\r\n    Ztring DateT;\r\n    Ztring Date;\r\n    DateT.From_Number(HH); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(MM); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(Stream); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\".\");\r\n    DateT.From_Number(MS); if (DateT.size()<2){DateT=Ztring(__T(\"00\"))+DateT;} else if (DateT.size()<3){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    assign (Date.c_str());\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::Date_From_Milliseconds_1601 (const int64u Value)\r\n{\r\n    if (Value>=11644473600000LL) //Values <1970 are not supported\r\n    {\r\n        Date_From_Seconds_1970((int32u)((Value-11644473600000LL)/1000));\r\n        append(__T(\".\"));\r\n        Ztring Milliseconds; Milliseconds.From_Number(Value%1000);\r\n        while (Milliseconds.size()<3)\r\n            Milliseconds+=__T('0');\r\n        append(Milliseconds);\r\n    }\r\n    else\r\n        clear(); //Not supported\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1601 (const int64u Value)\r\n{\r\n    return Date_From_Seconds_1970(((int64s)Value)-11644473600LL);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1900 (const int32u Value)\r\n{\r\n    if (Value>2208988800)\r\n        return Date_From_Seconds_1970(((int64s)Value)-2208988800);\r\n    else\r\n        return Date_From_Seconds_1970(((int64s)Value)+0x100000000LL-2208988800); //Value is considering to loop e.g. NTP value\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1900 (const int64s Value)\r\n{\r\n    return Date_From_Seconds_1970(Value-2208988800);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1904 (const int32u Value)\r\n{\r\n    return Date_From_Seconds_1970(((int64s)Value)-2082844800);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1904 (const int64u Value)\r\n{\r\n    return Date_From_Seconds_1970(((int64s)Value)-2082844800);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1904 (const int64s Value)\r\n{\r\n    return Date_From_Seconds_1970(Value-2082844800);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1970 (const int32u Value)\r\n{\r\n    return Date_From_Seconds_1970((int64s)Value);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1970 (const int32s Value)\r\n{\r\n    return Date_From_Seconds_1970((int64s)Value);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1970 (const int64s Value)\r\n{\r\n    time_t Time=(time_t)Value;\r\n    #if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE\r\n    struct tm Gmt_Temp;\r\n    struct tm *Gmt=gmtime_r(&Time, &Gmt_Temp);\r\n    #elif defined(_MSC_VER)\r\n    struct tm Gmt_Temp;\r\n    errno_t gmtime_s_Result=gmtime_s(&Gmt_Temp , &Time);\r\n    struct tm* Gmt=gmtime_s_Result?NULL:&Gmt_Temp;\r\n    #else\r\n    struct tm *Gmt=gmtime(&Time);\r\n    #endif\r\n    if (!Gmt)\r\n    {\r\n        clear();\r\n        return *this;\r\n    }\r\n    Ztring DateT;\r\n    Ztring Date=__T(\"UTC \");\r\n    Date+=Ztring::ToZtring((Gmt->tm_year+1900));\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Gmt->tm_mon+1); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mon+1);}\r\n    Date+=DateT;\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Gmt->tm_mday); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mday);}\r\n    Date+=DateT;\r\n    Date+=__T(\" \");\r\n    DateT.From_Number(Gmt->tm_hour); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_hour);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT=Ztring::ToZtring(Gmt->tm_min); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_min);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(Gmt->tm_sec); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_sec);}\r\n    Date+=DateT;\r\n    assign (Date.c_str());\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1970_Local (const int32u Value)\r\n{\r\n    time_t Time=(time_t)Value;\r\n    #if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE\r\n    struct tm Gmt_Temp;\r\n    struct tm *Gmt=localtime_r(&Time, &Gmt_Temp);\r\n    #elif defined(_MSC_VER)\r\n    struct tm Gmt_Temp;\r\n    errno_t localtime_s_Result=localtime_s(&Gmt_Temp , &Time);\r\n    struct tm* Gmt=localtime_s_Result?NULL:&Gmt_Temp;\r\n    #else\r\n    struct tm *Gmt=localtime(&Time);\r\n    #endif\r\n    Ztring DateT;\r\n    Ztring Date;\r\n    Date+=Ztring::ToZtring((Gmt->tm_year+1900));\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Gmt->tm_mon+1); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mon+1);}\r\n    Date+=DateT;\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Gmt->tm_mday); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mday);}\r\n    Date+=DateT;\r\n    Date+=__T(\" \");\r\n    DateT.From_Number(Gmt->tm_hour); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_hour);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT=Ztring::ToZtring(Gmt->tm_min); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_min);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(Gmt->tm_sec); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_sec);}\r\n    Date+=DateT;\r\n    assign (Date.c_str());\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::Date_From_String (const char* Value, size_t Value_Size)\r\n{\r\n    //Only the year\r\n    if (Value_Size<10)\r\n    {\r\n        From_UTF8(Value, 0, Value_Size);\r\n        return *this;\r\n    }\r\n\r\n    #ifdef ZENLIB_USEWX\r\n        Ztring ToReturn=__T(\"UTC \");\r\n        wxDateTime Date;\r\n        Ztring DateS;\r\n        DateS.From_Local(Value, Value_Size).c_str();\r\n        if (!DateS.empty() && DateS[DateS.size()-1]==__T('\\n'))\r\n            DateS.resize(DateS.size()-1);\r\n\r\n        //Some strange formating : exactly 24 bytes (or 25 with 0x0A at the end) and Year is at the end\r\n        if (DateS.size()==24 && DateS[23]>=__T('0') && DateS[23]<=__T('9') && DateS[21]>=__T('0') && DateS[21]<=__T('9') && DateS[19]==__T(' '))\r\n            Date.ParseFormat(DateS.c_str(), __T(\"%a %b %d %H:%M:%S %Y\"));\r\n        //ISO date\r\n        else if (DateS.size()==10 && (DateS[4]<__T('0') || DateS[4]>__T('9')) && (DateS[7]<__T('0') || DateS[7]>__T('9')))\r\n        {\r\n            DateS[4]=__T('-');\r\n            DateS[7]=__T('-');\r\n            ToReturn+=DateS;\r\n        }\r\n        //Default\r\n        else\r\n            Date.ParseDateTime(DateS.c_str());\r\n\r\n        if (ToReturn.size()<5)\r\n        {\r\n            ToReturn+=Date.FormatISODate();\r\n            ToReturn+=__T(\" \");\r\n            ToReturn+=Date.FormatISOTime();\r\n        }\r\n        else\r\n            ToReturn+=DateS;\r\n\r\n        assign (ToReturn.c_str());\r\n    #else //ZENLIB_USEWX\r\n        Ztring DateS; DateS.From_UTF8(Value, 0, Value_Size);\r\n        //Unix style formating : exactly 24 bytes (or 25 with 0x0A at the end) and Year is at the end\r\n        if ((DateS.size()==24 || (DateS.size()==25 && DateS[24]==__T('\\n'))) && DateS[23]>=__T('0') && DateS[23]<=__T('9') && DateS[21]>=__T('0') && DateS[21]<=__T('9') && DateS[19]==__T(' '))\r\n        {\r\n            clear();\r\n            append(1, DateS[20]);\r\n            append(1, DateS[21]);\r\n            append(1, DateS[22]);\r\n            append(1, DateS[23]);\r\n            append(1, __T('-'));\r\n                 if (DateS[4]==__T('J') && DateS[5]==__T('a') && DateS[6]==__T('n') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('1'));\r\n            }\r\n            else if (DateS[4]==__T('F') && DateS[5]==__T('e') && DateS[6]==__T('b') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('2'));\r\n            }\r\n            else if (DateS[4]==__T('M') && DateS[5]==__T('a') && DateS[6]==__T('r') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('3'));\r\n            }\r\n            else if (DateS[4]==__T('A') && DateS[5]==__T('p') && DateS[6]==__T('r') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('4'));\r\n            }\r\n            else if (DateS[4]==__T('M') && DateS[5]==__T('a') && DateS[6]==__T('y') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('5'));\r\n            }\r\n            else if (DateS[4]==__T('J') && DateS[5]==__T('u') && DateS[6]==__T('n') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('6'));\r\n            }\r\n            else if (DateS[4]==__T('J') && DateS[5]==__T('u') && DateS[6]==__T('l') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('7'));\r\n            }\r\n            else if (DateS[4]==__T('A') && DateS[5]==__T('u') && DateS[6]==__T('g') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('8'));\r\n            }\r\n            else if (DateS[4]==__T('S') && DateS[5]==__T('e') && DateS[6]==__T('p') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('9'));\r\n            }\r\n            else if (DateS[4]==__T('O') && DateS[5]==__T('c') && DateS[6]==__T('t') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('1'));\r\n                append(1, __T('0'));\r\n            }\r\n            else if (DateS[4]==__T('N') && DateS[5]==__T('o') && DateS[6]==__T('v') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('1'));\r\n                append(1, __T('1'));\r\n            }\r\n            else if (DateS[4]==__T('D') && DateS[5]==__T('e') && DateS[6]==__T('c') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('1'));\r\n                append(1, __T('2'));\r\n            }\r\n            else\r\n            {\r\n                assign(DateS);\r\n                return *this;\r\n            }\r\n            append(1, __T('-'));\r\n            append(1, DateS[8]);\r\n            append(1, DateS[9]);\r\n            append(1, __T(' '));\r\n            append(1, DateS[11]);\r\n            append(1, DateS[12]);\r\n            append(1, __T(':'));\r\n            append(1, DateS[14]);\r\n            append(1, DateS[15]);\r\n            append(1, __T(':'));\r\n            append(1, DateS[17]);\r\n            append(1, DateS[18]);\r\n        }\r\n        else if (DateS.size()==20 && DateS[4]==__T('-') && DateS[7]==__T('-') && DateS[10]==__T('T') && DateS[13]==__T(':') && DateS[16]==__T(':') && DateS[19]==__T('Z'))\r\n        {\r\n            DateS.resize(19);\r\n            DateS[10]=__T(' ');\r\n            assign(__T(\"UTC \"));\r\n            append(DateS);\r\n        }\r\n        else if (DateS.size()==23 && DateS[4]==__T('-') && DateS[7]==__T('-') && DateS[10]==__T(' ') && DateS[14]==__T(' ') && DateS[17]==__T(':') && DateS[20]==__T(':'))\r\n        {\r\n            DateS.erase(10, 4);\r\n            //assign(__T(\"UTC \")); //Is not UTC\r\n            append(DateS);\r\n        }\r\n        else\r\n            From_UTF8(Value, 0, Value_Size); //Not implemented\r\n    #endif //ZENLIB_USEWX\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::Date_From_Numbers (const int8u Year, const int8u Month, const int8u Day, const int8u Hour, const int8u Minute, const int8u Second)\r\n{\r\n    Ztring DateT;\r\n    Ztring Date=__T(\"UTC \");\r\n    DateT.From_Number(Year); if (DateT.size()<2){DateT=Ztring(__T(\"200\"))+Ztring::ToZtring(Year);}; if (DateT.size()<3){DateT=Ztring(__T(\"20\"))+Ztring::ToZtring(Year);}\r\n    Date+=DateT;\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Month); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Month);}\r\n    Date+=DateT;\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Day); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Day);}\r\n    Date+=DateT;\r\n    Date+=__T(\" \");\r\n    DateT.From_Number(Hour); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Hour);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT=Ztring::ToZtring(Minute); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Minute);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(Second); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Second);}\r\n    Date+=DateT;\r\n    assign (Date.c_str());\r\n    return *this;\r\n}\r\n\r\n#ifndef WSTRING_MISSING\r\n//---------------------------------------------------------------------------\r\nstd::wstring Ztring::To_Unicode () const\r\n{\r\n    #ifdef _UNICODE\r\n        return c_str();\r\n    #else //_UNICODE\r\n        #ifdef ZENLIB_USEWX\r\n            return wxConvCurrent->cMB2WC(c_str()).data();\r\n        #else //ZENLIB_USEWX\r\n            return std::wstring(); //Not implemented\r\n        #endif //ZENLIB_USEWX\r\n    #endif //_UNICODE\r\n}\r\n#endif //WSTRING_MISSING\r\n\r\nstd::string Ztring::To_UTF8 () const\r\n{\r\n    #ifdef _UNICODE\r\n        //Correction thanks to Andrew Jang\r\n        // Don't use WideCharToMultiByte(), some characters are not well converted\r\n        std::string ToReturn;\r\n        ToReturn.reserve(size()); // more efficient\r\n\r\n        const wchar_t* Z=c_str();\r\n\r\n        while (*Z)\r\n        {\r\n            if (*Z < 0x80)\r\n            {\r\n                ToReturn += (char)(*(Z++));\r\n                continue;\r\n            }\r\n            \r\n            int32u wc; // must be unsigned.\r\n\r\n            #if defined(_MSC_VER)\r\n                #pragma warning(push)\r\n                #pragma warning(disable:4127)\r\n            #endif //defined(_MSC_VER)\r\n            if (sizeof(wchar_t) == 2)\r\n            #if defined(_MSC_VER)\r\n                #pragma warning(pop)\r\n            #endif //defined(_MSC_VER)\r\n            {\r\n                if (((*Z) & 0xFC00) == 0xD800)\r\n                {\r\n                    //UTF-16\r\n                    wc =( (((int16u) *Z) & 0x3FF) + 0x40) << 10;\r\n                    Z++;\r\n                    wc |= (((int16u) *Z) & 0x3FF);\r\n                }\r\n                else\r\n                wc = (int16u) *Z; // avoid a cast problem if wchar_t is signed.\r\n            }\r\n            else\r\n                wc = *Z;\r\n\r\n            int count;\r\n\r\n            // refer to http://en.wikipedia.org/wiki/UTF-8#Description\r\n\r\n            if (wc < 0x80)\r\n                count = 1;\r\n            else if (wc < 0x800)\r\n                count = 2;\r\n            else if (wc < 0x10000)\r\n                count = 3;\r\n            else if (wc < 0x200000)\r\n                count = 4;\r\n            else if (wc < 0x4000000)\r\n                count = 5;\r\n            else if (wc <= 0x7fffffff)\r\n                count = 6;\r\n            else\r\n                break;  // bad character\r\n\r\n            int64u utfbuf = 0; // 8 bytes\r\n            char* utf8chars = (char*) &utfbuf;\r\n\r\n            switch (count)\r\n            {\r\n            case 6:\r\n                utf8chars[5] = 0x80 | (wc & 0x3f);\r\n                wc = (wc >> 6) | 0x4000000;\r\n                /* fallthrough */\r\n            case 5:\r\n                utf8chars[4] = 0x80 | (wc & 0x3f);\r\n                wc = (wc >> 6) | 0x200000;\r\n                /* fallthrough */\r\n            case 4:\r\n                utf8chars[3] = 0x80 | (wc & 0x3f);\r\n                wc = (wc >> 6) | 0x10000;\r\n                /* fallthrough */\r\n            case 3:\r\n                utf8chars[2] = 0x80 | (wc & 0x3f);\r\n                wc = (wc >> 6) | 0x800;\r\n                /* fallthrough */\r\n            case 2:\r\n                utf8chars[1] = 0x80 | (wc & 0x3f);\r\n                wc = (wc >> 6) | 0xc0;\r\n                /* fallthrough */\r\n            case 1:\r\n                utf8chars[0] = (char) wc;\r\n            }\r\n\r\n            ToReturn += utf8chars;\r\n\r\n            ++Z;\r\n        }\r\n\r\n        return ToReturn;\r\n    #else\r\n        #ifdef ZENLIB_USEWX\r\n            return wxConvUTF8.cWC2MB(wxConvCurrent->cMB2WC(c_str())).data();\r\n        #else //ZENLIB_USEWX\r\n            return c_str(); //Not implemented\r\n        #endif //ZENLIB_USEWX\r\n    #endif\r\n}\r\n\r\nstd::string Ztring::To_Local () const\r\n{\r\n    #ifdef _UNICODE\r\n        #ifdef ZENLIB_USEWX\r\n            wxCharBuffer C=wxConvCurrent->cWC2MB(c_str());\r\n            if (C.data())\r\n                return C.data();\r\n            else\r\n                return std::string();\r\n        #else //ZENLIB_USEWX\r\n            #ifdef WINDOWS\r\n                int Size=WideCharToMultiByte(CP_ACP, 0, c_str(), -1, NULL, 0, NULL, NULL);\r\n                if (Size!=0)\r\n                {\r\n                    char* AnsiString=new char[Size+1];\r\n                    WideCharToMultiByte(CP_ACP, 0, c_str(), -1, AnsiString, Size, NULL, NULL);\r\n                    AnsiString[Size]='\\0';\r\n                    std::string ToReturn(AnsiString);\r\n                    delete[] AnsiString; //AnsiString=NULL;\r\n                    return ToReturn;\r\n                }\r\n                else\r\n                    return std::string();\r\n            #else //WINDOWS\r\n                if (empty())\r\n                    return std::string();\r\n\r\n                size_t Size=wcstombs(NULL, c_str(), 0);\r\n                if (Size!=0 && Size!=(size_t)-1)\r\n                {\r\n                    char* AnsiString=new char[Size+1];\r\n                    Size=wcstombs(AnsiString, c_str(), Size);\r\n                    if (Size!=0 && Size!=(size_t)-1)\r\n                    {\r\n                        AnsiString[Size]='\\0';\r\n                        std::string ToReturn(AnsiString);\r\n                        delete[] AnsiString; //AnsiString=NULL;\r\n                        return ToReturn;\r\n                    }\r\n\r\n                    //Failed\r\n                    delete[] AnsiString; //AnsiString=NULL;\r\n                }\r\n\r\n                //Trying with bad chars\r\n                char* Result=new char[MB_CUR_MAX];\r\n                std::string AnsiString;\r\n                for (size_t Pos=0; Pos<size(); Pos++)\r\n                {\r\n                    size_t Result_Size=wcrtomb(Result, operator[](Pos), 0);\r\n                    if (Result_Size && Result_Size!=(size_t)-1)\r\n                        AnsiString.append(Result, Result_Size);\r\n                    else\r\n                        AnsiString+='?';\r\n                }\r\n                delete[] Result; //Result=NULL;\r\n                return AnsiString;\r\n            #endif\r\n        #endif //ZENLIB_USEWX\r\n    #else\r\n        return c_str();\r\n    #endif\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\nint128u Ztring::To_UUID () const\r\n{\r\n    if (size()!=36)\r\n        return 0;\r\n\r\n    Ztring Temp=*this;\r\n\r\n    for (size_t Pos=0; Pos<36; Pos++)\r\n    {\r\n        if ((Temp[Pos]< __T('0') || Temp[Pos]> __T('9'))\r\n         && (Temp[Pos]< __T('A') || Temp[Pos]> __T('F'))\r\n         && (Temp[Pos]< __T('a') || Temp[Pos]> __T('f')))\r\n            return 0;\r\n        if (Temp[Pos]>=__T('A') && Temp[Pos]<=__T('F'))\r\n        {\r\n            Temp[Pos]-=__T('A');\r\n            Temp[Pos]+=__T('9')+1;\r\n        }\r\n        if (Temp[Pos]>=__T('a') && Temp[Pos]<=__T('f'))\r\n        {\r\n            Temp[Pos]-=__T('a');\r\n            Temp[Pos]+=__T('9')+1;\r\n        }\r\n\r\n        switch(Pos)\r\n        {\r\n            case  7 :\r\n            case 12 :\r\n            case 17 :\r\n            case 22 :\r\n                        if (at(Pos+1)!=__T('-'))\r\n                            return 0;\r\n                        Pos++; //Skipping dash in the test\r\n        }\r\n    }\r\n\r\n    int128u I;\r\n    I.hi=((int64u)((int8u)(Temp[ 0]-'0'))<<60)\r\n       | ((int64u)((int8u)(Temp[ 1]-'0'))<<56)\r\n       | ((int64u)((int8u)(Temp[ 2]-'0'))<<52)\r\n       | ((int64u)((int8u)(Temp[ 3]-'0'))<<48)\r\n       | ((int64u)((int8u)(Temp[ 4]-'0'))<<44)\r\n       | ((int64u)((int8u)(Temp[ 5]-'0'))<<40)\r\n       | ((int64u)((int8u)(Temp[ 6]-'0'))<<36)\r\n       | ((int64u)((int8u)(Temp[ 7]-'0'))<<32)\r\n       | ((int64u)((int8u)(Temp[ 9]-'0'))<<28)\r\n       | ((int64u)((int8u)(Temp[10]-'0'))<<24)\r\n       | ((int64u)((int8u)(Temp[11]-'0'))<<20)\r\n       | ((int64u)((int8u)(Temp[12]-'0'))<<16)\r\n       | ((int64u)((int8u)(Temp[14]-'0'))<<12)\r\n       | ((int64u)((int8u)(Temp[15]-'0'))<< 8)\r\n       | ((int64u)((int8u)(Temp[16]-'0'))<< 4)\r\n       | ((int64u)((int8u)(Temp[17]-'0'))    );\r\n    I.lo=((int64u)((int8u)(Temp[19]-'0'))<<60)\r\n       | ((int64u)((int8u)(Temp[20]-'0'))<<56)\r\n       | ((int64u)((int8u)(Temp[21]-'0'))<<52)\r\n       | ((int64u)((int8u)(Temp[22]-'0'))<<48)\r\n       | ((int64u)((int8u)(Temp[24]-'0'))<<44)\r\n       | ((int64u)((int8u)(Temp[25]-'0'))<<40)\r\n       | ((int64u)((int8u)(Temp[26]-'0'))<<36)\r\n       | ((int64u)((int8u)(Temp[27]-'0'))<<32)\r\n       | ((int64u)((int8u)(Temp[28]-'0'))<<28)\r\n       | ((int64u)((int8u)(Temp[29]-'0'))<<24)\r\n       | ((int64u)((int8u)(Temp[30]-'0'))<<20)\r\n       | ((int64u)((int8u)(Temp[31]-'0'))<<16)\r\n       | ((int64u)((int8u)(Temp[32]-'0'))<<12)\r\n       | ((int64u)((int8u)(Temp[33]-'0'))<< 8)\r\n       | ((int64u)((int8u)(Temp[34]-'0'))<< 4)\r\n       | ((int64u)((int8u)(Temp[35]-'0'))    );\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\nint32u Ztring::To_CC4 () const\r\n{\r\n    int32u I;\r\n    I =((int32u)((int8u)at(0))<<24)\r\n     | ((int32u)((int8u)at(1))<<16)\r\n     | ((int32u)((int8u)at(2))<< 8)\r\n     | ((int32u)((int8u)at(3))    );\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint8s Ztring::To_int8s (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi(c_str());\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoi(S.c_str());\r\n        #else //UNICODE\r\n            I=atoi(c_str());\r\n        #endif //UNICODE\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=Error)\r\n    {\r\n        float80 F=To_float80();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return (int8s)I+1;\r\n    }\r\n\r\n    return (int8s)I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint8u Ztring::To_int8u (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    unsigned int I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi64(c_str()); //TODO : I>0x7FFFFFFF - Replaced by i64 version to support, but not good\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoi(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atoi(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=std::string::npos)\r\n    {\r\n        float32 F=To_float32();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return (int8u)I+1;\r\n    }\r\n\r\n    return (int8u)I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint16s Ztring::To_int16s (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi(c_str());\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoi(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atoi(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=Error)\r\n    {\r\n        float80 F=To_float80();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return (int16s)I+1;\r\n    }\r\n\r\n    return (int16s)I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint16u Ztring::To_int16u (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    unsigned int I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi64(c_str()); //TODO : I>0x7FFFFFFF - Replaced by i64 version to support, but not good\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoi(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atoi(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=std::string::npos)\r\n    {\r\n        float32 F=To_float32();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return (int16u)I+1;\r\n    }\r\n\r\n    return (int16u)I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint32s Ztring::To_int32s (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int32s I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi(c_str());\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atol(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atol(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=Error)\r\n    {\r\n        float80 F=To_float80();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return I+1;\r\n    }\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint32u Ztring::To_int32u (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int32u I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi64(c_str()); //TODO : I>0x7FFFFFFF - Replaced by i64 version to support, but not good\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atol(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atol(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=std::string::npos)\r\n    {\r\n        float32 F=To_float32();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return I+1;\r\n    }\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint64s Ztring::To_int64s (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int64s I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi64(c_str());\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoll(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atoll(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=std::string::npos)\r\n    {\r\n        float32 F=To_float32();\r\n        F-=I;\r\n        if (F>0.5f)\r\n            return I+1;\r\n    }\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint64u Ztring::To_int64u (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int64u I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi64(c_str()); //TODO : I>0x7FFFFFFFFFFFFFFF\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoll(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atoll(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=std::string::npos)\r\n    {\r\n        float32 F=To_float32();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return I+1;\r\n    }\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\nint128u Ztring::To_int128u (int8u, ztring_t) const\r\n{\r\n    if (size()!=32)\r\n        return 0;\r\n\r\n    Ztring Temp=*this;\r\n\r\n    for (size_t Pos=0; Pos<32; Pos++)\r\n    {\r\n        if ((Temp[Pos]< __T('0') || Temp[Pos]> __T('9'))\r\n         && (Temp[Pos]< __T('A') || Temp[Pos]> __T('F'))\r\n         && (Temp[Pos]< __T('a') || Temp[Pos]> __T('f')))\r\n            return 0;\r\n        if (Temp[Pos]>=__T('A') && Temp[Pos]<=__T('F'))\r\n        {\r\n            Temp[Pos]-=__T('A');\r\n            Temp[Pos]+=__T('9')+1;\r\n        }\r\n        if (Temp[Pos]>=__T('a') && Temp[Pos]<=__T('f'))\r\n        {\r\n            Temp[Pos]-=__T('a');\r\n            Temp[Pos]+=__T('9')+1;\r\n        }\r\n    }\r\n\r\n    int128u I;\r\n    I.hi=((int64u)((int8u)(Temp[ 0]-'0'))<<60)\r\n       | ((int64u)((int8u)(Temp[ 1]-'0'))<<56)\r\n       | ((int64u)((int8u)(Temp[ 2]-'0'))<<52)\r\n       | ((int64u)((int8u)(Temp[ 3]-'0'))<<48)\r\n       | ((int64u)((int8u)(Temp[ 4]-'0'))<<44)\r\n       | ((int64u)((int8u)(Temp[ 5]-'0'))<<40)\r\n       | ((int64u)((int8u)(Temp[ 6]-'0'))<<36)\r\n       | ((int64u)((int8u)(Temp[ 7]-'0'))<<32)\r\n       | ((int64u)((int8u)(Temp[ 8]-'0'))<<28)\r\n       | ((int64u)((int8u)(Temp[ 9]-'0'))<<24)\r\n       | ((int64u)((int8u)(Temp[10]-'0'))<<20)\r\n       | ((int64u)((int8u)(Temp[11]-'0'))<<16)\r\n       | ((int64u)((int8u)(Temp[12]-'0'))<<12)\r\n       | ((int64u)((int8u)(Temp[13]-'0'))<< 8)\r\n       | ((int64u)((int8u)(Temp[14]-'0'))<< 4)\r\n       | ((int64u)((int8u)(Temp[15]-'0'))    );\r\n    I.lo=((int64u)((int8u)(Temp[16]-'0'))<<60)\r\n       | ((int64u)((int8u)(Temp[17]-'0'))<<56)\r\n       | ((int64u)((int8u)(Temp[18]-'0'))<<52)\r\n       | ((int64u)((int8u)(Temp[19]-'0'))<<48)\r\n       | ((int64u)((int8u)(Temp[20]-'0'))<<44)\r\n       | ((int64u)((int8u)(Temp[21]-'0'))<<40)\r\n       | ((int64u)((int8u)(Temp[22]-'0'))<<36)\r\n       | ((int64u)((int8u)(Temp[23]-'0'))<<32)\r\n       | ((int64u)((int8u)(Temp[24]-'0'))<<28)\r\n       | ((int64u)((int8u)(Temp[25]-'0'))<<24)\r\n       | ((int64u)((int8u)(Temp[26]-'0'))<<20)\r\n       | ((int64u)((int8u)(Temp[27]-'0'))<<16)\r\n       | ((int64u)((int8u)(Temp[28]-'0'))<<12)\r\n       | ((int64u)((int8u)(Temp[29]-'0'))<< 8)\r\n       | ((int64u)((int8u)(Temp[30]-'0'))<< 4)\r\n       | ((int64u)((int8u)(Temp[31]-'0'))    );\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToFloat\r\nfloat32 Ztring::To_float32(ztring_t) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef UNICODE\r\n            return (wcstod(c_str(),NULL));\r\n        #else\r\n            return (strtod(c_str(),NULL));\r\n        #endif\r\n    #else\r\n        float32 F;\r\n        tStringStream Stream(*this);\r\n        Stream >> F;\r\n        if (Stream.fail())\r\n            return 0;\r\n\r\n        return F;\r\n    #endif\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToFloat\r\nfloat64 Ztring::To_float64(ztring_t) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef UNICODE\r\n            return (wcstod(c_str(),NULL)); //TODO verify no wcstold\r\n        #else\r\n            return (strtod(c_str(),NULL)); //TODO verify no strtold\r\n        #endif\r\n    #else\r\n        float64 F;\r\n        tStringStream Stream(*this);\r\n        Stream >> F;\r\n        if (Stream.fail())\r\n            return 0;\r\n\r\n        return F;\r\n    #endif\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToFloat\r\nfloat80 Ztring::To_float80(ztring_t) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef UNICODE\r\n            return (wcstod(c_str(),NULL)); //TODO verify no wcstold\r\n        #else\r\n            return (strtod(c_str(),NULL)); //TODO verify no strtold\r\n        #endif\r\n    #else\r\n        float80 F;\r\n        tStringStream Stream(*this);\r\n        Stream >> F;\r\n        if (Stream.fail())\r\n            return 0;\r\n\r\n        return F;\r\n    #endif\r\n}\r\n\r\n//***************************************************************************\r\n// Edition\r\n//***************************************************************************\r\n\r\n//---------------------------------------------------------------------------\r\n// Retourne une partie de la chaine\r\nZtring Ztring::SubString (const tstring &Begin, const tstring &End, size_type Pos, ztring_t Options) const\r\n{\r\n    //Recherche Debut\r\n    size_type I_Debut=find(Begin, Pos);\r\n    if (I_Debut==Error)\r\n        return Ztring();\r\n    I_Debut+=Begin.size();\r\n\r\n    //gestion fin NULL\r\n    if (End.empty())\r\n        return substr(I_Debut);\r\n\r\n    //Recherche Fin\r\n    size_type I_Fin=find(End, I_Debut);\r\n    if (I_Fin==Error)\r\n    {\r\n        if (Options & Ztring_AddLastItem)\r\n            return substr(I_Debut);\r\n        else\r\n            return Ztring();\r\n    }\r\n\r\n    return substr(I_Debut, I_Fin-I_Debut);\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//FindAndReplace\r\nZtring::size_type Ztring::FindAndReplace (const ZenLib::tstring &ToFind, const ZenLib::tstring &ReplaceBy, size_type Pos, ZenLib::ztring_t Options)\r\n{\r\n    if (ToFind.empty())\r\n        return 0;\r\n\r\n    size_type Count=0;\r\n    size_type Middle=Pos;\r\n    while (!(Count==1 && !(Options&Ztring_Recursive)) && (Middle=find(ToFind, Middle))!=npos)\r\n    {\r\n        replace(Middle, ToFind.length(), ReplaceBy);\r\n        Middle += ReplaceBy.length();\r\n        Count++;\r\n    }\r\n\r\n    return Count;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//test if it is a number\r\nbool Ztring::IsNumber() const\r\n{\r\n    if (empty())\r\n        return false;\r\n\r\n    bool OK=true;\r\n    size_t Size=size();\r\n    for (size_t Pos=0; Pos<Size; Pos++)\r\n        if (operator[](Pos)<__T('0') || operator[](Pos)>__T('9'))\r\n        {\r\n            OK=false;\r\n            break;\r\n        }\r\n    return OK;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Mise en minuscules\r\nZtring &Ztring::MakeLowerCase()\r\n{\r\n    transform(begin(), end(), begin(), (int(*)(int))tolower); //(int(*)(int)) is a patch for unix\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Mise en majuscules\r\nZtring &Ztring::MakeUpperCase()\r\n{\r\n    transform(begin(), end(), begin(), (int(*)(int))toupper); //(int(*)(int)) is a patch for unix\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Remove leading whitespaces from a string\r\nZtring &Ztring::TrimLeft(Char ToTrim)\r\n{\r\n    size_type First=0;\r\n    while (First<size() && operator[](First)==ToTrim)\r\n        First++;\r\n    assign (c_str()+First);\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Remove trailing whitespaces from a string\r\nZtring &Ztring::TrimRight(Char ToTrim)\r\n{\r\n    if (size()==0)\r\n        return *this;\r\n\r\n    size_type Last=size()-1;\r\n    while (Last!=(size_type)-1 && operator[](Last)==ToTrim)\r\n        Last--;\r\n    assign (c_str(), Last+1);\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Remove leading and trailing whitespaces from a string\r\nZtring &Ztring::Trim(Char ToTrim)\r\n{\r\n    TrimLeft(ToTrim);\r\n    TrimRight(ToTrim);\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Quotes a string\r\nZtring &Ztring::Quote(Char ToTrim)\r\n{\r\n    assign(tstring(1, ToTrim)+c_str()+ToTrim);\r\n    return *this;\r\n}\r\n\r\n//***************************************************************************\r\n// Information\r\n//***************************************************************************\r\n\r\n//---------------------------------------------------------------------------\r\n//Count\r\nZtring::size_type Ztring::Count (const Ztring &ToCount, ztring_t) const\r\n{\r\n    size_type Count=0;\r\n    for (size_type Pos=0; Pos<=size(); Pos++)\r\n        if (find(ToCount, Pos)!=npos)\r\n        {\r\n            Count++;\r\n            Pos+=ToCount.size()-1; //-1 because the loop will add 1\r\n        }\r\n    return Count;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Compare\r\nbool Ztring::Compare (const Ztring &ToCompare, const Ztring &Comparator, ztring_t Options) const\r\n{\r\n    //Integers management\r\n    if (IsNumber() && ToCompare.IsNumber())\r\n    {\r\n        int64s Left=To_int64s();\r\n        int64s Right=ToCompare.To_int64s();\r\n        if (Comparator==__T(\"==\")) return (Left==Right);\r\n        if (Comparator==__T(\"<\"))  return (Left< Right);\r\n        if (Comparator==__T(\"<=\")) return (Left<=Right);\r\n        if (Comparator==__T(\">=\")) return (Left>=Right);\r\n        if (Comparator==__T(\">\"))  return (Left> Right);\r\n        if (Comparator==__T(\"!=\")) return (Left!=Right);\r\n        if (Comparator==__T(\"<>\")) return (Left!=Right);\r\n        return false;\r\n    }\r\n\r\n    //Case sensitive option\r\n    if (!(Options & Ztring_CaseSensitive))\r\n    {\r\n        //Need to copy strings and make it lowercase\r\n        Ztring Left (c_str());\r\n        Ztring Right (ToCompare.c_str());\r\n        Left.MakeLowerCase();\r\n        Right.MakeLowerCase();\r\n\r\n        //string comparasion\r\n        if (Comparator==__T(\"==\")) return (Left==Right);\r\n        if (Comparator==__T(\"IN\")) {if (Left.find(Right)!=string::npos) return true; else return false;}\r\n        if (Comparator==__T(\"<\"))  return (Left< Right);\r\n        if (Comparator==__T(\"<=\")) return (Left<=Right);\r\n        if (Comparator==__T(\">=\")) return (Left>=Right);\r\n        if (Comparator==__T(\">\"))  return (Left> Right);\r\n        if (Comparator==__T(\"!=\")) return (Left!=Right);\r\n        if (Comparator==__T(\"<>\")) return (Left!=Right);\r\n        return false;\r\n    }\r\n    else\r\n    {\r\n        //string comparasion\r\n        if (Comparator==__T(\"==\")) return (*this==ToCompare);\r\n        if (Comparator==__T(\"IN\")) {if (this->find(ToCompare)!=string::npos) return true; else return false;}\r\n        if (Comparator==__T(\"<\"))  return (*this< ToCompare);\r\n        if (Comparator==__T(\"<=\")) return (*this<=ToCompare);\r\n        if (Comparator==__T(\">=\")) return (*this>=ToCompare);\r\n        if (Comparator==__T(\">\"))  return (*this> ToCompare);\r\n        if (Comparator==__T(\"!=\")) return (*this!=ToCompare);\r\n        if (Comparator==__T(\"<>\")) return (*this!=ToCompare);\r\n        return false;\r\n    }\r\n}\r\n\r\n} //namespace\r\n"], "fixing_code": ["/*  Copyright (c) MediaArea.net SARL. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a zlib-style license that can\r\n *  be found in the License.txt file in the root of the source tree.\r\n */\r\n\r\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n//\r\n// More methods for std::(w)string\r\n//\r\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\r\n//---------------------------------------------------------------------------\r\n#include \"ZenLib/PreComp.h\"\r\n#ifdef __BORLANDC__\r\n    #pragma hdrstop\r\n#endif\r\n//---------------------------------------------------------------------------\r\n\r\n//---------------------------------------------------------------------------\r\n#include \"ZenLib/Conf_Internal.h\"\r\n//---------------------------------------------------------------------------\r\n\r\n//---------------------------------------------------------------------------\r\n#ifdef ZENLIB_USEWX\r\n    #include <wx/strconv.h>\r\n    #include <wx/datetime.h>\r\n#else //ZENLIB_USEWX\r\n    #ifdef ZENLIB_STANDARD\r\n        #undef WINDOWS\r\n    #endif\r\n    #ifdef WINDOWS\r\n        #undef __TEXT\r\n        #include <windows.h>\r\n        #include <tchar.h>\r\n    #endif\r\n#endif //ZENLIB_USEWX\r\n#ifdef __MINGW32__\r\n    #include <windows.h>\r\n#endif //__MINGW32__\r\n#include <algorithm>\r\n#include <iomanip>\r\n#include <cmath>\r\n#include <ctime>\r\n#include \"ZenLib/OS_Utils.h\"\r\n#include \"ZenLib/File.h\"\r\nusing namespace std;\r\n//---------------------------------------------------------------------------\r\n\r\nnamespace ZenLib\r\n{\r\n\r\nint16u Ztring_ISO_8859_2[96]=\r\n{\r\n    0x00A0,\r\n    0x0104,\r\n    0x02D8,\r\n    0x0141,\r\n    0x00A4,\r\n    0x013D,\r\n    0x015A,\r\n    0x00A7,\r\n    0x00A8,\r\n    0x0160,\r\n    0x015E,\r\n    0x0164,\r\n    0x0179,\r\n    0x00AD,\r\n    0x017D,\r\n    0x017B,\r\n    0x00B0,\r\n    0x0105,\r\n    0x02DB,\r\n    0x0142,\r\n    0x00B4,\r\n    0x013E,\r\n    0x015B,\r\n    0x02C7,\r\n    0x00B8,\r\n    0x0161,\r\n    0x015F,\r\n    0x0165,\r\n    0x017A,\r\n    0x02DD,\r\n    0x017E,\r\n    0x017C,\r\n    0x0154,\r\n    0x00C1,\r\n    0x00C2,\r\n    0x0102,\r\n    0x00C4,\r\n    0x0139,\r\n    0x0106,\r\n    0x00C7,\r\n    0x010C,\r\n    0x00C9,\r\n    0x0118,\r\n    0x00CB,\r\n    0x011A,\r\n    0x00CD,\r\n    0x00CE,\r\n    0x010E,\r\n    0x0110,\r\n    0x0143,\r\n    0x0147,\r\n    0x00D3,\r\n    0x00D4,\r\n    0x0150,\r\n    0x00D6,\r\n    0x00D7,\r\n    0x0158,\r\n    0x016E,\r\n    0x00DA,\r\n    0x0170,\r\n    0x00DC,\r\n    0x00DD,\r\n    0x0162,\r\n    0x00DF,\r\n    0x0155,\r\n    0x00E1,\r\n    0x00E2,\r\n    0x0103,\r\n    0x00E4,\r\n    0x013A,\r\n    0x0107,\r\n    0x00E7,\r\n    0x010D,\r\n    0x00E9,\r\n    0x0119,\r\n    0x00EB,\r\n    0x011B,\r\n    0x00ED,\r\n    0x00EE,\r\n    0x010F,\r\n    0x0111,\r\n    0x0144,\r\n    0x0148,\r\n    0x00F3,\r\n    0x00F4,\r\n    0x0151,\r\n    0x00F6,\r\n    0x00F7,\r\n    0x0159,\r\n    0x016F,\r\n    0x00FA,\r\n    0x0171,\r\n    0x00FC,\r\n    0x00FD,\r\n    0x0163,\r\n    0x02D9,\r\n};\r\n\r\n//---------------------------------------------------------------------------\r\nZtring EmptyZtring;\r\n//---------------------------------------------------------------------------\r\n\r\n//---------------------------------------------------------------------------\r\n#if defined(STREAM_MISSING)\r\n    #if defined (_UNICODE)\r\n        #if defined (MACOS) || defined (MACOSX)\r\n            #define _tnprintf swprintf\r\n        #else\r\n            #define _tnprintf snwprintf\r\n        #endif\r\n    #else\r\n        #define _tnprintf snprintf\r\n    #endif\r\n#else\r\n    typedef basic_stringstream<Char>  tStringStream;\r\n    typedef basic_istringstream<Char> tiStringStream;\r\n    typedef basic_ostringstream<Char> toStringStream;\r\n#endif\r\n//---------------------------------------------------------------------------\r\n\r\n//***************************************************************************\r\n// Operators\r\n//***************************************************************************\r\n\r\nChar &Ztring::operator() (size_type Pos)\r\n{\r\n    if (Pos>size())\r\n        resize(Pos);\r\n    return operator[] (Pos);\r\n}\r\n\r\n//***************************************************************************\r\n// Assign\r\n//***************************************************************************\r\n\r\nbool Ztring::Assign_FromFile (const Ztring &FileName)\r\n{\r\n    File F;\r\n    if (!F.Open(FileName))\r\n        return false;\r\n    int64u F_Size=F.Size_Get();\r\n    if (F_Size>((size_t)-1)-1)\r\n        return false;\r\n\r\n    //Creating buffer\r\n    int8u* Buffer=new int8u[(size_t)F_Size+1];\r\n    size_t Buffer_Offset=0;\r\n\r\n    //Reading the file\r\n    while(Buffer_Offset<F_Size)\r\n    {\r\n        size_t BytesRead=F.Read(Buffer+Buffer_Offset, (size_t)F_Size-Buffer_Offset);\r\n        if (BytesRead==0)\r\n            break; //Read is finished\r\n        Buffer_Offset+=BytesRead;\r\n    }\r\n    if (Buffer_Offset<F_Size)\r\n    {\r\n        delete[] Buffer;\r\n        return false;\r\n    }\r\n    Buffer[Buffer_Offset]='\\0';\r\n\r\n    //Filling\r\n    assign((const Char*)Buffer);\r\n    delete[] Buffer;\r\n\r\n    return true;\r\n}\r\n\r\n//***************************************************************************\r\n// Conversions\r\n//***************************************************************************\r\n\r\nZtring& Ztring::From_Unicode (const wchar_t S)\r\n{\r\n    #ifdef _UNICODE\r\n        append(1, S);\r\n    #else\r\n        From_Unicode(&S, 1);\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Unicode (const wchar_t* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    #ifdef _UNICODE\r\n        assign(S);\r\n    #else\r\n        #ifdef ZENLIB_USEWX\r\n            size_type OK=wxConvCurrent->WC2MB(NULL, S, 0);\r\n            if (OK!=0 && OK!=Error)\r\n                assign(wxConvCurrent->cWC2MB(S));\r\n        #else //ZENLIB_USEWX\r\n            #ifdef WINDOWS\r\n                int Size=WideCharToMultiByte(CP_UTF8, 0, S, -1, NULL, 0, NULL, NULL);\r\n                if (Size!=0)\r\n                {\r\n                    char* AnsiString=new char[Size+1];\r\n                    WideCharToMultiByte(CP_UTF8, 0, S, -1, AnsiString, Size, NULL, NULL);\r\n                    AnsiString[Size]='\\0';\r\n                    assign (AnsiString);\r\n                    delete[] AnsiString;\r\n                }\r\n                else\r\n                    clear();\r\n            #else //WINDOWS\r\n                size_t Size=wcstombs(NULL, S, 0);\r\n                if (Size!=0 && Size!=(size_t)-1)\r\n                {\r\n                    char* AnsiString=new char[Size+1];\r\n                    Size=wcstombs(AnsiString, S, wcslen(S));\r\n                    AnsiString[Size]='\\0';\r\n                    assign (AnsiString);\r\n                    delete[] AnsiString;\r\n                }\r\n                else\r\n                    clear();\r\n            #endif\r\n        #endif //ZENLIB_USEWX\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Unicode (const wchar_t *S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n        Length=wcslen(S+Start);\r\n    wchar_t* Temp=new wchar_t[Length+1];\r\n    wcsncpy (Temp, S+Start, Length);\r\n    Temp[Length]=__T('\\0');\r\n\r\n    From_Unicode(Temp);\r\n    delete[] Temp; //Temp=NULL;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF8 (const char* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    #ifdef ZENLIB_USEWX\r\n        size_type OK=wxConvUTF8.MB2WC(NULL, S, 0);\r\n        if (OK!=0 && OK!=Error)\r\n            #ifdef _UNICODE\r\n                assign(wxConvUTF8.cMB2WC(S).data());\r\n            #else\r\n                assign(wxConvCurrent->cWC2MB(wxConvUTF8.cMB2WC(S)));\r\n            #endif\r\n    #else //ZENLIB_USEWX\r\n        #ifdef _UNICODE\r\n            // Don't use MultiByteToWideChar(), some characters are not well decoded\r\n            clear();\r\n            const int8u* Z=(const int8u*)S;\r\n            while (*Z) //0 is end\r\n            {\r\n                //1 byte\r\n                if (*Z<0x80)\r\n                {\r\n                    operator += ((wchar_t)(*Z));\r\n                    Z++;\r\n                }\r\n                //2 bytes\r\n                else if ((*Z&0xE0)==0xC0)\r\n                {\r\n                    if ((*(Z+1)&0xC0)==0x80)\r\n                    {\r\n                        operator += ((((wchar_t)(*Z&0x1F))<<6)|(*(Z+1)&0x3F));\r\n                        Z+=2;\r\n                    }\r\n                    else\r\n                    {\r\n                        clear();\r\n                        return *this; //Bad character\r\n                    }\r\n                }\r\n                //3 bytes\r\n                else if ((*Z&0xF0)==0xE0)\r\n                {\r\n                    if ((*(Z+1)&0xC0)==0x80 && (*(Z+2)&0xC0)==0x80)\r\n                    {\r\n                        operator += ((((wchar_t)(*Z&0x0F))<<12)|((*(Z+1)&0x3F)<<6)|(*(Z+2)&0x3F));\r\n                        Z+=3;\r\n                    }\r\n                    else\r\n                    {\r\n                        clear();\r\n                        return *this; //Bad character\r\n                    }\r\n                }\r\n                //4 bytes\r\n                else if ((*Z&0xF8)==0xF0)\r\n                {\r\n                    if ((*(Z+1)&0xC0)==0x80 && (*(Z+2)&0xC0)==0x80 && (*(Z+3)&0xC0)==0x80)\r\n                    {\r\n                        #if defined(_MSC_VER)\r\n                            #pragma warning(push)\r\n                            #pragma warning(disable:4127)\r\n                        #endif //defined(_MSC_VER)\r\n                        if (sizeof(wchar_t) == 2)\r\n                        #if defined(_MSC_VER)\r\n                            #pragma warning(pop)\r\n                        #endif //defined(_MSC_VER)\r\n                        {\r\n                            int32u Value = ((((int32u)(*Z&0x0F))<<18)|((*(Z+1)&0x3F)<<12)|((*(Z+2)&0x3F)<<6)|(*(Z+3)&0x3F));\r\n                            operator += (0xD800|((Value>>10)-0x40));\r\n                            operator += (0xDC00| (Value&0x3FF));\r\n                        }\r\n                        else\r\n                            operator += ((((wchar_t)(*Z&0x0F))<<18)|((*(Z+1)&0x3F)<<12)|((*(Z+2)&0x3F)<<6)|(*(Z+3)&0x3F));\r\n                        Z+=4;\r\n                    }\r\n                    else\r\n                    {\r\n                        clear();\r\n                        return *this; //Bad character\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    clear();\r\n                    return *this; //Bad character\r\n                }\r\n            }\r\n        #else\r\n            assign(S); //Not implemented\r\n        #endif\r\n    #endif //ZENLIB_USEWX\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF8 (const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n        Length=strlen(S+Start);\r\n    char* Temp=new char[Length+1];\r\n    strncpy (Temp, S+Start, Length);\r\n    Temp[Length]='\\0';\r\n\r\n    From_UTF8(Temp);\r\n    delete[] Temp; //Temp=NULL;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF16 (const char* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n         if ((unsigned char)S[0]==(unsigned char)0xFF && (unsigned char)S[1]==(unsigned char)0xFE)\r\n        return From_UTF16LE(S+2);\r\n    else if ((unsigned char)S[0]==(unsigned char)0xFE && (unsigned char)S[1]==(unsigned char)0xFF)\r\n        return From_UTF16BE(S+2);\r\n    else if ((unsigned char)S[0]==(unsigned char)0x00 && (unsigned char)S[1]==(unsigned char)0x00)\r\n    {\r\n        clear(); //No begin!\r\n        return *this;\r\n    }\r\n    else\r\n        return From_UTF16LE(S); //Not sure, default\r\n}\r\n\r\nZtring& Ztring::From_UTF16 (const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length<2)\r\n        return *this;\r\n\r\n         if ((unsigned char)S[0]==(unsigned char)0xFF && (unsigned char)S[1]==(unsigned char)0xFE)\r\n        return From_UTF16LE(S+2, Start, Length-2);\r\n    else if ((unsigned char)S[0]==(unsigned char)0xFE && (unsigned char)S[1]==(unsigned char)0xFF)\r\n        return From_UTF16BE(S+2, Start, Length-2);\r\n    else if ((unsigned char)S[0]==(unsigned char)0x00 && (unsigned char)S[1]==(unsigned char)0x00)\r\n    {\r\n        clear(); //No begin!\r\n        return *this;\r\n    }\r\n    else\r\n        return From_UTF16LE(S, Start, Length); //Not sure, default\r\n}\r\n\r\nZtring& Ztring::From_UTF16BE (const char* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    #ifdef ZENLIB_USEWX\r\n        //clear(); return *this;\r\n        wxMBConvUTF16BE wxConvUTF16BE;\r\n        size_type OK=wxConvUTF16BE.MB2WC(NULL, S, 0);\r\n        if (OK!=0 && OK!=Error)\r\n            #ifdef _UNICODE\r\n                assign(wxConvUTF16BE.cMB2WC(S).data());\r\n            #else\r\n                assign(wxConvCurrent->cWC2MB(wxConvUTF16BE.cMB2WC(S)));\r\n            #endif\r\n    #else //ZENLIB_USEWX\r\n        #ifdef WINDOWS\r\n            clear();\r\n            const wchar_t* SW=(const wchar_t*)S;\r\n            size_t Pos=0;\r\n            while (SW[Pos]!=__T('\\0'))\r\n            {\r\n                Char Temp=(Char)(((SW[Pos]&0xFF00)>>8)+((SW[Pos]&0x00FF)<<8));\r\n                append(1, Temp);\r\n                Pos++;\r\n            }\r\n        #else //WINDOWS\r\n            clear();\r\n            while (S[0]!=0 || S[1]!=0)\r\n            {\r\n                append(1, (Char)BigEndian2int16u(S));\r\n                S+=2;\r\n            }\r\n        #endif\r\n    #endif //ZENLIB_USEWX\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF16BE (const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n    {\r\n        Length=0;\r\n        while(S[Length]!=0x0000)\r\n            Length++;\r\n    }\r\n    else\r\n        Length&=(size_t)-2; //odd number\r\n\r\n    char* Temp=new char[Length+2];\r\n    memcpy (Temp, S+Start, Length);\r\n    Temp[Length+0]=0x00;\r\n    Temp[Length+1]=0x00;\r\n    reserve(Length);\r\n    From_UTF16BE(Temp);\r\n    delete[] Temp; //Temp=NULL;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF16LE (const char* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    #ifdef ZENLIB_USEWX\r\n        //clear(); return *this;\r\n        wxMBConvUTF16LE wxConvUTF16LE;\r\n        size_type OK=wxConvUTF16LE.MB2WC(NULL, S, 0);\r\n        if (OK!=0 && OK!=Error)\r\n            #ifdef _UNICODE\r\n                assign(wxConvUTF16LE.cMB2WC(S).data());\r\n            #else\r\n                assign(wxConvCurrent->cWC2MB(wxConvUTF16LE.cMB2WC(S)));\r\n            #endif\r\n    #else //ZENLIB_USEWX\r\n        #ifdef WINDOWS\r\n            #ifdef UNICODE\r\n                const wchar_t* SW=(const wchar_t*)S;\r\n                assign(SW);\r\n            #else\r\n                clear(); //Not implemented\r\n            #endif\r\n        #else //WINDOWS\r\n            clear();\r\n            while (S[0]!=0 || S[1]!=0)\r\n            {\r\n                append(1, (Char)LittleEndian2int16u(S));\r\n                S+=2;\r\n            }\r\n        #endif\r\n    #endif //ZENLIB_USEWX\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UTF16LE (const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n    {\r\n        Length=0;\r\n        while(S[Length]!=0x0000)\r\n            Length+=2;\r\n    }\r\n    else\r\n        Length&=(size_t)-2; //odd number\r\n\r\n    char* Temp=new char[Length+2];\r\n    memcpy (Temp, S+Start, Length);\r\n    Temp[Length+0]=0x00;\r\n    Temp[Length+1]=0x00;\r\n    From_UTF16LE(Temp);\r\n    delete[] Temp; //Temp=NULL;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Local (const char* S)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    #ifdef _UNICODE\r\n        #ifdef ZENLIB_USEWX\r\n            size_type OK=wxConvCurrent->MB2WC(NULL, S, 0);\r\n            if (OK!=0 && OK!=Error)\r\n                assign(wxConvCurrent->cMB2WC(S).data());\r\n        #else //ZENLIB_USEWX\r\n            #ifdef WINDOWS\r\n                int Size=MultiByteToWideChar(CP_ACP, 0, S, -1, NULL, 0);\r\n                if (Size!=0)\r\n                {\r\n                    wchar_t* WideString=new wchar_t[Size+1];\r\n                    MultiByteToWideChar(CP_ACP, 0, S, -1, WideString, Size);\r\n                    WideString[Size]=L'\\0';\r\n                    assign (WideString);\r\n                    delete[] WideString; //WideString=NULL;\r\n                }\r\n                else\r\n                    clear();\r\n            #else //WINDOWS\r\n                size_t Size=mbsrtowcs(NULL, &S, 0, NULL);\r\n                if (Size!=0 && Size!=(size_t)-1)\r\n                {\r\n                    wchar_t* WideString=new wchar_t[Size+1];\r\n                    Size=mbsrtowcs(WideString, &S, Size, NULL);\r\n                    WideString[Size]=L'\\0';\r\n                    assign (WideString);\r\n                    delete[] WideString; //WideString=NULL;\r\n                }\r\n                else\r\n                    clear();\r\n            #endif\r\n        #endif //ZENLIB_USEWX\r\n    #else\r\n        assign(S);\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Local (const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n        Length=strlen(S+Start);\r\n    #ifdef _UNICODE\r\n        char* Temp=new char[Length+1];\r\n        strncpy (Temp, S+Start, Length);\r\n        Temp[Length]='\\0';\r\n        From_Local(Temp);\r\n        delete[] Temp; //Temp=NULL;\r\n    #else\r\n        assign(S+Start, Length);\r\n        if (find(__T('\\0'))!=std::string::npos)\r\n            resize(find(__T('\\0')));\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_ISO_8859_1(const char* S)\r\n{\r\n    size_t Length = strlen(S);\r\n    wchar_t* Temp = new wchar_t[Length +1];\r\n\r\n    for (size_t Pos=0; Pos<Length+1; Pos++)\r\n        Temp[Pos]=(wchar_t)((int8u)S[Pos]);\r\n\r\n    From_Unicode(Temp);\r\n    delete[] Temp;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_ISO_8859_1(const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n        Length=strlen(S+Start);\r\n    #ifdef _UNICODE\r\n        char* Temp = new char[Length+1];\r\n        strncpy(Temp, S +Start, Length);\r\n        Temp[Length] = '\\0';\r\n        From_ISO_8859_1(Temp);\r\n        delete[] Temp;\r\n    #else\r\n        assign(S +Start, Length);\r\n        if (find(__T('\\0')) != std::string::npos)\r\n            resize(find(__T('\\0')));\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_ISO_8859_2(const char* S)\r\n{\r\n    size_t Length = strlen(S);\r\n    wchar_t* Temp = new wchar_t[Length +1];\r\n\r\n    for (size_t Pos=0; Pos<Length+1; Pos++)\r\n    {\r\n        if ((int8u)S[Pos]>=0xA0)\r\n            Temp[Pos]=(wchar_t)Ztring_ISO_8859_2[((int8u)S[Pos])-0xA0];\r\n        else\r\n            Temp[Pos]=(wchar_t)((int8u)S[Pos]);\r\n    }\r\n\r\n    From_Unicode(Temp);\r\n    delete[] Temp;\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_ISO_8859_2(const char* S, size_type Start, size_type Length)\r\n{\r\n    if (S==NULL)\r\n        return *this;\r\n\r\n    if (Length==Error)\r\n        Length=strlen(S+Start);\r\n    #ifdef _UNICODE\r\n        char* Temp = new char[Length+1];\r\n        strncpy(Temp, S +Start, Length);\r\n        Temp[Length] = '\\0';\r\n        From_ISO_8859_2(Temp);\r\n        delete[] Temp;\r\n    #else\r\n        assign(S +Start, Length);\r\n        if (find(__T('\\0')) != std::string::npos)\r\n            resize(find(__T('\\0')));\r\n    #endif\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_GUID (const int128u S)\r\n{\r\n    Ztring S1;\r\n    S1.From_CC1((int8u) ((S.hi&0x000000FF00000000LL)>>32)); append(S1);\r\n    S1.From_CC1((int8u) ((S.hi&0x0000FF0000000000LL)>>40)); append(S1);\r\n    S1.From_CC1((int8u) ((S.hi&0x00FF000000000000LL)>>48)); append(S1);\r\n    S1.From_CC1((int8u) ((S.hi&0xFF00000000000000LL)>>56)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC1((int8u) ((S.hi&0x0000000000FF0000LL)>>16)); append(S1);\r\n    S1.From_CC1((int8u) ((S.hi&0x00000000FF000000LL)>>24)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC1((int8u) ( S.hi&0x00000000000000FFLL     )); append(S1);\r\n    S1.From_CC1((int8u) ((S.hi&0x000000000000FF00LL)>> 8)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)((S.lo&0xFFFF000000000000LL)>>48)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)((S.lo&0x0000FFFF00000000LL)>>32)); append(S1);\r\n    S1.From_CC2((int16u)((S.lo&0x00000000FFFF0000LL)>>16)); append(S1);\r\n    S1.From_CC2((int16u)( S.lo&0x000000000000FFFFLL     )); append(S1);\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_UUID (const int128u S)\r\n{\r\n    Ztring S1;\r\n    S1.From_CC2((int16u)((S.hi&0xFFFF000000000000LL)>>48)); assign(S1);\r\n    S1.From_CC2((int16u)((S.hi&0x0000FFFF00000000LL)>>32)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)((S.hi&0x00000000FFFF0000LL)>>16)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)( S.hi&0x000000000000FFFFLL     )); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)((S.lo&0xFFFF000000000000LL)>>48)); append(S1); append(__T(\"-\"));\r\n    S1.From_CC2((int16u)((S.lo&0x0000FFFF00000000LL)>>32)); append(S1);\r\n    S1.From_CC2((int16u)((S.lo&0x00000000FFFF0000LL)>>16)); append(S1);\r\n    S1.From_CC2((int16u)( S.lo&0x000000000000FFFFLL     )); append(S1);\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_CC4 (const int32u S)\r\n{\r\n    clear();\r\n    for (int8s i=(4-1)*8; i>=0; i-=8)\r\n    {\r\n        int32u Value=(S&(0xFF<<i))>>i;\r\n        if (Value<0x20)\r\n        {\r\n            if (!i || (i!=24  && !(S&(0xFFFFFFFF>>(32-i)))))\r\n                return *this; // Trailing 0 are fine\r\n\r\n            // Not valid, using 0x as fallback\r\n            clear();\r\n            append(__T(\"0x\"));\r\n            append(Ztring().From_CC1((int8u)((S&0xFF000000)>>24)));\r\n            append(Ztring().From_CC1((int8u)((S&0x00FF0000)>>16)));\r\n            append(Ztring().From_CC1((int8u)((S&0x0000FF00)>> 8)));\r\n            append(Ztring().From_CC1((int8u)((S&0x000000FF)    )));\r\n            return *this;\r\n        }\r\n        append(1, (Char)(Value));\r\n    }\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_CC3 (const int32u S)\r\n{\r\n    clear();\r\n    for (int8s i=(3-1)*8; i>=0; i-=8)\r\n    {\r\n        int32u Value=(S&(0xFF<<i))>>i;\r\n        if (Value<0x20)\r\n        {\r\n            if (!i || (i!=16  && !(S&(0xFFFFFF>>(24-i)))))\r\n                return *this; // Trailing 0 are fine\r\n\r\n            // Not valid, using 0x as fallback\r\n            clear();\r\n            append(__T(\"0x\"));\r\n            append(Ztring().From_CC1((int8u)((S&0x00FF0000)>>16)));\r\n            append(Ztring().From_CC1((int8u)((S&0x0000FF00)>> 8)));\r\n            append(Ztring().From_CC1((int8u)((S&0x000000FF)    )));\r\n            return *this;\r\n        }\r\n        append(1, (Char)(Value));\r\n    }\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_CC2 (const int16u S)\r\n{\r\n    clear();\r\n    Ztring Pos1; Pos1.From_Number(S, 16);\r\n    resize(4-Pos1.size(), __T('0'));\r\n    append(Pos1);\r\n    MakeUpperCase();\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_CC1 (const int8u S)\r\n{\r\n    clear();\r\n    Ztring Pos1; Pos1.From_Number(S, 16);\r\n    resize(2-Pos1.size(), __T('0'));\r\n    append(Pos1);\r\n    MakeUpperCase();\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int8s I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _itot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%d\"):(Radix==16?__T(\"%x\"):(Radix==8?__T(\"%o\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        toStringStream Stream;\r\n        #ifdef UNICODE\r\n            Stream << setbase(Radix) << I;\r\n        #else //UNICODE\r\n            Stream << setbase(Radix) << (size_t)I; //On linux (at least), (un)signed char is detected as a char\r\n        #endif //UNICODE\r\n        assign(Stream.str());\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int8u I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _ultot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%d\"):(Radix==16?__T(\"%x\"):(Radix==8?__T(\"%o\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        if (Radix==2)\r\n        {\r\n            clear();\r\n            for (int8u Pos=0; Pos<8; Pos++)\r\n            {\r\n                if (I<(((int8u)1)<<Pos))\r\n                    break;\r\n                insert(0, 1, (I&(((int8u)1)<<Pos))?__T('1'):__T('0'));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            toStringStream Stream;\r\n            #ifdef UNICODE\r\n                Stream << setbase(Radix) << I;\r\n            #else //UNICODE\r\n                Stream << setbase(Radix) << (size_t)I; //On linux (at least), (un)signed char is detected as a char\r\n            #endif //UNICODE\r\n            assign(Stream.str());\r\n        }\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int16s I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _itot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%d\"):(Radix==16?__T(\"%x\"):(Radix==8?__T(\"%o\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setbase(Radix) << I;\r\n        assign(Stream.str());\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int16u I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _ultot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%u\"):(Radix==16?__T(\"%x\"):(Radix==8?__T(\"%o\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        if (Radix==2)\r\n        {\r\n            clear();\r\n            for (int8u Pos=0; Pos<16; Pos++)\r\n            {\r\n                if (I<(((int16u)1)<<Pos))\r\n                    break;\r\n                insert(0, 1, (I&(((int16u)1)<<Pos))?__T('1'):__T('0'));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            toStringStream Stream;\r\n            Stream << setbase(Radix) << I;\r\n            assign(Stream.str());\r\n        }\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int32s I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _itot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%ld\"):(Radix==16?__T(\"%lx\"):(Radix==8?__T(\"%lo\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setbase(Radix) << I;\r\n        assign(Stream.str());\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int32u I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[33];\r\n        #ifdef __MINGW32__\r\n            _ultot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 32, Radix==10?__T(\"%lu\"):(Radix==16?__T(\"%lx\"):(Radix==8?__T(\"%lo\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        if (Radix==2)\r\n        {\r\n            clear();\r\n            for (int8u Pos=0; Pos<32; Pos++)\r\n            {\r\n                if (I<(((int32u)1)<<Pos))\r\n                    break;\r\n                insert(0, 1, (I&(((int32u)1)<<Pos))?__T('1'):__T('0'));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            toStringStream Stream;\r\n            Stream << setbase(Radix) << I;\r\n            assign(Stream.str());\r\n        }\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int64s I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[65];\r\n        #ifdef __MINGW32__\r\n            _i64tot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 64, Radix==10?__T(\"%lld\"):(Radix==16?__T(\"%llx\"):(Radix==8?__T(\"%llo\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setbase(Radix) << I;\r\n        assign(Stream.str());\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int64u I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        if (Radix==0)\r\n        {\r\n            clear();\r\n            return *this;\r\n        }\r\n        Char* C1=new Char[65]; C1[0] = 0;\r\n        #ifdef __MINGW32__\r\n            _ui64tot (I, C1, Radix);\r\n        #else\r\n            _tnprintf(C1, 64, Radix==10?__T(\"%llu\"):(Radix==16?__T(\"%llx\"):(Radix==8?__T(\"%llo\"):__T(\"\"))), I);\r\n        #endif\r\n        assign (C1);\r\n        delete[] C1; //C1=NULL;\r\n    #else\r\n        if (Radix==2)\r\n        {\r\n            clear();\r\n            for (int8u Pos=0; Pos<32; Pos++)\r\n            {\r\n                if (I<(((int64u)1)<<Pos))\r\n                    break;\r\n                insert(0, 1, (I&(((int64u)1)<<Pos))?__T('1'):__T('0'));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            toStringStream Stream;\r\n            Stream << setbase(Radix) << I;\r\n            assign(Stream.str());\r\n        }\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const int128u I, int8u Radix)\r\n{\r\n    From_Local(I.toString(Radix));\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const float32 F, int8u Precision, ztring_t Options)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        Char C1[100];\r\n        _tnprintf (C1, 99, (Ztring(__T(\"%.\"))+Ztring::ToZtring(Precision)+__T(\"f\")).c_str(), F);\r\n        assign(C1);\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setprecision(Precision) << fixed << F;\r\n        assign(Stream.str());\r\n        #if defined(__BORLANDC__)\r\n            FindAndReplace(__T(\",\"), __T(\".\")); //Borland C++ Builder 2010+Windows Seven put a comma for istringstream, but does not support comma for ostringstream\r\n        #endif\r\n    #endif\r\n\r\n    if ((Options & Ztring_NoZero && size()>0) && find(__T('.'))!=string::npos)\r\n    {\r\n        while (size()>0 && ((*this)[size()-1]==__T('0')))\r\n            resize(size()-1);\r\n        if (size()>0 && (*this)[size()-1]==__T('.'))\r\n            resize(size()-1);\r\n    }\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const float64 F, int8u Precision, ztring_t Options)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        Char C1[100];\r\n        _tnprintf (C1, 99, (Ztring(__T(\"%.\"))+Ztring::ToZtring(Precision)+__T(\"f\")).c_str(), F);\r\n        assign(C1);\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setprecision(Precision) << fixed << F;\r\n        assign(Stream.str());\r\n        #if defined(__BORLANDC__)\r\n            FindAndReplace(__T(\",\"), __T(\".\")); //Borland C++ Builder 2010+Windows Seven put a comma for istringstream, but does not support comma for ostringstream\r\n        #endif\r\n    #endif\r\n\r\n    if ((Options & Ztring_NoZero && size()>0) && find(__T('.'))!=string::npos)\r\n    {\r\n        while (size()>0 && ((*this)[size()-1]==__T('0')))\r\n            resize(size()-1);\r\n        if (size()>0 && (*this)[size()-1]==__T('.'))\r\n            resize(size()-1);\r\n    }\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::From_Number (const float80 F, int8u Precision, ztring_t Options)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        Char C1[100];\r\n        _tnprintf (C1, 99, (Ztring(__T(\"%.\"))+Ztring::ToZtring(Precision)+__T(\"f\")).c_str(), F);\r\n        assign(C1);\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setprecision(Precision) << fixed << F;\r\n        assign(Stream.str());\r\n        #if defined(__BORLANDC__)\r\n            FindAndReplace(__T(\",\"), __T(\".\")); //Borland C++ Builder 2010+Windows Seven put a comma for istringstream, but does not support comma for ostringstream\r\n        #endif\r\n    #endif\r\n\r\n    if ((Options & Ztring_NoZero && size()>0) && find(__T('.'))!=string::npos)\r\n    {\r\n        while (size()>0 && ((*this)[size()-1]==__T('0')))\r\n            resize(size()-1);\r\n        if (size()>0 && (*this)[size()-1]==__T('.'))\r\n            resize(size()-1);\r\n    }\r\n\r\n    return *this;\r\n}\r\n\r\n#ifdef SIZE_T_IS_LONG\r\nZtring& Ztring::From_Number (const size_t I, int8u Radix)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        Char C1[100];\r\n        _tnprintf(C1, 64, Radix==10?__T(\"%zu\"):(Radix==16?__T(\"%zx\"):(Radix==8?__T(\"%zo\"):__T(\"\"))), I);\r\n        assign(C1);\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << setbase(Radix) << I;\r\n        assign(Stream.str());\r\n        #if defined(__BORLANDC__)\r\n            FindAndReplace(__T(\",\"), __T(\".\")); //Borland C++ Builder 2010+Windows Seven put a comma for istringstream, but does not support comma for ostringstream\r\n        #endif\r\n    #endif\r\n    MakeUpperCase();\r\n    return *this;\r\n}\r\n#endif //SIZE_T_IS_LONG\r\n\r\nZtring& Ztring::From_BCD     (const int8u I)\r\n{\r\n    #if defined(STREAM_MISSING)\r\n        clear();\r\n        append(1, __T('0')+I/0x10);\r\n        append(1, __T('0')+I%0x10);\r\n    #else\r\n        toStringStream Stream;\r\n        Stream << I/0x10;\r\n        Stream << I%0x10;\r\n        assign(Stream.str());\r\n    #endif\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\nZtring& Ztring::Duration_From_Milliseconds (const int64s Value_)\r\n{\r\n    int64s Value=Value_;\r\n    bool Negative=false;\r\n    if (Value<0)\r\n    {\r\n        Value=-Value;\r\n        Negative=true;\r\n    }\r\n\r\n    int64u HH=(int8u)(Value/1000/60/60);\r\n    int64u MM=Value/1000/60   -((HH*60));\r\n    int64u Stream=Value/1000      -((HH*60+MM)*60);\r\n    int64u MS=Value           -((HH*60+MM)*60+Stream)*1000;\r\n    Ztring DateT;\r\n    Ztring Date;\r\n    DateT.From_Number(HH); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(MM); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(Stream); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\".\");\r\n    DateT.From_Number(MS); if (DateT.size()<2){DateT=Ztring(__T(\"00\"))+DateT;} else if (DateT.size()<3){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    if (Negative)\r\n    {\r\n        assign(__T(\"-\"));\r\n        append(Date);\r\n    }\r\n    else\r\n        assign (Date.c_str());\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\nZtring& Ztring::Duration_From_Milliseconds (const int64u Value)\r\n{\r\n    int64u HH=(int8u)(Value/1000/60/60);\r\n    int64u MM=Value/1000/60   -((HH*60));\r\n    int64u Stream=Value/1000      -((HH*60+MM)*60);\r\n    int64u MS=Value           -((HH*60+MM)*60+Stream)*1000;\r\n    Ztring DateT;\r\n    Ztring Date;\r\n    DateT.From_Number(HH); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(MM); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(Stream); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    Date+=__T(\".\");\r\n    DateT.From_Number(MS); if (DateT.size()<2){DateT=Ztring(__T(\"00\"))+DateT;} else if (DateT.size()<3){DateT=Ztring(__T(\"0\"))+DateT;}\r\n    Date+=DateT;\r\n    assign (Date.c_str());\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::Date_From_Milliseconds_1601 (const int64u Value)\r\n{\r\n    if (Value>=11644473600000LL) //Values <1970 are not supported\r\n    {\r\n        Date_From_Seconds_1970((int32u)((Value-11644473600000LL)/1000));\r\n        append(__T(\".\"));\r\n        Ztring Milliseconds; Milliseconds.From_Number(Value%1000);\r\n        while (Milliseconds.size()<3)\r\n            Milliseconds+=__T('0');\r\n        append(Milliseconds);\r\n    }\r\n    else\r\n        clear(); //Not supported\r\n\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1601 (const int64u Value)\r\n{\r\n    return Date_From_Seconds_1970(((int64s)Value)-11644473600LL);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1900 (const int32u Value)\r\n{\r\n    if (Value>2208988800)\r\n        return Date_From_Seconds_1970(((int64s)Value)-2208988800);\r\n    else\r\n        return Date_From_Seconds_1970(((int64s)Value)+0x100000000LL-2208988800); //Value is considering to loop e.g. NTP value\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1900 (const int64s Value)\r\n{\r\n    return Date_From_Seconds_1970(Value-2208988800);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1904 (const int32u Value)\r\n{\r\n    return Date_From_Seconds_1970(((int64s)Value)-2082844800);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1904 (const int64u Value)\r\n{\r\n    return Date_From_Seconds_1970(((int64s)Value)-2082844800);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1904 (const int64s Value)\r\n{\r\n    return Date_From_Seconds_1970(Value-2082844800);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1970 (const int32u Value)\r\n{\r\n    return Date_From_Seconds_1970((int64s)Value);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1970 (const int32s Value)\r\n{\r\n    return Date_From_Seconds_1970((int64s)Value);\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1970 (const int64s Value)\r\n{\r\n    time_t Time=(time_t)Value;\r\n    #if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE\r\n    struct tm Gmt_Temp;\r\n    struct tm *Gmt=gmtime_r(&Time, &Gmt_Temp);\r\n    #elif defined(_MSC_VER)\r\n    struct tm Gmt_Temp;\r\n    errno_t gmtime_s_Result=gmtime_s(&Gmt_Temp , &Time);\r\n    struct tm* Gmt=gmtime_s_Result?NULL:&Gmt_Temp;\r\n    #else\r\n    struct tm *Gmt=gmtime(&Time);\r\n    #endif\r\n    if (!Gmt)\r\n    {\r\n        clear();\r\n        return *this;\r\n    }\r\n    Ztring DateT;\r\n    Ztring Date=__T(\"UTC \");\r\n    Date+=Ztring::ToZtring((Gmt->tm_year+1900));\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Gmt->tm_mon+1); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mon+1);}\r\n    Date+=DateT;\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Gmt->tm_mday); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mday);}\r\n    Date+=DateT;\r\n    Date+=__T(\" \");\r\n    DateT.From_Number(Gmt->tm_hour); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_hour);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT=Ztring::ToZtring(Gmt->tm_min); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_min);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(Gmt->tm_sec); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_sec);}\r\n    Date+=DateT;\r\n    assign (Date.c_str());\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::Date_From_Seconds_1970_Local (const int32u Value)\r\n{\r\n    time_t Time=(time_t)Value;\r\n    #if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE\r\n    struct tm Gmt_Temp;\r\n    struct tm *Gmt=localtime_r(&Time, &Gmt_Temp);\r\n    #elif defined(_MSC_VER)\r\n    struct tm Gmt_Temp;\r\n    errno_t localtime_s_Result=localtime_s(&Gmt_Temp , &Time);\r\n    struct tm* Gmt=localtime_s_Result?NULL:&Gmt_Temp;\r\n    #else\r\n    struct tm *Gmt=localtime(&Time);\r\n    #endif\r\n    Ztring DateT;\r\n    Ztring Date;\r\n    if (Gmt)\r\n    {\r\n    Date+=Ztring::ToZtring((Gmt->tm_year+1900));\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Gmt->tm_mon+1); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mon+1);}\r\n    Date+=DateT;\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Gmt->tm_mday); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mday);}\r\n    Date+=DateT;\r\n    Date+=__T(\" \");\r\n    DateT.From_Number(Gmt->tm_hour); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_hour);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT=Ztring::ToZtring(Gmt->tm_min); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_min);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(Gmt->tm_sec); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_sec);}\r\n    Date+=DateT;\r\n    assign (Date.c_str());\r\n    }\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::Date_From_String (const char* Value, size_t Value_Size)\r\n{\r\n    //Only the year\r\n    if (Value_Size<10)\r\n    {\r\n        From_UTF8(Value, 0, Value_Size);\r\n        return *this;\r\n    }\r\n\r\n    #ifdef ZENLIB_USEWX\r\n        Ztring ToReturn=__T(\"UTC \");\r\n        wxDateTime Date;\r\n        Ztring DateS;\r\n        DateS.From_Local(Value, Value_Size).c_str();\r\n        if (!DateS.empty() && DateS[DateS.size()-1]==__T('\\n'))\r\n            DateS.resize(DateS.size()-1);\r\n\r\n        //Some strange formating : exactly 24 bytes (or 25 with 0x0A at the end) and Year is at the end\r\n        if (DateS.size()==24 && DateS[23]>=__T('0') && DateS[23]<=__T('9') && DateS[21]>=__T('0') && DateS[21]<=__T('9') && DateS[19]==__T(' '))\r\n            Date.ParseFormat(DateS.c_str(), __T(\"%a %b %d %H:%M:%S %Y\"));\r\n        //ISO date\r\n        else if (DateS.size()==10 && (DateS[4]<__T('0') || DateS[4]>__T('9')) && (DateS[7]<__T('0') || DateS[7]>__T('9')))\r\n        {\r\n            DateS[4]=__T('-');\r\n            DateS[7]=__T('-');\r\n            ToReturn+=DateS;\r\n        }\r\n        //Default\r\n        else\r\n            Date.ParseDateTime(DateS.c_str());\r\n\r\n        if (ToReturn.size()<5)\r\n        {\r\n            ToReturn+=Date.FormatISODate();\r\n            ToReturn+=__T(\" \");\r\n            ToReturn+=Date.FormatISOTime();\r\n        }\r\n        else\r\n            ToReturn+=DateS;\r\n\r\n        assign (ToReturn.c_str());\r\n    #else //ZENLIB_USEWX\r\n        Ztring DateS; DateS.From_UTF8(Value, 0, Value_Size);\r\n        //Unix style formating : exactly 24 bytes (or 25 with 0x0A at the end) and Year is at the end\r\n        if ((DateS.size()==24 || (DateS.size()==25 && DateS[24]==__T('\\n'))) && DateS[23]>=__T('0') && DateS[23]<=__T('9') && DateS[21]>=__T('0') && DateS[21]<=__T('9') && DateS[19]==__T(' '))\r\n        {\r\n            clear();\r\n            append(1, DateS[20]);\r\n            append(1, DateS[21]);\r\n            append(1, DateS[22]);\r\n            append(1, DateS[23]);\r\n            append(1, __T('-'));\r\n                 if (DateS[4]==__T('J') && DateS[5]==__T('a') && DateS[6]==__T('n') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('1'));\r\n            }\r\n            else if (DateS[4]==__T('F') && DateS[5]==__T('e') && DateS[6]==__T('b') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('2'));\r\n            }\r\n            else if (DateS[4]==__T('M') && DateS[5]==__T('a') && DateS[6]==__T('r') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('3'));\r\n            }\r\n            else if (DateS[4]==__T('A') && DateS[5]==__T('p') && DateS[6]==__T('r') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('4'));\r\n            }\r\n            else if (DateS[4]==__T('M') && DateS[5]==__T('a') && DateS[6]==__T('y') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('5'));\r\n            }\r\n            else if (DateS[4]==__T('J') && DateS[5]==__T('u') && DateS[6]==__T('n') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('6'));\r\n            }\r\n            else if (DateS[4]==__T('J') && DateS[5]==__T('u') && DateS[6]==__T('l') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('7'));\r\n            }\r\n            else if (DateS[4]==__T('A') && DateS[5]==__T('u') && DateS[6]==__T('g') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('8'));\r\n            }\r\n            else if (DateS[4]==__T('S') && DateS[5]==__T('e') && DateS[6]==__T('p') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('0'));\r\n                append(1, __T('9'));\r\n            }\r\n            else if (DateS[4]==__T('O') && DateS[5]==__T('c') && DateS[6]==__T('t') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('1'));\r\n                append(1, __T('0'));\r\n            }\r\n            else if (DateS[4]==__T('N') && DateS[5]==__T('o') && DateS[6]==__T('v') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('1'));\r\n                append(1, __T('1'));\r\n            }\r\n            else if (DateS[4]==__T('D') && DateS[5]==__T('e') && DateS[6]==__T('c') && DateS[7]==__T(' '))\r\n            {\r\n                append(1, __T('1'));\r\n                append(1, __T('2'));\r\n            }\r\n            else\r\n            {\r\n                assign(DateS);\r\n                return *this;\r\n            }\r\n            append(1, __T('-'));\r\n            append(1, DateS[8]);\r\n            append(1, DateS[9]);\r\n            append(1, __T(' '));\r\n            append(1, DateS[11]);\r\n            append(1, DateS[12]);\r\n            append(1, __T(':'));\r\n            append(1, DateS[14]);\r\n            append(1, DateS[15]);\r\n            append(1, __T(':'));\r\n            append(1, DateS[17]);\r\n            append(1, DateS[18]);\r\n        }\r\n        else if (DateS.size()==20 && DateS[4]==__T('-') && DateS[7]==__T('-') && DateS[10]==__T('T') && DateS[13]==__T(':') && DateS[16]==__T(':') && DateS[19]==__T('Z'))\r\n        {\r\n            DateS.resize(19);\r\n            DateS[10]=__T(' ');\r\n            assign(__T(\"UTC \"));\r\n            append(DateS);\r\n        }\r\n        else if (DateS.size()==23 && DateS[4]==__T('-') && DateS[7]==__T('-') && DateS[10]==__T(' ') && DateS[14]==__T(' ') && DateS[17]==__T(':') && DateS[20]==__T(':'))\r\n        {\r\n            DateS.erase(10, 4);\r\n            //assign(__T(\"UTC \")); //Is not UTC\r\n            append(DateS);\r\n        }\r\n        else\r\n            From_UTF8(Value, 0, Value_Size); //Not implemented\r\n    #endif //ZENLIB_USEWX\r\n    return *this;\r\n}\r\n\r\nZtring& Ztring::Date_From_Numbers (const int8u Year, const int8u Month, const int8u Day, const int8u Hour, const int8u Minute, const int8u Second)\r\n{\r\n    Ztring DateT;\r\n    Ztring Date=__T(\"UTC \");\r\n    DateT.From_Number(Year); if (DateT.size()<2){DateT=Ztring(__T(\"200\"))+Ztring::ToZtring(Year);}; if (DateT.size()<3){DateT=Ztring(__T(\"20\"))+Ztring::ToZtring(Year);}\r\n    Date+=DateT;\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Month); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Month);}\r\n    Date+=DateT;\r\n    Date+=__T(\"-\");\r\n    DateT.From_Number(Day); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Day);}\r\n    Date+=DateT;\r\n    Date+=__T(\" \");\r\n    DateT.From_Number(Hour); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Hour);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT=Ztring::ToZtring(Minute); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Minute);}\r\n    Date+=DateT;\r\n    Date+=__T(\":\");\r\n    DateT.From_Number(Second); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Second);}\r\n    Date+=DateT;\r\n    assign (Date.c_str());\r\n    return *this;\r\n}\r\n\r\n#ifndef WSTRING_MISSING\r\n//---------------------------------------------------------------------------\r\nstd::wstring Ztring::To_Unicode () const\r\n{\r\n    #ifdef _UNICODE\r\n        return c_str();\r\n    #else //_UNICODE\r\n        #ifdef ZENLIB_USEWX\r\n            return wxConvCurrent->cMB2WC(c_str()).data();\r\n        #else //ZENLIB_USEWX\r\n            return std::wstring(); //Not implemented\r\n        #endif //ZENLIB_USEWX\r\n    #endif //_UNICODE\r\n}\r\n#endif //WSTRING_MISSING\r\n\r\nstd::string Ztring::To_UTF8 () const\r\n{\r\n    #ifdef _UNICODE\r\n        //Correction thanks to Andrew Jang\r\n        // Don't use WideCharToMultiByte(), some characters are not well converted\r\n        std::string ToReturn;\r\n        ToReturn.reserve(size()); // more efficient\r\n\r\n        const wchar_t* Z=c_str();\r\n\r\n        while (*Z)\r\n        {\r\n            if (*Z < 0x80)\r\n            {\r\n                ToReturn += (char)(*(Z++));\r\n                continue;\r\n            }\r\n            \r\n            int32u wc; // must be unsigned.\r\n\r\n            #if defined(_MSC_VER)\r\n                #pragma warning(push)\r\n                #pragma warning(disable:4127)\r\n            #endif //defined(_MSC_VER)\r\n            if (sizeof(wchar_t) == 2)\r\n            #if defined(_MSC_VER)\r\n                #pragma warning(pop)\r\n            #endif //defined(_MSC_VER)\r\n            {\r\n                if (((*Z) & 0xFC00) == 0xD800)\r\n                {\r\n                    //UTF-16\r\n                    wc =( (((int16u) *Z) & 0x3FF) + 0x40) << 10;\r\n                    Z++;\r\n                    wc |= (((int16u) *Z) & 0x3FF);\r\n                }\r\n                else\r\n                wc = (int16u) *Z; // avoid a cast problem if wchar_t is signed.\r\n            }\r\n            else\r\n                wc = *Z;\r\n\r\n            int count;\r\n\r\n            // refer to http://en.wikipedia.org/wiki/UTF-8#Description\r\n\r\n            if (wc < 0x80)\r\n                count = 1;\r\n            else if (wc < 0x800)\r\n                count = 2;\r\n            else if (wc < 0x10000)\r\n                count = 3;\r\n            else if (wc < 0x200000)\r\n                count = 4;\r\n            else if (wc < 0x4000000)\r\n                count = 5;\r\n            else if (wc <= 0x7fffffff)\r\n                count = 6;\r\n            else\r\n                break;  // bad character\r\n\r\n            int64u utfbuf = 0; // 8 bytes\r\n            char* utf8chars = (char*) &utfbuf;\r\n\r\n            switch (count)\r\n            {\r\n            case 6:\r\n                utf8chars[5] = 0x80 | (wc & 0x3f);\r\n                wc = (wc >> 6) | 0x4000000;\r\n                /* fallthrough */\r\n            case 5:\r\n                utf8chars[4] = 0x80 | (wc & 0x3f);\r\n                wc = (wc >> 6) | 0x200000;\r\n                /* fallthrough */\r\n            case 4:\r\n                utf8chars[3] = 0x80 | (wc & 0x3f);\r\n                wc = (wc >> 6) | 0x10000;\r\n                /* fallthrough */\r\n            case 3:\r\n                utf8chars[2] = 0x80 | (wc & 0x3f);\r\n                wc = (wc >> 6) | 0x800;\r\n                /* fallthrough */\r\n            case 2:\r\n                utf8chars[1] = 0x80 | (wc & 0x3f);\r\n                wc = (wc >> 6) | 0xc0;\r\n                /* fallthrough */\r\n            case 1:\r\n                utf8chars[0] = (char) wc;\r\n            }\r\n\r\n            ToReturn += utf8chars;\r\n\r\n            ++Z;\r\n        }\r\n\r\n        return ToReturn;\r\n    #else\r\n        #ifdef ZENLIB_USEWX\r\n            return wxConvUTF8.cWC2MB(wxConvCurrent->cMB2WC(c_str())).data();\r\n        #else //ZENLIB_USEWX\r\n            return c_str(); //Not implemented\r\n        #endif //ZENLIB_USEWX\r\n    #endif\r\n}\r\n\r\nstd::string Ztring::To_Local () const\r\n{\r\n    #ifdef _UNICODE\r\n        #ifdef ZENLIB_USEWX\r\n            wxCharBuffer C=wxConvCurrent->cWC2MB(c_str());\r\n            if (C.data())\r\n                return C.data();\r\n            else\r\n                return std::string();\r\n        #else //ZENLIB_USEWX\r\n            #ifdef WINDOWS\r\n                int Size=WideCharToMultiByte(CP_ACP, 0, c_str(), -1, NULL, 0, NULL, NULL);\r\n                if (Size!=0)\r\n                {\r\n                    char* AnsiString=new char[Size+1];\r\n                    WideCharToMultiByte(CP_ACP, 0, c_str(), -1, AnsiString, Size, NULL, NULL);\r\n                    AnsiString[Size]='\\0';\r\n                    std::string ToReturn(AnsiString);\r\n                    delete[] AnsiString; //AnsiString=NULL;\r\n                    return ToReturn;\r\n                }\r\n                else\r\n                    return std::string();\r\n            #else //WINDOWS\r\n                if (empty())\r\n                    return std::string();\r\n\r\n                size_t Size=wcstombs(NULL, c_str(), 0);\r\n                if (Size!=0 && Size!=(size_t)-1)\r\n                {\r\n                    char* AnsiString=new char[Size+1];\r\n                    Size=wcstombs(AnsiString, c_str(), Size);\r\n                    if (Size!=0 && Size!=(size_t)-1)\r\n                    {\r\n                        AnsiString[Size]='\\0';\r\n                        std::string ToReturn(AnsiString);\r\n                        delete[] AnsiString; //AnsiString=NULL;\r\n                        return ToReturn;\r\n                    }\r\n\r\n                    //Failed\r\n                    delete[] AnsiString; //AnsiString=NULL;\r\n                }\r\n\r\n                //Trying with bad chars\r\n                char* Result=new char[MB_CUR_MAX];\r\n                std::string AnsiString;\r\n                for (size_t Pos=0; Pos<size(); Pos++)\r\n                {\r\n                    size_t Result_Size=wcrtomb(Result, operator[](Pos), 0);\r\n                    if (Result_Size && Result_Size!=(size_t)-1)\r\n                        AnsiString.append(Result, Result_Size);\r\n                    else\r\n                        AnsiString+='?';\r\n                }\r\n                delete[] Result; //Result=NULL;\r\n                return AnsiString;\r\n            #endif\r\n        #endif //ZENLIB_USEWX\r\n    #else\r\n        return c_str();\r\n    #endif\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\nint128u Ztring::To_UUID () const\r\n{\r\n    if (size()!=36)\r\n        return 0;\r\n\r\n    Ztring Temp=*this;\r\n\r\n    for (size_t Pos=0; Pos<36; Pos++)\r\n    {\r\n        if ((Temp[Pos]< __T('0') || Temp[Pos]> __T('9'))\r\n         && (Temp[Pos]< __T('A') || Temp[Pos]> __T('F'))\r\n         && (Temp[Pos]< __T('a') || Temp[Pos]> __T('f')))\r\n            return 0;\r\n        if (Temp[Pos]>=__T('A') && Temp[Pos]<=__T('F'))\r\n        {\r\n            Temp[Pos]-=__T('A');\r\n            Temp[Pos]+=__T('9')+1;\r\n        }\r\n        if (Temp[Pos]>=__T('a') && Temp[Pos]<=__T('f'))\r\n        {\r\n            Temp[Pos]-=__T('a');\r\n            Temp[Pos]+=__T('9')+1;\r\n        }\r\n\r\n        switch(Pos)\r\n        {\r\n            case  7 :\r\n            case 12 :\r\n            case 17 :\r\n            case 22 :\r\n                        if (at(Pos+1)!=__T('-'))\r\n                            return 0;\r\n                        Pos++; //Skipping dash in the test\r\n        }\r\n    }\r\n\r\n    int128u I;\r\n    I.hi=((int64u)((int8u)(Temp[ 0]-'0'))<<60)\r\n       | ((int64u)((int8u)(Temp[ 1]-'0'))<<56)\r\n       | ((int64u)((int8u)(Temp[ 2]-'0'))<<52)\r\n       | ((int64u)((int8u)(Temp[ 3]-'0'))<<48)\r\n       | ((int64u)((int8u)(Temp[ 4]-'0'))<<44)\r\n       | ((int64u)((int8u)(Temp[ 5]-'0'))<<40)\r\n       | ((int64u)((int8u)(Temp[ 6]-'0'))<<36)\r\n       | ((int64u)((int8u)(Temp[ 7]-'0'))<<32)\r\n       | ((int64u)((int8u)(Temp[ 9]-'0'))<<28)\r\n       | ((int64u)((int8u)(Temp[10]-'0'))<<24)\r\n       | ((int64u)((int8u)(Temp[11]-'0'))<<20)\r\n       | ((int64u)((int8u)(Temp[12]-'0'))<<16)\r\n       | ((int64u)((int8u)(Temp[14]-'0'))<<12)\r\n       | ((int64u)((int8u)(Temp[15]-'0'))<< 8)\r\n       | ((int64u)((int8u)(Temp[16]-'0'))<< 4)\r\n       | ((int64u)((int8u)(Temp[17]-'0'))    );\r\n    I.lo=((int64u)((int8u)(Temp[19]-'0'))<<60)\r\n       | ((int64u)((int8u)(Temp[20]-'0'))<<56)\r\n       | ((int64u)((int8u)(Temp[21]-'0'))<<52)\r\n       | ((int64u)((int8u)(Temp[22]-'0'))<<48)\r\n       | ((int64u)((int8u)(Temp[24]-'0'))<<44)\r\n       | ((int64u)((int8u)(Temp[25]-'0'))<<40)\r\n       | ((int64u)((int8u)(Temp[26]-'0'))<<36)\r\n       | ((int64u)((int8u)(Temp[27]-'0'))<<32)\r\n       | ((int64u)((int8u)(Temp[28]-'0'))<<28)\r\n       | ((int64u)((int8u)(Temp[29]-'0'))<<24)\r\n       | ((int64u)((int8u)(Temp[30]-'0'))<<20)\r\n       | ((int64u)((int8u)(Temp[31]-'0'))<<16)\r\n       | ((int64u)((int8u)(Temp[32]-'0'))<<12)\r\n       | ((int64u)((int8u)(Temp[33]-'0'))<< 8)\r\n       | ((int64u)((int8u)(Temp[34]-'0'))<< 4)\r\n       | ((int64u)((int8u)(Temp[35]-'0'))    );\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\nint32u Ztring::To_CC4 () const\r\n{\r\n    int32u I;\r\n    I =((int32u)((int8u)at(0))<<24)\r\n     | ((int32u)((int8u)at(1))<<16)\r\n     | ((int32u)((int8u)at(2))<< 8)\r\n     | ((int32u)((int8u)at(3))    );\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint8s Ztring::To_int8s (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi(c_str());\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoi(S.c_str());\r\n        #else //UNICODE\r\n            I=atoi(c_str());\r\n        #endif //UNICODE\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=Error)\r\n    {\r\n        float80 F=To_float80();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return (int8s)I+1;\r\n    }\r\n\r\n    return (int8s)I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint8u Ztring::To_int8u (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    unsigned int I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi64(c_str()); //TODO : I>0x7FFFFFFF - Replaced by i64 version to support, but not good\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoi(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atoi(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=std::string::npos)\r\n    {\r\n        float32 F=To_float32();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return (int8u)I+1;\r\n    }\r\n\r\n    return (int8u)I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint16s Ztring::To_int16s (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi(c_str());\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoi(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atoi(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=Error)\r\n    {\r\n        float80 F=To_float80();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return (int16s)I+1;\r\n    }\r\n\r\n    return (int16s)I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint16u Ztring::To_int16u (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    unsigned int I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi64(c_str()); //TODO : I>0x7FFFFFFF - Replaced by i64 version to support, but not good\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoi(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atoi(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=std::string::npos)\r\n    {\r\n        float32 F=To_float32();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return (int16u)I+1;\r\n    }\r\n\r\n    return (int16u)I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint32s Ztring::To_int32s (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int32s I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi(c_str());\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atol(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atol(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=Error)\r\n    {\r\n        float80 F=To_float80();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return I+1;\r\n    }\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint32u Ztring::To_int32u (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int32u I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi64(c_str()); //TODO : I>0x7FFFFFFF - Replaced by i64 version to support, but not good\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atol(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atol(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=std::string::npos)\r\n    {\r\n        float32 F=To_float32();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return I+1;\r\n    }\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint64s Ztring::To_int64s (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int64s I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi64(c_str());\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoll(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atoll(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=std::string::npos)\r\n    {\r\n        float32 F=To_float32();\r\n        F-=I;\r\n        if (F>0.5f)\r\n            return I+1;\r\n    }\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToInt\r\nint64u Ztring::To_int64u (int8u Radix, ztring_t Options) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    int64u I;\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef __MINGW32__\r\n            I=_ttoi64(c_str()); //TODO : I>0x7FFFFFFFFFFFFFFF\r\n        #elif defined(UNICODE)\r\n            std::string S=To_UTF8();\r\n            I=atoll(S.c_str());\r\n        #else //defined(UNICODE)\r\n            I=atoll(c_str());\r\n        #endif //defined(UNICODE)\r\n    #else\r\n        tStringStream Stream(*this);\r\n        Stream >> setbase(Radix) >> I;\r\n        if (Stream.fail())\r\n            return 0;\r\n    #endif\r\n\r\n    //Rounded\r\n    if (Options==Ztring_Rounded && find(__T('.'))!=std::string::npos)\r\n    {\r\n        float32 F=To_float32();\r\n        F-=I;\r\n        if (F>=0.5f)\r\n            return I+1;\r\n    }\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\nint128u Ztring::To_int128u (int8u, ztring_t) const\r\n{\r\n    if (size()!=32)\r\n        return 0;\r\n\r\n    Ztring Temp=*this;\r\n\r\n    for (size_t Pos=0; Pos<32; Pos++)\r\n    {\r\n        if ((Temp[Pos]< __T('0') || Temp[Pos]> __T('9'))\r\n         && (Temp[Pos]< __T('A') || Temp[Pos]> __T('F'))\r\n         && (Temp[Pos]< __T('a') || Temp[Pos]> __T('f')))\r\n            return 0;\r\n        if (Temp[Pos]>=__T('A') && Temp[Pos]<=__T('F'))\r\n        {\r\n            Temp[Pos]-=__T('A');\r\n            Temp[Pos]+=__T('9')+1;\r\n        }\r\n        if (Temp[Pos]>=__T('a') && Temp[Pos]<=__T('f'))\r\n        {\r\n            Temp[Pos]-=__T('a');\r\n            Temp[Pos]+=__T('9')+1;\r\n        }\r\n    }\r\n\r\n    int128u I;\r\n    I.hi=((int64u)((int8u)(Temp[ 0]-'0'))<<60)\r\n       | ((int64u)((int8u)(Temp[ 1]-'0'))<<56)\r\n       | ((int64u)((int8u)(Temp[ 2]-'0'))<<52)\r\n       | ((int64u)((int8u)(Temp[ 3]-'0'))<<48)\r\n       | ((int64u)((int8u)(Temp[ 4]-'0'))<<44)\r\n       | ((int64u)((int8u)(Temp[ 5]-'0'))<<40)\r\n       | ((int64u)((int8u)(Temp[ 6]-'0'))<<36)\r\n       | ((int64u)((int8u)(Temp[ 7]-'0'))<<32)\r\n       | ((int64u)((int8u)(Temp[ 8]-'0'))<<28)\r\n       | ((int64u)((int8u)(Temp[ 9]-'0'))<<24)\r\n       | ((int64u)((int8u)(Temp[10]-'0'))<<20)\r\n       | ((int64u)((int8u)(Temp[11]-'0'))<<16)\r\n       | ((int64u)((int8u)(Temp[12]-'0'))<<12)\r\n       | ((int64u)((int8u)(Temp[13]-'0'))<< 8)\r\n       | ((int64u)((int8u)(Temp[14]-'0'))<< 4)\r\n       | ((int64u)((int8u)(Temp[15]-'0'))    );\r\n    I.lo=((int64u)((int8u)(Temp[16]-'0'))<<60)\r\n       | ((int64u)((int8u)(Temp[17]-'0'))<<56)\r\n       | ((int64u)((int8u)(Temp[18]-'0'))<<52)\r\n       | ((int64u)((int8u)(Temp[19]-'0'))<<48)\r\n       | ((int64u)((int8u)(Temp[20]-'0'))<<44)\r\n       | ((int64u)((int8u)(Temp[21]-'0'))<<40)\r\n       | ((int64u)((int8u)(Temp[22]-'0'))<<36)\r\n       | ((int64u)((int8u)(Temp[23]-'0'))<<32)\r\n       | ((int64u)((int8u)(Temp[24]-'0'))<<28)\r\n       | ((int64u)((int8u)(Temp[25]-'0'))<<24)\r\n       | ((int64u)((int8u)(Temp[26]-'0'))<<20)\r\n       | ((int64u)((int8u)(Temp[27]-'0'))<<16)\r\n       | ((int64u)((int8u)(Temp[28]-'0'))<<12)\r\n       | ((int64u)((int8u)(Temp[29]-'0'))<< 8)\r\n       | ((int64u)((int8u)(Temp[30]-'0'))<< 4)\r\n       | ((int64u)((int8u)(Temp[31]-'0'))    );\r\n\r\n    return I;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToFloat\r\nfloat32 Ztring::To_float32(ztring_t) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef UNICODE\r\n            return (wcstod(c_str(),NULL));\r\n        #else\r\n            return (strtod(c_str(),NULL));\r\n        #endif\r\n    #else\r\n        float32 F;\r\n        tStringStream Stream(*this);\r\n        Stream >> F;\r\n        if (Stream.fail())\r\n            return 0;\r\n\r\n        return F;\r\n    #endif\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToFloat\r\nfloat64 Ztring::To_float64(ztring_t) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef UNICODE\r\n            return (wcstod(c_str(),NULL)); //TODO verify no wcstold\r\n        #else\r\n            return (strtod(c_str(),NULL)); //TODO verify no strtold\r\n        #endif\r\n    #else\r\n        float64 F;\r\n        tStringStream Stream(*this);\r\n        Stream >> F;\r\n        if (Stream.fail())\r\n            return 0;\r\n\r\n        return F;\r\n    #endif\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Operateur ToFloat\r\nfloat80 Ztring::To_float80(ztring_t) const\r\n{\r\n    //Integrity\r\n    if (empty())\r\n        return 0;\r\n\r\n    //Conversion\r\n    #if defined(STREAM_MISSING)\r\n        #ifdef UNICODE\r\n            return (wcstod(c_str(),NULL)); //TODO verify no wcstold\r\n        #else\r\n            return (strtod(c_str(),NULL)); //TODO verify no strtold\r\n        #endif\r\n    #else\r\n        float80 F;\r\n        tStringStream Stream(*this);\r\n        Stream >> F;\r\n        if (Stream.fail())\r\n            return 0;\r\n\r\n        return F;\r\n    #endif\r\n}\r\n\r\n//***************************************************************************\r\n// Edition\r\n//***************************************************************************\r\n\r\n//---------------------------------------------------------------------------\r\n// Retourne une partie de la chaine\r\nZtring Ztring::SubString (const tstring &Begin, const tstring &End, size_type Pos, ztring_t Options) const\r\n{\r\n    //Recherche Debut\r\n    size_type I_Debut=find(Begin, Pos);\r\n    if (I_Debut==Error)\r\n        return Ztring();\r\n    I_Debut+=Begin.size();\r\n\r\n    //gestion fin NULL\r\n    if (End.empty())\r\n        return substr(I_Debut);\r\n\r\n    //Recherche Fin\r\n    size_type I_Fin=find(End, I_Debut);\r\n    if (I_Fin==Error)\r\n    {\r\n        if (Options & Ztring_AddLastItem)\r\n            return substr(I_Debut);\r\n        else\r\n            return Ztring();\r\n    }\r\n\r\n    return substr(I_Debut, I_Fin-I_Debut);\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//FindAndReplace\r\nZtring::size_type Ztring::FindAndReplace (const ZenLib::tstring &ToFind, const ZenLib::tstring &ReplaceBy, size_type Pos, ZenLib::ztring_t Options)\r\n{\r\n    if (ToFind.empty())\r\n        return 0;\r\n\r\n    size_type Count=0;\r\n    size_type Middle=Pos;\r\n    while (!(Count==1 && !(Options&Ztring_Recursive)) && (Middle=find(ToFind, Middle))!=npos)\r\n    {\r\n        replace(Middle, ToFind.length(), ReplaceBy);\r\n        Middle += ReplaceBy.length();\r\n        Count++;\r\n    }\r\n\r\n    return Count;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//test if it is a number\r\nbool Ztring::IsNumber() const\r\n{\r\n    if (empty())\r\n        return false;\r\n\r\n    bool OK=true;\r\n    size_t Size=size();\r\n    for (size_t Pos=0; Pos<Size; Pos++)\r\n        if (operator[](Pos)<__T('0') || operator[](Pos)>__T('9'))\r\n        {\r\n            OK=false;\r\n            break;\r\n        }\r\n    return OK;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Mise en minuscules\r\nZtring &Ztring::MakeLowerCase()\r\n{\r\n    transform(begin(), end(), begin(), (int(*)(int))tolower); //(int(*)(int)) is a patch for unix\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Mise en majuscules\r\nZtring &Ztring::MakeUpperCase()\r\n{\r\n    transform(begin(), end(), begin(), (int(*)(int))toupper); //(int(*)(int)) is a patch for unix\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Remove leading whitespaces from a string\r\nZtring &Ztring::TrimLeft(Char ToTrim)\r\n{\r\n    size_type First=0;\r\n    while (First<size() && operator[](First)==ToTrim)\r\n        First++;\r\n    assign (c_str()+First);\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Remove trailing whitespaces from a string\r\nZtring &Ztring::TrimRight(Char ToTrim)\r\n{\r\n    if (size()==0)\r\n        return *this;\r\n\r\n    size_type Last=size()-1;\r\n    while (Last!=(size_type)-1 && operator[](Last)==ToTrim)\r\n        Last--;\r\n    assign (c_str(), Last+1);\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Remove leading and trailing whitespaces from a string\r\nZtring &Ztring::Trim(Char ToTrim)\r\n{\r\n    TrimLeft(ToTrim);\r\n    TrimRight(ToTrim);\r\n    return *this;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Quotes a string\r\nZtring &Ztring::Quote(Char ToTrim)\r\n{\r\n    assign(tstring(1, ToTrim)+c_str()+ToTrim);\r\n    return *this;\r\n}\r\n\r\n//***************************************************************************\r\n// Information\r\n//***************************************************************************\r\n\r\n//---------------------------------------------------------------------------\r\n//Count\r\nZtring::size_type Ztring::Count (const Ztring &ToCount, ztring_t) const\r\n{\r\n    size_type Count=0;\r\n    for (size_type Pos=0; Pos<=size(); Pos++)\r\n        if (find(ToCount, Pos)!=npos)\r\n        {\r\n            Count++;\r\n            Pos+=ToCount.size()-1; //-1 because the loop will add 1\r\n        }\r\n    return Count;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n//Compare\r\nbool Ztring::Compare (const Ztring &ToCompare, const Ztring &Comparator, ztring_t Options) const\r\n{\r\n    //Integers management\r\n    if (IsNumber() && ToCompare.IsNumber())\r\n    {\r\n        int64s Left=To_int64s();\r\n        int64s Right=ToCompare.To_int64s();\r\n        if (Comparator==__T(\"==\")) return (Left==Right);\r\n        if (Comparator==__T(\"<\"))  return (Left< Right);\r\n        if (Comparator==__T(\"<=\")) return (Left<=Right);\r\n        if (Comparator==__T(\">=\")) return (Left>=Right);\r\n        if (Comparator==__T(\">\"))  return (Left> Right);\r\n        if (Comparator==__T(\"!=\")) return (Left!=Right);\r\n        if (Comparator==__T(\"<>\")) return (Left!=Right);\r\n        return false;\r\n    }\r\n\r\n    //Case sensitive option\r\n    if (!(Options & Ztring_CaseSensitive))\r\n    {\r\n        //Need to copy strings and make it lowercase\r\n        Ztring Left (c_str());\r\n        Ztring Right (ToCompare.c_str());\r\n        Left.MakeLowerCase();\r\n        Right.MakeLowerCase();\r\n\r\n        //string comparasion\r\n        if (Comparator==__T(\"==\")) return (Left==Right);\r\n        if (Comparator==__T(\"IN\")) {if (Left.find(Right)!=string::npos) return true; else return false;}\r\n        if (Comparator==__T(\"<\"))  return (Left< Right);\r\n        if (Comparator==__T(\"<=\")) return (Left<=Right);\r\n        if (Comparator==__T(\">=\")) return (Left>=Right);\r\n        if (Comparator==__T(\">\"))  return (Left> Right);\r\n        if (Comparator==__T(\"!=\")) return (Left!=Right);\r\n        if (Comparator==__T(\"<>\")) return (Left!=Right);\r\n        return false;\r\n    }\r\n    else\r\n    {\r\n        //string comparasion\r\n        if (Comparator==__T(\"==\")) return (*this==ToCompare);\r\n        if (Comparator==__T(\"IN\")) {if (this->find(ToCompare)!=string::npos) return true; else return false;}\r\n        if (Comparator==__T(\"<\"))  return (*this< ToCompare);\r\n        if (Comparator==__T(\"<=\")) return (*this<=ToCompare);\r\n        if (Comparator==__T(\">=\")) return (*this>=ToCompare);\r\n        if (Comparator==__T(\">\"))  return (*this> ToCompare);\r\n        if (Comparator==__T(\"!=\")) return (*this!=ToCompare);\r\n        if (Comparator==__T(\"<>\")) return (*this!=ToCompare);\r\n        return false;\r\n    }\r\n}\r\n\r\n} //namespace\r\n"], "filenames": ["Source/ZenLib/Ztring.cpp"], "buggy_code_start_loc": [1366], "buggy_code_end_loc": [1383], "fixing_code_start_loc": [1367], "fixing_code_end_loc": [1387], "type": "CWE-476", "message": "A vulnerability classified as problematic has been found in MediaArea ZenLib up to 0.4.38. This affects the function Ztring::Date_From_Seconds_1970_Local of the file Source/ZenLib/Ztring.cpp. The manipulation of the argument Value leads to unchecked return value to null pointer dereference. Upgrading to version 0.4.39 is able to address this issue. The name of the patch is 6475fcccd37c9cf17e0cfe263b5fe0e2e47a8408. It is recommended to upgrade the affected component. The identifier VDB-217629 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2020-36646", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-07T20:15:09.523", "lastModified": "2023-01-12T20:32:59.227", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic has been found in MediaArea ZenLib up to 0.4.38. This affects the function Ztring::Date_From_Seconds_1970_Local of the file Source/ZenLib/Ztring.cpp. The manipulation of the argument Value leads to unchecked return value to null pointer dereference. Upgrading to version 0.4.39 is able to address this issue. The name of the patch is 6475fcccd37c9cf17e0cfe263b5fe0e2e47a8408. It is recommended to upgrade the affected component. The identifier VDB-217629 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.3}, "baseSeverity": "LOW", "exploitabilityScore": 4.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-690"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mediaarea:zenlib:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.4.0", "versionEndExcluding": "0.4.39", "matchCriteriaId": "BEB25B3D-8187-42BF-9B6B-F49994B3EFD7"}]}]}], "references": [{"url": "https://github.com/MediaArea/ZenLib/commit/6475fcccd37c9cf17e0cfe263b5fe0e2e47a8408", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/MediaArea/ZenLib/pull/119", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/MediaArea/ZenLib/releases/tag/v0.4.39", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217629", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://vuldb.com/?id.217629", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/MediaArea/ZenLib/commit/6475fcccd37c9cf17e0cfe263b5fe0e2e47a8408"}}