{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#ifndef __PJSIP_AUTH_SIP_AUTH_H__\n#define __PJSIP_AUTH_SIP_AUTH_H__\n\n/**\n * @file pjsip_auth.h\n * @brief SIP Authorization Module.\n */\n\n#include <pjsip/sip_config.h>\n#include <pjsip/sip_auth_msg.h>\n\nPJ_BEGIN_DECL\n\n/**\n * @addtogroup PJSIP_AUTH\n * @ingroup PJSIP_CORE\n * @brief Client and server side authentication framework.\n */\n\n/**\n * @defgroup PJSIP_AUTH_API Authentication API's\n * @ingroup PJSIP_AUTH\n * @brief Structures and functions to perform authentication.\n * @{\n */\n\n/** Length of digest MD5 string. */\n#define PJSIP_MD5STRLEN\t\t32\n\n/** Length of digest SHA256 string. */\n#define PJSIP_SHA256STRLEN\t64\n\n\n/** Type of data in the credential information in #pjsip_cred_info. */\ntypedef enum pjsip_cred_data_type\n{\n    PJSIP_CRED_DATA_PLAIN_PASSWD=0, /**< Plain text password.\t\t*/\n    PJSIP_CRED_DATA_DIGEST\t=1, /**< Hashed digest.\t\t\t*/\n\n    PJSIP_CRED_DATA_EXT_AKA\t=16 /**< Extended AKA info is available */\n\n} pjsip_cred_data_type;\n\n/** Authentication's quality of protection (qop) type. */\ntypedef enum pjsip_auth_qop_type\n{\n    PJSIP_AUTH_QOP_NONE,\t    /**< No quality of protection. */\n    PJSIP_AUTH_QOP_AUTH,\t    /**< Authentication. */\n    PJSIP_AUTH_QOP_AUTH_INT,\t    /**< Authentication with integrity protection. */\n    PJSIP_AUTH_QOP_UNKNOWN\t    /**< Unknown protection. */\n} pjsip_auth_qop_type;\n\n\n/**\n * Type of callback function to create authentication response.\n * Application can specify this callback in \\a cb field of the credential info\n * (#pjsip_cred_info) and specifying PJSIP_CRED_DATA_DIGEST_CALLBACK as \n * \\a data_type. When this function is called, most of the fields in the \n * \\a auth authentication response will have been filled by the framework. \n * Application normally should just need to calculate the response digest \n * of the authentication response.\n *\n * @param pool\t    Pool to allocate memory from if application needs to.\n * @param chal\t    The authentication challenge sent by server in 401\n *\t\t    or 401 response, in either Proxy-Authenticate or\n *\t\t    WWW-Authenticate header.\n * @param cred\t    The credential that has been selected by the framework\n *\t\t    to authenticate against the challenge.\n * @param auth\t    The authentication response which application needs to\n *\t\t    calculate the response digest.\n *\n * @return\t    Application may return non-PJ_SUCCESS to abort the\n *\t\t    authentication process. When this happens, the \n *\t\t    framework will return failure to the original function\n *\t\t    that requested authentication.\n */\ntypedef pj_status_t (*pjsip_cred_cb)(pj_pool_t *pool,\n\t\t\t\t     const pjsip_digest_challenge *chal,\n\t\t\t\t     const pjsip_cred_info *cred,\n\t\t\t\t     const pj_str_t *method,\n\t\t\t\t     pjsip_digest_credential *auth);\n\n\n/** \n * This structure describes credential information. \n * A credential information is a static, persistent information that identifies\n * username and password required to authorize to a specific realm.\n *\n * Note that since PJSIP 0.7.0.1, it is possible to make a credential that is\n * valid for any realms, by setting the realm to star/wildcard character,\n * i.e. realm = pj_str(\"*\");.\n */\nstruct pjsip_cred_info\n{\n    pj_str_t    realm;\t\t/**< Realm. Use \"*\" to make a credential that\n\t\t\t\t     can be used to authenticate against any\n\t\t\t\t     challenges.\t\t\t    */\n    pj_str_t\tscheme;\t\t/**< Scheme (e.g. \"digest\").\t\t    */\n    pj_str_t\tusername;\t/**< User name.\t\t\t\t    */\n    int\t\tdata_type;\t/**< Type of data (0 for plaintext passwd). */\n    pj_str_t\tdata;\t\t/**< The data, which can be a plaintext \n\t\t\t\t     password or a hashed digest.\t    */\n\n    /** Extended data */\n    union {\n\t/** Digest AKA credential information. Note that when AKA credential\n\t *  is being used, the \\a data field of this #pjsip_cred_info is\n\t *  not used, but it still must be initialized to an empty string.\n\t * Please see \\ref PJSIP_AUTH_AKA_API for more information.\n\t */\n\tstruct {\n\t    pj_str_t\t  k;\t/**< Permanent subscriber key.\t\t*/\n\t    pj_str_t\t  op;\t/**< Operator variant key.\t\t*/\n\t    pj_str_t\t  amf;\t/**< Authentication Management Field\t*/\n\t    pjsip_cred_cb cb;\t/**< Callback to create AKA digest.\t*/\n\t} aka;\n\n    } ext;\n};\n\n/**\n * This structure describes cached value of previously sent Authorization\n * or Proxy-Authorization header. The authentication framework keeps a list\n * of this structure and will resend the same header to the same server\n * as long as the method, uri, and nonce stays the same.\n */\ntypedef struct pjsip_cached_auth_hdr\n{\n    /** Standard list member */\n    PJ_DECL_LIST_MEMBER(struct pjsip_cached_auth_hdr);\n\n    pjsip_method\t     method;\t/**< To quickly see the method. */\n    pjsip_authorization_hdr *hdr;\t/**< The cached header.\t\t*/\n\n} pjsip_cached_auth_hdr;\n\n\n/**\n * This structure describes authentication information for the specified\n * realm. Each instance of this structure describes authentication \"session\"\n * between this endpoint and remote server. This \"session\" information is\n * usefull to keep information that persists for more than one challenge,\n * such as nonce-count and cnonce value.\n *\n * Other than that, this structure also keeps the last authorization headers\n * that have been sent in the cache list.\n */\ntypedef struct pjsip_cached_auth\n{\n    /** Standard list member */\n    PJ_DECL_LIST_MEMBER(struct pjsip_cached_auth);\n\n    pj_pool_t\t\t\t*pool;      /**< Pool for cached auth\t    */\n    pj_str_t\t\t\t realm;\t    /**< Realm.\t\t\t    */\n    pj_bool_t\t\t\t is_proxy;  /**< Server type (401/407)\t    */\n    pjsip_auth_qop_type\t\t qop_value; /**< qop required by server.    */\n    unsigned\t\t\t stale_cnt; /**< Number of stale retry.\t    */\n#if PJSIP_AUTH_QOP_SUPPORT\n    pj_uint32_t\t\t\t nc;\t    /**< Nonce count.\t\t    */\n    pj_str_t\t\t\t cnonce;    /**< Cnonce value.\t\t    */\n#endif\n    pjsip_www_authenticate_hdr\t*last_chal; /**< Last challenge seen.\t    */\n#if PJSIP_AUTH_HEADER_CACHING\n    pjsip_cached_auth_hdr\t cached_hdr;/**< List of cached header for\n\t\t\t\t\t\t each method.\t\t    */\n#endif\n\n} pjsip_cached_auth;\n\n\n/**\n * This structure describes client authentication session preference.\n * The preference can be set by calling #pjsip_auth_clt_set_prefs().\n */\ntypedef struct pjsip_auth_clt_pref\n{\n    /**\n     * If this flag is set, the authentication client framework will\n     * send an empty Authorization header in each initial request.\n     * Default is no.\n     */\n    pj_bool_t\tinitial_auth;\n\n    /**\n     * Specify the algorithm to use when empty Authorization header \n     * is to be sent for each initial request (see above)\n     */\n    pj_str_t\talgorithm;\n\n} pjsip_auth_clt_pref;\n\n\n/**\n * Duplicate a client authentication preference setting.\n *\n * @param pool\t    The memory pool.\n * @param dst\t    Destination client authentication preference.\n * @param src\t    Source client authentication preference.\n */\nPJ_DECL(void) pjsip_auth_clt_pref_dup(pj_pool_t *pool,\n\t\t\t\t      pjsip_auth_clt_pref *dst,\n\t\t\t\t      const pjsip_auth_clt_pref *src);\n\n\n/**\n * This structure describes client authentication sessions. It keeps\n * all the information needed to authorize the client against all downstream \n * servers.\n */\ntypedef struct pjsip_auth_clt_sess\n{\n    pj_pool_t\t\t*pool;\t\t/**< Pool to use.\t\t    */\n    pjsip_endpoint\t*endpt;\t\t/**< Endpoint where this belongs.   */\n    pjsip_auth_clt_pref  pref;\t\t/**< Preference/options.\t    */\n    unsigned\t\t cred_cnt;\t/**< Number of credentials.\t    */\n    pjsip_cred_info\t*cred_info;\t/**< Array of credential information*/\n    pjsip_cached_auth\t cached_auth;\t/**< Cached authorization info.\t    */\n\n} pjsip_auth_clt_sess;\n\n\n/**\n * Duplicate a credential info.\n *\n * @param pool\t    The memory pool.\n * @param dst\t    Destination credential.\n * @param src\t    Source credential.\n */\nPJ_DECL(void) pjsip_cred_info_dup(pj_pool_t *pool,\n\t\t\t\t  pjsip_cred_info *dst,\n\t\t\t\t  const pjsip_cred_info *src);\n\n/**\n * Compare two credential infos.\n *\n * @param cred1\t    The credential info to compare.\n * @param cred2\t    The credential info to compare.\n *\n * @return\t    0 if both credentials are equal.\n */\nPJ_DECL(int) pjsip_cred_info_cmp(const pjsip_cred_info *cred1,\n\t\t\t\t const pjsip_cred_info *cred2);\n\n\n/**\n * Type of function to lookup credential for the specified name.\n *\n * @param pool\t\tPool to initialize the credential info.\n * @param realm\t\tRealm to find the account.\n * @param acc_name\tAccount name to look for.\n * @param cred_info\tThe structure to put the credential when it's found.\n *\n * @return\t\tThe function MUST return PJ_SUCCESS when it found\n *\t\t\ta correct credential for the specified account and\n *\t\t\trealm. Otherwise it may return PJSIP_EAUTHACCNOTFOUND\n *\t\t\tor PJSIP_EAUTHACCDISABLED.\n */\ntypedef pj_status_t pjsip_auth_lookup_cred( pj_pool_t *pool,\n\t\t\t\t\t    const pj_str_t *realm,\n\t\t\t\t\t    const pj_str_t *acc_name,\n\t\t\t\t\t    pjsip_cred_info *cred_info );\n\n\n/**\n * This structure describes input param for credential lookup.\n */\ntypedef struct pjsip_auth_lookup_cred_param\n{\n    pj_str_t realm;\t    /**< Realm to find the account.\t\t*/\n    pj_str_t acc_name;\t    /**< Account name to look for.\t\t*/\n    pjsip_rx_data *rdata;   /**< Incoming request to be authenticated.\t*/\n\n} pjsip_auth_lookup_cred_param;\n\n\n/**\n * Type of function to lookup credential for the specified name.\n *\n * @param pool\t\tPool to initialize the credential info.\n * @param param\t\tThe input param for credential lookup.\n * @param cred_info\tThe structure to put the credential when it's found.\n *\n * @return\t\tThe function MUST return PJ_SUCCESS when it found\n *\t\t\ta correct credential for the specified account and\n *\t\t\trealm. Otherwise it may return PJSIP_EAUTHACCNOTFOUND\n *\t\t\tor PJSIP_EAUTHACCDISABLED.\n */\ntypedef pj_status_t pjsip_auth_lookup_cred2(\n\t\t\t\tpj_pool_t *pool,\n\t\t\t\tconst pjsip_auth_lookup_cred_param *param,\n\t\t\t\tpjsip_cred_info *cred_info );\n\n\n/** Flag to specify that server is a proxy. */\n#define PJSIP_AUTH_SRV_IS_PROXY\t    1\n\n/**\n * This structure describes server authentication information.\n */\ntypedef struct pjsip_auth_srv\n{\n    pj_str_t\t\t     realm;\t/**< Realm to serve.\t\t    */\n    pj_bool_t\t\t     is_proxy;\t/**< Will issue 407 instead of 401  */\n    pjsip_auth_lookup_cred  *lookup;\t/**< Lookup function.\t\t    */\n    pjsip_auth_lookup_cred2 *lookup2;\t/**< Lookup function with additional\n\t\t\t\t\t     info in its input param.\t    */\n} pjsip_auth_srv;\n\n\n/**\n * Initialize client authentication session data structure, and set the \n * session to use pool for its subsequent memory allocation. The argument \n * options should be set to zero for this PJSIP version.\n *\n * @param sess\t\tThe client authentication session.\n * @param endpt\t\tEndpoint where this session belongs.\n * @param pool\t\tPool to use.\n * @param options\tMust be zero.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_init( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t  pjsip_endpoint *endpt,\n\t\t\t\t\t  pj_pool_t *pool, \n\t\t\t\t\t  unsigned options);\n\n\n/**\n * Deinitialize client authentication session data structure.\n *\n * @param sess\t\tThe client authentication session.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_deinit( pjsip_auth_clt_sess *sess);\n\n\n/**\n * Clone client initialization session. \n *\n * @param pool\t\tPool to use.\n * @param sess\t\tStructure to put the duplicated session.\n * @param rhs\t\tThe client session to be cloned.\n *\n * @return\t\tPJ_SUCCESS on success;\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_clone( pj_pool_t *pool,\n\t\t\t\t\t   pjsip_auth_clt_sess *sess,\n\t\t\t\t\t   const pjsip_auth_clt_sess *rhs);\n\n/**\n * Set the credentials to be used during the session. This will duplicate \n * the specified credentials using client authentication's pool.\n *\n * @param sess\t\tThe client authentication session.\n * @param cred_cnt\tNumber of credentials.\n * @param c\t\tArray of credentials.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_set_credentials( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t\t     int cred_cnt,\n\t\t\t\t\t\t     const pjsip_cred_info *c);\n\n\n/**\n * Set the preference for the client authentication session.\n *\n * @param sess\t\tThe client authentication session.\n * @param p\t\tPreference.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,\n\t\t\t\t\t      const pjsip_auth_clt_pref *p);\n\n\n/**\n * Get the preference for the client authentication session.\n *\n * @param sess\t\tThe client authentication session.\n * @param p\t\tPointer to receive the preference.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_get_prefs(pjsip_auth_clt_sess *sess,\n\t\t\t\t\t      pjsip_auth_clt_pref *p);\n\n/**\n * Initialize new request message with authorization headers.\n * This function will put Authorization/Proxy-Authorization headers to the\n * outgoing request message. If caching is enabled (PJSIP_AUTH_HEADER_CACHING)\n * and the session has previously sent Authorization/Proxy-Authorization header\n * with the same method, then the same Authorization/Proxy-Authorization header\n * will be resent from the cache only if qop is not present. If the stack is \n * configured to automatically generate next Authorization/Proxy-Authorization\n * headers (PJSIP_AUTH_AUTO_SEND_NEXT flag), then new Authorization/Proxy-\n * Authorization headers are calculated and generated when they are not present\n * in the case or if authorization session has qop.\n *\n * If both PJSIP_AUTH_HEADER_CACHING flag and PJSIP_AUTH_AUTO_SEND_NEXT flag\n * are not set, this function will do nothing. The stack then will only send\n * Authorization/Proxy-Authorization to respond 401/407 response.\n *\n * @param sess\t\tThe client authentication session.\n * @param tdata\t\tThe request message to be initialized.\n *\n * @return\t\tPJ_SUCCESS if successfull.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_init_req( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t      pjsip_tx_data *tdata );\n\n\n/**\n * Call this function when a transaction failed with 401 or 407 response.\n * This function will reinitialize the original request message with the\n * authentication challenge found in the response message, and add the\n * new authorization header in the authorization cache.\n *\n * Note that upon return the reference counter of the new transmit data\n * will be set to 1.\n *\n * @param sess\t\tThe client authentication session.\n * @param rdata\t\tThe response message containing 401/407 status.\n * @param old_request\tThe original request message, which will be re-\n *\t\t\tcreated with authorization info.\n * @param new_request\tPointer to receive new request message which\n *\t\t\twill contain all required authorization headers.\n *\n * @return\t\tPJ_SUCCESS if new request can be successfully\n *\t\t\tcreated to respond all the authentication\n *\t\t\tchallenges.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_reinit_req(\tpjsip_auth_clt_sess *sess,\n\t\t\t\t\t\tconst pjsip_rx_data *rdata,\n\t\t\t\t\t\tpjsip_tx_data *old_request,\n\t\t\t\t\t\tpjsip_tx_data **new_request );\n\n/**\n * Initialize server authorization session data structure to serve the \n * specified realm and to use lookup_func function to look for the credential \n * info. \n *\n * @param pool\t\tPool used to initialize the authentication server.\n * @param auth_srv\tThe authentication server structure.\n * @param realm\t\tRealm to be served by the server.\n * @param lookup\tAccount lookup function.\n * @param options\tOptions, bitmask of:\n *\t\t\t- PJSIP_AUTH_SRV_IS_PROXY: to specify that the server\n *\t\t\t  will authorize clients as a proxy server (instead of\n *\t\t\t  as UAS), which means that Proxy-Authenticate will \n *\t\t\t  be used instead of WWW-Authenticate.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_srv_init( pj_pool_t *pool,\n\t\t\t\t\t  pjsip_auth_srv *auth_srv,\n\t\t\t\t\t  const pj_str_t *realm,\n\t\t\t\t\t  pjsip_auth_lookup_cred *lookup,\n\t\t\t\t\t  unsigned options );\n\n\n/**\n * This structure describes initialization settings of server authorization\n * session.\n */\ntypedef struct pjsip_auth_srv_init_param\n{\n    /**\n     * Realm to be served by the server.\n     */\n    const pj_str_t\t\t*realm;\n\n    /**\n     * Account lookup function.\n     */\n    pjsip_auth_lookup_cred2\t*lookup2;\n\n    /**\n     * Options, bitmask of:\n     * - PJSIP_AUTH_SRV_IS_PROXY: to specify that the server will authorize\n     *   clients as a proxy server (instead of as UAS), which means that\n     *   Proxy-Authenticate will be used instead of WWW-Authenticate.\n     */\n    unsigned\t\t\t options;\n\n} pjsip_auth_srv_init_param;\n\n\n/**\n * Initialize server authorization session data structure to serve the \n * specified realm and to use lookup_func function to look for the credential\n * info. \n *\n * @param pool\t\tPool used to initialize the authentication server.\n * @param auth_srv\tThe authentication server structure.\n * @param param\t\tThe initialization param.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_srv_init2(\n\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t    pjsip_auth_srv *auth_srv,\n\t\t\t\t    const pjsip_auth_srv_init_param *param);\n\n/**\n * Request the authorization server framework to verify the authorization \n * information in the specified request in rdata.\n *\n * @param auth_srv\tThe server authentication structure.\n * @param rdata\t\tIncoming request to be authenticated.\n * @param status_code\tWhen not null, it will be filled with suitable \n *\t\t\tstatus code to be sent to the client.\n *\n * @return\t\tPJ_SUCCESS if request is successfully authenticated.\n *\t\t\tOtherwise the function may return one of the\n *\t\t\tfollowing error codes:\n *\t\t\t- PJSIP_EAUTHNOAUTH\n *\t\t\t- PJSIP_EINVALIDAUTHSCHEME\n *\t\t\t- PJSIP_EAUTHACCNOTFOUND\n *\t\t\t- PJSIP_EAUTHACCDISABLED\n *\t\t\t- PJSIP_EAUTHINVALIDREALM\n *\t\t\t- PJSIP_EAUTHINVALIDDIGEST\n */\nPJ_DECL(pj_status_t) pjsip_auth_srv_verify( pjsip_auth_srv *auth_srv,\n\t\t\t\t\t    pjsip_rx_data *rdata,\n\t\t\t\t\t    int *status_code );\n\n\n/**\n * Add authentication challenge headers to the outgoing response in tdata. \n * Application may specify its customized nonce and opaque for the challenge, \n * or can leave the value to NULL to make the function fills them in with \n * random characters.\n *\n * @param auth_srv\tThe server authentication structure.\n * @param qop\t\tOptional qop value.\n * @param nonce\t\tOptional nonce value.\n * @param opaque\tOptional opaque value.\n * @param stale\t\tStale indication.\n * @param tdata\t\tThe outgoing response message. The response must have\n *\t\t\t401 or 407 response code.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_srv_challenge( pjsip_auth_srv *auth_srv,\n\t\t\t\t\t       const pj_str_t *qop,\n\t\t\t\t\t       const pj_str_t *nonce,\n\t\t\t\t\t       const pj_str_t *opaque,\n\t\t\t\t\t       pj_bool_t stale,\n\t\t\t\t\t       pjsip_tx_data *tdata);\n\n/**\n * Helper function to create MD5 digest out of the specified \n * parameters.\n *\n * @param result\tString to store the response digest. This string\n *\t\t\tmust have been preallocated by caller with the \n *\t\t\tbuffer at least PJSIP_MD5STRLEN (32 bytes) in size.\n * @param nonce\t\tOptional nonce.\n * @param nc\t\tNonce count.\n * @param cnonce\tOptional cnonce.\n * @param qop\t\tOptional qop.\n * @param uri\t\tURI.\n * @param realm\t\tRealm.\n * @param cred_info\tCredential info.\n * @param method\tSIP method.\n */\nPJ_DECL(void) pjsip_auth_create_digest(pj_str_t *result,\n\t\t\t\t       const pj_str_t *nonce,\n\t\t\t\t       const pj_str_t *nc,\n\t\t\t\t       const pj_str_t *cnonce,\n\t\t\t\t       const pj_str_t *qop,\n\t\t\t\t       const pj_str_t *uri,\n\t\t\t\t       const pj_str_t *realm,\n\t\t\t\t       const pjsip_cred_info *cred_info,\n\t\t\t\t       const pj_str_t *method);\n\n/**\n * @}\n */\n\n\n\nPJ_END_DECL\n\n\n#endif\t/* __PJSIP_AUTH_SIP_AUTH_H__ */\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjsip/sip_auth_aka.h>\n#include <pjsip/sip_errno.h>\n#include <pjlib-util/base64.h>\n#include <pjlib-util/md5.h>\n#include <pjlib-util/hmac_md5.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n#if PJSIP_HAS_DIGEST_AKA_AUTH\n\n#include \"../../third_party/milenage/milenage.h\"\n\n/*\n * Create MD5-AKA1 digest response.\n */\nPJ_DEF(pj_status_t) pjsip_auth_create_aka_response( \n\t\t\t\t\t     pj_pool_t *pool,\n\t\t\t\t\t     const pjsip_digest_challenge *chal,\n\t\t\t\t\t     const pjsip_cred_info *cred,\n\t\t\t\t\t     const pj_str_t *method,\n\t\t\t\t\t     pjsip_digest_credential *auth)\n{\n    pj_str_t nonce_bin;\n    int aka_version;\n    const pj_str_t pjsip_AKAv1_MD5 = { \"AKAv1-MD5\", 9 };\n    const pj_str_t pjsip_AKAv2_MD5 = { \"AKAv2-MD5\", 9 };\n    pj_uint8_t *chal_rand, *chal_sqnxoraka, *chal_mac;\n    pj_uint8_t k[PJSIP_AKA_KLEN];\n    pj_uint8_t op[PJSIP_AKA_OPLEN];\n    pj_uint8_t amf[PJSIP_AKA_AMFLEN];\n    pj_uint8_t res[PJSIP_AKA_RESLEN];\n    pj_uint8_t ck[PJSIP_AKA_CKLEN];\n    pj_uint8_t ik[PJSIP_AKA_IKLEN];\n    pj_uint8_t ak[PJSIP_AKA_AKLEN];\n    pj_uint8_t sqn[PJSIP_AKA_SQNLEN];\n    pj_uint8_t xmac[PJSIP_AKA_MACLEN];\n    pjsip_cred_info aka_cred;\n    int i, len;\n    pj_status_t status;\n\n    /* Check the algorithm is supported. */\n    if (chal->algorithm.slen==0 || pj_stricmp2(&chal->algorithm, \"md5\") == 0) {\n\t/*\n\t * A normal MD5 authentication is requested. Fallbackt to the usual\n\t * MD5 digest creation.\n\t */\n\tpjsip_auth_create_digest(&auth->response, &auth->nonce, &auth->nc,\n\t\t\t\t &auth->cnonce, &auth->qop, &auth->uri,\n\t\t\t\t &auth->realm, cred, method);\n\treturn PJ_SUCCESS;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5) == 0) {\n\t/*\n\t * AKA version 1 is requested.\n\t */\n\taka_version = 1;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv2_MD5) == 0) {\n\t/*\n\t * AKA version 2 is requested.\n\t */\n\taka_version = 2;\n\n    } else {\n\t/* Unsupported algorithm */\n\treturn PJSIP_EINVALIDALGORITHM;\n    }\n\n    /* Decode nonce */\n    nonce_bin.slen = len = PJ_BASE64_TO_BASE256_LEN(chal->nonce.slen);\n    nonce_bin.ptr = pj_pool_alloc(pool, nonce_bin.slen + 1);\n    status = pj_base64_decode(&chal->nonce, (pj_uint8_t*)nonce_bin.ptr, &len);\n    nonce_bin.slen = len;\n    if (status != PJ_SUCCESS)\n\treturn PJSIP_EAUTHINNONCE;\n\n    if (nonce_bin.slen < PJSIP_AKA_RANDLEN + PJSIP_AKA_AUTNLEN)\n\treturn PJSIP_EAUTHINNONCE;\n\n    /* Get RAND, AUTN, and MAC */\n    chal_rand = (pj_uint8_t*)(nonce_bin.ptr + 0);\n    chal_sqnxoraka = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN);\n    chal_mac = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN + \n\t\t\t      PJSIP_AKA_SQNLEN + PJSIP_AKA_AMFLEN);\n\n    /* Copy k. op, and amf */\n    pj_bzero(k, sizeof(k));\n    pj_bzero(op, sizeof(op));\n    pj_bzero(amf, sizeof(amf));\n\n    if (cred->ext.aka.k.slen)\n\tpj_memcpy(k, cred->ext.aka.k.ptr, cred->ext.aka.k.slen);\n    if (cred->ext.aka.op.slen)\n\tpj_memcpy(op, cred->ext.aka.op.ptr, cred->ext.aka.op.slen);\n    if (cred->ext.aka.amf.slen)\n\tpj_memcpy(amf, cred->ext.aka.amf.ptr, cred->ext.aka.amf.slen);\n\n    /* Given key K and random challenge RAND, compute response RES,\n     * confidentiality key CK, integrity key IK and anonymity key AK.\n     */\n    f2345(k, chal_rand, res, ck, ik, ak, op);\n\n    /* Compute sequence number SQN */\n    for (i=0; i<PJSIP_AKA_SQNLEN; ++i)\n\tsqn[i] = (pj_uint8_t) (chal_sqnxoraka[i] ^ ak[i]);\n\n    /* Verify MAC in the challenge */\n    /* Compute XMAC */\n    f1(k, chal_rand, sqn, amf, xmac, op);\n\n    if (pj_memcmp(chal_mac, xmac, PJSIP_AKA_MACLEN) != 0) {\n\treturn PJSIP_EAUTHINNONCE;\n    }\n\n    /* Build a temporary credential info to create MD5 digest, using\n     * \"res\" as the password. \n     */\n    pj_memcpy(&aka_cred, cred, sizeof(aka_cred));\n    aka_cred.data_type = PJSIP_CRED_DATA_PLAIN_PASSWD;\n\n    /* Create a response */\n    if (aka_version == 1) {\n\t/*\n\t * For AKAv1, the password is RES\n\t */\n\taka_cred.data.ptr = (char*)res;\n\taka_cred.data.slen = PJSIP_AKA_RESLEN;\n\n\tpjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n\n    } else if (aka_version == 2) {\n\n\t/*\n\t * For AKAv2, password is base64 encoded [1] parameters:\n\t *    PRF(RES||IK||CK,\"http-digest-akav2-password\")\n\t *\n\t * The pseudo-random function (PRF) is HMAC-MD5 in this case.\n\t */\n\n\tpj_str_t resikck;\n\tconst pj_str_t AKAv2_Passwd = { \"http-digest-akav2-password\", 26 };\n\tpj_uint8_t hmac_digest[16];\n\tchar tmp_buf[48];\n\tint hmac64_len;\n\n\tresikck.slen = PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN + PJSIP_AKA_CKLEN;\n\tpj_assert(resikck.slen <= PJ_ARRAY_SIZE(tmp_buf));\n\tresikck.ptr = tmp_buf;\n\tpj_memcpy(resikck.ptr + 0, res, PJSIP_AKA_RESLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN, ik, PJSIP_AKA_IKLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN,\n\t          ck, PJSIP_AKA_CKLEN);\n\n\tpj_hmac_md5((const pj_uint8_t*)AKAv2_Passwd.ptr, AKAv2_Passwd.slen,\n\t            (const pj_uint8_t*)resikck.ptr, resikck.slen,\n\t            hmac_digest);\n\n\taka_cred.data.slen = hmac64_len =\n\t\tPJ_BASE256_TO_BASE64_LEN(PJ_ARRAY_SIZE(hmac_digest));\n\tpj_assert(aka_cred.data.slen+1 <= PJ_ARRAY_SIZE(tmp_buf));\n\taka_cred.data.ptr = tmp_buf;\n\tpj_base64_encode(hmac_digest, PJ_ARRAY_SIZE(hmac_digest),\n\t                 aka_cred.data.ptr, &len);\n\taka_cred.data.slen = hmac64_len;\n\n\tpjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n\n    } else {\n\tpj_assert(!\"Bug!\");\n\treturn PJ_EBUG;\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\n#endif\t/* PJSIP_HAS_DIGEST_AKA_AUTH */\n\n", "/* $Id$ */\n/*\n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <pjsip/sip_auth.h>\n#include <pjsip/sip_auth_parser.h>\t/* just to get pjsip_DIGEST_STR */\n#include <pjsip/sip_auth_aka.h>\n#include <pjsip/sip_transport.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_util.h>\n#include <pjlib-util/md5.h>\n#include <pj/log.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/guid.h>\n#include <pj/assert.h>\n#include <pj/ctype.h>\n\n\n#if PJ_HAS_SSL_SOCK && PJ_SSL_SOCK_IMP==PJ_SSL_SOCK_IMP_OPENSSL\n#  if !defined(PJSIP_AUTH_HAS_DIGEST_SHA256)\n#    define PJSIP_AUTH_HAS_DIGEST_SHA256    1\n#  endif\n#else\n#  undef  PJSIP_AUTH_HAS_DIGEST_SHA256\n#  define PJSIP_AUTH_HAS_DIGEST_SHA256\t    0\n#endif\n\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n#  include <openssl/sha.h>\n#  ifdef _MSC_VER\n#    include <openssl/opensslv.h>\n#    if OPENSSL_VERSION_NUMBER >= 0x10100000L\n#      pragma comment(lib, \"libcrypto\")\n#    else\n#      pragma comment(lib, \"libeay32\")\n#      pragma comment(lib, \"ssleay32\")\n#    endif\n#  endif\n#endif\n\n/* A macro just to get rid of type mismatch between char and unsigned char */\n#define MD5_APPEND(pms,buf,len)\tpj_md5_update(pms, (const pj_uint8_t*)buf, \\\n\t\t\t\t\t      (unsigned)len)\n\n/* Logging. */\n#define THIS_FILE   \"sip_auth_client.c\"\n#if 0\n#  define AUTH_TRACE_(expr)  PJ_LOG(3, expr)\n#else\n#  define AUTH_TRACE_(expr)\n#endif\n\n#define PASSWD_MASK\t    0x000F\n#define EXT_MASK\t    0x00F0\n\n\nstatic void dup_bin(pj_pool_t *pool, pj_str_t *dst, const pj_str_t *src)\n{\n    dst->slen = src->slen;\n\n    if (dst->slen) {\n\tdst->ptr = (char*) pj_pool_alloc(pool, src->slen);\n\tpj_memcpy(dst->ptr, src->ptr, src->slen);\n    } else {\n\tdst->ptr = NULL;\n    }\n}\n\nPJ_DEF(void) pjsip_cred_info_dup(pj_pool_t *pool,\n\t\t\t\t pjsip_cred_info *dst,\n\t\t\t\t const pjsip_cred_info *src)\n{\n    pj_memcpy(dst, src, sizeof(pjsip_cred_info));\n\n    pj_strdup_with_null(pool, &dst->realm, &src->realm);\n    pj_strdup_with_null(pool, &dst->scheme, &src->scheme);\n    pj_strdup_with_null(pool, &dst->username, &src->username);\n    pj_strdup_with_null(pool, &dst->data, &src->data);\n\n    if ((dst->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\tdup_bin(pool, &dst->ext.aka.k, &src->ext.aka.k);\n\tdup_bin(pool, &dst->ext.aka.op, &src->ext.aka.op);\n\tdup_bin(pool, &dst->ext.aka.amf, &src->ext.aka.amf);\n    }\n}\n\n\nPJ_DEF(int) pjsip_cred_info_cmp(const pjsip_cred_info *cred1,\n\t\t\t\tconst pjsip_cred_info *cred2)\n{\n    int result;\n\n    result = pj_strcmp(&cred1->realm, &cred2->realm);\n    if (result) goto on_return;\n    result = pj_strcmp(&cred1->scheme, &cred2->scheme);\n    if (result) goto on_return;\n    result = pj_strcmp(&cred1->username, &cred2->username);\n    if (result) goto on_return;\n    result = pj_strcmp(&cred1->data, &cred2->data);\n    if (result) goto on_return;\n    result = (cred1->data_type != cred2->data_type);\n    if (result) goto on_return;\n\n    if ((cred1->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\tresult = pj_strcmp(&cred1->ext.aka.k, &cred2->ext.aka.k);\n\tif (result) goto on_return;\n\tresult = pj_strcmp(&cred1->ext.aka.op, &cred2->ext.aka.op);\n\tif (result) goto on_return;\n\tresult = pj_strcmp(&cred1->ext.aka.amf, &cred2->ext.aka.amf);\n\tif (result) goto on_return;\n    }\n\non_return:\n    return result;\n}\n\nPJ_DEF(void) pjsip_auth_clt_pref_dup( pj_pool_t *pool,\n\t\t\t\t      pjsip_auth_clt_pref *dst,\n\t\t\t\t      const pjsip_auth_clt_pref *src)\n{\n    pj_memcpy(dst, src, sizeof(pjsip_auth_clt_pref));\n    pj_strdup_with_null(pool, &dst->algorithm, &src->algorithm);\n}\n\n\n/* Transform digest to string.\n * output must be at least PJSIP_MD5STRLEN+1 bytes.\n *\n * NOTE: THE OUTPUT STRING IS NOT NULL TERMINATED!\n */\nstatic void digestNtoStr(const unsigned char digest[], int n, char *output)\n{\n    int i;\n    for (i = 0; i<n; ++i) {\n        pj_val_to_hex_digit(digest[i], output);\n        output += 2;\n    }\n}\n\n\n/*\n * Create response digest based on the parameters and store the\n * digest ASCII in 'result'.\n */\nPJ_DEF(void) pjsip_auth_create_digest( pj_str_t *result,\n\t\t\t\t       const pj_str_t *nonce,\n\t\t\t\t       const pj_str_t *nc,\n\t\t\t\t       const pj_str_t *cnonce,\n\t\t\t\t       const pj_str_t *qop,\n\t\t\t\t       const pj_str_t *uri,\n\t\t\t\t       const pj_str_t *realm,\n\t\t\t\t       const pjsip_cred_info *cred_info,\n\t\t\t\t       const pj_str_t *method)\n{\n    char ha1[PJSIP_MD5STRLEN];\n    char ha2[PJSIP_MD5STRLEN];\n    unsigned char digest[16];\n    pj_md5_context pms;\n\n    pj_assert(result->slen >= PJSIP_MD5STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n    if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_PLAIN_PASSWD) {\n\t/***\n\t *** ha1 = MD5(username \":\" realm \":\" password)\n\t ***/\n\tpj_md5_init(&pms);\n\tMD5_APPEND( &pms, cred_info->username.ptr, cred_info->username.slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, realm->ptr, realm->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tpj_md5_final(&pms, digest);\n\n\tdigestNtoStr(digest, 16, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n\tpj_assert(cred_info->data.slen == 32);\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n    }\n\n    AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n\n    /***\n     *** ha2 = MD5(method \":\" req_uri)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, method->ptr, method->slen);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, uri->ptr, uri->slen);\n    pj_md5_final(&pms, digest);\n    digestNtoStr(digest, 16, ha2);\n\n    AUTH_TRACE_((THIS_FILE, \"  ha2=%.32s\", ha2));\n\n    /***\n     *** When qop is not used:\n     ***    response = MD5(ha1 \":\" nonce \":\" ha2)\n     ***\n     *** When qop=auth is used:\n     ***    response = MD5(ha1 \":\" nonce \":\" nc \":\" cnonce \":\" qop \":\" ha2)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, ha1, PJSIP_MD5STRLEN);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, nonce->ptr, nonce->slen);\n    if (qop && qop->slen != 0) {\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, nc->ptr, nc->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cnonce->ptr, cnonce->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, qop->ptr, qop->slen);\n    }\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, ha2, PJSIP_MD5STRLEN);\n\n    /* This is the final response digest. */\n    pj_md5_final(&pms, digest);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_MD5STRLEN;\n    digestNtoStr(digest, 16, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n}\n\n\n/*\n * Create response SHA-256 digest based on the parameters and store the\n * digest ASCII in 'result'.\n */\nPJ_DEF(void) pjsip_auth_create_digestSHA256(pj_str_t *result,\n\t\t\t\t\t    const pj_str_t *nonce,\n\t\t\t\t\t    const pj_str_t *nc,\n\t\t\t\t\t    const pj_str_t *cnonce,\n\t\t\t\t\t    const pj_str_t *qop,\n\t\t\t\t\t    const pj_str_t *uri,\n\t\t\t\t\t    const pj_str_t *realm,\n\t\t\t\t\t    const pjsip_cred_info *cred_info,\n\t\t\t\t\t    const pj_str_t *method)\n{\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n\n    char ha1[PJSIP_SHA256STRLEN];\n    char ha2[PJSIP_SHA256STRLEN];\n    unsigned char digest[32];\n    SHA256_CTX pms;\n\n    pj_assert(result->slen >= PJSIP_SHA256STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n    if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_PLAIN_PASSWD)\n    {\n\t/***\n\t *** ha1 = SHA256(username \":\" realm \":\" password)\n\t ***/\n\tSHA256_Init(&pms);\n\tSHA256_Update( &pms, cred_info->username.ptr,\n\t\t       cred_info->username.slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, realm->ptr, realm->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tSHA256_Final(digest, &pms);\n\n\tdigestNtoStr(digest, 32, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST)\n    {\n\tpj_assert(cred_info->data.slen == 32);\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n    }\n\n    AUTH_TRACE_((THIS_FILE, \" ha1=%.64s\", ha1));\n\n    /***\n     *** ha2 = SHA256(method \":\" req_uri)\n     ***/\n    SHA256_Init(&pms);\n    SHA256_Update( &pms, method->ptr, method->slen);\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, uri->ptr, uri->slen);\n    SHA256_Final( digest, &pms);\n    digestNtoStr(digest, 32, ha2);\n\n    AUTH_TRACE_((THIS_FILE, \" ha2=%.64s\", ha2));\n\n    /***\n     *** When qop is not used:\n     ***   response = SHA256(ha1 \":\" nonce \":\" ha2)\n     ***\n     *** When qop=auth is used:\n     ***   response = SHA256(ha1 \":\" nonce \":\" nc \":\" cnonce \":\" qop \":\" ha2)\n     ***/\n    SHA256_Init(&pms);\n    SHA256_Update( &pms, ha1, PJSIP_SHA256STRLEN);\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, nonce->ptr, nonce->slen);\n    if (qop && qop->slen != 0) {\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, nc->ptr, nc->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, cnonce->ptr, cnonce->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, qop->ptr, qop->slen);\n    }\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, ha2, PJSIP_SHA256STRLEN);\n\n    /* This is the final response digest. */\n    SHA256_Final(digest, &pms);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_SHA256STRLEN;\n    digestNtoStr(digest, 32, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \" digest=%.64s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n\n#else\n    PJ_UNUSED_ARG(result);\n    PJ_UNUSED_ARG(nonce);\n    PJ_UNUSED_ARG(nc);\n    PJ_UNUSED_ARG(cnonce);\n    PJ_UNUSED_ARG(qop);\n    PJ_UNUSED_ARG(uri);\n    PJ_UNUSED_ARG(realm);\n    PJ_UNUSED_ARG(cred_info);\n    PJ_UNUSED_ARG(method);\n#endif\n}\n\n\n/*\n * Finds out if qop offer contains \"auth\" token.\n */\nstatic pj_bool_t has_auth_qop( pj_pool_t *pool, const pj_str_t *qop_offer)\n{\n    pj_str_t qop;\n    char *p;\n\n    pj_strdup_with_null( pool, &qop, qop_offer);\n    p = qop.ptr;\n    while (*p) {\n\t*p = (char)pj_tolower(*p);\n\t++p;\n    }\n\n    p = qop.ptr;\n    while (*p) {\n\tif (*p=='a' && *(p+1)=='u' && *(p+2)=='t' && *(p+3)=='h') {\n\t    int e = *(p+4);\n\t    if (e=='\"' || e==',' || e==0)\n\t\treturn PJ_TRUE;\n\t    else\n\t\tp += 4;\n\t} else {\n\t    ++p;\n\t}\n    }\n\n    return PJ_FALSE;\n}\n\n/*\n * Generate response digest.\n * Most of the parameters to generate the digest (i.e. username, realm, uri,\n * and nonce) are expected to be in the credential. Additional parameters (i.e.\n * password and method param) should be supplied in the argument.\n *\n * The resulting digest will be stored in cred->response.\n * The pool is used to allocate 32 bytes to store the digest in cred->response.\n */\nstatic pj_status_t respond_digest( pj_pool_t *pool,\n\t\t\t\t   pjsip_digest_credential *cred,\n\t\t\t\t   const pjsip_digest_challenge *chal,\n\t\t\t\t   const pj_str_t *uri,\n\t\t\t\t   const pjsip_cred_info *cred_info,\n\t\t\t\t   const pj_str_t *cnonce,\n\t\t\t\t   pj_uint32_t nc,\n\t\t\t\t   const pj_str_t *method)\n{\n    const pj_str_t pjsip_AKAv1_MD5_STR = { \"AKAv1-MD5\", 9 };\n    pj_bool_t algo_sha256 = PJ_FALSE;\n\n    /* Check if algo is sha256 */\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n    algo_sha256 = (pj_stricmp(&chal->algorithm, &pjsip_SHA256_STR)==0);\n#endif\n\n    /* Check algorithm is supported. We support MD5, AKAv1-MD5, and SHA256. */\n    if (chal->algorithm.slen==0 ||\n        (algo_sha256 ||\n\t pj_stricmp(&chal->algorithm, &pjsip_MD5_STR)==0 ||\n         pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5_STR)==0))\n    {\n\tPJ_LOG(4,(THIS_FILE, \"Digest algorithm is \\\"%.*s\\\"\",\n\t\t  chal->algorithm.slen, chal->algorithm.ptr));\n    }\n    else {\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported digest algorithm \\\"%.*s\\\"\",\n\t\t  chal->algorithm.slen, chal->algorithm.ptr));\n\treturn PJSIP_EINVALIDALGORITHM;\n    }\n\n    /* Build digest credential from arguments. */\n    pj_strdup(pool, &cred->username, &cred_info->username);\n    pj_strdup(pool, &cred->realm, &chal->realm);\n    pj_strdup(pool, &cred->nonce, &chal->nonce);\n    pj_strdup(pool, &cred->uri, uri);\n    pj_strdup(pool, &cred->algorithm, &chal->algorithm);\n    pj_strdup(pool, &cred->opaque, &chal->opaque);\n\n    /* Allocate memory. */\n    cred->response.slen = algo_sha256? PJSIP_SHA256STRLEN : PJSIP_MD5STRLEN;\n    cred->response.ptr = (char*) pj_pool_alloc(pool, cred->response.slen);\n\n    if (chal->qop.slen == 0) {\n\t/* Server doesn't require quality of protection. */\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    } else {\n\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    }\n\t}\n\n    } else if (has_auth_qop(pool, &chal->qop)) {\n\t/* Server requires quality of protection.\n\t * We respond with selecting \"qop=auth\" protection.\n\t */\n\tcred->qop = pjsip_AUTH_STR;\n\tcred->nc.ptr = (char*) pj_pool_alloc(pool, 16);\n\tcred->nc.slen = pj_ansi_snprintf(cred->nc.ptr, 16, \"%08u\", nc);\n\n\tif (cnonce && cnonce->slen) {\n\t    pj_strdup(pool, &cred->cnonce, cnonce);\n\t} else {\n\t    pj_str_t dummy_cnonce = { \"b39971\", 6};\n\t    pj_strdup(pool, &cred->cnonce, &dummy_cnonce);\n\t}\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    } else {\n\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    }\n\t}\n\n    } else {\n\t/* Server requires quality protection that we don't support. */\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported qop offer %.*s\",\n\t\t  chal->qop.slen, chal->qop.ptr));\n\treturn PJSIP_EINVALIDQOP;\n    }\n\n    return PJ_SUCCESS;\n}\n\n#if defined(PJSIP_AUTH_QOP_SUPPORT) && PJSIP_AUTH_QOP_SUPPORT!=0\n/*\n * Update authentication session with a challenge.\n */\nstatic void update_digest_session( pjsip_cached_auth *cached_auth,\n\t\t\t\t   const pjsip_www_authenticate_hdr *hdr )\n{\n    if (hdr->challenge.digest.qop.slen == 0) {\n#if PJSIP_AUTH_AUTO_SEND_NEXT!=0\n\tif (!cached_auth->last_chal || pj_stricmp2(&hdr->scheme, \"digest\")) {\n\t    cached_auth->last_chal = (pjsip_www_authenticate_hdr*)\n\t\t\t\t     pjsip_hdr_clone(cached_auth->pool, hdr);\n\t} else {\n\t    /* Only update if the new challenge is \"significantly different\"\n\t     * than the one in the cache, to reduce memory usage.\n\t     */\n\t    const pjsip_digest_challenge *d1 =\n\t\t\t&cached_auth->last_chal->challenge.digest;\n\t    const pjsip_digest_challenge *d2 = &hdr->challenge.digest;\n\n\t    if (pj_strcmp(&d1->domain, &d2->domain) ||\n\t\tpj_strcmp(&d1->realm, &d2->realm) ||\n\t\tpj_strcmp(&d1->nonce, &d2->nonce) ||\n\t\tpj_strcmp(&d1->opaque, &d2->opaque) ||\n\t\tpj_strcmp(&d1->algorithm, &d2->algorithm) ||\n\t\tpj_strcmp(&d1->qop, &d2->qop))\n\t    {\n\t\tcached_auth->last_chal = (pjsip_www_authenticate_hdr*)\n\t\t\t\t       pjsip_hdr_clone(cached_auth->pool, hdr);\n\t    }\n\t}\n#endif\n\treturn;\n    }\n\n    /* Initialize cnonce and qop if not present. */\n    if (cached_auth->cnonce.slen == 0) {\n\t/* Save the whole challenge */\n\tcached_auth->last_chal = (pjsip_www_authenticate_hdr*)\n\t\t\t\t pjsip_hdr_clone(cached_auth->pool, hdr);\n\n\t/* Create cnonce */\n\tpj_create_unique_string( cached_auth->pool, &cached_auth->cnonce );\n#if defined(PJSIP_AUTH_CNONCE_USE_DIGITS_ONLY) && \\\n    PJSIP_AUTH_CNONCE_USE_DIGITS_ONLY!=0\n\tif (pj_strchr(&cached_auth->cnonce, '-')) {\n\t    /* remove hyphen character. */\n\t    pj_size_t w, r, len = pj_strlen(&cached_auth->cnonce);\n\t    char *s = cached_auth->cnonce.ptr;\n\n\t    w = r = 0;\n\t    for (; r < len; r++) {\n\t\tif (s[r] != '-')\n\t\t    s[w++] = s[r];\n\t    }\n\t    s[w] = '\\0';\n\t    cached_auth->cnonce.slen = w;\n\t}\n#endif\n\n\t/* Initialize nonce-count */\n\tcached_auth->nc = 1;\n\n\t/* Save realm. */\n\t/* Note: allow empty realm (http://trac.pjsip.org/repos/ticket/1061)\n\tpj_assert(cached_auth->realm.slen != 0);\n\t*/\n\tif (cached_auth->realm.slen == 0) {\n\t    pj_strdup(cached_auth->pool, &cached_auth->realm,\n\t\t      &hdr->challenge.digest.realm);\n\t}\n\n    } else {\n\t/* Update last_nonce and nonce-count */\n\tif (!pj_strcmp(&hdr->challenge.digest.nonce,\n\t\t       &cached_auth->last_chal->challenge.digest.nonce))\n\t{\n\t    /* Same nonce, increment nonce-count */\n\t    ++cached_auth->nc;\n\t} else {\n\t    /* Server gives new nonce. */\n\t    pj_strdup(cached_auth->pool, \n\t\t      &cached_auth->last_chal->challenge.digest.nonce,\n\t\t      &hdr->challenge.digest.nonce);\n\t    /* Has the opaque changed? */\n\t    if (pj_strcmp(&cached_auth->last_chal->challenge.digest.opaque,\n\t\t\t  &hdr->challenge.digest.opaque))\n\t    {\n\t\tpj_strdup(cached_auth->pool,\n\t\t\t  &cached_auth->last_chal->challenge.digest.opaque,\n\t\t\t  &hdr->challenge.digest.opaque);\n\t    }\n\t    cached_auth->nc = 1;\n\t}\n    }\n}\n#endif\t/* PJSIP_AUTH_QOP_SUPPORT */\n\n\n/* Find cached authentication in the list for the specified realm. */\nstatic pjsip_cached_auth *find_cached_auth( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t    const pj_str_t *realm )\n{\n    pjsip_cached_auth *auth = sess->cached_auth.next;\n    while (auth != &sess->cached_auth) {\n\tif (pj_stricmp(&auth->realm, realm) == 0)\n\t    return auth;\n\tauth = auth->next;\n    }\n\n    return NULL;\n}\n\n/* Find credential to use for the specified realm and auth scheme. */\nstatic const pjsip_cred_info* auth_find_cred( const pjsip_auth_clt_sess *sess,\n\t\t\t\t\t      const pj_str_t *realm,\n\t\t\t\t\t      const pj_str_t *auth_scheme)\n{\n    unsigned i;\n    int wildcard = -1;\n\n    PJ_UNUSED_ARG(auth_scheme);\n\n    for (i=0; i<sess->cred_cnt; ++i) {\n\tif (pj_stricmp(&sess->cred_info[i].realm, realm) == 0)\n\t    return &sess->cred_info[i];\n\telse if (sess->cred_info[i].realm.slen == 1 &&\n\t\t sess->cred_info[i].realm.ptr[0] == '*')\n\t{\n\t    wildcard = i;\n\t}\n    }\n\n    /* No matching realm. See if we have credential with wildcard ('*')\n     * as the realm.\n     */\n    if (wildcard != -1)\n\treturn &sess->cred_info[wildcard];\n\n    /* Nothing is suitable */\n    return NULL;\n}\n\n\n/* Init client session. */\nPJ_DEF(pj_status_t) pjsip_auth_clt_init(  pjsip_auth_clt_sess *sess,\n\t\t\t\t\t  pjsip_endpoint *endpt,\n\t\t\t\t\t  pj_pool_t *pool,\n\t\t\t\t\t  unsigned options)\n{\n    PJ_ASSERT_RETURN(sess && endpt && pool && (options==0), PJ_EINVAL);\n\n    sess->pool = pool;\n    sess->endpt = endpt;\n    sess->cred_cnt = 0;\n    sess->cred_info = NULL;\n    pj_list_init(&sess->cached_auth);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Deinit client session. */\nPJ_DEF(pj_status_t) pjsip_auth_clt_deinit(pjsip_auth_clt_sess *sess)\n{\n    pjsip_cached_auth *auth;\n    \n    PJ_ASSERT_RETURN(sess && sess->endpt, PJ_EINVAL);\n    \n    auth = sess->cached_auth.next;\n    while (auth != &sess->cached_auth) {\n\tpjsip_endpt_release_pool(sess->endpt, auth->pool);\n\tauth = auth->next;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Clone session. */\nPJ_DEF(pj_status_t) pjsip_auth_clt_clone( pj_pool_t *pool,\n\t\t\t\t\t  pjsip_auth_clt_sess *sess,\n\t\t\t\t\t  const pjsip_auth_clt_sess *rhs )\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && sess && rhs, PJ_EINVAL);\n\n    pjsip_auth_clt_init(sess, (pjsip_endpoint*)rhs->endpt, pool, 0);\n\n    sess->cred_cnt = rhs->cred_cnt;\n    sess->cred_info = (pjsip_cred_info*)\n    \t\t      pj_pool_alloc(pool,\n\t\t\t\t    sess->cred_cnt*sizeof(pjsip_cred_info));\n    for (i=0; i<rhs->cred_cnt; ++i) {\n\tpj_strdup(pool, &sess->cred_info[i].realm, &rhs->cred_info[i].realm);\n\tpj_strdup(pool, &sess->cred_info[i].scheme, &rhs->cred_info[i].scheme);\n\tpj_strdup(pool, &sess->cred_info[i].username,\n\t\t  &rhs->cred_info[i].username);\n\tsess->cred_info[i].data_type = rhs->cred_info[i].data_type;\n\tpj_strdup(pool, &sess->cred_info[i].data, &rhs->cred_info[i].data);\n    }\n\n    /* TODO note:\n     * Cloning the full authentication client is quite a big task.\n     * We do only the necessary bits here, i.e. cloning the credentials.\n     * The drawback of this basic approach is, a forked dialog will have to\n     * re-authenticate itself on the next request because it has lost the\n     * cached authentication headers.\n     */\n    PJ_TODO(FULL_CLONE_OF_AUTH_CLIENT_SESSION);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Set client credentials. */\nPJ_DEF(pj_status_t) pjsip_auth_clt_set_credentials( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t\t    int cred_cnt,\n\t\t\t\t\t\t    const pjsip_cred_info *c)\n{\n    PJ_ASSERT_RETURN(sess && c, PJ_EINVAL);\n\n    if (cred_cnt == 0) {\n\tsess->cred_cnt = 0;\n    } else {\n\tint i;\n\tsess->cred_info = (pjsip_cred_info*)\n\t\t\t  pj_pool_alloc(sess->pool, cred_cnt * sizeof(*c));\n\tfor (i=0; i<cred_cnt; ++i) {\n\t    sess->cred_info[i].data_type = c[i].data_type;\n\n\t    /* When data_type is PJSIP_CRED_DATA_EXT_AKA,\n\t     * callback must be specified.\n\t     */\n\t    if ((c[i].data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\n#if !PJSIP_HAS_DIGEST_AKA_AUTH\n\t\tif (!PJSIP_HAS_DIGEST_AKA_AUTH) {\n\t\t    pj_assert(!\"PJSIP_HAS_DIGEST_AKA_AUTH is not enabled\");\n\t\t    return PJSIP_EAUTHINAKACRED;\n\t\t}\n#endif\n\n\t\t/* Callback must be specified */\n\t\tPJ_ASSERT_RETURN(c[i].ext.aka.cb != NULL, PJ_EINVAL);\n\n\t\t/* Verify K len */\n\t\tPJ_ASSERT_RETURN(c[i].ext.aka.k.slen <= PJSIP_AKA_KLEN,\n\t\t\t\t PJSIP_EAUTHINAKACRED);\n\n\t\t/* Verify OP len */\n\t\tPJ_ASSERT_RETURN(c[i].ext.aka.op.slen <= PJSIP_AKA_OPLEN,\n\t\t\t\t PJSIP_EAUTHINAKACRED);\n\n\t\t/* Verify AMF len */\n\t\tPJ_ASSERT_RETURN(c[i].ext.aka.amf.slen <= PJSIP_AKA_AMFLEN,\n\t\t\t\t PJSIP_EAUTHINAKACRED);\n\n\t\tsess->cred_info[i].ext.aka.cb = c[i].ext.aka.cb;\n\t\tpj_strdup(sess->pool, &sess->cred_info[i].ext.aka.k,\n\t\t\t  &c[i].ext.aka.k);\n\t\tpj_strdup(sess->pool, &sess->cred_info[i].ext.aka.op,\n\t\t\t  &c[i].ext.aka.op);\n\t\tpj_strdup(sess->pool, &sess->cred_info[i].ext.aka.amf,\n\t\t\t  &c[i].ext.aka.amf);\n\t    }\n\n\t    pj_strdup(sess->pool, &sess->cred_info[i].scheme, &c[i].scheme);\n\t    pj_strdup(sess->pool, &sess->cred_info[i].realm, &c[i].realm);\n\t    pj_strdup(sess->pool, &sess->cred_info[i].username, &c[i].username);\n\t    pj_strdup(sess->pool, &sess->cred_info[i].data, &c[i].data);\n\t}\n\tsess->cred_cnt = cred_cnt;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Set the preference for the client authentication session.\n */\nPJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,\n\t\t\t\t\t     const pjsip_auth_clt_pref *p)\n{\n    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);\n\n    pj_memcpy(&sess->pref, p, sizeof(*p));\n    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);\n    //if (sess->pref.algorithm.slen == 0)\n    //\tsess->pref.algorithm = pj_str(\"MD5\");\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get the preference for the client authentication session.\n */\nPJ_DEF(pj_status_t) pjsip_auth_clt_get_prefs(pjsip_auth_clt_sess *sess,\n\t\t\t\t\t     pjsip_auth_clt_pref *p)\n{\n    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);\n\n    pj_memcpy(p, &sess->pref, sizeof(pjsip_auth_clt_pref));\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create Authorization/Proxy-Authorization response header based on the challege\n * in WWW-Authenticate/Proxy-Authenticate header.\n */\nstatic pj_status_t auth_respond( pj_pool_t *req_pool,\n\t\t\t\t const pjsip_www_authenticate_hdr *hdr,\n\t\t\t\t const pjsip_uri *uri,\n\t\t\t\t const pjsip_cred_info *cred_info,\n\t\t\t\t const pjsip_method *method,\n\t\t\t\t pj_pool_t *sess_pool,\n\t\t\t\t pjsip_cached_auth *cached_auth,\n\t\t\t\t pjsip_authorization_hdr **p_h_auth)\n{\n    pjsip_authorization_hdr *hauth;\n    char tmp[PJSIP_MAX_URL_SIZE];\n    pj_str_t uri_str;\n    pj_pool_t *pool;\n    pj_status_t status;\n\n    /* Verify arguments. */\n    PJ_ASSERT_RETURN(req_pool && hdr && uri && cred_info && method &&\n\t\t     sess_pool && cached_auth && p_h_auth, PJ_EINVAL);\n\n    /* Print URL in the original request. */\n    uri_str.ptr = tmp;\n    uri_str.slen = pjsip_uri_print(PJSIP_URI_IN_REQ_URI, uri, tmp,sizeof(tmp));\n    if (uri_str.slen < 1) {\n\treturn PJSIP_EURITOOLONG;\n    }\n\n#   if (PJSIP_AUTH_HEADER_CACHING)\n    {\n\tpool = sess_pool;\n\tPJ_UNUSED_ARG(req_pool);\n    }\n#   else\n    {\n\tpool = req_pool;\n\tPJ_UNUSED_ARG(sess_pool);\n    }\n#   endif\n\n    if (hdr->type == PJSIP_H_WWW_AUTHENTICATE)\n\thauth = pjsip_authorization_hdr_create(pool);\n    else if (hdr->type == PJSIP_H_PROXY_AUTHENTICATE)\n\thauth = pjsip_proxy_authorization_hdr_create(pool);\n    else {\n\treturn PJSIP_EINVALIDHDR;\n    }\n\n    /* Only support digest scheme at the moment. */\n    if (!pj_stricmp(&hdr->scheme, &pjsip_DIGEST_STR)) {\n\tpj_str_t *cnonce = NULL;\n\tpj_uint32_t nc = 1;\n\n\t/* Update the session (nonce-count etc) if required. */\n#\tif PJSIP_AUTH_QOP_SUPPORT\n\t{\n\t    if (cached_auth) {\n\t\tupdate_digest_session( cached_auth, hdr );\n\n\t\tcnonce = &cached_auth->cnonce;\n\t\tnc = cached_auth->nc;\n\t    }\n\t}\n#\tendif\t/* PJSIP_AUTH_QOP_SUPPORT */\n\n\thauth->scheme = pjsip_DIGEST_STR;\n\tstatus = respond_digest( pool, &hauth->credential.digest,\n\t\t\t\t &hdr->challenge.digest, &uri_str, cred_info,\n\t\t\t\t cnonce, nc, &method->name);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\n\t/* Set qop type in auth session the first time only. */\n\tif (hdr->challenge.digest.qop.slen != 0 && cached_auth) {\n\t    if (cached_auth->qop_value == PJSIP_AUTH_QOP_NONE) {\n\t\tpj_str_t *qop_val = &hauth->credential.digest.qop;\n\t\tif (!pj_strcmp(qop_val, &pjsip_AUTH_STR)) {\n\t\t    cached_auth->qop_value = PJSIP_AUTH_QOP_AUTH;\n\t\t} else {\n\t\t    cached_auth->qop_value = PJSIP_AUTH_QOP_UNKNOWN;\n\t\t}\n\t    }\n\t}\n    } else {\n\treturn PJSIP_EINVALIDAUTHSCHEME;\n    }\n\n    /* Keep the new authorization header in the cache, only\n     * if no qop is not present.\n     */\n#   if PJSIP_AUTH_HEADER_CACHING\n    {\n\tif (hauth && cached_auth && cached_auth->qop_value == PJSIP_AUTH_QOP_NONE) {\n\t    pjsip_cached_auth_hdr *cached_hdr;\n\n\t    /* Delete old header with the same method. */\n\t    cached_hdr = cached_auth->cached_hdr.next;\n\t    while (cached_hdr != &cached_auth->cached_hdr) {\n\t\tif (pjsip_method_cmp(method, &cached_hdr->method)==0)\n\t\t    break;\n\t\tcached_hdr = cached_hdr->next;\n\t    }\n\n\t    /* Save the header to the list. */\n\t    if (cached_hdr != &cached_auth->cached_hdr) {\n\t\tcached_hdr->hdr = hauth;\n\t    } else {\n\t\tcached_hdr = pj_pool_alloc(pool, sizeof(*cached_hdr));\n\t\tpjsip_method_copy( pool, &cached_hdr->method, method);\n\t\tcached_hdr->hdr = hauth;\n\t\tpj_list_insert_before( &cached_auth->cached_hdr, cached_hdr );\n\t    }\n\t}\n\n#\tif defined(PJSIP_AUTH_AUTO_SEND_NEXT) && PJSIP_AUTH_AUTO_SEND_NEXT!=0\n\t    if (hdr != cached_auth->last_chal) {\n\t\tcached_auth->last_chal = pjsip_hdr_clone(sess_pool, hdr);\n\t    }\n#\tendif\n    }\n#   endif\n\n    *p_h_auth = hauth;\n    return PJ_SUCCESS;\n\n}\n\n\n#if defined(PJSIP_AUTH_AUTO_SEND_NEXT) && PJSIP_AUTH_AUTO_SEND_NEXT!=0\nstatic pj_status_t new_auth_for_req( pjsip_tx_data *tdata,\n\t\t\t\t     pjsip_auth_clt_sess *sess,\n\t\t\t\t     pjsip_cached_auth *auth,\n\t\t\t\t     pjsip_authorization_hdr **p_h_auth)\n{\n    const pjsip_cred_info *cred;\n    pjsip_authorization_hdr *hauth;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tdata && sess && auth, PJ_EINVAL);\n    PJ_ASSERT_RETURN(auth->last_chal != NULL, PJSIP_EAUTHNOPREVCHAL);\n\n    cred = auth_find_cred( sess, &auth->realm, &auth->last_chal->scheme );\n    if (!cred)\n\treturn PJSIP_ENOCREDENTIAL;\n\n    status = auth_respond( tdata->pool, auth->last_chal,\n\t\t\t   tdata->msg->line.req.uri,\n\t\t\t   cred, &tdata->msg->line.req.method,\n\t\t\t   sess->pool, auth, &hauth);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    pjsip_msg_add_hdr( tdata->msg, (pjsip_hdr*)hauth);\n\n    if (p_h_auth)\n\t*p_h_auth = hauth;\n\n    return PJ_SUCCESS;\n}\n#endif\n\n\n/* Find credential in list of (Proxy-)Authorization headers */\nstatic pjsip_authorization_hdr* get_header_for_realm(const pjsip_hdr *hdr_list,\n\t\t\t\t\t\t     const pj_str_t *realm)\n{\n    pjsip_authorization_hdr *h;\n\n    h = (pjsip_authorization_hdr*)hdr_list->next;\n    while (h != (pjsip_authorization_hdr*)hdr_list) {\n\tif (pj_stricmp(&h->credential.digest.realm, realm)==0)\n\t    return h;\n\th = h->next;\n    }\n\n    return NULL;\n}\n\n\n/* Initialize outgoing request. */\nPJ_DEF(pj_status_t) pjsip_auth_clt_init_req( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t     pjsip_tx_data *tdata )\n{\n    const pjsip_method *method;\n    pjsip_cached_auth *auth;\n    pjsip_hdr added;\n\n    PJ_ASSERT_RETURN(sess && tdata, PJ_EINVAL);\n    PJ_ASSERT_RETURN(sess->pool, PJSIP_ENOTINITIALIZED);\n    PJ_ASSERT_RETURN(tdata->msg->type==PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* Init list */\n    pj_list_init(&added);\n\n    /* Get the method. */\n    method = &tdata->msg->line.req.method;\n    PJ_UNUSED_ARG(method); /* Warning about unused var caused by #if below */\n\n    auth = sess->cached_auth.next;\n    while (auth != &sess->cached_auth) {\n\t/* Reset stale counter */\n\tauth->stale_cnt = 0;\n\n\tif (auth->qop_value == PJSIP_AUTH_QOP_NONE) {\n#\t    if defined(PJSIP_AUTH_HEADER_CACHING) && \\\n\t       PJSIP_AUTH_HEADER_CACHING!=0\n\t    {\n\t\tpjsip_cached_auth_hdr *entry = auth->cached_hdr.next;\n\t\twhile (entry != &auth->cached_hdr) {\n\t\t    if (pjsip_method_cmp(&entry->method, method)==0) {\n\t\t\tpjsip_authorization_hdr *hauth;\n\t\t\thauth = pjsip_hdr_shallow_clone(tdata->pool, entry->hdr);\n\t\t\t//pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)hauth);\n\t\t\tpj_list_push_back(&added, hauth);\n\t\t\tbreak;\n\t\t    }\n\t\t    entry = entry->next;\n\t\t}\n\n#\t\tif defined(PJSIP_AUTH_AUTO_SEND_NEXT) && \\\n\t\t\t   PJSIP_AUTH_AUTO_SEND_NEXT!=0\n\t\t{\n\t\t    if (entry == &auth->cached_hdr)\n\t\t\tnew_auth_for_req( tdata, sess, auth, NULL);\n\t\t}\n#\t\tendif\n\n\t    }\n#\t    elif defined(PJSIP_AUTH_AUTO_SEND_NEXT) && \\\n\t\t PJSIP_AUTH_AUTO_SEND_NEXT!=0\n\t    {\n\t\tnew_auth_for_req( tdata, sess, auth, NULL);\n\t    }\n#\t    endif\n\n\t}\n#\tif defined(PJSIP_AUTH_QOP_SUPPORT) && \\\n\t   defined(PJSIP_AUTH_AUTO_SEND_NEXT) && \\\n\t   (PJSIP_AUTH_QOP_SUPPORT && PJSIP_AUTH_AUTO_SEND_NEXT)\n\telse if (auth->qop_value == PJSIP_AUTH_QOP_AUTH) {\n\t    /* For qop=\"auth\", we have to re-create the authorization header.\n\t     */\n\t    const pjsip_cred_info *cred;\n\t    pjsip_authorization_hdr *hauth;\n\t    pj_status_t status;\n\n\t    cred = auth_find_cred(sess, &auth->realm,\n\t\t\t\t  &auth->last_chal->scheme);\n\t    if (!cred) {\n\t\tauth = auth->next;\n\t\tcontinue;\n\t    }\n\n\t    status = auth_respond( tdata->pool, auth->last_chal,\n\t\t\t\t   tdata->msg->line.req.uri,\n\t\t\t\t   cred,\n\t\t\t\t   &tdata->msg->line.req.method,\n\t\t\t\t   sess->pool, auth, &hauth);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\n\t    //pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)hauth);\n\t    pj_list_push_back(&added, hauth);\n\t}\n#\tendif\t/* PJSIP_AUTH_QOP_SUPPORT && PJSIP_AUTH_AUTO_SEND_NEXT */\n\n\tauth = auth->next;\n    }\n\n    if (sess->pref.initial_auth == PJ_FALSE) {\n\tpjsip_hdr *h;\n\n\t/* Don't want to send initial empty Authorization header, so\n\t * just send whatever available in the list (maybe empty).\n\t */\n\n\th = added.next;\n\twhile (h != &added) {\n\t    pjsip_hdr *next = h->next;\n\t    pjsip_msg_add_hdr(tdata->msg, h);\n\t    h = next;\n\t}\n    } else {\n\t/* For each realm, add either the cached authorization header\n\t * or add an empty authorization header.\n\t */\n\tunsigned i;\n\tpj_str_t uri;\n\n\turi.ptr = (char*)pj_pool_alloc(tdata->pool, PJSIP_MAX_URL_SIZE);\n\turi.slen = pjsip_uri_print(PJSIP_URI_IN_REQ_URI,\n\t                           tdata->msg->line.req.uri,\n\t                           uri.ptr, PJSIP_MAX_URL_SIZE);\n\tif (uri.slen < 1 || uri.slen >= PJSIP_MAX_URL_SIZE)\n\t    return PJSIP_EURITOOLONG;\n\n\tfor (i=0; i<sess->cred_cnt; ++i) {\n\t    pjsip_cred_info *c = &sess->cred_info[i];\n\t    pjsip_authorization_hdr *h;\n\n\t    h = get_header_for_realm(&added, &c->realm);\n\t    if (h) {\n\t\tpj_list_erase(h);\n\t\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)h);\n\t    } else {\n\t\tpjsip_authorization_hdr *hs;\n\n\t\ths = pjsip_authorization_hdr_create(tdata->pool);\n\t\tpj_strdup(tdata->pool, &hs->scheme, &c->scheme);\n\t\tif (pj_stricmp(&c->scheme, &pjsip_BEARER_STR)==0) {\n\t\t\tpj_strdup(tdata->pool, &hs->credential.oauth.username,\n                                  &c->username);\n                        pj_strdup(tdata->pool, &hs->credential.oauth.realm,\n                                  &c->realm);\n                        pj_strdup(tdata->pool, &hs->credential.oauth.token,\n                                  &c->data);\n\t\t} else { //if (pj_stricmp(&c->scheme, &pjsip_DIGEST_STR)==0)\n\t\t\tpj_strdup(tdata->pool, &hs->credential.digest.username,\n\t\t\t\t  &c->username);\n\t\t\tpj_strdup(tdata->pool, &hs->credential.digest.realm,\n\t\t\t\t  &c->realm);\n\t\t\tpj_strdup(tdata->pool,&hs->credential.digest.uri, &uri);\n\t\t\tpj_strdup(tdata->pool, &hs->credential.digest.algorithm,\n\t\t\t  \t  &sess->pref.algorithm);\n\t\t}\n\n\t\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)hs);\n\t    }\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void recreate_cached_auth_pool( pjsip_endpoint *endpt, \n\t\t\t\t       pjsip_cached_auth *auth )\n{\n    pj_pool_t *auth_pool = pjsip_endpt_create_pool(endpt, \"auth_cli%p\", 1024, \n\t\t\t\t\t\t   1024);\n\n    if (auth->realm.slen) {\n        pj_str_t realm;\n        pj_strdup(auth_pool, &realm, &auth->realm);\n        pj_strassign(&auth->realm, &realm);\n    }\n\n    if (auth->cnonce.slen) {\n        pj_str_t cnonce;\n        pj_strdup(auth_pool, &cnonce, &auth->cnonce);\n        pj_strassign(&auth->cnonce, &cnonce);\n    }\n\n    if (auth->last_chal) {\n        auth->last_chal = (pjsip_www_authenticate_hdr*)\n\t\t\t  pjsip_hdr_clone(auth_pool, auth->last_chal);\n    }\n\n    pjsip_endpt_release_pool(endpt, auth->pool);\n    auth->pool = auth_pool;\n}\n\n/* Process authorization challenge */\nstatic pj_status_t process_auth( pj_pool_t *req_pool,\n\t\t\t\t const pjsip_www_authenticate_hdr *hchal,\n\t\t\t\t const pjsip_uri *uri,\n\t\t\t\t pjsip_tx_data *tdata,\n\t\t\t\t pjsip_auth_clt_sess *sess,\n\t\t\t\t pjsip_cached_auth *cached_auth,\n\t\t\t\t pjsip_authorization_hdr **h_auth)\n{\n    const pjsip_cred_info *cred;\n    pjsip_authorization_hdr *sent_auth = NULL;\n    pjsip_hdr *hdr;\n    pj_status_t status;\n\n    /* See if we have sent authorization header for this realm (and scheme) */\n    hdr = tdata->msg->hdr.next;\n    while (hdr != &tdata->msg->hdr) {\n\tif ((hchal->type == PJSIP_H_WWW_AUTHENTICATE &&\n\t     hdr->type == PJSIP_H_AUTHORIZATION) ||\n\t    (hchal->type == PJSIP_H_PROXY_AUTHENTICATE &&\n\t     hdr->type == PJSIP_H_PROXY_AUTHORIZATION))\n\t{\n\t    sent_auth = (pjsip_authorization_hdr*) hdr;\n\t    if (pj_stricmp(&hchal->challenge.common.realm,\n\t\t\t   &sent_auth->credential.common.realm)==0 &&\n\t\tpj_stricmp(&hchal->scheme, &sent_auth->scheme)==0)\n\t    {\n\t\t/* If this authorization has empty response, remove it. */\n\t\tif (pj_stricmp(&sent_auth->scheme, &pjsip_DIGEST_STR)==0 &&\n\t\t    sent_auth->credential.digest.response.slen == 0)\n\t\t{\n\t\t    /* This is empty authorization, remove it. */\n\t\t    hdr = hdr->next;\n\t\t    pj_list_erase(sent_auth);\n\t\t    continue;\n\t\t} else\n\t\tif (pj_stricmp(&sent_auth->scheme, &pjsip_DIGEST_STR)==0 &&\n\t\t    pj_stricmp(&sent_auth->credential.digest.algorithm,\n\t\t               &hchal->challenge.digest.algorithm)!=0)\n\t\t{\n\t\t    /* Same 'digest' scheme but different algo */\n\t\t    hdr = hdr->next;\n\t\t    continue;\n\t\t} else {\n\t\t    /* Found previous authorization attempt */\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\thdr = hdr->next;\n    }\n\n    /* If we have sent, see if server rejected because of stale nonce or\n     * other causes.\n     */\n    if (hdr != &tdata->msg->hdr) {\n\tpj_bool_t stale;\n\n\t/* Detect \"stale\" state */\n\tstale = hchal->challenge.digest.stale;\n\tif (!stale) {\n\t    /* If stale is false, check is nonce has changed. Some servers\n\t     * (broken ones!) want to change nonce but they fail to set\n\t     * stale to true.\n\t     */\n\t    stale = pj_strcmp(&hchal->challenge.digest.nonce,\n\t\t\t      &sent_auth->credential.digest.nonce);\n\t}\n\n\tif (stale == PJ_FALSE) {\n\t    /* Our credential is rejected. No point in trying to re-supply\n\t     * the same credential.\n\t     */\n\t    PJ_LOG(4, (THIS_FILE, \"Authorization failed for %.*s@%.*s: \"\n\t\t       \"server rejected with stale=false\",\n\t\t       sent_auth->credential.digest.username.slen,\n\t\t       sent_auth->credential.digest.username.ptr,\n\t\t       sent_auth->credential.digest.realm.slen,\n\t\t       sent_auth->credential.digest.realm.ptr));\n\t    return PJSIP_EFAILEDCREDENTIAL;\n\t}\n\n\tcached_auth->stale_cnt++;\n\tif (cached_auth->stale_cnt >= PJSIP_MAX_STALE_COUNT) {\n\t    /* Our credential is rejected. No point in trying to re-supply\n\t     * the same credential.\n\t     */\n\t    PJ_LOG(4, (THIS_FILE, \"Authorization failed for %.*s@%.*s: \"\n\t\t       \"maximum number of stale retries exceeded\",\n\t\t       sent_auth->credential.digest.username.slen,\n\t\t       sent_auth->credential.digest.username.ptr,\n\t\t       sent_auth->credential.digest.realm.slen,\n\t\t       sent_auth->credential.digest.realm.ptr));\n\t    return PJSIP_EAUTHSTALECOUNT;\n\t}\n\n\t/* Otherwise remove old, stale authorization header from the mesasge.\n\t * We will supply a new one.\n\t */\n\tpj_list_erase(sent_auth);\n    }\n\n    /* Find credential to be used for the challenge. */\n    cred = auth_find_cred( sess, &hchal->challenge.common.realm,\n\t\t\t   &hchal->scheme);\n    if (!cred) {\n\tconst pj_str_t *realm = &hchal->challenge.common.realm;\n\tPJ_LOG(4,(THIS_FILE,\n\t\t  \"Unable to set auth for %s: can not find credential for %.*s/%.*s\",\n\t\t  tdata->obj_name,\n\t\t  realm->slen, realm->ptr,\n\t\t  hchal->scheme.slen, hchal->scheme.ptr));\n\treturn PJSIP_ENOCREDENTIAL;\n    }\n\n    /* Respond to authorization challenge. */\n    status = auth_respond( req_pool, hchal, uri, cred,\n\t\t\t   &tdata->msg->line.req.method,\n\t\t\t   sess->pool, cached_auth, h_auth);\n    return status;\n}\n\n\n/* Reinitialize outgoing request after 401/407 response is received.\n * The purpose of this function is:\n *  - to add a Authorization/Proxy-Authorization header.\n *  - to put the newly created Authorization/Proxy-Authorization header\n *    in cached_list.\n */\nPJ_DEF(pj_status_t) pjsip_auth_clt_reinit_req(\tpjsip_auth_clt_sess *sess,\n\t\t\t\t\t\tconst pjsip_rx_data *rdata,\n\t\t\t\t\t\tpjsip_tx_data *old_request,\n\t\t\t\t\t\tpjsip_tx_data **new_request )\n{\n    pjsip_tx_data *tdata;\n    const pjsip_hdr *hdr;\n    unsigned chal_cnt, auth_cnt;\n    pjsip_via_hdr *via;\n    pj_status_t status;\n    pj_status_t last_auth_err;\n\n    PJ_ASSERT_RETURN(sess && rdata && old_request && new_request,\n\t\t     PJ_EINVAL);\n    PJ_ASSERT_RETURN(sess->pool, PJSIP_ENOTINITIALIZED);\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_RESPONSE_MSG,\n\t\t     PJSIP_ENOTRESPONSEMSG);\n    PJ_ASSERT_RETURN(old_request->msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->line.status.code == 401 ||\n\t\t     rdata->msg_info.msg->line.status.code == 407,\n\t\t     PJSIP_EINVALIDSTATUS);\n\n    tdata = old_request;\n    tdata->auth_retry = PJ_FALSE;\n\n    /*\n     * Respond to each authentication challenge.\n     */\n    hdr = rdata->msg_info.msg->hdr.next;\n    chal_cnt = 0;\n    auth_cnt = 0;\n    last_auth_err = PJSIP_EAUTHNOAUTH;\n    while (hdr != &rdata->msg_info.msg->hdr && auth_cnt == 0) {\n\tpjsip_cached_auth *cached_auth;\n\tconst pjsip_www_authenticate_hdr *hchal;\n\tpjsip_authorization_hdr *hauth;\n\n\t/* Find WWW-Authenticate or Proxy-Authenticate header. */\n\twhile (hdr != &rdata->msg_info.msg->hdr &&\n\t       hdr->type != PJSIP_H_WWW_AUTHENTICATE &&\n\t       hdr->type != PJSIP_H_PROXY_AUTHENTICATE)\n\t{\n\t    hdr = hdr->next;\n\t}\n\tif (hdr == &rdata->msg_info.msg->hdr)\n\t    break;\n\n\thchal = (const pjsip_www_authenticate_hdr*)hdr;\n\t++chal_cnt;\n\n\t/* Find authentication session for this realm, create a new one\n\t * if not present.\n\t */\n\tcached_auth = find_cached_auth(sess, &hchal->challenge.common.realm);\n\tif (!cached_auth) {\n\t    cached_auth = PJ_POOL_ZALLOC_T(sess->pool, pjsip_cached_auth);\n\t    cached_auth->pool = pjsip_endpt_create_pool(sess->endpt,\n\t\t\t\t\t\t\t\"auth_cli%p\",\n\t\t\t\t\t\t\t1024,\n\t\t\t\t\t\t\t1024);\n\t    pj_strdup(cached_auth->pool, &cached_auth->realm,\n\t\t      &hchal->challenge.common.realm);\n\t    cached_auth->is_proxy = (hchal->type == PJSIP_H_PROXY_AUTHENTICATE);\n#\t    if (PJSIP_AUTH_HEADER_CACHING)\n\t    {\n\t\tpj_list_init(&cached_auth->cached_hdr);\n\t    }\n#\t    endif\n\t    pj_list_insert_before(&sess->cached_auth, cached_auth);\n\t}\n\n\t/* Create authorization header for this challenge, and update\n\t * authorization session.\n\t */\n\tstatus = process_auth(tdata->pool, hchal, tdata->msg->line.req.uri,\n\t\t\t      tdata, sess, cached_auth, &hauth);\n\tif (status != PJ_SUCCESS) {\n\t    last_auth_err = status;\n\n\t    /* Process next header. */\n\t    hdr = hdr->next;\n\t    continue;\n\t}\n\n\tif (pj_pool_get_used_size(cached_auth->pool) >\n\t    PJSIP_AUTH_CACHED_POOL_MAX_SIZE) \n\t{\n\t    recreate_cached_auth_pool(sess->endpt, cached_auth);\n\t}\t\n\n\t/* Add to the message. */\n\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)hauth);\n\n\t/* Process next header. */\n\thdr = hdr->next;\n\tauth_cnt++;\n    }\n\n    /* Check if challenge is present */\n    if (chal_cnt == 0)\n\treturn PJSIP_EAUTHNOCHAL;\n\n    /* Check if any authorization header has been created */\n    if (auth_cnt == 0)\n\treturn last_auth_err;\n\n    /* Remove branch param in Via header. */\n    via = (pjsip_via_hdr*) pjsip_msg_find_hdr(tdata->msg, PJSIP_H_VIA, NULL);\n    via->branch_param.slen = 0;\n\n    /* Restore strict route set.\n     * See http://trac.pjsip.org/repos/ticket/492\n     */\n    pjsip_restore_strict_route_set(tdata);\n\n    /* Must invalidate the message! */\n    pjsip_tx_data_invalidate_msg(tdata);\n\n    /* Retrying.. */\n    tdata->auth_retry = PJ_TRUE;\n\n    /* Increment reference counter. */\n    pjsip_tx_data_add_ref(tdata);\n\n    /* Done. */\n    *new_request = tdata;\n    return PJ_SUCCESS;\n\n}\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n#include <pjsip/sip_auth.h>\n#include <pjsip/sip_auth_parser.h>\t/* just to get pjsip_DIGEST_STR */\n#include <pjsip/sip_auth_msg.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_transport.h>\n#include <pj/string.h>\n#include <pj/assert.h>\n\n\n/*\n * Initialize server authorization session data structure to serve the \n * specified realm and to use lookup_func function to look for the credential \n * info. \n */\nPJ_DEF(pj_status_t) pjsip_auth_srv_init(  pj_pool_t *pool,\n\t\t\t\t\t  pjsip_auth_srv *auth_srv,\n\t\t\t\t\t  const pj_str_t *realm,\n\t\t\t\t\t  pjsip_auth_lookup_cred *lookup,\n\t\t\t\t\t  unsigned options )\n{\n    PJ_ASSERT_RETURN(pool && auth_srv && realm && lookup, PJ_EINVAL);\n\n    pj_bzero(auth_srv, sizeof(*auth_srv));\n    pj_strdup( pool, &auth_srv->realm, realm);\n    auth_srv->lookup = lookup;\n    auth_srv->is_proxy = (options & PJSIP_AUTH_SRV_IS_PROXY);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Initialize server authorization session data structure to serve the \n * specified realm and to use lookup_func function to look for the credential \n * info. \n */\nPJ_DEF(pj_status_t) pjsip_auth_srv_init2(\n\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t    pjsip_auth_srv *auth_srv,\n\t\t\t\t    const pjsip_auth_srv_init_param *param)\n{\n    PJ_ASSERT_RETURN(pool && auth_srv && param, PJ_EINVAL);\n\n    pj_bzero(auth_srv, sizeof(*auth_srv));\n    pj_strdup( pool, &auth_srv->realm, param->realm);\n    auth_srv->lookup2 = param->lookup2;\n    auth_srv->is_proxy = (param->options & PJSIP_AUTH_SRV_IS_PROXY);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Verify incoming Authorization/Proxy-Authorization header against the \n * specified credential.\n */\nstatic pj_status_t pjsip_auth_verify( const pjsip_authorization_hdr *hdr,\n\t\t\t\t      const pj_str_t *method,\n\t\t\t\t      const pjsip_cred_info *cred_info )\n{\n    if (pj_stricmp(&hdr->scheme, &pjsip_DIGEST_STR) == 0) {\n\tchar digest_buf[PJSIP_MD5STRLEN];\n\tpj_str_t digest;\n\tconst pjsip_digest_credential *dig = &hdr->credential.digest;\n\n\t/* Check that username and realm match. \n\t * These checks should have been performed before entering this\n\t * function.\n\t */\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->username, &cred_info->username) == 0,\n\t\t\t PJ_EINVALIDOP);\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->realm, &cred_info->realm) == 0,\n\t\t\t PJ_EINVALIDOP);\n\n\t/* Prepare for our digest calculation. */\n\tdigest.ptr = digest_buf;\n\tdigest.slen = PJSIP_MD5STRLEN;\n\n\t/* Create digest for comparison. */\n\tpjsip_auth_create_digest(&digest, \n\t\t\t\t &hdr->credential.digest.nonce,\n\t\t\t\t &hdr->credential.digest.nc, \n\t\t\t\t &hdr->credential.digest.cnonce,\n\t\t\t\t &hdr->credential.digest.qop,\n\t\t\t\t &hdr->credential.digest.uri,\n\t\t\t\t &cred_info->realm,\n\t\t\t\t cred_info, \n\t\t\t\t method );\n\n\t/* Compare digest. */\n\treturn (pj_stricmp(&digest, &hdr->credential.digest.response) == 0) ?\n\t       PJ_SUCCESS : PJSIP_EAUTHINVALIDDIGEST;\n\n    } else {\n\tpj_assert(!\"Unsupported authentication scheme\");\n\treturn PJSIP_EINVALIDAUTHSCHEME;\n    }\n}\n\n\n/*\n * Request the authorization server framework to verify the authorization \n * information in the specified request in rdata.\n */\nPJ_DEF(pj_status_t) pjsip_auth_srv_verify( pjsip_auth_srv *auth_srv,\n\t\t\t\t\t   pjsip_rx_data *rdata,\n\t\t\t\t\t   int *status_code)\n{\n    pjsip_authorization_hdr *h_auth;\n    pjsip_msg *msg = rdata->msg_info.msg;\n    pjsip_hdr_e htype;\n    pj_str_t acc_name;\n    pjsip_cred_info cred_info;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(auth_srv && rdata, PJ_EINVAL);\n    PJ_ASSERT_RETURN(msg->type == PJSIP_REQUEST_MSG, PJSIP_ENOTREQUESTMSG);\n\n    htype = auth_srv->is_proxy ? PJSIP_H_PROXY_AUTHORIZATION : \n\t\t\t\t PJSIP_H_AUTHORIZATION;\n\n    /* Initialize status with 200. */\n    *status_code = 200;\n\n    /* Find authorization header for our realm. */\n    h_auth = (pjsip_authorization_hdr*) pjsip_msg_find_hdr(msg, htype, NULL);\n    while (h_auth) {\n\tif (!pj_stricmp(&h_auth->credential.common.realm, &auth_srv->realm))\n\t    break;\n\n\th_auth = h_auth->next;\n\tif (h_auth == (void*) &msg->hdr) {\n\t    h_auth = NULL;\n\t    break;\n\t}\n\n\th_auth=(pjsip_authorization_hdr*)pjsip_msg_find_hdr(msg,htype,h_auth);\n    }\n\n    if (!h_auth) {\n\t*status_code = auth_srv->is_proxy ? 407 : 401;\n\treturn PJSIP_EAUTHNOAUTH;\n    }\n\n    /* Check authorization scheme. */\n    if (pj_stricmp(&h_auth->scheme, &pjsip_DIGEST_STR) == 0)\n\tacc_name = h_auth->credential.digest.username;\n    else {\n\t*status_code = auth_srv->is_proxy ? 407 : 401;\n\treturn PJSIP_EINVALIDAUTHSCHEME;\n    }\n\n    /* Find the credential information for the account. */\n    if (auth_srv->lookup2) {\n\tpjsip_auth_lookup_cred_param param;\n\n\tpj_bzero(&param, sizeof(param));\n\tparam.realm = auth_srv->realm;\n\tparam.acc_name = acc_name;\n\tparam.rdata = rdata;\n\tstatus = (*auth_srv->lookup2)(rdata->tp_info.pool, &param, &cred_info);\n\tif (status != PJ_SUCCESS) {\n\t    *status_code = PJSIP_SC_FORBIDDEN;\n\t    return status;\n\t}\n    } else {\n\tstatus = (*auth_srv->lookup)(rdata->tp_info.pool, &auth_srv->realm,\n\t\t\t\t     &acc_name, &cred_info);\n\tif (status != PJ_SUCCESS) {\n\t    *status_code = PJSIP_SC_FORBIDDEN;\n\t    return status;\n\t}\n    }\n\n    /* Authenticate with the specified credential. */\n    status = pjsip_auth_verify(h_auth, &msg->line.req.method.name, \n\t\t\t       &cred_info);\n    if (status != PJ_SUCCESS) {\n\t*status_code = PJSIP_SC_FORBIDDEN;\n    }\n    return status;\n}\n\n\n/*\n * Add authentication challenge headers to the outgoing response in tdata. \n * Application may specify its customized nonce and opaque for the challenge, \n * or can leave the value to NULL to make the function fills them in with \n * random characters.\n */\nPJ_DEF(pj_status_t) pjsip_auth_srv_challenge(  pjsip_auth_srv *auth_srv,\n\t\t\t\t\t       const pj_str_t *qop,\n\t\t\t\t\t       const pj_str_t *nonce,\n\t\t\t\t\t       const pj_str_t *opaque,\n\t\t\t\t\t       pj_bool_t stale,\n\t\t\t\t\t       pjsip_tx_data *tdata)\n{\n    pjsip_www_authenticate_hdr *hdr;\n    char nonce_buf[16];\n    pj_str_t random;\n\n    PJ_ASSERT_RETURN( auth_srv && tdata, PJ_EINVAL );\n\n    random.ptr = nonce_buf;\n    random.slen = sizeof(nonce_buf);\n\n    /* Create the header. */\n    if (auth_srv->is_proxy)\n\thdr = pjsip_proxy_authenticate_hdr_create(tdata->pool);\n    else\n\thdr = pjsip_www_authenticate_hdr_create(tdata->pool);\n\n    /* Initialize header. \n     * Note: only support digest authentication now.\n     */\n    hdr->scheme = pjsip_DIGEST_STR;\n    hdr->challenge.digest.algorithm = pjsip_MD5_STR;\n    if (nonce) {\n\tpj_strdup(tdata->pool, &hdr->challenge.digest.nonce, nonce);\n    } else {\n\tpj_create_random_string(nonce_buf, sizeof(nonce_buf));\n\tpj_strdup(tdata->pool, &hdr->challenge.digest.nonce, &random);\n    }\n    if (opaque) {\n\tpj_strdup(tdata->pool, &hdr->challenge.digest.opaque, opaque);\n    } else {\n\tpj_create_random_string(nonce_buf, sizeof(nonce_buf));\n\tpj_strdup(tdata->pool, &hdr->challenge.digest.opaque, &random);\n    }\n    if (qop) {\n\tpj_strdup(tdata->pool, &hdr->challenge.digest.qop, qop);\n    } else {\n\thdr->challenge.digest.qop.slen = 0;\n    }\n    pj_strdup(tdata->pool, &hdr->challenge.digest.realm, &auth_srv->realm);\n    hdr->challenge.digest.stale = stale;\n\n    pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)hdr);\n\n    return PJ_SUCCESS;\n}\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjsua-lib/pjsua.h>\n#include <pjsua-lib/pjsua_internal.h>\n\n\n#define THIS_FILE   \"pjsua_core.c\"\n\n#define DEFAULT_RTP_PORT\t4000\n\n\n/* Internal prototypes */\nstatic void resolve_stun_entry(pjsua_stun_resolve *sess);\n\n\n/* PJSUA application instance. */\nstruct pjsua_data pjsua_var;\n\n\nPJ_DEF(struct pjsua_data*) pjsua_get_var(void)\n{\n    return &pjsua_var;\n}\n\n\n/* Display error */\nPJ_DEF(void) pjsua_perror( const char *sender, const char *title, \n\t\t\t   pj_status_t status)\n{\n    char errmsg[PJ_ERR_MSG_SIZE];\n\n    pj_strerror(status, errmsg, sizeof(errmsg));\n    PJ_LOG(1,(sender, \"%s: %s [status=%d]\", title, errmsg, status));\n}\n\n\nstatic void init_data()\n{\n    unsigned i;\n\n    pj_bzero(&pjsua_var, sizeof(pjsua_var));\n\n    for (i=0; i<PJ_ARRAY_SIZE(pjsua_var.acc); ++i)\n\tpjsua_var.acc[i].index = i;\n    \n    for (i=0; i<PJ_ARRAY_SIZE(pjsua_var.tpdata); ++i)\n\tpjsua_var.tpdata[i].index = i;\n\n    pjsua_var.stun_status = PJ_EUNKNOWN;\n    pjsua_var.nat_status = PJ_EPENDING;\n    pj_list_init(&pjsua_var.stun_res);\n    pj_list_init(&pjsua_var.outbound_proxy);\n\n    pjsua_config_default(&pjsua_var.ua_cfg);\n\n    for (i=0; i<PJSUA_MAX_VID_WINS; ++i) {\n\tpjsua_vid_win_reset(i);\n    }\n}\n\n\nPJ_DEF(void) pjsua_logging_config_default(pjsua_logging_config *cfg)\n{\n    pj_bzero(cfg, sizeof(*cfg));\n\n    cfg->msg_logging = PJ_TRUE;\n    cfg->level = 5;\n    cfg->console_level = 4;\n    cfg->decor = PJ_LOG_HAS_SENDER | PJ_LOG_HAS_TIME | \n\t\t PJ_LOG_HAS_MICRO_SEC | PJ_LOG_HAS_NEWLINE |\n\t\t PJ_LOG_HAS_SPACE | PJ_LOG_HAS_THREAD_SWC |\n\t\t PJ_LOG_HAS_INDENT;\n#if (defined(PJ_WIN32) && PJ_WIN32 != 0) || (defined(PJ_WIN64) && PJ_WIN64 != 0)\n    cfg->decor |= PJ_LOG_HAS_COLOR;\n#endif\n}\n\nPJ_DEF(void) pjsua_logging_config_dup(pj_pool_t *pool,\n\t\t\t\t      pjsua_logging_config *dst,\n\t\t\t\t      const pjsua_logging_config *src)\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    pj_strdup_with_null(pool, &dst->log_filename, &src->log_filename);\n}\n\nPJ_DEF(void) pjsua_config_default(pjsua_config *cfg)\n{\n    pj_bzero(cfg, sizeof(*cfg));\n\n    cfg->max_calls = PJSUA_MAX_CALLS;\n    cfg->thread_cnt = PJSUA_SEPARATE_WORKER_FOR_TIMER? 2 : 1;\n    cfg->nat_type_in_sdp = 1;\n    cfg->stun_ignore_failure = PJ_TRUE;\n    cfg->force_lr = PJ_TRUE;\n    cfg->enable_unsolicited_mwi = PJ_TRUE;\n    cfg->use_srtp = PJSUA_DEFAULT_USE_SRTP;\n    cfg->srtp_secure_signaling = PJSUA_DEFAULT_SRTP_SECURE_SIGNALING;\n    cfg->hangup_forked_call = PJ_TRUE;\n\n    cfg->use_timer = PJSUA_SIP_TIMER_OPTIONAL;\n    pjsip_timer_setting_default(&cfg->timer_setting);\n    pjsua_srtp_opt_default(&cfg->srtp_opt);\n}\n\nPJ_DEF(void) pjsua_config_dup(pj_pool_t *pool,\n\t\t\t      pjsua_config *dst,\n\t\t\t      const pjsua_config *src)\n{\n    unsigned i;\n\n    pj_memcpy(dst, src, sizeof(*src));\n\n    for (i=0; i<src->outbound_proxy_cnt; ++i) {\n\tpj_strdup_with_null(pool, &dst->outbound_proxy[i],\n\t\t\t    &src->outbound_proxy[i]);\n    }\n\n    for (i=0; i<src->cred_count; ++i) {\n\tpjsip_cred_dup(pool, &dst->cred_info[i], &src->cred_info[i]);\n    }\n\n    pj_strdup_with_null(pool, &dst->user_agent, &src->user_agent);\n    pj_strdup_with_null(pool, &dst->stun_domain, &src->stun_domain);\n    pj_strdup_with_null(pool, &dst->stun_host, &src->stun_host);\n\n    for (i=0; i<src->stun_srv_cnt; ++i) {\n\tpj_strdup_with_null(pool, &dst->stun_srv[i], &src->stun_srv[i]);\n    }\n\n    pjsua_srtp_opt_dup(pool, &dst->srtp_opt, &src->srtp_opt, PJ_FALSE);\n}\n\nPJ_DEF(void) pjsua_msg_data_init(pjsua_msg_data *msg_data)\n{\n    pj_bzero(msg_data, sizeof(*msg_data));\n    pj_list_init(&msg_data->hdr_list);\n    pjsip_media_type_init(&msg_data->multipart_ctype, NULL, NULL);\n    pj_list_init(&msg_data->multipart_parts);\n}\n\nPJ_DEF(pjsua_msg_data*) pjsua_msg_data_clone(pj_pool_t *pool,\n                                             const pjsua_msg_data *rhs)\n{\n    pjsua_msg_data *msg_data;\n    const pjsip_hdr *hdr;\n    const pjsip_multipart_part *mpart;\n\n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    msg_data = PJ_POOL_ZALLOC_T(pool, pjsua_msg_data);\n    PJ_ASSERT_RETURN(msg_data != NULL, NULL);\n\n    pj_strdup(pool, &msg_data->target_uri, &rhs->target_uri);\n\n    pj_list_init(&msg_data->hdr_list);\n    hdr = rhs->hdr_list.next;\n    while (hdr != &rhs->hdr_list) {\n\tpj_list_push_back(&msg_data->hdr_list, pjsip_hdr_clone(pool, hdr));\n\thdr = hdr->next;\n    }\n\n    pj_strdup(pool, &msg_data->content_type, &rhs->content_type);\n    pj_strdup(pool, &msg_data->msg_body, &rhs->msg_body);\n\n    pjsip_media_type_cp(pool, &msg_data->multipart_ctype,\n                        &rhs->multipart_ctype);\n\n    pj_list_init(&msg_data->multipart_parts);\n    mpart = rhs->multipart_parts.next;\n    while (mpart != &rhs->multipart_parts) {\n\tpj_list_push_back(&msg_data->multipart_parts,\n                          pjsip_multipart_clone_part(pool, mpart));\n\tmpart = mpart->next;\n    }\n\n    return msg_data;\n}\n\nPJ_DEF(void) pjsua_transport_config_default(pjsua_transport_config *cfg)\n{\n    pj_bzero(cfg, sizeof(*cfg));\n    pjsip_tls_setting_default(&cfg->tls_setting);\n}\n\nPJ_DEF(void) pjsua_transport_config_dup(pj_pool_t *pool,\n\t\t\t\t\tpjsua_transport_config *dst,\n\t\t\t\t\tconst pjsua_transport_config *src)\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    pj_strdup(pool, &dst->public_addr, &src->public_addr);\n    pj_strdup(pool, &dst->bound_addr, &src->bound_addr);\n}\n\nPJ_DEF(void) pjsua_ice_config_from_media_config( pj_pool_t *pool,\n                                           pjsua_ice_config *dst,\n                                           const pjsua_media_config *src)\n{\n    PJ_UNUSED_ARG(pool);\n\n    dst->enable_ice = src->enable_ice;\n    dst->ice_max_host_cands = src->ice_max_host_cands;\n    dst->ice_opt = src->ice_opt;\n    dst->ice_no_rtcp = src->ice_no_rtcp;\n    dst->ice_always_update = src->ice_always_update;\n}\n\nPJ_DEF(void) pjsua_ice_config_dup( pj_pool_t *pool,\n                                pjsua_ice_config *dst,\n                                const pjsua_ice_config *src)\n{\n    PJ_UNUSED_ARG(pool);\n    pj_memcpy(dst, src, sizeof(*src));\n}\n\nPJ_DEF(void) pjsua_turn_config_from_media_config(pj_pool_t *pool,\n                                                 pjsua_turn_config *dst,\n                                                 const pjsua_media_config *src)\n{\n    dst->enable_turn = src->enable_turn;\n    dst->turn_conn_type = src->turn_conn_type;\n    if (pool == NULL) {\n\tdst->turn_server = src->turn_server;\n\tdst->turn_auth_cred = src->turn_auth_cred;\n\n#if PJ_HAS_SSL_SOCK\n\tpj_memcpy(&dst->turn_tls_setting, &src->turn_tls_setting,\n\t\t  sizeof(src->turn_tls_setting));\n#endif\n    } else {\n\tif (pj_stricmp(&dst->turn_server, &src->turn_server))\n\t    pj_strdup(pool, &dst->turn_server, &src->turn_server);\n\tpj_stun_auth_cred_dup(pool, &dst->turn_auth_cred,\n\t                      &src->turn_auth_cred);\n\n#if PJ_HAS_SSL_SOCK\n\tpj_turn_sock_tls_cfg_dup(pool, &dst->turn_tls_setting,\n\t\t\t\t &src->turn_tls_setting);\n#endif\n    }\n}\n\nPJ_DEF(void) pjsua_turn_config_dup(pj_pool_t *pool,\n                                   pjsua_turn_config *dst,\n                                   const pjsua_turn_config *src)\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    if (pool) {\n\tpj_strdup(pool, &dst->turn_server, &src->turn_server);\n\tpj_stun_auth_cred_dup(pool, &dst->turn_auth_cred,\n\t                      &src->turn_auth_cred);\n\n#if PJ_HAS_SSL_SOCK\n\tpj_turn_sock_tls_cfg_dup(pool, &dst->turn_tls_setting,\n\t\t\t\t &src->turn_tls_setting);\n#endif\n    }\n}\n\n\nPJ_DEF(void) pjsua_srtp_opt_default(pjsua_srtp_opt *cfg)\n{\n    pj_bzero(cfg, sizeof(*cfg));\n}\n\n\nPJ_DEF(void) pjsua_srtp_opt_dup( pj_pool_t *pool, pjsua_srtp_opt *dst,\n                                 const pjsua_srtp_opt *src,\n                                 pj_bool_t check_str)\n{\n    pjsua_srtp_opt backup_dst;\n    \n    if (check_str) pj_memcpy(&backup_dst, dst, sizeof(*dst));\n    pj_memcpy(dst, src, sizeof(*src));\n\n    if (pool) {\n    \tunsigned i;\n    \t\n    \tfor (i = 0; i < src->crypto_count; i++) {\n    \t    if (!check_str ||\n    \t    \tpj_stricmp(&backup_dst.crypto[i].key, &src->crypto[i].key))\n    \t    {\n\t    \tpj_strdup(pool, &dst->crypto[i].key, &src->crypto[i].key);\n\t    } else {\n\t    \t/* If strings are identical, use the old string to\n\t    \t * avoid wasting memory.\n\t    \t */\n\t    \tdst->crypto[i].key = backup_dst.crypto[i].key;\n\t    }\n    \t    if (!check_str ||\n    \t    \tpj_stricmp(&backup_dst.crypto[i].name, &src->crypto[i].name))\n    \t    {\n\t    \tpj_strdup(pool, &dst->crypto[i].name, &src->crypto[i].name);\n\t    } else {\n\t    \t/* If strings are identical, use the old string to\n\t    \t * avoid wasting memory.\n\t    \t */\n\t    \tdst->crypto[i].name = backup_dst.crypto[i].name;\n\t    }\n\t}\n    }\n}\n\n\nPJ_DEF(void) pjsua_acc_config_default(pjsua_acc_config *cfg)\n{\n    pjsua_media_config med_cfg;\n\n    pj_bzero(cfg, sizeof(*cfg));\n\n    cfg->reg_timeout = PJSUA_REG_INTERVAL;\n    cfg->reg_delay_before_refresh = PJSIP_REGISTER_CLIENT_DELAY_BEFORE_REFRESH;\n    cfg->unreg_timeout = PJSUA_UNREG_TIMEOUT;\n    pjsip_publishc_opt_default(&cfg->publish_opt);\n    cfg->unpublish_max_wait_time_msec = PJSUA_UNPUBLISH_MAX_WAIT_TIME_MSEC;\n    cfg->transport_id = PJSUA_INVALID_ID;\n    cfg->allow_contact_rewrite = PJ_TRUE;\n    cfg->allow_via_rewrite = PJ_TRUE;\n    cfg->require_100rel = pjsua_var.ua_cfg.require_100rel;\n    cfg->use_timer = pjsua_var.ua_cfg.use_timer;\n    cfg->timer_setting = pjsua_var.ua_cfg.timer_setting;\n    cfg->lock_codec = 1;\n    cfg->ka_interval = 15;\n    cfg->ka_data = pj_str(\"\\r\\n\");\n    cfg->vid_cap_dev = PJMEDIA_VID_DEFAULT_CAPTURE_DEV;\n    cfg->vid_rend_dev = PJMEDIA_VID_DEFAULT_RENDER_DEV;\n#if PJMEDIA_HAS_VIDEO\n    pjmedia_vid_stream_rc_config_default(&cfg->vid_stream_rc_cfg);\n    pjmedia_vid_stream_sk_config_default(&cfg->vid_stream_sk_cfg);\n#endif\n    pjsua_transport_config_default(&cfg->rtp_cfg);\n    cfg->rtp_cfg.port = DEFAULT_RTP_PORT;\n    pjmedia_rtcp_fb_setting_default(&cfg->rtcp_fb_cfg);\n\n    pjsua_media_config_default(&med_cfg);\n    pjsua_ice_config_from_media_config(NULL, &cfg->ice_cfg, &med_cfg);\n    pjsua_turn_config_from_media_config(NULL, &cfg->turn_cfg, &med_cfg);\n\n    cfg->use_srtp = pjsua_var.ua_cfg.use_srtp;\n    cfg->srtp_secure_signaling = pjsua_var.ua_cfg.srtp_secure_signaling;\n    cfg->srtp_optional_dup_offer = pjsua_var.ua_cfg.srtp_optional_dup_offer;\n    cfg->srtp_opt = pjsua_var.ua_cfg.srtp_opt;\n    cfg->reg_retry_interval = PJSUA_REG_RETRY_INTERVAL;\n    cfg->reg_retry_random_interval = 10;\n    cfg->contact_rewrite_method = PJSUA_CONTACT_REWRITE_METHOD;\n    cfg->contact_use_src_port = PJ_TRUE;\n    cfg->use_rfc5626 = PJ_TRUE;\n    cfg->reg_use_proxy = PJSUA_REG_USE_OUTBOUND_PROXY |\n\t\t\t PJSUA_REG_USE_ACC_PROXY;\n#if defined(PJMEDIA_STREAM_ENABLE_KA) && PJMEDIA_STREAM_ENABLE_KA!=0\n    cfg->use_stream_ka = (PJMEDIA_STREAM_ENABLE_KA != 0);\n    pjmedia_stream_ka_config_default(&cfg->stream_ka_cfg);\n#endif\n    pj_list_init(&cfg->reg_hdr_list);\n    pj_list_init(&cfg->sub_hdr_list);\n    cfg->call_hold_type = PJSUA_CALL_HOLD_TYPE_DEFAULT;\n    cfg->register_on_acc_add = PJ_TRUE;\n    cfg->mwi_expires = PJSIP_MWI_DEFAULT_EXPIRES;\n\n    cfg->media_stun_use = PJSUA_STUN_RETRY_ON_FAILURE;\n    cfg->ip_change_cfg.shutdown_tp = PJ_TRUE;\n    cfg->ip_change_cfg.hangup_calls = PJ_FALSE;\n    cfg->ip_change_cfg.reinvite_flags = PJSUA_CALL_REINIT_MEDIA |\n\t\t\t\t\tPJSUA_CALL_UPDATE_CONTACT |\n\t\t\t\t\tPJSUA_CALL_UPDATE_VIA;\n}\n\nPJ_DEF(void) pjsua_buddy_config_default(pjsua_buddy_config *cfg)\n{\n    pj_bzero(cfg, sizeof(*cfg));\n}\n\nPJ_DEF(void) pjsua_media_config_default(pjsua_media_config *cfg)\n{\n    const pj_sys_info *si = pj_get_sys_info();\n    pj_str_t dev_model = {\"iPhone5\", 7};\n    \n    pj_bzero(cfg, sizeof(*cfg));\n\n    cfg->clock_rate = PJSUA_DEFAULT_CLOCK_RATE;\n    /* It is reported that there may be some media server resampling problem\n     * with iPhone 5 devices running iOS 7, so we set the sound device's\n     * clock rate to 44100 to avoid resampling.\n     */\n    if (pj_stristr(&si->machine, &dev_model) &&\n        ((si->os_ver & 0xFF000000) >> 24) >= 7)\n    {\n        cfg->snd_clock_rate = 44100;\n    } else {\n        cfg->snd_clock_rate = 0;\n    }\n    cfg->channel_count = 1;\n    cfg->audio_frame_ptime = PJSUA_DEFAULT_AUDIO_FRAME_PTIME;\n    cfg->max_media_ports = PJSUA_MAX_CONF_PORTS;\n    cfg->has_ioqueue = PJ_TRUE;\n    cfg->thread_cnt = 1;\n    cfg->quality = PJSUA_DEFAULT_CODEC_QUALITY;\n    cfg->ilbc_mode = PJSUA_DEFAULT_ILBC_MODE;\n    cfg->ec_tail_len = PJSUA_DEFAULT_EC_TAIL_LEN;\n    cfg->snd_rec_latency = PJMEDIA_SND_DEFAULT_REC_LATENCY;\n    cfg->snd_play_latency = PJMEDIA_SND_DEFAULT_PLAY_LATENCY;\n    cfg->jb_init = cfg->jb_min_pre = cfg->jb_max_pre = cfg->jb_max = -1;\n    cfg->jb_discard_algo = PJMEDIA_JB_DISCARD_PROGRESSIVE;\n    cfg->snd_auto_close_time = 1;\n\n    cfg->ice_max_host_cands = -1;\n    cfg->ice_always_update = PJ_TRUE;\n    pj_ice_sess_options_default(&cfg->ice_opt);\n\n    cfg->turn_conn_type = PJ_TURN_TP_UDP;\n#if PJ_HAS_SSL_SOCK\n    pj_turn_sock_tls_cfg_default(&cfg->turn_tls_setting);\n#endif\n    cfg->vid_preview_enable_native = PJ_TRUE;\n}\n\n/*****************************************************************************\n * This is a very simple PJSIP module, whose sole purpose is to display\n * incoming and outgoing messages to log. This module will have priority\n * higher than transport layer, which means:\n *\n *  - incoming messages will come to this module first before reaching\n *    transaction layer.\n *\n *  - outgoing messages will come to this module last, after the message\n *    has been 'printed' to contiguous buffer by transport layer and\n *    appropriate transport instance has been decided for this message.\n *\n */\n\n/* Notification on incoming messages */\nstatic pj_bool_t logging_on_rx_msg(pjsip_rx_data *rdata)\n{\n    char addr[PJ_INET6_ADDRSTRLEN+10];\n    pj_str_t input_str = pj_str(rdata->pkt_info.src_name);\n\n    PJ_LOG(4,(THIS_FILE, \"RX %d bytes %s from %s %s:\\n\"\n\t\t\t \"%.*s\\n\"\n\t\t\t \"--end msg--\",\n\t\t\t rdata->msg_info.len,\n\t\t\t pjsip_rx_data_get_info(rdata),\n\t\t\t rdata->tp_info.transport->type_name,\t      \n\t\t\t pj_addr_str_print(&input_str, \n\t\t\t\t\t   rdata->pkt_info.src_port, \n\t\t\t\t\t   addr,\n\t\t\t\t\t   sizeof(addr), \n\t\t\t\t\t   1),\n\t\t\t (int)rdata->msg_info.len,\n\t\t\t rdata->msg_info.msg_buf));\n    \n    /* Always return false, otherwise messages will not get processed! */\n    return PJ_FALSE;\n}\n\n/* Notification on outgoing messages */\nstatic pj_status_t logging_on_tx_msg(pjsip_tx_data *tdata)\n{\n    char addr[PJ_INET6_ADDRSTRLEN+10];\n    pj_str_t input_str = pj_str(tdata->tp_info.dst_name);\n    \n    /* Important note:\n     *\ttp_info field is only valid after outgoing messages has passed\n     *\ttransport layer. So don't try to access tp_info when the module\n     *\thas lower priority than transport layer.\n     */\n    PJ_LOG(4,(THIS_FILE, \"TX %d bytes %s to %s %s:\\n\"\n\t\t\t \"%.*s\\n\"\n\t\t\t \"--end msg--\",\n\t\t\t (tdata->buf.cur - tdata->buf.start),\n\t\t\t pjsip_tx_data_get_info(tdata),\n\t\t\t tdata->tp_info.transport->type_name,\n\t\t\t pj_addr_str_print(&input_str, \n\t\t\t\t\t   tdata->tp_info.dst_port, \n\t\t\t\t\t   addr,\n\t\t\t\t\t   sizeof(addr), \n\t\t\t\t\t   1),\n\t\t\t (int)(tdata->buf.cur - tdata->buf.start),\n\t\t\t tdata->buf.start));\n\n\n    /* Always return success, otherwise message will not get sent! */\n    return PJ_SUCCESS;\n}\n\n/* The module instance. */\nstatic pjsip_module pjsua_msg_logger = \n{\n    NULL, NULL,\t\t\t\t/* prev, next.\t\t*/\n    { \"mod-pjsua-log\", 13 },\t\t/* Name.\t\t*/\n    -1,\t\t\t\t\t/* Id\t\t\t*/\n    PJSIP_MOD_PRIORITY_TRANSPORT_LAYER-1,/* Priority\t        */\n    NULL,\t\t\t\t/* load()\t\t*/\n    NULL,\t\t\t\t/* start()\t\t*/\n    NULL,\t\t\t\t/* stop()\t\t*/\n    NULL,\t\t\t\t/* unload()\t\t*/\n    &logging_on_rx_msg,\t\t\t/* on_rx_request()\t*/\n    &logging_on_rx_msg,\t\t\t/* on_rx_response()\t*/\n    &logging_on_tx_msg,\t\t\t/* on_tx_request.\t*/\n    &logging_on_tx_msg,\t\t\t/* on_tx_response()\t*/\n    NULL,\t\t\t\t/* on_tsx_state()\t*/\n\n};\n\n\n/*****************************************************************************\n * Another simple module to handle incoming OPTIONS request\n */\n\n/* Notification on incoming request */\nstatic pj_bool_t options_on_rx_request(pjsip_rx_data *rdata)\n{\n    pjsip_tx_data *tdata;\n    pjsip_response_addr res_addr;\n    const pjsip_hdr *cap_hdr;\n    pj_status_t status;\n\n    /* Only want to handle OPTIONS requests */\n    if (pjsip_method_cmp(&rdata->msg_info.msg->line.req.method,\n\t\t\t pjsip_get_options_method()) != 0)\n    {\n\treturn PJ_FALSE;\n    }\n\n    /* Don't want to handle if shutdown is in progress */\n    if (pjsua_var.thread_quit_flag) {\n\tpjsip_endpt_respond_stateless(pjsua_var.endpt, rdata, \n\t\t\t\t      PJSIP_SC_TEMPORARILY_UNAVAILABLE, NULL,\n\t\t\t\t      NULL, NULL);\n\treturn PJ_TRUE;\n    }\n\n    /* Create basic response. */\n    status = pjsip_endpt_create_response(pjsua_var.endpt, rdata, 200, NULL, \n\t\t\t\t\t &tdata);\n    if (status != PJ_SUCCESS) {\n\tpjsua_perror(THIS_FILE, \"Unable to create OPTIONS response\", status);\n\treturn PJ_TRUE;\n    }\n\n    /* Add Allow header */\n    cap_hdr = pjsip_endpt_get_capability(pjsua_var.endpt, PJSIP_H_ALLOW, NULL);\n    if (cap_hdr) {\n\tpjsip_msg_add_hdr(tdata->msg, \n\t\t\t  (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, cap_hdr));\n    }\n\n    /* Add Accept header */\n    cap_hdr = pjsip_endpt_get_capability(pjsua_var.endpt, PJSIP_H_ACCEPT, NULL);\n    if (cap_hdr) {\n\tpjsip_msg_add_hdr(tdata->msg, \n\t\t\t  (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, cap_hdr));\n    }\n\n    /* Add Supported header */\n    cap_hdr = pjsip_endpt_get_capability(pjsua_var.endpt, PJSIP_H_SUPPORTED, NULL);\n    if (cap_hdr) {\n\tpjsip_msg_add_hdr(tdata->msg, \n\t\t\t  (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, cap_hdr));\n    }\n\n    /* Add Allow-Events header from the evsub module */\n    cap_hdr = pjsip_evsub_get_allow_events_hdr(NULL);\n    if (cap_hdr) {\n\tpjsip_msg_add_hdr(tdata->msg, \n\t\t\t  (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, cap_hdr));\n    }\n\n    /* Add User-Agent header */\n    if (pjsua_var.ua_cfg.user_agent.slen) {\n\tconst pj_str_t USER_AGENT = { \"User-Agent\", 10};\n\tpjsip_hdr *h;\n\n\th = (pjsip_hdr*) pjsip_generic_string_hdr_create(tdata->pool,\n\t\t\t\t\t\t\t &USER_AGENT,\n\t\t\t\t\t\t\t &pjsua_var.ua_cfg.user_agent);\n\tpjsip_msg_add_hdr(tdata->msg, h);\n    }\n\n    /* Get media socket info, make sure transport is ready */\n#if DISABLED_FOR_TICKET_1185\n    if (pjsua_var.calls[0].med_tp) {\n\tpjmedia_transport_info tpinfo;\n\tpjmedia_sdp_session *sdp;\n\n\tpjmedia_transport_info_init(&tpinfo);\n\tpjmedia_transport_get_info(pjsua_var.calls[0].med_tp, &tpinfo);\n\n\t/* Add SDP body, using call0's RTP address */\n\tstatus = pjmedia_endpt_create_sdp(pjsua_var.med_endpt, tdata->pool, 1,\n\t\t\t\t\t  &tpinfo.sock_info, &sdp);\n\tif (status == PJ_SUCCESS) {\n\t    pjsip_create_sdp_body(tdata->pool, sdp, &tdata->msg->body);\n\t}\n    }\n#endif\n\n    /* Send response */\n    pjsip_get_response_addr(tdata->pool, rdata, &res_addr);\n    status = pjsip_endpt_send_response(pjsua_var.endpt, &res_addr, tdata, NULL, NULL);\n    if (status != PJ_SUCCESS)\n\tpjsip_tx_data_dec_ref(tdata);\n\n    return PJ_TRUE;\n}\n\n\n/* The module instance. */\nstatic pjsip_module pjsua_options_handler = \n{\n    NULL, NULL,\t\t\t\t/* prev, next.\t\t*/\n    { \"mod-pjsua-options\", 17 },\t/* Name.\t\t*/\n    -1,\t\t\t\t\t/* Id\t\t\t*/\n    PJSIP_MOD_PRIORITY_APPLICATION,\t/* Priority\t        */\n    NULL,\t\t\t\t/* load()\t\t*/\n    NULL,\t\t\t\t/* start()\t\t*/\n    NULL,\t\t\t\t/* stop()\t\t*/\n    NULL,\t\t\t\t/* unload()\t\t*/\n    &options_on_rx_request,\t\t/* on_rx_request()\t*/\n    NULL,\t\t\t\t/* on_rx_response()\t*/\n    NULL,\t\t\t\t/* on_tx_request.\t*/\n    NULL,\t\t\t\t/* on_tx_response()\t*/\n    NULL,\t\t\t\t/* on_tsx_state()\t*/\n\n};\n\n\n/*****************************************************************************\n * These two functions are the main callbacks registered to PJSIP stack\n * to receive SIP request and response messages that are outside any\n * dialogs and any transactions.\n */\n\n/*\n * Handler for receiving incoming requests.\n *\n * This handler serves multiple purposes:\n *  - it receives requests outside dialogs.\n *  - it receives requests inside dialogs, when the requests are\n *    unhandled by other dialog usages. Example of these\n *    requests are: MESSAGE.\n */\nstatic pj_bool_t mod_pjsua_on_rx_request(pjsip_rx_data *rdata)\n{\n    pj_bool_t processed = PJ_FALSE;\n\n    PJSUA_LOCK();\n\n    if (rdata->msg_info.msg->line.req.method.id == PJSIP_INVITE_METHOD) {\n\n\tprocessed = pjsua_call_on_incoming(rdata);\n    }\n\n    PJSUA_UNLOCK();\n\n    return processed;\n}\n\n\n/*\n * Handler for receiving incoming responses.\n *\n * This handler serves multiple purposes:\n *  - it receives strayed responses (i.e. outside any dialog and\n *    outside any transactions).\n *  - it receives responses coming to a transaction, when pjsua\n *    module is set as transaction user for the transaction.\n *  - it receives responses inside a dialog, when these responses\n *    are unhandled by other dialog usages.\n */\nstatic pj_bool_t mod_pjsua_on_rx_response(pjsip_rx_data *rdata)\n{\n    PJ_UNUSED_ARG(rdata);\n    return PJ_FALSE;\n}\n\n\n/*****************************************************************************\n * Logging.\n */\n\n/* Log callback */\nstatic void log_writer(int level, const char *buffer, int len)\n{\n    /* Write to file, stdout or application callback. */\n\n    if (pjsua_var.log_file) {\n\tpj_ssize_t size = len;\n\tpj_file_write(pjsua_var.log_file, buffer, &size);\n\t/* This will slow things down considerably! Don't do it!\n\t pj_file_flush(pjsua_var.log_file);\n\t*/\n    }\n\n    if (level <= (int)pjsua_var.log_cfg.console_level) {\n\tif (pjsua_var.log_cfg.cb)\n\t    (*pjsua_var.log_cfg.cb)(level, buffer, len);\n\telse\n\t    pj_log_write(level, buffer, len);\n    }\n}\n\n\n/*\n * Application can call this function at any time (after pjsua_create(), of\n * course) to change logging settings.\n */\nPJ_DEF(pj_status_t) pjsua_reconfigure_logging(const pjsua_logging_config *cfg)\n{\n    pj_status_t status;\n\n    /* Save config. */\n    pjsua_logging_config_dup(pjsua_var.pool, &pjsua_var.log_cfg, cfg);\n\n    /* Redirect log function to ours */\n    pj_log_set_log_func( &log_writer );\n\n    /* Set decor */\n    pj_log_set_decor(pjsua_var.log_cfg.decor);\n\n    /* Set log level */\n    pj_log_set_level(pjsua_var.log_cfg.level);\n\n    /* Close existing file, if any */\n    if (pjsua_var.log_file) {\n\tpj_file_close(pjsua_var.log_file);\n\tpjsua_var.log_file = NULL;\n    }\n\n    /* If output log file is desired, create the file: */\n    if (pjsua_var.log_cfg.log_filename.slen) {\n\tunsigned flags = PJ_O_WRONLY;\n\tflags |= pjsua_var.log_cfg.log_file_flags;\n\tstatus = pj_file_open(pjsua_var.pool, \n\t\t\t      pjsua_var.log_cfg.log_filename.ptr,\n\t\t\t      flags, \n\t\t\t      &pjsua_var.log_file);\n\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error creating log file\", status);\n\t    return status;\n\t}\n    }\n\n    /* Unregister msg logging if it's previously registered */\n    if (pjsua_msg_logger.id >= 0) {\n\tpjsip_endpt_unregister_module(pjsua_var.endpt, &pjsua_msg_logger);\n\tpjsua_msg_logger.id = -1;\n    }\n\n    /* Enable SIP message logging */\n    if (pjsua_var.log_cfg.msg_logging)\n\tpjsip_endpt_register_module(pjsua_var.endpt, &pjsua_msg_logger);\n\n    return PJ_SUCCESS;\n}\n\n\n/*****************************************************************************\n * PJSUA Base API.\n */\n\n/* Worker thread function. */\nstatic int worker_thread(void *arg)\n{\n    enum { TIMEOUT = 10 };\n\n    PJ_UNUSED_ARG(arg);\n\n    while (!pjsua_var.thread_quit_flag) {\n\tint count;\n\n\tcount = pjsua_handle_events(TIMEOUT);\n\tif (count < 0)\n\t    pj_thread_sleep(TIMEOUT);\n    }\n\n    return 0;\n}\n\n#if PJSUA_SEPARATE_WORKER_FOR_TIMER\n\n/* Timer heap worker thread function. */\nstatic int worker_thread_timer(void *arg)\n{\n    pj_timer_heap_t *th;\n\n    PJ_UNUSED_ARG(arg);\n\n    th = pjsip_endpt_get_timer_heap(pjsua_var.endpt);\n    while (!pjsua_var.thread_quit_flag) {\n\tpj_time_val timeout = {0, 0};\n\tint c;\n\n\tc = pj_timer_heap_poll(th, &timeout);\n\tif (c == 0) {\n\t    /* Sleep if no event */\n\t    enum { MAX_SLEEP_MS = 100 };\n\t    if (PJ_TIME_VAL_MSEC(timeout) < MAX_SLEEP_MS)\n\t\tpj_thread_sleep(PJ_TIME_VAL_MSEC(timeout));\n\t    else\n\t\tpj_thread_sleep(MAX_SLEEP_MS);\n\t}\n    }\n    return 0;\n}\n\n/* Ioqueue worker thread function. */\nstatic int worker_thread_ioqueue(void *arg)\n{\n    pj_ioqueue_t *ioq;\n\n    PJ_UNUSED_ARG(arg);\n\n    ioq = pjsip_endpt_get_ioqueue(pjsua_var.endpt);\n    while (!pjsua_var.thread_quit_flag) {\n\tpj_time_val timeout = {0, 100};\n\tpj_ioqueue_poll(ioq, &timeout);\n    }\n    return 0;\n}\n\n#endif\n\nPJ_DEF(void) pjsua_stop_worker_threads(void)\n{\n    unsigned i;\n\n    pjsua_var.thread_quit_flag = 1;\n\n    /* Wait worker threads to quit: */\n    for (i=0; i<(int)pjsua_var.ua_cfg.thread_cnt; ++i) {\n    \tif (pjsua_var.thread[i]) {\n    \t    pj_status_t status;\n    \t    status = pj_thread_join(pjsua_var.thread[i]);\n    \t    if (status != PJ_SUCCESS) {\n    \t\tPJ_PERROR(4,(THIS_FILE, status, \"Error joining worker thread\"));\n    \t\tpj_thread_sleep(1000);\n    \t    }\n    \t    pj_thread_destroy(pjsua_var.thread[i]);\n    \t    pjsua_var.thread[i] = NULL;\n    \t}\n    }\n}\n\n/* Init random seed */\nstatic void init_random_seed(void)\n{\n    pj_sockaddr addr;\n    const pj_str_t *hostname;\n    pj_uint32_t pid;\n    pj_time_val t;\n    unsigned seed=0;\n\n    /* Add hostname */\n    hostname = pj_gethostname();\n    seed = pj_hash_calc(seed, hostname->ptr, (int)hostname->slen);\n\n    /* Add primary IP address */\n    if (pj_gethostip(pj_AF_INET(), &addr)==PJ_SUCCESS)\n\tseed = pj_hash_calc(seed, &addr.ipv4.sin_addr, 4);\n\n    /* Get timeofday */\n    pj_gettimeofday(&t);\n    seed = pj_hash_calc(seed, &t, sizeof(t));\n\n    /* Add PID */\n    pid = pj_getpid();\n    seed = pj_hash_calc(seed, &pid, sizeof(pid));\n\n    /* Init random seed */\n    pj_srand(seed);\n}\n\n/*\n * Instantiate pjsua application.\n */\nPJ_DEF(pj_status_t) pjsua_create(void)\n{\n    pj_status_t status;\n\n    /* Init pjsua data */\n    init_data();\n\n    /* Set default logging settings */\n    pjsua_logging_config_default(&pjsua_var.log_cfg);\n\n    /* Init PJLIB: */\n    status = pj_init();\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    pj_log_push_indent();\n\n    /* Init random seed */\n    init_random_seed();\n\n    /* Init PJLIB-UTIL: */\n    status = pjlib_util_init();\n    if (status != PJ_SUCCESS) {\n\tpj_log_pop_indent();\n\tpjsua_perror(THIS_FILE, \"Failed in initializing pjlib-util\", status);\n\tpj_shutdown();\n\treturn status;\n    }\n\n    /* Init PJNATH */\n    status = pjnath_init();\n    if (status != PJ_SUCCESS) {\n\tpj_log_pop_indent();\n\tpjsua_perror(THIS_FILE, \"Failed in initializing pjnath\", status);\n\tpj_shutdown();\n\treturn status;\n    }\n\n    /* Set default sound device ID */\n    pjsua_var.cap_dev = PJMEDIA_AUD_DEFAULT_CAPTURE_DEV;\n    pjsua_var.play_dev = PJMEDIA_AUD_DEFAULT_PLAYBACK_DEV;\n\n    /* Set default video device ID */\n    pjsua_var.vcap_dev = PJMEDIA_VID_DEFAULT_CAPTURE_DEV;\n    pjsua_var.vrdr_dev = PJMEDIA_VID_DEFAULT_RENDER_DEV;\n\n    /* Init caching pool. */\n    pj_caching_pool_init(&pjsua_var.cp, NULL, 0);\n\n    /* Create memory pools for application and internal use. */\n    pjsua_var.pool = pjsua_pool_create(\"pjsua\", PJSUA_POOL_LEN, PJSUA_POOL_INC);\n    pjsua_var.timer_pool = pjsua_pool_create(\"pjsua_timer\", 500, 500);\n    if (pjsua_var.pool == NULL || pjsua_var.timer_pool == NULL) {\n\tpj_log_pop_indent();\n\tstatus = PJ_ENOMEM;\n\tpjsua_perror(THIS_FILE, \"Unable to create pjsua/timer pool\", status);\n\tpj_shutdown();\n\treturn status;\n    }\n    \n    /* Create mutex */\n    status = pj_mutex_create_recursive(pjsua_var.pool, \"pjsua\", \n\t\t\t\t       &pjsua_var.mutex);\n    if (status != PJ_SUCCESS) {\n\tpj_log_pop_indent();\n\tpjsua_perror(THIS_FILE, \"Unable to create mutex\", status);\n\tpjsua_destroy();\n\treturn status;\n    }\n\n    /* Must create SIP endpoint to initialize SIP parser. The parser\n     * is needed for example when application needs to call pjsua_verify_url().\n     */\n    status = pjsip_endpt_create(&pjsua_var.cp.factory, \n\t\t\t\tpj_gethostname()->ptr, \n\t\t\t\t&pjsua_var.endpt);\n    if (status != PJ_SUCCESS) {\n\tpj_log_pop_indent();\n\tpjsua_perror(THIS_FILE, \"Unable to create endpoint\", status);\n\tpjsua_destroy();\n\treturn status;\n    }\n\n    /* Init timer entry and event list */\n    pj_list_init(&pjsua_var.active_timer_list);\n    pj_list_init(&pjsua_var.timer_list);\n    pj_list_init(&pjsua_var.event_list);\n\n    /* Create timer mutex */\n    status = pj_mutex_create_recursive(pjsua_var.pool, \"pjsua_timer\", \n\t\t\t\t       &pjsua_var.timer_mutex);\n    if (status != PJ_SUCCESS) {\n\tpj_log_pop_indent();\n\tpjsua_perror(THIS_FILE, \"Unable to create mutex\", status);\n\tpjsua_destroy();\n\treturn status;\n    }\n\n    pjsua_set_state(PJSUA_STATE_CREATED);\n    pj_log_pop_indent();\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Initialize pjsua with the specified settings. All the settings are \n * optional, and the default values will be used when the config is not\n * specified.\n */\nPJ_DEF(pj_status_t) pjsua_init( const pjsua_config *ua_cfg,\n\t\t\t\tconst pjsua_logging_config *log_cfg,\n\t\t\t\tconst pjsua_media_config *media_cfg)\n{\n    pjsua_config\t default_cfg;\n    pjsua_media_config\t default_media_cfg;\n    const pj_str_t\t STR_OPTIONS = { \"OPTIONS\", 7 };\n    pjsip_ua_init_param  ua_init_param;\n    unsigned i;\n    pj_status_t status;\n\n    pj_log_push_indent();\n\n    /* Create default configurations when the config is not supplied */\n\n    if (ua_cfg == NULL) {\n\tpjsua_config_default(&default_cfg);\n\tua_cfg = &default_cfg;\n    }\n\n    if (media_cfg == NULL) {\n\tpjsua_media_config_default(&default_media_cfg);\n\tmedia_cfg = &default_media_cfg;\n    }\n\n    /* Initialize logging first so that info/errors can be captured */\n    if (log_cfg) {\n\tstatus = pjsua_reconfigure_logging(log_cfg);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n    }\n\n#if defined(PJ_IPHONE_OS_HAS_MULTITASKING_SUPPORT) && \\\n    PJ_IPHONE_OS_HAS_MULTITASKING_SUPPORT != 0\n    if (!(pj_get_sys_info()->flags & PJ_SYS_HAS_IOS_BG)) {\n\tPJ_LOG(5, (THIS_FILE, \"Device does not support \"\n\t\t\t      \"background mode\"));\n\tpj_activesock_enable_iphone_os_bg(PJ_FALSE);\n    }\n#endif\n\n    /* If nameserver is configured, create DNS resolver instance and\n     * set it to be used by SIP resolver.\n     */\n    if (ua_cfg->nameserver_count) {\n#if PJSIP_HAS_RESOLVER\n\tunsigned ii;\n\n\t/* Create DNS resolver */\n\tstatus = pjsip_endpt_create_resolver(pjsua_var.endpt, \n\t\t\t\t\t     &pjsua_var.resolver);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error creating resolver\", status);\n\t    goto on_error;\n\t}\n\n\t/* Configure nameserver for the DNS resolver */\n\tstatus = pj_dns_resolver_set_ns(pjsua_var.resolver, \n\t\t\t\t\tua_cfg->nameserver_count,\n\t\t\t\t\tua_cfg->nameserver, NULL);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error setting nameserver\", status);\n\t    goto on_error;\n\t}\n\n\t/* Set this DNS resolver to be used by the SIP resolver */\n\tstatus = pjsip_endpt_set_resolver(pjsua_var.endpt, pjsua_var.resolver);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error setting DNS resolver\", status);\n\t    goto on_error;\n\t}\n\n\t/* Print nameservers */\n\tfor (ii=0; ii<ua_cfg->nameserver_count; ++ii) {\n\t    PJ_LOG(4,(THIS_FILE, \"Nameserver %.*s added\",\n\t\t      (int)ua_cfg->nameserver[ii].slen,\n\t\t      ua_cfg->nameserver[ii].ptr));\n\t}\n#else\n\tPJ_LOG(2,(THIS_FILE, \n\t\t  \"DNS resolver is disabled (PJSIP_HAS_RESOLVER==0)\"));\n#endif\n    }\n\n    /* Init SIP UA: */\n\n    /* Initialize transaction layer: */\n    status = pjsip_tsx_layer_init_module(pjsua_var.endpt);\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n\n    /* Initialize UA layer module: */\n    pj_bzero(&ua_init_param, sizeof(ua_init_param));\n    if (ua_cfg->hangup_forked_call) {\n\tua_init_param.on_dlg_forked = &on_dlg_forked;\n    }\n    status = pjsip_ua_init_module( pjsua_var.endpt, &ua_init_param);\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n\n    /* Initialize Replaces support. */\n    status = pjsip_replaces_init_module( pjsua_var.endpt );\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    /* Initialize 100rel support */\n    status = pjsip_100rel_init_module(pjsua_var.endpt);\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    /* Initialize session timer support */\n    status = pjsip_timer_init_module(pjsua_var.endpt);\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    /* Initialize and register PJSUA application module. */\n    {\n\tconst pjsip_module mod_initializer = \n\t{\n\tNULL, NULL,\t\t    /* prev, next.\t\t\t*/\n\t{ \"mod-pjsua\", 9 },\t    /* Name.\t\t\t\t*/\n\t-1,\t\t\t    /* Id\t\t\t\t*/\n\tPJSIP_MOD_PRIORITY_APPLICATION,\t/* Priority\t\t\t*/\n\tNULL,\t\t\t    /* load()\t\t\t\t*/\n\tNULL,\t\t\t    /* start()\t\t\t\t*/\n\tNULL,\t\t\t    /* stop()\t\t\t\t*/\n\tNULL,\t\t\t    /* unload()\t\t\t\t*/\n\t&mod_pjsua_on_rx_request,   /* on_rx_request()\t\t\t*/\n\t&mod_pjsua_on_rx_response,  /* on_rx_response()\t\t\t*/\n\tNULL,\t\t\t    /* on_tx_request.\t\t\t*/\n\tNULL,\t\t\t    /* on_tx_response()\t\t\t*/\n\tNULL,\t\t\t    /* on_tsx_state()\t\t\t*/\n\t};\n\n\tpjsua_var.mod = mod_initializer;\n\n\tstatus = pjsip_endpt_register_module(pjsua_var.endpt, &pjsua_var.mod);\n\tPJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n    }\n\n    /* Parse outbound proxies */\n    for (i=0; i<ua_cfg->outbound_proxy_cnt; ++i) {\n\tpj_str_t tmp;\n    \tpj_str_t hname = { \"Route\", 5};\n\tpjsip_route_hdr *r;\n\n\tpj_strdup_with_null(pjsua_var.pool, &tmp, &ua_cfg->outbound_proxy[i]);\n\n\tr = (pjsip_route_hdr*)\n\t    pjsip_parse_hdr(pjsua_var.pool, &hname, tmp.ptr,\n\t\t\t    (unsigned)tmp.slen, NULL);\n\tif (r == NULL) {\n\t    pjsua_perror(THIS_FILE, \"Invalid outbound proxy URI\",\n\t\t\t PJSIP_EINVALIDURI);\n\t    status = PJSIP_EINVALIDURI;\n\t    goto on_error;\n\t}\n\n\tif (pjsua_var.ua_cfg.force_lr) {\n\t    pjsip_sip_uri *sip_url;\n\t    if (!PJSIP_URI_SCHEME_IS_SIP(r->name_addr.uri) &&\n\t\t!PJSIP_URI_SCHEME_IS_SIPS(r->name_addr.uri))\n\t    {\n\t\tstatus = PJSIP_EINVALIDSCHEME;\n\t\tgoto on_error;\n\t    }\n\t    sip_url = (pjsip_sip_uri*)r->name_addr.uri;\n\t    sip_url->lr_param = 1;\n\t}\n\n\tpj_list_push_back(&pjsua_var.outbound_proxy, r);\n    }\n    \n\n    /* Initialize PJSUA call subsystem: */\n    status = pjsua_call_subsys_init(ua_cfg);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Convert deprecated STUN settings */\n    if (pjsua_var.ua_cfg.stun_srv_cnt==0) {\n\tif (pjsua_var.ua_cfg.stun_domain.slen) {\n\t    pjsua_var.ua_cfg.stun_srv[pjsua_var.ua_cfg.stun_srv_cnt++] = \n\t\tpjsua_var.ua_cfg.stun_domain;\n\t}\n\tif (pjsua_var.ua_cfg.stun_host.slen) {\n\t    pjsua_var.ua_cfg.stun_srv[pjsua_var.ua_cfg.stun_srv_cnt++] = \n\t\tpjsua_var.ua_cfg.stun_host;\n\t}\n    }\n\n    /* Start resolving STUN server */\n    status = resolve_stun_server(PJ_FALSE, PJ_FALSE, 0);\n    if (status != PJ_SUCCESS && status != PJ_EPENDING) {\n\tpjsua_perror(THIS_FILE, \"Error resolving STUN server\", status);\n\tgoto on_error;\n    }\n\n    /* Initialize PJSUA media subsystem */\n    status = pjsua_media_subsys_init(media_cfg);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n\n    /* Init core SIMPLE module : */\n    status = pjsip_evsub_init_module(pjsua_var.endpt);\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n\n    /* Init presence module: */\n    status = pjsip_pres_init_module( pjsua_var.endpt, pjsip_evsub_instance());\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    /* Initialize MWI support */\n    status = pjsip_mwi_init_module(pjsua_var.endpt, pjsip_evsub_instance());\n\n    /* Init PUBLISH module */\n    pjsip_publishc_init_module(pjsua_var.endpt);\n\n    /* Init xfer/REFER module */\n    status = pjsip_xfer_init_module( pjsua_var.endpt );\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    /* Init pjsua presence handler: */\n    status = pjsua_pres_init();\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Init out-of-dialog MESSAGE request handler. */\n    status = pjsua_im_init();\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Register OPTIONS handler */\n    pjsip_endpt_register_module(pjsua_var.endpt, &pjsua_options_handler);\n\n    /* Add OPTIONS in Allow header */\n    pjsip_endpt_add_capability(pjsua_var.endpt, NULL, PJSIP_H_ALLOW,\n\t\t\t       NULL, 1, &STR_OPTIONS);\n\n    /* Start worker thread if needed. */\n    if (pjsua_var.ua_cfg.thread_cnt) {\n\tunsigned ii;\n\n\tif (pjsua_var.ua_cfg.thread_cnt > PJ_ARRAY_SIZE(pjsua_var.thread))\n\t    pjsua_var.ua_cfg.thread_cnt = PJ_ARRAY_SIZE(pjsua_var.thread);\n\n#if PJSUA_SEPARATE_WORKER_FOR_TIMER\n\tif (pjsua_var.ua_cfg.thread_cnt < 2)\n\t    pjsua_var.ua_cfg.thread_cnt = 2;\n#endif\n\n\tfor (ii=0; ii<pjsua_var.ua_cfg.thread_cnt; ++ii) {\n\t    char tname[16];\n\t    \n\t    pj_ansi_snprintf(tname, sizeof(tname), \"pjsua_%d\", ii);\n\n#if PJSUA_SEPARATE_WORKER_FOR_TIMER\n\t    if (ii == 0) {\n\t\tstatus = pj_thread_create(pjsua_var.pool, tname,\n\t\t\t\t\t  &worker_thread_timer,\n\t\t\t\t\t  NULL, 0, 0, &pjsua_var.thread[ii]);\n\t    } else {\n\t\tstatus = pj_thread_create(pjsua_var.pool, tname,\n\t\t\t\t\t  &worker_thread_ioqueue,\n\t\t\t\t\t  NULL, 0, 0, &pjsua_var.thread[ii]);\n\t    }\n#else\n\t    status = pj_thread_create(pjsua_var.pool, tname, &worker_thread,\n\t\t\t\t      NULL, 0, 0, &pjsua_var.thread[ii]);\n#endif\n\t    if (status != PJ_SUCCESS)\n\t\tgoto on_error;\n\t}\n\tPJ_LOG(4,(THIS_FILE, \"%d SIP worker threads created\", \n\t\t  pjsua_var.ua_cfg.thread_cnt));\n    } else {\n\tPJ_LOG(4,(THIS_FILE, \"No SIP worker threads created\"));\n    }\n\n    /* Done! */\n\n    PJ_LOG(3,(THIS_FILE, \"pjsua version %s for %s initialized\", \n\t\t\t pj_get_version(), pj_get_sys_info()->info.ptr));\n\n    pjsua_set_state(PJSUA_STATE_INIT);\n    pj_log_pop_indent();\n    return PJ_SUCCESS;\n\non_error:\n    pj_log_pop_indent();\n    return status;\n}\n\n\n/* Sleep with polling */\nstatic void busy_sleep(unsigned msec)\n{\n    pj_time_val timeout, now;\n\n    pj_gettickcount(&timeout);\n    timeout.msec += msec;\n    pj_time_val_normalize(&timeout);\n\n    do {\n\tint i;\n\ti = msec / 10;\n\twhile (pjsua_handle_events(10) > 0 && i > 0)\n\t    --i;\n\tpj_gettickcount(&now);\n    } while (PJ_TIME_VAL_LT(now, timeout));\n}\n\nstatic void stun_resolve_add_ref(pjsua_stun_resolve *sess)\n{\n    ++sess->ref_cnt;\n}\n\n\nstatic void release_stun_session(pjsua_stun_resolve *sess)\n{\n    PJSUA_LOCK();\n    pj_list_erase(sess);\n    PJSUA_UNLOCK();\n\n    pj_assert(sess->stun_sock==NULL);\n    pj_pool_release(sess->pool);\n}\n\nstatic void destroy_stun_resolve_cb(pj_timer_heap_t *t, pj_timer_entry *e)\n{\n    pjsua_stun_resolve *sess = (pjsua_stun_resolve*)e->user_data;\n    PJ_UNUSED_ARG(t);\n\n    release_stun_session(sess);\n}\n\n\nstatic void destroy_stun_resolve(pjsua_stun_resolve *sess, pj_bool_t forced)\n{\n    pj_time_val timeout = {0, 0};\n\n    if (sess->destroy_flag)\n\treturn;\n\n    sess->destroy_flag = PJ_TRUE;\n    if (sess->stun_sock) {\n        pj_stun_sock_destroy(sess->stun_sock);\n        sess->stun_sock = NULL;\n    }\n\n    if (pjsua_var.stun_status == PJ_EUNKNOWN ||\n    \tpjsua_var.stun_status == PJ_EPENDING)\n    {\n        pjsua_var.stun_status = PJNATH_ESTUNDESTROYED;\n    }\n\n    if (forced) {\n\trelease_stun_session(sess);\n    } else {\n\t/* Schedule session clean up, it needs PJSUA lock and locking it here\n\t * may cause deadlock as this function may be called by STUN socket\n\t * while holding STUN socket lock, while application may wait for STUN\n\t * resolution while holding PJSUA lock.\n\t */\n\tpj_timer_entry_init(&sess->timer, 0, (void*)sess,\n\t\t\t    &destroy_stun_resolve_cb);\n\tpjsua_schedule_timer(&sess->timer, &timeout);\n    }\n}\n\nstatic void stun_resolve_dec_ref(pjsua_stun_resolve *sess)\n{\n    int ref_cnt = --sess->ref_cnt;\n    /* If the STUN resolution session is blocking, only the waiting thread\n     * is allowed to destroy the session, otherwise it may cause deadlock.\n     */\n    if ((ref_cnt > 0) ||\n\t(sess->blocking && (sess->waiter != pj_thread_this()))) \n    {\n\treturn;\n    }\n\n    destroy_stun_resolve(sess, PJ_FALSE);\n}\n\n\n/* This is the internal function to be called when STUN resolution\n * session (pj_stun_resolve) has completed.\n */\nstatic void stun_resolve_complete(pjsua_stun_resolve *sess)\n{\n    pj_stun_resolve_result result;\n\n    if (sess->has_result)\n\tgoto on_return;\n\n    pj_bzero(&result, sizeof(result));\n    result.token = sess->token;\n    result.status = sess->status;\n    result.name = sess->srv[sess->idx];\n    result.index = sess->idx;\n    pj_memcpy(&result.addr, &sess->addr, sizeof(result.addr));\n    sess->has_result = PJ_TRUE;\n\n    if (result.status == PJ_SUCCESS) {\n\tchar addr[PJ_INET6_ADDRSTRLEN+10];\n\tpj_sockaddr_print(&result.addr, addr, sizeof(addr), 3);\n\tPJ_LOG(4,(THIS_FILE, \n\t\t  \"STUN resolution success, using %.*s, address is %s\",\n\t\t  (int)sess->srv[sess->idx].slen,\n\t\t  sess->srv[sess->idx].ptr,\n\t\t  addr));\n    } else {\n\tchar errmsg[PJ_ERR_MSG_SIZE];\n\tpj_strerror(result.status, errmsg, sizeof(errmsg));\n\tPJ_LOG(1,(THIS_FILE, \"STUN resolution failed: %s\", errmsg));\n    }\n\n    sess->cb(&result);\n\non_return:\n    if (!sess->blocking) {\n\tstun_resolve_dec_ref(sess);\n    }\n}\n\n/* This is the callback called by the STUN socket (pj_stun_sock)\n * to report it's state. We use this as part of testing the\n * STUN server.\n */\nstatic pj_bool_t test_stun_on_status(pj_stun_sock *stun_sock, \n\t\t\t\t     pj_stun_sock_op op,\n\t\t\t\t     pj_status_t status)\n{\n    pjsua_stun_resolve *sess;\n\n    sess = (pjsua_stun_resolve*) pj_stun_sock_get_user_data(stun_sock);\n    pj_assert(stun_sock == sess->stun_sock);\n\n    if (status != PJ_SUCCESS) {\n\tchar errmsg[PJ_ERR_MSG_SIZE];\n\tpj_strerror(status, errmsg, sizeof(errmsg));\n\n\tPJ_LOG(4,(THIS_FILE, \"STUN resolution for %.*s failed: %s\",\n\t\t  (int)sess->srv[sess->idx].slen,\n\t\t  sess->srv[sess->idx].ptr, errmsg));\n\n\tif (op == PJ_STUN_SOCK_BINDING_OP && !sess->async_wait) {\n\t    /* Just return here, we will destroy the STUN socket and\n\t     * continue the STUN resolution later in resolve_stun_entry().\n\t     * For more details, please refer to ticket #1962.\n\t     */\n            return PJ_FALSE;\n\t}\n\n\tpj_stun_sock_destroy(stun_sock);\n\tsess->stun_sock = NULL;\n\n\tstun_resolve_add_ref(sess);\n\n\tif (pjsua_var.ua_cfg.stun_try_ipv6 && sess->af == pj_AF_INET()) {\n\t    sess->af = pj_AF_INET6();\n\t} else {\n\t    ++sess->idx;\n\t    sess->af = pj_AF_INET();\n\t    if (sess->idx >= sess->count)\n                sess->status = status;\n        }\n\n\tresolve_stun_entry(sess);\n\n\tstun_resolve_dec_ref(sess);\n\n\treturn PJ_FALSE;\n\n    } else if (op == PJ_STUN_SOCK_BINDING_OP) {\n\tpj_stun_sock_info ssi;\n\n\tpj_stun_sock_get_info(stun_sock, &ssi);\n\tpj_memcpy(&sess->addr, &ssi.srv_addr, sizeof(sess->addr));\n\n\tstun_resolve_add_ref(sess);\n\n\tsess->status = PJ_SUCCESS;\n\tpj_stun_sock_destroy(stun_sock);\n\tsess->stun_sock = NULL;\n\n\tstun_resolve_complete(sess);\n\n\tstun_resolve_dec_ref(sess);\n\n\treturn PJ_FALSE;\n\n    } else\n\treturn PJ_TRUE;\n    \n}\n\n/* This is an internal function to resolve and test current\n * server entry in pj_stun_resolve session. It is called by\n * pjsua_resolve_stun_servers() and test_stun_on_status() above\n */\nstatic void resolve_stun_entry(pjsua_stun_resolve *sess)\n{\n    pj_status_t status = PJ_EUNKNOWN;\n\n    /* Loop while we have entry to try */\n    for (; sess->idx < sess->count;\n    \t (pjsua_var.ua_cfg.stun_try_ipv6 && sess->af == pj_AF_INET())?\n\t sess->af = pj_AF_INET6(): (++sess->idx, sess->af = pj_AF_INET()))\n    {\n\tint af;\n\tchar target[64];\n\tpj_str_t hostpart;\n\tpj_uint16_t port;\n\tpj_stun_sock_cb stun_sock_cb;\n\t\n\tpj_assert(sess->idx < sess->count);\n\n\tif (pjsua_var.ua_cfg.stun_try_ipv6 &&\n\t    pjsua_var.stun_opt != PJSUA_NAT64_DISABLED &&\n\t    sess->af == pj_AF_INET())\n\t{\n\t    /* Skip IPv4 STUN resolution if NAT64 is not disabled. */\n\t    PJ_LOG(4,(THIS_FILE, \"Skipping IPv4 resolution of STUN server \"\n\t    \t\t\t \"%s (%d of %d)\", target,\n\t    \t\t\t sess->idx+1, sess->count));\t    \n\t    continue;\n\t}\n\n\tpj_ansi_snprintf(target, sizeof(target), \"%.*s\",\n\t\t\t (int)sess->srv[sess->idx].slen,\n\t\t\t sess->srv[sess->idx].ptr);\n\n\t/* Parse the server entry into host:port */\n\tstatus = pj_sockaddr_parse2(pj_AF_UNSPEC(), 0, &sess->srv[sess->idx],\n\t\t\t\t    &hostpart, &port, &af);\n\tif (status != PJ_SUCCESS) {\n    \t    PJ_LOG(2,(THIS_FILE, \"Invalid STUN server entry %s\", target));\n\t    continue;\n\t}\n\t\n\t/* Use default port if not specified */\n\tif (port == 0)\n\t    port = PJ_STUN_PORT;\n\n\tpj_assert(sess->stun_sock == NULL);\n\n\tPJ_LOG(4,(THIS_FILE, \"Trying STUN server %s %s (%d of %d)..\",\n\t\t  target, (sess->af == pj_AF_INET()? \"IPv4\": \"IPv6\"),\n\t\t  sess->idx+1, sess->count));\n\n\t/* Use STUN_sock to test this entry */\n\tpj_bzero(&stun_sock_cb, sizeof(stun_sock_cb));\n\tstun_sock_cb.on_status = &test_stun_on_status;\n\tsess->async_wait = PJ_FALSE;\n\tstatus = pj_stun_sock_create(&pjsua_var.stun_cfg, \"stunresolve\",\n\t\t\t\t     sess->af, &stun_sock_cb,\n\t\t\t\t     NULL, sess, &sess->stun_sock);\n\tif (status != PJ_SUCCESS) {\n\t    char errmsg[PJ_ERR_MSG_SIZE];\n\t    pj_strerror(status, errmsg, sizeof(errmsg));\n\t    PJ_LOG(4,(THIS_FILE, \n\t\t     \"Error creating STUN socket for %s: %s\",\n\t\t     target, errmsg));\n\n\t    continue;\n\t}\n\n\tstatus = pj_stun_sock_start(sess->stun_sock, &hostpart, port,\n\t\t\t\t    pjsua_var.resolver);\n\tif (status != PJ_SUCCESS) {\n\t    char errmsg[PJ_ERR_MSG_SIZE];\n\t    pj_strerror(status, errmsg, sizeof(errmsg));\n\t    PJ_LOG(4,(THIS_FILE, \n\t\t     \"Error starting STUN socket for %s: %s\",\n\t\t     target, errmsg));\n\n\t    if (sess->stun_sock) {\n\t\tpj_stun_sock_destroy(sess->stun_sock);\n\t\tsess->stun_sock = NULL;\n\t    }\n\t    continue;\n\t}\n\n\t/* Done for now, testing will resume/complete asynchronously in\n\t * stun_sock_cb()\n\t */\n\tsess->async_wait = PJ_TRUE;\n\treturn;\n    }\n\n    if (sess->idx >= sess->count) {\n\t/* No more entries to try */\n\tstun_resolve_add_ref(sess);\n\tpj_assert(status != PJ_SUCCESS || sess->status != PJ_EPENDING);\n        if (sess->status == PJ_EPENDING)\n            sess->status = status;\n\tstun_resolve_complete(sess);\n\tstun_resolve_dec_ref(sess);\n    }\n}\n\n\n/*\n * Update STUN servers.\n */\nPJ_DEF(pj_status_t) pjsua_update_stun_servers(unsigned count, pj_str_t srv[],\n\t\t\t\t\t      pj_bool_t wait)\n{\n    unsigned i;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(count && srv, PJ_EINVAL);\n    \n    PJSUA_LOCK();\n\n    pjsua_var.ua_cfg.stun_srv_cnt = count;\n    for (i = 0; i < count; i++) {\n        if (pj_strcmp(&pjsua_var.ua_cfg.stun_srv[i], &srv[i]))\n            pj_strdup(pjsua_var.pool, &pjsua_var.ua_cfg.stun_srv[i], &srv[i]);\n    }\n    pjsua_var.stun_status = PJ_EUNKNOWN;\n\n    PJSUA_UNLOCK();\n    \n    status = resolve_stun_server(wait, PJ_FALSE, 0);\n    if (wait == PJ_FALSE && status == PJ_EPENDING)\n        status = PJ_SUCCESS;\n\n    return status;\n}\n\n\n/*\n * Resolve STUN server.\n */\nPJ_DEF(pj_status_t) pjsua_resolve_stun_servers( unsigned count,\n\t\t\t\t\t\tpj_str_t srv[],\n\t\t\t\t\t\tpj_bool_t wait,\n\t\t\t\t\t\tvoid *token,\n\t\t\t\t\t\tpj_stun_resolve_cb cb)\n{\n    pj_pool_t *pool;\n    pjsua_stun_resolve *sess;\n    pj_status_t status;\n    unsigned i, max_wait_ms;\n    pj_timestamp start, now;\n\n    PJ_ASSERT_RETURN(count && srv && cb, PJ_EINVAL);\n\n    pool = pjsua_pool_create(\"stunres\", 256, 256);\n    if (!pool)\n\treturn PJ_ENOMEM;\n\n    sess = PJ_POOL_ZALLOC_T(pool, pjsua_stun_resolve);\n    sess->pool = pool;\n    sess->token = token;\n    sess->cb = cb;\n    sess->count = count;\n    sess->blocking = wait;\n    sess->waiter = pj_thread_this();\n    sess->status = PJ_EPENDING;\n    sess->af = pj_AF_INET();\n    stun_resolve_add_ref(sess);\n    sess->srv = (pj_str_t*) pj_pool_calloc(pool, count, sizeof(pj_str_t));\n    for (i=0; i<count; ++i) {\n\tpj_strdup(pool, &sess->srv[i], &srv[i]);\n    }\n\n    PJSUA_LOCK();\n    pj_list_push_back(&pjsua_var.stun_res, sess);\n    PJSUA_UNLOCK();\n\n    resolve_stun_entry(sess);\n\n    if (!wait)\n\treturn PJ_SUCCESS;\n\n    /* Should limit the wait time to avoid deadlock. For example,\n     * if app holds dlg/tsx lock, pjsua worker thread will block on\n     * any dlg/tsx state change.\n     */\n    max_wait_ms = count * pjsua_var.stun_cfg.rto_msec * (1 << 7);\n    pj_get_timestamp(&start);\n    \n    while ((sess->status == PJ_EPENDING) && (!sess->destroy_flag)) {\n        /* If there is no worker thread or\n         * the function is called from the only worker thread,\n         * we have to handle the events here.\n         */\n        if (pjsua_var.thread[0] == NULL ||\n            (pj_thread_this() == pjsua_var.thread[0] &&\n             pjsua_var.ua_cfg.thread_cnt == 1))\n            {\n            pjsua_handle_events(50);\n        } else {\n            pj_thread_sleep(20);\n        }\n\n\tpj_get_timestamp(&now);\n\tif (pj_elapsed_msec(&start, &now) > max_wait_ms)\n\t    sess->status = PJ_ETIMEDOUT;\n    }\n\n    status = sess->status;\n    stun_resolve_dec_ref(sess);\n\n    return status;\n}\n\n/*\n * Cancel pending STUN resolution.\n */\nPJ_DEF(pj_status_t) pjsua_cancel_stun_resolution( void *token,\n\t\t\t\t\t\t  pj_bool_t notify_cb)\n{\n    pjsua_stun_resolve *sess;\n    unsigned cancelled_count = 0;\n\n    PJSUA_LOCK();\n    sess = pjsua_var.stun_res.next;\n    while (sess != &pjsua_var.stun_res) {\n\tpjsua_stun_resolve *next = sess->next;\n\n\tif (sess->token == token) {\n\t    sess->has_result = PJ_TRUE;\n\t    sess->status = PJ_ECANCELLED;\n\t    if (notify_cb) {\n\t\tpj_stun_resolve_result result;\n\n\t\tpj_bzero(&result, sizeof(result));\n\t\tresult.token = token;\n\t\tresult.status = PJ_ECANCELLED;\n\n\t\tsess->cb(&result);\n\t    }\t    \n\t    ++cancelled_count;\n\t}\n\n\tsess = next;\n    }\n    PJSUA_UNLOCK();\n\n    return cancelled_count ? PJ_SUCCESS : PJ_ENOTFOUND;\n}\n\nstatic void internal_stun_resolve_cb(const pj_stun_resolve_result *result)\n{\n    pjsua_var.stun_status = result->status;\n    if ((result->status == PJ_SUCCESS) && (pjsua_var.ua_cfg.stun_srv_cnt>0)) {\n\tpj_memcpy(&pjsua_var.stun_srv, &result->addr, sizeof(result->addr));\n\tpjsua_var.stun_srv_idx = result->index;\n\n\t/* Perform NAT type detection if not yet */\n\tif (pjsua_var.nat_type == PJ_STUN_NAT_TYPE_UNKNOWN &&\n\t    !pjsua_var.nat_in_progress &&\n\t    pjsua_var.ua_cfg.nat_type_in_sdp)\n\t{\n\t    pjsua_detect_nat_type();\n\t}\n    }\n    \n    if (pjsua_var.ua_cfg.cb.on_stun_resolution_complete)\n    \t(*pjsua_var.ua_cfg.cb.on_stun_resolution_complete)(result);\n}\n\n/*\n * Resolve STUN server.\n */\npj_status_t resolve_stun_server(pj_bool_t wait, pj_bool_t retry_if_cur_error,\n\t\t\t\tunsigned options)\n{\n    pjsua_var.stun_opt = options;\n\n    /* Retry resolving if currently the STUN status is error */\n    if (pjsua_var.stun_status != PJ_EPENDING &&\n\tpjsua_var.stun_status != PJ_SUCCESS &&\n\tretry_if_cur_error)\n    {\n\tpjsua_var.stun_status = PJ_EUNKNOWN;\n    }\n\n    if (pjsua_var.stun_status == PJ_EUNKNOWN) {\n\tpj_status_t status;\n\n\t/* Initialize STUN configuration */\n\tpj_stun_config_init(&pjsua_var.stun_cfg, &pjsua_var.cp.factory, 0,\n\t\t\t    pjsip_endpt_get_ioqueue(pjsua_var.endpt),\n\t\t\t    pjsip_endpt_get_timer_heap(pjsua_var.endpt));\n\n\t/* Start STUN server resolution */\n\tif (pjsua_var.ua_cfg.stun_srv_cnt) {\n\t    pjsua_var.stun_status = PJ_EPENDING;\n\t    status = pjsua_resolve_stun_servers(pjsua_var.ua_cfg.stun_srv_cnt,\n\t\t\t\t\t\tpjsua_var.ua_cfg.stun_srv,\n\t\t\t\t\t\twait, NULL,\n\t\t\t\t\t\t&internal_stun_resolve_cb);\n\t    if (wait || status != PJ_SUCCESS) {\n\t\tpjsua_var.stun_status = status;\n\t    }\n\t} else {\n\t    pjsua_var.stun_status = PJ_SUCCESS;\n\t}\n\n    } else if (pjsua_var.stun_status == PJ_EPENDING) {\n\t/* STUN server resolution has been started, wait for the\n\t * result.\n\t */\n\tif (wait) {\n\t    unsigned max_wait_ms;\n\t    pj_timestamp start, now;\n\n\t    /* Should limit the wait time to avoid deadlock. For example,\n\t     * if app holds dlg/tsx lock, pjsua worker thread will block on\n\t     * any dlg/tsx state change.\n\t     */\n\t    max_wait_ms = pjsua_var.ua_cfg.stun_srv_cnt *\n\t\t\t  pjsua_var.stun_cfg.rto_msec * (1 << 7);\n\t    pj_get_timestamp(&start);\n\n\t    while (pjsua_var.stun_status == PJ_EPENDING) {\t\t\n                /* If there is no worker thread or\n                 * the function is called from the only worker thread,\n                 * we have to handle the events here.\n                 */\n\t\tif (pjsua_var.thread[0] == NULL ||\n                    (pj_thread_this() == pjsua_var.thread[0] &&\n                     pjsua_var.ua_cfg.thread_cnt == 1))\n                {\n\t\t    pjsua_handle_events(10);\n                } else {\n\t\t    pj_thread_sleep(10);\n                }\n\n\t\tpj_get_timestamp(&now);\n\t\tif (pj_elapsed_msec(&start, &now) > max_wait_ms)\n\t\t    return PJ_ETIMEDOUT;\n\t    }\n\t}\n    }\n\n    if (pjsua_var.stun_status != PJ_EPENDING &&\n\tpjsua_var.stun_status != PJ_SUCCESS &&\n\tpjsua_var.ua_cfg.stun_ignore_failure)\n    {\n\tPJ_LOG(2,(THIS_FILE, \n\t\t  \"Ignoring STUN resolution failure (by setting)\"));\n\t//pjsua_var.stun_status = PJ_SUCCESS;\n\treturn PJ_SUCCESS;\n    }\n\n    return pjsua_var.stun_status;\n}\n\n/*\n * Destroy pjsua.\n */\nPJ_DEF(pj_status_t) pjsua_destroy2(unsigned flags)\n{\n    int i;  /* Must be signed */\n\n    if (pjsua_var.endpt) {\n\tPJ_LOG(4,(THIS_FILE, \"Shutting down, flags=%d...\", flags));\n    }\n\n    if (pjsua_var.state > PJSUA_STATE_NULL &&\n\tpjsua_var.state < PJSUA_STATE_CLOSING)\n    {\n\tpjsua_set_state(PJSUA_STATE_CLOSING);\n    }\n\n    /* Signal threads to quit: */\n    pjsua_stop_worker_threads();\n    \n    if (pjsua_var.endpt) {\n\tunsigned max_wait;\n\n\tpj_log_push_indent();\n\n\t/* Terminate all calls. */\n\tif ((flags & PJSUA_DESTROY_NO_TX_MSG) == 0) {\n\t    pjsua_call_hangup_all();\n\t}\n\n\t/* Deinit media channel of all calls (see #1717) */\n\tfor (i=0; i<(int)pjsua_var.ua_cfg.max_calls; ++i) {\n\t    /* TODO: check if we're not allowed to send to network in the\n\t     *       \"flags\", and if so do not do TURN allocation...\n\t     */\n\t    pjsua_media_channel_deinit(i);\n\t}\n\n\t/* Set all accounts to offline */\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (!pjsua_var.acc[i].valid)\n\t\tcontinue;\n\t    pjsua_var.acc[i].online_status = PJ_FALSE;\n\t    pj_bzero(&pjsua_var.acc[i].rpid, sizeof(pjrpid_element));\n\t}\n\n\t/* Terminate all presence subscriptions. */\n\tpjsua_pres_shutdown(flags);\n\n\t/* Wait for sometime until all publish client sessions are done\n\t * (ticket #364)\n\t */\n\t/* First stage, get the maximum wait time */\n\tmax_wait = 100;\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (!pjsua_var.acc[i].valid)\n\t\tcontinue;\n\t    if (pjsua_var.acc[i].cfg.unpublish_max_wait_time_msec > max_wait)\n\t\tmax_wait = pjsua_var.acc[i].cfg.unpublish_max_wait_time_msec;\n\t}\n\t\n\t/* No waiting if RX is disabled */\n\tif (flags & PJSUA_DESTROY_NO_RX_MSG) {\n\t    max_wait = 0;\n\t}\n\n\t/* Second stage, wait for unpublications to complete */\n\tfor (i=0; i<(int)(max_wait/50); ++i) {\n\t    unsigned j;\n\t    for (j=0; j<PJ_ARRAY_SIZE(pjsua_var.acc); ++j) {\n\t\tif (!pjsua_var.acc[j].valid)\n\t\t    continue;\n\n\t\tif (pjsua_var.acc[j].publish_sess)\n\t\t    break;\n\t    }\n\t    if (j != PJ_ARRAY_SIZE(pjsua_var.acc))\n\t\tbusy_sleep(50);\n\t    else\n\t\tbreak;\n\t}\n\n\t/* Third stage, forcefully destroy unfinished unpublications */\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (pjsua_var.acc[i].publish_sess) {\n\t\tpjsip_publishc_destroy(pjsua_var.acc[i].publish_sess);\n\t\tpjsua_var.acc[i].publish_sess = NULL;\n\t    }\n\t}\n\n\t/* Unregister all accounts */\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (!pjsua_var.acc[i].valid)\n\t\tcontinue;\n\n\t    if (pjsua_var.acc[i].regc && (flags & PJSUA_DESTROY_NO_TX_MSG)==0)\n\t    {\n\t\tpjsua_acc_set_registration(i, PJ_FALSE);\n\t    }\n#if PJ_HAS_SSL_SOCK\n\t    pj_turn_sock_tls_cfg_wipe_keys(\n\t\t\t      &pjsua_var.acc[i].cfg.turn_cfg.turn_tls_setting);\n#endif\n\t}\n\n\t/* Wait until all unregistrations are done (ticket #364) */\n\t/* First stage, get the maximum wait time */\n\tmax_wait = 100;\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (!pjsua_var.acc[i].valid)\n\t\tcontinue;\n\t    if (pjsua_var.acc[i].cfg.unreg_timeout > max_wait)\n\t\tmax_wait = pjsua_var.acc[i].cfg.unreg_timeout;\n\t}\n\t\n\t/* No waiting if RX is disabled */\n\tif (flags & PJSUA_DESTROY_NO_RX_MSG) {\n\t    max_wait = 0;\n\t}\n\n\t/* Second stage, wait for unregistrations to complete */\n\tfor (i=0; i<(int)(max_wait/50); ++i) {\n\t    unsigned j;\n\t    for (j=0; j<PJ_ARRAY_SIZE(pjsua_var.acc); ++j) {\n\t\tif (!pjsua_var.acc[j].valid)\n\t\t    continue;\n\n\t\tif (pjsua_var.acc[j].regc)\n\t\t    break;\n\t    }\n\t    if (j != PJ_ARRAY_SIZE(pjsua_var.acc))\n\t\tbusy_sleep(50);\n\t    else\n\t\tbreak;\n\t}\n\t/* Note variable 'i' is used below */\n\n\t/* Wait for some time to allow unregistration and ICE/TURN\n\t * transports shutdown to complete: \n\t */\n\tif (i < 20 && (flags & PJSUA_DESTROY_NO_RX_MSG) == 0) {\n\t    busy_sleep(1000 - i*50);\n\t}\n\n\tPJ_LOG(4,(THIS_FILE, \"Destroying...\"));\n\t\n\t/* Terminate any pending STUN resolution */\n\tif (!pj_list_empty(&pjsua_var.stun_res)) {\n\t    pjsua_stun_resolve *sess = pjsua_var.stun_res.next;\n\t    while (sess != &pjsua_var.stun_res) {\n\t\tpjsua_stun_resolve *next = sess->next;\n\t\tdestroy_stun_resolve(sess, PJ_TRUE);\n\t\tsess = next;\n\t    }\n\t}\n\n\t/* Destroy media (to shutdown media endpoint, etc) */\n\tpjsua_media_subsys_destroy(flags);\n\n\t/* Must destroy endpoint first before destroying pools in\n\t * buddies or accounts, since shutting down transaction layer\n\t * may emit events which trigger some buddy or account callbacks\n\t * to be called.\n\t */\n\tpjsip_endpt_destroy(pjsua_var.endpt);\n\tpjsua_var.endpt = NULL;\n\n\t/* Destroy pool in the buddy object */\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.buddy); ++i) {\n\t    if (pjsua_var.buddy[i].pool) {\n\t\tpj_pool_release(pjsua_var.buddy[i].pool);\n\t\tpjsua_var.buddy[i].pool = NULL;\n\t    }\n\t}\n\n\t/* Destroy accounts */\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (pjsua_var.acc[i].pool) {\n\t\tpj_pool_release(pjsua_var.acc[i].pool);\n\t\tpjsua_var.acc[i].pool = NULL;\n\t    }\n\t}\n    }\n\n    /* Destroy mutex */\n    if (pjsua_var.mutex) {\n\tpj_mutex_destroy(pjsua_var.mutex);\n\tpjsua_var.mutex = NULL;\n    }\n    \n    if (pjsua_var.timer_mutex) {\n        pj_mutex_destroy(pjsua_var.timer_mutex);\n        pjsua_var.timer_mutex = NULL;\n    }\n\n    /* Destroy pools and pool factory. */\n    if (pjsua_var.timer_pool) {\n\tpj_pool_release(pjsua_var.timer_pool);\n\tpjsua_var.timer_pool = NULL;\n    }\n    if (pjsua_var.pool) {\n\tpj_pool_release(pjsua_var.pool);\n\tpjsua_var.pool = NULL;\n\tpj_caching_pool_destroy(&pjsua_var.cp);\n\n\tpjsua_set_state(PJSUA_STATE_NULL);\n\n\tPJ_LOG(4,(THIS_FILE, \"PJSUA destroyed...\"));\n\n\t/* End logging */\n\tif (pjsua_var.log_file) {\n\t    pj_file_close(pjsua_var.log_file);\n\t    pjsua_var.log_file = NULL;\n\t}\n\n\tpj_log_pop_indent();\n\n\t/* Shutdown PJLIB */\n\tpj_shutdown();\n    }\n\n    /* Clear pjsua_var */\n    pj_bzero(&pjsua_var, sizeof(pjsua_var));\n\n    /* Done. */\n    return PJ_SUCCESS;\n}\n\nvoid pjsua_set_state(pjsua_state new_state)\n{\n    const char *state_name[] = {\n        \"NULL\",\n        \"CREATED\",\n        \"INIT\",\n        \"STARTING\",\n        \"RUNNING\",\n        \"CLOSING\"\n    };\n    pjsua_state old_state = pjsua_var.state;\n\n    pjsua_var.state = new_state;\n    PJ_LOG(4,(THIS_FILE, \"PJSUA state changed: %s --> %s\",\n\t      state_name[old_state], state_name[new_state]));\n}\n\n/* Get state */\nPJ_DEF(pjsua_state) pjsua_get_state(void)\n{\n    return pjsua_var.state;\n}\n\nPJ_DEF(pj_status_t) pjsua_destroy(void)\n{\n    return pjsua_destroy2(0);\n}\n\n\n/**\n * Application is recommended to call this function after all initialization\n * is done, so that the library can do additional checking set up\n * additional \n *\n * @return\t\tPJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_DEF(pj_status_t) pjsua_start(void)\n{\n    pj_status_t status;\n\n    pjsua_set_state(PJSUA_STATE_STARTING);\n    pj_log_push_indent();\n\n    status = pjsua_call_subsys_start();\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    status = pjsua_media_subsys_start();\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    status = pjsua_pres_start();\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    pjsua_set_state(PJSUA_STATE_RUNNING);\n\non_return:\n    pj_log_pop_indent();\n    return status;\n}\n\n\n/**\n * Poll pjsua for events, and if necessary block the caller thread for\n * the specified maximum interval (in miliseconds).\n */\nPJ_DEF(int) pjsua_handle_events(unsigned msec_timeout)\n{\n#if defined(PJ_SYMBIAN) && PJ_SYMBIAN != 0\n\n    return pj_symbianos_poll(-1, msec_timeout);\n\n#else\n\n    unsigned count = 0;\n    pj_time_val tv;\n    pj_status_t status;\n\n    tv.sec = 0;\n    tv.msec = msec_timeout;\n    pj_time_val_normalize(&tv);\n\n    status = pjsip_endpt_handle_events2(pjsua_var.endpt, &tv, &count);\n\n    if (status != PJ_SUCCESS)\n\treturn -status;\n\n    return count;\n    \n#endif\n}\n\n\n/*\n * Create memory pool.\n */\nPJ_DEF(pj_pool_t*) pjsua_pool_create( const char *name, pj_size_t init_size,\n\t\t\t\t      pj_size_t increment)\n{\n    /* Pool factory is thread safe, no need to lock */\n    return pj_pool_create(&pjsua_var.cp.factory, name, init_size, increment, \n\t\t\t  NULL);\n}\n\n\n/*\n * Internal function to get SIP endpoint instance of pjsua, which is\n * needed for example to register module, create transports, etc.\n * Probably is only valid after #pjsua_init() is called.\n */\nPJ_DEF(pjsip_endpoint*) pjsua_get_pjsip_endpt(void)\n{\n    return pjsua_var.endpt;\n}\n\n/*\n * Internal function to get media endpoint instance.\n * Only valid after #pjsua_init() is called.\n */\nPJ_DEF(pjmedia_endpt*) pjsua_get_pjmedia_endpt(void)\n{\n    return pjsua_var.med_endpt;\n}\n\n/*\n * Internal function to get PJSUA pool factory.\n */\nPJ_DEF(pj_pool_factory*) pjsua_get_pool_factory(void)\n{\n    return &pjsua_var.cp.factory;\n}\n\n/*****************************************************************************\n * PJSUA SIP Transport API.\n */\n\n/*\n * Tools to get address string.\n */\nstatic const char *addr_string(const pj_sockaddr_t *addr)\n{\n    static char str[128];\n    str[0] = '\\0';\n    pj_inet_ntop(((const pj_sockaddr*)addr)->addr.sa_family, \n\t\t pj_sockaddr_get_addr(addr),\n\t\t str, sizeof(str));\n    return str;\n}\n\nvoid pjsua_acc_on_tp_state_changed(pjsip_transport *tp,\n\t\t\t\t   pjsip_transport_state state,\n\t\t\t\t   const pjsip_transport_state_info *info);\n\n/* Callback to receive transport state notifications */\nstatic void on_tp_state_callback(pjsip_transport *tp,\n\t\t\t\t pjsip_transport_state state,\n\t\t\t\t const pjsip_transport_state_info *info)\n{\n    if (pjsua_var.ua_cfg.cb.on_transport_state) {\n\t(*pjsua_var.ua_cfg.cb.on_transport_state)(tp, state, info);\n    }\n    if (pjsua_var.old_tp_cb) {\n\t(*pjsua_var.old_tp_cb)(tp, state, info);\n    }\n    pjsua_acc_on_tp_state_changed(tp, state, info);\n}\n\n/* Set transport state callback */\nstatic void set_tp_state_cb()\n{\n    pjsip_tp_state_callback tpcb;\n    pjsip_tpmgr *tpmgr;\n\n    tpmgr = pjsip_endpt_get_tpmgr(pjsua_var.endpt);\n    tpcb = pjsip_tpmgr_get_state_cb(tpmgr);\n\n    if (tpcb != &on_tp_state_callback) {\n\tpjsua_var.old_tp_cb = tpcb;\n\tpjsip_tpmgr_set_state_cb(tpmgr, &on_tp_state_callback);\n    }\n}\n\n/*\n * Create and initialize SIP socket (and possibly resolve public\n * address via STUN, depending on config).\n */\nstatic pj_status_t create_sip_udp_sock(int af,\n\t\t\t\t       const pjsua_transport_config *cfg,\n\t\t\t\t       pj_sock_t *p_sock,\n\t\t\t\t       pj_sockaddr *p_pub_addr)\n{\n    char stun_ip_addr[PJ_INET6_ADDRSTRLEN];\n    unsigned port = cfg->port;\n    pj_str_t stun_srv;\n    pj_sock_t sock;\n    pj_sockaddr bind_addr;\n    pj_status_t status;\n\n    /* Make sure STUN server resolution has completed */\n    status = resolve_stun_server(PJ_TRUE, PJ_TRUE, 0);\n    if (status != PJ_SUCCESS) {\n\tpjsua_perror(THIS_FILE, \"Error resolving STUN server\", status);\n\treturn status;\n    }\n\n    /* Initialize bound address */\n    if (cfg->bound_addr.slen) {\n\tstatus = pj_sockaddr_init(af, &bind_addr, &cfg->bound_addr, \n\t\t\t\t  (pj_uint16_t)port);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \n\t\t\t \"Unable to resolve transport bound address\", \n\t\t\t status);\n\t    return status;\n\t}\n    } else {\n\tpj_sockaddr_init(af, &bind_addr, NULL, (pj_uint16_t)port);\n    }\n\n    /* Create socket */\n    status = pj_sock_socket(af, pj_SOCK_DGRAM(), 0, &sock);\n    if (status != PJ_SUCCESS) {\n\tpjsua_perror(THIS_FILE, \"socket() error\", status);\n\treturn status;\n    }\n\n    /* Apply QoS, if specified */\n    status = pj_sock_apply_qos2(sock, cfg->qos_type, \n\t\t\t\t&cfg->qos_params, \n\t\t\t\t2, THIS_FILE, \"SIP UDP socket\");\n\n    /* Apply sockopt, if specified */\n    if (cfg->sockopt_params.cnt)\n\tstatus = pj_sock_setsockopt_params(sock, &cfg->sockopt_params);\n\n    /* Bind socket */\n    status = pj_sock_bind(sock, &bind_addr, pj_sockaddr_get_len(&bind_addr));\n    if (status != PJ_SUCCESS) {\n\tpjsua_perror(THIS_FILE, \"bind() error\", status);\n\tpj_sock_close(sock);\n\treturn status;\n    }\n\n    /* If port is zero, get the bound port */\n    if (port == 0) {\n\tpj_sockaddr bound_addr;\n\tint namelen = sizeof(bound_addr);\n\tstatus = pj_sock_getsockname(sock, &bound_addr, &namelen);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"getsockname() error\", status);\n\t    pj_sock_close(sock);\n\t    return status;\n\t}\n\n\tport = pj_sockaddr_get_port(&bound_addr);\n    }\n\n    if (pjsua_var.stun_srv.addr.sa_family != 0) {\n    \tpj_sockaddr_print(&pjsua_var.stun_srv,\n    \t\t     \t  stun_ip_addr, sizeof(stun_ip_addr), 0);\n\tstun_srv = pj_str(stun_ip_addr);\n    } else {\n\tstun_srv.slen = 0;\n    }\n\n    /* Get the published address, either by STUN or by resolving\n     * the name of local host.\n     */\n    if (pj_sockaddr_has_addr(p_pub_addr)) {\n\t/*\n\t * Public address is already specified, no need to resolve the \n\t * address, only set the port.\n\t */\n\tif (pj_sockaddr_get_port(p_pub_addr) == 0)\n\t    pj_sockaddr_set_port(p_pub_addr, (pj_uint16_t)port);\n\n    } else if (stun_srv.slen &&\n               (af == pj_AF_INET() || pjsua_var.ua_cfg.stun_try_ipv6))\n    {\n\tpjstun_setting stun_opt;\n\n\t/*\n\t * STUN is specified, resolve the address with STUN.\n\t * Currently, this is only to get IPv4 mapped address\n\t * (does IPv6 still need a mapped address?).\n\t */\n\tpj_bzero(&stun_opt, sizeof(stun_opt));\n\tstun_opt.use_stun2 = pjsua_var.ua_cfg.stun_map_use_stun2;\n\tstun_opt.af = pjsua_var.stun_srv.addr.sa_family;\n\tstun_opt.srv1  = stun_opt.srv2  = stun_srv;\n\tstun_opt.port1 = stun_opt.port2 = \n\t\t\t pj_sockaddr_get_port(&pjsua_var.stun_srv);\n\tstatus = pjstun_get_mapped_addr2(&pjsua_var.cp.factory, &stun_opt,\n\t\t\t\t\t 1, &sock, &p_pub_addr->ipv4);\n\tif (status != PJ_SUCCESS) {\n\t    /* Failed getting mapped address via STUN */\n\t    pjsua_perror(THIS_FILE, \"Error contacting STUN server\", status);\n\t    \n\t    /* Return error if configured to not ignore STUN failure */\n\t    if (!pjsua_var.ua_cfg.stun_ignore_failure) {\n\t\tpj_sock_close(sock);\n\t\treturn status;\n\t    }\n\n\t    /* Otherwise, just use host IP */\n\t    pj_sockaddr_init(af, p_pub_addr, NULL, (pj_uint16_t)port);\n\t    status = pj_gethostip(af, p_pub_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \"Unable to get local host IP\", status);\n\t\tpj_sock_close(sock);\n\t\treturn status;\n\t    }\n\t}\n\n    } else {\n\n\tpj_bzero(p_pub_addr, sizeof(pj_sockaddr));\n\n\tif (pj_sockaddr_has_addr(&bind_addr)) {\n\t    pj_sockaddr_copy_addr(p_pub_addr, &bind_addr);\n\t} else {\n\t    status = pj_gethostip(af, p_pub_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \"Unable to get local host IP\", status);\n\t\tpj_sock_close(sock);\n\t\treturn status;\n\t    }\n\t}\n\n\tp_pub_addr->addr.sa_family = (pj_uint16_t)af;\n\tpj_sockaddr_set_port(p_pub_addr, (pj_uint16_t)port);\n\n\tif (stun_srv.slen && af != pj_AF_INET()) {\n\t    /* STUN is specified, but it is not IPv4, just print warning */\n\t    PJ_PERROR(2, (THIS_FILE, PJ_EAFNOTSUP,\n\t\t          \"Cannot use STUN for SIP UDP socket %s:%d\",\n\t\t          addr_string(p_pub_addr),\n\t\t          (int)pj_sockaddr_get_port(p_pub_addr)));\n\t}\n\n    }\n\n    *p_sock = sock;\n\n    PJ_LOG(4,(THIS_FILE, \"SIP UDP socket reachable at %s:%d\",\n\t      addr_string(p_pub_addr),\n\t      (int)pj_sockaddr_get_port(p_pub_addr)));\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create SIP transport.\n */\nPJ_DEF(pj_status_t) pjsua_transport_create( pjsip_transport_type_e type,\n\t\t\t\t\t    const pjsua_transport_config *cfg,\n\t\t\t\t\t    pjsua_transport_id *p_id)\n{\n    pjsip_transport *tp;\n    unsigned id;\n    pj_status_t status;\n\n    PJSUA_LOCK();\n\n    /* Find empty transport slot */\n    for (id=0; id < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++id) {\n\tif (pjsua_var.tpdata[id].data.ptr == NULL)\n\t    break;\n    }\n\n    if (id == PJ_ARRAY_SIZE(pjsua_var.tpdata)) {\n\tstatus = PJ_ETOOMANY;\n\tpjsua_perror(THIS_FILE, \"Error creating transport\", status);\n\tgoto on_return;\n    }\n\n    /* Create the transport */\n    if (type==PJSIP_TRANSPORT_UDP || type==PJSIP_TRANSPORT_UDP6) {\n\t/*\n\t * Create UDP transport (IPv4 or IPv6).\n\t */\n\tpjsua_transport_config config;\n\tchar hostbuf[PJ_INET6_ADDRSTRLEN];\n\tpj_sock_t sock = PJ_INVALID_SOCKET;\n\tpj_sockaddr pub_addr;\n\tpjsip_host_port addr_name;\n\n\t/* Supply default config if it's not specified */\n\tif (cfg == NULL) {\n\t    pjsua_transport_config_default(&config);\n\t    cfg = &config;\n\t}\n\n\t/* Initialize the public address from the config, if any */\n\tpj_sockaddr_init(pjsip_transport_type_get_af(type), &pub_addr, \n\t\t\t NULL, (pj_uint16_t)cfg->port);\n\tif (cfg->public_addr.slen) {\n\t    status = pj_sockaddr_set_str_addr(pjsip_transport_type_get_af(type),\n\t\t\t\t\t      &pub_addr, &cfg->public_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \n\t\t\t     \"Unable to resolve transport public address\", \n\t\t\t     status);\n\t\tgoto on_return;\n\t    }\n\t}\n\n\t/* Create the socket and possibly resolve the address with STUN \n\t * (only when public address is not specified).\n\t */\n\tstatus = create_sip_udp_sock(pjsip_transport_type_get_af(type),\n\t\t\t\t     cfg, &sock, &pub_addr);\n\tif (status != PJ_SUCCESS)\n\t    goto on_return;\n\n\tpj_ansi_strcpy(hostbuf, addr_string(&pub_addr));\n\taddr_name.host = pj_str(hostbuf);\n\taddr_name.port = pj_sockaddr_get_port(&pub_addr);\n\n\t/* Create UDP transport */\n\tstatus = pjsip_udp_transport_attach2(pjsua_var.endpt, type, sock,\n\t\t\t\t\t     &addr_name, 1, &tp);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error creating SIP UDP transport\", \n\t\t\t status);\n\t    pj_sock_close(sock);\n\t    goto on_return;\n\t}\n\n\n\t/* Save the transport */\n\tpjsua_var.tpdata[id].type = type;\n\tpjsua_var.tpdata[id].local_name = tp->local_name;\n\tpjsua_var.tpdata[id].data.tp = tp;\n\tif (cfg->bound_addr.slen)\n\t    pjsua_var.tpdata[id].has_bound_addr = PJ_TRUE;\n\n#if defined(PJ_HAS_TCP) && PJ_HAS_TCP!=0\n\n    } else if (type == PJSIP_TRANSPORT_TCP || type == PJSIP_TRANSPORT_TCP6) {\n\t/*\n\t * Create TCP transport.\n\t */\n\tpjsua_transport_config config;\n\tpjsip_tpfactory *tcp;\n\tpjsip_tcp_transport_cfg tcp_cfg;\n\tint af;\n\n\taf = (type==PJSIP_TRANSPORT_TCP6) ? pj_AF_INET6() : pj_AF_INET();\n\tpjsip_tcp_transport_cfg_default(&tcp_cfg, af);\n\n\t/* Supply default config if it's not specified */\n\tif (cfg == NULL) {\n\t    pjsua_transport_config_default(&config);\n\t    cfg = &config;\n\t}\n\n\t/* Configure bind address */\n\tif (cfg->port)\n\t    pj_sockaddr_set_port(&tcp_cfg.bind_addr, (pj_uint16_t)cfg->port);\n\n\tif (cfg->bound_addr.slen) {\n\t    status = pj_sockaddr_set_str_addr(tcp_cfg.af, \n\t\t\t\t\t      &tcp_cfg.bind_addr,\n\t\t\t\t\t      &cfg->bound_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \n\t\t\t     \"Unable to resolve transport bound address\", \n\t\t\t     status);\n\t\tgoto on_return;\n\t    }\n\t}\n\n\t/* Set published name */\n\tif (cfg->public_addr.slen)\n\t    tcp_cfg.addr_name.host = cfg->public_addr;\n\n\t/* Copy the QoS settings */\n\ttcp_cfg.qos_type = cfg->qos_type;\n\tpj_memcpy(&tcp_cfg.qos_params, &cfg->qos_params, \n\t\t  sizeof(cfg->qos_params));\n\n\t/* Copy the sockopt */\n\tpj_memcpy(&tcp_cfg.sockopt_params, &cfg->sockopt_params,\n\t\t  sizeof(tcp_cfg.sockopt_params));\n\n\t/* Create the TCP transport */\n\tstatus = pjsip_tcp_transport_start3(pjsua_var.endpt, &tcp_cfg, &tcp);\n\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error creating SIP TCP listener\", \n\t\t\t status);\n\t    goto on_return;\n\t}\n\n\t/* Save the transport */\n\tpjsua_var.tpdata[id].type = type;\n\tpjsua_var.tpdata[id].local_name = tcp->addr_name;\n\tpjsua_var.tpdata[id].data.factory = tcp;\n\n#endif\t/* PJ_HAS_TCP */\n\n#if defined(PJSIP_HAS_TLS_TRANSPORT) && PJSIP_HAS_TLS_TRANSPORT!=0\n    } else if (type == PJSIP_TRANSPORT_TLS || type == PJSIP_TRANSPORT_TLS6) {\n\t/*\n\t * Create TLS transport.\n\t */\n\tpjsua_transport_config config;\n\tpjsip_host_port a_name;\n\tpjsip_tpfactory *tls;\n\tpj_sockaddr local_addr;\n\tint af;\n\n\t/* Supply default config if it's not specified */\n\tif (cfg == NULL) {\n\t    pjsua_transport_config_default(&config);\n\t    config.port = 5061;\n\t    cfg = &config;\n\t}\n\n\t/* Init local address */\n\taf = (type==PJSIP_TRANSPORT_TLS) ? pj_AF_INET() : pj_AF_INET6();\n\tpj_sockaddr_init(af, &local_addr, NULL, 0);\n\n\tif (cfg->port)\n\t    pj_sockaddr_set_port(&local_addr, (pj_uint16_t)cfg->port);\n\n\tif (cfg->bound_addr.slen) {\n\t    status = pj_sockaddr_set_str_addr(af, &local_addr,\n\t                                      &cfg->bound_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \n\t\t\t     \"Unable to resolve transport bound address\", \n\t\t\t     status);\n\t\tgoto on_return;\n\t    }\n\t}\n\n\t/* Init published name */\n\tpj_bzero(&a_name, sizeof(pjsip_host_port));\n\tif (cfg->public_addr.slen)\n\t    a_name.host = cfg->public_addr;\n\n\tstatus = pjsip_tls_transport_start2(pjsua_var.endpt, &cfg->tls_setting,\n\t\t\t\t\t    &local_addr, &a_name, 1, &tls);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error creating SIP TLS listener\", \n\t\t\t status);\n\t    goto on_return;\n\t}\n\n\t/* Save the transport */\n\tpjsua_var.tpdata[id].type = type;\n\tpjsua_var.tpdata[id].local_name = tls->addr_name;\n\tpjsua_var.tpdata[id].data.factory = tls;\n#endif\n\n    } else {\n\tstatus = PJSIP_EUNSUPTRANSPORT;\n\tpjsua_perror(THIS_FILE, \"Error creating transport\", status);\n\tgoto on_return;\n    }\n\n    /* Set transport state callback */\n    set_tp_state_cb();\n\n    /* Return the ID */\n    if (p_id) *p_id = id;\n\n    status = PJ_SUCCESS;\n\non_return:\n\n    PJSUA_UNLOCK();\n\n    return status;\n}\n\n\n/*\n * Register transport that has been created by application.\n */\nPJ_DEF(pj_status_t) pjsua_transport_register( pjsip_transport *tp,\n\t\t\t\t\t      pjsua_transport_id *p_id)\n{\n    unsigned id;\n\n    PJSUA_LOCK();\n\n    /* Find empty transport slot */\n    for (id=0; id < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++id) {\n\tif (pjsua_var.tpdata[id].data.ptr == NULL)\n\t    break;\n    }\n\n    if (id == PJ_ARRAY_SIZE(pjsua_var.tpdata)) {\n\tpjsua_perror(THIS_FILE, \"Error creating transport\", PJ_ETOOMANY);\n\tPJSUA_UNLOCK();\n\treturn PJ_ETOOMANY;\n    }\n\n    /* Save the transport */\n    pjsua_var.tpdata[id].type = (pjsip_transport_type_e) tp->key.type;\n    pjsua_var.tpdata[id].local_name = tp->local_name;\n    pjsua_var.tpdata[id].data.tp = tp;\n\n    /* Set transport state callback */\n    set_tp_state_cb();\n\n    /* Return the ID */\n    if (p_id) *p_id = id;\n\n    PJSUA_UNLOCK();\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Register transport factory that has been created by application.\n */\nPJ_DEF(pj_status_t) pjsua_tpfactory_register( pjsip_tpfactory *tf,\n\t\t\t\t\t      pjsua_transport_id *p_id)\n{\n    unsigned id;\n\n    PJSUA_LOCK();\n\n    /* Find empty transport slot */\n    for (id=0; id < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++id) {\n\tif (pjsua_var.tpdata[id].data.ptr == NULL)\n\t    break;\n    }\n\n    if (id == PJ_ARRAY_SIZE(pjsua_var.tpdata)) {\n\tpjsua_perror(THIS_FILE, \"Error creating transport\", PJ_ETOOMANY);\n\tPJSUA_UNLOCK();\n\treturn PJ_ETOOMANY;\n    }\n\n    /* Save the transport */\n    pjsua_var.tpdata[id].type = (pjsip_transport_type_e) tf->type;\n    pjsua_var.tpdata[id].local_name = tf->addr_name;\n    pjsua_var.tpdata[id].data.factory = tf;\n\n    /* Set transport state callback */\n    set_tp_state_cb();\n\n    /* Return the ID */\n    if (p_id) *p_id = id;\n\n    PJSUA_UNLOCK();\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Enumerate all transports currently created in the system.\n */\nPJ_DEF(pj_status_t) pjsua_enum_transports( pjsua_transport_id id[],\n\t\t\t\t\t   unsigned *p_count )\n{\n    unsigned i, count;\n\n    PJSUA_LOCK();\n\n    for (i=0, count=0; i<PJ_ARRAY_SIZE(pjsua_var.tpdata) && count<*p_count; \n\t ++i) \n    {\n\tif (!pjsua_var.tpdata[i].data.ptr)\n\t    continue;\n\n\tid[count++] = i;\n    }\n\n    *p_count = count;\n\n    PJSUA_UNLOCK();\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get information about transports.\n */\nPJ_DEF(pj_status_t) pjsua_transport_get_info( pjsua_transport_id id,\n\t\t\t\t\t      pjsua_transport_info *info)\n{\n    pjsua_transport_data *t = &pjsua_var.tpdata[id];\n    pj_status_t status;\n\n    pj_bzero(info, sizeof(*info));\n\n    /* Make sure id is in range. */\n    PJ_ASSERT_RETURN(id>=0 && id<(int)PJ_ARRAY_SIZE(pjsua_var.tpdata), \n\t\t     PJ_EINVAL);\n\n    /* Make sure that transport exists */\n    PJ_ASSERT_RETURN(pjsua_var.tpdata[id].data.ptr != NULL, PJ_EINVAL);\n\n    PJSUA_LOCK();\n\n    if ((t->type & ~PJSIP_TRANSPORT_IPV6) == PJSIP_TRANSPORT_UDP) {\n\n\tpjsip_transport *tp = t->data.tp;\n\n\tif (tp == NULL) {\n\t    PJSUA_UNLOCK();\n\t    return PJ_EINVALIDOP;\n\t}\n    \n\tinfo->id = id;\n\tinfo->type = (pjsip_transport_type_e) tp->key.type;\n\tinfo->type_name = pj_str(tp->type_name);\n\tinfo->info = pj_str(tp->info);\n\tinfo->flag = tp->flag;\n\tinfo->addr_len = tp->addr_len;\n\tinfo->local_addr = tp->local_addr;\n\tinfo->local_name = tp->local_name;\n\tinfo->usage_count = pj_atomic_get(tp->ref_cnt);\n\n\tstatus = PJ_SUCCESS;\n\n    } else if ((t->type & ~PJSIP_TRANSPORT_IPV6) == PJSIP_TRANSPORT_TCP ||\n\t       (t->type & ~PJSIP_TRANSPORT_IPV6) == PJSIP_TRANSPORT_TLS)\n    {\n\n\tpjsip_tpfactory *factory = t->data.factory;\n\n\tif (factory == NULL) {\n\t    PJSUA_UNLOCK();\n\t    return PJ_EINVALIDOP;\n\t}\n    \n\tinfo->id = id;\n\tinfo->type = t->type;\n\tinfo->type_name = pj_str(factory->type_name);\n\tinfo->info = pj_str(factory->info);\n\tinfo->flag = factory->flag;\n\tinfo->addr_len = sizeof(factory->local_addr);\n\tinfo->local_addr = factory->local_addr;\n\tinfo->local_name = factory->addr_name;\n\tinfo->usage_count = 0;\n\n\tstatus = PJ_SUCCESS;\n\n    } else {\n\tpj_assert(!\"Unsupported transport\");\n\tstatus = PJ_EINVALIDOP;\n    }\n\n\n    PJSUA_UNLOCK();\n\n    return status;\n}\n\n\n/*\n * Disable a transport or re-enable it.\n */\nPJ_DEF(pj_status_t) pjsua_transport_set_enable( pjsua_transport_id id,\n\t\t\t\t\t\tpj_bool_t enabled)\n{\n    /* Make sure id is in range. */\n    PJ_ASSERT_RETURN(id>=0 && id<(int)PJ_ARRAY_SIZE(pjsua_var.tpdata), \n\t\t     PJ_EINVAL);\n\n    /* Make sure that transport exists */\n    PJ_ASSERT_RETURN(pjsua_var.tpdata[id].data.ptr != NULL, PJ_EINVAL);\n\n\n    /* To be done!! */\n    PJ_TODO(pjsua_transport_set_enable);\n    PJ_UNUSED_ARG(enabled);\n\n    return PJ_EINVALIDOP;\n}\n\n\n/*\n * Close the transport.\n */\nPJ_DEF(pj_status_t) pjsua_transport_close( pjsua_transport_id id,\n\t\t\t\t\t   pj_bool_t force )\n{\n    pj_status_t status;\n    pjsip_transport_type_e tp_type;\n\n    /* Make sure id is in range. */\n    PJ_ASSERT_RETURN(id>=0 && id<(int)PJ_ARRAY_SIZE(pjsua_var.tpdata), \n\t\t     PJ_EINVAL);\n\n    /* Make sure that transport exists */\n    PJ_ASSERT_RETURN(pjsua_var.tpdata[id].data.ptr != NULL, PJ_EINVAL);\n\n    tp_type = pjsua_var.tpdata[id].type & ~PJSIP_TRANSPORT_IPV6;\n\n    if (force) {\n    \t/* Forcefully closing transport is deprecated, since any pending\n    \t * transactions that are using the transport may not terminate\n    \t * properly and can even crash.\n    \t */\n\tPJ_LOG(1, (THIS_FILE, \"pjsua_transport_close(force=PJ_TRUE) is \"\n\t\t\t      \"deprecated.\"));\n    \t\n    \t/* To minimize the effect to users, we shouldn't hard-deprecate this\n    \t * and let it continue as if force is false.\n    \t */\n    \t// return PJ_EINVAL;\n    }\n\n    /* If force is not specified, transports will be closed at their\n     * convenient time.\n     */\n    switch (tp_type) {\n\tcase PJSIP_TRANSPORT_UDP:\n\t    status = pjsip_transport_shutdown(pjsua_var.tpdata[id].data.tp);\n\t    break;\n\tcase PJSIP_TRANSPORT_TLS:\n\tcase PJSIP_TRANSPORT_TCP:\n\t    /* This will close the TCP listener, but existing TCP/TLS\n\t     * connections (if any) will still linger \n\t     */\n\t    status = (*pjsua_var.tpdata[id].data.factory->destroy)\n\t\t\t(pjsua_var.tpdata[id].data.factory);\n\t    break;\n\tdefault:\n\t    return PJ_EINVAL;\n    }\n\n    /* Cleanup pjsua data. We don't need to keep the transport\n     * descriptor, the transport will be destroyed later by the last user\n     * which decrements the transport's reference.\n     */\n    if (status == PJ_SUCCESS) {\n    \tpjsua_var.tpdata[id].type = PJSIP_TRANSPORT_UNSPECIFIED;\n    \tpjsua_var.tpdata[id].data.ptr = NULL;\n    }\n\n    return status;\n}\n\n\nPJ_DEF(pj_status_t) pjsua_transport_lis_start(pjsua_transport_id id,\n\t\t\t\t\t     const pjsua_transport_config *cfg)\n{\n    pj_status_t status = PJ_SUCCESS;\n    pjsip_transport_type_e tp_type;\n\n    /* Make sure id is in range. */\n    PJ_ASSERT_RETURN(id>=0 && id<(int)PJ_ARRAY_SIZE(pjsua_var.tpdata), \n\t\t     PJ_EINVAL);\n\n    /* Make sure that transport exists */\n    PJ_ASSERT_RETURN(pjsua_var.tpdata[id].data.ptr != NULL, PJ_EINVAL);\n\n    tp_type = pjsua_var.tpdata[id].type & ~PJSIP_TRANSPORT_IPV6;\n \n    if ((tp_type == PJSIP_TRANSPORT_TLS) || (tp_type == PJSIP_TRANSPORT_TCP)) {\n\tpj_sockaddr bind_addr;\n\tpjsip_host_port addr_name;\n\tpjsip_tpfactory *factory = pjsua_var.tpdata[id].data.factory;\n\t\n        int af = pjsip_transport_type_get_af(factory->type);\n\n\tif (cfg->port)\n\t    pj_sockaddr_set_port(&bind_addr, (pj_uint16_t)cfg->port);\n\n\tif (cfg->bound_addr.slen) {\n\t    status = pj_sockaddr_set_str_addr(af, \n\t\t\t\t\t      &bind_addr,\n\t\t\t\t\t      &cfg->bound_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \n\t\t\t     \"Unable to resolve transport bound address\", \n\t\t\t     status);\n\t\treturn status;\n\t    }\n\t}\n\n\t/* Set published name */\n\tif (cfg->public_addr.slen)\n\t    addr_name.host = cfg->public_addr;\n\n\tif (tp_type == PJSIP_TRANSPORT_TCP) {\n\t    status = pjsip_tcp_transport_lis_start(factory, &bind_addr,\n\t\t\t\t\t\t   &addr_name);\n\t}\n#if defined(PJSIP_HAS_TLS_TRANSPORT) && PJSIP_HAS_TLS_TRANSPORT!=0\n\telse {\n\t    status = pjsip_tls_transport_lis_start(factory, &bind_addr,\n\t\t\t\t\t\t   &addr_name);\t\n\t}\n#endif\t\n    } else if (tp_type == PJSIP_TRANSPORT_UDP) {\n\tstatus = PJ_SUCCESS;\n    } else {\n\tstatus = PJ_EINVAL;\n    }\n    return status;\n}\n\n\n/*\n * Add additional headers etc in msg_data specified by application\n * when sending requests.\n */\nvoid pjsua_process_msg_data(pjsip_tx_data *tdata,\n\t\t\t    const pjsua_msg_data *msg_data)\n{\n    pj_bool_t allow_body;\n    const pjsip_hdr *hdr;\n\n    /* Always add User-Agent */\n    if (pjsua_var.ua_cfg.user_agent.slen && \n\ttdata->msg->type == PJSIP_REQUEST_MSG) \n    {\n\tconst pj_str_t STR_USER_AGENT = { \"User-Agent\", 10 };\n\tpjsip_hdr *h;\n\th = (pjsip_hdr*)pjsip_generic_string_hdr_create(tdata->pool, \n\t\t\t\t\t\t\t&STR_USER_AGENT, \n\t\t\t\t\t\t\t&pjsua_var.ua_cfg.user_agent);\n\tpjsip_msg_add_hdr(tdata->msg, h);\n    }\n\n    if (!msg_data)\n\treturn;\n\n    hdr = msg_data->hdr_list.next;\n    while (hdr && hdr != &msg_data->hdr_list) {\n\tpjsip_hdr *new_hdr;\n\n\tnew_hdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, hdr);\n\tpjsip_msg_add_hdr(tdata->msg, new_hdr);\n\n\thdr = hdr->next;\n    }\n\n    allow_body = (tdata->msg->body == NULL);\n\n    if (allow_body && msg_data->content_type.slen && msg_data->msg_body.slen) {\n\tpjsip_media_type ctype;\n\tpjsip_msg_body *body;\t\n\n\tpjsua_parse_media_type(tdata->pool, &msg_data->content_type, &ctype);\n\tbody = pjsip_msg_body_create(tdata->pool, &ctype.type, &ctype.subtype,\n\t\t\t\t     &msg_data->msg_body);\n\ttdata->msg->body = body;\n    }\n\n    /* Multipart */\n    if (!pj_list_empty(&msg_data->multipart_parts) &&\n\tmsg_data->multipart_ctype.type.slen)\n    {\n\tpjsip_msg_body *bodies;\n\tpjsip_multipart_part *part;\n\tpj_str_t *boundary = NULL;\n\n\tbodies = pjsip_multipart_create(tdata->pool,\n\t\t\t\t        &msg_data->multipart_ctype,\n\t\t\t\t        boundary);\n\tpart = msg_data->multipart_parts.next;\n\twhile (part != &msg_data->multipart_parts) {\n\t    pjsip_multipart_part *part_copy;\n\n\t    part_copy = pjsip_multipart_clone_part(tdata->pool, part);\n\t    pjsip_multipart_add_part(tdata->pool, bodies, part_copy);\n\t    part = part->next;\n\t}\n\n\tif (tdata->msg->body) {\n\t    part = pjsip_multipart_create_part(tdata->pool);\n\t    part->body = tdata->msg->body;\n\t    pjsip_multipart_add_part(tdata->pool, bodies, part);\n\n\t    tdata->msg->body = NULL;\n\t}\n\n\ttdata->msg->body = bodies;\n    }\n}\n\n\n/*\n * Add route_set to outgoing requests\n */\nvoid pjsua_set_msg_route_set( pjsip_tx_data *tdata,\n\t\t\t      const pjsip_route_hdr *route_set )\n{\n    const pjsip_route_hdr *r;\n\n    r = route_set->next;\n    while (r != route_set) {\n\tpjsip_route_hdr *new_r;\n\n\tnew_r = (pjsip_route_hdr*) pjsip_hdr_clone(tdata->pool, r);\n\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)new_r);\n\n\tr = r->next;\n    }\n}\n\n\n/*\n * Simple version of MIME type parsing (it doesn't support parameters)\n */\nvoid pjsua_parse_media_type( pj_pool_t *pool,\n\t\t\t     const pj_str_t *mime,\n\t\t\t     pjsip_media_type *media_type)\n{\n    pj_str_t tmp;\n    char *pos;\n\n    pj_bzero(media_type, sizeof(*media_type));\n\n    pj_strdup_with_null(pool, &tmp, mime);\n\n    pos = pj_strchr(&tmp, '/');\n    if (pos) {\n\tmedia_type->type.ptr = tmp.ptr; \n\tmedia_type->type.slen = (pos-tmp.ptr);\n\tmedia_type->subtype.ptr = pos+1; \n\tmedia_type->subtype.slen = tmp.ptr+tmp.slen-pos-1;\n    } else {\n\tmedia_type->type = tmp;\n    }\n}\n\n\n/*\n * Internal function to init transport selector from transport id.\n */\nvoid pjsua_init_tpselector(pjsua_transport_id tp_id,\n\t\t\t   pjsip_tpselector *sel)\n{\n    pjsua_transport_data *tpdata;\n    unsigned flag;\n\n    pj_bzero(sel, sizeof(*sel));\n    if (tp_id == PJSUA_INVALID_ID)\n\treturn;\n\n    pj_assert(tp_id >= 0 && tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata));\n    tpdata = &pjsua_var.tpdata[tp_id];\n\n    flag = pjsip_transport_get_flag_from_type(tpdata->type);\n\n    if (flag & PJSIP_TRANSPORT_DATAGRAM) {\n\tsel->type = PJSIP_TPSELECTOR_TRANSPORT;\n\tsel->u.transport = tpdata->data.tp;\n    } else {\n\tsel->type = PJSIP_TPSELECTOR_LISTENER;\n\tsel->u.listener = tpdata->data.factory;\n    }\n}\n\n\nPJ_DEF(void) pjsua_ip_change_param_default(pjsua_ip_change_param *param)\n{\n    pj_bzero(param, sizeof(*param));\n    param->restart_listener = PJ_TRUE;\n    param->restart_lis_delay = PJSUA_TRANSPORT_RESTART_DELAY_TIME;\n}\n\n\n/* Callback upon NAT detection completion */\nstatic void nat_detect_cb(void *user_data, \n\t\t\t  const pj_stun_nat_detect_result *res)\n{\n    PJ_UNUSED_ARG(user_data);\n\n    pjsua_var.nat_in_progress = PJ_FALSE;\n    pjsua_var.nat_status = res->status;\n    pjsua_var.nat_type = res->nat_type;\n\n    if (pjsua_var.ua_cfg.cb.on_nat_detect) {\n\t(*pjsua_var.ua_cfg.cb.on_nat_detect)(res);\n    }\n}\n\n\n/*\n * Detect NAT type.\n */\nPJ_DEF(pj_status_t) pjsua_detect_nat_type()\n{\n    pj_status_t status;\n\n    if (pjsua_var.nat_in_progress)\n\treturn PJ_SUCCESS;\n\n    /* Make sure STUN server resolution has completed */\n    status = resolve_stun_server(PJ_TRUE, PJ_TRUE, 0);\n    if (status != PJ_SUCCESS) {\n\tpjsua_var.nat_status = status;\n\tpjsua_var.nat_type = PJ_STUN_NAT_TYPE_ERR_UNKNOWN;\n\treturn status;\n    }\n\n    /* Make sure we have STUN */\n    if (pjsua_var.stun_srv.addr.sa_family == 0) {\n\tpjsua_var.nat_status = PJNATH_ESTUNINSERVER;\n\treturn PJNATH_ESTUNINSERVER;\n    }\n\n    status = pj_stun_detect_nat_type2(&pjsua_var.stun_srv, \n\t\t\t\t      &pjsua_var.stun_cfg, \n\t\t\t\t      NULL, &nat_detect_cb);\n\n    if (status != PJ_SUCCESS) {\n\tpjsua_var.nat_status = status;\n\tpjsua_var.nat_type = PJ_STUN_NAT_TYPE_ERR_UNKNOWN;\n\treturn status;\n    }\n\n    pjsua_var.nat_in_progress = PJ_TRUE;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get NAT type.\n */\nPJ_DEF(pj_status_t) pjsua_get_nat_type(pj_stun_nat_type *type)\n{\n    *type = pjsua_var.nat_type;\n    return pjsua_var.nat_status;\n}\n\n/*\n * Verify that valid url is given.\n */\nPJ_DEF(pj_status_t) pjsua_verify_url(const char *c_url)\n{\n    pjsip_uri *p;\n    pj_pool_t *pool;\n    char *url;\n    pj_size_t len = (c_url ? pj_ansi_strlen(c_url) : 0);\n\n    if (!len) return PJSIP_EINVALIDURI;\n\n    pool = pj_pool_create(&pjsua_var.cp.factory, \"check%p\", 1024, 0, NULL);\n    if (!pool) return PJ_ENOMEM;\n\n    url = (char*) pj_pool_alloc(pool, len+1);\n    pj_ansi_strcpy(url, c_url);\n\n    p = pjsip_parse_uri(pool, url, len, 0);\n\n    pj_pool_release(pool);\n    return p ? 0 : PJSIP_EINVALIDURI;\n}\n\n/*\n * Verify that valid SIP url is given.\n */\nPJ_DEF(pj_status_t) pjsua_verify_sip_url(const char *c_url)\n{\n    pjsip_uri *p;\n    pj_pool_t *pool;\n    char *url;\n    pj_size_t len = (c_url ? pj_ansi_strlen(c_url) : 0);\n\n    if (!len) return PJSIP_EINVALIDURI;\n\n    pool = pj_pool_create(&pjsua_var.cp.factory, \"check%p\", 1024, 0, NULL);\n    if (!pool) return PJ_ENOMEM;\n\n    url = (char*) pj_pool_alloc(pool, len+1);\n    pj_ansi_strcpy(url, c_url);\n\n    p = pjsip_parse_uri(pool, url, len, 0);\n    if (!p || (pj_stricmp2(pjsip_uri_get_scheme(p), \"sip\") != 0 &&\n\t       pj_stricmp2(pjsip_uri_get_scheme(p), \"sips\") != 0))\n    {\n\tp = NULL;\n    }\n\n    pj_pool_release(pool);\n    return p ? 0 : PJSIP_EINVALIDURI;\n}\n\n/*\n * Schedule a timer entry. \n */\n#if PJ_TIMER_DEBUG\nPJ_DEF(pj_status_t) pjsua_schedule_timer_dbg( pj_timer_entry *entry,\n                                              const pj_time_val *delay,\n                                              const char *src_file,\n                                              int src_line)\n{\n    return pjsip_endpt_schedule_timer_dbg(pjsua_var.endpt, entry, delay,\n                                          src_file, src_line);\n}\n#else\nPJ_DEF(pj_status_t) pjsua_schedule_timer( pj_timer_entry *entry,\n\t\t\t\t\t  const pj_time_val *delay)\n{\n    return pjsip_endpt_schedule_timer(pjsua_var.endpt, entry, delay);\n}\n#endif\n\n/* Timer callback */\nstatic void timer_cb( pj_timer_heap_t *th,\n\t\t      pj_timer_entry *entry)\n{\n    pjsua_timer_list *tmr = (pjsua_timer_list *)entry->user_data;\n    void (*cb)(void *user_data) = tmr->cb;\n    void *user_data = tmr->user_data;\n\n    PJ_UNUSED_ARG(th);\n\n    if (cb)\n        (*cb)(user_data);\n\n    pj_mutex_lock(pjsua_var.timer_mutex);\n    pj_list_erase(tmr);\n    pj_list_push_back(&pjsua_var.timer_list, tmr);\n    pj_mutex_unlock(pjsua_var.timer_mutex);\n}\n\n/*\n * Schedule a timer callback. \n */\n#if PJ_TIMER_DEBUG\nPJ_DEF(pj_status_t) pjsua_schedule_timer2_dbg( void (*cb)(void *user_data),\n                                               void *user_data,\n                                               unsigned msec_delay,\n                                               const char *src_file,\n                                               int src_line)\n#else\nPJ_DEF(pj_status_t) pjsua_schedule_timer2( void (*cb)(void *user_data),\n                                           void *user_data,\n                                           unsigned msec_delay)\n#endif\n{\n    pjsua_timer_list *tmr = NULL;\n    pj_status_t status;\n    pj_time_val delay;\n\n    pj_mutex_lock(pjsua_var.timer_mutex);\n\n    if (pj_list_empty(&pjsua_var.timer_list)) {\n        tmr = PJ_POOL_ALLOC_T(pjsua_var.timer_pool, pjsua_timer_list);\n    } else {\n        tmr = pjsua_var.timer_list.next;\n        pj_list_erase(tmr);\n    }\n    pj_timer_entry_init(&tmr->entry, 0, tmr, timer_cb);\n    tmr->cb = cb;\n    tmr->user_data = user_data;\n    delay.sec = 0;\n    delay.msec = msec_delay;\n\n#if PJ_TIMER_DEBUG\n    status = pjsip_endpt_schedule_timer_dbg(pjsua_var.endpt, &tmr->entry,\n                                            &delay, src_file, src_line);\n#else\n    status = pjsip_endpt_schedule_timer(pjsua_var.endpt, &tmr->entry, &delay);\n#endif\n    if (status == PJ_SUCCESS) {\n    \tpj_list_push_back(&pjsua_var.active_timer_list, tmr);\n    } else {\n        pj_list_push_back(&pjsua_var.timer_list, tmr);\n    }\n\n    pj_mutex_unlock(pjsua_var.timer_mutex);\n\n    return status;\n}\n\n/*\n * Cancel the previously scheduled timer.\n *\n */\nPJ_DEF(void) pjsua_cancel_timer(pj_timer_entry *entry)\n{\n    pjsip_endpt_cancel_timer(pjsua_var.endpt, entry);\n}\n\n/** \n * Normalize route URI (check for \";lr\" and append one if it doesn't\n * exist and pjsua_config.force_lr is set.\n */\npj_status_t normalize_route_uri(pj_pool_t *pool, pj_str_t *uri)\n{\n    pj_str_t tmp_uri;\n    pj_pool_t *tmp_pool;\n    pjsip_uri *uri_obj;\n    pjsip_sip_uri *sip_uri;\n\n    tmp_pool = pjsua_pool_create(\"tmplr%p\", 512, 512);\n    if (!tmp_pool)\n\treturn PJ_ENOMEM;\n\n    pj_strdup_with_null(tmp_pool, &tmp_uri, uri);\n\n    uri_obj = pjsip_parse_uri(tmp_pool, tmp_uri.ptr, tmp_uri.slen, 0);\n    if (!uri_obj) {\n\tPJ_LOG(1,(THIS_FILE, \"Invalid route URI: %.*s\", \n\t\t  (int)uri->slen, uri->ptr));\n\tpj_pool_release(tmp_pool);\n\treturn PJSIP_EINVALIDURI;\n    }\n\n    if (!PJSIP_URI_SCHEME_IS_SIP(uri_obj) && \n\t!PJSIP_URI_SCHEME_IS_SIPS(uri_obj))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Route URI must be SIP URI: %.*s\", \n\t\t  (int)uri->slen, uri->ptr));\n\tpj_pool_release(tmp_pool);\n\treturn PJSIP_EINVALIDSCHEME;\n    }\n\n    sip_uri = (pjsip_sip_uri*) pjsip_uri_get_uri(uri_obj);\n\n    /* Done if force_lr is disabled or if lr parameter is present */\n    if (!pjsua_var.ua_cfg.force_lr || sip_uri->lr_param) {\n\tpj_pool_release(tmp_pool);\n\treturn PJ_SUCCESS;\n    }\n\n    /* Set lr param */\n    sip_uri->lr_param = 1;\n\n    /* Print the URI */\n    tmp_uri.ptr = (char*) pj_pool_alloc(tmp_pool, PJSIP_MAX_URL_SIZE);\n    tmp_uri.slen = pjsip_uri_print(PJSIP_URI_IN_ROUTING_HDR, uri_obj, \n\t\t\t\t   tmp_uri.ptr, PJSIP_MAX_URL_SIZE);\n    if (tmp_uri.slen < 1) {\n\tPJ_LOG(1,(THIS_FILE, \"Route URI is too long: %.*s\", \n\t\t  (int)uri->slen, uri->ptr));\n\tpj_pool_release(tmp_pool);\n\treturn PJSIP_EURITOOLONG;\n    }\n\n    /* Clone the URI */\n    pj_strdup_with_null(pool, uri, &tmp_uri);\n\n    pj_pool_release(tmp_pool);\n    return PJ_SUCCESS;\n}\n\n/*\n * This is a utility function to dump the stack states to log, using\n * verbosity level 3.\n */\nPJ_DEF(void) pjsua_dump(pj_bool_t detail)\n{\n    unsigned old_decor;\n    unsigned i;\n\n    PJ_LOG(3,(THIS_FILE, \"Start dumping application states:\"));\n\n    old_decor = pj_log_get_decor();\n    pj_log_set_decor(old_decor & (PJ_LOG_HAS_NEWLINE | PJ_LOG_HAS_CR));\n\n    if (detail)\n\tpj_dump_config();\n\n    pjsip_endpt_dump(pjsua_get_pjsip_endpt(), detail);\n\n    pjmedia_endpt_dump(pjsua_get_pjmedia_endpt());\n\n    PJ_LOG(3,(THIS_FILE, \"Dumping media transports:\"));\n    for (i=0; i<pjsua_var.ua_cfg.max_calls; ++i) {\n\tpjsua_call *call = &pjsua_var.calls[i];\n\tpjsua_acc_config *acc_cfg;\n\tpjmedia_transport *tp[PJSUA_MAX_CALL_MEDIA*2];\n\tunsigned tp_cnt = 0;\n\tunsigned j;\n\n\t/* Collect media transports in this call */\n\tfor (j = 0; j < call->med_cnt; ++j) {\n\t    if (call->media[j].tp != NULL)\n\t\ttp[tp_cnt++] = call->media[j].tp;\n\t}\n\tfor (j = 0; j < call->med_prov_cnt; ++j) {\n\t    pjmedia_transport *med_tp = call->media_prov[j].tp;\n\t    if (med_tp) {\n\t\tunsigned k;\n\t\tpj_bool_t used = PJ_FALSE;\n\t\tfor (k = 0; k < tp_cnt; ++k) {\n\t\t    if (med_tp == tp[k]) {\n\t\t\tused = PJ_TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!used)\n\t\t    tp[tp_cnt++] = med_tp;\n\t    }\n\t}\n\n\tacc_cfg = &pjsua_var.acc[call->acc_id].cfg;\n\n\t/* Dump the media transports in this call */\n\tfor (j = 0; j < tp_cnt; ++j) {\n\t    pjmedia_transport_info tpinfo;\n\t    char addr_buf[80];\n\n\t    pjmedia_transport_info_init(&tpinfo);\n\t    pjmedia_transport_get_info(tp[j], &tpinfo);\n\t    PJ_LOG(3,(THIS_FILE, \" %s: %s\",\n\t\t      (acc_cfg->ice_cfg.enable_ice ? \"ICE\" : \"UDP\"),\n\t\t      pj_sockaddr_print(&tpinfo.sock_info.rtp_addr_name,\n\t\t\t\t\taddr_buf,\n\t\t\t\t\tsizeof(addr_buf), 3)));\n\t}\n    }\n\n    pjsip_tsx_layer_dump(detail);\n    pjsip_ua_dump(detail);\n\n// Dumping complete call states may require a 'large' buffer \n// (about 3KB per call session, including RTCP XR).\n#if 0\n    /* Dump all invite sessions: */\n    PJ_LOG(3,(THIS_FILE, \"Dumping invite sessions:\"));\n\n    if (pjsua_call_get_count() == 0) {\n\n\tPJ_LOG(3,(THIS_FILE, \"  - no sessions -\"));\n\n    } else {\n\tunsigned i;\n\n\tfor (i=0; i<pjsua_var.ua_cfg.max_calls; ++i) {\n\t    if (pjsua_call_is_active(i)) {\n\t\t/* Tricky logging, since call states log string tends to be \n\t\t * longer than PJ_LOG_MAX_SIZE.\n\t\t */\n\t\tchar buf[1024 * 3];\n\t\tunsigned call_dump_len;\n\t\tunsigned part_len;\n\t\tunsigned part_idx;\n\t\tunsigned log_decor;\n\n\t\tpjsua_call_dump(i, detail, buf, sizeof(buf), \"  \");\n\t\tcall_dump_len = strlen(buf);\n\n\t\tlog_decor = pj_log_get_decor();\n\t\tpj_log_set_decor(log_decor & ~(PJ_LOG_HAS_NEWLINE | \n\t\t\t\t\t       PJ_LOG_HAS_CR));\n\t\tPJ_LOG(3,(THIS_FILE, \"\\n\"));\n\t\tpj_log_set_decor(0);\n\n\t\tpart_idx = 0;\n\t\tpart_len = PJ_LOG_MAX_SIZE-80;\n\t\twhile (part_idx < call_dump_len) {\n\t\t    char p_orig, *p;\n\n\t\t    p = &buf[part_idx];\n\t\t    if (part_idx + part_len > call_dump_len)\n\t\t\tpart_len = call_dump_len - part_idx;\n\t\t    p_orig = p[part_len];\n\t\t    p[part_len] = '\\0';\n\t\t    PJ_LOG(3,(THIS_FILE, \"%s\", p));\n\t\t    p[part_len] = p_orig;\n\t\t    part_idx += part_len;\n\t\t}\n\t\tpj_log_set_decor(log_decor);\n\t    }\n\t}\n    }\n#endif\n\n    /* Dump presence status */\n    pjsua_pres_dump(detail);\n\n    pj_log_set_decor(old_decor);\n    PJ_LOG(3,(THIS_FILE, \"Dump complete\"));\n}\n\n\n/* Forward declaration. */\nstatic void restart_listener_cb(void *user_data);\n\n\nstatic pj_status_t handle_ip_change_on_acc()\n{\n    int i = 0;\n    pj_status_t status = PJ_SUCCESS;\n    pj_bool_t acc_done[PJSUA_MAX_ACC];\n\n    PJSUA_LOCK();\n\n    if (pjsua_var.acc_cnt == 0) {\n\tPJ_LOG(3, (THIS_FILE,\n\t\t   \"No account is set, IP change handling will stop\"));\n\tpjsua_acc_end_ip_change(NULL);\n\tPJSUA_UNLOCK();\n\treturn status;\n    }\n\n    /* Reset ip_change_active flag. */\n    for (; i < (int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\tpjsua_var.acc[i].ip_change_op = PJSUA_IP_CHANGE_OP_NULL;\n\tacc_done[i] = PJ_FALSE;\n    }\n\n    for (i = 0; i < (int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\tpj_bool_t shutdown_transport = PJ_FALSE;\n\tpjsip_regc_info regc_info;\n\tchar acc_id[PJSUA_MAX_ACC * 4];\n\tpjsua_acc *acc = &pjsua_var.acc[i];\n\tpjsip_transport *transport = NULL;\n\tpjsua_acc_id shut_acc_ids[PJSUA_MAX_ACC];\n\tunsigned shut_acc_cnt = 0;\n\n\tif (!acc->valid || (acc_done[i]))\n\t    continue;\n\n\tif (acc->regc) {\n\t    int j = 0;\n\t    pj_status_t found_restart_tp_fail = PJ_FALSE;\n\n\t    pjsip_regc_get_info(acc->regc, &regc_info);\n\n\t    /* Check if transport restart listener succeed. */\n\t    for (; j < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++j) {\n\t\tif (pjsua_var.tpdata[j].data.ptr != NULL &&\n\t\t  pjsua_var.tpdata[j].restart_status != PJ_SUCCESS &&\n\t\t  pjsua_var.tpdata[j].type == regc_info.transport->key.type)\n\t\t{\n\t\t    if ((pjsua_var.tpdata[j].data.factory\n\t\t\t\t\t   == regc_info.transport->factory) ||\n\t\t\t(pjsua_var.tpdata[j].data.tp\n\t\t\t\t\t       == regc_info.transport))\n\t\t    {\n\t\t\tfound_restart_tp_fail = PJ_TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (found_restart_tp_fail) {\n\t\tif (acc->ka_timer.id) {\n\t\t    pjsip_endpt_cancel_timer(pjsua_var.endpt, &acc->ka_timer);\n\t\t    acc->ka_timer.id = PJ_FALSE;\n\n\t\t    if (acc->ka_transport) {\n\t\t\tpjsip_transport_dec_ref(acc->ka_transport);\n\t\t\tacc->ka_transport = NULL;\n\t\t    }\n\t\t}\n\t\tpjsua_acc_end_ip_change(acc);\n\t\tcontinue;\n\t    }\n\n\t    if ((regc_info.transport) &&\n\t\t((regc_info.transport->flag & PJSIP_TRANSPORT_DATAGRAM) == 0))\n\t    {\n\t\ttransport = regc_info.transport;\n\t\tshutdown_transport = acc->cfg.ip_change_cfg.shutdown_tp;\n\t\tshut_acc_ids[shut_acc_cnt++] = acc->index;\n\t    }\n\t} else if (acc->cfg.reg_uri.slen &&\n\t\t   acc->reg_last_code != PJSIP_SC_OK &&\n\t\t   acc->reg_last_code != PJSIP_SC_REQUEST_TIMEOUT &&\n\t\t   acc->reg_last_code != PJSIP_SC_INTERNAL_SERVER_ERROR &&\n\t\t   acc->reg_last_code != PJSIP_SC_BAD_GATEWAY &&\n\t\t   acc->reg_last_code != PJSIP_SC_SERVICE_UNAVAILABLE &&\n\t\t   acc->reg_last_code != PJSIP_SC_SERVER_TIMEOUT &&\n\t\t   acc->reg_last_code != PJSIP_SC_TEMPORARILY_UNAVAILABLE)\n\t{\n\t    PJ_LOG(3, (THIS_FILE, \"Permanent registration failure, \"\n\t\t       \"IP change handling will stop for acc %d\", acc->index));\n\n\t    pjsua_acc_end_ip_change(acc);\n\t    continue;\n\t}\n\tpj_ansi_snprintf(acc_id, sizeof(acc_id), \"#%d\", i);\n\n\tif (transport) {\n\t    unsigned j = i + 1;\n\n\t    /* Find other account that uses the same transport. */\n\t    for (; j < (int)PJ_ARRAY_SIZE(pjsua_var.acc); ++j) {\n\t\tpjsip_regc_info tmp_regc_info;\n\t\tpjsua_acc *next_acc = &pjsua_var.acc[j];\n\n\t\tif (!next_acc->valid || !next_acc->regc ||\n\t\t    (next_acc->ip_change_op > PJSUA_IP_CHANGE_OP_NULL))\n\t\t{\n\t\t    continue;\n\t\t}\n\n\t\tpjsip_regc_get_info(next_acc->regc, &tmp_regc_info);\n\t\tif (transport == tmp_regc_info.transport) {\n                    char tmp_buf[4];\n\n                    pj_ansi_snprintf(tmp_buf, sizeof(tmp_buf), \" #%d\", j);\n                    if (pj_ansi_strlen(acc_id) + pj_ansi_strlen(tmp_buf) <\n                        sizeof(acc_id))\n                    {\n                        pj_ansi_strcat(acc_id, tmp_buf);\n                    }\n\n\t\t    shut_acc_ids[shut_acc_cnt++] = j;\n\t\t    if (!shutdown_transport) {\n\t\t\tshutdown_transport =\n\t\t\t\t    next_acc->cfg.ip_change_cfg.shutdown_tp;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (shutdown_transport) {\n\t    unsigned j;\n\t    /* Shutdown the transport. */\n\t    PJ_LOG(3, (THIS_FILE, \"Shutdown transport %s used by account %s \"\n\t\t       \"triggered by IP change\", transport->obj_name, acc_id));\n\n\t    for (j = 0; j < shut_acc_cnt; ++j) {\n\t\tpjsua_acc *tmp_acc = &pjsua_var.acc[shut_acc_ids[j]];\n\t\ttmp_acc->ip_change_op = PJSUA_IP_CHANGE_OP_ACC_SHUTDOWN_TP;\n\t\tacc_done[shut_acc_ids[j]] = PJ_TRUE;\n\t    }\n\n\t    status = pjsip_transport_shutdown2(transport, PJ_TRUE);\n\t} else {\n\t    acc_done[i] = PJ_TRUE;\n\t    if (acc->cfg.allow_contact_rewrite && acc->cfg.reg_uri.slen) {\n\t\tstatus = pjsua_acc_update_contact_on_ip_change(acc);\n\t    } else {\n\t\tstatus = pjsua_acc_handle_call_on_ip_change(acc);\n\t    }\n\t}\n    }\n    PJSUA_UNLOCK();\n    return status;\n}\n\n\nstatic pj_status_t restart_listener(pjsua_transport_id id,\n\t\t\t\t    unsigned restart_lis_delay)\n{\n    pj_sockaddr bind_addr;\n    pjsua_transport_info tp_info;\n    pj_status_t status;\n\n    pjsua_transport_get_info(id, &tp_info);\n    pj_sockaddr_init(pjsip_transport_type_get_af(tp_info.type),\n\t\t     &bind_addr,\n\t\t     NULL,\n\t\t     pj_sockaddr_get_port(&tp_info.local_addr));\n\n    switch (tp_info.type) {\n    case PJSIP_TRANSPORT_UDP:\n    case PJSIP_TRANSPORT_UDP6:    \n    {\n\tunsigned num_locks = 0;\n\n\t/* Release locks before restarting the transport, to avoid deadlock. */\n\twhile (PJSUA_LOCK_IS_LOCKED()) {\n    \t    num_locks++;\n    \t    PJSUA_UNLOCK();\n\t}\n\n\tstatus = pjsip_udp_transport_restart2(\n\t\t\t\t       pjsua_var.tpdata[id].data.tp,\n\t\t\t\t       PJSIP_UDP_TRANSPORT_DESTROY_SOCKET,\n\t\t\t\t       PJ_INVALID_SOCKET,\n\t\t\t\t       &bind_addr,\n\t\t\t\t       NULL);\n\n\t/* Re-acquire the locks. */\n\tfor (;num_locks > 0; num_locks--)\n    \t    PJSUA_LOCK();\n\n    }\n\tbreak;\n\n#if defined(PJSIP_HAS_TLS_TRANSPORT) && PJSIP_HAS_TLS_TRANSPORT!=0\n    case PJSIP_TRANSPORT_TLS:\n    case PJSIP_TRANSPORT_TLS6:\n\tstatus = pjsip_tls_transport_restart(\n\t\t\t\t\tpjsua_var.tpdata[id].data.factory,\n\t\t\t\t\t&bind_addr,\n\t\t\t\t\tNULL);\n\tbreak;\n#endif\n    case PJSIP_TRANSPORT_TCP:\n    case PJSIP_TRANSPORT_TCP6:\n\tstatus = pjsip_tcp_transport_restart(\n\t\t\t\t\tpjsua_var.tpdata[id].data.factory,\n\t\t\t\t\t&bind_addr,\n\t\t\t\t\tNULL);\n\tbreak;\n\n    default:\n\tstatus = PJ_EINVAL;\n    }\n\n    PJ_PERROR(3,(THIS_FILE, status, \"Listener %.*s restart\",\n\t\t tp_info.info.slen, tp_info.info.ptr));\n\n    if (status != PJ_SUCCESS && (restart_lis_delay > 0)) {\n\t/* Try restarting again, with delay. */\n\tpjsua_schedule_timer2(&restart_listener_cb,\n\t\t\t      (void*)(pj_size_t)id,\n\t\t\t      restart_lis_delay);\n\n\tPJ_LOG(3,(THIS_FILE, \"Retry listener %.*s restart in %d ms\",\n\t\t  tp_info.info.slen, tp_info.info.ptr, restart_lis_delay));\n\n\tstatus = PJ_SUCCESS;\n    } else {\n\tint i = 0;\n\tpj_bool_t all_done = PJ_TRUE;\n\n\tpjsua_var.tpdata[id].is_restarting = PJ_FALSE;\n\tpjsua_var.tpdata[id].restart_status = status;\n\tif (pjsua_var.ua_cfg.cb.on_ip_change_progress) {\n\t    pjsua_ip_change_op_info info;\n\n\t    pj_bzero(&info, sizeof(info));\n\t    info.lis_restart.transport_id = id;\n\t    pjsua_var.ua_cfg.cb.on_ip_change_progress(\n\t\t\t\t\t\tPJSUA_IP_CHANGE_OP_RESTART_LIS,\n\t\t\t\t\t\tstatus,\n\t\t\t\t\t\t&info);\n\t}\n\n\t/* Move forward if all listener has been restarted. */\n\tfor (; i < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++i) {\n\t    if (pjsua_var.tpdata[i].data.ptr != NULL &&\n\t\tpjsua_var.tpdata[i].is_restarting)\n\t    {\n\t\tall_done = PJ_FALSE;\n\t\tbreak;\n\t    }\n\t}\n\tif (all_done)\n\t    status = handle_ip_change_on_acc();\n    }\n    return status;\n}\n\n\nstatic void restart_listener_cb(void *user_data)\n{\n    pjsua_transport_id transport_id = (pjsua_transport_id)(pj_size_t)user_data;\n    restart_listener(transport_id, 0);\n}\n\n\nstatic void ip_change_put_back_inv_config(void *user_data)\n{\n    PJ_UNUSED_ARG(user_data);\n\n    PJ_LOG(4,(THIS_FILE,\"IP change stops ignoring request timeout\"));\n    pjsip_cfg()->endpt.keep_inv_after_tsx_timeout = PJ_FALSE;\n}\n\n\nPJ_DEF(pj_status_t) pjsua_handle_ip_change(const pjsua_ip_change_param *param)\n{\n    pj_status_t status = PJ_SUCCESS;\n    int i = 0;\n\n    PJ_ASSERT_RETURN(param, PJ_EINVAL);\n\n    for (; i < (int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\tif (pjsua_var.acc[i].valid &&\n\t    pjsua_var.acc[i].ip_change_op != PJSUA_IP_CHANGE_OP_NULL &&\n\t    pjsua_var.acc[i].ip_change_op != PJSUA_IP_CHANGE_OP_COMPLETED)\n\t{\n\t    PJ_LOG(2, (THIS_FILE,\n\t\t     \"Previous IP address change handling still in progress\"));\n\t}\n    }\n\n    PJ_LOG(3, (THIS_FILE, \"Start handling IP address change\"));\n\n    /* Avoid call disconnection due to request timeout. Some requests may\n     * be in progress when network is changing, they may eventually get\n     * timed out and cause call disconnection.\n     */\n    if (!pjsip_cfg()->endpt.keep_inv_after_tsx_timeout) {\n\tpjsip_cfg()->endpt.keep_inv_after_tsx_timeout = PJ_TRUE;\n\n\t/* Put it back after some time (transaction timeout setting value) */\n\tpjsua_schedule_timer2(&ip_change_put_back_inv_config, NULL,\n\t\t\t      pjsip_cfg()->tsx.td);\n\n\tPJ_LOG(4,(THIS_FILE,\"IP change temporarily ignores request timeout\"));\n    }\n\n    if (param->restart_listener) {\n\tPJSUA_LOCK();\n\t/* Restart listener/transport, handle_ip_change_on_acc() will\n\t * be called after listener restart is completed successfully.\n\t */\n\tfor (i = 0; i < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++i) {\n\t    if (pjsua_var.tpdata[i].data.ptr != NULL) {\n\t\tpjsua_var.tpdata[i].is_restarting = PJ_TRUE;\n\t\tpjsua_var.tpdata[i].restart_status = PJ_EUNKNOWN;\n\t    }\n\t}\n\tfor (i = 0; i < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++i) {\n\t    if (pjsua_var.tpdata[i].data.ptr != NULL) {\n\t\tstatus = restart_listener(i, param->restart_lis_delay);\n\t    }\n\t}\n        PJSUA_UNLOCK();\n    } else {\n\tfor (i = 0; i < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++i) {\n\t    if (pjsua_var.tpdata[i].data.ptr != NULL) {\n\t\tpjsua_var.tpdata[i].restart_status = PJ_SUCCESS;\n\t    }\n\t}\n\tstatus = handle_ip_change_on_acc();\n    }\n\n    return status;\n}\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#ifndef __PJSIP_AUTH_SIP_AUTH_H__\n#define __PJSIP_AUTH_SIP_AUTH_H__\n\n/**\n * @file pjsip_auth.h\n * @brief SIP Authorization Module.\n */\n\n#include <pjsip/sip_config.h>\n#include <pjsip/sip_auth_msg.h>\n\nPJ_BEGIN_DECL\n\n/**\n * @addtogroup PJSIP_AUTH\n * @ingroup PJSIP_CORE\n * @brief Client and server side authentication framework.\n */\n\n/**\n * @defgroup PJSIP_AUTH_API Authentication API's\n * @ingroup PJSIP_AUTH\n * @brief Structures and functions to perform authentication.\n * @{\n */\n\n/** Length of digest MD5 string. */\n#define PJSIP_MD5STRLEN\t\t32\n\n/** Length of digest SHA256 string. */\n#define PJSIP_SHA256STRLEN\t64\n\n\n/** Type of data in the credential information in #pjsip_cred_info. */\ntypedef enum pjsip_cred_data_type\n{\n    PJSIP_CRED_DATA_PLAIN_PASSWD=0, /**< Plain text password.\t\t*/\n    PJSIP_CRED_DATA_DIGEST\t=1, /**< Hashed digest.\t\t\t*/\n\n    PJSIP_CRED_DATA_EXT_AKA\t=16 /**< Extended AKA info is available */\n\n} pjsip_cred_data_type;\n\n/** Authentication's quality of protection (qop) type. */\ntypedef enum pjsip_auth_qop_type\n{\n    PJSIP_AUTH_QOP_NONE,\t    /**< No quality of protection. */\n    PJSIP_AUTH_QOP_AUTH,\t    /**< Authentication. */\n    PJSIP_AUTH_QOP_AUTH_INT,\t    /**< Authentication with integrity protection. */\n    PJSIP_AUTH_QOP_UNKNOWN\t    /**< Unknown protection. */\n} pjsip_auth_qop_type;\n\n\n/**\n * Type of callback function to create authentication response.\n * Application can specify this callback in \\a cb field of the credential info\n * (#pjsip_cred_info) and specifying PJSIP_CRED_DATA_DIGEST_CALLBACK as \n * \\a data_type. When this function is called, most of the fields in the \n * \\a auth authentication response will have been filled by the framework. \n * Application normally should just need to calculate the response digest \n * of the authentication response.\n *\n * @param pool\t    Pool to allocate memory from if application needs to.\n * @param chal\t    The authentication challenge sent by server in 401\n *\t\t    or 401 response, in either Proxy-Authenticate or\n *\t\t    WWW-Authenticate header.\n * @param cred\t    The credential that has been selected by the framework\n *\t\t    to authenticate against the challenge.\n * @param auth\t    The authentication response which application needs to\n *\t\t    calculate the response digest.\n *\n * @return\t    Application may return non-PJ_SUCCESS to abort the\n *\t\t    authentication process. When this happens, the \n *\t\t    framework will return failure to the original function\n *\t\t    that requested authentication.\n */\ntypedef pj_status_t (*pjsip_cred_cb)(pj_pool_t *pool,\n\t\t\t\t     const pjsip_digest_challenge *chal,\n\t\t\t\t     const pjsip_cred_info *cred,\n\t\t\t\t     const pj_str_t *method,\n\t\t\t\t     pjsip_digest_credential *auth);\n\n\n/** \n * This structure describes credential information. \n * A credential information is a static, persistent information that identifies\n * username and password required to authorize to a specific realm.\n *\n * Note that since PJSIP 0.7.0.1, it is possible to make a credential that is\n * valid for any realms, by setting the realm to star/wildcard character,\n * i.e. realm = pj_str(\"*\");.\n */\nstruct pjsip_cred_info\n{\n    pj_str_t    realm;\t\t/**< Realm. Use \"*\" to make a credential that\n\t\t\t\t     can be used to authenticate against any\n\t\t\t\t     challenges.\t\t\t    */\n    pj_str_t\tscheme;\t\t/**< Scheme (e.g. \"digest\").\t\t    */\n    pj_str_t\tusername;\t/**< User name.\t\t\t\t    */\n    int\t\tdata_type;\t/**< Type of data (0 for plaintext passwd). */\n    pj_str_t\tdata;\t\t/**< The data, which can be a plaintext \n\t\t\t\t     password or a hashed digest.\t    */\n\n    /** Extended data */\n    union {\n\t/** Digest AKA credential information. Note that when AKA credential\n\t *  is being used, the \\a data field of this #pjsip_cred_info is\n\t *  not used, but it still must be initialized to an empty string.\n\t * Please see \\ref PJSIP_AUTH_AKA_API for more information.\n\t */\n\tstruct {\n\t    pj_str_t\t  k;\t/**< Permanent subscriber key.\t\t*/\n\t    pj_str_t\t  op;\t/**< Operator variant key.\t\t*/\n\t    pj_str_t\t  amf;\t/**< Authentication Management Field\t*/\n\t    pjsip_cred_cb cb;\t/**< Callback to create AKA digest.\t*/\n\t} aka;\n\n    } ext;\n};\n\n/**\n * This structure describes cached value of previously sent Authorization\n * or Proxy-Authorization header. The authentication framework keeps a list\n * of this structure and will resend the same header to the same server\n * as long as the method, uri, and nonce stays the same.\n */\ntypedef struct pjsip_cached_auth_hdr\n{\n    /** Standard list member */\n    PJ_DECL_LIST_MEMBER(struct pjsip_cached_auth_hdr);\n\n    pjsip_method\t     method;\t/**< To quickly see the method. */\n    pjsip_authorization_hdr *hdr;\t/**< The cached header.\t\t*/\n\n} pjsip_cached_auth_hdr;\n\n\n/**\n * This structure describes authentication information for the specified\n * realm. Each instance of this structure describes authentication \"session\"\n * between this endpoint and remote server. This \"session\" information is\n * usefull to keep information that persists for more than one challenge,\n * such as nonce-count and cnonce value.\n *\n * Other than that, this structure also keeps the last authorization headers\n * that have been sent in the cache list.\n */\ntypedef struct pjsip_cached_auth\n{\n    /** Standard list member */\n    PJ_DECL_LIST_MEMBER(struct pjsip_cached_auth);\n\n    pj_pool_t\t\t\t*pool;      /**< Pool for cached auth\t    */\n    pj_str_t\t\t\t realm;\t    /**< Realm.\t\t\t    */\n    pj_bool_t\t\t\t is_proxy;  /**< Server type (401/407)\t    */\n    pjsip_auth_qop_type\t\t qop_value; /**< qop required by server.    */\n    unsigned\t\t\t stale_cnt; /**< Number of stale retry.\t    */\n#if PJSIP_AUTH_QOP_SUPPORT\n    pj_uint32_t\t\t\t nc;\t    /**< Nonce count.\t\t    */\n    pj_str_t\t\t\t cnonce;    /**< Cnonce value.\t\t    */\n#endif\n    pjsip_www_authenticate_hdr\t*last_chal; /**< Last challenge seen.\t    */\n#if PJSIP_AUTH_HEADER_CACHING\n    pjsip_cached_auth_hdr\t cached_hdr;/**< List of cached header for\n\t\t\t\t\t\t each method.\t\t    */\n#endif\n\n} pjsip_cached_auth;\n\n\n/**\n * This structure describes client authentication session preference.\n * The preference can be set by calling #pjsip_auth_clt_set_prefs().\n */\ntypedef struct pjsip_auth_clt_pref\n{\n    /**\n     * If this flag is set, the authentication client framework will\n     * send an empty Authorization header in each initial request.\n     * Default is no.\n     */\n    pj_bool_t\tinitial_auth;\n\n    /**\n     * Specify the algorithm to use when empty Authorization header \n     * is to be sent for each initial request (see above)\n     */\n    pj_str_t\talgorithm;\n\n} pjsip_auth_clt_pref;\n\n\n/**\n * Duplicate a client authentication preference setting.\n *\n * @param pool\t    The memory pool.\n * @param dst\t    Destination client authentication preference.\n * @param src\t    Source client authentication preference.\n */\nPJ_DECL(void) pjsip_auth_clt_pref_dup(pj_pool_t *pool,\n\t\t\t\t      pjsip_auth_clt_pref *dst,\n\t\t\t\t      const pjsip_auth_clt_pref *src);\n\n\n/**\n * This structure describes client authentication sessions. It keeps\n * all the information needed to authorize the client against all downstream \n * servers.\n */\ntypedef struct pjsip_auth_clt_sess\n{\n    pj_pool_t\t\t*pool;\t\t/**< Pool to use.\t\t    */\n    pjsip_endpoint\t*endpt;\t\t/**< Endpoint where this belongs.   */\n    pjsip_auth_clt_pref  pref;\t\t/**< Preference/options.\t    */\n    unsigned\t\t cred_cnt;\t/**< Number of credentials.\t    */\n    pjsip_cred_info\t*cred_info;\t/**< Array of credential information*/\n    pjsip_cached_auth\t cached_auth;\t/**< Cached authorization info.\t    */\n\n} pjsip_auth_clt_sess;\n\n\n/**\n * Duplicate a credential info.\n *\n * @param pool\t    The memory pool.\n * @param dst\t    Destination credential.\n * @param src\t    Source credential.\n */\nPJ_DECL(void) pjsip_cred_info_dup(pj_pool_t *pool,\n\t\t\t\t  pjsip_cred_info *dst,\n\t\t\t\t  const pjsip_cred_info *src);\n\n/**\n * Compare two credential infos.\n *\n * @param cred1\t    The credential info to compare.\n * @param cred2\t    The credential info to compare.\n *\n * @return\t    0 if both credentials are equal.\n */\nPJ_DECL(int) pjsip_cred_info_cmp(const pjsip_cred_info *cred1,\n\t\t\t\t const pjsip_cred_info *cred2);\n\n\n/**\n * Type of function to lookup credential for the specified name.\n *\n * @param pool\t\tPool to initialize the credential info.\n * @param realm\t\tRealm to find the account.\n * @param acc_name\tAccount name to look for.\n * @param cred_info\tThe structure to put the credential when it's found.\n *\n * @return\t\tThe function MUST return PJ_SUCCESS when it found\n *\t\t\ta correct credential for the specified account and\n *\t\t\trealm. Otherwise it may return PJSIP_EAUTHACCNOTFOUND\n *\t\t\tor PJSIP_EAUTHACCDISABLED.\n */\ntypedef pj_status_t pjsip_auth_lookup_cred( pj_pool_t *pool,\n\t\t\t\t\t    const pj_str_t *realm,\n\t\t\t\t\t    const pj_str_t *acc_name,\n\t\t\t\t\t    pjsip_cred_info *cred_info );\n\n\n/**\n * This structure describes input param for credential lookup.\n */\ntypedef struct pjsip_auth_lookup_cred_param\n{\n    pj_str_t realm;\t    /**< Realm to find the account.\t\t*/\n    pj_str_t acc_name;\t    /**< Account name to look for.\t\t*/\n    pjsip_rx_data *rdata;   /**< Incoming request to be authenticated.\t*/\n\n} pjsip_auth_lookup_cred_param;\n\n\n/**\n * Type of function to lookup credential for the specified name.\n *\n * @param pool\t\tPool to initialize the credential info.\n * @param param\t\tThe input param for credential lookup.\n * @param cred_info\tThe structure to put the credential when it's found.\n *\n * @return\t\tThe function MUST return PJ_SUCCESS when it found\n *\t\t\ta correct credential for the specified account and\n *\t\t\trealm. Otherwise it may return PJSIP_EAUTHACCNOTFOUND\n *\t\t\tor PJSIP_EAUTHACCDISABLED.\n */\ntypedef pj_status_t pjsip_auth_lookup_cred2(\n\t\t\t\tpj_pool_t *pool,\n\t\t\t\tconst pjsip_auth_lookup_cred_param *param,\n\t\t\t\tpjsip_cred_info *cred_info );\n\n\n/** Flag to specify that server is a proxy. */\n#define PJSIP_AUTH_SRV_IS_PROXY\t    1\n\n/**\n * This structure describes server authentication information.\n */\ntypedef struct pjsip_auth_srv\n{\n    pj_str_t\t\t     realm;\t/**< Realm to serve.\t\t    */\n    pj_bool_t\t\t     is_proxy;\t/**< Will issue 407 instead of 401  */\n    pjsip_auth_lookup_cred  *lookup;\t/**< Lookup function.\t\t    */\n    pjsip_auth_lookup_cred2 *lookup2;\t/**< Lookup function with additional\n\t\t\t\t\t     info in its input param.\t    */\n} pjsip_auth_srv;\n\n\n/**\n * Initialize client authentication session data structure, and set the \n * session to use pool for its subsequent memory allocation. The argument \n * options should be set to zero for this PJSIP version.\n *\n * @param sess\t\tThe client authentication session.\n * @param endpt\t\tEndpoint where this session belongs.\n * @param pool\t\tPool to use.\n * @param options\tMust be zero.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_init( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t  pjsip_endpoint *endpt,\n\t\t\t\t\t  pj_pool_t *pool, \n\t\t\t\t\t  unsigned options);\n\n\n/**\n * Deinitialize client authentication session data structure.\n *\n * @param sess\t\tThe client authentication session.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_deinit( pjsip_auth_clt_sess *sess);\n\n\n/**\n * Clone client initialization session. \n *\n * @param pool\t\tPool to use.\n * @param sess\t\tStructure to put the duplicated session.\n * @param rhs\t\tThe client session to be cloned.\n *\n * @return\t\tPJ_SUCCESS on success;\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_clone( pj_pool_t *pool,\n\t\t\t\t\t   pjsip_auth_clt_sess *sess,\n\t\t\t\t\t   const pjsip_auth_clt_sess *rhs);\n\n/**\n * Set the credentials to be used during the session. This will duplicate \n * the specified credentials using client authentication's pool.\n *\n * @param sess\t\tThe client authentication session.\n * @param cred_cnt\tNumber of credentials.\n * @param c\t\tArray of credentials.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_set_credentials( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t\t     int cred_cnt,\n\t\t\t\t\t\t     const pjsip_cred_info *c);\n\n\n/**\n * Set the preference for the client authentication session.\n *\n * @param sess\t\tThe client authentication session.\n * @param p\t\tPreference.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,\n\t\t\t\t\t      const pjsip_auth_clt_pref *p);\n\n\n/**\n * Get the preference for the client authentication session.\n *\n * @param sess\t\tThe client authentication session.\n * @param p\t\tPointer to receive the preference.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_get_prefs(pjsip_auth_clt_sess *sess,\n\t\t\t\t\t      pjsip_auth_clt_pref *p);\n\n/**\n * Initialize new request message with authorization headers.\n * This function will put Authorization/Proxy-Authorization headers to the\n * outgoing request message. If caching is enabled (PJSIP_AUTH_HEADER_CACHING)\n * and the session has previously sent Authorization/Proxy-Authorization header\n * with the same method, then the same Authorization/Proxy-Authorization header\n * will be resent from the cache only if qop is not present. If the stack is \n * configured to automatically generate next Authorization/Proxy-Authorization\n * headers (PJSIP_AUTH_AUTO_SEND_NEXT flag), then new Authorization/Proxy-\n * Authorization headers are calculated and generated when they are not present\n * in the case or if authorization session has qop.\n *\n * If both PJSIP_AUTH_HEADER_CACHING flag and PJSIP_AUTH_AUTO_SEND_NEXT flag\n * are not set, this function will do nothing. The stack then will only send\n * Authorization/Proxy-Authorization to respond 401/407 response.\n *\n * @param sess\t\tThe client authentication session.\n * @param tdata\t\tThe request message to be initialized.\n *\n * @return\t\tPJ_SUCCESS if successfull.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_init_req( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t      pjsip_tx_data *tdata );\n\n\n/**\n * Call this function when a transaction failed with 401 or 407 response.\n * This function will reinitialize the original request message with the\n * authentication challenge found in the response message, and add the\n * new authorization header in the authorization cache.\n *\n * Note that upon return the reference counter of the new transmit data\n * will be set to 1.\n *\n * @param sess\t\tThe client authentication session.\n * @param rdata\t\tThe response message containing 401/407 status.\n * @param old_request\tThe original request message, which will be re-\n *\t\t\tcreated with authorization info.\n * @param new_request\tPointer to receive new request message which\n *\t\t\twill contain all required authorization headers.\n *\n * @return\t\tPJ_SUCCESS if new request can be successfully\n *\t\t\tcreated to respond all the authentication\n *\t\t\tchallenges.\n */\nPJ_DECL(pj_status_t) pjsip_auth_clt_reinit_req(\tpjsip_auth_clt_sess *sess,\n\t\t\t\t\t\tconst pjsip_rx_data *rdata,\n\t\t\t\t\t\tpjsip_tx_data *old_request,\n\t\t\t\t\t\tpjsip_tx_data **new_request );\n\n/**\n * Initialize server authorization session data structure to serve the \n * specified realm and to use lookup_func function to look for the credential \n * info. \n *\n * @param pool\t\tPool used to initialize the authentication server.\n * @param auth_srv\tThe authentication server structure.\n * @param realm\t\tRealm to be served by the server.\n * @param lookup\tAccount lookup function.\n * @param options\tOptions, bitmask of:\n *\t\t\t- PJSIP_AUTH_SRV_IS_PROXY: to specify that the server\n *\t\t\t  will authorize clients as a proxy server (instead of\n *\t\t\t  as UAS), which means that Proxy-Authenticate will \n *\t\t\t  be used instead of WWW-Authenticate.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_srv_init( pj_pool_t *pool,\n\t\t\t\t\t  pjsip_auth_srv *auth_srv,\n\t\t\t\t\t  const pj_str_t *realm,\n\t\t\t\t\t  pjsip_auth_lookup_cred *lookup,\n\t\t\t\t\t  unsigned options );\n\n\n/**\n * This structure describes initialization settings of server authorization\n * session.\n */\ntypedef struct pjsip_auth_srv_init_param\n{\n    /**\n     * Realm to be served by the server.\n     */\n    const pj_str_t\t\t*realm;\n\n    /**\n     * Account lookup function.\n     */\n    pjsip_auth_lookup_cred2\t*lookup2;\n\n    /**\n     * Options, bitmask of:\n     * - PJSIP_AUTH_SRV_IS_PROXY: to specify that the server will authorize\n     *   clients as a proxy server (instead of as UAS), which means that\n     *   Proxy-Authenticate will be used instead of WWW-Authenticate.\n     */\n    unsigned\t\t\t options;\n\n} pjsip_auth_srv_init_param;\n\n\n/**\n * Initialize server authorization session data structure to serve the \n * specified realm and to use lookup_func function to look for the credential\n * info. \n *\n * @param pool\t\tPool used to initialize the authentication server.\n * @param auth_srv\tThe authentication server structure.\n * @param param\t\tThe initialization param.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_srv_init2(\n\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t    pjsip_auth_srv *auth_srv,\n\t\t\t\t    const pjsip_auth_srv_init_param *param);\n\n/**\n * Request the authorization server framework to verify the authorization \n * information in the specified request in rdata.\n *\n * @param auth_srv\tThe server authentication structure.\n * @param rdata\t\tIncoming request to be authenticated.\n * @param status_code\tWhen not null, it will be filled with suitable \n *\t\t\tstatus code to be sent to the client.\n *\n * @return\t\tPJ_SUCCESS if request is successfully authenticated.\n *\t\t\tOtherwise the function may return one of the\n *\t\t\tfollowing error codes:\n *\t\t\t- PJSIP_EAUTHNOAUTH\n *\t\t\t- PJSIP_EINVALIDAUTHSCHEME\n *\t\t\t- PJSIP_EAUTHACCNOTFOUND\n *\t\t\t- PJSIP_EAUTHACCDISABLED\n *\t\t\t- PJSIP_EAUTHINVALIDREALM\n *\t\t\t- PJSIP_EAUTHINVALIDDIGEST\n */\nPJ_DECL(pj_status_t) pjsip_auth_srv_verify( pjsip_auth_srv *auth_srv,\n\t\t\t\t\t    pjsip_rx_data *rdata,\n\t\t\t\t\t    int *status_code );\n\n\n/**\n * Add authentication challenge headers to the outgoing response in tdata. \n * Application may specify its customized nonce and opaque for the challenge, \n * or can leave the value to NULL to make the function fills them in with \n * random characters.\n *\n * @param auth_srv\tThe server authentication structure.\n * @param qop\t\tOptional qop value.\n * @param nonce\t\tOptional nonce value.\n * @param opaque\tOptional opaque value.\n * @param stale\t\tStale indication.\n * @param tdata\t\tThe outgoing response message. The response must have\n *\t\t\t401 or 407 response code.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_srv_challenge( pjsip_auth_srv *auth_srv,\n\t\t\t\t\t       const pj_str_t *qop,\n\t\t\t\t\t       const pj_str_t *nonce,\n\t\t\t\t\t       const pj_str_t *opaque,\n\t\t\t\t\t       pj_bool_t stale,\n\t\t\t\t\t       pjsip_tx_data *tdata);\n\n/**\n * Helper function to create MD5 digest out of the specified \n * parameters.\n *\n * @param result\tString to store the response digest. This string\n *\t\t\tmust have been preallocated by caller with the \n *\t\t\tbuffer at least PJSIP_MD5STRLEN (32 bytes) in size.\n * @param nonce\t\tOptional nonce.\n * @param nc\t\tNonce count.\n * @param cnonce\tOptional cnonce.\n * @param qop\t\tOptional qop.\n * @param uri\t\tURI.\n * @param realm\t\tRealm.\n * @param cred_info\tCredential info.\n * @param method\tSIP method.\n *\n * @return\t\tPJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_auth_create_digest(pj_str_t *result,\n\t\t\t\t\t      const pj_str_t *nonce,\n\t\t\t\t\t      const pj_str_t *nc,\n\t\t\t\t\t      const pj_str_t *cnonce,\n\t\t\t\t\t      const pj_str_t *qop,\n\t\t\t\t\t      const pj_str_t *uri,\n\t\t\t\t\t      const pj_str_t *realm,\n\t\t\t\t\t      const pjsip_cred_info *cred_info,\n\t\t\t\t\t      const pj_str_t *method);\n\n/**\n * Helper function to create SHA-256 digest out of the specified \n * parameters.\n *\n * @param result\tString to store the response digest. This string\n *\t\t\tmust have been preallocated by caller with the \n *\t\t\tbuffer at least PJSIP_SHA256STRLEN (64 bytes) in size.\n * @param nonce\t\tOptional nonce.\n * @param nc\t\tNonce count.\n * @param cnonce\tOptional cnonce.\n * @param qop\t\tOptional qop.\n * @param uri\t\tURI.\n * @param realm\t\tRealm.\n * @param cred_info\tCredential info.\n * @param method\tSIP method.\n *\n * @return\t\tPJ_SUCCESS on success. \n */\nPJ_DEF(pj_status_t) pjsip_auth_create_digestSHA256(pj_str_t* result,\n\t\t\t\t\t    const pj_str_t* nonce,\n\t\t\t\t\t    const pj_str_t* nc,\n\t\t\t\t\t    const pj_str_t* cnonce,\n\t\t\t\t\t    const pj_str_t* qop,\n\t\t\t\t\t    const pj_str_t* uri,\n\t\t\t\t\t    const pj_str_t* realm,\n\t\t\t\t\t    const pjsip_cred_info* cred_info,\n\t\t\t\t\t    const pj_str_t* method);\n\n/**\n * @}\n */\n\n\n\nPJ_END_DECL\n\n\n#endif\t/* __PJSIP_AUTH_SIP_AUTH_H__ */\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjsip/sip_auth_aka.h>\n#include <pjsip/sip_errno.h>\n#include <pjlib-util/base64.h>\n#include <pjlib-util/md5.h>\n#include <pjlib-util/hmac_md5.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n#if PJSIP_HAS_DIGEST_AKA_AUTH\n\n#include \"../../third_party/milenage/milenage.h\"\n\n/*\n * Create MD5-AKA1 digest response.\n */\nPJ_DEF(pj_status_t) pjsip_auth_create_aka_response( \n\t\t\t\t\t     pj_pool_t *pool,\n\t\t\t\t\t     const pjsip_digest_challenge *chal,\n\t\t\t\t\t     const pjsip_cred_info *cred,\n\t\t\t\t\t     const pj_str_t *method,\n\t\t\t\t\t     pjsip_digest_credential *auth)\n{\n    pj_str_t nonce_bin;\n    int aka_version;\n    const pj_str_t pjsip_AKAv1_MD5 = { \"AKAv1-MD5\", 9 };\n    const pj_str_t pjsip_AKAv2_MD5 = { \"AKAv2-MD5\", 9 };\n    pj_uint8_t *chal_rand, *chal_sqnxoraka, *chal_mac;\n    pj_uint8_t k[PJSIP_AKA_KLEN];\n    pj_uint8_t op[PJSIP_AKA_OPLEN];\n    pj_uint8_t amf[PJSIP_AKA_AMFLEN];\n    pj_uint8_t res[PJSIP_AKA_RESLEN];\n    pj_uint8_t ck[PJSIP_AKA_CKLEN];\n    pj_uint8_t ik[PJSIP_AKA_IKLEN];\n    pj_uint8_t ak[PJSIP_AKA_AKLEN];\n    pj_uint8_t sqn[PJSIP_AKA_SQNLEN];\n    pj_uint8_t xmac[PJSIP_AKA_MACLEN];\n    pjsip_cred_info aka_cred;\n    int i, len;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Check the algorithm is supported. */\n    if (chal->algorithm.slen==0 || pj_stricmp2(&chal->algorithm, \"md5\") == 0) {\n\t/*\n\t * A normal MD5 authentication is requested. Fallback to the usual\n\t * MD5 digest creation.\n\t */\n\tstatus = pjsip_auth_create_digest(&auth->response, &auth->nonce, \n\t\t\t         &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t         &auth->uri, &auth->realm, cred, method);\n\n\treturn status;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5) == 0) {\n\t/*\n\t * AKA version 1 is requested.\n\t */\n\taka_version = 1;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv2_MD5) == 0) {\n\t/*\n\t * AKA version 2 is requested.\n\t */\n\taka_version = 2;\n\n    } else {\n\t/* Unsupported algorithm */\n\treturn PJSIP_EINVALIDALGORITHM;\n    }\n\n    /* Decode nonce */\n    nonce_bin.slen = len = PJ_BASE64_TO_BASE256_LEN(chal->nonce.slen);\n    nonce_bin.ptr = pj_pool_alloc(pool, nonce_bin.slen + 1);\n    status = pj_base64_decode(&chal->nonce, (pj_uint8_t*)nonce_bin.ptr, &len);\n    nonce_bin.slen = len;\n    if (status != PJ_SUCCESS)\n\treturn PJSIP_EAUTHINNONCE;\n\n    if (nonce_bin.slen < PJSIP_AKA_RANDLEN + PJSIP_AKA_AUTNLEN)\n\treturn PJSIP_EAUTHINNONCE;\n\n    /* Get RAND, AUTN, and MAC */\n    chal_rand = (pj_uint8_t*)(nonce_bin.ptr + 0);\n    chal_sqnxoraka = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN);\n    chal_mac = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN + \n\t\t\t      PJSIP_AKA_SQNLEN + PJSIP_AKA_AMFLEN);\n\n    /* Copy k. op, and amf */\n    pj_bzero(k, sizeof(k));\n    pj_bzero(op, sizeof(op));\n    pj_bzero(amf, sizeof(amf));\n\n    if (cred->ext.aka.k.slen)\n\tpj_memcpy(k, cred->ext.aka.k.ptr, cred->ext.aka.k.slen);\n    if (cred->ext.aka.op.slen)\n\tpj_memcpy(op, cred->ext.aka.op.ptr, cred->ext.aka.op.slen);\n    if (cred->ext.aka.amf.slen)\n\tpj_memcpy(amf, cred->ext.aka.amf.ptr, cred->ext.aka.amf.slen);\n\n    /* Given key K and random challenge RAND, compute response RES,\n     * confidentiality key CK, integrity key IK and anonymity key AK.\n     */\n    f2345(k, chal_rand, res, ck, ik, ak, op);\n\n    /* Compute sequence number SQN */\n    for (i=0; i<PJSIP_AKA_SQNLEN; ++i)\n\tsqn[i] = (pj_uint8_t) (chal_sqnxoraka[i] ^ ak[i]);\n\n    /* Verify MAC in the challenge */\n    /* Compute XMAC */\n    f1(k, chal_rand, sqn, amf, xmac, op);\n\n    if (pj_memcmp(chal_mac, xmac, PJSIP_AKA_MACLEN) != 0) {\n\treturn PJSIP_EAUTHINNONCE;\n    }\n\n    /* Build a temporary credential info to create MD5 digest, using\n     * \"res\" as the password. \n     */\n    pj_memcpy(&aka_cred, cred, sizeof(aka_cred));\n    aka_cred.data_type = PJSIP_CRED_DATA_PLAIN_PASSWD;\n\n    /* Create a response */\n    if (aka_version == 1) {\n\t/*\n\t * For AKAv1, the password is RES\n\t */\n\taka_cred.data.ptr = (char*)res;\n\taka_cred.data.slen = PJSIP_AKA_RESLEN;\n\n\tstatus = pjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\t\n\n    } else if (aka_version == 2) {\n\n\t/*\n\t * For AKAv2, password is base64 encoded [1] parameters:\n\t *    PRF(RES||IK||CK,\"http-digest-akav2-password\")\n\t *\n\t * The pseudo-random function (PRF) is HMAC-MD5 in this case.\n\t */\n\n\tpj_str_t resikck;\n\tconst pj_str_t AKAv2_Passwd = { \"http-digest-akav2-password\", 26 };\n\tpj_uint8_t hmac_digest[16];\n\tchar tmp_buf[48];\n\tint hmac64_len;\n\n\tresikck.slen = PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN + PJSIP_AKA_CKLEN;\n\tpj_assert(resikck.slen <= PJ_ARRAY_SIZE(tmp_buf));\n\tresikck.ptr = tmp_buf;\n\tpj_memcpy(resikck.ptr + 0, res, PJSIP_AKA_RESLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN, ik, PJSIP_AKA_IKLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN,\n\t          ck, PJSIP_AKA_CKLEN);\n\n\tpj_hmac_md5((const pj_uint8_t*)AKAv2_Passwd.ptr, AKAv2_Passwd.slen,\n\t            (const pj_uint8_t*)resikck.ptr, resikck.slen,\n\t            hmac_digest);\n\n\taka_cred.data.slen = hmac64_len =\n\t\tPJ_BASE256_TO_BASE64_LEN(PJ_ARRAY_SIZE(hmac_digest));\n\tpj_assert(aka_cred.data.slen+1 <= PJ_ARRAY_SIZE(tmp_buf));\n\taka_cred.data.ptr = tmp_buf;\n\tpj_base64_encode(hmac_digest, PJ_ARRAY_SIZE(hmac_digest),\n\t                 aka_cred.data.ptr, &len);\n\taka_cred.data.slen = hmac64_len;\n\n\tstatus = pjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n\n    } else {\n\tpj_assert(!\"Bug!\");\n\treturn PJ_EBUG;\n    }\n\n    /* Done */\n    return status;\n}\n\n\n#endif\t/* PJSIP_HAS_DIGEST_AKA_AUTH */\n\n", "/* $Id$ */\n/*\n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <pjsip/sip_auth.h>\n#include <pjsip/sip_auth_parser.h>\t/* just to get pjsip_DIGEST_STR */\n#include <pjsip/sip_auth_aka.h>\n#include <pjsip/sip_transport.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_util.h>\n#include <pjlib-util/md5.h>\n#include <pj/log.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/guid.h>\n#include <pj/assert.h>\n#include <pj/ctype.h>\n\n\n#if PJ_HAS_SSL_SOCK && PJ_SSL_SOCK_IMP==PJ_SSL_SOCK_IMP_OPENSSL\n#  if !defined(PJSIP_AUTH_HAS_DIGEST_SHA256)\n#    define PJSIP_AUTH_HAS_DIGEST_SHA256    1\n#  endif\n#else\n#  undef  PJSIP_AUTH_HAS_DIGEST_SHA256\n#  define PJSIP_AUTH_HAS_DIGEST_SHA256\t    0\n#endif\n\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n#  include <openssl/sha.h>\n#  ifdef _MSC_VER\n#    include <openssl/opensslv.h>\n#    if OPENSSL_VERSION_NUMBER >= 0x10100000L\n#      pragma comment(lib, \"libcrypto\")\n#    else\n#      pragma comment(lib, \"libeay32\")\n#      pragma comment(lib, \"ssleay32\")\n#    endif\n#  endif\n#endif\n\n/* A macro just to get rid of type mismatch between char and unsigned char */\n#define MD5_APPEND(pms,buf,len)\tpj_md5_update(pms, (const pj_uint8_t*)buf, \\\n\t\t\t\t\t      (unsigned)len)\n\n/* Logging. */\n#define THIS_FILE   \"sip_auth_client.c\"\n#if 0\n#  define AUTH_TRACE_(expr)  PJ_LOG(3, expr)\n#else\n#  define AUTH_TRACE_(expr)\n#endif\n\n#define PASSWD_MASK\t    0x000F\n#define EXT_MASK\t    0x00F0\n\n\nstatic void dup_bin(pj_pool_t *pool, pj_str_t *dst, const pj_str_t *src)\n{\n    dst->slen = src->slen;\n\n    if (dst->slen) {\n\tdst->ptr = (char*) pj_pool_alloc(pool, src->slen);\n\tpj_memcpy(dst->ptr, src->ptr, src->slen);\n    } else {\n\tdst->ptr = NULL;\n    }\n}\n\nPJ_DEF(void) pjsip_cred_info_dup(pj_pool_t *pool,\n\t\t\t\t pjsip_cred_info *dst,\n\t\t\t\t const pjsip_cred_info *src)\n{\n    pj_memcpy(dst, src, sizeof(pjsip_cred_info));\n\n    pj_strdup_with_null(pool, &dst->realm, &src->realm);\n    pj_strdup_with_null(pool, &dst->scheme, &src->scheme);\n    pj_strdup_with_null(pool, &dst->username, &src->username);\n    pj_strdup_with_null(pool, &dst->data, &src->data);\n\n    if ((dst->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\tdup_bin(pool, &dst->ext.aka.k, &src->ext.aka.k);\n\tdup_bin(pool, &dst->ext.aka.op, &src->ext.aka.op);\n\tdup_bin(pool, &dst->ext.aka.amf, &src->ext.aka.amf);\n    }\n}\n\n\nPJ_DEF(int) pjsip_cred_info_cmp(const pjsip_cred_info *cred1,\n\t\t\t\tconst pjsip_cred_info *cred2)\n{\n    int result;\n\n    result = pj_strcmp(&cred1->realm, &cred2->realm);\n    if (result) goto on_return;\n    result = pj_strcmp(&cred1->scheme, &cred2->scheme);\n    if (result) goto on_return;\n    result = pj_strcmp(&cred1->username, &cred2->username);\n    if (result) goto on_return;\n    result = pj_strcmp(&cred1->data, &cred2->data);\n    if (result) goto on_return;\n    result = (cred1->data_type != cred2->data_type);\n    if (result) goto on_return;\n\n    if ((cred1->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\tresult = pj_strcmp(&cred1->ext.aka.k, &cred2->ext.aka.k);\n\tif (result) goto on_return;\n\tresult = pj_strcmp(&cred1->ext.aka.op, &cred2->ext.aka.op);\n\tif (result) goto on_return;\n\tresult = pj_strcmp(&cred1->ext.aka.amf, &cred2->ext.aka.amf);\n\tif (result) goto on_return;\n    }\n\non_return:\n    return result;\n}\n\nPJ_DEF(void) pjsip_auth_clt_pref_dup( pj_pool_t *pool,\n\t\t\t\t      pjsip_auth_clt_pref *dst,\n\t\t\t\t      const pjsip_auth_clt_pref *src)\n{\n    pj_memcpy(dst, src, sizeof(pjsip_auth_clt_pref));\n    pj_strdup_with_null(pool, &dst->algorithm, &src->algorithm);\n}\n\n\n/* Transform digest to string.\n * output must be at least PJSIP_MD5STRLEN+1 bytes.\n *\n * NOTE: THE OUTPUT STRING IS NOT NULL TERMINATED!\n */\nstatic void digestNtoStr(const unsigned char digest[], int n, char *output)\n{\n    int i;\n    for (i = 0; i<n; ++i) {\n        pj_val_to_hex_digit(digest[i], output);\n        output += 2;\n    }\n}\n\n\n/*\n * Create response digest based on the parameters and store the\n * digest ASCII in 'result'.\n */\nPJ_DEF(pj_status_t) pjsip_auth_create_digest( pj_str_t *result,\n\t\t\t\t\t      const pj_str_t *nonce,\n\t\t\t\t\t      const pj_str_t *nc,\n\t\t\t\t\t      const pj_str_t *cnonce,\n\t\t\t\t\t      const pj_str_t *qop,\n\t\t\t\t\t      const pj_str_t *uri,\n\t\t\t\t\t      const pj_str_t *realm,\n\t\t\t\t\t      const pjsip_cred_info *cred_info,\n\t\t\t\t\t      const pj_str_t *method)\n{\n    char ha1[PJSIP_MD5STRLEN];\n    char ha2[PJSIP_MD5STRLEN];\n    unsigned char digest[16];\n    pj_md5_context pms;\n\n    pj_assert(result->slen >= PJSIP_MD5STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n    if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_PLAIN_PASSWD) {\n\t/***\n\t *** ha1 = MD5(username \":\" realm \":\" password)\n\t ***/\n\tpj_md5_init(&pms);\n\tMD5_APPEND( &pms, cred_info->username.ptr, cred_info->username.slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, realm->ptr, realm->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tpj_md5_final(&pms, digest);\n\n\tdigestNtoStr(digest, 16, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n\tif (cred_info->data.slen != 32) {\n\t    pj_assert(!\"Invalid cred_info data length\");\n\t    pj_bzero(result->ptr, result->slen);\n\t    result->slen = 0;\n\t    return PJ_EINVAL;\n\t}\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n\tpj_bzero(result->ptr, result->slen);\n\tresult->slen = 0;\n\treturn PJ_EINVAL;\n    }\n\n    AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n\n    /***\n     *** ha2 = MD5(method \":\" req_uri)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, method->ptr, method->slen);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, uri->ptr, uri->slen);\n    pj_md5_final(&pms, digest);\n    digestNtoStr(digest, 16, ha2);\n\n    AUTH_TRACE_((THIS_FILE, \"  ha2=%.32s\", ha2));\n\n    /***\n     *** When qop is not used:\n     ***    response = MD5(ha1 \":\" nonce \":\" ha2)\n     ***\n     *** When qop=auth is used:\n     ***    response = MD5(ha1 \":\" nonce \":\" nc \":\" cnonce \":\" qop \":\" ha2)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, ha1, PJSIP_MD5STRLEN);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, nonce->ptr, nonce->slen);\n    if (qop && qop->slen != 0) {\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, nc->ptr, nc->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cnonce->ptr, cnonce->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, qop->ptr, qop->slen);\n    }\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, ha2, PJSIP_MD5STRLEN);\n\n    /* This is the final response digest. */\n    pj_md5_final(&pms, digest);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_MD5STRLEN;\n    digestNtoStr(digest, 16, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create response SHA-256 digest based on the parameters and store the\n * digest ASCII in 'result'.\n */\nPJ_DEF(pj_status_t) pjsip_auth_create_digestSHA256(pj_str_t *result,\n\t\t\t\t\t    const pj_str_t *nonce,\n\t\t\t\t\t    const pj_str_t *nc,\n\t\t\t\t\t    const pj_str_t *cnonce,\n\t\t\t\t\t    const pj_str_t *qop,\n\t\t\t\t\t    const pj_str_t *uri,\n\t\t\t\t\t    const pj_str_t *realm,\n\t\t\t\t\t    const pjsip_cred_info *cred_info,\n\t\t\t\t\t    const pj_str_t *method)\n{\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n\n    char ha1[PJSIP_SHA256STRLEN];\n    char ha2[PJSIP_SHA256STRLEN];\n    unsigned char digest[32];\n    SHA256_CTX pms;\n\n    pj_assert(result->slen >= PJSIP_SHA256STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n    if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_PLAIN_PASSWD)\n    {\n\t/***\n\t *** ha1 = SHA256(username \":\" realm \":\" password)\n\t ***/\n\tSHA256_Init(&pms);\n\tSHA256_Update( &pms, cred_info->username.ptr,\n\t\t       cred_info->username.slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, realm->ptr, realm->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tSHA256_Final(digest, &pms);\n\n\tdigestNtoStr(digest, 32, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST)\n    {\n\tif (cred_info->data.slen != 64) {\n\t    pj_assert(!\"Invalid cred_info data length\");\n\t    pj_bzero(result->ptr, result->slen);\n\t    result->slen = 0;\n\t    return PJ_EINVAL;\n\t}\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n\tpj_bzero(result->ptr, result->slen);\n\tresult->slen = 0;\n\treturn PJ_EINVAL;\n    }\n\n    AUTH_TRACE_((THIS_FILE, \" ha1=%.64s\", ha1));\n\n    /***\n     *** ha2 = SHA256(method \":\" req_uri)\n     ***/\n    SHA256_Init(&pms);\n    SHA256_Update( &pms, method->ptr, method->slen);\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, uri->ptr, uri->slen);\n    SHA256_Final( digest, &pms);\n    digestNtoStr(digest, 32, ha2);\n\n    AUTH_TRACE_((THIS_FILE, \" ha2=%.64s\", ha2));\n\n    /***\n     *** When qop is not used:\n     ***   response = SHA256(ha1 \":\" nonce \":\" ha2)\n     ***\n     *** When qop=auth is used:\n     ***   response = SHA256(ha1 \":\" nonce \":\" nc \":\" cnonce \":\" qop \":\" ha2)\n     ***/\n    SHA256_Init(&pms);\n    SHA256_Update( &pms, ha1, PJSIP_SHA256STRLEN);\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, nonce->ptr, nonce->slen);\n    if (qop && qop->slen != 0) {\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, nc->ptr, nc->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, cnonce->ptr, cnonce->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, qop->ptr, qop->slen);\n    }\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, ha2, PJSIP_SHA256STRLEN);\n\n    /* This is the final response digest. */\n    SHA256_Final(digest, &pms);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_SHA256STRLEN;\n    digestNtoStr(digest, 32, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \" digest=%.64s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n\n#else\n    PJ_UNUSED_ARG(result);\n    PJ_UNUSED_ARG(nonce);\n    PJ_UNUSED_ARG(nc);\n    PJ_UNUSED_ARG(cnonce);\n    PJ_UNUSED_ARG(qop);\n    PJ_UNUSED_ARG(uri);\n    PJ_UNUSED_ARG(realm);\n    PJ_UNUSED_ARG(cred_info);\n    PJ_UNUSED_ARG(method);\n#endif\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Finds out if qop offer contains \"auth\" token.\n */\nstatic pj_bool_t has_auth_qop( pj_pool_t *pool, const pj_str_t *qop_offer)\n{\n    pj_str_t qop;\n    char *p;\n\n    pj_strdup_with_null( pool, &qop, qop_offer);\n    p = qop.ptr;\n    while (*p) {\n\t*p = (char)pj_tolower(*p);\n\t++p;\n    }\n\n    p = qop.ptr;\n    while (*p) {\n\tif (*p=='a' && *(p+1)=='u' && *(p+2)=='t' && *(p+3)=='h') {\n\t    int e = *(p+4);\n\t    if (e=='\"' || e==',' || e==0)\n\t\treturn PJ_TRUE;\n\t    else\n\t\tp += 4;\n\t} else {\n\t    ++p;\n\t}\n    }\n\n    return PJ_FALSE;\n}\n\n/*\n * Generate response digest.\n * Most of the parameters to generate the digest (i.e. username, realm, uri,\n * and nonce) are expected to be in the credential. Additional parameters (i.e.\n * password and method param) should be supplied in the argument.\n *\n * The resulting digest will be stored in cred->response.\n * The pool is used to allocate 32 bytes to store the digest in cred->response.\n */\nstatic pj_status_t respond_digest( pj_pool_t *pool,\n\t\t\t\t   pjsip_digest_credential *cred,\n\t\t\t\t   const pjsip_digest_challenge *chal,\n\t\t\t\t   const pj_str_t *uri,\n\t\t\t\t   const pjsip_cred_info *cred_info,\n\t\t\t\t   const pj_str_t *cnonce,\n\t\t\t\t   pj_uint32_t nc,\n\t\t\t\t   const pj_str_t *method)\n{\n    const pj_str_t pjsip_AKAv1_MD5_STR = { \"AKAv1-MD5\", 9 };\n    pj_bool_t algo_sha256 = PJ_FALSE;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Check if algo is sha256 */\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n    algo_sha256 = (pj_stricmp(&chal->algorithm, &pjsip_SHA256_STR)==0);\n#endif\n\n    /* Check algorithm is supported. We support MD5, AKAv1-MD5, and SHA256. */\n    if (chal->algorithm.slen==0 ||\n        (algo_sha256 ||\n\t pj_stricmp(&chal->algorithm, &pjsip_MD5_STR)==0 ||\n         pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5_STR)==0))\n    {\n\tPJ_LOG(4,(THIS_FILE, \"Digest algorithm is \\\"%.*s\\\"\",\n\t\t  chal->algorithm.slen, chal->algorithm.ptr));\n    }\n    else {\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported digest algorithm \\\"%.*s\\\"\",\n\t\t  chal->algorithm.slen, chal->algorithm.ptr));\n\treturn PJSIP_EINVALIDALGORITHM;\n    }\n\n    /* Build digest credential from arguments. */\n    pj_strdup(pool, &cred->username, &cred_info->username);\n    pj_strdup(pool, &cred->realm, &chal->realm);\n    pj_strdup(pool, &cred->nonce, &chal->nonce);\n    pj_strdup(pool, &cred->uri, uri);\n    pj_strdup(pool, &cred->algorithm, &chal->algorithm);\n    pj_strdup(pool, &cred->opaque, &chal->opaque);\n\n    /* Allocate memory. */\n    cred->response.slen = algo_sha256? PJSIP_SHA256STRLEN : PJSIP_MD5STRLEN;\n    cred->response.ptr = (char*) pj_pool_alloc(pool, cred->response.slen);\n\n    if (chal->qop.slen == 0) {\n\t/* Server doesn't require quality of protection. */\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tstatus = pjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    } else {\n\t\tstatus = pjsip_auth_create_digest( &cred->response, \n\t\t\t\t\t  &cred->nonce, NULL, NULL, NULL, uri, \n\t\t\t\t\t  &chal->realm, cred_info, method);\n\t    }\n\t}\n\n    } else if (has_auth_qop(pool, &chal->qop)) {\n\t/* Server requires quality of protection.\n\t * We respond with selecting \"qop=auth\" protection.\n\t */\n\tcred->qop = pjsip_AUTH_STR;\n\tcred->nc.ptr = (char*) pj_pool_alloc(pool, 16);\n\tcred->nc.slen = pj_ansi_snprintf(cred->nc.ptr, 16, \"%08u\", nc);\n\n\tif (cnonce && cnonce->slen) {\n\t    pj_strdup(pool, &cred->cnonce, cnonce);\n\t} else {\n\t    pj_str_t dummy_cnonce = { \"b39971\", 6};\n\t    pj_strdup(pool, &cred->cnonce, &dummy_cnonce);\n\t}\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tstatus = pjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    } else {\n\t\tstatus = pjsip_auth_create_digest( &cred->response, \n\t\t\t\t\t  &cred->nonce, &cred->nc, \n\t\t\t\t          &cred->cnonce, &pjsip_AUTH_STR, \n\t\t\t\t\t  uri, &chal->realm, \n\t\t\t\t\t  cred_info, method);\n\t    }\n\t}\n\n    } else {\n\t/* Server requires quality protection that we don't support. */\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported qop offer %.*s\",\n\t\t  chal->qop.slen, chal->qop.ptr));\n\treturn PJSIP_EINVALIDQOP;\n    }\n\n    return status;\n}\n\n#if defined(PJSIP_AUTH_QOP_SUPPORT) && PJSIP_AUTH_QOP_SUPPORT!=0\n/*\n * Update authentication session with a challenge.\n */\nstatic void update_digest_session( pjsip_cached_auth *cached_auth,\n\t\t\t\t   const pjsip_www_authenticate_hdr *hdr )\n{\n    if (hdr->challenge.digest.qop.slen == 0) {\n#if PJSIP_AUTH_AUTO_SEND_NEXT!=0\n\tif (!cached_auth->last_chal || pj_stricmp2(&hdr->scheme, \"digest\")) {\n\t    cached_auth->last_chal = (pjsip_www_authenticate_hdr*)\n\t\t\t\t     pjsip_hdr_clone(cached_auth->pool, hdr);\n\t} else {\n\t    /* Only update if the new challenge is \"significantly different\"\n\t     * than the one in the cache, to reduce memory usage.\n\t     */\n\t    const pjsip_digest_challenge *d1 =\n\t\t\t&cached_auth->last_chal->challenge.digest;\n\t    const pjsip_digest_challenge *d2 = &hdr->challenge.digest;\n\n\t    if (pj_strcmp(&d1->domain, &d2->domain) ||\n\t\tpj_strcmp(&d1->realm, &d2->realm) ||\n\t\tpj_strcmp(&d1->nonce, &d2->nonce) ||\n\t\tpj_strcmp(&d1->opaque, &d2->opaque) ||\n\t\tpj_strcmp(&d1->algorithm, &d2->algorithm) ||\n\t\tpj_strcmp(&d1->qop, &d2->qop))\n\t    {\n\t\tcached_auth->last_chal = (pjsip_www_authenticate_hdr*)\n\t\t\t\t       pjsip_hdr_clone(cached_auth->pool, hdr);\n\t    }\n\t}\n#endif\n\treturn;\n    }\n\n    /* Initialize cnonce and qop if not present. */\n    if (cached_auth->cnonce.slen == 0) {\n\t/* Save the whole challenge */\n\tcached_auth->last_chal = (pjsip_www_authenticate_hdr*)\n\t\t\t\t pjsip_hdr_clone(cached_auth->pool, hdr);\n\n\t/* Create cnonce */\n\tpj_create_unique_string( cached_auth->pool, &cached_auth->cnonce );\n#if defined(PJSIP_AUTH_CNONCE_USE_DIGITS_ONLY) && \\\n    PJSIP_AUTH_CNONCE_USE_DIGITS_ONLY!=0\n\tif (pj_strchr(&cached_auth->cnonce, '-')) {\n\t    /* remove hyphen character. */\n\t    pj_size_t w, r, len = pj_strlen(&cached_auth->cnonce);\n\t    char *s = cached_auth->cnonce.ptr;\n\n\t    w = r = 0;\n\t    for (; r < len; r++) {\n\t\tif (s[r] != '-')\n\t\t    s[w++] = s[r];\n\t    }\n\t    s[w] = '\\0';\n\t    cached_auth->cnonce.slen = w;\n\t}\n#endif\n\n\t/* Initialize nonce-count */\n\tcached_auth->nc = 1;\n\n\t/* Save realm. */\n\t/* Note: allow empty realm (http://trac.pjsip.org/repos/ticket/1061)\n\tpj_assert(cached_auth->realm.slen != 0);\n\t*/\n\tif (cached_auth->realm.slen == 0) {\n\t    pj_strdup(cached_auth->pool, &cached_auth->realm,\n\t\t      &hdr->challenge.digest.realm);\n\t}\n\n    } else {\n\t/* Update last_nonce and nonce-count */\n\tif (!pj_strcmp(&hdr->challenge.digest.nonce,\n\t\t       &cached_auth->last_chal->challenge.digest.nonce))\n\t{\n\t    /* Same nonce, increment nonce-count */\n\t    ++cached_auth->nc;\n\t} else {\n\t    /* Server gives new nonce. */\n\t    pj_strdup(cached_auth->pool, \n\t\t      &cached_auth->last_chal->challenge.digest.nonce,\n\t\t      &hdr->challenge.digest.nonce);\n\t    /* Has the opaque changed? */\n\t    if (pj_strcmp(&cached_auth->last_chal->challenge.digest.opaque,\n\t\t\t  &hdr->challenge.digest.opaque))\n\t    {\n\t\tpj_strdup(cached_auth->pool,\n\t\t\t  &cached_auth->last_chal->challenge.digest.opaque,\n\t\t\t  &hdr->challenge.digest.opaque);\n\t    }\n\t    cached_auth->nc = 1;\n\t}\n    }\n}\n#endif\t/* PJSIP_AUTH_QOP_SUPPORT */\n\n\n/* Find cached authentication in the list for the specified realm. */\nstatic pjsip_cached_auth *find_cached_auth( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t    const pj_str_t *realm )\n{\n    pjsip_cached_auth *auth = sess->cached_auth.next;\n    while (auth != &sess->cached_auth) {\n\tif (pj_stricmp(&auth->realm, realm) == 0)\n\t    return auth;\n\tauth = auth->next;\n    }\n\n    return NULL;\n}\n\n/* Find credential to use for the specified realm and auth scheme. */\nstatic const pjsip_cred_info* auth_find_cred( const pjsip_auth_clt_sess *sess,\n\t\t\t\t\t      const pj_str_t *realm,\n\t\t\t\t\t      const pj_str_t *auth_scheme)\n{\n    unsigned i;\n    int wildcard = -1;\n\n    PJ_UNUSED_ARG(auth_scheme);\n\n    for (i=0; i<sess->cred_cnt; ++i) {\n\tif (pj_stricmp(&sess->cred_info[i].realm, realm) == 0)\n\t    return &sess->cred_info[i];\n\telse if (sess->cred_info[i].realm.slen == 1 &&\n\t\t sess->cred_info[i].realm.ptr[0] == '*')\n\t{\n\t    wildcard = i;\n\t}\n    }\n\n    /* No matching realm. See if we have credential with wildcard ('*')\n     * as the realm.\n     */\n    if (wildcard != -1)\n\treturn &sess->cred_info[wildcard];\n\n    /* Nothing is suitable */\n    return NULL;\n}\n\n\n/* Init client session. */\nPJ_DEF(pj_status_t) pjsip_auth_clt_init(  pjsip_auth_clt_sess *sess,\n\t\t\t\t\t  pjsip_endpoint *endpt,\n\t\t\t\t\t  pj_pool_t *pool,\n\t\t\t\t\t  unsigned options)\n{\n    PJ_ASSERT_RETURN(sess && endpt && pool && (options==0), PJ_EINVAL);\n\n    sess->pool = pool;\n    sess->endpt = endpt;\n    sess->cred_cnt = 0;\n    sess->cred_info = NULL;\n    pj_list_init(&sess->cached_auth);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Deinit client session. */\nPJ_DEF(pj_status_t) pjsip_auth_clt_deinit(pjsip_auth_clt_sess *sess)\n{\n    pjsip_cached_auth *auth;\n    \n    PJ_ASSERT_RETURN(sess && sess->endpt, PJ_EINVAL);\n    \n    auth = sess->cached_auth.next;\n    while (auth != &sess->cached_auth) {\n\tpjsip_endpt_release_pool(sess->endpt, auth->pool);\n\tauth = auth->next;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Clone session. */\nPJ_DEF(pj_status_t) pjsip_auth_clt_clone( pj_pool_t *pool,\n\t\t\t\t\t  pjsip_auth_clt_sess *sess,\n\t\t\t\t\t  const pjsip_auth_clt_sess *rhs )\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && sess && rhs, PJ_EINVAL);\n\n    pjsip_auth_clt_init(sess, (pjsip_endpoint*)rhs->endpt, pool, 0);\n\n    sess->cred_cnt = rhs->cred_cnt;\n    sess->cred_info = (pjsip_cred_info*)\n    \t\t      pj_pool_alloc(pool,\n\t\t\t\t    sess->cred_cnt*sizeof(pjsip_cred_info));\n    for (i=0; i<rhs->cred_cnt; ++i) {\n\tpj_strdup(pool, &sess->cred_info[i].realm, &rhs->cred_info[i].realm);\n\tpj_strdup(pool, &sess->cred_info[i].scheme, &rhs->cred_info[i].scheme);\n\tpj_strdup(pool, &sess->cred_info[i].username,\n\t\t  &rhs->cred_info[i].username);\n\tsess->cred_info[i].data_type = rhs->cred_info[i].data_type;\n\tpj_strdup(pool, &sess->cred_info[i].data, &rhs->cred_info[i].data);\n    }\n\n    /* TODO note:\n     * Cloning the full authentication client is quite a big task.\n     * We do only the necessary bits here, i.e. cloning the credentials.\n     * The drawback of this basic approach is, a forked dialog will have to\n     * re-authenticate itself on the next request because it has lost the\n     * cached authentication headers.\n     */\n    PJ_TODO(FULL_CLONE_OF_AUTH_CLIENT_SESSION);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Set client credentials. */\nPJ_DEF(pj_status_t) pjsip_auth_clt_set_credentials( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t\t    int cred_cnt,\n\t\t\t\t\t\t    const pjsip_cred_info *c)\n{\n    PJ_ASSERT_RETURN(sess && c, PJ_EINVAL);\n\n    if (cred_cnt == 0) {\n\tsess->cred_cnt = 0;\n    } else {\n\tint i;\n\tsess->cred_info = (pjsip_cred_info*)\n\t\t\t  pj_pool_alloc(sess->pool, cred_cnt * sizeof(*c));\n\tfor (i=0; i<cred_cnt; ++i) {\n\t    sess->cred_info[i].data_type = c[i].data_type;\n\n\t    /* When data_type is PJSIP_CRED_DATA_EXT_AKA,\n\t     * callback must be specified.\n\t     */\n\t    if ((c[i].data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\n#if !PJSIP_HAS_DIGEST_AKA_AUTH\n\t\tif (!PJSIP_HAS_DIGEST_AKA_AUTH) {\n\t\t    pj_assert(!\"PJSIP_HAS_DIGEST_AKA_AUTH is not enabled\");\n\t\t    return PJSIP_EAUTHINAKACRED;\n\t\t}\n#endif\n\n\t\t/* Callback must be specified */\n\t\tPJ_ASSERT_RETURN(c[i].ext.aka.cb != NULL, PJ_EINVAL);\n\n\t\t/* Verify K len */\n\t\tPJ_ASSERT_RETURN(c[i].ext.aka.k.slen <= PJSIP_AKA_KLEN,\n\t\t\t\t PJSIP_EAUTHINAKACRED);\n\n\t\t/* Verify OP len */\n\t\tPJ_ASSERT_RETURN(c[i].ext.aka.op.slen <= PJSIP_AKA_OPLEN,\n\t\t\t\t PJSIP_EAUTHINAKACRED);\n\n\t\t/* Verify AMF len */\n\t\tPJ_ASSERT_RETURN(c[i].ext.aka.amf.slen <= PJSIP_AKA_AMFLEN,\n\t\t\t\t PJSIP_EAUTHINAKACRED);\n\n\t\tsess->cred_info[i].ext.aka.cb = c[i].ext.aka.cb;\n\t\tpj_strdup(sess->pool, &sess->cred_info[i].ext.aka.k,\n\t\t\t  &c[i].ext.aka.k);\n\t\tpj_strdup(sess->pool, &sess->cred_info[i].ext.aka.op,\n\t\t\t  &c[i].ext.aka.op);\n\t\tpj_strdup(sess->pool, &sess->cred_info[i].ext.aka.amf,\n\t\t\t  &c[i].ext.aka.amf);\n\t    }\n\n\t    pj_strdup(sess->pool, &sess->cred_info[i].scheme, &c[i].scheme);\n\t    pj_strdup(sess->pool, &sess->cred_info[i].realm, &c[i].realm);\n\t    pj_strdup(sess->pool, &sess->cred_info[i].username, &c[i].username);\n\t    pj_strdup(sess->pool, &sess->cred_info[i].data, &c[i].data);\n\t}\n\tsess->cred_cnt = cred_cnt;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Set the preference for the client authentication session.\n */\nPJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,\n\t\t\t\t\t     const pjsip_auth_clt_pref *p)\n{\n    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);\n\n    pj_memcpy(&sess->pref, p, sizeof(*p));\n    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);\n    //if (sess->pref.algorithm.slen == 0)\n    //\tsess->pref.algorithm = pj_str(\"MD5\");\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get the preference for the client authentication session.\n */\nPJ_DEF(pj_status_t) pjsip_auth_clt_get_prefs(pjsip_auth_clt_sess *sess,\n\t\t\t\t\t     pjsip_auth_clt_pref *p)\n{\n    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);\n\n    pj_memcpy(p, &sess->pref, sizeof(pjsip_auth_clt_pref));\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create Authorization/Proxy-Authorization response header based on the challege\n * in WWW-Authenticate/Proxy-Authenticate header.\n */\nstatic pj_status_t auth_respond( pj_pool_t *req_pool,\n\t\t\t\t const pjsip_www_authenticate_hdr *hdr,\n\t\t\t\t const pjsip_uri *uri,\n\t\t\t\t const pjsip_cred_info *cred_info,\n\t\t\t\t const pjsip_method *method,\n\t\t\t\t pj_pool_t *sess_pool,\n\t\t\t\t pjsip_cached_auth *cached_auth,\n\t\t\t\t pjsip_authorization_hdr **p_h_auth)\n{\n    pjsip_authorization_hdr *hauth;\n    char tmp[PJSIP_MAX_URL_SIZE];\n    pj_str_t uri_str;\n    pj_pool_t *pool;\n    pj_status_t status;\n\n    /* Verify arguments. */\n    PJ_ASSERT_RETURN(req_pool && hdr && uri && cred_info && method &&\n\t\t     sess_pool && cached_auth && p_h_auth, PJ_EINVAL);\n\n    /* Print URL in the original request. */\n    uri_str.ptr = tmp;\n    uri_str.slen = pjsip_uri_print(PJSIP_URI_IN_REQ_URI, uri, tmp,sizeof(tmp));\n    if (uri_str.slen < 1) {\n\treturn PJSIP_EURITOOLONG;\n    }\n\n#   if (PJSIP_AUTH_HEADER_CACHING)\n    {\n\tpool = sess_pool;\n\tPJ_UNUSED_ARG(req_pool);\n    }\n#   else\n    {\n\tpool = req_pool;\n\tPJ_UNUSED_ARG(sess_pool);\n    }\n#   endif\n\n    if (hdr->type == PJSIP_H_WWW_AUTHENTICATE)\n\thauth = pjsip_authorization_hdr_create(pool);\n    else if (hdr->type == PJSIP_H_PROXY_AUTHENTICATE)\n\thauth = pjsip_proxy_authorization_hdr_create(pool);\n    else {\n\treturn PJSIP_EINVALIDHDR;\n    }\n\n    /* Only support digest scheme at the moment. */\n    if (!pj_stricmp(&hdr->scheme, &pjsip_DIGEST_STR)) {\n\tpj_str_t *cnonce = NULL;\n\tpj_uint32_t nc = 1;\n\n\t/* Update the session (nonce-count etc) if required. */\n#\tif PJSIP_AUTH_QOP_SUPPORT\n\t{\n\t    if (cached_auth) {\n\t\tupdate_digest_session( cached_auth, hdr );\n\n\t\tcnonce = &cached_auth->cnonce;\n\t\tnc = cached_auth->nc;\n\t    }\n\t}\n#\tendif\t/* PJSIP_AUTH_QOP_SUPPORT */\n\n\thauth->scheme = pjsip_DIGEST_STR;\n\tstatus = respond_digest( pool, &hauth->credential.digest,\n\t\t\t\t &hdr->challenge.digest, &uri_str, cred_info,\n\t\t\t\t cnonce, nc, &method->name);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\n\t/* Set qop type in auth session the first time only. */\n\tif (hdr->challenge.digest.qop.slen != 0 && cached_auth) {\n\t    if (cached_auth->qop_value == PJSIP_AUTH_QOP_NONE) {\n\t\tpj_str_t *qop_val = &hauth->credential.digest.qop;\n\t\tif (!pj_strcmp(qop_val, &pjsip_AUTH_STR)) {\n\t\t    cached_auth->qop_value = PJSIP_AUTH_QOP_AUTH;\n\t\t} else {\n\t\t    cached_auth->qop_value = PJSIP_AUTH_QOP_UNKNOWN;\n\t\t}\n\t    }\n\t}\n    } else {\n\treturn PJSIP_EINVALIDAUTHSCHEME;\n    }\n\n    /* Keep the new authorization header in the cache, only\n     * if no qop is not present.\n     */\n#   if PJSIP_AUTH_HEADER_CACHING\n    {\n\tif (hauth && cached_auth && cached_auth->qop_value == PJSIP_AUTH_QOP_NONE) {\n\t    pjsip_cached_auth_hdr *cached_hdr;\n\n\t    /* Delete old header with the same method. */\n\t    cached_hdr = cached_auth->cached_hdr.next;\n\t    while (cached_hdr != &cached_auth->cached_hdr) {\n\t\tif (pjsip_method_cmp(method, &cached_hdr->method)==0)\n\t\t    break;\n\t\tcached_hdr = cached_hdr->next;\n\t    }\n\n\t    /* Save the header to the list. */\n\t    if (cached_hdr != &cached_auth->cached_hdr) {\n\t\tcached_hdr->hdr = hauth;\n\t    } else {\n\t\tcached_hdr = pj_pool_alloc(pool, sizeof(*cached_hdr));\n\t\tpjsip_method_copy( pool, &cached_hdr->method, method);\n\t\tcached_hdr->hdr = hauth;\n\t\tpj_list_insert_before( &cached_auth->cached_hdr, cached_hdr );\n\t    }\n\t}\n\n#\tif defined(PJSIP_AUTH_AUTO_SEND_NEXT) && PJSIP_AUTH_AUTO_SEND_NEXT!=0\n\t    if (hdr != cached_auth->last_chal) {\n\t\tcached_auth->last_chal = pjsip_hdr_clone(sess_pool, hdr);\n\t    }\n#\tendif\n    }\n#   endif\n\n    *p_h_auth = hauth;\n    return PJ_SUCCESS;\n\n}\n\n\n#if defined(PJSIP_AUTH_AUTO_SEND_NEXT) && PJSIP_AUTH_AUTO_SEND_NEXT!=0\nstatic pj_status_t new_auth_for_req( pjsip_tx_data *tdata,\n\t\t\t\t     pjsip_auth_clt_sess *sess,\n\t\t\t\t     pjsip_cached_auth *auth,\n\t\t\t\t     pjsip_authorization_hdr **p_h_auth)\n{\n    const pjsip_cred_info *cred;\n    pjsip_authorization_hdr *hauth;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tdata && sess && auth, PJ_EINVAL);\n    PJ_ASSERT_RETURN(auth->last_chal != NULL, PJSIP_EAUTHNOPREVCHAL);\n\n    cred = auth_find_cred( sess, &auth->realm, &auth->last_chal->scheme );\n    if (!cred)\n\treturn PJSIP_ENOCREDENTIAL;\n\n    status = auth_respond( tdata->pool, auth->last_chal,\n\t\t\t   tdata->msg->line.req.uri,\n\t\t\t   cred, &tdata->msg->line.req.method,\n\t\t\t   sess->pool, auth, &hauth);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    pjsip_msg_add_hdr( tdata->msg, (pjsip_hdr*)hauth);\n\n    if (p_h_auth)\n\t*p_h_auth = hauth;\n\n    return PJ_SUCCESS;\n}\n#endif\n\n\n/* Find credential in list of (Proxy-)Authorization headers */\nstatic pjsip_authorization_hdr* get_header_for_realm(const pjsip_hdr *hdr_list,\n\t\t\t\t\t\t     const pj_str_t *realm)\n{\n    pjsip_authorization_hdr *h;\n\n    h = (pjsip_authorization_hdr*)hdr_list->next;\n    while (h != (pjsip_authorization_hdr*)hdr_list) {\n\tif (pj_stricmp(&h->credential.digest.realm, realm)==0)\n\t    return h;\n\th = h->next;\n    }\n\n    return NULL;\n}\n\n\n/* Initialize outgoing request. */\nPJ_DEF(pj_status_t) pjsip_auth_clt_init_req( pjsip_auth_clt_sess *sess,\n\t\t\t\t\t     pjsip_tx_data *tdata )\n{\n    const pjsip_method *method;\n    pjsip_cached_auth *auth;\n    pjsip_hdr added;\n\n    PJ_ASSERT_RETURN(sess && tdata, PJ_EINVAL);\n    PJ_ASSERT_RETURN(sess->pool, PJSIP_ENOTINITIALIZED);\n    PJ_ASSERT_RETURN(tdata->msg->type==PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* Init list */\n    pj_list_init(&added);\n\n    /* Get the method. */\n    method = &tdata->msg->line.req.method;\n    PJ_UNUSED_ARG(method); /* Warning about unused var caused by #if below */\n\n    auth = sess->cached_auth.next;\n    while (auth != &sess->cached_auth) {\n\t/* Reset stale counter */\n\tauth->stale_cnt = 0;\n\n\tif (auth->qop_value == PJSIP_AUTH_QOP_NONE) {\n#\t    if defined(PJSIP_AUTH_HEADER_CACHING) && \\\n\t       PJSIP_AUTH_HEADER_CACHING!=0\n\t    {\n\t\tpjsip_cached_auth_hdr *entry = auth->cached_hdr.next;\n\t\twhile (entry != &auth->cached_hdr) {\n\t\t    if (pjsip_method_cmp(&entry->method, method)==0) {\n\t\t\tpjsip_authorization_hdr *hauth;\n\t\t\thauth = pjsip_hdr_shallow_clone(tdata->pool, entry->hdr);\n\t\t\t//pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)hauth);\n\t\t\tpj_list_push_back(&added, hauth);\n\t\t\tbreak;\n\t\t    }\n\t\t    entry = entry->next;\n\t\t}\n\n#\t\tif defined(PJSIP_AUTH_AUTO_SEND_NEXT) && \\\n\t\t\t   PJSIP_AUTH_AUTO_SEND_NEXT!=0\n\t\t{\n\t\t    if (entry == &auth->cached_hdr)\n\t\t\tnew_auth_for_req( tdata, sess, auth, NULL);\n\t\t}\n#\t\tendif\n\n\t    }\n#\t    elif defined(PJSIP_AUTH_AUTO_SEND_NEXT) && \\\n\t\t PJSIP_AUTH_AUTO_SEND_NEXT!=0\n\t    {\n\t\tnew_auth_for_req( tdata, sess, auth, NULL);\n\t    }\n#\t    endif\n\n\t}\n#\tif defined(PJSIP_AUTH_QOP_SUPPORT) && \\\n\t   defined(PJSIP_AUTH_AUTO_SEND_NEXT) && \\\n\t   (PJSIP_AUTH_QOP_SUPPORT && PJSIP_AUTH_AUTO_SEND_NEXT)\n\telse if (auth->qop_value == PJSIP_AUTH_QOP_AUTH) {\n\t    /* For qop=\"auth\", we have to re-create the authorization header.\n\t     */\n\t    const pjsip_cred_info *cred;\n\t    pjsip_authorization_hdr *hauth;\n\t    pj_status_t status;\n\n\t    cred = auth_find_cred(sess, &auth->realm,\n\t\t\t\t  &auth->last_chal->scheme);\n\t    if (!cred) {\n\t\tauth = auth->next;\n\t\tcontinue;\n\t    }\n\n\t    status = auth_respond( tdata->pool, auth->last_chal,\n\t\t\t\t   tdata->msg->line.req.uri,\n\t\t\t\t   cred,\n\t\t\t\t   &tdata->msg->line.req.method,\n\t\t\t\t   sess->pool, auth, &hauth);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\n\t    //pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)hauth);\n\t    pj_list_push_back(&added, hauth);\n\t}\n#\tendif\t/* PJSIP_AUTH_QOP_SUPPORT && PJSIP_AUTH_AUTO_SEND_NEXT */\n\n\tauth = auth->next;\n    }\n\n    if (sess->pref.initial_auth == PJ_FALSE) {\n\tpjsip_hdr *h;\n\n\t/* Don't want to send initial empty Authorization header, so\n\t * just send whatever available in the list (maybe empty).\n\t */\n\n\th = added.next;\n\twhile (h != &added) {\n\t    pjsip_hdr *next = h->next;\n\t    pjsip_msg_add_hdr(tdata->msg, h);\n\t    h = next;\n\t}\n    } else {\n\t/* For each realm, add either the cached authorization header\n\t * or add an empty authorization header.\n\t */\n\tunsigned i;\n\tpj_str_t uri;\n\n\turi.ptr = (char*)pj_pool_alloc(tdata->pool, PJSIP_MAX_URL_SIZE);\n\turi.slen = pjsip_uri_print(PJSIP_URI_IN_REQ_URI,\n\t                           tdata->msg->line.req.uri,\n\t                           uri.ptr, PJSIP_MAX_URL_SIZE);\n\tif (uri.slen < 1 || uri.slen >= PJSIP_MAX_URL_SIZE)\n\t    return PJSIP_EURITOOLONG;\n\n\tfor (i=0; i<sess->cred_cnt; ++i) {\n\t    pjsip_cred_info *c = &sess->cred_info[i];\n\t    pjsip_authorization_hdr *h;\n\n\t    h = get_header_for_realm(&added, &c->realm);\n\t    if (h) {\n\t\tpj_list_erase(h);\n\t\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)h);\n\t    } else {\n\t\tpjsip_authorization_hdr *hs;\n\n\t\ths = pjsip_authorization_hdr_create(tdata->pool);\n\t\tpj_strdup(tdata->pool, &hs->scheme, &c->scheme);\n\t\tif (pj_stricmp(&c->scheme, &pjsip_BEARER_STR)==0) {\n\t\t\tpj_strdup(tdata->pool, &hs->credential.oauth.username,\n                                  &c->username);\n                        pj_strdup(tdata->pool, &hs->credential.oauth.realm,\n                                  &c->realm);\n                        pj_strdup(tdata->pool, &hs->credential.oauth.token,\n                                  &c->data);\n\t\t} else { //if (pj_stricmp(&c->scheme, &pjsip_DIGEST_STR)==0)\n\t\t\tpj_strdup(tdata->pool, &hs->credential.digest.username,\n\t\t\t\t  &c->username);\n\t\t\tpj_strdup(tdata->pool, &hs->credential.digest.realm,\n\t\t\t\t  &c->realm);\n\t\t\tpj_strdup(tdata->pool,&hs->credential.digest.uri, &uri);\n\t\t\tpj_strdup(tdata->pool, &hs->credential.digest.algorithm,\n\t\t\t  \t  &sess->pref.algorithm);\n\t\t}\n\n\t\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)hs);\n\t    }\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void recreate_cached_auth_pool( pjsip_endpoint *endpt, \n\t\t\t\t       pjsip_cached_auth *auth )\n{\n    pj_pool_t *auth_pool = pjsip_endpt_create_pool(endpt, \"auth_cli%p\", 1024, \n\t\t\t\t\t\t   1024);\n\n    if (auth->realm.slen) {\n        pj_str_t realm;\n        pj_strdup(auth_pool, &realm, &auth->realm);\n        pj_strassign(&auth->realm, &realm);\n    }\n\n    if (auth->cnonce.slen) {\n        pj_str_t cnonce;\n        pj_strdup(auth_pool, &cnonce, &auth->cnonce);\n        pj_strassign(&auth->cnonce, &cnonce);\n    }\n\n    if (auth->last_chal) {\n        auth->last_chal = (pjsip_www_authenticate_hdr*)\n\t\t\t  pjsip_hdr_clone(auth_pool, auth->last_chal);\n    }\n\n    pjsip_endpt_release_pool(endpt, auth->pool);\n    auth->pool = auth_pool;\n}\n\n/* Process authorization challenge */\nstatic pj_status_t process_auth( pj_pool_t *req_pool,\n\t\t\t\t const pjsip_www_authenticate_hdr *hchal,\n\t\t\t\t const pjsip_uri *uri,\n\t\t\t\t pjsip_tx_data *tdata,\n\t\t\t\t pjsip_auth_clt_sess *sess,\n\t\t\t\t pjsip_cached_auth *cached_auth,\n\t\t\t\t pjsip_authorization_hdr **h_auth)\n{\n    const pjsip_cred_info *cred;\n    pjsip_authorization_hdr *sent_auth = NULL;\n    pjsip_hdr *hdr;\n    pj_status_t status;\n\n    /* See if we have sent authorization header for this realm (and scheme) */\n    hdr = tdata->msg->hdr.next;\n    while (hdr != &tdata->msg->hdr) {\n\tif ((hchal->type == PJSIP_H_WWW_AUTHENTICATE &&\n\t     hdr->type == PJSIP_H_AUTHORIZATION) ||\n\t    (hchal->type == PJSIP_H_PROXY_AUTHENTICATE &&\n\t     hdr->type == PJSIP_H_PROXY_AUTHORIZATION))\n\t{\n\t    sent_auth = (pjsip_authorization_hdr*) hdr;\n\t    if (pj_stricmp(&hchal->challenge.common.realm,\n\t\t\t   &sent_auth->credential.common.realm)==0 &&\n\t\tpj_stricmp(&hchal->scheme, &sent_auth->scheme)==0)\n\t    {\n\t\t/* If this authorization has empty response, remove it. */\n\t\tif (pj_stricmp(&sent_auth->scheme, &pjsip_DIGEST_STR)==0 &&\n\t\t    sent_auth->credential.digest.response.slen == 0)\n\t\t{\n\t\t    /* This is empty authorization, remove it. */\n\t\t    hdr = hdr->next;\n\t\t    pj_list_erase(sent_auth);\n\t\t    continue;\n\t\t} else\n\t\tif (pj_stricmp(&sent_auth->scheme, &pjsip_DIGEST_STR)==0 &&\n\t\t    pj_stricmp(&sent_auth->credential.digest.algorithm,\n\t\t               &hchal->challenge.digest.algorithm)!=0)\n\t\t{\n\t\t    /* Same 'digest' scheme but different algo */\n\t\t    hdr = hdr->next;\n\t\t    continue;\n\t\t} else {\n\t\t    /* Found previous authorization attempt */\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\thdr = hdr->next;\n    }\n\n    /* If we have sent, see if server rejected because of stale nonce or\n     * other causes.\n     */\n    if (hdr != &tdata->msg->hdr) {\n\tpj_bool_t stale;\n\n\t/* Detect \"stale\" state */\n\tstale = hchal->challenge.digest.stale;\n\tif (!stale) {\n\t    /* If stale is false, check is nonce has changed. Some servers\n\t     * (broken ones!) want to change nonce but they fail to set\n\t     * stale to true.\n\t     */\n\t    stale = pj_strcmp(&hchal->challenge.digest.nonce,\n\t\t\t      &sent_auth->credential.digest.nonce);\n\t}\n\n\tif (stale == PJ_FALSE) {\n\t    /* Our credential is rejected. No point in trying to re-supply\n\t     * the same credential.\n\t     */\n\t    PJ_LOG(4, (THIS_FILE, \"Authorization failed for %.*s@%.*s: \"\n\t\t       \"server rejected with stale=false\",\n\t\t       sent_auth->credential.digest.username.slen,\n\t\t       sent_auth->credential.digest.username.ptr,\n\t\t       sent_auth->credential.digest.realm.slen,\n\t\t       sent_auth->credential.digest.realm.ptr));\n\t    return PJSIP_EFAILEDCREDENTIAL;\n\t}\n\n\tcached_auth->stale_cnt++;\n\tif (cached_auth->stale_cnt >= PJSIP_MAX_STALE_COUNT) {\n\t    /* Our credential is rejected. No point in trying to re-supply\n\t     * the same credential.\n\t     */\n\t    PJ_LOG(4, (THIS_FILE, \"Authorization failed for %.*s@%.*s: \"\n\t\t       \"maximum number of stale retries exceeded\",\n\t\t       sent_auth->credential.digest.username.slen,\n\t\t       sent_auth->credential.digest.username.ptr,\n\t\t       sent_auth->credential.digest.realm.slen,\n\t\t       sent_auth->credential.digest.realm.ptr));\n\t    return PJSIP_EAUTHSTALECOUNT;\n\t}\n\n\t/* Otherwise remove old, stale authorization header from the mesasge.\n\t * We will supply a new one.\n\t */\n\tpj_list_erase(sent_auth);\n    }\n\n    /* Find credential to be used for the challenge. */\n    cred = auth_find_cred( sess, &hchal->challenge.common.realm,\n\t\t\t   &hchal->scheme);\n    if (!cred) {\n\tconst pj_str_t *realm = &hchal->challenge.common.realm;\n\tPJ_LOG(4,(THIS_FILE,\n\t\t  \"Unable to set auth for %s: can not find credential for %.*s/%.*s\",\n\t\t  tdata->obj_name,\n\t\t  realm->slen, realm->ptr,\n\t\t  hchal->scheme.slen, hchal->scheme.ptr));\n\treturn PJSIP_ENOCREDENTIAL;\n    }\n\n    /* Respond to authorization challenge. */\n    status = auth_respond( req_pool, hchal, uri, cred,\n\t\t\t   &tdata->msg->line.req.method,\n\t\t\t   sess->pool, cached_auth, h_auth);\n    return status;\n}\n\n\n/* Reinitialize outgoing request after 401/407 response is received.\n * The purpose of this function is:\n *  - to add a Authorization/Proxy-Authorization header.\n *  - to put the newly created Authorization/Proxy-Authorization header\n *    in cached_list.\n */\nPJ_DEF(pj_status_t) pjsip_auth_clt_reinit_req(\tpjsip_auth_clt_sess *sess,\n\t\t\t\t\t\tconst pjsip_rx_data *rdata,\n\t\t\t\t\t\tpjsip_tx_data *old_request,\n\t\t\t\t\t\tpjsip_tx_data **new_request )\n{\n    pjsip_tx_data *tdata;\n    const pjsip_hdr *hdr;\n    unsigned chal_cnt, auth_cnt;\n    pjsip_via_hdr *via;\n    pj_status_t status;\n    pj_status_t last_auth_err;\n\n    PJ_ASSERT_RETURN(sess && rdata && old_request && new_request,\n\t\t     PJ_EINVAL);\n    PJ_ASSERT_RETURN(sess->pool, PJSIP_ENOTINITIALIZED);\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_RESPONSE_MSG,\n\t\t     PJSIP_ENOTRESPONSEMSG);\n    PJ_ASSERT_RETURN(old_request->msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->line.status.code == 401 ||\n\t\t     rdata->msg_info.msg->line.status.code == 407,\n\t\t     PJSIP_EINVALIDSTATUS);\n\n    tdata = old_request;\n    tdata->auth_retry = PJ_FALSE;\n\n    /*\n     * Respond to each authentication challenge.\n     */\n    hdr = rdata->msg_info.msg->hdr.next;\n    chal_cnt = 0;\n    auth_cnt = 0;\n    last_auth_err = PJSIP_EAUTHNOAUTH;\n    while (hdr != &rdata->msg_info.msg->hdr && auth_cnt == 0) {\n\tpjsip_cached_auth *cached_auth;\n\tconst pjsip_www_authenticate_hdr *hchal;\n\tpjsip_authorization_hdr *hauth;\n\n\t/* Find WWW-Authenticate or Proxy-Authenticate header. */\n\twhile (hdr != &rdata->msg_info.msg->hdr &&\n\t       hdr->type != PJSIP_H_WWW_AUTHENTICATE &&\n\t       hdr->type != PJSIP_H_PROXY_AUTHENTICATE)\n\t{\n\t    hdr = hdr->next;\n\t}\n\tif (hdr == &rdata->msg_info.msg->hdr)\n\t    break;\n\n\thchal = (const pjsip_www_authenticate_hdr*)hdr;\n\t++chal_cnt;\n\n\t/* Find authentication session for this realm, create a new one\n\t * if not present.\n\t */\n\tcached_auth = find_cached_auth(sess, &hchal->challenge.common.realm);\n\tif (!cached_auth) {\n\t    cached_auth = PJ_POOL_ZALLOC_T(sess->pool, pjsip_cached_auth);\n\t    cached_auth->pool = pjsip_endpt_create_pool(sess->endpt,\n\t\t\t\t\t\t\t\"auth_cli%p\",\n\t\t\t\t\t\t\t1024,\n\t\t\t\t\t\t\t1024);\n\t    pj_strdup(cached_auth->pool, &cached_auth->realm,\n\t\t      &hchal->challenge.common.realm);\n\t    cached_auth->is_proxy = (hchal->type == PJSIP_H_PROXY_AUTHENTICATE);\n#\t    if (PJSIP_AUTH_HEADER_CACHING)\n\t    {\n\t\tpj_list_init(&cached_auth->cached_hdr);\n\t    }\n#\t    endif\n\t    pj_list_insert_before(&sess->cached_auth, cached_auth);\n\t}\n\n\t/* Create authorization header for this challenge, and update\n\t * authorization session.\n\t */\n\tstatus = process_auth(tdata->pool, hchal, tdata->msg->line.req.uri,\n\t\t\t      tdata, sess, cached_auth, &hauth);\n\tif (status != PJ_SUCCESS) {\n\t    last_auth_err = status;\n\n\t    /* Process next header. */\n\t    hdr = hdr->next;\n\t    continue;\n\t}\n\n\tif (pj_pool_get_used_size(cached_auth->pool) >\n\t    PJSIP_AUTH_CACHED_POOL_MAX_SIZE) \n\t{\n\t    recreate_cached_auth_pool(sess->endpt, cached_auth);\n\t}\t\n\n\t/* Add to the message. */\n\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)hauth);\n\n\t/* Process next header. */\n\thdr = hdr->next;\n\tauth_cnt++;\n    }\n\n    /* Check if challenge is present */\n    if (chal_cnt == 0)\n\treturn PJSIP_EAUTHNOCHAL;\n\n    /* Check if any authorization header has been created */\n    if (auth_cnt == 0)\n\treturn last_auth_err;\n\n    /* Remove branch param in Via header. */\n    via = (pjsip_via_hdr*) pjsip_msg_find_hdr(tdata->msg, PJSIP_H_VIA, NULL);\n    via->branch_param.slen = 0;\n\n    /* Restore strict route set.\n     * See http://trac.pjsip.org/repos/ticket/492\n     */\n    pjsip_restore_strict_route_set(tdata);\n\n    /* Must invalidate the message! */\n    pjsip_tx_data_invalidate_msg(tdata);\n\n    /* Retrying.. */\n    tdata->auth_retry = PJ_TRUE;\n\n    /* Increment reference counter. */\n    pjsip_tx_data_add_ref(tdata);\n\n    /* Done. */\n    *new_request = tdata;\n    return PJ_SUCCESS;\n\n}\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n#include <pjsip/sip_auth.h>\n#include <pjsip/sip_auth_parser.h>\t/* just to get pjsip_DIGEST_STR */\n#include <pjsip/sip_auth_msg.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_transport.h>\n#include <pj/string.h>\n#include <pj/assert.h>\n\n\n/*\n * Initialize server authorization session data structure to serve the \n * specified realm and to use lookup_func function to look for the credential \n * info. \n */\nPJ_DEF(pj_status_t) pjsip_auth_srv_init(  pj_pool_t *pool,\n\t\t\t\t\t  pjsip_auth_srv *auth_srv,\n\t\t\t\t\t  const pj_str_t *realm,\n\t\t\t\t\t  pjsip_auth_lookup_cred *lookup,\n\t\t\t\t\t  unsigned options )\n{\n    PJ_ASSERT_RETURN(pool && auth_srv && realm && lookup, PJ_EINVAL);\n\n    pj_bzero(auth_srv, sizeof(*auth_srv));\n    pj_strdup( pool, &auth_srv->realm, realm);\n    auth_srv->lookup = lookup;\n    auth_srv->is_proxy = (options & PJSIP_AUTH_SRV_IS_PROXY);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Initialize server authorization session data structure to serve the \n * specified realm and to use lookup_func function to look for the credential \n * info. \n */\nPJ_DEF(pj_status_t) pjsip_auth_srv_init2(\n\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t    pjsip_auth_srv *auth_srv,\n\t\t\t\t    const pjsip_auth_srv_init_param *param)\n{\n    PJ_ASSERT_RETURN(pool && auth_srv && param, PJ_EINVAL);\n\n    pj_bzero(auth_srv, sizeof(*auth_srv));\n    pj_strdup( pool, &auth_srv->realm, param->realm);\n    auth_srv->lookup2 = param->lookup2;\n    auth_srv->is_proxy = (param->options & PJSIP_AUTH_SRV_IS_PROXY);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Verify incoming Authorization/Proxy-Authorization header against the \n * specified credential.\n */\nstatic pj_status_t pjsip_auth_verify( const pjsip_authorization_hdr *hdr,\n\t\t\t\t      const pj_str_t *method,\n\t\t\t\t      const pjsip_cred_info *cred_info )\n{\n    if (pj_stricmp(&hdr->scheme, &pjsip_DIGEST_STR) == 0) {\n\tchar digest_buf[PJSIP_MD5STRLEN];\n\tpj_str_t digest;\n\tpj_status_t status;\n\tconst pjsip_digest_credential *dig = &hdr->credential.digest;\n\n\t/* Check that username and realm match. \n\t * These checks should have been performed before entering this\n\t * function.\n\t */\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->username, &cred_info->username) == 0,\n\t\t\t PJ_EINVALIDOP);\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->realm, &cred_info->realm) == 0,\n\t\t\t PJ_EINVALIDOP);\n\n\t/* Prepare for our digest calculation. */\n\tdigest.ptr = digest_buf;\n\tdigest.slen = PJSIP_MD5STRLEN;\n\n\t/* Create digest for comparison. */\n\tstatus = pjsip_auth_create_digest(&digest, \n\t\t\t\t &hdr->credential.digest.nonce,\n\t\t\t\t &hdr->credential.digest.nc, \n\t\t\t\t &hdr->credential.digest.cnonce,\n\t\t\t\t &hdr->credential.digest.qop,\n\t\t\t\t &hdr->credential.digest.uri,\n\t\t\t\t &cred_info->realm,\n\t\t\t\t cred_info, \n\t\t\t\t method );\n\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\n\t/* Compare digest. */\n\treturn (pj_stricmp(&digest, &hdr->credential.digest.response) == 0) ?\n\t       PJ_SUCCESS : PJSIP_EAUTHINVALIDDIGEST;\n\n    } else {\n\tpj_assert(!\"Unsupported authentication scheme\");\n\treturn PJSIP_EINVALIDAUTHSCHEME;\n    }\n}\n\n\n/*\n * Request the authorization server framework to verify the authorization \n * information in the specified request in rdata.\n */\nPJ_DEF(pj_status_t) pjsip_auth_srv_verify( pjsip_auth_srv *auth_srv,\n\t\t\t\t\t   pjsip_rx_data *rdata,\n\t\t\t\t\t   int *status_code)\n{\n    pjsip_authorization_hdr *h_auth;\n    pjsip_msg *msg = rdata->msg_info.msg;\n    pjsip_hdr_e htype;\n    pj_str_t acc_name;\n    pjsip_cred_info cred_info;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(auth_srv && rdata, PJ_EINVAL);\n    PJ_ASSERT_RETURN(msg->type == PJSIP_REQUEST_MSG, PJSIP_ENOTREQUESTMSG);\n\n    htype = auth_srv->is_proxy ? PJSIP_H_PROXY_AUTHORIZATION : \n\t\t\t\t PJSIP_H_AUTHORIZATION;\n\n    /* Initialize status with 200. */\n    *status_code = 200;\n\n    /* Find authorization header for our realm. */\n    h_auth = (pjsip_authorization_hdr*) pjsip_msg_find_hdr(msg, htype, NULL);\n    while (h_auth) {\n\tif (!pj_stricmp(&h_auth->credential.common.realm, &auth_srv->realm))\n\t    break;\n\n\th_auth = h_auth->next;\n\tif (h_auth == (void*) &msg->hdr) {\n\t    h_auth = NULL;\n\t    break;\n\t}\n\n\th_auth=(pjsip_authorization_hdr*)pjsip_msg_find_hdr(msg,htype,h_auth);\n    }\n\n    if (!h_auth) {\n\t*status_code = auth_srv->is_proxy ? 407 : 401;\n\treturn PJSIP_EAUTHNOAUTH;\n    }\n\n    /* Check authorization scheme. */\n    if (pj_stricmp(&h_auth->scheme, &pjsip_DIGEST_STR) == 0)\n\tacc_name = h_auth->credential.digest.username;\n    else {\n\t*status_code = auth_srv->is_proxy ? 407 : 401;\n\treturn PJSIP_EINVALIDAUTHSCHEME;\n    }\n\n    /* Find the credential information for the account. */\n    if (auth_srv->lookup2) {\n\tpjsip_auth_lookup_cred_param param;\n\n\tpj_bzero(&param, sizeof(param));\n\tparam.realm = auth_srv->realm;\n\tparam.acc_name = acc_name;\n\tparam.rdata = rdata;\n\tstatus = (*auth_srv->lookup2)(rdata->tp_info.pool, &param, &cred_info);\n\tif (status != PJ_SUCCESS) {\n\t    *status_code = PJSIP_SC_FORBIDDEN;\n\t    return status;\n\t}\n    } else {\n\tstatus = (*auth_srv->lookup)(rdata->tp_info.pool, &auth_srv->realm,\n\t\t\t\t     &acc_name, &cred_info);\n\tif (status != PJ_SUCCESS) {\n\t    *status_code = PJSIP_SC_FORBIDDEN;\n\t    return status;\n\t}\n    }\n\n    /* Authenticate with the specified credential. */\n    status = pjsip_auth_verify(h_auth, &msg->line.req.method.name, \n\t\t\t       &cred_info);\n    if (status != PJ_SUCCESS) {\n\t*status_code = PJSIP_SC_FORBIDDEN;\n    }\n    return status;\n}\n\n\n/*\n * Add authentication challenge headers to the outgoing response in tdata. \n * Application may specify its customized nonce and opaque for the challenge, \n * or can leave the value to NULL to make the function fills them in with \n * random characters.\n */\nPJ_DEF(pj_status_t) pjsip_auth_srv_challenge(  pjsip_auth_srv *auth_srv,\n\t\t\t\t\t       const pj_str_t *qop,\n\t\t\t\t\t       const pj_str_t *nonce,\n\t\t\t\t\t       const pj_str_t *opaque,\n\t\t\t\t\t       pj_bool_t stale,\n\t\t\t\t\t       pjsip_tx_data *tdata)\n{\n    pjsip_www_authenticate_hdr *hdr;\n    char nonce_buf[16];\n    pj_str_t random;\n\n    PJ_ASSERT_RETURN( auth_srv && tdata, PJ_EINVAL );\n\n    random.ptr = nonce_buf;\n    random.slen = sizeof(nonce_buf);\n\n    /* Create the header. */\n    if (auth_srv->is_proxy)\n\thdr = pjsip_proxy_authenticate_hdr_create(tdata->pool);\n    else\n\thdr = pjsip_www_authenticate_hdr_create(tdata->pool);\n\n    /* Initialize header. \n     * Note: only support digest authentication now.\n     */\n    hdr->scheme = pjsip_DIGEST_STR;\n    hdr->challenge.digest.algorithm = pjsip_MD5_STR;\n    if (nonce) {\n\tpj_strdup(tdata->pool, &hdr->challenge.digest.nonce, nonce);\n    } else {\n\tpj_create_random_string(nonce_buf, sizeof(nonce_buf));\n\tpj_strdup(tdata->pool, &hdr->challenge.digest.nonce, &random);\n    }\n    if (opaque) {\n\tpj_strdup(tdata->pool, &hdr->challenge.digest.opaque, opaque);\n    } else {\n\tpj_create_random_string(nonce_buf, sizeof(nonce_buf));\n\tpj_strdup(tdata->pool, &hdr->challenge.digest.opaque, &random);\n    }\n    if (qop) {\n\tpj_strdup(tdata->pool, &hdr->challenge.digest.qop, qop);\n    } else {\n\thdr->challenge.digest.qop.slen = 0;\n    }\n    pj_strdup(tdata->pool, &hdr->challenge.digest.realm, &auth_srv->realm);\n    hdr->challenge.digest.stale = stale;\n\n    pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)hdr);\n\n    return PJ_SUCCESS;\n}\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjsua-lib/pjsua.h>\n#include <pjsua-lib/pjsua_internal.h>\n\n\n#define THIS_FILE   \"pjsua_core.c\"\n\n#define DEFAULT_RTP_PORT\t4000\n\n\n/* Internal prototypes */\nstatic void resolve_stun_entry(pjsua_stun_resolve *sess);\n\n\n/* PJSUA application instance. */\nstruct pjsua_data pjsua_var;\n\n\nPJ_DEF(struct pjsua_data*) pjsua_get_var(void)\n{\n    return &pjsua_var;\n}\n\n\n/* Display error */\nPJ_DEF(void) pjsua_perror( const char *sender, const char *title, \n\t\t\t   pj_status_t status)\n{\n    char errmsg[PJ_ERR_MSG_SIZE];\n\n    pj_strerror(status, errmsg, sizeof(errmsg));\n    PJ_LOG(1,(sender, \"%s: %s [status=%d]\", title, errmsg, status));\n}\n\n\nstatic void init_data()\n{\n    unsigned i;\n\n    pj_bzero(&pjsua_var, sizeof(pjsua_var));\n\n    for (i=0; i<PJ_ARRAY_SIZE(pjsua_var.acc); ++i)\n\tpjsua_var.acc[i].index = i;\n    \n    for (i=0; i<PJ_ARRAY_SIZE(pjsua_var.tpdata); ++i)\n\tpjsua_var.tpdata[i].index = i;\n\n    pjsua_var.stun_status = PJ_EUNKNOWN;\n    pjsua_var.nat_status = PJ_EPENDING;\n    pj_list_init(&pjsua_var.stun_res);\n    pj_list_init(&pjsua_var.outbound_proxy);\n\n    pjsua_config_default(&pjsua_var.ua_cfg);\n\n    for (i=0; i<PJSUA_MAX_VID_WINS; ++i) {\n\tpjsua_vid_win_reset(i);\n    }\n}\n\n\nPJ_DEF(void) pjsua_logging_config_default(pjsua_logging_config *cfg)\n{\n    pj_bzero(cfg, sizeof(*cfg));\n\n    cfg->msg_logging = PJ_TRUE;\n    cfg->level = 5;\n    cfg->console_level = 4;\n    cfg->decor = PJ_LOG_HAS_SENDER | PJ_LOG_HAS_TIME | \n\t\t PJ_LOG_HAS_MICRO_SEC | PJ_LOG_HAS_NEWLINE |\n\t\t PJ_LOG_HAS_SPACE | PJ_LOG_HAS_THREAD_SWC |\n\t\t PJ_LOG_HAS_INDENT;\n#if (defined(PJ_WIN32) && PJ_WIN32 != 0) || (defined(PJ_WIN64) && PJ_WIN64 != 0)\n    cfg->decor |= PJ_LOG_HAS_COLOR;\n#endif\n}\n\nPJ_DEF(void) pjsua_logging_config_dup(pj_pool_t *pool,\n\t\t\t\t      pjsua_logging_config *dst,\n\t\t\t\t      const pjsua_logging_config *src)\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    pj_strdup_with_null(pool, &dst->log_filename, &src->log_filename);\n}\n\nPJ_DEF(void) pjsua_config_default(pjsua_config *cfg)\n{\n    pj_bzero(cfg, sizeof(*cfg));\n\n    cfg->max_calls = PJSUA_MAX_CALLS;\n    cfg->thread_cnt = PJSUA_SEPARATE_WORKER_FOR_TIMER? 2 : 1;\n    cfg->nat_type_in_sdp = 1;\n    cfg->stun_ignore_failure = PJ_TRUE;\n    cfg->force_lr = PJ_TRUE;\n    cfg->enable_unsolicited_mwi = PJ_TRUE;\n    cfg->use_srtp = PJSUA_DEFAULT_USE_SRTP;\n    cfg->srtp_secure_signaling = PJSUA_DEFAULT_SRTP_SECURE_SIGNALING;\n    cfg->hangup_forked_call = PJ_TRUE;\n\n    cfg->use_timer = PJSUA_SIP_TIMER_OPTIONAL;\n    pjsip_timer_setting_default(&cfg->timer_setting);\n    pjsua_srtp_opt_default(&cfg->srtp_opt);\n}\n\nPJ_DEF(void) pjsua_config_dup(pj_pool_t *pool,\n\t\t\t      pjsua_config *dst,\n\t\t\t      const pjsua_config *src)\n{\n    unsigned i;\n\n    pj_memcpy(dst, src, sizeof(*src));\n\n    for (i=0; i<src->outbound_proxy_cnt; ++i) {\n\tpj_strdup_with_null(pool, &dst->outbound_proxy[i],\n\t\t\t    &src->outbound_proxy[i]);\n    }\n\n    for (i=0; i<src->cred_count; ++i) {\n\tpjsip_cred_dup(pool, &dst->cred_info[i], &src->cred_info[i]);\n    }\n\n    pj_strdup_with_null(pool, &dst->user_agent, &src->user_agent);\n    pj_strdup_with_null(pool, &dst->stun_domain, &src->stun_domain);\n    pj_strdup_with_null(pool, &dst->stun_host, &src->stun_host);\n\n    for (i=0; i<src->stun_srv_cnt; ++i) {\n\tpj_strdup_with_null(pool, &dst->stun_srv[i], &src->stun_srv[i]);\n    }\n\n    pjsua_srtp_opt_dup(pool, &dst->srtp_opt, &src->srtp_opt, PJ_FALSE);\n}\n\nPJ_DEF(void) pjsua_msg_data_init(pjsua_msg_data *msg_data)\n{\n    pj_bzero(msg_data, sizeof(*msg_data));\n    pj_list_init(&msg_data->hdr_list);\n    pjsip_media_type_init(&msg_data->multipart_ctype, NULL, NULL);\n    pj_list_init(&msg_data->multipart_parts);\n}\n\nPJ_DEF(pjsua_msg_data*) pjsua_msg_data_clone(pj_pool_t *pool,\n                                             const pjsua_msg_data *rhs)\n{\n    pjsua_msg_data *msg_data;\n    const pjsip_hdr *hdr;\n    const pjsip_multipart_part *mpart;\n\n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    msg_data = PJ_POOL_ZALLOC_T(pool, pjsua_msg_data);\n    PJ_ASSERT_RETURN(msg_data != NULL, NULL);\n\n    pj_strdup(pool, &msg_data->target_uri, &rhs->target_uri);\n\n    pj_list_init(&msg_data->hdr_list);\n    hdr = rhs->hdr_list.next;\n    while (hdr != &rhs->hdr_list) {\n\tpj_list_push_back(&msg_data->hdr_list, pjsip_hdr_clone(pool, hdr));\n\thdr = hdr->next;\n    }\n\n    pj_strdup(pool, &msg_data->content_type, &rhs->content_type);\n    pj_strdup(pool, &msg_data->msg_body, &rhs->msg_body);\n\n    pjsip_media_type_cp(pool, &msg_data->multipart_ctype,\n                        &rhs->multipart_ctype);\n\n    pj_list_init(&msg_data->multipart_parts);\n    mpart = rhs->multipart_parts.next;\n    while (mpart != &rhs->multipart_parts) {\n\tpj_list_push_back(&msg_data->multipart_parts,\n                          pjsip_multipart_clone_part(pool, mpart));\n\tmpart = mpart->next;\n    }\n\n    return msg_data;\n}\n\nPJ_DEF(void) pjsua_transport_config_default(pjsua_transport_config *cfg)\n{\n    pj_bzero(cfg, sizeof(*cfg));\n    pjsip_tls_setting_default(&cfg->tls_setting);\n}\n\nPJ_DEF(void) pjsua_transport_config_dup(pj_pool_t *pool,\n\t\t\t\t\tpjsua_transport_config *dst,\n\t\t\t\t\tconst pjsua_transport_config *src)\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    pj_strdup(pool, &dst->public_addr, &src->public_addr);\n    pj_strdup(pool, &dst->bound_addr, &src->bound_addr);\n}\n\nPJ_DEF(void) pjsua_ice_config_from_media_config( pj_pool_t *pool,\n                                           pjsua_ice_config *dst,\n                                           const pjsua_media_config *src)\n{\n    PJ_UNUSED_ARG(pool);\n\n    dst->enable_ice = src->enable_ice;\n    dst->ice_max_host_cands = src->ice_max_host_cands;\n    dst->ice_opt = src->ice_opt;\n    dst->ice_no_rtcp = src->ice_no_rtcp;\n    dst->ice_always_update = src->ice_always_update;\n}\n\nPJ_DEF(void) pjsua_ice_config_dup( pj_pool_t *pool,\n                                pjsua_ice_config *dst,\n                                const pjsua_ice_config *src)\n{\n    PJ_UNUSED_ARG(pool);\n    pj_memcpy(dst, src, sizeof(*src));\n}\n\nPJ_DEF(void) pjsua_turn_config_from_media_config(pj_pool_t *pool,\n                                                 pjsua_turn_config *dst,\n                                                 const pjsua_media_config *src)\n{\n    dst->enable_turn = src->enable_turn;\n    dst->turn_conn_type = src->turn_conn_type;\n    if (pool == NULL) {\n\tdst->turn_server = src->turn_server;\n\tdst->turn_auth_cred = src->turn_auth_cred;\n\n#if PJ_HAS_SSL_SOCK\n\tpj_memcpy(&dst->turn_tls_setting, &src->turn_tls_setting,\n\t\t  sizeof(src->turn_tls_setting));\n#endif\n    } else {\n\tif (pj_stricmp(&dst->turn_server, &src->turn_server))\n\t    pj_strdup(pool, &dst->turn_server, &src->turn_server);\n\tpj_stun_auth_cred_dup(pool, &dst->turn_auth_cred,\n\t                      &src->turn_auth_cred);\n\n#if PJ_HAS_SSL_SOCK\n\tpj_turn_sock_tls_cfg_dup(pool, &dst->turn_tls_setting,\n\t\t\t\t &src->turn_tls_setting);\n#endif\n    }\n}\n\nPJ_DEF(void) pjsua_turn_config_dup(pj_pool_t *pool,\n                                   pjsua_turn_config *dst,\n                                   const pjsua_turn_config *src)\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    if (pool) {\n\tpj_strdup(pool, &dst->turn_server, &src->turn_server);\n\tpj_stun_auth_cred_dup(pool, &dst->turn_auth_cred,\n\t                      &src->turn_auth_cred);\n\n#if PJ_HAS_SSL_SOCK\n\tpj_turn_sock_tls_cfg_dup(pool, &dst->turn_tls_setting,\n\t\t\t\t &src->turn_tls_setting);\n#endif\n    }\n}\n\n\nPJ_DEF(void) pjsua_srtp_opt_default(pjsua_srtp_opt *cfg)\n{\n    pj_bzero(cfg, sizeof(*cfg));\n}\n\n\nPJ_DEF(void) pjsua_srtp_opt_dup( pj_pool_t *pool, pjsua_srtp_opt *dst,\n                                 const pjsua_srtp_opt *src,\n                                 pj_bool_t check_str)\n{\n    pjsua_srtp_opt backup_dst;\n    \n    if (check_str) pj_memcpy(&backup_dst, dst, sizeof(*dst));\n    pj_memcpy(dst, src, sizeof(*src));\n\n    if (pool) {\n    \tunsigned i;\n    \t\n    \tfor (i = 0; i < src->crypto_count; i++) {\n    \t    if (!check_str ||\n    \t    \tpj_stricmp(&backup_dst.crypto[i].key, &src->crypto[i].key))\n    \t    {\n\t    \tpj_strdup(pool, &dst->crypto[i].key, &src->crypto[i].key);\n\t    } else {\n\t    \t/* If strings are identical, use the old string to\n\t    \t * avoid wasting memory.\n\t    \t */\n\t    \tdst->crypto[i].key = backup_dst.crypto[i].key;\n\t    }\n    \t    if (!check_str ||\n    \t    \tpj_stricmp(&backup_dst.crypto[i].name, &src->crypto[i].name))\n    \t    {\n\t    \tpj_strdup(pool, &dst->crypto[i].name, &src->crypto[i].name);\n\t    } else {\n\t    \t/* If strings are identical, use the old string to\n\t    \t * avoid wasting memory.\n\t    \t */\n\t    \tdst->crypto[i].name = backup_dst.crypto[i].name;\n\t    }\n\t}\n    }\n}\n\n\nPJ_DEF(void) pjsua_acc_config_default(pjsua_acc_config *cfg)\n{\n    pjsua_media_config med_cfg;\n\n    pj_bzero(cfg, sizeof(*cfg));\n\n    cfg->reg_timeout = PJSUA_REG_INTERVAL;\n    cfg->reg_delay_before_refresh = PJSIP_REGISTER_CLIENT_DELAY_BEFORE_REFRESH;\n    cfg->unreg_timeout = PJSUA_UNREG_TIMEOUT;\n    pjsip_publishc_opt_default(&cfg->publish_opt);\n    cfg->unpublish_max_wait_time_msec = PJSUA_UNPUBLISH_MAX_WAIT_TIME_MSEC;\n    cfg->transport_id = PJSUA_INVALID_ID;\n    cfg->allow_contact_rewrite = PJ_TRUE;\n    cfg->allow_via_rewrite = PJ_TRUE;\n    cfg->require_100rel = pjsua_var.ua_cfg.require_100rel;\n    cfg->use_timer = pjsua_var.ua_cfg.use_timer;\n    cfg->timer_setting = pjsua_var.ua_cfg.timer_setting;\n    cfg->lock_codec = 1;\n    cfg->ka_interval = 15;\n    cfg->ka_data = pj_str(\"\\r\\n\");\n    cfg->vid_cap_dev = PJMEDIA_VID_DEFAULT_CAPTURE_DEV;\n    cfg->vid_rend_dev = PJMEDIA_VID_DEFAULT_RENDER_DEV;\n#if PJMEDIA_HAS_VIDEO\n    pjmedia_vid_stream_rc_config_default(&cfg->vid_stream_rc_cfg);\n    pjmedia_vid_stream_sk_config_default(&cfg->vid_stream_sk_cfg);\n#endif\n    pjsua_transport_config_default(&cfg->rtp_cfg);\n    cfg->rtp_cfg.port = DEFAULT_RTP_PORT;\n    pjmedia_rtcp_fb_setting_default(&cfg->rtcp_fb_cfg);\n\n    pjsua_media_config_default(&med_cfg);\n    pjsua_ice_config_from_media_config(NULL, &cfg->ice_cfg, &med_cfg);\n    pjsua_turn_config_from_media_config(NULL, &cfg->turn_cfg, &med_cfg);\n\n    cfg->use_srtp = pjsua_var.ua_cfg.use_srtp;\n    cfg->srtp_secure_signaling = pjsua_var.ua_cfg.srtp_secure_signaling;\n    cfg->srtp_optional_dup_offer = pjsua_var.ua_cfg.srtp_optional_dup_offer;\n    cfg->srtp_opt = pjsua_var.ua_cfg.srtp_opt;\n    cfg->reg_retry_interval = PJSUA_REG_RETRY_INTERVAL;\n    cfg->reg_retry_random_interval = 10;\n    cfg->contact_rewrite_method = PJSUA_CONTACT_REWRITE_METHOD;\n    cfg->contact_use_src_port = PJ_TRUE;\n    cfg->use_rfc5626 = PJ_TRUE;\n    cfg->reg_use_proxy = PJSUA_REG_USE_OUTBOUND_PROXY |\n\t\t\t PJSUA_REG_USE_ACC_PROXY;\n#if defined(PJMEDIA_STREAM_ENABLE_KA) && PJMEDIA_STREAM_ENABLE_KA!=0\n    cfg->use_stream_ka = (PJMEDIA_STREAM_ENABLE_KA != 0);\n    pjmedia_stream_ka_config_default(&cfg->stream_ka_cfg);\n#endif\n    pj_list_init(&cfg->reg_hdr_list);\n    pj_list_init(&cfg->sub_hdr_list);\n    cfg->call_hold_type = PJSUA_CALL_HOLD_TYPE_DEFAULT;\n    cfg->register_on_acc_add = PJ_TRUE;\n    cfg->mwi_expires = PJSIP_MWI_DEFAULT_EXPIRES;\n\n    cfg->media_stun_use = PJSUA_STUN_RETRY_ON_FAILURE;\n    cfg->ip_change_cfg.shutdown_tp = PJ_TRUE;\n    cfg->ip_change_cfg.hangup_calls = PJ_FALSE;\n    cfg->ip_change_cfg.reinvite_flags = PJSUA_CALL_REINIT_MEDIA |\n\t\t\t\t\tPJSUA_CALL_UPDATE_CONTACT |\n\t\t\t\t\tPJSUA_CALL_UPDATE_VIA;\n}\n\nPJ_DEF(void) pjsua_buddy_config_default(pjsua_buddy_config *cfg)\n{\n    pj_bzero(cfg, sizeof(*cfg));\n}\n\nPJ_DEF(void) pjsua_media_config_default(pjsua_media_config *cfg)\n{\n    const pj_sys_info *si = pj_get_sys_info();\n    pj_str_t dev_model = {\"iPhone5\", 7};\n    \n    pj_bzero(cfg, sizeof(*cfg));\n\n    cfg->clock_rate = PJSUA_DEFAULT_CLOCK_RATE;\n    /* It is reported that there may be some media server resampling problem\n     * with iPhone 5 devices running iOS 7, so we set the sound device's\n     * clock rate to 44100 to avoid resampling.\n     */\n    if (pj_stristr(&si->machine, &dev_model) &&\n        ((si->os_ver & 0xFF000000) >> 24) >= 7)\n    {\n        cfg->snd_clock_rate = 44100;\n    } else {\n        cfg->snd_clock_rate = 0;\n    }\n    cfg->channel_count = 1;\n    cfg->audio_frame_ptime = PJSUA_DEFAULT_AUDIO_FRAME_PTIME;\n    cfg->max_media_ports = PJSUA_MAX_CONF_PORTS;\n    cfg->has_ioqueue = PJ_TRUE;\n    cfg->thread_cnt = 1;\n    cfg->quality = PJSUA_DEFAULT_CODEC_QUALITY;\n    cfg->ilbc_mode = PJSUA_DEFAULT_ILBC_MODE;\n    cfg->ec_tail_len = PJSUA_DEFAULT_EC_TAIL_LEN;\n    cfg->snd_rec_latency = PJMEDIA_SND_DEFAULT_REC_LATENCY;\n    cfg->snd_play_latency = PJMEDIA_SND_DEFAULT_PLAY_LATENCY;\n    cfg->jb_init = cfg->jb_min_pre = cfg->jb_max_pre = cfg->jb_max = -1;\n    cfg->jb_discard_algo = PJMEDIA_JB_DISCARD_PROGRESSIVE;\n    cfg->snd_auto_close_time = 1;\n\n    cfg->ice_max_host_cands = -1;\n    cfg->ice_always_update = PJ_TRUE;\n    pj_ice_sess_options_default(&cfg->ice_opt);\n\n    cfg->turn_conn_type = PJ_TURN_TP_UDP;\n#if PJ_HAS_SSL_SOCK\n    pj_turn_sock_tls_cfg_default(&cfg->turn_tls_setting);\n#endif\n    cfg->vid_preview_enable_native = PJ_TRUE;\n}\n\n/*****************************************************************************\n * This is a very simple PJSIP module, whose sole purpose is to display\n * incoming and outgoing messages to log. This module will have priority\n * higher than transport layer, which means:\n *\n *  - incoming messages will come to this module first before reaching\n *    transaction layer.\n *\n *  - outgoing messages will come to this module last, after the message\n *    has been 'printed' to contiguous buffer by transport layer and\n *    appropriate transport instance has been decided for this message.\n *\n */\n\n/* Notification on incoming messages */\nstatic pj_bool_t logging_on_rx_msg(pjsip_rx_data *rdata)\n{\n    char addr[PJ_INET6_ADDRSTRLEN+10];\n    pj_str_t input_str = pj_str(rdata->pkt_info.src_name);\n\n    PJ_LOG(4,(THIS_FILE, \"RX %d bytes %s from %s %s:\\n\"\n\t\t\t \"%.*s\\n\"\n\t\t\t \"--end msg--\",\n\t\t\t rdata->msg_info.len,\n\t\t\t pjsip_rx_data_get_info(rdata),\n\t\t\t rdata->tp_info.transport->type_name,\t      \n\t\t\t pj_addr_str_print(&input_str, \n\t\t\t\t\t   rdata->pkt_info.src_port, \n\t\t\t\t\t   addr,\n\t\t\t\t\t   sizeof(addr), \n\t\t\t\t\t   1),\n\t\t\t (int)rdata->msg_info.len,\n\t\t\t rdata->msg_info.msg_buf));\n    \n    /* Always return false, otherwise messages will not get processed! */\n    return PJ_FALSE;\n}\n\n/* Notification on outgoing messages */\nstatic pj_status_t logging_on_tx_msg(pjsip_tx_data *tdata)\n{\n    char addr[PJ_INET6_ADDRSTRLEN+10];\n    pj_str_t input_str = pj_str(tdata->tp_info.dst_name);\n    \n    /* Important note:\n     *\ttp_info field is only valid after outgoing messages has passed\n     *\ttransport layer. So don't try to access tp_info when the module\n     *\thas lower priority than transport layer.\n     */\n    PJ_LOG(4,(THIS_FILE, \"TX %d bytes %s to %s %s:\\n\"\n\t\t\t \"%.*s\\n\"\n\t\t\t \"--end msg--\",\n\t\t\t (tdata->buf.cur - tdata->buf.start),\n\t\t\t pjsip_tx_data_get_info(tdata),\n\t\t\t tdata->tp_info.transport->type_name,\n\t\t\t pj_addr_str_print(&input_str, \n\t\t\t\t\t   tdata->tp_info.dst_port, \n\t\t\t\t\t   addr,\n\t\t\t\t\t   sizeof(addr), \n\t\t\t\t\t   1),\n\t\t\t (int)(tdata->buf.cur - tdata->buf.start),\n\t\t\t tdata->buf.start));\n\n\n    /* Always return success, otherwise message will not get sent! */\n    return PJ_SUCCESS;\n}\n\n/* The module instance. */\nstatic pjsip_module pjsua_msg_logger = \n{\n    NULL, NULL,\t\t\t\t/* prev, next.\t\t*/\n    { \"mod-pjsua-log\", 13 },\t\t/* Name.\t\t*/\n    -1,\t\t\t\t\t/* Id\t\t\t*/\n    PJSIP_MOD_PRIORITY_TRANSPORT_LAYER-1,/* Priority\t        */\n    NULL,\t\t\t\t/* load()\t\t*/\n    NULL,\t\t\t\t/* start()\t\t*/\n    NULL,\t\t\t\t/* stop()\t\t*/\n    NULL,\t\t\t\t/* unload()\t\t*/\n    &logging_on_rx_msg,\t\t\t/* on_rx_request()\t*/\n    &logging_on_rx_msg,\t\t\t/* on_rx_response()\t*/\n    &logging_on_tx_msg,\t\t\t/* on_tx_request.\t*/\n    &logging_on_tx_msg,\t\t\t/* on_tx_response()\t*/\n    NULL,\t\t\t\t/* on_tsx_state()\t*/\n\n};\n\n\n/*****************************************************************************\n * Another simple module to handle incoming OPTIONS request\n */\n\n/* Notification on incoming request */\nstatic pj_bool_t options_on_rx_request(pjsip_rx_data *rdata)\n{\n    pjsip_tx_data *tdata;\n    pjsip_response_addr res_addr;\n    const pjsip_hdr *cap_hdr;\n    pj_status_t status;\n\n    /* Only want to handle OPTIONS requests */\n    if (pjsip_method_cmp(&rdata->msg_info.msg->line.req.method,\n\t\t\t pjsip_get_options_method()) != 0)\n    {\n\treturn PJ_FALSE;\n    }\n\n    /* Don't want to handle if shutdown is in progress */\n    if (pjsua_var.thread_quit_flag) {\n\tpjsip_endpt_respond_stateless(pjsua_var.endpt, rdata, \n\t\t\t\t      PJSIP_SC_TEMPORARILY_UNAVAILABLE, NULL,\n\t\t\t\t      NULL, NULL);\n\treturn PJ_TRUE;\n    }\n\n    /* Create basic response. */\n    status = pjsip_endpt_create_response(pjsua_var.endpt, rdata, 200, NULL, \n\t\t\t\t\t &tdata);\n    if (status != PJ_SUCCESS) {\n\tpjsua_perror(THIS_FILE, \"Unable to create OPTIONS response\", status);\n\treturn PJ_TRUE;\n    }\n\n    /* Add Allow header */\n    cap_hdr = pjsip_endpt_get_capability(pjsua_var.endpt, PJSIP_H_ALLOW, NULL);\n    if (cap_hdr) {\n\tpjsip_msg_add_hdr(tdata->msg, \n\t\t\t  (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, cap_hdr));\n    }\n\n    /* Add Accept header */\n    cap_hdr = pjsip_endpt_get_capability(pjsua_var.endpt, PJSIP_H_ACCEPT, NULL);\n    if (cap_hdr) {\n\tpjsip_msg_add_hdr(tdata->msg, \n\t\t\t  (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, cap_hdr));\n    }\n\n    /* Add Supported header */\n    cap_hdr = pjsip_endpt_get_capability(pjsua_var.endpt, PJSIP_H_SUPPORTED, NULL);\n    if (cap_hdr) {\n\tpjsip_msg_add_hdr(tdata->msg, \n\t\t\t  (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, cap_hdr));\n    }\n\n    /* Add Allow-Events header from the evsub module */\n    cap_hdr = pjsip_evsub_get_allow_events_hdr(NULL);\n    if (cap_hdr) {\n\tpjsip_msg_add_hdr(tdata->msg, \n\t\t\t  (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, cap_hdr));\n    }\n\n    /* Add User-Agent header */\n    if (pjsua_var.ua_cfg.user_agent.slen) {\n\tconst pj_str_t USER_AGENT = { \"User-Agent\", 10};\n\tpjsip_hdr *h;\n\n\th = (pjsip_hdr*) pjsip_generic_string_hdr_create(tdata->pool,\n\t\t\t\t\t\t\t &USER_AGENT,\n\t\t\t\t\t\t\t &pjsua_var.ua_cfg.user_agent);\n\tpjsip_msg_add_hdr(tdata->msg, h);\n    }\n\n    /* Get media socket info, make sure transport is ready */\n#if DISABLED_FOR_TICKET_1185\n    if (pjsua_var.calls[0].med_tp) {\n\tpjmedia_transport_info tpinfo;\n\tpjmedia_sdp_session *sdp;\n\n\tpjmedia_transport_info_init(&tpinfo);\n\tpjmedia_transport_get_info(pjsua_var.calls[0].med_tp, &tpinfo);\n\n\t/* Add SDP body, using call0's RTP address */\n\tstatus = pjmedia_endpt_create_sdp(pjsua_var.med_endpt, tdata->pool, 1,\n\t\t\t\t\t  &tpinfo.sock_info, &sdp);\n\tif (status == PJ_SUCCESS) {\n\t    pjsip_create_sdp_body(tdata->pool, sdp, &tdata->msg->body);\n\t}\n    }\n#endif\n\n    /* Send response */\n    pjsip_get_response_addr(tdata->pool, rdata, &res_addr);\n    status = pjsip_endpt_send_response(pjsua_var.endpt, &res_addr, tdata, NULL, NULL);\n    if (status != PJ_SUCCESS)\n\tpjsip_tx_data_dec_ref(tdata);\n\n    return PJ_TRUE;\n}\n\n\n/* The module instance. */\nstatic pjsip_module pjsua_options_handler = \n{\n    NULL, NULL,\t\t\t\t/* prev, next.\t\t*/\n    { \"mod-pjsua-options\", 17 },\t/* Name.\t\t*/\n    -1,\t\t\t\t\t/* Id\t\t\t*/\n    PJSIP_MOD_PRIORITY_APPLICATION,\t/* Priority\t        */\n    NULL,\t\t\t\t/* load()\t\t*/\n    NULL,\t\t\t\t/* start()\t\t*/\n    NULL,\t\t\t\t/* stop()\t\t*/\n    NULL,\t\t\t\t/* unload()\t\t*/\n    &options_on_rx_request,\t\t/* on_rx_request()\t*/\n    NULL,\t\t\t\t/* on_rx_response()\t*/\n    NULL,\t\t\t\t/* on_tx_request.\t*/\n    NULL,\t\t\t\t/* on_tx_response()\t*/\n    NULL,\t\t\t\t/* on_tsx_state()\t*/\n\n};\n\n\n/*****************************************************************************\n * These two functions are the main callbacks registered to PJSIP stack\n * to receive SIP request and response messages that are outside any\n * dialogs and any transactions.\n */\n\n/*\n * Handler for receiving incoming requests.\n *\n * This handler serves multiple purposes:\n *  - it receives requests outside dialogs.\n *  - it receives requests inside dialogs, when the requests are\n *    unhandled by other dialog usages. Example of these\n *    requests are: MESSAGE.\n */\nstatic pj_bool_t mod_pjsua_on_rx_request(pjsip_rx_data *rdata)\n{\n    pj_bool_t processed = PJ_FALSE;\n\n    PJSUA_LOCK();\n\n    if (rdata->msg_info.msg->line.req.method.id == PJSIP_INVITE_METHOD) {\n\n\tprocessed = pjsua_call_on_incoming(rdata);\n    }\n\n    PJSUA_UNLOCK();\n\n    return processed;\n}\n\n\n/*\n * Handler for receiving incoming responses.\n *\n * This handler serves multiple purposes:\n *  - it receives strayed responses (i.e. outside any dialog and\n *    outside any transactions).\n *  - it receives responses coming to a transaction, when pjsua\n *    module is set as transaction user for the transaction.\n *  - it receives responses inside a dialog, when these responses\n *    are unhandled by other dialog usages.\n */\nstatic pj_bool_t mod_pjsua_on_rx_response(pjsip_rx_data *rdata)\n{\n    PJ_UNUSED_ARG(rdata);\n    return PJ_FALSE;\n}\n\n\n/*****************************************************************************\n * Logging.\n */\n\n/* Log callback */\nstatic void log_writer(int level, const char *buffer, int len)\n{\n    /* Write to file, stdout or application callback. */\n\n    if (pjsua_var.log_file) {\n\tpj_ssize_t size = len;\n\tpj_file_write(pjsua_var.log_file, buffer, &size);\n\t/* This will slow things down considerably! Don't do it!\n\t pj_file_flush(pjsua_var.log_file);\n\t*/\n    }\n\n    if (level <= (int)pjsua_var.log_cfg.console_level) {\n\tif (pjsua_var.log_cfg.cb)\n\t    (*pjsua_var.log_cfg.cb)(level, buffer, len);\n\telse\n\t    pj_log_write(level, buffer, len);\n    }\n}\n\n\n/*\n * Application can call this function at any time (after pjsua_create(), of\n * course) to change logging settings.\n */\nPJ_DEF(pj_status_t) pjsua_reconfigure_logging(const pjsua_logging_config *cfg)\n{\n    pj_status_t status;\n\n    /* Save config. */\n    pjsua_logging_config_dup(pjsua_var.pool, &pjsua_var.log_cfg, cfg);\n\n    /* Redirect log function to ours */\n    pj_log_set_log_func( &log_writer );\n\n    /* Set decor */\n    pj_log_set_decor(pjsua_var.log_cfg.decor);\n\n    /* Set log level */\n    pj_log_set_level(pjsua_var.log_cfg.level);\n\n    /* Close existing file, if any */\n    if (pjsua_var.log_file) {\n\tpj_file_close(pjsua_var.log_file);\n\tpjsua_var.log_file = NULL;\n    }\n\n    /* If output log file is desired, create the file: */\n    if (pjsua_var.log_cfg.log_filename.slen) {\n\tunsigned flags = PJ_O_WRONLY;\n\tflags |= pjsua_var.log_cfg.log_file_flags;\n\tstatus = pj_file_open(pjsua_var.pool, \n\t\t\t      pjsua_var.log_cfg.log_filename.ptr,\n\t\t\t      flags, \n\t\t\t      &pjsua_var.log_file);\n\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error creating log file\", status);\n\t    return status;\n\t}\n    }\n\n    /* Unregister msg logging if it's previously registered */\n    if (pjsua_msg_logger.id >= 0) {\n\tpjsip_endpt_unregister_module(pjsua_var.endpt, &pjsua_msg_logger);\n\tpjsua_msg_logger.id = -1;\n    }\n\n    /* Enable SIP message logging */\n    if (pjsua_var.log_cfg.msg_logging)\n\tpjsip_endpt_register_module(pjsua_var.endpt, &pjsua_msg_logger);\n\n    return PJ_SUCCESS;\n}\n\n\n/*****************************************************************************\n * PJSUA Base API.\n */\n\n/* Worker thread function. */\nstatic int worker_thread(void *arg)\n{\n    enum { TIMEOUT = 10 };\n\n    PJ_UNUSED_ARG(arg);\n\n    while (!pjsua_var.thread_quit_flag) {\n\tint count;\n\n\tcount = pjsua_handle_events(TIMEOUT);\n\tif (count < 0)\n\t    pj_thread_sleep(TIMEOUT);\n    }\n\n    return 0;\n}\n\n#if PJSUA_SEPARATE_WORKER_FOR_TIMER\n\n/* Timer heap worker thread function. */\nstatic int worker_thread_timer(void *arg)\n{\n    pj_timer_heap_t *th;\n\n    PJ_UNUSED_ARG(arg);\n\n    th = pjsip_endpt_get_timer_heap(pjsua_var.endpt);\n    while (!pjsua_var.thread_quit_flag) {\n\tpj_time_val timeout = {0, 0};\n\tint c;\n\n\tc = pj_timer_heap_poll(th, &timeout);\n\tif (c == 0) {\n\t    /* Sleep if no event */\n\t    enum { MAX_SLEEP_MS = 100 };\n\t    if (PJ_TIME_VAL_MSEC(timeout) < MAX_SLEEP_MS)\n\t\tpj_thread_sleep(PJ_TIME_VAL_MSEC(timeout));\n\t    else\n\t\tpj_thread_sleep(MAX_SLEEP_MS);\n\t}\n    }\n    return 0;\n}\n\n/* Ioqueue worker thread function. */\nstatic int worker_thread_ioqueue(void *arg)\n{\n    pj_ioqueue_t *ioq;\n\n    PJ_UNUSED_ARG(arg);\n\n    ioq = pjsip_endpt_get_ioqueue(pjsua_var.endpt);\n    while (!pjsua_var.thread_quit_flag) {\n\tpj_time_val timeout = {0, 100};\n\tpj_ioqueue_poll(ioq, &timeout);\n    }\n    return 0;\n}\n\n#endif\n\nPJ_DEF(void) pjsua_stop_worker_threads(void)\n{\n    unsigned i;\n\n    pjsua_var.thread_quit_flag = 1;\n\n    /* Wait worker threads to quit: */\n    for (i=0; i<(int)pjsua_var.ua_cfg.thread_cnt; ++i) {\n    \tif (pjsua_var.thread[i]) {\n    \t    pj_status_t status;\n    \t    status = pj_thread_join(pjsua_var.thread[i]);\n    \t    if (status != PJ_SUCCESS) {\n    \t\tPJ_PERROR(4,(THIS_FILE, status, \"Error joining worker thread\"));\n    \t\tpj_thread_sleep(1000);\n    \t    }\n    \t    pj_thread_destroy(pjsua_var.thread[i]);\n    \t    pjsua_var.thread[i] = NULL;\n    \t}\n    }\n}\n\n/* Init random seed */\nstatic void init_random_seed(void)\n{\n    pj_sockaddr addr;\n    const pj_str_t *hostname;\n    pj_uint32_t pid;\n    pj_time_val t;\n    unsigned seed=0;\n\n    /* Add hostname */\n    hostname = pj_gethostname();\n    seed = pj_hash_calc(seed, hostname->ptr, (int)hostname->slen);\n\n    /* Add primary IP address */\n    if (pj_gethostip(pj_AF_INET(), &addr)==PJ_SUCCESS)\n\tseed = pj_hash_calc(seed, &addr.ipv4.sin_addr, 4);\n\n    /* Get timeofday */\n    pj_gettimeofday(&t);\n    seed = pj_hash_calc(seed, &t, sizeof(t));\n\n    /* Add PID */\n    pid = pj_getpid();\n    seed = pj_hash_calc(seed, &pid, sizeof(pid));\n\n    /* Init random seed */\n    pj_srand(seed);\n}\n\n/*\n * Instantiate pjsua application.\n */\nPJ_DEF(pj_status_t) pjsua_create(void)\n{\n    pj_status_t status;\n\n    /* Init pjsua data */\n    init_data();\n\n    /* Set default logging settings */\n    pjsua_logging_config_default(&pjsua_var.log_cfg);\n\n    /* Init PJLIB: */\n    status = pj_init();\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    pj_log_push_indent();\n\n    /* Init random seed */\n    init_random_seed();\n\n    /* Init PJLIB-UTIL: */\n    status = pjlib_util_init();\n    if (status != PJ_SUCCESS) {\n\tpj_log_pop_indent();\n\tpjsua_perror(THIS_FILE, \"Failed in initializing pjlib-util\", status);\n\tpj_shutdown();\n\treturn status;\n    }\n\n    /* Init PJNATH */\n    status = pjnath_init();\n    if (status != PJ_SUCCESS) {\n\tpj_log_pop_indent();\n\tpjsua_perror(THIS_FILE, \"Failed in initializing pjnath\", status);\n\tpj_shutdown();\n\treturn status;\n    }\n\n    /* Set default sound device ID */\n    pjsua_var.cap_dev = PJMEDIA_AUD_DEFAULT_CAPTURE_DEV;\n    pjsua_var.play_dev = PJMEDIA_AUD_DEFAULT_PLAYBACK_DEV;\n\n    /* Set default video device ID */\n    pjsua_var.vcap_dev = PJMEDIA_VID_DEFAULT_CAPTURE_DEV;\n    pjsua_var.vrdr_dev = PJMEDIA_VID_DEFAULT_RENDER_DEV;\n\n    /* Init caching pool. */\n    pj_caching_pool_init(&pjsua_var.cp, NULL, 0);\n\n    /* Create memory pools for application and internal use. */\n    pjsua_var.pool = pjsua_pool_create(\"pjsua\", PJSUA_POOL_LEN, PJSUA_POOL_INC);\n    pjsua_var.timer_pool = pjsua_pool_create(\"pjsua_timer\", 500, 500);\n    if (pjsua_var.pool == NULL || pjsua_var.timer_pool == NULL) {\n\tpj_log_pop_indent();\n\tstatus = PJ_ENOMEM;\n\tpjsua_perror(THIS_FILE, \"Unable to create pjsua/timer pool\", status);\n\tpj_shutdown();\n\treturn status;\n    }\n    \n    /* Create mutex */\n    status = pj_mutex_create_recursive(pjsua_var.pool, \"pjsua\", \n\t\t\t\t       &pjsua_var.mutex);\n    if (status != PJ_SUCCESS) {\n\tpj_log_pop_indent();\n\tpjsua_perror(THIS_FILE, \"Unable to create mutex\", status);\n\tpjsua_destroy();\n\treturn status;\n    }\n\n    /* Must create SIP endpoint to initialize SIP parser. The parser\n     * is needed for example when application needs to call pjsua_verify_url().\n     */\n    status = pjsip_endpt_create(&pjsua_var.cp.factory, \n\t\t\t\tpj_gethostname()->ptr, \n\t\t\t\t&pjsua_var.endpt);\n    if (status != PJ_SUCCESS) {\n\tpj_log_pop_indent();\n\tpjsua_perror(THIS_FILE, \"Unable to create endpoint\", status);\n\tpjsua_destroy();\n\treturn status;\n    }\n\n    /* Init timer entry and event list */\n    pj_list_init(&pjsua_var.active_timer_list);\n    pj_list_init(&pjsua_var.timer_list);\n    pj_list_init(&pjsua_var.event_list);\n\n    /* Create timer mutex */\n    status = pj_mutex_create_recursive(pjsua_var.pool, \"pjsua_timer\", \n\t\t\t\t       &pjsua_var.timer_mutex);\n    if (status != PJ_SUCCESS) {\n\tpj_log_pop_indent();\n\tpjsua_perror(THIS_FILE, \"Unable to create mutex\", status);\n\tpjsua_destroy();\n\treturn status;\n    }\n\n    pjsua_set_state(PJSUA_STATE_CREATED);\n    pj_log_pop_indent();\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Initialize pjsua with the specified settings. All the settings are \n * optional, and the default values will be used when the config is not\n * specified.\n */\nPJ_DEF(pj_status_t) pjsua_init( const pjsua_config *ua_cfg,\n\t\t\t\tconst pjsua_logging_config *log_cfg,\n\t\t\t\tconst pjsua_media_config *media_cfg)\n{\n    pjsua_config\t default_cfg;\n    pjsua_media_config\t default_media_cfg;\n    const pj_str_t\t STR_OPTIONS = { \"OPTIONS\", 7 };\n    pjsip_ua_init_param  ua_init_param;\n    unsigned i;\n    pj_status_t status;\n\n    pj_log_push_indent();\n\n    /* Create default configurations when the config is not supplied */\n\n    if (ua_cfg == NULL) {\n\tpjsua_config_default(&default_cfg);\n\tua_cfg = &default_cfg;\n    }\n\n    if (media_cfg == NULL) {\n\tpjsua_media_config_default(&default_media_cfg);\n\tmedia_cfg = &default_media_cfg;\n    }\n\n    /* Initialize logging first so that info/errors can be captured */\n    if (log_cfg) {\n\tstatus = pjsua_reconfigure_logging(log_cfg);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n    }\n\n#if defined(PJ_IPHONE_OS_HAS_MULTITASKING_SUPPORT) && \\\n    PJ_IPHONE_OS_HAS_MULTITASKING_SUPPORT != 0\n    if (!(pj_get_sys_info()->flags & PJ_SYS_HAS_IOS_BG)) {\n\tPJ_LOG(5, (THIS_FILE, \"Device does not support \"\n\t\t\t      \"background mode\"));\n\tpj_activesock_enable_iphone_os_bg(PJ_FALSE);\n    }\n#endif\n\n    /* If nameserver is configured, create DNS resolver instance and\n     * set it to be used by SIP resolver.\n     */\n    if (ua_cfg->nameserver_count) {\n#if PJSIP_HAS_RESOLVER\n\tunsigned ii;\n\n\t/* Create DNS resolver */\n\tstatus = pjsip_endpt_create_resolver(pjsua_var.endpt, \n\t\t\t\t\t     &pjsua_var.resolver);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error creating resolver\", status);\n\t    goto on_error;\n\t}\n\n\t/* Configure nameserver for the DNS resolver */\n\tstatus = pj_dns_resolver_set_ns(pjsua_var.resolver, \n\t\t\t\t\tua_cfg->nameserver_count,\n\t\t\t\t\tua_cfg->nameserver, NULL);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error setting nameserver\", status);\n\t    goto on_error;\n\t}\n\n\t/* Set this DNS resolver to be used by the SIP resolver */\n\tstatus = pjsip_endpt_set_resolver(pjsua_var.endpt, pjsua_var.resolver);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error setting DNS resolver\", status);\n\t    goto on_error;\n\t}\n\n\t/* Print nameservers */\n\tfor (ii=0; ii<ua_cfg->nameserver_count; ++ii) {\n\t    PJ_LOG(4,(THIS_FILE, \"Nameserver %.*s added\",\n\t\t      (int)ua_cfg->nameserver[ii].slen,\n\t\t      ua_cfg->nameserver[ii].ptr));\n\t}\n#else\n\tPJ_LOG(2,(THIS_FILE, \n\t\t  \"DNS resolver is disabled (PJSIP_HAS_RESOLVER==0)\"));\n#endif\n    }\n\n    /* Init SIP UA: */\n\n    /* Initialize transaction layer: */\n    status = pjsip_tsx_layer_init_module(pjsua_var.endpt);\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n\n    /* Initialize UA layer module: */\n    pj_bzero(&ua_init_param, sizeof(ua_init_param));\n    if (ua_cfg->hangup_forked_call) {\n\tua_init_param.on_dlg_forked = &on_dlg_forked;\n    }\n    status = pjsip_ua_init_module( pjsua_var.endpt, &ua_init_param);\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n\n    /* Initialize Replaces support. */\n    status = pjsip_replaces_init_module( pjsua_var.endpt );\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    /* Initialize 100rel support */\n    status = pjsip_100rel_init_module(pjsua_var.endpt);\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    /* Initialize session timer support */\n    status = pjsip_timer_init_module(pjsua_var.endpt);\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    /* Initialize and register PJSUA application module. */\n    {\n\tconst pjsip_module mod_initializer = \n\t{\n\tNULL, NULL,\t\t    /* prev, next.\t\t\t*/\n\t{ \"mod-pjsua\", 9 },\t    /* Name.\t\t\t\t*/\n\t-1,\t\t\t    /* Id\t\t\t\t*/\n\tPJSIP_MOD_PRIORITY_APPLICATION,\t/* Priority\t\t\t*/\n\tNULL,\t\t\t    /* load()\t\t\t\t*/\n\tNULL,\t\t\t    /* start()\t\t\t\t*/\n\tNULL,\t\t\t    /* stop()\t\t\t\t*/\n\tNULL,\t\t\t    /* unload()\t\t\t\t*/\n\t&mod_pjsua_on_rx_request,   /* on_rx_request()\t\t\t*/\n\t&mod_pjsua_on_rx_response,  /* on_rx_response()\t\t\t*/\n\tNULL,\t\t\t    /* on_tx_request.\t\t\t*/\n\tNULL,\t\t\t    /* on_tx_response()\t\t\t*/\n\tNULL,\t\t\t    /* on_tsx_state()\t\t\t*/\n\t};\n\n\tpjsua_var.mod = mod_initializer;\n\n\tstatus = pjsip_endpt_register_module(pjsua_var.endpt, &pjsua_var.mod);\n\tPJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n    }\n\n    /* Parse outbound proxies */\n    for (i=0; i<ua_cfg->outbound_proxy_cnt; ++i) {\n\tpj_str_t tmp;\n    \tpj_str_t hname = { \"Route\", 5};\n\tpjsip_route_hdr *r;\n\n\tpj_strdup_with_null(pjsua_var.pool, &tmp, &ua_cfg->outbound_proxy[i]);\n\n\tr = (pjsip_route_hdr*)\n\t    pjsip_parse_hdr(pjsua_var.pool, &hname, tmp.ptr,\n\t\t\t    (unsigned)tmp.slen, NULL);\n\tif (r == NULL) {\n\t    pjsua_perror(THIS_FILE, \"Invalid outbound proxy URI\",\n\t\t\t PJSIP_EINVALIDURI);\n\t    status = PJSIP_EINVALIDURI;\n\t    goto on_error;\n\t}\n\n\tif (pjsua_var.ua_cfg.force_lr) {\n\t    pjsip_sip_uri *sip_url;\n\t    if (!PJSIP_URI_SCHEME_IS_SIP(r->name_addr.uri) &&\n\t\t!PJSIP_URI_SCHEME_IS_SIPS(r->name_addr.uri))\n\t    {\n\t\tstatus = PJSIP_EINVALIDSCHEME;\n\t\tgoto on_error;\n\t    }\n\t    sip_url = (pjsip_sip_uri*)r->name_addr.uri;\n\t    sip_url->lr_param = 1;\n\t}\n\n\tpj_list_push_back(&pjsua_var.outbound_proxy, r);\n    }\n    \n\n    /* Initialize PJSUA call subsystem: */\n    status = pjsua_call_subsys_init(ua_cfg);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Convert deprecated STUN settings */\n    if (pjsua_var.ua_cfg.stun_srv_cnt==0) {\n\tif (pjsua_var.ua_cfg.stun_domain.slen) {\n\t    pjsua_var.ua_cfg.stun_srv[pjsua_var.ua_cfg.stun_srv_cnt++] = \n\t\tpjsua_var.ua_cfg.stun_domain;\n\t}\n\tif (pjsua_var.ua_cfg.stun_host.slen) {\n\t    pjsua_var.ua_cfg.stun_srv[pjsua_var.ua_cfg.stun_srv_cnt++] = \n\t\tpjsua_var.ua_cfg.stun_host;\n\t}\n    }\n\n    /* Start resolving STUN server */\n    status = resolve_stun_server(PJ_FALSE, PJ_FALSE, 0);\n    if (status != PJ_SUCCESS && status != PJ_EPENDING) {\n\tpjsua_perror(THIS_FILE, \"Error resolving STUN server\", status);\n\tgoto on_error;\n    }\n\n    /* Initialize PJSUA media subsystem */\n    status = pjsua_media_subsys_init(media_cfg);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n\n    /* Init core SIMPLE module : */\n    status = pjsip_evsub_init_module(pjsua_var.endpt);\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n\n    /* Init presence module: */\n    status = pjsip_pres_init_module( pjsua_var.endpt, pjsip_evsub_instance());\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    /* Initialize MWI support */\n    status = pjsip_mwi_init_module(pjsua_var.endpt, pjsip_evsub_instance());\n\n    /* Init PUBLISH module */\n    pjsip_publishc_init_module(pjsua_var.endpt);\n\n    /* Init xfer/REFER module */\n    status = pjsip_xfer_init_module( pjsua_var.endpt );\n    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);\n\n    /* Init pjsua presence handler: */\n    status = pjsua_pres_init();\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Init out-of-dialog MESSAGE request handler. */\n    status = pjsua_im_init();\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Register OPTIONS handler */\n    pjsip_endpt_register_module(pjsua_var.endpt, &pjsua_options_handler);\n\n    /* Add OPTIONS in Allow header */\n    pjsip_endpt_add_capability(pjsua_var.endpt, NULL, PJSIP_H_ALLOW,\n\t\t\t       NULL, 1, &STR_OPTIONS);\n\n    /* Start worker thread if needed. */\n    if (pjsua_var.ua_cfg.thread_cnt) {\n\tunsigned ii;\n\n\tif (pjsua_var.ua_cfg.thread_cnt > PJ_ARRAY_SIZE(pjsua_var.thread))\n\t    pjsua_var.ua_cfg.thread_cnt = PJ_ARRAY_SIZE(pjsua_var.thread);\n\n#if PJSUA_SEPARATE_WORKER_FOR_TIMER\n\tif (pjsua_var.ua_cfg.thread_cnt < 2)\n\t    pjsua_var.ua_cfg.thread_cnt = 2;\n#endif\n\n\tfor (ii=0; ii<pjsua_var.ua_cfg.thread_cnt; ++ii) {\n\t    char tname[16];\n\t    \n\t    pj_ansi_snprintf(tname, sizeof(tname), \"pjsua_%d\", ii);\n\n#if PJSUA_SEPARATE_WORKER_FOR_TIMER\n\t    if (ii == 0) {\n\t\tstatus = pj_thread_create(pjsua_var.pool, tname,\n\t\t\t\t\t  &worker_thread_timer,\n\t\t\t\t\t  NULL, 0, 0, &pjsua_var.thread[ii]);\n\t    } else {\n\t\tstatus = pj_thread_create(pjsua_var.pool, tname,\n\t\t\t\t\t  &worker_thread_ioqueue,\n\t\t\t\t\t  NULL, 0, 0, &pjsua_var.thread[ii]);\n\t    }\n#else\n\t    status = pj_thread_create(pjsua_var.pool, tname, &worker_thread,\n\t\t\t\t      NULL, 0, 0, &pjsua_var.thread[ii]);\n#endif\n\t    if (status != PJ_SUCCESS)\n\t\tgoto on_error;\n\t}\n\tPJ_LOG(4,(THIS_FILE, \"%d SIP worker threads created\", \n\t\t  pjsua_var.ua_cfg.thread_cnt));\n    } else {\n\tPJ_LOG(4,(THIS_FILE, \"No SIP worker threads created\"));\n    }\n\n    /* Done! */\n\n    PJ_LOG(3,(THIS_FILE, \"pjsua version %s for %s initialized\", \n\t\t\t pj_get_version(), pj_get_sys_info()->info.ptr));\n\n    pjsua_set_state(PJSUA_STATE_INIT);\n    pj_log_pop_indent();\n    return PJ_SUCCESS;\n\non_error:\n    pj_log_pop_indent();\n    return status;\n}\n\n\n/* Sleep with polling */\nstatic void busy_sleep(unsigned msec)\n{\n    pj_time_val timeout, now;\n\n    pj_gettickcount(&timeout);\n    timeout.msec += msec;\n    pj_time_val_normalize(&timeout);\n\n    do {\n\tint i;\n\ti = msec / 10;\n\twhile (pjsua_handle_events(10) > 0 && i > 0)\n\t    --i;\n\tpj_gettickcount(&now);\n    } while (PJ_TIME_VAL_LT(now, timeout));\n}\n\nstatic void stun_resolve_add_ref(pjsua_stun_resolve *sess)\n{\n    ++sess->ref_cnt;\n}\n\n\nstatic void release_stun_session(pjsua_stun_resolve *sess)\n{\n    PJSUA_LOCK();\n    pj_list_erase(sess);\n    PJSUA_UNLOCK();\n\n    pj_assert(sess->stun_sock==NULL);\n    pj_pool_release(sess->pool);\n}\n\nstatic void destroy_stun_resolve_cb(pj_timer_heap_t *t, pj_timer_entry *e)\n{\n    pjsua_stun_resolve *sess = (pjsua_stun_resolve*)e->user_data;\n    PJ_UNUSED_ARG(t);\n\n    release_stun_session(sess);\n}\n\n\nstatic void destroy_stun_resolve(pjsua_stun_resolve *sess, pj_bool_t forced)\n{\n    pj_time_val timeout = {0, 0};\n\n    if (sess->destroy_flag)\n\treturn;\n\n    sess->destroy_flag = PJ_TRUE;\n    if (sess->stun_sock) {\n        pj_stun_sock_destroy(sess->stun_sock);\n        sess->stun_sock = NULL;\n    }\n\n    if (pjsua_var.stun_status == PJ_EUNKNOWN ||\n    \tpjsua_var.stun_status == PJ_EPENDING)\n    {\n        pjsua_var.stun_status = PJNATH_ESTUNDESTROYED;\n    }\n\n    if (forced) {\n\trelease_stun_session(sess);\n    } else {\n\t/* Schedule session clean up, it needs PJSUA lock and locking it here\n\t * may cause deadlock as this function may be called by STUN socket\n\t * while holding STUN socket lock, while application may wait for STUN\n\t * resolution while holding PJSUA lock.\n\t */\n\tpj_timer_entry_init(&sess->timer, 0, (void*)sess,\n\t\t\t    &destroy_stun_resolve_cb);\n\tpjsua_schedule_timer(&sess->timer, &timeout);\n    }\n}\n\nstatic void stun_resolve_dec_ref(pjsua_stun_resolve *sess)\n{\n    int ref_cnt = --sess->ref_cnt;\n    /* If the STUN resolution session is blocking, only the waiting thread\n     * is allowed to destroy the session, otherwise it may cause deadlock.\n     */\n    if ((ref_cnt > 0) ||\n\t(sess->blocking && (sess->waiter != pj_thread_this()))) \n    {\n\treturn;\n    }\n\n    destroy_stun_resolve(sess, PJ_FALSE);\n}\n\n\n/* This is the internal function to be called when STUN resolution\n * session (pj_stun_resolve) has completed.\n */\nstatic void stun_resolve_complete(pjsua_stun_resolve *sess)\n{\n    pj_stun_resolve_result result;\n\n    if (sess->has_result)\n\tgoto on_return;\n\n    pj_bzero(&result, sizeof(result));\n    result.token = sess->token;\n    result.status = sess->status;\n    result.name = sess->srv[sess->idx];\n    result.index = sess->idx;\n    pj_memcpy(&result.addr, &sess->addr, sizeof(result.addr));\n    sess->has_result = PJ_TRUE;\n\n    if (result.status == PJ_SUCCESS) {\n\tchar addr[PJ_INET6_ADDRSTRLEN+10];\n\tpj_sockaddr_print(&result.addr, addr, sizeof(addr), 3);\n\tPJ_LOG(4,(THIS_FILE, \n\t\t  \"STUN resolution success, using %.*s, address is %s\",\n\t\t  (int)sess->srv[sess->idx].slen,\n\t\t  sess->srv[sess->idx].ptr,\n\t\t  addr));\n    } else {\n\tchar errmsg[PJ_ERR_MSG_SIZE];\n\tpj_strerror(result.status, errmsg, sizeof(errmsg));\n\tPJ_LOG(1,(THIS_FILE, \"STUN resolution failed: %s\", errmsg));\n    }\n\n    sess->cb(&result);\n\non_return:\n    if (!sess->blocking) {\n\tstun_resolve_dec_ref(sess);\n    }\n}\n\n/* This is the callback called by the STUN socket (pj_stun_sock)\n * to report it's state. We use this as part of testing the\n * STUN server.\n */\nstatic pj_bool_t test_stun_on_status(pj_stun_sock *stun_sock, \n\t\t\t\t     pj_stun_sock_op op,\n\t\t\t\t     pj_status_t status)\n{\n    pjsua_stun_resolve *sess;\n\n    sess = (pjsua_stun_resolve*) pj_stun_sock_get_user_data(stun_sock);\n    pj_assert(stun_sock == sess->stun_sock);\n\n    if (status != PJ_SUCCESS) {\n\tchar errmsg[PJ_ERR_MSG_SIZE];\n\tpj_strerror(status, errmsg, sizeof(errmsg));\n\n\tPJ_LOG(4,(THIS_FILE, \"STUN resolution for %.*s failed: %s\",\n\t\t  (int)sess->srv[sess->idx].slen,\n\t\t  sess->srv[sess->idx].ptr, errmsg));\n\n\tif (op == PJ_STUN_SOCK_BINDING_OP && !sess->async_wait) {\n\t    /* Just return here, we will destroy the STUN socket and\n\t     * continue the STUN resolution later in resolve_stun_entry().\n\t     * For more details, please refer to ticket #1962.\n\t     */\n            return PJ_FALSE;\n\t}\n\n\tpj_stun_sock_destroy(stun_sock);\n\tsess->stun_sock = NULL;\n\n\tstun_resolve_add_ref(sess);\n\n\tif (pjsua_var.ua_cfg.stun_try_ipv6 && sess->af == pj_AF_INET()) {\n\t    sess->af = pj_AF_INET6();\n\t} else {\n\t    ++sess->idx;\n\t    sess->af = pj_AF_INET();\n\t    if (sess->idx >= sess->count)\n                sess->status = status;\n        }\n\n\tresolve_stun_entry(sess);\n\n\tstun_resolve_dec_ref(sess);\n\n\treturn PJ_FALSE;\n\n    } else if (op == PJ_STUN_SOCK_BINDING_OP) {\n\tpj_stun_sock_info ssi;\n\n\tpj_stun_sock_get_info(stun_sock, &ssi);\n\tpj_memcpy(&sess->addr, &ssi.srv_addr, sizeof(sess->addr));\n\n\tstun_resolve_add_ref(sess);\n\n\tsess->status = PJ_SUCCESS;\n\tpj_stun_sock_destroy(stun_sock);\n\tsess->stun_sock = NULL;\n\n\tstun_resolve_complete(sess);\n\n\tstun_resolve_dec_ref(sess);\n\n\treturn PJ_FALSE;\n\n    } else\n\treturn PJ_TRUE;\n    \n}\n\n/* This is an internal function to resolve and test current\n * server entry in pj_stun_resolve session. It is called by\n * pjsua_resolve_stun_servers() and test_stun_on_status() above\n */\nstatic void resolve_stun_entry(pjsua_stun_resolve *sess)\n{\n    pj_status_t status = PJ_EUNKNOWN;\n\n    /* Loop while we have entry to try */\n    for (; sess->idx < sess->count;\n    \t (pjsua_var.ua_cfg.stun_try_ipv6 && sess->af == pj_AF_INET())?\n\t sess->af = pj_AF_INET6(): (++sess->idx, sess->af = pj_AF_INET()))\n    {\n\tint af;\n\tchar target[64];\n\tpj_str_t hostpart;\n\tpj_uint16_t port;\n\tpj_stun_sock_cb stun_sock_cb;\n\t\n\tpj_assert(sess->idx < sess->count);\n\n\tif (pjsua_var.ua_cfg.stun_try_ipv6 &&\n\t    pjsua_var.stun_opt != PJSUA_NAT64_DISABLED &&\n\t    sess->af == pj_AF_INET())\n\t{\n\t    /* Skip IPv4 STUN resolution if NAT64 is not disabled. */\n\t    PJ_LOG(4,(THIS_FILE, \"Skipping IPv4 resolution of STUN server \"\n\t    \t\t\t \"%s (%d of %d)\", target,\n\t    \t\t\t sess->idx+1, sess->count));\t    \n\t    continue;\n\t}\n\n\tpj_ansi_snprintf(target, sizeof(target), \"%.*s\",\n\t\t\t (int)sess->srv[sess->idx].slen,\n\t\t\t sess->srv[sess->idx].ptr);\n\n\t/* Parse the server entry into host:port */\n\tstatus = pj_sockaddr_parse2(pj_AF_UNSPEC(), 0, &sess->srv[sess->idx],\n\t\t\t\t    &hostpart, &port, &af);\n\tif (status != PJ_SUCCESS) {\n    \t    PJ_LOG(2,(THIS_FILE, \"Invalid STUN server entry %s\", target));\n\t    continue;\n\t}\n\t\n\t/* Use default port if not specified */\n\tif (port == 0)\n\t    port = PJ_STUN_PORT;\n\n\tpj_assert(sess->stun_sock == NULL);\n\n\tPJ_LOG(4,(THIS_FILE, \"Trying STUN server %s %s (%d of %d)..\",\n\t\t  target, (sess->af == pj_AF_INET()? \"IPv4\": \"IPv6\"),\n\t\t  sess->idx+1, sess->count));\n\n\t/* Use STUN_sock to test this entry */\n\tpj_bzero(&stun_sock_cb, sizeof(stun_sock_cb));\n\tstun_sock_cb.on_status = &test_stun_on_status;\n\tsess->async_wait = PJ_FALSE;\n\tstatus = pj_stun_sock_create(&pjsua_var.stun_cfg, \"stunresolve\",\n\t\t\t\t     sess->af, &stun_sock_cb,\n\t\t\t\t     NULL, sess, &sess->stun_sock);\n\tif (status != PJ_SUCCESS) {\n\t    char errmsg[PJ_ERR_MSG_SIZE];\n\t    pj_strerror(status, errmsg, sizeof(errmsg));\n\t    PJ_LOG(4,(THIS_FILE, \n\t\t     \"Error creating STUN socket for %s: %s\",\n\t\t     target, errmsg));\n\n\t    continue;\n\t}\n\n\tstatus = pj_stun_sock_start(sess->stun_sock, &hostpart, port,\n\t\t\t\t    pjsua_var.resolver);\n\tif (status != PJ_SUCCESS) {\n\t    char errmsg[PJ_ERR_MSG_SIZE];\n\t    pj_strerror(status, errmsg, sizeof(errmsg));\n\t    PJ_LOG(4,(THIS_FILE, \n\t\t     \"Error starting STUN socket for %s: %s\",\n\t\t     target, errmsg));\n\n\t    if (sess->stun_sock) {\n\t\tpj_stun_sock_destroy(sess->stun_sock);\n\t\tsess->stun_sock = NULL;\n\t    }\n\t    continue;\n\t}\n\n\t/* Done for now, testing will resume/complete asynchronously in\n\t * stun_sock_cb()\n\t */\n\tsess->async_wait = PJ_TRUE;\n\treturn;\n    }\n\n    if (sess->idx >= sess->count) {\n\t/* No more entries to try */\n\tstun_resolve_add_ref(sess);\n\tpj_assert(status != PJ_SUCCESS || sess->status != PJ_EPENDING);\n        if (sess->status == PJ_EPENDING)\n            sess->status = status;\n\tstun_resolve_complete(sess);\n\tstun_resolve_dec_ref(sess);\n    }\n}\n\n\n/*\n * Update STUN servers.\n */\nPJ_DEF(pj_status_t) pjsua_update_stun_servers(unsigned count, pj_str_t srv[],\n\t\t\t\t\t      pj_bool_t wait)\n{\n    unsigned i;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(count && srv, PJ_EINVAL);\n    \n    PJSUA_LOCK();\n\n    pjsua_var.ua_cfg.stun_srv_cnt = count;\n    for (i = 0; i < count; i++) {\n        if (pj_strcmp(&pjsua_var.ua_cfg.stun_srv[i], &srv[i]))\n            pj_strdup(pjsua_var.pool, &pjsua_var.ua_cfg.stun_srv[i], &srv[i]);\n    }\n    pjsua_var.stun_status = PJ_EUNKNOWN;\n\n    PJSUA_UNLOCK();\n    \n    status = resolve_stun_server(wait, PJ_FALSE, 0);\n    if (wait == PJ_FALSE && status == PJ_EPENDING)\n        status = PJ_SUCCESS;\n\n    return status;\n}\n\n\n/*\n * Resolve STUN server.\n */\nPJ_DEF(pj_status_t) pjsua_resolve_stun_servers( unsigned count,\n\t\t\t\t\t\tpj_str_t srv[],\n\t\t\t\t\t\tpj_bool_t wait,\n\t\t\t\t\t\tvoid *token,\n\t\t\t\t\t\tpj_stun_resolve_cb cb)\n{\n    pj_pool_t *pool;\n    pjsua_stun_resolve *sess;\n    pj_status_t status;\n    unsigned i, max_wait_ms;\n    pj_timestamp start, now;\n\n    PJ_ASSERT_RETURN(count && srv && cb, PJ_EINVAL);\n\n    pool = pjsua_pool_create(\"stunres\", 256, 256);\n    if (!pool)\n\treturn PJ_ENOMEM;\n\n    sess = PJ_POOL_ZALLOC_T(pool, pjsua_stun_resolve);\n    sess->pool = pool;\n    sess->token = token;\n    sess->cb = cb;\n    sess->count = count;\n    sess->blocking = wait;\n    sess->waiter = pj_thread_this();\n    sess->status = PJ_EPENDING;\n    sess->af = pj_AF_INET();\n    stun_resolve_add_ref(sess);\n    sess->srv = (pj_str_t*) pj_pool_calloc(pool, count, sizeof(pj_str_t));\n    for (i=0; i<count; ++i) {\n\tpj_strdup(pool, &sess->srv[i], &srv[i]);\n    }\n\n    PJSUA_LOCK();\n    pj_list_push_back(&pjsua_var.stun_res, sess);\n    PJSUA_UNLOCK();\n\n    resolve_stun_entry(sess);\n\n    if (!wait)\n\treturn PJ_SUCCESS;\n\n    /* Should limit the wait time to avoid deadlock. For example,\n     * if app holds dlg/tsx lock, pjsua worker thread will block on\n     * any dlg/tsx state change.\n     */\n    max_wait_ms = count * pjsua_var.stun_cfg.rto_msec * (1 << 7);\n    pj_get_timestamp(&start);\n    \n    while ((sess->status == PJ_EPENDING) && (!sess->destroy_flag)) {\n        /* If there is no worker thread or\n         * the function is called from the only worker thread,\n         * we have to handle the events here.\n         */\n        if (pjsua_var.thread[0] == NULL ||\n            (pj_thread_this() == pjsua_var.thread[0] &&\n             pjsua_var.ua_cfg.thread_cnt == 1))\n            {\n            pjsua_handle_events(50);\n        } else {\n            pj_thread_sleep(20);\n        }\n\n\tpj_get_timestamp(&now);\n\tif (pj_elapsed_msec(&start, &now) > max_wait_ms)\n\t    sess->status = PJ_ETIMEDOUT;\n    }\n\n    status = sess->status;\n    stun_resolve_dec_ref(sess);\n\n    return status;\n}\n\n/*\n * Cancel pending STUN resolution.\n */\nPJ_DEF(pj_status_t) pjsua_cancel_stun_resolution( void *token,\n\t\t\t\t\t\t  pj_bool_t notify_cb)\n{\n    pjsua_stun_resolve *sess;\n    unsigned cancelled_count = 0;\n\n    PJSUA_LOCK();\n    sess = pjsua_var.stun_res.next;\n    while (sess != &pjsua_var.stun_res) {\n\tpjsua_stun_resolve *next = sess->next;\n\n\tif (sess->token == token) {\n\t    sess->has_result = PJ_TRUE;\n\t    sess->status = PJ_ECANCELLED;\n\t    if (notify_cb) {\n\t\tpj_stun_resolve_result result;\n\n\t\tpj_bzero(&result, sizeof(result));\n\t\tresult.token = token;\n\t\tresult.status = PJ_ECANCELLED;\n\n\t\tsess->cb(&result);\n\t    }\t    \n\t    ++cancelled_count;\n\t}\n\n\tsess = next;\n    }\n    PJSUA_UNLOCK();\n\n    return cancelled_count ? PJ_SUCCESS : PJ_ENOTFOUND;\n}\n\nstatic void internal_stun_resolve_cb(const pj_stun_resolve_result *result)\n{\n    pjsua_var.stun_status = result->status;\n    if ((result->status == PJ_SUCCESS) && (pjsua_var.ua_cfg.stun_srv_cnt>0)) {\n\tpj_memcpy(&pjsua_var.stun_srv, &result->addr, sizeof(result->addr));\n\tpjsua_var.stun_srv_idx = result->index;\n\n\t/* Perform NAT type detection if not yet */\n\tif (pjsua_var.nat_type == PJ_STUN_NAT_TYPE_UNKNOWN &&\n\t    !pjsua_var.nat_in_progress &&\n\t    pjsua_var.ua_cfg.nat_type_in_sdp)\n\t{\n\t    pjsua_detect_nat_type();\n\t}\n    }\n    \n    if (pjsua_var.ua_cfg.cb.on_stun_resolution_complete)\n    \t(*pjsua_var.ua_cfg.cb.on_stun_resolution_complete)(result);\n}\n\n/*\n * Resolve STUN server.\n */\npj_status_t resolve_stun_server(pj_bool_t wait, pj_bool_t retry_if_cur_error,\n\t\t\t\tunsigned options)\n{\n    pjsua_var.stun_opt = options;\n\n    /* Retry resolving if currently the STUN status is error */\n    if (pjsua_var.stun_status != PJ_EPENDING &&\n\tpjsua_var.stun_status != PJ_SUCCESS &&\n\tretry_if_cur_error)\n    {\n\tpjsua_var.stun_status = PJ_EUNKNOWN;\n    }\n\n    if (pjsua_var.stun_status == PJ_EUNKNOWN) {\n\tpj_status_t status;\n\n\t/* Initialize STUN configuration */\n\tpj_stun_config_init(&pjsua_var.stun_cfg, &pjsua_var.cp.factory, 0,\n\t\t\t    pjsip_endpt_get_ioqueue(pjsua_var.endpt),\n\t\t\t    pjsip_endpt_get_timer_heap(pjsua_var.endpt));\n\n\t/* Start STUN server resolution */\n\tif (pjsua_var.ua_cfg.stun_srv_cnt) {\n\t    pjsua_var.stun_status = PJ_EPENDING;\n\t    status = pjsua_resolve_stun_servers(pjsua_var.ua_cfg.stun_srv_cnt,\n\t\t\t\t\t\tpjsua_var.ua_cfg.stun_srv,\n\t\t\t\t\t\twait, NULL,\n\t\t\t\t\t\t&internal_stun_resolve_cb);\n\t    if (wait || status != PJ_SUCCESS) {\n\t\tpjsua_var.stun_status = status;\n\t    }\n\t} else {\n\t    pjsua_var.stun_status = PJ_SUCCESS;\n\t}\n\n    } else if (pjsua_var.stun_status == PJ_EPENDING) {\n\t/* STUN server resolution has been started, wait for the\n\t * result.\n\t */\n\tif (wait) {\n\t    unsigned max_wait_ms;\n\t    pj_timestamp start, now;\n\n\t    /* Should limit the wait time to avoid deadlock. For example,\n\t     * if app holds dlg/tsx lock, pjsua worker thread will block on\n\t     * any dlg/tsx state change.\n\t     */\n\t    max_wait_ms = pjsua_var.ua_cfg.stun_srv_cnt *\n\t\t\t  pjsua_var.stun_cfg.rto_msec * (1 << 7);\n\t    pj_get_timestamp(&start);\n\n\t    while (pjsua_var.stun_status == PJ_EPENDING) {\t\t\n                /* If there is no worker thread or\n                 * the function is called from the only worker thread,\n                 * we have to handle the events here.\n                 */\n\t\tif (pjsua_var.thread[0] == NULL ||\n                    (pj_thread_this() == pjsua_var.thread[0] &&\n                     pjsua_var.ua_cfg.thread_cnt == 1))\n                {\n\t\t    pjsua_handle_events(10);\n                } else {\n\t\t    pj_thread_sleep(10);\n                }\n\n\t\tpj_get_timestamp(&now);\n\t\tif (pj_elapsed_msec(&start, &now) > max_wait_ms)\n\t\t    return PJ_ETIMEDOUT;\n\t    }\n\t}\n    }\n\n    if (pjsua_var.stun_status != PJ_EPENDING &&\n\tpjsua_var.stun_status != PJ_SUCCESS &&\n\tpjsua_var.ua_cfg.stun_ignore_failure)\n    {\n\tPJ_LOG(2,(THIS_FILE, \n\t\t  \"Ignoring STUN resolution failure (by setting)\"));\n\t//pjsua_var.stun_status = PJ_SUCCESS;\n\treturn PJ_SUCCESS;\n    }\n\n    return pjsua_var.stun_status;\n}\n\n/*\n * Destroy pjsua.\n */\nPJ_DEF(pj_status_t) pjsua_destroy2(unsigned flags)\n{\n    int i;  /* Must be signed */\n\n    if (pjsua_var.endpt) {\n\tPJ_LOG(4,(THIS_FILE, \"Shutting down, flags=%d...\", flags));\n    }\n\n    if (pjsua_var.state > PJSUA_STATE_NULL &&\n\tpjsua_var.state < PJSUA_STATE_CLOSING)\n    {\n\tpjsua_set_state(PJSUA_STATE_CLOSING);\n    }\n\n    /* Signal threads to quit: */\n    pjsua_stop_worker_threads();\n    \n    if (pjsua_var.endpt) {\n\tunsigned max_wait;\n\n\tpj_log_push_indent();\n\n\t/* Terminate all calls. */\n\tif ((flags & PJSUA_DESTROY_NO_TX_MSG) == 0) {\n\t    pjsua_call_hangup_all();\n\t}\n\n\t/* Deinit media channel of all calls (see #1717) */\n\tfor (i=0; i<(int)pjsua_var.ua_cfg.max_calls; ++i) {\n\t    /* TODO: check if we're not allowed to send to network in the\n\t     *       \"flags\", and if so do not do TURN allocation...\n\t     */\n\t    pjsua_media_channel_deinit(i);\n\t}\n\n\t/* Set all accounts to offline */\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (!pjsua_var.acc[i].valid)\n\t\tcontinue;\n\t    pjsua_var.acc[i].online_status = PJ_FALSE;\n\t    pj_bzero(&pjsua_var.acc[i].rpid, sizeof(pjrpid_element));\n\t}\n\n\t/* Terminate all presence subscriptions. */\n\tpjsua_pres_shutdown(flags);\n\n\t/* Wait for sometime until all publish client sessions are done\n\t * (ticket #364)\n\t */\n\t/* First stage, get the maximum wait time */\n\tmax_wait = 100;\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (!pjsua_var.acc[i].valid)\n\t\tcontinue;\n\t    if (pjsua_var.acc[i].cfg.unpublish_max_wait_time_msec > max_wait)\n\t\tmax_wait = pjsua_var.acc[i].cfg.unpublish_max_wait_time_msec;\n\t}\n\t\n\t/* No waiting if RX is disabled */\n\tif (flags & PJSUA_DESTROY_NO_RX_MSG) {\n\t    max_wait = 0;\n\t}\n\n\t/* Second stage, wait for unpublications to complete */\n\tfor (i=0; i<(int)(max_wait/50); ++i) {\n\t    unsigned j;\n\t    for (j=0; j<PJ_ARRAY_SIZE(pjsua_var.acc); ++j) {\n\t\tif (!pjsua_var.acc[j].valid)\n\t\t    continue;\n\n\t\tif (pjsua_var.acc[j].publish_sess)\n\t\t    break;\n\t    }\n\t    if (j != PJ_ARRAY_SIZE(pjsua_var.acc))\n\t\tbusy_sleep(50);\n\t    else\n\t\tbreak;\n\t}\n\n\t/* Third stage, forcefully destroy unfinished unpublications */\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (pjsua_var.acc[i].publish_sess) {\n\t\tpjsip_publishc_destroy(pjsua_var.acc[i].publish_sess);\n\t\tpjsua_var.acc[i].publish_sess = NULL;\n\t    }\n\t}\n\n\t/* Unregister all accounts */\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (!pjsua_var.acc[i].valid)\n\t\tcontinue;\n\n\t    if (pjsua_var.acc[i].regc && (flags & PJSUA_DESTROY_NO_TX_MSG)==0)\n\t    {\n\t\tpjsua_acc_set_registration(i, PJ_FALSE);\n\t    }\n#if PJ_HAS_SSL_SOCK\n\t    pj_turn_sock_tls_cfg_wipe_keys(\n\t\t\t      &pjsua_var.acc[i].cfg.turn_cfg.turn_tls_setting);\n#endif\n\t}\n\n\t/* Wait until all unregistrations are done (ticket #364) */\n\t/* First stage, get the maximum wait time */\n\tmax_wait = 100;\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (!pjsua_var.acc[i].valid)\n\t\tcontinue;\n\t    if (pjsua_var.acc[i].cfg.unreg_timeout > max_wait)\n\t\tmax_wait = pjsua_var.acc[i].cfg.unreg_timeout;\n\t}\n\t\n\t/* No waiting if RX is disabled */\n\tif (flags & PJSUA_DESTROY_NO_RX_MSG) {\n\t    max_wait = 0;\n\t}\n\n\t/* Second stage, wait for unregistrations to complete */\n\tfor (i=0; i<(int)(max_wait/50); ++i) {\n\t    unsigned j;\n\t    for (j=0; j<PJ_ARRAY_SIZE(pjsua_var.acc); ++j) {\n\t\tif (!pjsua_var.acc[j].valid)\n\t\t    continue;\n\n\t\tif (pjsua_var.acc[j].regc)\n\t\t    break;\n\t    }\n\t    if (j != PJ_ARRAY_SIZE(pjsua_var.acc))\n\t\tbusy_sleep(50);\n\t    else\n\t\tbreak;\n\t}\n\t/* Note variable 'i' is used below */\n\n\t/* Wait for some time to allow unregistration and ICE/TURN\n\t * transports shutdown to complete: \n\t */\n\tif (i < 20 && (flags & PJSUA_DESTROY_NO_RX_MSG) == 0) {\n\t    busy_sleep(1000 - i*50);\n\t}\n\n\tPJ_LOG(4,(THIS_FILE, \"Destroying...\"));\n\t\n\t/* Terminate any pending STUN resolution */\n\tif (!pj_list_empty(&pjsua_var.stun_res)) {\n\t    pjsua_stun_resolve *sess = pjsua_var.stun_res.next;\n\t    while (sess != &pjsua_var.stun_res) {\n\t\tpjsua_stun_resolve *next = sess->next;\n\t\tdestroy_stun_resolve(sess, PJ_TRUE);\n\t\tsess = next;\n\t    }\n\t}\n\n\t/* Destroy media (to shutdown media endpoint, etc) */\n\tpjsua_media_subsys_destroy(flags);\n\n\t/* Must destroy endpoint first before destroying pools in\n\t * buddies or accounts, since shutting down transaction layer\n\t * may emit events which trigger some buddy or account callbacks\n\t * to be called.\n\t */\n\tpjsip_endpt_destroy(pjsua_var.endpt);\n\tpjsua_var.endpt = NULL;\n\n\t/* Destroy pool in the buddy object */\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.buddy); ++i) {\n\t    if (pjsua_var.buddy[i].pool) {\n\t\tpj_pool_release(pjsua_var.buddy[i].pool);\n\t\tpjsua_var.buddy[i].pool = NULL;\n\t    }\n\t}\n\n\t/* Destroy accounts */\n\tfor (i=0; i<(int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\t    if (pjsua_var.acc[i].pool) {\n\t\tpj_pool_release(pjsua_var.acc[i].pool);\n\t\tpjsua_var.acc[i].pool = NULL;\n\t    }\n\t}\n    }\n\n    /* Destroy mutex */\n    if (pjsua_var.mutex) {\n\tpj_mutex_destroy(pjsua_var.mutex);\n\tpjsua_var.mutex = NULL;\n    }\n    \n    if (pjsua_var.timer_mutex) {\n        pj_mutex_destroy(pjsua_var.timer_mutex);\n        pjsua_var.timer_mutex = NULL;\n    }\n\n    /* Destroy pools and pool factory. */\n    if (pjsua_var.timer_pool) {\n\tpj_pool_release(pjsua_var.timer_pool);\n\tpjsua_var.timer_pool = NULL;\n    }\n    if (pjsua_var.pool) {\n\tpj_pool_release(pjsua_var.pool);\n\tpjsua_var.pool = NULL;\n\tpj_caching_pool_destroy(&pjsua_var.cp);\n\n\tpjsua_set_state(PJSUA_STATE_NULL);\n\n\tPJ_LOG(4,(THIS_FILE, \"PJSUA destroyed...\"));\n\n\t/* End logging */\n\tif (pjsua_var.log_file) {\n\t    pj_file_close(pjsua_var.log_file);\n\t    pjsua_var.log_file = NULL;\n\t}\n\n\tpj_log_pop_indent();\n\n\t/* Shutdown PJLIB */\n\tpj_shutdown();\n    }\n\n    /* Clear pjsua_var */\n    pj_bzero(&pjsua_var, sizeof(pjsua_var));\n\n    /* Done. */\n    return PJ_SUCCESS;\n}\n\nvoid pjsua_set_state(pjsua_state new_state)\n{\n    const char *state_name[] = {\n        \"NULL\",\n        \"CREATED\",\n        \"INIT\",\n        \"STARTING\",\n        \"RUNNING\",\n        \"CLOSING\"\n    };\n    pjsua_state old_state = pjsua_var.state;\n\n    pjsua_var.state = new_state;\n    PJ_LOG(4,(THIS_FILE, \"PJSUA state changed: %s --> %s\",\n\t      state_name[old_state], state_name[new_state]));\n}\n\n/* Get state */\nPJ_DEF(pjsua_state) pjsua_get_state(void)\n{\n    return pjsua_var.state;\n}\n\nPJ_DEF(pj_status_t) pjsua_destroy(void)\n{\n    return pjsua_destroy2(0);\n}\n\n\n/**\n * Application is recommended to call this function after all initialization\n * is done, so that the library can do additional checking set up\n * additional \n *\n * @return\t\tPJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_DEF(pj_status_t) pjsua_start(void)\n{\n    pj_status_t status;\n\n    pjsua_set_state(PJSUA_STATE_STARTING);\n    pj_log_push_indent();\n\n    status = pjsua_call_subsys_start();\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    status = pjsua_media_subsys_start();\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    status = pjsua_pres_start();\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    pjsua_set_state(PJSUA_STATE_RUNNING);\n\non_return:\n    pj_log_pop_indent();\n    return status;\n}\n\n\n/**\n * Poll pjsua for events, and if necessary block the caller thread for\n * the specified maximum interval (in miliseconds).\n */\nPJ_DEF(int) pjsua_handle_events(unsigned msec_timeout)\n{\n#if defined(PJ_SYMBIAN) && PJ_SYMBIAN != 0\n\n    return pj_symbianos_poll(-1, msec_timeout);\n\n#else\n\n    unsigned count = 0;\n    pj_time_val tv;\n    pj_status_t status;\n\n    tv.sec = 0;\n    tv.msec = msec_timeout;\n    pj_time_val_normalize(&tv);\n\n    status = pjsip_endpt_handle_events2(pjsua_var.endpt, &tv, &count);\n\n    if (status != PJ_SUCCESS)\n\treturn -status;\n\n    return count;\n    \n#endif\n}\n\n\n/*\n * Create memory pool.\n */\nPJ_DEF(pj_pool_t*) pjsua_pool_create( const char *name, pj_size_t init_size,\n\t\t\t\t      pj_size_t increment)\n{\n    /* Pool factory is thread safe, no need to lock */\n    return pj_pool_create(&pjsua_var.cp.factory, name, init_size, increment, \n\t\t\t  NULL);\n}\n\n\n/*\n * Internal function to get SIP endpoint instance of pjsua, which is\n * needed for example to register module, create transports, etc.\n * Probably is only valid after #pjsua_init() is called.\n */\nPJ_DEF(pjsip_endpoint*) pjsua_get_pjsip_endpt(void)\n{\n    return pjsua_var.endpt;\n}\n\n/*\n * Internal function to get media endpoint instance.\n * Only valid after #pjsua_init() is called.\n */\nPJ_DEF(pjmedia_endpt*) pjsua_get_pjmedia_endpt(void)\n{\n    return pjsua_var.med_endpt;\n}\n\n/*\n * Internal function to get PJSUA pool factory.\n */\nPJ_DEF(pj_pool_factory*) pjsua_get_pool_factory(void)\n{\n    return &pjsua_var.cp.factory;\n}\n\n/*****************************************************************************\n * PJSUA SIP Transport API.\n */\n\n/*\n * Tools to get address string.\n */\nstatic const char *addr_string(const pj_sockaddr_t *addr)\n{\n    static char str[128];\n    str[0] = '\\0';\n    pj_inet_ntop(((const pj_sockaddr*)addr)->addr.sa_family, \n\t\t pj_sockaddr_get_addr(addr),\n\t\t str, sizeof(str));\n    return str;\n}\n\nvoid pjsua_acc_on_tp_state_changed(pjsip_transport *tp,\n\t\t\t\t   pjsip_transport_state state,\n\t\t\t\t   const pjsip_transport_state_info *info);\n\n/* Callback to receive transport state notifications */\nstatic void on_tp_state_callback(pjsip_transport *tp,\n\t\t\t\t pjsip_transport_state state,\n\t\t\t\t const pjsip_transport_state_info *info)\n{\n    if (pjsua_var.ua_cfg.cb.on_transport_state) {\n\t(*pjsua_var.ua_cfg.cb.on_transport_state)(tp, state, info);\n    }\n    if (pjsua_var.old_tp_cb) {\n\t(*pjsua_var.old_tp_cb)(tp, state, info);\n    }\n    pjsua_acc_on_tp_state_changed(tp, state, info);\n}\n\n/* Set transport state callback */\nstatic void set_tp_state_cb()\n{\n    pjsip_tp_state_callback tpcb;\n    pjsip_tpmgr *tpmgr;\n\n    tpmgr = pjsip_endpt_get_tpmgr(pjsua_var.endpt);\n    tpcb = pjsip_tpmgr_get_state_cb(tpmgr);\n\n    if (tpcb != &on_tp_state_callback) {\n\tpjsua_var.old_tp_cb = tpcb;\n\tpjsip_tpmgr_set_state_cb(tpmgr, &on_tp_state_callback);\n    }\n}\n\n/*\n * Create and initialize SIP socket (and possibly resolve public\n * address via STUN, depending on config).\n */\nstatic pj_status_t create_sip_udp_sock(int af,\n\t\t\t\t       const pjsua_transport_config *cfg,\n\t\t\t\t       pj_sock_t *p_sock,\n\t\t\t\t       pj_sockaddr *p_pub_addr)\n{\n    char stun_ip_addr[PJ_INET6_ADDRSTRLEN];\n    unsigned port = cfg->port;\n    pj_str_t stun_srv;\n    pj_sock_t sock;\n    pj_sockaddr bind_addr;\n    pj_status_t status;\n\n    /* Make sure STUN server resolution has completed */\n    status = resolve_stun_server(PJ_TRUE, PJ_TRUE, 0);\n    if (status != PJ_SUCCESS) {\n\tpjsua_perror(THIS_FILE, \"Error resolving STUN server\", status);\n\treturn status;\n    }\n\n    /* Initialize bound address */\n    if (cfg->bound_addr.slen) {\n\tstatus = pj_sockaddr_init(af, &bind_addr, &cfg->bound_addr, \n\t\t\t\t  (pj_uint16_t)port);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \n\t\t\t \"Unable to resolve transport bound address\", \n\t\t\t status);\n\t    return status;\n\t}\n    } else {\n\tpj_sockaddr_init(af, &bind_addr, NULL, (pj_uint16_t)port);\n    }\n\n    /* Create socket */\n    status = pj_sock_socket(af, pj_SOCK_DGRAM(), 0, &sock);\n    if (status != PJ_SUCCESS) {\n\tpjsua_perror(THIS_FILE, \"socket() error\", status);\n\treturn status;\n    }\n\n    /* Apply QoS, if specified */\n    status = pj_sock_apply_qos2(sock, cfg->qos_type, \n\t\t\t\t&cfg->qos_params, \n\t\t\t\t2, THIS_FILE, \"SIP UDP socket\");\n\n    /* Apply sockopt, if specified */\n    if (cfg->sockopt_params.cnt)\n\tstatus = pj_sock_setsockopt_params(sock, &cfg->sockopt_params);\n\n    /* Bind socket */\n    status = pj_sock_bind(sock, &bind_addr, pj_sockaddr_get_len(&bind_addr));\n    if (status != PJ_SUCCESS) {\n\tpjsua_perror(THIS_FILE, \"bind() error\", status);\n\tpj_sock_close(sock);\n\treturn status;\n    }\n\n    /* If port is zero, get the bound port */\n    if (port == 0) {\n\tpj_sockaddr bound_addr;\n\tint namelen = sizeof(bound_addr);\n\tstatus = pj_sock_getsockname(sock, &bound_addr, &namelen);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"getsockname() error\", status);\n\t    pj_sock_close(sock);\n\t    return status;\n\t}\n\n\tport = pj_sockaddr_get_port(&bound_addr);\n    }\n\n    if (pjsua_var.stun_srv.addr.sa_family != 0) {\n    \tpj_sockaddr_print(&pjsua_var.stun_srv,\n    \t\t     \t  stun_ip_addr, sizeof(stun_ip_addr), 0);\n\tstun_srv = pj_str(stun_ip_addr);\n    } else {\n\tstun_srv.slen = 0;\n    }\n\n    /* Get the published address, either by STUN or by resolving\n     * the name of local host.\n     */\n    if (pj_sockaddr_has_addr(p_pub_addr)) {\n\t/*\n\t * Public address is already specified, no need to resolve the \n\t * address, only set the port.\n\t */\n\tif (pj_sockaddr_get_port(p_pub_addr) == 0)\n\t    pj_sockaddr_set_port(p_pub_addr, (pj_uint16_t)port);\n\n    } else if (stun_srv.slen &&\n               (af == pj_AF_INET() || pjsua_var.ua_cfg.stun_try_ipv6))\n    {\n\tpjstun_setting stun_opt;\n\n\t/*\n\t * STUN is specified, resolve the address with STUN.\n\t * Currently, this is only to get IPv4 mapped address\n\t * (does IPv6 still need a mapped address?).\n\t */\n\tpj_bzero(&stun_opt, sizeof(stun_opt));\n\tstun_opt.use_stun2 = pjsua_var.ua_cfg.stun_map_use_stun2;\n\tstun_opt.af = pjsua_var.stun_srv.addr.sa_family;\n\tstun_opt.srv1  = stun_opt.srv2  = stun_srv;\n\tstun_opt.port1 = stun_opt.port2 = \n\t\t\t pj_sockaddr_get_port(&pjsua_var.stun_srv);\n\tstatus = pjstun_get_mapped_addr2(&pjsua_var.cp.factory, &stun_opt,\n\t\t\t\t\t 1, &sock, &p_pub_addr->ipv4);\n\tif (status != PJ_SUCCESS) {\n\t    /* Failed getting mapped address via STUN */\n\t    pjsua_perror(THIS_FILE, \"Error contacting STUN server\", status);\n\t    \n\t    /* Return error if configured to not ignore STUN failure */\n\t    if (!pjsua_var.ua_cfg.stun_ignore_failure) {\n\t\tpj_sock_close(sock);\n\t\treturn status;\n\t    }\n\n\t    /* Otherwise, just use host IP */\n\t    pj_sockaddr_init(af, p_pub_addr, NULL, (pj_uint16_t)port);\n\t    status = pj_gethostip(af, p_pub_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \"Unable to get local host IP\", status);\n\t\tpj_sock_close(sock);\n\t\treturn status;\n\t    }\n\t}\n\n    } else {\n\n\tpj_bzero(p_pub_addr, sizeof(pj_sockaddr));\n\n\tif (pj_sockaddr_has_addr(&bind_addr)) {\n\t    pj_sockaddr_copy_addr(p_pub_addr, &bind_addr);\n\t} else {\n\t    status = pj_gethostip(af, p_pub_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \"Unable to get local host IP\", status);\n\t\tpj_sock_close(sock);\n\t\treturn status;\n\t    }\n\t}\n\n\tp_pub_addr->addr.sa_family = (pj_uint16_t)af;\n\tpj_sockaddr_set_port(p_pub_addr, (pj_uint16_t)port);\n\n\tif (stun_srv.slen && af != pj_AF_INET()) {\n\t    /* STUN is specified, but it is not IPv4, just print warning */\n\t    PJ_PERROR(2, (THIS_FILE, PJ_EAFNOTSUP,\n\t\t          \"Cannot use STUN for SIP UDP socket %s:%d\",\n\t\t          addr_string(p_pub_addr),\n\t\t          (int)pj_sockaddr_get_port(p_pub_addr)));\n\t}\n\n    }\n\n    *p_sock = sock;\n\n    PJ_LOG(4,(THIS_FILE, \"SIP UDP socket reachable at %s:%d\",\n\t      addr_string(p_pub_addr),\n\t      (int)pj_sockaddr_get_port(p_pub_addr)));\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create SIP transport.\n */\nPJ_DEF(pj_status_t) pjsua_transport_create( pjsip_transport_type_e type,\n\t\t\t\t\t    const pjsua_transport_config *cfg,\n\t\t\t\t\t    pjsua_transport_id *p_id)\n{\n    pjsip_transport *tp;\n    unsigned id;\n    pj_status_t status;\n\n    PJSUA_LOCK();\n\n    /* Find empty transport slot */\n    for (id=0; id < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++id) {\n\tif (pjsua_var.tpdata[id].data.ptr == NULL)\n\t    break;\n    }\n\n    if (id == PJ_ARRAY_SIZE(pjsua_var.tpdata)) {\n\tstatus = PJ_ETOOMANY;\n\tpjsua_perror(THIS_FILE, \"Error creating transport\", status);\n\tgoto on_return;\n    }\n\n    /* Create the transport */\n    if (type==PJSIP_TRANSPORT_UDP || type==PJSIP_TRANSPORT_UDP6) {\n\t/*\n\t * Create UDP transport (IPv4 or IPv6).\n\t */\n\tpjsua_transport_config config;\n\tchar hostbuf[PJ_INET6_ADDRSTRLEN];\n\tpj_sock_t sock = PJ_INVALID_SOCKET;\n\tpj_sockaddr pub_addr;\n\tpjsip_host_port addr_name;\n\n\t/* Supply default config if it's not specified */\n\tif (cfg == NULL) {\n\t    pjsua_transport_config_default(&config);\n\t    cfg = &config;\n\t}\n\n\t/* Initialize the public address from the config, if any */\n\tpj_sockaddr_init(pjsip_transport_type_get_af(type), &pub_addr, \n\t\t\t NULL, (pj_uint16_t)cfg->port);\n\tif (cfg->public_addr.slen) {\n\t    status = pj_sockaddr_set_str_addr(pjsip_transport_type_get_af(type),\n\t\t\t\t\t      &pub_addr, &cfg->public_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \n\t\t\t     \"Unable to resolve transport public address\", \n\t\t\t     status);\n\t\tgoto on_return;\n\t    }\n\t}\n\n\t/* Create the socket and possibly resolve the address with STUN \n\t * (only when public address is not specified).\n\t */\n\tstatus = create_sip_udp_sock(pjsip_transport_type_get_af(type),\n\t\t\t\t     cfg, &sock, &pub_addr);\n\tif (status != PJ_SUCCESS)\n\t    goto on_return;\n\n\tpj_ansi_strcpy(hostbuf, addr_string(&pub_addr));\n\taddr_name.host = pj_str(hostbuf);\n\taddr_name.port = pj_sockaddr_get_port(&pub_addr);\n\n\t/* Create UDP transport */\n\tstatus = pjsip_udp_transport_attach2(pjsua_var.endpt, type, sock,\n\t\t\t\t\t     &addr_name, 1, &tp);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error creating SIP UDP transport\", \n\t\t\t status);\n\t    pj_sock_close(sock);\n\t    goto on_return;\n\t}\n\n\n\t/* Save the transport */\n\tpjsua_var.tpdata[id].type = type;\n\tpjsua_var.tpdata[id].local_name = tp->local_name;\n\tpjsua_var.tpdata[id].data.tp = tp;\n\tif (cfg->bound_addr.slen)\n\t    pjsua_var.tpdata[id].has_bound_addr = PJ_TRUE;\n\n#if defined(PJ_HAS_TCP) && PJ_HAS_TCP!=0\n\n    } else if (type == PJSIP_TRANSPORT_TCP || type == PJSIP_TRANSPORT_TCP6) {\n\t/*\n\t * Create TCP transport.\n\t */\n\tpjsua_transport_config config;\n\tpjsip_tpfactory *tcp;\n\tpjsip_tcp_transport_cfg tcp_cfg;\n\tint af;\n\n\taf = (type==PJSIP_TRANSPORT_TCP6) ? pj_AF_INET6() : pj_AF_INET();\n\tpjsip_tcp_transport_cfg_default(&tcp_cfg, af);\n\n\t/* Supply default config if it's not specified */\n\tif (cfg == NULL) {\n\t    pjsua_transport_config_default(&config);\n\t    cfg = &config;\n\t}\n\n\t/* Configure bind address */\n\tif (cfg->port)\n\t    pj_sockaddr_set_port(&tcp_cfg.bind_addr, (pj_uint16_t)cfg->port);\n\n\tif (cfg->bound_addr.slen) {\n\t    status = pj_sockaddr_set_str_addr(tcp_cfg.af, \n\t\t\t\t\t      &tcp_cfg.bind_addr,\n\t\t\t\t\t      &cfg->bound_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \n\t\t\t     \"Unable to resolve transport bound address\", \n\t\t\t     status);\n\t\tgoto on_return;\n\t    }\n\t}\n\n\t/* Set published name */\n\tif (cfg->public_addr.slen)\n\t    tcp_cfg.addr_name.host = cfg->public_addr;\n\n\t/* Copy the QoS settings */\n\ttcp_cfg.qos_type = cfg->qos_type;\n\tpj_memcpy(&tcp_cfg.qos_params, &cfg->qos_params, \n\t\t  sizeof(cfg->qos_params));\n\n\t/* Copy the sockopt */\n\tpj_memcpy(&tcp_cfg.sockopt_params, &cfg->sockopt_params,\n\t\t  sizeof(tcp_cfg.sockopt_params));\n\n\t/* Create the TCP transport */\n\tstatus = pjsip_tcp_transport_start3(pjsua_var.endpt, &tcp_cfg, &tcp);\n\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error creating SIP TCP listener\", \n\t\t\t status);\n\t    goto on_return;\n\t}\n\n\t/* Save the transport */\n\tpjsua_var.tpdata[id].type = type;\n\tpjsua_var.tpdata[id].local_name = tcp->addr_name;\n\tpjsua_var.tpdata[id].data.factory = tcp;\n\n#endif\t/* PJ_HAS_TCP */\n\n#if defined(PJSIP_HAS_TLS_TRANSPORT) && PJSIP_HAS_TLS_TRANSPORT!=0\n    } else if (type == PJSIP_TRANSPORT_TLS || type == PJSIP_TRANSPORT_TLS6) {\n\t/*\n\t * Create TLS transport.\n\t */\n\tpjsua_transport_config config;\n\tpjsip_host_port a_name;\n\tpjsip_tpfactory *tls;\n\tpj_sockaddr local_addr;\n\tint af;\n\n\t/* Supply default config if it's not specified */\n\tif (cfg == NULL) {\n\t    pjsua_transport_config_default(&config);\n\t    config.port = 5061;\n\t    cfg = &config;\n\t}\n\n\t/* Init local address */\n\taf = (type==PJSIP_TRANSPORT_TLS) ? pj_AF_INET() : pj_AF_INET6();\n\tpj_sockaddr_init(af, &local_addr, NULL, 0);\n\n\tif (cfg->port)\n\t    pj_sockaddr_set_port(&local_addr, (pj_uint16_t)cfg->port);\n\n\tif (cfg->bound_addr.slen) {\n\t    status = pj_sockaddr_set_str_addr(af, &local_addr,\n\t                                      &cfg->bound_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \n\t\t\t     \"Unable to resolve transport bound address\", \n\t\t\t     status);\n\t\tgoto on_return;\n\t    }\n\t}\n\n\t/* Init published name */\n\tpj_bzero(&a_name, sizeof(pjsip_host_port));\n\tif (cfg->public_addr.slen)\n\t    a_name.host = cfg->public_addr;\n\n\tstatus = pjsip_tls_transport_start2(pjsua_var.endpt, &cfg->tls_setting,\n\t\t\t\t\t    &local_addr, &a_name, 1, &tls);\n\tif (status != PJ_SUCCESS) {\n\t    pjsua_perror(THIS_FILE, \"Error creating SIP TLS listener\", \n\t\t\t status);\n\t    goto on_return;\n\t}\n\n\t/* Save the transport */\n\tpjsua_var.tpdata[id].type = type;\n\tpjsua_var.tpdata[id].local_name = tls->addr_name;\n\tpjsua_var.tpdata[id].data.factory = tls;\n#endif\n\n    } else {\n\tstatus = PJSIP_EUNSUPTRANSPORT;\n\tpjsua_perror(THIS_FILE, \"Error creating transport\", status);\n\tgoto on_return;\n    }\n\n    /* Set transport state callback */\n    set_tp_state_cb();\n\n    /* Return the ID */\n    if (p_id) *p_id = id;\n\n    status = PJ_SUCCESS;\n\non_return:\n\n    PJSUA_UNLOCK();\n\n    return status;\n}\n\n\n/*\n * Register transport that has been created by application.\n */\nPJ_DEF(pj_status_t) pjsua_transport_register( pjsip_transport *tp,\n\t\t\t\t\t      pjsua_transport_id *p_id)\n{\n    unsigned id;\n\n    PJSUA_LOCK();\n\n    /* Find empty transport slot */\n    for (id=0; id < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++id) {\n\tif (pjsua_var.tpdata[id].data.ptr == NULL)\n\t    break;\n    }\n\n    if (id == PJ_ARRAY_SIZE(pjsua_var.tpdata)) {\n\tpjsua_perror(THIS_FILE, \"Error creating transport\", PJ_ETOOMANY);\n\tPJSUA_UNLOCK();\n\treturn PJ_ETOOMANY;\n    }\n\n    /* Save the transport */\n    pjsua_var.tpdata[id].type = (pjsip_transport_type_e) tp->key.type;\n    pjsua_var.tpdata[id].local_name = tp->local_name;\n    pjsua_var.tpdata[id].data.tp = tp;\n\n    /* Set transport state callback */\n    set_tp_state_cb();\n\n    /* Return the ID */\n    if (p_id) *p_id = id;\n\n    PJSUA_UNLOCK();\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Register transport factory that has been created by application.\n */\nPJ_DEF(pj_status_t) pjsua_tpfactory_register( pjsip_tpfactory *tf,\n\t\t\t\t\t      pjsua_transport_id *p_id)\n{\n    unsigned id;\n\n    PJSUA_LOCK();\n\n    /* Find empty transport slot */\n    for (id=0; id < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++id) {\n\tif (pjsua_var.tpdata[id].data.ptr == NULL)\n\t    break;\n    }\n\n    if (id == PJ_ARRAY_SIZE(pjsua_var.tpdata)) {\n\tpjsua_perror(THIS_FILE, \"Error creating transport\", PJ_ETOOMANY);\n\tPJSUA_UNLOCK();\n\treturn PJ_ETOOMANY;\n    }\n\n    /* Save the transport */\n    pjsua_var.tpdata[id].type = (pjsip_transport_type_e) tf->type;\n    pjsua_var.tpdata[id].local_name = tf->addr_name;\n    pjsua_var.tpdata[id].data.factory = tf;\n\n    /* Set transport state callback */\n    set_tp_state_cb();\n\n    /* Return the ID */\n    if (p_id) *p_id = id;\n\n    PJSUA_UNLOCK();\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Enumerate all transports currently created in the system.\n */\nPJ_DEF(pj_status_t) pjsua_enum_transports( pjsua_transport_id id[],\n\t\t\t\t\t   unsigned *p_count )\n{\n    unsigned i, count;\n\n    PJSUA_LOCK();\n\n    for (i=0, count=0; i<PJ_ARRAY_SIZE(pjsua_var.tpdata) && count<*p_count; \n\t ++i) \n    {\n\tif (!pjsua_var.tpdata[i].data.ptr)\n\t    continue;\n\n\tid[count++] = i;\n    }\n\n    *p_count = count;\n\n    PJSUA_UNLOCK();\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get information about transports.\n */\nPJ_DEF(pj_status_t) pjsua_transport_get_info( pjsua_transport_id id,\n\t\t\t\t\t      pjsua_transport_info *info)\n{\n    pjsua_transport_data *t = &pjsua_var.tpdata[id];\n    pj_status_t status;\n\n    pj_bzero(info, sizeof(*info));\n\n    /* Make sure id is in range. */\n    PJ_ASSERT_RETURN(id>=0 && id<(int)PJ_ARRAY_SIZE(pjsua_var.tpdata), \n\t\t     PJ_EINVAL);\n\n    /* Make sure that transport exists */\n    PJ_ASSERT_RETURN(pjsua_var.tpdata[id].data.ptr != NULL, PJ_EINVAL);\n\n    PJSUA_LOCK();\n\n    if ((t->type & ~PJSIP_TRANSPORT_IPV6) == PJSIP_TRANSPORT_UDP) {\n\n\tpjsip_transport *tp = t->data.tp;\n\n\tif (tp == NULL) {\n\t    PJSUA_UNLOCK();\n\t    return PJ_EINVALIDOP;\n\t}\n    \n\tinfo->id = id;\n\tinfo->type = (pjsip_transport_type_e) tp->key.type;\n\tinfo->type_name = pj_str(tp->type_name);\n\tinfo->info = pj_str(tp->info);\n\tinfo->flag = tp->flag;\n\tinfo->addr_len = tp->addr_len;\n\tinfo->local_addr = tp->local_addr;\n\tinfo->local_name = tp->local_name;\n\tinfo->usage_count = pj_atomic_get(tp->ref_cnt);\n\n\tstatus = PJ_SUCCESS;\n\n    } else if ((t->type & ~PJSIP_TRANSPORT_IPV6) == PJSIP_TRANSPORT_TCP ||\n\t       (t->type & ~PJSIP_TRANSPORT_IPV6) == PJSIP_TRANSPORT_TLS)\n    {\n\n\tpjsip_tpfactory *factory = t->data.factory;\n\n\tif (factory == NULL) {\n\t    PJSUA_UNLOCK();\n\t    return PJ_EINVALIDOP;\n\t}\n    \n\tinfo->id = id;\n\tinfo->type = t->type;\n\tinfo->type_name = pj_str(factory->type_name);\n\tinfo->info = pj_str(factory->info);\n\tinfo->flag = factory->flag;\n\tinfo->addr_len = sizeof(factory->local_addr);\n\tinfo->local_addr = factory->local_addr;\n\tinfo->local_name = factory->addr_name;\n\tinfo->usage_count = 0;\n\n\tstatus = PJ_SUCCESS;\n\n    } else {\n\tpj_assert(!\"Unsupported transport\");\n\tstatus = PJ_EINVALIDOP;\n    }\n\n\n    PJSUA_UNLOCK();\n\n    return status;\n}\n\n\n/*\n * Disable a transport or re-enable it.\n */\nPJ_DEF(pj_status_t) pjsua_transport_set_enable( pjsua_transport_id id,\n\t\t\t\t\t\tpj_bool_t enabled)\n{\n    /* Make sure id is in range. */\n    PJ_ASSERT_RETURN(id>=0 && id<(int)PJ_ARRAY_SIZE(pjsua_var.tpdata), \n\t\t     PJ_EINVAL);\n\n    /* Make sure that transport exists */\n    PJ_ASSERT_RETURN(pjsua_var.tpdata[id].data.ptr != NULL, PJ_EINVAL);\n\n\n    /* To be done!! */\n    PJ_TODO(pjsua_transport_set_enable);\n    PJ_UNUSED_ARG(enabled);\n\n    return PJ_EINVALIDOP;\n}\n\n\n/*\n * Close the transport.\n */\nPJ_DEF(pj_status_t) pjsua_transport_close( pjsua_transport_id id,\n\t\t\t\t\t   pj_bool_t force )\n{\n    pj_status_t status;\n    pjsip_transport_type_e tp_type;\n\n    /* Make sure id is in range. */\n    PJ_ASSERT_RETURN(id>=0 && id<(int)PJ_ARRAY_SIZE(pjsua_var.tpdata), \n\t\t     PJ_EINVAL);\n\n    /* Make sure that transport exists */\n    PJ_ASSERT_RETURN(pjsua_var.tpdata[id].data.ptr != NULL, PJ_EINVAL);\n\n    tp_type = pjsua_var.tpdata[id].type & ~PJSIP_TRANSPORT_IPV6;\n\n    if (force) {\n    \t/* Forcefully closing transport is deprecated, since any pending\n    \t * transactions that are using the transport may not terminate\n    \t * properly and can even crash.\n    \t */\n\tPJ_LOG(1, (THIS_FILE, \"pjsua_transport_close(force=PJ_TRUE) is \"\n\t\t\t      \"deprecated.\"));\n    \t\n    \t/* To minimize the effect to users, we shouldn't hard-deprecate this\n    \t * and let it continue as if force is false.\n    \t */\n    \t// return PJ_EINVAL;\n    }\n\n    /* If force is not specified, transports will be closed at their\n     * convenient time.\n     */\n    switch (tp_type) {\n\tcase PJSIP_TRANSPORT_UDP:\n\t    status = pjsip_transport_shutdown(pjsua_var.tpdata[id].data.tp);\n\t    break;\n\tcase PJSIP_TRANSPORT_TLS:\n\tcase PJSIP_TRANSPORT_TCP:\n\t    /* This will close the TCP listener, but existing TCP/TLS\n\t     * connections (if any) will still linger \n\t     */\n\t    status = (*pjsua_var.tpdata[id].data.factory->destroy)\n\t\t\t(pjsua_var.tpdata[id].data.factory);\n\t    break;\n\tdefault:\n\t    return PJ_EINVAL;\n    }\n\n    /* Cleanup pjsua data. We don't need to keep the transport\n     * descriptor, the transport will be destroyed later by the last user\n     * which decrements the transport's reference.\n     */\n    if (status == PJ_SUCCESS) {\n    \tpjsua_var.tpdata[id].type = PJSIP_TRANSPORT_UNSPECIFIED;\n    \tpjsua_var.tpdata[id].data.ptr = NULL;\n    }\n\n    return status;\n}\n\n\nPJ_DEF(pj_status_t) pjsua_transport_lis_start(pjsua_transport_id id,\n\t\t\t\t\t     const pjsua_transport_config *cfg)\n{\n    pj_status_t status = PJ_SUCCESS;\n    pjsip_transport_type_e tp_type;\n\n    /* Make sure id is in range. */\n    PJ_ASSERT_RETURN(id>=0 && id<(int)PJ_ARRAY_SIZE(pjsua_var.tpdata), \n\t\t     PJ_EINVAL);\n\n    /* Make sure that transport exists */\n    PJ_ASSERT_RETURN(pjsua_var.tpdata[id].data.ptr != NULL, PJ_EINVAL);\n\n    tp_type = pjsua_var.tpdata[id].type & ~PJSIP_TRANSPORT_IPV6;\n \n    if ((tp_type == PJSIP_TRANSPORT_TLS) || (tp_type == PJSIP_TRANSPORT_TCP)) {\n\tpj_sockaddr bind_addr;\n\tpjsip_host_port addr_name;\n\tpjsip_tpfactory *factory = pjsua_var.tpdata[id].data.factory;\n\t\n        int af = pjsip_transport_type_get_af(factory->type);\n\n\tif (cfg->port)\n\t    pj_sockaddr_set_port(&bind_addr, (pj_uint16_t)cfg->port);\n\n\tif (cfg->bound_addr.slen) {\n\t    status = pj_sockaddr_set_str_addr(af, \n\t\t\t\t\t      &bind_addr,\n\t\t\t\t\t      &cfg->bound_addr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsua_perror(THIS_FILE, \n\t\t\t     \"Unable to resolve transport bound address\", \n\t\t\t     status);\n\t\treturn status;\n\t    }\n\t}\n\n\t/* Set published name */\n\tif (cfg->public_addr.slen)\n\t    addr_name.host = cfg->public_addr;\n\n\tif (tp_type == PJSIP_TRANSPORT_TCP) {\n\t    status = pjsip_tcp_transport_lis_start(factory, &bind_addr,\n\t\t\t\t\t\t   &addr_name);\n\t}\n#if defined(PJSIP_HAS_TLS_TRANSPORT) && PJSIP_HAS_TLS_TRANSPORT!=0\n\telse {\n\t    status = pjsip_tls_transport_lis_start(factory, &bind_addr,\n\t\t\t\t\t\t   &addr_name);\t\n\t}\n#endif\t\n    } else if (tp_type == PJSIP_TRANSPORT_UDP) {\n\tstatus = PJ_SUCCESS;\n    } else {\n\tstatus = PJ_EINVAL;\n    }\n    return status;\n}\n\n\n/*\n * Add additional headers etc in msg_data specified by application\n * when sending requests.\n */\nvoid pjsua_process_msg_data(pjsip_tx_data *tdata,\n\t\t\t    const pjsua_msg_data *msg_data)\n{\n    pj_bool_t allow_body;\n    const pjsip_hdr *hdr;\n\n    /* Always add User-Agent */\n    if (pjsua_var.ua_cfg.user_agent.slen && \n\ttdata->msg->type == PJSIP_REQUEST_MSG) \n    {\n\tconst pj_str_t STR_USER_AGENT = { \"User-Agent\", 10 };\n\tpjsip_hdr *h;\n\th = (pjsip_hdr*)pjsip_generic_string_hdr_create(tdata->pool, \n\t\t\t\t\t\t\t&STR_USER_AGENT, \n\t\t\t\t\t\t\t&pjsua_var.ua_cfg.user_agent);\n\tpjsip_msg_add_hdr(tdata->msg, h);\n    }\n\n    if (!msg_data)\n\treturn;\n\n    hdr = msg_data->hdr_list.next;\n    while (hdr && hdr != &msg_data->hdr_list) {\n\tpjsip_hdr *new_hdr;\n\n\tnew_hdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, hdr);\n\tpjsip_msg_add_hdr(tdata->msg, new_hdr);\n\n\thdr = hdr->next;\n    }\n\n    allow_body = (tdata->msg->body == NULL);\n\n    if (allow_body && msg_data->content_type.slen && msg_data->msg_body.slen) {\n\tpjsip_media_type ctype;\n\tpjsip_msg_body *body;\t\n\n\tpjsua_parse_media_type(tdata->pool, &msg_data->content_type, &ctype);\n\tbody = pjsip_msg_body_create(tdata->pool, &ctype.type, &ctype.subtype,\n\t\t\t\t     &msg_data->msg_body);\n\ttdata->msg->body = body;\n    }\n\n    /* Multipart */\n    if (!pj_list_empty(&msg_data->multipart_parts) &&\n\tmsg_data->multipart_ctype.type.slen)\n    {\n\tpjsip_msg_body *bodies;\n\tpjsip_multipart_part *part;\n\tpj_str_t *boundary = NULL;\n\n\tbodies = pjsip_multipart_create(tdata->pool,\n\t\t\t\t        &msg_data->multipart_ctype,\n\t\t\t\t        boundary);\n\tpart = msg_data->multipart_parts.next;\n\twhile (part != &msg_data->multipart_parts) {\n\t    pjsip_multipart_part *part_copy;\n\n\t    part_copy = pjsip_multipart_clone_part(tdata->pool, part);\n\t    pjsip_multipart_add_part(tdata->pool, bodies, part_copy);\n\t    part = part->next;\n\t}\n\n\tif (tdata->msg->body) {\n\t    part = pjsip_multipart_create_part(tdata->pool);\n\t    part->body = tdata->msg->body;\n\t    pjsip_multipart_add_part(tdata->pool, bodies, part);\n\n\t    tdata->msg->body = NULL;\n\t}\n\n\ttdata->msg->body = bodies;\n    }\n}\n\n\n/*\n * Add route_set to outgoing requests\n */\nvoid pjsua_set_msg_route_set( pjsip_tx_data *tdata,\n\t\t\t      const pjsip_route_hdr *route_set )\n{\n    const pjsip_route_hdr *r;\n\n    r = route_set->next;\n    while (r != route_set) {\n\tpjsip_route_hdr *new_r;\n\n\tnew_r = (pjsip_route_hdr*) pjsip_hdr_clone(tdata->pool, r);\n\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)new_r);\n\n\tr = r->next;\n    }\n}\n\n\n/*\n * Simple version of MIME type parsing (it doesn't support parameters)\n */\nvoid pjsua_parse_media_type( pj_pool_t *pool,\n\t\t\t     const pj_str_t *mime,\n\t\t\t     pjsip_media_type *media_type)\n{\n    pj_str_t tmp;\n    char *pos;\n\n    pj_bzero(media_type, sizeof(*media_type));\n\n    pj_strdup_with_null(pool, &tmp, mime);\n\n    pos = pj_strchr(&tmp, '/');\n    if (pos) {\n\tmedia_type->type.ptr = tmp.ptr; \n\tmedia_type->type.slen = (pos-tmp.ptr);\n\tmedia_type->subtype.ptr = pos+1; \n\tmedia_type->subtype.slen = tmp.ptr+tmp.slen-pos-1;\n    } else {\n\tmedia_type->type = tmp;\n    }\n}\n\n\n/*\n * Internal function to init transport selector from transport id.\n */\nvoid pjsua_init_tpselector(pjsua_transport_id tp_id,\n\t\t\t   pjsip_tpselector *sel)\n{\n    pjsua_transport_data *tpdata;\n    unsigned flag;\n\n    pj_bzero(sel, sizeof(*sel));\n    if (tp_id == PJSUA_INVALID_ID)\n\treturn;\n\n    PJ_ASSERT_RETURN(tp_id >= 0 && \n\t\t     tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata), );\n    tpdata = &pjsua_var.tpdata[tp_id];\n\n    flag = pjsip_transport_get_flag_from_type(tpdata->type);\n\n    if (flag & PJSIP_TRANSPORT_DATAGRAM) {\n\tsel->type = PJSIP_TPSELECTOR_TRANSPORT;\n\tsel->u.transport = tpdata->data.tp;\n    } else {\n\tsel->type = PJSIP_TPSELECTOR_LISTENER;\n\tsel->u.listener = tpdata->data.factory;\n    }\n}\n\n\nPJ_DEF(void) pjsua_ip_change_param_default(pjsua_ip_change_param *param)\n{\n    pj_bzero(param, sizeof(*param));\n    param->restart_listener = PJ_TRUE;\n    param->restart_lis_delay = PJSUA_TRANSPORT_RESTART_DELAY_TIME;\n}\n\n\n/* Callback upon NAT detection completion */\nstatic void nat_detect_cb(void *user_data, \n\t\t\t  const pj_stun_nat_detect_result *res)\n{\n    PJ_UNUSED_ARG(user_data);\n\n    pjsua_var.nat_in_progress = PJ_FALSE;\n    pjsua_var.nat_status = res->status;\n    pjsua_var.nat_type = res->nat_type;\n\n    if (pjsua_var.ua_cfg.cb.on_nat_detect) {\n\t(*pjsua_var.ua_cfg.cb.on_nat_detect)(res);\n    }\n}\n\n\n/*\n * Detect NAT type.\n */\nPJ_DEF(pj_status_t) pjsua_detect_nat_type()\n{\n    pj_status_t status;\n\n    if (pjsua_var.nat_in_progress)\n\treturn PJ_SUCCESS;\n\n    /* Make sure STUN server resolution has completed */\n    status = resolve_stun_server(PJ_TRUE, PJ_TRUE, 0);\n    if (status != PJ_SUCCESS) {\n\tpjsua_var.nat_status = status;\n\tpjsua_var.nat_type = PJ_STUN_NAT_TYPE_ERR_UNKNOWN;\n\treturn status;\n    }\n\n    /* Make sure we have STUN */\n    if (pjsua_var.stun_srv.addr.sa_family == 0) {\n\tpjsua_var.nat_status = PJNATH_ESTUNINSERVER;\n\treturn PJNATH_ESTUNINSERVER;\n    }\n\n    status = pj_stun_detect_nat_type2(&pjsua_var.stun_srv, \n\t\t\t\t      &pjsua_var.stun_cfg, \n\t\t\t\t      NULL, &nat_detect_cb);\n\n    if (status != PJ_SUCCESS) {\n\tpjsua_var.nat_status = status;\n\tpjsua_var.nat_type = PJ_STUN_NAT_TYPE_ERR_UNKNOWN;\n\treturn status;\n    }\n\n    pjsua_var.nat_in_progress = PJ_TRUE;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get NAT type.\n */\nPJ_DEF(pj_status_t) pjsua_get_nat_type(pj_stun_nat_type *type)\n{\n    *type = pjsua_var.nat_type;\n    return pjsua_var.nat_status;\n}\n\n/*\n * Verify that valid url is given.\n */\nPJ_DEF(pj_status_t) pjsua_verify_url(const char *c_url)\n{\n    pjsip_uri *p;\n    pj_pool_t *pool;\n    char *url;\n    pj_size_t len = (c_url ? pj_ansi_strlen(c_url) : 0);\n\n    if (!len) return PJSIP_EINVALIDURI;\n\n    pool = pj_pool_create(&pjsua_var.cp.factory, \"check%p\", 1024, 0, NULL);\n    if (!pool) return PJ_ENOMEM;\n\n    url = (char*) pj_pool_alloc(pool, len+1);\n    pj_ansi_strcpy(url, c_url);\n\n    p = pjsip_parse_uri(pool, url, len, 0);\n\n    pj_pool_release(pool);\n    return p ? 0 : PJSIP_EINVALIDURI;\n}\n\n/*\n * Verify that valid SIP url is given.\n */\nPJ_DEF(pj_status_t) pjsua_verify_sip_url(const char *c_url)\n{\n    pjsip_uri *p;\n    pj_pool_t *pool;\n    char *url;\n    pj_size_t len = (c_url ? pj_ansi_strlen(c_url) : 0);\n\n    if (!len) return PJSIP_EINVALIDURI;\n\n    pool = pj_pool_create(&pjsua_var.cp.factory, \"check%p\", 1024, 0, NULL);\n    if (!pool) return PJ_ENOMEM;\n\n    url = (char*) pj_pool_alloc(pool, len+1);\n    pj_ansi_strcpy(url, c_url);\n\n    p = pjsip_parse_uri(pool, url, len, 0);\n    if (!p || (pj_stricmp2(pjsip_uri_get_scheme(p), \"sip\") != 0 &&\n\t       pj_stricmp2(pjsip_uri_get_scheme(p), \"sips\") != 0))\n    {\n\tp = NULL;\n    }\n\n    pj_pool_release(pool);\n    return p ? 0 : PJSIP_EINVALIDURI;\n}\n\n/*\n * Schedule a timer entry. \n */\n#if PJ_TIMER_DEBUG\nPJ_DEF(pj_status_t) pjsua_schedule_timer_dbg( pj_timer_entry *entry,\n                                              const pj_time_val *delay,\n                                              const char *src_file,\n                                              int src_line)\n{\n    return pjsip_endpt_schedule_timer_dbg(pjsua_var.endpt, entry, delay,\n                                          src_file, src_line);\n}\n#else\nPJ_DEF(pj_status_t) pjsua_schedule_timer( pj_timer_entry *entry,\n\t\t\t\t\t  const pj_time_val *delay)\n{\n    return pjsip_endpt_schedule_timer(pjsua_var.endpt, entry, delay);\n}\n#endif\n\n/* Timer callback */\nstatic void timer_cb( pj_timer_heap_t *th,\n\t\t      pj_timer_entry *entry)\n{\n    pjsua_timer_list *tmr = (pjsua_timer_list *)entry->user_data;\n    void (*cb)(void *user_data) = tmr->cb;\n    void *user_data = tmr->user_data;\n\n    PJ_UNUSED_ARG(th);\n\n    if (cb)\n        (*cb)(user_data);\n\n    pj_mutex_lock(pjsua_var.timer_mutex);\n    pj_list_erase(tmr);\n    pj_list_push_back(&pjsua_var.timer_list, tmr);\n    pj_mutex_unlock(pjsua_var.timer_mutex);\n}\n\n/*\n * Schedule a timer callback. \n */\n#if PJ_TIMER_DEBUG\nPJ_DEF(pj_status_t) pjsua_schedule_timer2_dbg( void (*cb)(void *user_data),\n                                               void *user_data,\n                                               unsigned msec_delay,\n                                               const char *src_file,\n                                               int src_line)\n#else\nPJ_DEF(pj_status_t) pjsua_schedule_timer2( void (*cb)(void *user_data),\n                                           void *user_data,\n                                           unsigned msec_delay)\n#endif\n{\n    pjsua_timer_list *tmr = NULL;\n    pj_status_t status;\n    pj_time_val delay;\n\n    pj_mutex_lock(pjsua_var.timer_mutex);\n\n    if (pj_list_empty(&pjsua_var.timer_list)) {\n        tmr = PJ_POOL_ALLOC_T(pjsua_var.timer_pool, pjsua_timer_list);\n    } else {\n        tmr = pjsua_var.timer_list.next;\n        pj_list_erase(tmr);\n    }\n    pj_timer_entry_init(&tmr->entry, 0, tmr, timer_cb);\n    tmr->cb = cb;\n    tmr->user_data = user_data;\n    delay.sec = 0;\n    delay.msec = msec_delay;\n\n#if PJ_TIMER_DEBUG\n    status = pjsip_endpt_schedule_timer_dbg(pjsua_var.endpt, &tmr->entry,\n                                            &delay, src_file, src_line);\n#else\n    status = pjsip_endpt_schedule_timer(pjsua_var.endpt, &tmr->entry, &delay);\n#endif\n    if (status == PJ_SUCCESS) {\n    \tpj_list_push_back(&pjsua_var.active_timer_list, tmr);\n    } else {\n        pj_list_push_back(&pjsua_var.timer_list, tmr);\n    }\n\n    pj_mutex_unlock(pjsua_var.timer_mutex);\n\n    return status;\n}\n\n/*\n * Cancel the previously scheduled timer.\n *\n */\nPJ_DEF(void) pjsua_cancel_timer(pj_timer_entry *entry)\n{\n    pjsip_endpt_cancel_timer(pjsua_var.endpt, entry);\n}\n\n/** \n * Normalize route URI (check for \";lr\" and append one if it doesn't\n * exist and pjsua_config.force_lr is set.\n */\npj_status_t normalize_route_uri(pj_pool_t *pool, pj_str_t *uri)\n{\n    pj_str_t tmp_uri;\n    pj_pool_t *tmp_pool;\n    pjsip_uri *uri_obj;\n    pjsip_sip_uri *sip_uri;\n\n    tmp_pool = pjsua_pool_create(\"tmplr%p\", 512, 512);\n    if (!tmp_pool)\n\treturn PJ_ENOMEM;\n\n    pj_strdup_with_null(tmp_pool, &tmp_uri, uri);\n\n    uri_obj = pjsip_parse_uri(tmp_pool, tmp_uri.ptr, tmp_uri.slen, 0);\n    if (!uri_obj) {\n\tPJ_LOG(1,(THIS_FILE, \"Invalid route URI: %.*s\", \n\t\t  (int)uri->slen, uri->ptr));\n\tpj_pool_release(tmp_pool);\n\treturn PJSIP_EINVALIDURI;\n    }\n\n    if (!PJSIP_URI_SCHEME_IS_SIP(uri_obj) && \n\t!PJSIP_URI_SCHEME_IS_SIPS(uri_obj))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Route URI must be SIP URI: %.*s\", \n\t\t  (int)uri->slen, uri->ptr));\n\tpj_pool_release(tmp_pool);\n\treturn PJSIP_EINVALIDSCHEME;\n    }\n\n    sip_uri = (pjsip_sip_uri*) pjsip_uri_get_uri(uri_obj);\n\n    /* Done if force_lr is disabled or if lr parameter is present */\n    if (!pjsua_var.ua_cfg.force_lr || sip_uri->lr_param) {\n\tpj_pool_release(tmp_pool);\n\treturn PJ_SUCCESS;\n    }\n\n    /* Set lr param */\n    sip_uri->lr_param = 1;\n\n    /* Print the URI */\n    tmp_uri.ptr = (char*) pj_pool_alloc(tmp_pool, PJSIP_MAX_URL_SIZE);\n    tmp_uri.slen = pjsip_uri_print(PJSIP_URI_IN_ROUTING_HDR, uri_obj, \n\t\t\t\t   tmp_uri.ptr, PJSIP_MAX_URL_SIZE);\n    if (tmp_uri.slen < 1) {\n\tPJ_LOG(1,(THIS_FILE, \"Route URI is too long: %.*s\", \n\t\t  (int)uri->slen, uri->ptr));\n\tpj_pool_release(tmp_pool);\n\treturn PJSIP_EURITOOLONG;\n    }\n\n    /* Clone the URI */\n    pj_strdup_with_null(pool, uri, &tmp_uri);\n\n    pj_pool_release(tmp_pool);\n    return PJ_SUCCESS;\n}\n\n/*\n * This is a utility function to dump the stack states to log, using\n * verbosity level 3.\n */\nPJ_DEF(void) pjsua_dump(pj_bool_t detail)\n{\n    unsigned old_decor;\n    unsigned i;\n\n    PJ_LOG(3,(THIS_FILE, \"Start dumping application states:\"));\n\n    old_decor = pj_log_get_decor();\n    pj_log_set_decor(old_decor & (PJ_LOG_HAS_NEWLINE | PJ_LOG_HAS_CR));\n\n    if (detail)\n\tpj_dump_config();\n\n    pjsip_endpt_dump(pjsua_get_pjsip_endpt(), detail);\n\n    pjmedia_endpt_dump(pjsua_get_pjmedia_endpt());\n\n    PJ_LOG(3,(THIS_FILE, \"Dumping media transports:\"));\n    for (i=0; i<pjsua_var.ua_cfg.max_calls; ++i) {\n\tpjsua_call *call = &pjsua_var.calls[i];\n\tpjsua_acc_config *acc_cfg;\n\tpjmedia_transport *tp[PJSUA_MAX_CALL_MEDIA*2];\n\tunsigned tp_cnt = 0;\n\tunsigned j;\n\n\t/* Collect media transports in this call */\n\tfor (j = 0; j < call->med_cnt; ++j) {\n\t    if (call->media[j].tp != NULL)\n\t\ttp[tp_cnt++] = call->media[j].tp;\n\t}\n\tfor (j = 0; j < call->med_prov_cnt; ++j) {\n\t    pjmedia_transport *med_tp = call->media_prov[j].tp;\n\t    if (med_tp) {\n\t\tunsigned k;\n\t\tpj_bool_t used = PJ_FALSE;\n\t\tfor (k = 0; k < tp_cnt; ++k) {\n\t\t    if (med_tp == tp[k]) {\n\t\t\tused = PJ_TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!used)\n\t\t    tp[tp_cnt++] = med_tp;\n\t    }\n\t}\n\n\tacc_cfg = &pjsua_var.acc[call->acc_id].cfg;\n\n\t/* Dump the media transports in this call */\n\tfor (j = 0; j < tp_cnt; ++j) {\n\t    pjmedia_transport_info tpinfo;\n\t    char addr_buf[80];\n\n\t    pjmedia_transport_info_init(&tpinfo);\n\t    pjmedia_transport_get_info(tp[j], &tpinfo);\n\t    PJ_LOG(3,(THIS_FILE, \" %s: %s\",\n\t\t      (acc_cfg->ice_cfg.enable_ice ? \"ICE\" : \"UDP\"),\n\t\t      pj_sockaddr_print(&tpinfo.sock_info.rtp_addr_name,\n\t\t\t\t\taddr_buf,\n\t\t\t\t\tsizeof(addr_buf), 3)));\n\t}\n    }\n\n    pjsip_tsx_layer_dump(detail);\n    pjsip_ua_dump(detail);\n\n// Dumping complete call states may require a 'large' buffer \n// (about 3KB per call session, including RTCP XR).\n#if 0\n    /* Dump all invite sessions: */\n    PJ_LOG(3,(THIS_FILE, \"Dumping invite sessions:\"));\n\n    if (pjsua_call_get_count() == 0) {\n\n\tPJ_LOG(3,(THIS_FILE, \"  - no sessions -\"));\n\n    } else {\n\tunsigned i;\n\n\tfor (i=0; i<pjsua_var.ua_cfg.max_calls; ++i) {\n\t    if (pjsua_call_is_active(i)) {\n\t\t/* Tricky logging, since call states log string tends to be \n\t\t * longer than PJ_LOG_MAX_SIZE.\n\t\t */\n\t\tchar buf[1024 * 3];\n\t\tunsigned call_dump_len;\n\t\tunsigned part_len;\n\t\tunsigned part_idx;\n\t\tunsigned log_decor;\n\n\t\tpjsua_call_dump(i, detail, buf, sizeof(buf), \"  \");\n\t\tcall_dump_len = strlen(buf);\n\n\t\tlog_decor = pj_log_get_decor();\n\t\tpj_log_set_decor(log_decor & ~(PJ_LOG_HAS_NEWLINE | \n\t\t\t\t\t       PJ_LOG_HAS_CR));\n\t\tPJ_LOG(3,(THIS_FILE, \"\\n\"));\n\t\tpj_log_set_decor(0);\n\n\t\tpart_idx = 0;\n\t\tpart_len = PJ_LOG_MAX_SIZE-80;\n\t\twhile (part_idx < call_dump_len) {\n\t\t    char p_orig, *p;\n\n\t\t    p = &buf[part_idx];\n\t\t    if (part_idx + part_len > call_dump_len)\n\t\t\tpart_len = call_dump_len - part_idx;\n\t\t    p_orig = p[part_len];\n\t\t    p[part_len] = '\\0';\n\t\t    PJ_LOG(3,(THIS_FILE, \"%s\", p));\n\t\t    p[part_len] = p_orig;\n\t\t    part_idx += part_len;\n\t\t}\n\t\tpj_log_set_decor(log_decor);\n\t    }\n\t}\n    }\n#endif\n\n    /* Dump presence status */\n    pjsua_pres_dump(detail);\n\n    pj_log_set_decor(old_decor);\n    PJ_LOG(3,(THIS_FILE, \"Dump complete\"));\n}\n\n\n/* Forward declaration. */\nstatic void restart_listener_cb(void *user_data);\n\n\nstatic pj_status_t handle_ip_change_on_acc()\n{\n    int i = 0;\n    pj_status_t status = PJ_SUCCESS;\n    pj_bool_t acc_done[PJSUA_MAX_ACC];\n\n    PJSUA_LOCK();\n\n    if (pjsua_var.acc_cnt == 0) {\n\tPJ_LOG(3, (THIS_FILE,\n\t\t   \"No account is set, IP change handling will stop\"));\n\tpjsua_acc_end_ip_change(NULL);\n\tPJSUA_UNLOCK();\n\treturn status;\n    }\n\n    /* Reset ip_change_active flag. */\n    for (; i < (int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\tpjsua_var.acc[i].ip_change_op = PJSUA_IP_CHANGE_OP_NULL;\n\tacc_done[i] = PJ_FALSE;\n    }\n\n    for (i = 0; i < (int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\tpj_bool_t shutdown_transport = PJ_FALSE;\n\tpjsip_regc_info regc_info;\n\tchar acc_id[PJSUA_MAX_ACC * 4];\n\tpjsua_acc *acc = &pjsua_var.acc[i];\n\tpjsip_transport *transport = NULL;\n\tpjsua_acc_id shut_acc_ids[PJSUA_MAX_ACC];\n\tunsigned shut_acc_cnt = 0;\n\n\tif (!acc->valid || (acc_done[i]))\n\t    continue;\n\n\tif (acc->regc) {\n\t    int j = 0;\n\t    pj_status_t found_restart_tp_fail = PJ_FALSE;\n\n\t    pjsip_regc_get_info(acc->regc, &regc_info);\n\n\t    /* Check if transport restart listener succeed. */\n\t    for (; j < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++j) {\n\t\tif (pjsua_var.tpdata[j].data.ptr != NULL &&\n\t\t  pjsua_var.tpdata[j].restart_status != PJ_SUCCESS &&\n\t\t  pjsua_var.tpdata[j].type == regc_info.transport->key.type)\n\t\t{\n\t\t    if ((pjsua_var.tpdata[j].data.factory\n\t\t\t\t\t   == regc_info.transport->factory) ||\n\t\t\t(pjsua_var.tpdata[j].data.tp\n\t\t\t\t\t       == regc_info.transport))\n\t\t    {\n\t\t\tfound_restart_tp_fail = PJ_TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (found_restart_tp_fail) {\n\t\tif (acc->ka_timer.id) {\n\t\t    pjsip_endpt_cancel_timer(pjsua_var.endpt, &acc->ka_timer);\n\t\t    acc->ka_timer.id = PJ_FALSE;\n\n\t\t    if (acc->ka_transport) {\n\t\t\tpjsip_transport_dec_ref(acc->ka_transport);\n\t\t\tacc->ka_transport = NULL;\n\t\t    }\n\t\t}\n\t\tpjsua_acc_end_ip_change(acc);\n\t\tcontinue;\n\t    }\n\n\t    if ((regc_info.transport) &&\n\t\t((regc_info.transport->flag & PJSIP_TRANSPORT_DATAGRAM) == 0))\n\t    {\n\t\ttransport = regc_info.transport;\n\t\tshutdown_transport = acc->cfg.ip_change_cfg.shutdown_tp;\n\t\tshut_acc_ids[shut_acc_cnt++] = acc->index;\n\t    }\n\t} else if (acc->cfg.reg_uri.slen &&\n\t\t   acc->reg_last_code != PJSIP_SC_OK &&\n\t\t   acc->reg_last_code != PJSIP_SC_REQUEST_TIMEOUT &&\n\t\t   acc->reg_last_code != PJSIP_SC_INTERNAL_SERVER_ERROR &&\n\t\t   acc->reg_last_code != PJSIP_SC_BAD_GATEWAY &&\n\t\t   acc->reg_last_code != PJSIP_SC_SERVICE_UNAVAILABLE &&\n\t\t   acc->reg_last_code != PJSIP_SC_SERVER_TIMEOUT &&\n\t\t   acc->reg_last_code != PJSIP_SC_TEMPORARILY_UNAVAILABLE)\n\t{\n\t    PJ_LOG(3, (THIS_FILE, \"Permanent registration failure, \"\n\t\t       \"IP change handling will stop for acc %d\", acc->index));\n\n\t    pjsua_acc_end_ip_change(acc);\n\t    continue;\n\t}\n\tpj_ansi_snprintf(acc_id, sizeof(acc_id), \"#%d\", i);\n\n\tif (transport) {\n\t    unsigned j = i + 1;\n\n\t    /* Find other account that uses the same transport. */\n\t    for (; j < (int)PJ_ARRAY_SIZE(pjsua_var.acc); ++j) {\n\t\tpjsip_regc_info tmp_regc_info;\n\t\tpjsua_acc *next_acc = &pjsua_var.acc[j];\n\n\t\tif (!next_acc->valid || !next_acc->regc ||\n\t\t    (next_acc->ip_change_op > PJSUA_IP_CHANGE_OP_NULL))\n\t\t{\n\t\t    continue;\n\t\t}\n\n\t\tpjsip_regc_get_info(next_acc->regc, &tmp_regc_info);\n\t\tif (transport == tmp_regc_info.transport) {\n                    char tmp_buf[4];\n\n                    pj_ansi_snprintf(tmp_buf, sizeof(tmp_buf), \" #%d\", j);\n                    if (pj_ansi_strlen(acc_id) + pj_ansi_strlen(tmp_buf) <\n                        sizeof(acc_id))\n                    {\n                        pj_ansi_strcat(acc_id, tmp_buf);\n                    }\n\n\t\t    shut_acc_ids[shut_acc_cnt++] = j;\n\t\t    if (!shutdown_transport) {\n\t\t\tshutdown_transport =\n\t\t\t\t    next_acc->cfg.ip_change_cfg.shutdown_tp;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (shutdown_transport) {\n\t    unsigned j;\n\t    /* Shutdown the transport. */\n\t    PJ_LOG(3, (THIS_FILE, \"Shutdown transport %s used by account %s \"\n\t\t       \"triggered by IP change\", transport->obj_name, acc_id));\n\n\t    for (j = 0; j < shut_acc_cnt; ++j) {\n\t\tpjsua_acc *tmp_acc = &pjsua_var.acc[shut_acc_ids[j]];\n\t\ttmp_acc->ip_change_op = PJSUA_IP_CHANGE_OP_ACC_SHUTDOWN_TP;\n\t\tacc_done[shut_acc_ids[j]] = PJ_TRUE;\n\t    }\n\n\t    status = pjsip_transport_shutdown2(transport, PJ_TRUE);\n\t} else {\n\t    acc_done[i] = PJ_TRUE;\n\t    if (acc->cfg.allow_contact_rewrite && acc->cfg.reg_uri.slen) {\n\t\tstatus = pjsua_acc_update_contact_on_ip_change(acc);\n\t    } else {\n\t\tstatus = pjsua_acc_handle_call_on_ip_change(acc);\n\t    }\n\t}\n    }\n    PJSUA_UNLOCK();\n    return status;\n}\n\n\nstatic pj_status_t restart_listener(pjsua_transport_id id,\n\t\t\t\t    unsigned restart_lis_delay)\n{\n    pj_sockaddr bind_addr;\n    pjsua_transport_info tp_info;\n    pj_status_t status;\n\n    pjsua_transport_get_info(id, &tp_info);\n    pj_sockaddr_init(pjsip_transport_type_get_af(tp_info.type),\n\t\t     &bind_addr,\n\t\t     NULL,\n\t\t     pj_sockaddr_get_port(&tp_info.local_addr));\n\n    switch (tp_info.type) {\n    case PJSIP_TRANSPORT_UDP:\n    case PJSIP_TRANSPORT_UDP6:    \n    {\n\tunsigned num_locks = 0;\n\n\t/* Release locks before restarting the transport, to avoid deadlock. */\n\twhile (PJSUA_LOCK_IS_LOCKED()) {\n    \t    num_locks++;\n    \t    PJSUA_UNLOCK();\n\t}\n\n\tstatus = pjsip_udp_transport_restart2(\n\t\t\t\t       pjsua_var.tpdata[id].data.tp,\n\t\t\t\t       PJSIP_UDP_TRANSPORT_DESTROY_SOCKET,\n\t\t\t\t       PJ_INVALID_SOCKET,\n\t\t\t\t       &bind_addr,\n\t\t\t\t       NULL);\n\n\t/* Re-acquire the locks. */\n\tfor (;num_locks > 0; num_locks--)\n    \t    PJSUA_LOCK();\n\n    }\n\tbreak;\n\n#if defined(PJSIP_HAS_TLS_TRANSPORT) && PJSIP_HAS_TLS_TRANSPORT!=0\n    case PJSIP_TRANSPORT_TLS:\n    case PJSIP_TRANSPORT_TLS6:\n\tstatus = pjsip_tls_transport_restart(\n\t\t\t\t\tpjsua_var.tpdata[id].data.factory,\n\t\t\t\t\t&bind_addr,\n\t\t\t\t\tNULL);\n\tbreak;\n#endif\n    case PJSIP_TRANSPORT_TCP:\n    case PJSIP_TRANSPORT_TCP6:\n\tstatus = pjsip_tcp_transport_restart(\n\t\t\t\t\tpjsua_var.tpdata[id].data.factory,\n\t\t\t\t\t&bind_addr,\n\t\t\t\t\tNULL);\n\tbreak;\n\n    default:\n\tstatus = PJ_EINVAL;\n    }\n\n    PJ_PERROR(3,(THIS_FILE, status, \"Listener %.*s restart\",\n\t\t tp_info.info.slen, tp_info.info.ptr));\n\n    if (status != PJ_SUCCESS && (restart_lis_delay > 0)) {\n\t/* Try restarting again, with delay. */\n\tpjsua_schedule_timer2(&restart_listener_cb,\n\t\t\t      (void*)(pj_size_t)id,\n\t\t\t      restart_lis_delay);\n\n\tPJ_LOG(3,(THIS_FILE, \"Retry listener %.*s restart in %d ms\",\n\t\t  tp_info.info.slen, tp_info.info.ptr, restart_lis_delay));\n\n\tstatus = PJ_SUCCESS;\n    } else {\n\tint i = 0;\n\tpj_bool_t all_done = PJ_TRUE;\n\n\tpjsua_var.tpdata[id].is_restarting = PJ_FALSE;\n\tpjsua_var.tpdata[id].restart_status = status;\n\tif (pjsua_var.ua_cfg.cb.on_ip_change_progress) {\n\t    pjsua_ip_change_op_info info;\n\n\t    pj_bzero(&info, sizeof(info));\n\t    info.lis_restart.transport_id = id;\n\t    pjsua_var.ua_cfg.cb.on_ip_change_progress(\n\t\t\t\t\t\tPJSUA_IP_CHANGE_OP_RESTART_LIS,\n\t\t\t\t\t\tstatus,\n\t\t\t\t\t\t&info);\n\t}\n\n\t/* Move forward if all listener has been restarted. */\n\tfor (; i < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++i) {\n\t    if (pjsua_var.tpdata[i].data.ptr != NULL &&\n\t\tpjsua_var.tpdata[i].is_restarting)\n\t    {\n\t\tall_done = PJ_FALSE;\n\t\tbreak;\n\t    }\n\t}\n\tif (all_done)\n\t    status = handle_ip_change_on_acc();\n    }\n    return status;\n}\n\n\nstatic void restart_listener_cb(void *user_data)\n{\n    pjsua_transport_id transport_id = (pjsua_transport_id)(pj_size_t)user_data;\n    restart_listener(transport_id, 0);\n}\n\n\nstatic void ip_change_put_back_inv_config(void *user_data)\n{\n    PJ_UNUSED_ARG(user_data);\n\n    PJ_LOG(4,(THIS_FILE,\"IP change stops ignoring request timeout\"));\n    pjsip_cfg()->endpt.keep_inv_after_tsx_timeout = PJ_FALSE;\n}\n\n\nPJ_DEF(pj_status_t) pjsua_handle_ip_change(const pjsua_ip_change_param *param)\n{\n    pj_status_t status = PJ_SUCCESS;\n    int i = 0;\n\n    PJ_ASSERT_RETURN(param, PJ_EINVAL);\n\n    for (; i < (int)PJ_ARRAY_SIZE(pjsua_var.acc); ++i) {\n\tif (pjsua_var.acc[i].valid &&\n\t    pjsua_var.acc[i].ip_change_op != PJSUA_IP_CHANGE_OP_NULL &&\n\t    pjsua_var.acc[i].ip_change_op != PJSUA_IP_CHANGE_OP_COMPLETED)\n\t{\n\t    PJ_LOG(2, (THIS_FILE,\n\t\t     \"Previous IP address change handling still in progress\"));\n\t}\n    }\n\n    PJ_LOG(3, (THIS_FILE, \"Start handling IP address change\"));\n\n    /* Avoid call disconnection due to request timeout. Some requests may\n     * be in progress when network is changing, they may eventually get\n     * timed out and cause call disconnection.\n     */\n    if (!pjsip_cfg()->endpt.keep_inv_after_tsx_timeout) {\n\tpjsip_cfg()->endpt.keep_inv_after_tsx_timeout = PJ_TRUE;\n\n\t/* Put it back after some time (transaction timeout setting value) */\n\tpjsua_schedule_timer2(&ip_change_put_back_inv_config, NULL,\n\t\t\t      pjsip_cfg()->tsx.td);\n\n\tPJ_LOG(4,(THIS_FILE,\"IP change temporarily ignores request timeout\"));\n    }\n\n    if (param->restart_listener) {\n\tPJSUA_LOCK();\n\t/* Restart listener/transport, handle_ip_change_on_acc() will\n\t * be called after listener restart is completed successfully.\n\t */\n\tfor (i = 0; i < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++i) {\n\t    if (pjsua_var.tpdata[i].data.ptr != NULL) {\n\t\tpjsua_var.tpdata[i].is_restarting = PJ_TRUE;\n\t\tpjsua_var.tpdata[i].restart_status = PJ_EUNKNOWN;\n\t    }\n\t}\n\tfor (i = 0; i < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++i) {\n\t    if (pjsua_var.tpdata[i].data.ptr != NULL) {\n\t\tstatus = restart_listener(i, param->restart_lis_delay);\n\t    }\n\t}\n        PJSUA_UNLOCK();\n    } else {\n\tfor (i = 0; i < PJ_ARRAY_SIZE(pjsua_var.tpdata); ++i) {\n\t    if (pjsua_var.tpdata[i].data.ptr != NULL) {\n\t\tpjsua_var.tpdata[i].restart_status = PJ_SUCCESS;\n\t    }\n\t}\n\tstatus = handle_ip_change_on_acc();\n    }\n\n    return status;\n}\n"], "filenames": ["pjsip/include/pjsip/sip_auth.h", "pjsip/src/pjsip/sip_auth_aka.c", "pjsip/src/pjsip/sip_auth_client.c", "pjsip/src/pjsip/sip_auth_server.c", "pjsip/src/pjsua-lib/pjsua_core.c"], "buggy_code_start_loc": [587, 60, 163, 81, 3129], "buggy_code_end_loc": [597, 200, 512, 106, 3130], "fixing_code_start_loc": [587, 60, 163, 82, 3129], "fixing_code_end_loc": [627, 201, 531, 111, 3131], "type": "CWE-120", "message": "PJSIP is a free and open source multimedia communication library written in C language. In versions prior to and including 2.12 PJSIP there is a stack-buffer overflow vulnerability which only impacts PJSIP users who accept hashed digest credentials (credentials with data_type `PJSIP_CRED_DATA_DIGEST`). This issue has been patched in the master branch of the PJSIP repository and will be included with the next release. Users unable to upgrade need to check that the hashed digest data length must be equal to `PJSIP_MD5STRLEN` before passing to PJSIP.", "other": {"cve": {"id": "CVE-2022-24754", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-11T20:15:08.873", "lastModified": "2022-11-16T19:26:42.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C language. In versions prior to and including 2.12 PJSIP there is a stack-buffer overflow vulnerability which only impacts PJSIP users who accept hashed digest credentials (credentials with data_type `PJSIP_CRED_DATA_DIGEST`). This issue has been patched in the master branch of the PJSIP repository and will be included with the next release. Users unable to upgrade need to check that the hashed digest data length must be equal to `PJSIP_MD5STRLEN` before passing to PJSIP."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en lenguaje C. En las versiones anteriores a 2.12 de PJSIP, se presenta una vulnerabilidad de desbordamiento del buffer de pila que s\u00f3lo afecta a usuarios de PJSIP que aceptan credenciales de resumen (data_type \"PJSIP_CRED_DATA_DIGEST\"). Este problema ha sido parcheado en la rama maestra del repositorio PJSIP y ser\u00e1 incluida en la pr\u00f3xima versi\u00f3n. Los usuarios que no puedan actualizarse deben comprobar que la longitud de los datos del resumen hash debe ser igual a \"PJSIP_MD5STRLEN\" antes de pasar a PJSIP"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.12", "matchCriteriaId": "0BB82CA1-A3B5-4FFB-B6B2-9E5FB840ED07"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/d27f79da11df7bc8bb56c2f291d71e54df8d2c47", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-73f7-48m9-w662", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/d27f79da11df7bc8bb56c2f291d71e54df8d2c47"}}