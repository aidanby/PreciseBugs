{"buggy_code": ["package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/infra/fs\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/plugins/backendplugin\"\n\t\"github.com/grafana/grafana/pkg/plugins/repo\"\n\t\"github.com/grafana/grafana/pkg/plugins/storage\"\n\tac \"github.com/grafana/grafana/pkg/services/accesscontrol\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/services/featuremgmt\"\n\t\"github.com/grafana/grafana/pkg/services/org\"\n\t\"github.com/grafana/grafana/pkg/services/pluginsettings\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nfunc (hs *HTTPServer) GetPluginList(c *models.ReqContext) response.Response {\n\ttypeFilter := c.Query(\"type\")\n\tenabledFilter := c.Query(\"enabled\")\n\tembeddedFilter := c.Query(\"embedded\")\n\t// \"\" => no filter\n\t// \"0\" => filter out core plugins\n\t// \"1\" => filter out non-core plugins\n\tcoreFilter := c.Query(\"core\")\n\n\t// FIXME: while we don't have permissions for listing plugins we need this complex check:\n\t// When using access control, should be able to list non-core plugins:\n\t//  * anyone that can create a data source\n\t//  * anyone that can install a plugin\n\t// Fallback to only letting admins list non-core plugins\n\treqOrgAdmin := ac.ReqHasRole(org.RoleAdmin)\n\thasAccess := ac.HasAccess(hs.AccessControl, c)\n\tcanListNonCorePlugins := reqOrgAdmin(c) || hasAccess(reqOrgAdmin, ac.EvalAny(\n\t\tac.EvalPermission(datasources.ActionCreate),\n\t\tac.EvalPermission(plugins.ActionInstall),\n\t))\n\n\tpluginSettingsMap, err := hs.pluginSettings(c.Req.Context(), c.OrgID)\n\tif err != nil {\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to get list of plugins\", err)\n\t}\n\n\t// Filter plugins\n\tpluginDefinitions := hs.pluginStore.Plugins(c.Req.Context())\n\tfilteredPluginDefinitions := []plugins.PluginDTO{}\n\tfilteredPluginIDs := map[string]bool{}\n\tfor _, pluginDef := range pluginDefinitions {\n\t\t// filter out app sub plugins\n\t\tif embeddedFilter == \"0\" && pluginDef.IncludedInAppID != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out core plugins\n\t\tif (coreFilter == \"0\" && pluginDef.IsCorePlugin()) || (coreFilter == \"1\" && !pluginDef.IsCorePlugin()) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// FIXME: while we don't have permissions for listing plugins we need this complex check:\n\t\t// When using access control, should be able to list non-core plugins:\n\t\t//  * anyone that can create a data source\n\t\t//  * anyone that can install a plugin\n\t\t// Should be able to list this installed plugin:\n\t\t//  * anyone that can edit its settings\n\t\tif !pluginDef.IsCorePlugin() && !canListNonCorePlugins && !hasAccess(reqOrgAdmin,\n\t\t\tac.EvalPermission(plugins.ActionWrite, plugins.ScopeProvider.GetResourceScope(pluginDef.ID))) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter on type\n\t\tif typeFilter != \"\" && typeFilter != string(pluginDef.Type) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif pluginDef.State == plugins.AlphaRelease && !hs.Cfg.PluginsEnableAlpha {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out built in plugins\n\t\tif pluginDef.BuiltIn {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out disabled plugins\n\t\tif pluginSetting, exists := pluginSettingsMap[pluginDef.ID]; exists {\n\t\t\tif enabledFilter == \"1\" && !pluginSetting.Enabled {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif (pluginDef.ID == \"parca\" || pluginDef.ID == \"phlare\") && !hs.Features.IsEnabled(featuremgmt.FlagFlameGraph) {\n\t\t\tcontinue\n\t\t}\n\n\t\tfilteredPluginDefinitions = append(filteredPluginDefinitions, pluginDef)\n\t\tfilteredPluginIDs[pluginDef.ID] = true\n\t}\n\n\t// Compute metadata\n\tpluginsMetadata := hs.getMultiAccessControlMetadata(c, c.OrgID,\n\t\tplugins.ScopeProvider.GetResourceScope(\"\"), filteredPluginIDs)\n\n\t// Prepare DTO\n\tresult := make(dtos.PluginList, 0)\n\tfor _, pluginDef := range filteredPluginDefinitions {\n\t\tlistItem := dtos.PluginListItem{\n\t\t\tId:            pluginDef.ID,\n\t\t\tName:          pluginDef.Name,\n\t\t\tType:          string(pluginDef.Type),\n\t\t\tCategory:      pluginDef.Category,\n\t\t\tInfo:          pluginDef.Info,\n\t\t\tDependencies:  pluginDef.Dependencies,\n\t\t\tDefaultNavUrl: path.Join(hs.Cfg.AppSubURL, pluginDef.DefaultNavURL),\n\t\t\tState:         pluginDef.State,\n\t\t\tSignature:     pluginDef.Signature,\n\t\t\tSignatureType: pluginDef.SignatureType,\n\t\t\tSignatureOrg:  pluginDef.SignatureOrg,\n\t\t\tAccessControl: pluginsMetadata[pluginDef.ID],\n\t\t}\n\n\t\tupdate, exists := hs.pluginsUpdateChecker.HasUpdate(c.Req.Context(), pluginDef.ID)\n\t\tif exists {\n\t\t\tlistItem.LatestVersion = update\n\t\t\tlistItem.HasUpdate = true\n\t\t}\n\n\t\tif pluginSetting, exists := pluginSettingsMap[pluginDef.ID]; exists {\n\t\t\tlistItem.Enabled = pluginSetting.Enabled\n\t\t\tlistItem.Pinned = pluginSetting.Pinned\n\t\t}\n\n\t\tif listItem.DefaultNavUrl == \"\" || !listItem.Enabled {\n\t\t\tlistItem.DefaultNavUrl = hs.Cfg.AppSubURL + \"/plugins/\" + listItem.Id + \"/\"\n\t\t}\n\n\t\tresult = append(result, listItem)\n\t}\n\n\tsort.Sort(result)\n\treturn response.JSON(http.StatusOK, result)\n}\n\nfunc (hs *HTTPServer) GetPluginSettingByID(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(http.StatusNotFound, \"Plugin not found, no installed plugin with that id\", nil)\n\t}\n\n\t// In a first iteration, we only have one permission for app plugins.\n\t// We will need a different permission to allow users to configure the plugin without needing access to it.\n\tif plugin.IsApp() {\n\t\thasAccess := ac.HasAccess(hs.AccessControl, c)\n\t\tif !hasAccess(ac.ReqSignedIn,\n\t\t\tac.EvalPermission(plugins.ActionAppAccess, plugins.ScopeProvider.GetResourceScope(plugin.ID))) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Access Denied\", nil)\n\t\t}\n\t}\n\n\tdto := &dtos.PluginSetting{\n\t\tType:             string(plugin.Type),\n\t\tId:               plugin.ID,\n\t\tName:             plugin.Name,\n\t\tInfo:             plugin.Info,\n\t\tDependencies:     plugin.Dependencies,\n\t\tIncludes:         plugin.Includes,\n\t\tBaseUrl:          plugin.BaseURL,\n\t\tModule:           plugin.Module,\n\t\tDefaultNavUrl:    path.Join(hs.Cfg.AppSubURL, plugin.DefaultNavURL),\n\t\tState:            plugin.State,\n\t\tSignature:        plugin.Signature,\n\t\tSignatureType:    plugin.SignatureType,\n\t\tSignatureOrg:     plugin.SignatureOrg,\n\t\tSecureJsonFields: map[string]bool{},\n\t}\n\n\tif plugin.IsApp() {\n\t\tdto.Enabled = plugin.AutoEnabled\n\t\tdto.Pinned = plugin.AutoEnabled\n\t}\n\n\tps, err := hs.PluginSettings.GetPluginSettingByPluginID(c.Req.Context(), &pluginsettings.GetByPluginIDArgs{\n\t\tPluginID: pluginID,\n\t\tOrgID:    c.OrgID,\n\t})\n\tif err != nil {\n\t\tif !errors.Is(err, models.ErrPluginSettingNotFound) {\n\t\t\treturn response.Error(http.StatusInternalServerError, \"Failed to get plugin settings\", nil)\n\t\t}\n\t} else {\n\t\tdto.Enabled = ps.Enabled\n\t\tdto.Pinned = ps.Pinned\n\t\tdto.JsonData = ps.JSONData\n\n\t\tfor k, v := range hs.PluginSettings.DecryptedValues(ps) {\n\t\t\tif len(v) > 0 {\n\t\t\t\tdto.SecureJsonFields[k] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate, exists := hs.pluginsUpdateChecker.HasUpdate(c.Req.Context(), plugin.ID)\n\tif exists {\n\t\tdto.LatestVersion = update\n\t\tdto.HasUpdate = true\n\t}\n\n\treturn response.JSON(http.StatusOK, dto)\n}\n\nfunc (hs *HTTPServer) UpdatePluginSetting(c *models.ReqContext) response.Response {\n\tcmd := models.UpdatePluginSettingCmd{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tif _, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID); !exists {\n\t\treturn response.Error(404, \"Plugin not installed\", nil)\n\t}\n\n\tcmd.OrgId = c.OrgID\n\tcmd.PluginId = pluginID\n\tif err := hs.PluginSettings.UpdatePluginSetting(c.Req.Context(), &pluginsettings.UpdateArgs{\n\t\tEnabled:                 cmd.Enabled,\n\t\tPinned:                  cmd.Pinned,\n\t\tJSONData:                cmd.JsonData,\n\t\tSecureJSONData:          cmd.SecureJsonData,\n\t\tPluginVersion:           cmd.PluginVersion,\n\t\tPluginID:                cmd.PluginId,\n\t\tOrgID:                   cmd.OrgId,\n\t\tEncryptedSecureJSONData: cmd.EncryptedSecureJsonData,\n\t}); err != nil {\n\t\treturn response.Error(500, \"Failed to update plugin setting\", err)\n\t}\n\n\treturn response.Success(\"Plugin settings updated\")\n}\n\nfunc (hs *HTTPServer) GetPluginMarkdown(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tname := web.Params(c.Req)[\":name\"]\n\n\tcontent, err := hs.pluginMarkdown(c.Req.Context(), pluginID, name)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Could not get markdown file\", err)\n\t}\n\n\t// fallback try readme\n\tif len(content) == 0 {\n\t\tcontent, err = hs.pluginMarkdown(c.Req.Context(), pluginID, \"help\")\n\t\tif err != nil {\n\t\t\treturn response.Error(501, \"Could not get markdown file\", err)\n\t\t}\n\t}\n\n\tresp := response.Respond(http.StatusOK, content)\n\tresp.SetHeader(\"Content-Type\", \"text/plain; charset=utf-8\")\n\treturn resp\n}\n\n// CollectPluginMetrics collect metrics from a plugin.\n//\n// /api/plugins/:pluginId/metrics\nfunc (hs *HTTPServer) CollectPluginMetrics(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tresp, err := hs.pluginClient.CollectMetrics(c.Req.Context(), &backend.CollectMetricsRequest{PluginContext: backend.PluginContext{PluginID: pluginID}})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\theaders := make(http.Header)\n\theaders.Set(\"Content-Type\", \"text/plain\")\n\n\treturn response.CreateNormalResponse(headers, resp.PrometheusMetrics, http.StatusOK)\n}\n\n// getPluginAssets returns public plugin assets (images, JS, etc.)\n//\n// /public/plugins/:pluginId/*\nfunc (hs *HTTPServer) getPluginAssets(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\t// prepend slash for cleaning relative paths\n\trequestedFile := filepath.Clean(filepath.Join(\"/\", web.Params(c.Req)[\"*\"]))\n\trel, err := filepath.Rel(\"/\", requestedFile)\n\tif err != nil {\n\t\t// slash is prepended above therefore this is not expected to fail\n\t\tc.JsonApiErr(500, \"Failed to get the relative path\", err)\n\t\treturn\n\t}\n\n\tif !plugin.IncludedInSignature(rel) {\n\t\ths.log.Warn(\"Access to requested plugin file will be forbidden in upcoming Grafana versions as the file \"+\n\t\t\t\"is not included in the plugin signature\", \"file\", requestedFile)\n\t}\n\n\tabsPluginDir, err := filepath.Abs(plugin.PluginDir)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin absolute path\", nil)\n\t\treturn\n\t}\n\n\tpluginFilePath := filepath.Join(absPluginDir, rel)\n\n\t// It's safe to ignore gosec warning G304 since we already clean the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\t// nolint:gosec\n\tf, err := os.Open(pluginFilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tc.JsonApiErr(404, \"Plugin file not found\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(500, \"Could not open plugin file\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err := f.Close(); err != nil {\n\t\t\ths.log.Error(\"Failed to close file\", \"err\", err)\n\t\t}\n\t}()\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Plugin file exists but could not open\", err)\n\t\treturn\n\t}\n\n\tif hs.Cfg.Env == setting.Dev {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"max-age=0, must-revalidate, no-cache\")\n\t} else {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"public, max-age=3600\")\n\t}\n\n\thttp.ServeContent(c.Resp, c.Req, pluginFilePath, fi.ModTime(), f)\n}\n\n// CheckHealth returns the health of a plugin.\n// /api/plugins/:pluginId/health\nfunc (hs *HTTPServer) CheckHealth(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, c.SignedInUser)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get plugin settings\", err)\n\t}\n\tif !found {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CheckHealth(c.Req.Context(), &backend.CheckHealthRequest{\n\t\tPluginContext: pCtx,\n\t\tHeaders:       map[string]string{},\n\t})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\tpayload := map[string]interface{}{\n\t\t\"status\":  resp.Status.String(),\n\t\t\"message\": resp.Message,\n\t}\n\n\t// Unmarshal JSONDetails if it's not empty.\n\tif len(resp.JSONDetails) > 0 {\n\t\tvar jsonDetails map[string]interface{}\n\t\terr = json.Unmarshal(resp.JSONDetails, &jsonDetails)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to unmarshal detailed response from backend plugin\", err)\n\t\t}\n\n\t\tpayload[\"details\"] = jsonDetails\n\t}\n\n\tif resp.Status != backend.HealthStatusOk {\n\t\treturn response.JSON(503, payload)\n\t}\n\n\treturn response.JSON(http.StatusOK, payload)\n}\n\nfunc (hs *HTTPServer) GetPluginErrorsList(_ *models.ReqContext) response.Response {\n\treturn response.JSON(http.StatusOK, hs.pluginErrorResolver.PluginErrors())\n}\n\nfunc (hs *HTTPServer) InstallPlugin(c *models.ReqContext) response.Response {\n\tdto := dtos.InstallPluginCommand{}\n\tif err := web.Bind(c.Req, &dto); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginInstaller.Add(c.Req.Context(), pluginID, dto.Version, plugins.CompatOpts{\n\t\tGrafanaVersion: hs.Cfg.BuildVersion,\n\t\tOS:             runtime.GOOS,\n\t\tArch:           runtime.GOARCH,\n\t})\n\tif err != nil {\n\t\tvar dupeErr plugins.DuplicateError\n\t\tif errors.As(err, &dupeErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin already installed\", err)\n\t\t}\n\t\tvar versionUnsupportedErr repo.ErrVersionUnsupported\n\t\tif errors.As(err, &versionUnsupportedErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin version not supported\", err)\n\t\t}\n\t\tvar versionNotFoundErr repo.ErrVersionNotFound\n\t\tif errors.As(err, &versionNotFoundErr) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin version not found\", err)\n\t\t}\n\t\tvar clientError repo.Response4xxError\n\t\tif errors.As(err, &clientError) {\n\t\t\treturn response.Error(clientError.StatusCode, clientError.Message, err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrInstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot install or change a Core plugin\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to install plugin\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc (hs *HTTPServer) UninstallPlugin(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginInstaller.Remove(c.Req.Context(), pluginID)\n\tif err != nil {\n\t\tif errors.Is(err, plugins.ErrPluginNotInstalled) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin not installed\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a Core plugin\", err)\n\t\t}\n\t\tif errors.Is(err, storage.ErrUninstallOutsideOfPluginDir) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a plugin outside of the plugins directory\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to uninstall plugin\", err)\n\t}\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc translatePluginRequestErrorToAPIError(err error) response.Response {\n\tif errors.Is(err, backendplugin.ErrPluginNotRegistered) {\n\t\treturn response.Error(404, \"Plugin not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treturn response.Error(404, \"Not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrHealthCheckFailed) {\n\t\treturn response.Error(500, \"Plugin health check failed\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treturn response.Error(503, \"Plugin unavailable\", err)\n\t}\n\n\treturn response.Error(500, \"Plugin request failed\", err)\n}\n\nfunc (hs *HTTPServer) pluginMarkdown(ctx context.Context, pluginId string, name string) ([]byte, error) {\n\tplugin, exists := hs.pluginStore.Plugin(ctx, pluginId)\n\tif !exists {\n\t\treturn nil, plugins.NotFoundError{PluginID: pluginId}\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning since we have cleaned the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\tpath := filepath.Join(plugin.PluginDir, mdFilepath(strings.ToUpper(name)))\n\texists, err := fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\tpath = filepath.Join(plugin.PluginDir, mdFilepath(strings.ToLower(name)))\n\t}\n\n\texists, err = fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn make([]byte, 0), nil\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning since we have cleaned the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n\nfunc mdFilepath(mdFilename string) string {\n\treturn filepath.Clean(filepath.Join(\"/\", fmt.Sprintf(\"%s.md\", mdFilename)))\n}\n", "import React, { PureComponent } from 'react';\n\nimport { renderMarkdown } from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\n\ninterface Props {\n  plugin: {\n    name: string;\n    id: string;\n  };\n  type: string;\n}\n\ninterface State {\n  isError: boolean;\n  isLoading: boolean;\n  help: string;\n}\n\nexport class PluginHelp extends PureComponent<Props, State> {\n  state = {\n    isError: false,\n    isLoading: false,\n    help: '',\n  };\n\n  componentDidMount(): void {\n    this.loadHelp();\n  }\n\n  constructPlaceholderInfo() {\n    return 'No plugin help or readme markdown file was found';\n  }\n\n  loadHelp = () => {\n    const { plugin, type } = this.props;\n    this.setState({ isLoading: true });\n\n    getBackendSrv()\n      .get(`/api/plugins/${plugin.id}/markdown/${type}`)\n      .then((response: string) => {\n        const helpHtml = renderMarkdown(response);\n\n        if (response === '' && type === 'help') {\n          this.setState({\n            isError: false,\n            isLoading: false,\n            help: this.constructPlaceholderInfo(),\n          });\n        } else {\n          this.setState({\n            isError: false,\n            isLoading: false,\n            help: helpHtml,\n          });\n        }\n      })\n      .catch(() => {\n        this.setState({\n          isError: true,\n          isLoading: false,\n        });\n      });\n  };\n\n  render() {\n    const { type } = this.props;\n    const { isError, isLoading, help } = this.state;\n\n    if (isLoading) {\n      return <h2>Loading help...</h2>;\n    }\n\n    if (isError) {\n      return <h3>&apos;Error occurred when loading help&apos;</h3>;\n    }\n\n    if (type === 'panel_help' && help === '') {\n    }\n\n    return <div className=\"markdown-html\" dangerouslySetInnerHTML={{ __html: help }} />;\n  }\n}\n", "import { css } from '@emotion/css';\nimport React, { PureComponent } from 'react';\nimport { Unsubscribable } from 'rxjs';\n\nimport {\n  CoreApp,\n  DataQuery,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  getDefaultTimeRange,\n  LoadingState,\n  PanelData,\n} from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { DataSourcePicker, getDataSourceSrv } from '@grafana/runtime';\nimport { Button, CustomScrollbar, HorizontalGroup, InlineFormLabel, Modal, stylesFactory } from '@grafana/ui';\nimport { PluginHelp } from 'app/core/components/PluginHelp/PluginHelp';\nimport config from 'app/core/config';\nimport { backendSrv } from 'app/core/services/backend_srv';\nimport { addQuery, queryIsEmpty } from 'app/core/utils/query';\nimport { dataSource as expressionDatasource } from 'app/features/expressions/ExpressionDatasource';\nimport { DashboardQueryEditor, isSharedDashboardQuery } from 'app/plugins/datasource/dashboard';\nimport { QueryGroupOptions } from 'app/types';\n\nimport { PanelQueryRunner } from '../state/PanelQueryRunner';\nimport { updateQueries } from '../state/updateQueries';\n\nimport { GroupActionComponents } from './QueryActionComponent';\nimport { QueryEditorRows } from './QueryEditorRows';\nimport { QueryGroupOptionsEditor } from './QueryGroupOptions';\n\ninterface Props {\n  queryRunner: PanelQueryRunner;\n  options: QueryGroupOptions;\n  onOpenQueryInspector?: () => void;\n  onRunQueries: () => void;\n  onOptionsChange: (options: QueryGroupOptions) => void;\n}\n\ninterface State {\n  dataSource?: DataSourceApi;\n  dsSettings?: DataSourceInstanceSettings;\n  queries: DataQuery[];\n  helpContent: React.ReactNode;\n  isLoadingHelp: boolean;\n  isPickerOpen: boolean;\n  isAddingMixed: boolean;\n  data: PanelData;\n  isHelpOpen: boolean;\n  defaultDataSource?: DataSourceApi;\n  scrollElement?: HTMLDivElement;\n}\n\nexport class QueryGroup extends PureComponent<Props, State> {\n  backendSrv = backendSrv;\n  dataSourceSrv = getDataSourceSrv();\n  querySubscription: Unsubscribable | null = null;\n\n  state: State = {\n    isLoadingHelp: false,\n    helpContent: null,\n    isPickerOpen: false,\n    isAddingMixed: false,\n    isHelpOpen: false,\n    queries: [],\n    data: {\n      state: LoadingState.NotStarted,\n      series: [],\n      timeRange: getDefaultTimeRange(),\n    },\n  };\n\n  async componentDidMount() {\n    const { queryRunner, options } = this.props;\n\n    this.querySubscription = queryRunner.getData({ withTransforms: false, withFieldConfig: false }).subscribe({\n      next: (data: PanelData) => this.onPanelDataUpdate(data),\n    });\n\n    try {\n      const ds = await this.dataSourceSrv.get(options.dataSource);\n      const dsSettings = this.dataSourceSrv.getInstanceSettings(options.dataSource);\n      const defaultDataSource = await this.dataSourceSrv.get();\n      const datasource = ds.getRef();\n      const queries = options.queries.map((q) => ({\n        ...(queryIsEmpty(q) && ds?.getDefaultQuery?.(CoreApp.PanelEditor)),\n        datasource,\n        ...q,\n      }));\n      this.setState({ queries, dataSource: ds, dsSettings, defaultDataSource });\n    } catch (error) {\n      console.log('failed to load data source', error);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.querySubscription) {\n      this.querySubscription.unsubscribe();\n      this.querySubscription = null;\n    }\n  }\n\n  onPanelDataUpdate(data: PanelData) {\n    this.setState({ data });\n  }\n\n  onChangeDataSource = async (newSettings: DataSourceInstanceSettings) => {\n    const { dsSettings } = this.state;\n    const currentDS = dsSettings ? await getDataSourceSrv().get(dsSettings.uid) : undefined;\n    const nextDS = await getDataSourceSrv().get(newSettings.uid);\n\n    // We need to pass in newSettings.uid as well here as that can be a variable expression and we want to store that in the query model not the current ds variable value\n    const queries = await updateQueries(nextDS, newSettings.uid, this.state.queries, currentDS);\n\n    const dataSource = await this.dataSourceSrv.get(newSettings.name);\n    this.onChange({\n      queries,\n      dataSource: {\n        name: newSettings.name,\n        uid: newSettings.uid,\n        type: newSettings.meta.id,\n        default: newSettings.isDefault,\n      },\n    });\n\n    this.setState({\n      queries,\n      dataSource: dataSource,\n      dsSettings: newSettings,\n    });\n  };\n\n  onAddQueryClick = () => {\n    const { queries } = this.state;\n    this.onQueriesChange(addQuery(queries, this.newQuery()));\n    this.onScrollBottom();\n  };\n\n  newQuery(): Partial<DataQuery> {\n    const { dsSettings, defaultDataSource } = this.state;\n\n    const ds = !dsSettings?.meta.mixed ? dsSettings : defaultDataSource;\n\n    return {\n      ...this.state.dataSource?.getDefaultQuery?.(CoreApp.PanelEditor),\n      datasource: { uid: ds?.uid, type: ds?.type },\n    };\n  }\n\n  onChange(changedProps: Partial<QueryGroupOptions>) {\n    this.props.onOptionsChange({\n      ...this.props.options,\n      ...changedProps,\n    });\n  }\n\n  onAddExpressionClick = () => {\n    this.onQueriesChange(addQuery(this.state.queries, expressionDatasource.newQuery()));\n    this.onScrollBottom();\n  };\n\n  onScrollBottom = () => {\n    setTimeout(() => {\n      if (this.state.scrollElement) {\n        this.state.scrollElement.scrollTo({ top: 10000 });\n      }\n    }, 20);\n  };\n\n  onUpdateAndRun = (options: QueryGroupOptions) => {\n    this.props.onOptionsChange(options);\n    this.props.onRunQueries();\n  };\n\n  renderTopSection(styles: QueriesTabStyles) {\n    const { onOpenQueryInspector, options } = this.props;\n    const { dataSource, data } = this.state;\n\n    return (\n      <div>\n        <div className={styles.dataSourceRow}>\n          <InlineFormLabel htmlFor=\"data-source-picker\" width={'auto'}>\n            Data source\n          </InlineFormLabel>\n          <div className={styles.dataSourceRowItem}>\n            <DataSourcePicker\n              onChange={this.onChangeDataSource}\n              current={options.dataSource}\n              metrics={true}\n              mixed={true}\n              dashboard={true}\n              variables={true}\n            />\n          </div>\n          {dataSource && (\n            <>\n              <div className={styles.dataSourceRowItem}>\n                <Button\n                  variant=\"secondary\"\n                  icon=\"question-circle\"\n                  title=\"Open data source help\"\n                  onClick={this.onOpenHelp}\n                />\n              </div>\n              <div className={styles.dataSourceRowItemOptions}>\n                <QueryGroupOptionsEditor\n                  options={options}\n                  dataSource={dataSource}\n                  data={data}\n                  onChange={this.onUpdateAndRun}\n                />\n              </div>\n              {onOpenQueryInspector && (\n                <div className={styles.dataSourceRowItem}>\n                  <Button\n                    variant=\"secondary\"\n                    onClick={onOpenQueryInspector}\n                    aria-label={selectors.components.QueryTab.queryInspectorButton}\n                  >\n                    Query inspector\n                  </Button>\n                </div>\n              )}\n            </>\n          )}\n        </div>\n      </div>\n    );\n  }\n\n  onOpenHelp = () => {\n    this.setState({ isHelpOpen: true });\n  };\n\n  onCloseHelp = () => {\n    this.setState({ isHelpOpen: false });\n  };\n\n  renderMixedPicker = () => {\n    return (\n      <DataSourcePicker\n        mixed={false}\n        onChange={this.onAddMixedQuery}\n        current={null}\n        autoFocus={true}\n        variables={true}\n        onBlur={this.onMixedPickerBlur}\n        openMenuOnFocus={true}\n      />\n    );\n  };\n\n  onAddMixedQuery = (datasource: any) => {\n    this.onAddQuery({ datasource: datasource.name });\n    this.setState({ isAddingMixed: false });\n  };\n\n  onMixedPickerBlur = () => {\n    this.setState({ isAddingMixed: false });\n  };\n\n  onAddQuery = (query: Partial<DataQuery>) => {\n    const { dsSettings, queries } = this.state;\n    this.onQueriesChange(addQuery(queries, query, { type: dsSettings?.type, uid: dsSettings?.uid }));\n    this.onScrollBottom();\n  };\n\n  onQueriesChange = (queries: DataQuery[]) => {\n    this.onChange({ queries });\n    this.setState({ queries });\n  };\n\n  renderQueries(dsSettings: DataSourceInstanceSettings) {\n    const { onRunQueries } = this.props;\n    const { data, queries } = this.state;\n\n    if (isSharedDashboardQuery(dsSettings.name)) {\n      return (\n        <DashboardQueryEditor\n          queries={queries}\n          panelData={data}\n          onChange={this.onQueriesChange}\n          onRunQueries={onRunQueries}\n        />\n      );\n    }\n\n    return (\n      <div aria-label={selectors.components.QueryTab.content}>\n        <QueryEditorRows\n          queries={queries}\n          dsSettings={dsSettings}\n          onQueriesChange={this.onQueriesChange}\n          onAddQuery={this.onAddQuery}\n          onRunQueries={onRunQueries}\n          data={data}\n        />\n      </div>\n    );\n  }\n\n  isExpressionsSupported(dsSettings: DataSourceInstanceSettings): boolean {\n    return (dsSettings.meta.alerting || dsSettings.meta.mixed) === true;\n  }\n\n  renderExtraActions() {\n    return GroupActionComponents.getAllExtraRenderAction()\n      .map((action, index) =>\n        action({\n          onAddQuery: this.onAddQuery,\n          onChangeDataSource: this.onChangeDataSource,\n          key: index,\n        })\n      )\n      .filter(Boolean);\n  }\n\n  renderAddQueryRow(dsSettings: DataSourceInstanceSettings, styles: QueriesTabStyles) {\n    const { isAddingMixed } = this.state;\n    const showAddButton = !(isAddingMixed || isSharedDashboardQuery(dsSettings.name));\n\n    return (\n      <HorizontalGroup spacing=\"md\" align=\"flex-start\">\n        {showAddButton && (\n          <Button\n            icon=\"plus\"\n            onClick={this.onAddQueryClick}\n            variant=\"secondary\"\n            aria-label={selectors.components.QueryTab.addQuery}\n          >\n            Query\n          </Button>\n        )}\n        {config.expressionsEnabled && this.isExpressionsSupported(dsSettings) && (\n          <Button\n            icon=\"plus\"\n            onClick={this.onAddExpressionClick}\n            variant=\"secondary\"\n            className={styles.expressionButton}\n          >\n            <span>Expression&nbsp;</span>\n          </Button>\n        )}\n        {this.renderExtraActions()}\n      </HorizontalGroup>\n    );\n  }\n\n  setScrollRef = (scrollElement: HTMLDivElement): void => {\n    this.setState({ scrollElement });\n  };\n\n  render() {\n    const { isHelpOpen, dsSettings } = this.state;\n    const styles = getStyles();\n\n    return (\n      <CustomScrollbar autoHeightMin=\"100%\" scrollRefCallback={this.setScrollRef}>\n        <div className={styles.innerWrapper}>\n          {this.renderTopSection(styles)}\n          {dsSettings && (\n            <>\n              <div className={styles.queriesWrapper}>{this.renderQueries(dsSettings)}</div>\n              {this.renderAddQueryRow(dsSettings, styles)}\n              {isHelpOpen && (\n                <Modal title=\"Data source help\" isOpen={true} onDismiss={this.onCloseHelp}>\n                  <PluginHelp plugin={dsSettings.meta} type=\"query_help\" />\n                </Modal>\n              )}\n            </>\n          )}\n        </div>\n      </CustomScrollbar>\n    );\n  }\n}\n\nconst getStyles = stylesFactory(() => {\n  const { theme } = config;\n\n  return {\n    innerWrapper: css`\n      display: flex;\n      flex-direction: column;\n      padding: ${theme.spacing.md};\n    `,\n    dataSourceRow: css`\n      display: flex;\n      margin-bottom: ${theme.spacing.md};\n    `,\n    dataSourceRowItem: css`\n      margin-right: ${theme.spacing.inlineFormMargin};\n    `,\n    dataSourceRowItemOptions: css`\n      flex-grow: 1;\n      margin-right: ${theme.spacing.inlineFormMargin};\n    `,\n    queriesWrapper: css`\n      padding-bottom: 16px;\n    `,\n    expressionWrapper: css``,\n    expressionButton: css`\n      margin-right: ${theme.spacing.sm};\n    `,\n  };\n});\n\ntype QueriesTabStyles = ReturnType<typeof getStyles>;\n"], "fixing_code": ["package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/infra/fs\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/plugins/backendplugin\"\n\t\"github.com/grafana/grafana/pkg/plugins/repo\"\n\t\"github.com/grafana/grafana/pkg/plugins/storage\"\n\tac \"github.com/grafana/grafana/pkg/services/accesscontrol\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/services/featuremgmt\"\n\t\"github.com/grafana/grafana/pkg/services/org\"\n\t\"github.com/grafana/grafana/pkg/services/pluginsettings\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nfunc (hs *HTTPServer) GetPluginList(c *models.ReqContext) response.Response {\n\ttypeFilter := c.Query(\"type\")\n\tenabledFilter := c.Query(\"enabled\")\n\tembeddedFilter := c.Query(\"embedded\")\n\t// \"\" => no filter\n\t// \"0\" => filter out core plugins\n\t// \"1\" => filter out non-core plugins\n\tcoreFilter := c.Query(\"core\")\n\n\t// FIXME: while we don't have permissions for listing plugins we need this complex check:\n\t// When using access control, should be able to list non-core plugins:\n\t//  * anyone that can create a data source\n\t//  * anyone that can install a plugin\n\t// Fallback to only letting admins list non-core plugins\n\treqOrgAdmin := ac.ReqHasRole(org.RoleAdmin)\n\thasAccess := ac.HasAccess(hs.AccessControl, c)\n\tcanListNonCorePlugins := reqOrgAdmin(c) || hasAccess(reqOrgAdmin, ac.EvalAny(\n\t\tac.EvalPermission(datasources.ActionCreate),\n\t\tac.EvalPermission(plugins.ActionInstall),\n\t))\n\n\tpluginSettingsMap, err := hs.pluginSettings(c.Req.Context(), c.OrgID)\n\tif err != nil {\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to get list of plugins\", err)\n\t}\n\n\t// Filter plugins\n\tpluginDefinitions := hs.pluginStore.Plugins(c.Req.Context())\n\tfilteredPluginDefinitions := []plugins.PluginDTO{}\n\tfilteredPluginIDs := map[string]bool{}\n\tfor _, pluginDef := range pluginDefinitions {\n\t\t// filter out app sub plugins\n\t\tif embeddedFilter == \"0\" && pluginDef.IncludedInAppID != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out core plugins\n\t\tif (coreFilter == \"0\" && pluginDef.IsCorePlugin()) || (coreFilter == \"1\" && !pluginDef.IsCorePlugin()) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// FIXME: while we don't have permissions for listing plugins we need this complex check:\n\t\t// When using access control, should be able to list non-core plugins:\n\t\t//  * anyone that can create a data source\n\t\t//  * anyone that can install a plugin\n\t\t// Should be able to list this installed plugin:\n\t\t//  * anyone that can edit its settings\n\t\tif !pluginDef.IsCorePlugin() && !canListNonCorePlugins && !hasAccess(reqOrgAdmin,\n\t\t\tac.EvalPermission(plugins.ActionWrite, plugins.ScopeProvider.GetResourceScope(pluginDef.ID))) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter on type\n\t\tif typeFilter != \"\" && typeFilter != string(pluginDef.Type) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif pluginDef.State == plugins.AlphaRelease && !hs.Cfg.PluginsEnableAlpha {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out built in plugins\n\t\tif pluginDef.BuiltIn {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out disabled plugins\n\t\tif pluginSetting, exists := pluginSettingsMap[pluginDef.ID]; exists {\n\t\t\tif enabledFilter == \"1\" && !pluginSetting.Enabled {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif (pluginDef.ID == \"parca\" || pluginDef.ID == \"phlare\") && !hs.Features.IsEnabled(featuremgmt.FlagFlameGraph) {\n\t\t\tcontinue\n\t\t}\n\n\t\tfilteredPluginDefinitions = append(filteredPluginDefinitions, pluginDef)\n\t\tfilteredPluginIDs[pluginDef.ID] = true\n\t}\n\n\t// Compute metadata\n\tpluginsMetadata := hs.getMultiAccessControlMetadata(c, c.OrgID,\n\t\tplugins.ScopeProvider.GetResourceScope(\"\"), filteredPluginIDs)\n\n\t// Prepare DTO\n\tresult := make(dtos.PluginList, 0)\n\tfor _, pluginDef := range filteredPluginDefinitions {\n\t\tlistItem := dtos.PluginListItem{\n\t\t\tId:            pluginDef.ID,\n\t\t\tName:          pluginDef.Name,\n\t\t\tType:          string(pluginDef.Type),\n\t\t\tCategory:      pluginDef.Category,\n\t\t\tInfo:          pluginDef.Info,\n\t\t\tDependencies:  pluginDef.Dependencies,\n\t\t\tDefaultNavUrl: path.Join(hs.Cfg.AppSubURL, pluginDef.DefaultNavURL),\n\t\t\tState:         pluginDef.State,\n\t\t\tSignature:     pluginDef.Signature,\n\t\t\tSignatureType: pluginDef.SignatureType,\n\t\t\tSignatureOrg:  pluginDef.SignatureOrg,\n\t\t\tAccessControl: pluginsMetadata[pluginDef.ID],\n\t\t}\n\n\t\tupdate, exists := hs.pluginsUpdateChecker.HasUpdate(c.Req.Context(), pluginDef.ID)\n\t\tif exists {\n\t\t\tlistItem.LatestVersion = update\n\t\t\tlistItem.HasUpdate = true\n\t\t}\n\n\t\tif pluginSetting, exists := pluginSettingsMap[pluginDef.ID]; exists {\n\t\t\tlistItem.Enabled = pluginSetting.Enabled\n\t\t\tlistItem.Pinned = pluginSetting.Pinned\n\t\t}\n\n\t\tif listItem.DefaultNavUrl == \"\" || !listItem.Enabled {\n\t\t\tlistItem.DefaultNavUrl = hs.Cfg.AppSubURL + \"/plugins/\" + listItem.Id + \"/\"\n\t\t}\n\n\t\tresult = append(result, listItem)\n\t}\n\n\tsort.Sort(result)\n\treturn response.JSON(http.StatusOK, result)\n}\n\nfunc (hs *HTTPServer) GetPluginSettingByID(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(http.StatusNotFound, \"Plugin not found, no installed plugin with that id\", nil)\n\t}\n\n\t// In a first iteration, we only have one permission for app plugins.\n\t// We will need a different permission to allow users to configure the plugin without needing access to it.\n\tif plugin.IsApp() {\n\t\thasAccess := ac.HasAccess(hs.AccessControl, c)\n\t\tif !hasAccess(ac.ReqSignedIn,\n\t\t\tac.EvalPermission(plugins.ActionAppAccess, plugins.ScopeProvider.GetResourceScope(plugin.ID))) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Access Denied\", nil)\n\t\t}\n\t}\n\n\tdto := &dtos.PluginSetting{\n\t\tType:             string(plugin.Type),\n\t\tId:               plugin.ID,\n\t\tName:             plugin.Name,\n\t\tInfo:             plugin.Info,\n\t\tDependencies:     plugin.Dependencies,\n\t\tIncludes:         plugin.Includes,\n\t\tBaseUrl:          plugin.BaseURL,\n\t\tModule:           plugin.Module,\n\t\tDefaultNavUrl:    path.Join(hs.Cfg.AppSubURL, plugin.DefaultNavURL),\n\t\tState:            plugin.State,\n\t\tSignature:        plugin.Signature,\n\t\tSignatureType:    plugin.SignatureType,\n\t\tSignatureOrg:     plugin.SignatureOrg,\n\t\tSecureJsonFields: map[string]bool{},\n\t}\n\n\tif plugin.IsApp() {\n\t\tdto.Enabled = plugin.AutoEnabled\n\t\tdto.Pinned = plugin.AutoEnabled\n\t}\n\n\tps, err := hs.PluginSettings.GetPluginSettingByPluginID(c.Req.Context(), &pluginsettings.GetByPluginIDArgs{\n\t\tPluginID: pluginID,\n\t\tOrgID:    c.OrgID,\n\t})\n\tif err != nil {\n\t\tif !errors.Is(err, models.ErrPluginSettingNotFound) {\n\t\t\treturn response.Error(http.StatusInternalServerError, \"Failed to get plugin settings\", nil)\n\t\t}\n\t} else {\n\t\tdto.Enabled = ps.Enabled\n\t\tdto.Pinned = ps.Pinned\n\t\tdto.JsonData = ps.JSONData\n\n\t\tfor k, v := range hs.PluginSettings.DecryptedValues(ps) {\n\t\t\tif len(v) > 0 {\n\t\t\t\tdto.SecureJsonFields[k] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate, exists := hs.pluginsUpdateChecker.HasUpdate(c.Req.Context(), plugin.ID)\n\tif exists {\n\t\tdto.LatestVersion = update\n\t\tdto.HasUpdate = true\n\t}\n\n\treturn response.JSON(http.StatusOK, dto)\n}\n\nfunc (hs *HTTPServer) UpdatePluginSetting(c *models.ReqContext) response.Response {\n\tcmd := models.UpdatePluginSettingCmd{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tif _, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID); !exists {\n\t\treturn response.Error(404, \"Plugin not installed\", nil)\n\t}\n\n\tcmd.OrgId = c.OrgID\n\tcmd.PluginId = pluginID\n\tif err := hs.PluginSettings.UpdatePluginSetting(c.Req.Context(), &pluginsettings.UpdateArgs{\n\t\tEnabled:                 cmd.Enabled,\n\t\tPinned:                  cmd.Pinned,\n\t\tJSONData:                cmd.JsonData,\n\t\tSecureJSONData:          cmd.SecureJsonData,\n\t\tPluginVersion:           cmd.PluginVersion,\n\t\tPluginID:                cmd.PluginId,\n\t\tOrgID:                   cmd.OrgId,\n\t\tEncryptedSecureJSONData: cmd.EncryptedSecureJsonData,\n\t}); err != nil {\n\t\treturn response.Error(500, \"Failed to update plugin setting\", err)\n\t}\n\n\treturn response.Success(\"Plugin settings updated\")\n}\n\nfunc (hs *HTTPServer) GetPluginMarkdown(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tname := web.Params(c.Req)[\":name\"]\n\n\tcontent, err := hs.pluginMarkdown(c.Req.Context(), pluginID, name)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Could not get markdown file\", err)\n\t}\n\n\t// fallback try readme\n\tif len(content) == 0 {\n\t\tcontent, err = hs.pluginMarkdown(c.Req.Context(), pluginID, \"readme\")\n\t\tif err != nil {\n\t\t\treturn response.Error(501, \"Could not get markdown file\", err)\n\t\t}\n\t}\n\n\tresp := response.Respond(http.StatusOK, content)\n\tresp.SetHeader(\"Content-Type\", \"text/plain; charset=utf-8\")\n\treturn resp\n}\n\n// CollectPluginMetrics collect metrics from a plugin.\n//\n// /api/plugins/:pluginId/metrics\nfunc (hs *HTTPServer) CollectPluginMetrics(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tresp, err := hs.pluginClient.CollectMetrics(c.Req.Context(), &backend.CollectMetricsRequest{PluginContext: backend.PluginContext{PluginID: pluginID}})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\theaders := make(http.Header)\n\theaders.Set(\"Content-Type\", \"text/plain\")\n\n\treturn response.CreateNormalResponse(headers, resp.PrometheusMetrics, http.StatusOK)\n}\n\n// getPluginAssets returns public plugin assets (images, JS, etc.)\n//\n// /public/plugins/:pluginId/*\nfunc (hs *HTTPServer) getPluginAssets(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\t// prepend slash for cleaning relative paths\n\trequestedFile := filepath.Clean(filepath.Join(\"/\", web.Params(c.Req)[\"*\"]))\n\trel, err := filepath.Rel(\"/\", requestedFile)\n\tif err != nil {\n\t\t// slash is prepended above therefore this is not expected to fail\n\t\tc.JsonApiErr(500, \"Failed to get the relative path\", err)\n\t\treturn\n\t}\n\n\tif !plugin.IncludedInSignature(rel) {\n\t\ths.log.Warn(\"Access to requested plugin file will be forbidden in upcoming Grafana versions as the file \"+\n\t\t\t\"is not included in the plugin signature\", \"file\", requestedFile)\n\t}\n\n\tabsPluginDir, err := filepath.Abs(plugin.PluginDir)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin absolute path\", nil)\n\t\treturn\n\t}\n\n\tpluginFilePath := filepath.Join(absPluginDir, rel)\n\n\t// It's safe to ignore gosec warning G304 since we already clean the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\t// nolint:gosec\n\tf, err := os.Open(pluginFilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tc.JsonApiErr(404, \"Plugin file not found\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(500, \"Could not open plugin file\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err := f.Close(); err != nil {\n\t\t\ths.log.Error(\"Failed to close file\", \"err\", err)\n\t\t}\n\t}()\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Plugin file exists but could not open\", err)\n\t\treturn\n\t}\n\n\tif hs.Cfg.Env == setting.Dev {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"max-age=0, must-revalidate, no-cache\")\n\t} else {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"public, max-age=3600\")\n\t}\n\n\thttp.ServeContent(c.Resp, c.Req, pluginFilePath, fi.ModTime(), f)\n}\n\n// CheckHealth returns the health of a plugin.\n// /api/plugins/:pluginId/health\nfunc (hs *HTTPServer) CheckHealth(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, c.SignedInUser)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get plugin settings\", err)\n\t}\n\tif !found {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CheckHealth(c.Req.Context(), &backend.CheckHealthRequest{\n\t\tPluginContext: pCtx,\n\t\tHeaders:       map[string]string{},\n\t})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\tpayload := map[string]interface{}{\n\t\t\"status\":  resp.Status.String(),\n\t\t\"message\": resp.Message,\n\t}\n\n\t// Unmarshal JSONDetails if it's not empty.\n\tif len(resp.JSONDetails) > 0 {\n\t\tvar jsonDetails map[string]interface{}\n\t\terr = json.Unmarshal(resp.JSONDetails, &jsonDetails)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to unmarshal detailed response from backend plugin\", err)\n\t\t}\n\n\t\tpayload[\"details\"] = jsonDetails\n\t}\n\n\tif resp.Status != backend.HealthStatusOk {\n\t\treturn response.JSON(503, payload)\n\t}\n\n\treturn response.JSON(http.StatusOK, payload)\n}\n\nfunc (hs *HTTPServer) GetPluginErrorsList(_ *models.ReqContext) response.Response {\n\treturn response.JSON(http.StatusOK, hs.pluginErrorResolver.PluginErrors())\n}\n\nfunc (hs *HTTPServer) InstallPlugin(c *models.ReqContext) response.Response {\n\tdto := dtos.InstallPluginCommand{}\n\tif err := web.Bind(c.Req, &dto); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginInstaller.Add(c.Req.Context(), pluginID, dto.Version, plugins.CompatOpts{\n\t\tGrafanaVersion: hs.Cfg.BuildVersion,\n\t\tOS:             runtime.GOOS,\n\t\tArch:           runtime.GOARCH,\n\t})\n\tif err != nil {\n\t\tvar dupeErr plugins.DuplicateError\n\t\tif errors.As(err, &dupeErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin already installed\", err)\n\t\t}\n\t\tvar versionUnsupportedErr repo.ErrVersionUnsupported\n\t\tif errors.As(err, &versionUnsupportedErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin version not supported\", err)\n\t\t}\n\t\tvar versionNotFoundErr repo.ErrVersionNotFound\n\t\tif errors.As(err, &versionNotFoundErr) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin version not found\", err)\n\t\t}\n\t\tvar clientError repo.Response4xxError\n\t\tif errors.As(err, &clientError) {\n\t\t\treturn response.Error(clientError.StatusCode, clientError.Message, err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrInstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot install or change a Core plugin\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to install plugin\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc (hs *HTTPServer) UninstallPlugin(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginInstaller.Remove(c.Req.Context(), pluginID)\n\tif err != nil {\n\t\tif errors.Is(err, plugins.ErrPluginNotInstalled) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin not installed\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a Core plugin\", err)\n\t\t}\n\t\tif errors.Is(err, storage.ErrUninstallOutsideOfPluginDir) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a plugin outside of the plugins directory\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to uninstall plugin\", err)\n\t}\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc translatePluginRequestErrorToAPIError(err error) response.Response {\n\tif errors.Is(err, backendplugin.ErrPluginNotRegistered) {\n\t\treturn response.Error(404, \"Plugin not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treturn response.Error(404, \"Not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrHealthCheckFailed) {\n\t\treturn response.Error(500, \"Plugin health check failed\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treturn response.Error(503, \"Plugin unavailable\", err)\n\t}\n\n\treturn response.Error(500, \"Plugin request failed\", err)\n}\n\nfunc (hs *HTTPServer) pluginMarkdown(ctx context.Context, pluginId string, name string) ([]byte, error) {\n\tplugin, exists := hs.pluginStore.Plugin(ctx, pluginId)\n\tif !exists {\n\t\treturn nil, plugins.NotFoundError{PluginID: pluginId}\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning since we have cleaned the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\tpath := filepath.Join(plugin.PluginDir, mdFilepath(strings.ToUpper(name)))\n\texists, err := fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\tpath = filepath.Join(plugin.PluginDir, mdFilepath(strings.ToLower(name)))\n\t}\n\n\texists, err = fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn make([]byte, 0), nil\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning since we have cleaned the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n\nfunc mdFilepath(mdFilename string) string {\n\treturn filepath.Clean(filepath.Join(\"/\", fmt.Sprintf(\"%s.md\", mdFilename)))\n}\n", "import React from 'react';\nimport { useAsync } from 'react-use';\n\nimport { renderMarkdown } from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { LoadingPlaceholder } from '@grafana/ui';\n\ninterface Props {\n  pluginId: string;\n}\n\nexport function PluginHelp({ pluginId }: Props) {\n  const { value, loading, error } = useAsync(async () => {\n    return getBackendSrv().get(`/api/plugins/${pluginId}/markdown/query_help`);\n  }, []);\n\n  const renderedMarkdown = renderMarkdown(value);\n\n  if (loading) {\n    return <LoadingPlaceholder text=\"Loading help...\" />;\n  }\n\n  if (error) {\n    return <h3>An error occurred when loading help.</h3>;\n  }\n\n  if (value === '') {\n    return <h3>No query help could be found.</h3>;\n  }\n\n  return <div className=\"markdown-html\" dangerouslySetInnerHTML={{ __html: renderedMarkdown }} />;\n}\n", "import { css } from '@emotion/css';\nimport React, { PureComponent } from 'react';\nimport { Unsubscribable } from 'rxjs';\n\nimport {\n  CoreApp,\n  DataQuery,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  getDefaultTimeRange,\n  LoadingState,\n  PanelData,\n} from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { DataSourcePicker, getDataSourceSrv } from '@grafana/runtime';\nimport { Button, CustomScrollbar, HorizontalGroup, InlineFormLabel, Modal, stylesFactory } from '@grafana/ui';\nimport { PluginHelp } from 'app/core/components/PluginHelp/PluginHelp';\nimport config from 'app/core/config';\nimport { backendSrv } from 'app/core/services/backend_srv';\nimport { addQuery, queryIsEmpty } from 'app/core/utils/query';\nimport { dataSource as expressionDatasource } from 'app/features/expressions/ExpressionDatasource';\nimport { DashboardQueryEditor, isSharedDashboardQuery } from 'app/plugins/datasource/dashboard';\nimport { QueryGroupOptions } from 'app/types';\n\nimport { PanelQueryRunner } from '../state/PanelQueryRunner';\nimport { updateQueries } from '../state/updateQueries';\n\nimport { GroupActionComponents } from './QueryActionComponent';\nimport { QueryEditorRows } from './QueryEditorRows';\nimport { QueryGroupOptionsEditor } from './QueryGroupOptions';\n\ninterface Props {\n  queryRunner: PanelQueryRunner;\n  options: QueryGroupOptions;\n  onOpenQueryInspector?: () => void;\n  onRunQueries: () => void;\n  onOptionsChange: (options: QueryGroupOptions) => void;\n}\n\ninterface State {\n  dataSource?: DataSourceApi;\n  dsSettings?: DataSourceInstanceSettings;\n  queries: DataQuery[];\n  helpContent: React.ReactNode;\n  isLoadingHelp: boolean;\n  isPickerOpen: boolean;\n  isAddingMixed: boolean;\n  data: PanelData;\n  isHelpOpen: boolean;\n  defaultDataSource?: DataSourceApi;\n  scrollElement?: HTMLDivElement;\n}\n\nexport class QueryGroup extends PureComponent<Props, State> {\n  backendSrv = backendSrv;\n  dataSourceSrv = getDataSourceSrv();\n  querySubscription: Unsubscribable | null = null;\n\n  state: State = {\n    isLoadingHelp: false,\n    helpContent: null,\n    isPickerOpen: false,\n    isAddingMixed: false,\n    isHelpOpen: false,\n    queries: [],\n    data: {\n      state: LoadingState.NotStarted,\n      series: [],\n      timeRange: getDefaultTimeRange(),\n    },\n  };\n\n  async componentDidMount() {\n    const { queryRunner, options } = this.props;\n\n    this.querySubscription = queryRunner.getData({ withTransforms: false, withFieldConfig: false }).subscribe({\n      next: (data: PanelData) => this.onPanelDataUpdate(data),\n    });\n\n    try {\n      const ds = await this.dataSourceSrv.get(options.dataSource);\n      const dsSettings = this.dataSourceSrv.getInstanceSettings(options.dataSource);\n      const defaultDataSource = await this.dataSourceSrv.get();\n      const datasource = ds.getRef();\n      const queries = options.queries.map((q) => ({\n        ...(queryIsEmpty(q) && ds?.getDefaultQuery?.(CoreApp.PanelEditor)),\n        datasource,\n        ...q,\n      }));\n      this.setState({ queries, dataSource: ds, dsSettings, defaultDataSource });\n    } catch (error) {\n      console.log('failed to load data source', error);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.querySubscription) {\n      this.querySubscription.unsubscribe();\n      this.querySubscription = null;\n    }\n  }\n\n  onPanelDataUpdate(data: PanelData) {\n    this.setState({ data });\n  }\n\n  onChangeDataSource = async (newSettings: DataSourceInstanceSettings) => {\n    const { dsSettings } = this.state;\n    const currentDS = dsSettings ? await getDataSourceSrv().get(dsSettings.uid) : undefined;\n    const nextDS = await getDataSourceSrv().get(newSettings.uid);\n\n    // We need to pass in newSettings.uid as well here as that can be a variable expression and we want to store that in the query model not the current ds variable value\n    const queries = await updateQueries(nextDS, newSettings.uid, this.state.queries, currentDS);\n\n    const dataSource = await this.dataSourceSrv.get(newSettings.name);\n    this.onChange({\n      queries,\n      dataSource: {\n        name: newSettings.name,\n        uid: newSettings.uid,\n        type: newSettings.meta.id,\n        default: newSettings.isDefault,\n      },\n    });\n\n    this.setState({\n      queries,\n      dataSource: dataSource,\n      dsSettings: newSettings,\n    });\n  };\n\n  onAddQueryClick = () => {\n    const { queries } = this.state;\n    this.onQueriesChange(addQuery(queries, this.newQuery()));\n    this.onScrollBottom();\n  };\n\n  newQuery(): Partial<DataQuery> {\n    const { dsSettings, defaultDataSource } = this.state;\n\n    const ds = !dsSettings?.meta.mixed ? dsSettings : defaultDataSource;\n\n    return {\n      ...this.state.dataSource?.getDefaultQuery?.(CoreApp.PanelEditor),\n      datasource: { uid: ds?.uid, type: ds?.type },\n    };\n  }\n\n  onChange(changedProps: Partial<QueryGroupOptions>) {\n    this.props.onOptionsChange({\n      ...this.props.options,\n      ...changedProps,\n    });\n  }\n\n  onAddExpressionClick = () => {\n    this.onQueriesChange(addQuery(this.state.queries, expressionDatasource.newQuery()));\n    this.onScrollBottom();\n  };\n\n  onScrollBottom = () => {\n    setTimeout(() => {\n      if (this.state.scrollElement) {\n        this.state.scrollElement.scrollTo({ top: 10000 });\n      }\n    }, 20);\n  };\n\n  onUpdateAndRun = (options: QueryGroupOptions) => {\n    this.props.onOptionsChange(options);\n    this.props.onRunQueries();\n  };\n\n  renderTopSection(styles: QueriesTabStyles) {\n    const { onOpenQueryInspector, options } = this.props;\n    const { dataSource, data } = this.state;\n\n    return (\n      <div>\n        <div className={styles.dataSourceRow}>\n          <InlineFormLabel htmlFor=\"data-source-picker\" width={'auto'}>\n            Data source\n          </InlineFormLabel>\n          <div className={styles.dataSourceRowItem}>\n            <DataSourcePicker\n              onChange={this.onChangeDataSource}\n              current={options.dataSource}\n              metrics={true}\n              mixed={true}\n              dashboard={true}\n              variables={true}\n            />\n          </div>\n          {dataSource && (\n            <>\n              <div className={styles.dataSourceRowItem}>\n                <Button\n                  variant=\"secondary\"\n                  icon=\"question-circle\"\n                  title=\"Open data source help\"\n                  onClick={this.onOpenHelp}\n                />\n              </div>\n              <div className={styles.dataSourceRowItemOptions}>\n                <QueryGroupOptionsEditor\n                  options={options}\n                  dataSource={dataSource}\n                  data={data}\n                  onChange={this.onUpdateAndRun}\n                />\n              </div>\n              {onOpenQueryInspector && (\n                <div className={styles.dataSourceRowItem}>\n                  <Button\n                    variant=\"secondary\"\n                    onClick={onOpenQueryInspector}\n                    aria-label={selectors.components.QueryTab.queryInspectorButton}\n                  >\n                    Query inspector\n                  </Button>\n                </div>\n              )}\n            </>\n          )}\n        </div>\n      </div>\n    );\n  }\n\n  onOpenHelp = () => {\n    this.setState({ isHelpOpen: true });\n  };\n\n  onCloseHelp = () => {\n    this.setState({ isHelpOpen: false });\n  };\n\n  renderMixedPicker = () => {\n    return (\n      <DataSourcePicker\n        mixed={false}\n        onChange={this.onAddMixedQuery}\n        current={null}\n        autoFocus={true}\n        variables={true}\n        onBlur={this.onMixedPickerBlur}\n        openMenuOnFocus={true}\n      />\n    );\n  };\n\n  onAddMixedQuery = (datasource: any) => {\n    this.onAddQuery({ datasource: datasource.name });\n    this.setState({ isAddingMixed: false });\n  };\n\n  onMixedPickerBlur = () => {\n    this.setState({ isAddingMixed: false });\n  };\n\n  onAddQuery = (query: Partial<DataQuery>) => {\n    const { dsSettings, queries } = this.state;\n    this.onQueriesChange(addQuery(queries, query, { type: dsSettings?.type, uid: dsSettings?.uid }));\n    this.onScrollBottom();\n  };\n\n  onQueriesChange = (queries: DataQuery[]) => {\n    this.onChange({ queries });\n    this.setState({ queries });\n  };\n\n  renderQueries(dsSettings: DataSourceInstanceSettings) {\n    const { onRunQueries } = this.props;\n    const { data, queries } = this.state;\n\n    if (isSharedDashboardQuery(dsSettings.name)) {\n      return (\n        <DashboardQueryEditor\n          queries={queries}\n          panelData={data}\n          onChange={this.onQueriesChange}\n          onRunQueries={onRunQueries}\n        />\n      );\n    }\n\n    return (\n      <div aria-label={selectors.components.QueryTab.content}>\n        <QueryEditorRows\n          queries={queries}\n          dsSettings={dsSettings}\n          onQueriesChange={this.onQueriesChange}\n          onAddQuery={this.onAddQuery}\n          onRunQueries={onRunQueries}\n          data={data}\n        />\n      </div>\n    );\n  }\n\n  isExpressionsSupported(dsSettings: DataSourceInstanceSettings): boolean {\n    return (dsSettings.meta.alerting || dsSettings.meta.mixed) === true;\n  }\n\n  renderExtraActions() {\n    return GroupActionComponents.getAllExtraRenderAction()\n      .map((action, index) =>\n        action({\n          onAddQuery: this.onAddQuery,\n          onChangeDataSource: this.onChangeDataSource,\n          key: index,\n        })\n      )\n      .filter(Boolean);\n  }\n\n  renderAddQueryRow(dsSettings: DataSourceInstanceSettings, styles: QueriesTabStyles) {\n    const { isAddingMixed } = this.state;\n    const showAddButton = !(isAddingMixed || isSharedDashboardQuery(dsSettings.name));\n\n    return (\n      <HorizontalGroup spacing=\"md\" align=\"flex-start\">\n        {showAddButton && (\n          <Button\n            icon=\"plus\"\n            onClick={this.onAddQueryClick}\n            variant=\"secondary\"\n            aria-label={selectors.components.QueryTab.addQuery}\n          >\n            Query\n          </Button>\n        )}\n        {config.expressionsEnabled && this.isExpressionsSupported(dsSettings) && (\n          <Button\n            icon=\"plus\"\n            onClick={this.onAddExpressionClick}\n            variant=\"secondary\"\n            className={styles.expressionButton}\n          >\n            <span>Expression&nbsp;</span>\n          </Button>\n        )}\n        {this.renderExtraActions()}\n      </HorizontalGroup>\n    );\n  }\n\n  setScrollRef = (scrollElement: HTMLDivElement): void => {\n    this.setState({ scrollElement });\n  };\n\n  render() {\n    const { isHelpOpen, dsSettings } = this.state;\n    const styles = getStyles();\n\n    return (\n      <CustomScrollbar autoHeightMin=\"100%\" scrollRefCallback={this.setScrollRef}>\n        <div className={styles.innerWrapper}>\n          {this.renderTopSection(styles)}\n          {dsSettings && (\n            <>\n              <div className={styles.queriesWrapper}>{this.renderQueries(dsSettings)}</div>\n              {this.renderAddQueryRow(dsSettings, styles)}\n              {isHelpOpen && (\n                <Modal title=\"Data source help\" isOpen={true} onDismiss={this.onCloseHelp}>\n                  <PluginHelp pluginId={dsSettings.meta.id} />\n                </Modal>\n              )}\n            </>\n          )}\n        </div>\n      </CustomScrollbar>\n    );\n  }\n}\n\nconst getStyles = stylesFactory(() => {\n  const { theme } = config;\n\n  return {\n    innerWrapper: css`\n      display: flex;\n      flex-direction: column;\n      padding: ${theme.spacing.md};\n    `,\n    dataSourceRow: css`\n      display: flex;\n      margin-bottom: ${theme.spacing.md};\n    `,\n    dataSourceRowItem: css`\n      margin-right: ${theme.spacing.inlineFormMargin};\n    `,\n    dataSourceRowItemOptions: css`\n      flex-grow: 1;\n      margin-right: ${theme.spacing.inlineFormMargin};\n    `,\n    queriesWrapper: css`\n      padding-bottom: 16px;\n    `,\n    expressionWrapper: css``,\n    expressionButton: css`\n      margin-right: ${theme.spacing.sm};\n    `,\n  };\n});\n\ntype QueriesTabStyles = ReturnType<typeof getStyles>;\n"], "filenames": ["pkg/api/plugins.go", "public/app/core/components/PluginHelp/PluginHelp.tsx", "public/app/features/query/components/QueryGroup.tsx"], "buggy_code_start_loc": [273, 1, 367], "buggy_code_end_loc": [274, 83, 368], "fixing_code_start_loc": [273, 1, 367], "fixing_code_end_loc": [274, 32, 368], "type": "CWE-79", "message": "Grafana is an open-source platform for monitoring and observability. On 2023-01-01 during an internal audit of Grafana, a member of the security team found a stored XSS vulnerability affecting the core plugin \"Text\". The stored XSS vulnerability requires several user interactions in order to be fully exploited. The vulnerability was possible due to React's render cycle that will pass though the unsanitized HTML code, but in the next cycle the HTML is cleaned up and saved in Grafana's database. An attacker needs to have the Editor role in order to change a Text panel to include JavaScript. Another user needs to edit the same Text panel, and click on \"Markdown\" or \"HTML\" for the code to be executed. This means that vertical privilege escalation is possible, where a user with Editor role can change to a known password for a user having Admin role if the user with Admin role executes malicious JavaScript viewing a dashboard. This issue has been patched in versions 9.2.10 and 9.3.4.", "other": {"cve": {"id": "CVE-2023-22462", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-02T01:15:11.727", "lastModified": "2023-04-13T17:15:12.857", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Grafana is an open-source platform for monitoring and observability. On 2023-01-01 during an internal audit of Grafana, a member of the security team found a stored XSS vulnerability affecting the core plugin \"Text\". The stored XSS vulnerability requires several user interactions in order to be fully exploited. The vulnerability was possible due to React's render cycle that will pass though the unsanitized HTML code, but in the next cycle the HTML is cleaned up and saved in Grafana's database. An attacker needs to have the Editor role in order to change a Text panel to include JavaScript. Another user needs to edit the same Text panel, and click on \"Markdown\" or \"HTML\" for the code to be executed. This means that vertical privilege escalation is possible, where a user with Editor role can change to a known password for a user having Admin role if the user with Admin role executes malicious JavaScript viewing a dashboard. This issue has been patched in versions 9.2.10 and 9.3.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.2.0", "versionEndExcluding": "9.2.10", "matchCriteriaId": "2145D69A-D240-4E87-80F1-08AC1F4E5DF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.3.0", "versionEndExcluding": "9.3.4", "matchCriteriaId": "E8642012-7942-4810-8DB0-1894D3BF4662"}]}]}], "references": [{"url": "https://github.com/grafana/grafana/commit/db83d5f398caffe35c5846cfa7727d1a2a414165", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/grafana/grafana/security/advisories/GHSA-7rqg-hjwc-6mjf", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://grafana.com/blog/2023/02/28/grafana-security-release-new-versions-with-security-fixes-for-cve-2023-0594-cve-2023-0507-and-cve-2023-22462/", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230413-0004/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/grafana/grafana/commit/db83d5f398caffe35c5846cfa7727d1a2a414165"}}