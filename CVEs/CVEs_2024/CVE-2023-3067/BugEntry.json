{"buggy_code": ["\"use strict\";\n\nconst normalizeString = require(\"normalize-strings\");\nconst lex = require('./lex');\nconst handleParens = require('./handle_parens');\nconst parse = require('./parse');\nconst SearchResult = require(\"../search_result\");\nconst SearchContext = require(\"../search_context\");\nconst becca = require('../../../becca/becca');\nconst beccaService = require('../../../becca/becca_service');\nconst utils = require('../../utils');\nconst log = require('../../log');\nconst scriptService = require(\"../../script\");\nconst hoistedNoteService = require(\"../../hoisted_note\");\n\nfunction searchFromNote(note) {\n    let searchResultNoteIds, highlightedTokens;\n\n    const searchScript = note.getRelationValue('searchScript');\n    const searchString = note.getLabelValue('searchString');\n    let error = null;\n\n    if (searchScript) {\n        searchResultNoteIds = searchFromRelation(note, 'searchScript');\n        highlightedTokens = [];\n    } else {\n        const searchContext = new SearchContext({\n            fastSearch: note.hasLabel('fastSearch'),\n            ancestorNoteId: note.getRelationValue('ancestor'),\n            ancestorDepth: note.getLabelValue('ancestorDepth'),\n            includeArchivedNotes: note.hasLabel('includeArchivedNotes'),\n            orderBy: note.getLabelValue('orderBy'),\n            orderDirection: note.getLabelValue('orderDirection'),\n            limit: note.getLabelValue('limit'),\n            debug: note.hasLabel('debug'),\n            fuzzyAttributeSearch: false\n        });\n\n        searchResultNoteIds = findResultsWithQuery(searchString, searchContext)\n            .map(sr => sr.noteId);\n\n        highlightedTokens = searchContext.highlightedTokens;\n        error = searchContext.getError();\n    }\n\n    // we won't return search note's own noteId\n    // also don't allow root since that would force infinite cycle\n    return {\n        searchResultNoteIds: searchResultNoteIds.filter(resultNoteId => !['root', note.noteId].includes(resultNoteId)),\n        highlightedTokens,\n        error: error\n    };\n}\n\nfunction searchFromRelation(note, relationName) {\n    const scriptNote = note.getRelationTarget(relationName);\n\n    if (!scriptNote) {\n        log.info(`Search note's relation ${relationName} has not been found.`);\n\n        return [];\n    }\n\n    if (!scriptNote.isJavaScript() || scriptNote.getScriptEnv() !== 'backend') {\n        log.info(`Note ${scriptNote.noteId} is not executable.`);\n\n        return [];\n    }\n\n    if (!note.isContentAvailable()) {\n        log.info(`Note ${scriptNote.noteId} is not available outside of protected session.`);\n\n        return [];\n    }\n\n    const result = scriptService.executeNote(scriptNote, { originEntity: note });\n\n    if (!Array.isArray(result)) {\n        log.info(`Result from ${scriptNote.noteId} is not an array.`);\n\n        return [];\n    }\n\n    if (result.length === 0) {\n        return [];\n    }\n\n    // we expect either array of noteIds (strings) or notes, in that case we extract noteIds ourselves\n    return typeof result[0] === 'string' ? result : result.map(item => item.noteId);\n}\n\nfunction loadNeededInfoFromDatabase() {\n    const sql = require('../../sql');\n\n    for (const noteId in becca.notes) {\n        becca.notes[noteId].contentSize = 0;\n        becca.notes[noteId].noteSize = 0;\n        becca.notes[noteId].revisionCount = 0;\n    }\n\n    const noteContentLengths = sql.getRows(`\n        SELECT \n            noteId, \n            LENGTH(content) AS length \n        FROM notes\n             JOIN note_contents USING(noteId) \n        WHERE notes.isDeleted = 0`);\n\n    for (const {noteId, length} of noteContentLengths) {\n        if (!(noteId in becca.notes)) {\n            log.error(`Note ${noteId} not found in becca.`);\n            continue;\n        }\n\n        becca.notes[noteId].contentSize = length;\n        becca.notes[noteId].noteSize = length;\n    }\n\n    const noteRevisionContentLengths = sql.getRows(`\n        SELECT \n            noteId, \n            LENGTH(content) AS length \n        FROM notes\n             JOIN note_revisions USING(noteId) \n             JOIN note_revision_contents USING(noteRevisionId) \n        WHERE notes.isDeleted = 0`);\n\n    for (const {noteId, length} of noteRevisionContentLengths) {\n        if (!(noteId in becca.notes)) {\n            log.error(`Note ${noteId} not found in becca.`);\n            continue;\n        }\n\n        becca.notes[noteId].noteSize += length;\n        becca.notes[noteId].revisionCount++;\n    }\n}\n\n/**\n * @param {Expression} expression\n * @param {SearchContext} searchContext\n * @returns {SearchResult[]}\n */\nfunction findResultsWithExpression(expression, searchContext) {\n    if (searchContext.dbLoadNeeded) {\n        loadNeededInfoFromDatabase();\n    }\n\n    const allNoteSet = becca.getAllNoteSet();\n\n    const executionContext = {\n        noteIdToNotePath: {}\n    };\n\n    const noteSet = expression.execute(allNoteSet, executionContext, searchContext);\n\n    const searchResults = noteSet.notes\n        .filter(note => !note.isDeleted)\n        .map(note => {\n            const notePathArray = executionContext.noteIdToNotePath[note.noteId] || beccaService.getSomePath(note);\n\n            if (!notePathArray) {\n                throw new Error(`Can't find note path for note ${JSON.stringify(note.getPojo())}`);\n            }\n\n            return new SearchResult(notePathArray);\n        });\n\n    for (const res of searchResults) {\n        res.computeScore(searchContext.fulltextQuery, searchContext.highlightedTokens);\n    }\n\n    if (!noteSet.sorted) {\n        searchResults.sort((a, b) => {\n            if (a.score > b.score) {\n                return -1;\n            } else if (a.score < b.score) {\n                return 1;\n            }\n\n            // if score does not decide then sort results by depth of the note.\n            // This is based on the assumption that more important results are closer to the note root.\n            if (a.notePathArray.length === b.notePathArray.length) {\n                return a.notePathTitle < b.notePathTitle ? -1 : 1;\n            }\n\n            return a.notePathArray.length < b.notePathArray.length ? -1 : 1;\n        });\n    }\n\n    return searchResults;\n}\n\nfunction parseQueryToExpression(query, searchContext) {\n    const {fulltextQuery, fulltextTokens, expressionTokens} = lex(query);\n    searchContext.fulltextQuery = fulltextQuery;\n\n    let structuredExpressionTokens;\n\n    try {\n        structuredExpressionTokens = handleParens(expressionTokens);\n    }\n    catch (e) {\n        structuredExpressionTokens = [];\n        searchContext.addError(e.message);\n    }\n\n    const expression = parse({\n        fulltextTokens,\n        expressionTokens: structuredExpressionTokens,\n        searchContext,\n        originalQuery: query\n    });\n\n    if (searchContext.debug) {\n        searchContext.debugInfo = {\n            fulltextTokens,\n            structuredExpressionTokens,\n            expression\n        };\n\n        log.info(`Search debug: ${JSON.stringify(searchContext.debugInfo, null, 4)}`);\n    }\n\n    return expression;\n}\n\n/**\n * @param {string} query\n * @param {object} params - see SearchContext\n * @returns {BNote[]}\n */\nfunction searchNotes(query, params = {}) {\n    const searchResults = findResultsWithQuery(query, new SearchContext(params));\n\n    return searchResults.map(sr => becca.notes[sr.noteId]);\n}\n\n/**\n * @param {string} query\n * @param {SearchContext} searchContext\n * @returns {SearchResult[]}\n */\nfunction findResultsWithQuery(query, searchContext) {\n    query = query || \"\";\n    searchContext.originalQuery = query;\n\n    const expression = parseQueryToExpression(query, searchContext);\n\n    if (!expression) {\n        return [];\n    }\n\n    return findResultsWithExpression(expression, searchContext);\n}\n\n/**\n * @param {string} query\n * @param {SearchContext} searchContext\n * @returns {BNote|null}\n */\nfunction findFirstNoteWithQuery(query, searchContext) {\n    const searchResults = findResultsWithQuery(query, searchContext);\n\n    return searchResults.length > 0 ? becca.notes[searchResults[0].noteId] : null;\n}\n\nfunction searchNotesForAutocomplete(query) {\n    const searchContext = new SearchContext({\n        fastSearch: true,\n        includeArchivedNotes: false,\n        includeHiddenNotes: true,\n        fuzzyAttributeSearch: true,\n        ancestorNoteId: hoistedNoteService.isHoistedInHiddenSubtree()\n            ? 'root'\n            : hoistedNoteService.getHoistedNoteId()\n    });\n\n    const allSearchResults = findResultsWithQuery(query, searchContext);\n\n    const trimmed = allSearchResults.slice(0, 200);\n\n    highlightSearchResults(trimmed, searchContext.highlightedTokens);\n\n    return trimmed.map(result => {\n        return {\n            notePath: result.notePath,\n            noteTitle: beccaService.getNoteTitle(result.noteId),\n            notePathTitle: result.notePathTitle,\n            highlightedNotePathTitle: result.highlightedNotePathTitle\n        }\n    });\n}\n\nfunction highlightSearchResults(searchResults, highlightedTokens) {\n    highlightedTokens = Array.from(new Set(highlightedTokens));\n\n    // we remove < signs because they can cause trouble in matching and overwriting existing highlighted chunks\n    // which would make the resulting HTML string invalid.\n    // { and } are used for marking <b> and </b> tag (to avoid matches on single 'b' character)\n    // < and > are used for marking <small> and </small>\n    highlightedTokens = highlightedTokens.map(token => token.replace('/[<\\{\\}]/g', ''));\n\n    // sort by the longest, so we first highlight the longest matches\n    highlightedTokens.sort((a, b) => a.length > b.length ? -1 : 1);\n\n    for (const result of searchResults) {\n        const note = becca.notes[result.noteId];\n\n        result.highlightedNotePathTitle = result.notePathTitle.replace('/[<\\{\\}]/g', '');\n\n        if (highlightedTokens.find(token => note.type.includes(token))) {\n            result.highlightedNotePathTitle += ` \"type: ${note.type}'`;\n        }\n\n        if (highlightedTokens.find(token => note.mime.includes(token))) {\n            result.highlightedNotePathTitle += ` \"mime: ${note.mime}'`;\n        }\n\n        for (const attr of note.getAttributes()) {\n            if (highlightedTokens.find(token => utils.normalize(attr.name).includes(token)\n                || utils.normalize(attr.value).includes(token))) {\n\n                result.highlightedNotePathTitle += ` \"${formatAttribute(attr)}'`;\n            }\n        }\n    }\n\n    function wrapText(text, start, length, prefix, suffix) {\n        return text.substring(0, start) + prefix + text.substr(start, length) + suffix + text.substring(start + length);\n    }\n\n    for (const token of highlightedTokens) {\n        for (const result of searchResults) {\n            // Reset token\n            const tokenRegex = new RegExp(utils.escapeRegExp(token), \"gi\");\n            let match;\n\n            // Find all matches\n            while ((match = tokenRegex.exec(normalizeString(result.highlightedNotePathTitle))) !== null) {\n                result.highlightedNotePathTitle = wrapText(result.highlightedNotePathTitle, match.index, token.length, \"{\", \"}\");\n\n                // 2 characters are added, so we need to adjust the index\n                tokenRegex.lastIndex += 2;\n            }\n        }\n    }\n\n    for (const result of searchResults) {\n        result.highlightedNotePathTitle = result.highlightedNotePathTitle\n            .replace(/\"/g, \"<small>\")\n            .replace(/'/g, \"</small>\")\n            .replace(/{/g, \"<b>\")\n            .replace(/}/g, \"</b>\");\n    }\n}\n\nfunction formatAttribute(attr) {\n    if (attr.type === 'relation') {\n        return `~${utils.escapeHtml(attr.name)}=\u2026`;\n    }\n    else if (attr.type === 'label') {\n        let label = `#${utils.escapeHtml(attr.name)}`;\n\n        if (attr.value) {\n            const val = /[^\\w_-]/.test(attr.value) ? `\"${attr.value}\"` : attr.value;\n\n            label += `=${utils.escapeHtml(val)}`;\n        }\n\n        return label;\n    }\n}\n\nmodule.exports = {\n    searchFromNote,\n    searchNotesForAutocomplete,\n    findResultsWithQuery,\n    findFirstNoteWithQuery,\n    searchNotes\n};\n"], "fixing_code": ["\"use strict\";\n\nconst normalizeString = require(\"normalize-strings\");\nconst lex = require('./lex');\nconst handleParens = require('./handle_parens');\nconst parse = require('./parse');\nconst SearchResult = require(\"../search_result\");\nconst SearchContext = require(\"../search_context\");\nconst becca = require('../../../becca/becca');\nconst beccaService = require('../../../becca/becca_service');\nconst utils = require('../../utils');\nconst log = require('../../log');\nconst scriptService = require(\"../../script\");\nconst hoistedNoteService = require(\"../../hoisted_note\");\n\nfunction searchFromNote(note) {\n    let searchResultNoteIds, highlightedTokens;\n\n    const searchScript = note.getRelationValue('searchScript');\n    const searchString = note.getLabelValue('searchString');\n    let error = null;\n\n    if (searchScript) {\n        searchResultNoteIds = searchFromRelation(note, 'searchScript');\n        highlightedTokens = [];\n    } else {\n        const searchContext = new SearchContext({\n            fastSearch: note.hasLabel('fastSearch'),\n            ancestorNoteId: note.getRelationValue('ancestor'),\n            ancestorDepth: note.getLabelValue('ancestorDepth'),\n            includeArchivedNotes: note.hasLabel('includeArchivedNotes'),\n            orderBy: note.getLabelValue('orderBy'),\n            orderDirection: note.getLabelValue('orderDirection'),\n            limit: note.getLabelValue('limit'),\n            debug: note.hasLabel('debug'),\n            fuzzyAttributeSearch: false\n        });\n\n        searchResultNoteIds = findResultsWithQuery(searchString, searchContext)\n            .map(sr => sr.noteId);\n\n        highlightedTokens = searchContext.highlightedTokens;\n        error = searchContext.getError();\n    }\n\n    // we won't return search note's own noteId\n    // also don't allow root since that would force infinite cycle\n    return {\n        searchResultNoteIds: searchResultNoteIds.filter(resultNoteId => !['root', note.noteId].includes(resultNoteId)),\n        highlightedTokens,\n        error: error\n    };\n}\n\nfunction searchFromRelation(note, relationName) {\n    const scriptNote = note.getRelationTarget(relationName);\n\n    if (!scriptNote) {\n        log.info(`Search note's relation ${relationName} has not been found.`);\n\n        return [];\n    }\n\n    if (!scriptNote.isJavaScript() || scriptNote.getScriptEnv() !== 'backend') {\n        log.info(`Note ${scriptNote.noteId} is not executable.`);\n\n        return [];\n    }\n\n    if (!note.isContentAvailable()) {\n        log.info(`Note ${scriptNote.noteId} is not available outside of protected session.`);\n\n        return [];\n    }\n\n    const result = scriptService.executeNote(scriptNote, { originEntity: note });\n\n    if (!Array.isArray(result)) {\n        log.info(`Result from ${scriptNote.noteId} is not an array.`);\n\n        return [];\n    }\n\n    if (result.length === 0) {\n        return [];\n    }\n\n    // we expect either array of noteIds (strings) or notes, in that case we extract noteIds ourselves\n    return typeof result[0] === 'string' ? result : result.map(item => item.noteId);\n}\n\nfunction loadNeededInfoFromDatabase() {\n    const sql = require('../../sql');\n\n    for (const noteId in becca.notes) {\n        becca.notes[noteId].contentSize = 0;\n        becca.notes[noteId].noteSize = 0;\n        becca.notes[noteId].revisionCount = 0;\n    }\n\n    const noteContentLengths = sql.getRows(`\n        SELECT \n            noteId, \n            LENGTH(content) AS length \n        FROM notes\n             JOIN note_contents USING(noteId) \n        WHERE notes.isDeleted = 0`);\n\n    for (const {noteId, length} of noteContentLengths) {\n        if (!(noteId in becca.notes)) {\n            log.error(`Note ${noteId} not found in becca.`);\n            continue;\n        }\n\n        becca.notes[noteId].contentSize = length;\n        becca.notes[noteId].noteSize = length;\n    }\n\n    const noteRevisionContentLengths = sql.getRows(`\n        SELECT \n            noteId, \n            LENGTH(content) AS length \n        FROM notes\n             JOIN note_revisions USING(noteId) \n             JOIN note_revision_contents USING(noteRevisionId) \n        WHERE notes.isDeleted = 0`);\n\n    for (const {noteId, length} of noteRevisionContentLengths) {\n        if (!(noteId in becca.notes)) {\n            log.error(`Note ${noteId} not found in becca.`);\n            continue;\n        }\n\n        becca.notes[noteId].noteSize += length;\n        becca.notes[noteId].revisionCount++;\n    }\n}\n\n/**\n * @param {Expression} expression\n * @param {SearchContext} searchContext\n * @returns {SearchResult[]}\n */\nfunction findResultsWithExpression(expression, searchContext) {\n    if (searchContext.dbLoadNeeded) {\n        loadNeededInfoFromDatabase();\n    }\n\n    const allNoteSet = becca.getAllNoteSet();\n\n    const executionContext = {\n        noteIdToNotePath: {}\n    };\n\n    const noteSet = expression.execute(allNoteSet, executionContext, searchContext);\n\n    const searchResults = noteSet.notes\n        .filter(note => !note.isDeleted)\n        .map(note => {\n            const notePathArray = executionContext.noteIdToNotePath[note.noteId] || beccaService.getSomePath(note);\n\n            if (!notePathArray) {\n                throw new Error(`Can't find note path for note ${JSON.stringify(note.getPojo())}`);\n            }\n\n            return new SearchResult(notePathArray);\n        });\n\n    for (const res of searchResults) {\n        res.computeScore(searchContext.fulltextQuery, searchContext.highlightedTokens);\n    }\n\n    if (!noteSet.sorted) {\n        searchResults.sort((a, b) => {\n            if (a.score > b.score) {\n                return -1;\n            } else if (a.score < b.score) {\n                return 1;\n            }\n\n            // if score does not decide then sort results by depth of the note.\n            // This is based on the assumption that more important results are closer to the note root.\n            if (a.notePathArray.length === b.notePathArray.length) {\n                return a.notePathTitle < b.notePathTitle ? -1 : 1;\n            }\n\n            return a.notePathArray.length < b.notePathArray.length ? -1 : 1;\n        });\n    }\n\n    return searchResults;\n}\n\nfunction parseQueryToExpression(query, searchContext) {\n    const {fulltextQuery, fulltextTokens, expressionTokens} = lex(query);\n    searchContext.fulltextQuery = fulltextQuery;\n\n    let structuredExpressionTokens;\n\n    try {\n        structuredExpressionTokens = handleParens(expressionTokens);\n    }\n    catch (e) {\n        structuredExpressionTokens = [];\n        searchContext.addError(e.message);\n    }\n\n    const expression = parse({\n        fulltextTokens,\n        expressionTokens: structuredExpressionTokens,\n        searchContext,\n        originalQuery: query\n    });\n\n    if (searchContext.debug) {\n        searchContext.debugInfo = {\n            fulltextTokens,\n            structuredExpressionTokens,\n            expression\n        };\n\n        log.info(`Search debug: ${JSON.stringify(searchContext.debugInfo, null, 4)}`);\n    }\n\n    return expression;\n}\n\n/**\n * @param {string} query\n * @param {object} params - see SearchContext\n * @returns {BNote[]}\n */\nfunction searchNotes(query, params = {}) {\n    const searchResults = findResultsWithQuery(query, new SearchContext(params));\n\n    return searchResults.map(sr => becca.notes[sr.noteId]);\n}\n\n/**\n * @param {string} query\n * @param {SearchContext} searchContext\n * @returns {SearchResult[]}\n */\nfunction findResultsWithQuery(query, searchContext) {\n    query = query || \"\";\n    searchContext.originalQuery = query;\n\n    const expression = parseQueryToExpression(query, searchContext);\n\n    if (!expression) {\n        return [];\n    }\n\n    return findResultsWithExpression(expression, searchContext);\n}\n\n/**\n * @param {string} query\n * @param {SearchContext} searchContext\n * @returns {BNote|null}\n */\nfunction findFirstNoteWithQuery(query, searchContext) {\n    const searchResults = findResultsWithQuery(query, searchContext);\n\n    return searchResults.length > 0 ? becca.notes[searchResults[0].noteId] : null;\n}\n\nfunction searchNotesForAutocomplete(query) {\n    const searchContext = new SearchContext({\n        fastSearch: true,\n        includeArchivedNotes: false,\n        includeHiddenNotes: true,\n        fuzzyAttributeSearch: true,\n        ancestorNoteId: hoistedNoteService.isHoistedInHiddenSubtree()\n            ? 'root'\n            : hoistedNoteService.getHoistedNoteId()\n    });\n\n    const allSearchResults = findResultsWithQuery(query, searchContext);\n\n    const trimmed = allSearchResults.slice(0, 200);\n\n    highlightSearchResults(trimmed, searchContext.highlightedTokens);\n\n    return trimmed.map(result => {\n        return {\n            notePath: result.notePath,\n            noteTitle: beccaService.getNoteTitle(result.noteId),\n            notePathTitle: result.notePathTitle,\n            highlightedNotePathTitle: result.highlightedNotePathTitle\n        }\n    });\n}\n\nfunction highlightSearchResults(searchResults, highlightedTokens) {\n    highlightedTokens = Array.from(new Set(highlightedTokens));\n\n    // we remove < signs because they can cause trouble in matching and overwriting existing highlighted chunks\n    // which would make the resulting HTML string invalid.\n    // { and } are used for marking <b> and </b> tag (to avoid matches on single 'b' character)\n    // < and > are used for marking <small> and </small>\n    highlightedTokens = highlightedTokens.map(token => token.replace('/[<\\{\\}]/g', ''));\n\n    // sort by the longest, so we first highlight the longest matches\n    highlightedTokens.sort((a, b) => a.length > b.length ? -1 : 1);\n\n    for (const result of searchResults) {\n        const note = becca.notes[result.noteId];\n\n        result.highlightedNotePathTitle = result.notePathTitle.replace(/[<{}]/g, '');\n\n        if (highlightedTokens.find(token => note.type.includes(token))) {\n            result.highlightedNotePathTitle += ` \"type: ${note.type}'`;\n        }\n\n        if (highlightedTokens.find(token => note.mime.includes(token))) {\n            result.highlightedNotePathTitle += ` \"mime: ${note.mime}'`;\n        }\n\n        for (const attr of note.getAttributes()) {\n            if (highlightedTokens.find(token => utils.normalize(attr.name).includes(token)\n                || utils.normalize(attr.value).includes(token))) {\n\n                result.highlightedNotePathTitle += ` \"${formatAttribute(attr)}'`;\n            }\n        }\n    }\n\n    function wrapText(text, start, length, prefix, suffix) {\n        return text.substring(0, start) + prefix + text.substr(start, length) + suffix + text.substring(start + length);\n    }\n\n    for (const token of highlightedTokens) {\n        for (const result of searchResults) {\n            // Reset token\n            const tokenRegex = new RegExp(utils.escapeRegExp(token), \"gi\");\n            let match;\n\n            // Find all matches\n            while ((match = tokenRegex.exec(normalizeString(result.highlightedNotePathTitle))) !== null) {\n                result.highlightedNotePathTitle = wrapText(result.highlightedNotePathTitle, match.index, token.length, \"{\", \"}\");\n\n                // 2 characters are added, so we need to adjust the index\n                tokenRegex.lastIndex += 2;\n            }\n        }\n    }\n\n    for (const result of searchResults) {\n        result.highlightedNotePathTitle = result.highlightedNotePathTitle\n            .replace(/\"/g, \"<small>\")\n            .replace(/'/g, \"</small>\")\n            .replace(/{/g, \"<b>\")\n            .replace(/}/g, \"</b>\");\n    }\n}\n\nfunction formatAttribute(attr) {\n    if (attr.type === 'relation') {\n        return `~${utils.escapeHtml(attr.name)}=\u2026`;\n    }\n    else if (attr.type === 'label') {\n        let label = `#${utils.escapeHtml(attr.name)}`;\n\n        if (attr.value) {\n            const val = /[^\\w_-]/.test(attr.value) ? `\"${attr.value}\"` : attr.value;\n\n            label += `=${utils.escapeHtml(val)}`;\n        }\n\n        return label;\n    }\n}\n\nmodule.exports = {\n    searchFromNote,\n    searchNotesForAutocomplete,\n    findResultsWithQuery,\n    findFirstNoteWithQuery,\n    searchNotes\n};\n"], "filenames": ["src/services/search/services/search.js"], "buggy_code_start_loc": [310], "buggy_code_end_loc": [311], "fixing_code_start_loc": [310], "fixing_code_end_loc": [311], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository zadam/trilium prior to 0.59.4.", "other": {"cve": {"id": "CVE-2023-3067", "sourceIdentifier": "security@huntr.dev", "published": "2023-06-02T16:15:09.977", "lastModified": "2023-06-09T17:02:18.977", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository zadam/trilium prior to 0.59.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:H/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trilium_project:trilium:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.59.3", "matchCriteriaId": "89C3ACE9-A1BF-4B98-8ECC-92D2086E3321"}]}]}], "references": [{"url": "https://github.com/zadam/trilium/commit/4c3fcc3ea6f37debcb87ac1a7f5698c27be0e67b", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/4772ceb7-1594-414d-9b20-5b82029da7b6", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zadam/trilium/commit/4c3fcc3ea6f37debcb87ac1a7f5698c27be0e67b"}}