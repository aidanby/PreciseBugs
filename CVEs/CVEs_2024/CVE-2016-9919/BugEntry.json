{"buggy_code": ["/*\n *\tInternet Control Message Protocol (ICMPv6)\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on net/ipv4/icmp.c\n *\n *\tRFC 1885\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n/*\n *\tChanges:\n *\n *\tAndi Kleen\t\t:\texception handling\n *\tAndi Kleen\t\t\tadd rate limits. never reply to a icmp.\n *\t\t\t\t\tadd more length checks and other fixes.\n *\tyoshfuji\t\t:\tensure to sent parameter problem for\n *\t\t\t\t\tfragments.\n *\tYOSHIFUJI Hideaki @USAGI:\tadded sysctl for icmp rate limit.\n *\tRandy Dunlap and\n *\tYOSHIFUJI Hideaki @USAGI:\tPer-interface statistics support\n *\tKazunori MIYAZAWA @USAGI:       change output process to use ip6_append_data\n */\n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/netfilter.h>\n#include <linux/slab.h>\n\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/icmpv6.h>\n\n#include <net/ip.h>\n#include <net/sock.h>\n\n#include <net/ipv6.h>\n#include <net/ip6_checksum.h>\n#include <net/ping.h>\n#include <net/protocol.h>\n#include <net/raw.h>\n#include <net/rawv6.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/icmp.h>\n#include <net/xfrm.h>\n#include <net/inet_common.h>\n#include <net/dsfield.h>\n#include <net/l3mdev.h>\n\n#include <asm/uaccess.h>\n\n/*\n *\tThe ICMP socket(s). This is the most convenient way to flow control\n *\tour ICMP output as well as maintain a clean interface throughout\n *\tall layers. All Socketless IP sends will soon be gone.\n *\n *\tOn SMP we have one ICMP socket per-cpu.\n */\nstatic inline struct sock *icmpv6_sk(struct net *net)\n{\n\treturn net->ipv6.icmp_sk[smp_processor_id()];\n}\n\nstatic void icmpv6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\t/* icmpv6_notify checks 8 bytes can be pulled, icmp6hdr is 8 bytes */\n\tstruct icmp6hdr *icmp6 = (struct icmp6hdr *) (skb->data + offset);\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (type == ICMPV6_PKT_TOOBIG)\n\t\tip6_update_pmtu(skb, net, info, 0, 0);\n\telse if (type == NDISC_REDIRECT)\n\t\tip6_redirect(skb, net, skb->dev->ifindex, 0);\n\n\tif (!(type & ICMPV6_INFOMSG_MASK))\n\t\tif (icmp6->icmp6_type == ICMPV6_ECHO_REQUEST)\n\t\t\tping_err(skb, offset, ntohl(info));\n}\n\nstatic int icmpv6_rcv(struct sk_buff *skb);\n\nstatic const struct inet6_protocol icmpv6_protocol = {\n\t.handler\t=\ticmpv6_rcv,\n\t.err_handler\t=\ticmpv6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic __inline__ struct sock *icmpv6_xmit_lock(struct net *net)\n{\n\tstruct sock *sk;\n\n\tlocal_bh_disable();\n\n\tsk = icmpv6_sk(net);\n\tif (unlikely(!spin_trylock(&sk->sk_lock.slock))) {\n\t\t/* This can happen if the output path (f.e. SIT or\n\t\t * ip6ip6 tunnel) signals dst_link_failure() for an\n\t\t * outgoing ICMP6 packet.\n\t\t */\n\t\tlocal_bh_enable();\n\t\treturn NULL;\n\t}\n\treturn sk;\n}\n\nstatic __inline__ void icmpv6_xmit_unlock(struct sock *sk)\n{\n\tspin_unlock_bh(&sk->sk_lock.slock);\n}\n\n/*\n * Figure out, may we reply to this packet with icmp error.\n *\n * We do not reply, if:\n *\t- it was icmp error message.\n *\t- it is truncated, so that it is known, that protocol is ICMPV6\n *\t  (i.e. in the middle of some exthdr)\n *\n *\t--ANK (980726)\n */\n\nstatic bool is_ineligible(const struct sk_buff *skb)\n{\n\tint ptr = (u8 *)(ipv6_hdr(skb) + 1) - skb->data;\n\tint len = skb->len - ptr;\n\t__u8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\t__be16 frag_off;\n\n\tif (len < 0)\n\t\treturn true;\n\n\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr, &frag_off);\n\tif (ptr < 0)\n\t\treturn false;\n\tif (nexthdr == IPPROTO_ICMPV6) {\n\t\tu8 _type, *tp;\n\t\ttp = skb_header_pointer(skb,\n\t\t\tptr+offsetof(struct icmp6hdr, icmp6_type),\n\t\t\tsizeof(_type), &_type);\n\t\tif (!tp || !(*tp & ICMPV6_INFOMSG_MASK))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * Check the ICMP output rate limit\n */\nstatic bool icmpv6_xrlim_allow(struct sock *sk, u8 type,\n\t\t\t       struct flowi6 *fl6)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct dst_entry *dst;\n\tbool res = false;\n\n\t/* Informational messages are not limited. */\n\tif (type & ICMPV6_INFOMSG_MASK)\n\t\treturn true;\n\n\t/* Do not limit pmtu discovery, it would break it. */\n\tif (type == ICMPV6_PKT_TOOBIG)\n\t\treturn true;\n\n\t/*\n\t * Look up the output route.\n\t * XXX: perhaps the expire for routing entries cloned by\n\t * this lookup should be more aggressive (not longer than timeout).\n\t */\n\tdst = ip6_route_output(net, sk, fl6);\n\tif (dst->error) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t      IPSTATS_MIB_OUTNOROUTES);\n\t} else if (dst->dev && (dst->dev->flags&IFF_LOOPBACK)) {\n\t\tres = true;\n\t} else {\n\t\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\t\tint tmo = net->ipv6.sysctl.icmpv6_time;\n\n\t\t/* Give more bandwidth to wider prefixes. */\n\t\tif (rt->rt6i_dst.plen < 128)\n\t\t\ttmo >>= ((128 - rt->rt6i_dst.plen)>>5);\n\n\t\tif (icmp_global_allow()) {\n\t\t\tstruct inet_peer *peer;\n\n\t\t\tpeer = inet_getpeer_v6(net->ipv6.peers,\n\t\t\t\t\t       &fl6->daddr, 1);\n\t\t\tres = inet_peer_xrlim_allow(peer, tmo);\n\t\t\tif (peer)\n\t\t\t\tinet_putpeer(peer);\n\t\t}\n\t}\n\tdst_release(dst);\n\treturn res;\n}\n\n/*\n *\tan inline helper for the \"simple\" if statement below\n *\tchecks if parameter problem report is caused by an\n *\tunrecognized IPv6 option that has the Option Type\n *\thighest-order two bits set to 10\n */\n\nstatic bool opt_unrec(struct sk_buff *skb, __u32 offset)\n{\n\tu8 _optval, *op;\n\n\toffset += skb_network_offset(skb);\n\top = skb_header_pointer(skb, offset, sizeof(_optval), &_optval);\n\tif (!op)\n\t\treturn true;\n\treturn (*op & 0xC0) == 0x80;\n}\n\nint icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,\n\t\t\t       struct icmp6hdr *thdr, int len)\n{\n\tstruct sk_buff *skb;\n\tstruct icmp6hdr *icmp6h;\n\tint err = 0;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (!skb)\n\t\tgoto out;\n\n\ticmp6h = icmp6_hdr(skb);\n\tmemcpy(icmp6h, thdr, sizeof(struct icmp6hdr));\n\ticmp6h->icmp6_cksum = 0;\n\n\tif (skb_queue_len(&sk->sk_write_queue) == 1) {\n\t\tskb->csum = csum_partial(icmp6h,\n\t\t\t\t\tsizeof(struct icmp6hdr), skb->csum);\n\t\ticmp6h->icmp6_cksum = csum_ipv6_magic(&fl6->saddr,\n\t\t\t\t\t\t      &fl6->daddr,\n\t\t\t\t\t\t      len, fl6->flowi6_proto,\n\t\t\t\t\t\t      skb->csum);\n\t} else {\n\t\t__wsum tmp_csum = 0;\n\n\t\tskb_queue_walk(&sk->sk_write_queue, skb) {\n\t\t\ttmp_csum = csum_add(tmp_csum, skb->csum);\n\t\t}\n\n\t\ttmp_csum = csum_partial(icmp6h,\n\t\t\t\t\tsizeof(struct icmp6hdr), tmp_csum);\n\t\ticmp6h->icmp6_cksum = csum_ipv6_magic(&fl6->saddr,\n\t\t\t\t\t\t      &fl6->daddr,\n\t\t\t\t\t\t      len, fl6->flowi6_proto,\n\t\t\t\t\t\t      tmp_csum);\n\t}\n\tip6_push_pending_frames(sk);\nout:\n\treturn err;\n}\n\nstruct icmpv6_msg {\n\tstruct sk_buff\t*skb;\n\tint\t\toffset;\n\tuint8_t\t\ttype;\n};\n\nstatic int icmpv6_getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb)\n{\n\tstruct icmpv6_msg *msg = (struct icmpv6_msg *) from;\n\tstruct sk_buff *org_skb = msg->skb;\n\t__wsum csum = 0;\n\n\tcsum = skb_copy_and_csum_bits(org_skb, msg->offset + offset,\n\t\t\t\t      to, len, csum);\n\tskb->csum = csum_block_add(skb->csum, csum, odd);\n\tif (!(msg->type & ICMPV6_INFOMSG_MASK))\n\t\tnf_ct_attach(skb, org_skb);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\nstatic void mip6_addr_swap(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct ipv6_destopt_hao *hao;\n\tstruct in6_addr tmp;\n\tint off;\n\n\tif (opt->dsthao) {\n\t\toff = ipv6_find_tlv(skb, opt->dsthao, IPV6_TLV_HAO);\n\t\tif (likely(off >= 0)) {\n\t\t\thao = (struct ipv6_destopt_hao *)\n\t\t\t\t\t(skb_network_header(skb) + off);\n\t\t\ttmp = iph->saddr;\n\t\t\tiph->saddr = hao->addr;\n\t\t\thao->addr = tmp;\n\t\t}\n\t}\n}\n#else\nstatic inline void mip6_addr_swap(struct sk_buff *skb) {}\n#endif\n\nstatic struct dst_entry *icmpv6_route_lookup(struct net *net,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     struct sock *sk,\n\t\t\t\t\t     struct flowi6 *fl6)\n{\n\tstruct dst_entry *dst, *dst2;\n\tstruct flowi6 fl2;\n\tint err;\n\n\terr = ip6_dst_lookup(net, sk, &dst, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t/*\n\t * We won't send icmp if the destination is known\n\t * anycast.\n\t */\n\tif (ipv6_anycast_destination(dst, &fl6->daddr)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: acast source\\n\");\n\t\tdst_release(dst);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* No need to clone since we're just using its address. */\n\tdst2 = dst;\n\n\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(fl6), sk, 0);\n\tif (!IS_ERR(dst)) {\n\t\tif (dst != dst2)\n\t\t\treturn dst;\n\t} else {\n\t\tif (PTR_ERR(dst) == -EPERM)\n\t\t\tdst = NULL;\n\t\telse\n\t\t\treturn dst;\n\t}\n\n\terr = xfrm_decode_session_reverse(skb, flowi6_to_flowi(&fl2), AF_INET6);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\terr = ip6_dst_lookup(net, sk, &dst2, &fl2);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tdst2 = xfrm_lookup(net, dst2, flowi6_to_flowi(&fl2), sk, XFRM_LOOKUP_ICMP);\n\tif (!IS_ERR(dst2)) {\n\t\tdst_release(dst);\n\t\tdst = dst2;\n\t} else {\n\t\terr = PTR_ERR(dst2);\n\t\tif (err == -EPERM) {\n\t\t\tdst_release(dst);\n\t\t\treturn dst2;\n\t\t} else\n\t\t\tgoto relookup_failed;\n\t}\n\nrelookup_failed:\n\tif (dst)\n\t\treturn dst;\n\treturn ERR_PTR(err);\n}\n\n/*\n *\tSend an ICMP message in response to a packet in error\n */\nstatic void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info,\n\t\t       const struct in6_addr *force_saddr)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct inet6_dev *idev = NULL;\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct sock *sk;\n\tstruct ipv6_pinfo *np;\n\tconst struct in6_addr *saddr = NULL;\n\tstruct dst_entry *dst;\n\tstruct icmp6hdr tmp_hdr;\n\tstruct flowi6 fl6;\n\tstruct icmpv6_msg msg;\n\tstruct sockcm_cookie sockc_unused = {0};\n\tstruct ipcm6_cookie ipc6;\n\tint iif = 0;\n\tint addr_type = 0;\n\tint len;\n\tint err = 0;\n\tu32 mark = IP6_REPLY_MARK(net, skb->mark);\n\n\tif ((u8 *)hdr < skb->head ||\n\t    (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb))\n\t\treturn;\n\n\t/*\n\t *\tMake sure we respect the rules\n\t *\ti.e. RFC 1885 2.4(e)\n\t *\tRule (e.1) is enforced by not using icmp6_send\n\t *\tin any code that processes icmp errors.\n\t */\n\taddr_type = ipv6_addr_type(&hdr->daddr);\n\n\tif (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) ||\n\t    ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr))\n\t\tsaddr = &hdr->daddr;\n\n\t/*\n\t *\tDest addr check\n\t */\n\n\tif (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) {\n\t\tif (type != ICMPV6_PKT_TOOBIG &&\n\t\t    !(type == ICMPV6_PARAMPROB &&\n\t\t      code == ICMPV6_UNK_OPTION &&\n\t\t      (opt_unrec(skb, info))))\n\t\t\treturn;\n\n\t\tsaddr = NULL;\n\t}\n\n\taddr_type = ipv6_addr_type(&hdr->saddr);\n\n\t/*\n\t *\tSource addr check\n\t */\n\n\tif (__ipv6_addr_needs_scope_id(addr_type))\n\t\tiif = skb->dev->ifindex;\n\telse\n\t\tiif = l3mdev_master_ifindex(skb_dst(skb)->dev);\n\n\t/*\n\t *\tMust not send error if the source does not uniquely\n\t *\tidentify a single node (RFC2463 Section 2.4).\n\t *\tWe check unspecified / multicast addresses here,\n\t *\tand anycast addresses will be checked later.\n\t */\n\tif ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\t/*\n\t *\tNever answer to a ICMP packet.\n\t */\n\tif (is_ineligible(skb)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: no reply to icmp error [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\tmip6_addr_swap(skb);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_ICMPV6;\n\tfl6.daddr = hdr->saddr;\n\tif (force_saddr)\n\t\tsaddr = force_saddr;\n\tif (saddr)\n\t\tfl6.saddr = *saddr;\n\tfl6.flowi6_mark = mark;\n\tfl6.flowi6_oif = iif;\n\tfl6.fl6_icmp_type = type;\n\tfl6.fl6_icmp_code = code;\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\tsk = icmpv6_xmit_lock(net);\n\tif (!sk)\n\t\treturn;\n\tsk->sk_mark = mark;\n\tnp = inet6_sk(sk);\n\n\tif (!icmpv6_xrlim_allow(sk, type, &fl6))\n\t\tgoto out;\n\n\ttmp_hdr.icmp6_type = type;\n\ttmp_hdr.icmp6_code = code;\n\ttmp_hdr.icmp6_cksum = 0;\n\ttmp_hdr.icmp6_pointer = htonl(info);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tipc6.tclass = np->tclass;\n\tfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\n\n\tdst = icmpv6_route_lookup(net, skb, sk, &fl6);\n\tif (IS_ERR(dst))\n\t\tgoto out;\n\n\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\tipc6.dontfrag = np->dontfrag;\n\tipc6.opt = NULL;\n\n\tmsg.skb = skb;\n\tmsg.offset = skb_network_offset(skb);\n\tmsg.type = type;\n\n\tlen = skb->len - msg.offset;\n\tlen = min_t(unsigned int, len, IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(struct icmp6hdr));\n\tif (len < 0) {\n\t\tnet_dbg_ratelimited(\"icmp: len problem [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\tgoto out_dst_release;\n\t}\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(skb->dev);\n\n\terr = ip6_append_data(sk, icmpv6_getfrag, &msg,\n\t\t\t      len + sizeof(struct icmp6hdr),\n\t\t\t      sizeof(struct icmp6hdr),\n\t\t\t      &ipc6, &fl6, (struct rt6_info *)dst,\n\t\t\t      MSG_DONTWAIT, &sockc_unused);\n\tif (err) {\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);\n\t\tip6_flush_pending_frames(sk);\n\t} else {\n\t\terr = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr,\n\t\t\t\t\t\t len + sizeof(struct icmp6hdr));\n\t}\n\trcu_read_unlock();\nout_dst_release:\n\tdst_release(dst);\nout:\n\ticmpv6_xmit_unlock(sk);\n}\n\n/* Slightly more convenient version of icmp6_send.\n */\nvoid icmpv6_param_prob(struct sk_buff *skb, u8 code, int pos)\n{\n\ticmp6_send(skb, ICMPV6_PARAMPROB, code, pos, NULL);\n\tkfree_skb(skb);\n}\n\n/* Generate icmpv6 with type/code ICMPV6_DEST_UNREACH/ICMPV6_ADDR_UNREACH\n * if sufficient data bytes are available\n * @nhs is the size of the tunnel header(s) :\n *  Either an IPv4 header for SIT encap\n *         an IPv4 header + GRE header for GRE encap\n */\nint ip6_err_gen_icmpv6_unreach(struct sk_buff *skb, int nhs, int type,\n\t\t\t       unsigned int data_len)\n{\n\tstruct in6_addr temp_saddr;\n\tstruct rt6_info *rt;\n\tstruct sk_buff *skb2;\n\tu32 info = 0;\n\n\tif (!pskb_may_pull(skb, nhs + sizeof(struct ipv6hdr) + 8))\n\t\treturn 1;\n\n\t/* RFC 4884 (partial) support for ICMP extensions */\n\tif (data_len < 128 || (data_len & 7) || skb->len < data_len)\n\t\tdata_len = 0;\n\n\tskb2 = data_len ? skb_copy(skb, GFP_ATOMIC) : skb_clone(skb, GFP_ATOMIC);\n\n\tif (!skb2)\n\t\treturn 1;\n\n\tskb_dst_drop(skb2);\n\tskb_pull(skb2, nhs);\n\tskb_reset_network_header(skb2);\n\n\trt = rt6_lookup(dev_net(skb->dev), &ipv6_hdr(skb2)->saddr, NULL, 0, 0);\n\n\tif (rt && rt->dst.dev)\n\t\tskb2->dev = rt->dst.dev;\n\n\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr, &temp_saddr);\n\n\tif (data_len) {\n\t\t/* RFC 4884 (partial) support :\n\t\t * insert 0 padding at the end, before the extensions\n\t\t */\n\t\t__skb_push(skb2, nhs);\n\t\tskb_reset_network_header(skb2);\n\t\tmemmove(skb2->data, skb2->data + nhs, data_len - nhs);\n\t\tmemset(skb2->data + data_len - nhs, 0, nhs);\n\t\t/* RFC 4884 4.5 : Length is measured in 64-bit words,\n\t\t * and stored in reserved[0]\n\t\t */\n\t\tinfo = (data_len/8) << 24;\n\t}\n\tif (type == ICMP_TIME_EXCEEDED)\n\t\ticmp6_send(skb2, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT,\n\t\t\t   info, &temp_saddr);\n\telse\n\t\ticmp6_send(skb2, ICMPV6_DEST_UNREACH, ICMPV6_ADDR_UNREACH,\n\t\t\t   info, &temp_saddr);\n\tif (rt)\n\t\tip6_rt_put(rt);\n\n\tkfree_skb(skb2);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ip6_err_gen_icmpv6_unreach);\n\nstatic void icmpv6_echo_reply(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tstruct inet6_dev *idev;\n\tstruct ipv6_pinfo *np;\n\tconst struct in6_addr *saddr = NULL;\n\tstruct icmp6hdr *icmph = icmp6_hdr(skb);\n\tstruct icmp6hdr tmp_hdr;\n\tstruct flowi6 fl6;\n\tstruct icmpv6_msg msg;\n\tstruct dst_entry *dst;\n\tstruct ipcm6_cookie ipc6;\n\tint err = 0;\n\tu32 mark = IP6_REPLY_MARK(net, skb->mark);\n\tstruct sockcm_cookie sockc_unused = {0};\n\n\tsaddr = &ipv6_hdr(skb)->daddr;\n\n\tif (!ipv6_unicast_destination(skb) &&\n\t    !(net->ipv6.sysctl.anycast_src_echo_reply &&\n\t      ipv6_anycast_destination(skb_dst(skb), saddr)))\n\t\tsaddr = NULL;\n\n\tmemcpy(&tmp_hdr, icmph, sizeof(tmp_hdr));\n\ttmp_hdr.icmp6_type = ICMPV6_ECHO_REPLY;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_ICMPV6;\n\tfl6.daddr = ipv6_hdr(skb)->saddr;\n\tif (saddr)\n\t\tfl6.saddr = *saddr;\n\tfl6.flowi6_oif = skb->dev->ifindex;\n\tfl6.fl6_icmp_type = ICMPV6_ECHO_REPLY;\n\tfl6.flowi6_mark = mark;\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\tsk = icmpv6_xmit_lock(net);\n\tif (!sk)\n\t\treturn;\n\tsk->sk_mark = mark;\n\tnp = inet6_sk(sk);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\terr = ip6_dst_lookup(net, sk, &dst, &fl6);\n\tif (err)\n\t\tgoto out;\n\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), sk, 0);\n\tif (IS_ERR(dst))\n\t\tgoto out;\n\n\tidev = __in6_dev_get(skb->dev);\n\n\tmsg.skb = skb;\n\tmsg.offset = 0;\n\tmsg.type = ICMPV6_ECHO_REPLY;\n\n\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\tipc6.tclass = ipv6_get_dsfield(ipv6_hdr(skb));\n\tipc6.dontfrag = np->dontfrag;\n\tipc6.opt = NULL;\n\n\terr = ip6_append_data(sk, icmpv6_getfrag, &msg, skb->len + sizeof(struct icmp6hdr),\n\t\t\t\tsizeof(struct icmp6hdr), &ipc6, &fl6,\n\t\t\t\t(struct rt6_info *)dst, MSG_DONTWAIT,\n\t\t\t\t&sockc_unused);\n\n\tif (err) {\n\t\t__ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);\n\t\tip6_flush_pending_frames(sk);\n\t} else {\n\t\terr = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr,\n\t\t\t\t\t\t skb->len + sizeof(struct icmp6hdr));\n\t}\n\tdst_release(dst);\nout:\n\ticmpv6_xmit_unlock(sk);\n}\n\nvoid icmpv6_notify(struct sk_buff *skb, u8 type, u8 code, __be32 info)\n{\n\tconst struct inet6_protocol *ipprot;\n\tint inner_offset;\n\t__be16 frag_off;\n\tu8 nexthdr;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\n\tnexthdr = ((struct ipv6hdr *)skb->data)->nexthdr;\n\tif (ipv6_ext_hdr(nexthdr)) {\n\t\t/* now skip over extension headers */\n\t\tinner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr),\n\t\t\t\t\t\t&nexthdr, &frag_off);\n\t\tif (inner_offset < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tinner_offset = sizeof(struct ipv6hdr);\n\t}\n\n\t/* Checkin header including 8 bytes of inner protocol header. */\n\tif (!pskb_may_pull(skb, inner_offset+8))\n\t\tgoto out;\n\n\t/* BUGGG_FUTURE: we should try to parse exthdrs in this packet.\n\t   Without this we will not able f.e. to make source routed\n\t   pmtu discovery.\n\t   Corresponding argument (opt) to notifiers is already added.\n\t   --ANK (980726)\n\t */\n\n\tipprot = rcu_dereference(inet6_protos[nexthdr]);\n\tif (ipprot && ipprot->err_handler)\n\t\tipprot->err_handler(skb, NULL, type, code, inner_offset, info);\n\n\traw6_icmp_error(skb, nexthdr, type, code, inner_offset, info);\n\treturn;\n\nout:\n\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev), ICMP6_MIB_INERRORS);\n}\n\n/*\n *\tHandle icmp messages\n */\n\nstatic int icmpv6_rcv(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct icmp6hdr *hdr;\n\tu8 type;\n\tbool success = false;\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tstruct sec_path *sp = skb_sec_path(skb);\n\t\tint nh;\n\n\t\tif (!(sp && sp->xvec[sp->len - 1]->props.flags &\n\t\t\t\t XFRM_STATE_ICMP))\n\t\t\tgoto drop_no_count;\n\n\t\tif (!pskb_may_pull(skb, sizeof(*hdr) + sizeof(struct ipv6hdr)))\n\t\t\tgoto drop_no_count;\n\n\t\tnh = skb_network_offset(skb);\n\t\tskb_set_network_header(skb, sizeof(*hdr));\n\n\t\tif (!xfrm6_policy_check_reverse(NULL, XFRM_POLICY_IN, skb))\n\t\t\tgoto drop_no_count;\n\n\t\tskb_set_network_header(skb, nh);\n\t}\n\n\t__ICMP6_INC_STATS(dev_net(dev), idev, ICMP6_MIB_INMSGS);\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\n\tif (skb_checksum_validate(skb, IPPROTO_ICMPV6, ip6_compute_pseudo)) {\n\t\tnet_dbg_ratelimited(\"ICMPv6 checksum failed [%pI6c > %pI6c]\\n\",\n\t\t\t\t    saddr, daddr);\n\t\tgoto csum_error;\n\t}\n\n\tif (!pskb_pull(skb, sizeof(*hdr)))\n\t\tgoto discard_it;\n\n\thdr = icmp6_hdr(skb);\n\n\ttype = hdr->icmp6_type;\n\n\tICMP6MSGIN_INC_STATS(dev_net(dev), idev, type);\n\n\tswitch (type) {\n\tcase ICMPV6_ECHO_REQUEST:\n\t\ticmpv6_echo_reply(skb);\n\t\tbreak;\n\n\tcase ICMPV6_ECHO_REPLY:\n\t\tsuccess = ping_rcv(skb);\n\t\tbreak;\n\n\tcase ICMPV6_PKT_TOOBIG:\n\t\t/* BUGGG_FUTURE: if packet contains rthdr, we cannot update\n\t\t   standard destination cache. Seems, only \"advanced\"\n\t\t   destination cache will allow to solve this problem\n\t\t   --ANK (980726)\n\t\t */\n\t\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\t\tgoto discard_it;\n\t\thdr = icmp6_hdr(skb);\n\n\t\t/*\n\t\t *\tDrop through to notify\n\t\t */\n\n\tcase ICMPV6_DEST_UNREACH:\n\tcase ICMPV6_TIME_EXCEED:\n\tcase ICMPV6_PARAMPROB:\n\t\ticmpv6_notify(skb, type, hdr->icmp6_code, hdr->icmp6_mtu);\n\t\tbreak;\n\n\tcase NDISC_ROUTER_SOLICITATION:\n\tcase NDISC_ROUTER_ADVERTISEMENT:\n\tcase NDISC_NEIGHBOUR_SOLICITATION:\n\tcase NDISC_NEIGHBOUR_ADVERTISEMENT:\n\tcase NDISC_REDIRECT:\n\t\tndisc_rcv(skb);\n\t\tbreak;\n\n\tcase ICMPV6_MGM_QUERY:\n\t\tigmp6_event_query(skb);\n\t\tbreak;\n\n\tcase ICMPV6_MGM_REPORT:\n\t\tigmp6_event_report(skb);\n\t\tbreak;\n\n\tcase ICMPV6_MGM_REDUCTION:\n\tcase ICMPV6_NI_QUERY:\n\tcase ICMPV6_NI_REPLY:\n\tcase ICMPV6_MLD2_REPORT:\n\tcase ICMPV6_DHAAD_REQUEST:\n\tcase ICMPV6_DHAAD_REPLY:\n\tcase ICMPV6_MOBILE_PREFIX_SOL:\n\tcase ICMPV6_MOBILE_PREFIX_ADV:\n\t\tbreak;\n\n\tdefault:\n\t\t/* informational */\n\t\tif (type & ICMPV6_INFOMSG_MASK)\n\t\t\tbreak;\n\n\t\tnet_dbg_ratelimited(\"icmpv6: msg of unknown type [%pI6c > %pI6c]\\n\",\n\t\t\t\t    saddr, daddr);\n\n\t\t/*\n\t\t * error of unknown type.\n\t\t * must pass to upper level\n\t\t */\n\n\t\ticmpv6_notify(skb, type, hdr->icmp6_code, hdr->icmp6_mtu);\n\t}\n\n\t/* until the v6 path can be better sorted assume failure and\n\t * preserve the status quo behaviour for the rest of the paths to here\n\t */\n\tif (success)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\n\treturn 0;\n\ncsum_error:\n\t__ICMP6_INC_STATS(dev_net(dev), idev, ICMP6_MIB_CSUMERRORS);\ndiscard_it:\n\t__ICMP6_INC_STATS(dev_net(dev), idev, ICMP6_MIB_INERRORS);\ndrop_no_count:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nvoid icmpv6_flow_init(struct sock *sk, struct flowi6 *fl6,\n\t\t      u8 type,\n\t\t      const struct in6_addr *saddr,\n\t\t      const struct in6_addr *daddr,\n\t\t      int oif)\n{\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->saddr = *saddr;\n\tfl6->daddr = *daddr;\n\tfl6->flowi6_proto\t= IPPROTO_ICMPV6;\n\tfl6->fl6_icmp_type\t= type;\n\tfl6->fl6_icmp_code\t= 0;\n\tfl6->flowi6_oif\t\t= oif;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n}\n\nstatic int __net_init icmpv6_sk_init(struct net *net)\n{\n\tstruct sock *sk;\n\tint err, i, j;\n\n\tnet->ipv6.icmp_sk =\n\t\tkzalloc(nr_cpu_ids * sizeof(struct sock *), GFP_KERNEL);\n\tif (!net->ipv6.icmp_sk)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(i) {\n\t\terr = inet_ctl_sock_create(&sk, PF_INET6,\n\t\t\t\t\t   SOCK_RAW, IPPROTO_ICMPV6, net);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"Failed to initialize the ICMP6 control socket (err %d)\\n\",\n\t\t\t       err);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnet->ipv6.icmp_sk[i] = sk;\n\n\t\t/* Enough space for 2 64K ICMP packets, including\n\t\t * sk_buff struct overhead.\n\t\t */\n\t\tsk->sk_sndbuf = 2 * SKB_TRUESIZE(64 * 1024);\n\t}\n\treturn 0;\n\n fail:\n\tfor (j = 0; j < i; j++)\n\t\tinet_ctl_sock_destroy(net->ipv6.icmp_sk[j]);\n\tkfree(net->ipv6.icmp_sk);\n\treturn err;\n}\n\nstatic void __net_exit icmpv6_sk_exit(struct net *net)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tinet_ctl_sock_destroy(net->ipv6.icmp_sk[i]);\n\t}\n\tkfree(net->ipv6.icmp_sk);\n}\n\nstatic struct pernet_operations icmpv6_sk_ops = {\n\t.init = icmpv6_sk_init,\n\t.exit = icmpv6_sk_exit,\n};\n\nint __init icmpv6_init(void)\n{\n\tint err;\n\n\terr = register_pernet_subsys(&icmpv6_sk_ops);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EAGAIN;\n\tif (inet6_add_protocol(&icmpv6_protocol, IPPROTO_ICMPV6) < 0)\n\t\tgoto fail;\n\n\terr = inet6_register_icmp_sender(icmp6_send);\n\tif (err)\n\t\tgoto sender_reg_err;\n\treturn 0;\n\nsender_reg_err:\n\tinet6_del_protocol(&icmpv6_protocol, IPPROTO_ICMPV6);\nfail:\n\tpr_err(\"Failed to register ICMP6 protocol\\n\");\n\tunregister_pernet_subsys(&icmpv6_sk_ops);\n\treturn err;\n}\n\nvoid icmpv6_cleanup(void)\n{\n\tinet6_unregister_icmp_sender(icmp6_send);\n\tunregister_pernet_subsys(&icmpv6_sk_ops);\n\tinet6_del_protocol(&icmpv6_protocol, IPPROTO_ICMPV6);\n}\n\n\nstatic const struct icmp6_err {\n\tint err;\n\tint fatal;\n} tab_unreach[] = {\n\t{\t/* NOROUTE */\n\t\t.err\t= ENETUNREACH,\n\t\t.fatal\t= 0,\n\t},\n\t{\t/* ADM_PROHIBITED */\n\t\t.err\t= EACCES,\n\t\t.fatal\t= 1,\n\t},\n\t{\t/* Was NOT_NEIGHBOUR, now reserved */\n\t\t.err\t= EHOSTUNREACH,\n\t\t.fatal\t= 0,\n\t},\n\t{\t/* ADDR_UNREACH\t*/\n\t\t.err\t= EHOSTUNREACH,\n\t\t.fatal\t= 0,\n\t},\n\t{\t/* PORT_UNREACH\t*/\n\t\t.err\t= ECONNREFUSED,\n\t\t.fatal\t= 1,\n\t},\n\t{\t/* POLICY_FAIL */\n\t\t.err\t= EACCES,\n\t\t.fatal\t= 1,\n\t},\n\t{\t/* REJECT_ROUTE\t*/\n\t\t.err\t= EACCES,\n\t\t.fatal\t= 1,\n\t},\n};\n\nint icmpv6_err_convert(u8 type, u8 code, int *err)\n{\n\tint fatal = 0;\n\n\t*err = EPROTO;\n\n\tswitch (type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tfatal = 1;\n\t\tif (code < ARRAY_SIZE(tab_unreach)) {\n\t\t\t*err  = tab_unreach[code].err;\n\t\t\tfatal = tab_unreach[code].fatal;\n\t\t}\n\t\tbreak;\n\n\tcase ICMPV6_PKT_TOOBIG:\n\t\t*err = EMSGSIZE;\n\t\tbreak;\n\n\tcase ICMPV6_PARAMPROB:\n\t\t*err = EPROTO;\n\t\tfatal = 1;\n\t\tbreak;\n\n\tcase ICMPV6_TIME_EXCEED:\n\t\t*err = EHOSTUNREACH;\n\t\tbreak;\n\t}\n\n\treturn fatal;\n}\nEXPORT_SYMBOL(icmpv6_err_convert);\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table ipv6_icmp_table_template[] = {\n\t{\n\t\t.procname\t= \"ratelimit\",\n\t\t.data\t\t= &init_net.ipv6.sysctl.icmpv6_time,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_ms_jiffies,\n\t},\n\t{ },\n};\n\nstruct ctl_table * __net_init ipv6_icmp_sysctl_init(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = kmemdup(ipv6_icmp_table_template,\n\t\t\tsizeof(ipv6_icmp_table_template),\n\t\t\tGFP_KERNEL);\n\n\tif (table)\n\t\ttable[0].data = &net->ipv6.sysctl.icmpv6_time;\n\n\treturn table;\n}\n#endif\n"], "fixing_code": ["/*\n *\tInternet Control Message Protocol (ICMPv6)\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on net/ipv4/icmp.c\n *\n *\tRFC 1885\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n/*\n *\tChanges:\n *\n *\tAndi Kleen\t\t:\texception handling\n *\tAndi Kleen\t\t\tadd rate limits. never reply to a icmp.\n *\t\t\t\t\tadd more length checks and other fixes.\n *\tyoshfuji\t\t:\tensure to sent parameter problem for\n *\t\t\t\t\tfragments.\n *\tYOSHIFUJI Hideaki @USAGI:\tadded sysctl for icmp rate limit.\n *\tRandy Dunlap and\n *\tYOSHIFUJI Hideaki @USAGI:\tPer-interface statistics support\n *\tKazunori MIYAZAWA @USAGI:       change output process to use ip6_append_data\n */\n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/netfilter.h>\n#include <linux/slab.h>\n\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/icmpv6.h>\n\n#include <net/ip.h>\n#include <net/sock.h>\n\n#include <net/ipv6.h>\n#include <net/ip6_checksum.h>\n#include <net/ping.h>\n#include <net/protocol.h>\n#include <net/raw.h>\n#include <net/rawv6.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/icmp.h>\n#include <net/xfrm.h>\n#include <net/inet_common.h>\n#include <net/dsfield.h>\n#include <net/l3mdev.h>\n\n#include <asm/uaccess.h>\n\n/*\n *\tThe ICMP socket(s). This is the most convenient way to flow control\n *\tour ICMP output as well as maintain a clean interface throughout\n *\tall layers. All Socketless IP sends will soon be gone.\n *\n *\tOn SMP we have one ICMP socket per-cpu.\n */\nstatic inline struct sock *icmpv6_sk(struct net *net)\n{\n\treturn net->ipv6.icmp_sk[smp_processor_id()];\n}\n\nstatic void icmpv6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\t/* icmpv6_notify checks 8 bytes can be pulled, icmp6hdr is 8 bytes */\n\tstruct icmp6hdr *icmp6 = (struct icmp6hdr *) (skb->data + offset);\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (type == ICMPV6_PKT_TOOBIG)\n\t\tip6_update_pmtu(skb, net, info, 0, 0);\n\telse if (type == NDISC_REDIRECT)\n\t\tip6_redirect(skb, net, skb->dev->ifindex, 0);\n\n\tif (!(type & ICMPV6_INFOMSG_MASK))\n\t\tif (icmp6->icmp6_type == ICMPV6_ECHO_REQUEST)\n\t\t\tping_err(skb, offset, ntohl(info));\n}\n\nstatic int icmpv6_rcv(struct sk_buff *skb);\n\nstatic const struct inet6_protocol icmpv6_protocol = {\n\t.handler\t=\ticmpv6_rcv,\n\t.err_handler\t=\ticmpv6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic __inline__ struct sock *icmpv6_xmit_lock(struct net *net)\n{\n\tstruct sock *sk;\n\n\tlocal_bh_disable();\n\n\tsk = icmpv6_sk(net);\n\tif (unlikely(!spin_trylock(&sk->sk_lock.slock))) {\n\t\t/* This can happen if the output path (f.e. SIT or\n\t\t * ip6ip6 tunnel) signals dst_link_failure() for an\n\t\t * outgoing ICMP6 packet.\n\t\t */\n\t\tlocal_bh_enable();\n\t\treturn NULL;\n\t}\n\treturn sk;\n}\n\nstatic __inline__ void icmpv6_xmit_unlock(struct sock *sk)\n{\n\tspin_unlock_bh(&sk->sk_lock.slock);\n}\n\n/*\n * Figure out, may we reply to this packet with icmp error.\n *\n * We do not reply, if:\n *\t- it was icmp error message.\n *\t- it is truncated, so that it is known, that protocol is ICMPV6\n *\t  (i.e. in the middle of some exthdr)\n *\n *\t--ANK (980726)\n */\n\nstatic bool is_ineligible(const struct sk_buff *skb)\n{\n\tint ptr = (u8 *)(ipv6_hdr(skb) + 1) - skb->data;\n\tint len = skb->len - ptr;\n\t__u8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\t__be16 frag_off;\n\n\tif (len < 0)\n\t\treturn true;\n\n\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr, &frag_off);\n\tif (ptr < 0)\n\t\treturn false;\n\tif (nexthdr == IPPROTO_ICMPV6) {\n\t\tu8 _type, *tp;\n\t\ttp = skb_header_pointer(skb,\n\t\t\tptr+offsetof(struct icmp6hdr, icmp6_type),\n\t\t\tsizeof(_type), &_type);\n\t\tif (!tp || !(*tp & ICMPV6_INFOMSG_MASK))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * Check the ICMP output rate limit\n */\nstatic bool icmpv6_xrlim_allow(struct sock *sk, u8 type,\n\t\t\t       struct flowi6 *fl6)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct dst_entry *dst;\n\tbool res = false;\n\n\t/* Informational messages are not limited. */\n\tif (type & ICMPV6_INFOMSG_MASK)\n\t\treturn true;\n\n\t/* Do not limit pmtu discovery, it would break it. */\n\tif (type == ICMPV6_PKT_TOOBIG)\n\t\treturn true;\n\n\t/*\n\t * Look up the output route.\n\t * XXX: perhaps the expire for routing entries cloned by\n\t * this lookup should be more aggressive (not longer than timeout).\n\t */\n\tdst = ip6_route_output(net, sk, fl6);\n\tif (dst->error) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t      IPSTATS_MIB_OUTNOROUTES);\n\t} else if (dst->dev && (dst->dev->flags&IFF_LOOPBACK)) {\n\t\tres = true;\n\t} else {\n\t\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\t\tint tmo = net->ipv6.sysctl.icmpv6_time;\n\n\t\t/* Give more bandwidth to wider prefixes. */\n\t\tif (rt->rt6i_dst.plen < 128)\n\t\t\ttmo >>= ((128 - rt->rt6i_dst.plen)>>5);\n\n\t\tif (icmp_global_allow()) {\n\t\t\tstruct inet_peer *peer;\n\n\t\t\tpeer = inet_getpeer_v6(net->ipv6.peers,\n\t\t\t\t\t       &fl6->daddr, 1);\n\t\t\tres = inet_peer_xrlim_allow(peer, tmo);\n\t\t\tif (peer)\n\t\t\t\tinet_putpeer(peer);\n\t\t}\n\t}\n\tdst_release(dst);\n\treturn res;\n}\n\n/*\n *\tan inline helper for the \"simple\" if statement below\n *\tchecks if parameter problem report is caused by an\n *\tunrecognized IPv6 option that has the Option Type\n *\thighest-order two bits set to 10\n */\n\nstatic bool opt_unrec(struct sk_buff *skb, __u32 offset)\n{\n\tu8 _optval, *op;\n\n\toffset += skb_network_offset(skb);\n\top = skb_header_pointer(skb, offset, sizeof(_optval), &_optval);\n\tif (!op)\n\t\treturn true;\n\treturn (*op & 0xC0) == 0x80;\n}\n\nint icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,\n\t\t\t       struct icmp6hdr *thdr, int len)\n{\n\tstruct sk_buff *skb;\n\tstruct icmp6hdr *icmp6h;\n\tint err = 0;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (!skb)\n\t\tgoto out;\n\n\ticmp6h = icmp6_hdr(skb);\n\tmemcpy(icmp6h, thdr, sizeof(struct icmp6hdr));\n\ticmp6h->icmp6_cksum = 0;\n\n\tif (skb_queue_len(&sk->sk_write_queue) == 1) {\n\t\tskb->csum = csum_partial(icmp6h,\n\t\t\t\t\tsizeof(struct icmp6hdr), skb->csum);\n\t\ticmp6h->icmp6_cksum = csum_ipv6_magic(&fl6->saddr,\n\t\t\t\t\t\t      &fl6->daddr,\n\t\t\t\t\t\t      len, fl6->flowi6_proto,\n\t\t\t\t\t\t      skb->csum);\n\t} else {\n\t\t__wsum tmp_csum = 0;\n\n\t\tskb_queue_walk(&sk->sk_write_queue, skb) {\n\t\t\ttmp_csum = csum_add(tmp_csum, skb->csum);\n\t\t}\n\n\t\ttmp_csum = csum_partial(icmp6h,\n\t\t\t\t\tsizeof(struct icmp6hdr), tmp_csum);\n\t\ticmp6h->icmp6_cksum = csum_ipv6_magic(&fl6->saddr,\n\t\t\t\t\t\t      &fl6->daddr,\n\t\t\t\t\t\t      len, fl6->flowi6_proto,\n\t\t\t\t\t\t      tmp_csum);\n\t}\n\tip6_push_pending_frames(sk);\nout:\n\treturn err;\n}\n\nstruct icmpv6_msg {\n\tstruct sk_buff\t*skb;\n\tint\t\toffset;\n\tuint8_t\t\ttype;\n};\n\nstatic int icmpv6_getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb)\n{\n\tstruct icmpv6_msg *msg = (struct icmpv6_msg *) from;\n\tstruct sk_buff *org_skb = msg->skb;\n\t__wsum csum = 0;\n\n\tcsum = skb_copy_and_csum_bits(org_skb, msg->offset + offset,\n\t\t\t\t      to, len, csum);\n\tskb->csum = csum_block_add(skb->csum, csum, odd);\n\tif (!(msg->type & ICMPV6_INFOMSG_MASK))\n\t\tnf_ct_attach(skb, org_skb);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\nstatic void mip6_addr_swap(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct ipv6_destopt_hao *hao;\n\tstruct in6_addr tmp;\n\tint off;\n\n\tif (opt->dsthao) {\n\t\toff = ipv6_find_tlv(skb, opt->dsthao, IPV6_TLV_HAO);\n\t\tif (likely(off >= 0)) {\n\t\t\thao = (struct ipv6_destopt_hao *)\n\t\t\t\t\t(skb_network_header(skb) + off);\n\t\t\ttmp = iph->saddr;\n\t\t\tiph->saddr = hao->addr;\n\t\t\thao->addr = tmp;\n\t\t}\n\t}\n}\n#else\nstatic inline void mip6_addr_swap(struct sk_buff *skb) {}\n#endif\n\nstatic struct dst_entry *icmpv6_route_lookup(struct net *net,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     struct sock *sk,\n\t\t\t\t\t     struct flowi6 *fl6)\n{\n\tstruct dst_entry *dst, *dst2;\n\tstruct flowi6 fl2;\n\tint err;\n\n\terr = ip6_dst_lookup(net, sk, &dst, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t/*\n\t * We won't send icmp if the destination is known\n\t * anycast.\n\t */\n\tif (ipv6_anycast_destination(dst, &fl6->daddr)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: acast source\\n\");\n\t\tdst_release(dst);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* No need to clone since we're just using its address. */\n\tdst2 = dst;\n\n\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(fl6), sk, 0);\n\tif (!IS_ERR(dst)) {\n\t\tif (dst != dst2)\n\t\t\treturn dst;\n\t} else {\n\t\tif (PTR_ERR(dst) == -EPERM)\n\t\t\tdst = NULL;\n\t\telse\n\t\t\treturn dst;\n\t}\n\n\terr = xfrm_decode_session_reverse(skb, flowi6_to_flowi(&fl2), AF_INET6);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\terr = ip6_dst_lookup(net, sk, &dst2, &fl2);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tdst2 = xfrm_lookup(net, dst2, flowi6_to_flowi(&fl2), sk, XFRM_LOOKUP_ICMP);\n\tif (!IS_ERR(dst2)) {\n\t\tdst_release(dst);\n\t\tdst = dst2;\n\t} else {\n\t\terr = PTR_ERR(dst2);\n\t\tif (err == -EPERM) {\n\t\t\tdst_release(dst);\n\t\t\treturn dst2;\n\t\t} else\n\t\t\tgoto relookup_failed;\n\t}\n\nrelookup_failed:\n\tif (dst)\n\t\treturn dst;\n\treturn ERR_PTR(err);\n}\n\n/*\n *\tSend an ICMP message in response to a packet in error\n */\nstatic void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info,\n\t\t       const struct in6_addr *force_saddr)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct inet6_dev *idev = NULL;\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct sock *sk;\n\tstruct ipv6_pinfo *np;\n\tconst struct in6_addr *saddr = NULL;\n\tstruct dst_entry *dst;\n\tstruct icmp6hdr tmp_hdr;\n\tstruct flowi6 fl6;\n\tstruct icmpv6_msg msg;\n\tstruct sockcm_cookie sockc_unused = {0};\n\tstruct ipcm6_cookie ipc6;\n\tint iif = 0;\n\tint addr_type = 0;\n\tint len;\n\tint err = 0;\n\tu32 mark = IP6_REPLY_MARK(net, skb->mark);\n\n\tif ((u8 *)hdr < skb->head ||\n\t    (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb))\n\t\treturn;\n\n\t/*\n\t *\tMake sure we respect the rules\n\t *\ti.e. RFC 1885 2.4(e)\n\t *\tRule (e.1) is enforced by not using icmp6_send\n\t *\tin any code that processes icmp errors.\n\t */\n\taddr_type = ipv6_addr_type(&hdr->daddr);\n\n\tif (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) ||\n\t    ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr))\n\t\tsaddr = &hdr->daddr;\n\n\t/*\n\t *\tDest addr check\n\t */\n\n\tif (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) {\n\t\tif (type != ICMPV6_PKT_TOOBIG &&\n\t\t    !(type == ICMPV6_PARAMPROB &&\n\t\t      code == ICMPV6_UNK_OPTION &&\n\t\t      (opt_unrec(skb, info))))\n\t\t\treturn;\n\n\t\tsaddr = NULL;\n\t}\n\n\taddr_type = ipv6_addr_type(&hdr->saddr);\n\n\t/*\n\t *\tSource addr check\n\t */\n\n\tif (__ipv6_addr_needs_scope_id(addr_type))\n\t\tiif = skb->dev->ifindex;\n\telse {\n\t\tdst = skb_dst(skb);\n\t\tiif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev);\n\t}\n\n\t/*\n\t *\tMust not send error if the source does not uniquely\n\t *\tidentify a single node (RFC2463 Section 2.4).\n\t *\tWe check unspecified / multicast addresses here,\n\t *\tand anycast addresses will be checked later.\n\t */\n\tif ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\t/*\n\t *\tNever answer to a ICMP packet.\n\t */\n\tif (is_ineligible(skb)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: no reply to icmp error [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\tmip6_addr_swap(skb);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_ICMPV6;\n\tfl6.daddr = hdr->saddr;\n\tif (force_saddr)\n\t\tsaddr = force_saddr;\n\tif (saddr)\n\t\tfl6.saddr = *saddr;\n\tfl6.flowi6_mark = mark;\n\tfl6.flowi6_oif = iif;\n\tfl6.fl6_icmp_type = type;\n\tfl6.fl6_icmp_code = code;\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\tsk = icmpv6_xmit_lock(net);\n\tif (!sk)\n\t\treturn;\n\tsk->sk_mark = mark;\n\tnp = inet6_sk(sk);\n\n\tif (!icmpv6_xrlim_allow(sk, type, &fl6))\n\t\tgoto out;\n\n\ttmp_hdr.icmp6_type = type;\n\ttmp_hdr.icmp6_code = code;\n\ttmp_hdr.icmp6_cksum = 0;\n\ttmp_hdr.icmp6_pointer = htonl(info);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tipc6.tclass = np->tclass;\n\tfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\n\n\tdst = icmpv6_route_lookup(net, skb, sk, &fl6);\n\tif (IS_ERR(dst))\n\t\tgoto out;\n\n\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\tipc6.dontfrag = np->dontfrag;\n\tipc6.opt = NULL;\n\n\tmsg.skb = skb;\n\tmsg.offset = skb_network_offset(skb);\n\tmsg.type = type;\n\n\tlen = skb->len - msg.offset;\n\tlen = min_t(unsigned int, len, IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(struct icmp6hdr));\n\tif (len < 0) {\n\t\tnet_dbg_ratelimited(\"icmp: len problem [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\tgoto out_dst_release;\n\t}\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(skb->dev);\n\n\terr = ip6_append_data(sk, icmpv6_getfrag, &msg,\n\t\t\t      len + sizeof(struct icmp6hdr),\n\t\t\t      sizeof(struct icmp6hdr),\n\t\t\t      &ipc6, &fl6, (struct rt6_info *)dst,\n\t\t\t      MSG_DONTWAIT, &sockc_unused);\n\tif (err) {\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);\n\t\tip6_flush_pending_frames(sk);\n\t} else {\n\t\terr = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr,\n\t\t\t\t\t\t len + sizeof(struct icmp6hdr));\n\t}\n\trcu_read_unlock();\nout_dst_release:\n\tdst_release(dst);\nout:\n\ticmpv6_xmit_unlock(sk);\n}\n\n/* Slightly more convenient version of icmp6_send.\n */\nvoid icmpv6_param_prob(struct sk_buff *skb, u8 code, int pos)\n{\n\ticmp6_send(skb, ICMPV6_PARAMPROB, code, pos, NULL);\n\tkfree_skb(skb);\n}\n\n/* Generate icmpv6 with type/code ICMPV6_DEST_UNREACH/ICMPV6_ADDR_UNREACH\n * if sufficient data bytes are available\n * @nhs is the size of the tunnel header(s) :\n *  Either an IPv4 header for SIT encap\n *         an IPv4 header + GRE header for GRE encap\n */\nint ip6_err_gen_icmpv6_unreach(struct sk_buff *skb, int nhs, int type,\n\t\t\t       unsigned int data_len)\n{\n\tstruct in6_addr temp_saddr;\n\tstruct rt6_info *rt;\n\tstruct sk_buff *skb2;\n\tu32 info = 0;\n\n\tif (!pskb_may_pull(skb, nhs + sizeof(struct ipv6hdr) + 8))\n\t\treturn 1;\n\n\t/* RFC 4884 (partial) support for ICMP extensions */\n\tif (data_len < 128 || (data_len & 7) || skb->len < data_len)\n\t\tdata_len = 0;\n\n\tskb2 = data_len ? skb_copy(skb, GFP_ATOMIC) : skb_clone(skb, GFP_ATOMIC);\n\n\tif (!skb2)\n\t\treturn 1;\n\n\tskb_dst_drop(skb2);\n\tskb_pull(skb2, nhs);\n\tskb_reset_network_header(skb2);\n\n\trt = rt6_lookup(dev_net(skb->dev), &ipv6_hdr(skb2)->saddr, NULL, 0, 0);\n\n\tif (rt && rt->dst.dev)\n\t\tskb2->dev = rt->dst.dev;\n\n\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr, &temp_saddr);\n\n\tif (data_len) {\n\t\t/* RFC 4884 (partial) support :\n\t\t * insert 0 padding at the end, before the extensions\n\t\t */\n\t\t__skb_push(skb2, nhs);\n\t\tskb_reset_network_header(skb2);\n\t\tmemmove(skb2->data, skb2->data + nhs, data_len - nhs);\n\t\tmemset(skb2->data + data_len - nhs, 0, nhs);\n\t\t/* RFC 4884 4.5 : Length is measured in 64-bit words,\n\t\t * and stored in reserved[0]\n\t\t */\n\t\tinfo = (data_len/8) << 24;\n\t}\n\tif (type == ICMP_TIME_EXCEEDED)\n\t\ticmp6_send(skb2, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT,\n\t\t\t   info, &temp_saddr);\n\telse\n\t\ticmp6_send(skb2, ICMPV6_DEST_UNREACH, ICMPV6_ADDR_UNREACH,\n\t\t\t   info, &temp_saddr);\n\tif (rt)\n\t\tip6_rt_put(rt);\n\n\tkfree_skb(skb2);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ip6_err_gen_icmpv6_unreach);\n\nstatic void icmpv6_echo_reply(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tstruct inet6_dev *idev;\n\tstruct ipv6_pinfo *np;\n\tconst struct in6_addr *saddr = NULL;\n\tstruct icmp6hdr *icmph = icmp6_hdr(skb);\n\tstruct icmp6hdr tmp_hdr;\n\tstruct flowi6 fl6;\n\tstruct icmpv6_msg msg;\n\tstruct dst_entry *dst;\n\tstruct ipcm6_cookie ipc6;\n\tint err = 0;\n\tu32 mark = IP6_REPLY_MARK(net, skb->mark);\n\tstruct sockcm_cookie sockc_unused = {0};\n\n\tsaddr = &ipv6_hdr(skb)->daddr;\n\n\tif (!ipv6_unicast_destination(skb) &&\n\t    !(net->ipv6.sysctl.anycast_src_echo_reply &&\n\t      ipv6_anycast_destination(skb_dst(skb), saddr)))\n\t\tsaddr = NULL;\n\n\tmemcpy(&tmp_hdr, icmph, sizeof(tmp_hdr));\n\ttmp_hdr.icmp6_type = ICMPV6_ECHO_REPLY;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_ICMPV6;\n\tfl6.daddr = ipv6_hdr(skb)->saddr;\n\tif (saddr)\n\t\tfl6.saddr = *saddr;\n\tfl6.flowi6_oif = skb->dev->ifindex;\n\tfl6.fl6_icmp_type = ICMPV6_ECHO_REPLY;\n\tfl6.flowi6_mark = mark;\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\tsk = icmpv6_xmit_lock(net);\n\tif (!sk)\n\t\treturn;\n\tsk->sk_mark = mark;\n\tnp = inet6_sk(sk);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\terr = ip6_dst_lookup(net, sk, &dst, &fl6);\n\tif (err)\n\t\tgoto out;\n\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), sk, 0);\n\tif (IS_ERR(dst))\n\t\tgoto out;\n\n\tidev = __in6_dev_get(skb->dev);\n\n\tmsg.skb = skb;\n\tmsg.offset = 0;\n\tmsg.type = ICMPV6_ECHO_REPLY;\n\n\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\tipc6.tclass = ipv6_get_dsfield(ipv6_hdr(skb));\n\tipc6.dontfrag = np->dontfrag;\n\tipc6.opt = NULL;\n\n\terr = ip6_append_data(sk, icmpv6_getfrag, &msg, skb->len + sizeof(struct icmp6hdr),\n\t\t\t\tsizeof(struct icmp6hdr), &ipc6, &fl6,\n\t\t\t\t(struct rt6_info *)dst, MSG_DONTWAIT,\n\t\t\t\t&sockc_unused);\n\n\tif (err) {\n\t\t__ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);\n\t\tip6_flush_pending_frames(sk);\n\t} else {\n\t\terr = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr,\n\t\t\t\t\t\t skb->len + sizeof(struct icmp6hdr));\n\t}\n\tdst_release(dst);\nout:\n\ticmpv6_xmit_unlock(sk);\n}\n\nvoid icmpv6_notify(struct sk_buff *skb, u8 type, u8 code, __be32 info)\n{\n\tconst struct inet6_protocol *ipprot;\n\tint inner_offset;\n\t__be16 frag_off;\n\tu8 nexthdr;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\n\tnexthdr = ((struct ipv6hdr *)skb->data)->nexthdr;\n\tif (ipv6_ext_hdr(nexthdr)) {\n\t\t/* now skip over extension headers */\n\t\tinner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr),\n\t\t\t\t\t\t&nexthdr, &frag_off);\n\t\tif (inner_offset < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tinner_offset = sizeof(struct ipv6hdr);\n\t}\n\n\t/* Checkin header including 8 bytes of inner protocol header. */\n\tif (!pskb_may_pull(skb, inner_offset+8))\n\t\tgoto out;\n\n\t/* BUGGG_FUTURE: we should try to parse exthdrs in this packet.\n\t   Without this we will not able f.e. to make source routed\n\t   pmtu discovery.\n\t   Corresponding argument (opt) to notifiers is already added.\n\t   --ANK (980726)\n\t */\n\n\tipprot = rcu_dereference(inet6_protos[nexthdr]);\n\tif (ipprot && ipprot->err_handler)\n\t\tipprot->err_handler(skb, NULL, type, code, inner_offset, info);\n\n\traw6_icmp_error(skb, nexthdr, type, code, inner_offset, info);\n\treturn;\n\nout:\n\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev), ICMP6_MIB_INERRORS);\n}\n\n/*\n *\tHandle icmp messages\n */\n\nstatic int icmpv6_rcv(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct icmp6hdr *hdr;\n\tu8 type;\n\tbool success = false;\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tstruct sec_path *sp = skb_sec_path(skb);\n\t\tint nh;\n\n\t\tif (!(sp && sp->xvec[sp->len - 1]->props.flags &\n\t\t\t\t XFRM_STATE_ICMP))\n\t\t\tgoto drop_no_count;\n\n\t\tif (!pskb_may_pull(skb, sizeof(*hdr) + sizeof(struct ipv6hdr)))\n\t\t\tgoto drop_no_count;\n\n\t\tnh = skb_network_offset(skb);\n\t\tskb_set_network_header(skb, sizeof(*hdr));\n\n\t\tif (!xfrm6_policy_check_reverse(NULL, XFRM_POLICY_IN, skb))\n\t\t\tgoto drop_no_count;\n\n\t\tskb_set_network_header(skb, nh);\n\t}\n\n\t__ICMP6_INC_STATS(dev_net(dev), idev, ICMP6_MIB_INMSGS);\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\n\tif (skb_checksum_validate(skb, IPPROTO_ICMPV6, ip6_compute_pseudo)) {\n\t\tnet_dbg_ratelimited(\"ICMPv6 checksum failed [%pI6c > %pI6c]\\n\",\n\t\t\t\t    saddr, daddr);\n\t\tgoto csum_error;\n\t}\n\n\tif (!pskb_pull(skb, sizeof(*hdr)))\n\t\tgoto discard_it;\n\n\thdr = icmp6_hdr(skb);\n\n\ttype = hdr->icmp6_type;\n\n\tICMP6MSGIN_INC_STATS(dev_net(dev), idev, type);\n\n\tswitch (type) {\n\tcase ICMPV6_ECHO_REQUEST:\n\t\ticmpv6_echo_reply(skb);\n\t\tbreak;\n\n\tcase ICMPV6_ECHO_REPLY:\n\t\tsuccess = ping_rcv(skb);\n\t\tbreak;\n\n\tcase ICMPV6_PKT_TOOBIG:\n\t\t/* BUGGG_FUTURE: if packet contains rthdr, we cannot update\n\t\t   standard destination cache. Seems, only \"advanced\"\n\t\t   destination cache will allow to solve this problem\n\t\t   --ANK (980726)\n\t\t */\n\t\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\t\tgoto discard_it;\n\t\thdr = icmp6_hdr(skb);\n\n\t\t/*\n\t\t *\tDrop through to notify\n\t\t */\n\n\tcase ICMPV6_DEST_UNREACH:\n\tcase ICMPV6_TIME_EXCEED:\n\tcase ICMPV6_PARAMPROB:\n\t\ticmpv6_notify(skb, type, hdr->icmp6_code, hdr->icmp6_mtu);\n\t\tbreak;\n\n\tcase NDISC_ROUTER_SOLICITATION:\n\tcase NDISC_ROUTER_ADVERTISEMENT:\n\tcase NDISC_NEIGHBOUR_SOLICITATION:\n\tcase NDISC_NEIGHBOUR_ADVERTISEMENT:\n\tcase NDISC_REDIRECT:\n\t\tndisc_rcv(skb);\n\t\tbreak;\n\n\tcase ICMPV6_MGM_QUERY:\n\t\tigmp6_event_query(skb);\n\t\tbreak;\n\n\tcase ICMPV6_MGM_REPORT:\n\t\tigmp6_event_report(skb);\n\t\tbreak;\n\n\tcase ICMPV6_MGM_REDUCTION:\n\tcase ICMPV6_NI_QUERY:\n\tcase ICMPV6_NI_REPLY:\n\tcase ICMPV6_MLD2_REPORT:\n\tcase ICMPV6_DHAAD_REQUEST:\n\tcase ICMPV6_DHAAD_REPLY:\n\tcase ICMPV6_MOBILE_PREFIX_SOL:\n\tcase ICMPV6_MOBILE_PREFIX_ADV:\n\t\tbreak;\n\n\tdefault:\n\t\t/* informational */\n\t\tif (type & ICMPV6_INFOMSG_MASK)\n\t\t\tbreak;\n\n\t\tnet_dbg_ratelimited(\"icmpv6: msg of unknown type [%pI6c > %pI6c]\\n\",\n\t\t\t\t    saddr, daddr);\n\n\t\t/*\n\t\t * error of unknown type.\n\t\t * must pass to upper level\n\t\t */\n\n\t\ticmpv6_notify(skb, type, hdr->icmp6_code, hdr->icmp6_mtu);\n\t}\n\n\t/* until the v6 path can be better sorted assume failure and\n\t * preserve the status quo behaviour for the rest of the paths to here\n\t */\n\tif (success)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\n\treturn 0;\n\ncsum_error:\n\t__ICMP6_INC_STATS(dev_net(dev), idev, ICMP6_MIB_CSUMERRORS);\ndiscard_it:\n\t__ICMP6_INC_STATS(dev_net(dev), idev, ICMP6_MIB_INERRORS);\ndrop_no_count:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nvoid icmpv6_flow_init(struct sock *sk, struct flowi6 *fl6,\n\t\t      u8 type,\n\t\t      const struct in6_addr *saddr,\n\t\t      const struct in6_addr *daddr,\n\t\t      int oif)\n{\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->saddr = *saddr;\n\tfl6->daddr = *daddr;\n\tfl6->flowi6_proto\t= IPPROTO_ICMPV6;\n\tfl6->fl6_icmp_type\t= type;\n\tfl6->fl6_icmp_code\t= 0;\n\tfl6->flowi6_oif\t\t= oif;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n}\n\nstatic int __net_init icmpv6_sk_init(struct net *net)\n{\n\tstruct sock *sk;\n\tint err, i, j;\n\n\tnet->ipv6.icmp_sk =\n\t\tkzalloc(nr_cpu_ids * sizeof(struct sock *), GFP_KERNEL);\n\tif (!net->ipv6.icmp_sk)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(i) {\n\t\terr = inet_ctl_sock_create(&sk, PF_INET6,\n\t\t\t\t\t   SOCK_RAW, IPPROTO_ICMPV6, net);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"Failed to initialize the ICMP6 control socket (err %d)\\n\",\n\t\t\t       err);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnet->ipv6.icmp_sk[i] = sk;\n\n\t\t/* Enough space for 2 64K ICMP packets, including\n\t\t * sk_buff struct overhead.\n\t\t */\n\t\tsk->sk_sndbuf = 2 * SKB_TRUESIZE(64 * 1024);\n\t}\n\treturn 0;\n\n fail:\n\tfor (j = 0; j < i; j++)\n\t\tinet_ctl_sock_destroy(net->ipv6.icmp_sk[j]);\n\tkfree(net->ipv6.icmp_sk);\n\treturn err;\n}\n\nstatic void __net_exit icmpv6_sk_exit(struct net *net)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tinet_ctl_sock_destroy(net->ipv6.icmp_sk[i]);\n\t}\n\tkfree(net->ipv6.icmp_sk);\n}\n\nstatic struct pernet_operations icmpv6_sk_ops = {\n\t.init = icmpv6_sk_init,\n\t.exit = icmpv6_sk_exit,\n};\n\nint __init icmpv6_init(void)\n{\n\tint err;\n\n\terr = register_pernet_subsys(&icmpv6_sk_ops);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EAGAIN;\n\tif (inet6_add_protocol(&icmpv6_protocol, IPPROTO_ICMPV6) < 0)\n\t\tgoto fail;\n\n\terr = inet6_register_icmp_sender(icmp6_send);\n\tif (err)\n\t\tgoto sender_reg_err;\n\treturn 0;\n\nsender_reg_err:\n\tinet6_del_protocol(&icmpv6_protocol, IPPROTO_ICMPV6);\nfail:\n\tpr_err(\"Failed to register ICMP6 protocol\\n\");\n\tunregister_pernet_subsys(&icmpv6_sk_ops);\n\treturn err;\n}\n\nvoid icmpv6_cleanup(void)\n{\n\tinet6_unregister_icmp_sender(icmp6_send);\n\tunregister_pernet_subsys(&icmpv6_sk_ops);\n\tinet6_del_protocol(&icmpv6_protocol, IPPROTO_ICMPV6);\n}\n\n\nstatic const struct icmp6_err {\n\tint err;\n\tint fatal;\n} tab_unreach[] = {\n\t{\t/* NOROUTE */\n\t\t.err\t= ENETUNREACH,\n\t\t.fatal\t= 0,\n\t},\n\t{\t/* ADM_PROHIBITED */\n\t\t.err\t= EACCES,\n\t\t.fatal\t= 1,\n\t},\n\t{\t/* Was NOT_NEIGHBOUR, now reserved */\n\t\t.err\t= EHOSTUNREACH,\n\t\t.fatal\t= 0,\n\t},\n\t{\t/* ADDR_UNREACH\t*/\n\t\t.err\t= EHOSTUNREACH,\n\t\t.fatal\t= 0,\n\t},\n\t{\t/* PORT_UNREACH\t*/\n\t\t.err\t= ECONNREFUSED,\n\t\t.fatal\t= 1,\n\t},\n\t{\t/* POLICY_FAIL */\n\t\t.err\t= EACCES,\n\t\t.fatal\t= 1,\n\t},\n\t{\t/* REJECT_ROUTE\t*/\n\t\t.err\t= EACCES,\n\t\t.fatal\t= 1,\n\t},\n};\n\nint icmpv6_err_convert(u8 type, u8 code, int *err)\n{\n\tint fatal = 0;\n\n\t*err = EPROTO;\n\n\tswitch (type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tfatal = 1;\n\t\tif (code < ARRAY_SIZE(tab_unreach)) {\n\t\t\t*err  = tab_unreach[code].err;\n\t\t\tfatal = tab_unreach[code].fatal;\n\t\t}\n\t\tbreak;\n\n\tcase ICMPV6_PKT_TOOBIG:\n\t\t*err = EMSGSIZE;\n\t\tbreak;\n\n\tcase ICMPV6_PARAMPROB:\n\t\t*err = EPROTO;\n\t\tfatal = 1;\n\t\tbreak;\n\n\tcase ICMPV6_TIME_EXCEED:\n\t\t*err = EHOSTUNREACH;\n\t\tbreak;\n\t}\n\n\treturn fatal;\n}\nEXPORT_SYMBOL(icmpv6_err_convert);\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table ipv6_icmp_table_template[] = {\n\t{\n\t\t.procname\t= \"ratelimit\",\n\t\t.data\t\t= &init_net.ipv6.sysctl.icmpv6_time,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_ms_jiffies,\n\t},\n\t{ },\n};\n\nstruct ctl_table * __net_init ipv6_icmp_sysctl_init(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = kmemdup(ipv6_icmp_table_template,\n\t\t\tsizeof(ipv6_icmp_table_template),\n\t\t\tGFP_KERNEL);\n\n\tif (table)\n\t\ttable[0].data = &net->ipv6.sysctl.icmpv6_time;\n\n\treturn table;\n}\n#endif\n"], "filenames": ["net/ipv6/icmp.c"], "buggy_code_start_loc": [450], "buggy_code_end_loc": [452], "fixing_code_start_loc": [450], "fixing_code_end_loc": [454], "type": "CWE-20", "message": "The icmp6_send function in net/ipv6/icmp.c in the Linux kernel through 4.8.12 omits a certain check of the dst data structure, which allows remote attackers to cause a denial of service (panic) via a fragmented IPv6 packet.", "other": {"cve": {"id": "CVE-2016-9919", "sourceIdentifier": "cve@mitre.org", "published": "2016-12-08T17:59:03.867", "lastModified": "2023-01-24T15:07:11.217", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The icmp6_send function in net/ipv6/icmp.c in the Linux kernel through 4.8.12 omits a certain check of the dst data structure, which allows remote attackers to cause a denial of service (panic) via a fragmented IPv6 packet."}, {"lang": "es", "value": "La funci\u00f3n icmp6_send en net/ipv6/icmp.c en el kernel de Linux hasta la versi\u00f3n 4.8.12 omite una cierta comprobaci\u00f3n de la estructura de datos dst, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (p\u00e1nico) a trav\u00e9s de un paquete IPv6 fragmentado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.8.10", "versionEndExcluding": "4.9", "matchCriteriaId": "EAE5E41F-3A03-48A1-92EA-69733E806CD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.4.223:*:*:*:*:*:*:*", "matchCriteriaId": "702D72F9-8C90-4514-B995-AD978ED38DCD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "B0288B1E-67AB-40F4-98C7-8C686510F664"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "73A5C6E1-051D-4FDC-8034-BE2896C639F3"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/08/15", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94824", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2"}}