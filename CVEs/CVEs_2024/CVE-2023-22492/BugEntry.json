{"buggy_code": ["package command\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/zitadel/logging\"\n\n\t\"github.com/zitadel/zitadel/internal/api/authz\"\n\t\"github.com/zitadel/zitadel/internal/command/preparation\"\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\t\"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/eventstore/v1/models\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n\t\"github.com/zitadel/zitadel/internal/telemetry/tracing\"\n)\n\nfunc (c *Commands) ChangeUsername(ctx context.Context, orgID, userID, userName string) (*domain.ObjectDetails, error) {\n\tuserName = strings.TrimSpace(userName)\n\tif orgID == \"\" || userID == \"\" || userName == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-2N9fs\", \"Errors.IDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-5N9ds\", \"Errors.User.NotFound\")\n\t}\n\n\tif existingUser.UserName == userName {\n\t\treturn nil, errors.ThrowPreconditionFailed(nil, \"COMMAND-6m9gs\", \"Errors.User.UsernameNotChanged\")\n\t}\n\n\tdomainPolicy, err := c.getOrgDomainPolicy(ctx, orgID)\n\tif err != nil {\n\t\treturn nil, errors.ThrowPreconditionFailed(err, \"COMMAND-38fnu\", \"Errors.Org.DomainPolicy.NotExisting\")\n\t}\n\n\tif err := CheckDomainPolicyForUserName(userName, domainPolicy); err != nil {\n\t\treturn nil, err\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&existingUser.WriteModel)\n\n\tpushedEvents, err := c.eventstore.Push(ctx,\n\t\tuser.NewUsernameChangedEvent(ctx, userAgg, existingUser.UserName, userName, domainPolicy.UserLoginMustBeDomain))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) DeactivateUser(ctx context.Context, userID, resourceOwner string) (*domain.ObjectDetails, error) {\n\tif userID == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-m0gDf\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-3M9ds\", \"Errors.User.NotFound\")\n\t}\n\tif isUserStateInitial(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-ke0fw\", \"Errors.User.CantDeactivateInitial\")\n\t}\n\tif isUserStateInactive(existingUser.UserState) {\n\t\treturn nil, errors.ThrowPreconditionFailed(nil, \"COMMAND-5M0sf\", \"Errors.User.AlreadyInactive\")\n\t}\n\n\tpushedEvents, err := c.eventstore.Push(ctx,\n\t\tuser.NewUserDeactivatedEvent(ctx, UserAggregateFromWriteModel(&existingUser.WriteModel)))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) ReactivateUser(ctx context.Context, userID, resourceOwner string) (*domain.ObjectDetails, error) {\n\tif userID == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-4M9ds\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-4M0sd\", \"Errors.User.NotFound\")\n\t}\n\tif !isUserStateInactive(existingUser.UserState) {\n\t\treturn nil, errors.ThrowPreconditionFailed(nil, \"COMMAND-6M0sf\", \"Errors.User.NotInactive\")\n\t}\n\n\tpushedEvents, err := c.eventstore.Push(ctx,\n\t\tuser.NewUserReactivatedEvent(ctx, UserAggregateFromWriteModel(&existingUser.WriteModel)))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) LockUser(ctx context.Context, userID, resourceOwner string) (*domain.ObjectDetails, error) {\n\tif userID == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-2M0sd\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-5M9fs\", \"Errors.User.NotFound\")\n\t}\n\tif !hasUserState(existingUser.UserState, domain.UserStateActive, domain.UserStateInitial) {\n\t\treturn nil, errors.ThrowPreconditionFailed(nil, \"COMMAND-3NN8v\", \"Errors.User.ShouldBeActiveOrInitial\")\n\t}\n\n\tpushedEvents, err := c.eventstore.Push(ctx,\n\t\tuser.NewUserLockedEvent(ctx, UserAggregateFromWriteModel(&existingUser.WriteModel)))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) UnlockUser(ctx context.Context, userID, resourceOwner string) (*domain.ObjectDetails, error) {\n\tif userID == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-M0dse\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-M0dos\", \"Errors.User.NotFound\")\n\t}\n\tif !hasUserState(existingUser.UserState, domain.UserStateLocked) {\n\t\treturn nil, errors.ThrowPreconditionFailed(nil, \"COMMAND-4M0ds\", \"Errors.User.NotLocked\")\n\t}\n\n\tpushedEvents, err := c.eventstore.Push(ctx,\n\t\tuser.NewUserUnlockedEvent(ctx, UserAggregateFromWriteModel(&existingUser.WriteModel)))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) RemoveUser(ctx context.Context, userID, resourceOwner string, cascadingUserMemberships []*CascadingMembership, cascadingGrantIDs ...string) (*domain.ObjectDetails, error) {\n\tif userID == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-2M0ds\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-m9od\", \"Errors.User.NotFound\")\n\t}\n\n\tdomainPolicy, err := c.getOrgDomainPolicy(ctx, existingUser.ResourceOwner)\n\tif err != nil {\n\t\treturn nil, errors.ThrowPreconditionFailed(err, \"COMMAND-3M9fs\", \"Errors.Org.DomainPolicy.NotExisting\")\n\t}\n\tvar events []eventstore.Command\n\tuserAgg := UserAggregateFromWriteModel(&existingUser.WriteModel)\n\tevents = append(events, user.NewUserRemovedEvent(ctx, userAgg, existingUser.UserName, existingUser.IDPLinks, domainPolicy.UserLoginMustBeDomain))\n\n\tfor _, grantID := range cascadingGrantIDs {\n\t\tremoveEvent, _, err := c.removeUserGrant(ctx, grantID, \"\", true)\n\t\tif err != nil {\n\t\t\tlogging.WithFields(\"usergrantid\", grantID).WithError(err).Warn(\"could not cascade remove role on user grant\")\n\t\t\tcontinue\n\t\t}\n\t\tevents = append(events, removeEvent)\n\t}\n\n\tif len(cascadingUserMemberships) > 0 {\n\t\tmembershipEvents, err := c.removeUserMemberships(ctx, cascadingUserMemberships)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tevents = append(events, membershipEvents...)\n\t}\n\n\tpushedEvents, err := c.eventstore.Push(ctx, events...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) AddUserToken(ctx context.Context, orgID, agentID, clientID, userID string, audience, scopes []string, lifetime time.Duration) (*domain.Token, error) {\n\tif userID == \"\" { //do not check for empty orgID (JWT Profile requests won't provide it, so service user requests fail)\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-Dbge4\", \"Errors.IDMissing\")\n\t}\n\tuserWriteModel := NewUserWriteModel(userID, orgID)\n\tevent, accessToken, err := c.addUserToken(ctx, userWriteModel, agentID, clientID, \"\", audience, scopes, lifetime)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_, err = c.eventstore.Push(ctx, event)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn accessToken, nil\n}\n\nfunc (c *Commands) RevokeAccessToken(ctx context.Context, userID, orgID, tokenID string) (*domain.ObjectDetails, error) {\n\tremoveEvent, accessTokenWriteModel, err := c.removeAccessToken(ctx, userID, orgID, tokenID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tevents, err := c.eventstore.Push(ctx, removeEvent)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(accessTokenWriteModel, events...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&accessTokenWriteModel.WriteModel), nil\n}\n\nfunc (c *Commands) addUserToken(ctx context.Context, userWriteModel *UserWriteModel, agentID, clientID, refreshTokenID string, audience, scopes []string, lifetime time.Duration) (*user.UserTokenAddedEvent, *domain.Token, error) {\n\terr := c.eventstore.FilterToQueryReducer(ctx, userWriteModel)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif !isUserStateExists(userWriteModel.UserState) {\n\t\treturn nil, nil, errors.ThrowNotFound(nil, \"COMMAND-1d6Gg\", \"Errors.User.NotFound\")\n\t}\n\n\taudience = domain.AddAudScopeToAudience(ctx, audience, scopes)\n\n\tpreferredLanguage := \"\"\n\texistingHuman, err := c.getHumanWriteModelByID(ctx, userWriteModel.AggregateID, userWriteModel.ResourceOwner)\n\tif existingHuman != nil {\n\t\tpreferredLanguage = existingHuman.PreferredLanguage.String()\n\t}\n\texpiration := time.Now().UTC().Add(lifetime)\n\ttokenID, err := c.idGenerator.Next()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tuserAgg := UserAggregateFromWriteModel(&userWriteModel.WriteModel)\n\treturn user.NewUserTokenAddedEvent(ctx, userAgg, tokenID, clientID, agentID, preferredLanguage, refreshTokenID, audience, scopes, expiration),\n\t\t&domain.Token{\n\t\t\tObjectRoot: models.ObjectRoot{\n\t\t\t\tAggregateID: userWriteModel.AggregateID,\n\t\t\t},\n\t\t\tTokenID:           tokenID,\n\t\t\tUserAgentID:       agentID,\n\t\t\tApplicationID:     clientID,\n\t\t\tRefreshTokenID:    refreshTokenID,\n\t\t\tAudience:          audience,\n\t\t\tScopes:            scopes,\n\t\t\tExpiration:        expiration,\n\t\t\tPreferredLanguage: preferredLanguage,\n\t\t}, nil\n}\n\nfunc (c *Commands) removeAccessToken(ctx context.Context, userID, orgID, tokenID string) (*user.UserTokenRemovedEvent, *UserAccessTokenWriteModel, error) {\n\tif userID == \"\" || orgID == \"\" || tokenID == \"\" {\n\t\treturn nil, nil, errors.ThrowInvalidArgument(nil, \"COMMAND-Dng42\", \"Errors.IDMissing\")\n\t}\n\trefreshTokenWriteModel := NewUserAccessTokenWriteModel(userID, orgID, tokenID)\n\terr := c.eventstore.FilterToQueryReducer(ctx, refreshTokenWriteModel)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif refreshTokenWriteModel.UserState != domain.UserStateActive {\n\t\treturn nil, nil, errors.ThrowNotFound(nil, \"COMMAND-BF4hd\", \"Errors.User.AccessToken.NotFound\")\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&refreshTokenWriteModel.WriteModel)\n\treturn user.NewUserTokenRemovedEvent(ctx, userAgg, tokenID), refreshTokenWriteModel, nil\n}\n\nfunc (c *Commands) userDomainClaimed(ctx context.Context, userID string) (events []eventstore.Command, _ *UserWriteModel, err error) {\n\texistingUser, err := c.userWriteModelByID(ctx, userID, \"\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif existingUser.UserState == domain.UserStateUnspecified || existingUser.UserState == domain.UserStateDeleted {\n\t\treturn nil, nil, errors.ThrowNotFound(nil, \"COMMAND-ii9K0\", \"Errors.User.NotFound\")\n\t}\n\tchangedUserGrant := NewUserWriteModel(userID, existingUser.ResourceOwner)\n\tuserAgg := UserAggregateFromWriteModel(&changedUserGrant.WriteModel)\n\n\tdomainPolicy, err := c.getOrgDomainPolicy(ctx, existingUser.ResourceOwner)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tid, err := c.idGenerator.Next()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn []eventstore.Command{\n\t\tuser.NewDomainClaimedEvent(\n\t\t\tctx,\n\t\t\tuserAgg,\n\t\t\tfmt.Sprintf(\"%s@temporary.%s\", id, authz.GetInstance(ctx).RequestedDomain()),\n\t\t\texistingUser.UserName,\n\t\t\tdomainPolicy.UserLoginMustBeDomain),\n\t}, changedUserGrant, nil\n}\n\nfunc (c *Commands) prepareUserDomainClaimed(ctx context.Context, filter preparation.FilterToQueryReducer, userID string) (*user.DomainClaimedEvent, error) {\n\tuserWriteModel, err := userWriteModelByID(ctx, filter, userID, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !userWriteModel.UserState.Exists() {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-ii9K0\", \"Errors.User.NotFound\")\n\t}\n\tdomainPolicy, err := domainPolicyWriteModel(ctx, filter, userWriteModel.ResourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&userWriteModel.WriteModel)\n\n\tid, err := c.idGenerator.Next()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user.NewDomainClaimedEvent(\n\t\tctx,\n\t\tuserAgg,\n\t\tfmt.Sprintf(\"%s@temporary.%s\", id, authz.GetInstance(ctx).RequestedDomain()),\n\t\tuserWriteModel.UserName,\n\t\tdomainPolicy.UserLoginMustBeDomain), nil\n}\n\nfunc (c *Commands) UserDomainClaimedSent(ctx context.Context, orgID, userID string) (err error) {\n\tif userID == \"\" {\n\t\treturn errors.ThrowInvalidArgument(nil, \"COMMAND-5m0fs\", \"Errors.IDMissing\")\n\t}\n\texistingUser, err := c.userWriteModelByID(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn errors.ThrowNotFound(nil, \"COMMAND-5m9gK\", \"Errors.User.NotFound\")\n\t}\n\n\t_, err = c.eventstore.Push(ctx,\n\t\tuser.NewDomainClaimedSentEvent(ctx, UserAggregateFromWriteModel(&existingUser.WriteModel)))\n\treturn err\n}\n\nfunc (c *Commands) checkUserExists(ctx context.Context, userID, resourceOwner string) error {\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn errors.ThrowPreconditionFailed(nil, \"COMMAND-uXHNj\", \"Errors.User.NotFound\")\n\t}\n\treturn nil\n}\n\nfunc (c *Commands) userWriteModelByID(ctx context.Context, userID, resourceOwner string) (writeModel *UserWriteModel, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\twriteModel = NewUserWriteModel(userID, resourceOwner)\n\terr = c.eventstore.FilterToQueryReducer(ctx, writeModel)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModel, nil\n}\n\nfunc ExistsUser(ctx context.Context, filter preparation.FilterToQueryReducer, id, resourceOwner string) (exists bool, err error) {\n\tevents, err := filter(ctx, eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).\n\t\tResourceOwner(resourceOwner).\n\t\tOrderAsc().\n\t\tAddQuery().\n\t\tAggregateTypes(user.AggregateType).\n\t\tAggregateIDs(id).\n\t\tEventTypes(\n\t\t\tuser.HumanRegisteredType,\n\t\t\tuser.UserV1RegisteredType,\n\t\t\tuser.HumanAddedType,\n\t\t\tuser.UserV1AddedType,\n\t\t\tuser.MachineAddedEventType,\n\t\t\tuser.UserRemovedType,\n\t\t).Builder())\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, event := range events {\n\t\tswitch event.(type) {\n\t\tcase *user.HumanRegisteredEvent, *user.HumanAddedEvent, *user.MachineAddedEvent:\n\t\t\texists = true\n\t\tcase *user.UserRemovedEvent:\n\t\t\texists = false\n\t\t}\n\t}\n\n\treturn exists, nil\n}\n\nfunc newUserInitCode(ctx context.Context, filter preparation.FilterToQueryReducer, alg crypto.EncryptionAlgorithm) (value *crypto.CryptoValue, expiry time.Duration, err error) {\n\treturn newCryptoCodeWithExpiry(ctx, filter, domain.SecretGeneratorTypeInitCode, alg)\n}\n\nfunc userWriteModelByID(ctx context.Context, filter preparation.FilterToQueryReducer, userID, resourceOwner string) (*UserWriteModel, error) {\n\tuser := NewUserWriteModel(userID, resourceOwner)\n\tevents, err := filter(ctx, user.Query())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuser.AppendEvents(events...)\n\terr = user.Reduce()\n\treturn user, err\n}\n", "package command\n\nimport (\n\t\"time\"\n\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n)\n\ntype HumanRefreshTokenWriteModel struct {\n\teventstore.WriteModel\n\n\tTokenID      string\n\tRefreshToken string\n\n\tUserState      domain.UserState\n\tIdleExpiration time.Time\n\tExpiration     time.Time\n}\n\nfunc NewHumanRefreshTokenWriteModel(userID, resourceOwner, tokenID string) *HumanRefreshTokenWriteModel {\n\treturn &HumanRefreshTokenWriteModel{\n\t\tWriteModel: eventstore.WriteModel{\n\t\t\tAggregateID:   userID,\n\t\t\tResourceOwner: resourceOwner,\n\t\t},\n\t\tTokenID: tokenID,\n\t}\n}\n\nfunc (wm *HumanRefreshTokenWriteModel) AppendEvents(events ...eventstore.Event) {\n\tfor _, event := range events {\n\t\tswitch e := event.(type) {\n\t\tcase *user.HumanRefreshTokenAddedEvent:\n\t\t\tif wm.TokenID != e.TokenID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twm.WriteModel.AppendEvents(e)\n\t\tcase *user.HumanRefreshTokenRenewedEvent:\n\t\t\tif wm.TokenID != e.TokenID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twm.WriteModel.AppendEvents(e)\n\t\tcase *user.HumanRefreshTokenRemovedEvent:\n\t\t\tif wm.TokenID != e.TokenID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twm.WriteModel.AppendEvents(e)\n\t\t}\n\t}\n}\n\nfunc (wm *HumanRefreshTokenWriteModel) Reduce() error {\n\tfor _, event := range wm.Events {\n\t\tswitch e := event.(type) {\n\t\tcase *user.HumanRefreshTokenAddedEvent:\n\t\t\twm.TokenID = e.TokenID\n\t\t\twm.RefreshToken = e.TokenID\n\t\t\twm.IdleExpiration = e.CreationDate().Add(e.IdleExpiration)\n\t\t\twm.Expiration = e.CreationDate().Add(e.Expiration)\n\t\t\twm.UserState = domain.UserStateActive\n\t\tcase *user.HumanRefreshTokenRenewedEvent:\n\t\t\tif wm.UserState == domain.UserStateActive {\n\t\t\t\twm.RefreshToken = e.RefreshToken\n\t\t\t}\n\t\t\twm.RefreshToken = e.RefreshToken\n\t\t\twm.IdleExpiration = e.CreationDate().Add(e.IdleExpiration)\n\t\tcase *user.HumanRefreshTokenRemovedEvent,\n\t\t\t*user.HumanSignedOutEvent,\n\t\t\t*user.UserLockedEvent,\n\t\t\t*user.UserDeactivatedEvent,\n\t\t\t*user.UserRemovedEvent:\n\t\t\twm.UserState = domain.UserStateDeleted\n\t\t}\n\t}\n\treturn wm.WriteModel.Reduce()\n}\n\nfunc (wm *HumanRefreshTokenWriteModel) Query() *eventstore.SearchQueryBuilder {\n\tquery := eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).\n\t\tAddQuery().\n\t\tAggregateTypes(user.AggregateType).\n\t\tAggregateIDs(wm.AggregateID).\n\t\tEventTypes(\n\t\t\tuser.HumanRefreshTokenAddedType,\n\t\t\tuser.HumanRefreshTokenRenewedType,\n\t\t\tuser.HumanRefreshTokenRemovedType,\n\t\t\tuser.HumanSignedOutType,\n\t\t\tuser.UserLockedType,\n\t\t\tuser.UserDeactivatedType,\n\t\t\tuser.UserRemovedType).\n\t\tBuilder()\n\n\tif wm.ResourceOwner != \"\" {\n\t\tquery.ResourceOwner(wm.ResourceOwner)\n\t}\n\treturn query\n}\n", "package command\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/golang/mock/gomock\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/zitadel/oidc/v2/pkg/oidc\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\tcaos_errs \"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/eventstore/repository\"\n\t\"github.com/zitadel/zitadel/internal/eventstore/v1/models\"\n\t\"github.com/zitadel/zitadel/internal/id\"\n\tid_mock \"github.com/zitadel/zitadel/internal/id/mock\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n)\n\nfunc TestCommands_AddAccessAndRefreshToken(t *testing.T) {\n\ttype fields struct {\n\t\teventstore   *eventstore.Eventstore\n\t\tidGenerator  id.Generator\n\t\tkeyAlgorithm crypto.EncryptionAlgorithm\n\t}\n\ttype args struct {\n\t\tctx                   context.Context\n\t\torgID                 string\n\t\tagentID               string\n\t\tclientID              string\n\t\tuserID                string\n\t\trefreshToken          string\n\t\taudience              []string\n\t\tscopes                []string\n\t\tauthMethodsReferences []string\n\t\tlifetime              time.Duration\n\t\tauthTime              time.Time\n\t\trefreshIdleExpiration time.Duration\n\t\trefreshExpiration     time.Duration\n\t}\n\ttype res struct {\n\t\ttoken        *domain.Token\n\t\trefreshToken string\n\t\terr          func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"missing ID, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t),\n\t\t\t},\n\t\t\targs: args{},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"add refresh token, user inactive, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t\tidGenerator: id_mock.NewIDGeneratorExpectIDs(t, \"refreshTokenID1\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:      context.Background(),\n\t\t\t\torgID:    \"orgID\",\n\t\t\t\tagentID:  \"agentID\",\n\t\t\t\tuserID:   \"userID\",\n\t\t\t\tclientID: \"clientID\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsNotFound,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"renew refresh token, invalid token, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore:   eventstoreExpect(t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\trefreshToken: \"invalid\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"renew refresh token, invalid token (invalid userID), error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore:   eventstoreExpect(t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID2:tokenID:token\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"renew refresh token, token inactive, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:token\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"renew refresh token, token expired, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t-1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:tokenID\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t//fails because of timestamp equality\n\t\t//{\n\t\t//\tname: \"push failed, error\",\n\t\t//\tfields: fields{\n\t\t//\t\teventstore: eventstoreExpect(t,\n\t\t//\t\t\texpectFilter(\n\t\t//\t\t\t\teventFromEventPusher(user.NewHumanAddedEvent(\n\t\t//\t\t\t\t\tcontext.Background(),\n\t\t//\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t//\t\t\t\t\t\"username\",\n\t\t//\t\t\t\t\t\"firstname\",\n\t\t//\t\t\t\t\t\"lastname\",\n\t\t//\t\t\t\t\t\"nickname\",\n\t\t//\t\t\t\t\t\"displayname\",\n\t\t//\t\t\t\t\tlanguage.German,\n\t\t//\t\t\t\t\tdomain.GenderUnspecified,\n\t\t//\t\t\t\t\t\"email\",\n\t\t//\t\t\t\t\ttrue,\n\t\t//\t\t\t\t)),\n\t\t//\t\t\t),\n\t\t//\t\t\texpectFilter(\n\t\t//\t\t\t\teventFromEventPusherWithCreationDateNow(user.NewHumanAddedEvent(\n\t\t//\t\t\t\t\tcontext.Background(),\n\t\t//\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t//\t\t\t\t\t\"username\",\n\t\t//\t\t\t\t\t\"firstname\",\n\t\t//\t\t\t\t\t\"lastname\",\n\t\t//\t\t\t\t\t\"nickname\",\n\t\t//\t\t\t\t\t\"displayname\",\n\t\t//\t\t\t\t\tlanguage.German,\n\t\t//\t\t\t\t\tdomain.GenderUnspecified,\n\t\t//\t\t\t\t\t\"email\",\n\t\t//\t\t\t\t\ttrue,\n\t\t//\t\t\t\t)),\n\t\t//\t\t\t),\n\t\t//\t\t\texpectFilter(\n\t\t//\t\t\t\teventFromEventPusherWithCreationDateNow(user.NewHumanRefreshTokenAddedEvent(\n\t\t//\t\t\t\t\tcontext.Background(),\n\t\t//\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t//\t\t\t\t\t\"tokenID\",\n\t\t//\t\t\t\t\t\"applicationID\",\n\t\t//\t\t\t\t\t\"userAgentID\",\n\t\t//\t\t\t\t\t\"de\",\n\t\t//\t\t\t\t\t[]string{\"clientID1\"},\n\t\t//\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t//\t\t\t\t\t[]string{\"password\"},\n\t\t//\t\t\t\t\ttime.Now(),\n\t\t//\t\t\t\t\t1*time.Hour,\n\t\t//\t\t\t\t\t24*time.Hour,\n\t\t//\t\t\t\t)),\n\t\t//\t\t\t),\n\t\t//\t\t\texpectPushFailed(\n\t\t//\t\t\t\tcaos_errs.ThrowInternal(nil, \"ERROR\", \"internal\"),\n\t\t//\t\t\t\t[]*repository.Event{\n\t\t//\t\t\t\t\teventFromEventPusher(user.NewUserTokenAddedEvent(\n\t\t//\t\t\t\t\t\tcontext.Background(),\n\t\t//\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t//\t\t\t\t\t\t\"accessTokenID1\",\n\t\t//\t\t\t\t\t\t\"clientID\",\n\t\t//\t\t\t\t\t\t\"agentID\",\n\t\t//\t\t\t\t\t\t\"de\",\n\t\t//\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t//\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t//\t\t\t\t\t\ttime.Now().Add(5*time.Minute),\n\t\t//\t\t\t\t\t)),\n\t\t//\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRenewedEvent(\n\t\t//\t\t\t\t\t\tcontext.Background(),\n\t\t//\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t//\t\t\t\t\t\t\"tokenID\",\n\t\t//\t\t\t\t\t\t\"refreshToken1\",\n\t\t//\t\t\t\t\t\t1*time.Hour,\n\t\t//\t\t\t\t\t)),\n\t\t//\t\t\t\t},\n\t\t//\t\t\t),\n\t\t//\t\t),\n\t\t//\t\tidGenerator:  id_mock.NewIDGeneratorExpectIDs(t, \"accessTokenID1\", \"refreshToken1\"),\n\t\t//\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t//\t},\n\t\t//\targs: args{\n\t\t//\t\tctx:                   context.Background(),\n\t\t//\t\torgID:                 \"orgID\",\n\t\t//\t\tagentID:               \"agentID\",\n\t\t//\t\tclientID:              \"clientID\",\n\t\t//\t\tuserID:                \"userID\",\n\t\t//\t\trefreshToken:          base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:tokenID\")),\n\t\t//\t\taudience:              []string{\"clientID1\"},\n\t\t//\t\tscopes:                []string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t//\t\tauthMethodsReferences: []string{\"password\"},\n\t\t//\t\tlifetime:              5 * time.Minute,\n\t\t//\t\tauthTime:              time.Now(),\n\t\t//\t},\n\t\t//\tres: res{\n\t\t//\t\terr: caos_errs.IsInternal,\n\t\t//\t},\n\t\t//},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &Commands{\n\t\t\t\teventstore:   tt.fields.eventstore,\n\t\t\t\tidGenerator:  tt.fields.idGenerator,\n\t\t\t\tkeyAlgorithm: tt.fields.keyAlgorithm,\n\t\t\t}\n\t\t\tgot, gotRefresh, err := c.AddAccessAndRefreshToken(tt.args.ctx, tt.args.orgID, tt.args.agentID, tt.args.clientID, tt.args.userID, tt.args.refreshToken,\n\t\t\t\ttt.args.audience, tt.args.scopes, tt.args.authMethodsReferences, tt.args.lifetime, tt.args.refreshIdleExpiration, tt.args.refreshExpiration, tt.args.authTime)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.token, got)\n\t\t\t\tassert.Equal(t, tt.res.refreshToken, gotRefresh)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommands_RevokeRefreshToken(t *testing.T) {\n\ttype fields struct {\n\t\teventstore *eventstore.Eventstore\n\t}\n\ttype args struct {\n\t\tctx     context.Context\n\t\tuserID  string\n\t\torgID   string\n\t\ttokenID string\n\t}\n\ttype res struct {\n\t\twant *domain.ObjectDetails\n\t\terr  func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\t\"missing param, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t),\n\t\t\t},\n\t\t\targs{},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"token not active, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t\"tokenID\",\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsNotFound,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"push failed, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectPushFailed(caos_errs.ThrowInternal(nil, \"ERROR\", \"internal\"),\n\t\t\t\t\t\t[]*repository.Event{\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t\"tokenID\",\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsInternal,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"revoke, ok\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\t[]*repository.Event{\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t\"tokenID\",\n\t\t\t},\n\t\t\tres{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"orgID\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &Commands{\n\t\t\t\teventstore: tt.fields.eventstore,\n\t\t\t}\n\t\t\tgot, err := c.RevokeRefreshToken(tt.args.ctx, tt.args.userID, tt.args.orgID, tt.args.tokenID)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommands_RevokeRefreshTokens(t *testing.T) {\n\ttype fields struct {\n\t\teventstore *eventstore.Eventstore\n\t}\n\ttype args struct {\n\t\tctx      context.Context\n\t\tuserID   string\n\t\torgID    string\n\t\ttokenIDs []string\n\t}\n\ttype res struct {\n\t\terr func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\t\"missing tokenIDs, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\tnil,\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"one token not active, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t[]string{\"tokenID\", \"tokenID2\"},\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsNotFound,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"push failed, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID2\",\n\t\t\t\t\t\t\t\"clientID2\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID2\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectPushFailed(caos_errs.ThrowInternal(nil, \"ERROR\", \"internal\"),\n\t\t\t\t\t\t[]*repository.Event{\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID2\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t[]string{\"tokenID\", \"tokenID2\"},\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsInternal,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"revoke, ok\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID2\",\n\t\t\t\t\t\t\t\"clientID2\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID2\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\t[]*repository.Event{\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID2\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t[]string{\"tokenID\", \"tokenID2\"},\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &Commands{\n\t\t\t\teventstore: tt.fields.eventstore,\n\t\t\t}\n\t\t\terr := c.RevokeRefreshTokens(tt.args.ctx, tt.args.userID, tt.args.orgID, tt.args.tokenIDs)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc refreshTokenEncryptionAlgorithm(ctrl *gomock.Controller) crypto.EncryptionAlgorithm {\n\tmCrypto := crypto.NewMockEncryptionAlgorithm(ctrl)\n\tmCrypto.EXPECT().Algorithm().AnyTimes().Return(\"enc\")\n\tmCrypto.EXPECT().EncryptionKeyID().AnyTimes().Return(\"id\")\n\tmCrypto.EXPECT().Encrypt(gomock.Any()).AnyTimes().DoAndReturn(\n\t\tfunc(refrehToken []byte) ([]byte, error) {\n\t\t\treturn refrehToken, nil\n\t\t},\n\t)\n\tmCrypto.EXPECT().Decrypt(gomock.Any(), gomock.Any()).AnyTimes().DoAndReturn(\n\t\tfunc(refrehToken []byte, keyID string) ([]byte, error) {\n\t\t\tif keyID != \"id\" {\n\t\t\t\treturn nil, caos_errs.ThrowInternal(nil, \"id\", \"invalid key id\")\n\t\t\t}\n\t\t\treturn refrehToken, nil\n\t\t},\n\t)\n\treturn mCrypto\n}\n\nfunc TestCommands_addRefreshToken(t *testing.T) {\n\tauthTime := time.Now().Add(-1 * time.Hour)\n\ttype fields struct {\n\t\teventstore   *eventstore.Eventstore\n\t\tkeyAlgorithm crypto.EncryptionAlgorithm\n\t}\n\ttype args struct {\n\t\tctx                   context.Context\n\t\taccessToken           *domain.Token\n\t\tauthMethodsReferences []string\n\t\tauthTime              time.Time\n\t\tidleExpiration        time.Duration\n\t\texpiration            time.Duration\n\t}\n\ttype res struct {\n\t\tevent        *user.HumanRefreshTokenAddedEvent\n\t\trefreshToken string\n\t\terr          func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\n\t\t{\n\t\t\tname: \"add refresh Token\",\n\t\t\tfields: fields{\n\t\t\t\teventstore:   eventstoreExpect(t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx: context.Background(),\n\t\t\t\taccessToken: &domain.Token{\n\t\t\t\t\tObjectRoot: models.ObjectRoot{\n\t\t\t\t\t\tAggregateID:   \"userID\",\n\t\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t\t},\n\t\t\t\t\tTokenID:           \"accessTokenID1\",\n\t\t\t\t\tApplicationID:     \"clientID\",\n\t\t\t\t\tUserAgentID:       \"agentID\",\n\t\t\t\t\tRefreshTokenID:    \"refreshTokenID\",\n\t\t\t\t\tAudience:          []string{\"clientID1\"},\n\t\t\t\t\tExpiration:        time.Now().Add(5 * time.Minute),\n\t\t\t\t\tScopes:            []string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\tPreferredLanguage: \"de\",\n\t\t\t\t},\n\t\t\t\tauthMethodsReferences: []string{\"password\"},\n\t\t\t\tauthTime:              authTime,\n\t\t\t\tidleExpiration:        1 * time.Hour,\n\t\t\t\texpiration:            10 * time.Hour,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\tevent: user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t&user.NewAggregate(\"userID\", \"org1\").Aggregate,\n\t\t\t\t\t\"refreshTokenID\",\n\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\"de\",\n\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\tauthTime,\n\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t10*time.Hour,\n\t\t\t\t),\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:refreshTokenID:refreshTokenID\")),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &Commands{\n\t\t\t\teventstore:   tt.fields.eventstore,\n\t\t\t\tkeyAlgorithm: tt.fields.keyAlgorithm,\n\t\t\t}\n\t\t\tgotEvent, gotRefreshToken, err := c.addRefreshToken(tt.args.ctx, tt.args.accessToken, tt.args.authMethodsReferences, tt.args.authTime, tt.args.idleExpiration, tt.args.expiration)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.event, gotEvent)\n\t\t\t\tassert.Equal(t, tt.res.refreshToken, gotRefreshToken)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommands_renewRefreshToken(t *testing.T) {\n\ttype fields struct {\n\t\teventstore   *eventstore.Eventstore\n\t\tidGenerator  id.Generator\n\t\tkeyAlgorithm crypto.EncryptionAlgorithm\n\t}\n\ttype args struct {\n\t\tctx            context.Context\n\t\tuserID         string\n\t\torgID          string\n\t\trefreshToken   string\n\t\tidleExpiration time.Duration\n\t}\n\ttype res struct {\n\t\tevent           *user.HumanRefreshTokenRenewedEvent\n\t\trefreshTokenID  string\n\t\tnewRefreshToken string\n\t\terr             func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"empty token, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx: context.Background(),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid token, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore:   eventstoreExpect(t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\trefreshToken: \"invalid\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid token (invalid userID), error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore:   eventstoreExpect(t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID2:tokenID:token\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"token inactive, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:token\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"token expired, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:tokenID\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"token renewed, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusherWithCreationDateNow(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t\tidGenerator:  id_mock.NewIDGeneratorExpectIDs(t, \"refreshToken1\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:            context.Background(),\n\t\t\t\tuserID:         \"userID\",\n\t\t\t\torgID:          \"orgID\",\n\t\t\t\trefreshToken:   base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:tokenID\")),\n\t\t\t\tidleExpiration: 1 * time.Hour,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\tevent: user.NewHumanRefreshTokenRenewedEvent(\n\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\"refreshToken1\",\n\t\t\t\t\t1*time.Hour,\n\t\t\t\t),\n\t\t\t\trefreshTokenID:  \"tokenID\",\n\t\t\t\tnewRefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:refreshToken1\")),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &Commands{\n\t\t\t\teventstore:   tt.fields.eventstore,\n\t\t\t\tidGenerator:  tt.fields.idGenerator,\n\t\t\t\tkeyAlgorithm: tt.fields.keyAlgorithm,\n\t\t\t}\n\t\t\tgotEvent, gotRefreshTokenID, gotNewRefreshToken, err := c.renewRefreshToken(tt.args.ctx, tt.args.userID, tt.args.orgID, tt.args.refreshToken, tt.args.idleExpiration)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.event, gotEvent)\n\t\t\t\tassert.Equal(t, tt.res.refreshTokenID, gotRefreshTokenID)\n\t\t\t\tassert.Equal(t, tt.res.newRefreshToken, gotNewRefreshToken)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package user\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"time\"\n\n\t\"golang.org/x/text/language\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\t\"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/eventstore/repository\"\n)\n\nconst (\n\thumanEventPrefix                   = userEventTypePrefix + \"human.\"\n\tHumanAddedType                     = humanEventPrefix + \"added\"\n\tHumanRegisteredType                = humanEventPrefix + \"selfregistered\"\n\tHumanInitialCodeAddedType          = humanEventPrefix + \"initialization.code.added\"\n\tHumanInitialCodeSentType           = humanEventPrefix + \"initialization.code.sent\"\n\tHumanInitializedCheckSucceededType = humanEventPrefix + \"initialization.check.succeeded\"\n\tHumanInitializedCheckFailedType    = humanEventPrefix + \"initialization.check.failed\"\n\tHumanSignedOutType                 = humanEventPrefix + \"signed.out\"\n)\n\ntype HumanAddedEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n\n\tUserName              string `json:\"userName\"`\n\tuserLoginMustBeDomain bool\n\n\tFirstName         string        `json:\"firstName,omitempty\"`\n\tLastName          string        `json:\"lastName,omitempty\"`\n\tNickName          string        `json:\"nickName,omitempty\"`\n\tDisplayName       string        `json:\"displayName,omitempty\"`\n\tPreferredLanguage language.Tag  `json:\"preferredLanguage,omitempty\"`\n\tGender            domain.Gender `json:\"gender,omitempty\"`\n\n\tEmailAddress string `json:\"email,omitempty\"`\n\n\tPhoneNumber string `json:\"phone,omitempty\"`\n\n\tCountry       string `json:\"country,omitempty\"`\n\tLocality      string `json:\"locality,omitempty\"`\n\tPostalCode    string `json:\"postalCode,omitempty\"`\n\tRegion        string `json:\"region,omitempty\"`\n\tStreetAddress string `json:\"streetAddress,omitempty\"`\n\n\tSecret         *crypto.CryptoValue `json:\"secret,omitempty\"`\n\tChangeRequired bool                `json:\"changeRequired,omitempty\"`\n}\n\nfunc (e *HumanAddedEvent) Data() interface{} {\n\treturn e\n}\n\nfunc (e *HumanAddedEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn []*eventstore.EventUniqueConstraint{NewAddUsernameUniqueConstraint(e.UserName, e.Aggregate().ResourceOwner, e.userLoginMustBeDomain)}\n}\n\nfunc (e *HumanAddedEvent) AddAddressData(\n\tcountry,\n\tlocality,\n\tpostalCode,\n\tregion,\n\tstreetAddress string,\n) {\n\te.Country = country\n\te.Locality = locality\n\te.PostalCode = postalCode\n\te.Region = region\n\te.StreetAddress = streetAddress\n}\n\nfunc (e *HumanAddedEvent) AddPhoneData(\n\tphoneNumber string,\n) {\n\te.PhoneNumber = phoneNumber\n}\n\nfunc (e *HumanAddedEvent) AddPasswordData(\n\tsecret *crypto.CryptoValue,\n\tchangeRequired bool,\n) {\n\te.Secret = secret\n\te.ChangeRequired = changeRequired\n}\n\nfunc NewHumanAddedEvent(\n\tctx context.Context,\n\taggregate *eventstore.Aggregate,\n\n\tuserName,\n\tfirstName,\n\tlastName,\n\tnickName,\n\tdisplayName string,\n\tpreferredLanguage language.Tag,\n\tgender domain.Gender,\n\temailAddress string,\n\tuserLoginMustBeDomain bool,\n) *HumanAddedEvent {\n\treturn &HumanAddedEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanAddedType,\n\t\t),\n\t\tUserName:              userName,\n\t\tFirstName:             firstName,\n\t\tLastName:              lastName,\n\t\tNickName:              nickName,\n\t\tDisplayName:           displayName,\n\t\tPreferredLanguage:     preferredLanguage,\n\t\tGender:                gender,\n\t\tEmailAddress:          emailAddress,\n\t\tuserLoginMustBeDomain: userLoginMustBeDomain,\n\t}\n}\n\nfunc HumanAddedEventMapper(event *repository.Event) (eventstore.Event, error) {\n\thumanAdded := &HumanAddedEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}\n\terr := json.Unmarshal(event.Data, humanAdded)\n\tif err != nil {\n\t\treturn nil, errors.ThrowInternal(err, \"USER-5Gm9s\", \"unable to unmarshal human added\")\n\t}\n\n\treturn humanAdded, nil\n}\n\ntype HumanRegisteredEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n\n\tUserName              string `json:\"userName\"`\n\tuserLoginMustBeDomain bool\n\n\tFirstName         string        `json:\"firstName,omitempty\"`\n\tLastName          string        `json:\"lastName,omitempty\"`\n\tNickName          string        `json:\"nickName,omitempty\"`\n\tDisplayName       string        `json:\"displayName,omitempty\"`\n\tPreferredLanguage language.Tag  `json:\"preferredLanguage,omitempty\"`\n\tGender            domain.Gender `json:\"gender,omitempty\"`\n\n\tEmailAddress string `json:\"email,omitempty\"`\n\n\tPhoneNumber string `json:\"phone,omitempty\"`\n\n\tCountry       string `json:\"country,omitempty\"`\n\tLocality      string `json:\"locality,omitempty\"`\n\tPostalCode    string `json:\"postalCode,omitempty\"`\n\tRegion        string `json:\"region,omitempty\"`\n\tStreetAddress string `json:\"streetAddress,omitempty\"`\n\n\tSecret         *crypto.CryptoValue `json:\"secret,omitempty\"`\n\tChangeRequired bool                `json:\"changeRequired,omitempty\"`\n}\n\nfunc (e *HumanRegisteredEvent) Data() interface{} {\n\treturn e\n}\n\nfunc (e *HumanRegisteredEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn []*eventstore.EventUniqueConstraint{NewAddUsernameUniqueConstraint(e.UserName, e.Aggregate().ResourceOwner, e.userLoginMustBeDomain)}\n}\n\nfunc (e *HumanRegisteredEvent) AddAddressData(\n\tcountry,\n\tlocality,\n\tpostalCode,\n\tregion,\n\tstreetAddress string,\n) {\n\te.Country = country\n\te.Locality = locality\n\te.PostalCode = postalCode\n\te.Region = region\n\te.StreetAddress = streetAddress\n}\n\nfunc (e *HumanRegisteredEvent) AddPhoneData(\n\tphoneNumber string,\n) {\n\te.PhoneNumber = phoneNumber\n}\n\nfunc (e *HumanRegisteredEvent) AddPasswordData(\n\tsecret *crypto.CryptoValue,\n\tchangeRequired bool,\n) {\n\te.Secret = secret\n\te.ChangeRequired = changeRequired\n}\n\nfunc NewHumanRegisteredEvent(\n\tctx context.Context,\n\taggregate *eventstore.Aggregate,\n\n\tuserName,\n\tfirstName,\n\tlastName,\n\tnickName,\n\tdisplayName string,\n\tpreferredLanguage language.Tag,\n\tgender domain.Gender,\n\temailAddress string,\n\tuserLoginMustBeDomain bool,\n) *HumanRegisteredEvent {\n\treturn &HumanRegisteredEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanRegisteredType,\n\t\t),\n\t\tUserName:              userName,\n\t\tFirstName:             firstName,\n\t\tLastName:              lastName,\n\t\tNickName:              nickName,\n\t\tDisplayName:           displayName,\n\t\tPreferredLanguage:     preferredLanguage,\n\t\tGender:                gender,\n\t\tEmailAddress:          emailAddress,\n\t\tuserLoginMustBeDomain: userLoginMustBeDomain,\n\t}\n}\n\nfunc HumanRegisteredEventMapper(event *repository.Event) (eventstore.Event, error) {\n\thumanRegistered := &HumanRegisteredEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}\n\terr := json.Unmarshal(event.Data, humanRegistered)\n\tif err != nil {\n\t\treturn nil, errors.ThrowInternal(err, \"USER-3Vm9s\", \"unable to unmarshal human registered\")\n\t}\n\n\treturn humanRegistered, nil\n}\n\ntype HumanInitialCodeAddedEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n\tCode                 *crypto.CryptoValue `json:\"code,omitempty\"`\n\tExpiry               time.Duration       `json:\"expiry,omitempty\"`\n}\n\nfunc (e *HumanInitialCodeAddedEvent) Data() interface{} {\n\treturn e\n}\n\nfunc (e *HumanInitialCodeAddedEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn nil\n}\n\nfunc NewHumanInitialCodeAddedEvent(\n\tctx context.Context,\n\taggregate *eventstore.Aggregate,\n\tcode *crypto.CryptoValue,\n\texpiry time.Duration,\n) *HumanInitialCodeAddedEvent {\n\treturn &HumanInitialCodeAddedEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanInitialCodeAddedType,\n\t\t),\n\t\tCode:   code,\n\t\tExpiry: expiry,\n\t}\n}\n\nfunc HumanInitialCodeAddedEventMapper(event *repository.Event) (eventstore.Event, error) {\n\thumanRegistered := &HumanInitialCodeAddedEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}\n\terr := json.Unmarshal(event.Data, humanRegistered)\n\tif err != nil {\n\t\treturn nil, errors.ThrowInternal(err, \"USER-bM9se\", \"unable to unmarshal human initial code added\")\n\t}\n\n\treturn humanRegistered, nil\n}\n\ntype HumanInitialCodeSentEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n}\n\nfunc (e *HumanInitialCodeSentEvent) Data() interface{} {\n\treturn nil\n}\n\nfunc (e *HumanInitialCodeSentEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn nil\n}\n\nfunc NewHumanInitialCodeSentEvent(ctx context.Context, aggregate *eventstore.Aggregate) *HumanInitialCodeSentEvent {\n\treturn &HumanInitialCodeSentEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanInitialCodeSentType,\n\t\t),\n\t}\n}\n\nfunc HumanInitialCodeSentEventMapper(event *repository.Event) (eventstore.Event, error) {\n\treturn &HumanInitialCodeSentEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}, nil\n}\n\ntype HumanInitializedCheckSucceededEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n}\n\nfunc (e *HumanInitializedCheckSucceededEvent) Data() interface{} {\n\treturn nil\n}\n\nfunc (e *HumanInitializedCheckSucceededEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn nil\n}\n\nfunc NewHumanInitializedCheckSucceededEvent(ctx context.Context, aggregate *eventstore.Aggregate) *HumanInitializedCheckSucceededEvent {\n\treturn &HumanInitializedCheckSucceededEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanInitializedCheckSucceededType,\n\t\t),\n\t}\n}\n\nfunc HumanInitializedCheckSucceededEventMapper(event *repository.Event) (eventstore.Event, error) {\n\treturn &HumanInitializedCheckSucceededEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}, nil\n}\n\ntype HumanInitializedCheckFailedEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n}\n\nfunc (e *HumanInitializedCheckFailedEvent) Data() interface{} {\n\treturn nil\n}\n\nfunc (e *HumanInitializedCheckFailedEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn nil\n}\n\nfunc NewHumanInitializedCheckFailedEvent(ctx context.Context, aggregate *eventstore.Aggregate) *HumanInitializedCheckFailedEvent {\n\treturn &HumanInitializedCheckFailedEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanInitializedCheckFailedType,\n\t\t),\n\t}\n}\n\nfunc HumanInitializedCheckFailedEventMapper(event *repository.Event) (eventstore.Event, error) {\n\treturn &HumanInitializedCheckFailedEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}, nil\n}\n\ntype HumanSignedOutEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n\n\tUserAgentID string `json:\"userAgentID\"`\n}\n\nfunc (e *HumanSignedOutEvent) Data() interface{} {\n\treturn e\n}\n\nfunc (e *HumanSignedOutEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn nil\n}\n\nfunc NewHumanSignedOutEvent(\n\tctx context.Context,\n\taggregate *eventstore.Aggregate,\n\tuserAgentID string,\n) *HumanSignedOutEvent {\n\treturn &HumanSignedOutEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanSignedOutType,\n\t\t),\n\t\tUserAgentID: userAgentID,\n\t}\n}\n\nfunc HumanSignedOutEventMapper(event *repository.Event) (eventstore.Event, error) {\n\treturn &HumanSignedOutEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}, nil\n}\n"], "fixing_code": ["package command\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/zitadel/logging\"\n\n\t\"github.com/zitadel/zitadel/internal/api/authz\"\n\t\"github.com/zitadel/zitadel/internal/command/preparation\"\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\t\"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/eventstore/v1/models\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n\t\"github.com/zitadel/zitadel/internal/telemetry/tracing\"\n)\n\nfunc (c *Commands) ChangeUsername(ctx context.Context, orgID, userID, userName string) (*domain.ObjectDetails, error) {\n\tuserName = strings.TrimSpace(userName)\n\tif orgID == \"\" || userID == \"\" || userName == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-2N9fs\", \"Errors.IDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-5N9ds\", \"Errors.User.NotFound\")\n\t}\n\n\tif existingUser.UserName == userName {\n\t\treturn nil, errors.ThrowPreconditionFailed(nil, \"COMMAND-6m9gs\", \"Errors.User.UsernameNotChanged\")\n\t}\n\n\tdomainPolicy, err := c.getOrgDomainPolicy(ctx, orgID)\n\tif err != nil {\n\t\treturn nil, errors.ThrowPreconditionFailed(err, \"COMMAND-38fnu\", \"Errors.Org.DomainPolicy.NotExisting\")\n\t}\n\n\tif err := CheckDomainPolicyForUserName(userName, domainPolicy); err != nil {\n\t\treturn nil, err\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&existingUser.WriteModel)\n\n\tpushedEvents, err := c.eventstore.Push(ctx,\n\t\tuser.NewUsernameChangedEvent(ctx, userAgg, existingUser.UserName, userName, domainPolicy.UserLoginMustBeDomain))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) DeactivateUser(ctx context.Context, userID, resourceOwner string) (*domain.ObjectDetails, error) {\n\tif userID == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-m0gDf\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-3M9ds\", \"Errors.User.NotFound\")\n\t}\n\tif isUserStateInitial(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-ke0fw\", \"Errors.User.CantDeactivateInitial\")\n\t}\n\tif isUserStateInactive(existingUser.UserState) {\n\t\treturn nil, errors.ThrowPreconditionFailed(nil, \"COMMAND-5M0sf\", \"Errors.User.AlreadyInactive\")\n\t}\n\n\tpushedEvents, err := c.eventstore.Push(ctx,\n\t\tuser.NewUserDeactivatedEvent(ctx, UserAggregateFromWriteModel(&existingUser.WriteModel)))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) ReactivateUser(ctx context.Context, userID, resourceOwner string) (*domain.ObjectDetails, error) {\n\tif userID == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-4M9ds\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-4M0sd\", \"Errors.User.NotFound\")\n\t}\n\tif !isUserStateInactive(existingUser.UserState) {\n\t\treturn nil, errors.ThrowPreconditionFailed(nil, \"COMMAND-6M0sf\", \"Errors.User.NotInactive\")\n\t}\n\n\tpushedEvents, err := c.eventstore.Push(ctx,\n\t\tuser.NewUserReactivatedEvent(ctx, UserAggregateFromWriteModel(&existingUser.WriteModel)))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) LockUser(ctx context.Context, userID, resourceOwner string) (*domain.ObjectDetails, error) {\n\tif userID == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-2M0sd\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-5M9fs\", \"Errors.User.NotFound\")\n\t}\n\tif !hasUserState(existingUser.UserState, domain.UserStateActive, domain.UserStateInitial) {\n\t\treturn nil, errors.ThrowPreconditionFailed(nil, \"COMMAND-3NN8v\", \"Errors.User.ShouldBeActiveOrInitial\")\n\t}\n\n\tpushedEvents, err := c.eventstore.Push(ctx,\n\t\tuser.NewUserLockedEvent(ctx, UserAggregateFromWriteModel(&existingUser.WriteModel)))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) UnlockUser(ctx context.Context, userID, resourceOwner string) (*domain.ObjectDetails, error) {\n\tif userID == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-M0dse\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-M0dos\", \"Errors.User.NotFound\")\n\t}\n\tif !hasUserState(existingUser.UserState, domain.UserStateLocked) {\n\t\treturn nil, errors.ThrowPreconditionFailed(nil, \"COMMAND-4M0ds\", \"Errors.User.NotLocked\")\n\t}\n\n\tpushedEvents, err := c.eventstore.Push(ctx,\n\t\tuser.NewUserUnlockedEvent(ctx, UserAggregateFromWriteModel(&existingUser.WriteModel)))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) RemoveUser(ctx context.Context, userID, resourceOwner string, cascadingUserMemberships []*CascadingMembership, cascadingGrantIDs ...string) (*domain.ObjectDetails, error) {\n\tif userID == \"\" {\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-2M0ds\", \"Errors.User.UserIDMissing\")\n\t}\n\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-m9od\", \"Errors.User.NotFound\")\n\t}\n\n\tdomainPolicy, err := c.getOrgDomainPolicy(ctx, existingUser.ResourceOwner)\n\tif err != nil {\n\t\treturn nil, errors.ThrowPreconditionFailed(err, \"COMMAND-3M9fs\", \"Errors.Org.DomainPolicy.NotExisting\")\n\t}\n\tvar events []eventstore.Command\n\tuserAgg := UserAggregateFromWriteModel(&existingUser.WriteModel)\n\tevents = append(events, user.NewUserRemovedEvent(ctx, userAgg, existingUser.UserName, existingUser.IDPLinks, domainPolicy.UserLoginMustBeDomain))\n\n\tfor _, grantID := range cascadingGrantIDs {\n\t\tremoveEvent, _, err := c.removeUserGrant(ctx, grantID, \"\", true)\n\t\tif err != nil {\n\t\t\tlogging.WithFields(\"usergrantid\", grantID).WithError(err).Warn(\"could not cascade remove role on user grant\")\n\t\t\tcontinue\n\t\t}\n\t\tevents = append(events, removeEvent)\n\t}\n\n\tif len(cascadingUserMemberships) > 0 {\n\t\tmembershipEvents, err := c.removeUserMemberships(ctx, cascadingUserMemberships)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tevents = append(events, membershipEvents...)\n\t}\n\n\tpushedEvents, err := c.eventstore.Push(ctx, events...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(existingUser, pushedEvents...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&existingUser.WriteModel), nil\n}\n\nfunc (c *Commands) AddUserToken(ctx context.Context, orgID, agentID, clientID, userID string, audience, scopes []string, lifetime time.Duration) (*domain.Token, error) {\n\tif userID == \"\" { //do not check for empty orgID (JWT Profile requests won't provide it, so service user requests fail)\n\t\treturn nil, errors.ThrowInvalidArgument(nil, \"COMMAND-Dbge4\", \"Errors.IDMissing\")\n\t}\n\tuserWriteModel := NewUserWriteModel(userID, orgID)\n\tevent, accessToken, err := c.addUserToken(ctx, userWriteModel, agentID, clientID, \"\", audience, scopes, lifetime)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_, err = c.eventstore.Push(ctx, event)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn accessToken, nil\n}\n\nfunc (c *Commands) RevokeAccessToken(ctx context.Context, userID, orgID, tokenID string) (*domain.ObjectDetails, error) {\n\tremoveEvent, accessTokenWriteModel, err := c.removeAccessToken(ctx, userID, orgID, tokenID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tevents, err := c.eventstore.Push(ctx, removeEvent)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = AppendAndReduce(accessTokenWriteModel, events...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModelToObjectDetails(&accessTokenWriteModel.WriteModel), nil\n}\n\nfunc (c *Commands) addUserToken(ctx context.Context, userWriteModel *UserWriteModel, agentID, clientID, refreshTokenID string, audience, scopes []string, lifetime time.Duration) (*user.UserTokenAddedEvent, *domain.Token, error) {\n\terr := c.eventstore.FilterToQueryReducer(ctx, userWriteModel)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif userWriteModel.UserState != domain.UserStateActive {\n\t\treturn nil, nil, errors.ThrowNotFound(nil, \"COMMAND-1d6Gg\", \"Errors.User.NotFound\")\n\t}\n\n\taudience = domain.AddAudScopeToAudience(ctx, audience, scopes)\n\n\tpreferredLanguage := \"\"\n\texistingHuman, err := c.getHumanWriteModelByID(ctx, userWriteModel.AggregateID, userWriteModel.ResourceOwner)\n\tif existingHuman != nil {\n\t\tpreferredLanguage = existingHuman.PreferredLanguage.String()\n\t}\n\texpiration := time.Now().UTC().Add(lifetime)\n\ttokenID, err := c.idGenerator.Next()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tuserAgg := UserAggregateFromWriteModel(&userWriteModel.WriteModel)\n\treturn user.NewUserTokenAddedEvent(ctx, userAgg, tokenID, clientID, agentID, preferredLanguage, refreshTokenID, audience, scopes, expiration),\n\t\t&domain.Token{\n\t\t\tObjectRoot: models.ObjectRoot{\n\t\t\t\tAggregateID: userWriteModel.AggregateID,\n\t\t\t},\n\t\t\tTokenID:           tokenID,\n\t\t\tUserAgentID:       agentID,\n\t\t\tApplicationID:     clientID,\n\t\t\tRefreshTokenID:    refreshTokenID,\n\t\t\tAudience:          audience,\n\t\t\tScopes:            scopes,\n\t\t\tExpiration:        expiration,\n\t\t\tPreferredLanguage: preferredLanguage,\n\t\t}, nil\n}\n\nfunc (c *Commands) removeAccessToken(ctx context.Context, userID, orgID, tokenID string) (*user.UserTokenRemovedEvent, *UserAccessTokenWriteModel, error) {\n\tif userID == \"\" || orgID == \"\" || tokenID == \"\" {\n\t\treturn nil, nil, errors.ThrowInvalidArgument(nil, \"COMMAND-Dng42\", \"Errors.IDMissing\")\n\t}\n\trefreshTokenWriteModel := NewUserAccessTokenWriteModel(userID, orgID, tokenID)\n\terr := c.eventstore.FilterToQueryReducer(ctx, refreshTokenWriteModel)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif refreshTokenWriteModel.UserState != domain.UserStateActive {\n\t\treturn nil, nil, errors.ThrowNotFound(nil, \"COMMAND-BF4hd\", \"Errors.User.AccessToken.NotFound\")\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&refreshTokenWriteModel.WriteModel)\n\treturn user.NewUserTokenRemovedEvent(ctx, userAgg, tokenID), refreshTokenWriteModel, nil\n}\n\nfunc (c *Commands) userDomainClaimed(ctx context.Context, userID string) (events []eventstore.Command, _ *UserWriteModel, err error) {\n\texistingUser, err := c.userWriteModelByID(ctx, userID, \"\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif existingUser.UserState == domain.UserStateUnspecified || existingUser.UserState == domain.UserStateDeleted {\n\t\treturn nil, nil, errors.ThrowNotFound(nil, \"COMMAND-ii9K0\", \"Errors.User.NotFound\")\n\t}\n\tchangedUserGrant := NewUserWriteModel(userID, existingUser.ResourceOwner)\n\tuserAgg := UserAggregateFromWriteModel(&changedUserGrant.WriteModel)\n\n\tdomainPolicy, err := c.getOrgDomainPolicy(ctx, existingUser.ResourceOwner)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tid, err := c.idGenerator.Next()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn []eventstore.Command{\n\t\tuser.NewDomainClaimedEvent(\n\t\t\tctx,\n\t\t\tuserAgg,\n\t\t\tfmt.Sprintf(\"%s@temporary.%s\", id, authz.GetInstance(ctx).RequestedDomain()),\n\t\t\texistingUser.UserName,\n\t\t\tdomainPolicy.UserLoginMustBeDomain),\n\t}, changedUserGrant, nil\n}\n\nfunc (c *Commands) prepareUserDomainClaimed(ctx context.Context, filter preparation.FilterToQueryReducer, userID string) (*user.DomainClaimedEvent, error) {\n\tuserWriteModel, err := userWriteModelByID(ctx, filter, userID, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !userWriteModel.UserState.Exists() {\n\t\treturn nil, errors.ThrowNotFound(nil, \"COMMAND-ii9K0\", \"Errors.User.NotFound\")\n\t}\n\tdomainPolicy, err := domainPolicyWriteModel(ctx, filter, userWriteModel.ResourceOwner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserAgg := UserAggregateFromWriteModel(&userWriteModel.WriteModel)\n\n\tid, err := c.idGenerator.Next()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user.NewDomainClaimedEvent(\n\t\tctx,\n\t\tuserAgg,\n\t\tfmt.Sprintf(\"%s@temporary.%s\", id, authz.GetInstance(ctx).RequestedDomain()),\n\t\tuserWriteModel.UserName,\n\t\tdomainPolicy.UserLoginMustBeDomain), nil\n}\n\nfunc (c *Commands) UserDomainClaimedSent(ctx context.Context, orgID, userID string) (err error) {\n\tif userID == \"\" {\n\t\treturn errors.ThrowInvalidArgument(nil, \"COMMAND-5m0fs\", \"Errors.IDMissing\")\n\t}\n\texistingUser, err := c.userWriteModelByID(ctx, userID, orgID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn errors.ThrowNotFound(nil, \"COMMAND-5m9gK\", \"Errors.User.NotFound\")\n\t}\n\n\t_, err = c.eventstore.Push(ctx,\n\t\tuser.NewDomainClaimedSentEvent(ctx, UserAggregateFromWriteModel(&existingUser.WriteModel)))\n\treturn err\n}\n\nfunc (c *Commands) checkUserExists(ctx context.Context, userID, resourceOwner string) error {\n\texistingUser, err := c.userWriteModelByID(ctx, userID, resourceOwner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !isUserStateExists(existingUser.UserState) {\n\t\treturn errors.ThrowPreconditionFailed(nil, \"COMMAND-uXHNj\", \"Errors.User.NotFound\")\n\t}\n\treturn nil\n}\n\nfunc (c *Commands) userWriteModelByID(ctx context.Context, userID, resourceOwner string) (writeModel *UserWriteModel, err error) {\n\tctx, span := tracing.NewSpan(ctx)\n\tdefer func() { span.EndWithError(err) }()\n\n\twriteModel = NewUserWriteModel(userID, resourceOwner)\n\terr = c.eventstore.FilterToQueryReducer(ctx, writeModel)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn writeModel, nil\n}\n\nfunc ExistsUser(ctx context.Context, filter preparation.FilterToQueryReducer, id, resourceOwner string) (exists bool, err error) {\n\tevents, err := filter(ctx, eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).\n\t\tResourceOwner(resourceOwner).\n\t\tOrderAsc().\n\t\tAddQuery().\n\t\tAggregateTypes(user.AggregateType).\n\t\tAggregateIDs(id).\n\t\tEventTypes(\n\t\t\tuser.HumanRegisteredType,\n\t\t\tuser.UserV1RegisteredType,\n\t\t\tuser.HumanAddedType,\n\t\t\tuser.UserV1AddedType,\n\t\t\tuser.MachineAddedEventType,\n\t\t\tuser.UserRemovedType,\n\t\t).Builder())\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, event := range events {\n\t\tswitch event.(type) {\n\t\tcase *user.HumanRegisteredEvent, *user.HumanAddedEvent, *user.MachineAddedEvent:\n\t\t\texists = true\n\t\tcase *user.UserRemovedEvent:\n\t\t\texists = false\n\t\t}\n\t}\n\n\treturn exists, nil\n}\n\nfunc newUserInitCode(ctx context.Context, filter preparation.FilterToQueryReducer, alg crypto.EncryptionAlgorithm) (value *crypto.CryptoValue, expiry time.Duration, err error) {\n\treturn newCryptoCodeWithExpiry(ctx, filter, domain.SecretGeneratorTypeInitCode, alg)\n}\n\nfunc userWriteModelByID(ctx context.Context, filter preparation.FilterToQueryReducer, userID, resourceOwner string) (*UserWriteModel, error) {\n\tuser := NewUserWriteModel(userID, resourceOwner)\n\tevents, err := filter(ctx, user.Query())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuser.AppendEvents(events...)\n\terr = user.Reduce()\n\treturn user, err\n}\n", "package command\n\nimport (\n\t\"time\"\n\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n)\n\ntype HumanRefreshTokenWriteModel struct {\n\teventstore.WriteModel\n\n\tTokenID      string\n\tRefreshToken string\n\n\tUserState      domain.UserState\n\tIdleExpiration time.Time\n\tExpiration     time.Time\n\tUserAgentID    string\n}\n\nfunc NewHumanRefreshTokenWriteModel(userID, resourceOwner, tokenID string) *HumanRefreshTokenWriteModel {\n\treturn &HumanRefreshTokenWriteModel{\n\t\tWriteModel: eventstore.WriteModel{\n\t\t\tAggregateID:   userID,\n\t\t\tResourceOwner: resourceOwner,\n\t\t},\n\t\tTokenID: tokenID,\n\t}\n}\n\nfunc (wm *HumanRefreshTokenWriteModel) AppendEvents(events ...eventstore.Event) {\n\tfor _, event := range events {\n\t\tswitch e := event.(type) {\n\t\tcase *user.HumanRefreshTokenAddedEvent:\n\t\t\tif wm.TokenID != e.TokenID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twm.WriteModel.AppendEvents(e)\n\t\tcase *user.HumanRefreshTokenRenewedEvent:\n\t\t\tif wm.TokenID != e.TokenID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twm.WriteModel.AppendEvents(e)\n\t\tcase *user.HumanRefreshTokenRemovedEvent:\n\t\t\tif wm.TokenID != e.TokenID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twm.WriteModel.AppendEvents(e)\n\t\tdefault:\n\t\t\twm.WriteModel.AppendEvents(e)\n\t\t}\n\t}\n}\n\nfunc (wm *HumanRefreshTokenWriteModel) Reduce() error {\n\tfor _, event := range wm.Events {\n\t\tswitch e := event.(type) {\n\t\tcase *user.HumanRefreshTokenAddedEvent:\n\t\t\twm.TokenID = e.TokenID\n\t\t\twm.RefreshToken = e.TokenID\n\t\t\twm.IdleExpiration = e.CreationDate().Add(e.IdleExpiration)\n\t\t\twm.Expiration = e.CreationDate().Add(e.Expiration)\n\t\t\twm.UserState = domain.UserStateActive\n\t\t\twm.UserAgentID = e.UserAgentID\n\t\tcase *user.HumanRefreshTokenRenewedEvent:\n\t\t\tif wm.UserState == domain.UserStateActive {\n\t\t\t\twm.RefreshToken = e.RefreshToken\n\t\t\t}\n\t\t\twm.RefreshToken = e.RefreshToken\n\t\t\twm.IdleExpiration = e.CreationDate().Add(e.IdleExpiration)\n\t\tcase *user.HumanSignedOutEvent:\n\t\t\tif wm.UserAgentID == e.UserAgentID {\n\t\t\t\twm.UserState = domain.UserStateDeleted\n\t\t\t}\n\t\tcase *user.HumanRefreshTokenRemovedEvent,\n\t\t\t*user.UserLockedEvent,\n\t\t\t*user.UserDeactivatedEvent,\n\t\t\t*user.UserRemovedEvent:\n\t\t\twm.UserState = domain.UserStateDeleted\n\t\t}\n\t}\n\treturn wm.WriteModel.Reduce()\n}\n\nfunc (wm *HumanRefreshTokenWriteModel) Query() *eventstore.SearchQueryBuilder {\n\tquery := eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).\n\t\tAddQuery().\n\t\tAggregateTypes(user.AggregateType).\n\t\tAggregateIDs(wm.AggregateID).\n\t\tEventTypes(\n\t\t\tuser.HumanRefreshTokenAddedType,\n\t\t\tuser.HumanRefreshTokenRenewedType,\n\t\t\tuser.HumanRefreshTokenRemovedType,\n\t\t\tuser.HumanSignedOutType,\n\t\t\tuser.UserLockedType,\n\t\t\tuser.UserDeactivatedType,\n\t\t\tuser.UserRemovedType).\n\t\tBuilder()\n\n\tif wm.ResourceOwner != \"\" {\n\t\tquery.ResourceOwner(wm.ResourceOwner)\n\t}\n\treturn query\n}\n", "package command\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/golang/mock/gomock\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/zitadel/oidc/v2/pkg/oidc\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\tcaos_errs \"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/eventstore/repository\"\n\t\"github.com/zitadel/zitadel/internal/eventstore/v1/models\"\n\t\"github.com/zitadel/zitadel/internal/id\"\n\tid_mock \"github.com/zitadel/zitadel/internal/id/mock\"\n\t\"github.com/zitadel/zitadel/internal/repository/user\"\n)\n\nfunc TestCommands_AddAccessAndRefreshToken(t *testing.T) {\n\ttype fields struct {\n\t\teventstore   *eventstore.Eventstore\n\t\tidGenerator  id.Generator\n\t\tkeyAlgorithm crypto.EncryptionAlgorithm\n\t}\n\ttype args struct {\n\t\tctx                   context.Context\n\t\torgID                 string\n\t\tagentID               string\n\t\tclientID              string\n\t\tuserID                string\n\t\trefreshToken          string\n\t\taudience              []string\n\t\tscopes                []string\n\t\tauthMethodsReferences []string\n\t\tlifetime              time.Duration\n\t\tauthTime              time.Time\n\t\trefreshIdleExpiration time.Duration\n\t\trefreshExpiration     time.Duration\n\t}\n\ttype res struct {\n\t\ttoken        *domain.Token\n\t\trefreshToken string\n\t\terr          func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"missing ID, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t),\n\t\t\t},\n\t\t\targs: args{},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"add refresh token, user deactivated, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewUserDeactivatedEvent(context.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tidGenerator: id_mock.NewIDGeneratorExpectIDs(t, \"refreshTokenID1\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:      context.Background(),\n\t\t\t\torgID:    \"orgID\",\n\t\t\t\tagentID:  \"agentID\",\n\t\t\t\tuserID:   \"userID\",\n\t\t\t\tclientID: \"clientID\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsNotFound,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"renew refresh token, invalid token, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore:   eventstoreExpect(t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\trefreshToken: \"invalid\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"renew refresh token, invalid token (invalid userID), error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore:   eventstoreExpect(t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID2:tokenID:token\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"renew refresh token, token inactive, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:token\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"renew refresh token, token expired, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t-1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:tokenID\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t//fails because of timestamp equality\n\t\t//{\n\t\t//\tname: \"push failed, error\",\n\t\t//\tfields: fields{\n\t\t//\t\teventstore: eventstoreExpect(t,\n\t\t//\t\t\texpectFilter(\n\t\t//\t\t\t\teventFromEventPusher(user.NewHumanAddedEvent(\n\t\t//\t\t\t\t\tcontext.Background(),\n\t\t//\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t//\t\t\t\t\t\"username\",\n\t\t//\t\t\t\t\t\"firstname\",\n\t\t//\t\t\t\t\t\"lastname\",\n\t\t//\t\t\t\t\t\"nickname\",\n\t\t//\t\t\t\t\t\"displayname\",\n\t\t//\t\t\t\t\tlanguage.German,\n\t\t//\t\t\t\t\tdomain.GenderUnspecified,\n\t\t//\t\t\t\t\t\"email\",\n\t\t//\t\t\t\t\ttrue,\n\t\t//\t\t\t\t)),\n\t\t//\t\t\t),\n\t\t//\t\t\texpectFilter(\n\t\t//\t\t\t\teventFromEventPusherWithCreationDateNow(user.NewHumanAddedEvent(\n\t\t//\t\t\t\t\tcontext.Background(),\n\t\t//\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t//\t\t\t\t\t\"username\",\n\t\t//\t\t\t\t\t\"firstname\",\n\t\t//\t\t\t\t\t\"lastname\",\n\t\t//\t\t\t\t\t\"nickname\",\n\t\t//\t\t\t\t\t\"displayname\",\n\t\t//\t\t\t\t\tlanguage.German,\n\t\t//\t\t\t\t\tdomain.GenderUnspecified,\n\t\t//\t\t\t\t\t\"email\",\n\t\t//\t\t\t\t\ttrue,\n\t\t//\t\t\t\t)),\n\t\t//\t\t\t),\n\t\t//\t\t\texpectFilter(\n\t\t//\t\t\t\teventFromEventPusherWithCreationDateNow(user.NewHumanRefreshTokenAddedEvent(\n\t\t//\t\t\t\t\tcontext.Background(),\n\t\t//\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t//\t\t\t\t\t\"tokenID\",\n\t\t//\t\t\t\t\t\"applicationID\",\n\t\t//\t\t\t\t\t\"userAgentID\",\n\t\t//\t\t\t\t\t\"de\",\n\t\t//\t\t\t\t\t[]string{\"clientID1\"},\n\t\t//\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t//\t\t\t\t\t[]string{\"password\"},\n\t\t//\t\t\t\t\ttime.Now(),\n\t\t//\t\t\t\t\t1*time.Hour,\n\t\t//\t\t\t\t\t24*time.Hour,\n\t\t//\t\t\t\t)),\n\t\t//\t\t\t),\n\t\t//\t\t\texpectPushFailed(\n\t\t//\t\t\t\tcaos_errs.ThrowInternal(nil, \"ERROR\", \"internal\"),\n\t\t//\t\t\t\t[]*repository.Event{\n\t\t//\t\t\t\t\teventFromEventPusher(user.NewUserTokenAddedEvent(\n\t\t//\t\t\t\t\t\tcontext.Background(),\n\t\t//\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t//\t\t\t\t\t\t\"accessTokenID1\",\n\t\t//\t\t\t\t\t\t\"clientID\",\n\t\t//\t\t\t\t\t\t\"agentID\",\n\t\t//\t\t\t\t\t\t\"de\",\n\t\t//\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t//\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t//\t\t\t\t\t\ttime.Now().Add(5*time.Minute),\n\t\t//\t\t\t\t\t)),\n\t\t//\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRenewedEvent(\n\t\t//\t\t\t\t\t\tcontext.Background(),\n\t\t//\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t//\t\t\t\t\t\t\"tokenID\",\n\t\t//\t\t\t\t\t\t\"refreshToken1\",\n\t\t//\t\t\t\t\t\t1*time.Hour,\n\t\t//\t\t\t\t\t)),\n\t\t//\t\t\t\t},\n\t\t//\t\t\t),\n\t\t//\t\t),\n\t\t//\t\tidGenerator:  id_mock.NewIDGeneratorExpectIDs(t, \"accessTokenID1\", \"refreshToken1\"),\n\t\t//\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t//\t},\n\t\t//\targs: args{\n\t\t//\t\tctx:                   context.Background(),\n\t\t//\t\torgID:                 \"orgID\",\n\t\t//\t\tagentID:               \"agentID\",\n\t\t//\t\tclientID:              \"clientID\",\n\t\t//\t\tuserID:                \"userID\",\n\t\t//\t\trefreshToken:          base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:tokenID\")),\n\t\t//\t\taudience:              []string{\"clientID1\"},\n\t\t//\t\tscopes:                []string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t//\t\tauthMethodsReferences: []string{\"password\"},\n\t\t//\t\tlifetime:              5 * time.Minute,\n\t\t//\t\tauthTime:              time.Now(),\n\t\t//\t},\n\t\t//\tres: res{\n\t\t//\t\terr: caos_errs.IsInternal,\n\t\t//\t},\n\t\t//},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &Commands{\n\t\t\t\teventstore:   tt.fields.eventstore,\n\t\t\t\tidGenerator:  tt.fields.idGenerator,\n\t\t\t\tkeyAlgorithm: tt.fields.keyAlgorithm,\n\t\t\t}\n\t\t\tgot, gotRefresh, err := c.AddAccessAndRefreshToken(tt.args.ctx, tt.args.orgID, tt.args.agentID, tt.args.clientID, tt.args.userID, tt.args.refreshToken,\n\t\t\t\ttt.args.audience, tt.args.scopes, tt.args.authMethodsReferences, tt.args.lifetime, tt.args.refreshIdleExpiration, tt.args.refreshExpiration, tt.args.authTime)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.token, got)\n\t\t\t\tassert.Equal(t, tt.res.refreshToken, gotRefresh)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommands_RevokeRefreshToken(t *testing.T) {\n\ttype fields struct {\n\t\teventstore *eventstore.Eventstore\n\t}\n\ttype args struct {\n\t\tctx     context.Context\n\t\tuserID  string\n\t\torgID   string\n\t\ttokenID string\n\t}\n\ttype res struct {\n\t\twant *domain.ObjectDetails\n\t\terr  func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\t\"missing param, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t),\n\t\t\t},\n\t\t\targs{},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"token not active, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t\"tokenID\",\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsNotFound,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"push failed, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectPushFailed(caos_errs.ThrowInternal(nil, \"ERROR\", \"internal\"),\n\t\t\t\t\t\t[]*repository.Event{\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t\"tokenID\",\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsInternal,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"revoke, ok\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\t[]*repository.Event{\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t\"tokenID\",\n\t\t\t},\n\t\t\tres{\n\t\t\t\twant: &domain.ObjectDetails{\n\t\t\t\t\tResourceOwner: \"orgID\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &Commands{\n\t\t\t\teventstore: tt.fields.eventstore,\n\t\t\t}\n\t\t\tgot, err := c.RevokeRefreshToken(tt.args.ctx, tt.args.userID, tt.args.orgID, tt.args.tokenID)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommands_RevokeRefreshTokens(t *testing.T) {\n\ttype fields struct {\n\t\teventstore *eventstore.Eventstore\n\t}\n\ttype args struct {\n\t\tctx      context.Context\n\t\tuserID   string\n\t\torgID    string\n\t\ttokenIDs []string\n\t}\n\ttype res struct {\n\t\terr func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\t\"missing tokenIDs, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\tnil,\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"one token not active, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t[]string{\"tokenID\", \"tokenID2\"},\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsNotFound,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"push failed, error\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID2\",\n\t\t\t\t\t\t\t\"clientID2\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID2\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectPushFailed(caos_errs.ThrowInternal(nil, \"ERROR\", \"internal\"),\n\t\t\t\t\t\t[]*repository.Event{\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID2\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t[]string{\"tokenID\", \"tokenID2\"},\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: caos_errs.IsInternal,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"revoke, ok\",\n\t\t\tfields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID2\",\n\t\t\t\t\t\t\t\"clientID2\",\n\t\t\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID2\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t10*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t\texpectPush(\n\t\t\t\t\t\t[]*repository.Event{\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"tokenID2\",\n\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t},\n\t\t\targs{\n\t\t\t\tcontext.Background(),\n\t\t\t\t\"userID\",\n\t\t\t\t\"orgID\",\n\t\t\t\t[]string{\"tokenID\", \"tokenID2\"},\n\t\t\t},\n\t\t\tres{\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &Commands{\n\t\t\t\teventstore: tt.fields.eventstore,\n\t\t\t}\n\t\t\terr := c.RevokeRefreshTokens(tt.args.ctx, tt.args.userID, tt.args.orgID, tt.args.tokenIDs)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc refreshTokenEncryptionAlgorithm(ctrl *gomock.Controller) crypto.EncryptionAlgorithm {\n\tmCrypto := crypto.NewMockEncryptionAlgorithm(ctrl)\n\tmCrypto.EXPECT().Algorithm().AnyTimes().Return(\"enc\")\n\tmCrypto.EXPECT().EncryptionKeyID().AnyTimes().Return(\"id\")\n\tmCrypto.EXPECT().Encrypt(gomock.Any()).AnyTimes().DoAndReturn(\n\t\tfunc(refrehToken []byte) ([]byte, error) {\n\t\t\treturn refrehToken, nil\n\t\t},\n\t)\n\tmCrypto.EXPECT().Decrypt(gomock.Any(), gomock.Any()).AnyTimes().DoAndReturn(\n\t\tfunc(refrehToken []byte, keyID string) ([]byte, error) {\n\t\t\tif keyID != \"id\" {\n\t\t\t\treturn nil, caos_errs.ThrowInternal(nil, \"id\", \"invalid key id\")\n\t\t\t}\n\t\t\treturn refrehToken, nil\n\t\t},\n\t)\n\treturn mCrypto\n}\n\nfunc TestCommands_addRefreshToken(t *testing.T) {\n\tauthTime := time.Now().Add(-1 * time.Hour)\n\ttype fields struct {\n\t\teventstore   *eventstore.Eventstore\n\t\tkeyAlgorithm crypto.EncryptionAlgorithm\n\t}\n\ttype args struct {\n\t\tctx                   context.Context\n\t\taccessToken           *domain.Token\n\t\tauthMethodsReferences []string\n\t\tauthTime              time.Time\n\t\tidleExpiration        time.Duration\n\t\texpiration            time.Duration\n\t}\n\ttype res struct {\n\t\tevent        *user.HumanRefreshTokenAddedEvent\n\t\trefreshToken string\n\t\terr          func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\n\t\t{\n\t\t\tname: \"add refresh Token\",\n\t\t\tfields: fields{\n\t\t\t\teventstore:   eventstoreExpect(t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx: context.Background(),\n\t\t\t\taccessToken: &domain.Token{\n\t\t\t\t\tObjectRoot: models.ObjectRoot{\n\t\t\t\t\t\tAggregateID:   \"userID\",\n\t\t\t\t\t\tResourceOwner: \"org1\",\n\t\t\t\t\t},\n\t\t\t\t\tTokenID:           \"accessTokenID1\",\n\t\t\t\t\tApplicationID:     \"clientID\",\n\t\t\t\t\tUserAgentID:       \"agentID\",\n\t\t\t\t\tRefreshTokenID:    \"refreshTokenID\",\n\t\t\t\t\tAudience:          []string{\"clientID1\"},\n\t\t\t\t\tExpiration:        time.Now().Add(5 * time.Minute),\n\t\t\t\t\tScopes:            []string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\tPreferredLanguage: \"de\",\n\t\t\t\t},\n\t\t\t\tauthMethodsReferences: []string{\"password\"},\n\t\t\t\tauthTime:              authTime,\n\t\t\t\tidleExpiration:        1 * time.Hour,\n\t\t\t\texpiration:            10 * time.Hour,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\tevent: user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t&user.NewAggregate(\"userID\", \"org1\").Aggregate,\n\t\t\t\t\t\"refreshTokenID\",\n\t\t\t\t\t\"clientID\",\n\t\t\t\t\t\"agentID\",\n\t\t\t\t\t\"de\",\n\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\tauthTime,\n\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t10*time.Hour,\n\t\t\t\t),\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:refreshTokenID:refreshTokenID\")),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &Commands{\n\t\t\t\teventstore:   tt.fields.eventstore,\n\t\t\t\tkeyAlgorithm: tt.fields.keyAlgorithm,\n\t\t\t}\n\t\t\tgotEvent, gotRefreshToken, err := c.addRefreshToken(tt.args.ctx, tt.args.accessToken, tt.args.authMethodsReferences, tt.args.authTime, tt.args.idleExpiration, tt.args.expiration)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.event, gotEvent)\n\t\t\t\tassert.Equal(t, tt.res.refreshToken, gotRefreshToken)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommands_renewRefreshToken(t *testing.T) {\n\ttype fields struct {\n\t\teventstore   *eventstore.Eventstore\n\t\tidGenerator  id.Generator\n\t\tkeyAlgorithm crypto.EncryptionAlgorithm\n\t}\n\ttype args struct {\n\t\tctx            context.Context\n\t\tuserID         string\n\t\torgID          string\n\t\trefreshToken   string\n\t\tidleExpiration time.Duration\n\t}\n\ttype res struct {\n\t\tevent           *user.HumanRefreshTokenRenewedEvent\n\t\trefreshTokenID  string\n\t\tnewRefreshToken string\n\t\terr             func(error) bool\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\tres    res\n\t}{\n\t\t{\n\t\t\tname: \"empty token, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx: context.Background(),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid token, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore:   eventstoreExpect(t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\trefreshToken: \"invalid\",\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid token (invalid userID), error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore:   eventstoreExpect(t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID2:tokenID:token\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"token inactive, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenRemovedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:token\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"token expired, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusher(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:          context.Background(),\n\t\t\t\tuserID:       \"userID\",\n\t\t\t\torgID:        \"orgID\",\n\t\t\t\trefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:tokenID\")),\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user deactivated, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusherWithCreationDateNow(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewUserDeactivatedEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:            context.Background(),\n\t\t\t\tuserID:         \"userID\",\n\t\t\t\torgID:          \"orgID\",\n\t\t\t\trefreshToken:   base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:tokenID\")),\n\t\t\t\tidleExpiration: 1 * time.Hour,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user signedout, error\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusherWithCreationDateNow(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t\teventFromEventPusher(\n\t\t\t\t\t\t\tuser.NewHumanSignedOutEvent(\n\t\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:            context.Background(),\n\t\t\t\tuserID:         \"userID\",\n\t\t\t\torgID:          \"orgID\",\n\t\t\t\trefreshToken:   base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:tokenID\")),\n\t\t\t\tidleExpiration: 1 * time.Hour,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\terr: caos_errs.IsErrorInvalidArgument,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"token renewed, ok\",\n\t\t\tfields: fields{\n\t\t\t\teventstore: eventstoreExpect(t,\n\t\t\t\t\texpectFilter(\n\t\t\t\t\t\teventFromEventPusherWithCreationDateNow(user.NewHumanRefreshTokenAddedEvent(\n\t\t\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\t\t\"applicationID\",\n\t\t\t\t\t\t\t\"userAgentID\",\n\t\t\t\t\t\t\t\"de\",\n\t\t\t\t\t\t\t[]string{\"clientID1\"},\n\t\t\t\t\t\t\t[]string{oidc.ScopeOpenID, oidc.ScopeProfile, oidc.ScopeEmail, oidc.ScopeOfflineAccess},\n\t\t\t\t\t\t\t[]string{\"password\"},\n\t\t\t\t\t\t\ttime.Now(),\n\t\t\t\t\t\t\t1*time.Hour,\n\t\t\t\t\t\t\t24*time.Hour,\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tkeyAlgorithm: refreshTokenEncryptionAlgorithm(gomock.NewController(t)),\n\t\t\t\tidGenerator:  id_mock.NewIDGeneratorExpectIDs(t, \"refreshToken1\"),\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tctx:            context.Background(),\n\t\t\t\tuserID:         \"userID\",\n\t\t\t\torgID:          \"orgID\",\n\t\t\t\trefreshToken:   base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:tokenID\")),\n\t\t\t\tidleExpiration: 1 * time.Hour,\n\t\t\t},\n\t\t\tres: res{\n\t\t\t\tevent: user.NewHumanRefreshTokenRenewedEvent(\n\t\t\t\t\tcontext.Background(),\n\t\t\t\t\t&user.NewAggregate(\"userID\", \"orgID\").Aggregate,\n\t\t\t\t\t\"tokenID\",\n\t\t\t\t\t\"refreshToken1\",\n\t\t\t\t\t1*time.Hour,\n\t\t\t\t),\n\t\t\t\trefreshTokenID:  \"tokenID\",\n\t\t\t\tnewRefreshToken: base64.RawURLEncoding.EncodeToString([]byte(\"userID:tokenID:refreshToken1\")),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &Commands{\n\t\t\t\teventstore:   tt.fields.eventstore,\n\t\t\t\tidGenerator:  tt.fields.idGenerator,\n\t\t\t\tkeyAlgorithm: tt.fields.keyAlgorithm,\n\t\t\t}\n\t\t\tgotEvent, gotRefreshTokenID, gotNewRefreshToken, err := c.renewRefreshToken(tt.args.ctx, tt.args.userID, tt.args.orgID, tt.args.refreshToken, tt.args.idleExpiration)\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tif tt.res.err != nil && !tt.res.err(err) {\n\t\t\t\tt.Errorf(\"got wrong err: %v \", err)\n\t\t\t}\n\t\t\tif tt.res.err == nil {\n\t\t\t\tassert.Equal(t, tt.res.event, gotEvent)\n\t\t\t\tassert.Equal(t, tt.res.refreshTokenID, gotRefreshTokenID)\n\t\t\t\tassert.Equal(t, tt.res.newRefreshToken, gotNewRefreshToken)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package user\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"time\"\n\n\t\"golang.org/x/text/language\"\n\n\t\"github.com/zitadel/zitadel/internal/crypto\"\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\t\"github.com/zitadel/zitadel/internal/errors\"\n\t\"github.com/zitadel/zitadel/internal/eventstore\"\n\t\"github.com/zitadel/zitadel/internal/eventstore/repository\"\n)\n\nconst (\n\thumanEventPrefix                   = userEventTypePrefix + \"human.\"\n\tHumanAddedType                     = humanEventPrefix + \"added\"\n\tHumanRegisteredType                = humanEventPrefix + \"selfregistered\"\n\tHumanInitialCodeAddedType          = humanEventPrefix + \"initialization.code.added\"\n\tHumanInitialCodeSentType           = humanEventPrefix + \"initialization.code.sent\"\n\tHumanInitializedCheckSucceededType = humanEventPrefix + \"initialization.check.succeeded\"\n\tHumanInitializedCheckFailedType    = humanEventPrefix + \"initialization.check.failed\"\n\tHumanSignedOutType                 = humanEventPrefix + \"signed.out\"\n)\n\ntype HumanAddedEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n\n\tUserName              string `json:\"userName\"`\n\tuserLoginMustBeDomain bool\n\n\tFirstName         string        `json:\"firstName,omitempty\"`\n\tLastName          string        `json:\"lastName,omitempty\"`\n\tNickName          string        `json:\"nickName,omitempty\"`\n\tDisplayName       string        `json:\"displayName,omitempty\"`\n\tPreferredLanguage language.Tag  `json:\"preferredLanguage,omitempty\"`\n\tGender            domain.Gender `json:\"gender,omitempty\"`\n\n\tEmailAddress string `json:\"email,omitempty\"`\n\n\tPhoneNumber string `json:\"phone,omitempty\"`\n\n\tCountry       string `json:\"country,omitempty\"`\n\tLocality      string `json:\"locality,omitempty\"`\n\tPostalCode    string `json:\"postalCode,omitempty\"`\n\tRegion        string `json:\"region,omitempty\"`\n\tStreetAddress string `json:\"streetAddress,omitempty\"`\n\n\tSecret         *crypto.CryptoValue `json:\"secret,omitempty\"`\n\tChangeRequired bool                `json:\"changeRequired,omitempty\"`\n}\n\nfunc (e *HumanAddedEvent) Data() interface{} {\n\treturn e\n}\n\nfunc (e *HumanAddedEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn []*eventstore.EventUniqueConstraint{NewAddUsernameUniqueConstraint(e.UserName, e.Aggregate().ResourceOwner, e.userLoginMustBeDomain)}\n}\n\nfunc (e *HumanAddedEvent) AddAddressData(\n\tcountry,\n\tlocality,\n\tpostalCode,\n\tregion,\n\tstreetAddress string,\n) {\n\te.Country = country\n\te.Locality = locality\n\te.PostalCode = postalCode\n\te.Region = region\n\te.StreetAddress = streetAddress\n}\n\nfunc (e *HumanAddedEvent) AddPhoneData(\n\tphoneNumber string,\n) {\n\te.PhoneNumber = phoneNumber\n}\n\nfunc (e *HumanAddedEvent) AddPasswordData(\n\tsecret *crypto.CryptoValue,\n\tchangeRequired bool,\n) {\n\te.Secret = secret\n\te.ChangeRequired = changeRequired\n}\n\nfunc NewHumanAddedEvent(\n\tctx context.Context,\n\taggregate *eventstore.Aggregate,\n\n\tuserName,\n\tfirstName,\n\tlastName,\n\tnickName,\n\tdisplayName string,\n\tpreferredLanguage language.Tag,\n\tgender domain.Gender,\n\temailAddress string,\n\tuserLoginMustBeDomain bool,\n) *HumanAddedEvent {\n\treturn &HumanAddedEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanAddedType,\n\t\t),\n\t\tUserName:              userName,\n\t\tFirstName:             firstName,\n\t\tLastName:              lastName,\n\t\tNickName:              nickName,\n\t\tDisplayName:           displayName,\n\t\tPreferredLanguage:     preferredLanguage,\n\t\tGender:                gender,\n\t\tEmailAddress:          emailAddress,\n\t\tuserLoginMustBeDomain: userLoginMustBeDomain,\n\t}\n}\n\nfunc HumanAddedEventMapper(event *repository.Event) (eventstore.Event, error) {\n\thumanAdded := &HumanAddedEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}\n\terr := json.Unmarshal(event.Data, humanAdded)\n\tif err != nil {\n\t\treturn nil, errors.ThrowInternal(err, \"USER-5Gm9s\", \"unable to unmarshal human added\")\n\t}\n\n\treturn humanAdded, nil\n}\n\ntype HumanRegisteredEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n\n\tUserName              string `json:\"userName\"`\n\tuserLoginMustBeDomain bool\n\n\tFirstName         string        `json:\"firstName,omitempty\"`\n\tLastName          string        `json:\"lastName,omitempty\"`\n\tNickName          string        `json:\"nickName,omitempty\"`\n\tDisplayName       string        `json:\"displayName,omitempty\"`\n\tPreferredLanguage language.Tag  `json:\"preferredLanguage,omitempty\"`\n\tGender            domain.Gender `json:\"gender,omitempty\"`\n\n\tEmailAddress string `json:\"email,omitempty\"`\n\n\tPhoneNumber string `json:\"phone,omitempty\"`\n\n\tCountry       string `json:\"country,omitempty\"`\n\tLocality      string `json:\"locality,omitempty\"`\n\tPostalCode    string `json:\"postalCode,omitempty\"`\n\tRegion        string `json:\"region,omitempty\"`\n\tStreetAddress string `json:\"streetAddress,omitempty\"`\n\n\tSecret         *crypto.CryptoValue `json:\"secret,omitempty\"`\n\tChangeRequired bool                `json:\"changeRequired,omitempty\"`\n}\n\nfunc (e *HumanRegisteredEvent) Data() interface{} {\n\treturn e\n}\n\nfunc (e *HumanRegisteredEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn []*eventstore.EventUniqueConstraint{NewAddUsernameUniqueConstraint(e.UserName, e.Aggregate().ResourceOwner, e.userLoginMustBeDomain)}\n}\n\nfunc (e *HumanRegisteredEvent) AddAddressData(\n\tcountry,\n\tlocality,\n\tpostalCode,\n\tregion,\n\tstreetAddress string,\n) {\n\te.Country = country\n\te.Locality = locality\n\te.PostalCode = postalCode\n\te.Region = region\n\te.StreetAddress = streetAddress\n}\n\nfunc (e *HumanRegisteredEvent) AddPhoneData(\n\tphoneNumber string,\n) {\n\te.PhoneNumber = phoneNumber\n}\n\nfunc (e *HumanRegisteredEvent) AddPasswordData(\n\tsecret *crypto.CryptoValue,\n\tchangeRequired bool,\n) {\n\te.Secret = secret\n\te.ChangeRequired = changeRequired\n}\n\nfunc NewHumanRegisteredEvent(\n\tctx context.Context,\n\taggregate *eventstore.Aggregate,\n\n\tuserName,\n\tfirstName,\n\tlastName,\n\tnickName,\n\tdisplayName string,\n\tpreferredLanguage language.Tag,\n\tgender domain.Gender,\n\temailAddress string,\n\tuserLoginMustBeDomain bool,\n) *HumanRegisteredEvent {\n\treturn &HumanRegisteredEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanRegisteredType,\n\t\t),\n\t\tUserName:              userName,\n\t\tFirstName:             firstName,\n\t\tLastName:              lastName,\n\t\tNickName:              nickName,\n\t\tDisplayName:           displayName,\n\t\tPreferredLanguage:     preferredLanguage,\n\t\tGender:                gender,\n\t\tEmailAddress:          emailAddress,\n\t\tuserLoginMustBeDomain: userLoginMustBeDomain,\n\t}\n}\n\nfunc HumanRegisteredEventMapper(event *repository.Event) (eventstore.Event, error) {\n\thumanRegistered := &HumanRegisteredEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}\n\terr := json.Unmarshal(event.Data, humanRegistered)\n\tif err != nil {\n\t\treturn nil, errors.ThrowInternal(err, \"USER-3Vm9s\", \"unable to unmarshal human registered\")\n\t}\n\n\treturn humanRegistered, nil\n}\n\ntype HumanInitialCodeAddedEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n\tCode                 *crypto.CryptoValue `json:\"code,omitempty\"`\n\tExpiry               time.Duration       `json:\"expiry,omitempty\"`\n}\n\nfunc (e *HumanInitialCodeAddedEvent) Data() interface{} {\n\treturn e\n}\n\nfunc (e *HumanInitialCodeAddedEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn nil\n}\n\nfunc NewHumanInitialCodeAddedEvent(\n\tctx context.Context,\n\taggregate *eventstore.Aggregate,\n\tcode *crypto.CryptoValue,\n\texpiry time.Duration,\n) *HumanInitialCodeAddedEvent {\n\treturn &HumanInitialCodeAddedEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanInitialCodeAddedType,\n\t\t),\n\t\tCode:   code,\n\t\tExpiry: expiry,\n\t}\n}\n\nfunc HumanInitialCodeAddedEventMapper(event *repository.Event) (eventstore.Event, error) {\n\thumanRegistered := &HumanInitialCodeAddedEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}\n\terr := json.Unmarshal(event.Data, humanRegistered)\n\tif err != nil {\n\t\treturn nil, errors.ThrowInternal(err, \"USER-bM9se\", \"unable to unmarshal human initial code added\")\n\t}\n\n\treturn humanRegistered, nil\n}\n\ntype HumanInitialCodeSentEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n}\n\nfunc (e *HumanInitialCodeSentEvent) Data() interface{} {\n\treturn nil\n}\n\nfunc (e *HumanInitialCodeSentEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn nil\n}\n\nfunc NewHumanInitialCodeSentEvent(ctx context.Context, aggregate *eventstore.Aggregate) *HumanInitialCodeSentEvent {\n\treturn &HumanInitialCodeSentEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanInitialCodeSentType,\n\t\t),\n\t}\n}\n\nfunc HumanInitialCodeSentEventMapper(event *repository.Event) (eventstore.Event, error) {\n\treturn &HumanInitialCodeSentEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}, nil\n}\n\ntype HumanInitializedCheckSucceededEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n}\n\nfunc (e *HumanInitializedCheckSucceededEvent) Data() interface{} {\n\treturn nil\n}\n\nfunc (e *HumanInitializedCheckSucceededEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn nil\n}\n\nfunc NewHumanInitializedCheckSucceededEvent(ctx context.Context, aggregate *eventstore.Aggregate) *HumanInitializedCheckSucceededEvent {\n\treturn &HumanInitializedCheckSucceededEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanInitializedCheckSucceededType,\n\t\t),\n\t}\n}\n\nfunc HumanInitializedCheckSucceededEventMapper(event *repository.Event) (eventstore.Event, error) {\n\treturn &HumanInitializedCheckSucceededEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}, nil\n}\n\ntype HumanInitializedCheckFailedEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n}\n\nfunc (e *HumanInitializedCheckFailedEvent) Data() interface{} {\n\treturn nil\n}\n\nfunc (e *HumanInitializedCheckFailedEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn nil\n}\n\nfunc NewHumanInitializedCheckFailedEvent(ctx context.Context, aggregate *eventstore.Aggregate) *HumanInitializedCheckFailedEvent {\n\treturn &HumanInitializedCheckFailedEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanInitializedCheckFailedType,\n\t\t),\n\t}\n}\n\nfunc HumanInitializedCheckFailedEventMapper(event *repository.Event) (eventstore.Event, error) {\n\treturn &HumanInitializedCheckFailedEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}, nil\n}\n\ntype HumanSignedOutEvent struct {\n\teventstore.BaseEvent `json:\"-\"`\n\n\tUserAgentID string `json:\"userAgentID\"`\n}\n\nfunc (e *HumanSignedOutEvent) Data() interface{} {\n\treturn e\n}\n\nfunc (e *HumanSignedOutEvent) UniqueConstraints() []*eventstore.EventUniqueConstraint {\n\treturn nil\n}\n\nfunc NewHumanSignedOutEvent(\n\tctx context.Context,\n\taggregate *eventstore.Aggregate,\n\tuserAgentID string,\n) *HumanSignedOutEvent {\n\treturn &HumanSignedOutEvent{\n\t\tBaseEvent: *eventstore.NewBaseEventForPush(\n\t\t\tctx,\n\t\t\taggregate,\n\t\t\tHumanSignedOutType,\n\t\t),\n\t\tUserAgentID: userAgentID,\n\t}\n}\n\nfunc HumanSignedOutEventMapper(event *repository.Event) (eventstore.Event, error) {\n\tsignedOut := &HumanSignedOutEvent{\n\t\tBaseEvent: *eventstore.BaseEventFromRepo(event),\n\t}\n\terr := json.Unmarshal(event.Data, signedOut)\n\tif err != nil {\n\t\treturn nil, errors.ThrowInternal(err, \"USER-WFS3g\", \"unable to unmarshal human signed out\")\n\t}\n\n\treturn signedOut, nil\n}\n"], "filenames": ["internal/command/user.go", "internal/command/user_human_refresh_token_model.go", "internal/command/user_human_refresh_token_test.go", "internal/repository/user/human.go"], "buggy_code_start_loc": [264, 20, 67, 399], "buggy_code_end_loc": [265, 72, 915, 403], "fixing_code_start_loc": [264, 21, 67, 399], "fixing_code_end_loc": [265, 78, 1003, 409], "type": "CWE-613", "message": "ZITADEL is a combination of Auth0 and Keycloak. RefreshTokens is an OAuth 2.0 feature that allows applications to retrieve new access tokens and refresh the user's session without the need for interacting with a UI. RefreshTokens were not invalidated when a user was locked or deactivated. The deactivated or locked user was able to obtain a valid access token only through a refresh token grant. When the locked or deactivated user\u2019s session was already terminated (\u201clogged out\u201d) then it was not possible to create a new session. Renewal of access token through a refresh token grant is limited to the configured amount of time (RefreshTokenExpiration). As a workaround, ensure the RefreshTokenExpiration in the OIDC settings of your instance is set according to your security requirements. This issue has been patched in versions 2.17.3 and 2.16.4.", "other": {"cve": {"id": "CVE-2023-22492", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-11T20:15:08.970", "lastModified": "2023-01-24T18:21:59.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ZITADEL is a combination of Auth0 and Keycloak. RefreshTokens is an OAuth 2.0 feature that allows applications to retrieve new access tokens and refresh the user's session without the need for interacting with a UI. RefreshTokens were not invalidated when a user was locked or deactivated. The deactivated or locked user was able to obtain a valid access token only through a refresh token grant. When the locked or deactivated user\u2019s session was already terminated (\u201clogged out\u201d) then it was not possible to create a new session. Renewal of access token through a refresh token grant is limited to the configured amount of time (RefreshTokenExpiration). As a workaround, ensure the RefreshTokenExpiration in the OIDC settings of your instance is set according to your security requirements. This issue has been patched in versions 2.17.3 and 2.16.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zitadel:zitadel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.16.4", "matchCriteriaId": "0656FCDD-D804-476F-B8F8-4BB6845B622A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zitadel:zitadel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.17.0", "versionEndExcluding": "2.17.3", "matchCriteriaId": "52C4BACF-5AB3-4DBF-865D-E0FC740C379C"}]}]}], "references": [{"url": "https://github.com/zitadel/zitadel/commit/301e22c4956ead6014a8179463c37263f7301a83", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zitadel/zitadel/commit/fc892c52a10cd4ffdac395747494f3a93a7494c2", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zitadel/zitadel/security/advisories/GHSA-6rrr-78xp-5jp8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zitadel/zitadel/commit/301e22c4956ead6014a8179463c37263f7301a83"}}