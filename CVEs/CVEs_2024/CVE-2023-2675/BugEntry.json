{"buggy_code": ["import axios, { AxiosInstance } from \"axios\";\nimport { v1 as uuidv1 } from \"uuid\";\nimport { ConsoleServiceClient } from \"../client-interface\";\nimport {\n  ConsoleCompany,\n  ConsoleHookCompany,\n  ConsoleHookUser,\n  ConsoleOptions,\n  CreateConsoleCompany,\n  CreateConsoleUser,\n  CreatedConsoleCompany,\n  CreatedConsoleUser,\n  UpdateConsoleUserRole,\n  UpdatedConsoleUserRole,\n} from \"../types\";\n\nimport User, { getInstance } from \"../../user/entities/user\";\nimport Company, {\n  CompanySearchKey,\n  getInstance as getCompanyInstance,\n} from \"../../user/entities/company\";\nimport { CrudException } from \"../../../core/platform/framework/api/crud-service\";\nimport coalesce from \"../../../utils/coalesce\";\nimport { logger } from \"../../../core/platform/framework/logger\";\nimport { CompanyFeaturesEnum, CompanyLimitsEnum } from \"../../user/web/types\";\nimport gr from \"../../global-resolver\";\nimport { ConsoleServiceImpl } from \"../service\";\n\nexport class ConsoleRemoteClient implements ConsoleServiceClient {\n  version: \"1\";\n  client: AxiosInstance;\n\n  private infos: ConsoleOptions;\n\n  constructor(consoleInstance: ConsoleServiceImpl, private dryRun: boolean) {\n    this.infos = consoleInstance.consoleOptions;\n    this.client = axios.create({ baseURL: this.infos.url });\n  }\n\n  private auth() {\n    return { username: this.infos.username, password: this.infos.password };\n  }\n\n  async addUserToCompany(\n    company: ConsoleCompany,\n    user: CreateConsoleUser,\n  ): Promise<CreatedConsoleUser> {\n    logger.info(\"Remote: addUserToCompany\");\n\n    const isNewConsole = this.infos.new_console;\n\n    if (this.dryRun) {\n      return {\n        _id: uuidv1(),\n      };\n    }\n\n    if (user.skipInvite && user.name && user.email && user.password) {\n      return this.client\n        .post(`/api/companies/${company.code}/users`, user, {\n          auth: this.auth(),\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          params: {\n            skipInvite: user.skipInvite,\n          },\n        })\n        .then(({ data }) => data);\n    } else {\n      const invitationData = {\n        role: user.role,\n        emails: [\n          {\n            email: user.email,\n            role: user.role,\n          },\n        ],\n        inviter: { email: user.inviterEmail },\n        ...(isNewConsole\n          ? {\n              applicationCodes: [\"twake\"],\n            }\n          : {}),\n      };\n\n      const result = await this.client\n        .post(\n          `/api/companies/${company.code}/${isNewConsole ? \"invitations\" : \"users/invitation\"}`,\n          invitationData,\n          {\n            auth: this.auth(),\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n          },\n        )\n        .then(async ({ data, status }) => {\n          //Fixme: When console solve https://gitlab.com/COMPANY_LINAGORA/software/saas/twake-console-account/-/issues/36\n          //       we can remove this fallback\n          if ([200, 201].indexOf(status) >= 0) {\n            return data;\n          } else {\n            return this.client\n              .post(`/api/companies/${company.code}/users`, user, {\n                auth: this.auth(),\n                headers: {\n                  \"Content-Type\": \"application/json\",\n                },\n                params: {\n                  skipInvite: user.skipInvite,\n                },\n              })\n              .then(({ data }) => data);\n          }\n        });\n\n      return result;\n    }\n  }\n\n  async updateUserRole(\n    company: ConsoleCompany,\n    user: UpdateConsoleUserRole,\n  ): Promise<UpdatedConsoleUserRole> {\n    logger.info(\"Remote: updateUserRole\");\n\n    if (this.dryRun) {\n      return {\n        id: user.id,\n        role: user.role,\n      };\n    }\n\n    const result = await this.client\n      .put(\n        `/api/companies/${company.code}/users/${user.id}`,\n        { role: user.role },\n        {\n          auth: this.auth(),\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n        },\n      )\n      .then(({ data }) => data);\n\n    return result;\n  }\n\n  async createCompany(company: CreateConsoleCompany): Promise<CreatedConsoleCompany> {\n    logger.info(\"Remote: createCompany\");\n\n    if (this.dryRun) {\n      return company;\n    }\n\n    const result = await this.client\n      .post(\"/api/companies\", company, {\n        auth: this.auth(),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      })\n      .then(({ data }) => data);\n\n    return result;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  addUserToTwake(user: CreateConsoleUser): Promise<User> {\n    logger.info(\"Remote: addUserToTwake\");\n    //should do noting for real console\n    return Promise.resolve(undefined);\n  }\n\n  async updateLocalCompanyFromConsole(partialCompanyDTO: ConsoleHookCompany): Promise<Company> {\n    logger.info(\"Remote: updateLocalCompanyFromConsole\");\n\n    const companyDTO = await this.fetchCompanyInfo(partialCompanyDTO.details.code);\n\n    let company = await gr.services.companies.getCompany({\n      identity_provider_id: companyDTO.details.code,\n    });\n\n    if (!company) {\n      const newCompany = getCompanyInstance({\n        id: uuidv1(),\n        identity_provider: \"console\",\n        identity_provider_id: companyDTO.details.code,\n      });\n      company = await gr.services.companies.createCompany(newCompany);\n    }\n\n    const details = companyDTO.details;\n\n    if (details) {\n      company.name = coalesce(details.name, company.name);\n      company.displayName = coalesce(details.name, company.displayName);\n\n      const avatar = details.avatar;\n\n      company.logo =\n        details.logo ||\n        (avatar && avatar.type && avatar.type !== \"url\"\n          ? this.infos.url.replace(/\\/$/, \"\") + \"/api/avatars/\" + avatar.value\n          : companyDTO.value || \"\");\n    }\n\n    if (!company.plan) {\n      company.plan = { name: \"\", limits: undefined, features: undefined };\n    }\n\n    const limits = companyDTO.limits.twake || companyDTO.limits;\n\n    //FIXME this is a hack right now!\n    let planFeatures: any = {\n      [CompanyFeaturesEnum.CHAT_GUESTS]: true,\n      [CompanyFeaturesEnum.CHAT_MESSAGE_HISTORY]: true,\n      [CompanyFeaturesEnum.CHAT_MULTIPLE_WORKSPACES]: true,\n      [CompanyFeaturesEnum.CHAT_EDIT_FILES]: true,\n      [CompanyFeaturesEnum.CHAT_UNLIMITED_STORAGE]: true,\n      [CompanyFeaturesEnum.COMPANY_INVITE_MEMBER]: true,\n    };\n\n    if (limits.members < 0 && this.infos.type === \"remote\") {\n      //Hack to say this is free version\n      planFeatures = {\n        [CompanyFeaturesEnum.CHAT_GUESTS]: false,\n        [CompanyFeaturesEnum.CHAT_MESSAGE_HISTORY]: false,\n        [CompanyFeaturesEnum.CHAT_MULTIPLE_WORKSPACES]: false,\n        [CompanyFeaturesEnum.CHAT_EDIT_FILES]: false,\n        [CompanyFeaturesEnum.CHAT_UNLIMITED_STORAGE]: false, // Currently inactive\n      };\n      company.plan.name = \"free\";\n    } else {\n      company.plan.name = \"standard\";\n    }\n    company.plan.features = { ...planFeatures };\n    company.plan.limits = {\n      [CompanyLimitsEnum.CHAT_MESSAGE_HISTORY_LIMIT]: 10000, // To remove duplicata since we define this in formatCompany function\n      [CompanyLimitsEnum.COMPANY_MEMBERS_LIMIT]: limits[\"members\"],\n      [CompanyLimitsEnum.COMPANY_GUESTS_LIMIT]: limits[\"guests\"],\n    };\n\n    company.stats = coalesce(companyDTO.stats, company.stats);\n\n    await gr.services.companies.updateCompany(company);\n\n    return company;\n  }\n\n  async updateLocalUserFromConsole(code: string): Promise<User> {\n    logger.info(\"Remote: updateLocalUserFromConsole\");\n\n    const userDTO = await this.fetchUserInfo(code);\n\n    if (!userDTO) {\n      throw CrudException.badRequest(\"User not found on Console\");\n    }\n\n    const roles = userDTO.roles.filter(\n      role => role.applications === undefined || role.applications.find(a => a.code === \"twake\"),\n    );\n\n    let user = await gr.services.users.getByConsoleId(userDTO._id);\n\n    if (!user) {\n      if (!userDTO.email) {\n        throw CrudException.badRequest(\"Email is required\");\n      }\n\n      let username = userDTO.email\n        .split(\"@\")[0]\n        .toLocaleLowerCase()\n        .replace(/[^a-zA-Z0-9]/g, \"\")\n        .replace(/ +/g, \"_\");\n\n      if (await gr.services.users.isEmailAlreadyInUse(userDTO.email)) {\n        const user = await gr.services.users.getByEmail(userDTO.email);\n\n        if (user.identity_provider === \"console\") {\n          let emailUserOnConsole = null;\n          try {\n            emailUserOnConsole = await this.fetchUserInfo(user.identity_provider_id);\n          } catch (err) {}\n          if (emailUserOnConsole?._id) {\n            throw CrudException.badRequest(\n              `Console user not created because email already exists on console with different id: ${emailUserOnConsole._id} while requested to provision user with id: ${userDTO._id}`,\n            );\n          }\n\n          //If not present on console, then anonymise this one and create a new one\n          await gr.services.users.anonymizeAndDelete(\n            { id: user.id },\n            {\n              user: { id: user.id, server_request: true },\n            },\n          );\n\n          //Now we can create the new user\n        }\n      }\n\n      username = await gr.services.users.getAvailableUsername(username);\n      if (!username) {\n        throw CrudException.badRequest(\"Console user not created because username already exists\");\n      }\n\n      user = getInstance({});\n      user.username_canonical = (username || \"\").toLocaleLowerCase();\n      user.email_canonical = userDTO.email;\n      user.deleted = false;\n    }\n\n    user.email_canonical = coalesce(userDTO.email, user.email_canonical);\n    user.phone = \"\";\n    user.first_name = coalesce(userDTO.name, user.first_name);\n    user.last_name = coalesce(userDTO.surname, user.last_name);\n    user.identity_provider = \"console\";\n    user.identity_provider_id = userDTO._id;\n    user.mail_verified = coalesce(userDTO.isVerified, user.mail_verified);\n    if (userDTO.preference) {\n      user.preferences = user.preferences || {};\n      user.preferences.allow_tracking = coalesce(\n        userDTO.preference.allowTrackingPersonalInfo,\n        user.preferences?.allow_tracking,\n      );\n      user.preferences.language = coalesce(userDTO.preference.locale, user.preferences?.language);\n      user.preferences.timezone = coalesce(userDTO.preference.timeZone, user.preferences?.timezone);\n    }\n\n    const avatar = userDTO.avatar;\n\n    user.picture =\n      avatar && avatar.type && avatar.type !== \"url\"\n        ? this.infos.url.replace(/\\/$/, \"\") + \"/api/avatars/\" + avatar.value\n        : \"\";\n\n    await gr.services.users.save(user);\n\n    const getCompanyByCode = async (companyCode: string) => {\n      let company = await gr.services.companies.getCompany({\n        identity_provider_id: companyCode,\n      });\n      if (!company) {\n        const companyDTO = await this.fetchCompanyInfo(companyCode);\n        await this.updateLocalCompanyFromConsole(companyDTO);\n        company = await gr.services.companies.getCompany({\n          identity_provider_id: companyCode,\n        });\n      }\n      return company;\n    };\n\n    const updatedListOfCompanies = [];\n    if (roles) {\n      for (const role of roles) {\n        const companyConsoleCode = role.targetCode;\n        const roleName = role.roleCode;\n        const company = await getCompanyByCode(companyConsoleCode);\n        if (!company) {\n          throw CrudException.notFound(`Company ${companyConsoleCode} not found`);\n        }\n        //Make sure user is active, if not we remove it\n        if (role.status !== \"deactivated\") {\n          updatedListOfCompanies.push(company);\n          const applications = (role.applications || []).map(a => a.code);\n          await gr.services.companies.setUserRole(company.id, user.id, roleName, applications);\n        }\n      }\n    }\n\n    // Remove user from companies not in the console\n    const currentCompanies = await gr.services.companies.getAllForUser(user.id);\n    for (const company of currentCompanies) {\n      if (!updatedListOfCompanies.map(c => c.id).includes(company.group_id)) {\n        await gr.services.companies.removeUserFromCompany(\n          { id: company.group_id },\n          { id: user.id },\n        );\n      }\n    }\n\n    await gr.services.users.save(user, { user: { id: user.id, server_request: true } });\n\n    return user;\n  }\n\n  async removeCompanyUser(consoleUserId: string, company: Company): Promise<void> {\n    logger.info(\"Remote: removeCompanyUser\");\n\n    const user = await gr.services.users.getByConsoleId(consoleUserId);\n    if (!user) {\n      throw CrudException.notFound(`User ${consoleUserId} doesn't exists`);\n    }\n    await gr.services.companies.removeUserFromCompany({ id: company.id }, { id: user.id });\n  }\n\n  async removeUser(consoleUserId: string): Promise<void> {\n    logger.info(\"Remote: removeUser\");\n\n    const user = await gr.services.users.getByConsoleId(consoleUserId);\n\n    if (!user) {\n      throw new Error(\"User does not exists on Twake.\");\n    }\n\n    await gr.services.users.anonymizeAndDelete(\n      { id: user.id },\n      {\n        user: { id: user.id, server_request: true },\n      },\n    );\n  }\n\n  async removeCompany(companySearchKey: CompanySearchKey): Promise<void> {\n    logger.info(\"Remote: removeCompany\");\n    await gr.services.companies.removeCompany(companySearchKey);\n  }\n\n  fetchCompanyInfo(consoleCompanyCode: string): Promise<ConsoleHookCompany> {\n    logger.info(`Remote: fetchCompanyInfo ${consoleCompanyCode}`);\n    return this.client\n      .get(`/api/companies/${consoleCompanyCode}`, {\n        auth: this.auth(),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      })\n      .then(({ data }) => data.company)\n      .catch(e => {\n        if (e.response.status === 401) {\n          throw CrudException.forbidden(\"Bad console credentials\");\n        }\n        throw e;\n      });\n  }\n\n  fetchUserInfo(consoleUserId: string): Promise<ConsoleHookUser> {\n    logger.info(`Remote: fetchUserInfo ${consoleUserId}`);\n    return this.client\n      .get(`/api/users/${consoleUserId}`, {\n        auth: this.auth(),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      })\n      .then(({ data }) => data)\n      .catch(e => {\n        if (e.response.status === 401) {\n          throw CrudException.forbidden(\"Bad console credentials\");\n        }\n        throw e;\n      });\n  }\n\n  getUserByAccessToken(accessToken: string): Promise<ConsoleHookUser> {\n    logger.info(\"Remote: getUserByAccessToken\");\n    return this.client\n      .get(\"/api/users/profile\", {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${accessToken}`,\n        },\n      })\n      .then(({ data }) => data)\n      .catch(e => {\n        if (e.response?.status === 401) {\n          throw CrudException.forbidden(\"Bad access token credentials\");\n        }\n        throw e;\n      });\n  }\n\n  async resendVerificationEmail(email: string) {\n    logger.info(\"Remote: resendVerificationEmail\");\n    return this.client\n      .post(\n        \"/api/users/resend-verification-email\",\n        {\n          email,\n        },\n        {\n          auth: this.auth(),\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n        },\n      )\n      .then(({ data }) => data)\n      .catch(e => {\n        if (e.response.status === 401) {\n          throw CrudException.forbidden(\"Bad credentials\");\n        }\n        throw e;\n      });\n  }\n}\n"], "fixing_code": ["import axios, { AxiosInstance } from \"axios\";\nimport { v1 as uuidv1 } from \"uuid\";\nimport { ConsoleServiceClient } from \"../client-interface\";\nimport {\n  ConsoleCompany,\n  ConsoleHookCompany,\n  ConsoleHookUser,\n  ConsoleOptions,\n  CreateConsoleCompany,\n  CreateConsoleUser,\n  CreatedConsoleCompany,\n  CreatedConsoleUser,\n  UpdateConsoleUserRole,\n  UpdatedConsoleUserRole,\n} from \"../types\";\n\nimport User, { getInstance } from \"../../user/entities/user\";\nimport Company, {\n  CompanySearchKey,\n  getInstance as getCompanyInstance,\n} from \"../../user/entities/company\";\nimport { CrudException } from \"../../../core/platform/framework/api/crud-service\";\nimport coalesce from \"../../../utils/coalesce\";\nimport { logger } from \"../../../core/platform/framework/logger\";\nimport { CompanyFeaturesEnum, CompanyLimitsEnum } from \"../../user/web/types\";\nimport gr from \"../../global-resolver\";\nimport { ConsoleServiceImpl } from \"../service\";\n\nexport class ConsoleRemoteClient implements ConsoleServiceClient {\n  version: \"1\";\n  client: AxiosInstance;\n\n  private infos: ConsoleOptions;\n\n  constructor(consoleInstance: ConsoleServiceImpl, private dryRun: boolean) {\n    this.infos = consoleInstance.consoleOptions;\n    this.client = axios.create({ baseURL: this.infos.url });\n  }\n\n  private auth() {\n    return { username: this.infos.username, password: this.infos.password };\n  }\n\n  async addUserToCompany(\n    company: ConsoleCompany,\n    user: CreateConsoleUser,\n  ): Promise<CreatedConsoleUser> {\n    logger.info(\"Remote: addUserToCompany\");\n\n    const isNewConsole = this.infos.new_console;\n\n    if (this.dryRun) {\n      return {\n        _id: uuidv1(),\n      };\n    }\n\n    if (user.skipInvite && user.name && user.email && user.password) {\n      return this.client\n        .post(\n          `/api/companies/${company.code}/users`,\n          {\n            ...user,\n            ...(isNewConsole\n              ? {\n                  name: user.lastName ? user.firstName : user.name,\n                  surname: user.lastName,\n                  applicationCodes: [\"twake\"],\n                }\n              : {}),\n          },\n          {\n            auth: this.auth(),\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            params: {\n              skipInvite: user.skipInvite,\n            },\n          },\n        )\n        .then(({ data }) => data);\n    } else {\n      const invitationData = {\n        role: user.role,\n        emails: [\n          {\n            email: user.email,\n            role: user.role,\n          },\n        ],\n        inviter: { email: user.inviterEmail },\n        ...(isNewConsole\n          ? {\n              applicationCodes: [\"twake\"],\n            }\n          : {}),\n      };\n\n      const result = await this.client\n        .post(\n          `/api/companies/${company.code}/${isNewConsole ? \"invitations\" : \"users/invitation\"}`,\n          invitationData,\n          {\n            auth: this.auth(),\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n          },\n        )\n        .then(async ({ data, status }) => {\n          //Fixme: When console solve https://gitlab.com/COMPANY_LINAGORA/software/saas/twake-console-account/-/issues/36\n          //       we can remove this fallback\n          if ([200, 201].indexOf(status) >= 0) {\n            return data;\n          } else {\n            return this.client\n              .post(`/api/companies/${company.code}/users`, user, {\n                auth: this.auth(),\n                headers: {\n                  \"Content-Type\": \"application/json\",\n                },\n                params: {\n                  skipInvite: user.skipInvite,\n                },\n              })\n              .then(({ data }) => data);\n          }\n        });\n\n      return result;\n    }\n  }\n\n  async updateUserRole(\n    company: ConsoleCompany,\n    user: UpdateConsoleUserRole,\n  ): Promise<UpdatedConsoleUserRole> {\n    logger.info(\"Remote: updateUserRole\");\n\n    if (this.dryRun) {\n      return {\n        id: user.id,\n        role: user.role,\n      };\n    }\n\n    const result = await this.client\n      .put(\n        `/api/companies/${company.code}/users/${user.id}`,\n        { role: user.role },\n        {\n          auth: this.auth(),\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n        },\n      )\n      .then(({ data }) => data);\n\n    return result;\n  }\n\n  async createCompany(company: CreateConsoleCompany): Promise<CreatedConsoleCompany> {\n    logger.info(\"Remote: createCompany\");\n\n    if (this.dryRun) {\n      return company;\n    }\n\n    const result = await this.client\n      .post(\"/api/companies\", company, {\n        auth: this.auth(),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      })\n      .then(({ data }) => data);\n\n    return result;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  addUserToTwake(user: CreateConsoleUser): Promise<User> {\n    logger.info(\"Remote: addUserToTwake\");\n    //should do noting for real console\n    return Promise.resolve(undefined);\n  }\n\n  async updateLocalCompanyFromConsole(partialCompanyDTO: ConsoleHookCompany): Promise<Company> {\n    logger.info(\"Remote: updateLocalCompanyFromConsole\");\n\n    const companyDTO = await this.fetchCompanyInfo(partialCompanyDTO.details.code);\n\n    let company = await gr.services.companies.getCompany({\n      identity_provider_id: companyDTO.details.code,\n    });\n\n    if (!company) {\n      const newCompany = getCompanyInstance({\n        id: uuidv1(),\n        identity_provider: \"console\",\n        identity_provider_id: companyDTO.details.code,\n      });\n      company = await gr.services.companies.createCompany(newCompany);\n    }\n\n    const details = companyDTO.details;\n\n    if (details) {\n      company.name = coalesce(details.name, company.name);\n      company.displayName = coalesce(details.name, company.displayName);\n\n      const avatar = details.avatar;\n\n      company.logo =\n        details.logo ||\n        (avatar && avatar.type && avatar.type !== \"url\"\n          ? this.infos.url.replace(/\\/$/, \"\") + \"/api/avatars/\" + avatar.value\n          : companyDTO.value || \"\");\n    }\n\n    if (!company.plan) {\n      company.plan = { name: \"\", limits: undefined, features: undefined };\n    }\n\n    const limits = companyDTO.limits.twake || companyDTO.limits;\n\n    //FIXME this is a hack right now!\n    let planFeatures: any = {\n      [CompanyFeaturesEnum.CHAT_GUESTS]: true,\n      [CompanyFeaturesEnum.CHAT_MESSAGE_HISTORY]: true,\n      [CompanyFeaturesEnum.CHAT_MULTIPLE_WORKSPACES]: true,\n      [CompanyFeaturesEnum.CHAT_EDIT_FILES]: true,\n      [CompanyFeaturesEnum.CHAT_UNLIMITED_STORAGE]: true,\n      [CompanyFeaturesEnum.COMPANY_INVITE_MEMBER]: true,\n    };\n\n    if (limits.members < 0 && this.infos.type === \"remote\") {\n      //Hack to say this is free version\n      planFeatures = {\n        [CompanyFeaturesEnum.CHAT_GUESTS]: false,\n        [CompanyFeaturesEnum.CHAT_MESSAGE_HISTORY]: false,\n        [CompanyFeaturesEnum.CHAT_MULTIPLE_WORKSPACES]: false,\n        [CompanyFeaturesEnum.CHAT_EDIT_FILES]: false,\n        [CompanyFeaturesEnum.CHAT_UNLIMITED_STORAGE]: false, // Currently inactive\n      };\n      company.plan.name = \"free\";\n    } else {\n      company.plan.name = \"standard\";\n    }\n    company.plan.features = { ...planFeatures };\n    company.plan.limits = {\n      [CompanyLimitsEnum.CHAT_MESSAGE_HISTORY_LIMIT]: 10000, // To remove duplicata since we define this in formatCompany function\n      [CompanyLimitsEnum.COMPANY_MEMBERS_LIMIT]: limits[\"members\"],\n      [CompanyLimitsEnum.COMPANY_GUESTS_LIMIT]: limits[\"guests\"],\n    };\n\n    company.stats = coalesce(companyDTO.stats, company.stats);\n\n    await gr.services.companies.updateCompany(company);\n\n    return company;\n  }\n\n  async updateLocalUserFromConsole(code: string): Promise<User> {\n    logger.info(\"Remote: updateLocalUserFromConsole\");\n\n    const userDTO = await this.fetchUserInfo(code);\n\n    if (!userDTO) {\n      throw CrudException.badRequest(\"User not found on Console\");\n    }\n\n    const roles = userDTO.roles.filter(\n      role => role.applications === undefined || role.applications.find(a => a.code === \"twake\"),\n    );\n\n    let user = await gr.services.users.getByConsoleId(userDTO._id);\n\n    if (!user) {\n      if (!userDTO.email) {\n        throw CrudException.badRequest(\"Email is required\");\n      }\n\n      let username = userDTO.email\n        .split(\"@\")[0]\n        .toLocaleLowerCase()\n        .replace(/[^a-zA-Z0-9]/g, \"\")\n        .replace(/ +/g, \"_\");\n\n      if (await gr.services.users.isEmailAlreadyInUse(userDTO.email)) {\n        const user = await gr.services.users.getByEmail(userDTO.email);\n\n        if (user.identity_provider === \"console\") {\n          let emailUserOnConsole = null;\n          try {\n            emailUserOnConsole = await this.fetchUserInfo(user.identity_provider_id);\n          } catch (err) {}\n          if (emailUserOnConsole?._id) {\n            throw CrudException.badRequest(\n              `Console user not created because email already exists on console with different id: ${emailUserOnConsole._id} while requested to provision user with id: ${userDTO._id}`,\n            );\n          }\n\n          //If not present on console, then anonymise this one and create a new one\n          await gr.services.users.anonymizeAndDelete(\n            { id: user.id },\n            {\n              user: { id: user.id, server_request: true },\n            },\n          );\n\n          //Now we can create the new user\n        }\n      }\n\n      username = await gr.services.users.getAvailableUsername(username);\n      if (!username) {\n        throw CrudException.badRequest(\"Console user not created because username already exists\");\n      }\n\n      user = getInstance({});\n      user.username_canonical = (username || \"\").toLocaleLowerCase();\n      user.email_canonical = userDTO.email;\n      user.deleted = false;\n    }\n\n    user.email_canonical = coalesce(userDTO.email, user.email_canonical);\n    user.phone = \"\";\n    user.first_name = coalesce(userDTO.name, user.first_name);\n    user.last_name = coalesce(userDTO.surname, user.last_name);\n    user.identity_provider = \"console\";\n    user.identity_provider_id = userDTO._id;\n    user.mail_verified = coalesce(userDTO.isVerified, user.mail_verified);\n    if (userDTO.preference) {\n      user.preferences = user.preferences || {};\n      user.preferences.allow_tracking = coalesce(\n        userDTO.preference.allowTrackingPersonalInfo,\n        user.preferences?.allow_tracking,\n      );\n      user.preferences.language = coalesce(userDTO.preference.locale, user.preferences?.language);\n      user.preferences.timezone = coalesce(userDTO.preference.timeZone, user.preferences?.timezone);\n    }\n\n    const avatar = userDTO.avatar;\n\n    user.picture =\n      avatar && avatar.type && avatar.type !== \"url\"\n        ? this.infos.url.replace(/\\/$/, \"\") + \"/api/avatars/\" + avatar.value\n        : \"\";\n\n    await gr.services.users.save(user);\n\n    const getCompanyByCode = async (companyCode: string) => {\n      let company = await gr.services.companies.getCompany({\n        identity_provider_id: companyCode,\n      });\n      if (!company) {\n        const companyDTO = await this.fetchCompanyInfo(companyCode);\n        await this.updateLocalCompanyFromConsole(companyDTO);\n        company = await gr.services.companies.getCompany({\n          identity_provider_id: companyCode,\n        });\n      }\n      return company;\n    };\n\n    const updatedListOfCompanies = [];\n    if (roles) {\n      for (const role of roles) {\n        const companyConsoleCode = role.targetCode;\n        const roleName = role.roleCode;\n        const company = await getCompanyByCode(companyConsoleCode);\n        if (!company) {\n          throw CrudException.notFound(`Company ${companyConsoleCode} not found`);\n        }\n        //Make sure user is active, if not we remove it\n        if (role.status !== \"deactivated\") {\n          updatedListOfCompanies.push(company);\n          const applications = (role.applications || []).map(a => a.code);\n          await gr.services.companies.setUserRole(company.id, user.id, roleName, applications);\n        }\n      }\n    }\n\n    // Remove user from companies not in the console\n    const currentCompanies = await gr.services.companies.getAllForUser(user.id);\n    for (const company of currentCompanies) {\n      if (!updatedListOfCompanies.map(c => c.id).includes(company.group_id)) {\n        await gr.services.companies.removeUserFromCompany(\n          { id: company.group_id },\n          { id: user.id },\n        );\n      }\n    }\n\n    await gr.services.users.save(user, { user: { id: user.id, server_request: true } });\n\n    return user;\n  }\n\n  async removeCompanyUser(consoleUserId: string, company: Company): Promise<void> {\n    logger.info(\"Remote: removeCompanyUser\");\n\n    const user = await gr.services.users.getByConsoleId(consoleUserId);\n    if (!user) {\n      throw CrudException.notFound(`User ${consoleUserId} doesn't exists`);\n    }\n    await gr.services.companies.removeUserFromCompany({ id: company.id }, { id: user.id });\n  }\n\n  async removeUser(consoleUserId: string): Promise<void> {\n    logger.info(\"Remote: removeUser\");\n\n    const user = await gr.services.users.getByConsoleId(consoleUserId);\n\n    if (!user) {\n      throw new Error(\"User does not exists on Twake.\");\n    }\n\n    await gr.services.users.anonymizeAndDelete(\n      { id: user.id },\n      {\n        user: { id: user.id, server_request: true },\n      },\n    );\n  }\n\n  async removeCompany(companySearchKey: CompanySearchKey): Promise<void> {\n    logger.info(\"Remote: removeCompany\");\n    await gr.services.companies.removeCompany(companySearchKey);\n  }\n\n  fetchCompanyInfo(consoleCompanyCode: string): Promise<ConsoleHookCompany> {\n    logger.info(`Remote: fetchCompanyInfo ${consoleCompanyCode}`);\n    return this.client\n      .get(`/api/companies/${consoleCompanyCode}`, {\n        auth: this.auth(),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      })\n      .then(({ data }) => data.company)\n      .catch(e => {\n        if (e.response.status === 401) {\n          throw CrudException.forbidden(\"Bad console credentials\");\n        }\n        throw e;\n      });\n  }\n\n  fetchUserInfo(consoleUserId: string): Promise<ConsoleHookUser> {\n    logger.info(`Remote: fetchUserInfo ${consoleUserId}`);\n    return this.client\n      .get(`/api/users/${consoleUserId}`, {\n        auth: this.auth(),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      })\n      .then(({ data }) => data)\n      .catch(e => {\n        if (e.response.status === 401) {\n          throw CrudException.forbidden(\"Bad console credentials\");\n        }\n        throw e;\n      });\n  }\n\n  getUserByAccessToken(accessToken: string): Promise<ConsoleHookUser> {\n    logger.info(\"Remote: getUserByAccessToken\");\n    return this.client\n      .get(\"/api/users/profile\", {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${accessToken}`,\n        },\n      })\n      .then(({ data }) => data)\n      .catch(e => {\n        if (e.response?.status === 401) {\n          throw CrudException.forbidden(\"Bad access token credentials\");\n        }\n        throw e;\n      });\n  }\n\n  async resendVerificationEmail(email: string) {\n    logger.info(\"Remote: resendVerificationEmail\");\n    return this.client\n      .post(\n        \"/api/users/resend-verification-email\",\n        {\n          email,\n        },\n        {\n          auth: this.auth(),\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n        },\n      )\n      .then(({ data }) => data)\n      .catch(e => {\n        if (e.response.status === 401) {\n          throw CrudException.forbidden(\"Bad credentials\");\n        }\n        throw e;\n      });\n  }\n}\n"], "filenames": ["twake/backend/node/src/services/console/clients/remote.ts"], "buggy_code_start_loc": [60], "buggy_code_end_loc": [69], "fixing_code_start_loc": [60], "fixing_code_end_loc": [82], "type": "CWE-307", "message": "Improper Restriction of Excessive Authentication Attempts in GitHub repository linagora/twake prior to 2023.Q1.1223.", "other": {"cve": {"id": "CVE-2023-2675", "sourceIdentifier": "security@huntr.dev", "published": "2023-11-07T04:13:06.620", "lastModified": "2023-11-13T19:40:23.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Restriction of Excessive Authentication Attempts in GitHub repository linagora/twake prior to 2023.Q1.1223."}, {"lang": "es", "value": "Restricci\u00f3n inadecuada de intentos de autenticaci\u00f3n excesivos en el repositorio de GitHub linagora/twake antes de 2023.Q1.1223."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-307"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linagora:twake:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023.q1.1223", "matchCriteriaId": "95DB6849-F608-49E8-BEC3-0CA309E77AF5"}]}]}], "references": [{"url": "https://github.com/linagora/twake/commit/0770da3b184b5d5e71fee8251a5847a04c7cb9bc", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/474d3b39-1882-4d2c-b8f7-ff9f68f14cee", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/linagora/twake/commit/0770da3b184b5d5e71fee8251a5847a04c7cb9bc"}}