{"buggy_code": ["package command\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\n\tconfigtypes \"github.com/docker/cli/cli/config/types\"\n\t\"github.com/docker/cli/cli/debug\"\n\t\"github.com/docker/cli/cli/streams\"\n\t\"github.com/docker/distribution/reference\"\n\t\"github.com/docker/docker/api/types\"\n\tregistrytypes \"github.com/docker/docker/api/types/registry\"\n\t\"github.com/docker/docker/registry\"\n\t\"github.com/moby/term\"\n\t\"github.com/pkg/errors\"\n)\n\n// ElectAuthServer returns the default registry to use (by asking the daemon)\nfunc ElectAuthServer(ctx context.Context, cli Cli) string {\n\t// The daemon `/info` endpoint informs us of the default registry being\n\t// used. This is essential in cross-platforms environment, where for\n\t// example a Linux client might be interacting with a Windows daemon, hence\n\t// the default registry URL might be Windows specific.\n\tinfo, err := cli.Client().Info(ctx)\n\tif err != nil {\n\t\t// Daemon is not responding so use system default.\n\t\tif debug.IsEnabled() {\n\t\t\t// Only report the warning if we're in debug mode to prevent nagging during engine initialization workflows\n\t\t\tfmt.Fprintf(cli.Err(), \"Warning: failed to get default registry endpoint from daemon (%v). Using system default: %s\\n\", err, registry.IndexServer)\n\t\t}\n\t\treturn registry.IndexServer\n\t}\n\tif info.IndexServerAddress == \"\" {\n\t\tif debug.IsEnabled() {\n\t\t\tfmt.Fprintf(cli.Err(), \"Warning: Empty registry endpoint from daemon. Using system default: %s\\n\", registry.IndexServer)\n\t\t}\n\t\treturn registry.IndexServer\n\t}\n\treturn info.IndexServerAddress\n}\n\n// EncodeAuthToBase64 serializes the auth configuration as JSON base64 payload\nfunc EncodeAuthToBase64(authConfig types.AuthConfig) (string, error) {\n\tbuf, err := json.Marshal(authConfig)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn base64.URLEncoding.EncodeToString(buf), nil\n}\n\n// RegistryAuthenticationPrivilegedFunc returns a RequestPrivilegeFunc from the specified registry index info\n// for the given command.\nfunc RegistryAuthenticationPrivilegedFunc(cli Cli, index *registrytypes.IndexInfo, cmdName string) types.RequestPrivilegeFunc {\n\treturn func() (string, error) {\n\t\tfmt.Fprintf(cli.Out(), \"\\nPlease login prior to %s:\\n\", cmdName)\n\t\tindexServer := registry.GetAuthConfigKey(index)\n\t\tisDefaultRegistry := indexServer == ElectAuthServer(context.Background(), cli)\n\t\tauthConfig, err := GetDefaultAuthConfig(cli, true, indexServer, isDefaultRegistry)\n\t\tif authConfig == nil {\n\t\t\tauthConfig = &types.AuthConfig{}\n\t\t}\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(cli.Err(), \"Unable to retrieve stored credentials for %s, error: %s.\\n\", indexServer, err)\n\t\t}\n\t\terr = ConfigureAuth(cli, \"\", \"\", authConfig, isDefaultRegistry)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn EncodeAuthToBase64(*authConfig)\n\t}\n}\n\n// ResolveAuthConfig is like registry.ResolveAuthConfig, but if using the\n// default index, it uses the default index name for the daemon's platform,\n// not the client's platform.\nfunc ResolveAuthConfig(ctx context.Context, cli Cli, index *registrytypes.IndexInfo) types.AuthConfig {\n\tconfigKey := index.Name\n\tif index.Official {\n\t\tconfigKey = ElectAuthServer(ctx, cli)\n\t}\n\n\ta, _ := cli.ConfigFile().GetAuthConfig(configKey)\n\treturn types.AuthConfig(a)\n}\n\n// GetDefaultAuthConfig gets the default auth config given a serverAddress\n// If credentials for given serverAddress exists in the credential store, the configuration will be populated with values in it\nfunc GetDefaultAuthConfig(cli Cli, checkCredStore bool, serverAddress string, isDefaultRegistry bool) (*types.AuthConfig, error) {\n\tif !isDefaultRegistry {\n\t\tserverAddress = registry.ConvertToHostname(serverAddress)\n\t}\n\tvar authconfig = configtypes.AuthConfig{}\n\tvar err error\n\tif checkCredStore {\n\t\tauthconfig, err = cli.ConfigFile().GetAuthConfig(serverAddress)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tauthconfig.ServerAddress = serverAddress\n\tauthconfig.IdentityToken = \"\"\n\tres := types.AuthConfig(authconfig)\n\treturn &res, nil\n}\n\n// ConfigureAuth handles prompting of user's username and password if needed\nfunc ConfigureAuth(cli Cli, flUser, flPassword string, authconfig *types.AuthConfig, isDefaultRegistry bool) error {\n\t// On Windows, force the use of the regular OS stdin stream. Fixes #14336/#14210\n\tif runtime.GOOS == \"windows\" {\n\t\tcli.SetIn(streams.NewIn(os.Stdin))\n\t}\n\n\t// Some links documenting this:\n\t// - https://code.google.com/archive/p/mintty/issues/56\n\t// - https://github.com/docker/docker/issues/15272\n\t// - https://mintty.github.io/ (compatibility)\n\t// Linux will hit this if you attempt `cat | docker login`, and Windows\n\t// will hit this if you attempt docker login from mintty where stdin\n\t// is a pipe, not a character based console.\n\tif flPassword == \"\" && !cli.In().IsTerminal() {\n\t\treturn errors.Errorf(\"Error: Cannot perform an interactive login from a non TTY device\")\n\t}\n\n\tauthconfig.Username = strings.TrimSpace(authconfig.Username)\n\n\tif flUser = strings.TrimSpace(flUser); flUser == \"\" {\n\t\tif isDefaultRegistry {\n\t\t\t// if this is a default registry (docker hub), then display the following message.\n\t\t\tfmt.Fprintln(cli.Out(), \"Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\")\n\t\t}\n\t\tpromptWithDefault(cli.Out(), \"Username\", authconfig.Username)\n\t\tflUser = readInput(cli.In(), cli.Out())\n\t\tflUser = strings.TrimSpace(flUser)\n\t\tif flUser == \"\" {\n\t\t\tflUser = authconfig.Username\n\t\t}\n\t}\n\tif flUser == \"\" {\n\t\treturn errors.Errorf(\"Error: Non-null Username Required\")\n\t}\n\tif flPassword == \"\" {\n\t\toldState, err := term.SaveState(cli.In().FD())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Fprintf(cli.Out(), \"Password: \")\n\t\tterm.DisableEcho(cli.In().FD(), oldState)\n\n\t\tflPassword = readInput(cli.In(), cli.Out())\n\t\tfmt.Fprint(cli.Out(), \"\\n\")\n\n\t\tterm.RestoreTerminal(cli.In().FD(), oldState)\n\t\tif flPassword == \"\" {\n\t\t\treturn errors.Errorf(\"Error: Password Required\")\n\t\t}\n\t}\n\n\tauthconfig.Username = flUser\n\tauthconfig.Password = flPassword\n\n\treturn nil\n}\n\nfunc readInput(in io.Reader, out io.Writer) string {\n\treader := bufio.NewReader(in)\n\tline, _, err := reader.ReadLine()\n\tif err != nil {\n\t\tfmt.Fprintln(out, err.Error())\n\t\tos.Exit(1)\n\t}\n\treturn string(line)\n}\n\nfunc promptWithDefault(out io.Writer, prompt string, configDefault string) {\n\tif configDefault == \"\" {\n\t\tfmt.Fprintf(out, \"%s: \", prompt)\n\t} else {\n\t\tfmt.Fprintf(out, \"%s (%s): \", prompt, configDefault)\n\t}\n}\n\n// RetrieveAuthTokenFromImage retrieves an encoded auth token given a complete image\nfunc RetrieveAuthTokenFromImage(ctx context.Context, cli Cli, image string) (string, error) {\n\t// Retrieve encoded auth token from the image reference\n\tauthConfig, err := resolveAuthConfigFromImage(ctx, cli, image)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tencodedAuth, err := EncodeAuthToBase64(authConfig)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn encodedAuth, nil\n}\n\n// resolveAuthConfigFromImage retrieves that AuthConfig using the image string\nfunc resolveAuthConfigFromImage(ctx context.Context, cli Cli, image string) (types.AuthConfig, error) {\n\tregistryRef, err := reference.ParseNormalizedNamed(image)\n\tif err != nil {\n\t\treturn types.AuthConfig{}, err\n\t}\n\trepoInfo, err := registry.ParseRepositoryInfo(registryRef)\n\tif err != nil {\n\t\treturn types.AuthConfig{}, err\n\t}\n\treturn ResolveAuthConfig(ctx, cli, repoInfo.Index), nil\n}\n", "package registry\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n\n\t\"github.com/docker/cli/cli\"\n\t\"github.com/docker/cli/cli/command\"\n\tconfigtypes \"github.com/docker/cli/cli/config/types\"\n\t\"github.com/docker/docker/api/types\"\n\tregistrytypes \"github.com/docker/docker/api/types/registry\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/docker/registry\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/cobra\"\n)\n\nconst unencryptedWarning = `WARNING! Your password will be stored unencrypted in %s.\nConfigure a credential helper to remove this warning. See\nhttps://docs.docker.com/engine/reference/commandline/login/#credentials-store\n`\n\ntype loginOptions struct {\n\tserverAddress string\n\tuser          string\n\tpassword      string\n\tpasswordStdin bool\n}\n\n// NewLoginCommand creates a new `docker login` command\nfunc NewLoginCommand(dockerCli command.Cli) *cobra.Command {\n\tvar opts loginOptions\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"login [OPTIONS] [SERVER]\",\n\t\tShort: \"Log in to a Docker registry\",\n\t\tLong:  \"Log in to a Docker registry.\\nIf no server is specified, the default is defined by the daemon.\",\n\t\tArgs:  cli.RequiresMaxArgs(1),\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif len(args) > 0 {\n\t\t\t\topts.serverAddress = args[0]\n\t\t\t}\n\t\t\treturn runLogin(dockerCli, opts)\n\t\t},\n\t}\n\n\tflags := cmd.Flags()\n\n\tflags.StringVarP(&opts.user, \"username\", \"u\", \"\", \"Username\")\n\tflags.StringVarP(&opts.password, \"password\", \"p\", \"\", \"Password\")\n\tflags.BoolVarP(&opts.passwordStdin, \"password-stdin\", \"\", false, \"Take the password from stdin\")\n\n\treturn cmd\n}\n\n// displayUnencryptedWarning warns the user when using an insecure credential storage.\n// After a deprecation period, user will get prompted if stdin and stderr are a terminal.\n// Otherwise, we'll assume they want it (sadly), because people may have been scripting\n// insecure logins and we don't want to break them. Maybe they'll see the warning in their\n// logs and fix things.\nfunc displayUnencryptedWarning(dockerCli command.Streams, filename string) error {\n\t_, err := fmt.Fprintln(dockerCli.Err(), fmt.Sprintf(unencryptedWarning, filename))\n\n\treturn err\n}\n\ntype isFileStore interface {\n\tIsFileStore() bool\n\tGetFilename() string\n}\n\nfunc verifyloginOptions(dockerCli command.Cli, opts *loginOptions) error {\n\tif opts.password != \"\" {\n\t\tfmt.Fprintln(dockerCli.Err(), \"WARNING! Using --password via the CLI is insecure. Use --password-stdin.\")\n\t\tif opts.passwordStdin {\n\t\t\treturn errors.New(\"--password and --password-stdin are mutually exclusive\")\n\t\t}\n\t}\n\n\tif opts.passwordStdin {\n\t\tif opts.user == \"\" {\n\t\t\treturn errors.New(\"Must provide --username with --password-stdin\")\n\t\t}\n\n\t\tcontents, err := ioutil.ReadAll(dockerCli.In())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\topts.password = strings.TrimSuffix(string(contents), \"\\n\")\n\t\topts.password = strings.TrimSuffix(opts.password, \"\\r\")\n\t}\n\treturn nil\n}\n\nfunc runLogin(dockerCli command.Cli, opts loginOptions) error { //nolint: gocyclo\n\tctx := context.Background()\n\tclnt := dockerCli.Client()\n\tif err := verifyloginOptions(dockerCli, &opts); err != nil {\n\t\treturn err\n\t}\n\tvar (\n\t\tserverAddress string\n\t\tauthServer    = command.ElectAuthServer(ctx, dockerCli)\n\t)\n\tif opts.serverAddress != \"\" && opts.serverAddress != registry.DefaultNamespace {\n\t\tserverAddress = opts.serverAddress\n\t} else {\n\t\tserverAddress = authServer\n\t}\n\n\tvar response registrytypes.AuthenticateOKBody\n\tisDefaultRegistry := serverAddress == authServer\n\tauthConfig, err := command.GetDefaultAuthConfig(dockerCli, opts.user == \"\" && opts.password == \"\", serverAddress, isDefaultRegistry)\n\tif authConfig == nil {\n\t\tauthConfig = &types.AuthConfig{}\n\t}\n\tif err == nil && authConfig.Username != \"\" && authConfig.Password != \"\" {\n\t\tresponse, err = loginWithCredStoreCreds(ctx, dockerCli, authConfig)\n\t}\n\tif err != nil || authConfig.Username == \"\" || authConfig.Password == \"\" {\n\t\terr = command.ConfigureAuth(dockerCli, opts.user, opts.password, authConfig, isDefaultRegistry)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tresponse, err = clnt.RegistryLogin(ctx, *authConfig)\n\t\tif err != nil && client.IsErrConnectionFailed(err) {\n\t\t\t// If the server isn't responding (yet) attempt to login purely client side\n\t\t\tresponse, err = loginClientSide(ctx, *authConfig)\n\t\t}\n\t\t// If we (still) have an error, give up\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif response.IdentityToken != \"\" {\n\t\tauthConfig.Password = \"\"\n\t\tauthConfig.IdentityToken = response.IdentityToken\n\t}\n\n\tcreds := dockerCli.ConfigFile().GetCredentialsStore(serverAddress)\n\n\tstore, isDefault := creds.(isFileStore)\n\t// Display a warning if we're storing the users password (not a token)\n\tif isDefault && authConfig.Password != \"\" {\n\t\terr = displayUnencryptedWarning(dockerCli, store.GetFilename())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := creds.Store(configtypes.AuthConfig(*authConfig)); err != nil {\n\t\treturn errors.Errorf(\"Error saving credentials: %v\", err)\n\t}\n\n\tif response.Status != \"\" {\n\t\tfmt.Fprintln(dockerCli.Out(), response.Status)\n\t}\n\treturn nil\n}\n\nfunc loginWithCredStoreCreds(ctx context.Context, dockerCli command.Cli, authConfig *types.AuthConfig) (registrytypes.AuthenticateOKBody, error) {\n\tfmt.Fprintf(dockerCli.Out(), \"Authenticating with existing credentials...\\n\")\n\tcliClient := dockerCli.Client()\n\tresponse, err := cliClient.RegistryLogin(ctx, *authConfig)\n\tif err != nil {\n\t\tif client.IsErrUnauthorized(err) {\n\t\t\tfmt.Fprintf(dockerCli.Err(), \"Stored credentials invalid or expired\\n\")\n\t\t} else {\n\t\t\tfmt.Fprintf(dockerCli.Err(), \"Login did not succeed, error: %s\\n\", err)\n\t\t}\n\t}\n\treturn response, err\n}\n\nfunc loginClientSide(ctx context.Context, auth types.AuthConfig) (registrytypes.AuthenticateOKBody, error) {\n\tsvc, err := registry.NewService(registry.ServiceOptions{})\n\tif err != nil {\n\t\treturn registrytypes.AuthenticateOKBody{}, err\n\t}\n\n\tstatus, token, err := svc.Auth(ctx, &auth, command.UserAgent())\n\n\treturn registrytypes.AuthenticateOKBody{\n\t\tStatus:        status,\n\t\tIdentityToken: token,\n\t}, err\n}\n", "package command_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/pkg/errors\"\n\t\"gotest.tools/v3/assert\"\n\tis \"gotest.tools/v3/assert/cmp\"\n\n\t// Prevents a circular import with \"github.com/docker/cli/internal/test\"\n\n\t. \"github.com/docker/cli/cli/command\"\n\tconfigtypes \"github.com/docker/cli/cli/config/types\"\n\t\"github.com/docker/cli/cli/debug\"\n\t\"github.com/docker/cli/internal/test\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/client\"\n)\n\ntype fakeClient struct {\n\tclient.Client\n\tinfoFunc func() (types.Info, error)\n}\n\nvar testAuthConfigs = []types.AuthConfig{\n\t{\n\t\tServerAddress: \"https://index.docker.io/v1/\",\n\t\tUsername:      \"u0\",\n\t\tPassword:      \"p0\",\n\t},\n\t{\n\t\tServerAddress: \"server1.io\",\n\t\tUsername:      \"u1\",\n\t\tPassword:      \"p1\",\n\t},\n}\n\nfunc (cli *fakeClient) Info(_ context.Context) (types.Info, error) {\n\tif cli.infoFunc != nil {\n\t\treturn cli.infoFunc()\n\t}\n\treturn types.Info{}, nil\n}\n\nfunc TestElectAuthServer(t *testing.T) {\n\ttestCases := []struct {\n\t\texpectedAuthServer string\n\t\texpectedWarning    string\n\t\tinfoFunc           func() (types.Info, error)\n\t}{\n\t\t{\n\t\t\texpectedAuthServer: \"https://index.docker.io/v1/\",\n\t\t\texpectedWarning:    \"\",\n\t\t\tinfoFunc: func() (types.Info, error) {\n\t\t\t\treturn types.Info{IndexServerAddress: \"https://index.docker.io/v1/\"}, nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\texpectedAuthServer: \"https://index.docker.io/v1/\",\n\t\t\texpectedWarning:    \"Empty registry endpoint from daemon\",\n\t\t\tinfoFunc: func() (types.Info, error) {\n\t\t\t\treturn types.Info{IndexServerAddress: \"\"}, nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\texpectedAuthServer: \"https://foo.example.com\",\n\t\t\texpectedWarning:    \"\",\n\t\t\tinfoFunc: func() (types.Info, error) {\n\t\t\t\treturn types.Info{IndexServerAddress: \"https://foo.example.com\"}, nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\texpectedAuthServer: \"https://index.docker.io/v1/\",\n\t\t\texpectedWarning:    \"failed to get default registry endpoint from daemon\",\n\t\t\tinfoFunc: func() (types.Info, error) {\n\t\t\t\treturn types.Info{}, errors.Errorf(\"error getting info\")\n\t\t\t},\n\t\t},\n\t}\n\t// Enable debug to see warnings we're checking for\n\tdebug.Enable()\n\tfor _, tc := range testCases {\n\t\tcli := test.NewFakeCli(&fakeClient{infoFunc: tc.infoFunc})\n\t\tserver := ElectAuthServer(context.Background(), cli)\n\t\tassert.Check(t, is.Equal(tc.expectedAuthServer, server))\n\t\tactual := cli.ErrBuffer().String()\n\t\tif tc.expectedWarning == \"\" {\n\t\t\tassert.Check(t, is.Len(actual, 0))\n\t\t} else {\n\t\t\tassert.Check(t, is.Contains(actual, tc.expectedWarning))\n\t\t}\n\t}\n}\n\nfunc TestGetDefaultAuthConfig(t *testing.T) {\n\ttestCases := []struct {\n\t\tcheckCredStore     bool\n\t\tinputServerAddress string\n\t\texpectedErr        string\n\t\texpectedAuthConfig types.AuthConfig\n\t}{\n\t\t{\n\t\t\tcheckCredStore:     false,\n\t\t\tinputServerAddress: \"\",\n\t\t\texpectedErr:        \"\",\n\t\t\texpectedAuthConfig: types.AuthConfig{\n\t\t\t\tServerAddress: \"\",\n\t\t\t\tUsername:      \"\",\n\t\t\t\tPassword:      \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcheckCredStore:     true,\n\t\t\tinputServerAddress: testAuthConfigs[0].ServerAddress,\n\t\t\texpectedErr:        \"\",\n\t\t\texpectedAuthConfig: testAuthConfigs[0],\n\t\t},\n\t\t{\n\t\t\tcheckCredStore:     true,\n\t\t\tinputServerAddress: testAuthConfigs[1].ServerAddress,\n\t\t\texpectedErr:        \"\",\n\t\t\texpectedAuthConfig: testAuthConfigs[1],\n\t\t},\n\t\t{\n\t\t\tcheckCredStore:     true,\n\t\t\tinputServerAddress: fmt.Sprintf(\"https://%s\", testAuthConfigs[1].ServerAddress),\n\t\t\texpectedErr:        \"\",\n\t\t\texpectedAuthConfig: testAuthConfigs[1],\n\t\t},\n\t}\n\tcli := test.NewFakeCli(&fakeClient{})\n\terrBuf := new(bytes.Buffer)\n\tcli.SetErr(errBuf)\n\tfor _, authconfig := range testAuthConfigs {\n\t\tcli.ConfigFile().GetCredentialsStore(authconfig.ServerAddress).Store(configtypes.AuthConfig(authconfig))\n\t}\n\tfor _, tc := range testCases {\n\t\tserverAddress := tc.inputServerAddress\n\t\tauthconfig, err := GetDefaultAuthConfig(cli, tc.checkCredStore, serverAddress, serverAddress == \"https://index.docker.io/v1/\")\n\t\tif tc.expectedErr != \"\" {\n\t\t\tassert.Check(t, err != nil)\n\t\t\tassert.Check(t, is.Equal(tc.expectedErr, err.Error()))\n\t\t} else {\n\t\t\tassert.NilError(t, err)\n\t\t\tassert.Check(t, is.DeepEqual(tc.expectedAuthConfig, *authconfig))\n\t\t}\n\t}\n}\n"], "fixing_code": ["package command\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\n\tconfigtypes \"github.com/docker/cli/cli/config/types\"\n\t\"github.com/docker/cli/cli/debug\"\n\t\"github.com/docker/cli/cli/streams\"\n\t\"github.com/docker/distribution/reference\"\n\t\"github.com/docker/docker/api/types\"\n\tregistrytypes \"github.com/docker/docker/api/types/registry\"\n\t\"github.com/docker/docker/registry\"\n\t\"github.com/moby/term\"\n\t\"github.com/pkg/errors\"\n)\n\n// ElectAuthServer returns the default registry to use (by asking the daemon)\nfunc ElectAuthServer(ctx context.Context, cli Cli) string {\n\t// The daemon `/info` endpoint informs us of the default registry being\n\t// used. This is essential in cross-platforms environment, where for\n\t// example a Linux client might be interacting with a Windows daemon, hence\n\t// the default registry URL might be Windows specific.\n\tinfo, err := cli.Client().Info(ctx)\n\tif err != nil {\n\t\t// Daemon is not responding so use system default.\n\t\tif debug.IsEnabled() {\n\t\t\t// Only report the warning if we're in debug mode to prevent nagging during engine initialization workflows\n\t\t\tfmt.Fprintf(cli.Err(), \"Warning: failed to get default registry endpoint from daemon (%v). Using system default: %s\\n\", err, registry.IndexServer)\n\t\t}\n\t\treturn registry.IndexServer\n\t}\n\tif info.IndexServerAddress == \"\" {\n\t\tif debug.IsEnabled() {\n\t\t\tfmt.Fprintf(cli.Err(), \"Warning: Empty registry endpoint from daemon. Using system default: %s\\n\", registry.IndexServer)\n\t\t}\n\t\treturn registry.IndexServer\n\t}\n\treturn info.IndexServerAddress\n}\n\n// EncodeAuthToBase64 serializes the auth configuration as JSON base64 payload\nfunc EncodeAuthToBase64(authConfig types.AuthConfig) (string, error) {\n\tbuf, err := json.Marshal(authConfig)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn base64.URLEncoding.EncodeToString(buf), nil\n}\n\n// RegistryAuthenticationPrivilegedFunc returns a RequestPrivilegeFunc from the specified registry index info\n// for the given command.\nfunc RegistryAuthenticationPrivilegedFunc(cli Cli, index *registrytypes.IndexInfo, cmdName string) types.RequestPrivilegeFunc {\n\treturn func() (string, error) {\n\t\tfmt.Fprintf(cli.Out(), \"\\nPlease login prior to %s:\\n\", cmdName)\n\t\tindexServer := registry.GetAuthConfigKey(index)\n\t\tisDefaultRegistry := indexServer == ElectAuthServer(context.Background(), cli)\n\t\tauthConfig, err := GetDefaultAuthConfig(cli, true, indexServer, isDefaultRegistry)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(cli.Err(), \"Unable to retrieve stored credentials for %s, error: %s.\\n\", indexServer, err)\n\t\t}\n\t\terr = ConfigureAuth(cli, \"\", \"\", &authConfig, isDefaultRegistry)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn EncodeAuthToBase64(authConfig)\n\t}\n}\n\n// ResolveAuthConfig is like registry.ResolveAuthConfig, but if using the\n// default index, it uses the default index name for the daemon's platform,\n// not the client's platform.\nfunc ResolveAuthConfig(ctx context.Context, cli Cli, index *registrytypes.IndexInfo) types.AuthConfig {\n\tconfigKey := index.Name\n\tif index.Official {\n\t\tconfigKey = ElectAuthServer(ctx, cli)\n\t}\n\n\ta, _ := cli.ConfigFile().GetAuthConfig(configKey)\n\treturn types.AuthConfig(a)\n}\n\n// GetDefaultAuthConfig gets the default auth config given a serverAddress\n// If credentials for given serverAddress exists in the credential store, the configuration will be populated with values in it\nfunc GetDefaultAuthConfig(cli Cli, checkCredStore bool, serverAddress string, isDefaultRegistry bool) (types.AuthConfig, error) {\n\tif !isDefaultRegistry {\n\t\tserverAddress = registry.ConvertToHostname(serverAddress)\n\t}\n\tvar authconfig = configtypes.AuthConfig{}\n\tvar err error\n\tif checkCredStore {\n\t\tauthconfig, err = cli.ConfigFile().GetAuthConfig(serverAddress)\n\t\tif err != nil {\n\t\t\treturn types.AuthConfig{\n\t\t\t\tServerAddress: serverAddress,\n\t\t\t}, err\n\t\t}\n\t}\n\tauthconfig.ServerAddress = serverAddress\n\tauthconfig.IdentityToken = \"\"\n\tres := types.AuthConfig(authconfig)\n\treturn res, nil\n}\n\n// ConfigureAuth handles prompting of user's username and password if needed\nfunc ConfigureAuth(cli Cli, flUser, flPassword string, authconfig *types.AuthConfig, isDefaultRegistry bool) error {\n\t// On Windows, force the use of the regular OS stdin stream. Fixes #14336/#14210\n\tif runtime.GOOS == \"windows\" {\n\t\tcli.SetIn(streams.NewIn(os.Stdin))\n\t}\n\n\t// Some links documenting this:\n\t// - https://code.google.com/archive/p/mintty/issues/56\n\t// - https://github.com/docker/docker/issues/15272\n\t// - https://mintty.github.io/ (compatibility)\n\t// Linux will hit this if you attempt `cat | docker login`, and Windows\n\t// will hit this if you attempt docker login from mintty where stdin\n\t// is a pipe, not a character based console.\n\tif flPassword == \"\" && !cli.In().IsTerminal() {\n\t\treturn errors.Errorf(\"Error: Cannot perform an interactive login from a non TTY device\")\n\t}\n\n\tauthconfig.Username = strings.TrimSpace(authconfig.Username)\n\n\tif flUser = strings.TrimSpace(flUser); flUser == \"\" {\n\t\tif isDefaultRegistry {\n\t\t\t// if this is a default registry (docker hub), then display the following message.\n\t\t\tfmt.Fprintln(cli.Out(), \"Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\")\n\t\t}\n\t\tpromptWithDefault(cli.Out(), \"Username\", authconfig.Username)\n\t\tflUser = readInput(cli.In(), cli.Out())\n\t\tflUser = strings.TrimSpace(flUser)\n\t\tif flUser == \"\" {\n\t\t\tflUser = authconfig.Username\n\t\t}\n\t}\n\tif flUser == \"\" {\n\t\treturn errors.Errorf(\"Error: Non-null Username Required\")\n\t}\n\tif flPassword == \"\" {\n\t\toldState, err := term.SaveState(cli.In().FD())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Fprintf(cli.Out(), \"Password: \")\n\t\tterm.DisableEcho(cli.In().FD(), oldState)\n\n\t\tflPassword = readInput(cli.In(), cli.Out())\n\t\tfmt.Fprint(cli.Out(), \"\\n\")\n\n\t\tterm.RestoreTerminal(cli.In().FD(), oldState)\n\t\tif flPassword == \"\" {\n\t\t\treturn errors.Errorf(\"Error: Password Required\")\n\t\t}\n\t}\n\n\tauthconfig.Username = flUser\n\tauthconfig.Password = flPassword\n\n\treturn nil\n}\n\nfunc readInput(in io.Reader, out io.Writer) string {\n\treader := bufio.NewReader(in)\n\tline, _, err := reader.ReadLine()\n\tif err != nil {\n\t\tfmt.Fprintln(out, err.Error())\n\t\tos.Exit(1)\n\t}\n\treturn string(line)\n}\n\nfunc promptWithDefault(out io.Writer, prompt string, configDefault string) {\n\tif configDefault == \"\" {\n\t\tfmt.Fprintf(out, \"%s: \", prompt)\n\t} else {\n\t\tfmt.Fprintf(out, \"%s (%s): \", prompt, configDefault)\n\t}\n}\n\n// RetrieveAuthTokenFromImage retrieves an encoded auth token given a complete image\nfunc RetrieveAuthTokenFromImage(ctx context.Context, cli Cli, image string) (string, error) {\n\t// Retrieve encoded auth token from the image reference\n\tauthConfig, err := resolveAuthConfigFromImage(ctx, cli, image)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tencodedAuth, err := EncodeAuthToBase64(authConfig)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn encodedAuth, nil\n}\n\n// resolveAuthConfigFromImage retrieves that AuthConfig using the image string\nfunc resolveAuthConfigFromImage(ctx context.Context, cli Cli, image string) (types.AuthConfig, error) {\n\tregistryRef, err := reference.ParseNormalizedNamed(image)\n\tif err != nil {\n\t\treturn types.AuthConfig{}, err\n\t}\n\trepoInfo, err := registry.ParseRepositoryInfo(registryRef)\n\tif err != nil {\n\t\treturn types.AuthConfig{}, err\n\t}\n\treturn ResolveAuthConfig(ctx, cli, repoInfo.Index), nil\n}\n", "package registry\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n\n\t\"github.com/docker/cli/cli\"\n\t\"github.com/docker/cli/cli/command\"\n\tconfigtypes \"github.com/docker/cli/cli/config/types\"\n\t\"github.com/docker/docker/api/types\"\n\tregistrytypes \"github.com/docker/docker/api/types/registry\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/docker/registry\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/cobra\"\n)\n\nconst unencryptedWarning = `WARNING! Your password will be stored unencrypted in %s.\nConfigure a credential helper to remove this warning. See\nhttps://docs.docker.com/engine/reference/commandline/login/#credentials-store\n`\n\ntype loginOptions struct {\n\tserverAddress string\n\tuser          string\n\tpassword      string\n\tpasswordStdin bool\n}\n\n// NewLoginCommand creates a new `docker login` command\nfunc NewLoginCommand(dockerCli command.Cli) *cobra.Command {\n\tvar opts loginOptions\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"login [OPTIONS] [SERVER]\",\n\t\tShort: \"Log in to a Docker registry\",\n\t\tLong:  \"Log in to a Docker registry.\\nIf no server is specified, the default is defined by the daemon.\",\n\t\tArgs:  cli.RequiresMaxArgs(1),\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif len(args) > 0 {\n\t\t\t\topts.serverAddress = args[0]\n\t\t\t}\n\t\t\treturn runLogin(dockerCli, opts)\n\t\t},\n\t}\n\n\tflags := cmd.Flags()\n\n\tflags.StringVarP(&opts.user, \"username\", \"u\", \"\", \"Username\")\n\tflags.StringVarP(&opts.password, \"password\", \"p\", \"\", \"Password\")\n\tflags.BoolVarP(&opts.passwordStdin, \"password-stdin\", \"\", false, \"Take the password from stdin\")\n\n\treturn cmd\n}\n\n// displayUnencryptedWarning warns the user when using an insecure credential storage.\n// After a deprecation period, user will get prompted if stdin and stderr are a terminal.\n// Otherwise, we'll assume they want it (sadly), because people may have been scripting\n// insecure logins and we don't want to break them. Maybe they'll see the warning in their\n// logs and fix things.\nfunc displayUnencryptedWarning(dockerCli command.Streams, filename string) error {\n\t_, err := fmt.Fprintln(dockerCli.Err(), fmt.Sprintf(unencryptedWarning, filename))\n\n\treturn err\n}\n\ntype isFileStore interface {\n\tIsFileStore() bool\n\tGetFilename() string\n}\n\nfunc verifyloginOptions(dockerCli command.Cli, opts *loginOptions) error {\n\tif opts.password != \"\" {\n\t\tfmt.Fprintln(dockerCli.Err(), \"WARNING! Using --password via the CLI is insecure. Use --password-stdin.\")\n\t\tif opts.passwordStdin {\n\t\t\treturn errors.New(\"--password and --password-stdin are mutually exclusive\")\n\t\t}\n\t}\n\n\tif opts.passwordStdin {\n\t\tif opts.user == \"\" {\n\t\t\treturn errors.New(\"Must provide --username with --password-stdin\")\n\t\t}\n\n\t\tcontents, err := ioutil.ReadAll(dockerCli.In())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\topts.password = strings.TrimSuffix(string(contents), \"\\n\")\n\t\topts.password = strings.TrimSuffix(opts.password, \"\\r\")\n\t}\n\treturn nil\n}\n\nfunc runLogin(dockerCli command.Cli, opts loginOptions) error { //nolint: gocyclo\n\tctx := context.Background()\n\tclnt := dockerCli.Client()\n\tif err := verifyloginOptions(dockerCli, &opts); err != nil {\n\t\treturn err\n\t}\n\tvar (\n\t\tserverAddress string\n\t\tauthServer    = command.ElectAuthServer(ctx, dockerCli)\n\t)\n\tif opts.serverAddress != \"\" && opts.serverAddress != registry.DefaultNamespace {\n\t\tserverAddress = opts.serverAddress\n\t} else {\n\t\tserverAddress = authServer\n\t}\n\n\tvar response registrytypes.AuthenticateOKBody\n\tisDefaultRegistry := serverAddress == authServer\n\tauthConfig, err := command.GetDefaultAuthConfig(dockerCli, opts.user == \"\" && opts.password == \"\", serverAddress, isDefaultRegistry)\n\tif err == nil && authConfig.Username != \"\" && authConfig.Password != \"\" {\n\t\tresponse, err = loginWithCredStoreCreds(ctx, dockerCli, &authConfig)\n\t}\n\tif err != nil || authConfig.Username == \"\" || authConfig.Password == \"\" {\n\t\terr = command.ConfigureAuth(dockerCli, opts.user, opts.password, &authConfig, isDefaultRegistry)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tresponse, err = clnt.RegistryLogin(ctx, authConfig)\n\t\tif err != nil && client.IsErrConnectionFailed(err) {\n\t\t\t// If the server isn't responding (yet) attempt to login purely client side\n\t\t\tresponse, err = loginClientSide(ctx, authConfig)\n\t\t}\n\t\t// If we (still) have an error, give up\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif response.IdentityToken != \"\" {\n\t\tauthConfig.Password = \"\"\n\t\tauthConfig.IdentityToken = response.IdentityToken\n\t}\n\n\tcreds := dockerCli.ConfigFile().GetCredentialsStore(serverAddress)\n\n\tstore, isDefault := creds.(isFileStore)\n\t// Display a warning if we're storing the users password (not a token)\n\tif isDefault && authConfig.Password != \"\" {\n\t\terr = displayUnencryptedWarning(dockerCli, store.GetFilename())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := creds.Store(configtypes.AuthConfig(authConfig)); err != nil {\n\t\treturn errors.Errorf(\"Error saving credentials: %v\", err)\n\t}\n\n\tif response.Status != \"\" {\n\t\tfmt.Fprintln(dockerCli.Out(), response.Status)\n\t}\n\treturn nil\n}\n\nfunc loginWithCredStoreCreds(ctx context.Context, dockerCli command.Cli, authConfig *types.AuthConfig) (registrytypes.AuthenticateOKBody, error) {\n\tfmt.Fprintf(dockerCli.Out(), \"Authenticating with existing credentials...\\n\")\n\tcliClient := dockerCli.Client()\n\tresponse, err := cliClient.RegistryLogin(ctx, *authConfig)\n\tif err != nil {\n\t\tif client.IsErrUnauthorized(err) {\n\t\t\tfmt.Fprintf(dockerCli.Err(), \"Stored credentials invalid or expired\\n\")\n\t\t} else {\n\t\t\tfmt.Fprintf(dockerCli.Err(), \"Login did not succeed, error: %s\\n\", err)\n\t\t}\n\t}\n\treturn response, err\n}\n\nfunc loginClientSide(ctx context.Context, auth types.AuthConfig) (registrytypes.AuthenticateOKBody, error) {\n\tsvc, err := registry.NewService(registry.ServiceOptions{})\n\tif err != nil {\n\t\treturn registrytypes.AuthenticateOKBody{}, err\n\t}\n\n\tstatus, token, err := svc.Auth(ctx, &auth, command.UserAgent())\n\n\treturn registrytypes.AuthenticateOKBody{\n\t\tStatus:        status,\n\t\tIdentityToken: token,\n\t}, err\n}\n", "package command_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/pkg/errors\"\n\t\"gotest.tools/v3/assert\"\n\tis \"gotest.tools/v3/assert/cmp\"\n\n\t// Prevents a circular import with \"github.com/docker/cli/internal/test\"\n\n\t. \"github.com/docker/cli/cli/command\"\n\tconfigtypes \"github.com/docker/cli/cli/config/types\"\n\t\"github.com/docker/cli/cli/debug\"\n\t\"github.com/docker/cli/internal/test\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/client\"\n)\n\ntype fakeClient struct {\n\tclient.Client\n\tinfoFunc func() (types.Info, error)\n}\n\nvar testAuthConfigs = []types.AuthConfig{\n\t{\n\t\tServerAddress: \"https://index.docker.io/v1/\",\n\t\tUsername:      \"u0\",\n\t\tPassword:      \"p0\",\n\t},\n\t{\n\t\tServerAddress: \"server1.io\",\n\t\tUsername:      \"u1\",\n\t\tPassword:      \"p1\",\n\t},\n}\n\nfunc (cli *fakeClient) Info(_ context.Context) (types.Info, error) {\n\tif cli.infoFunc != nil {\n\t\treturn cli.infoFunc()\n\t}\n\treturn types.Info{}, nil\n}\n\nfunc TestElectAuthServer(t *testing.T) {\n\ttestCases := []struct {\n\t\texpectedAuthServer string\n\t\texpectedWarning    string\n\t\tinfoFunc           func() (types.Info, error)\n\t}{\n\t\t{\n\t\t\texpectedAuthServer: \"https://index.docker.io/v1/\",\n\t\t\texpectedWarning:    \"\",\n\t\t\tinfoFunc: func() (types.Info, error) {\n\t\t\t\treturn types.Info{IndexServerAddress: \"https://index.docker.io/v1/\"}, nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\texpectedAuthServer: \"https://index.docker.io/v1/\",\n\t\t\texpectedWarning:    \"Empty registry endpoint from daemon\",\n\t\t\tinfoFunc: func() (types.Info, error) {\n\t\t\t\treturn types.Info{IndexServerAddress: \"\"}, nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\texpectedAuthServer: \"https://foo.example.com\",\n\t\t\texpectedWarning:    \"\",\n\t\t\tinfoFunc: func() (types.Info, error) {\n\t\t\t\treturn types.Info{IndexServerAddress: \"https://foo.example.com\"}, nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\texpectedAuthServer: \"https://index.docker.io/v1/\",\n\t\t\texpectedWarning:    \"failed to get default registry endpoint from daemon\",\n\t\t\tinfoFunc: func() (types.Info, error) {\n\t\t\t\treturn types.Info{}, errors.Errorf(\"error getting info\")\n\t\t\t},\n\t\t},\n\t}\n\t// Enable debug to see warnings we're checking for\n\tdebug.Enable()\n\tfor _, tc := range testCases {\n\t\tcli := test.NewFakeCli(&fakeClient{infoFunc: tc.infoFunc})\n\t\tserver := ElectAuthServer(context.Background(), cli)\n\t\tassert.Check(t, is.Equal(tc.expectedAuthServer, server))\n\t\tactual := cli.ErrBuffer().String()\n\t\tif tc.expectedWarning == \"\" {\n\t\t\tassert.Check(t, is.Len(actual, 0))\n\t\t} else {\n\t\t\tassert.Check(t, is.Contains(actual, tc.expectedWarning))\n\t\t}\n\t}\n}\n\nfunc TestGetDefaultAuthConfig(t *testing.T) {\n\ttestCases := []struct {\n\t\tcheckCredStore     bool\n\t\tinputServerAddress string\n\t\texpectedErr        string\n\t\texpectedAuthConfig types.AuthConfig\n\t}{\n\t\t{\n\t\t\tcheckCredStore:     false,\n\t\t\tinputServerAddress: \"\",\n\t\t\texpectedErr:        \"\",\n\t\t\texpectedAuthConfig: types.AuthConfig{\n\t\t\t\tServerAddress: \"\",\n\t\t\t\tUsername:      \"\",\n\t\t\t\tPassword:      \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcheckCredStore:     true,\n\t\t\tinputServerAddress: testAuthConfigs[0].ServerAddress,\n\t\t\texpectedErr:        \"\",\n\t\t\texpectedAuthConfig: testAuthConfigs[0],\n\t\t},\n\t\t{\n\t\t\tcheckCredStore:     true,\n\t\t\tinputServerAddress: testAuthConfigs[1].ServerAddress,\n\t\t\texpectedErr:        \"\",\n\t\t\texpectedAuthConfig: testAuthConfigs[1],\n\t\t},\n\t\t{\n\t\t\tcheckCredStore:     true,\n\t\t\tinputServerAddress: fmt.Sprintf(\"https://%s\", testAuthConfigs[1].ServerAddress),\n\t\t\texpectedErr:        \"\",\n\t\t\texpectedAuthConfig: testAuthConfigs[1],\n\t\t},\n\t}\n\tcli := test.NewFakeCli(&fakeClient{})\n\terrBuf := new(bytes.Buffer)\n\tcli.SetErr(errBuf)\n\tfor _, authconfig := range testAuthConfigs {\n\t\tcli.ConfigFile().GetCredentialsStore(authconfig.ServerAddress).Store(configtypes.AuthConfig(authconfig))\n\t}\n\tfor _, tc := range testCases {\n\t\tserverAddress := tc.inputServerAddress\n\t\tauthconfig, err := GetDefaultAuthConfig(cli, tc.checkCredStore, serverAddress, serverAddress == \"https://index.docker.io/v1/\")\n\t\tif tc.expectedErr != \"\" {\n\t\t\tassert.Check(t, err != nil)\n\t\t\tassert.Check(t, is.Equal(tc.expectedErr, err.Error()))\n\t\t} else {\n\t\t\tassert.NilError(t, err)\n\t\t\tassert.Check(t, is.DeepEqual(tc.expectedAuthConfig, authconfig))\n\t\t}\n\t}\n}\n\nfunc TestGetDefaultAuthConfig_HelperError(t *testing.T) {\n\tcli := test.NewFakeCli(&fakeClient{})\n\terrBuf := new(bytes.Buffer)\n\tcli.SetErr(errBuf)\n\tcli.ConfigFile().CredentialsStore = \"fake-does-not-exist\"\n\tserverAddress := \"test-server-address\"\n\texpectedAuthConfig := types.AuthConfig{\n\t\tServerAddress: serverAddress,\n\t}\n\tauthconfig, err := GetDefaultAuthConfig(cli, true, serverAddress, serverAddress == \"https://index.docker.io/v1/\")\n\tassert.Check(t, is.DeepEqual(expectedAuthConfig, authconfig))\n\tassert.Check(t, is.ErrorContains(err, \"docker-credential-fake-does-not-exist\"))\n}\n"], "filenames": ["cli/command/registry.go", "cli/command/registry/login.go", "cli/command/registry_test.go"], "buggy_code_start_loc": [66, 117, 148], "buggy_code_end_loc": [111, 156, 151], "fixing_code_start_loc": [65, 116, 148], "fixing_code_end_loc": [110, 153, 166], "type": "CWE-200", "message": "Docker CLI is the command line interface for the docker container runtime. A bug was found in the Docker CLI where running `docker login my-private-registry.example.com` with a misconfigured configuration file (typically `~/.docker/config.json`) listing a `credsStore` or `credHelpers` that could not be executed would result in any provided credentials being sent to `registry-1.docker.io` rather than the intended private registry. This bug has been fixed in Docker CLI 20.10.9. Users should update to this version as soon as possible. For users unable to update ensure that any configured credsStore or credHelpers entries in the configuration file reference an installed credential helper that is executable and on the PATH.", "other": {"cve": {"id": "CVE-2021-41092", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-04T20:15:07.757", "lastModified": "2022-06-14T11:15:10.760", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Docker CLI is the command line interface for the docker container runtime. A bug was found in the Docker CLI where running `docker login my-private-registry.example.com` with a misconfigured configuration file (typically `~/.docker/config.json`) listing a `credsStore` or `credHelpers` that could not be executed would result in any provided credentials being sent to `registry-1.docker.io` rather than the intended private registry. This bug has been fixed in Docker CLI 20.10.9. Users should update to this version as soon as possible. For users unable to update ensure that any configured credsStore or credHelpers entries in the configuration file reference an installed credential helper that is executable and on the PATH."}, {"lang": "es", "value": "Docker CLI es la interfaz de l\u00ednea de comandos para el tiempo de ejecuci\u00f3n del contenedor Docker. Se encontr\u00f3 un bug en Docker CLI en el que la ejecuci\u00f3n de \"docker login my-private-registry.example.com\" con un archivo de configuraci\u00f3n configurado inapropiadamente (normalmente \"~/.docker/config.json\") con una lista de \"credsStore\" o \"credHelpers\" que no pod\u00eda ser ejecutada, resultar\u00eda en que cualquier credencial proporcionada fuera enviada a \"registry-1.docker.io\" en lugar del registro privado previsto. Este bug ha sido corregido en Docker CLI versi\u00f3n  20.10.9. Los usuarios deben actualizar a esta versi\u00f3n tan pronto como sea posible. Para usuarios que no puedan actualizar, aseg\u00farese de que las entradas credsStore o credHelpers configuradas en el archivo de configuraci\u00f3n hagan referencia a un ayudante de credenciales instalado que sea ejecutable y est\u00e9 en el PATH"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-522"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:docker:command_line_interface:*:*:*:*:*:*:*:*", "versionEndExcluding": "20.10.9", "matchCriteriaId": "A15A6670-8646-4CAD-B4B0-BC80CD53CD32"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-222547.pdf", "source": "security-advisories@github.com"}, {"url": "https://github.com/docker/cli/commit/893e52cf4ba4b048d72e99748e0f86b2767c6c6b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/docker/cli/security/advisories/GHSA-99pg-grm5-qq3v", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/B5Q6G6I4W5COQE25QMC7FJY3I3PAYFBB/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZNFADTCHHYWVM6W4NJ6CB4FNFM2VMBIB/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/docker/cli/commit/893e52cf4ba4b048d72e99748e0f86b2767c6c6b"}}