{"buggy_code": ["/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include <stdint.h>\n\n#include <vector>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/kernels/internal/reference/reference_ops.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/types.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace split_v {\n\nstruct OpContext {\n  OpContext(TfLiteContext* context, TfLiteNode* node) {\n    params = reinterpret_cast<TfLiteSplitVParams*>(node->builtin_data);\n    input = GetInput(context, node, 0);\n    size_splits = GetInput(context, node, 1);\n    axis = GetInput(context, node, 2);\n  }\n  TfLiteSplitVParams* params;\n  const TfLiteTensor* input;\n  const TfLiteTensor* size_splits;\n  const TfLiteTensor* axis;\n};\n\nTfLiteStatus UseDynamicOutputTensors(TfLiteContext* context, TfLiteNode* node) {\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteTensor* tensor;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &tensor));\n    SetTensorToDynamic(tensor);\n  }\n  return kTfLiteOk;\n}\n\ntemplate <typename T>\nvoid GetSizeSplitsVector(const TfLiteTensor* size_splits,\n                         std::vector<int64_t>* size_splits_vector) {\n  const auto num_elements = NumElements(size_splits);\n  for (int i = 0; i < num_elements; ++i) {\n    size_splits_vector->push_back(GetTensorData<T>(size_splits)[i]);\n  }\n}\n\nTfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* input,\n                                 const TfLiteTensor* size_splits,\n                                 const TfLiteTensor* axis) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  std::vector<int64_t> size_splits_vector;\n  if (size_splits->type == kTfLiteInt32) {\n    GetSizeSplitsVector<int32_t>(size_splits, &size_splits_vector);\n  } else if (size_splits->type == kTfLiteInt64) {\n    GetSizeSplitsVector<int64_t>(size_splits, &size_splits_vector);\n  } else {\n    context->ReportError(context, \"size_splits only support type int32|int64.\");\n    return kTfLiteError;\n  }\n\n  int minus_one_index = -1;\n  int64_t size_splits_sum = 0;\n\n  for (int i = 0; i < size_splits_vector.size(); ++i) {\n    if (size_splits_vector.at(i) == -1) {\n      if (minus_one_index == -1) {\n        minus_one_index = i;\n      } else {\n        context->ReportError(context,\n                             \"The size_splits contains more than one -1.\");\n      }\n    } else {\n      size_splits_sum += size_splits_vector.at(i);\n    }\n  }\n\n  const int input_size = SizeOfDimension(input, axis_value);\n\n  if (minus_one_index != -1) {\n    if (size_splits_sum > input_size) {\n      context->ReportError(\n          context,\n          \"The sum of size_splits must be less than the dimension of value.\");\n    } else {\n      size_splits_vector[minus_one_index] = input_size - size_splits_sum;\n    }\n  } else if (size_splits_sum != input_size) {\n    context->ReportError(\n        context,\n        \"The size_splits must sum to the dimension of value along axis.\");\n  }\n\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = size_splits_vector.at(i);\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n\n  return kTfLiteOk;\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n\n  OpContext op_context(context, node);\n\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), op_context.params->num_splits);\n\n  auto input_type = op_context.input->type;\n  TF_LITE_ENSURE(context,\n                 input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||\n                     input_type == kTfLiteInt16 || input_type == kTfLiteInt32 ||\n                     input_type == kTfLiteInt64 || input_type == kTfLiteInt8);\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteTensor* tensor;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &tensor));\n    tensor->type = input_type;\n  }\n\n  auto size_splits = op_context.size_splits;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(size_splits), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), NumElements(size_splits));\n\n  // If we know the contents of the 'size_splits' tensor and the 'axis' tensor,\n  // resize all outputs. Otherwise, wait until Eval().\n  if (IsConstantTensor(op_context.size_splits) &&\n      IsConstantTensor(op_context.axis)) {\n    return ResizeOutputTensors(context, node, op_context.input,\n                               op_context.size_splits, op_context.axis);\n  } else {\n    return UseDynamicOutputTensors(context, node);\n  }\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n  // When the 'size_splits' and the 'axis' tensor is non-const we can't resize\n  // output tensors in Prepare(), and we have to do it now.\n  if (!IsConstantTensor(op_context.axis) ||\n      !IsConstantTensor(op_context.size_splits)) {\n    TF_LITE_ENSURE_OK(\n        context, ResizeOutputTensors(context, node, op_context.input,\n                                     op_context.size_splits, op_context.axis));\n  }\n\n  int axis_value = GetTensorData<int>(op_context.axis)[0];\n\n  // Use split function to build the outputs since they share the same logic.\n#define TF_LITE_SPLIT_V(scalar)                                     \\\n  VectorOfTensors<scalar> all_outputs(*context, *node->outputs);    \\\n  tflite::SplitParams op_params;                                    \\\n  op_params.num_split = NumOutputs(node);                           \\\n  op_params.axis = axis_value;                                      \\\n  reference_ops::Split(op_params, GetTensorShape(op_context.input), \\\n                       GetTensorData<scalar>(op_context.input),     \\\n                       all_outputs.shapes(), all_outputs.data());\n  switch (op_context.input->type) {\n    case kTfLiteFloat32: {\n      TF_LITE_SPLIT_V(float);\n      break;\n    }\n    case kTfLiteUInt8: {\n      TF_LITE_SPLIT_V(uint8_t);\n      break;\n    }\n    case kTfLiteInt16: {\n      TF_LITE_SPLIT_V(int16_t);\n      break;\n    }\n    case kTfLiteInt32: {\n      TF_LITE_SPLIT_V(int32_t);\n      break;\n    }\n    case kTfLiteInt64: {\n      TF_LITE_SPLIT_V(int64_t);\n      break;\n    }\n    case kTfLiteInt8: {\n      TF_LITE_SPLIT_V(int8_t);\n      break;\n    }\n    default:\n      context->ReportError(context, \"Type %s currently not supported.\",\n                           TfLiteTypeGetName(op_context.input->type));\n      return kTfLiteError;\n  }\n#undef TF_LITE_SPLIT_V\n\n  return kTfLiteOk;\n}\n\n}  // namespace split_v\n\nTfLiteRegistration* Register_SPLIT_V() {\n  static TfLiteRegistration r = {nullptr, nullptr, split_v::Prepare,\n                                 split_v::Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite\n"], "fixing_code": ["/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include <stdint.h>\n\n#include <vector>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/kernels/internal/reference/reference_ops.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/types.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace split_v {\n\nstruct OpContext {\n  OpContext(TfLiteContext* context, TfLiteNode* node) {\n    params = reinterpret_cast<TfLiteSplitVParams*>(node->builtin_data);\n    input = GetInput(context, node, 0);\n    size_splits = GetInput(context, node, 1);\n    axis = GetInput(context, node, 2);\n  }\n  TfLiteSplitVParams* params;\n  const TfLiteTensor* input;\n  const TfLiteTensor* size_splits;\n  const TfLiteTensor* axis;\n};\n\nTfLiteStatus UseDynamicOutputTensors(TfLiteContext* context, TfLiteNode* node) {\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteTensor* tensor;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &tensor));\n    SetTensorToDynamic(tensor);\n  }\n  return kTfLiteOk;\n}\n\ntemplate <typename T>\nvoid GetSizeSplitsVector(const TfLiteTensor* size_splits,\n                         std::vector<int64_t>* size_splits_vector) {\n  const auto num_elements = NumElements(size_splits);\n  for (int i = 0; i < num_elements; ++i) {\n    size_splits_vector->push_back(GetTensorData<T>(size_splits)[i]);\n  }\n}\n\nTfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* input,\n                                 const TfLiteTensor* size_splits,\n                                 const TfLiteTensor* axis) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  std::vector<int64_t> size_splits_vector;\n  if (size_splits->type == kTfLiteInt32) {\n    GetSizeSplitsVector<int32_t>(size_splits, &size_splits_vector);\n  } else if (size_splits->type == kTfLiteInt64) {\n    GetSizeSplitsVector<int64_t>(size_splits, &size_splits_vector);\n  } else {\n    context->ReportError(context, \"size_splits only support type int32|int64.\");\n    return kTfLiteError;\n  }\n\n  int minus_one_index = -1;\n  int64_t size_splits_sum = 0;\n\n  for (int i = 0; i < size_splits_vector.size(); ++i) {\n    if (size_splits_vector.at(i) == -1) {\n      if (minus_one_index == -1) {\n        minus_one_index = i;\n      } else {\n        context->ReportError(context,\n                             \"The size_splits contains more than one -1.\");\n      }\n    } else {\n      size_splits_sum += size_splits_vector.at(i);\n    }\n  }\n\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n  const int input_size = SizeOfDimension(input, axis_value);\n\n  if (minus_one_index != -1) {\n    if (size_splits_sum > input_size) {\n      context->ReportError(\n          context,\n          \"The sum of size_splits must be less than the dimension of value.\");\n    } else {\n      size_splits_vector[minus_one_index] = input_size - size_splits_sum;\n    }\n  } else if (size_splits_sum != input_size) {\n    context->ReportError(\n        context,\n        \"The size_splits must sum to the dimension of value along axis.\");\n  }\n\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = size_splits_vector.at(i);\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n\n  return kTfLiteOk;\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n\n  OpContext op_context(context, node);\n\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), op_context.params->num_splits);\n\n  auto input_type = op_context.input->type;\n  TF_LITE_ENSURE(context,\n                 input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||\n                     input_type == kTfLiteInt16 || input_type == kTfLiteInt32 ||\n                     input_type == kTfLiteInt64 || input_type == kTfLiteInt8);\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteTensor* tensor;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &tensor));\n    tensor->type = input_type;\n  }\n\n  auto size_splits = op_context.size_splits;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(size_splits), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), NumElements(size_splits));\n\n  // If we know the contents of the 'size_splits' tensor and the 'axis' tensor,\n  // resize all outputs. Otherwise, wait until Eval().\n  if (IsConstantTensor(op_context.size_splits) &&\n      IsConstantTensor(op_context.axis)) {\n    return ResizeOutputTensors(context, node, op_context.input,\n                               op_context.size_splits, op_context.axis);\n  } else {\n    return UseDynamicOutputTensors(context, node);\n  }\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n  // When the 'size_splits' and the 'axis' tensor is non-const we can't resize\n  // output tensors in Prepare(), and we have to do it now.\n  if (!IsConstantTensor(op_context.axis) ||\n      !IsConstantTensor(op_context.size_splits)) {\n    TF_LITE_ENSURE_OK(\n        context, ResizeOutputTensors(context, node, op_context.input,\n                                     op_context.size_splits, op_context.axis));\n  }\n\n  int axis_value = GetTensorData<int>(op_context.axis)[0];\n\n  // Use split function to build the outputs since they share the same logic.\n#define TF_LITE_SPLIT_V(scalar)                                     \\\n  VectorOfTensors<scalar> all_outputs(*context, *node->outputs);    \\\n  tflite::SplitParams op_params;                                    \\\n  op_params.num_split = NumOutputs(node);                           \\\n  op_params.axis = axis_value;                                      \\\n  reference_ops::Split(op_params, GetTensorShape(op_context.input), \\\n                       GetTensorData<scalar>(op_context.input),     \\\n                       all_outputs.shapes(), all_outputs.data());\n  switch (op_context.input->type) {\n    case kTfLiteFloat32: {\n      TF_LITE_SPLIT_V(float);\n      break;\n    }\n    case kTfLiteUInt8: {\n      TF_LITE_SPLIT_V(uint8_t);\n      break;\n    }\n    case kTfLiteInt16: {\n      TF_LITE_SPLIT_V(int16_t);\n      break;\n    }\n    case kTfLiteInt32: {\n      TF_LITE_SPLIT_V(int32_t);\n      break;\n    }\n    case kTfLiteInt64: {\n      TF_LITE_SPLIT_V(int64_t);\n      break;\n    }\n    case kTfLiteInt8: {\n      TF_LITE_SPLIT_V(int8_t);\n      break;\n    }\n    default:\n      context->ReportError(context, \"Type %s currently not supported.\",\n                           TfLiteTypeGetName(op_context.input->type));\n      return kTfLiteError;\n  }\n#undef TF_LITE_SPLIT_V\n\n  return kTfLiteOk;\n}\n\n}  // namespace split_v\n\nTfLiteRegistration* Register_SPLIT_V() {\n  static TfLiteRegistration r = {nullptr, nullptr, split_v::Prepare,\n                                 split_v::Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite\n"], "filenames": ["tensorflow/lite/kernels/split_v.cc"], "buggy_code_start_loc": [98], "buggy_code_end_loc": [98], "fixing_code_start_loc": [99], "fixing_code_end_loc": [101], "type": "CWE-125", "message": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB read on heap in the TFLite implementation of `Split_V`(https://github.com/tensorflow/tensorflow/blob/c59c37e7b2d563967da813fa50fe20b21f4da683/tensorflow/lite/kernels/split_v.cc#L99). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the `SizeOfDimension` function(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/kernel_util.h#L148-L150) will access data outside the bounds of the tensor shape array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-29606", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-14T20:15:15.717", "lastModified": "2021-05-18T15:06:44.573", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB read on heap in the TFLite implementation of `Split_V`(https://github.com/tensorflow/tensorflow/blob/c59c37e7b2d563967da813fa50fe20b21f4da683/tensorflow/lite/kernels/split_v.cc#L99). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the `SizeOfDimension` function(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/kernel_util.h#L148-L150) will access data outside the bounds of the tensor shape array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico.&#xa0;Un modelo TFLite especialmente dise\u00f1ado podr\u00eda desencadenar una lectura OOB en la pila en la implementaci\u00f3n de TFLite de \"Split_V\" (https://github.com/tensorflow/tensorflow/blob/c59c37e7b2d563967da813fa50fe20b21f4da683/tensorflow/lite/kernels/split_v.cc#L99).&#xa0;Si \"axis_value\" no es un valor entre 0 y \"NumDimensions (input)\", entonces la funci\u00f3n \"SizeOfDimension\" (https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/kernel_util.h # L148-L150) acceder\u00e1 a datos fuera de l\u00edmites de la matriz de forma de tensor.&#xa0;La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.5.0.&#xa0;Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.4.2, TensorFlow versi\u00f3n 2.3.3, TensorFlow versi\u00f3n 2.2.3 y TensorFlow versi\u00f3n 2.1.4, ya que estos tambi\u00e9n est\u00e1n afectados y a\u00fan est\u00e1n en el rango compatible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "323ABCCE-24EB-47CC-87F6-48C101477587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.3", "matchCriteriaId": "64ABA90C-0649-4BB0-89C9-83C14BBDCC0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.3", "matchCriteriaId": "0F83E0CF-CBF6-4C24-8683-3E7A5DC95BA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.2", "matchCriteriaId": "8259531B-A8AC-4F8B-B60F-B69DE4767C03"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/ae2daeb45abfe2c6dda539cf8d0d6f653d3ef412", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-h4pc-gx2w-f2xv", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/ae2daeb45abfe2c6dda539cf8d0d6f653d3ef412"}}