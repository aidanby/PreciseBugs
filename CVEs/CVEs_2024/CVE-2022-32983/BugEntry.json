{"buggy_code": [".. SPDX-License-Identifier: GPL-3.0-or-later\n\n.. default-domain:: py\n.. module:: policy\n\n.. _mod-policy:\n\n\nQuery policies\n==============\n\nThis module can block, rewrite, or alter inbound queries based on user-defined policies. It does not affect queries generated by the resolver itself, e.g. when following CNAME chains etc.\n\nEach policy *rule* has two parts: a *filter* and an *action*. A *filter* selects which queries will be affected by the policy, and *action* which modifies queries matching the associated filter.\n\nTypically a rule is defined as follows: ``filter(action(action parameters), filter parameters)``. For example, a filter can be ``suffix`` which matches queries whose suffix part is in specified set, and one of possible actions is :any:`policy.DENY`, which denies resolution. These are combined together into ``policy.suffix(policy.DENY, {todname('badguy.example.')})``. The rule is effective when it is added into rule table using ``policy.add()``, please see examples below.\n\nThis module is enabled by default because it implements mandatory :rfc:`6761` logic.\nWhen no rule applies to a query, built-in rules for `special-use <https://www.iana.org/assignments/special-use-domain-names/special-use-domain-names.xhtml>`_ and `locally-served <http://www.iana.org/assignments/locally-served-dns-zones>`_ domain names are applied.\nThese rules can be overridden by action :any:`policy.PASS`.  For debugging purposes you can also add ``modules.unload('policy')`` to your config to unload the module.\n\n\nFilters\n-------\nA *filter* selects which queries will be affected by specified Actions_. There are several policy filters available in the ``policy.`` table:\n\n.. function:: all(action)\n\n   Always applies the action.\n\n.. function:: pattern(action, pattern)\n\n   Applies the action if query name matches a `Lua regular expression <http://lua-users.org/wiki/PatternsTutorial>`_.\n\n.. function:: suffix(action, suffix_table)\n\n   Applies the action if query name suffix matches one of suffixes in the table (useful for \"is domain in zone\" rules).\n\n.. note:: For speed this filter requires domain names in DNS wire format, not textual representation, so each label in the name must be prefixed with its length. Always use convenience function :func:`policy.todnames` for automatic conversion from strings! For example:\n\n   .. code-block:: lua\n\n      policy.add(policy.suffix(policy.DENY, policy.todnames({'example.com', 'example.net'})))\n\n.. function:: domains(action, domain_table)\n\n   Like :func:`policy.suffix` match, but the queried name must match exactly, not just its suffix.\n\n.. function:: suffix_common(action, suffix_table[, common_suffix])\n\n  :param action: action if the pattern matches query name\n  :param suffix_table: table of valid suffixes\n  :param common_suffix: common suffix of entries in suffix_table\n\n  Like :func:`policy.suffix` match, but you can also provide a common suffix of all matches for faster processing (nil otherwise).\n  This function is faster for small suffix tables (in the order of \"hundreds\").\n\n.. :noindex: function:: rpz(default_action, path, [watch])\n\n   Implements a subset of `Response Policy Zone` (RPZ_) stored in zonefile format.  See below for details: :func:`policy.rpz`.\n\nIt is also possible to define custom filter function with any name.\n\n.. function:: custom_filter(state, query)\n\n   :param state: Request processing state :c:type:`kr_layer_state`, typically not used by filter function.\n   :param query: Incoming DNS query as :c:type:`kr_query` structure.\n   :return: An `action <#actions>`_ function or ``nil`` if filter did not match.\n\n   Typically filter function is generated by another function, which allows easy parametrization - this technique is called `closure <https://www.lua.org/pil/6.1.html>`_. An practical example of such filter generator is:\n\n.. code-block:: lua\n\n   function match_query_type(action, target_qtype)\n       return function (state, query)\n           if query.stype == target_qtype then\n               -- filter matched the query, return action function\n               return action\n           else\n               -- filter did not match, continue with next filter\n               return nil\n           end\n       end\n   end\n\nThis custom filter can be used as any other built-in filter.\nFor example this applies our custom filter and executes action :any:`policy.DENY` on all queries of type `HINFO`:\n\n.. code-block:: lua\n\n   -- custom filter which matches HINFO queries, action is policy.DENY\n   policy.add(match_query_type(policy.DENY, kres.type.HINFO))\n\n\n.. _mod-policy-actions:\n\nActions\n-------\nAn *action* is a function which modifies DNS request, and is either of type *chain* or *non-chain*:\n\n  * `Non-chain actions`_ modify state of the request and stop rule processing. An example of such action is :ref:`forwarding`.\n  * `Chain actions`_ modify state of the request and allow other rules to evaluate and act on the same request. One such example is :func:`policy.MIRROR`.\n\nNon-chain actions\n^^^^^^^^^^^^^^^^^\n\nFollowing actions stop the policy matching on the query, i.e. other rules are not evaluated once rule with following actions matches:\n\n.. py:attribute:: PASS\n\n   Let the query pass through; it's useful to make exceptions before wider rules. For example:\n\n   More specific whitelist rule must precede generic blacklist rule:\n\n   .. code-block:: lua\n\n    -- Whitelist 'good.example.com'\n    policy.add(policy.pattern(policy.PASS, todname('good.example.com.')))\n    -- Block all names below example.com\n    policy.add(policy.suffix(policy.DENY, {todname('example.com.')}))\n\n.. py:attribute:: DENY\n\n   Deny existence of names matching filter, i.e. reply NXDOMAIN authoritatively.\n\n.. function:: DENY_MSG(message, [extended_error=kres.extended_error.BLOCKED])\n\n   Deny existence of a given domain and add explanatory message. NXDOMAIN reply\n   contains an additional explanatory message as TXT record in the additional\n   section.\n\n   You may override the extended DNS error to provide the user with more\n   information. By default, ``BLOCKED`` is returned to indicate the domain is\n   blocked due to the internal policy of the operator. Other suitable error\n   codes are ``CENSORED`` (for externally imposed policy reasons) or\n   ``FILTERED`` (for blocking requested by the client). For more information,\n   please refer to :rfc:`8914`.\n\n.. py:attribute:: DROP\n\n   Terminate query resolution and return SERVFAIL to the requestor.\n\n.. py:attribute:: REFUSE\n\n   Terminate query resolution and return REFUSED to the requestor.\n\n.. py:attribute:: TC\n\n   Force requestor to use TCP. It sets truncated bit (*TC*) in response to true if the request came through UDP, which will force standard-compliant clients to retry the request over TCP.\n\n.. function:: REROUTE({subnet = target, ...})\n\n   Reroute IP addresses in response matching given subnet to given target, e.g. ``{['192.0.2.0/24'] = '127.0.0.0'}`` will rewrite '192.0.2.55' to '127.0.0.55', see :ref:`renumber module <mod-renumber>` for more information. See :func:`policy.add` and do not forget to specify that this is *postrule*. Quick example:\n\n   .. code-block:: lua\n\n      -- this policy is enforced on answers\n      -- therefore we have to use 'postrule'\n      -- (the \"true\" at the end of policy.add)\n      policy.add(policy.all(policy.REROUTE({['192.0.2.0/24'] = '127.0.0.0'})), true)\n\n.. function:: ANSWER({ type = { rdata=data, [ttl=1] } }, [nodata=false])\n\n   Overwrite Resource Records in responses with specified values.\n\n      * type\n        - RR type to be replaced, e.g. ``[kres.type.A]`` or `numeric value <https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4>`_.\n      * rdata\n        - RR data in DNS wire format, i.e. binary form specific for given RR type. Set of multiple RRs can be specified as table ``{ rdata1, rdata2, ... }``. Use helper function :func:`kres.str2ip` to generate wire format for A and AAAA records. Wire format for other record types can be generated with :func:`kres.parse_rdata`.\n      * ttl\n        - TTL in seconds. Default: 1 second.\n      * nodata\n        - If type requested by client is not configured in this policy:\n\n          - ``true``: Return empty answer (`NODATA`).\n          - ``false``: Ignore this policy and continue processing other rules.\n\n          Default: ``false``.\n\n   .. code-block:: lua\n\n      -- policy to change IPv4 address and TTL for example.com\n      policy.add(\n          policy.domains(\n              policy.ANSWER(\n                  { [kres.type.A] = { rdata=kres.str2ip('192.0.2.7'), ttl=300 } }\n              ), { todname('example.com') }))\n      -- policy to generate two TXT records (specified in binary format) for example.net\n      policy.add(\n          policy.domains(\n              policy.ANSWER(\n                  { [kres.type.TXT] = { rdata={'\\005first', '\\006second'}, ttl=5 } }\n              ), { todname('example.net') }))\n\n\n   .. function:: kres.parse_rdata({str, ...})\n\n      Parse string representation of RTYPE and RDATA into RDATA wire format. Expects\n      a table of string(s) and returns a table of wire data.\n\n      .. code-block:: lua\n\n         -- create wire format RDATA that can be passed to policy.ANSWER\n         kres.parse_rdata({'SVCB 1 resolver.example. alpn=dot'})\n         kres.parse_rdata({\n            'SVCB 1 resolver.example. alpn=dot ipv4hint=192.0.2.1 ipv6hint=2001:db8::1',\n            'SVCB 2 resolver.example. mandatory=key65380 alpn=h2 key65380=/dns-query{?dns}',\n         })\n\nMore complex non-chain actions are described in their own chapters, namely:\n\n  * :ref:`forwarding`\n  * `Response Policy Zones`_\n\nChain actions\n^^^^^^^^^^^^^\n\nFollowing actions act on request and then processing continue until first non-chain action (specified in the previous section) is triggered:\n\n.. function:: MIRROR(ip_address)\n\n   Send copy of incoming DNS queries to a given IP address using DNS-over-UDP and continue resolving them as usual. This is useful for sanity testing new versions of DNS resolvers.\n\n   .. code-block:: lua\n\n      policy.add(policy.all(policy.MIRROR('127.0.0.2')))\n\n.. function:: FLAGS(set, clear)\n\n   Set and/or clear some flags for the query.  There can be multiple flags to set/clear.  You can just pass a single flag name (string) or a set of names. Flag names correspond to :c:type:`kr_qflags` structure.  Use only if you know what you are doing.\n\n\n.. _mod-policy-logging:\n\nActions for extra logging\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThese are also \"chain\" actions, i.e. they don't stop processing the policy rule list.\nSimilarly to other actions, they apply during whole processing of the client's request,\ni.e. including any sub-queries.\n\nThe log lines from these policy actions are tagged by extra ``[reqdbg]`` prefix,\nand they are produced regardless of your :func:`log_level()` setting.\nThey are marked as ``debug`` level, so e.g. with journalctl command you can use ``-p info`` to skip them.\n\n.. warning::  Beware of producing too much logs.\n\n   These actions are not suitable for use on a large fraction of resolver's requests.\n   The extra logs have significant performance impact and might also overload your logging system\n   (or get rate-limited by it).\n   You can use `Filters`_ to further limit on which requests this happens.\n\n.. py:attribute:: DEBUG_ALWAYS\n\n   Print debug-level logging for this request.\n   That also includes messages from client (:any:`REQTRACE`), upstream servers (:any:`QTRACE`), and stats about interesting records at the end.\n\n   .. code-block:: lua\n\n      -- debug requests that ask for flaky.example.net or below\n      policy.add(policy.suffix(policy.DEBUG_ALWAYS,\n          policy.todnames({'flaky.example.net'})))\n\n.. py:attribute:: DEBUG_CACHE_MISS\n\n   Same as :any:`DEBUG_ALWAYS` but only if the request required information which was not available locally, i.e. requests which forced resolver to ask upstream server(s).\n   Intended usage is for debugging problems with remote servers.\n\n.. py:function:: DEBUG_IF(test_function)\n\n   :param test_function: Function with single argument of type :c:type:`kr_request` which returns ``true`` if debug logs for that request should be generated and ``false`` otherwise.\n\n   Same as :any:`DEBUG_ALWAYS` but only logs if the test_function says so.\n\n   .. note:: ``test_function`` is evaluated only when request is finished.\n        As a result all debug logs this request must be collected,\n        and at the end they get either printed or thrown away.\n\n   Example usage which gathers verbose logs for all requests in subtree ``dnssec-failed.org.`` and prints debug logs for those finishing in a different state than ``kres.DONE`` (most importantly ``kres.FAIL``, see :c:type:`kr_layer_state`).\n\n   .. code-block:: lua\n\n      policy.add(policy.suffix(\n          policy.DEBUG_IF(function(req)\n                              return (req.state ~= kres.DONE)\n                          end),\n          policy.todnames({'dnssec-failed.org.'})))\n\n.. py:attribute:: QTRACE\n\n   Pretty-print DNS responses from upstream servers (or cache) into logs.\n   It's useful for debugging weird DNS servers.\n\n   If you do not use ``QTRACE`` in combination with ``DEBUG*``,\n   you additionally need either ``log_groups({'iterat'})`` (possibly with other groups)\n   or ``log_level('debug')`` to see the output in logs.\n\n.. py:attribute:: REQTRACE\n\n   Pretty-print DNS requests from clients into the verbose log. It's useful for debugging weird DNS clients.\n   It makes most sense together with :ref:`mod-view` (enabling per-client)\n   and probably with verbose logging those request (e.g. use :any:`DEBUG_ALWAYS` instead).\n\n.. py:attribute:: IPTRACE\n\n   Log how the request arrived.\n   Most notably, this includes the client's IP address, so beware of privacy implications.\n\n   .. code-block:: lua\n\n        -- example usage in configuration\n        policy.add(policy.all(policy.IPTRACE))\n        -- you might want to combine it with some other logs, e.g.\n        policy.add(policy.all(policy.DEBUG_ALWAYS))\n\n   .. code-block:: text\n\n        -- example log lines from IPTRACE:\n        [reqdbg][policy][57517.00] request packet arrived from ::1#37931 to ::1#00853 (TCP + TLS)\n        [reqdbg][policy][65538.00] request packet arrived internally\n\n\nCustom actions\n^^^^^^^^^^^^^^\n\n.. function:: custom_action(state, request)\n\n   :param state: Request processing state :c:type:`kr_layer_state`.\n   :param request: Current DNS request as :c:type:`kr_request` structure.\n   :return: Returning a new :c:type:`kr_layer_state` prevents evaluating other policy rules. Returning ``nil`` creates a `chain action <#actions>`_ and allows to continue evaluating other rules.\n\n   This is real example of an action function:\n\n.. code-block:: lua\n\n   -- Custom action which generates fake A record\n   local ffi = require('ffi')\n   local function fake_A_record(state, req)\n       local answer = req:ensure_answer()\n       if answer == nil then return nil end\n       local qry = req:current()\n       if qry.stype ~= kres.type.A then\n           return state\n       end\n       ffi.C.kr_pkt_make_auth_header(answer)\n       answer:rcode(kres.rcode.NOERROR)\n       answer:begin(kres.section.ANSWER)\n       answer:put(qry.sname, 900, answer:qclass(), kres.type.A, '\\192\\168\\1\\3')\n       return kres.DONE\n   end\n\nThis custom action can be used as any other built-in action.\nFor example this applies our *fake A record action* and executes it on all queries in subtree ``example.net``:\n\n.. code-block:: lua\n\n   policy.add(policy.suffix(fake_A_record, policy.todnames({'example.net'})))\n\nThe action function can implement arbitrary logic so it is possible to implement complex heuristics, e.g. to deflect `Slow drip DNS attacks <https://secure64.com/water-torture-slow-drip-dns-ddos-attack>`_ or gray-list resolution of misbehaving zones.\n\n.. warning:: The policy module currently only looks at whole DNS requests.  The rules won't be re-applied e.g. when following CNAMEs.\n\n.. _forwarding:\n\nForwarding\n----------\n\nForwarding action alters behavior for cache-miss events. If an information is missing in the local cache the resolver will *forward* the query to *another DNS resolver* for resolution (instead of contacting authoritative servers directly). DNS answers from the remote resolver are then processed locally and sent back to the original client.\n\nActions :func:`policy.FORWARD`, :func:`policy.TLS_FORWARD` and :func:`policy.STUB` accept up to four IP addresses at once and the resolver will automatically select IP address which statistically responds the fastest.\n\n.. function:: FORWARD(ip_address)\n              FORWARD({ ip_address, [ip_address, ...] })\n\n   Forward cache-miss queries to specified IP addresses (without encryption), DNSSEC validate received answers and cache them. Target IP addresses are expected to be DNS resolvers.\n\n   .. code-block:: lua\n\n      -- Forward all queries to public resolvers https://www.nic.cz/odvr\n      policy.add(policy.all(\n         policy.FORWARD(\n             {'2001:148f:fffe::1', '2001:148f:ffff::1',\n              '185.43.135.1', '193.14.47.1'})))\n\n   A variant which uses encrypted DNS-over-TLS transport is called :func:`policy.TLS_FORWARD`, please see section :ref:`tls-forwarding`.\n\n.. function:: STUB(ip_address)\n              STUB({ ip_address, [ip_address, ...] })\n\n   Similar to :func:`policy.FORWARD` but *without* attempting DNSSEC validation.\n   Each request may be either answered from cache or simply sent to one of the IPs with proxying back the answer.\n\n   This mode does not support encryption and should be used only for `Replacing part of the DNS tree`_.\n   Use :func:`policy.FORWARD` mode if possible.\n\n   .. code-block:: lua\n\n      -- Answers for reverse queries about the 192.168.1.0/24 subnet\n      -- are to be obtained from IP address 192.0.2.1 port 5353\n      -- This disables DNSSEC validation!\n      policy.add(policy.suffix(\n          policy.STUB('192.0.2.1@5353'),\n          {todname('1.168.192.in-addr.arpa')}))\n\n.. note:: By default, forwarding targets must support\n   `EDNS <https://en.wikipedia.org/wiki/Extension_mechanisms_for_DNS>`_ and\n   `0x20 randomization <https://tools.ietf.org/html/draft-vixie-dnsext-dns0x20-00>`_.\n   See example in `Replacing part of the DNS tree`_.\n\n\n.. _tls-forwarding:\n\nForwarding over TLS protocol (DNS-over-TLS)\n-------------------------------------------\n.. function:: TLS_FORWARD( { {ip_address, authentication}, [...] } )\n\n   Same as :func:`policy.FORWARD` but send query over DNS-over-TLS protocol (encrypted).\n   Each target IP address needs explicit configuration how to validate\n   TLS certificate so each IP address is configured by pair:\n   ``{ip_address, authentication}``. See sections below for more details.\n\n\nPolicy :func:`policy.TLS_FORWARD` allows you to forward queries using `Transport Layer Security`_ protocol, which hides the content of your queries from an attacker observing the network traffic. Further details about this protocol can be found in :rfc:`7858` and `IETF draft dprive-dtls-and-tls-profiles`_.\n\nQueries affected by :func:`policy.TLS_FORWARD` will always be resolved over TLS connection. Knot Resolver does not implement fallback to non-TLS connection, so if TLS connection cannot be established or authenticated according to the configuration, the resolution will fail.\n\nTo test this feature you need to either :ref:`configure Knot Resolver as DNS-over-TLS server <tls-server-config>`, or pick some public DNS-over-TLS server. Please see `DNS Privacy Project`_ homepage for list of public servers.\n\n.. note:: Some public DNS-over-TLS providers may apply rate-limiting which\n   makes their service incompatible with Knot Resolver's TLS forwarding.\n   Notably, `Google Public DNS\n   <https://developers.google.com/speed/public-dns/docs/dns-over-tls>`_ doesn't\n   work as of 2019-07-10.\n\nWhen multiple servers are specified, the one with the lowest round-trip time is used.\n\nCA+hostname authentication\n^^^^^^^^^^^^^^^^^^^^^^^^^^\nTraditional PKI authentication requires server to present certificate with specified hostname, which is issued by one of trusted CAs. Example policy is:\n\n.. code-block:: lua\n\n   policy.TLS_FORWARD({\n       {'2001:DB8::d0c', hostname='res.example.com'}})\n\n- ``hostname`` must be a valid domain name matching server's certificate.  It will also be sent to the server as SNI_.\n- ``ca_file`` optionally contains a path to a CA certificate (or certificate bundle) in `PEM format`_.\n  If you omit that, the system CA certificate store will be used instead (usually sufficient).\n  A list of paths is also accepted, but all of them must be valid PEMs.\n\nKey-pinned authentication\n^^^^^^^^^^^^^^^^^^^^^^^^^\nInstead of CAs, you can specify hashes of accepted certificates in ``pin_sha256``.\nThey are in the usual format -- base64 from sha256.\nYou may still specify ``hostname`` if you want SNI_ to be sent.\n\n.. _tls-examples:\n\nTLS Examples\n^^^^^^^^^^^^\n\n.. code-block:: lua\n\n   modules = { 'policy' }\n   -- forward all queries over TLS to the specified server\n   policy.add(policy.all(policy.TLS_FORWARD({{'192.0.2.1', pin_sha256='YQ=='}})))\n   -- for brevity, other TLS examples omit policy.add(policy.all())\n   -- single server authenticated using its certificate pin_sha256\n   policy.TLS_FORWARD({{'192.0.2.1', pin_sha256='YQ=='}})  -- pin_sha256 is base64-encoded\n   -- single server authenticated using hostname and system-wide CA certificates\n   policy.TLS_FORWARD({{'192.0.2.1', hostname='res.example.com'}})\n   -- single server using non-standard port\n   policy.TLS_FORWARD({{'192.0.2.1@443', pin_sha256='YQ=='}})  -- use @ or # to specify port\n   -- single server with multiple valid pins (e.g. anycast)\n   policy.TLS_FORWARD({{'192.0.2.1', pin_sha256={'YQ==', 'Wg=='}})\n   -- multiple servers, each with own authenticator\n   policy.TLS_FORWARD({ -- please note that { here starts list of servers\n       {'192.0.2.1', pin_sha256='Wg=='},\n       -- server must present certificate issued by specified CA and hostname must match\n       {'2001:DB8::d0c', hostname='res.example.com', ca_file='/etc/knot-resolver/tlsca.crt'}\n   })\n\nForwarding to multiple targets\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWith the use of :func:`policy.slice` function, it is possible to split the\nentire DNS namespace into distinct slices. When used in conjunction with\n:func:`policy.TLS_FORWARD`, it's possible to forward different queries to\ndifferent targets.\n\n.. function:: slice(slice_func, action[, action[, ...])\n\n  :param slice_func: slicing function that returns index based on query\n  :param action: action to be performed for the slice\n\n  This function splits the entire domain space into multiple slices (determined\n  by the number of provided ``actions``). A ``slice_func`` is called to determine\n  which slice a query belongs to. The corresponding ``action`` is then executed.\n\n\n.. function:: slice_randomize_psl(seed = os.time() / (3600 * 24 * 7))\n\n  :param seed: seed for random assignment\n\n  The function initializes and returns a slicing function, which\n  deterministically assigns ``query`` to a slice based on the query name.\n\n  It utilizes the `Public Suffix List`_ to ensure domains under the same\n  registrable domain end up in a single slice. (see example below)\n\n  ``seed`` can be used to re-shuffle the slicing algorithm when the slicing\n  function is initialized. By default, the assignment is re-shuffled after one\n  week (when resolver restart / reloads config). To force a stable\n  distribution, pass a fixed value. To re-shuffle on every resolver restart,\n  use ``os.time()``.\n\n  The following example demonstrates a distribution among 3 slices::\n\n    slice 1/3:\n    example.com\n    a.example.com\n    b.example.com\n    x.b.example.com\n    example3.com\n\n    slice 2/3:\n    example2.co.uk\n\n    slice 3/3:\n    example.co.uk\n    a.example.co.uk\n\nThese two functions can be used together to forward queries for names\nin different parts of DNS name space to different target servers:\n\n.. code-block:: lua\n\n   policy.add(policy.slice(\n       policy.slice_randomize_psl(),\n       policy.TLS_FORWARD({{'192.0.2.1', hostname='res.example.com'}}),\n       policy.TLS_FORWARD({\n           -- multiple servers can be specified for a single slice\n           -- the one with lowest round-trip time will be used\n           {'193.17.47.1', hostname='odvr.nic.cz'},\n           {'185.43.135.1', hostname='odvr.nic.cz'},\n       })\n   ))\n\n.. note:: The privacy implications of using this feature aren't clear. Since\n   websites often make requests to multiple domains, these might be forwarded\n   to different targets. This could result in decreased privacy (e.g. when the\n   remote targets are both logging or otherwise processing your DNS traffic).\n   The intended use-case is to use this feature with semi-trusted resolvers\n   which claim to do no logging (such as those listed on `dnsprivacy.org\n   <https://dnsprivacy.org/wiki/display/DP/DNS+Privacy+Test+Servers>`_), to\n   decrease the potential exposure of your DNS data to a malicious resolver\n   operator.\n\n.. _dns-graft:\n\nReplacing part of the DNS tree\n------------------------------\n\nFollowing procedure applies only to domains which have different content\npublicly and internally. For example this applies to \"your own\" top-level domain\n``example.`` which does not exist in the public (global) DNS namespace.\n\nDealing with these internal-only domains requires extra configuration because\nDNS was designed as \"single namespace\" and local modifications like adding\nyour own TLD break this assumption.\n\n.. warning:: Use of internal names which are not delegated from the public DNS\n             *is causing technical problems* with caching and DNSSEC validation\n             and generally makes DNS operation more costly.\n             We recommend **against** using these non-delegated names.\n\nTo make such internal domain available in your resolver it is necessary to\n*graft* your domain onto the public DNS namespace,\nbut *grafting* creates new issues:\n\nThese *grafted* domains will be rejected by DNSSEC validation\nbecause such domains are technically indistinguishable from an spoofing attack\nagainst the public DNS.\nTherefore, if you trust the remote resolver which hosts the internal-only domain,\nand you trust your link to it, you need to use the :func:`policy.STUB` policy\ninstead of :func:`policy.FORWARD` to disable DNSSEC validation for those\n*grafted* domains.\n\nSecondly, after disabling DNSSEC validation you have to solve another issue\ncaused by grafting. For example, if you grafted your own top-level domain\n``example.`` onto the public DNS namespace, at some point the root server might\nsend proof-of-nonexistence proving e.g. that there are no other top-level\ndomain in between names ``events.`` and ``exchange.``, effectively proving\nnon-existence of ``example.``.\n\nThese proofs-of-nonexistence protect public DNS from spoofing but break\n*grafted* domains because proofs will be latter used by resolver\n(when the positive records for the grafted domain timeout from cache),\neffectively making grafted domain unavailable.\nThe easiest work-around is to disable reading from cache for grafted domains.\n\n.. code-block:: lua\n   :caption: Example configuration grafting domains onto public DNS namespace\n\n   extraTrees = policy.todnames(\n       {'faketldtest.',\n        'sld.example.',\n        'internal.example.com.',\n        '2.0.192.in-addr.arpa.'  -- this applies to reverse DNS tree as well\n        })\n   -- Beware: the rule order is important, as policy.STUB is not a chain action.\n   -- Flags: for \"dumb\" targets disabling EDNS can help (below) as DNSSEC isn't\n   -- validated anyway; in some of those cases adding 'NO_0X20' can also help,\n   -- though it also lowers defenses against off-path attacks on communication\n   -- between the two servers.\n   policy.add(policy.suffix(policy.FLAGS({'NO_CACHE', 'NO_EDNS'}), extraTrees))\n   policy.add(policy.suffix(policy.STUB({'2001:db8::1'}), extraTrees))\n\nResponse policy zones\n---------------------\n  .. warning::\n\n     There is no published Internet Standard for RPZ_ and implementations vary.\n     At the moment Knot Resolver supports limited subset of RPZ format and deviates\n     from implementation in BIND. Nevertheless it is good enough\n     for blocking large lists of spam or advertising domains.\n\n\n\n  The RPZ file format is basically a DNS zone file with *very special* semantics.\n  For example:\n\n  .. code-block:: none\n\n     ; left hand side          ; TTL and class  ; right hand side\n     ; encodes RPZ trigger     ; ignored        ; encodes action\n     ; (i.e. filter)\n     blocked.domain.example    600 IN           CNAME .           ; block main domain\n     *.blocked.domain.example  600 IN           CNAME .           ; block subdomains\n\n  The only \"trigger\" supported in Knot Resolver is query name,\n  i.e. left hand side must be a domain name which triggers the action specified\n  on the right hand side.\n\n  Subset of possible RPZ actions is supported, namely:\n\n  .. csv-table::\n   :header: \"RPZ Right Hand Side\", \"Knot Resolver Action\", \"BIND Compatibility\"\n\n   \"``.``\", \"``action`` is used\", \"compatible if ``action`` is :any:`policy.DENY`\"\n   \"``*.``\", \":func:`policy.ANSWER`\", \"yes\"\n   \"``rpz-passthru.``\", \":any:`policy.PASS`\", \"yes\"\n   \"``rpz-tcp-only.``\", \":any:`policy.TC`\", \"yes\"\n   \"``rpz-drop.``\", \":any:`policy.DROP`\", \"no [#]_\"\n   \"fake A/AAAA\", \":func:`policy.ANSWER`\", \"yes\"\n   \"fake CNAME\", \"not supported\", \"no\"\n\n  .. [#] Our :any:`policy.DROP` returns *SERVFAIL* answer (for historical reasons).\n\n\n  .. note::\n\n     To debug which domains are affected by RPZ (or other policy actions), you can enable the ``policy`` log group:\n\n     .. code-block:: lua\n\n        log_groups({'policy'})\n\n\n.. function:: rpz(action, path, [watch = true])\n\n  :param action: the default action for match in the zone; typically you want :any:`policy.DENY`\n  :param path: path to zone file\n  :param watch: boolean, if true, the file will be reloaded on file change\n\n  Enforce RPZ_ rules. This can be used in conjunction with published blocklist feeds.\n  The RPZ_ operation is well described in this `Jan-Piet Mens's post`_,\n  or the `Pro DNS and BIND`_ book.\n\n  For example, we can store the example snippet with domain ``blocked.domain.example``\n  (above) into file ``/etc/knot-resolver/blocklist.rpz`` and configure resolver to\n  answer with *NXDOMAIN* plus the specified additional text to queries for this domain:\n\n  .. code-block:: lua\n\n     policy.add(\n         policy.rpz(policy.DENY_MSG('domain blocked by your resolver operator'),\n                    '/etc/knot-resolver/blocklist.rpz',\n                    true))\n\n  Resolver will reload RPZ file at run-time if the RPZ file changes.\n  Recommended RPZ update procedure is to store new blocklist in a new file\n  (*newblocklist.rpz*) and then rename the new file to the original file name\n  (*blocklist.rpz*). This avoids problems where resolver might attempt\n  to re-read an incomplete file.\n\n\n\nAdditional properties\n---------------------\n\nMost properties (actions, filters) are described above.\n\n.. function:: add(rule, postrule)\n\n  :param rule: added rule, i.e. ``policy.pattern(policy.DENY, '[0-9]+\\2cz')``\n  :param postrule: boolean, if true the rule will be evaluated on answer instead of query\n  :return: rule description\n\n  Add a new policy rule that is executed either or queries or answers, depending on the ``postrule`` parameter. You can then use the returned rule description to get information and unique identifier for the rule, as well as match count.\n\n  .. code-block:: lua\n\n     -- mirror all queries, keep handle so we can retrieve information later\n     local rule = policy.add(policy.all(policy.MIRROR('127.0.0.2')))\n     -- we can print statistics about this rule any time later\n     print(string.format('id: %d, matched queries: %d', rule.id, rule.count)\n\n.. function:: del(id)\n\n  :param id: identifier of a given rule returned by :func:`policy.add`\n  :return: boolean ``true`` if rule was deleted, ``false`` otherwise\n\n  Remove a rule from policy list.\n\n.. function:: todnames({name, ...})\n\n   :param: names table of domain names in textual format\n\n   Returns table of domain names in wire format converted from strings.\n\n   .. code-block:: lua\n\n      -- Convert single name\n      assert(todname('example.com') == '\\7example\\3com\\0')\n      -- Convert table of names\n      policy.todnames({'example.com', 'me.cz'})\n      { '\\7example\\3com\\0', '\\2me\\2cz\\0' }\n\n\n.. _RPZ: https://dnsrpz.info/\n.. _`PEM format`: https://en.wikipedia.org/wiki/Privacy-enhanced_Electronic_Mail\n.. _`Pro DNS and BIND`: http://www.zytrax.com/books/dns/ch7/rpz.html\n.. _`Jan-Piet Mens's post`: http://jpmens.net/2011/04/26/how-to-configure-your-bind-resolvers-to-lie-using-response-policy-zones-rpz/\n.. _`Transport Layer Security`: https://en.wikipedia.org/wiki/Transport_Layer_Security\n.. _`DNS Privacy Project`: https://dnsprivacy.org/\n.. _`IETF draft dprive-dtls-and-tls-profiles`: https://tools.ietf.org/html/draft-ietf-dprive-dtls-and-tls-profiles\n.. _SNI: https://en.wikipedia.org/wiki/Server_Name_Indication\n.. _`Public Suffix List`: https://publicsuffix.org\n"], "fixing_code": [".. SPDX-License-Identifier: GPL-3.0-or-later\n\n.. default-domain:: py\n.. module:: policy\n\n.. _mod-policy:\n\n\nQuery policies\n==============\n\nThis module can block, rewrite, or alter inbound queries based on user-defined policies. It does not affect queries generated by the resolver itself, e.g. when following CNAME chains etc.\n\nEach policy *rule* has two parts: a *filter* and an *action*. A *filter* selects which queries will be affected by the policy, and *action* which modifies queries matching the associated filter.\n\nTypically a rule is defined as follows: ``filter(action(action parameters), filter parameters)``. For example, a filter can be ``suffix`` which matches queries whose suffix part is in specified set, and one of possible actions is :any:`policy.DENY`, which denies resolution. These are combined together into ``policy.suffix(policy.DENY, {todname('badguy.example.')})``. The rule is effective when it is added into rule table using ``policy.add()``, please see examples below.\n\nThis module is enabled by default because it implements mandatory :rfc:`6761` logic.\nWhen no rule applies to a query, built-in rules for `special-use <https://www.iana.org/assignments/special-use-domain-names/special-use-domain-names.xhtml>`_ and `locally-served <http://www.iana.org/assignments/locally-served-dns-zones>`_ domain names are applied.\nThese rules can be overridden by action :any:`policy.PASS`.  For debugging purposes you can also add ``modules.unload('policy')`` to your config to unload the module.\n\n\nFilters\n-------\nA *filter* selects which queries will be affected by specified Actions_. There are several policy filters available in the ``policy.`` table:\n\n.. function:: all(action)\n\n   Always applies the action.\n\n.. function:: pattern(action, pattern)\n\n   Applies the action if query name matches a `Lua regular expression <http://lua-users.org/wiki/PatternsTutorial>`_.\n\n.. function:: suffix(action, suffix_table)\n\n   Applies the action if query name suffix matches one of suffixes in the table (useful for \"is domain in zone\" rules).\n\n.. note:: For speed this filter requires domain names in DNS wire format, not textual representation, so each label in the name must be prefixed with its length. Always use convenience function :func:`policy.todnames` for automatic conversion from strings! For example:\n\n   .. code-block:: lua\n\n      policy.add(policy.suffix(policy.DENY, policy.todnames({'example.com', 'example.net'})))\n\n.. function:: domains(action, domain_table)\n\n   Like :func:`policy.suffix` match, but the queried name must match exactly, not just its suffix.\n\n.. function:: suffix_common(action, suffix_table[, common_suffix])\n\n  :param action: action if the pattern matches query name\n  :param suffix_table: table of valid suffixes\n  :param common_suffix: common suffix of entries in suffix_table\n\n  Like :func:`policy.suffix` match, but you can also provide a common suffix of all matches for faster processing (nil otherwise).\n  This function is faster for small suffix tables (in the order of \"hundreds\").\n\n.. :noindex: function:: rpz(default_action, path, [watch])\n\n   Implements a subset of `Response Policy Zone` (RPZ_) stored in zonefile format.  See below for details: :func:`policy.rpz`.\n\nIt is also possible to define custom filter function with any name.\n\n.. function:: custom_filter(state, query)\n\n   :param state: Request processing state :c:type:`kr_layer_state`, typically not used by filter function.\n   :param query: Incoming DNS query as :c:type:`kr_query` structure.\n   :return: An `action <#actions>`_ function or ``nil`` if filter did not match.\n\n   Typically filter function is generated by another function, which allows easy parametrization - this technique is called `closure <https://www.lua.org/pil/6.1.html>`_. An practical example of such filter generator is:\n\n.. code-block:: lua\n\n   function match_query_type(action, target_qtype)\n       return function (state, query)\n           if query.stype == target_qtype then\n               -- filter matched the query, return action function\n               return action\n           else\n               -- filter did not match, continue with next filter\n               return nil\n           end\n       end\n   end\n\nThis custom filter can be used as any other built-in filter.\nFor example this applies our custom filter and executes action :any:`policy.DENY` on all queries of type `HINFO`:\n\n.. code-block:: lua\n\n   -- custom filter which matches HINFO queries, action is policy.DENY\n   policy.add(match_query_type(policy.DENY, kres.type.HINFO))\n\n\n.. _mod-policy-actions:\n\nActions\n-------\nAn *action* is a function which modifies DNS request, and is either of type *chain* or *non-chain*:\n\n  * `Non-chain actions`_ modify state of the request and stop rule processing. An example of such action is :ref:`forwarding`.\n  * `Chain actions`_ modify state of the request and allow other rules to evaluate and act on the same request. One such example is :func:`policy.MIRROR`.\n\nNon-chain actions\n^^^^^^^^^^^^^^^^^\n\nFollowing actions stop the policy matching on the query, i.e. other rules are not evaluated once rule with following actions matches:\n\n.. py:attribute:: PASS\n\n   Let the query pass through; it's useful to make exceptions before wider rules. For example:\n\n   More specific whitelist rule must precede generic blacklist rule:\n\n   .. code-block:: lua\n\n    -- Whitelist 'good.example.com'\n    policy.add(policy.pattern(policy.PASS, todname('good.example.com.')))\n    -- Block all names below example.com\n    policy.add(policy.suffix(policy.DENY, {todname('example.com.')}))\n\n.. py:attribute:: DENY\n\n   Deny existence of names matching filter, i.e. reply NXDOMAIN authoritatively.\n\n.. function:: DENY_MSG(message, [extended_error=kres.extended_error.BLOCKED])\n\n   Deny existence of a given domain and add explanatory message. NXDOMAIN reply\n   contains an additional explanatory message as TXT record in the additional\n   section.\n\n   You may override the extended DNS error to provide the user with more\n   information. By default, ``BLOCKED`` is returned to indicate the domain is\n   blocked due to the internal policy of the operator. Other suitable error\n   codes are ``CENSORED`` (for externally imposed policy reasons) or\n   ``FILTERED`` (for blocking requested by the client). For more information,\n   please refer to :rfc:`8914`.\n\n.. py:attribute:: DROP\n\n   Terminate query resolution and return SERVFAIL to the requestor.\n\n.. py:attribute:: REFUSE\n\n   Terminate query resolution and return REFUSED to the requestor.\n\n.. py:attribute:: TC\n\n   Force requestor to use TCP. It sets truncated bit (*TC*) in response to true if the request came through UDP, which will force standard-compliant clients to retry the request over TCP.\n\n.. function:: REROUTE({subnet = target, ...})\n\n   Reroute IP addresses in response matching given subnet to given target, e.g. ``{['192.0.2.0/24'] = '127.0.0.0'}`` will rewrite '192.0.2.55' to '127.0.0.55', see :ref:`renumber module <mod-renumber>` for more information. See :func:`policy.add` and do not forget to specify that this is *postrule*. Quick example:\n\n   .. code-block:: lua\n\n      -- this policy is enforced on answers\n      -- therefore we have to use 'postrule'\n      -- (the \"true\" at the end of policy.add)\n      policy.add(policy.all(policy.REROUTE({['192.0.2.0/24'] = '127.0.0.0'})), true)\n\n.. function:: ANSWER({ type = { rdata=data, [ttl=1] } }, [nodata=false])\n\n   Overwrite Resource Records in responses with specified values.\n\n      * type\n        - RR type to be replaced, e.g. ``[kres.type.A]`` or `numeric value <https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4>`_.\n      * rdata\n        - RR data in DNS wire format, i.e. binary form specific for given RR type. Set of multiple RRs can be specified as table ``{ rdata1, rdata2, ... }``. Use helper function :func:`kres.str2ip` to generate wire format for A and AAAA records. Wire format for other record types can be generated with :func:`kres.parse_rdata`.\n      * ttl\n        - TTL in seconds. Default: 1 second.\n      * nodata\n        - If type requested by client is not configured in this policy:\n\n          - ``true``: Return empty answer (`NODATA`).\n          - ``false``: Ignore this policy and continue processing other rules.\n\n          Default: ``false``.\n\n   .. code-block:: lua\n\n      -- policy to change IPv4 address and TTL for example.com\n      policy.add(\n          policy.domains(\n              policy.ANSWER(\n                  { [kres.type.A] = { rdata=kres.str2ip('192.0.2.7'), ttl=300 } }\n              ), { todname('example.com') }))\n      -- policy to generate two TXT records (specified in binary format) for example.net\n      policy.add(\n          policy.domains(\n              policy.ANSWER(\n                  { [kres.type.TXT] = { rdata={'\\005first', '\\006second'}, ttl=5 } }\n              ), { todname('example.net') }))\n\n\n   .. function:: kres.parse_rdata({str, ...})\n\n      Parse string representation of RTYPE and RDATA into RDATA wire format. Expects\n      a table of string(s) and returns a table of wire data.\n\n      .. code-block:: lua\n\n         -- create wire format RDATA that can be passed to policy.ANSWER\n         kres.parse_rdata({'SVCB 1 resolver.example. alpn=dot'})\n         kres.parse_rdata({\n            'SVCB 1 resolver.example. alpn=dot ipv4hint=192.0.2.1 ipv6hint=2001:db8::1',\n            'SVCB 2 resolver.example. mandatory=key65380 alpn=h2 key65380=/dns-query{?dns}',\n         })\n\nMore complex non-chain actions are described in their own chapters, namely:\n\n  * :ref:`forwarding`\n  * `Response Policy Zones`_\n\nChain actions\n^^^^^^^^^^^^^\n\nFollowing actions act on request and then processing continue until first non-chain action (specified in the previous section) is triggered:\n\n.. function:: MIRROR(ip_address)\n\n   Send copy of incoming DNS queries to a given IP address using DNS-over-UDP and continue resolving them as usual. This is useful for sanity testing new versions of DNS resolvers.\n\n   .. code-block:: lua\n\n      policy.add(policy.all(policy.MIRROR('127.0.0.2')))\n\n.. function:: FLAGS(set, clear)\n\n   Set and/or clear some flags for the query.  There can be multiple flags to set/clear.  You can just pass a single flag name (string) or a set of names. Flag names correspond to :c:type:`kr_qflags` structure.  Use only if you know what you are doing.\n\n\n.. _mod-policy-logging:\n\nActions for extra logging\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThese are also \"chain\" actions, i.e. they don't stop processing the policy rule list.\nSimilarly to other actions, they apply during whole processing of the client's request,\ni.e. including any sub-queries.\n\nThe log lines from these policy actions are tagged by extra ``[reqdbg]`` prefix,\nand they are produced regardless of your :func:`log_level()` setting.\nThey are marked as ``debug`` level, so e.g. with journalctl command you can use ``-p info`` to skip them.\n\n.. warning::  Beware of producing too much logs.\n\n   These actions are not suitable for use on a large fraction of resolver's requests.\n   The extra logs have significant performance impact and might also overload your logging system\n   (or get rate-limited by it).\n   You can use `Filters`_ to further limit on which requests this happens.\n\n.. py:attribute:: DEBUG_ALWAYS\n\n   Print debug-level logging for this request.\n   That also includes messages from client (:any:`REQTRACE`), upstream servers (:any:`QTRACE`), and stats about interesting records at the end.\n\n   .. code-block:: lua\n\n      -- debug requests that ask for flaky.example.net or below\n      policy.add(policy.suffix(policy.DEBUG_ALWAYS,\n          policy.todnames({'flaky.example.net'})))\n\n.. py:attribute:: DEBUG_CACHE_MISS\n\n   Same as :any:`DEBUG_ALWAYS` but only if the request required information which was not available locally, i.e. requests which forced resolver to ask upstream server(s).\n   Intended usage is for debugging problems with remote servers.\n\n.. py:function:: DEBUG_IF(test_function)\n\n   :param test_function: Function with single argument of type :c:type:`kr_request` which returns ``true`` if debug logs for that request should be generated and ``false`` otherwise.\n\n   Same as :any:`DEBUG_ALWAYS` but only logs if the test_function says so.\n\n   .. note:: ``test_function`` is evaluated only when request is finished.\n        As a result all debug logs this request must be collected,\n        and at the end they get either printed or thrown away.\n\n   Example usage which gathers verbose logs for all requests in subtree ``dnssec-failed.org.`` and prints debug logs for those finishing in a different state than ``kres.DONE`` (most importantly ``kres.FAIL``, see :c:type:`kr_layer_state`).\n\n   .. code-block:: lua\n\n      policy.add(policy.suffix(\n          policy.DEBUG_IF(function(req)\n                              return (req.state ~= kres.DONE)\n                          end),\n          policy.todnames({'dnssec-failed.org.'})))\n\n.. py:attribute:: QTRACE\n\n   Pretty-print DNS responses from upstream servers (or cache) into logs.\n   It's useful for debugging weird DNS servers.\n\n   If you do not use ``QTRACE`` in combination with ``DEBUG*``,\n   you additionally need either ``log_groups({'iterat'})`` (possibly with other groups)\n   or ``log_level('debug')`` to see the output in logs.\n\n.. py:attribute:: REQTRACE\n\n   Pretty-print DNS requests from clients into the verbose log. It's useful for debugging weird DNS clients.\n   It makes most sense together with :ref:`mod-view` (enabling per-client)\n   and probably with verbose logging those request (e.g. use :any:`DEBUG_ALWAYS` instead).\n\n.. py:attribute:: IPTRACE\n\n   Log how the request arrived.\n   Most notably, this includes the client's IP address, so beware of privacy implications.\n\n   .. code-block:: lua\n\n        -- example usage in configuration\n        policy.add(policy.all(policy.IPTRACE))\n        -- you might want to combine it with some other logs, e.g.\n        policy.add(policy.all(policy.DEBUG_ALWAYS))\n\n   .. code-block:: text\n\n        -- example log lines from IPTRACE:\n        [reqdbg][policy][57517.00] request packet arrived from ::1#37931 to ::1#00853 (TCP + TLS)\n        [reqdbg][policy][65538.00] request packet arrived internally\n\n\nCustom actions\n^^^^^^^^^^^^^^\n\n.. function:: custom_action(state, request)\n\n   :param state: Request processing state :c:type:`kr_layer_state`.\n   :param request: Current DNS request as :c:type:`kr_request` structure.\n   :return: Returning a new :c:type:`kr_layer_state` prevents evaluating other policy rules. Returning ``nil`` creates a `chain action <#actions>`_ and allows to continue evaluating other rules.\n\n   This is real example of an action function:\n\n.. code-block:: lua\n\n   -- Custom action which generates fake A record\n   local ffi = require('ffi')\n   local function fake_A_record(state, req)\n       local answer = req:ensure_answer()\n       if answer == nil then return nil end\n       local qry = req:current()\n       if qry.stype ~= kres.type.A then\n           return state\n       end\n       ffi.C.kr_pkt_make_auth_header(answer)\n       answer:rcode(kres.rcode.NOERROR)\n       answer:begin(kres.section.ANSWER)\n       answer:put(qry.sname, 900, answer:qclass(), kres.type.A, '\\192\\168\\1\\3')\n       return kres.DONE\n   end\n\nThis custom action can be used as any other built-in action.\nFor example this applies our *fake A record action* and executes it on all queries in subtree ``example.net``:\n\n.. code-block:: lua\n\n   policy.add(policy.suffix(fake_A_record, policy.todnames({'example.net'})))\n\nThe action function can implement arbitrary logic so it is possible to implement complex heuristics, e.g. to deflect `Slow drip DNS attacks <https://secure64.com/water-torture-slow-drip-dns-ddos-attack>`_ or gray-list resolution of misbehaving zones.\n\n.. warning:: The policy module currently only looks at whole DNS requests.  The rules won't be re-applied e.g. when following CNAMEs.\n\n.. _forwarding:\n\nForwarding\n----------\n\nForwarding action alters behavior for cache-miss events. If an information is missing in the local cache the resolver will *forward* the query to *another DNS resolver* for resolution (instead of contacting authoritative servers directly). DNS answers from the remote resolver are then processed locally and sent back to the original client.\n\nActions :func:`policy.FORWARD`, :func:`policy.TLS_FORWARD` and :func:`policy.STUB` accept up to four IP addresses at once and the resolver will automatically select IP address which statistically responds the fastest.\n\n.. function:: FORWARD(ip_address)\n              FORWARD({ ip_address, [ip_address, ...] })\n\n   Forward cache-miss queries to specified IP addresses (without encryption), DNSSEC validate received answers and cache them. Target IP addresses are expected to be DNS resolvers.\n\n   .. code-block:: lua\n\n      -- Forward all queries to public resolvers https://www.nic.cz/odvr\n      policy.add(policy.all(\n         policy.FORWARD(\n             {'2001:148f:fffe::1', '2001:148f:ffff::1',\n              '185.43.135.1', '193.14.47.1'})))\n\n   A variant which uses encrypted DNS-over-TLS transport is called :func:`policy.TLS_FORWARD`, please see section :ref:`tls-forwarding`.\n\n.. function:: STUB(ip_address)\n              STUB({ ip_address, [ip_address, ...] })\n\n   Similar to :func:`policy.FORWARD` but *without* attempting DNSSEC validation.\n   Each request may be either answered from cache or simply sent to one of the IPs with proxying back the answer.\n\n   This mode does not support encryption and should be used only for `Replacing part of the DNS tree`_.\n   Use :func:`policy.FORWARD` mode if possible.\n\n   .. code-block:: lua\n\n      -- Answers for reverse queries about the 192.168.1.0/24 subnet\n      -- are to be obtained from IP address 192.0.2.1 port 5353\n      -- This disables DNSSEC validation!\n      policy.add(policy.suffix(\n          policy.STUB('192.0.2.1@5353'),\n          {todname('1.168.192.in-addr.arpa')}))\n\n.. note:: By default, forwarding targets must support\n   `EDNS <https://en.wikipedia.org/wiki/Extension_mechanisms_for_DNS>`_ and\n   `0x20 randomization <https://tools.ietf.org/html/draft-vixie-dnsext-dns0x20-00>`_.\n   See example in `Replacing part of the DNS tree`_.\n\n.. warning::\n   Limiting forwarding actions by filters (e.g. :func:`policy.suffix`) may have unexpected consequences.\n   Notably, forwarders can inject *any* records into your cache\n   even if you \"restrict\" them to an insignificant DNS subtree --\n   except in cases where DNSSEC validation applies, of course.\n\n   The behavior is probably best understood through the fact\n   that filters and actions are completely decoupled.\n   The forwarding actions have no clue about why they were executed,\n   e.g. that the user wanted to restrict the forwarder only to some subtree.\n   The action just selects some set of forwarders to process this whole request from the client,\n   and during that processing it might need some other \"sub-queries\" (e.g. for validation).\n   Some of those might not've passed the intended filter,\n   but policy rule-set only applies once per client's request.\n\n.. _tls-forwarding:\n\nForwarding over TLS protocol (DNS-over-TLS)\n-------------------------------------------\n.. function:: TLS_FORWARD( { {ip_address, authentication}, [...] } )\n\n   Same as :func:`policy.FORWARD` but send query over DNS-over-TLS protocol (encrypted).\n   Each target IP address needs explicit configuration how to validate\n   TLS certificate so each IP address is configured by pair:\n   ``{ip_address, authentication}``. See sections below for more details.\n\n\nPolicy :func:`policy.TLS_FORWARD` allows you to forward queries using `Transport Layer Security`_ protocol, which hides the content of your queries from an attacker observing the network traffic. Further details about this protocol can be found in :rfc:`7858` and `IETF draft dprive-dtls-and-tls-profiles`_.\n\nQueries affected by :func:`policy.TLS_FORWARD` will always be resolved over TLS connection. Knot Resolver does not implement fallback to non-TLS connection, so if TLS connection cannot be established or authenticated according to the configuration, the resolution will fail.\n\nTo test this feature you need to either :ref:`configure Knot Resolver as DNS-over-TLS server <tls-server-config>`, or pick some public DNS-over-TLS server. Please see `DNS Privacy Project`_ homepage for list of public servers.\n\n.. note:: Some public DNS-over-TLS providers may apply rate-limiting which\n   makes their service incompatible with Knot Resolver's TLS forwarding.\n   Notably, `Google Public DNS\n   <https://developers.google.com/speed/public-dns/docs/dns-over-tls>`_ doesn't\n   work as of 2019-07-10.\n\nWhen multiple servers are specified, the one with the lowest round-trip time is used.\n\nCA+hostname authentication\n^^^^^^^^^^^^^^^^^^^^^^^^^^\nTraditional PKI authentication requires server to present certificate with specified hostname, which is issued by one of trusted CAs. Example policy is:\n\n.. code-block:: lua\n\n   policy.TLS_FORWARD({\n       {'2001:DB8::d0c', hostname='res.example.com'}})\n\n- ``hostname`` must be a valid domain name matching server's certificate.  It will also be sent to the server as SNI_.\n- ``ca_file`` optionally contains a path to a CA certificate (or certificate bundle) in `PEM format`_.\n  If you omit that, the system CA certificate store will be used instead (usually sufficient).\n  A list of paths is also accepted, but all of them must be valid PEMs.\n\nKey-pinned authentication\n^^^^^^^^^^^^^^^^^^^^^^^^^\nInstead of CAs, you can specify hashes of accepted certificates in ``pin_sha256``.\nThey are in the usual format -- base64 from sha256.\nYou may still specify ``hostname`` if you want SNI_ to be sent.\n\n.. _tls-examples:\n\nTLS Examples\n^^^^^^^^^^^^\n\n.. code-block:: lua\n\n   modules = { 'policy' }\n   -- forward all queries over TLS to the specified server\n   policy.add(policy.all(policy.TLS_FORWARD({{'192.0.2.1', pin_sha256='YQ=='}})))\n   -- for brevity, other TLS examples omit policy.add(policy.all())\n   -- single server authenticated using its certificate pin_sha256\n   policy.TLS_FORWARD({{'192.0.2.1', pin_sha256='YQ=='}})  -- pin_sha256 is base64-encoded\n   -- single server authenticated using hostname and system-wide CA certificates\n   policy.TLS_FORWARD({{'192.0.2.1', hostname='res.example.com'}})\n   -- single server using non-standard port\n   policy.TLS_FORWARD({{'192.0.2.1@443', pin_sha256='YQ=='}})  -- use @ or # to specify port\n   -- single server with multiple valid pins (e.g. anycast)\n   policy.TLS_FORWARD({{'192.0.2.1', pin_sha256={'YQ==', 'Wg=='}})\n   -- multiple servers, each with own authenticator\n   policy.TLS_FORWARD({ -- please note that { here starts list of servers\n       {'192.0.2.1', pin_sha256='Wg=='},\n       -- server must present certificate issued by specified CA and hostname must match\n       {'2001:DB8::d0c', hostname='res.example.com', ca_file='/etc/knot-resolver/tlsca.crt'}\n   })\n\nForwarding to multiple targets\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWith the use of :func:`policy.slice` function, it is possible to split the\nentire DNS namespace into distinct slices. When used in conjunction with\n:func:`policy.TLS_FORWARD`, it's possible to forward different queries to\ndifferent targets.\n\n.. function:: slice(slice_func, action[, action[, ...])\n\n  :param slice_func: slicing function that returns index based on query\n  :param action: action to be performed for the slice\n\n  This function splits the entire domain space into multiple slices (determined\n  by the number of provided ``actions``). A ``slice_func`` is called to determine\n  which slice a query belongs to. The corresponding ``action`` is then executed.\n\n\n.. function:: slice_randomize_psl(seed = os.time() / (3600 * 24 * 7))\n\n  :param seed: seed for random assignment\n\n  The function initializes and returns a slicing function, which\n  deterministically assigns ``query`` to a slice based on the query name.\n\n  It utilizes the `Public Suffix List`_ to ensure domains under the same\n  registrable domain end up in a single slice. (see example below)\n\n  ``seed`` can be used to re-shuffle the slicing algorithm when the slicing\n  function is initialized. By default, the assignment is re-shuffled after one\n  week (when resolver restart / reloads config). To force a stable\n  distribution, pass a fixed value. To re-shuffle on every resolver restart,\n  use ``os.time()``.\n\n  The following example demonstrates a distribution among 3 slices::\n\n    slice 1/3:\n    example.com\n    a.example.com\n    b.example.com\n    x.b.example.com\n    example3.com\n\n    slice 2/3:\n    example2.co.uk\n\n    slice 3/3:\n    example.co.uk\n    a.example.co.uk\n\nThese two functions can be used together to forward queries for names\nin different parts of DNS name space to different target servers:\n\n.. code-block:: lua\n\n   policy.add(policy.slice(\n       policy.slice_randomize_psl(),\n       policy.TLS_FORWARD({{'192.0.2.1', hostname='res.example.com'}}),\n       policy.TLS_FORWARD({\n           -- multiple servers can be specified for a single slice\n           -- the one with lowest round-trip time will be used\n           {'193.17.47.1', hostname='odvr.nic.cz'},\n           {'185.43.135.1', hostname='odvr.nic.cz'},\n       })\n   ))\n\n.. note:: The privacy implications of using this feature aren't clear. Since\n   websites often make requests to multiple domains, these might be forwarded\n   to different targets. This could result in decreased privacy (e.g. when the\n   remote targets are both logging or otherwise processing your DNS traffic).\n   The intended use-case is to use this feature with semi-trusted resolvers\n   which claim to do no logging (such as those listed on `dnsprivacy.org\n   <https://dnsprivacy.org/wiki/display/DP/DNS+Privacy+Test+Servers>`_), to\n   decrease the potential exposure of your DNS data to a malicious resolver\n   operator.\n\n.. _dns-graft:\n\nReplacing part of the DNS tree\n------------------------------\n\nFollowing procedure applies only to domains which have different content\npublicly and internally. For example this applies to \"your own\" top-level domain\n``example.`` which does not exist in the public (global) DNS namespace.\n\nDealing with these internal-only domains requires extra configuration because\nDNS was designed as \"single namespace\" and local modifications like adding\nyour own TLD break this assumption.\n\n.. warning:: Use of internal names which are not delegated from the public DNS\n             *is causing technical problems* with caching and DNSSEC validation\n             and generally makes DNS operation more costly.\n             We recommend **against** using these non-delegated names.\n\nTo make such internal domain available in your resolver it is necessary to\n*graft* your domain onto the public DNS namespace,\nbut *grafting* creates new issues:\n\nThese *grafted* domains will be rejected by DNSSEC validation\nbecause such domains are technically indistinguishable from an spoofing attack\nagainst the public DNS.\nTherefore, if you trust the remote resolver which hosts the internal-only domain,\nand you trust your link to it, you need to use the :func:`policy.STUB` policy\ninstead of :func:`policy.FORWARD` to disable DNSSEC validation for those\n*grafted* domains.\n\nSecondly, after disabling DNSSEC validation you have to solve another issue\ncaused by grafting. For example, if you grafted your own top-level domain\n``example.`` onto the public DNS namespace, at some point the root server might\nsend proof-of-nonexistence proving e.g. that there are no other top-level\ndomain in between names ``events.`` and ``exchange.``, effectively proving\nnon-existence of ``example.``.\n\nThese proofs-of-nonexistence protect public DNS from spoofing but break\n*grafted* domains because proofs will be latter used by resolver\n(when the positive records for the grafted domain timeout from cache),\neffectively making grafted domain unavailable.\nThe easiest work-around is to disable reading from cache for grafted domains.\n\n.. code-block:: lua\n   :caption: Example configuration grafting domains onto public DNS namespace\n\n   extraTrees = policy.todnames(\n       {'faketldtest.',\n        'sld.example.',\n        'internal.example.com.',\n        '2.0.192.in-addr.arpa.'  -- this applies to reverse DNS tree as well\n        })\n   -- Beware: the rule order is important, as policy.STUB is not a chain action.\n   -- Flags: for \"dumb\" targets disabling EDNS can help (below) as DNSSEC isn't\n   -- validated anyway; in some of those cases adding 'NO_0X20' can also help,\n   -- though it also lowers defenses against off-path attacks on communication\n   -- between the two servers.\n   policy.add(policy.suffix(policy.FLAGS({'NO_CACHE', 'NO_EDNS'}), extraTrees))\n   policy.add(policy.suffix(policy.STUB({'2001:db8::1'}), extraTrees))\n\nResponse policy zones\n---------------------\n  .. warning::\n\n     There is no published Internet Standard for RPZ_ and implementations vary.\n     At the moment Knot Resolver supports limited subset of RPZ format and deviates\n     from implementation in BIND. Nevertheless it is good enough\n     for blocking large lists of spam or advertising domains.\n\n\n\n  The RPZ file format is basically a DNS zone file with *very special* semantics.\n  For example:\n\n  .. code-block:: none\n\n     ; left hand side          ; TTL and class  ; right hand side\n     ; encodes RPZ trigger     ; ignored        ; encodes action\n     ; (i.e. filter)\n     blocked.domain.example    600 IN           CNAME .           ; block main domain\n     *.blocked.domain.example  600 IN           CNAME .           ; block subdomains\n\n  The only \"trigger\" supported in Knot Resolver is query name,\n  i.e. left hand side must be a domain name which triggers the action specified\n  on the right hand side.\n\n  Subset of possible RPZ actions is supported, namely:\n\n  .. csv-table::\n   :header: \"RPZ Right Hand Side\", \"Knot Resolver Action\", \"BIND Compatibility\"\n\n   \"``.``\", \"``action`` is used\", \"compatible if ``action`` is :any:`policy.DENY`\"\n   \"``*.``\", \":func:`policy.ANSWER`\", \"yes\"\n   \"``rpz-passthru.``\", \":any:`policy.PASS`\", \"yes\"\n   \"``rpz-tcp-only.``\", \":any:`policy.TC`\", \"yes\"\n   \"``rpz-drop.``\", \":any:`policy.DROP`\", \"no [#]_\"\n   \"fake A/AAAA\", \":func:`policy.ANSWER`\", \"yes\"\n   \"fake CNAME\", \"not supported\", \"no\"\n\n  .. [#] Our :any:`policy.DROP` returns *SERVFAIL* answer (for historical reasons).\n\n\n  .. note::\n\n     To debug which domains are affected by RPZ (or other policy actions), you can enable the ``policy`` log group:\n\n     .. code-block:: lua\n\n        log_groups({'policy'})\n\n\n.. function:: rpz(action, path, [watch = true])\n\n  :param action: the default action for match in the zone; typically you want :any:`policy.DENY`\n  :param path: path to zone file\n  :param watch: boolean, if true, the file will be reloaded on file change\n\n  Enforce RPZ_ rules. This can be used in conjunction with published blocklist feeds.\n  The RPZ_ operation is well described in this `Jan-Piet Mens's post`_,\n  or the `Pro DNS and BIND`_ book.\n\n  For example, we can store the example snippet with domain ``blocked.domain.example``\n  (above) into file ``/etc/knot-resolver/blocklist.rpz`` and configure resolver to\n  answer with *NXDOMAIN* plus the specified additional text to queries for this domain:\n\n  .. code-block:: lua\n\n     policy.add(\n         policy.rpz(policy.DENY_MSG('domain blocked by your resolver operator'),\n                    '/etc/knot-resolver/blocklist.rpz',\n                    true))\n\n  Resolver will reload RPZ file at run-time if the RPZ file changes.\n  Recommended RPZ update procedure is to store new blocklist in a new file\n  (*newblocklist.rpz*) and then rename the new file to the original file name\n  (*blocklist.rpz*). This avoids problems where resolver might attempt\n  to re-read an incomplete file.\n\n\n\nAdditional properties\n---------------------\n\nMost properties (actions, filters) are described above.\n\n.. function:: add(rule, postrule)\n\n  :param rule: added rule, i.e. ``policy.pattern(policy.DENY, '[0-9]+\\2cz')``\n  :param postrule: boolean, if true the rule will be evaluated on answer instead of query\n  :return: rule description\n\n  Add a new policy rule that is executed either or queries or answers, depending on the ``postrule`` parameter. You can then use the returned rule description to get information and unique identifier for the rule, as well as match count.\n\n  .. code-block:: lua\n\n     -- mirror all queries, keep handle so we can retrieve information later\n     local rule = policy.add(policy.all(policy.MIRROR('127.0.0.2')))\n     -- we can print statistics about this rule any time later\n     print(string.format('id: %d, matched queries: %d', rule.id, rule.count)\n\n.. function:: del(id)\n\n  :param id: identifier of a given rule returned by :func:`policy.add`\n  :return: boolean ``true`` if rule was deleted, ``false`` otherwise\n\n  Remove a rule from policy list.\n\n.. function:: todnames({name, ...})\n\n   :param: names table of domain names in textual format\n\n   Returns table of domain names in wire format converted from strings.\n\n   .. code-block:: lua\n\n      -- Convert single name\n      assert(todname('example.com') == '\\7example\\3com\\0')\n      -- Convert table of names\n      policy.todnames({'example.com', 'me.cz'})\n      { '\\7example\\3com\\0', '\\2me\\2cz\\0' }\n\n\n.. _RPZ: https://dnsrpz.info/\n.. _`PEM format`: https://en.wikipedia.org/wiki/Privacy-enhanced_Electronic_Mail\n.. _`Pro DNS and BIND`: http://www.zytrax.com/books/dns/ch7/rpz.html\n.. _`Jan-Piet Mens's post`: http://jpmens.net/2011/04/26/how-to-configure-your-bind-resolvers-to-lie-using-response-policy-zones-rpz/\n.. _`Transport Layer Security`: https://en.wikipedia.org/wiki/Transport_Layer_Security\n.. _`DNS Privacy Project`: https://dnsprivacy.org/\n.. _`IETF draft dprive-dtls-and-tls-profiles`: https://tools.ietf.org/html/draft-ietf-dprive-dtls-and-tls-profiles\n.. _SNI: https://en.wikipedia.org/wiki/Server_Name_Indication\n.. _`Public Suffix List`: https://publicsuffix.org\n"], "filenames": ["modules/policy/README.rst"], "buggy_code_start_loc": [409], "buggy_code_end_loc": [409], "fixing_code_start_loc": [410], "fixing_code_end_loc": [424], "type": "CWE-290", "message": "Knot Resolver through 5.5.1 may allow DNS cache poisoning when there is an attempt to limit forwarding actions by filters.", "other": {"cve": {"id": "CVE-2022-32983", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-20T16:15:07.990", "lastModified": "2022-06-27T18:34:38.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Knot Resolver through 5.5.1 may allow DNS cache poisoning when there is an attempt to limit forwarding actions by filters."}, {"lang": "es", "value": "Knot Resolver versiones hasta 5.5.1, puede permitir el envenenamiento de la cach\u00e9 DNS cuando intenta limitar las acciones de reenv\u00edo mediante filtros"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-290"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nic:knot_resolver:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.5.1", "matchCriteriaId": "59E489F9-265F-4CBC-A9C3-CFB8F9B9A9D9"}]}]}], "references": [{"url": "https://github.com/CZ-NIC/knot-resolver/commit/ccb9d9794db5eb757c33becf65cb1cf48ecfd968", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://knot-resolver.readthedocs.io/en/stable/modules-policy.html#forwarding", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/CZ-NIC/knot-resolver/commit/ccb9d9794db5eb757c33becf65cb1cf48ecfd968"}}