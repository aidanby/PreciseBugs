{"buggy_code": ["require 'logger'\n\nmodule Rack\n  class Cors\n    ENV_KEY = 'rack.cors'.freeze\n\n    ORIGIN_HEADER_KEY     = 'HTTP_ORIGIN'.freeze\n    ORIGIN_X_HEADER_KEY   = 'HTTP_X_ORIGIN'.freeze\n    PATH_INFO_HEADER_KEY  = 'PATH_INFO'.freeze\n    VARY_HEADER_KEY       = 'Vary'.freeze\n    DEFAULT_VARY_HEADERS  = ['Origin'].freeze\n\n    def initialize(app, opts={}, &block)\n      @app = app\n      @debug_mode = !!opts[:debug]\n\n      if logger = opts[:logger]\n        if logger.respond_to? :call\n          @logger_proc = opts[:logger]\n        else\n          @logger = logger\n        end\n      end\n\n      if block_given?\n        if block.arity == 1\n          block.call(self)\n        else\n          instance_eval(&block)\n        end\n      end\n    end\n\n    def debug?\n      @debug_mode\n    end\n\n    def allow(&block)\n      all_resources << (resources = Resources.new)\n\n      if block.arity == 1\n        block.call(resources)\n      else\n        resources.instance_eval(&block)\n      end\n    end\n\n    def call(env)\n      env[ORIGIN_HEADER_KEY] ||= env[ORIGIN_X_HEADER_KEY] if env[ORIGIN_X_HEADER_KEY]\n\n      add_headers = nil\n      if env[ORIGIN_HEADER_KEY]\n        debug(env) do\n          [ 'Incoming Headers:',\n            \"  Origin: #{env[ORIGIN_HEADER_KEY]}\",\n            \"  Access-Control-Request-Method: #{env['HTTP_ACCESS_CONTROL_REQUEST_METHOD']}\",\n            \"  Access-Control-Request-Headers: #{env['HTTP_ACCESS_CONTROL_REQUEST_HEADERS']}\"\n            ].join(\"\\n\")\n        end\n        if env['REQUEST_METHOD'] == 'OPTIONS' and env['HTTP_ACCESS_CONTROL_REQUEST_METHOD']\n          if headers = process_preflight(env)\n            debug(env) do\n              \"Preflight Headers:\\n\" +\n                  headers.collect{|kv| \"  #{kv.join(': ')}\"}.join(\"\\n\")\n            end\n            return [200, headers, []]\n          end\n        else\n          add_headers = process_cors(env)\n        end\n      else\n        Result.miss(env, Result::MISS_NO_ORIGIN)\n      end\n\n      # This call must be done BEFORE calling the app because for some reason\n      # env[PATH_INFO_HEADER_KEY] gets changed after that and it won't match.\n      # (At least in rails 4.1.6)\n      vary_resource = resource_for_path(env[PATH_INFO_HEADER_KEY])\n\n      status, headers, body = @app.call env\n\n      if add_headers\n        headers = headers.merge(add_headers)\n      end\n\n      # Vary header should ALWAYS mention Origin if there's ANY chance for the\n      # response to be different depending on the Origin header value.\n      # Better explained here: http://www.fastly.com/blog/best-practices-for-using-the-vary-header/\n      if vary_resource\n        vary = headers[VARY_HEADER_KEY]\n        cors_vary_headers = if vary_resource.vary_headers && vary_resource.vary_headers.any?\n          vary_resource.vary_headers\n        else\n          DEFAULT_VARY_HEADERS\n        end\n        headers[VARY_HEADER_KEY] = ((vary ? vary.split(/,\\s*/) : []) + cors_vary_headers).uniq.join(', ')\n      end\n\n      if debug? && result = env[ENV_KEY]\n        result.append_header(headers)\n      end\n\n      [status, headers, body]\n    end\n\n    protected\n      def debug(env, message = nil, &block)\n        (@logger || select_logger(env)).debug(message, &block) if debug?\n      end\n\n      def select_logger(env)\n        @logger = if @logger_proc\n          logger_proc = @logger_proc\n          @logger_proc = nil\n          logger_proc.call\n\n        elsif defined?(Rails) && Rails.logger\n          Rails.logger\n\n        elsif env['rack.logger']\n          env['rack.logger']\n\n        else\n          ::Logger.new(STDOUT).tap { |logger| logger.level = ::Logger::Severity::DEBUG }\n        end\n      end\n\n      def all_resources\n        @all_resources ||= []\n      end\n\n      def process_preflight(env)\n        resource, error = match_resource(env)\n        if resource\n          Result.preflight_hit(env)\n          preflight = resource.process_preflight(env)\n          preflight\n\n        else\n          Result.preflight_miss(env, error)\n          nil\n        end\n      end\n\n      def process_cors(env)\n        resource, error = match_resource(env)\n        if resource\n          Result.hit(env)\n          cors = resource.to_headers(env)\n          cors\n\n        else\n          Result.miss(env, error)\n          nil\n        end\n      end\n\n      def resource_for_path(path_info)\n        all_resources.each do |r|\n          if found = r.resource_for_path(path_info)\n            return found\n          end\n        end\n        nil\n      end\n\n      def match_resource(env)\n        path   = env[PATH_INFO_HEADER_KEY]\n        origin = env[ORIGIN_HEADER_KEY]\n\n        origin_matched = false\n        all_resources.each do |r|\n          if r.allow_origin?(origin, env)\n            origin_matched = true\n            if found = r.match_resource(path, env)\n              return [found, nil]\n            end\n          end\n        end\n\n        [nil, origin_matched ? Result::MISS_NO_PATH : Result::MISS_NO_ORIGIN]\n      end\n\n      class Result\n        HEADER_KEY = 'X-Rack-CORS'.freeze\n\n        MISS_NO_ORIGIN = 'no-origin'.freeze\n        MISS_NO_PATH   = 'no-path'.freeze\n\n        attr_accessor :preflight, :hit, :miss_reason\n\n        def hit?\n          !!hit\n        end\n\n        def preflight?\n          !!preflight\n        end\n\n        def self.hit(env)\n          r = Result.new\n          r.preflight = false\n          r.hit = true\n          env[ENV_KEY] = r\n        end\n\n        def self.miss(env, reason)\n          r = Result.new\n          r.preflight = false\n          r.hit = false\n          r.miss_reason = reason\n          env[ENV_KEY] = r\n        end\n\n        def self.preflight_hit(env)\n          r = Result.new\n          r.preflight = true\n          r.hit = true\n          env[ENV_KEY] = r\n        end\n\n        def self.preflight_miss(env, reason)\n          r = Result.new\n          r.preflight = true\n          r.hit = false\n          r.miss_reason = reason\n          env[ENV_KEY] = r\n        end\n\n        def append_header(headers)\n          headers[HEADER_KEY] = if hit?\n            preflight? ? 'preflight-hit' : 'hit'\n          else\n            [\n              (preflight? ? 'preflight-miss' : 'preflight-hit'),\n              miss_reason\n            ].join('; ')\n          end\n        end\n      end\n\n      class Resources\n        def initialize\n          @origins = []\n          @resources = []\n          @public_resources = false\n        end\n\n        def origins(*args, &blk)\n          @origins = args.flatten.collect do |n|\n            case n\n            when Regexp,\n                 /^https?:\\/\\//,\n                 'file://'        then n\n            when '*'              then @public_resources = true; n\n            else                  Regexp.compile(\"^[a-z][a-z0-9.+-]*:\\\\\\/\\\\\\/#{Regexp.quote(n)}\")\n            end\n          end.flatten\n          @origins.push(blk) if blk\n        end\n\n        def resource(path, opts={})\n          @resources << Resource.new(public_resources?, path, opts)\n        end\n\n        def public_resources?\n          @public_resources\n        end\n\n        def allow_origin?(source,env = {})\n          return true if public_resources?\n\n          effective_source = (source == 'null' ? 'file://' : source)\n\n          return !! @origins.detect do |origin|\n            if origin.is_a?(Proc)\n              origin.call(source,env)\n            else\n              origin === effective_source\n            end\n          end\n        end\n\n        def match_resource(path, env)\n          @resources.detect { |r| r.match?(path, env) }\n        end\n\n        def resource_for_path(path)\n          @resources.detect { |r| r.matches_path?(path) }\n        end\n\n      end\n\n      class Resource\n        attr_accessor :path, :methods, :headers, :expose, :max_age, :credentials, :pattern, :if_proc, :vary_headers\n\n        def initialize(public_resource, path, opts={})\n          self.path         = path\n          self.credentials  = opts[:credentials].nil? ? true : opts[:credentials]\n          self.max_age      = opts[:max_age] || 1728000\n          self.pattern      = compile(path)\n          self.if_proc      = opts[:if]\n          self.vary_headers = opts[:vary] && [opts[:vary]].flatten\n          @public_resource  = public_resource\n\n          self.headers = case opts[:headers]\n          when :any then :any\n          when nil then nil\n          else\n            [opts[:headers]].flatten.collect{|h| h.downcase}\n          end\n\n          self.methods = case opts[:methods]\n          when :any then [:get, :head, :post, :put, :patch, :delete, :options]\n          else\n            ensure_enum(opts[:methods]) || [:get]\n          end.map{|e| e.to_s }\n          \n          self.expose = opts[:expose] ? [opts[:expose]].flatten : nil\n        end\n\n        def matches_path?(path)\n          pattern =~ path\n        end\n\n        def match?(path, env)\n          matches_path?(path) && (if_proc.nil? || if_proc.call(env))\n        end\n\n        def process_preflight(env)\n          return nil if invalid_method_request?(env) || invalid_headers_request?(env)\n          {'Content-Type' => 'text/plain'}.merge(to_preflight_headers(env))\n        end\n\n        def to_headers(env)\n          h = {\n            'Access-Control-Allow-Origin'     => origin_for_response_header(env[ORIGIN_HEADER_KEY]),\n            'Access-Control-Allow-Methods'    => methods.collect{|m| m.to_s.upcase}.join(', '),\n            'Access-Control-Expose-Headers'   => expose.nil? ? '' : expose.join(', '),\n            'Access-Control-Max-Age'          => max_age.to_s }\n          h['Access-Control-Allow-Credentials'] = 'true' if credentials\n          h\n        end\n\n        protected\n          def public_resource?\n            @public_resource\n          end\n\n          def origin_for_response_header(origin)\n            return '*' if public_resource? && !credentials\n            origin\n          end\n\n          def to_preflight_headers(env)\n            h = to_headers(env)\n            if env['HTTP_ACCESS_CONTROL_REQUEST_HEADERS']\n              h.merge!('Access-Control-Allow-Headers' => env['HTTP_ACCESS_CONTROL_REQUEST_HEADERS'])\n            end\n            h\n          end\n\n          def invalid_method_request?(env)\n            request_method = env['HTTP_ACCESS_CONTROL_REQUEST_METHOD']\n            request_method.nil? || !methods.include?(request_method.downcase)\n          end\n\n          def invalid_headers_request?(env)\n            request_headers = env['HTTP_ACCESS_CONTROL_REQUEST_HEADERS']\n            request_headers && !allow_headers?(request_headers)\n          end\n\n          def allow_headers?(request_headers)\n            return false if headers.nil?\n            headers == :any || begin\n              request_headers = request_headers.split(/,\\s*/) if request_headers.kind_of?(String)\n              request_headers.all?{|h| headers.include?(h.downcase)}\n            end\n          end\n\n          def ensure_enum(v)\n            return nil if v.nil?\n            [v].flatten\n          end\n\n          def compile(path)\n            if path.respond_to? :to_str\n              special_chars = %w{. + ( )}\n              pattern =\n                path.to_str.gsub(/((:\\w+)|[\\*#{special_chars.join}])/) do |match|\n                  case match\n                  when \"*\"\n                    \"(.*?)\"\n                  when *special_chars\n                    Regexp.escape(match)\n                  else\n                    \"([^/?&#]+)\"\n                  end\n                end\n              /^#{pattern}$/\n            elsif path.respond_to? :match\n              path\n            else\n              raise TypeError, path\n            end\n          end\n      end\n\n  end\nend\n"], "fixing_code": ["require 'logger'\n\nmodule Rack\n  class Cors\n    ENV_KEY = 'rack.cors'.freeze\n\n    ORIGIN_HEADER_KEY     = 'HTTP_ORIGIN'.freeze\n    ORIGIN_X_HEADER_KEY   = 'HTTP_X_ORIGIN'.freeze\n    PATH_INFO_HEADER_KEY  = 'PATH_INFO'.freeze\n    VARY_HEADER_KEY       = 'Vary'.freeze\n    DEFAULT_VARY_HEADERS  = ['Origin'].freeze\n\n    def initialize(app, opts={}, &block)\n      @app = app\n      @debug_mode = !!opts[:debug]\n\n      if logger = opts[:logger]\n        if logger.respond_to? :call\n          @logger_proc = opts[:logger]\n        else\n          @logger = logger\n        end\n      end\n\n      if block_given?\n        if block.arity == 1\n          block.call(self)\n        else\n          instance_eval(&block)\n        end\n      end\n    end\n\n    def debug?\n      @debug_mode\n    end\n\n    def allow(&block)\n      all_resources << (resources = Resources.new)\n\n      if block.arity == 1\n        block.call(resources)\n      else\n        resources.instance_eval(&block)\n      end\n    end\n\n    def call(env)\n      env[ORIGIN_HEADER_KEY] ||= env[ORIGIN_X_HEADER_KEY] if env[ORIGIN_X_HEADER_KEY]\n\n      add_headers = nil\n      if env[ORIGIN_HEADER_KEY]\n        debug(env) do\n          [ 'Incoming Headers:',\n            \"  Origin: #{env[ORIGIN_HEADER_KEY]}\",\n            \"  Access-Control-Request-Method: #{env['HTTP_ACCESS_CONTROL_REQUEST_METHOD']}\",\n            \"  Access-Control-Request-Headers: #{env['HTTP_ACCESS_CONTROL_REQUEST_HEADERS']}\"\n            ].join(\"\\n\")\n        end\n        if env['REQUEST_METHOD'] == 'OPTIONS' and env['HTTP_ACCESS_CONTROL_REQUEST_METHOD']\n          if headers = process_preflight(env)\n            debug(env) do\n              \"Preflight Headers:\\n\" +\n                  headers.collect{|kv| \"  #{kv.join(': ')}\"}.join(\"\\n\")\n            end\n            return [200, headers, []]\n          end\n        else\n          add_headers = process_cors(env)\n        end\n      else\n        Result.miss(env, Result::MISS_NO_ORIGIN)\n      end\n\n      # This call must be done BEFORE calling the app because for some reason\n      # env[PATH_INFO_HEADER_KEY] gets changed after that and it won't match.\n      # (At least in rails 4.1.6)\n      vary_resource = resource_for_path(env[PATH_INFO_HEADER_KEY])\n\n      status, headers, body = @app.call env\n\n      if add_headers\n        headers = headers.merge(add_headers)\n      end\n\n      # Vary header should ALWAYS mention Origin if there's ANY chance for the\n      # response to be different depending on the Origin header value.\n      # Better explained here: http://www.fastly.com/blog/best-practices-for-using-the-vary-header/\n      if vary_resource\n        vary = headers[VARY_HEADER_KEY]\n        cors_vary_headers = if vary_resource.vary_headers && vary_resource.vary_headers.any?\n          vary_resource.vary_headers\n        else\n          DEFAULT_VARY_HEADERS\n        end\n        headers[VARY_HEADER_KEY] = ((vary ? vary.split(/,\\s*/) : []) + cors_vary_headers).uniq.join(', ')\n      end\n\n      if debug? && result = env[ENV_KEY]\n        result.append_header(headers)\n      end\n\n      [status, headers, body]\n    end\n\n    protected\n      def debug(env, message = nil, &block)\n        (@logger || select_logger(env)).debug(message, &block) if debug?\n      end\n\n      def select_logger(env)\n        @logger = if @logger_proc\n          logger_proc = @logger_proc\n          @logger_proc = nil\n          logger_proc.call\n\n        elsif defined?(Rails) && Rails.logger\n          Rails.logger\n\n        elsif env['rack.logger']\n          env['rack.logger']\n\n        else\n          ::Logger.new(STDOUT).tap { |logger| logger.level = ::Logger::Severity::DEBUG }\n        end\n      end\n\n      def all_resources\n        @all_resources ||= []\n      end\n\n      def process_preflight(env)\n        resource, error = match_resource(env)\n        if resource\n          Result.preflight_hit(env)\n          preflight = resource.process_preflight(env)\n          preflight\n\n        else\n          Result.preflight_miss(env, error)\n          nil\n        end\n      end\n\n      def process_cors(env)\n        resource, error = match_resource(env)\n        if resource\n          Result.hit(env)\n          cors = resource.to_headers(env)\n          cors\n\n        else\n          Result.miss(env, error)\n          nil\n        end\n      end\n\n      def resource_for_path(path_info)\n        all_resources.each do |r|\n          if found = r.resource_for_path(path_info)\n            return found\n          end\n        end\n        nil\n      end\n\n      def match_resource(env)\n        path   = env[PATH_INFO_HEADER_KEY]\n        origin = env[ORIGIN_HEADER_KEY]\n\n        origin_matched = false\n        all_resources.each do |r|\n          if r.allow_origin?(origin, env)\n            origin_matched = true\n            if found = r.match_resource(path, env)\n              return [found, nil]\n            end\n          end\n        end\n\n        [nil, origin_matched ? Result::MISS_NO_PATH : Result::MISS_NO_ORIGIN]\n      end\n\n      class Result\n        HEADER_KEY = 'X-Rack-CORS'.freeze\n\n        MISS_NO_ORIGIN = 'no-origin'.freeze\n        MISS_NO_PATH   = 'no-path'.freeze\n\n        attr_accessor :preflight, :hit, :miss_reason\n\n        def hit?\n          !!hit\n        end\n\n        def preflight?\n          !!preflight\n        end\n\n        def self.hit(env)\n          r = Result.new\n          r.preflight = false\n          r.hit = true\n          env[ENV_KEY] = r\n        end\n\n        def self.miss(env, reason)\n          r = Result.new\n          r.preflight = false\n          r.hit = false\n          r.miss_reason = reason\n          env[ENV_KEY] = r\n        end\n\n        def self.preflight_hit(env)\n          r = Result.new\n          r.preflight = true\n          r.hit = true\n          env[ENV_KEY] = r\n        end\n\n        def self.preflight_miss(env, reason)\n          r = Result.new\n          r.preflight = true\n          r.hit = false\n          r.miss_reason = reason\n          env[ENV_KEY] = r\n        end\n\n        def append_header(headers)\n          headers[HEADER_KEY] = if hit?\n            preflight? ? 'preflight-hit' : 'hit'\n          else\n            [\n              (preflight? ? 'preflight-miss' : 'preflight-hit'),\n              miss_reason\n            ].join('; ')\n          end\n        end\n      end\n\n      class Resources\n        def initialize\n          @origins = []\n          @resources = []\n          @public_resources = false\n        end\n\n        def origins(*args, &blk)\n          @origins = args.flatten.collect do |n|\n            case n\n            when Regexp,\n                 /^https?:\\/\\//,\n                 'file://'        then n\n            when '*'              then @public_resources = true; n\n            else                  Regexp.compile(\"^[a-z][a-z0-9.+-]*:\\\\\\/\\\\\\/#{Regexp.quote(n)}$\")\n            end\n          end.flatten\n          @origins.push(blk) if blk\n        end\n\n        def resource(path, opts={})\n          @resources << Resource.new(public_resources?, path, opts)\n        end\n\n        def public_resources?\n          @public_resources\n        end\n\n        def allow_origin?(source,env = {})\n          return true if public_resources?\n\n          effective_source = (source == 'null' ? 'file://' : source)\n\n          return !! @origins.detect do |origin|\n            if origin.is_a?(Proc)\n              origin.call(source,env)\n            else\n              origin === effective_source\n            end\n          end\n        end\n\n        def match_resource(path, env)\n          @resources.detect { |r| r.match?(path, env) }\n        end\n\n        def resource_for_path(path)\n          @resources.detect { |r| r.matches_path?(path) }\n        end\n\n      end\n\n      class Resource\n        attr_accessor :path, :methods, :headers, :expose, :max_age, :credentials, :pattern, :if_proc, :vary_headers\n\n        def initialize(public_resource, path, opts={})\n          self.path         = path\n          self.credentials  = opts[:credentials].nil? ? true : opts[:credentials]\n          self.max_age      = opts[:max_age] || 1728000\n          self.pattern      = compile(path)\n          self.if_proc      = opts[:if]\n          self.vary_headers = opts[:vary] && [opts[:vary]].flatten\n          @public_resource  = public_resource\n\n          self.headers = case opts[:headers]\n          when :any then :any\n          when nil then nil\n          else\n            [opts[:headers]].flatten.collect{|h| h.downcase}\n          end\n\n          self.methods = case opts[:methods]\n          when :any then [:get, :head, :post, :put, :patch, :delete, :options]\n          else\n            ensure_enum(opts[:methods]) || [:get]\n          end.map{|e| e.to_s }\n          \n          self.expose = opts[:expose] ? [opts[:expose]].flatten : nil\n        end\n\n        def matches_path?(path)\n          pattern =~ path\n        end\n\n        def match?(path, env)\n          matches_path?(path) && (if_proc.nil? || if_proc.call(env))\n        end\n\n        def process_preflight(env)\n          return nil if invalid_method_request?(env) || invalid_headers_request?(env)\n          {'Content-Type' => 'text/plain'}.merge(to_preflight_headers(env))\n        end\n\n        def to_headers(env)\n          h = {\n            'Access-Control-Allow-Origin'     => origin_for_response_header(env[ORIGIN_HEADER_KEY]),\n            'Access-Control-Allow-Methods'    => methods.collect{|m| m.to_s.upcase}.join(', '),\n            'Access-Control-Expose-Headers'   => expose.nil? ? '' : expose.join(', '),\n            'Access-Control-Max-Age'          => max_age.to_s }\n          h['Access-Control-Allow-Credentials'] = 'true' if credentials\n          h\n        end\n\n        protected\n          def public_resource?\n            @public_resource\n          end\n\n          def origin_for_response_header(origin)\n            return '*' if public_resource? && !credentials\n            origin\n          end\n\n          def to_preflight_headers(env)\n            h = to_headers(env)\n            if env['HTTP_ACCESS_CONTROL_REQUEST_HEADERS']\n              h.merge!('Access-Control-Allow-Headers' => env['HTTP_ACCESS_CONTROL_REQUEST_HEADERS'])\n            end\n            h\n          end\n\n          def invalid_method_request?(env)\n            request_method = env['HTTP_ACCESS_CONTROL_REQUEST_METHOD']\n            request_method.nil? || !methods.include?(request_method.downcase)\n          end\n\n          def invalid_headers_request?(env)\n            request_headers = env['HTTP_ACCESS_CONTROL_REQUEST_HEADERS']\n            request_headers && !allow_headers?(request_headers)\n          end\n\n          def allow_headers?(request_headers)\n            return false if headers.nil?\n            headers == :any || begin\n              request_headers = request_headers.split(/,\\s*/) if request_headers.kind_of?(String)\n              request_headers.all?{|h| headers.include?(h.downcase)}\n            end\n          end\n\n          def ensure_enum(v)\n            return nil if v.nil?\n            [v].flatten\n          end\n\n          def compile(path)\n            if path.respond_to? :to_str\n              special_chars = %w{. + ( )}\n              pattern =\n                path.to_str.gsub(/((:\\w+)|[\\*#{special_chars.join}])/) do |match|\n                  case match\n                  when \"*\"\n                    \"(.*?)\"\n                  when *special_chars\n                    Regexp.escape(match)\n                  else\n                    \"([^/?&#]+)\"\n                  end\n                end\n              /^#{pattern}$/\n            elsif path.respond_to? :match\n              path\n            else\n              raise TypeError, path\n            end\n          end\n      end\n\n  end\nend\n"], "filenames": ["lib/rack/cors.rb"], "buggy_code_start_loc": [256], "buggy_code_end_loc": [257], "fixing_code_start_loc": [256], "fixing_code_end_loc": [257], "type": "NVD-CWE-noinfo", "message": "Missing anchor in generated regex for rack-cors before 0.4.1 allows a malicious third-party site to perform CORS requests. If the configuration were intended to allow only the trusted example.com domain name and not the malicious example.net domain name, then example.com.example.net (as well as example.com-example.net) would be inadvertently allowed.", "other": {"cve": {"id": "CVE-2017-11173", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-13T03:29:00.217", "lastModified": "2020-03-03T19:16:55.467", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Missing anchor in generated regex for rack-cors before 0.4.1 allows a malicious third-party site to perform CORS requests. If the configuration were intended to allow only the trusted example.com domain name and not the malicious example.net domain name, then example.com.example.net (as well as example.com-example.net) would be inadvertently allowed."}, {"lang": "es", "value": "La falta de anclaje en la expresi\u00f3n regular (regex) generada para rack-cors anterior a versi\u00f3n 0.4.1 permite que un sitio de terceros malicioso realice peticiones CORS. Si la configuraci\u00f3n estuviera destinada a permitir solo el nombre de dominio de confianza example.com y no el nombre de dominio malicioso example.net, entonces, podr\u00eda ser permitido inadvertidamente example.com.example.net (as\u00ed como example.com-example.net)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rack-cors_project:rack-cors:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "0.4.1", "matchCriteriaId": "15A00D74-A764-4CA5-89B7-23E9E440D470"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2017/Jul/22", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3931", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/cyu/rack-cors/commit/42ebe6caa8e85ffa9c8a171bda668ba1acc7a5e6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://packetstormsecurity.com/files/143345/rack-cors-Missing-Anchor.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/cyu/rack-cors/commit/42ebe6caa8e85ffa9c8a171bda668ba1acc7a5e6"}}