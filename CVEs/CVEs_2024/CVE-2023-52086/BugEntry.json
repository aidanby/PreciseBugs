{"buggy_code": ["{\n  \"name\": \"dilab/resumable.php\",\n  \"description\": \"PHP package for Resumable.js\",\n  \"authors\": [\n    {\n      \"name\": \"xu ding\",\n      \"email\": \"thedilab@gmail.com\"\n    }\n  ],\n  \"require\": {\n    \"php\": \">=8.1.0\",\n    \"cakephp/filesystem\": \"^3.0\",\n    \"monolog/monolog\": \"^2.0\"\n  },\n  \"require-dev\": {\n    \"phpunit/phpunit\": \"~10.0\"\n  },\n  \"license\": \"MIT\",\n  \"autoload\": {\n    \"psr-4\": {\n      \"Dilab\\\\\": \"src/\"\n    }\n  },\n  \"autoload-dev\": {\n    \"psr-4\": {\n      \"Dilab\\\\Test\\\\\": \"test/src/\"\n    }\n  },\n  \"config\": {\n    \"allow-plugins\": {\n        \"dealerdirect/phpcodesniffer-composer-installer\": true\n    }\n  }\n}\n", "<?php\n\nnamespace Dilab;\n\nuse Cake\\Filesystem\\File;\nuse Cake\\Filesystem\\Folder;\nuse Dilab\\Network\\Request;\nuse Dilab\\Network\\Response;\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\nclass Resumable\n{\n    public $debug = false;\n\n    public $tempFolder = 'tmp';\n\n    public $uploadFolder = 'test/files/uploads';\n\n    // for testing\n    public $deleteTmpFolder = true;\n\n    protected $request;\n\n    protected $response;\n\n    protected $instanceId;\n\n    protected $params;\n\n    protected $chunkFile;\n\n    protected $log;\n\n    protected $filename;\n\n    protected $filepath;\n\n    protected $extension;\n\n    protected $originalFilename;\n\n    protected $isUploadComplete = false;\n\n    protected $resumableOption = [\n        'identifier' => 'identifier',\n        'filename' => 'filename',\n        'chunkNumber' => 'chunkNumber',\n        'chunkSize' => 'chunkSize',\n        'totalSize' => 'totalSize',\n        'totalChunks' => 'totalChunks'\n    ];\n\n    const WITHOUT_EXTENSION = true;\n\n    public function __construct(Request $request, Response $response, string|null $instanceId = null)\n    {\n        $this->request = $request;\n        $this->response = $response;\n        $this->instanceId = $instanceId;\n\n        $this->log = new Logger('debug');\n        $this->log->pushHandler(new StreamHandler('debug.log', Logger::DEBUG));\n\n        $this->preProcess();\n    }\n\n    public function setResumableOption(array $resumableOption)\n    {\n        $this->resumableOption = array_merge($this->resumableOption, $resumableOption);\n    }\n\n    // sets original filename and extension, blah blah\n    public function preProcess()\n    {\n        if (!empty($this->resumableParams())) {\n            if (!empty($this->request->file())) {\n                $this->extension = $this->findExtension($this->resumableParam('filename'));\n                $this->originalFilename = $this->resumableParam('filename');\n            }\n        }\n    }\n\n    public function process()\n    {\n        if (!empty($this->resumableParams())) {\n            if (!empty($this->request->file())) {\n                return $this->handleChunk();\n            } else {\n                return $this->handleTestChunk();\n            }\n        }\n    }\n\n    /**\n     * Get isUploadComplete\n     *\n     * @return boolean\n     */\n    public function isUploadComplete()\n    {\n        return $this->isUploadComplete;\n    }\n\n    /**\n     * Set final filename.\n     *\n     * @param string Final filename\n     */\n    public function setFilename($filename)\n    {\n        $this->filename = $filename;\n\n        return $this;\n    }\n\n    /**\n     * Get final filename.\n     *\n     * @return string Final filename\n     */\n    public function getFilename()\n    {\n        return $this->filename;\n    }\n\n    /**\n     * Get final filename.\n     *\n     * @return string Final filename\n     */\n    public function getOriginalFilename($withoutExtension = false)\n    {\n        if ($withoutExtension === static::WITHOUT_EXTENSION) {\n            return $this->removeExtension($this->originalFilename);\n        }\n\n        return $this->originalFilename;\n    }\n\n    /**\n     * Get final filapath.\n     *\n     * @return string Final filename\n     */\n    public function getFilepath()\n    {\n        return $this->filepath;\n    }\n\n    /**\n     * Get final extension.\n     *\n     * @return string Final extension name\n     */\n    public function getExtension()\n    {\n        return $this->extension;\n    }\n\n    /**\n     * Makes sure the orginal extension never gets overriden by user defined filename.\n     *\n     * @param string User defined filename\n     * @param string Original filename\n     * @return string Filename that always has an extension from the original file\n     */\n    private function createSafeFilename($filename, $originalFilename)\n    {\n        $filename = $this->removeExtension($filename);\n        $extension = $this->findExtension($originalFilename);\n\n        return sprintf('%s.%s', $filename, $extension);\n    }\n\n    public function handleTestChunk()\n    {\n        $identifier = $this->resumableParam($this->resumableOption['identifier']);\n        $filename = $this->resumableParam($this->resumableOption['filename']);\n        $chunkNumber = (int) $this->resumableParam($this->resumableOption['chunkNumber']);\n        $chunkSize = (int) $this->resumableParam($this->resumableOption['chunkSize']);\n        $totalChunks = (int) $this->resumableParam($this->resumableOption['totalChunks']);\n\n        if (!$this->isChunkUploaded($identifier, $filename, $chunkNumber)) {\n            return $this->response->header(204);\n        } else {\n            if ($this->isFileUploadComplete($filename, $identifier, $totalChunks)) {\n                $this->isUploadComplete = true;\n                $this->createFileAndDeleteTmp($identifier, $filename);\n                return $this->response->header(201);\n            }\n            return $this->response->header(200);\n        }\n\n    }\n\n    public function handleChunk()\n    {\n        $file = $this->request->file();\n        $identifier = $this->resumableParam($this->resumableOption['identifier']);\n        $filename = $this->resumableParam($this->resumableOption['filename']);\n        $chunkNumber = (int) $this->resumableParam($this->resumableOption['chunkNumber']);\n        $chunkSize = (int) $this->resumableParam($this->resumableOption['chunkSize']);\n        $totalChunks = (int) $this->resumableParam($this->resumableOption['totalChunks']);\n\n        if (!$this->isChunkUploaded($identifier, $filename, $chunkNumber)) {\n            $chunkFile = $this->tmpChunkDir($identifier) . DIRECTORY_SEPARATOR . $this->tmpChunkFilename($filename, $chunkNumber);\n            $this->moveUploadedFile($file['tmp_name'], $chunkFile);\n        }\n\n        if ($this->isFileUploadComplete($filename, $identifier, $totalChunks)) {\n            $this->isUploadComplete = true;\n            $this->createFileAndDeleteTmp($identifier, $filename);\n            return $this->response->header(201);\n        }\n\n        return $this->response->header(200);\n    }\n\n    /**\n     * Create the final file from chunks\n     */\n    private function createFileAndDeleteTmp($identifier, $filename)\n    {\n        $tmpFolder = new Folder($this->tmpChunkDir($identifier));\n        $chunkFiles = $tmpFolder->read(true, true, true)[1];\n\n        // if the user has set a custom filename\n        if (null !== $this->filename) {\n            $finalFilename = $this->createSafeFilename($this->filename, $filename);\n        } else {\n            $finalFilename = $filename;\n        }\n\n        // replace filename reference by the final file\n        $this->filepath = $this->uploadFolder . DIRECTORY_SEPARATOR;\n        if (!empty($this->instanceId)) {\n            $this->filepath .= $this->instanceId . DIRECTORY_SEPARATOR;\n        }\n        $this->filepath .= $finalFilename;\n\n        $this->extension = $this->findExtension($this->filepath);\n\n        if ($this->createFileFromChunks($chunkFiles, $this->filepath) && $this->deleteTmpFolder) {\n            $tmpFolder->delete();\n            $this->isUploadComplete = true;\n        }\n    }\n\n    private function resumableParam($shortName)\n    {\n        $resumableParams = $this->resumableParams();\n        if (!isset($resumableParams['resumable' . ucfirst($shortName)])) {\n            return null;\n        }\n        return $resumableParams['resumable' . ucfirst($shortName)];\n    }\n\n    public function resumableParams()\n    {\n        if ($this->request->is('get')) {\n            return $this->request->data('get');\n        }\n        if ($this->request->is('post')) {\n            return $this->request->data('post');\n        }\n    }\n\n    public function isFileUploadComplete($filename, $identifier, $totalChunks)\n    {\n        for ($i = 1; $i <= $totalChunks; $i++) {\n            if (!$this->isChunkUploaded($identifier, $filename, $i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public function isChunkUploaded($identifier, $filename, $chunkNumber)\n    {\n        $file = new File($this->tmpChunkDir($identifier) . DIRECTORY_SEPARATOR . $this->tmpChunkFilename($filename, $chunkNumber));\n        return $file->exists();\n    }\n\n    public function tmpChunkDir($identifier)\n    {\n        $tmpChunkDir = $this->tempFolder. DIRECTORY_SEPARATOR;\n        if (!empty($this->instanceId)){\n            $tmpChunkDir .= $this->instanceId . DIRECTORY_SEPARATOR;\n        }\n        $tmpChunkDir .= $identifier;\n        $this->ensureDirExists($tmpChunkDir);\n        return $tmpChunkDir;\n    }\n\n    /**\n     * make directory if it doesn't exists (Immune against the race condition)\n     *\n     *\n     * since the resumable is usually used with simultaneously uploads,\n     * this sometimes resulted in directory creation between the *is_dir* check\n     * and *mkdir* then following race condition.\n     * in this setup it will shut down the mkdir error\n     * then try to check if directory is created after that\n     *\n     * @param string $path the directoryPath to ensure\n     * @return void\n     * @throws \\Exception\n     */\n    private function ensureDirExists($path)\n    {\n        umask(0);\n        if ( is_dir($path) || @mkdir($path, 0775, true) || is_dir($path)) {\n            return;\n        }\n        throw new \\Exception(\"could not mkdir $path\");\n    }\n\n    public function tmpChunkFilename($filename, $chunkNumber)\n    {\n        return $filename . '.' . str_pad($chunkNumber, 4, 0, STR_PAD_LEFT);\n    }\n\n    public function getExclusiveFileHandle($name)\n    {\n        // if the file exists, fopen() will raise a warning\n        $previous_error_level = error_reporting();\n        error_reporting(E_ERROR);\n        $handle = fopen($name, 'x');\n        error_reporting($previous_error_level);\n        return $handle;\n    }\n\n    public function createFileFromChunks($chunkFiles, $destFile)\n    {\n        $this->log('Beginning of create files from chunks');\n\n        natsort($chunkFiles);\n\n        if (!empty($this->instanceId)) {\n            $this->ensureDirExists(dirname($destFile));\n        }\n\n        $handle = $this->getExclusiveFileHandle($destFile);\n        if (!$handle) {\n            return false;\n        }\n\n        $destFile = new File($destFile);\n        $destFile->handle = $handle;\n        foreach ($chunkFiles as $chunkFile) {\n            $file = new File($chunkFile);\n            $destFile->append($file->read());\n\n            $this->log('Append ', ['chunk file' => $chunkFile]);\n        }\n\n        $this->log('End of create files from chunks');\n        return $destFile->exists();\n    }\n\n    public function moveUploadedFile($file, $destFile)\n    {\n        //workaround cakephp error regarding: TMP not defined\n        define(\"TMP\",sys_get_temp_dir());\n\n        $file = new File($file);\n        if ($file->exists()) {\n            return $file->copy($destFile);\n        }\n        return false;\n    }\n\n    public function setRequest($request)\n    {\n        $this->request = $request;\n    }\n\n    public function setResponse($response)\n    {\n        $this->response = $response;\n    }\n\n    private function log($msg, $ctx = array())\n    {\n        if ($this->debug) {\n            $this->log->addDebug($msg, $ctx);\n        }\n    }\n\n    private function findExtension($filename)\n    {\n        $parts = explode('.', basename($filename));\n\n        return end($parts);\n    }\n\n    private function removeExtension($filename)\n    {\n        $parts = explode('.', basename($filename));\n        $ext = end($parts); // get extension\n\n        // remove extension from filename if any\n        return str_replace(sprintf('.%s', $ext), '', $filename);\n    }\n}\n\n", "<?php\nnamespace Dilab\\Test;\n\nuse Dilab\\Network\\SimpleRequest;\nuse Dilab\\Resumable;\nuse Cake\\Filesystem\\File;\n\n/**\n * Class ResumbableTest\n * @package Dilab\\Test\n * @property $resumbable Resumable\n * @property $request Request\n * @property $response Response\n */\nclass ResumableTest extends \\PHPUnit\\Framework\\TestCase\n{\n    public $resumbable;\n\n    protected $provider;\n\n    protected function setUp() : void\n    {\n        $this->request = $this->getMockBuilder('Dilab\\Network\\SimpleRequest')\n                        ->getMock();\n\n        $this->response = $this->getMockBuilder('Dilab\\Network\\SimpleResponse')\n                        ->getMock();\n    }\n\n    public function tearDown() : void\n    {\n        unset($this->request);\n        unset($this->response);\n        parent::tearDown();\n    }\n\n    public function testProcessHandleChunk()\n    {\n        $resumableParams = array(\n            'resumableChunkNumber'=> 3,\n            'resumableTotalChunks'=> 600,\n            'resumableChunkSize'=>  200,\n            'resumableIdentifier'=> 'identifier',\n            'resumableFilename'=> 'mock.png',\n            'resumableRelativePath'=> 'upload',\n        );\n\n        $this->request->method('is')->willReturn(true);\n\n        $this->request->method('file')\n                    ->willReturn([\n                            'name'=> 'mock.png',\n                            'tmp_name'=>  'test/files/mock.png.0003',\n                            'error'=> 0,\n                            'size'=> 27000,\n                        ]);\n\n        $this->request->method('data')->willReturn($resumableParams);\n\n        $this->resumbable = $this->getMockBuilder('Dilab\\Resumable')\n                                ->setConstructorArgs(array($this->request,$this->response))\n                                ->onlyMethods(array('handleChunk'))\n                                ->getMock();\n\n        $this->resumbable->expects($this->once())\n                        ->method('handleChunk')\n                        ->willReturn(true);\n\n        $this->resumbable->process();\n    }\n\n    public function testProcessHandleTestChunk()\n    {\n        $resumableParams = array(\n            'resumableChunkNumber'=> 3,\n            'resumableTotalChunks'=> 600,\n            'resumableChunkSize'=>  200,\n            'resumableIdentifier'=> 'identifier',\n            'resumableFilename'=> 'mock.png',\n            'resumableRelativePath'=> 'upload',\n        );\n\n        $this->request->method('is')->willReturn(true);\n\n        $this->request->method('file')->willReturn([]);\n\n        $this->request->method('data')->willReturn($resumableParams);\n\n        $this->resumbable = $this->getMockBuilder('Dilab\\Resumable')\n                                ->setConstructorArgs(array($this->request,$this->response))\n                                ->onlyMethods(array('handleTestChunk'))\n                                ->getMock();\n\n        $this->resumbable->expects($this->once())\n                        ->method('handleTestChunk')\n                        ->willReturn(true);\n\n        $this->resumbable->process();\n    }\n\n    public function testHandleTestChunk()\n    {\n        $this->request->method('is')\n                      ->willReturn(true);\n\n        $this->request->method('data')\n                      ->willReturn(array(\n                           'resumableChunkNumber'=> 1,\n                           'resumableTotalSize'=> 600,\n                           'resumableChunkSize'=>  200,\n                           'resumableIdentifier'=> 'identifier',\n                           'resumableFilename'=> 'mock.png',\n                           'resumableRelativePath'=> 'upload',\n                      ));\n\n        $this->response->expects($this->once())\n                        ->method('header')\n                        ->with($this->equalTo(201));\n\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->tempFolder = 'test/tmp';\n        $this->resumbable->handleTestChunk();\n    }\n\n    public function testHandleChunk() {\n        $resumableParams = array(\n            'resumableChunkNumber'=> 3,\n            // 'resumableTotalChunks'=> 600,\n            'resumableTotalSize'=> 600,\n            'resumableChunkSize'=>  200,\n            'resumableIdentifier'=> 'identifier',\n            'resumableFilename'=> 'mock.png',\n            'resumableRelativePath'=> 'upload',\n        );\n\n\n        $this->request->method('is')\n            ->willReturn(true);\n\n        $this->request->method('data')\n                ->willReturn($resumableParams);\n\n        $this->request->method('file')\n                ->willReturn(array(\n                    'name'=> 'mock.png',\n                    'tmp_name'=>  'test/files/mock.png.0003',\n                    'error'=> 0,\n                    'size'=> 27000,\n                ));\n\n        $this->resumbable = new Resumable($this->request, $this->response);\n        $this->resumbable->tempFolder = 'test/tmp';\n        $this->resumbable->uploadFolder = 'test/uploads';\n        $this->resumbable->deleteTmpFolder = false;\n        $this->resumbable->handleChunk();\n\n        $this->assertFileExists('test/uploads/mock.png');\n        file_exists('test/tmp/identifier/mock.png.0003') && unlink('test/tmp/identifier/mock.png.0003');\n        unlink('test/uploads/mock.png');\n    }\n\n    public function testResumableParamsGetRequest()\n    {\n        $resumableParams = array(\n            'resumableChunkNumber'=> 1,\n            'resumableTotalChunks'=> 100,\n            'resumableChunkSize'=>  1000,\n            'resumableIdentifier'=> 100,\n            'resumableFilename'=> 'mock_file_name',\n            'resumableRelativePath'=> 'upload',\n        );\n\n        $this->request = $this->getMockBuilder('Dilab\\Network\\SimpleRequest')\n            ->getMock();\n\n        $this->request->method('is')\n            ->willReturn(true);\n\n        $this->request->method('data')->willReturn($resumableParams);\n\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->assertEquals($resumableParams, $this->resumbable->resumableParams());\n    }\n\n    public static function isFileUploadCompleteProvider()\n    {\n        return [\n            ['mock.png', 'files', 1, true],// test/files/0001-0003 exist\n            ['mock.png', 'files', 2, true],// test/files/0001-0003 exist\n            ['mock.png', 'files', 3, true],// test/files/0001-0003 exist\n            ['mock.png', 'files', 4, false],// no 0004 chunk\n            ['mock.png', 'files', 5, false],// no 0004-0005 chunks\n            ['mock.png', 'files', 15, false],// no 0004-00015 chunks\n        ];\n    }\n\n    /**\n     *\n     * @dataProvider isFileUploadCompleteProvider\n     */\n    public function testIsFileUploadComplete($filename,$identifier, $totalChunks, $expected)\n    {\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->tempFolder ='test';\n        $this->assertEquals($expected, $this->resumbable->isFileUploadComplete($filename, $identifier, $totalChunks));\n    }\n\n    public function testIsChunkUploaded()\n    {\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->tempFolder ='test';\n        $identifier = 'files';\n        $filename = 'mock.png';\n        $this->assertTrue($this->resumbable->isChunkUploaded($identifier,$filename,1));\n        $this->assertFalse($this->resumbable->isChunkUploaded($identifier,$filename,10));\n    }\n\n    public function testTmpChunkDir()\n    {\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->tempFolder ='test';\n        $identifier = 'mock-identifier';\n        $expected = $this->resumbable->tempFolder.DIRECTORY_SEPARATOR.$identifier;\n        $this->assertEquals($expected, $this->resumbable->tmpChunkDir($identifier));\n        $this->assertFileExists($expected);\n        rmdir($expected);\n    }\n\n    public function testTmpChunkFile()\n    {\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $filename = 'mock-file.png';\n        $chunkNumber = str_pad(1, 4, 0, STR_PAD_LEFT);\n        $expected = $filename.'.'.$chunkNumber;\n        $this->assertEquals($expected, $this->resumbable->tmpChunkFilename($filename,$chunkNumber));\n    }\n\n    public function testCreateFileFromChunks()\n    {\n        $files = array(\n            'test/files/mock.png.0001',\n            'test/files/mock.png.0002',\n            'test/files/mock.png.0003',\n        );\n        $totalFileSize = array_sum(array(\n            filesize('test/files/mock.png.0001'),\n            filesize('test/files/mock.png.0002'),\n            filesize('test/files/mock.png.0003')\n        ));\n        $destFile = 'test/files/5.png';\n\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->createFileFromChunks($files, $destFile);\n        $this->assertFileExists($destFile);\n        $this->assertEquals($totalFileSize, filesize($destFile));\n        unlink('test/files/5.png');\n    }\n\n    public function testMoveUploadedFile()\n    {\n        $destFile = 'test/files/4.png';\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->moveUploadedFile('test/files/mock.png.0001', $destFile);\n        $this->assertFileExists($destFile);\n        unlink($destFile);\n    }\n}\n"], "fixing_code": ["{\n  \"name\": \"dilab/resumable.php\",\n  \"description\": \"PHP package for Resumable.js\",\n  \"authors\": [\n    {\n      \"name\": \"xu ding\",\n      \"email\": \"thedilab@gmail.com\"\n    }\n  ],\n  \"require\": {\n    \"php\": \">=8.1.0\",\n    \"cakephp/filesystem\": \"^3.0\",\n    \"monolog/monolog\": \"^2.0\",\n    \"ondrej-vrto/php-filename-sanitize\": \"^1.4\"\n  },\n  \"require-dev\": {\n    \"phpunit/phpunit\": \"~10.0\"\n  },\n  \"license\": \"MIT\",\n  \"autoload\": {\n    \"psr-4\": {\n      \"Dilab\\\\\": \"src/\"\n    }\n  },\n  \"autoload-dev\": {\n    \"psr-4\": {\n      \"Dilab\\\\Test\\\\\": \"test/src/\"\n    }\n  },\n  \"config\": {\n    \"allow-plugins\": {\n        \"dealerdirect/phpcodesniffer-composer-installer\": true\n    }\n  }\n}\n", "<?php\n\nnamespace Dilab;\n\nuse Cake\\Filesystem\\File;\nuse Cake\\Filesystem\\Folder;\nuse Dilab\\Network\\Request;\nuse Dilab\\Network\\Response;\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\nuse OndrejVrto\\FilenameSanitize\\FilenameSanitize;\n\nclass Resumable\n{\n    public $debug = false;\n\n    public $tempFolder = 'tmp';\n\n    public $uploadFolder = 'test/files/uploads';\n\n    // for testing\n    public $deleteTmpFolder = true;\n\n    protected $request;\n\n    protected $response;\n\n    protected $instanceId;\n\n    protected $params;\n\n    protected $chunkFile;\n\n    protected $log;\n\n    protected $filename;\n\n    protected $filepath;\n\n    protected $extension;\n\n    protected $originalFilename;\n\n    protected $isUploadComplete = false;\n\n    protected $resumableOption = [\n        'identifier' => 'identifier',\n        'filename' => 'filename',\n        'chunkNumber' => 'chunkNumber',\n        'chunkSize' => 'chunkSize',\n        'totalSize' => 'totalSize',\n        'totalChunks' => 'totalChunks'\n    ];\n\n    const WITHOUT_EXTENSION = true;\n\n    public function __construct(Request $request, Response $response, string|null $instanceId = null)\n    {\n        $this->request = $request;\n        $this->response = $response;\n        $this->instanceId = $instanceId;\n\n        $this->log = new Logger('debug');\n        $this->log->pushHandler(new StreamHandler('debug.log', Logger::DEBUG));\n\n        $this->preProcess();\n    }\n\n    public function setResumableOption(array $resumableOption)\n    {\n        $this->resumableOption = array_merge($this->resumableOption, $resumableOption);\n    }\n\n    // sets original filename and extension, blah blah\n    public function preProcess()\n    {\n        if (!empty($this->resumableParams())) {\n            if (!empty($this->request->file())) {\n                $this->extension = $this->findExtension($this->resumableParam('filename'));\n                $this->originalFilename = $this->resumableParam('filename');\n            }\n        }\n    }\n\n    public function process()\n    {\n        if (!empty($this->resumableParams())) {\n            if (!empty($this->request->file())) {\n                return $this->handleChunk();\n            } else {\n                return $this->handleTestChunk();\n            }\n        }\n    }\n\n    /**\n     * Get isUploadComplete\n     *\n     * @return boolean\n     */\n    public function isUploadComplete()\n    {\n        return $this->isUploadComplete;\n    }\n\n    /**\n     * Set final filename.\n     *\n     * @param string Final filename\n     */\n    public function setFilename($filename)\n    {\n        $this->filename = $filename;\n\n        return $this;\n    }\n\n    /**\n     * Get final filename.\n     *\n     * @return string Final filename\n     */\n    public function getFilename()\n    {\n        return $this->filename;\n    }\n\n    /**\n     * Get final filename.\n     *\n     * @return string Final filename\n     */\n    public function getOriginalFilename($withoutExtension = false)\n    {\n        if ($withoutExtension === static::WITHOUT_EXTENSION) {\n            return $this->removeExtension($this->originalFilename);\n        }\n\n        return $this->originalFilename;\n    }\n\n    /**\n     * Get final filapath.\n     *\n     * @return string Final filename\n     */\n    public function getFilepath()\n    {\n        return $this->filepath;\n    }\n\n    /**\n     * Get final extension.\n     *\n     * @return string Final extension name\n     */\n    public function getExtension()\n    {\n        return $this->extension;\n    }\n\n    /**\n     * Creates a safe name\n     *\n     * @param string $name Original name\n     * @return string A safer name\n     */\n    private function createSafeName(string $name): string\n    {\n        return FilenameSanitize::of($name)->get();\n    }\n\n    public function handleTestChunk()\n    {\n        $identifier = $this->resumableParam($this->resumableOption['identifier']);\n        $filename = $this->resumableParam($this->resumableOption['filename']);\n        $chunkNumber = (int) $this->resumableParam($this->resumableOption['chunkNumber']);\n        $chunkSize = (int) $this->resumableParam($this->resumableOption['chunkSize']);\n        $totalChunks = (int) $this->resumableParam($this->resumableOption['totalChunks']);\n\n        if (!$this->isChunkUploaded($identifier, $filename, $chunkNumber)) {\n            return $this->response->header(204);\n        } else {\n            if ($this->isFileUploadComplete($filename, $identifier, $totalChunks)) {\n                $this->isUploadComplete = true;\n                $this->createFileAndDeleteTmp($identifier, $filename);\n                return $this->response->header(201);\n            }\n            return $this->response->header(200);\n        }\n\n    }\n\n    public function handleChunk()\n    {\n        $file = $this->request->file();\n        $identifier = $this->resumableParam($this->resumableOption['identifier']);\n        $filename = $this->resumableParam($this->resumableOption['filename']);\n        $chunkNumber = (int) $this->resumableParam($this->resumableOption['chunkNumber']);\n        $chunkSize = (int) $this->resumableParam($this->resumableOption['chunkSize']);\n        $totalChunks = (int) $this->resumableParam($this->resumableOption['totalChunks']);\n\n        if (!$this->isChunkUploaded($identifier, $filename, $chunkNumber)) {\n            $chunkFile = $this->tmpChunkDir($identifier) . DIRECTORY_SEPARATOR . $this->tmpChunkFilename($filename, $chunkNumber);\n            $this->moveUploadedFile($file['tmp_name'], $chunkFile);\n        }\n\n        if ($this->isFileUploadComplete($filename, $identifier, $totalChunks)) {\n            $this->isUploadComplete = true;\n            $this->createFileAndDeleteTmp($identifier, $filename);\n            return $this->response->header(201);\n        }\n\n        return $this->response->header(200);\n    }\n\n    /**\n     * Create the final file from chunks\n     */\n    private function createFileAndDeleteTmp($identifier, $filename)\n    {\n        $tmpFolder = new Folder($this->tmpChunkDir($identifier));\n        $chunkFiles = $tmpFolder->read(true, true, true)[1];\n\n        // if the user has set a custom filename\n        if (null !== $this->filename) {\n            $finalFilename = $this->createSafeName($this->filename);\n        } else {\n            $finalFilename = $this->createSafeName($filename);\n        }\n\n        // replace filename reference by the final file\n        $this->filepath = $this->uploadFolder . DIRECTORY_SEPARATOR;\n        if (!empty($this->instanceId)) {\n            $this->filepath .= $this->instanceId . DIRECTORY_SEPARATOR;\n        }\n        $this->filepath .= $finalFilename;\n\n        $this->extension = $this->findExtension($this->filepath);\n\n        if ($this->createFileFromChunks($chunkFiles, $this->filepath) && $this->deleteTmpFolder) {\n            $tmpFolder->delete();\n            $this->isUploadComplete = true;\n        }\n    }\n\n    private function resumableParam($shortName)\n    {\n        $resumableParams = $this->resumableParams();\n        if (!isset($resumableParams['resumable' . ucfirst($shortName)])) {\n            return null;\n        }\n        return $resumableParams['resumable' . ucfirst($shortName)];\n    }\n\n    public function resumableParams()\n    {\n        if ($this->request->is('get')) {\n            return $this->request->data('get');\n        }\n        if ($this->request->is('post')) {\n            return $this->request->data('post');\n        }\n    }\n\n    public function isFileUploadComplete($filename, $identifier, $totalChunks)\n    {\n        for ($i = 1; $i <= $totalChunks; $i++) {\n            if (!$this->isChunkUploaded($identifier, $filename, $i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public function isChunkUploaded($identifier, $filename, $chunkNumber)\n    {\n        $file = new File($this->tmpChunkDir($identifier) . DIRECTORY_SEPARATOR . $this->tmpChunkFilename($filename, $chunkNumber));\n        return $file->exists();\n    }\n\n    public function tmpChunkDir($identifier)\n    {\n        $tmpChunkDir = $this->tempFolder. DIRECTORY_SEPARATOR;\n        if (!empty($this->instanceId)){\n            $tmpChunkDir .= $this->instanceId . DIRECTORY_SEPARATOR;\n        }\n        $tmpChunkDir .= $this->createSafeName($identifier);\n        $this->ensureDirExists($tmpChunkDir);\n        return $tmpChunkDir;\n    }\n\n    /**\n     * make directory if it doesn't exists (Immune against the race condition)\n     *\n     *\n     * since the resumable is usually used with simultaneously uploads,\n     * this sometimes resulted in directory creation between the *is_dir* check\n     * and *mkdir* then following race condition.\n     * in this setup it will shut down the mkdir error\n     * then try to check if directory is created after that\n     *\n     * @param string $path the directoryPath to ensure\n     * @return void\n     * @throws \\Exception\n     */\n    private function ensureDirExists($path)\n    {\n        umask(0);\n        if ( is_dir($path) || @mkdir($path, 0775, true) || is_dir($path)) {\n            return;\n        }\n        throw new \\Exception(\"could not mkdir $path\");\n    }\n\n    public function tmpChunkFilename($filename, $chunkNumber)\n    {\n        return $this->createSafeName($filename) . '.' . str_pad($chunkNumber, 4, 0, STR_PAD_LEFT);\n    }\n\n    public function getExclusiveFileHandle($name)\n    {\n        // if the file exists, fopen() will raise a warning\n        $previous_error_level = error_reporting();\n        error_reporting(E_ERROR);\n        $handle = fopen($name, 'x');\n        error_reporting($previous_error_level);\n        return $handle;\n    }\n\n    public function createFileFromChunks($chunkFiles, $destFile)\n    {\n        $this->log('Beginning of create files from chunks');\n\n        natsort($chunkFiles);\n\n        if (!empty($this->instanceId)) {\n            $this->ensureDirExists(dirname($destFile));\n        }\n\n        $handle = $this->getExclusiveFileHandle($destFile);\n        if (!$handle) {\n            return false;\n        }\n\n        $destFile = new File($destFile);\n        $destFile->handle = $handle;\n        foreach ($chunkFiles as $chunkFile) {\n            $file = new File($chunkFile);\n            $destFile->append($file->read());\n\n            $this->log('Append ', ['chunk file' => $chunkFile]);\n        }\n\n        $this->log('End of create files from chunks');\n        return $destFile->exists();\n    }\n\n    public function moveUploadedFile($file, $destFile)\n    {\n        //workaround cakephp error regarding: TMP not defined\n        define(\"TMP\",sys_get_temp_dir());\n\n        $file = new File($file);\n        if ($file->exists()) {\n            return $file->copy($destFile);\n        }\n        return false;\n    }\n\n    public function setRequest($request)\n    {\n        $this->request = $request;\n    }\n\n    public function setResponse($response)\n    {\n        $this->response = $response;\n    }\n\n    private function log($msg, $ctx = array())\n    {\n        if ($this->debug) {\n            $this->log->addDebug($msg, $ctx);\n        }\n    }\n\n    private function findExtension($filename)\n    {\n        $parts = explode('.', basename($filename));\n\n        return end($parts);\n    }\n\n    private function removeExtension($filename)\n    {\n        $parts = explode('.', basename($filename));\n        $ext = end($parts); // get extension\n\n        // remove extension from filename if any\n        return str_replace(sprintf('.%s', $ext), '', $filename);\n    }\n}\n\n", "<?php\nnamespace Dilab\\Test;\n\nuse Dilab\\Network\\SimpleRequest;\nuse Dilab\\Resumable;\nuse Cake\\Filesystem\\File;\n\n/**\n * Class ResumbableTest\n * @package Dilab\\Test\n * @property $resumbable Resumable\n * @property $request Request\n * @property $response Response\n */\nclass ResumableTest extends \\PHPUnit\\Framework\\TestCase\n{\n    public $resumbable;\n\n    protected $provider;\n\n    protected function setUp() : void\n    {\n        $this->request = $this->getMockBuilder('Dilab\\Network\\SimpleRequest')\n                        ->getMock();\n\n        $this->response = $this->getMockBuilder('Dilab\\Network\\SimpleResponse')\n                        ->getMock();\n    }\n\n    public function tearDown() : void\n    {\n        unset($this->request);\n        unset($this->response);\n        parent::tearDown();\n    }\n\n    public function testProcessHandleChunk()\n    {\n        $resumableParams = array(\n            'resumableChunkNumber'=> 3,\n            'resumableTotalChunks'=> 600,\n            'resumableChunkSize'=>  200,\n            'resumableIdentifier'=> 'identifier',\n            'resumableFilename'=> 'mock.png',\n            'resumableRelativePath'=> 'upload',\n        );\n\n        $this->request->method('is')->willReturn(true);\n\n        $this->request->method('file')\n                    ->willReturn([\n                            'name'=> 'mock.png',\n                            'tmp_name'=>  'test/files/mock.png.0003',\n                            'error'=> 0,\n                            'size'=> 27000,\n                        ]);\n\n        $this->request->method('data')->willReturn($resumableParams);\n\n        $this->resumbable = $this->getMockBuilder('Dilab\\Resumable')\n                                ->setConstructorArgs(array($this->request,$this->response))\n                                ->onlyMethods(array('handleChunk'))\n                                ->getMock();\n\n        $this->resumbable->expects($this->once())\n                        ->method('handleChunk')\n                        ->willReturn(true);\n\n        $this->resumbable->process();\n    }\n\n    public function testProcessHandleTestChunk()\n    {\n        $resumableParams = array(\n            'resumableChunkNumber'=> 3,\n            'resumableTotalChunks'=> 600,\n            'resumableChunkSize'=>  200,\n            'resumableIdentifier'=> 'identifier',\n            'resumableFilename'=> 'mock.png',\n            'resumableRelativePath'=> 'upload',\n        );\n\n        $this->request->method('is')->willReturn(true);\n\n        $this->request->method('file')->willReturn([]);\n\n        $this->request->method('data')->willReturn($resumableParams);\n\n        $this->resumbable = $this->getMockBuilder('Dilab\\Resumable')\n                                ->setConstructorArgs(array($this->request,$this->response))\n                                ->onlyMethods(array('handleTestChunk'))\n                                ->getMock();\n\n        $this->resumbable->expects($this->once())\n                        ->method('handleTestChunk')\n                        ->willReturn(true);\n\n        $this->resumbable->process();\n    }\n\n    public function testHandleTestChunk()\n    {\n        $this->request->method('is')\n                      ->willReturn(true);\n\n        $this->request->method('data')\n                      ->willReturn(array(\n                           'resumableChunkNumber'=> 1,\n                           'resumableTotalSize'=> 600,\n                           'resumableChunkSize'=>  200,\n                           'resumableIdentifier'=> 'identifier',\n                           'resumableFilename'=> 'mock.png',\n                           'resumableRelativePath'=> 'upload',\n                      ));\n\n        $this->response->expects($this->once())\n                        ->method('header')\n                        ->with($this->equalTo(201));\n\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->tempFolder = 'test/tmp';\n        $this->resumbable->handleTestChunk();\n    }\n\n    public function testHandleChunk() {\n        $resumableParams = array(\n            'resumableChunkNumber'=> 3,\n            // 'resumableTotalChunks'=> 600,\n            'resumableTotalSize'=> 600,\n            'resumableChunkSize'=>  200,\n            'resumableIdentifier'=> 'identifier',\n            'resumableFilename'=> 'mock.png',\n            'resumableRelativePath'=> 'upload',\n        );\n\n\n        $this->request->method('is')\n            ->willReturn(true);\n\n        $this->request->method('data')\n                ->willReturn($resumableParams);\n\n        $this->request->method('file')\n                ->willReturn(array(\n                    'name'=> 'mock.png',\n                    'tmp_name'=>  'test/files/mock.png.0003',\n                    'error'=> 0,\n                    'size'=> 27000,\n                ));\n\n        $this->resumbable = new Resumable($this->request, $this->response);\n        $this->resumbable->tempFolder = 'test/tmp';\n        $this->resumbable->uploadFolder = 'test/uploads';\n        $this->resumbable->deleteTmpFolder = false;\n        $this->resumbable->handleChunk();\n\n        $this->assertFileExists('test/uploads/mock.png');\n        file_exists('test/tmp/identifier/mock.png.0003') && unlink('test/tmp/identifier/mock.png.0003');\n        unlink('test/uploads/mock.png');\n    }\n\n    public function testResumableParamsGetRequest()\n    {\n        $resumableParams = array(\n            'resumableChunkNumber'=> 1,\n            'resumableTotalChunks'=> 100,\n            'resumableChunkSize'=>  1000,\n            'resumableIdentifier'=> 100,\n            'resumableFilename'=> 'mock_file_name',\n            'resumableRelativePath'=> 'upload',\n        );\n\n        $this->request = $this->getMockBuilder('Dilab\\Network\\SimpleRequest')\n            ->getMock();\n\n        $this->request->method('is')\n            ->willReturn(true);\n\n        $this->request->method('data')->willReturn($resumableParams);\n\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->assertEquals($resumableParams, $this->resumbable->resumableParams());\n    }\n\n    public static function isFileUploadCompleteProvider()\n    {\n        return [\n            ['mock.png', 'files', 1, true],// test/files/0001-0003 exist\n            ['mock.png', 'files', 2, true],// test/files/0001-0003 exist\n            ['mock.png', 'files', 3, true],// test/files/0001-0003 exist\n            ['mock.png', 'files', 4, false],// no 0004 chunk\n            ['mock.png', 'files', 5, false],// no 0004-0005 chunks\n            ['mock.png', 'files', 15, false],// no 0004-00015 chunks\n        ];\n    }\n\n    /**\n     *\n     * @dataProvider isFileUploadCompleteProvider\n     */\n    public function testIsFileUploadComplete($filename,$identifier, $totalChunks, $expected)\n    {\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->tempFolder ='test';\n        $this->assertEquals($expected, $this->resumbable->isFileUploadComplete($filename, $identifier, $totalChunks));\n    }\n\n    public function testIsChunkUploaded()\n    {\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->tempFolder ='test';\n        $identifier = 'files';\n        $filename = 'mock.png';\n        $this->assertTrue($this->resumbable->isChunkUploaded($identifier,$filename,1));\n        $this->assertFalse($this->resumbable->isChunkUploaded($identifier,$filename,10));\n    }\n\n    public function testTmpChunkDir()\n    {\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->tempFolder ='test';\n        $identifier = 'mock-identifier';\n        $expected = $this->resumbable->tempFolder.DIRECTORY_SEPARATOR.$identifier;\n        $this->assertEquals($expected, $this->resumbable->tmpChunkDir($identifier));\n        $this->assertFileExists($expected);\n        rmdir($expected);\n    }\n\n    public function testTmpChunkFile()\n    {\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $filename = 'mock-file.png';\n        $chunkNumber = str_pad(1, 4, 0, STR_PAD_LEFT);\n        $expected = $filename.'.'.$chunkNumber;\n        $this->assertEquals($expected, $this->resumbable->tmpChunkFilename($filename,$chunkNumber));\n    }\n\n    public static function fileNameProvider(): array\n    {\n        return [\n            ['example-file.png', 'example-file.png'],\n            ['../unsafe-one-level.txt', 'unsafe-one-level.txt'],\n        ];\n    }\n\n    /**\n     * @dataProvider fileNameProvider\n     */\n    public function testResumableSanitizeFileName(string $filename, string $filenameSanitized): void\n    {\n        $resumableParams = array(\n            'resumableChunkNumber'=> 1,\n            'resumableTotalChunks'=> 1,\n            'resumableChunkSize'=>  200,\n            'resumableIdentifier'=> 'identifier',\n            'resumableFilename'=> $filename,\n            'resumableRelativePath'=> 'upload',\n        );\n\n\n        $this->request->method('is')\n            ->willReturn(true);\n\n        $this->request->method('data')\n                ->willReturn($resumableParams);\n\n        $this->request->method('file')\n                ->willReturn(array(\n                    'name'=> 'mock.png',\n                    'tmp_name'=>  'test/files/mock.png.0003',\n                    'error'=> 0,\n                    'size'=> 27000,\n                ));\n\n        $this->resumbable = new Resumable($this->request, $this->response);\n        $this->resumbable->tempFolder = 'test/tmp';\n        $this->resumbable->uploadFolder = 'test/uploads';\n        $this->resumbable->deleteTmpFolder = false;\n        $this->resumbable->handleChunk();\n\n        $this->assertFileExists('test/uploads/' . $filenameSanitized);\n        $this->assertFileExists('test/tmp/identifier/' . $filenameSanitized . '.0001');\n        $this->assertTrue(unlink('test/tmp/identifier/' . $filenameSanitized . '.0001'));\n        $this->assertTrue(unlink('test/uploads/' . $filenameSanitized));\n    }\n\n    public function testCreateFileFromChunks()\n    {\n        $files = array(\n            'test/files/mock.png.0001',\n            'test/files/mock.png.0002',\n            'test/files/mock.png.0003',\n        );\n        $totalFileSize = array_sum(array(\n            filesize('test/files/mock.png.0001'),\n            filesize('test/files/mock.png.0002'),\n            filesize('test/files/mock.png.0003')\n        ));\n        $destFile = 'test/files/5.png';\n\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->createFileFromChunks($files, $destFile);\n        $this->assertFileExists($destFile);\n        $this->assertEquals($totalFileSize, filesize($destFile));\n        unlink('test/files/5.png');\n    }\n\n    public function testMoveUploadedFile()\n    {\n        $destFile = 'test/files/4.png';\n        $this->resumbable = new Resumable($this->request,$this->response);\n        $this->resumbable->moveUploadedFile('test/files/mock.png.0001', $destFile);\n        $this->assertFileExists($destFile);\n        unlink($destFile);\n    }\n}\n"], "filenames": ["composer.json", "src/Resumable.php", "test/src/ResumableTest.php"], "buggy_code_start_loc": [13, 10, 237], "buggy_code_end_loc": [14, 322, 237], "fixing_code_start_loc": [13, 11, 238], "fixing_code_end_loc": [15, 319, 287], "type": "CWE-434", "message": "resumable.php (aka PHP backend for resumable.js) 0.1.4 before 3c6dbf5 allows arbitrary file upload anywhere in the filesystem via ../ in multipart/form-data content to upload.php. (File overwrite hasn't been possible with the code available in GitHub in recent years, however.)", "other": {"cve": {"id": "CVE-2023-52086", "sourceIdentifier": "cve@mitre.org", "published": "2023-12-26T18:15:09.030", "lastModified": "2024-01-04T03:09:10.993", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "resumable.php (aka PHP backend for resumable.js) 0.1.4 before 3c6dbf5 allows arbitrary file upload anywhere in the filesystem via ../ in multipart/form-data content to upload.php. (File overwrite hasn't been possible with the code available in GitHub in recent years, however.)"}, {"lang": "es", "value": "resumable.php (tambi\u00e9n conocido como backend PHP para resumable.js) 0.1.4 anterior a 3c6dbf5 permite la carga de archivos arbitrarios en cualquier parte del sistema de archivos a trav\u00e9s de ../ en multipart/form-data content to upload.php. (Sin embargo, la sobrescritura de archivos no ha sido posible con el c\u00f3digo disponible en GitHub en los \u00faltimos a\u00f1os)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:startutorial:php_backend_for_resumable.js:0.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "61A220BB-610D-4B95-AEC7-B4BE6197A87E"}]}]}], "references": [{"url": "https://github.com/dilab/resumable.php/commit/3c6dbf5170b01cbb712013c7d0a83f5aac45653b", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/dilab/resumable.php/issues/34", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/dilab/resumable.php/pull/27/commits/3e3c94d0302bb399a7611b4738a5a4dd0832a926", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/dilab/resumable.php/pull/39/commits/408f54dff10e48befa44d417933787232a64304b", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/dilab/resumable.php/pull/39/commits/d3552efd403e2d87407934477eee642836cab3b4", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/dilab/resumable.php/commit/3c6dbf5170b01cbb712013c7d0a83f5aac45653b"}}