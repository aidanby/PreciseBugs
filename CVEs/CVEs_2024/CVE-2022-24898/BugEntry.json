{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.Objects;\nimport java.util.regex.Pattern;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXResult;\nimport javax.xml.transform.sax.SAXSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.bootstrap.DOMImplementationRegistry;\nimport org.w3c.dom.ls.DOMImplementationLS;\nimport org.w3c.dom.ls.LSInput;\nimport org.w3c.dom.ls.LSOutput;\nimport org.w3c.dom.ls.LSParser;\nimport org.w3c.dom.ls.LSSerializer;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xwiki.stability.Unstable;\n\n/**\n * XML Utility methods.\n *\n * @version $Id$\n * @since 1.6M1\n */\npublic final class XMLUtils\n{\n    /** Logging helper object. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(XMLUtils.class);\n\n    /** XML encoding of the \"ampersand\" character. */\n    private static final String AMP = \"&#38;\";\n\n    /** Regular expression recognizing XML-escaped \"ampersand\" characters. */\n    private static final Pattern AMP_PATTERN = Pattern.compile(\"&(?:amp|#0*+38|#x0*+26);\");\n\n    /** XML encoding of the \"single quote\" character. */\n    private static final String APOS = \"&#39;\";\n\n    /** Regular expression recognizing XML-escaped \"single quote\" characters. */\n    private static final Pattern APOS_PATTERN = Pattern.compile(\"&(?:apos|#0*+39|#x0*+27);\");\n\n    /** XML encoding of the \"double quote\" character. */\n    private static final String QUOT = \"&#34;\";\n\n    /** Regular expression recognizing XML-escaped \"double quote\" characters. */\n    private static final Pattern QUOT_PATTERN = Pattern.compile(\"&(?:quot|#0*+34|#x0*+22);\");\n\n    /** XML encoding of the \"left curly bracket\". */\n    private static final String LCURL = \"&#123;\";\n\n    /** Regular expression recognizing XML-escaped \"left curly bracket\" characters. */\n    private static final Pattern LCURL_PATTERN = Pattern.compile(\"&(?:#0*+123|#x0*+7[bB]);\");\n\n    /** XML encoding of the \"less than\" character. */\n    private static final String LT = \"&#60;\";\n\n    /** Regular expression recognizing XML-escaped \"less than\" characters. */\n    private static final Pattern LT_PATTERN = Pattern.compile(\"&(?:lt|#0*+60|#x0*+3[cC]);\");\n\n    /** XML encoding of the \"greater than\" character. */\n    private static final String GT = \"&#62;\";\n\n    /** Regular expression recognizing XML-escaped \"greater than\" characters. */\n    private static final Pattern GT_PATTERN = Pattern.compile(\"&(?:gt|#0*+62|#x0*+3[eE]);\");\n\n    private static final char[] ELEMENT_SYNTAX = new char[] {'<', '&'};\n\n    /** Helper object for manipulating DOM Level 3 Load and Save APIs. */\n    private static final DOMImplementationLS LS_IMPL;\n\n    /** Xerces configuration parameter for disabling fetching and checking XMLs against their DTD. */\n    private static final String DISABLE_DTD_PARAM = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n\n    static {\n        DOMImplementationLS implementation = null;\n        try {\n            implementation =\n                (DOMImplementationLS) DOMImplementationRegistry.newInstance().getDOMImplementation(\"LS 3.0\");\n        } catch (Exception ex) {\n            LOGGER.warn(\"Cannot initialize the XML Script Service: [{}]\", ex.getMessage());\n        }\n        LS_IMPL = implementation;\n    }\n\n    /**\n     * Private constructor since this is a utility class that shouldn't be instantiated (all methods are static).\n     */\n    private XMLUtils()\n    {\n        // Nothing to do\n    }\n\n    /**\n     * Extracts a well-formed XML fragment from the given DOM tree.\n     *\n     * @param node the root of the DOM tree where the extraction takes place\n     * @param start the index of the first character\n     * @param length the maximum number of characters in text nodes to include in the returned fragment\n     * @return a well-formed XML fragment starting at the given character index and having up to the specified length,\n     *         summing only the characters in text nodes\n     * @since 1.6M2\n     */\n    public static String extractXML(Node node, int start, int length)\n    {\n        ExtractHandler handler = null;\n        try {\n            handler = new ExtractHandler(start, length);\n            Transformer xformer = TransformerFactory.newInstance().newTransformer();\n            xformer.transform(new DOMSource(node), new SAXResult(handler));\n            return handler.getResult();\n        } catch (Throwable t) {\n            if (handler != null && handler.isFinished()) {\n                return handler.getResult();\n            } else {\n                throw new RuntimeException(\"Failed to extract XML\", t);\n            }\n        }\n    }\n\n    /**\n     * XML comment does not support some characters inside its content but there is no official escaping/unescaping for\n     * it so we made our own.\n     * <ul>\n     *   <li>1) Escape existing \\</li>\n     *   <li>2) Escape --</li>\n     *   <li>3) Add {@code \\} (unescaped as {@code \"\"}) at the end if the last char is {@code -}</li>\n     * </ul>\n     *\n     * @param content the XML comment content to escape\n     * @return the escaped content.\n     * @since 1.9M2\n     */\n    public static String escapeXMLComment(String content)\n    {\n        StringBuffer str = new StringBuffer(content.length());\n\n        char[] buff = content.toCharArray();\n        char lastChar = 0;\n        for (char c : buff) {\n            if (c == '\\\\') {\n                str.append('\\\\');\n            } else if (c == '-' && lastChar == '-') {\n                str.append('\\\\');\n            }\n\n            str.append(c);\n            lastChar = c;\n        }\n\n        if (lastChar == '-') {\n            str.append('\\\\');\n        }\n\n        return str.toString();\n    }\n\n    /**\n     * XML comment does not support some characters inside its content but there is no official escaping/unescaping for\n     * it so we made our own.\n     *\n     * @param content the XML comment content to unescape\n     * @return the unescaped content.\n     * @see #escapeXMLComment(String)\n     * @since 1.9M2\n     */\n    public static String unescapeXMLComment(String content)\n    {\n        StringBuffer str = new StringBuffer(content.length());\n\n        char[] buff = content.toCharArray();\n        boolean escaped = false;\n        for (char c : buff) {\n            if (!escaped && c == '\\\\') {\n                escaped = true;\n                continue;\n            }\n\n            str.append(c);\n            escaped = false;\n        }\n\n        return str.toString();\n    }\n\n    /**\n     * Escapes all the XML special characters and a XWiki Syntax 2.0+ special character (i.e., <code>{</code>, to\n     * protect against <code>{{/html}}</code>) in a {@code String}.\n     * The escaping is done using numerical XML entities to allow the content to be used as an XML attribute value\n     * or as an XML element text.\n     * For instance, {@code <b>{{html}}$x{{/html}}</b>} will be escaped and can thus be put inside an XML attribute.\n     * To illustrate, the value can be used in a div tag\n     * <code>&lt;div&gt;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;\n     * &lt;/div&gt;</code>\n     * or in the attribute of an input tag\n     * <code>&lt;input\n     * value=&quot;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;&quot;\n     * /&gt;</code>.\n     * <p>\n     * Specifically, escapes &lt;, &gt;, \", ', &amp; and {.\n     * <p>\n     * Note that is is preferable to use {@link #escapeAttributeValue(String)} when the content is used as\n     * an XML tag attribute, and {@link #escapeElementText(String)} when the content is used as an XML text.\n     *\n     * @param content the text to escape, may be {@code null}. The content is converted to {@code String} using\n     * {@link Objects#toString(Object, String)}, where the second parameter is {@code null}\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @see #escapeAttributeValue(String)\n     * @see #escapeElementText(String)\n     * @deprecated since 12.8RC1, use {@link #escape(String)} instead\n     */\n    @Deprecated\n    public static String escape(Object content)\n    {\n        return escape(Objects.toString(content, null));\n    }\n\n    /**\n     * Escapes all the XML special characters and a XWiki Syntax 2.0+ special character (i.e., <code>{</code>, to\n     * protect against {{/html}}) in a {@code String}.\n     * The escaping is done using numerical XML entities to allow the content to be used as an XML attribute value\n     * or as an XML element text.\n     * For instance, {@code <b>{{html}}$x{{/html}}</b>} will be escaped and can thus be put inside as XML attribute.\n     * To illustrate, the value can be used in a div tag\n     * <code>&lt;div&gt;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;\n     * &lt;/div&gt;</code>\n     * or in the attribute of an input tag\n     * <code>&lt;input\n     * value=&quot;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;&quot;\n     * /&gt;</code>.\n     * <p>\n     * Specifically, escapes &lt;, &gt;, \", ', &amp; and {.\n     * <p>\n     * Note that is is preferable to use {@link #escapeAttributeValue(String)} when the content is used as\n     * an XML tag attribute, and {@link #escapeElementText(String)} when the content is used as an XML text.\n     *\n     * @param content the text to escape, may be {@code null}\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @see #escapeAttributeValue(String)\n     * @see #escapeElementText(String)\n     * @since 12.8RC1\n     * @since 12.6.3\n     * @since 11.10.11\n     */\n    @Unstable\n    public static String escape(String content)\n    {\n        return escapeAttributeValue(content);\n    }\n\n    /**\n     * Escapes all the XML special characters and a XWiki Syntax 2.0+ special character (i.e., <code>{</code>, to\n     * protect against {{/html}}) in a {@code String}.\n     * The escaping is done using numerical XML entities to allow the content to be used inside XML attributes.\n     * For instance, {@code <b>{{html}}$x{{/html}}</b>} will be escaped and can thus be put inside an XML attribute.\n     * To illustrate, the value can be used in the attribute of an input tag\n     * <code>&lt;input\n     * value=&quot;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;&quot;\n     * /&gt;</code>.\n     * <p>\n     * Specifically, escapes &lt;, &gt;, \", ', &amp; and {.\n     *\n     * @param content the text to escape, may be {@code null}. The content is converted to {@code String} using\n     * {@link String#valueOf(Object)} before escaping.\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @deprecated since 12.8RC1, use {@link #escapeAttributeValue(String)} instead\n     */\n    @Deprecated\n    public static String escapeAttributeValue(Object content)\n    {\n        if (content == null) {\n            return null;\n        }\n        return escapeAttributeValue(String.valueOf(content));\n    }\n\n    /**\n     * Escapes all the XML special characters and a XWiki Syntax 2.0+ special character (i.e., <code>{</code>, to\n     * protect against {{/html}}) in a {@code String}.\n     * The escaping is done using numerical XML entities to allow the content to be used inside XML attributes.\n     * For instance, {@code <b>{{html}}$x{{/html}}</b>} will be escaped and can thus be put inside an XML attribute.\n     * To illustrate, the value can be used in the attribute of an input tag\n     * <code>&lt;input\n     * value=&quot;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;&quot;\n     * /&gt;</code>.\n     * <p>\n     * Specifically, escapes &lt;, &gt;, \", ', &amp; and {.\n     *\n     * @param content the text to escape, may be {@code null}\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @since 12.8RC1\n     * @since 12.6.3\n     * @since 11.10.11\n     */\n    @Unstable\n    public static String escapeAttributeValue(String content)\n    {\n        if (content == null) {\n            return null;\n        }\n        StringBuilder result = new StringBuilder((int) (content.length() * 1.1));\n        int length = content.length();\n        char c;\n        for (int i = 0; i < length; ++i) {\n            c = content.charAt(i);\n            switch (c) {\n                case '&':\n                    result.append(AMP);\n                    break;\n                case '\\'':\n                    result.append(APOS);\n                    break;\n                case '\"':\n                    result.append(QUOT);\n                    break;\n                case '<':\n                    result.append(LT);\n                    break;\n                case '>':\n                    result.append(GT);\n                    break;\n                case '{':\n                    result.append(LCURL);\n                    break;\n                default:\n                    result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Escapes XML special characters in a {@code String} using numerical XML entities, so that the resulting string\n     * can safely be used as an XML element text value.\n     * For instance, {@code Jim & John} will be escaped and can thus be put inside an XML tag, such as the {@code p}\n     * tag, as in {@code <p>Jim &amp; John</p>}.\n     * Specifically, escapes &lt; to {@code &lt;}, and &amp; to {@code &amp;}.\n     *\n     * @param content the text to escape, may be {@code null}.\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @since 12.8RC1\n     * @since 12.6.3\n     * @since 11.10.11\n     */\n    @Unstable\n    public static String escapeElementText(String content)\n    {\n        if (content == null) {\n            return null;\n        }\n        // Initializes a string builder with an initial capacity 1.1 times greater than the initial content to account\n        // for special character substitutions.\n        int contentLength = content.length();\n        StringBuilder result = new StringBuilder((int) (contentLength * 1.1));\n        for (int i = 0; i < contentLength; ++i) {\n            char c = content.charAt(i);\n            switch (c) {\n                case '&':\n                    result.append(AMP);\n                    break;\n                case '<':\n                    result.append(LT);\n                    break;\n                default:\n                    result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Same logic as {@link #escapeElementText(String)} but only indicate if there is something to escape.\n     * \n     * @param content the content to parse\n     * @return true if the passed content contains content that can be interpreted as XML syntax\n     * @see #escapeElementText(String)\n     * @since 12.10\n     * @since 12.6.5\n     */\n    @Unstable\n    public static boolean containsElementText(CharSequence content)\n    {\n        return StringUtils.containsAny(content, ELEMENT_SYNTAX);\n    }\n\n    /**\n     * Escapes the XML special characters in a <code>String</code> using numerical XML entities, so that the resulting\n     * string can safely be used as an XML text node. Specifically, escapes &lt;, &gt;, and &amp;.\n     *\n     * @param content the text to escape, may be {@code null}. The content is converted to {@code String} using\n     * {@link String#valueOf(Object)} before escaping.\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @deprecated since 12.8RC1, use {@link #escapeElementText(String)} instead.\n     */\n    @Deprecated\n    public static String escapeElementContent(Object content)\n    {\n        if (content == null) {\n            return null;\n        }\n        String str = String.valueOf(content);\n        StringBuilder result = new StringBuilder((int) (str.length() * 1.1));\n        int length = str.length();\n        char c;\n        for (int i = 0; i < length; ++i) {\n            c = str.charAt(i);\n            switch (c) {\n                case '&':\n                    result.append(AMP);\n                    break;\n                case '<':\n                    result.append(LT);\n                    break;\n                case '>':\n                    result.append(GT);\n                    break;\n                default:\n                    result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Unescape encoded special XML characters. Only &gt;, &lt; &amp;, \", ' and { are unescaped, since they are the only\n     * ones that affect the resulting markup.\n     *\n     * @param content the text to decode, may be {@code null}. The content is converted to {@code String} using\n     * {@link String#valueOf(Object)} before escaping\n     * @return unescaped content, {@code null} if {@code null} input\n     * @deprecated since 12.8RC1, use {@link org.apache.commons.text.StringEscapeUtils#unescapeXml(String)} instead\n     */\n    @Deprecated\n    public static String unescape(Object content)\n    {\n        if (content == null) {\n            return null;\n        }\n        String str = String.valueOf(content);\n\n        str = APOS_PATTERN.matcher(str).replaceAll(\"'\");\n        str = QUOT_PATTERN.matcher(str).replaceAll(\"\\\"\");\n        str = LT_PATTERN.matcher(str).replaceAll(\"<\");\n        str = GT_PATTERN.matcher(str).replaceAll(\">\");\n        str = AMP_PATTERN.matcher(str).replaceAll(\"&\");\n        str = LCURL_PATTERN.matcher(str).replaceAll(\"{\");\n\n        return str;\n    }\n\n    /**\n     * Construct a new (empty) DOM Document and return it.\n     *\n     * @return an empty DOM Document\n     */\n    public static Document createDOMDocument()\n    {\n        try {\n            return DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n        } catch (ParserConfigurationException ex) {\n            LOGGER.error(\"Cannot create DOM Documents\", ex);\n            return null;\n        }\n    }\n\n    /**\n     * Parse a DOM Document from a source.\n     *\n     * @param source the source input to parse\n     * @return the equivalent DOM Document, or {@code null} if the parsing failed.\n     */\n    public static Document parse(LSInput source)\n    {\n        try {\n            LSParser p = LS_IMPL.createLSParser(DOMImplementationLS.MODE_SYNCHRONOUS, null);\n            // Disable validation, since this takes a lot of time and causes unneeded network traffic\n            p.getDomConfig().setParameter(\"validate\", false);\n            if (p.getDomConfig().canSetParameter(DISABLE_DTD_PARAM, false)) {\n                p.getDomConfig().setParameter(DISABLE_DTD_PARAM, false);\n            }\n            return p.parse(source);\n        } catch (Exception ex) {\n            LOGGER.warn(\"Cannot parse XML document: [{}]\", ex.getMessage());\n            return null;\n        }\n    }\n\n    /**\n     * Serialize a DOM Node into a string, including the XML declaration at the start.\n     *\n     * @param node the node to export\n     * @return the serialized node, or an empty string if the serialization fails\n     */\n    public static String serialize(Node node)\n    {\n        return serialize(node, true);\n    }\n\n    /**\n     * Serialize a DOM Node into a string, with an optional XML declaration at the start.\n     *\n     * @param node the node to export\n     * @param withXmlDeclaration whether to output the XML declaration or not\n     * @return the serialized node, or an empty string if the serialization fails or the node is {@code null}\n     */\n    public static String serialize(Node node, boolean withXmlDeclaration)\n    {\n        if (node == null) {\n            return \"\";\n        }\n        try {\n            LSOutput output = LS_IMPL.createLSOutput();\n            StringWriter result = new StringWriter();\n            output.setCharacterStream(result);\n            LSSerializer serializer = LS_IMPL.createLSSerializer();\n            serializer.getDomConfig().setParameter(\"xml-declaration\", withXmlDeclaration);\n            serializer.setNewLine(\"\\n\");\n            String encoding = \"UTF-8\";\n            if (node instanceof Document) {\n                encoding = ((Document) node).getXmlEncoding();\n            } else if (node.getOwnerDocument() != null) {\n                encoding = node.getOwnerDocument().getXmlEncoding();\n            }\n            output.setEncoding(encoding);\n            serializer.write(node, output);\n            return result.toString();\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to serialize node to XML String: [{}]\", ex.getMessage());\n            return \"\";\n        }\n    }\n\n    /**\n     * Apply an XSLT transformation to a Document.\n     *\n     * @param xml the document to transform\n     * @param xslt the stylesheet to apply\n     * @return the transformation result, or {@code null} if an error occurs or {@code null} xml or xslt input\n     */\n    public static String transform(Source xml, Source xslt)\n    {\n        if (xml != null && xslt != null) {\n            try {\n                StringWriter output = new StringWriter();\n                Result result = new StreamResult(output);\n                javax.xml.transform.TransformerFactory.newInstance().newTransformer(xslt).transform(xml, result);\n                return output.toString();\n            } catch (Exception ex) {\n                LOGGER.warn(\"Failed to apply XSLT transformation: [{}]\", ex.getMessage());\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Parse and pretty print a XML content.\n     *\n     * @param content the XML content to format\n     * @return the formated version of the passed XML content\n     * @throws TransformerFactoryConfigurationError when failing to create a\n     *             {@link TransformerFactoryConfigurationError}\n     * @throws TransformerException when failing to transform the content\n     * @since 5.2M1\n     */\n    public static String formatXMLContent(String content) throws TransformerFactoryConfigurationError,\n        TransformerException\n    {\n        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n\n        StreamResult result = new StreamResult(new StringWriter());\n\n        // Use a SAX Source instead of a StreamSource so that we can control the XMLReader used and set up one that\n        // doesn't resolve entities (and thus doesn't go out on the internet to fetch DTDs!).\n        SAXSource source = new SAXSource(new InputSource(new StringReader(content)));\n        try {\n            XMLReader reader = org.xml.sax.helpers.XMLReaderFactory.createXMLReader();\n            reader.setEntityResolver(new org.xml.sax.EntityResolver() {\n                @Override\n                public InputSource resolveEntity(String publicId, String systemId)\n                    throws SAXException, IOException\n                {\n                    // Return an empty resolved entity. Note that we don't return null since this would tell the reader\n                    // to go on the internet to fetch the DTD.\n                    return new InputSource(new StringReader(\"\"));\n                }\n            });\n            source.setXMLReader(reader);\n        } catch (Exception e) {\n            throw new TransformerException(String.format(\n                \"Failed to create XML Reader while pretty-printing content [%s]\", content), e);\n        }\n\n        transformer.transform(source, result);\n\n        return result.getWriter().toString();\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml;\n\nimport org.apache.html.dom.HTMLDocumentImpl;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.html.HTMLElement;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit tests for {@link XMLUtils}.\n *\n * @version $Id$\n * @since 1.6M1\n */\npublic class XMLUtilsTest\n{\n    @Test\n    void escapeXMLComment()\n    {\n        assertEquals(\"-\\\\- \", XMLUtils.escapeXMLComment(\"-- \"));\n        assertEquals(\"\\\\\\\\\", XMLUtils.escapeXMLComment(\"\\\\\"));\n        assertEquals(\"-\\\\\", XMLUtils.escapeXMLComment(\"-\"));\n        assertEquals(\"-\\\\-\\\\-\\\\\", XMLUtils.escapeXMLComment(\"---\"));\n        assertEquals(\"- \", XMLUtils.escapeXMLComment(\"- \"));\n    }\n\n    @Test\n    void unescapeXMLComment()\n    {\n        assertEquals(\"\", XMLUtils.unescapeXMLComment(\"\\\\\"));\n        assertEquals(\"\\\\\", XMLUtils.unescapeXMLComment(\"\\\\\\\\\"));\n        assertEquals(\"--\", XMLUtils.unescapeXMLComment(\"\\\\-\\\\-\"));\n        assertEquals(\"--\", XMLUtils.unescapeXMLComment(\"\\\\-\\\\-\\\\\"));\n    }\n\n    @Test\n    void escape()\n    {\n        String escapedText = XMLUtils.escape(\"a < a' && a' < a\\\" => a < a\\\"\");\n\n        assertFalse(escapedText.contains(\"<\"), \"Failed to escape <\");\n        assertFalse(escapedText.contains(\">\"), \"Failed to escape >\");\n        assertFalse(escapedText.contains(\"'\"), \"Failed to escape '\");\n        assertFalse(escapedText.contains(\"\\\"\"), \"Failed to escape \\\"\");\n        assertFalse(escapedText.contains(\"&&\"), \"Failed to escape &\");\n    }\n\n    @Test\n    void escapeObjectContent()\n    {\n        String content = \"a < a' && a' < a\\\" => a < a\\\"\";\n        StringBuilder sb = new StringBuilder();\n        sb.append(content);\n\n        String expected = XMLUtils.escape(content);\n        String actual = XMLUtils.escape(sb);\n\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void escapeElementText()\n    {\n        String actual = XMLUtils.escapeElementText(\"a < a' && a' < a\\\" => a < a\\\"\");\n        assertEquals(\"a &#60; a' &#38;&#38; a' &#60; a\\\" => a &#60; a\\\"\", actual);\n    }\n\n    @Test\n    void escapeElementTextNull()\n    {\n        assertNull(XMLUtils.escapeElementText(null));\n    }\n\n    @Test\n    void escapeApos()\n    {\n        assertNotEquals(\"&apos;\", XMLUtils.escape(\"'\"), \"' wrongly escaped to non-HTML &apos;\");\n    }\n\n    @Test\n    void escapeEmptyString()\n    {\n        assertEquals(\"\", XMLUtils.escape(\"\"), \"\\\"\\\" should be \\\"\\\"\");\n    }\n\n    @Test\n    void escapeWithNull()\n    {\n        assertNull(XMLUtils.escape(null), \"null should be null\");\n    }\n\n    @Test\n    void escapeNonAscii()\n    {\n        assertEquals(\"\\u0123\", XMLUtils.escape(\"\\u0123\"), \"Non-ASCII characters were escaped\");\n    }\n\n    @Test\n    void escapeAttributeValue()\n    {\n        String escapedText = XMLUtils.escapeAttributeValue(\"a < a' && a' < a\\\" => a < a\\\" {\");\n\n        assertFalse(escapedText.contains(\"<\"), \"Failed to escape <\");\n        assertFalse(escapedText.contains(\">\"), \"Failed to escape >\");\n        assertFalse(escapedText.contains(\"'\"), \"Failed to escape '\");\n        assertFalse(escapedText.contains(\"\\\"\"), \"Failed to escape \\\"\");\n        assertFalse(escapedText.contains(\"&&\"), \"Failed to escape &\");\n        assertFalse(escapedText.contains(\"{\"), \"Failed to escape {\");\n    }\n\n    @Test\n    void escapeAttributeValueContentNull()\n    {\n        StringBuilder sb = null;\n        assertNull(XMLUtils.escapeAttributeValue(sb));\n    }\n\n    @Test\n    void escapeAttributeValueApos()\n    {\n        assertNotEquals(\"&apos;\", XMLUtils.escapeAttributeValue(\"'\"), \"' wrongly escaped to non-HTML &apos;\");\n    }\n\n    @Test\n    void escapeFAttributeValueEmptyString()\n    {\n        assertEquals(\"\", XMLUtils.escapeAttributeValue(\"\"), \"\\\"\\\" should be \\\"\\\"\");\n    }\n\n    @Test\n    void escapeFAttributeValueWithNull()\n    {\n        assertNull(XMLUtils.escapeAttributeValue(null), \"null should be null\");\n    }\n\n    @Test\n    void escapeAttributeValueNonAscii()\n    {\n        assertEquals(\"\\u0123\", XMLUtils.escapeAttributeValue(\"\\u0123\"), \"Non-ASCII characters were escaped\");\n    }\n\n    @Test\n    void escapeElementContent()\n    {\n        String escapedText = XMLUtils.escapeElementContent(\"a < a' && a' < a\\\" => a < a\\\"\");\n\n        assertFalse(escapedText.contains(\"<\"), \"Failed to escape <\");\n        assertFalse(escapedText.contains(\">\"), \"Failed to escape >\");\n        assertTrue(escapedText.contains(\"'\"), \"Wrongfully escaped '\");\n        assertTrue(escapedText.contains(\"\\\"\"), \"Wrongfully escaped \\\"\");\n        assertFalse(escapedText.contains(\"&&\"), \"Failed to escape &\");\n    }\n\n    @Test\n    void escapeElementContentObjectContent()\n    {\n        String expected = XMLUtils.escapeElementContent(\"a < a' && a' < a\\\" => a < a\\\"\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"a < a' && a' < a\\\" => a < a\\\"\");\n        String actual = XMLUtils.escapeElementContent(content);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void escapeElementContentContentNull()\n    {\n        StringBuilder content = null;\n        assertNull(XMLUtils.escapeElementContent(content));\n    }\n\n    @Test\n    void escapeElementContentEmptyString()\n    {\n        assertEquals(\"\", XMLUtils.escapeElementContent(\"\"), \"\\\"\\\" should be \\\"\\\"\");\n    }\n\n    @Test\n    void escapeElementContentWithNull()\n    {\n        assertNull(XMLUtils.escapeElementContent(null), \"null should be null\");\n    }\n\n    @Test\n    void escapeElementContentNonAscii()\n    {\n        assertEquals(\"\\u0123\", XMLUtils.escapeElementContent(\"\\u0123\"), \"Non-ASCII characters were escaped\");\n    }\n\n    @Test\n    void unescape()\n    {\n        assertEquals(\"&'\\\"<>\", XMLUtils.unescape(\"&amp;&apos;&quot;&lt;&gt;\"), \"Failed to unescaped named entities\");\n        assertEquals(\"&'\\\"<>\", XMLUtils.unescape(\"&#38;&#39;&#34;&#60;&#62;\"), \"Failed to unescaped decimal entities\");\n        assertEquals(\"&'\\\"<>\", XMLUtils.unescape(\"&#038;&#0039;&#00034;&#000060;&#0000062;\"),\n            \"Failed to unescaped decimal entities with leading zeros\");\n        assertEquals(\"&'\\\"<<>>\", XMLUtils.unescape(\"&#x26;&#x27;&#x22;&#x3c;&#x3C;&#x3e;&#x3E;\"),\n            \"Failed to unescaped hexadecimal entities\");\n        assertEquals(\"&'\\\"<<>>\", XMLUtils.unescape(\"&#x026;&#x0027;&#x00022;&#x00003c;&#x0003C;&#x003e;&#x03E;\"),\n            \"Failed to unescaped hexadecimal entities with leading zeros\");\n    }\n\n    @Test\n    void unescapeObjectContent()\n    {\n        StringBuilder content = new StringBuilder();\n        content.append(\"&amp;&apos;&quot;&lt;&gt;\");\n        assertEquals(\"&'\\\"<>\", XMLUtils.unescape(content));\n    }\n\n    @Test\n    void unescapeNullContent()\n    {\n        StringBuilder content = null;\n        assertNull(XMLUtils.unescape(content));\n    }\n\n    @Test\n    void unescapeEmptyString()\n    {\n        assertEquals(\"\", XMLUtils.unescape(\"\"), \"\\\"\\\" should be \\\"\\\"\");\n    }\n\n    @Test\n    void unescapeWithNull()\n    {\n        assertNull(XMLUtils.unescape(null), \"null should be null\");\n    }\n\n    @Test\n    void unescapeOtherEscapes()\n    {\n        assertEquals(\"&deg;\", XMLUtils.unescape(\"&deg;\"), \"Extra named entities were unescaped\");\n        assertEquals(\"&#65;\", XMLUtils.unescape(\"&#65;\"), \"Extra decimal entities were unescaped\");\n        assertEquals(\"&#x5;\", XMLUtils.unescape(\"&#x5;\"), \"Extra hexadecimal entities were unescaped\");\n    }\n\n    @Test\n    void createDomDocument()\n    {\n        // Nothing much that we can test here...\n        assertNotNull(XMLUtils.createDOMDocument());\n    }\n\n    @Test\n    void serializeNode()\n    {\n        HTMLDocumentImpl node = new HTMLDocumentImpl();\n        String serialize = XMLUtils.serialize(node, false);\n        assertEquals(\"\", serialize);\n\n        Element body = node.createElement(\"body\");\n        node.setBody((HTMLElement) body);\n        body.setAttribute(\"class\", \"toto\");\n        serialize = XMLUtils.serialize(node, false);\n        assertEquals(\"<HTML><HEAD/><BODY class=\\\"toto\\\"/></HTML>\", serialize);\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.Objects;\nimport java.util.regex.Pattern;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXResult;\nimport javax.xml.transform.sax.SAXSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.bootstrap.DOMImplementationRegistry;\nimport org.w3c.dom.ls.DOMImplementationLS;\nimport org.w3c.dom.ls.LSInput;\nimport org.w3c.dom.ls.LSOutput;\nimport org.w3c.dom.ls.LSParser;\nimport org.w3c.dom.ls.LSSerializer;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xwiki.stability.Unstable;\n\n/**\n * XML Utility methods.\n *\n * @version $Id$\n * @since 1.6M1\n */\npublic final class XMLUtils\n{\n    /** Logging helper object. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(XMLUtils.class);\n\n    /** XML encoding of the \"ampersand\" character. */\n    private static final String AMP = \"&#38;\";\n\n    /** Regular expression recognizing XML-escaped \"ampersand\" characters. */\n    private static final Pattern AMP_PATTERN = Pattern.compile(\"&(?:amp|#0*+38|#x0*+26);\");\n\n    /** XML encoding of the \"single quote\" character. */\n    private static final String APOS = \"&#39;\";\n\n    /** Regular expression recognizing XML-escaped \"single quote\" characters. */\n    private static final Pattern APOS_PATTERN = Pattern.compile(\"&(?:apos|#0*+39|#x0*+27);\");\n\n    /** XML encoding of the \"double quote\" character. */\n    private static final String QUOT = \"&#34;\";\n\n    /** Regular expression recognizing XML-escaped \"double quote\" characters. */\n    private static final Pattern QUOT_PATTERN = Pattern.compile(\"&(?:quot|#0*+34|#x0*+22);\");\n\n    /** XML encoding of the \"left curly bracket\". */\n    private static final String LCURL = \"&#123;\";\n\n    /** Regular expression recognizing XML-escaped \"left curly bracket\" characters. */\n    private static final Pattern LCURL_PATTERN = Pattern.compile(\"&(?:#0*+123|#x0*+7[bB]);\");\n\n    /** XML encoding of the \"less than\" character. */\n    private static final String LT = \"&#60;\";\n\n    /** Regular expression recognizing XML-escaped \"less than\" characters. */\n    private static final Pattern LT_PATTERN = Pattern.compile(\"&(?:lt|#0*+60|#x0*+3[cC]);\");\n\n    /** XML encoding of the \"greater than\" character. */\n    private static final String GT = \"&#62;\";\n\n    /** Regular expression recognizing XML-escaped \"greater than\" characters. */\n    private static final Pattern GT_PATTERN = Pattern.compile(\"&(?:gt|#0*+62|#x0*+3[eE]);\");\n\n    private static final char[] ELEMENT_SYNTAX = new char[] {'<', '&'};\n\n    /** Helper object for manipulating DOM Level 3 Load and Save APIs. */\n    private static final DOMImplementationLS LS_IMPL;\n\n    /** Xerces configuration parameter for disabling fetching and checking XMLs against their DTD. */\n    private static final String DISABLE_DTD_PARAM = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n\n    /** Xerces configuration parameter for prevent DOCTYPE definition. */\n    private static final String DISABLE_EXTERNAL_DOCTYPE_DECLARATION =\n        \"http://apache.org/xml/features/disallow-doctype-decl\";\n\n    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n    private static final String DISABLE_EXTERNAL_PARAMETER_ENTITIES =\n        \"http://xml.org/sax/features/external-parameter-entities\";\n\n    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n    private static final String DISABLE_EXTERNAL_GENERAL_ENTITIES =\n        \"http://xml.org/sax/features/external-general-entities\";\n\n    static {\n        DOMImplementationLS implementation = null;\n        try {\n            implementation =\n                (DOMImplementationLS) DOMImplementationRegistry.newInstance().getDOMImplementation(\"LS 3.0\");\n        } catch (Exception ex) {\n            LOGGER.warn(\"Cannot initialize the XML Script Service: [{}]\", ex.getMessage());\n        }\n        LS_IMPL = implementation;\n    }\n\n    /**\n     * Private constructor since this is a utility class that shouldn't be instantiated (all methods are static).\n     */\n    private XMLUtils()\n    {\n        // Nothing to do\n    }\n\n    /**\n     * Extracts a well-formed XML fragment from the given DOM tree.\n     *\n     * @param node the root of the DOM tree where the extraction takes place\n     * @param start the index of the first character\n     * @param length the maximum number of characters in text nodes to include in the returned fragment\n     * @return a well-formed XML fragment starting at the given character index and having up to the specified length,\n     *         summing only the characters in text nodes\n     * @since 1.6M2\n     */\n    public static String extractXML(Node node, int start, int length)\n    {\n        ExtractHandler handler = null;\n        try {\n            handler = new ExtractHandler(start, length);\n            Transformer xformer = TransformerFactory.newInstance().newTransformer();\n            xformer.transform(new DOMSource(node), new SAXResult(handler));\n            return handler.getResult();\n        } catch (Throwable t) {\n            if (handler != null && handler.isFinished()) {\n                return handler.getResult();\n            } else {\n                throw new RuntimeException(\"Failed to extract XML\", t);\n            }\n        }\n    }\n\n    /**\n     * XML comment does not support some characters inside its content but there is no official escaping/unescaping for\n     * it so we made our own.\n     * <ul>\n     *   <li>1) Escape existing \\</li>\n     *   <li>2) Escape --</li>\n     *   <li>3) Add {@code \\} (unescaped as {@code \"\"}) at the end if the last char is {@code -}</li>\n     * </ul>\n     *\n     * @param content the XML comment content to escape\n     * @return the escaped content.\n     * @since 1.9M2\n     */\n    public static String escapeXMLComment(String content)\n    {\n        StringBuffer str = new StringBuffer(content.length());\n\n        char[] buff = content.toCharArray();\n        char lastChar = 0;\n        for (char c : buff) {\n            if (c == '\\\\') {\n                str.append('\\\\');\n            } else if (c == '-' && lastChar == '-') {\n                str.append('\\\\');\n            }\n\n            str.append(c);\n            lastChar = c;\n        }\n\n        if (lastChar == '-') {\n            str.append('\\\\');\n        }\n\n        return str.toString();\n    }\n\n    /**\n     * XML comment does not support some characters inside its content but there is no official escaping/unescaping for\n     * it so we made our own.\n     *\n     * @param content the XML comment content to unescape\n     * @return the unescaped content.\n     * @see #escapeXMLComment(String)\n     * @since 1.9M2\n     */\n    public static String unescapeXMLComment(String content)\n    {\n        StringBuffer str = new StringBuffer(content.length());\n\n        char[] buff = content.toCharArray();\n        boolean escaped = false;\n        for (char c : buff) {\n            if (!escaped && c == '\\\\') {\n                escaped = true;\n                continue;\n            }\n\n            str.append(c);\n            escaped = false;\n        }\n\n        return str.toString();\n    }\n\n    /**\n     * Escapes all the XML special characters and a XWiki Syntax 2.0+ special character (i.e., <code>{</code>, to\n     * protect against <code>{{/html}}</code>) in a {@code String}.\n     * The escaping is done using numerical XML entities to allow the content to be used as an XML attribute value\n     * or as an XML element text.\n     * For instance, {@code <b>{{html}}$x{{/html}}</b>} will be escaped and can thus be put inside an XML attribute.\n     * To illustrate, the value can be used in a div tag\n     * <code>&lt;div&gt;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;\n     * &lt;/div&gt;</code>\n     * or in the attribute of an input tag\n     * <code>&lt;input\n     * value=&quot;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;&quot;\n     * /&gt;</code>.\n     * <p>\n     * Specifically, escapes &lt;, &gt;, \", ', &amp; and {.\n     * <p>\n     * Note that is is preferable to use {@link #escapeAttributeValue(String)} when the content is used as\n     * an XML tag attribute, and {@link #escapeElementText(String)} when the content is used as an XML text.\n     *\n     * @param content the text to escape, may be {@code null}. The content is converted to {@code String} using\n     * {@link Objects#toString(Object, String)}, where the second parameter is {@code null}\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @see #escapeAttributeValue(String)\n     * @see #escapeElementText(String)\n     * @deprecated since 12.8RC1, use {@link #escape(String)} instead\n     */\n    @Deprecated\n    public static String escape(Object content)\n    {\n        return escape(Objects.toString(content, null));\n    }\n\n    /**\n     * Escapes all the XML special characters and a XWiki Syntax 2.0+ special character (i.e., <code>{</code>, to\n     * protect against {{/html}}) in a {@code String}.\n     * The escaping is done using numerical XML entities to allow the content to be used as an XML attribute value\n     * or as an XML element text.\n     * For instance, {@code <b>{{html}}$x{{/html}}</b>} will be escaped and can thus be put inside as XML attribute.\n     * To illustrate, the value can be used in a div tag\n     * <code>&lt;div&gt;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;\n     * &lt;/div&gt;</code>\n     * or in the attribute of an input tag\n     * <code>&lt;input\n     * value=&quot;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;&quot;\n     * /&gt;</code>.\n     * <p>\n     * Specifically, escapes &lt;, &gt;, \", ', &amp; and {.\n     * <p>\n     * Note that is is preferable to use {@link #escapeAttributeValue(String)} when the content is used as\n     * an XML tag attribute, and {@link #escapeElementText(String)} when the content is used as an XML text.\n     *\n     * @param content the text to escape, may be {@code null}\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @see #escapeAttributeValue(String)\n     * @see #escapeElementText(String)\n     * @since 12.8RC1\n     * @since 12.6.3\n     * @since 11.10.11\n     */\n    @Unstable\n    public static String escape(String content)\n    {\n        return escapeAttributeValue(content);\n    }\n\n    /**\n     * Escapes all the XML special characters and a XWiki Syntax 2.0+ special character (i.e., <code>{</code>, to\n     * protect against {{/html}}) in a {@code String}.\n     * The escaping is done using numerical XML entities to allow the content to be used inside XML attributes.\n     * For instance, {@code <b>{{html}}$x{{/html}}</b>} will be escaped and can thus be put inside an XML attribute.\n     * To illustrate, the value can be used in the attribute of an input tag\n     * <code>&lt;input\n     * value=&quot;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;&quot;\n     * /&gt;</code>.\n     * <p>\n     * Specifically, escapes &lt;, &gt;, \", ', &amp; and {.\n     *\n     * @param content the text to escape, may be {@code null}. The content is converted to {@code String} using\n     * {@link String#valueOf(Object)} before escaping.\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @deprecated since 12.8RC1, use {@link #escapeAttributeValue(String)} instead\n     */\n    @Deprecated\n    public static String escapeAttributeValue(Object content)\n    {\n        if (content == null) {\n            return null;\n        }\n        return escapeAttributeValue(String.valueOf(content));\n    }\n\n    /**\n     * Escapes all the XML special characters and a XWiki Syntax 2.0+ special character (i.e., <code>{</code>, to\n     * protect against {{/html}}) in a {@code String}.\n     * The escaping is done using numerical XML entities to allow the content to be used inside XML attributes.\n     * For instance, {@code <b>{{html}}$x{{/html}}</b>} will be escaped and can thus be put inside an XML attribute.\n     * To illustrate, the value can be used in the attribute of an input tag\n     * <code>&lt;input\n     * value=&quot;&amp;#60;b&amp;#62;&amp;#123;&amp;#123;html}}$x&amp;#123;&amp;#123;/html}}&amp;#60;/b&amp;#62;&quot;\n     * /&gt;</code>.\n     * <p>\n     * Specifically, escapes &lt;, &gt;, \", ', &amp; and {.\n     *\n     * @param content the text to escape, may be {@code null}\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @since 12.8RC1\n     * @since 12.6.3\n     * @since 11.10.11\n     */\n    @Unstable\n    public static String escapeAttributeValue(String content)\n    {\n        if (content == null) {\n            return null;\n        }\n        StringBuilder result = new StringBuilder((int) (content.length() * 1.1));\n        int length = content.length();\n        char c;\n        for (int i = 0; i < length; ++i) {\n            c = content.charAt(i);\n            switch (c) {\n                case '&':\n                    result.append(AMP);\n                    break;\n                case '\\'':\n                    result.append(APOS);\n                    break;\n                case '\"':\n                    result.append(QUOT);\n                    break;\n                case '<':\n                    result.append(LT);\n                    break;\n                case '>':\n                    result.append(GT);\n                    break;\n                case '{':\n                    result.append(LCURL);\n                    break;\n                default:\n                    result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Escapes XML special characters in a {@code String} using numerical XML entities, so that the resulting string\n     * can safely be used as an XML element text value.\n     * For instance, {@code Jim & John} will be escaped and can thus be put inside an XML tag, such as the {@code p}\n     * tag, as in {@code <p>Jim &amp; John</p>}.\n     * Specifically, escapes &lt; to {@code &lt;}, and &amp; to {@code &amp;}.\n     *\n     * @param content the text to escape, may be {@code null}.\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @since 12.8RC1\n     * @since 12.6.3\n     * @since 11.10.11\n     */\n    @Unstable\n    public static String escapeElementText(String content)\n    {\n        if (content == null) {\n            return null;\n        }\n        // Initializes a string builder with an initial capacity 1.1 times greater than the initial content to account\n        // for special character substitutions.\n        int contentLength = content.length();\n        StringBuilder result = new StringBuilder((int) (contentLength * 1.1));\n        for (int i = 0; i < contentLength; ++i) {\n            char c = content.charAt(i);\n            switch (c) {\n                case '&':\n                    result.append(AMP);\n                    break;\n                case '<':\n                    result.append(LT);\n                    break;\n                default:\n                    result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Same logic as {@link #escapeElementText(String)} but only indicate if there is something to escape.\n     * \n     * @param content the content to parse\n     * @return true if the passed content contains content that can be interpreted as XML syntax\n     * @see #escapeElementText(String)\n     * @since 12.10\n     * @since 12.6.5\n     */\n    @Unstable\n    public static boolean containsElementText(CharSequence content)\n    {\n        return StringUtils.containsAny(content, ELEMENT_SYNTAX);\n    }\n\n    /**\n     * Escapes the XML special characters in a <code>String</code> using numerical XML entities, so that the resulting\n     * string can safely be used as an XML text node. Specifically, escapes &lt;, &gt;, and &amp;.\n     *\n     * @param content the text to escape, may be {@code null}. The content is converted to {@code String} using\n     * {@link String#valueOf(Object)} before escaping.\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @deprecated since 12.8RC1, use {@link #escapeElementText(String)} instead.\n     */\n    @Deprecated\n    public static String escapeElementContent(Object content)\n    {\n        if (content == null) {\n            return null;\n        }\n        String str = String.valueOf(content);\n        StringBuilder result = new StringBuilder((int) (str.length() * 1.1));\n        int length = str.length();\n        char c;\n        for (int i = 0; i < length; ++i) {\n            c = str.charAt(i);\n            switch (c) {\n                case '&':\n                    result.append(AMP);\n                    break;\n                case '<':\n                    result.append(LT);\n                    break;\n                case '>':\n                    result.append(GT);\n                    break;\n                default:\n                    result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Unescape encoded special XML characters. Only &gt;, &lt; &amp;, \", ' and { are unescaped, since they are the only\n     * ones that affect the resulting markup.\n     *\n     * @param content the text to decode, may be {@code null}. The content is converted to {@code String} using\n     * {@link String#valueOf(Object)} before escaping\n     * @return unescaped content, {@code null} if {@code null} input\n     * @deprecated since 12.8RC1, use {@link org.apache.commons.text.StringEscapeUtils#unescapeXml(String)} instead\n     */\n    @Deprecated\n    public static String unescape(Object content)\n    {\n        if (content == null) {\n            return null;\n        }\n        String str = String.valueOf(content);\n\n        str = APOS_PATTERN.matcher(str).replaceAll(\"'\");\n        str = QUOT_PATTERN.matcher(str).replaceAll(\"\\\"\");\n        str = LT_PATTERN.matcher(str).replaceAll(\"<\");\n        str = GT_PATTERN.matcher(str).replaceAll(\">\");\n        str = AMP_PATTERN.matcher(str).replaceAll(\"&\");\n        str = LCURL_PATTERN.matcher(str).replaceAll(\"{\");\n\n        return str;\n    }\n\n    /**\n     * Construct a new (empty) DOM Document and return it.\n     *\n     * @return an empty DOM Document\n     */\n    public static Document createDOMDocument()\n    {\n        try {\n            return DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n        } catch (ParserConfigurationException ex) {\n            LOGGER.error(\"Cannot create DOM Documents\", ex);\n            return null;\n        }\n    }\n\n    /**\n     * Parse a DOM Document from a source.\n     *\n     * @param source the source input to parse\n     * @return the equivalent DOM Document, or {@code null} if the parsing failed.\n     */\n    public static Document parse(LSInput source)\n    {\n        try {\n            LSParser p = LS_IMPL.createLSParser(DOMImplementationLS.MODE_SYNCHRONOUS, null);\n            // Disable validation, since this takes a lot of time and causes unneeded network traffic\n            p.getDomConfig().setParameter(\"validate\", false);\n            if (p.getDomConfig().canSetParameter(DISABLE_DTD_PARAM, false)) {\n                p.getDomConfig().setParameter(DISABLE_DTD_PARAM, false);\n            }\n\n            // Avoid XML eXternal Entity injection (XXE)\n            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false)) {\n                p.getDomConfig().setParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false);\n            }\n            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false)) {\n                p.getDomConfig().setParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false);\n            }\n            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false)) {\n                p.getDomConfig().setParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false);\n            }\n            return p.parse(source);\n        } catch (Exception ex) {\n            LOGGER.warn(\"Cannot parse XML document: [{}]\", ex.getMessage());\n            return null;\n        }\n    }\n\n    /**\n     * Serialize a DOM Node into a string, including the XML declaration at the start.\n     *\n     * @param node the node to export\n     * @return the serialized node, or an empty string if the serialization fails\n     */\n    public static String serialize(Node node)\n    {\n        return serialize(node, true);\n    }\n\n    /**\n     * Serialize a DOM Node into a string, with an optional XML declaration at the start.\n     *\n     * @param node the node to export\n     * @param withXmlDeclaration whether to output the XML declaration or not\n     * @return the serialized node, or an empty string if the serialization fails or the node is {@code null}\n     */\n    public static String serialize(Node node, boolean withXmlDeclaration)\n    {\n        if (node == null) {\n            return \"\";\n        }\n        try {\n            LSOutput output = LS_IMPL.createLSOutput();\n            StringWriter result = new StringWriter();\n            output.setCharacterStream(result);\n            LSSerializer serializer = LS_IMPL.createLSSerializer();\n            serializer.getDomConfig().setParameter(\"xml-declaration\", withXmlDeclaration);\n            serializer.setNewLine(\"\\n\");\n            String encoding = \"UTF-8\";\n            if (node instanceof Document) {\n                encoding = ((Document) node).getXmlEncoding();\n            } else if (node.getOwnerDocument() != null) {\n                encoding = node.getOwnerDocument().getXmlEncoding();\n            }\n            output.setEncoding(encoding);\n            serializer.write(node, output);\n            return result.toString();\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to serialize node to XML String: [{}]\", ex.getMessage());\n            return \"\";\n        }\n    }\n\n    /**\n     * Apply an XSLT transformation to a Document.\n     *\n     * @param xml the document to transform\n     * @param xslt the stylesheet to apply\n     * @return the transformation result, or {@code null} if an error occurs or {@code null} xml or xslt input\n     */\n    public static String transform(Source xml, Source xslt)\n    {\n        if (xml != null && xslt != null) {\n            try {\n                StringWriter output = new StringWriter();\n                Result result = new StreamResult(output);\n                javax.xml.transform.TransformerFactory.newInstance().newTransformer(xslt).transform(xml, result);\n                return output.toString();\n            } catch (Exception ex) {\n                LOGGER.warn(\"Failed to apply XSLT transformation: [{}]\", ex.getMessage());\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Parse and pretty print a XML content.\n     *\n     * @param content the XML content to format\n     * @return the formated version of the passed XML content\n     * @throws TransformerFactoryConfigurationError when failing to create a\n     *             {@link TransformerFactoryConfigurationError}\n     * @throws TransformerException when failing to transform the content\n     * @since 5.2M1\n     */\n    public static String formatXMLContent(String content) throws TransformerFactoryConfigurationError,\n        TransformerException\n    {\n        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n\n        StreamResult result = new StreamResult(new StringWriter());\n\n        // Use a SAX Source instead of a StreamSource so that we can control the XMLReader used and set up one that\n        // doesn't resolve entities (and thus doesn't go out on the internet to fetch DTDs!).\n        SAXSource source = new SAXSource(new InputSource(new StringReader(content)));\n        try {\n            XMLReader reader = org.xml.sax.helpers.XMLReaderFactory.createXMLReader();\n            reader.setEntityResolver(new org.xml.sax.EntityResolver() {\n                @Override\n                public InputSource resolveEntity(String publicId, String systemId)\n                    throws SAXException, IOException\n                {\n                    // Return an empty resolved entity. Note that we don't return null since this would tell the reader\n                    // to go on the internet to fetch the DTD.\n                    return new InputSource(new StringReader(\"\"));\n                }\n            });\n            source.setXMLReader(reader);\n        } catch (Exception e) {\n            throw new TransformerException(String.format(\n                \"Failed to create XML Reader while pretty-printing content [%s]\", content), e);\n        }\n\n        transformer.transform(source, result);\n\n        return result.getWriter().toString();\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.html.dom.HTMLDocumentImpl;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.bootstrap.DOMImplementationRegistry;\nimport org.w3c.dom.html.HTMLElement;\nimport org.w3c.dom.ls.DOMImplementationLS;\nimport org.w3c.dom.ls.LSInput;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit tests for {@link XMLUtils}.\n *\n * @version $Id$\n * @since 1.6M1\n */\npublic class XMLUtilsTest\n{\n    @Test\n    void escapeXMLComment()\n    {\n        assertEquals(\"-\\\\- \", XMLUtils.escapeXMLComment(\"-- \"));\n        assertEquals(\"\\\\\\\\\", XMLUtils.escapeXMLComment(\"\\\\\"));\n        assertEquals(\"-\\\\\", XMLUtils.escapeXMLComment(\"-\"));\n        assertEquals(\"-\\\\-\\\\-\\\\\", XMLUtils.escapeXMLComment(\"---\"));\n        assertEquals(\"- \", XMLUtils.escapeXMLComment(\"- \"));\n    }\n\n    @Test\n    void unescapeXMLComment()\n    {\n        assertEquals(\"\", XMLUtils.unescapeXMLComment(\"\\\\\"));\n        assertEquals(\"\\\\\", XMLUtils.unescapeXMLComment(\"\\\\\\\\\"));\n        assertEquals(\"--\", XMLUtils.unescapeXMLComment(\"\\\\-\\\\-\"));\n        assertEquals(\"--\", XMLUtils.unescapeXMLComment(\"\\\\-\\\\-\\\\\"));\n    }\n\n    @Test\n    void escape()\n    {\n        String escapedText = XMLUtils.escape(\"a < a' && a' < a\\\" => a < a\\\"\");\n\n        assertFalse(escapedText.contains(\"<\"), \"Failed to escape <\");\n        assertFalse(escapedText.contains(\">\"), \"Failed to escape >\");\n        assertFalse(escapedText.contains(\"'\"), \"Failed to escape '\");\n        assertFalse(escapedText.contains(\"\\\"\"), \"Failed to escape \\\"\");\n        assertFalse(escapedText.contains(\"&&\"), \"Failed to escape &\");\n    }\n\n    @Test\n    void escapeObjectContent()\n    {\n        String content = \"a < a' && a' < a\\\" => a < a\\\"\";\n        StringBuilder sb = new StringBuilder();\n        sb.append(content);\n\n        String expected = XMLUtils.escape(content);\n        String actual = XMLUtils.escape(sb);\n\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void escapeElementText()\n    {\n        String actual = XMLUtils.escapeElementText(\"a < a' && a' < a\\\" => a < a\\\"\");\n        assertEquals(\"a &#60; a' &#38;&#38; a' &#60; a\\\" => a &#60; a\\\"\", actual);\n    }\n\n    @Test\n    void escapeElementTextNull()\n    {\n        assertNull(XMLUtils.escapeElementText(null));\n    }\n\n    @Test\n    void escapeApos()\n    {\n        assertNotEquals(\"&apos;\", XMLUtils.escape(\"'\"), \"' wrongly escaped to non-HTML &apos;\");\n    }\n\n    @Test\n    void escapeEmptyString()\n    {\n        assertEquals(\"\", XMLUtils.escape(\"\"), \"\\\"\\\" should be \\\"\\\"\");\n    }\n\n    @Test\n    void escapeWithNull()\n    {\n        assertNull(XMLUtils.escape(null), \"null should be null\");\n    }\n\n    @Test\n    void escapeNonAscii()\n    {\n        assertEquals(\"\\u0123\", XMLUtils.escape(\"\\u0123\"), \"Non-ASCII characters were escaped\");\n    }\n\n    @Test\n    void escapeAttributeValue()\n    {\n        String escapedText = XMLUtils.escapeAttributeValue(\"a < a' && a' < a\\\" => a < a\\\" {\");\n\n        assertFalse(escapedText.contains(\"<\"), \"Failed to escape <\");\n        assertFalse(escapedText.contains(\">\"), \"Failed to escape >\");\n        assertFalse(escapedText.contains(\"'\"), \"Failed to escape '\");\n        assertFalse(escapedText.contains(\"\\\"\"), \"Failed to escape \\\"\");\n        assertFalse(escapedText.contains(\"&&\"), \"Failed to escape &\");\n        assertFalse(escapedText.contains(\"{\"), \"Failed to escape {\");\n    }\n\n    @Test\n    void escapeAttributeValueContentNull()\n    {\n        StringBuilder sb = null;\n        assertNull(XMLUtils.escapeAttributeValue(sb));\n    }\n\n    @Test\n    void escapeAttributeValueApos()\n    {\n        assertNotEquals(\"&apos;\", XMLUtils.escapeAttributeValue(\"'\"), \"' wrongly escaped to non-HTML &apos;\");\n    }\n\n    @Test\n    void escapeFAttributeValueEmptyString()\n    {\n        assertEquals(\"\", XMLUtils.escapeAttributeValue(\"\"), \"\\\"\\\" should be \\\"\\\"\");\n    }\n\n    @Test\n    void escapeFAttributeValueWithNull()\n    {\n        assertNull(XMLUtils.escapeAttributeValue(null), \"null should be null\");\n    }\n\n    @Test\n    void escapeAttributeValueNonAscii()\n    {\n        assertEquals(\"\\u0123\", XMLUtils.escapeAttributeValue(\"\\u0123\"), \"Non-ASCII characters were escaped\");\n    }\n\n    @Test\n    void escapeElementContent()\n    {\n        String escapedText = XMLUtils.escapeElementContent(\"a < a' && a' < a\\\" => a < a\\\"\");\n\n        assertFalse(escapedText.contains(\"<\"), \"Failed to escape <\");\n        assertFalse(escapedText.contains(\">\"), \"Failed to escape >\");\n        assertTrue(escapedText.contains(\"'\"), \"Wrongfully escaped '\");\n        assertTrue(escapedText.contains(\"\\\"\"), \"Wrongfully escaped \\\"\");\n        assertFalse(escapedText.contains(\"&&\"), \"Failed to escape &\");\n    }\n\n    @Test\n    void escapeElementContentObjectContent()\n    {\n        String expected = XMLUtils.escapeElementContent(\"a < a' && a' < a\\\" => a < a\\\"\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"a < a' && a' < a\\\" => a < a\\\"\");\n        String actual = XMLUtils.escapeElementContent(content);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void escapeElementContentContentNull()\n    {\n        StringBuilder content = null;\n        assertNull(XMLUtils.escapeElementContent(content));\n    }\n\n    @Test\n    void escapeElementContentEmptyString()\n    {\n        assertEquals(\"\", XMLUtils.escapeElementContent(\"\"), \"\\\"\\\" should be \\\"\\\"\");\n    }\n\n    @Test\n    void escapeElementContentWithNull()\n    {\n        assertNull(XMLUtils.escapeElementContent(null), \"null should be null\");\n    }\n\n    @Test\n    void escapeElementContentNonAscii()\n    {\n        assertEquals(\"\\u0123\", XMLUtils.escapeElementContent(\"\\u0123\"), \"Non-ASCII characters were escaped\");\n    }\n\n    @Test\n    void unescape()\n    {\n        assertEquals(\"&'\\\"<>\", XMLUtils.unescape(\"&amp;&apos;&quot;&lt;&gt;\"), \"Failed to unescaped named entities\");\n        assertEquals(\"&'\\\"<>\", XMLUtils.unescape(\"&#38;&#39;&#34;&#60;&#62;\"), \"Failed to unescaped decimal entities\");\n        assertEquals(\"&'\\\"<>\", XMLUtils.unescape(\"&#038;&#0039;&#00034;&#000060;&#0000062;\"),\n            \"Failed to unescaped decimal entities with leading zeros\");\n        assertEquals(\"&'\\\"<<>>\", XMLUtils.unescape(\"&#x26;&#x27;&#x22;&#x3c;&#x3C;&#x3e;&#x3E;\"),\n            \"Failed to unescaped hexadecimal entities\");\n        assertEquals(\"&'\\\"<<>>\", XMLUtils.unescape(\"&#x026;&#x0027;&#x00022;&#x00003c;&#x0003C;&#x003e;&#x03E;\"),\n            \"Failed to unescaped hexadecimal entities with leading zeros\");\n    }\n\n    @Test\n    void unescapeObjectContent()\n    {\n        StringBuilder content = new StringBuilder();\n        content.append(\"&amp;&apos;&quot;&lt;&gt;\");\n        assertEquals(\"&'\\\"<>\", XMLUtils.unescape(content));\n    }\n\n    @Test\n    void unescapeNullContent()\n    {\n        StringBuilder content = null;\n        assertNull(XMLUtils.unescape(content));\n    }\n\n    @Test\n    void unescapeEmptyString()\n    {\n        assertEquals(\"\", XMLUtils.unescape(\"\"), \"\\\"\\\" should be \\\"\\\"\");\n    }\n\n    @Test\n    void unescapeWithNull()\n    {\n        assertNull(XMLUtils.unescape(null), \"null should be null\");\n    }\n\n    @Test\n    void unescapeOtherEscapes()\n    {\n        assertEquals(\"&deg;\", XMLUtils.unescape(\"&deg;\"), \"Extra named entities were unescaped\");\n        assertEquals(\"&#65;\", XMLUtils.unescape(\"&#65;\"), \"Extra decimal entities were unescaped\");\n        assertEquals(\"&#x5;\", XMLUtils.unescape(\"&#x5;\"), \"Extra hexadecimal entities were unescaped\");\n    }\n\n    @Test\n    void createDomDocument()\n    {\n        // Nothing much that we can test here...\n        assertNotNull(XMLUtils.createDOMDocument());\n    }\n\n    @Test\n    void serializeNode()\n    {\n        HTMLDocumentImpl node = new HTMLDocumentImpl();\n        String serialize = XMLUtils.serialize(node, false);\n        assertEquals(\"\", serialize);\n\n        Element body = node.createElement(\"body\");\n        node.setBody((HTMLElement) body);\n        body.setAttribute(\"class\", \"toto\");\n        serialize = XMLUtils.serialize(node, false);\n        assertEquals(\"<HTML><HEAD/><BODY class=\\\"toto\\\"/></HTML>\", serialize);\n    }\n\n    @Test\n    void disableExternalEntities()\n        throws ClassNotFoundException, InstantiationException, IllegalAccessException, ClassCastException, IOException\n    {\n        File tempFile = File.createTempFile(\"file\", \".txt\");\n\n        FileUtils.write(tempFile, \"external\", StandardCharsets.UTF_8);\n\n        DOMImplementationLS ls =\n            (DOMImplementationLS) DOMImplementationRegistry.newInstance().getDOMImplementation(\"LS 3.0\");\n        LSInput input = ls.createLSInput();\n        input.setStringData(\"<?xml version='1.0' encoding='UTF-8'?>\" + \"<!DOCTYPE root[<!ENTITY xxe SYSTEM 'file://\"\n            + tempFile.getAbsolutePath() + \"' >]><root>&xxe;</root>\");\n\n        Document result = XMLUtils.parse(input);\n        assertNotEquals(\"external\", result.getDocumentElement().getTextContent());\n    }\n}\n"], "filenames": ["xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/XMLUtils.java", "xwiki-commons-core/xwiki-commons-xml/src/test/java/org/xwiki/xml/XMLUtilsTest.java"], "buggy_code_start_loc": [112, 21], "buggy_code_end_loc": [517, 281], "fixing_code_start_loc": [113, 22], "fixing_code_end_loc": [541, 309], "type": "CWE-611", "message": "org.xwiki.commons:xwiki-commons-xml is a common module used by other XWiki top level projects. Starting in version 2.7 and prior to versions 12.10.10, 13.4.4, and 13.8-rc-1, it is possible for a script to access any file accessing to the user running XWiki application server with XML External Entity Injection through the XML script service. The problem has been patched in versions 12.10.10, 13.4.4, and 13.8-rc-1. There is no easy workaround for fixing this vulnerability other than upgrading and being careful when giving Script rights.", "other": {"cve": {"id": "CVE-2022-24898", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-28T20:15:07.813", "lastModified": "2022-05-10T12:47:21.213", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "org.xwiki.commons:xwiki-commons-xml is a common module used by other XWiki top level projects. Starting in version 2.7 and prior to versions 12.10.10, 13.4.4, and 13.8-rc-1, it is possible for a script to access any file accessing to the user running XWiki application server with XML External Entity Injection through the XML script service. The problem has been patched in versions 12.10.10, 13.4.4, and 13.8-rc-1. There is no easy workaround for fixing this vulnerability other than upgrading and being careful when giving Script rights."}, {"lang": "es", "value": "org.xwiki.commons:xwiki-commons-xml es un m\u00f3dulo com\u00fan usado por otros proyectos de primer nivel de XWiki. A partir de la versi\u00f3n 2.7 y versiones anteriores a 12.10.10, 13.4.4 y 13.8-rc-1, es posible que un script acceda a cualquier archivo que acceda al usuario que ejecuta el servidor de aplicaciones XWiki con XML External Entity Injection mediante el servicio de script XML. El problema ha sido parcheado en versiones 12.10.10, 13.4.4 y 13.8-rc-1. No se presenta una medida de mitigaci\u00f3n f\u00e1cil para arreglar esta vulnerabilidad, aparte de actualizar y tener cuidado cuando son dados derechos de Script"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:commons:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7", "versionEndExcluding": "12.10.10", "matchCriteriaId": "0A4F402B-57B2-40BF-BFC8-D07CEA411260"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:commons:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0", "versionEndExcluding": "13.4.4", "matchCriteriaId": "F86A6141-13AB-4AE8-BF7C-76F7E03A5A1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:commons:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.5", "versionEndExcluding": "13.8", "matchCriteriaId": "CCB47D33-43C0-4469-BCF9-D6518C22CB41"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-commons/commit/947e8921ebd95462d5a7928f397dd1b64f77c7d5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki/xwiki-commons/security/advisories/GHSA-m2r5-4w96-qxg5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-18946", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-commons/commit/947e8921ebd95462d5a7928f397dd1b64f77c7d5"}}